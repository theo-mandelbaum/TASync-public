import { CompressedStreamWriter } from '@syncfusion/ej2-compression';
import { Save } from '@syncfusion/ej2-file-utils';

/**
 * Public Enum to define annotation flag types.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfAnnotation = page.annotations.at(0);
 * // Sets the annotation flag to enable print
 * annotation.flags = PdfAnnotationFlag.print;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAnnotationFlag;
(function (PdfAnnotationFlag) {
    /**
     * Specifies the type of `default`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["default"] = 0] = "default";
    /**
     * Specifies the type of `invisible`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["invisible"] = 1] = "invisible";
    /**
     * Specifies the type of `hidden`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["hidden"] = 2] = "hidden";
    /**
     * Specifies the type of `print`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["print"] = 4] = "print";
    /**
     * Specifies the type of `noZoom`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["noZoom"] = 8] = "noZoom";
    /**
     * Specifies the type of `noRotate`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["noRotate"] = 16] = "noRotate";
    /**
     * Specifies the type of `noView`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["noView"] = 32] = "noView";
    /**
     * Specifies the type of `readOnly`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["readOnly"] = 64] = "readOnly";
    /**
     * Specifies the type of `locked`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["locked"] = 128] = "locked";
    /**
     * Specifies the type of `toggleNoView`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["toggleNoView"] = 256] = "toggleNoView";
})(PdfAnnotationFlag || (PdfAnnotationFlag = {}));
/**
 * Public Enum to define line ending style.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;
 * // Sets the begin line end style as openArrow
 * annotation.beginLineStyle = PdfLineEndingStyle.openArrow;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfLineEndingStyle;
(function (PdfLineEndingStyle) {
    /**
     * Specifies the type of `none`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["none"] = 0] = "none";
    /**
     * Specifies the type of `openArrow`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["openArrow"] = 1] = "openArrow";
    /**
     * Specifies the type of `closedArrow`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["closedArrow"] = 2] = "closedArrow";
    /**
     * Specifies the type of `rOpenArrow`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["rOpenArrow"] = 3] = "rOpenArrow";
    /**
     * Specifies the type of `rClosedArrow`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["rClosedArrow"] = 4] = "rClosedArrow";
    /**
     * Specifies the type of `butt`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["butt"] = 5] = "butt";
    /**
     * Specifies the type of `diamond`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["diamond"] = 6] = "diamond";
    /**
     * Specifies the type of `circle`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["circle"] = 7] = "circle";
    /**
     * Specifies the type of `square`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["square"] = 8] = "square";
    /**
     * Specifies the type of `slash`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["slash"] = 9] = "slash";
})(PdfLineEndingStyle || (PdfLineEndingStyle = {}));
/**
 * Public Enum to define line indent.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
 * // Sets the line intent as lineArrow
 * annotation.lineIntent = PdfLineIntent.lineArrow;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfLineIntent;
(function (PdfLineIntent) {
    /**
     * Specifies the type of `lineArrow`.
     */
    PdfLineIntent[PdfLineIntent["lineArrow"] = 0] = "lineArrow";
    /**
     * Specifies the type of `lineDimension`.
     */
    PdfLineIntent[PdfLineIntent["lineDimension"] = 1] = "lineDimension";
})(PdfLineIntent || (PdfLineIntent = {}));
/**
 * Public Enum to define the types of points and segments in a path.
 *
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access the first page
 * let page: PdfPage = document.getPage(0);
 * // Create a new pen
 * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
 * // Create a new brush
 * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
 * // Add path points
 * let pathPoints: Array<number[]> = [[50, 50], [100, 50], [100, 100], [50, 100], [50, 50]];
 * // Add path types
 * let pathTypes: PathPointType[] = [0, 1, 1, 1, 1];
 * // Create a new PDF path
 * let path: PdfPath = new PdfPath(pathPoints, pathTypes);
 * // Draw the path to the PDF page
 * page.graphics.drawPath(path, pen, brush);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PathPointType;
(function (PathPointType) {
    /**
     * The starting point of a path.
     */
    PathPointType[PathPointType["start"] = 0] = "start";
    /**
     * A straight line segment.
     */
    PathPointType[PathPointType["line"] = 1] = "line";
    /**
     * A Bezier curve segment.
     */
    PathPointType[PathPointType["bezier"] = 3] = "bezier";
    /**
     * A mask for extracting the type of a point.
     */
    PathPointType[PathPointType["pathTypeMask"] = 7] = "pathTypeMask";
    /**
     * Indicates that the segment has dashed line style.
     */
    PathPointType[PathPointType["dashMode"] = 16] = "dashMode";
    /**
     * Indicates a marker point in the path.
     */
    PathPointType[PathPointType["pathMarker"] = 32] = "pathMarker";
    /**
     * Closes the current path.
     */
    PathPointType[PathPointType["closePath"] = 128] = "closePath";
})(PathPointType || (PathPointType = {}));
/**
 * Public Enum to define line caption type.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfAnnotation = page.annotations.at(0);
 * // Sets the line caption type as inline
 * annotation.caption.type = PdfLineCaptionType.inline;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfLineCaptionType;
(function (PdfLineCaptionType) {
    /**
     * Specifies the type of `inline`.
     */
    PdfLineCaptionType[PdfLineCaptionType["inline"] = 0] = "inline";
    /**
     * Specifies the type of `top`.
     */
    PdfLineCaptionType[PdfLineCaptionType["top"] = 1] = "top";
})(PdfLineCaptionType || (PdfLineCaptionType = {}));
/**
 * Public Enum to define border style.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfAnnotation = page.annotations.at(0);
 * // Sets the border style as underline
 * annotation.border.style = PdfBorderStyle.underline;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfBorderStyle;
(function (PdfBorderStyle) {
    /**
     * Specifies the type of `solid`.
     */
    PdfBorderStyle[PdfBorderStyle["solid"] = 0] = "solid";
    /**
     * Specifies the type of `dashed`.
     */
    PdfBorderStyle[PdfBorderStyle["dashed"] = 1] = "dashed";
    /**
     * Specifies the type of `beveled`.
     */
    PdfBorderStyle[PdfBorderStyle["beveled"] = 2] = "beveled";
    /**
     * Specifies the type of `inset`.
     */
    PdfBorderStyle[PdfBorderStyle["inset"] = 3] = "inset";
    /**
     * Specifies the type of `underline`.
     */
    PdfBorderStyle[PdfBorderStyle["underline"] = 4] = "underline";
    /**
     * Specifies the type of `dot`.
     */
    PdfBorderStyle[PdfBorderStyle["dot"] = 5] = "dot";
})(PdfBorderStyle || (PdfBorderStyle = {}));
/**
 * Public Enum to define border effect style.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfAnnotation = page.annotations.at(0);
 * // Sets the border effect as underline
 * annotation.borderEffect.style = PdfBorderEffectStyle.cloudy;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfBorderEffectStyle;
(function (PdfBorderEffectStyle) {
    /**
     * Specifies the type of `solid`.
     */
    PdfBorderEffectStyle[PdfBorderEffectStyle["solid"] = 0] = "solid";
    /**
     * Specifies the type of `cloudy`.
     */
    PdfBorderEffectStyle[PdfBorderEffectStyle["cloudy"] = 1] = "cloudy";
})(PdfBorderEffectStyle || (PdfBorderEffectStyle = {}));
/**
 * Public Enum to define rotation of the interactive elements.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access text box field
 * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
 * // Gets the rotation of the field
 * let rotation: PdfRotationAngle = field.rotationAngle;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfRotationAngle;
(function (PdfRotationAngle) {
    /**
     * Specifies the type of `angle0`.
     */
    PdfRotationAngle[PdfRotationAngle["angle0"] = 0] = "angle0";
    /**
     * Specifies the type of `angle90`.
     */
    PdfRotationAngle[PdfRotationAngle["angle90"] = 1] = "angle90";
    /**
     * Specifies the type of `angle180`.
     */
    PdfRotationAngle[PdfRotationAngle["angle180"] = 2] = "angle180";
    /**
     * Specifies the type of `angle270`.
     */
    PdfRotationAngle[PdfRotationAngle["angle270"] = 3] = "angle270";
})(PdfRotationAngle || (PdfRotationAngle = {}));
/**
 * Public Enum to define cross reference type.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Save the document with cross reference type as stream
 * document.save('output.pdf', PdfCrossReferenceType.stream);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfCrossReferenceType;
(function (PdfCrossReferenceType) {
    /**
     * Specifies the type of `table`.
     */
    PdfCrossReferenceType[PdfCrossReferenceType["table"] = 0] = "table";
    /**
     * Specifies the type of `stream`.
     */
    PdfCrossReferenceType[PdfCrossReferenceType["stream"] = 1] = "stream";
})(PdfCrossReferenceType || (PdfCrossReferenceType = {}));
/**
 * Public Enum to define highlight mode of text box field.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access text box field
 * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
 * // Sets the highlight mode of text box field as outline
 * field.highlightMode = PdfHighlightMode.outline;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfHighlightMode;
(function (PdfHighlightMode) {
    /**
     * Specifies the type of `noHighlighting`.
     */
    PdfHighlightMode[PdfHighlightMode["noHighlighting"] = 0] = "noHighlighting";
    /**
     * Specifies the type of `invert`.
     */
    PdfHighlightMode[PdfHighlightMode["invert"] = 1] = "invert";
    /**
     * Specifies the type of `outline`.
     */
    PdfHighlightMode[PdfHighlightMode["outline"] = 2] = "outline";
    /**
     * Specifies the type of `push`.
     */
    PdfHighlightMode[PdfHighlightMode["push"] = 3] = "push";
})(PdfHighlightMode || (PdfHighlightMode = {}));
/**
 * Public Enum to define text alignment of text box field.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access text box field
 * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
 * // Sets the text alignment of form field as center
 * field.textAlignment = PdfTextAlignment.center;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfTextAlignment;
(function (PdfTextAlignment) {
    /**
     * Specifies the type of `left`.
     */
    PdfTextAlignment[PdfTextAlignment["left"] = 0] = "left";
    /**
     * Specifies the type of `center`.
     */
    PdfTextAlignment[PdfTextAlignment["center"] = 1] = "center";
    /**
     * Specifies the type of `right`.
     */
    PdfTextAlignment[PdfTextAlignment["right"] = 2] = "right";
    /**
     * Specifies the type of `justify`.
     */
    PdfTextAlignment[PdfTextAlignment["justify"] = 3] = "justify";
})(PdfTextAlignment || (PdfTextAlignment = {}));
/**
 * Public Enum to define visibility of form field.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access PDF form field
 * let field: PdfField = document.form.fieldAt(0);
 * // Sets the visibility of form field as hidden
 * field.visibility = PdfFormFieldVisibility.hidden;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfFormFieldVisibility;
(function (PdfFormFieldVisibility) {
    /**
     * Specifies the type of `visible`.
     */
    PdfFormFieldVisibility[PdfFormFieldVisibility["visible"] = 0] = "visible";
    /**
     * Specifies the type of `hidden`.
     */
    PdfFormFieldVisibility[PdfFormFieldVisibility["hidden"] = 1] = "hidden";
    /**
     * Specifies the type of `visibleNotPrintable`.
     */
    PdfFormFieldVisibility[PdfFormFieldVisibility["visibleNotPrintable"] = 2] = "visibleNotPrintable";
    /**
     * Specifies the type of `hiddenPrintable`.
     */
    PdfFormFieldVisibility[PdfFormFieldVisibility["hiddenPrintable"] = 3] = "hiddenPrintable";
})(PdfFormFieldVisibility || (PdfFormFieldVisibility = {}));
/**
 * Public Enum to define measurement unit of line measurement annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfLineAnnotation = page.annotations.at(0) PdfLineAnnotation;
 * // Sets the measurement unit of line measurement annoation as centimeter
 * annotation.unit = PdfMeasurementUnit.centimeter;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfMeasurementUnit;
(function (PdfMeasurementUnit) {
    /**
     * Specifies the type of `inch`.
     */
    PdfMeasurementUnit[PdfMeasurementUnit["inch"] = 0] = "inch";
    /**
     * Specifies the type of `pica`.
     */
    PdfMeasurementUnit[PdfMeasurementUnit["pica"] = 1] = "pica";
    /**
     * Specifies the type of `point`.
     */
    PdfMeasurementUnit[PdfMeasurementUnit["point"] = 3] = "point";
    /**
     * Specifies the type of `centimeter`.
     */
    PdfMeasurementUnit[PdfMeasurementUnit["centimeter"] = 4] = "centimeter";
    /**
     * Specifies the type of `millimeter`.
     */
    PdfMeasurementUnit[PdfMeasurementUnit["millimeter"] = 6] = "millimeter";
})(PdfMeasurementUnit || (PdfMeasurementUnit = {}));
/**
 * Public Enum to define measurement type of circle annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfCircleAnnotation = page.annotations.at(0) PdfCircleAnnotation;
 * // Sets the measurement type of circle annotation as diameter
 * annotation.measureType = PdfCircleMeasurementType.diameter;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfCircleMeasurementType;
(function (PdfCircleMeasurementType) {
    /**
     * Specifies the type of `diameter`.
     */
    PdfCircleMeasurementType[PdfCircleMeasurementType["diameter"] = 0] = "diameter";
    /**
     * Specifies the type of `radius`.
     */
    PdfCircleMeasurementType[PdfCircleMeasurementType["radius"] = 1] = "radius";
})(PdfCircleMeasurementType || (PdfCircleMeasurementType = {}));
/**
 * Public Enum to define icon type of rubber stamp annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfRubberStampAnnotation = page.annotations.at(0) PdfRubberStampAnnotation;
 * // Sets the rubber stamp annotation icon type as confidential
 * annotation.icon = PdfRubberStampAnnotationIcon.confidential;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfRubberStampAnnotationIcon;
(function (PdfRubberStampAnnotationIcon) {
    /**
     * Specifies the type of `approved`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["approved"] = 0] = "approved";
    /**
     * Specifies the type of `asIs`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["asIs"] = 1] = "asIs";
    /**
     * Specifies the type of `confidential`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["confidential"] = 2] = "confidential";
    /**
     * Specifies the type of `departmental`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["departmental"] = 3] = "departmental";
    /**
     * Specifies the type of `draft`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["draft"] = 4] = "draft";
    /**
     * Specifies the type of `experimental`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["experimental"] = 5] = "experimental";
    /**
     * Specifies the type of `expired`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["expired"] = 6] = "expired";
    /**
     * Specifies the type of `final`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["final"] = 7] = "final";
    /**
     * Specifies the type of `forComment`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["forComment"] = 8] = "forComment";
    /**
     * Specifies the type of `forPublicRelease`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["forPublicRelease"] = 9] = "forPublicRelease";
    /**
     * Specifies the type of `notApproved`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["notApproved"] = 10] = "notApproved";
    /**
     * Specifies the type of `notForPublicRelease`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["notForPublicRelease"] = 11] = "notForPublicRelease";
    /**
     * Specifies the type of `sold`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["sold"] = 12] = "sold";
    /**
     * Specifies the type of `topSecret`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["topSecret"] = 13] = "topSecret";
    /**
     * Specifies the type of `completed`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["completed"] = 14] = "completed";
    /**
     * Specifies the type of `void`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["void"] = 15] = "void";
    /**
     * Specifies the type of `informationOnly`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["informationOnly"] = 16] = "informationOnly";
    /**
     * Specifies the type of `preliminaryResults`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["preliminaryResults"] = 17] = "preliminaryResults";
})(PdfRubberStampAnnotationIcon || (PdfRubberStampAnnotationIcon = {}));
/**
 * Public Enum to define check box style.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access check box field
 * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
 * // Access first item of check box field
 * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;
 * // Sets the check box style as check
 * item.style = PdfCheckBoxStyle.check;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfCheckBoxStyle;
(function (PdfCheckBoxStyle) {
    /**
     * Specifies the type of `check`.
     */
    PdfCheckBoxStyle[PdfCheckBoxStyle["check"] = 0] = "check";
    /**
     * Specifies the type of `circle`.
     */
    PdfCheckBoxStyle[PdfCheckBoxStyle["circle"] = 1] = "circle";
    /**
     * Specifies the type of `cross`.
     */
    PdfCheckBoxStyle[PdfCheckBoxStyle["cross"] = 2] = "cross";
    /**
     * Specifies the type of `diamond`.
     */
    PdfCheckBoxStyle[PdfCheckBoxStyle["diamond"] = 3] = "diamond";
    /**
     * Specifies the type of `square`.
     */
    PdfCheckBoxStyle[PdfCheckBoxStyle["square"] = 4] = "square";
    /**
     * Specifies the type of `star`.
     */
    PdfCheckBoxStyle[PdfCheckBoxStyle["star"] = 5] = "star";
})(PdfCheckBoxStyle || (PdfCheckBoxStyle = {}));
/**
 * Public Enum to define type of text markup annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) PdfTextMarkupAnnotation;
 * // Sets the type of the text markup annotation as underline
 * annotation.textMarkupType = PdfTextMarkupAnnotationType.underline;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfTextMarkupAnnotationType;
(function (PdfTextMarkupAnnotationType) {
    /**
     * Specifies the type of `highlight`.
     */
    PdfTextMarkupAnnotationType[PdfTextMarkupAnnotationType["highlight"] = 0] = "highlight";
    /**
     * Specifies the type of `underline`.
     */
    PdfTextMarkupAnnotationType[PdfTextMarkupAnnotationType["underline"] = 1] = "underline";
    /**
     * Specifies the type of `squiggly`.
     */
    PdfTextMarkupAnnotationType[PdfTextMarkupAnnotationType["squiggly"] = 2] = "squiggly";
    /**
     * Specifies the type of `strikeOut`.
     */
    PdfTextMarkupAnnotationType[PdfTextMarkupAnnotationType["strikeOut"] = 3] = "strikeOut";
})(PdfTextMarkupAnnotationType || (PdfTextMarkupAnnotationType = {}));
/**
 * Public Enum to define icon type of popup annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfPopupAnnotation = page.annotations.at(0) PdfPopupAnnotation;
 * // Sets the icon type of the popup annotation as comment
 * annotation.icon = PdfPopupIcon.comment;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfPopupIcon;
(function (PdfPopupIcon) {
    /**
     * Specifies the type of `note`.
     */
    PdfPopupIcon[PdfPopupIcon["note"] = 0] = "note";
    /**
     * Specifies the type of `comment`.
     */
    PdfPopupIcon[PdfPopupIcon["comment"] = 1] = "comment";
    /**
     * Specifies the type of `help`.
     */
    PdfPopupIcon[PdfPopupIcon["help"] = 2] = "help";
    /**
     * Specifies the type of `insert`.
     */
    PdfPopupIcon[PdfPopupIcon["insert"] = 3] = "insert";
    /**
     * Specifies the type of `key`.
     */
    PdfPopupIcon[PdfPopupIcon["key"] = 4] = "key";
    /**
     * Specifies the type of `new paragraph`.
     */
    PdfPopupIcon[PdfPopupIcon["newParagraph"] = 5] = "newParagraph";
    /**
     * Specifies the type of `paragraph`.
     */
    PdfPopupIcon[PdfPopupIcon["paragraph"] = 6] = "paragraph";
})(PdfPopupIcon || (PdfPopupIcon = {}));
/**
 * Public Enum to define annotation state.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfPopupAnnotation = page.annotations.at(0) PdfPopupAnnotation;
 * // Sets the state of the popup annotation as accepted
 * annotation.state = PdfAnnotationState.accepted;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAnnotationState;
(function (PdfAnnotationState) {
    /**
     * Specifies the default state of `none`.
     */
    PdfAnnotationState[PdfAnnotationState["none"] = 0] = "none";
    /**
     * Specifies the state of `accepted`.
     */
    PdfAnnotationState[PdfAnnotationState["accepted"] = 1] = "accepted";
    /**
     * Specifies the state of `rejected`.
     */
    PdfAnnotationState[PdfAnnotationState["rejected"] = 2] = "rejected";
    /**
     * Specifies the state of `cancel`.
     */
    PdfAnnotationState[PdfAnnotationState["cancel"] = 3] = "cancel";
    /**
     * Specifies the state of `completed`.
     */
    PdfAnnotationState[PdfAnnotationState["completed"] = 4] = "completed";
    /**
     * Specifies the state of `marked`.
     */
    PdfAnnotationState[PdfAnnotationState["marked"] = 5] = "marked";
    /**
     * Specifies the state of `unmarked`.
     */
    PdfAnnotationState[PdfAnnotationState["unmarked"] = 6] = "unmarked";
    /**
     * Specifies the state of `unknown`.
     */
    PdfAnnotationState[PdfAnnotationState["unknown"] = 7] = "unknown";
})(PdfAnnotationState || (PdfAnnotationState = {}));
/**
 * Public Enum to define annotation state model.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfPopupAnnotation = page.annotations.at(0) PdfPopupAnnotation;
 * // Sets the state model of the popup annotation as marked
 * annotation.stateModel = PdfAnnotationStateModel.marked;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAnnotationStateModel;
(function (PdfAnnotationStateModel) {
    /**
     * Specifies the default model of `none`.
     */
    PdfAnnotationStateModel[PdfAnnotationStateModel["none"] = 0] = "none";
    /**
     * Specifies the model of `marked`.
     */
    PdfAnnotationStateModel[PdfAnnotationStateModel["marked"] = 1] = "marked";
    /**
     * Specifies the model of `review`.
     */
    PdfAnnotationStateModel[PdfAnnotationStateModel["review"] = 2] = "review";
})(PdfAnnotationStateModel || (PdfAnnotationStateModel = {}));
/**
 * Public Enum to define icon type of attachment annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfAttachmentAnnotation = page.annotations.at(0) PdfAttachmentAnnotation;
 * // Sets the icon type of attachment annotation to pushPin
 * annotation.icon = PdfAttachmentIcon.pushPin;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAttachmentIcon;
(function (PdfAttachmentIcon) {
    /**
     * Specifies the default icon of `pushPin`.
     */
    PdfAttachmentIcon[PdfAttachmentIcon["pushPin"] = 0] = "pushPin";
    /**
     * Specifies the icon of `tag`.
     */
    PdfAttachmentIcon[PdfAttachmentIcon["tag"] = 1] = "tag";
    /**
     * Specifies the icon of `graph`.
     */
    PdfAttachmentIcon[PdfAttachmentIcon["graph"] = 2] = "graph";
    /**
     * Specifies the icon of `paperClip`.
     */
    PdfAttachmentIcon[PdfAttachmentIcon["paperClip"] = 3] = "paperClip";
})(PdfAttachmentIcon || (PdfAttachmentIcon = {}));
/**
 * Public Enum to define annotation intent of free text annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) PdfFreeTextAnnotation;
 * // Sets the free text annotation intent to freeTextCallout
 * annotation.annotationIntent = PdfAnnotationIntent.freeTextCallout;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAnnotationIntent;
(function (PdfAnnotationIntent) {
    /**
     * Specifies the default intent of `none`.
     */
    PdfAnnotationIntent[PdfAnnotationIntent["none"] = 0] = "none";
    /**
     * Specifies the intent of `freeTextCallout`.
     */
    PdfAnnotationIntent[PdfAnnotationIntent["freeTextCallout"] = 1] = "freeTextCallout";
    /**
     * Specifies the intent of `freeTextTypeWriter`.
     */
    PdfAnnotationIntent[PdfAnnotationIntent["freeTextTypeWriter"] = 2] = "freeTextTypeWriter";
})(PdfAnnotationIntent || (PdfAnnotationIntent = {}));
/**
 * Public Enum to define destination mode of document link annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfDocumentLinkAnnotation = page.annotations.at(0) PdfDocumentLinkAnnotation;
 * // Sets the destination mode as fitToPage
 * annotation.destination.mode = PdfDestinationMode.fitToPage;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfDestinationMode;
(function (PdfDestinationMode) {
    /**
     * Specifies the default intent of `location`.
     */
    PdfDestinationMode[PdfDestinationMode["location"] = 0] = "location";
    /**
     * Specifies the intent of `FitToPage`.
     */
    PdfDestinationMode[PdfDestinationMode["fitToPage"] = 1] = "fitToPage";
    /**
     * Specifies the intent of `fitR`.
     */
    PdfDestinationMode[PdfDestinationMode["fitR"] = 2] = "fitR";
    /**
     * Specifies the intent of `fitH`.
     */
    PdfDestinationMode[PdfDestinationMode["fitH"] = 3] = "fitH";
})(PdfDestinationMode || (PdfDestinationMode = {}));
/**
 * Public Enum to define export or import data format.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Sets export data format as JSON type to annotation export settings
 * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();
 * settings.dataFormat = DataFormat.json;
 * // Export annotations to JSON format
 * let json: Uint8Array = document.exportAnnotations(settings);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var DataFormat;
(function (DataFormat) {
    /**
     * Specifies the intent of `FDF`.
     */
    DataFormat[DataFormat["fdf"] = 0] = "fdf";
    /**
     * Specifies the intent of `XFDF`.
     */
    DataFormat[DataFormat["xfdf"] = 1] = "xfdf";
    /**
     * Specifies the intent of `JSON`.
     */
    DataFormat[DataFormat["json"] = 2] = "json";
    /**
     * Specifies the intent of `XML`.
     */
    DataFormat[DataFormat["xml"] = 3] = "xml";
})(DataFormat || (DataFormat = {}));
/**
 * Public enum to define form fields tab order.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Set a PDF form's tab order.
 * document.form.orderFormFields(PdfFormFieldsTabOrder.row);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfFormFieldsTabOrder;
(function (PdfFormFieldsTabOrder) {
    /**
     * Specifies that no tab order is defined.
     */
    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder["none"] = 0] = "none";
    /**
     * Specifies the tab order is defined by the document's rows.
     */
    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder["row"] = 1] = "row";
    /**
     * Specifies the tab order is defined by the document's columns.
     */
    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder["column"] = 2] = "column";
    /**
     * Specifies the tab order is defined by the document's structure tree.
     */
    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder["structure"] = 3] = "structure";
    /**
     * Specifies the tab order is defined manually.
     */
    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder["manual"] = 4] = "manual";
    /**
     * Specifies the tab order is defined by the widget annotations in the document.
     */
    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder["widget"] = 5] = "widget";
})(PdfFormFieldsTabOrder || (PdfFormFieldsTabOrder = {}));
/**
 * Enum for PDF loaded annotation type.
 */
var _PdfAnnotationType;
(function (_PdfAnnotationType) {
    /**
     * Specifies the intent of `highlight`.
     */
    _PdfAnnotationType[_PdfAnnotationType["highlight"] = 0] = "highlight";
    /**
     * Specifies the intent of `underline`.
     */
    _PdfAnnotationType[_PdfAnnotationType["underline"] = 1] = "underline";
    /**
     * Specifies the intent of `strikeOut`.
     */
    _PdfAnnotationType[_PdfAnnotationType["strikeOut"] = 2] = "strikeOut";
    /**
     * Specifies the intent of `squiggly`.
     */
    _PdfAnnotationType[_PdfAnnotationType["squiggly"] = 3] = "squiggly";
    /**
     * Specifies the intent of `redactionAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["redactionAnnotation"] = 4] = "redactionAnnotation";
    /**
     * Specifies the intent of `textAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["textAnnotation"] = 5] = "textAnnotation";
    /**
     * Specifies the intent of `linkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["linkAnnotation"] = 6] = "linkAnnotation";
    /**
     * Specifies the intent of `documentLinkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["documentLinkAnnotation"] = 7] = "documentLinkAnnotation";
    /**
     * Specifies the intent of `uriAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["uriAnnotation"] = 8] = "uriAnnotation";
    /**
     * Specifies the intent of `fileLinkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["fileLinkAnnotation"] = 9] = "fileLinkAnnotation";
    /**
     * Specifies the intent of `freeTextAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["freeTextAnnotation"] = 10] = "freeTextAnnotation";
    /**
     * Specifies the intent of `lineAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["lineAnnotation"] = 11] = "lineAnnotation";
    /**
     * Specifies the intent of `circleAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["circleAnnotation"] = 12] = "circleAnnotation";
    /**
     * Specifies the intent of `ellipseAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["ellipseAnnotation"] = 13] = "ellipseAnnotation";
    /**
     * Specifies the intent of `squareAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["squareAnnotation"] = 14] = "squareAnnotation";
    /**
     * Specifies the intent of `rectangleAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["rectangleAnnotation"] = 15] = "rectangleAnnotation";
    /**
     * Specifies the intent of `polygonAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["polygonAnnotation"] = 16] = "polygonAnnotation";
    /**
     * Specifies the intent of `polyLineAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["polyLineAnnotation"] = 17] = "polyLineAnnotation";
    /**
     * Specifies the intent of `textMarkupAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["textMarkupAnnotation"] = 18] = "textMarkupAnnotation";
    /**
     * Specifies the intent of `caretAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["caretAnnotation"] = 19] = "caretAnnotation";
    /**
     * Specifies the intent of `rubberStampAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["rubberStampAnnotation"] = 20] = "rubberStampAnnotation";
    /**
     * Specifies the intent of `popupAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["popupAnnotation"] = 21] = "popupAnnotation";
    /**
     * Specifies the intent of `fileAttachmentAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["fileAttachmentAnnotation"] = 22] = "fileAttachmentAnnotation";
    /**
     * Specifies the intent of `soundAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["soundAnnotation"] = 23] = "soundAnnotation";
    /**
     * Specifies the intent of `movieAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["movieAnnotation"] = 24] = "movieAnnotation";
    /**
     * Specifies the intent of `screenAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["screenAnnotation"] = 25] = "screenAnnotation";
    /**
     * Specifies the intent of `widgetAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["widgetAnnotation"] = 26] = "widgetAnnotation";
    /**
     * Specifies the intent of `printerMarkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["printerMarkAnnotation"] = 27] = "printerMarkAnnotation";
    /**
     * Specifies the intent of `trapNetworkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["trapNetworkAnnotation"] = 28] = "trapNetworkAnnotation";
    /**
     * Specifies the intent of `watermarkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["watermarkAnnotation"] = 29] = "watermarkAnnotation";
    /**
     * Specifies the intent of `textWebLinkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["textWebLinkAnnotation"] = 30] = "textWebLinkAnnotation";
    /**
     * Specifies the intent of `inkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["inkAnnotation"] = 31] = "inkAnnotation";
    /**
     * Specifies the intent of `richMediaAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["richMediaAnnotation"] = 32] = "richMediaAnnotation";
    /**
     * Specifies the intent of `angleMeasurementAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["angleMeasurementAnnotation"] = 33] = "angleMeasurementAnnotation";
    /**
     * Specifies the intent of `null`.
     */
    _PdfAnnotationType[_PdfAnnotationType["null"] = 34] = "null";
})(_PdfAnnotationType || (_PdfAnnotationType = {}));
/**
 * Enum for PDF graphics unit.
 */
var _PdfGraphicsUnit;
(function (_PdfGraphicsUnit) {
    /**
     * Specifies the type of `centimeter`.
     */
    _PdfGraphicsUnit[_PdfGraphicsUnit["centimeter"] = 0] = "centimeter";
    /**
     * Specifies the type of `pica`.
     */
    _PdfGraphicsUnit[_PdfGraphicsUnit["pica"] = 1] = "pica";
    /**
     * Specifies the type of `pixel`.
     */
    _PdfGraphicsUnit[_PdfGraphicsUnit["pixel"] = 2] = "pixel";
    /**
     * Specifies the type of `point`.
     */
    _PdfGraphicsUnit[_PdfGraphicsUnit["point"] = 3] = "point";
    /**
     * Specifies the type of `inch`.
     */
    _PdfGraphicsUnit[_PdfGraphicsUnit["inch"] = 4] = "inch";
    /**
     * Specifies the type of `document`.
     */
    _PdfGraphicsUnit[_PdfGraphicsUnit["document"] = 5] = "document";
    /**
     * Specifies the type of `millimeter`.
     */
    _PdfGraphicsUnit[_PdfGraphicsUnit["millimeter"] = 6] = "millimeter";
})(_PdfGraphicsUnit || (_PdfGraphicsUnit = {}));
var _FieldFlag;
(function (_FieldFlag) {
    _FieldFlag[_FieldFlag["default"] = 0] = "default";
    _FieldFlag[_FieldFlag["readOnly"] = 1] = "readOnly";
    _FieldFlag[_FieldFlag["required"] = 2] = "required";
    _FieldFlag[_FieldFlag["noExport"] = 4] = "noExport";
    _FieldFlag[_FieldFlag["multiLine"] = 4096] = "multiLine";
    _FieldFlag[_FieldFlag["password"] = 8192] = "password";
    _FieldFlag[_FieldFlag["fileSelect"] = 1048576] = "fileSelect";
    _FieldFlag[_FieldFlag["doNotSpellCheck"] = 4194304] = "doNotSpellCheck";
    _FieldFlag[_FieldFlag["doNotScroll"] = 8388608] = "doNotScroll";
    _FieldFlag[_FieldFlag["comb"] = 16777216] = "comb";
    _FieldFlag[_FieldFlag["richText"] = 33554432] = "richText";
    _FieldFlag[_FieldFlag["noToggleToOff"] = 16384] = "noToggleToOff";
    _FieldFlag[_FieldFlag["radio"] = 32768] = "radio";
    _FieldFlag[_FieldFlag["pushButton"] = 65536] = "pushButton";
    _FieldFlag[_FieldFlag["radiosInUnison"] = 33554432] = "radiosInUnison";
    _FieldFlag[_FieldFlag["combo"] = 131072] = "combo";
    _FieldFlag[_FieldFlag["edit"] = 262144] = "edit";
    _FieldFlag[_FieldFlag["sort"] = 524288] = "sort";
    _FieldFlag[_FieldFlag["multiSelect"] = 2097152] = "multiSelect";
    _FieldFlag[_FieldFlag["commitOnSelectChange"] = 67108864] = "commitOnSelectChange";
})(_FieldFlag || (_FieldFlag = {}));
var _SignatureFlag;
(function (_SignatureFlag) {
    _SignatureFlag[_SignatureFlag["none"] = 0] = "none";
    _SignatureFlag[_SignatureFlag["signatureExists"] = 1] = "signatureExists";
    _SignatureFlag[_SignatureFlag["appendOnly"] = 2] = "appendOnly";
})(_SignatureFlag || (_SignatureFlag = {}));
var _PdfCheckFieldState;
(function (_PdfCheckFieldState) {
    _PdfCheckFieldState[_PdfCheckFieldState["unchecked"] = 0] = "unchecked";
    _PdfCheckFieldState[_PdfCheckFieldState["checked"] = 1] = "checked";
    _PdfCheckFieldState[_PdfCheckFieldState["pressedUnchecked"] = 2] = "pressedUnchecked";
    _PdfCheckFieldState[_PdfCheckFieldState["pressedChecked"] = 3] = "pressedChecked";
})(_PdfCheckFieldState || (_PdfCheckFieldState = {}));
/**
 * Public enum to define the PDF document permission flags.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the permission flag
 * let permission: PdfPermissionFlag = document.permissions;
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfPermissionFlag;
(function (PdfPermissionFlag) {
    /**
     * Specifies the default permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["default"] = 0] = "default";
    /**
     * Specifies the print permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["print"] = 4] = "print";
    /**
     * Specifies the edit content permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["editContent"] = 8] = "editContent";
    /**
     * Specifies the copy content permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["copyContent"] = 16] = "copyContent";
    /**
     * Specifies the edit annotations permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["editAnnotations"] = 32] = "editAnnotations";
    /**
     * Specifies the fill fields permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["fillFields"] = 256] = "fillFields";
    /**
     * Specifies the accessibility copy content permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["accessibilityCopyContent"] = 512] = "accessibilityCopyContent";
    /**
     * Specifies the assemble document permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["assembleDocument"] = 1024] = "assembleDocument";
    /**
     * Specifies the full quality print permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["fullQualityPrint"] = 2048] = "fullQualityPrint";
})(PdfPermissionFlag || (PdfPermissionFlag = {}));
/**
 * Public enum to define the PDF page orientation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Get the page orientation
 * let orientation: PdfPageOrientation = page.orientation;
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfPageOrientation;
(function (PdfPageOrientation) {
    /**
     * Specifies the type of `portrait`.
     */
    PdfPageOrientation[PdfPageOrientation["portrait"] = 0] = "portrait";
    /**
     * Specifies the type of `landscape`.
     */
    PdfPageOrientation[PdfPageOrientation["landscape"] = 1] = "landscape";
})(PdfPageOrientation || (PdfPageOrientation = {}));
/**
 * Public enum to define the text direction.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Load the font file
 * let font: PdfTrueTypeFont = new PdfTrueTypeFont(read('./resources/Fonts/', 'Arial.ttf'), 10);
 * // Add a string format
 * let format: PdfStringFormat = new PdfStringFormat();
 * format.alignment = PdfTextAlignment.right;
 * format.textDirection = PdfTextDirection.rightToLeft;
 * // Draw a text with right to left direction
 * page.graphics.drawString('Hello World مرحبا بالعالم', font, [10, 20, 300, 200], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfTextDirection;
(function (PdfTextDirection) {
    /**
     * Specifies the type of `none`.
     */
    PdfTextDirection[PdfTextDirection["none"] = 0] = "none";
    /**
     * Specifies the type of `leftToRight`.
     */
    PdfTextDirection[PdfTextDirection["leftToRight"] = 1] = "leftToRight";
    /**
     * Specifies the type of `rightToLeft`.
     */
    PdfTextDirection[PdfTextDirection["rightToLeft"] = 2] = "rightToLeft";
})(PdfTextDirection || (PdfTextDirection = {}));
/**
 * Public enum to define the subscript or superscript mode.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF standard font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right);
 * // Set a new paragraph indent
 * format.paragraphIndent = 20;
 * // Set the subscript or superscript mode
 * format.subSuperScript = PdfSubSuperScript.subScript;
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfSubSuperScript;
(function (PdfSubSuperScript) {
    /**
     * Specifies the type of `none`.
     */
    PdfSubSuperScript[PdfSubSuperScript["none"] = 0] = "none";
    /**
     * Specifies the type of `superScript`.
     */
    PdfSubSuperScript[PdfSubSuperScript["superScript"] = 1] = "superScript";
    /**
     * Specifies the type of `subScript`.
     */
    PdfSubSuperScript[PdfSubSuperScript["subScript"] = 2] = "subScript";
})(PdfSubSuperScript || (PdfSubSuperScript = {}));
/**
 * Public enum to define blend mode of the PDF page.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.symbol, 10);
 * // Set the blend mode
 * graphics.setTransparency(0.5, 0.5, PdfBlendMode.hardLight);
 * // Draw the text
 * graphics.drawString('Hello World', font, null, new PointF(10, 10));
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfBlendMode;
(function (PdfBlendMode) {
    /**
     * Specifies the type of `normal`.
     */
    PdfBlendMode[PdfBlendMode["normal"] = 0] = "normal";
    /**
     * Specifies the type of `multiply`.
     */
    PdfBlendMode[PdfBlendMode["multiply"] = 1] = "multiply";
    /**
     * Specifies the type of `screen`.
     */
    PdfBlendMode[PdfBlendMode["screen"] = 2] = "screen";
    /**
     * Specifies the type of `overlay`.
     */
    PdfBlendMode[PdfBlendMode["overlay"] = 3] = "overlay";
    /**
     * Specifies the type of `darken`.
     */
    PdfBlendMode[PdfBlendMode["darken"] = 4] = "darken";
    /**
     * Specifies the type of `lighten`.
     */
    PdfBlendMode[PdfBlendMode["lighten"] = 5] = "lighten";
    /**
     * Specifies the type of `colorDodge`.
     */
    PdfBlendMode[PdfBlendMode["colorDodge"] = 6] = "colorDodge";
    /**
     * Specifies the type of `colorBurn`.
     */
    PdfBlendMode[PdfBlendMode["colorBurn"] = 7] = "colorBurn";
    /**
     * Specifies the type of `hardLight`.
     */
    PdfBlendMode[PdfBlendMode["hardLight"] = 8] = "hardLight";
    /**
     * Specifies the type of `softLight`.
     */
    PdfBlendMode[PdfBlendMode["softLight"] = 9] = "softLight";
    /**
     * Specifies the type of `difference`.
     */
    PdfBlendMode[PdfBlendMode["difference"] = 10] = "difference";
    /**
     * Specifies the type of `exclusion`.
     */
    PdfBlendMode[PdfBlendMode["exclusion"] = 11] = "exclusion";
    /**
     * Specifies the type of `hue`.
     */
    PdfBlendMode[PdfBlendMode["hue"] = 12] = "hue";
    /**
     * Specifies the type of `saturation`.
     */
    PdfBlendMode[PdfBlendMode["saturation"] = 13] = "saturation";
    /**
     * Specifies the type of `color`.
     */
    PdfBlendMode[PdfBlendMode["color"] = 14] = "color";
    /**
     * Specifies the type of `luminosity`.
     */
    PdfBlendMode[PdfBlendMode["luminosity"] = 15] = "luminosity";
})(PdfBlendMode || (PdfBlendMode = {}));
/**
 * Public enum to define fill mode of the PDF page.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.symbol, 10);
 * // Set the fill mode
 * graphics.setClip([0, 0, 100, 100], PdfFillMode.winding);
 * // Draw the text
 * graphics.drawString('Hello World', font, null, new PointF(10, 10));
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfFillMode;
(function (PdfFillMode) {
    /**
     * Specifies the type of `winding`.
     */
    PdfFillMode[PdfFillMode["winding"] = 0] = "winding";
    /**
     * Specifies the type of `alternate`.
     */
    PdfFillMode[PdfFillMode["alternate"] = 1] = "alternate";
})(PdfFillMode || (PdfFillMode = {}));
/**
 * Public enum to define the dash style.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new pen
 * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
 * // Set the dash style
 * pen._dashStyle = PdfDashStyle.dashDot;
 * // Draw a rectangle using pen
 * graphics.drawRectangle(150, 50, 50, 50, pen);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfDashStyle;
(function (PdfDashStyle) {
    /**
     * Specifies the type of `solid`.
     */
    PdfDashStyle[PdfDashStyle["solid"] = 0] = "solid";
    /**
     * Specifies the type of `dash`.
     */
    PdfDashStyle[PdfDashStyle["dash"] = 1] = "dash";
    /**
     * Specifies the type of `dot`.
     */
    PdfDashStyle[PdfDashStyle["dot"] = 2] = "dot";
    /**
     * Specifies the type of `dashDot`.
     */
    PdfDashStyle[PdfDashStyle["dashDot"] = 3] = "dashDot";
    /**
     * Specifies the type of `dashDotDot`.
     */
    PdfDashStyle[PdfDashStyle["dashDotDot"] = 4] = "dashDotDot";
    /**
     * Specifies the type of `custom`.
     */
    PdfDashStyle[PdfDashStyle["custom"] = 5] = "custom";
})(PdfDashStyle || (PdfDashStyle = {}));
/**
 * Public enum to define the line cap.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new pen
 * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
 * // Set the dash style
 * pen._dashStyle = PdfDashStyle.dashDot;
 * // Set the line cap
 * pen._lineCap = PdfLineCap.round;
 * // Draw a rectangle using pen
 * graphics.drawRectangle(150, 50, 50, 50, pen);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfLineCap;
(function (PdfLineCap) {
    /**
     * Specifies the type of `flat`.
     */
    PdfLineCap[PdfLineCap["flat"] = 0] = "flat";
    /**
     * Specifies the type of `round`.
     */
    PdfLineCap[PdfLineCap["round"] = 1] = "round";
    /**
     * Specifies the type of `square`.
     */
    PdfLineCap[PdfLineCap["square"] = 2] = "square";
})(PdfLineCap || (PdfLineCap = {}));
/**
 * Public enum to define the line join.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new pen
 * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
 * // Set the dash style
 * pen._dashStyle = PdfDashStyle.dashDot;
 * // Set the line join
 * pen._lineJoin = PdfLineJoin.bevel;
 * // Draw a rectangle using pen
 * graphics.drawRectangle(150, 50, 50, 50, pen);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfLineJoin;
(function (PdfLineJoin) {
    /**
     * Specifies the type of `miter`.
     */
    PdfLineJoin[PdfLineJoin["miter"] = 0] = "miter";
    /**
     * Specifies the type of `round`.
     */
    PdfLineJoin[PdfLineJoin["round"] = 1] = "round";
    /**
     * Specifies the type of `bevel`.
     */
    PdfLineJoin[PdfLineJoin["bevel"] = 2] = "bevel";
})(PdfLineJoin || (PdfLineJoin = {}));
var _PdfWordWrapType;
(function (_PdfWordWrapType) {
    /**
     * Specifies the type of `none`.
     */
    _PdfWordWrapType[_PdfWordWrapType["none"] = 0] = "none";
    /**
     * Specifies the type of `word`.
     */
    _PdfWordWrapType[_PdfWordWrapType["word"] = 1] = "word";
    /**
     * Specifies the type of `wordOnly`.
     */
    _PdfWordWrapType[_PdfWordWrapType["wordOnly"] = 2] = "wordOnly";
    /**
     * Specifies the type of `character`.
     */
    _PdfWordWrapType[_PdfWordWrapType["character"] = 3] = "character";
})(_PdfWordWrapType || (_PdfWordWrapType = {}));
var _FontDescriptorFlag;
(function (_FontDescriptorFlag) {
    _FontDescriptorFlag[_FontDescriptorFlag["fixedPitch"] = 1] = "fixedPitch";
    _FontDescriptorFlag[_FontDescriptorFlag["serif"] = 2] = "serif";
    _FontDescriptorFlag[_FontDescriptorFlag["symbolic"] = 4] = "symbolic";
    _FontDescriptorFlag[_FontDescriptorFlag["script"] = 8] = "script";
    _FontDescriptorFlag[_FontDescriptorFlag["nonSymbolic"] = 32] = "nonSymbolic";
    _FontDescriptorFlag[_FontDescriptorFlag["italic"] = 64] = "italic";
    _FontDescriptorFlag[_FontDescriptorFlag["forceBold"] = 262144] = "forceBold";
})(_FontDescriptorFlag || (_FontDescriptorFlag = {}));
var _TrueTypeCmapFormat;
(function (_TrueTypeCmapFormat) {
    _TrueTypeCmapFormat[_TrueTypeCmapFormat["apple"] = 0] = "apple";
    _TrueTypeCmapFormat[_TrueTypeCmapFormat["microsoft"] = 4] = "microsoft";
    _TrueTypeCmapFormat[_TrueTypeCmapFormat["trimmed"] = 6] = "trimmed";
})(_TrueTypeCmapFormat || (_TrueTypeCmapFormat = {}));
var _TrueTypeCmapEncoding;
(function (_TrueTypeCmapEncoding) {
    _TrueTypeCmapEncoding[_TrueTypeCmapEncoding["unknown"] = 0] = "unknown";
    _TrueTypeCmapEncoding[_TrueTypeCmapEncoding["symbol"] = 1] = "symbol";
    _TrueTypeCmapEncoding[_TrueTypeCmapEncoding["unicode"] = 2] = "unicode";
    _TrueTypeCmapEncoding[_TrueTypeCmapEncoding["macintosh"] = 3] = "macintosh";
})(_TrueTypeCmapEncoding || (_TrueTypeCmapEncoding = {}));
var _TrueTypePlatformID;
(function (_TrueTypePlatformID) {
    _TrueTypePlatformID[_TrueTypePlatformID["appleUnicode"] = 0] = "appleUnicode";
    _TrueTypePlatformID[_TrueTypePlatformID["macintosh"] = 1] = "macintosh";
    _TrueTypePlatformID[_TrueTypePlatformID["iSO"] = 2] = "iSO";
    _TrueTypePlatformID[_TrueTypePlatformID["microsoft"] = 3] = "microsoft";
})(_TrueTypePlatformID || (_TrueTypePlatformID = {}));
var _TrueTypeMicrosoftEncodingID;
(function (_TrueTypeMicrosoftEncodingID) {
    _TrueTypeMicrosoftEncodingID[_TrueTypeMicrosoftEncodingID["undefined"] = 0] = "undefined";
    _TrueTypeMicrosoftEncodingID[_TrueTypeMicrosoftEncodingID["unicode"] = 1] = "unicode";
})(_TrueTypeMicrosoftEncodingID || (_TrueTypeMicrosoftEncodingID = {}));
var _TrueTypeMacintoshEncodingID;
(function (_TrueTypeMacintoshEncodingID) {
    _TrueTypeMacintoshEncodingID[_TrueTypeMacintoshEncodingID["roman"] = 0] = "roman";
    _TrueTypeMacintoshEncodingID[_TrueTypeMacintoshEncodingID["japanese"] = 1] = "japanese";
    _TrueTypeMacintoshEncodingID[_TrueTypeMacintoshEncodingID["chinese"] = 2] = "chinese";
})(_TrueTypeMacintoshEncodingID || (_TrueTypeMacintoshEncodingID = {}));
var _TrueTypeCompositeGlyphFlag;
(function (_TrueTypeCompositeGlyphFlag) {
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["Arg1And2AreWords"] = 1] = "Arg1And2AreWords";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["ArgsAreXyValues"] = 2] = "ArgsAreXyValues";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["RoundXyToGrid"] = 4] = "RoundXyToGrid";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["WeHaveScale"] = 8] = "WeHaveScale";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["Reserved"] = 16] = "Reserved";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["MoreComponents"] = 32] = "MoreComponents";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["WeHaveAnXyScale"] = 64] = "WeHaveAnXyScale";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["WeHaveTwoByTwo"] = 128] = "WeHaveTwoByTwo";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["WeHaveInstructions"] = 256] = "WeHaveInstructions";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["UseMyMetrics"] = 512] = "UseMyMetrics";
})(_TrueTypeCompositeGlyphFlag || (_TrueTypeCompositeGlyphFlag = {}));
var _ImageFormat;
(function (_ImageFormat) {
    /**
     * Specifies the type of `unknown`.
     */
    _ImageFormat[_ImageFormat["unknown"] = 0] = "unknown";
    /**
     * Specifies the type of `bmp`.
     */
    _ImageFormat[_ImageFormat["bmp"] = 1] = "bmp";
    /**
     * Specifies the type of `emf`.
     */
    _ImageFormat[_ImageFormat["emf"] = 2] = "emf";
    /**
     * Specifies the type of `gif`.
     */
    _ImageFormat[_ImageFormat["gif"] = 3] = "gif";
    /**
     * Specifies the type of `jpeg`.
     */
    _ImageFormat[_ImageFormat["jpeg"] = 4] = "jpeg";
    /**
     * Specifies the type of `png`.
     */
    _ImageFormat[_ImageFormat["png"] = 5] = "png";
    /**
     * Specifies the type of `wmf`.
     */
    _ImageFormat[_ImageFormat["wmf"] = 6] = "wmf";
    /**
     * Specifies the type of `icon`.
     */
    _ImageFormat[_ImageFormat["icon"] = 7] = "icon";
})(_ImageFormat || (_ImageFormat = {}));
var _TokenType;
(function (_TokenType) {
    _TokenType[_TokenType["none"] = 0] = "none";
    _TokenType[_TokenType["comment"] = 1] = "comment";
    _TokenType[_TokenType["number"] = 2] = "number";
    _TokenType[_TokenType["real"] = 3] = "real";
    _TokenType[_TokenType["string"] = 4] = "string";
    _TokenType[_TokenType["hexString"] = 5] = "hexString";
    _TokenType[_TokenType["unicodeString"] = 6] = "unicodeString";
    _TokenType[_TokenType["unicodeHexString"] = 7] = "unicodeHexString";
    _TokenType[_TokenType["name"] = 8] = "name";
    _TokenType[_TokenType["operator"] = 9] = "operator";
    _TokenType[_TokenType["beginArray"] = 10] = "beginArray";
    _TokenType[_TokenType["endArray"] = 11] = "endArray";
    _TokenType[_TokenType["eof"] = 12] = "eof";
})(_TokenType || (_TokenType = {}));
/**
 * Public enum to define text style.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Get the bookmarks
 * let bookmarks: PdfBookmarkBase = document.bookmarks;
 * // Gets bookmark at the specified index
 * let bookmark : PdfBookMark = bookmarks.at(0) as PdfBookMark;
 * // Gets the textStyle
 * let textStyle: PdfTextStyle = bookmark.textStyle;
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfTextStyle;
(function (PdfTextStyle) {
    /**
     * Specifies the `regular` text style.
     */
    PdfTextStyle[PdfTextStyle["regular"] = 0] = "regular";
    /**
     * Specifies the `italic` text style.
     */
    PdfTextStyle[PdfTextStyle["italic"] = 1] = "italic";
    /**
     * Specifies the `bold` text style.
     */
    PdfTextStyle[PdfTextStyle["bold"] = 2] = "bold";
})(PdfTextStyle || (PdfTextStyle = {}));
var _PdfColorSpace;
(function (_PdfColorSpace) {
    _PdfColorSpace[_PdfColorSpace["rgb"] = 0] = "rgb";
    _PdfColorSpace[_PdfColorSpace["cmyk"] = 1] = "cmyk";
    _PdfColorSpace[_PdfColorSpace["grayScale"] = 2] = "grayScale";
    _PdfColorSpace[_PdfColorSpace["indexed"] = 3] = "indexed";
})(_PdfColorSpace || (_PdfColorSpace = {}));
/**
 * Public enum type to represent the ordered list style
 * ````typescript
 * // Load an existing document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access the first page
 * let page: PdfPage = document.getPage(0);
 * // Add each item to the item collection by passing the string array
 * let items: PdfListitemCollection = new PdfListitemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
 * // Create a new ordered list and passing the list item collection
 * let list: PdfOrderedList = new PdfOrderedList(items);
 * // Set the ordered list number style for the list items
 * list.style = PdfNumberStyle.lowerLatin;
 * // Draw the ordered list
 * list.draw(page, 0, 20, 500, 700);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfNumberStyle;
(function (PdfNumberStyle) {
    /**
     * No numbering at all.
     */
    PdfNumberStyle[PdfNumberStyle["none"] = 0] = "none";
    /**
     * Specifies the type '1'.
     */
    PdfNumberStyle[PdfNumberStyle["numeric"] = 1] = "numeric";
    /**
     * Specifies the style 'a'.
     */
    PdfNumberStyle[PdfNumberStyle["lowerLatin"] = 2] = "lowerLatin";
    /**
     * Specifies the style 'i'.
     */
    PdfNumberStyle[PdfNumberStyle["lowerRoman"] = 3] = "lowerRoman";
    /**
     * Specifies the style 'A'.
     */
    PdfNumberStyle[PdfNumberStyle["upperLatin"] = 4] = "upperLatin";
    /**
     * Specifies the style 'I'.
     */
    PdfNumberStyle[PdfNumberStyle["upperRoman"] = 5] = "upperRoman";
})(PdfNumberStyle || (PdfNumberStyle = {}));
/**
 * Public enum to define the style used for unordered list.
 * ```typescript
 * // Load an existing document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access the first page
 * let page: PdfPage = document.getPage(0);
 * // Add each item to the collection by passing the string array
 * let items: PdfListitemCollection = new PdfListitemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
 * // Create a unordered list and pass the list item collection
 * let list: PdfUnorderedList = new PdfUnorderedList(items);
 * // Set the unordered list style for the list items
 * list.style = PdfUnorderedListStyle.circle;
 * // Draw the unordered list associated with items
 * list.draw(page, 0, 20, 500, 700);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfUnorderedListStyle;
(function (PdfUnorderedListStyle) {
    /**
     * No bulleting at all.
     */
    PdfUnorderedListStyle[PdfUnorderedListStyle["none"] = 0] = "none";
    /**
     * Specifies disk style.
     */
    PdfUnorderedListStyle[PdfUnorderedListStyle["disk"] = 1] = "disk";
    /**
     * Specifies square style.
     */
    PdfUnorderedListStyle[PdfUnorderedListStyle["square"] = 2] = "square";
    /**
     * Specifies asterisk style.
     */
    PdfUnorderedListStyle[PdfUnorderedListStyle["asterisk"] = 3] = "asterisk";
    /**
     * Specifies circle style.
     */
    PdfUnorderedListStyle[PdfUnorderedListStyle["circle"] = 4] = "circle";
})(PdfUnorderedListStyle || (PdfUnorderedListStyle = {}));
/**
 * Public enum to define a layout type for drawing
 * ```typescript
 * // Load an existing document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access the first page
 * let page: PdfPage = document.getPage(0);
 * // Assign the array of string for items
 * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
 * // Add the items to the list item collection by passing the array
 * let items: PdfListItemCollection = new PdfListItemCollection(products);
 * // Create a new ordered list
 * let list: PdfOrderedList = new PdfOrderedList(items);
 * // Create a layout format for drawing
 * let pageLayout: PdfLayoutFormat = new PdfLayoutFormat();
 * // Initialize layout type for drawing
 * pageLayout.layout = PdfLayoutType.paginate;
 * // Draw the list on the page along with the specified layout
 * list.draw(page, 0, 20, 500, 700, pageLayout);
 * // Get the layout type used to draw the list
 * let layoutType: PdfLayoutType = pageLayout.layout;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ````
 */
var PdfLayoutType;
(function (PdfLayoutType) {
    /**
     * Specifies pagination across multiple pages based on the specified dimensions and layout options
     */
    PdfLayoutType[PdfLayoutType["paginate"] = 0] = "paginate";
    /**
     * Specifies content to be laid out to fit within a single page, without pagination
     */
    PdfLayoutType[PdfLayoutType["onePage"] = 1] = "onePage";
})(PdfLayoutType || (PdfLayoutType = {}));
/**
 * Public enum to define a layout Break type for drawing
 * ```typescript
 * // Load an existing document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access the first page
 * let page: PdfPage = document.getPage(0);
 * // Assign the array of string for items
 * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
 * // Add the item to list item collection by passing the string array
 * let items: PdfListItemCollection = new PdfListItemCollection(products);
 * // Create a new ordered list
 * let list: PdfOrderedList = new PdfOrderedList(items);
 * // Create a layout for drawing
 * let pageLayout: PdfLayoutFormat = new PdfLayoutFormat();
 * // Set  the layout break type for drawing
 * pageLayout.break = PdfLayoutBreakType.fitPage;
 * // Draw the list associated with items along with layout
 * list.draw(page, 0, 20, 500, 700, pageLayout);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ````
 */
var PdfLayoutBreakType;
(function (PdfLayoutBreakType) {
    /**
     * Specifies that content should break to a new page to fit within specified dimensions.
     */
    PdfLayoutBreakType[PdfLayoutBreakType["fitPage"] = 0] = "fitPage";
    /**
     * Specifies that content should break to a new page or element to fit within specified dimensions.
     */
    PdfLayoutBreakType[PdfLayoutBreakType["fitElement"] = 1] = "fitElement";
})(PdfLayoutBreakType || (PdfLayoutBreakType = {}));
/**
 * Public enum to define a list marker alignment
 * ````typescript
 * // Load an existing document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access the first page
 * let page: PdfPage = document.getPage(0);
 * // Add each item to the item collection by passing the string array
 * let items: PdfListitemCollection = new PdfListitemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
 * // Create a new ordered list and passing the list item collection
 * let list: PdfOrderedList = new PdfOrderedList(items);
 * // Set the marker alignment
 * list.alignment = PdfListMarkerAlignment.left;
 * // Draw the ordered list
 * list.draw(page, 0, 20, 500, 700);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfListMarkerAlignment;
(function (PdfListMarkerAlignment) {
    /**
     * Left alignment for marker.
     */
    PdfListMarkerAlignment[PdfListMarkerAlignment["left"] = 0] = "left";
    /**
     * Right alignment for marker.
     */
    PdfListMarkerAlignment[PdfListMarkerAlignment["right"] = 1] = "right";
})(PdfListMarkerAlignment || (PdfListMarkerAlignment = {}));
/**
 * Public enum to define a print state of layer
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access the collection of layers in the document
 * let layers: PdfLayerCollection = document.layers;
 * // Retrieve the first layer from the layers collection
 * let layer: PdfLayer = layers.at(0);
 * // Retrieve the print state of the layer
 * let printState: PdfPrintState = layer.printState;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ````
 */
var PdfPrintState;
(function (PdfPrintState) {
    /**
     * The PDF layers always get print
     */
    PdfPrintState[PdfPrintState["alwaysPrint"] = 0] = "alwaysPrint";
    /**
     * The PDF layers never get print
     */
    PdfPrintState[PdfPrintState["neverPrint"] = 1] = "neverPrint";
    /**
     * The visible PDF layers get print
     */
    PdfPrintState[PdfPrintState["printWhenVisible"] = 2] = "printWhenVisible";
})(PdfPrintState || (PdfPrintState = {}));

var _PdfStreamWriter = /** @class */ (function () {
    function _PdfStreamWriter(stream) {
        this._newLine = '\r\n';
        this._whiteSpace = ' ';
        this._stream = stream;
    }
    _PdfStreamWriter.prototype._writeOperator = function (value) {
        this._stream.write(value);
        this._stream.write(this._newLine);
    };
    _PdfStreamWriter.prototype._saveGraphicsState = function () {
        this._writeOperator('q');
    };
    _PdfStreamWriter.prototype._restoreGraphicsState = function () {
        this._writeOperator('Q');
    };
    _PdfStreamWriter.prototype._writeComment = function (comment) {
        if (comment && comment.length > 0) {
            this._writeOperator('% ' + comment);
        }
    };
    _PdfStreamWriter.prototype._setGraphicsState = function (value) {
        this._stream.write("/" + _escapePdfName(value.name) + " ");
        this._writeOperator('gs');
    };
    _PdfStreamWriter.prototype._modifyCtm = function (matrix) {
        this._stream.write(matrix._toString() + " ");
        this._writeOperator('cm');
    };
    _PdfStreamWriter.prototype._modifyTM = function (matrix) {
        this._stream.write(matrix._toString() + " ");
        this._writeOperator('Tm');
    };
    _PdfStreamWriter.prototype._setColorSpace = function (value, arg2, arg3) {
        if (typeof value === 'string' && typeof arg2 === 'boolean') {
            this._stream.write("/" + value + " ");
            this._writeOperator(arg2 ? 'CS' : 'cs');
        }
        else if (Array.isArray(value) && typeof arg2 === 'number' && typeof arg3 === 'boolean') {
            var colorSpaceName = void 0;
            switch (arg2) {
                case _PdfColorSpace.rgb:
                    colorSpaceName = 'DeviceRGB';
                    break;
                case _PdfColorSpace.cmyk:
                    colorSpaceName = 'DeviceCMYK';
                    break;
                case _PdfColorSpace.grayScale:
                    colorSpaceName = 'DeviceGray';
                    break;
                default:
                    colorSpaceName = 'DeviceRGB';
                    break;
            }
            this._stream.write("/" + colorSpaceName + " ");
            this._writeOperator(arg3 ? 'CS' : 'cs');
            this._setColor(value, arg3);
        }
    };
    _PdfStreamWriter.prototype._setColor = function (color, forStroking) {
        this._stream.write((color[0] / 255).toFixed(3) + " " + (color[1] / 255).toFixed(3) + " " + (color[2] / 255).toFixed(3) + " ");
        this._writeOperator(forStroking ? 'RG' : 'rg');
    };
    _PdfStreamWriter.prototype._appendRectangle = function (x, y, width, height) {
        this._writePoint(x, y);
        this._writePoint(width, height);
        this._writeOperator('re');
    };
    _PdfStreamWriter.prototype._writePoint = function (x, y) {
        this._stream.write(x.toFixed(3) + " " + (-y).toFixed(3) + " ");
    };
    _PdfStreamWriter.prototype._clipPath = function (isEvenOdd) {
        this._stream.write((isEvenOdd ? 'W*' : 'W') + " n" + this._newLine);
    };
    _PdfStreamWriter.prototype._fillPath = function (isEvenOdd) {
        this._writeOperator(isEvenOdd ? 'f*' : 'f');
    };
    _PdfStreamWriter.prototype._closeFillPath = function (isEvenOdd) {
        this._writeOperator('h');
        this._fillPath(isEvenOdd);
    };
    _PdfStreamWriter.prototype._strokePath = function () {
        this._writeOperator('S');
    };
    _PdfStreamWriter.prototype._closeStrokePath = function () {
        this._writeOperator('s');
    };
    _PdfStreamWriter.prototype._fillStrokePath = function (isEvenOdd) {
        this._writeOperator(isEvenOdd ? 'B*' : 'B');
    };
    _PdfStreamWriter.prototype._closeFillStrokePath = function (isEvenOdd) {
        this._writeOperator(isEvenOdd ? 'b*' : 'b');
    };
    _PdfStreamWriter.prototype._endPath = function () {
        this._writeOperator('n');
    };
    _PdfStreamWriter.prototype._setFont = function (name, size) {
        this._stream.write("/" + name + " " + size.toFixed(3) + " ");
        this._writeOperator('Tf');
    };
    _PdfStreamWriter.prototype._setTextScaling = function (textScaling) {
        this._stream.write(textScaling.toFixed(3) + " ");
        this._writeOperator('Tz');
    };
    _PdfStreamWriter.prototype._closePath = function () {
        this._writeOperator('h');
    };
    _PdfStreamWriter.prototype._startNextLine = function (x, y) {
        if (typeof x === 'undefined') {
            this._writeOperator('T*');
        }
        else {
            this._writePoint(x, y);
            this._writeOperator('Td');
        }
    };
    _PdfStreamWriter.prototype._setLeading = function (leading) {
        this._write(leading.toFixed(3) + " ");
        this._write(this._whiteSpace);
        this._writeOperator('TL');
    };
    _PdfStreamWriter.prototype._showText = function (text) {
        this._writeText(text);
        this._writeOperator('Tj');
    };
    _PdfStreamWriter.prototype._write = function (string) {
        var builder = '';
        builder += string;
        builder += '\r\n';
        this._writeOperator(builder);
    };
    _PdfStreamWriter.prototype._writeText = function (text) {
        var result = '';
        var data = this._escapeSymbols(text);
        for (var i = 0; i < data.length; i++) {
            result += String.fromCharCode(data[i]); // eslint-disable-line
        }
        result = '(' + result + ')';
        this._stream.write(result);
    };
    _PdfStreamWriter.prototype._beginText = function () {
        this._writeOperator('BT');
    };
    _PdfStreamWriter.prototype._endText = function () {
        this._writeOperator('ET');
    };
    _PdfStreamWriter.prototype._beginPath = function (x, y) {
        this._writePoint(x, y);
        this._writeOperator('m');
    };
    _PdfStreamWriter.prototype._appendLineSegment = function (x, y) {
        this._writePoint(x, y);
        this._writeOperator('l');
    };
    _PdfStreamWriter.prototype._appendBezierSegment = function (x1, y1, x2, y2, x3, y3) {
        this._writePoint(x1, y1);
        this._writePoint(x2, y2);
        this._writePoint(x3, y3);
        this._writeOperator('c');
    };
    _PdfStreamWriter.prototype._setTextRenderingMode = function (renderingMode) {
        this._stream.write(renderingMode.toString() + " ");
        this._writeOperator('Tr');
    };
    _PdfStreamWriter.prototype._setCharacterSpacing = function (charSpacing) {
        this._stream.write(charSpacing.toFixed(3) + " ");
        this._writeOperator('Tc');
    };
    _PdfStreamWriter.prototype._setWordSpacing = function (wordSpacing) {
        this._stream.write(wordSpacing.toFixed(3) + " ");
        this._writeOperator('Tw');
    };
    _PdfStreamWriter.prototype._showNextLineText = function (text, unicode) {
        if (unicode !== null && typeof unicode !== 'undefined' && unicode) {
            this._writeText(text);
            this._writeOperator('\'');
        }
        else {
            this._stream.write(text);
            this._writeOperator('\'');
        }
    };
    _PdfStreamWriter.prototype._setLineDashPattern = function (pattern, patternOffset) {
        var tempPattern = '[';
        if (pattern.length > 1) {
            for (var index = 0; index < pattern.length; index++) {
                if (index === pattern.length - 1) {
                    tempPattern += pattern[index].toString(); // eslint-disable-line
                }
                else {
                    tempPattern += pattern[index].toString() + ' '; // eslint-disable-line
                }
            }
        }
        tempPattern += '] ';
        tempPattern += patternOffset.toString();
        tempPattern += ' d';
        this._writeOperator(tempPattern);
    };
    _PdfStreamWriter.prototype._setMiterLimit = function (miterLimit) {
        this._stream.write(miterLimit.toFixed(3) + " ");
        this._writeOperator('M');
    };
    _PdfStreamWriter.prototype._setLineWidth = function (width) {
        this._stream.write(width.toFixed(3) + " ");
        this._writeOperator('w');
    };
    _PdfStreamWriter.prototype._setLineCap = function (lineCapStyle) {
        this._stream.write(lineCapStyle + " ");
        this._writeOperator('J');
    };
    _PdfStreamWriter.prototype._setLineJoin = function (lineJoinStyle) {
        this._stream.write(lineJoinStyle + " ");
        this._writeOperator('j');
    };
    _PdfStreamWriter.prototype._executeObject = function (name) {
        this._stream.write("/" + name.name + " ");
        this._writeOperator('Do');
    };
    _PdfStreamWriter.prototype._beginMarkupSequence = function (name) {
        this._stream.write("/" + name + " ");
        this._writeOperator('BMC');
    };
    _PdfStreamWriter.prototype._endMarkupSequence = function () {
        this._writeOperator('EMC');
    };
    _PdfStreamWriter.prototype._clear = function () {
        this._stream._bytes = [];
    };
    _PdfStreamWriter.prototype._escapeSymbols = function (value) {
        var data = [];
        for (var i = 0; i < value.length; i++) {
            var currentData = value.charCodeAt(i);
            switch (currentData) {
                case 40:
                case 41:
                    data.push(92);
                    data.push(currentData);
                    break;
                case 13:
                    data.push(92);
                    data.push(114);
                    break;
                case 92:
                    data.push(92);
                    data.push(currentData);
                    break;
                default:
                    data.push(currentData);
                    break;
            }
        }
        return data;
    };
    return _PdfStreamWriter;
}());

/**
 * Represents the text layout information.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF standard font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfStringFormat = /** @class */ (function () {
    function PdfStringFormat(arg1, arg2) {
        this.horizontalScalingFactor = 100.0;
        this.rightToLeft = false;
        this._wordWrapType = _PdfWordWrapType.word;
        this._isList = false;
        this.lineLimit = true;
        if (typeof arg1 !== 'undefined') {
            this.alignment = arg1;
        }
        if (typeof arg2 !== 'undefined') {
            this.lineAlignment = arg2;
        }
        else {
            this.lineAlignment = PdfVerticalAlignment.top;
        }
        this.characterSpacing = 0;
        this.wordSpacing = 0;
        this.lineSpacing = 0;
        this.clipPath = false;
        this.firstLineIndent = 0;
        this._internalParagraphIndent = 0;
        this.measureTrailingSpaces = false;
        this.noClip = false;
    }
    Object.defineProperty(PdfStringFormat.prototype, "paragraphIndent", {
        /**
         * Gets the paragraph indent from string format.
         *
         * @returns {number} Returns the paragraph indent.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF standard font
         * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
         * // Create a new PDF string format
         * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right);
         * // Get the default paragraph indent
         * let paragraph: number = format.paragraphIndent;
         * // Draw the text
         * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._internalParagraphIndent;
        },
        /**
         * Sets the paragraph indent to string format.
         *
         * @param {number} value paragraph indent.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF standard font
         * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
         * // Create a new PDF string format
         * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right);
         * // Set a new paragraph indent
         * format.paragraphIndent = 20;
         * // Draw the text
         * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._internalParagraphIndent = value;
            this.firstLineIndent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfStringFormat.prototype, "subSuperScript", {
        /**
         * Gets the subscript or superscript mode from string format.
         *
         * @returns {PdfSubSuperScript} Returns the subscript or superscript mode.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF standard font
         * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
         * // Create a new PDF string format
         * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right);
         * // Set a new paragraph indent
         * format.paragraphIndent = 20;
         * // Get the subscript or superscript mode
         * let script: PdfSubSuperScript = format.subSuperScript;
         * // Draw the text
         * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._pdfSubSuperScript === 'undefined' || this._pdfSubSuperScript === null) {
                return PdfSubSuperScript.none;
            }
            else {
                return this._pdfSubSuperScript;
            }
        },
        /**
         * Sets the subscript or superscript mode to string format.
         *
         * @param {PdfSubSuperScript} value subscript or superscript mode.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF standard font
         * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
         * // Create a new PDF string format
         * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right);
         * // Set a new paragraph indent
         * format.paragraphIndent = 20;
         * // Set the subscript or superscript mode
         * format.subSuperScript = PdfSubSuperScript.subScript;
         * // Draw the text
         * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._pdfSubSuperScript = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfStringFormat.prototype, "_wordWrap", {
        get: function () {
            return this._wordWrapType;
        },
        set: function (value) {
            this._wordWrapType = value;
        },
        enumerable: true,
        configurable: true
    });
    return PdfStringFormat;
}());
/**
 * Public enum to define vertical alignment.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF standard font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.regular);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.top);
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfVerticalAlignment;
(function (PdfVerticalAlignment) {
    /**
     * Specifies the type of `top`.
     */
    PdfVerticalAlignment[PdfVerticalAlignment["top"] = 0] = "top";
    /**
     * Specifies the type of `middle`.
     */
    PdfVerticalAlignment[PdfVerticalAlignment["middle"] = 1] = "middle";
    /**
     * Specifies the type of `bottom`.
     */
    PdfVerticalAlignment[PdfVerticalAlignment["bottom"] = 2] = "bottom";
})(PdfVerticalAlignment || (PdfVerticalAlignment = {}));

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _PdfFontMetrics = /** @class */ (function () {
    function _PdfFontMetrics() {
        this._lineGap = 0;
    }
    _PdfFontMetrics.prototype._getAscent = function (format) {
        return this._ascent * 0.001 * this._getSize(format);
    };
    _PdfFontMetrics.prototype._getDescent = function (format) {
        return this._descent * 0.001 * this._getSize(format);
    };
    _PdfFontMetrics.prototype._getLineGap = function (format) {
        return this._lineGap * 0.001 * this._getSize(format);
    };
    _PdfFontMetrics.prototype._getHeight = function (format) {
        var height;
        var clearTypeFonts = ['cambria', 'candara', 'constantia', 'corbel', 'cariadings'];
        var clearTypeFontCollection = [];
        for (var index = 0; index < clearTypeFonts.length; index++) {
            clearTypeFontCollection.push(clearTypeFonts[Number.parseInt(index.toString(), 10)]);
        }
        if (this._getDescent(format) < 0) {
            height = (this._getAscent(format) - this._getDescent(format) + this._getLineGap(format));
        }
        else {
            height = (this._getAscent(format) + this._getDescent(format) + this._getLineGap(format));
        }
        return height;
    };
    _PdfFontMetrics.prototype._getSize = function (format) {
        var size = this._size;
        if (format !== null && typeof format !== 'undefined') {
            switch (format.subSuperScript) {
                case PdfSubSuperScript.subScript:
                    size /= this._subScriptSizeFactor;
                    break;
                case PdfSubSuperScript.superScript:
                    size /= this._superscriptSizeFactor;
                    break;
            }
        }
        return size;
    };
    return _PdfFontMetrics;
}());
var _WidthTable = /** @class */ (function () {
    function _WidthTable() {
    }
    return _WidthTable;
}());
var _StandardWidthTable = /** @class */ (function (_super) {
    __extends(_StandardWidthTable, _super);
    function _StandardWidthTable(widths) {
        var _this = _super.call(this) || this;
        _this.widths = widths;
        return _this;
    }
    _StandardWidthTable.prototype._itemAt = function (index) {
        if (index < 0 || index >= this.widths.length) {
            throw new Error('The character is not supported by the font.');
        }
        return this.widths[Number.parseInt(index.toString(), 10)];
    };
    _StandardWidthTable.prototype._toArray = function () {
        return this.widths;
    };
    return _StandardWidthTable;
}(_WidthTable));
var _CjkWidthTable = /** @class */ (function (_super) {
    __extends(_CjkWidthTable, _super);
    function _CjkWidthTable(defaultWidth) {
        var _this = _super.call(this) || this;
        _this._defaultWidth = defaultWidth;
        _this.widths = [];
        return _this;
    }
    _CjkWidthTable.prototype._itemAt = function (index) {
        var width = this._defaultWidth;
        this.widths.forEach(function (entry) {
            if (index >= entry._from && index <= entry._to) {
                width = entry._itemAt(index);
            }
        });
        return width;
    };
    _CjkWidthTable.prototype._toArray = function () {
        var array = [];
        this.widths.forEach(function (width) {
            width._appendToArray(array);
        });
        return array;
    };
    _CjkWidthTable.prototype._add = function (width) {
        this.widths.push(width);
    };
    return _CjkWidthTable;
}(_WidthTable));
var _CjkWidth = /** @class */ (function () {
    function _CjkWidth() {
    }
    return _CjkWidth;
}());
var _CjkSameWidth = /** @class */ (function (_super) {
    __extends(_CjkSameWidth, _super);
    function _CjkSameWidth(from, to, width) {
        var _this = _super.call(this) || this;
        _this._widthFrom = from;
        _this._widthTo = to;
        _this._width = width;
        return _this;
    }
    Object.defineProperty(_CjkSameWidth.prototype, "_from", {
        get: function () {
            return this._widthFrom;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_CjkSameWidth.prototype, "_to", {
        get: function () {
            return this._widthTo;
        },
        enumerable: true,
        configurable: true
    });
    _CjkSameWidth.prototype._itemAt = function (index) {
        if (index < this._from || index > this._to) {
            throw new Error('Index is out of range.');
        }
        return this._width;
    };
    _CjkSameWidth.prototype._appendToArray = function (array) {
        array.push(this._from, this._to, this._width);
    };
    return _CjkSameWidth;
}(_CjkWidth));
var _CjkDifferentWidth = /** @class */ (function (_super) {
    __extends(_CjkDifferentWidth, _super);
    function _CjkDifferentWidth(from, widths) {
        var _this = _super.call(this) || this;
        _this._widthFrom = from;
        _this._widths = widths;
        return _this;
    }
    Object.defineProperty(_CjkDifferentWidth.prototype, "_from", {
        get: function () {
            return this._widthFrom;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_CjkDifferentWidth.prototype, "_to", {
        get: function () {
            return this._widthFrom + this._widths.length - 1;
        },
        enumerable: true,
        configurable: true
    });
    _CjkDifferentWidth.prototype._itemAt = function (index) {
        if (index < this._widthFrom || index > this._to) {
            throw new Error('Index is out of range.');
        }
        return this._widths[Number.parseInt(index.toString(), 10)];
    };
    _CjkDifferentWidth.prototype._appendToArray = function (array) {
        array.push(this._from);
        array.forEach(function (entry) {
            array.push(entry);
        });
    };
    return _CjkDifferentWidth;
}(_CjkWidth));

var _PdfStringLayouter = /** @class */ (function () {
    function _PdfStringLayouter() {
    }
    _PdfStringLayouter.prototype._layout = function (text, font, format, size) {
        this._initialize(text, font, format, size);
        var result = this._doLayout();
        this._clear();
        return result;
    };
    _PdfStringLayouter.prototype._initialize = function (text, font, format, size) {
        this._font = font;
        this._format = format;
        this._size = size;
        this._rectangle = [0, 0, size[0], size[1]];
        this._reader = new _StringTokenizer(text);
        this._pageHeight = 0;
    };
    _PdfStringLayouter.prototype._clear = function () {
        this._font = null;
        this._format = null;
        this._reader._close();
        this._reader = null;
    };
    _PdfStringLayouter.prototype._doLayout = function () {
        var result = new _PdfStringLayoutResult();
        var lineResult = new _PdfStringLayoutResult();
        var lines = [];
        var line = this._reader._peekLine();
        var lineIndent = this._getLineIndent(true);
        while (line !== null) {
            lineResult = this._layoutLine(line, lineIndent);
            if (typeof lineResult !== 'undefined' && lineResult !== null) {
                var numSymbolsInserted = 0;
                var returnedValue = this._copyToResult(result, lineResult, lines, numSymbolsInserted);
                var success = returnedValue.success;
                numSymbolsInserted = returnedValue.flag;
                if (!success) {
                    this._reader._read(numSymbolsInserted);
                    break;
                }
            }
            this._reader._readLine();
            line = this._reader._peekLine();
            lineIndent = this._getLineIndent(false);
        }
        this._finalizeResult(result, lines);
        return result;
    };
    _PdfStringLayouter.prototype._getLineIndent = function (firstLine) {
        var lineIndent = 0;
        if (this._format) {
            lineIndent = (firstLine) ? this._format.firstLineIndent : this._format.paragraphIndent;
            lineIndent = (this._size[0] > 0) ? Math.min(this._size[0], lineIndent) : lineIndent;
        }
        return lineIndent;
    };
    _PdfStringLayouter.prototype._getLineHeight = function () {
        var height = this._font._metrics._getHeight();
        if (this._format && this._format.lineSpacing !== 0) {
            height = this._format.lineSpacing + this._font._metrics._getHeight();
        }
        return height;
    };
    _PdfStringLayouter.prototype._getLineWidth = function (line) {
        return this._font.getLineWidth(line, this._format);
    };
    _PdfStringLayouter.prototype._layoutLine = function (line, lineIndent) {
        var lineResult = new _PdfStringLayoutResult();
        lineResult._lineHeight = this._getLineHeight();
        var lines = [];
        var maxWidth = this._size[0];
        var lineWidth = this._getLineWidth(line) + lineIndent;
        var lineType = _LineType.firstParagraphLine;
        var readWord = true;
        if (maxWidth <= 0 || Math.round(lineWidth) <= Math.round(maxWidth)) {
            this._addToLineResult(lineResult, lines, line, lineWidth, _LineType.newLineBreak | lineType);
        }
        else {
            var builder = '';
            var curLine = '';
            lineWidth = lineIndent;
            var curIndent = lineIndent;
            var reader = new _StringTokenizer(line);
            var word = reader._peekWord();
            if (word.length !== reader._length) {
                if (word === ' ') {
                    curLine = curLine + word;
                    builder = builder + word;
                    reader._position += 1;
                    word = reader._peekWord();
                }
            }
            while (word !== null) {
                curLine = curLine + word;
                var curLineWidth = this._getLineWidth(curLine.toString()) + curIndent;
                if (curLine.toString() === ' ') {
                    curLine = '';
                    curLineWidth = 0;
                }
                if (curLineWidth > maxWidth) {
                    if (this._getWrapType() === _PdfWordWrapType.none) {
                        break;
                    }
                    if (curLine.length === word.length) {
                        if (this._getWrapType() === _PdfWordWrapType.wordOnly) {
                            lineResult._remainder = line.substring(reader._position);
                            break;
                        }
                        else if (curLine.length === 1) {
                            builder = builder + word;
                            break;
                        }
                        else {
                            readWord = false;
                            curLine = '';
                            word = reader._peek().toString();
                            continue;
                        }
                    }
                    else {
                        if (this._getLineWidth(word.toString()) > maxWidth) {
                            if (typeof this._format !== 'undefined' && this._format !== null) {
                                this._format._wordWrap = _PdfWordWrapType.character;
                            }
                        }
                        else {
                            if (typeof this._format !== 'undefined' && this._format !== null) {
                                this._format._wordWrap = _PdfWordWrapType.word;
                            }
                        }
                        if (this._getWrapType() !== _PdfWordWrapType.character || !readWord) {
                            var stringValue = builder.toString();
                            if (stringValue !== ' ') {
                                this._addToLineResult(lineResult, lines, stringValue, lineWidth, _LineType.layoutBreak | lineType);
                            }
                            curLine = '';
                            builder = '';
                            lineWidth = 0;
                            curIndent = 0;
                            curLineWidth = 0;
                            lineType = _LineType.none;
                            word = (readWord) ? word : reader._peekWord();
                            readWord = true;
                        }
                        else {
                            readWord = false;
                            curLine = '';
                            curLine = curLine + builder.toString();
                            word = reader._peek().toString();
                        }
                        continue;
                    }
                }
                builder = builder + word;
                lineWidth = curLineWidth;
                if (readWord) {
                    reader._readWord();
                    word = reader._peekWord();
                }
                else {
                    reader._read();
                    word = reader._peek().toString();
                }
            }
            if (builder.length > 0) {
                this._addToLineResult(lineResult, lines, builder.toString(), lineWidth, _LineType.newLineBreak | _LineType.lastParagraphLine);
            }
            reader._close();
        }
        lineResult._layoutLines = [];
        for (var index = 0; index < lines.length; index++) {
            lineResult._layoutLines.push(lines[index]); // eslint-disable-line
        }
        lines = [];
        return lineResult;
    };
    _PdfStringLayouter.prototype._addToLineResult = function (lineResult, lines, line, lineWidth, breakType) {
        var info = new _LineInfo();
        info._text = line;
        info._width = lineWidth;
        info._lineType = breakType;
        lines.push(info);
        var size = lineResult._actualSize;
        size[1] = size[1] + this._getLineHeight();
        size[0] = Math.max(size[0], lineWidth);
        lineResult._size = size;
    };
    _PdfStringLayouter.prototype._copyToResult = function (result, lineResult, lines, flag) {
        var success = true;
        var allowPartialLines = (this._format && !this._format.lineLimit);
        var height = result._actualSize[1];
        var maxHeight = this._size[1];
        if ((this._pageHeight > 0) && (maxHeight + this._rectangle[1] > this._pageHeight)) {
            maxHeight = this._rectangle[1] - this._pageHeight;
            maxHeight = Math.max(maxHeight, -maxHeight);
        }
        flag = 0;
        if (lineResult._lines !== null) {
            for (var i = 0, len = lineResult._lines.length; i < len; i++) {
                var expHeight = height + lineResult._lineHeight;
                if (expHeight <= maxHeight || maxHeight <= 0 || allowPartialLines) {
                    var info = lineResult._lines[i]; // eslint-disable-line
                    flag += info._text.length;
                    info = this._trimLine(info, (lines.length === 0));
                    lines.push(info);
                    var size = result._actualSize;
                    size[0] = Math.max(size[0], info._width);
                    result._size = size;
                    height = expHeight;
                }
                else {
                    success = false;
                    break;
                }
            }
        }
        if (height !== result._size[1]) {
            result._size = [result._actualSize[0], height];
        }
        return { success: success, flag: flag };
    };
    _PdfStringLayouter.prototype._finalizeResult = function (result, lines) {
        result._layoutLines = [];
        for (var index = 0; index < lines.length; index++) {
            result._layoutLines.push(lines[index]); // eslint-disable-line
        }
        result._lineHeight = this._getLineHeight();
        if (!this._reader._end) {
            result._remainder = this._reader._readToEnd();
        }
        lines = [];
    };
    _PdfStringLayouter.prototype._trimLine = function (info, firstLine) {
        var line = info._text.trim();
        var lineWidth = info._width;
        if (line.length !== info._text.length) {
            lineWidth = this._getLineWidth(line);
            if ((info._lineType & _LineType.firstParagraphLine) > 0) {
                lineWidth += this._getLineIndent(firstLine);
            }
        }
        info._text = line;
        info._width = lineWidth;
        return info;
    };
    _PdfStringLayouter.prototype._getWrapType = function () {
        var wrapType = (this._format !== null && typeof this._format !== 'undefined') ?
            this._format._wordWrap : _PdfWordWrapType.word;
        return wrapType;
    };
    return _PdfStringLayouter;
}());
var _PdfStringLayoutResult = /** @class */ (function () {
    function _PdfStringLayoutResult() {
    }
    Object.defineProperty(_PdfStringLayoutResult.prototype, "_actualSize", {
        get: function () {
            if (typeof this._size === 'undefined') {
                this._size = [0, 0];
            }
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_PdfStringLayoutResult.prototype, "_lines", {
        get: function () {
            return this._layoutLines;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_PdfStringLayoutResult.prototype, "_empty", {
        get: function () {
            return (this._layoutLines === null || this._layoutLines.length === 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_PdfStringLayoutResult.prototype, "_lineCount", {
        get: function () {
            return (!this._empty) ? this._layoutLines.length : 0;
        },
        enumerable: true,
        configurable: true
    });
    return _PdfStringLayoutResult;
}());
var _LineInfo = /** @class */ (function () {
    function _LineInfo() {
    }
    return _LineInfo;
}());
var _LineType;
(function (_LineType) {
    _LineType[_LineType["none"] = 0] = "none";
    _LineType[_LineType["newLineBreak"] = 1] = "newLineBreak";
    _LineType[_LineType["layoutBreak"] = 2] = "layoutBreak";
    _LineType[_LineType["firstParagraphLine"] = 4] = "firstParagraphLine";
    _LineType[_LineType["lastParagraphLine"] = 8] = "lastParagraphLine";
})(_LineType || (_LineType = {}));
var _StringTokenizer = /** @class */ (function () {
    function _StringTokenizer(textValue) {
        this._position = 0;
        if (typeof textValue === 'undefined' || textValue === null) {
            throw new Error('ArgumentNullException:text');
        }
        this._text = textValue;
    }
    Object.defineProperty(_StringTokenizer.prototype, "_length", {
        get: function () {
            return this._text.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_StringTokenizer.prototype, "_end", {
        get: function () {
            return (this._position === this._text.length);
        },
        enumerable: true,
        configurable: true
    });
    _StringTokenizer.prototype._readLine = function () {
        var position = this._position;
        while (position < this._length) {
            var ch = this._text[position]; // eslint-disable-line
            var text = void 0;
            switch (ch) {
                case '\r':
                case '\n':
                    text = this._text.substring(this._position, position);
                    this._position = position + 1;
                    if (((ch === '\r') && (this._position < this._length)) && (this._text[this._position] === '\n')) {
                        this._position++;
                    }
                    return text;
            }
            position++;
        }
        if (position > this._position) {
            var text2 = this._text.substring(this._position, position);
            this._position = position;
            return text2;
        }
        return null;
    };
    _StringTokenizer.prototype._peekLine = function () {
        var position = this._position;
        var line = this._readLine();
        this._position = position;
        return line;
    };
    _StringTokenizer.prototype._readWord = function () {
        var position = this._position;
        while (position < this._length) {
            var ch = this._text[position]; // eslint-disable-line
            var text = void 0;
            switch (ch) {
                case '\r':
                case '\n':
                    text = this._text.substring(this._position, position - this._position);
                    this._position = position + 1;
                    if (((ch === '\r') && (this._position < this._length)) && (this._text[this._position] === '\n')) {
                        this._position++;
                    }
                    return text;
                case ' ':
                case '\t':
                    if (position === this._position) {
                        position++;
                    }
                    text = this._text.substring(this._position, position);
                    this._position = position;
                    return text;
            }
            position++;
        }
        if (position > this._position) {
            var text2 = this._text.substring(this._position, position);
            this._position = position;
            return text2;
        }
        return null;
    };
    _StringTokenizer.prototype._peekWord = function () {
        var position = this._position;
        var word = this._readWord();
        this._position = position;
        return word;
    };
    _StringTokenizer.prototype._read = function (count) {
        if (typeof count === 'undefined') {
            var character = '0';
            if (!this._end) {
                character = this._text[this._position];
                this._position++;
            }
            return character;
        }
        else {
            var value = 0;
            var builder = '';
            while (!this._end && value < count) {
                builder += this._read();
                value++;
            }
            return builder;
        }
    };
    _StringTokenizer.prototype._peek = function () {
        return this._end ? '0' : this._text[this._position];
    };
    _StringTokenizer.prototype._close = function () {
        this._text = null;
    };
    _StringTokenizer.prototype._readToEnd = function () {
        var text;
        if (this._position === 0) {
            text = this._text;
        }
        else {
            text = this._text.substring(this._position);
        }
        this._position = this._length;
        return text;
    };
    _StringTokenizer._whiteSpace = ' ';
    _StringTokenizer._tab = '\t';
    _StringTokenizer._spaces = [_StringTokenizer._whiteSpace, _StringTokenizer._tab];
    return _StringTokenizer;
}());

var _TrueTypeTableInfo = /** @class */ (function () {
    function _TrueTypeTableInfo() {
    }
    Object.defineProperty(_TrueTypeTableInfo.prototype, "_empty", {
        get: function () {
            var empty = (this._offset === this._length && this._length === this._checksum && this._checksum === 0);
            return empty;
        },
        enumerable: true,
        configurable: true
    });
    return _TrueTypeTableInfo;
}());
var _TrueTypeOS2Table = /** @class */ (function () {
    function _TrueTypeOS2Table() {
    }
    return _TrueTypeOS2Table;
}());
var _TrueTypePostTable = /** @class */ (function () {
    function _TrueTypePostTable() {
    }
    return _TrueTypePostTable;
}());
var _TrueTypeNameTable = /** @class */ (function () {
    function _TrueTypeNameTable() {
    }
    return _TrueTypeNameTable;
}());
var _TrueTypeMicrosoftCmapSubTable = /** @class */ (function () {
    function _TrueTypeMicrosoftCmapSubTable() {
    }
    return _TrueTypeMicrosoftCmapSubTable;
}());
var _TrueTypeHorizontalHeaderTable = /** @class */ (function () {
    function _TrueTypeHorizontalHeaderTable() {
    }
    return _TrueTypeHorizontalHeaderTable;
}());
var _TrueTypeHeadTable = /** @class */ (function () {
    function _TrueTypeHeadTable() {
    }
    return _TrueTypeHeadTable;
}());
var _TrueTypeCmapTable = /** @class */ (function () {
    function _TrueTypeCmapTable() {
    }
    return _TrueTypeCmapTable;
}());
var _TrueTypeCmapSubTable = /** @class */ (function () {
    function _TrueTypeCmapSubTable() {
    }
    return _TrueTypeCmapSubTable;
}());
var _TrueTypeAppleCmapSubTable = /** @class */ (function () {
    function _TrueTypeAppleCmapSubTable() {
    }
    return _TrueTypeAppleCmapSubTable;
}());
var _TrueTypeTrimmedCmapSubTable = /** @class */ (function () {
    function _TrueTypeTrimmedCmapSubTable() {
    }
    return _TrueTypeTrimmedCmapSubTable;
}());

var _TrueTypeReader = /** @class */ (function () {
    function _TrueTypeReader(fontData) {
        this._int32Size = 4;
        this._isFont = false;
        this._isMacTtf = false;
        this._isMacFont = false;
        this._missedGlyphs = 0;
        this._tableNames = ['cvt ', 'fpgm', 'glyf', 'head', 'hhea', 'hmtx', 'loca', 'maxp', 'prep'];
        this._entrySelectors = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4];
        this._fontData = fontData;
        this._initialize();
    }
    Object.defineProperty(_TrueTypeReader.prototype, "macintosh", {
        get: function () {
            if (this._macintoshDictionary === null || typeof this._macintoshDictionary === 'undefined') {
                this._macintoshDictionary = new Dictionary();
            }
            return this._macintoshDictionary;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_TrueTypeReader.prototype, "_microsoft", {
        get: function () {
            if (this._microsoftDictionary === null || typeof this._microsoftDictionary === 'undefined') {
                this._microsoftDictionary = new Dictionary();
            }
            return this._microsoftDictionary;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_TrueTypeReader.prototype, "_macintoshGlyphs", {
        get: function () {
            if (this._internalMacintoshGlyphs === null || typeof this._internalMacintoshGlyphs === 'undefined') {
                this._internalMacintoshGlyphs = new Dictionary();
            }
            return this._internalMacintoshGlyphs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_TrueTypeReader.prototype, "_microsoftGlyphs", {
        get: function () {
            if (this._internalMicrosoftGlyphs === null || typeof this._internalMicrosoftGlyphs === 'undefined') {
                this._internalMicrosoftGlyphs = new Dictionary();
            }
            return this._internalMicrosoftGlyphs;
        },
        enumerable: true,
        configurable: true
    });
    _TrueTypeReader.prototype._initialize = function () {
        if (typeof this._metrics === 'undefined' || this._metrics === null) {
            this._metrics = new _TrueTypeMetrics();
        }
        this._readFontDictionary();
        var nameTable = this._readNameTable();
        var headTable = this._readHeadTable();
        this._initializeFontName(nameTable);
        this._metrics._macStyle = headTable._macStyle;
    };
    _TrueTypeReader.prototype._readFontDictionary = function () {
        this._offset = 0;
        this._check();
        var table = this._readInt16(this._offset);
        this._readInt16(this._offset);
        this._readInt16(this._offset);
        this._readInt16(this._offset);
        if (typeof this._tableDirectory === 'undefined' || this._tableDirectory === null) {
            this._tableDirectory = new Dictionary();
        }
        for (var i = 0; i < table; ++i) {
            var table_1 = new _TrueTypeTableInfo();
            var tableKey = this._readString(this._int32Size);
            table_1._checksum = this._readInt32(this._offset);
            table_1._offset = this._readInt32(this._offset);
            table_1._length = this._readInt32(this._offset);
            this._tableDirectory.setValue(tableKey, table_1);
        }
        this._lowestPosition = this._offset;
        if (!this._isFont) {
            this._fixOffsets();
        }
    };
    _TrueTypeReader.prototype._fixOffsets = function () {
        var minOffset = Number.MAX_VALUE;
        var tableKeys = this._tableDirectory.keys();
        for (var i = 0; i < tableKeys.length; i++) {
            var value = this._tableDirectory.getValue(tableKeys[Number.parseInt(i.toString(), 10)]);
            var offset = value._offset;
            if (minOffset > offset) {
                minOffset = offset;
                if (minOffset <= this._lowestPosition) {
                    break;
                }
            }
        }
        var shift = minOffset - this._lowestPosition;
        if (shift !== 0) {
            var table = new Dictionary();
            for (var i = 0; i < tableKeys.length; i++) {
                var value = this._tableDirectory.getValue(tableKeys[Number.parseInt(i.toString(), 10)]);
                value._offset -= shift;
                table.setValue(tableKeys[Number.parseInt(i.toString(), 10)], value);
            }
            this._tableDirectory = table;
        }
    };
    _TrueTypeReader.prototype._check = function () {
        var version = this._readInt32(this._offset);
        this._isMacTtf = (version === 0x74727565) ? true : false;
        if (version !== 0x10000 && version !== 0x74727565 && version !== 0x4f54544f) {
            this._isFont = true;
            this._offset = 0;
            var fontTag = this._readString(4);
            if (fontTag !== 'ttcf') {
                throw new Error('Can not read TTF font data');
            }
            this._offset += 4;
            var ttcIdentificationNumber = this._readInt32(this._offset);
            if (ttcIdentificationNumber < 0) {
                throw new Error('Can not read TTF font data');
            }
            this._offset = this._readInt32(this._offset);
            version = this._readInt32(this._offset);
        }
        return version;
    };
    _TrueTypeReader.prototype._readNameTable = function () {
        var tableInfo = this._getTable('name');
        if (typeof tableInfo._offset !== 'undefined' && tableInfo._offset !== null) {
            this._offset = tableInfo._offset;
        }
        var table = new _TrueTypeNameTable();
        table._formatSelector = this._readUInt16(this._offset);
        table._recordsCount = this._readUInt16(this._offset);
        table._offset = this._readUInt16(this._offset);
        table._nameRecords = [];
        var recordSize = 12;
        var position = this._offset;
        for (var i = 0; i < table._recordsCount; i++) {
            this._offset = position;
            var record = new _TrueTypeNameRecord();
            record._platformID = this._readUInt16(this._offset);
            record._encodingID = this._readUInt16(this._offset);
            record._languageID = this._readUInt16(this._offset);
            record._nameID = this._readUInt16(this._offset);
            record._length = this._readUInt16(this._offset);
            record._offset = this._readUInt16(this._offset);
            this._offset = tableInfo._offset + table._offset + record._offset;
            var unicode = (record._platformID === 0 || record._platformID === 3);
            record._name = this._readString(record._length, unicode);
            table._nameRecords[Number.parseInt(i.toString(), 10)] = record;
            position += recordSize;
        }
        return table;
    };
    _TrueTypeReader.prototype._readHeadTable = function () {
        var tableInfo = this._getTable('head');
        if (typeof tableInfo._offset !== 'undefined' && tableInfo._offset !== null) {
            this._offset = tableInfo._offset;
        }
        var table = new _TrueTypeHeadTable();
        table._version = this._readFixed(this._offset);
        table._fontRevision = this._readFixed(this._offset);
        table._checkSumAdjustment = this._readUInt32(this._offset);
        table._magicNumber = this._readUInt32(this._offset);
        table._flags = this._readUInt16(this._offset);
        table._unitsPerEm = this._readUInt16(this._offset);
        table._created = this._readInt64(this._offset);
        table._modified = this._readInt64(this._offset);
        table._xMin = this._readInt16(this._offset);
        table._yMin = this._readInt16(this._offset);
        table._xMax = this._readInt16(this._offset);
        table._yMax = this._readInt16(this._offset);
        table._macStyle = this._readUInt16(this._offset);
        table._lowestReadableSize = this._readUInt16(this._offset);
        table._fontDirectionHint = this._readInt16(this._offset);
        table._indexToLocalFormat = this._readInt16(this._offset);
        table._glyphDataFormat = this._readInt16(this._offset);
        return table;
    };
    _TrueTypeReader.prototype._readHorizontalHeaderTable = function () {
        var tableInfo = this._getTable('hhea');
        if (typeof tableInfo._offset !== 'undefined' && tableInfo._offset !== null) {
            this._offset = tableInfo._offset;
        }
        var table = new _TrueTypeHorizontalHeaderTable();
        table._version = this._readFixed(this._offset);
        table._ascender = this._readInt16(this._offset);
        table._descender = this._readInt16(this._offset);
        table._lineGap = this._readInt16(this._offset);
        table._advanceWidthMax = this._readUInt16(this._offset);
        table._minLeftSideBearing = this._readInt16(this._offset);
        table._minRightSideBearing = this._readInt16(this._offset);
        table._xMaxExtent = this._readInt16(this._offset);
        table._caretSlopeRise = this._readInt16(this._offset);
        table._caretSlopeRun = this._readInt16(this._offset);
        this._offset += 10;
        table._metricDataFormat = this._readInt16(this._offset);
        table._numberOfHMetrics = this._readUInt16(this._offset);
        return table;
    };
    _TrueTypeReader.prototype._readOS2Table = function () {
        var tableInfo = this._getTable('OS/2');
        if (typeof tableInfo._offset !== 'undefined' && tableInfo._offset !== null) {
            this._offset = tableInfo._offset;
        }
        var table = new _TrueTypeOS2Table();
        table._version = this._readUInt16(this._offset);
        table._xAvgCharWidth = this._readInt16(this._offset);
        table._usWeightClass = this._readUInt16(this._offset);
        table._usWidthClass = this._readUInt16(this._offset);
        table._fsType = this._readInt16(this._offset);
        table._ySubscriptXSize = this._readInt16(this._offset);
        table._ySubscriptYSize = this._readInt16(this._offset);
        table._ySubscriptXOffset = this._readInt16(this._offset);
        table._ySubscriptYOffset = this._readInt16(this._offset);
        table._ySuperscriptXSize = this._readInt16(this._offset);
        table._ySuperscriptYSize = this._readInt16(this._offset);
        table._ySuperscriptXOffset = this._readInt16(this._offset);
        table._ySuperscriptYOffset = this._readInt16(this._offset);
        table._yStrikeoutSize = this._readInt16(this._offset);
        table._yStrikeoutPosition = this._readInt16(this._offset);
        table._sFamilyClass = this._readInt16(this._offset);
        table._panose = this._readBytes(10);
        table._ulUnicodeRange1 = this._readUInt32(this._offset);
        table._ulUnicodeRange2 = this._readUInt32(this._offset);
        table._ulUnicodeRange3 = this._readUInt32(this._offset);
        table._ulUnicodeRange4 = this._readUInt32(this._offset);
        table._vendorIdentifier = this._readBytes(4);
        table._fsSelection = this._readUInt16(this._offset);
        table._usFirstCharIndex = this._readUInt16(this._offset);
        table._usLastCharIndex = this._readUInt16(this._offset);
        table._sTypoAscender = this._readInt16(this._offset);
        table._sTypoDescender = this._readInt16(this._offset);
        table._sTypoLineGap = this._readInt16(this._offset);
        table._usWinAscent = this._readUInt16(this._offset);
        table._usWinDescent = this._readUInt16(this._offset);
        table._ulCodePageRange1 = this._readUInt32(this._offset);
        table._ulCodePageRange2 = this._readUInt32(this._offset);
        if (table._version > 1) {
            table._sxHeight = this._readInt16(this._offset);
            table._sCapHeight = this._readInt16(this._offset);
            table._usDefaultChar = this._readUInt16(this._offset);
            table._usBreakChar = this._readUInt16(this._offset);
            table._usMaxContext = this._readUInt16(this._offset);
        }
        else {
            table._sxHeight = 0;
            table._sCapHeight = 0;
            table._usDefaultChar = 0;
            table._usBreakChar = 0;
            table._usMaxContext = 0;
        }
        return table;
    };
    _TrueTypeReader.prototype._readPostTable = function () {
        var tableInfo = this._getTable('post');
        if (typeof tableInfo._offset !== 'undefined' && tableInfo._offset !== null) {
            this._offset = tableInfo._offset;
        }
        var table = new _TrueTypePostTable();
        table._formatType = this._readFixed(this._offset);
        table._italicAngle = this._readFixed(this._offset);
        table._underlinePosition = this._readInt16(this._offset);
        table._underlineThickness = this._readInt16(this._offset);
        table._isFixedPitch = this._readUInt32(this._offset);
        table._minType42 = this._readUInt32(this._offset);
        table._maxType42 = this._readUInt32(this._offset);
        table._minType1 = this._readUInt32(this._offset);
        table._maxType1 = this._readUInt32(this._offset);
        return table;
    };
    _TrueTypeReader.prototype._readWidthTable = function (glyphCount, unitsPerEm) {
        var tableInfo = this._getTable('hmtx');
        if (typeof tableInfo._offset !== 'undefined' && tableInfo._offset !== null) {
            this._offset = tableInfo._offset;
        }
        var width = [];
        for (var i = 0; i < glyphCount; i++) {
            var glyph = new _TrueTypeLongHorMetric();
            glyph._advanceWidth = this._readUInt16(this._offset);
            glyph._lsb = this._readInt16(this._offset);
            var glyphWidth = glyph._advanceWidth * 1000 / unitsPerEm;
            width.push(Math.floor(glyphWidth));
        }
        return width;
    };
    _TrueTypeReader.prototype._readCmapTable = function () {
        var tableInfo = this._getTable('cmap');
        if (typeof tableInfo._offset !== 'undefined' && tableInfo._offset !== null) {
            this._offset = tableInfo._offset;
        }
        var table = new _TrueTypeCmapTable();
        table._version = this._readUInt16(this._offset);
        table._tablesCount = this._readUInt16(this._offset);
        var position = this._offset;
        var subTables = [];
        for (var i = 0; i < table._tablesCount; i++) {
            this._offset = position;
            var subTable = new _TrueTypeCmapSubTable();
            subTable._platformID = this._readUInt16(this._offset);
            subTable._encodingID = this._readUInt16(this._offset);
            subTable._offset = this._readUInt32(this._offset);
            position = this._offset;
            this._readCmapSubTable(subTable);
            subTables[Number.parseInt(i.toString(), 10)] = subTable;
        }
        return subTables;
    };
    _TrueTypeReader.prototype._readCmapSubTable = function (subTable) {
        var tableInfo = this._getTable('cmap');
        this._offset = tableInfo._offset + subTable._offset;
        var format = this._readUInt16(this._offset);
        var encoding = this._getCmapEncoding(subTable._platformID, subTable._encodingID);
        if (encoding !== _TrueTypeCmapEncoding.unknown) {
            switch (format) {
                case _TrueTypeCmapFormat.apple:
                    this._readAppleCmapTable(subTable, encoding);
                    break;
                case _TrueTypeCmapFormat.microsoft:
                    this._readMicrosoftCmapTable(subTable, encoding);
                    break;
                case _TrueTypeCmapFormat.trimmed:
                    this._readTrimmedCmapTable(subTable, encoding);
                    break;
            }
        }
    };
    _TrueTypeReader.prototype._readAppleCmapTable = function (subTable, encoding) {
        var tableInfo = this._getTable('cmap');
        this._offset = tableInfo._offset + subTable._offset;
        var table = new _TrueTypeAppleCmapSubTable();
        table._format = this._readUInt16(this._offset);
        table._length = this._readUInt16(this._offset);
        table._version = this._readUInt16(this._offset);
        if (this._maxMacIndex === null || typeof this._maxMacIndex === 'undefined') {
            this._maxMacIndex = 0;
        }
        for (var i = 0; i < 256; ++i) {
            var glyphInfo = new _TrueTypeGlyph();
            glyphInfo._index = this._readByte(this._offset);
            glyphInfo._width = this._getWidth(glyphInfo._index);
            glyphInfo._charCode = i;
            this.macintosh.setValue(i, glyphInfo);
            this._addGlyph(glyphInfo, encoding);
            this._maxMacIndex = Math.max(i, this._maxMacIndex);
        }
    };
    _TrueTypeReader.prototype._readMicrosoftCmapTable = function (subTable, encoding) {
        var tableInfo = this._getTable('cmap');
        this._offset = tableInfo._offset + subTable._offset;
        var collection = (encoding === _TrueTypeCmapEncoding.unicode) ? this._microsoft
            : this.macintosh;
        var table = new _TrueTypeMicrosoftCmapSubTable();
        table._format = this._readUInt16(this._offset);
        table._length = this._readUInt16(this._offset);
        table._version = this._readUInt16(this._offset);
        table._segCountX2 = this._readUInt16(this._offset);
        table._searchRange = this._readUInt16(this._offset);
        table._entrySelector = this._readUInt16(this._offset);
        table._rangeShift = this._readUInt16(this._offset);
        var segCount = table._segCountX2 / 2;
        table._endCount = this._readUShortArray(segCount);
        table._reservedPad = this._readUInt16(this._offset);
        table._startCount = this._readUShortArray(segCount);
        table._idDelta = this._readUShortArray(segCount);
        table._idRangeOffset = this._readUShortArray(segCount);
        var length = (table._length / 2 - 8) - (segCount * 4);
        table._glyphID = this._readUShortArray(length);
        var codeOffset = 0;
        var index = 0;
        for (var j = 0; j < segCount; j++) {
            for (var k = table._startCount[Number.parseInt(j.toString(), 10)]; k <=
                table._endCount[Number.parseInt(j.toString(), 10)] && k !== 65535; k++) {
                if (table._idRangeOffset[Number.parseInt(j.toString(), 10)] === 0) {
                    codeOffset = (k + table._idDelta[Number.parseInt(j.toString(), 10)]) & 65535;
                }
                else {
                    index = j + table._idRangeOffset[Number.parseInt(j.toString(), 10)] / 2 - segCount +
                        k - table._startCount[Number.parseInt(j.toString(), 10)];
                    if (index >= table._glyphID.length) {
                        continue;
                    }
                    codeOffset = (table._glyphID[Number.parseInt(index.toString(), 10)] +
                        table._idDelta[Number.parseInt(j.toString(), 10)]) & 65535;
                }
                var glyph = new _TrueTypeGlyph();
                glyph._index = codeOffset;
                glyph._width = this._getWidth(glyph._index);
                var id = (encoding === _TrueTypeCmapEncoding.symbol) ? ((k & 0xff00) === 0xf000 ? k & 0xff : k) : k;
                glyph._charCode = id;
                collection.setValue(id, glyph);
                this._addGlyph(glyph, encoding);
            }
        }
    };
    _TrueTypeReader.prototype._readTrimmedCmapTable = function (subTable, encoding) {
        var tableInfo = this._getTable('cmap');
        this._offset = tableInfo._offset + subTable._offset;
        var table = new _TrueTypeTrimmedCmapSubTable();
        table._format = this._readUInt16(this._offset);
        table._length = this._readUInt16(this._offset);
        table._version = this._readUInt16(this._offset);
        table._firstCode = this._readUInt16(this._offset);
        table._entryCount = this._readUInt16(this._offset);
        for (var i = 0; i < table._entryCount; ++i) {
            var glyphInfo = new _TrueTypeGlyph();
            glyphInfo._index = this._readUInt16(this._offset);
            glyphInfo._width = this._getWidth(glyphInfo._index);
            glyphInfo._charCode = i + table._firstCode;
            this.macintosh.setValue(i, glyphInfo);
            this._addGlyph(glyphInfo, encoding);
            this._maxMacIndex = Math.max(i, this._maxMacIndex);
        }
    };
    _TrueTypeReader.prototype._initializeFontName = function (nameTable) {
        for (var i = 0; i < nameTable._recordsCount; i++) {
            var record = nameTable._nameRecords[Number.parseInt(i.toString(), 10)];
            if (record._nameID === 1) {
                this._metrics._fontFamily = record._name;
            }
            else if (record._nameID === 6) {
                this._metrics._postScriptName = record._name;
            }
            if (this._metrics._fontFamily !== null && typeof this._metrics._fontFamily !== 'undefined' &&
                this._metrics._postScriptName !== null && typeof this._metrics._postScriptName !== 'undefined') {
                break;
            }
        }
    };
    _TrueTypeReader.prototype._getTable = function (name) {
        var table = new _TrueTypeTableInfo();
        var obj;
        if (this._tableDirectory.containsKey(name)) {
            obj = this._tableDirectory.getValue(name);
        }
        if (obj !== null && typeof obj !== 'undefined') {
            table = obj;
        }
        return table;
    };
    _TrueTypeReader.prototype._getWidth = function (glyphCode) {
        glyphCode = (glyphCode < this._width.length) ? glyphCode : this._width.length - 1;
        return this._width[Number.parseInt(glyphCode.toString(), 10)];
    };
    _TrueTypeReader.prototype._getCmapEncoding = function (platformID, encodingID) {
        var format = _TrueTypeCmapEncoding.unknown;
        if (platformID === _TrueTypePlatformID.microsoft &&
            encodingID === _TrueTypeMicrosoftEncodingID.undefined) {
            format = _TrueTypeCmapEncoding.symbol;
        }
        else if (platformID === _TrueTypePlatformID.microsoft
            && encodingID === _TrueTypeMicrosoftEncodingID.unicode) {
            format = _TrueTypeCmapEncoding.unicode;
        }
        else if (platformID === _TrueTypePlatformID.macintosh
            && encodingID === _TrueTypeMacintoshEncodingID.roman) {
            format = _TrueTypeCmapEncoding.macintosh;
        }
        return format;
    };
    _TrueTypeReader.prototype._addGlyph = function (glyph, encoding) {
        var collection = null;
        switch (encoding) {
            case _TrueTypeCmapEncoding.unicode:
                collection = this._microsoftGlyphs;
                break;
            case _TrueTypeCmapEncoding.macintosh:
            case _TrueTypeCmapEncoding.symbol:
                collection = this._macintoshGlyphs;
                break;
        }
        collection.setValue(glyph._index, glyph);
    };
    _TrueTypeReader.prototype._initializeMetrics = function (nameTable, headTable, horizontalHeadTable, os2Table, postTable, cmapTables) {
        this._initializeFontName(nameTable);
        var bSymbol = false;
        for (var i = 0; i < cmapTables.length; i++) {
            var subTable = cmapTables[Number.parseInt(i.toString(), 10)];
            var encoding = this._getCmapEncoding(subTable._platformID, subTable._encodingID);
            if (encoding === _TrueTypeCmapEncoding.symbol) {
                bSymbol = true;
                break;
            }
        }
        this._metrics._isSymbol = bSymbol;
        this._metrics._macStyle = headTable._macStyle;
        this._metrics._isFixedPitch = (postTable._isFixedPitch !== 0);
        this._metrics._italicAngle = postTable._italicAngle;
        var factor = 1000 / headTable._unitsPerEm;
        this._metrics._winAscent = os2Table._sTypoAscender * factor;
        this._metrics._macAscent = horizontalHeadTable._ascender * factor;
        this._metrics._capHeight = (os2Table._sCapHeight !== 0) ? os2Table._sCapHeight : 0.7 * headTable._unitsPerEm * factor;
        this._metrics._winDescent = os2Table._sTypoDescender * factor;
        this._metrics._macDescent = horizontalHeadTable._descender * factor;
        this._metrics._leading = (os2Table._sTypoAscender - os2Table._sTypoDescender + os2Table._sTypoLineGap) * factor;
        this._metrics._lineGap = Math.ceil(horizontalHeadTable._lineGap * factor);
        var left = headTable._xMin * factor;
        var top = Math.ceil(this._metrics._macAscent + this._metrics._lineGap);
        var right = headTable._xMax * factor;
        var bottom = this._metrics._macDescent;
        this._metrics._fontBox = [left, top, right, bottom];
        this._metrics._stemV = 80;
        this._metrics._widthTable = this._updateWidth();
        this._metrics._contains = this._tableDirectory.containsKey('CFF');
        this._metrics._subScriptSizeFactor = headTable._unitsPerEm / os2Table._ySubscriptYSize;
        this._metrics._superscriptSizeFactor = headTable._unitsPerEm / os2Table._ySuperscriptYSize;
    };
    _TrueTypeReader.prototype._updateWidth = function () {
        var count = 256;
        var bytes = [];
        if (this._metrics._isSymbol) {
            for (var i = 0; i < count; i++) {
                var glyphInfo = this._getGlyph(String.fromCharCode(Number.parseInt(i.toString(), 10)));
                bytes[Number.parseInt(i.toString(), 10)] = (glyphInfo._empty) ? 0 : glyphInfo._width;
            }
        }
        else {
            var byteToProcess = [];
            var unknown = '?';
            var space = String.fromCharCode(32);
            for (var i = 0; i < count; i++) {
                byteToProcess[0] = Number.parseInt(i.toString(), 10);
                var text = this._getString(byteToProcess, 0, byteToProcess.length);
                var ch = (text.length > 0) ? text[0] : unknown;
                var glyphInfo = this._getGlyph(ch);
                if (!glyphInfo._empty) {
                    bytes[Number.parseInt(i.toString(), 10)] = glyphInfo._width;
                }
                else {
                    glyphInfo = this._getGlyph(space);
                    bytes[Number.parseInt(i.toString(), 10)] = (glyphInfo._empty) ? 0 : glyphInfo._width;
                }
            }
        }
        return bytes;
    };
    _TrueTypeReader.prototype._getDefaultGlyph = function () {
        var glyph = this._getGlyph(_StringTokenizer._whiteSpace);
        return glyph;
    };
    _TrueTypeReader.prototype._getString = function (byteToProcess, start, length) {
        var result = '';
        for (var index = 0; index < length; index++) {
            result += String.fromCharCode(byteToProcess[index + start]);
        }
        return result;
    };
    _TrueTypeReader.prototype._setOffset = function (offset) {
        this._offset = offset;
    };
    _TrueTypeReader.prototype._readFontProgram = function (chars) {
        var glyphChars = this._getGlyphChars(chars);
        var locaTable = this._readLocaTable(this._bIsLocaShort);
        if (glyphChars && glyphChars._size() < chars._size()) {
            this._missedGlyphs = chars._size() - glyphChars._size();
        }
        this._updateGlyphChars(glyphChars, locaTable);
        var result1 = this._generateGlyphTable(glyphChars, locaTable, null, null);
        var glyphTableSize = result1.glyphTableSize;
        var newLocaTable = result1.newLocaTable;
        var newGlyphTable = result1.newGlyphTable;
        var result2 = this._updateLocaTable(newLocaTable, this._bIsLocaShort);
        var newLocaSize = result2.newLocaSize;
        var newLocaUpdated = result2.newLocaUpdated;
        var fontProgram = this._getFontProgram(newLocaUpdated, newGlyphTable, glyphTableSize, newLocaSize);
        return fontProgram;
    };
    _TrueTypeReader.prototype._generateGlyphTable = function (glyphChars, locaTable, newLocaTable, newGlyphTable) {
        newLocaTable = [];
        var activeGlyphs = glyphChars.keys();
        activeGlyphs.sort(function (a, b) { return a - b; });
        var glyphSize = 0;
        for (var i = 0; i < activeGlyphs.length; i++) {
            var glyphIndex = activeGlyphs[Number.parseInt(i.toString(), 10)];
            if (locaTable._offsets.length > 0) {
                glyphSize += locaTable._offsets[glyphIndex + 1] - locaTable._offsets[Number.parseInt(glyphIndex.toString(), 10)];
            }
        }
        var glyphSizeAligned = this._align(glyphSize);
        newGlyphTable = [];
        for (var i = 0; i < glyphSizeAligned; i++) {
            newGlyphTable.push(0);
        }
        var nextGlyphOffset = 0;
        var nextGlyphIndex = 0;
        var table = this._getTable('glyf');
        for (var i = 0; i < locaTable._offsets.length; i++) {
            newLocaTable.push(nextGlyphOffset);
            if (nextGlyphIndex < activeGlyphs.length && activeGlyphs[Number.parseInt(nextGlyphIndex.toString(), 10)] === i) {
                ++nextGlyphIndex;
                newLocaTable[Number.parseInt(i.toString(), 10)] = nextGlyphOffset;
                var oldGlyphOffset = locaTable._offsets[Number.parseInt(i.toString(), 10)];
                var oldNextGlyphOffset = locaTable._offsets[i + 1] - oldGlyphOffset;
                if (oldNextGlyphOffset > 0) {
                    this._offset = table._offset + oldGlyphOffset;
                    var result = this._read(newGlyphTable, nextGlyphOffset, oldNextGlyphOffset);
                    newGlyphTable = result.buffer;
                    nextGlyphOffset += oldNextGlyphOffset;
                }
            }
        }
        return { glyphTableSize: glyphSize, newLocaTable: newLocaTable, newGlyphTable: newGlyphTable };
    };
    _TrueTypeReader.prototype._readLocaTable = function (bShort) {
        var tableInfo = this._getTable('loca');
        this._offset = tableInfo._offset;
        var table = new _TrueTypeLocaTable();
        var buffer = [];
        if (bShort) {
            var len = tableInfo._length / 2;
            buffer = [];
            for (var i = 0; i < len; i++) {
                buffer[Number.parseInt(i.toString(), 10)] = this._readUInt16(this._offset) * 2;
            }
        }
        else {
            var len = tableInfo._length / 4;
            buffer = [];
            for (var i = 0; i < len; i++) {
                buffer[Number.parseInt(i.toString(), 10)] = this._readUInt32(this._offset);
            }
        }
        table._offsets = buffer;
        return table;
    };
    _TrueTypeReader.prototype._updateGlyphChars = function (glyphChars, locaTable) {
        if (!glyphChars.containsKey(0)) {
            glyphChars.setValue(0, 0);
        }
        var clone = new Dictionary();
        var glyphCharKeys = glyphChars.keys();
        for (var i = 0; i < glyphCharKeys.length; i++) {
            clone.setValue(glyphCharKeys[Number.parseInt(i.toString(), 10)], glyphChars.getValue(glyphCharKeys[Number.parseInt(i.toString(), 10)]));
        }
        for (var i = 0; i < glyphCharKeys.length; i++) {
            var nextKey = glyphCharKeys[Number.parseInt(i.toString(), 10)];
            this._processCompositeGlyph(glyphChars, nextKey, locaTable);
        }
    };
    _TrueTypeReader.prototype._processCompositeGlyph = function (glyphChars, glyph, locaTable) {
        if (glyph < locaTable._offsets.length - 1) {
            var glyphOffset = locaTable._offsets[Number.parseInt(glyph.toString(), 10)];
            if (glyphOffset !== locaTable._offsets[glyph + 1]) {
                var tableInfo = this._getTable('glyf');
                this._offset = tableInfo._offset + glyphOffset;
                var glyphHeader = new _TrueTypeGlyphHeader();
                glyphHeader.numberOfContours = this._readInt16(this._offset);
                glyphHeader.xMin = this._readInt16(this._offset);
                glyphHeader.yMin = this._readInt16(this._offset);
                glyphHeader.xMax = this._readInt16(this._offset);
                glyphHeader.yMax = this._readInt16(this._offset);
                if (glyphHeader.numberOfContours < 0) {
                    var skipBytes = 0;
                    var entry = true;
                    while (entry) {
                        var flags = this._readUInt16(this._offset);
                        var glyphIndex = this._readUInt16(this._offset);
                        if (!glyphChars.containsKey(glyphIndex)) {
                            glyphChars.setValue(glyphIndex, 0);
                        }
                        if ((flags & _TrueTypeCompositeGlyphFlag.MoreComponents) === 0) {
                            break;
                        }
                        skipBytes = ((flags & _TrueTypeCompositeGlyphFlag.Arg1And2AreWords) !== 0) ? 4 : 2;
                        if ((flags & _TrueTypeCompositeGlyphFlag.WeHaveScale) !== 0) {
                            skipBytes += 2;
                        }
                        else if ((flags & _TrueTypeCompositeGlyphFlag.WeHaveAnXyScale) !== 0) {
                            skipBytes += 4;
                        }
                        else if ((flags & _TrueTypeCompositeGlyphFlag.WeHaveTwoByTwo) !== 0) {
                            skipBytes += 2 * 4;
                        }
                        this._offset += skipBytes;
                    }
                }
            }
        }
    };
    _TrueTypeReader.prototype._updateLocaTable = function (newLocaTable, bLocaIsShort) {
        var size = (bLocaIsShort) ? newLocaTable.length * 2 : newLocaTable.length * 4;
        var count = this._align(size);
        var writer = new _BigEndianWriter(count);
        for (var i = 0; i < newLocaTable.length; i++) {
            var value = newLocaTable[Number.parseInt(i.toString(), 10)];
            if (bLocaIsShort) {
                value /= 2;
                writer._writeShort(value);
            }
            else {
                writer._writeInt(value);
            }
        }
        return { newLocaUpdated: writer._data, newLocaSize: size };
    };
    _TrueTypeReader.prototype._align = function (value) {
        return (value + 3) & (~3);
    };
    _TrueTypeReader.prototype._getFontProgram = function (newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {
        var result = this._getFontProgramLength(newLocaTableOut, newGlyphTable, 0);
        var fontProgramLength = result.fontProgramLength;
        var table = result.table;
        var writer = new _BigEndianWriter(fontProgramLength);
        writer._writeInt(0x10000);
        writer._writeShort(table);
        var entrySelector = this._entrySelectors[Number.parseInt(table.toString(), 10)];
        writer._writeShort((1 << (entrySelector & 31)) * 16);
        writer._writeShort(entrySelector);
        writer._writeShort((table - (1 << (entrySelector & 31))) * 16);
        this._writeCheckSums(writer, table, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize);
        this._writeGlyphs(writer, newLocaTableOut, newGlyphTable);
        return writer._data;
    };
    _TrueTypeReader.prototype._getFontProgramLength = function (newLocaTableOut, newGlyphTable, table) {
        var fontProgramLength = 0;
        if (newLocaTableOut !== null && typeof newLocaTableOut !== 'undefined' && newLocaTableOut.length > 0 &&
            newGlyphTable !== null && typeof newGlyphTable !== 'undefined' && newGlyphTable.length > 0) {
            table = 2;
            var tableNames = this._tableNames;
            for (var i = 0; i < tableNames.length; i++) {
                var tableName = tableNames[Number.parseInt(i.toString(), 10)];
                if (tableName !== 'glyf' && tableName !== 'loca') {
                    var tableInfo = this._getTable(tableName);
                    if (!tableInfo._empty) {
                        ++table;
                        fontProgramLength += this._align(tableInfo._length);
                    }
                }
            }
            fontProgramLength += newLocaTableOut.length;
            fontProgramLength += newGlyphTable.length;
            var usedTablesSize = table * 16 + (3 * 4);
            fontProgramLength += usedTablesSize;
        }
        return { fontProgramLength: fontProgramLength, table: table };
    };
    _TrueTypeReader.prototype._getGlyphChars = function (chars) {
        var dictionary = new Dictionary();
        if (chars !== null && typeof chars !== 'undefined') {
            var charKeys = chars.keys();
            for (var i = 0; i < charKeys.length; i++) {
                var ch = charKeys[Number.parseInt(i.toString(), 10)];
                var glyph = this._getGlyph(ch);
                if (!glyph._empty) {
                    dictionary.setValue(glyph._index, ch.charCodeAt(0));
                }
            }
        }
        return dictionary;
    };
    _TrueTypeReader.prototype._writeCheckSums = function (writer, table, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {
        if (writer !== null && typeof writer !== 'undefined' && newLocaTableOut !== null && typeof newLocaTableOut !== 'undefined' &&
            newLocaTableOut.length > 0 && newGlyphTable !== null && typeof newGlyphTable !== 'undefined' && newGlyphTable.length > 0) {
            var tableNames = this._tableNames;
            var usedTablesSize = table * 16 + (3 * 4);
            var nextTableSize = 0;
            for (var i = 0; i < tableNames.length; i++) {
                var tableName = tableNames[Number.parseInt(i.toString(), 10)];
                var tableInfo = this._getTable(tableName);
                if (tableInfo._empty) {
                    continue;
                }
                writer._writeString(tableName);
                if (tableName === 'glyf') {
                    var checksum = this._calculateCheckSum(newGlyphTable);
                    writer._writeInt(checksum);
                    nextTableSize = glyphTableSize;
                }
                else if (tableName === 'loca') {
                    var checksum = this._calculateCheckSum(newLocaTableOut);
                    writer._writeInt(checksum);
                    nextTableSize = locaTableSize;
                }
                else {
                    writer._writeInt(tableInfo._checksum);
                    nextTableSize = tableInfo._length;
                }
                writer._writeUInt(usedTablesSize);
                writer._writeUInt(nextTableSize);
                usedTablesSize += this._align(nextTableSize);
            }
        }
    };
    _TrueTypeReader.prototype._calculateCheckSum = function (bytes) {
        var pos = 0;
        var byte1 = 0;
        var byte2 = 0;
        var byte3 = 0;
        var byte4 = 0;
        var result = 0;
        if (bytes !== null && typeof bytes !== 'undefined' && bytes.length > 0) {
            for (var i = 0; i < (bytes.length + 1) / 4; i++) {
                byte4 += (bytes[pos++] & 255);
                byte3 += (bytes[pos++] & 255);
                byte2 += (bytes[pos++] & 255);
                byte1 += (bytes[pos++] & 255);
            }
            result = byte1;
            result += (byte2 << 8);
            result += (byte3 << 16);
            result += (byte4 << 24);
        }
        return result;
    };
    _TrueTypeReader.prototype._writeGlyphs = function (writer, newLocaTable, newGlyphTable) {
        if (writer !== null && typeof writer !== 'undefined' && newLocaTable !== null && typeof newLocaTable !== 'undefined' &&
            newLocaTable.length > 0 && newGlyphTable !== null && typeof newGlyphTable !== 'undefined' && newGlyphTable.length > 0) {
            var tableNames = this._tableNames;
            for (var i = 0; i < tableNames.length; i++) {
                var tableName = tableNames[Number.parseInt(i.toString(), 10)];
                var tableInfo = this._getTable(tableName);
                if (tableInfo._empty) {
                    continue;
                }
                if (tableName === 'glyf') {
                    writer._writeBytes(newGlyphTable);
                }
                else if (tableName === 'loca') {
                    writer._writeBytes(newLocaTable);
                }
                else {
                    var count = this._align(tableInfo._length);
                    var buff = [];
                    for (var i_1 = 0; i_1 < count; i_1++) {
                        buff.push(0);
                    }
                    this._offset = tableInfo._offset;
                    var result = this._read(buff, 0, tableInfo._length);
                    writer._writeBytes(result.buffer);
                }
            }
        }
    };
    _TrueTypeReader.prototype._read = function (buffer, index, count) {
        var written = 0;
        if (buffer !== null && typeof buffer !== 'undefined' && buffer.length > 0) {
            var read = 0;
            do {
                for (var i = 0; (i < count - written) && (this._offset + i < this._fontData.length); i++) {
                    buffer[index + i] = this._fontData[this._offset + i];
                }
                read = count - written;
                this._offset += read;
                written += read;
            } while (written < count);
        }
        return { buffer: buffer, written: written };
    };
    _TrueTypeReader.prototype._createInternals = function () {
        this._metrics = new _TrueTypeMetrics();
        var nameTable = this._readNameTable();
        var headTable = this._readHeadTable();
        this._bIsLocaShort = (headTable._indexToLocalFormat === 0);
        var horizontalHeadTable = this._readHorizontalHeaderTable();
        var os2Table = this._readOS2Table();
        var postTable = this._readPostTable();
        this._width = this._readWidthTable(horizontalHeadTable._numberOfHMetrics, headTable._unitsPerEm);
        var subTables = this._readCmapTable();
        this._initializeMetrics(nameTable, headTable, horizontalHeadTable, os2Table, postTable, subTables);
    };
    _TrueTypeReader.prototype._getGlyph = function (charCode) {
        if (typeof charCode === 'number') {
            var obj1 = null;
            if (!this._metrics._isSymbol && this._microsoftGlyphs !== null) {
                if (this._microsoftGlyphs.containsKey(charCode)) {
                    obj1 = this._microsoftGlyphs.getValue(charCode);
                }
            }
            else if (this._metrics._isSymbol && this._macintoshGlyphs !== null) {
                if (this._macintoshGlyphs.containsKey(charCode)) {
                    obj1 = this._macintoshGlyphs.getValue(charCode);
                }
            }
            var glyph = (obj1 !== null) ? obj1 : this._getDefaultGlyph();
            return glyph;
        }
        else {
            var obj = null;
            var code = charCode.charCodeAt(0);
            if (!this._metrics._isSymbol && this._microsoft !== null) {
                if (this._microsoft.containsKey(code)) {
                    obj = this._microsoft.getValue(code);
                    if (code !== _StringTokenizer._whiteSpace.charCodeAt(0)) {
                        this._isFontPresent = true;
                    }
                }
                else if (code !== _StringTokenizer._whiteSpace.charCodeAt(0)) {
                    this._isFontPresent = false;
                }
            }
            else if (this._metrics._isSymbol && this.macintosh !== null || this._isMacFont) {
                if (this._maxMacIndex !== 0) {
                    code %= this._maxMacIndex + 1;
                }
                else {
                    code = ((code & 0xff00) === 0xf000 ? code & 0xff : code);
                }
                if (this.macintosh.containsKey(code)) {
                    obj = this.macintosh.getValue(code);
                    this._isFontPresent = true;
                }
            }
            if (charCode === _StringTokenizer._whiteSpace && obj === null) {
                obj = new _TrueTypeGlyph();
            }
            var glyph = (obj !== null) ? obj : this._getDefaultGlyph();
            return glyph;
        }
    };
    _TrueTypeReader.prototype._readString = function (length, isUnicode) {
        if (typeof isUnicode === 'undefined' || isUnicode === null) {
            return this._readString(length, false);
        }
        else {
            var result = '';
            if (isUnicode) {
                for (var i = 0; i < length; i++) {
                    if (i % 2 !== 0) {
                        result += String.fromCharCode(this._fontData[this._offset]);
                    }
                    this._offset += 1;
                }
            }
            else {
                for (var i = 0; i < length; i++) {
                    result += String.fromCharCode(this._fontData[this._offset]);
                    this._offset += 1;
                }
            }
            return result;
        }
    };
    _TrueTypeReader.prototype._readFixed = function (offset) {
        var integer = this._readInt16(offset);
        var sFraction = this._readInt16(offset + 2);
        var fraction = sFraction / 16384;
        return integer + fraction;
    };
    _TrueTypeReader.prototype._readInt32 = function (offset) {
        var i1 = this._fontData[Number.parseInt(offset.toString(), 10) + 3];
        var i2 = this._fontData[Number.parseInt(offset.toString(), 10) + 2];
        var i3 = this._fontData[Number.parseInt(offset.toString(), 10) + 1];
        var i4 = this._fontData[Number.parseInt(offset.toString(), 10)];
        this._offset += 4;
        return i1 + (i2 << 8) + (i3 << 16) + (i4 << 24);
    };
    _TrueTypeReader.prototype._readUInt32 = function (offset) {
        var i1 = this._fontData[Number.parseInt(offset.toString(), 10) + 3];
        var i2 = this._fontData[Number.parseInt(offset.toString(), 10) + 2];
        var i3 = this._fontData[Number.parseInt(offset.toString(), 10) + 1];
        var i4 = this._fontData[Number.parseInt(offset.toString(), 10)];
        this._offset += 4;
        return (i1 | i2 << 8 | i3 << 16 | i4 << 24);
    };
    _TrueTypeReader.prototype._readInt16 = function (offset) {
        var result = (this._fontData[Number.parseInt(offset.toString(), 10)] << 8) +
            this._fontData[Number.parseInt(offset.toString(), 10) + 1];
        result = result & (1 << 15) ? result - 0x10000 : result;
        this._offset += 2;
        return result;
    };
    _TrueTypeReader.prototype._readInt64 = function (offset) {
        var low = this._readInt32(offset + 4);
        var n = this._readInt32(offset) * 4294967296.0 + low;
        if (low < 0) {
            n += 4294967296;
        }
        return n;
    };
    _TrueTypeReader.prototype._readUInt16 = function (offset) {
        var result = (this._fontData[Number.parseInt(offset.toString(), 10)] << 8) |
            this._fontData[Number.parseInt(offset.toString(), 10) + 1];
        this._offset += 2;
        return result;
    };
    _TrueTypeReader.prototype._readUShortArray = function (length) {
        var buffer = [];
        for (var i = 0; i < length; i++) {
            buffer[Number.parseInt(i.toString(), 10)] = this._readUInt16(this._offset);
        }
        return buffer;
    };
    _TrueTypeReader.prototype._readBytes = function (length) {
        var result = [];
        for (var i = 0; i < length; i++) {
            result.push(this._fontData[Number.parseInt(this._offset.toString(), 10)]);
            this._offset += 1;
        }
        return result;
    };
    _TrueTypeReader.prototype._readByte = function (offset) {
        var result = this._fontData[Number.parseInt(offset.toString(), 10)];
        this._offset += 1;
        return result;
    };
    _TrueTypeReader.prototype._getCharacterWidth = function (code) {
        var glyphInfo = this._getGlyph(code);
        glyphInfo = (!glyphInfo._empty) ? glyphInfo : this._getDefaultGlyph();
        var codeWidth = (!glyphInfo._empty) ? glyphInfo._width : 0;
        return codeWidth;
    };
    _TrueTypeReader.prototype._convertString = function (text) {
        var glyph = '';
        if (text !== null && text !== undefined && text.length > 0) {
            for (var k = 0; k < text.length; k++) {
                var ch = text[Number.parseInt(k.toString(), 10)];
                var glyphInfo = this._getGlyph(ch);
                if (!glyphInfo._empty) {
                    glyph += String.fromCharCode(glyphInfo._index);
                }
            }
        }
        return glyph;
    };
    return _TrueTypeReader;
}());
var _TrueTypeNameRecord = /** @class */ (function () {
    function _TrueTypeNameRecord() {
    }
    return _TrueTypeNameRecord;
}());
var _TrueTypeMetrics = /** @class */ (function () {
    function _TrueTypeMetrics() {
    }
    Object.defineProperty(_TrueTypeMetrics.prototype, "_isItalic", {
        get: function () {
            return ((this._macStyle & 2) !== 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_TrueTypeMetrics.prototype, "_isBold", {
        get: function () {
            return ((this._macStyle & 1) !== 0);
        },
        enumerable: true,
        configurable: true
    });
    return _TrueTypeMetrics;
}());
var _TrueTypeLongHorMetric = /** @class */ (function () {
    function _TrueTypeLongHorMetric() {
    }
    return _TrueTypeLongHorMetric;
}());
var _TrueTypeGlyph = /** @class */ (function () {
    function _TrueTypeGlyph() {
    }
    Object.defineProperty(_TrueTypeGlyph.prototype, "_empty", {
        get: function () {
            return (this._index === this._width && this._width === this._charCode && this._charCode === 0);
        },
        enumerable: true,
        configurable: true
    });
    return _TrueTypeGlyph;
}());
var _TrueTypeLocaTable = /** @class */ (function () {
    function _TrueTypeLocaTable() {
    }
    return _TrueTypeLocaTable;
}());
var _TrueTypeGlyphHeader = /** @class */ (function () {
    function _TrueTypeGlyphHeader() {
    }
    return _TrueTypeGlyphHeader;
}());
var _BigEndianWriter = /** @class */ (function () {
    function _BigEndianWriter(capacity) {
        this.int32Size = 4;
        this.int16Size = 2;
        this.int64Size = 8;
        this._bufferLength = capacity;
        this._buffer = [];
    }
    Object.defineProperty(_BigEndianWriter.prototype, "_data", {
        get: function () {
            if (this._buffer.length < this._bufferLength) {
                var length_1 = this._bufferLength - this._buffer.length;
                for (var i = 0; i < length_1; i++) {
                    this._buffer.push(0);
                }
            }
            return this._buffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_BigEndianWriter.prototype, "_position", {
        get: function () {
            if (typeof this._internalPosition === 'undefined' || this._internalPosition === null) {
                this._internalPosition = 0;
            }
            return this._internalPosition;
        },
        enumerable: true,
        configurable: true
    });
    _BigEndianWriter.prototype._writeShort = function (value) {
        var bytes = [((value & 0x0000ff00) >> 8), value & 0x000000ff];
        this._flush(bytes);
    };
    _BigEndianWriter.prototype._writeInt = function (value) {
        var bytes = [(value & 0xff000000) >> 24, (value & 0x00ff0000) >> 16, (value & 0x0000ff00) >> 8, value & 0x000000ff];
        this._flush(bytes);
    };
    _BigEndianWriter.prototype._writeUInt = function (value) {
        var buff = [(value & 0xff000000) >> 24, (value & 0x00ff0000) >> 16, (value & 0x0000ff00) >> 8, value & 0x000000ff];
        this._flush(buff);
    };
    _BigEndianWriter.prototype._writeString = function (value) {
        if (value !== null && typeof value !== 'undefined') {
            var bytes = [];
            for (var i = 0; i < value.length; i++) {
                bytes.push(value.charCodeAt(i));
            }
            this._flush(bytes);
        }
    };
    _BigEndianWriter.prototype._writeBytes = function (value) {
        this._flush(value);
    };
    _BigEndianWriter.prototype._flush = function (buff) {
        if (buff !== null && typeof buff !== 'undefined') {
            var position = this._position;
            for (var i = 0; i < buff.length; i++) {
                this._buffer[Number.parseInt(position.toString(), 10)] = buff[Number.parseInt(i.toString(), 10)];
                position++;
            }
            this._internalPosition += buff.length;
        }
    };
    return _BigEndianWriter;
}());

var _UnicodeTrueTypeFont = /** @class */ (function () {
    function _UnicodeTrueTypeFont(base64String, size) {
        this._nameString = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        this._isEmbedFont = false;
        this._cmapPrefix = '/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap' + '\r\n' + '/CIDSystemInfo << /Registry (Adobe)/Ordering (UCS)/Supplement 0>> def\n/CMapName ' + '/Adobe-Identity-UCS def\n/CMapType 2 def\n1 beginCodeSpacerange' + '\r\n';
        this._cmapEndCodeSpaceRange = 'endCodeSpacerange' + '\r\n';
        this._cmapBeginRange = 'beginbfrange' + '\r\n';
        this._cmapEndRange = 'endbfrange' + '\r\n';
        this._cmapSuffix = 'endbfrange\nendcmap\nCMapName currentdict ' + '/CMap defineresource pop\nend end' + '\r\n';
        if (base64String === null || typeof base64String === 'undefined') {
            throw new Error('ArgumentNullException:base64String');
        }
        this._fontSize = size;
        this._fontString = base64String;
        this._Initialize();
    }
    _UnicodeTrueTypeFont.prototype._beginSave = function () {
        this._descendantFontBeginSave();
        this._cmapBeginSave();
        this._fontDictionaryBeginSave();
        this._fontProgramBeginSave();
        if (this._fontDescriptor) {
            this._fontDescriptor.update('FontFile2', this._fontProgram);
            this._fontDescriptor._updated = true;
            this._fontDescriptor._isFont = true;
        }
    };
    _UnicodeTrueTypeFont.prototype._descendantFontBeginSave = function () {
        if (this._usedChars !== null && typeof this._usedChars !== 'undefined' && this._usedChars._size() > 0) {
            var width = this._getDescendantWidth(); // eslint-disable-line
            if (width !== null) {
                this._descendantFont.set('W', width);
            }
        }
    };
    _UnicodeTrueTypeFont.prototype._fontDictionaryBeginSave = function () {
        if (this._usedChars !== null && typeof this._usedChars !== 'undefined' && this._usedChars._size() > 0) {
            this._fontDictionary.update('ToUnicode', this._cmap);
        }
    };
    _UnicodeTrueTypeFont.prototype._Initialize = function () {
        var byteArray = _decode(this._fontString);
        this._fontData = byteArray;
        this._ttfReader = new _TrueTypeReader(this._fontData);
        this._ttfMetrics = this._ttfReader._metrics;
    };
    _UnicodeTrueTypeFont.prototype._createInternals = function () {
        this._fontDictionary = new _PdfDictionary();
        this._descendantFont = new _PdfDictionary();
        this._metrics = new _PdfFontMetrics();
        this._ttfReader._createInternals();
        this._usedChars = null;
        var data = []; // eslint-disable-line
        this._fontProgram = new _PdfStream(data, new _PdfDictionary());
        this._cmap = new _PdfStream(data, new _PdfDictionary());
        this._ttfMetrics = this._ttfReader._metrics;
        this._initializeMetrics();
        this._subsetName = this._getFontName();
        this._createDescendantFont();
        this._createFontDictionary();
    };
    _UnicodeTrueTypeFont.prototype._getInternals = function () {
        return this._fontDictionary;
    };
    _UnicodeTrueTypeFont.prototype._initializeMetrics = function () {
        var ttfMetrics = this._ttfReader._metrics;
        this._metrics._ascent = ttfMetrics._macAscent;
        this._metrics._descent = ttfMetrics._macDescent;
        this._metrics._height = ttfMetrics._macAscent - ttfMetrics._macDescent + ttfMetrics._lineGap;
        this._metrics._name = ttfMetrics._fontFamily;
        this._metrics._postScriptName = ttfMetrics._postScriptName;
        this._metrics._size = this._fontSize;
        this._metrics._widthTable = new _StandardWidthTable(ttfMetrics._widthTable);
        this._metrics._lineGap = ttfMetrics._lineGap;
        this._metrics._subScriptSizeFactor = ttfMetrics._subScriptSizeFactor;
        this._metrics._superscriptSizeFactor = ttfMetrics._superscriptSizeFactor;
        this._metrics._isBold = ttfMetrics._isBold;
    };
    _UnicodeTrueTypeFont.prototype._getFontName = function () {
        var builder = '';
        for (var i = 0; i < 6; i++) {
            var index = Math.floor(Math.random() * (25 - 0 + 1)) + 0;
            builder += this._nameString[Number.parseInt(index.toString(), 10)];
        }
        builder += '+';
        builder += this._ttfReader._metrics._postScriptName;
        return builder.toString();
    };
    _UnicodeTrueTypeFont.prototype._createDescendantFont = function () {
        this._descendantFont = new _PdfDictionary();
        this._descendantFont._updated = true;
        this._descendantFont.set('Type', new _PdfName('Font'));
        this._descendantFont.set('Subtype', new _PdfName('CIDFontType2'));
        this._descendantFont.set('BaseFont', new _PdfName(this._subsetName));
        this._descendantFont.set('CIDToGIDMap', new _PdfName('Identity'));
        this._descendantFont.set('DW', 1000);
        this._fontDescriptor = this._createFontDescriptor();
        this._descendantFont.set('FontDescriptor', this._fontDescriptor);
        var systemInfo = this._createSystemInfo();
        this._descendantFont.set('CIDSystemInfo', systemInfo);
        this._descendantFont._isFont = true;
    };
    _UnicodeTrueTypeFont.prototype._createFontDescriptor = function () {
        var descriptor = new _PdfDictionary();
        var metrics = this._ttfReader._metrics;
        descriptor.set('Type', new _PdfName('FontDescriptor'));
        descriptor.set('FontName', new _PdfName(this._subsetName));
        descriptor.set('Flags', this._getDescriptorFlags());
        descriptor.set('FontBBox', this._getBoundBox());
        descriptor.set('MissingWidth', metrics._widthTable[32]);
        descriptor.set('StemV', metrics._stemV);
        descriptor.set('ItalicAngle', metrics._italicAngle);
        descriptor.set('CapHeight', metrics._capHeight);
        descriptor.set('Ascent', metrics._winAscent);
        descriptor.set('Descent', metrics._winDescent);
        descriptor.set('Leading', metrics._leading);
        descriptor.set('AvgWidth', metrics._widthTable[32]);
        descriptor.set('MaxWidth', metrics._widthTable[32]);
        descriptor.set('XHeight', 0);
        descriptor.set('StemH', 0);
        descriptor._updated = true;
        return descriptor;
    };
    _UnicodeTrueTypeFont.prototype._generateFontProgram = function () {
        var fontProgram = [];
        this._usedChars = (this._usedChars === null || typeof this._usedChars === 'undefined') ? new Dictionary()
            : this._usedChars;
        this._ttfReader._setOffset(0);
        fontProgram = this._ttfReader._readFontProgram(this._usedChars);
        this._fontProgram._clearStream();
        this._fontProgram._writeBytes(fontProgram);
    };
    _UnicodeTrueTypeFont.prototype._getBoundBox = function () {
        var rect = this._ttfReader._metrics._fontBox;
        var width = Math.abs(rect[2] - rect[0]);
        var height = Math.abs(rect[1] - rect[3]);
        var rectangle = [rect[0], rect[3], width, height];
        return rectangle;
    };
    _UnicodeTrueTypeFont.prototype._cmapBeginSave = function () {
        this._generateCmap();
    };
    _UnicodeTrueTypeFont.prototype._fontProgramBeginSave = function () {
        this._generateFontProgram();
    };
    _UnicodeTrueTypeFont.prototype._toHexString = function (n, isCaseChange) {
        var s = n.toString(16);
        if (isCaseChange) {
            s = s.toUpperCase();
        }
        return '<0000'.substring(0, 5 - s.length) + s + '>';
    };
    _UnicodeTrueTypeFont.prototype._generateCmap = function () {
        if (this._usedChars !== null && typeof this._usedChars !== 'undefined' && this._usedChars._size() > 0) {
            var glyphChars = this._ttfReader._getGlyphChars(this._usedChars);
            if (glyphChars._size() > 0) {
                var keys = glyphChars.keys().sort();
                var first = keys[0];
                var last = keys[keys.length - 1];
                var middlePart = this._toHexString(first, false) + this._toHexString(last, false) + '\r\n';
                var builder = '';
                builder += this._cmapPrefix;
                builder += middlePart;
                builder += this._cmapEndCodeSpaceRange;
                var nextRange = 0;
                for (var i = 0; i < keys.length; i++) {
                    if (nextRange === 0) {
                        if (i !== 0) {
                            builder += this._cmapEndRange;
                        }
                        nextRange = Math.min(100, keys.length - i);
                        builder += nextRange;
                        builder += ' ';
                        builder += this._cmapBeginRange;
                    }
                    nextRange -= 1;
                    var key = keys[Number.parseInt(i.toString(), 10)];
                    builder += this._toHexString(key, true) + this._toHexString(key, true);
                    builder += this._toHexString(glyphChars.getValue(key), true) + '\n';
                }
                builder += this._cmapSuffix;
                this._cmap._clearStream();
                this._cmap._write(builder);
            }
        }
    };
    _UnicodeTrueTypeFont.prototype._createFontDictionary = function () {
        this._fontDictionary._updated = true;
        this._fontDictionary.set('Type', _PdfName.get('Font'));
        this._fontDictionary.set('Subtype', _PdfName.get('Type0'));
        this._fontDictionary.set('BaseFont', new _PdfName(this._subsetName));
        this._fontDictionary.set('Encoding', _PdfName.get('Identity-H'));
        this._fontDictionary.set('DescendantFonts', this._descendantFont);
        this._fontDictionary._isFont = true;
        this._fontDictionary._currentObj = this;
    };
    _UnicodeTrueTypeFont.prototype._createSystemInfo = function () {
        var systemInfo = new _PdfDictionary();
        systemInfo._updated = true;
        systemInfo.set('Registry', 'Adobe');
        systemInfo.set('Ordering', 'Identity');
        systemInfo.set('Supplement', 0);
        return systemInfo;
    };
    _UnicodeTrueTypeFont.prototype._getDescriptorFlags = function () {
        var flags = 0;
        var metrics = this._ttfReader._metrics;
        if (metrics._isFixedPitch) {
            flags |= _FontDescriptorFlag.fixedPitch;
        }
        if (metrics._isSymbol) {
            flags |= _FontDescriptorFlag.symbolic;
        }
        else {
            flags |= _FontDescriptorFlag.nonSymbolic;
        }
        if (metrics._isItalic) {
            flags |= _FontDescriptorFlag.italic;
        }
        if (metrics._isBold) {
            flags |= _FontDescriptorFlag.forceBold;
        }
        return flags;
    };
    _UnicodeTrueTypeFont.prototype._getCharacterWidth = function (charCode) {
        var codeWidth = this._ttfReader._getCharacterWidth(charCode);
        return codeWidth;
    };
    _UnicodeTrueTypeFont.prototype._setSymbols = function (text) {
        if (text !== null && typeof text !== 'undefined') {
            if (this._usedChars === null || typeof this._usedChars === 'undefined') {
                this._usedChars = new Dictionary();
            }
            for (var i = 0; i < text.length; i++) {
                var ch = text[Number.parseInt(i.toString(), 10)];
                this._usedChars.setValue(ch, String.fromCharCode(0));
            }
        }
    };
    _UnicodeTrueTypeFont.prototype._getDescendantWidth = function () {
        var array = new Array(); // eslint-disable-line
        if (this._usedChars !== null && typeof this._usedChars !== 'undefined' && this._usedChars._size() > 0) {
            var glyphInfo = [];
            var keys = this._usedChars.keys();
            for (var i = 0; i < keys.length; i++) {
                var chLen = keys[Number.parseInt(i.toString(), 10)];
                var glyph = this._ttfReader._getGlyph(chLen);
                glyphInfo.push(glyph);
            }
            glyphInfo.sort(function (a, b) { return a._index - b._index; });
            var firstGlyphIndex = 0;
            var lastGlyphIndex = 0;
            var firstGlyphIndexWasSet = false;
            var widthDetails = new Array(); // eslint-disable-line
            for (var i = 0; i < glyphInfo.length; i++) {
                var glyph = glyphInfo[Number.parseInt(i.toString(), 10)];
                if (!firstGlyphIndexWasSet) {
                    firstGlyphIndexWasSet = true;
                    firstGlyphIndex = glyph._index;
                    lastGlyphIndex = glyph._index - 1;
                }
                if ((lastGlyphIndex + 1 !== glyph._index || (i + 1 === glyphInfo.length)) && glyphInfo.length > 1) {
                    array.push(Number(firstGlyphIndex));
                    if (i !== 0) {
                        array.push(widthDetails);
                    }
                    firstGlyphIndex = glyph._index;
                    widthDetails = new Array(); // eslint-disable-line
                }
                widthDetails.push(Number(glyph._width));
                if ((i + 1) === glyphInfo.length) {
                    array.push(Number(firstGlyphIndex));
                    array.push(widthDetails);
                }
                lastGlyphIndex = glyph._index;
            }
        }
        return array;
    };
    return _UnicodeTrueTypeFont;
}());

var _ArabicShapeRenderer = /** @class */ (function () {
    /**
     * Creates an instance of the 'ArabicShapeRenderer' class.
     *
     * @private
     */
    function _ArabicShapeRenderer() {
        this._arabicCharTable = [['\u0621', '\uFE80'], ['\u0622', '\uFE81', '\uFE82'], ['\u0623', '\uFE83', '\uFE84'],
            ['\u0624', '\uFE85', '\uFE86'], ['\u0625', '\uFE87', '\uFE88'], ['\u0626', '\uFE89', '\uFE8A', '\uFE8B', '\uFE8C'],
            ['\u0627', '\uFE8D', '\uFE8E'], ['\u0628', '\uFE8F', '\uFE90', '\uFE91', '\uFE92'], ['\u0629', '\uFE93', '\uFE94'],
            ['\u062A', '\uFE95', '\uFE96', '\uFE97', '\uFE98'], ['\u062B', '\uFE99', '\uFE9A', '\uFE9B', '\uFE9C'],
            ['\u062C', '\uFE9D', '\uFE9E', '\uFE9F', '\uFEA0'], ['\u062D', '\uFEA1', '\uFEA2', '\uFEA3', '\uFEA4'],
            ['\u062E', '\uFEA5', '\uFEA6', '\uFEA7', '\uFEA8'], ['\u062F', '\uFEA9', '\uFEAA'], ['\u0630', '\uFEAB', '\uFEAC'],
            ['\u0631', '\uFEAD', '\uFEAE'], ['\u0632', '\uFEAF', '\uFEB0'], ['\u0633', '\uFEB1', '\uFEB2', '\uFEB3', '\uFEB4'],
            ['\u0634', '\uFEB5', '\uFEB6', '\uFEB7', '\uFEB8'], ['\u0635', '\uFEB9', '\uFEBA', '\uFEBB', '\uFEBC'],
            ['\u0636', '\uFEBD', '\uFEBE', '\uFEBF', '\uFEC0'], ['\u0637', '\uFEC1', '\uFEC2', '\uFEC3', '\uFEC4'],
            ['\u0638', '\uFEC5', '\uFEC6', '\uFEC7', '\uFEC8'], ['\u0639', '\uFEC9', '\uFECA', '\uFECB', '\uFECC'],
            ['\u063A', '\uFECD', '\uFECE', '\uFECF', '\uFED0'], ['\u0640', '\u0640', '\u0640', '\u0640', '\u0640'],
            ['\u0641', '\uFED1', '\uFED2', '\uFED3', '\uFED4'], ['\u0642', '\uFED5', '\uFED6', '\uFED7', '\uFED8'],
            ['\u0643', '\uFED9', '\uFEDA', '\uFEDB', '\uFEDC'], ['\u0644', '\uFEDD', '\uFEDE', '\uFEDF', '\uFEE0'],
            ['\u0645', '\uFEE1', '\uFEE2', '\uFEE3', '\uFEE4'], ['\u0646', '\uFEE5', '\uFEE6', '\uFEE7', '\uFEE8'],
            ['\u0647', '\uFEE9', '\uFEEA', '\uFEEB', '\uFEEC'], ['\u0648', '\uFEED', '\uFEEE'],
            ['\u0649', '\uFEEF', '\uFEF0', '\uFBE8', '\uFBE9'], ['\u064A', '\uFEF1', '\uFEF2', '\uFEF3', '\uFEF4'],
            ['\u0671', '\uFB50', '\uFB51'], ['\u0679', '\uFB66', '\uFB67', '\uFB68', '\uFB69'],
            ['\u067A', '\uFB5E', '\uFB5F', '\uFB60', '\uFB61'], ['\u067B', '\uFB52', '\uFB53', '\uFB54', '\uFB55'],
            ['\u067E', '\uFB56', '\uFB57', '\uFB58', '\uFB59'], ['\u067F', '\uFB62', '\uFB63', '\uFB64', '\uFB65'],
            ['\u0680', '\uFB5A', '\uFB5B', '\uFB5C', '\uFB5D'], ['\u0683', '\uFB76', '\uFB77', '\uFB78', '\uFB79'],
            ['\u0684', '\uFB72', '\uFB73', '\uFB74', '\uFB75'], ['\u0686', '\uFB7A', '\uFB7B', '\uFB7C', '\uFB7D'],
            ['\u0687', '\uFB7E', '\uFB7F', '\uFB80', '\uFB81'], ['\u0688', '\uFB88', '\uFB89'], ['\u068C', '\uFB84', '\uFB85'],
            ['\u068D', '\uFB82', '\uFB83'], ['\u068E', '\uFB86', '\uFB87'], ['\u0691', '\uFB8C', '\uFB8D'], ['\u0698', '\uFB8A', '\uFB8B'],
            ['\u06A4', '\uFB6A', '\uFB6B', '\uFB6C', '\uFB6D'], ['\u06A6', '\uFB6E', '\uFB6F', '\uFB70', '\uFB71'],
            ['\u06A9', '\uFB8E', '\uFB8F', '\uFB90', '\uFB91'], ['\u06AD', '\uFBD3', '\uFBD4', '\uFBD5', '\uFBD6'],
            ['\u06AF', '\uFB92', '\uFB93', '\uFB94', '\uFB95'], ['\u06B1', '\uFB9A', '\uFB9B', '\uFB9C', '\uFB9D'],
            ['\u06B3', '\uFB96', '\uFB97', '\uFB98', '\uFB99'], ['\u06BA', '\uFB9E', '\uFB9F'],
            ['\u06BB', '\uFBA0', '\uFBA1', '\uFBA2', '\uFBA3'], ['\u06BE', '\uFBAA', '\uFBAB', '\uFBAC', '\uFBAD'],
            ['\u06C0', '\uFBA4', '\uFBA5'], ['\u06C1', '\uFBA6', '\uFBA7', '\uFBA8', '\uFBA9'], ['\u06C5', '\uFBE0', '\uFBE1'],
            ['\u06C6', '\uFBD9', '\uFBDA'], ['\u06C7', '\uFBD7', '\uFBD8'], ['\u06C8', '\uFBDB', '\uFBDC'], ['\u06C9', '\uFBE2', '\uFBE3'],
            ['\u06CB', '\uFBDE', '\uFBDF'], ['\u06CC', '\uFBFC', '\uFBFD', '\uFBFE', '\uFBFF'],
            ['\u06D0', '\uFBE4', '\uFBE5', '\uFBE6', '\uFBE7'], ['\u06D2', '\uFBAE', '\uFBAF'], ['\u06D3', '\uFBB0', '\uFBB1']
        ];
        this._alef = '\u0627';
        this._alefHamza = '\u0623';
        this._alefHamzaBelow = '\u0625';
        this._alefMadda = '\u0622';
        this._lam = '\u0644';
        this._hamza = '\u0621';
        this._zeroWidthJoiner = '\u200D';
        this._hamzaAbove = '\u0654';
        this._hamzaBelow = '\u0655';
        this._wawHamza = '\u0624';
        this._yehHamza = '\u0626';
        this._waw = '\u0648';
        this._alefsura = '\u0649';
        this._yeh = '\u064A';
        this._farsiYeh = '\u06CC';
        this._shadda = '\u0651';
        this._madda = '\u0653';
        this._lwa = '\uFEFB';
        this._lwawh = '\uFEF7';
        this._lwawhb = '\uFEF9';
        this._lwawm = '\uFEF5';
        this._bwhb = '\u06D3';
        this._fathatan = '\u064B';
        this._superalef = '\u0670';
        this._vowel = 0x1;
        this._arabicMapTable = new Map();
        for (var i = 0; i < this._arabicCharTable.length; i++) {
            this._arabicMapTable.set(this._arabicCharTable[Number.parseInt(i.toString(), 10)][0], this._arabicCharTable[Number.parseInt(i.toString(), 10)]);
        }
    }
    _ArabicShapeRenderer.prototype._getCharacterShape = function (input, index) {
        if ((input >= this._hamza) && (input <= this._bwhb)) {
            var value = [];
            if (this._arabicMapTable.get(input)) {
                value = this._arabicMapTable.get(input);
                return value[index + 1];
            }
        }
        else if (input >= this._lwawm && input <= this._lwa) {
            return (input);
        }
        return input;
    };
    _ArabicShapeRenderer.prototype._shape = function (text) {
        var builder = '';
        var value = '';
        for (var i = 0; i < text.length; i++) {
            var c = text[Number.parseInt(i.toString(), 10)];
            if (c >= '؀' && c <= 'ۿ') {
                value = value + c;
            }
            else {
                if (value.length > 0) {
                    var shapeText = this._doShape(value.toString(), 0);
                    builder = builder + shapeText;
                    value = '';
                }
                builder = builder + c;
            }
        }
        if (value.length > 0) {
            var shapeText = this._doShape(value.toString(), 0);
            builder = builder + shapeText;
        }
        return builder.toString();
    };
    _ArabicShapeRenderer.prototype._doShape = function (input, level) {
        var str = '';
        var ligature = 0;
        var len = 0;
        var i = 0;
        var next = '';
        var previous = new _ArabicShape();
        var present = new _ArabicShape();
        while (i < input.length) {
            next = input[i++];
            ligature = this._ligature(next, present);
            if (ligature === 0) {
                var shapeCount = this._getShapeCount(next);
                len = (shapeCount === 1) ? 0 : 2;
                if (previous._shapes > 2) {
                    len += 1;
                }
                len = len % (present._shapes);
                present._shapeValue = this._getCharacterShape(present._shapeValue, len);
                str = this._append(str, previous, level);
                previous = present;
                present = new _ArabicShape();
                present._shapeValue = next;
                present._shapes = shapeCount;
                present._shapeLigature++;
            }
        }
        len = (previous._shapes > 2) ? 1 : 0;
        len = len % (present._shapes);
        present._shapeValue = this._getCharacterShape(present._shapeValue, len);
        str = this._append(str, previous, level);
        str = this._append(str, present, level);
        return str.toString();
    };
    _ArabicShapeRenderer.prototype._append = function (builder, shape, level) {
        if (shape._shapeValue !== '') {
            builder = builder + shape._shapeValue;
            shape._shapeLigature -= 1;
            if (shape._shapeType !== '') {
                if ((level & this._vowel) === 0) {
                    builder = builder + shape._shapeType;
                    shape._shapeLigature -= 1;
                }
                else {
                    shape._shapeLigature -= 1;
                }
            }
            if (shape._shapeVowel !== '') {
                if ((level & this._vowel) === 0) {
                    builder = builder + shape._shapeVowel;
                    shape._shapeLigature -= 1;
                }
                else {
                    shape._shapeLigature -= 1;
                }
            }
        }
        return builder;
    };
    _ArabicShapeRenderer.prototype._ligature = function (value, shape) {
        if (shape._shapeValue !== '') {
            var result = 0;
            if ((value >= this._fathatan && value <= this._hamzaBelow) || value === this._superalef) {
                result = 1;
                if ((shape._shapeVowel !== '') && (value !== this._shadda)) {
                    result = 2;
                }
                if (value === this._shadda) {
                    if (shape._shapeType === '') {
                        shape._shapeType = this._shadda;
                    }
                    else {
                        return 0;
                    }
                }
                else if (value === this._hamzaBelow) {
                    if (shape._shapeValue === this._alef) {
                        shape._shapeValue = this._alefHamzaBelow;
                        result = 2;
                    }
                    else if (shape._shapeValue === this._lwa) {
                        shape._shapeValue = this._lwawhb;
                        result = 2;
                    }
                    else {
                        shape._shapeType = this._hamzaBelow;
                    }
                }
                else if (value === this._hamzaAbove) {
                    if (shape._shapeValue === this._alef) {
                        shape._shapeValue = this._alefHamza;
                        result = 2;
                    }
                    else if (shape._shapeValue === this._lwa) {
                        shape._shapeValue = this._lwawh;
                        result = 2;
                    }
                    else if (shape._shapeValue === this._waw) {
                        shape._shapeValue = this._wawHamza;
                        result = 2;
                    }
                    else if (shape._shapeValue === this._yeh || shape._shapeValue === this._alefsura ||
                        shape._shapeValue === this._farsiYeh) {
                        shape._shapeValue = this._yehHamza;
                        result = 2;
                    }
                    else {
                        shape._shapeType = this._hamzaAbove;
                    }
                }
                else if (value === this._madda) {
                    if (shape._shapeValue === this._alef) {
                        shape._shapeValue = this._alefMadda;
                        result = 2;
                    }
                }
                else {
                    shape._shapeVowel = value;
                }
                if (result === 1) {
                    shape._shapeLigature++;
                }
                return result;
            }
            if (shape._shapeVowel !== '') {
                return 0;
            }
            if (shape._shapeValue === this._lam) {
                if (value === this._alef) {
                    shape._shapeValue = this._lwa;
                    shape._shapes = 2;
                    result = 3;
                }
                else if (value === this._alefHamza) {
                    shape._shapeValue = this._lwawh;
                    shape._shapes = 2;
                    result = 3;
                }
                else if (value === this._alefHamzaBelow) {
                    shape._shapeValue = this._lwawhb;
                    shape._shapes = 2;
                    result = 3;
                }
                else if (value === this._alefMadda) {
                    shape._shapeValue = this._lwawm;
                    shape._shapes = 2;
                    result = 3;
                }
            }
            return result;
        }
        else {
            return 0;
        }
    };
    _ArabicShapeRenderer.prototype._getShapeCount = function (shape) {
        if ((shape >= this._hamza) && (shape <= this._bwhb) && !((shape >= this._fathatan && shape <= this._hamzaBelow)
            || shape === this._superalef)) {
            var c = [];
            if (this._arabicMapTable.get(shape)) {
                c = this._arabicMapTable.get(shape);
                return c.length - 1;
            }
        }
        else if (shape === this._zeroWidthJoiner) {
            return 4;
        }
        return 1;
    };
    return _ArabicShapeRenderer;
}());
var _ArabicShape = /** @class */ (function () {
    function _ArabicShape() {
        this._shapeValue = '';
        this._shapeType = '';
        this._shapeVowel = '';
        this._shapeLigature = 0;
        this._shapes = 1;
    }
    return _ArabicShape;
}());

var _Bidirectional = /** @class */ (function () {
    /**
     * Creates a new instance of the `_Bidirectional` class.
     *
     * @private
     */
    function _Bidirectional() {
        this._indexes = [];
        this._indexLevels = [];
        this._mirroringShape = new Dictionary();
        this._update();
    }
    _Bidirectional.prototype._doMirrorShaping = function (text) {
        var result = [];
        for (var i = 0; i < text.length; i++) {
            if (((this._indexLevels[Number.parseInt(i.toString(), 10)] & 1) === 1)
                && this._mirroringShape.containsKey(text[Number.parseInt(i.toString(), 10)].charCodeAt(0))) {
                var value = text[Number.parseInt(i.toString(), 10)].charCodeAt(0); // eslint-disable-line
                result[Number.parseInt(i.toString(), 10)] = String.fromCharCode(this._mirroringShape.getValue(value));
            }
            else {
                result[Number.parseInt(i.toString(), 10)] = text[Number.parseInt(i.toString(), 10)].toString();
            }
        }
        var res = '';
        for (var j = 0; j < result.length; j++) {
            res = res + result[Number.parseInt(j.toString(), 10)];
        }
        return res;
    };
    _Bidirectional.prototype._getLogicalToVisualString = function (inputText, isRtl) {
        var rtlCharacters = new _RtlCharacters();
        this._indexLevels = rtlCharacters._getVisualOrder(inputText, isRtl);
        this._setDefaultIndexLevel();
        this._doOrder(0, this._indexLevels.length - 1);
        var text = this._doMirrorShaping(inputText);
        var resultBuilder = '';
        for (var i = 0; i < this._indexes.length; i++) {
            var index = this._indexes[Number.parseInt(i.toString(), 10)];
            resultBuilder += text[Number.parseInt(index.toString(), 10)];
        }
        return resultBuilder.toString();
    };
    _Bidirectional.prototype._setDefaultIndexLevel = function () {
        for (var i = 0; i < this._indexLevels.length; i++) {
            this._indexes[Number.parseInt(i.toString(), 10)] = i;
        }
    };
    _Bidirectional.prototype._doOrder = function (sIndex, eIndex) {
        var max = this._indexLevels[Number.parseInt(sIndex.toString(), 10)];
        var min = max;
        var odd = max;
        var even = max;
        for (var i = sIndex + 1; i <= eIndex; ++i) {
            var data = this._indexLevels[Number.parseInt(i.toString(), 10)];
            if (data > max) {
                max = data;
            }
            else if (data < min) {
                min = data;
            }
            odd &= data;
            even |= data;
        }
        if ((even & 1) === 0) {
            return;
        }
        if ((odd & 1) === 1) {
            this._reArrange(sIndex, eIndex + 1);
            return;
        }
        min |= 1;
        while (max >= min) {
            var pstart = sIndex;
            while (true) { // eslint-disable-line
                while (pstart <= eIndex) {
                    if (this._indexLevels[Number.parseInt(pstart.toString(), 10)] >= max) {
                        break;
                    }
                    pstart += 1;
                }
                if (pstart > eIndex) {
                    break;
                }
                var pend = pstart + 1;
                while (pend <= eIndex) {
                    if (this._indexLevels[Number.parseInt(pend.toString(), 10)] < max) {
                        break;
                    }
                    pend += 1;
                }
                this._reArrange(pstart, pend);
                pstart = pend + 1;
            }
            max -= 1;
        }
    };
    _Bidirectional.prototype._reArrange = function (i, j) {
        var length = (i + j) / 2;
        --j;
        for (; i < length; ++i, --j) {
            var temp = this._indexes[Number.parseInt(i.toString(), 10)];
            this._indexes[Number.parseInt(i.toString(), 10)] = this._indexes[Number.parseInt(j.toString(), 10)];
            this._indexes[Number.parseInt(j.toString(), 10)] = temp;
        }
    };
    _Bidirectional.prototype._update = function () {
        this._mirroringShape.setValue(40, 41);
        this._mirroringShape.setValue(41, 40);
        this._mirroringShape.setValue(60, 62);
        this._mirroringShape.setValue(62, 60);
        this._mirroringShape.setValue(91, 93);
        this._mirroringShape.setValue(93, 91);
        this._mirroringShape.setValue(123, 125);
        this._mirroringShape.setValue(125, 123);
        this._mirroringShape.setValue(171, 187);
        this._mirroringShape.setValue(187, 171);
        this._mirroringShape.setValue(8249, 8250);
        this._mirroringShape.setValue(8250, 8249);
        this._mirroringShape.setValue(8261, 8262);
        this._mirroringShape.setValue(8262, 8261);
        this._mirroringShape.setValue(8317, 8318);
        this._mirroringShape.setValue(8318, 8317);
        this._mirroringShape.setValue(8333, 8334);
        this._mirroringShape.setValue(8334, 8333);
        this._mirroringShape.setValue(8712, 8715);
        this._mirroringShape.setValue(8713, 8716);
        this._mirroringShape.setValue(8714, 8717);
        this._mirroringShape.setValue(8715, 8712);
        this._mirroringShape.setValue(8716, 8713);
        this._mirroringShape.setValue(8717, 8714);
        this._mirroringShape.setValue(8725, 10741);
        this._mirroringShape.setValue(8764, 8765);
        this._mirroringShape.setValue(8765, 8764);
        this._mirroringShape.setValue(8771, 8909);
        this._mirroringShape.setValue(8786, 8787);
        this._mirroringShape.setValue(8787, 8786);
        this._mirroringShape.setValue(8788, 8789);
        this._mirroringShape.setValue(8789, 8788);
        this._mirroringShape.setValue(8804, 8805);
        this._mirroringShape.setValue(8805, 8804);
        this._mirroringShape.setValue(8806, 8807);
        this._mirroringShape.setValue(8807, 8806);
        this._mirroringShape.setValue(8808, 8809);
        this._mirroringShape.setValue(8809, 8808);
        this._mirroringShape.setValue(8810, 8811);
        this._mirroringShape.setValue(8811, 8810);
        this._mirroringShape.setValue(8814, 8815);
        this._mirroringShape.setValue(8815, 8814);
        this._mirroringShape.setValue(8816, 8817);
        this._mirroringShape.setValue(8817, 8816);
        this._mirroringShape.setValue(8818, 8819);
        this._mirroringShape.setValue(8819, 8818);
        this._mirroringShape.setValue(8820, 8821);
        this._mirroringShape.setValue(8821, 8820);
        this._mirroringShape.setValue(8822, 8823);
        this._mirroringShape.setValue(8823, 8822);
        this._mirroringShape.setValue(8824, 8825);
        this._mirroringShape.setValue(8825, 8824);
        this._mirroringShape.setValue(8826, 8827);
        this._mirroringShape.setValue(8827, 8826);
        this._mirroringShape.setValue(8828, 8829);
        this._mirroringShape.setValue(8829, 8828);
        this._mirroringShape.setValue(8830, 8831);
        this._mirroringShape.setValue(8831, 8830);
        this._mirroringShape.setValue(8832, 8833);
        this._mirroringShape.setValue(8833, 8832);
        this._mirroringShape.setValue(8834, 8835);
        this._mirroringShape.setValue(8835, 8834);
        this._mirroringShape.setValue(8836, 8837);
        this._mirroringShape.setValue(8837, 8836);
        this._mirroringShape.setValue(8838, 8839);
        this._mirroringShape.setValue(8839, 8838);
        this._mirroringShape.setValue(8840, 8841);
        this._mirroringShape.setValue(8841, 8840);
        this._mirroringShape.setValue(8842, 8843);
        this._mirroringShape.setValue(8843, 8842);
        this._mirroringShape.setValue(8847, 8848);
        this._mirroringShape.setValue(8848, 8847);
        this._mirroringShape.setValue(8849, 8850);
        this._mirroringShape.setValue(8850, 8849);
        this._mirroringShape.setValue(8856, 10680);
        this._mirroringShape.setValue(8866, 8867);
        this._mirroringShape.setValue(8867, 8866);
        this._mirroringShape.setValue(8870, 10974);
        this._mirroringShape.setValue(8872, 10980);
        this._mirroringShape.setValue(8873, 10979);
        this._mirroringShape.setValue(8875, 10981);
        this._mirroringShape.setValue(8880, 8881);
        this._mirroringShape.setValue(8881, 8880);
        this._mirroringShape.setValue(8882, 8883);
        this._mirroringShape.setValue(8883, 8882);
        this._mirroringShape.setValue(8884, 8885);
        this._mirroringShape.setValue(8885, 8884);
        this._mirroringShape.setValue(8886, 8887);
        this._mirroringShape.setValue(8887, 8886);
        this._mirroringShape.setValue(8905, 8906);
        this._mirroringShape.setValue(8906, 8905);
        this._mirroringShape.setValue(8907, 8908);
        this._mirroringShape.setValue(8908, 8907);
        this._mirroringShape.setValue(8909, 8771);
        this._mirroringShape.setValue(8912, 8913);
        this._mirroringShape.setValue(8913, 8912);
        this._mirroringShape.setValue(8918, 8919);
        this._mirroringShape.setValue(8919, 8918);
        this._mirroringShape.setValue(8920, 8921);
        this._mirroringShape.setValue(8921, 8920);
        this._mirroringShape.setValue(8922, 8923);
        this._mirroringShape.setValue(8923, 8922);
        this._mirroringShape.setValue(8924, 8925);
        this._mirroringShape.setValue(8925, 8924);
        this._mirroringShape.setValue(8926, 8927);
        this._mirroringShape.setValue(8927, 8926);
        this._mirroringShape.setValue(8928, 8929);
        this._mirroringShape.setValue(8929, 8928);
        this._mirroringShape.setValue(8930, 8931);
        this._mirroringShape.setValue(8931, 8930);
        this._mirroringShape.setValue(8932, 8933);
        this._mirroringShape.setValue(8933, 8932);
        this._mirroringShape.setValue(8934, 8935);
        this._mirroringShape.setValue(8935, 8934);
        this._mirroringShape.setValue(8936, 8937);
        this._mirroringShape.setValue(8937, 8936);
        this._mirroringShape.setValue(8938, 8939);
        this._mirroringShape.setValue(8939, 8938);
        this._mirroringShape.setValue(8940, 8941);
        this._mirroringShape.setValue(8941, 8940);
        this._mirroringShape.setValue(8944, 8945);
        this._mirroringShape.setValue(8945, 8944);
        this._mirroringShape.setValue(8946, 8954);
        this._mirroringShape.setValue(8947, 8955);
        this._mirroringShape.setValue(8948, 8956);
        this._mirroringShape.setValue(8950, 8957);
        this._mirroringShape.setValue(8951, 8958);
        this._mirroringShape.setValue(8954, 8946);
        this._mirroringShape.setValue(8955, 8947);
        this._mirroringShape.setValue(8956, 8948);
        this._mirroringShape.setValue(8957, 8950);
        this._mirroringShape.setValue(8958, 8951);
        this._mirroringShape.setValue(8968, 8969);
        this._mirroringShape.setValue(8969, 8968);
        this._mirroringShape.setValue(8970, 8971);
        this._mirroringShape.setValue(8971, 8970);
        this._mirroringShape.setValue(9001, 9002);
        this._mirroringShape.setValue(9002, 9001);
        this._mirroringShape.setValue(10088, 10089);
        this._mirroringShape.setValue(10089, 10088);
        this._mirroringShape.setValue(10090, 10091);
        this._mirroringShape.setValue(10091, 10090);
        this._mirroringShape.setValue(10092, 10093);
        this._mirroringShape.setValue(10093, 10092);
        this._mirroringShape.setValue(10094, 10095);
        this._mirroringShape.setValue(10095, 10094);
        this._mirroringShape.setValue(10096, 10097);
        this._mirroringShape.setValue(10097, 10096);
        this._mirroringShape.setValue(10098, 10099);
        this._mirroringShape.setValue(10099, 10098);
        this._mirroringShape.setValue(10100, 10101);
        this._mirroringShape.setValue(10101, 10100);
        this._mirroringShape.setValue(10197, 10198);
        this._mirroringShape.setValue(10198, 10197);
        this._mirroringShape.setValue(10205, 10206);
        this._mirroringShape.setValue(10206, 10205);
        this._mirroringShape.setValue(10210, 10211);
        this._mirroringShape.setValue(10211, 10210);
        this._mirroringShape.setValue(10212, 10213);
        this._mirroringShape.setValue(10213, 10212);
        this._mirroringShape.setValue(10214, 10215);
        this._mirroringShape.setValue(10215, 10214);
        this._mirroringShape.setValue(10216, 10217);
        this._mirroringShape.setValue(10217, 10216);
        this._mirroringShape.setValue(10218, 10219);
        this._mirroringShape.setValue(10219, 10218);
        this._mirroringShape.setValue(10627, 10628);
        this._mirroringShape.setValue(10628, 10627);
        this._mirroringShape.setValue(10629, 10630);
        this._mirroringShape.setValue(10630, 10629);
        this._mirroringShape.setValue(10631, 10632);
        this._mirroringShape.setValue(10632, 10631);
        this._mirroringShape.setValue(10633, 10634);
        this._mirroringShape.setValue(10634, 10633);
        this._mirroringShape.setValue(10635, 10636);
        this._mirroringShape.setValue(10636, 10635);
        this._mirroringShape.setValue(10637, 10640);
        this._mirroringShape.setValue(10638, 10639);
        this._mirroringShape.setValue(10639, 10638);
        this._mirroringShape.setValue(10640, 10637);
        this._mirroringShape.setValue(10641, 10642);
        this._mirroringShape.setValue(10642, 10641);
        this._mirroringShape.setValue(10643, 10644);
        this._mirroringShape.setValue(10644, 10643);
        this._mirroringShape.setValue(10645, 10646);
        this._mirroringShape.setValue(10646, 10645);
        this._mirroringShape.setValue(10647, 10648);
        this._mirroringShape.setValue(10648, 10647);
        this._mirroringShape.setValue(10680, 8856);
        this._mirroringShape.setValue(10688, 10689);
        this._mirroringShape.setValue(10689, 10688);
        this._mirroringShape.setValue(10692, 10693);
        this._mirroringShape.setValue(10693, 10692);
        this._mirroringShape.setValue(10703, 10704);
        this._mirroringShape.setValue(10704, 10703);
        this._mirroringShape.setValue(10705, 10706);
        this._mirroringShape.setValue(10706, 10705);
        this._mirroringShape.setValue(10708, 10709);
        this._mirroringShape.setValue(10709, 10708);
        this._mirroringShape.setValue(10712, 10713);
        this._mirroringShape.setValue(10713, 10712);
        this._mirroringShape.setValue(10714, 10715);
        this._mirroringShape.setValue(10715, 10714);
        this._mirroringShape.setValue(10741, 8725);
        this._mirroringShape.setValue(10744, 10745);
        this._mirroringShape.setValue(10745, 10744);
        this._mirroringShape.setValue(10748, 10749);
        this._mirroringShape.setValue(10749, 10748);
        this._mirroringShape.setValue(10795, 10796);
        this._mirroringShape.setValue(10796, 10795);
        this._mirroringShape.setValue(10797, 10796);
        this._mirroringShape.setValue(10798, 10797);
        this._mirroringShape.setValue(10804, 10805);
        this._mirroringShape.setValue(10805, 10804);
        this._mirroringShape.setValue(10812, 10813);
        this._mirroringShape.setValue(10813, 10812);
        this._mirroringShape.setValue(10852, 10853);
        this._mirroringShape.setValue(10853, 10852);
        this._mirroringShape.setValue(10873, 10874);
        this._mirroringShape.setValue(10874, 10873);
        this._mirroringShape.setValue(10877, 10878);
        this._mirroringShape.setValue(10878, 10877);
        this._mirroringShape.setValue(10879, 10880);
        this._mirroringShape.setValue(10880, 10879);
        this._mirroringShape.setValue(10881, 10882);
        this._mirroringShape.setValue(10882, 10881);
        this._mirroringShape.setValue(10883, 10884);
        this._mirroringShape.setValue(10884, 10883);
        this._mirroringShape.setValue(10891, 10892);
        this._mirroringShape.setValue(10892, 10891);
        this._mirroringShape.setValue(10897, 10898);
        this._mirroringShape.setValue(10898, 10897);
        this._mirroringShape.setValue(10899, 10900);
        this._mirroringShape.setValue(10900, 10899);
        this._mirroringShape.setValue(10901, 10902);
        this._mirroringShape.setValue(10902, 10901);
        this._mirroringShape.setValue(10903, 10904);
        this._mirroringShape.setValue(10904, 10903);
        this._mirroringShape.setValue(10905, 10906);
        this._mirroringShape.setValue(10906, 10905);
        this._mirroringShape.setValue(10907, 10908);
        this._mirroringShape.setValue(10908, 10907);
        this._mirroringShape.setValue(10913, 10914);
        this._mirroringShape.setValue(10914, 10913);
        this._mirroringShape.setValue(10918, 10919);
        this._mirroringShape.setValue(10919, 10918);
        this._mirroringShape.setValue(10920, 10921);
        this._mirroringShape.setValue(10921, 10920);
        this._mirroringShape.setValue(10922, 10923);
        this._mirroringShape.setValue(10923, 10922);
        this._mirroringShape.setValue(10924, 10925);
        this._mirroringShape.setValue(10925, 10924);
        this._mirroringShape.setValue(10927, 10928);
        this._mirroringShape.setValue(10928, 10927);
        this._mirroringShape.setValue(10931, 10932);
        this._mirroringShape.setValue(10932, 10931);
        this._mirroringShape.setValue(10939, 10940);
        this._mirroringShape.setValue(10940, 10939);
        this._mirroringShape.setValue(10941, 10942);
        this._mirroringShape.setValue(10942, 10941);
        this._mirroringShape.setValue(10943, 10944);
        this._mirroringShape.setValue(10944, 10943);
        this._mirroringShape.setValue(10945, 10946);
        this._mirroringShape.setValue(10946, 10945);
        this._mirroringShape.setValue(10947, 10948);
        this._mirroringShape.setValue(10948, 10947);
        this._mirroringShape.setValue(10949, 10950);
        this._mirroringShape.setValue(10950, 10949);
        this._mirroringShape.setValue(10957, 10958);
        this._mirroringShape.setValue(10958, 10957);
        this._mirroringShape.setValue(10959, 10960);
        this._mirroringShape.setValue(10960, 10959);
        this._mirroringShape.setValue(10961, 10962);
        this._mirroringShape.setValue(10962, 10961);
        this._mirroringShape.setValue(10963, 10964);
        this._mirroringShape.setValue(10964, 10963);
        this._mirroringShape.setValue(10965, 10966);
        this._mirroringShape.setValue(10966, 10965);
        this._mirroringShape.setValue(10974, 8870);
        this._mirroringShape.setValue(10979, 8873);
        this._mirroringShape.setValue(10980, 8872);
        this._mirroringShape.setValue(10981, 8875);
        this._mirroringShape.setValue(10988, 10989);
        this._mirroringShape.setValue(10989, 10988);
        this._mirroringShape.setValue(10999, 11000);
        this._mirroringShape.setValue(11000, 10999);
        this._mirroringShape.setValue(11001, 11002);
        this._mirroringShape.setValue(11002, 11001);
        this._mirroringShape.setValue(12296, 12297);
        this._mirroringShape.setValue(12297, 12296);
        this._mirroringShape.setValue(12298, 12299);
        this._mirroringShape.setValue(12299, 12298);
        this._mirroringShape.setValue(12300, 12301);
        this._mirroringShape.setValue(12301, 12300);
        this._mirroringShape.setValue(12302, 12303);
        this._mirroringShape.setValue(12303, 12302);
        this._mirroringShape.setValue(12304, 12305);
        this._mirroringShape.setValue(12305, 12304);
        this._mirroringShape.setValue(12308, 12309);
        this._mirroringShape.setValue(12309, 12308);
        this._mirroringShape.setValue(12310, 12311);
        this._mirroringShape.setValue(12311, 12310);
        this._mirroringShape.setValue(12312, 12313);
        this._mirroringShape.setValue(12313, 12312);
        this._mirroringShape.setValue(12314, 12315);
        this._mirroringShape.setValue(12315, 12314);
        this._mirroringShape.setValue(65288, 65289);
        this._mirroringShape.setValue(65289, 65288);
        this._mirroringShape.setValue(65308, 65310);
        this._mirroringShape.setValue(65310, 65308);
        this._mirroringShape.setValue(65339, 65341);
        this._mirroringShape.setValue(65341, 65339);
        this._mirroringShape.setValue(65371, 65373);
        this._mirroringShape.setValue(65373, 65371);
        this._mirroringShape.setValue(65375, 65376);
        this._mirroringShape.setValue(65376, 65375);
        this._mirroringShape.setValue(65378, 65379);
        this._mirroringShape.setValue(65379, 65378);
    };
    return _Bidirectional;
}());
var _RtlCharacters = /** @class */ (function () {
    /**
     * Creates an instance of the 'RtlCharacters' class.
     *
     * @private
     */
    function _RtlCharacters() {
        this._type = [];
        this._textOrder = -1;
        this._rtlCharacterTypes = new Array(65536);
        this.L = 0;
        this.lre = 1;
        this.lro = 2;
        this.R = 3;
        this.AL = 4;
        this.rle = 5;
        this.rlo = 6;
        this.pdf = 7;
        this.EN = 8;
        this.ES = 9;
        this.ET = 10;
        this.AN = 11;
        this.CS = 12;
        this.nsm = 13;
        this.BN = 14;
        this.B = 15;
        this.S = 16;
        this.WS = 17;
        this.ON = 18;
        this._charTypes = [
            this.L, this.EN, this.BN, this.ES, this.ES, this.S, this.ET, this.ET, this.B, this.AN, this.AN, this.S, this.CS, this.CS,
            this.WS, this.nsm, this.nsm, this.B, this.BN, 27, this.BN, 28, 30, this.B, 31, 31, this.S, 32, 32, this.WS, 33, 34, this.ON, 35,
            37, this.ET, 38, 42, this.ON, 43, 43, this.ET, 44, 44, this.CS, 45, 45, this.ET, 46, 46, this.CS, 47, 47, this.CS, 48, 57, this.EN,
            58, 58, this.CS, 59, 64, this.ON, 65, 90, this.L, 91, 96, this.ON, 97, 122, this.L, 123, 126, this.ON, 127, 132, this.BN, 133, 133,
            this.B, 134, 159, this.BN, 160, 160, this.CS, 161, 161, this.ON, 162, 165, this.ET, 166, 169, this.ON, 170, 170, this.L, 171, 175,
            this.ON, 176, 177, this.ET, 178, 179, this.EN, 180, 180, this.ON, 181, 181, this.L, 182, 184, this.ON, 185, 185, this.EN, 186, 186,
            this.L, 187, 191, this.ON, 192, 214, this.L, 215, 215, this.ON, 216, 246, this.L, 247, 247, this.ON, 248, 696, this.L, 697, 698,
            this.ON, 699, 705, this.L, 706, 719, this.ON, 720, 721, this.L, 722, 735, this.ON, 736, 740, this.L, 741, 749, this.ON, 750, 750,
            this.L, 751, 767, this.ON, 768, 855, this.nsm, 856, 860, this.L, 861, 879, this.nsm, 880, 883, this.L, 884, 885, this.ON, 886, 893,
            this.L, 894, 894, this.ON, 895, 899, this.L, 900, 901, this.ON, 902, 902, this.L, 903, 903, this.ON, 904, 1013, this.L, 1014, 1014,
            this.ON, 1015, 1154, this.L, 1155, 1158, this.nsm, 1159, 1159, this.L, 1160, 1161, this.nsm, 1162, 1417, this.L, 1418, 1418,
            this.ON, 1419, 1424, this.L, 1425, 1441, this.nsm, 1442, 1442, this.L, 1443, 1465, this.nsm, 1466, 1466, this.L, 1467, 1469,
            this.nsm, 1470, 1470, this.R, 1471, 1471, this.nsm, 1472, 1472, this.R, 1473, 1474, this.nsm, 1475, 1475, this.R, 1476, 1476,
            this.nsm, 1477, 1487, this.L, 1488, 1514, this.R, 1515, 1519, this.L, 1520, 1524, this.R, 1525, 1535, this.L, 1536, 1539, this.AL,
            1540, 1547, this.L, 1548, 1548, this.CS, 1549, 1549, this.AL, 1550, 1551, this.ON, 1552, 1557, this.nsm, 1558, 1562, this.L, 1563,
            1563, this.AL, 1564, 1566, this.L, 1567, 1567, this.AL, 1568, 1568, this.L, 1569, 1594, this.AL, 1595, 1599, this.L, 1600, 1610,
            this.AL, 1611, 1624, this.nsm, 1625, 1631, this.L, 1632, 1641, this.AN, 1642, 1642, this.ET, 1643, 1644, this.AN, 1645, 1647,
            this.AL, 1648, 1648, this.nsm, 1649, 1749, this.AL, 1750, 1756, this.nsm, 1757, 1757, this.AL, 1758, 1764, this.nsm, 1765, 1766,
            this.AL, 1767, 1768, this.nsm, 1769, 1769, this.ON, 1770, 1773, this.nsm, 1774, 1775, this.AL, 1776, 1785, this.EN, 1786, 1805,
            this.AL, 1806, 1806, this.L, 1807, 1807, this.BN, 1808, 1808, this.AL, 1809, 1809, this.nsm, 1810, 1839, this.AL, 1840, 1866,
            this.nsm, 1867, 1868, this.L, 1869, 1871, this.AL, 1872, 1919, this.L, 1920, 1957, this.AL, 1958, 1968, this.nsm, 1969, 1969,
            this.AL, 1970, 2304, this.L, 2305, 2306, this.nsm, 2307, 2363, this.L, 2364, 2364, this.nsm, 2365, 2368, this.L, 2369, 2376,
            this.nsm, 2377, 2380, this.L, 2381, 2381, this.nsm, 2382, 2384, this.L, 2385, 2388, this.nsm, 2389, 2401, this.L, 2402, 2403,
            this.nsm, 2404, 2432, this.L, 2433, 2433, this.nsm, 2434, 2491, this.L, 2492, 2492, this.nsm, 2493, 2496, this.L, 2497, 2500,
            this.nsm, 2501, 2508, this.L, 2509, 2509, this.nsm, 2510, 2529, this.L, 2530, 2531, this.nsm, 2532, 2545, this.L, 2546, 2547,
            this.ET, 2548, 2560, this.L, 2561, 2562, this.nsm, 2563, 2619, this.L, 2620, 2620, this.nsm, 2621, 2624, this.L, 2625, 2626,
            this.nsm, 2627, 2630, this.L, 2631, 2632, this.nsm, 2633, 2634, this.L, 2635, 2637, this.nsm, 2638, 2671, this.L, 2672, 2673,
            this.nsm, 2674, 2688, this.L, 2689, 2690, this.nsm, 2691, 2747, this.L, 2748, 2748, this.nsm, 2749, 2752, this.L, 2753, 2757,
            this.nsm, 2758, 2758, this.L, 2759, 2760, this.nsm, 2761, 2764, this.L, 2765, 2765, this.nsm, 2766, 2785, this.L, 2786, 2787,
            this.nsm, 2788, 2800, this.L, 2801, 2801, this.ET, 2802, 2816, this.L, 2817, 2817, this.nsm, 2818, 2875, this.L, 2876, 2876,
            this.nsm, 2877, 2878, this.L, 2879, 2879, this.nsm, 2880, 2880, this.L, 2881, 2883, this.nsm, 2884, 2892, this.L, 2893, 2893,
            this.nsm, 2894, 2901, this.L, 2902, 2902, this.nsm, 2903, 2945, this.L, 2946, 2946, this.nsm, 2947, 3007, this.L, 3008, 3008,
            this.nsm, 3009, 3020, this.L, 3021, 3021, this.nsm, 3022, 3058, this.L, 3059, 3064, this.ON, 3065, 3065, this.ET, 3066, 3066,
            this.ON, 3067, 3133, this.L, 3134, 3136, this.nsm, 3137, 3141, this.L, 3142, 3144, this.nsm, 3145, 3145, this.L, 3146, 3149,
            this.nsm, 3150, 3156, this.L, 3157, 3158, this.nsm, 3159, 3259, this.L, 3260, 3260, this.nsm, 3261, 3275, this.L, 3276, 3277,
            this.nsm, 3278, 3392, this.L, 3393, 3395, this.nsm, 3396, 3404, this.L, 3405, 3405, this.nsm, 3406, 3529, this.L, 3530, 3530,
            this.nsm, 3531, 3537, this.L, 3538, 3540, this.nsm, 3541, 3541, this.L, 3542, 3542, this.nsm, 3543, 3632, this.L, 3633, 3633,
            this.nsm, 3634, 3635, this.L, 3636, 3642, this.nsm, 3643, 3646, this.L, 3647, 3647, this.ET, 3648, 3654, this.L, 3655, 3662,
            this.nsm, 3663, 3760, this.L, 3761, 3761, this.nsm, 3762, 3763, this.L, 3764, 3769, this.nsm, 3770, 3770, this.L, 3771, 3772,
            this.nsm, 3773, 3783, this.L, 3784, 3789, this.nsm, 3790, 3863, this.L, 3864, 3865, this.nsm, 3866, 3892, this.L, 3893, 3893,
            this.nsm, 3894, 3894, this.L, 3895, 3895, this.nsm, 3896, 3896, this.L, 3897, 3897, this.nsm, 3898, 3901, this.ON, 3902, 3952,
            this.L, 3953, 3966, this.nsm, 3967, 3967, this.L, 3968, 3972, this.nsm, 3973, 3973, this.L, 3974, 3975, this.nsm, 3976, 3983,
            this.L, 3984, 3991, this.nsm, 3992, 3992, this.L, 3993, 4028, this.nsm, 4029, 4037, this.L, 4038, 4038, this.nsm, 4039, 4140,
            this.L, 4141, 4144, this.nsm, 4145, 4145, this.L, 4146, 4146, this.nsm, 4147, 4149, this.L, 4150, 4151, this.nsm, 4152, 4152,
            this.L, 4153, 4153, this.nsm, 4154, 4183, this.L, 4184, 4185, this.nsm, 4186, 5759, this.L, 5760, 5760, this.WS, 5761, 5786,
            this.L, 5787, 5788, this.ON, 5789, 5905, this.L, 5906, 5908, this.nsm, 5909, 5937, this.L, 5938, 5940, this.nsm, 5941, 5969,
            this.L, 5970, 5971, this.nsm, 5972, 6001, this.L, 6002, 6003, this.nsm, 6004, 6070, this.L, 6071, 6077, this.nsm, 6078, 6085,
            this.L, 6086, 6086, this.nsm, 6087, 6088, this.L, 6089, 6099, this.nsm, 6100, 6106, this.L, 6107, 6107, this.ET, 6108, 6108,
            this.L, 6109, 6109, this.nsm, 6110, 6127, this.L, 6128, 6137, this.ON, 6138, 6143, this.L, 6144, 6154, this.ON, 6155, 6157,
            this.nsm, 6158, 6158, this.WS, 6159, 6312, this.L, 6313, 6313, this.nsm, 6314, 6431, this.L, 6432, 6434, this.nsm, 6435, 6438,
            this.L, 6439, 6443, this.nsm, 6444, 6449, this.L, 6450, 6450, this.nsm, 6451, 6456, this.L, 6457, 6459, this.nsm, 6460, 6463,
            this.L, 6464, 6464, this.ON, 6465, 6467, this.L, 6468, 6469, this.ON, 6470, 6623, this.L, 6624, 6655, this.ON, 6656, 8124, this.L,
            8125, 8125, this.ON, 8126, 8126, this.L, 8127, 8129, this.ON, 8130, 8140, this.L, 8141, 8143, this.ON, 8144, 8156, this.L, 8157,
            8159, this.ON, 8160, 8172, this.L, 8173, 8175, this.ON, 8176, 8188, this.L, 8189, 8190, this.ON, 8191, 8191, this.L, 8192, 8202,
            this.WS, 8203, 8205, this.BN, 8206, 8206, this.L, 8207, 8207, this.R, 8208, 8231, this.ON, 8232, 8232, this.WS, 8233, 8233, this.B,
            8234, 8234, this.lre, 8235, 8235, this.rle, 8236, 8236, this.pdf, 8237, 8237, this.lro, 8238, 8238, this.rlo, 8239, 8239, this.WS,
            8240, 8244, this.ET, 8245, 8276, this.ON, 8277, 8278, this.L, 8279, 8279, this.ON, 8280, 8286, this.L, 8287, 8287, this.WS, 8288,
            8291, this.BN, 8292, 8297, this.L, 8298, 8303, this.BN, 8304, 8304, this.EN, 8305, 8307, this.L, 8308, 8313, this.EN, 8314, 8315,
            this.ET, 8316, 8318, this.ON, 8319, 8319, this.L, 8320, 8329, this.EN, 8330, 8331, this.ET, 8332, 8334, this.ON, 8335, 8351,
            this.L, 8352, 8369, this.ET, 8370, 8399, this.L, 8400, 8426, this.nsm, 8427, 8447, this.L, 8448, 8449, this.ON, 8450, 8450, this.L,
            8451, 8454, this.ON, 8455, 8455, this.L, 8456, 8457, this.ON, 8458, 8467, this.L, 8468, 8468, this.ON, 8469, 8469, this.L, 8470,
            8472, this.ON, 8473, 8477, this.L, 8478, 8483, this.ON, 8484, 8484, this.L, 8485, 8485, this.ON, 8486, 8486, this.L, 8487, 8487,
            this.ON, 8488, 8488, this.L, 8489, 8489, this.ON, 8490, 8493, this.L, 8494, 8494, this.ET, 8495, 8497, this.L, 8498, 8498, this.ON,
            8499, 8505, this.L, 8506, 8507, this.ON, 8508, 8511, this.L, 8512, 8516, this.ON, 8517, 8521, this.L, 8522, 8523, this.ON, 8524,
            8530, this.L, 8531, 8543, this.ON, 8544, 8591, this.L, 8592, 8721, this.ON, 8722, 8723, this.ET, 8724, 9013, this.ON, 9014, 9082,
            this.L, 9083, 9108, this.ON, 9109, 9109, this.L, 9110, 9168, this.ON, 9169, 9215, this.L, 9216, 9254, this.ON, 9255, 9279, this.L,
            9280, 9290, this.ON, 9291, 9311, this.L, 9312, 9371, this.EN, 9372, 9449, this.L, 9450, 9450, this.EN, 9451, 9751, this.ON, 9752,
            9752, this.L, 9753, 9853, this.ON, 9854, 9855, this.L, 9856, 9873, this.ON, 9874, 9887, this.L, 9888, 9889, this.ON, 9890, 9984,
            this.L, 9985, 9988, this.ON, 9989, 9989, this.L, 9990, 9993, this.ON, 9994, 9995, this.L, 9996, 10023, this.ON, 10024, 10024,
            this.L, 10025, 10059, this.ON, 10060, 10060, this.L, 10061, 10061, this.ON, 10062, 10062, this.L, 10063, 10066, this.ON, 10067,
            10069, this.L, 10070, 10070, this.ON, 10071, 10071, this.L, 10072, 10078, this.ON, 10079, 10080, this.L, 10081, 10132, this.ON,
            10133, 10135, this.L, 10136, 10159, this.ON, 10160, 10160, this.L, 10161, 10174, this.ON, 10175, 10191, this.L, 10192, 10219,
            this.ON, 10220, 10223, this.L, 10224, 11021, this.ON, 11022, 11903, this.L, 11904, 11929, this.ON, 11930, 11930, this.L, 11931,
            12019, this.ON, 12020, 12031, this.L, 12032, 12245, this.ON, 12246, 12271, this.L, 12272, 12283, this.ON, 12284, 12287, this.L,
            12288, 12288, this.WS, 12289, 12292, this.ON, 12293, 12295, this.L, 12296, 12320, this.ON, 12321, 12329, this.L, 12330, 12335,
            this.nsm, 12336, 12336, this.ON, 12337, 12341, this.L, 12342, 12343, this.ON, 12344, 12348, this.L, 12349, 12351, this.ON, 12352,
            12440, this.L, 12441, 12442, this.nsm, 12443, 12444, this.ON, 12445, 12447, this.L, 12448, 12448, this.ON, 12449, 12538, this.L,
            12539, 12539, this.ON, 12540, 12828, this.L, 12829, 12830, this.ON, 12831, 12879, this.L, 12880, 12895, this.ON, 12896, 12923,
            this.L, 12924, 12925, this.ON, 12926, 12976, this.L, 12977, 12991, this.ON, 12992, 13003, this.L, 13004, 13007, this.ON, 13008,
            13174, this.L, 13175, 13178, this.ON, 13179, 13277, this.L, 13278, 13279, this.ON, 13280, 13310, this.L, 13311, 13311, this.ON,
            13312, 19903, this.L, 19904, 19967, this.ON, 19968, 42127, this.L, 42128, 42182, this.ON, 42183, 64284, this.L, 64285, 64285,
            this.R, 64286, 64286, this.nsm, 64287, 64296, this.R, 64297, 64297, this.ET, 64298, 64310, this.R, 64311, 64311, this.L, 64312,
            64316, this.R, 64317, 64317, this.L, 64318, 64318, this.R, 64319, 64319, this.L, 64320, 64321, this.R, 64322, 64322, this.L, 64323,
            64324, this.R, 64325, 64325, this.L, 64326, 64335, this.R, 64336, 64433, this.AL, 64434, 64466, this.L, 64467, 64829, this.AL,
            64830, 64831, this.ON, 64832, 64847, this.L, 64848, 64911, this.AL, 64912, 64913, this.L, 64914, 64967, this.AL, 64968, 65007,
            this.L, 65008, 65020, this.AL, 65021, 65021, this.ON, 65022, 65023, this.L, 65024, 65039, this.nsm, 65040, 65055, this.L, 65056,
            65059, this.nsm, 65060, 65071, this.L, 65072, 65103, this.ON, 65104, 65104, this.CS, 65105, 65105, this.ON, 65106, 65106, this.CS,
            65107, 65107, this.L, 65108, 65108, this.ON, 65109, 65109, this.CS, 65110, 65118, this.ON, 65119, 65119, this.ET, 65120, 65121,
            this.ON, 65122, 65123, this.ET, 65124, 65126, this.ON, 65127, 65127, this.L, 65128, 65128, this.ON, 65129, 65130, this.ET, 65131,
            65131, this.ON, 65132, 65135, this.L, 65136, 65140, this.AL, 65141, 65141, this.L, 65142, 65276, this.AL, 65277, 65278, this.L,
            65279, 65279, this.BN, 65280, 65280, this.L, 65281, 65282, this.ON, 65283, 65285, this.ET, 65286, 65290, this.ON, 65291, 65291,
            this.ET, 65292, 65292, this.CS, 65293, 65293, this.ET, 65294, 65294, this.CS, 65295, 65295, this.ES, 65296, 65305, this.EN, 65306,
            65306, this.CS, 65307, 65312, this.ON, 65313, 65338, this.L, 65339, 65344, this.ON, 65345, 65370, this.L, 65371, 65381, this.ON,
            65382, 65503, this.L, 65504, 65505, this.ET, 65506, 65508, this.ON, 65509, 65510, this.ET, 65511, 65511, this.L, 65512, 65518,
            this.ON, 65519, 65528, this.L, 65529, 65531, this.BN, 65532, 65533, this.ON, 65534, 65535, this.L
        ];
        for (var i = 0; i < this._charTypes.length; ++i) {
            var start = this._charTypes[Number.parseInt(i.toString(), 10)];
            var end = this._charTypes[++i];
            var b = this._charTypes[++i];
            while (start <= end) {
                this._rtlCharacterTypes[start++] = b;
            }
        }
    }
    _RtlCharacters.prototype._getVisualOrder = function (inputText, isRtl) {
        this._type = this._getCharacterCode(inputText);
        this._textOrder = isRtl ? this.lre : this.L;
        this._doVisualOrder();
        var result = [];
        for (var i = 0; i < this._levels.length; i++) {
            result[Number.parseInt(i.toString(), 10)] = this._levels[Number.parseInt(i.toString(), 10)];
        }
        return result;
    };
    _RtlCharacters.prototype._getCharacterCode = function (text) {
        var characterCodes = [];
        for (var i = 0; i < text.length; i++) {
            var value = text[Number.parseInt(i.toString(), 10)].charCodeAt(0); // eslint-disable-line
            characterCodes[Number.parseInt(i.toString(), 10)] = this._rtlCharacterTypes[Number.parseInt(value.toString(), 10)];
        }
        return characterCodes;
    };
    _RtlCharacters.prototype._setDefaultLevels = function () {
        for (var i = 0; i < this._length; i++) {
            this._levels[Number.parseInt(i.toString(), 10)] = this._textOrder;
        }
    };
    _RtlCharacters.prototype._setLevels = function () {
        this._setDefaultLevels();
        for (var n = 0; n < this._length; ++n) {
            var level = this._levels[Number.parseInt(n.toString(), 10)];
            this._levels[Number.parseInt(n.toString(), 10)] = level;
        }
    };
    _RtlCharacters.prototype._updateLevels = function (index, level, length) {
        if ((level & 1) === 0) {
            for (var i = index; i < length; ++i) {
                if (this._result[Number.parseInt(i.toString(), 10)] === this.R) {
                    this._levels[Number.parseInt(i.toString(), 10)] += 1;
                }
                else if (this._result[Number.parseInt(i.toString(), 10)] !== this.L) {
                    this._levels[Number.parseInt(i.toString(), 10)] += 2;
                }
            }
        }
        else {
            for (var i = index; i < length; ++i) {
                if (this._result[Number.parseInt(i.toString(), 10)] !== this.R) {
                    this._levels[Number.parseInt(i.toString(), 10)] += 1;
                }
            }
        }
    };
    _RtlCharacters.prototype._doVisualOrder = function () {
        this._length = this._type.length;
        this._result = this._type;
        this._levels = [];
        this._setLevels();
        this._length = this._getEmbeddedCharactersLength();
        var preview = this._textOrder;
        var i = 0;
        while (i < this._length) {
            var level = this._levels[Number.parseInt(i.toString(), 10)];
            var preType = ((Math.max(preview, level) & 0x1) === 0) ? this.L : this.R;
            var length_1 = i + 1;
            while (length_1 < this._length && this._levels[Number.parseInt(length_1.toString(), 10)] === level) {
                ++length_1;
            }
            var success = length_1 < this._length ? this._levels[Number.parseInt(length_1.toString(), 10)] : this._textOrder;
            var type = ((Math.max(success, level) & 0x1) === 0) ? this.L : this.R;
            this._check(i, length_1, level, preType, type);
            this._updateLevels(i, level, length_1);
            preview = level;
            i = length_1;
        }
        this._checkEmbeddedCharacters(this._length);
    };
    _RtlCharacters.prototype._getEmbeddedCharactersLength = function () {
        var index = 0;
        for (var i = 0; i < this._length; ++i) {
            if (!(this._type[Number.parseInt(i.toString(), 10)] === this.lre || this._type[Number.parseInt(i.toString(), 10)] === this.rle
                || this._type[Number.parseInt(i.toString(), 10)] === this.lro ||
                this._type[Number.parseInt(i.toString(), 10)] === this.rlo || this._type[Number.parseInt(i.toString(), 10)] === this.pdf
                || this._type[Number.parseInt(i.toString(), 10)] === this.BN)) {
                this._result[Number.parseInt(index.toString(), 10)] = this._result[Number.parseInt(i.toString(), 10)];
                this._levels[Number.parseInt(index.toString(), 10)] = this._levels[Number.parseInt(i.toString(), 10)];
                index++;
            }
        }
        return index;
    };
    _RtlCharacters.prototype._checkEmbeddedCharacters = function (length) {
        for (var i = this._type.length - 1; i >= 0; --i) {
            if (this._type[Number.parseInt(i.toString(), 10)] === this.lre || this._type[Number.parseInt(i.toString(), 10)] === this.rle
                || this._type[Number.parseInt(i.toString(), 10)] === this.lro ||
                this._type[Number.parseInt(i.toString(), 10)] === this.rlo || this._type[Number.parseInt(i.toString(), 10)] === this.pdf
                || this._type[Number.parseInt(i.toString(), 10)] === this.BN) {
                this._result[Number.parseInt(i.toString(), 10)] = this._type[Number.parseInt(i.toString(), 10)];
                this._levels[Number.parseInt(i.toString(), 10)] = -1;
            }
            else {
                length -= 1;
                this._result[Number.parseInt(i.toString(), 10)] = this._result[Number.parseInt(length.toString(), 10)];
                this._levels[Number.parseInt(i.toString(), 10)] = this._levels[Number.parseInt(length.toString(), 10)];
            }
        }
        for (var i = 0; i < this._type.length; i++) {
            if (this._levels[Number.parseInt(i.toString(), 10)] === -1) {
                this._levels[Number.parseInt(i.toString(), 10)] = this._levels[i - 1];
            }
        }
    };
    _RtlCharacters.prototype._check = function (index, length, level, startType, endType) {
        var charType = startType;
        for (var i = index; i < length; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.nsm) {
                this._result[Number.parseInt(i.toString(), 10)] = charType;
            }
            else {
                charType = this._result[Number.parseInt(i.toString(), 10)];
            }
        }
        this._checkEuropeanDigits(index, length, level, startType, endType);
    };
    _RtlCharacters.prototype._checkEuropeanDigits = function (index, length, level, startType, endType) {
        for (var i = index; i < length; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.EN) {
                for (var j = i - 1; j >= index; --j) {
                    if (this._result[Number.parseInt(j.toString(), 10)] === this.L ||
                        this._result[Number.parseInt(j.toString(), 10)] === this.R ||
                        this._result[Number.parseInt(j.toString(), 10)] === this.AL) {
                        if (this._result[Number.parseInt(j.toString(), 10)] === this.AL) {
                            this._result[Number.parseInt(i.toString(), 10)] = this.AN;
                        }
                        break;
                    }
                }
            }
        }
        this._checkArabicCharacters(index, length, level, startType, endType);
    };
    _RtlCharacters.prototype._checkArabicCharacters = function (index, length, level, startType, endType) {
        for (var i = index; i < length; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.AL) {
                this._result[Number.parseInt(i.toString(), 10)] = this.R;
            }
        }
        this._checkEuropeanNumberSeparator(index, length, level, startType, endType);
    };
    _RtlCharacters.prototype._checkEuropeanNumberSeparator = function (index, length, level, startType, endType) {
        for (var i = index + 1; i < length - 1; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.ES ||
                this._result[Number.parseInt(i.toString(), 10)] === this.CS) {
                var preview = this._result[i - 1];
                var success = this._result[i + 1];
                if (preview === this.EN && success === this.EN) {
                    this._result[Number.parseInt(i.toString(), 10)] = this.EN;
                }
                else if (this._result[Number.parseInt(i.toString(), 10)] === this.CS && preview === this.AN && success === this.AN) {
                    this._result[Number.parseInt(i.toString(), 10)] = this.AN;
                }
            }
        }
        this._checkEuropeanNumberTerminator(index, length, level, startType, endType);
    };
    _RtlCharacters.prototype._checkEuropeanNumberTerminator = function (index, length, level, startType, endType) {
        for (var i = index; i < length; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.ET) {
                var s = i;
                var b = [];
                b.push(this.ET);
                var l = this._getLength(s, length, b);
                var data = s === index ? startType : this._result[s - 1];
                if (data !== this.EN) {
                    data = (l === length) ? endType : this._result[Number.parseInt(l.toString(), 10)];
                }
                i = l;
            }
        }
        this._checkOtherNeutrals(index, length, level, startType, endType);
    };
    _RtlCharacters.prototype._checkOtherNeutrals = function (index, length, level, startType, endType) {
        for (var i = index; i < length; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.ES || this._result[Number.parseInt(i.toString(), 10)] === this.ET
                || this._result[Number.parseInt(i.toString(), 10)] === this.CS) {
                this._result[Number.parseInt(i.toString(), 10)] = this.ON;
            }
        }
        this._checkOtherCharacters(index, length, level, startType, endType);
    };
    _RtlCharacters.prototype._checkOtherCharacters = function (index, length, level, startType, endType) {
        for (var i = index; i < length; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.EN) {
                var pst = startType;
                for (var j = i - 1; j >= index; --j) {
                    if (this._result[Number.parseInt(j.toString(), 10)] === this.L ||
                        this._result[Number.parseInt(j.toString(), 10)] === this.R) {
                        pst = this._result[Number.parseInt(j.toString(), 10)];
                        break;
                    }
                }
                if (pst === this.L) {
                    this._result[Number.parseInt(i.toString(), 10)] = this.L;
                }
            }
        }
        this._checkCharacters(index, length, level, startType, endType);
    };
    _RtlCharacters.prototype._getLength = function (index, length, validSet) {
        --index;
        while (++index < length) {
            var t = this._result[Number.parseInt(index.toString(), 10)];
            for (var i = 0; i < validSet.length; ++i) {
                if (t === validSet[Number.parseInt(i.toString(), 10)]) {
                    index = this._getLength(++index, length, validSet);
                }
            }
            return index;
        }
        return length;
    };
    _RtlCharacters.prototype._checkCharacters = function (index, length, level, startType, endType) {
        for (var i = index; i < length; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.WS ||
                this._result[Number.parseInt(i.toString(), 10)] === this.ON ||
                this._result[Number.parseInt(i.toString(), 10)] === this.B ||
                this._result[Number.parseInt(i.toString(), 10)] === this.S) {
                var s = i;
                var byte = [this.B, this.S, this.WS, this.ON];
                var l = this._getLength(s, length, byte);
                var lt = 0;
                var tt = 0;
                var rt = 0;
                if (s === index) {
                    lt = startType;
                }
                else {
                    lt = this._result[s - 1];
                    if (lt === this.AN) {
                        lt = this.R;
                    }
                    else if (lt === this.EN) {
                        lt = this.R;
                    }
                }
                if (l === length) {
                    tt = endType;
                }
                else {
                    tt = this._result[Number.parseInt(l.toString(), 10)];
                    if (tt === this.AN) {
                        tt = this.R;
                    }
                }
                if (lt === tt) {
                    rt = lt;
                }
                else {
                    rt = ((level & 0x1) === 0) ? this.L : this.R;
                }
                for (var j = s; j < l; ++j) {
                    this._result[Number.parseInt(j.toString(), 10)] = rt;
                }
                i = l;
            }
        }
    };
    return _RtlCharacters;
}());

var _RtlRenderer = /** @class */ (function () {
    function _RtlRenderer() {
        this._openBracket = '(';
        this._closeBracket = ')';
    }
    _RtlRenderer.prototype._layout = function (line, font, rtl, wordSpace, format) {
        var result = [];
        if (font !== null && typeof font !== 'undefined' && line !== null && typeof line !== 'undefined') {
            if (font._isUnicode) {
                result = this._customLayout(line, rtl, format, font, wordSpace);
            }
            else {
                result = [];
                result[0] = line;
            }
        }
        return result;
    };
    _RtlRenderer.prototype._splitLayout = function (line, font, rtl, wordSpace, format) {
        var words = [];
        if (font !== null && typeof font !== 'undefined' && line !== null && typeof line !== 'undefined') {
            var system = false;
            if (!system) {
                words = this._customSplitLayout(line, font, rtl, wordSpace, format);
            }
        }
        return words;
    };
    _RtlRenderer.prototype._getGlyphIndex = function (line, font, glyphs) {
        glyphs = [];
        if (font !== null && typeof font !== 'undefined' && line !== null && typeof line !== 'undefined') {
            if (line.length === 0) {
                return { _result: false, _glyphIndex: glyphs };
            }
            var renderer = new _ArabicShapeRenderer();
            var text = renderer._shape(line);
            var internalFont = font._fontInternal;
            var ttfReader = internalFont._ttfReader;
            glyphs = [text.length];
            var i = 0;
            for (var k = 0, len = text.length; k < len; k++) {
                var ch = text[Number.parseInt(k.toString(), 10)];
                var glyphInfo = ttfReader._getGlyph(ch);
                if (glyphInfo !== null && typeof glyphInfo !== 'undefined') {
                    glyphs[i++] = (glyphInfo)._index;
                }
            }
        }
        var unicodeLine = new _UnicodeLine();
        unicodeLine._result = true;
        unicodeLine._glyphIndex = glyphs;
        return unicodeLine;
    };
    _RtlRenderer.prototype._customLayout = function (line, rtl, format, font, wordSpace) {
        if (wordSpace === null || typeof wordSpace === 'undefined') {
            var result = null;
            if (line !== null && typeof line !== 'undefined') {
                if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.none) {
                    var bidi = new _Bidirectional();
                    result = bidi._getLogicalToVisualString(line, rtl);
                }
            }
            return result;
        }
        else {
            var layouted = '';
            var result = [];
            if (line !== null && typeof line !== 'undefined' && font !== null && typeof font !== 'undefined') {
                if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.none) {
                    var renderer = new _ArabicShapeRenderer();
                    var txt = renderer._shape(line);
                    layouted = this._customLayout(txt, rtl, format);
                }
                if (wordSpace) {
                    var words = layouted.split('');
                    var count = words.length;
                    for (var i = 0; i < count; i++) {
                        words[Number.parseInt(i.toString(), 10)] = this._addCharacter(font, words[Number.parseInt(i.toString(), 10)]);
                    }
                    result = words;
                }
                else {
                    result = [];
                    result[0] = this._addCharacter(font, layouted);
                }
            }
            return result;
        }
    };
    _RtlRenderer.prototype._addCharacter = function (font, glyphs) {
        if (font !== null && typeof font !== 'undefined' && glyphs !== null && typeof glyphs !== 'undefined') {
            var internalFont = font._fontInternal;
            var ttfReader = internalFont._ttfReader;
            font._setSymbols(glyphs);
            glyphs = ttfReader._convertString(glyphs);
            var bytes = _stringToUnicodeArray(glyphs);
            glyphs = _bytesToString(bytes);
        }
        return glyphs;
    };
    _RtlRenderer.prototype._customSplitLayout = function (line, font, rtl, wordSpace, format) {
        var words = [];
        if (line !== null && typeof line !== 'undefined') {
            var reversedLine = this._customLayout(line, rtl, format);
            words = reversedLine.split('');
        }
        return words;
    };
    return _RtlRenderer;
}());

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Represents the base class for font objects.`
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF standard font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfFont = /** @class */ (function () {
    function PdfFont(size, style) {
        if (typeof size === 'number' && typeof style === 'undefined') {
            this._size = size;
        }
        else {
            this._size = size;
            this._style = style;
        }
    }
    Object.defineProperty(PdfFont.prototype, "size", {
        /**
         * Gets the size of the PDF font.
         *
         * @returns {number} size.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF standard font
         * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
         * // Gets the font size
         * let size: number = font.size;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFont.prototype, "style", {
        /**
         * Gets the style of the PDF font.
         *
         * @returns {PdfFontStyle} size.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF standard font
         * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.italic);
         * // Gets the font style
         * let style: PdfFontStyle = font.style;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._style;
        },
        /**
         * Sets the style of the PDF font.
         *
         * @param {PdfFontStyle} value to font style.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF standard font
         * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
         * // Sets the font style
         * font.style = PdfFontStyle.italic;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._style = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFont.prototype, "isUnderline", {
        /**
         * Gets the boolean flag indicating whether the font has underline style or not.
         *
         * @returns {boolean} isUnderline.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF standard font
         * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.underline);
         * // Gets the boolean flag indicating whether the font has underline style or not.
         * let underline: boolean = font.isUnderline;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return (this.style & PdfFontStyle.underline) > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFont.prototype, "isStrikeout", {
        /**
         * Gets the boolean flag indicating whether the font has strike out style or not.
         *
         * @returns {boolean} isStrikeout.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF standard font
         * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.strikeout);
         * // Gets the boolean flag indicating whether the font has strike out style or not.
         * let strikeout: boolean = font.isStrikeout;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return (this.style & PdfFontStyle.strikeout) > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFont.prototype, "_metrics", {
        get: function () {
            return this._fontMetrics;
        },
        set: function (value) {
            this._fontMetrics = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFont.prototype, "isBold", {
        /**
         * Gets the boolean flag indicating whether the font has bold style or not.
         *
         * @returns {boolean} isBold.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF standard font
         * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.bold);
         * // Gets the boolean flag indicating whether the font has bold style or not.
         * let bold: boolean = font.isBold;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return ((this.style & PdfFontStyle.bold) > 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFont.prototype, "isItalic", {
        /**
         * Gets the boolean flag indicating whether the font has italic style or not.
         *
         * @returns {boolean} isItalic.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF standard font
         * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.italic);
         * // Gets the boolean flag indicating whether the font has italic style or not.
         * let italic: boolean = font.isItalic;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return ((this.style & PdfFontStyle.italic) > 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFont.prototype, "height", {
        /**
         * Gets the font height.
         *
         * @returns {number} height.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF standard font
         * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.italic);
         * // Gets the font height
         * let height: number = font.height;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._metrics._getHeight();
        },
        enumerable: true,
        configurable: true
    });
    PdfFont.prototype._setInternals = function (internals) {
        if (!internals) {
            throw new Error('ArgumentNullException:internals');
        }
        this._pdfFontInternals = internals;
    };
    PdfFont.prototype._getCharacterCount = function (text, symbols) {
        if (typeof symbols === 'string') {
            var numSymbols = 0;
            var curIndex = 0;
            curIndex = text.indexOf(symbols, curIndex);
            while (curIndex !== -1) {
                numSymbols++;
                curIndex++;
                curIndex = text.indexOf(symbols, curIndex);
            }
            return numSymbols;
        }
        else {
            var count = 0;
            for (var i = 0; i < text.length; i++) {
                if (symbols.indexOf(text[Number.parseInt(i.toString(), 10)]) !== -1) {
                    count++;
                }
            }
            return count;
        }
    };
    PdfFont.prototype.measureString = function (text, arg2, arg3, arg4, arg5) {
        if (typeof text === 'string' && typeof arg2 === 'undefined') {
            return this.measureString(text, null);
        }
        else if (typeof text === 'string' && (arg2 instanceof PdfStringFormat || arg2 === null) &&
            typeof arg3 === 'undefined' && typeof arg4 === 'undefined') {
            var temparg2 = arg2;
            var charactersFitted = 0;
            var linesFilled = 0;
            return this.measureString(text, temparg2, charactersFitted, linesFilled);
        }
        else if (typeof text === 'string' && (arg2 instanceof PdfStringFormat || arg2 === null)
            && typeof arg3 === 'number' && typeof arg4 === 'number') {
            var temparg2 = arg2;
            return this.measureString(text, 0, temparg2, arg3, arg4);
        }
        else if (typeof text === 'string' && typeof arg2 === 'number'
            && (arg3 instanceof PdfStringFormat || arg3 === null) && typeof arg4 === 'number' && typeof arg5 === 'number') {
            var layoutArea = [arg2, 0];
            var temparg3 = arg3;
            return this.measureString(text, layoutArea, temparg3, arg4, arg5);
        }
        else {
            var temparg2 = arg2;
            var temparg3 = arg3;
            var layouter = new _PdfStringLayouter();
            var result = layouter._layout(text, this, temparg3, temparg2);
            arg4 = text.length;
            arg5 = (result._empty) ? 0 : result._lines.length;
            return result._actualSize;
        }
    };
    PdfFont.prototype._applyFormatSettings = function (line, format, width) {
        var realWidth = width;
        if (typeof format !== 'undefined' && format !== null && width > 0) {
            if (format.characterSpacing !== 0) {
                realWidth += (line.length - 1) * format.characterSpacing;
            }
            if (format.wordSpacing !== 0) {
                realWidth += this._getCharacterCount(line, [' ', '\t']) * format.wordSpacing;
            }
        }
        return realWidth;
    };
    return PdfFont;
}());
/**
 * Represents one of the 14 standard fonts.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF standard font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfStandardFont = /** @class */ (function (_super) {
    __extends$1(PdfStandardFont, _super);
    function PdfStandardFont(fontFamily, size, style) {
        var _this = _super.call(this, size, (typeof style === 'undefined') ? PdfFontStyle.regular : style) || this;
        _this._fontFamily = fontFamily;
        _this._checkStyle();
        _this._initializeInternals();
        return _this;
    }
    Object.defineProperty(PdfStandardFont.prototype, "fontFamily", {
        /**
         * Gets the font family of the PDF standard font.
         *
         * @returns {PdfFontFamily} fontFamily.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF standard font
         * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.strikeout);
         * // Gets the font family
         * let fontFamily: PdfFontFamily = font.fontFamily;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._fontFamily;
        },
        enumerable: true,
        configurable: true
    });
    PdfStandardFont.prototype._checkStyle = function () {
        if (this._fontFamily === PdfFontFamily.symbol || this._fontFamily === PdfFontFamily.zapfDingbats) {
            this._style &= ~(PdfFontStyle.bold | PdfFontStyle.italic);
        }
    };
    /**
     * Gets the line width.
     *
     * @param {string} line Line.
     * @param {PdfStringFormat} format String format.
     * @returns {number} width.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF standard font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.regular);
     * // Create a new PDF string format
     * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
     * // Get the text width
     * let width: number = font.getLineWidth('Syncfusion', format);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfStandardFont.prototype.getLineWidth = function (line, format) {
        var width = 0;
        for (var i = 0, len = line.length; i < len; i++) {
            width += this._getCharacterWidthInternal(line[Number.parseInt(i.toString(), 10)]);
        }
        width *= (0.001 * this._metrics._size);
        width = this._applyFormatSettings(line, format, width);
        return width;
    };
    PdfStandardFont.prototype._initializeInternals = function () {
        this._metrics = _PdfStandardFontMetricsFactory._getMetrics(this._fontFamily, this._style, this._size);
        this._dictionary = this._createInternals();
    };
    PdfStandardFont.prototype._createInternals = function () {
        var dictionary = new _PdfDictionary();
        dictionary._updated = true;
        dictionary.set('Type', _PdfName.get('Font'));
        dictionary.set('Subtype', _PdfName.get('Type1'));
        dictionary.set('BaseFont', new _PdfName(this._metrics._postScriptName));
        if (this._fontFamily !== PdfFontFamily.symbol && this._fontFamily !== PdfFontFamily.zapfDingbats) {
            dictionary.set('Encoding', new _PdfName('WinAnsiEncoding'));
        }
        return dictionary;
    };
    PdfStandardFont.prototype._getCharacterWidthInternal = function (charCode) {
        var code = charCode.charCodeAt(0);
        if (this._metrics._name === 'Helvetica' ||
            this._metrics._name === 'Courier' ||
            this._metrics._name === 'TimesRoman' ||
            this._metrics._name === 'Symbol' ||
            this._metrics._name === 'ZapfDingbats') {
            code = code - 32;
        }
        code = (code >= 0 && code !== 128) ? code : 0;
        return this._metrics._widthTable._itemAt(code);
    };
    return PdfStandardFont;
}(PdfFont));
/**
 * Represents one of the 7 CJK standard fonts.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF CJK standard font
 * let font: PdfCjkStandardFont = new PdfCjkStandardFont(PdfCjkFontFamily.heiseiMinchoW3, 20);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('こんにちは世界', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfCjkStandardFont = /** @class */ (function (_super) {
    __extends$1(PdfCjkStandardFont, _super);
    function PdfCjkStandardFont(fontFamily, size, style) {
        var _this = _super.call(this, size, (typeof style === 'undefined') ? PdfFontStyle.regular : style) || this;
        _this._fontFamily = fontFamily;
        _this._size = size;
        _this._initializeInternals();
        return _this;
    }
    Object.defineProperty(PdfCjkStandardFont.prototype, "fontFamily", {
        /**
         * Gets the font family of the PDF CJK font.
         *
         * @returns {PdfCjkFontFamily} fontFamily.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF CJK standard font
         * let font: PdfCjkStandardFont = new PdfCjkStandardFont(PdfCjkFontFamily.heiseiMinchoW3, 20);
         * // Gets the font family
         * let fontFamily: PdfCjkFontFamily = font.fontFamily;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._fontFamily;
        },
        enumerable: true,
        configurable: true
    });
    PdfCjkStandardFont.prototype._initializeInternals = function () {
        this._metrics = _PdfCjkStandardFontMetricsFactory._getMetrics(this._fontFamily, this._style, this._size);
        this._dictionary = this._createInternals();
    };
    PdfCjkStandardFont.prototype._createInternals = function () {
        var dictionary = new _PdfDictionary();
        dictionary._updated = true;
        dictionary.set('Type', _PdfName.get('Font'));
        dictionary.set('Subtype', _PdfName.get('Type0'));
        dictionary.set('BaseFont', new _PdfName(this._metrics._postScriptName));
        dictionary.set('Encoding', this._getEncoding(this._fontFamily));
        dictionary.set('DescendantFonts', this._getDescendantFont());
        return dictionary;
    };
    PdfCjkStandardFont.prototype._getEncoding = function (fontFamily) {
        var encoding = 'Unknown';
        switch (fontFamily) {
            case PdfCjkFontFamily.hanyangSystemsGothicMedium:
            case PdfCjkFontFamily.hanyangSystemsShinMyeongJoMedium:
                encoding = 'UniKS-UCS2-H';
                break;
            case PdfCjkFontFamily.heiseiKakuGothicW5:
            case PdfCjkFontFamily.heiseiMinchoW3:
                encoding = 'UniJIS-UCS2-H';
                break;
            case PdfCjkFontFamily.monotypeHeiMedium:
            case PdfCjkFontFamily.monotypeSungLight:
                encoding = 'UniCNS-UCS2-H';
                break;
            case PdfCjkFontFamily.sinoTypeSongLight:
                encoding = 'UniGB-UCS2-H';
                break;
        }
        return new _PdfName(encoding);
    };
    PdfCjkStandardFont.prototype._getDescendantFont = function () {
        var dictionary = new _PdfDictionary();
        dictionary._updated = true;
        dictionary.set('Type', _PdfName.get('Font'));
        dictionary.set('Subtype', _PdfName.get('CIDFontType2'));
        dictionary.set('BaseFont', new _PdfName(this._metrics._postScriptName));
        dictionary.set('DW', this._metrics._widthTable._defaultWidth);
        dictionary.set('W', this._metrics._widthTable._toArray());
        dictionary.set('FontDescriptor', _PdfCjkFontDescriptorFactory._getFontDescriptor(this._fontFamily, this._style, this._metrics));
        dictionary.set('CIDSystemInfo', this._getSystemInformation());
        return [dictionary];
    };
    PdfCjkStandardFont.prototype._getSystemInformation = function () {
        var systemInformation = new _PdfDictionary();
        systemInformation._updated = true;
        systemInformation.set('Registry', 'Adobe');
        switch (this._fontFamily) {
            case PdfCjkFontFamily.hanyangSystemsGothicMedium:
            case PdfCjkFontFamily.hanyangSystemsShinMyeongJoMedium:
                systemInformation.set('Ordering', 'Korea1');
                systemInformation.set('Supplement', 1);
                break;
            case PdfCjkFontFamily.heiseiKakuGothicW5:
            case PdfCjkFontFamily.heiseiMinchoW3:
                systemInformation.set('Ordering', 'Japan1');
                systemInformation.set('Supplement', 2);
                break;
            case PdfCjkFontFamily.monotypeHeiMedium:
            case PdfCjkFontFamily.monotypeSungLight:
                systemInformation.set('Ordering', 'CNS1');
                systemInformation.set('Supplement', '0');
                break;
            case PdfCjkFontFamily.sinoTypeSongLight:
                systemInformation.set('Ordering', 'GB1');
                systemInformation.set('Supplement', 2);
                break;
        }
        return systemInformation;
    };
    /**
     * Gets the line width.
     *
     * @param {string} line Line.
     * @param {PdfStringFormat} format String format.
     * @returns {number} width.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF CJK standard font
     * let font: PdfCjkStandardFont = new PdfCjkStandardFont(PdfCjkFontFamily.heiseiMinchoW3, 20, PdfFontStyle.bold);
     * // Create a new PDF string format
     * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
     * // Get the text width
     * let width: number = font.getLineWidth('Syncfusion', format);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfCjkStandardFont.prototype.getLineWidth = function (line, format) {
        var width = 0;
        for (var i = 0; i < line.length; i++) {
            width += this._getCharacterWidthInternal(line.charCodeAt(i));
        }
        width *= (0.001 * this._metrics._size);
        width = this._applyFormatSettings(line, format, width);
        return width;
    };
    PdfCjkStandardFont.prototype._getCharacterWidthInternal = function (charCode) {
        charCode = (charCode >= 0) ? charCode : 0;
        return this._metrics._widthTable._itemAt(charCode);
    };
    return PdfCjkStandardFont;
}(PdfFont));
/**
 * Represents TrueType font.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF truetype font
 * let font: PdfTrueTypeFont = new PdfTrueTypeFont(base64String, 10);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfTrueTypeFont = /** @class */ (function (_super) {
    __extends$1(PdfTrueTypeFont, _super);
    function PdfTrueTypeFont(base64String, size, style) {
        var _this = _super.call(this, size, (typeof style === 'undefined') ? PdfFontStyle.regular : style) || this;
        _this._isEmbedFont = false;
        _this._isUnicode = true;
        if (style !== undefined) {
            _this._createFontInternal(base64String, style);
        }
        else {
            _this._createFontInternal(base64String, PdfFontStyle.regular);
        }
        return _this;
    }
    Object.defineProperty(PdfTrueTypeFont.prototype, "isUnicode", {
        /**
         * Gets the boolean flag indicating whether the font has unicode or not.
         *
         * @returns {boolean} unicode.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF truetype font
         * let font: PdfTrueTypeFont = new PdfTrueTypeFont(base64String, 10);
         * // Gets the boolean flag indicating whether the font has or not.
         * let isUnicode: boolean = font.isUnicode;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._isUnicode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTrueTypeFont.prototype, "isEmbed", {
        /**
         * Gets the boolean flag indicating whether the font is embedded or not.
         *
         * @returns {boolean} isEmbed.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new PDF truetype font
         * let font: PdfTrueTypeFont = new PdfTrueTypeFont(base64String, 10);
         * // Gets the boolean flag indicating whether the font is embedded or not.
         * let isEmbed: boolean = font.isEmbed;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._isEmbedFont;
        },
        enumerable: true,
        configurable: true
    });
    PdfTrueTypeFont.prototype._createFontInternal = function (base64String, style) {
        this._fontInternal = new _UnicodeTrueTypeFont(base64String, this._size);
        this.style = style;
        this._initializeInternals();
    };
    PdfTrueTypeFont.prototype._initializeInternals = function () {
        var internals = null;
        if (this._fontInternal instanceof _UnicodeTrueTypeFont) {
            this._fontInternal._isEmbed = this._isEmbedFont;
        }
        this._fontInternal._createInternals();
        internals = this._fontInternal._getInternals();
        this._metrics = this._fontInternal._metrics;
        this._metrics._isUnicodeFont = true;
        this._setInternals(internals);
    };
    /**
     * Gets the line width.
     *
     * @param {string} line Line.
     * @param {PdfStringFormat} format String format.
     * @returns {number} width.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF truetype font
     * let font: PdfTrueTypeFont = new PdfTrueTypeFont(base64String, 10, PdfFontStyle.regular);
     * // Create a new PDF string format
     * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
     * // Get the text width
     * let width: number = font.getLineWidth('Syncfusion', format);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfTrueTypeFont.prototype.getLineWidth = function (line, format) {
        var width = 0;
        if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.none) {
            width = this._getUnicodeLineWidth(line, width);
        }
        else {
            for (var i = 0, len = line.length; i < len; i++) {
                width += this._getCharacterWidthInternal(line[Number.parseInt(i.toString(), 10)]);
            }
        }
        width *= (0.001 * this._metrics._size);
        width = this._applyFormatSettings(line, format, width);
        return width;
    };
    PdfTrueTypeFont.prototype._getUnicodeLineWidth = function (line, width) {
        width = 0;
        var glyphIndex = [];
        var result = false;
        var rtlRender = new _RtlRenderer();
        var value = rtlRender._getGlyphIndex(line, this, glyphIndex);
        result = value._result;
        glyphIndex = value._glyphIndex;
        if (result && glyphIndex !== null) {
            var ttfReader = this._fontInternal._ttfReader;
            for (var i = 0, len = glyphIndex.length; i < len; i++) {
                var index = glyphIndex[Number.parseInt(i.toString(), 10)];
                var glyph = ttfReader._getGlyph(index);
                if (glyph !== null && typeof glyph !== 'undefined') {
                    width += glyph._width;
                }
            }
        }
        return width;
    };
    PdfTrueTypeFont.prototype._getCharacterWidth = function (charCode, format) {
        var codeWidth = this._fontInternal._getCharacterWidth(charCode);
        var size = this._metrics._getSize(format);
        codeWidth *= (0.001 * size);
        return codeWidth;
    };
    PdfTrueTypeFont.prototype._setSymbols = function (text) {
        var internalFont = this._fontInternal;
        if (internalFont !== null && typeof internalFont !== 'undefined') {
            internalFont._setSymbols(text);
        }
    };
    PdfTrueTypeFont.prototype._getCharacterWidthInternal = function (charCode) {
        var code = charCode.charCodeAt(0);
        code = (code >= 0 && code !== 128) ? code : 0;
        return this._metrics._widthTable._itemAt(code);
    };
    return PdfTrueTypeFont;
}(PdfFont));
var _PdfStandardFontMetricsFactory = /** @class */ (function () {
    function _PdfStandardFontMetricsFactory() {
    }
    _PdfStandardFontMetricsFactory._getMetrics = function (fontFamily, fontStyle, size) {
        var metrics = null;
        switch (fontFamily) {
            case PdfFontFamily.helvetica:
                metrics = this._getHelveticaMetrics(fontStyle, size);
                metrics._name = 'Helvetica';
                break;
            case PdfFontFamily.courier:
                metrics = this._getCourierMetrics(fontStyle, size);
                metrics._name = 'Courier';
                break;
            case PdfFontFamily.timesRoman:
                metrics = this._getTimesMetrics(fontStyle, size);
                metrics._name = 'TimesRoman';
                break;
            case PdfFontFamily.symbol:
                metrics = this._getSymbolMetrics(size);
                metrics._name = 'Symbol';
                break;
            case PdfFontFamily.zapfDingbats:
                metrics = this._getZapfDingbatsMetrics(size);
                metrics._name = 'ZapfDingbats';
                break;
            default:
                metrics = this._getHelveticaMetrics(fontStyle, size);
                metrics._name = 'Helvetica';
                break;
        }
        metrics._subScriptSizeFactor = this._subSuperScriptFactor;
        metrics._superscriptSizeFactor = this._subSuperScriptFactor;
        return metrics;
    };
    _PdfStandardFontMetricsFactory._getHelveticaMetrics = function (fontStyle, size) {
        var metrics = new _PdfFontMetrics();
        if ((fontStyle & PdfFontStyle.bold) > 0 && (fontStyle & PdfFontStyle.italic) > 0) {
            metrics._ascent = this._helveticaBoldItalicAscent;
            metrics._descent = this._helveticaBoldItalicDescent;
            metrics._postScriptName = this._helveticaBoldItalicName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._arialBoldWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else if ((fontStyle & PdfFontStyle.bold) > 0) {
            metrics._ascent = this._helveticaBoldAscent;
            metrics._descent = this._helveticaBoldDescent;
            metrics._postScriptName = this._helveticaBoldName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._arialBoldWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else if ((fontStyle & PdfFontStyle.italic) > 0) {
            metrics._ascent = this._helveticaItalicAscent;
            metrics._descent = this._helveticaItalicDescent;
            metrics._postScriptName = this._helveticaItalicName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._arialWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else {
            metrics._ascent = this._helveticaAscent;
            metrics._descent = this._helveticaDescent;
            metrics._postScriptName = this._helveticaName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._arialWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        return metrics;
    };
    _PdfStandardFontMetricsFactory._getCourierMetrics = function (fontStyle, size) {
        var metrics = new _PdfFontMetrics();
        if ((fontStyle & PdfFontStyle.bold) > 0 && (fontStyle & PdfFontStyle.italic) > 0) {
            metrics._ascent = this._courierBoldItalicAscent;
            metrics._descent = this._courierBoldItalicDescent;
            metrics._postScriptName = this._courierBoldItalicName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._fixedWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else if ((fontStyle & PdfFontStyle.bold) > 0) {
            metrics._ascent = this._courierBoldAscent;
            metrics._descent = this._courierBoldDescent;
            metrics._postScriptName = this._courierBoldName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._fixedWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else if ((fontStyle & PdfFontStyle.italic) > 0) {
            metrics._ascent = this._courierItalicAscent;
            metrics._descent = this._courierItalicDescent;
            metrics._postScriptName = this._courierItalicName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._fixedWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else {
            metrics._ascent = this._courierAscent;
            metrics._descent = this._courierDescent;
            metrics._postScriptName = this._courierName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._fixedWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        return metrics;
    };
    _PdfStandardFontMetricsFactory._getTimesMetrics = function (fontStyle, size) {
        var metrics = new _PdfFontMetrics();
        if ((fontStyle & PdfFontStyle.bold) > 0 && (fontStyle & PdfFontStyle.italic) > 0) {
            metrics._ascent = this._timesBoldItalicAscent;
            metrics._descent = this._timesBoldItalicDescent;
            metrics._postScriptName = this._timesBoldItalicName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._timesRomanBoldItalicWidths);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else if ((fontStyle & PdfFontStyle.bold) > 0) {
            metrics._ascent = this._timesBoldAscent;
            metrics._descent = this._timesBoldDescent;
            metrics._postScriptName = this._timesBoldName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._timesRomanBoldWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else if ((fontStyle & PdfFontStyle.italic) > 0) {
            metrics._ascent = this._timesItalicAscent;
            metrics._descent = this._timesItalicDescent;
            metrics._postScriptName = this._timesItalicName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._timesRomanItalicWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else {
            metrics._ascent = this._timesAscent;
            metrics._descent = this._timesDescent;
            metrics._postScriptName = this._timesName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._timesRomanWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        return metrics;
    };
    _PdfStandardFontMetricsFactory._getSymbolMetrics = function (size) {
        var metrics = new _PdfFontMetrics();
        metrics._ascent = this._symbolAscent;
        metrics._descent = this._symbolDescent;
        metrics._postScriptName = this._symbolName;
        metrics._size = size;
        metrics._widthTable = new _StandardWidthTable(this._symbolWidth);
        metrics._height = metrics._ascent - metrics._descent;
        return metrics;
    };
    _PdfStandardFontMetricsFactory._getZapfDingbatsMetrics = function (size) {
        var metrics = new _PdfFontMetrics();
        metrics._ascent = this._zapfDingbatsAscent;
        metrics._descent = this._zapfDingbatsDescent;
        metrics._postScriptName = this._zapfDingbatsName;
        metrics._size = size;
        metrics._widthTable = new _StandardWidthTable(this._zapfDingbatsWidth);
        metrics._height = metrics._ascent - metrics._descent;
        return metrics;
    };
    _PdfStandardFontMetricsFactory._subSuperScriptFactor = 1.52;
    _PdfStandardFontMetricsFactory._helveticaAscent = 931;
    _PdfStandardFontMetricsFactory._helveticaDescent = -225;
    _PdfStandardFontMetricsFactory._helveticaName = 'Helvetica';
    _PdfStandardFontMetricsFactory._helveticaBoldAscent = 962;
    _PdfStandardFontMetricsFactory._helveticaBoldDescent = -228;
    _PdfStandardFontMetricsFactory._helveticaBoldName = 'Helvetica-Bold';
    _PdfStandardFontMetricsFactory._helveticaItalicAscent = 931;
    _PdfStandardFontMetricsFactory._helveticaItalicDescent = -225;
    _PdfStandardFontMetricsFactory._helveticaItalicName = 'Helvetica-Oblique';
    _PdfStandardFontMetricsFactory._helveticaBoldItalicAscent = 962;
    _PdfStandardFontMetricsFactory._helveticaBoldItalicDescent = -228;
    _PdfStandardFontMetricsFactory._helveticaBoldItalicName = 'Helvetica-BoldOblique';
    _PdfStandardFontMetricsFactory._courierAscent = 805;
    _PdfStandardFontMetricsFactory._courierDescent = -250;
    _PdfStandardFontMetricsFactory._courierName = 'Courier';
    _PdfStandardFontMetricsFactory._courierBoldAscent = 801;
    _PdfStandardFontMetricsFactory._courierBoldDescent = -250;
    _PdfStandardFontMetricsFactory._courierBoldName = 'Courier-Bold';
    _PdfStandardFontMetricsFactory._courierItalicAscent = 805;
    _PdfStandardFontMetricsFactory._courierItalicDescent = -250;
    _PdfStandardFontMetricsFactory._courierItalicName = 'Courier-Oblique';
    _PdfStandardFontMetricsFactory._courierBoldItalicAscent = 801;
    _PdfStandardFontMetricsFactory._courierBoldItalicDescent = -250;
    _PdfStandardFontMetricsFactory._courierBoldItalicName = 'Courier-BoldOblique';
    _PdfStandardFontMetricsFactory._timesAscent = 898;
    _PdfStandardFontMetricsFactory._timesDescent = -218;
    _PdfStandardFontMetricsFactory._timesName = 'Times-Roman';
    _PdfStandardFontMetricsFactory._timesBoldAscent = 935;
    _PdfStandardFontMetricsFactory._timesBoldDescent = -218;
    _PdfStandardFontMetricsFactory._timesBoldName = 'Times-Bold';
    _PdfStandardFontMetricsFactory._timesItalicAscent = 883;
    _PdfStandardFontMetricsFactory._timesItalicDescent = -217;
    _PdfStandardFontMetricsFactory._timesItalicName = 'Times-Italic';
    _PdfStandardFontMetricsFactory._timesBoldItalicAscent = 921;
    _PdfStandardFontMetricsFactory._timesBoldItalicDescent = -218;
    _PdfStandardFontMetricsFactory._timesBoldItalicName = 'Times-BoldItalic';
    _PdfStandardFontMetricsFactory._symbolAscent = 1010;
    _PdfStandardFontMetricsFactory._symbolDescent = -293;
    _PdfStandardFontMetricsFactory._symbolName = 'Symbol';
    _PdfStandardFontMetricsFactory._zapfDingbatsAscent = 820;
    _PdfStandardFontMetricsFactory._zapfDingbatsDescent = -143;
    _PdfStandardFontMetricsFactory._zapfDingbatsName = 'ZapfDingbats';
    _PdfStandardFontMetricsFactory._arialWidth = [
        278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333,
        278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584,
        584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833,
        722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278,
        469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833,
        556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334,
        584, 0, 556, 0, 222, 556, 333, 1000, 556, 556, 333, 1000, 667, 333, 1000, 0,
        611, 0, 0, 222, 222, 333, 333, 350, 556, 1000, 333, 1000, 500, 333, 944, 0,
        500, 667, 0, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 0,
        737, 333, 400, 584, 333, 333, 333, 556, 537, 278, 333, 333, 365, 556, 834, 834,
        834, 611, 667, 667, 667, 667, 667, 667, 1000, 722, 667, 667, 667, 667, 278, 278,
        278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667,
        667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278,
        278, 278, 556, 556, 556, 556, 556, 556, 556, 584, 611, 556, 556, 556, 556, 500,
        556, 500
    ];
    _PdfStandardFontMetricsFactory._arialBoldWidth = [
        278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333,
        278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584,
        584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833,
        722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333,
        584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889,
        611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389,
        584, 0, 556, 0, 278, 556, 500, 1000, 556, 556, 333, 1000, 667, 333, 1000, 0,
        611, 0, 0, 278, 278, 500, 500, 350, 556, 1000, 333, 1000, 556, 333, 944, 0,
        500, 667, 0, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 0,
        737, 333, 400, 584, 333, 333, 333, 611, 556, 278, 333, 333, 365, 556, 834, 834,
        834, 611, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 278, 278,
        278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667,
        667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278,
        278, 278, 611, 611, 611, 611, 611, 611, 611, 584, 611, 611, 611, 611, 611, 556,
        611, 556
    ];
    _PdfStandardFontMetricsFactory._fixedWidth = [
        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
        600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600
    ];
    _PdfStandardFontMetricsFactory._timesRomanWidth = [
        250, 333, 408, 500, 500, 833, 778, 180, 333, 333, 500, 564, 250, 333,
        250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 278, 278, 564, 564,
        564, 444, 921, 722, 667, 667, 722, 611, 556, 722, 722, 333, 389, 722, 611, 889,
        722, 722, 556, 722, 667, 556, 611, 722, 722, 944, 722, 722, 611, 333, 278, 333,
        469, 500, 333, 444, 500, 444, 500, 444, 333, 500, 500, 278, 278, 500, 278, 778,
        500, 500, 500, 500, 333, 389, 278, 500, 500, 722, 500, 500, 444, 480, 200, 480,
        541, 0, 500, 0, 333, 500, 444, 1000, 500, 500, 333, 1000, 556, 333, 889, 0,
        611, 0, 0, 333, 333, 444, 444, 350, 500, 1000, 333, 980, 389, 333, 722, 0,
        444, 722, 0, 333, 500, 500, 500, 500, 200, 500, 333, 760, 276, 500, 564, 0,
        760, 333, 400, 564, 300, 300, 333, 500, 453, 250, 333, 300, 310, 500, 750, 750,
        750, 444, 722, 722, 722, 722, 722, 722, 889, 667, 611, 611, 611, 611, 333, 333,
        333, 333, 722, 722, 722, 722, 722, 722, 722, 564, 722, 722, 722, 722, 722, 722,
        556, 500, 444, 444, 444, 444, 444, 444, 667, 444, 444, 444, 444, 444, 278, 278,
        278, 278, 500, 500, 500, 500, 500, 500, 500, 564, 500, 500, 500, 500, 500, 500,
        500, 500
    ];
    _PdfStandardFontMetricsFactory._timesRomanBoldWidth = [
        250, 333, 555, 500, 500, 1000, 833, 278, 333, 333, 500, 570, 250, 333,
        250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 570, 570,
        570, 500, 930, 722, 667, 722, 722, 667, 611, 778, 778, 389, 500, 778, 667, 944,
        722, 778, 611, 778, 722, 556, 667, 722, 722, 1000, 722, 722, 667, 333, 278, 333,
        581, 500, 333, 500, 556, 444, 556, 444, 333, 500, 556, 278, 333, 556, 278, 833,
        556, 500, 556, 556, 444, 389, 333, 556, 500, 722, 500, 500, 444, 394, 220, 394,
        520, 0, 500, 0, 333, 500, 500, 1000, 500, 500, 333, 1000, 556, 333, 1000, 0,
        667, 0, 0, 333, 333, 500, 500, 350, 500, 1000, 333, 1000, 389, 333, 722, 0,
        444, 722, 0, 333, 500, 500, 500, 500, 220, 500, 333, 747, 300, 500, 570, 0,
        747, 333, 400, 570, 300, 300, 333, 556, 540, 250, 333, 300, 330, 500, 750, 750,
        750, 500, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 389, 389,
        389, 389, 722, 722, 778, 778, 778, 778, 778, 570, 778, 722, 722, 722, 722, 722,
        611, 556, 500, 500, 500, 500, 500, 500, 722, 444, 444, 444, 444, 444, 278, 278,
        278, 278, 500, 556, 500, 500, 500, 500, 500, 570, 500, 556, 556, 556, 556, 500,
        556, 500
    ];
    _PdfStandardFontMetricsFactory._timesRomanItalicWidth = [
        250, 333, 420, 500, 500, 833, 778, 214, 333, 333, 500, 675, 250, 333,
        250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 675, 675,
        675, 500, 920, 611, 611, 667, 722, 611, 611, 722, 722, 333, 444, 667, 556, 833,
        667, 722, 611, 722, 611, 500, 556, 722, 611, 833, 611, 556, 556, 389, 278, 389,
        422, 500, 333, 500, 500, 444, 500, 444, 278, 500, 500, 278, 278, 444, 278, 722,
        500, 500, 500, 500, 389, 389, 278, 500, 444, 667, 444, 444, 389, 400, 275, 400,
        541, 0, 500, 0, 333, 500, 556, 889, 500, 500, 333, 1000, 500, 333, 944, 0,
        556, 0, 0, 333, 333, 556, 556, 350, 500, 889, 333, 980, 389, 333, 667, 0,
        389, 556, 0, 389, 500, 500, 500, 500, 275, 500, 333, 760, 276, 500, 675, 0,
        760, 333, 400, 675, 300, 300, 333, 500, 523, 250, 333, 300, 310, 500, 750, 750,
        750, 500, 611, 611, 611, 611, 611, 611, 889, 667, 611, 611, 611, 611, 333, 333,
        333, 333, 722, 667, 722, 722, 722, 722, 722, 675, 722, 722, 722, 722, 722, 556,
        611, 500, 500, 500, 500, 500, 500, 500, 667, 444, 444, 444, 444, 444, 278, 278,
        278, 278, 500, 500, 500, 500, 500, 500, 500, 675, 500, 500, 500, 500, 500, 444,
        500, 444
    ];
    _PdfStandardFontMetricsFactory._timesRomanBoldItalicWidths = [
        250, 389, 555, 500, 500, 833, 778, 278, 333, 333, 500, 570, 250, 333,
        250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 570, 570,
        570, 500, 832, 667, 667, 667, 722, 667, 667, 722, 778, 389, 500, 667, 611, 889,
        722, 722, 611, 722, 667, 556, 611, 722, 667, 889, 667, 611, 611, 333, 278, 333,
        570, 500, 333, 500, 500, 444, 500, 444, 333, 500, 556, 278, 278, 500, 278, 778,
        556, 500, 500, 500, 389, 389, 278, 556, 444, 667, 500, 444, 389, 348, 220, 348,
        570, 0, 500, 0, 333, 500, 500, 1000, 500, 500, 333, 1000, 556, 333, 944, 0,
        611, 0, 0, 333, 333, 500, 500, 350, 500, 1000, 333, 1000, 389, 333, 722, 0,
        389, 611, 0, 389, 500, 500, 500, 500, 220, 500, 333, 747, 266, 500, 606, 0,
        747, 333, 400, 570, 300, 300, 333, 576, 500, 250, 333, 300, 300, 500, 750, 750,
        750, 500, 667, 667, 667, 667, 667, 667, 944, 667, 667, 667, 667, 667, 389, 389,
        389, 389, 722, 722, 722, 722, 722, 722, 722, 570, 722, 722, 722, 722, 722, 611,
        611, 500, 500, 500, 500, 500, 500, 500, 722, 444, 444, 444, 444, 444, 278, 278,
        278, 278, 500, 556, 500, 500, 500, 500, 500, 570, 500, 556, 556, 556, 556, 444,
        500, 444
    ];
    _PdfStandardFontMetricsFactory._symbolWidth = [
        250, 333, 713, 500, 549, 833, 778, 439, 333, 333, 500, 549, 250, 549,
        250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 278, 278,
        549, 549, 549, 444, 549, 722, 667, 722, 612, 611, 763, 603, 722, 333,
        631, 722, 686, 889, 722, 722, 768, 741, 556, 592, 611, 690, 439, 768,
        645, 795, 611, 333, 863, 333, 658, 500, 500, 631, 549, 549, 494, 439,
        521, 411, 603, 329, 603, 549, 549, 576, 521, 549, 549, 521, 549, 603,
        439, 576, 713, 686, 493, 686, 494, 480, 200, 480, 549, 750, 620, 247,
        549, 167, 713, 500, 753, 753, 753, 753, 1042, 987, 603, 987, 603, 400,
        549, 411, 549, 549, 713, 494, 460, 549, 549, 549, 549, 1000, 603, 1000,
        658, 823, 686, 795, 987, 768, 768, 823, 768, 768, 713, 713, 713, 713,
        713, 713, 713, 768, 713, 790, 790, 890, 823, 549, 250, 713, 603, 603,
        1042, 987, 603, 987, 603, 494, 329, 790, 790, 786, 713, 384, 384, 384,
        384, 384, 384, 494, 494, 494, 494, 329, 274, 686, 686, 686, 384, 384,
        384, 384, 384, 384, 494, 494, 494, -1
    ];
    _PdfStandardFontMetricsFactory._zapfDingbatsWidth = [
        278, 974, 961, 974, 980, 719, 789, 790, 791, 690, 960, 939, 549, 855,
        911, 933, 911, 945, 974, 755, 846, 762, 761, 571, 677, 763, 760, 759,
        754, 494, 552, 537, 577, 692, 786, 788, 788, 790, 793, 794, 816, 823,
        789, 841, 823, 833, 816, 831, 923, 744, 723, 749, 790, 792, 695, 776,
        768, 792, 759, 707, 708, 682, 701, 826, 815, 789, 789, 707, 687, 696,
        689, 786, 787, 713, 791, 785, 791, 873, 761, 762, 762, 759, 759, 892,
        892, 788, 784, 438, 138, 277, 415, 392, 392, 668, 668, 390, 390, 317,
        317, 276, 276, 509, 509, 410, 410, 234, 234, 334, 334, 732, 544, 544,
        910, 667, 760, 760, 776, 595, 694, 626, 788, 788, 788, 788, 788, 788,
        788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788,
        788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788,
        788, 788, 788, 788, 788, 788, 894, 838, 1016, 458, 748, 924, 748, 918,
        927, 928, 928, 834, 873, 828, 924, 924, 917, 930, 931, 463, 883, 836,
        836, 867, 867, 696, 696, 874, 874, 760, 946, 771, 865, 771, 888, 967,
        888, 831, 873, 927, 970, 918
    ];
    return _PdfStandardFontMetricsFactory;
}());
var _PdfCjkStandardFontMetricsFactory = /** @class */ (function () {
    function _PdfCjkStandardFontMetricsFactory() {
    }
    _PdfCjkStandardFontMetricsFactory._getHanyangSystemsGothicMedium = function (fontStyle, size) {
        var metrics = new _PdfFontMetrics();
        var widthTable = new _CjkWidthTable(1000);
        widthTable._add(new _CjkSameWidth(1, 127, 500));
        widthTable._add(new _CjkSameWidth(8094, 8190, 500));
        metrics._widthTable = widthTable;
        metrics._ascent = 880;
        metrics._descent = -120;
        metrics._size = size;
        metrics._height = metrics._ascent - metrics._descent;
        if ((fontStyle & PdfFontStyle.bold) !== 0 && (fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HYGoThic-Medium,BoldItalic';
        }
        else if ((fontStyle & PdfFontStyle.bold) !== 0) {
            metrics._postScriptName = 'HYGoThic-Medium,Bold';
        }
        else if ((fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HYGoThic-Medium,Italic';
        }
        else {
            metrics._postScriptName = 'HYGoThic-Medium';
        }
        return metrics;
    };
    _PdfCjkStandardFontMetricsFactory._getHanyangSystemsShinMyeongJoMedium = function (fontStyle, size) {
        var metrics = new _PdfFontMetrics();
        var widthTable = new _CjkWidthTable(1000);
        widthTable._add(new _CjkSameWidth(1, 95, 500));
        widthTable._add(new _CjkSameWidth(8094, 8190, 500));
        metrics._widthTable = widthTable;
        metrics._ascent = 880;
        metrics._descent = -120;
        metrics._size = size;
        metrics._height = metrics._ascent - metrics._descent;
        if ((fontStyle & PdfFontStyle.bold) !== 0 && (fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HYSMyeongJo-Medium,BoldItalic';
        }
        else if ((fontStyle & PdfFontStyle.bold) !== 0) {
            metrics._postScriptName = 'HYSMyeongJo-Medium,Bold';
        }
        else if ((fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HYSMyeongJo-Medium,Italic';
        }
        else {
            metrics._postScriptName = 'HYSMyeongJo-Medium';
        }
        return metrics;
    };
    _PdfCjkStandardFontMetricsFactory._getHeiseiKakuGothicW5 = function (fontStyle, size) {
        var metrics = new _PdfFontMetrics();
        var widthTable = new _CjkWidthTable(1000);
        widthTable._add(new _CjkSameWidth(1, 95, 500));
        widthTable._add(new _CjkSameWidth(231, 632, 500));
        metrics._widthTable = widthTable;
        metrics._ascent = 857;
        metrics._descent = -125;
        metrics._size = size;
        metrics._height = metrics._ascent - metrics._descent;
        if ((fontStyle & PdfFontStyle.bold) !== 0 && (fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HeiseiKakuGo-W5,BoldItalic';
        }
        else if ((fontStyle & PdfFontStyle.bold) !== 0) {
            metrics._postScriptName = 'HeiseiKakuGo-W5,Bold';
        }
        else if ((fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HeiseiKakuGo-W5,Italic';
        }
        else {
            metrics._postScriptName = 'HeiseiKakuGo-W5';
        }
        return metrics;
    };
    _PdfCjkStandardFontMetricsFactory._getHeiseiMinchoW3 = function (fontStyle, size) {
        var metrics = new _PdfFontMetrics();
        var widthTable = new _CjkWidthTable(1000);
        widthTable._add(new _CjkSameWidth(1, 95, 500));
        widthTable._add(new _CjkSameWidth(231, 632, 500));
        metrics._widthTable = widthTable;
        metrics._ascent = 857;
        metrics._descent = -143;
        metrics._size = size;
        metrics._height = metrics._ascent - metrics._descent;
        if ((fontStyle & PdfFontStyle.bold) !== 0 && (fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HeiseiMin-W3,BoldItalic';
        }
        else if ((fontStyle & PdfFontStyle.bold) !== 0) {
            metrics._postScriptName = 'HeiseiMin-W3,Bold';
        }
        else if ((fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HeiseiMin-W3,Italic';
        }
        else {
            metrics._postScriptName = 'HeiseiMin-W3';
        }
        return metrics;
    };
    _PdfCjkStandardFontMetricsFactory._getMonotypeHeiMedium = function (fontStyle, size) {
        var metrics = new _PdfFontMetrics();
        var widthTable = new _CjkWidthTable(1000);
        widthTable._add(new _CjkSameWidth(1, 95, 500));
        widthTable._add(new _CjkSameWidth(13648, 13742, 500));
        metrics._widthTable = widthTable;
        metrics._ascent = 880;
        metrics._descent = -120;
        metrics._size = size;
        metrics._height = metrics._ascent - metrics._descent;
        if ((fontStyle & PdfFontStyle.bold) !== 0 && (fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'MHei-Medium,BoldItalic';
        }
        else if ((fontStyle & PdfFontStyle.bold) !== 0) {
            metrics._postScriptName = 'MHei-Medium,Bold';
        }
        else if ((fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'MHei-Medium,Italic';
        }
        else {
            metrics._postScriptName = 'MHei-Medium';
        }
        return metrics;
    };
    _PdfCjkStandardFontMetricsFactory._getMonotypeSungLight = function (fontStyle, size) {
        var metrics = new _PdfFontMetrics();
        var widthTable = new _CjkWidthTable(1000);
        widthTable._add(new _CjkSameWidth(1, 95, 500));
        widthTable._add(new _CjkSameWidth(13648, 13742, 500));
        metrics._widthTable = widthTable;
        metrics._ascent = 880;
        metrics._descent = -120;
        metrics._size = size;
        metrics._height = metrics._ascent - metrics._descent;
        if ((fontStyle & PdfFontStyle.bold) !== 0 && (fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'MSung-Light,BoldItalic';
        }
        else if ((fontStyle & PdfFontStyle.bold) !== 0) {
            metrics._postScriptName = 'MSung-Light,Bold';
        }
        else if ((fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'MSung-Light,Italic';
        }
        else {
            metrics._postScriptName = 'MSung-Light';
        }
        return metrics;
    };
    _PdfCjkStandardFontMetricsFactory._getSinoTypeSongLight = function (fontStyle, size) {
        var metrics = new _PdfFontMetrics();
        var widthTable = new _CjkWidthTable(1000);
        widthTable._add(new _CjkSameWidth(1, 95, 500));
        widthTable._add(new _CjkSameWidth(814, 939, 500));
        widthTable._add(new _CjkDifferentWidth(7712, [500]));
        widthTable._add(new _CjkDifferentWidth(7716, [500]));
        metrics._ascent = 880;
        metrics._descent = -120;
        metrics._size = size;
        metrics._height = metrics._ascent - metrics._descent;
        if ((fontStyle & PdfFontStyle.bold) !== 0 && (fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'STSong-Light,BoldItalic';
        }
        else if ((fontStyle & PdfFontStyle.bold) !== 0) {
            metrics._postScriptName = 'STSong-Light,Bold';
        }
        else if ((fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'STSong-Light,Italic';
        }
        else {
            metrics._postScriptName = 'STSong-Light';
        }
        metrics._widthTable = widthTable;
        return metrics;
    };
    _PdfCjkStandardFontMetricsFactory._getMetrics = function (fontFamily, fontStyle, size) {
        var metrics;
        switch (fontFamily) {
            case PdfCjkFontFamily.hanyangSystemsGothicMedium:
                metrics = this._getHanyangSystemsGothicMedium(fontStyle, size);
                metrics._name = 'HanyangSystemsGothicMedium';
                break;
            case PdfCjkFontFamily.hanyangSystemsShinMyeongJoMedium:
                metrics = this._getHanyangSystemsShinMyeongJoMedium(fontStyle, size);
                metrics._name = 'HanyangSystemsShinMyeongJoMedium';
                break;
            case PdfCjkFontFamily.heiseiKakuGothicW5:
                metrics = this._getHeiseiKakuGothicW5(fontStyle, size);
                metrics._name = 'HeiseiKakuGothicW5';
                break;
            case PdfCjkFontFamily.heiseiMinchoW3:
                metrics = this._getHeiseiMinchoW3(fontStyle, size);
                metrics._name = 'HeiseiMinchoW3';
                break;
            case PdfCjkFontFamily.monotypeHeiMedium:
                metrics = this._getMonotypeHeiMedium(fontStyle, size);
                metrics._name = 'MonotypeHeiMedium';
                break;
            case PdfCjkFontFamily.monotypeSungLight:
                metrics = this._getMonotypeSungLight(fontStyle, size);
                metrics._name = 'MonotypeSungLight';
                break;
            case PdfCjkFontFamily.sinoTypeSongLight:
                metrics = this._getSinoTypeSongLight(fontStyle, size);
                metrics._name = 'SinoTypeSongLight';
                break;
        }
        metrics._subScriptSizeFactor = this._subSuperScriptFactor;
        metrics._superscriptSizeFactor = this._subSuperScriptFactor;
        return metrics;
    };
    _PdfCjkStandardFontMetricsFactory._subSuperScriptFactor = 1.52;
    return _PdfCjkStandardFontMetricsFactory;
}());
var _PdfCjkFontDescriptorFactory = /** @class */ (function () {
    function _PdfCjkFontDescriptorFactory() {
    }
    _PdfCjkFontDescriptorFactory._fillMonotypeSungLight = function (fontDescriptor, fontFamily, fontMetrics) {
        var fontBox = { x: -160, y: -249, width: 1175, height: 1137 };
        this._fillFontBox(fontDescriptor, fontBox);
        this._fillKnownInformation(fontDescriptor, fontFamily, fontMetrics);
        fontDescriptor.set('StemV', 93);
        fontDescriptor.set('StemH', 93);
        fontDescriptor.set('AvgWidth', 1000);
        fontDescriptor.set('MaxWidth', 1000);
        fontDescriptor.set('CapHeight', 880);
        fontDescriptor.set('XHeight', 616);
        fontDescriptor.set('Leading', 250);
    };
    _PdfCjkFontDescriptorFactory._fillHeiseiKakuGothicW5 = function (fontDescriptor, fontStyle, fontFamily, fontMetrics) {
        var fontBox = { x: -92, y: -250, width: 1102, height: 1172 };
        var fontBoxItalic = { x: -92, y: -250, width: 1102, height: 1932 };
        if ((fontStyle & (PdfFontStyle.italic | PdfFontStyle.bold)) !== PdfFontStyle.italic) {
            this._fillFontBox(fontDescriptor, fontBox);
        }
        else {
            this._fillFontBox(fontDescriptor, fontBoxItalic);
        }
        this._fillKnownInformation(fontDescriptor, fontFamily, fontMetrics);
        fontDescriptor.set('StemV', 93);
        fontDescriptor.set('StemH', 93);
        fontDescriptor.set('AvgWidth', 689);
        fontDescriptor.set('MaxWidth', 1000);
        fontDescriptor.set('CapHeight', 718);
        fontDescriptor.set('XHeight', 500);
        fontDescriptor.set('Leading', 250);
    };
    _PdfCjkFontDescriptorFactory._fillHanyangSystemsShinMyeongJoMedium = function (fontDescriptor, fontFamily, fontMetrics) {
        var fontBox = { x: 0, y: -148, width: 1001, height: 1028 };
        this._fillFontBox(fontDescriptor, fontBox);
        this._fillKnownInformation(fontDescriptor, fontFamily, fontMetrics);
        fontDescriptor.set('StemV', 93);
        fontDescriptor.set('StemH', 93);
        fontDescriptor.set('AvgWidth', 1000);
        fontDescriptor.set('MaxWidth', 1000);
        fontDescriptor.set('CapHeight', 880);
        fontDescriptor.set('XHeight', 616);
        fontDescriptor.set('Leading', 250);
    };
    _PdfCjkFontDescriptorFactory._fillHeiseiMinchoW3 = function (fontDescriptor, fontFamily, fontMetrics) {
        var fontBox = { x: -123, y: -257, width: 1124, height: 1167 };
        this._fillFontBox(fontDescriptor, fontBox);
        this._fillKnownInformation(fontDescriptor, fontFamily, fontMetrics);
        fontDescriptor.set('StemV', 93);
        fontDescriptor.set('StemH', 93);
        fontDescriptor.set('AvgWidth', 702);
        fontDescriptor.set('MaxWidth', 1000);
        fontDescriptor.set('CapHeight', 718);
        fontDescriptor.set('XHeight', 500);
        fontDescriptor.set('Leading', 250);
    };
    _PdfCjkFontDescriptorFactory._fillSinoTypeSongLight = function (fontDescriptor, fontFamily, fontMetrics) {
        var fontBox = { x: -25, y: -254, width: 1025, height: 1134 };
        this._fillFontBox(fontDescriptor, fontBox);
        this._fillKnownInformation(fontDescriptor, fontFamily, fontMetrics);
        fontDescriptor.set('StemV', 93);
        fontDescriptor.set('StemH', 93);
        fontDescriptor.set('AvgWidth', 1000);
        fontDescriptor.set('MaxWidth', 1000);
        fontDescriptor.set('CapHeight', 880);
        fontDescriptor.set('XHeight', 616);
        fontDescriptor.set('Leading', 250);
    };
    _PdfCjkFontDescriptorFactory._fillMonotypeHeiMedium = function (fontDescriptor, fontFamily, fontMetrics) {
        var fontBox = { x: -45, y: -250, width: 1060, height: 1137 };
        this._fillFontBox(fontDescriptor, fontBox);
        this._fillKnownInformation(fontDescriptor, fontFamily, fontMetrics);
        fontDescriptor.set('StemV', 93);
        fontDescriptor.set('StemH', 93);
        fontDescriptor.set('AvgWidth', 1000);
        fontDescriptor.set('MaxWidth', 1000);
        fontDescriptor.set('CapHeight', 880);
        fontDescriptor.set('XHeight', 616);
        fontDescriptor.set('Leading', 250);
    };
    _PdfCjkFontDescriptorFactory._fillHanyangSystemsGothicMedium = function (fontDescriptor, fontFamily, fontMetrics) {
        var fontBox = { x: -6, y: -145, width: 1009, height: 1025 };
        this._fillFontBox(fontDescriptor, fontBox);
        this._fillKnownInformation(fontDescriptor, fontFamily, fontMetrics);
        fontDescriptor.set('Flags', 4);
        fontDescriptor.set('StemV', 93);
        fontDescriptor.set('StemH', 93);
        fontDescriptor.set('AvgWidth', 1000);
        fontDescriptor.set('MaxWidth', 1000);
        fontDescriptor.set('CapHeight', 880);
        fontDescriptor.set('XHeight', 616);
        fontDescriptor.set('Leading', 250);
    };
    _PdfCjkFontDescriptorFactory._fillFontBox = function (fontDescriptor, fontBox) {
        fontDescriptor.set('FontBBox', _fromRectangle(fontBox));
    };
    _PdfCjkFontDescriptorFactory._fillKnownInformation = function (fontDescriptor, fontFamily, fontMetrics) {
        fontDescriptor.set('FontName', _PdfName.get(fontMetrics._postScriptName));
        fontDescriptor.set('Type', _PdfName.get('FontDescriptor'));
        fontDescriptor.set('ItalicAngle', 0);
        fontDescriptor.set('MissingWidth', fontMetrics._widthTable._defaultWidth);
        fontDescriptor.set('Ascent', fontMetrics._ascent);
        fontDescriptor.set('Descent', fontMetrics._descent);
        switch (fontFamily) {
            case PdfCjkFontFamily.monotypeHeiMedium:
            case PdfCjkFontFamily.hanyangSystemsGothicMedium:
            case PdfCjkFontFamily.heiseiKakuGothicW5:
                fontDescriptor.set('Flags', 4);
                break;
            case PdfCjkFontFamily.sinoTypeSongLight:
            case PdfCjkFontFamily.monotypeSungLight:
            case PdfCjkFontFamily.hanyangSystemsShinMyeongJoMedium:
            case PdfCjkFontFamily.heiseiMinchoW3:
                fontDescriptor.set('Flags', 6);
                break;
        }
    };
    _PdfCjkFontDescriptorFactory._getFontDescriptor = function (fontFamily, fontStyle, fontMetrics) {
        var fontDescriptor = new _PdfDictionary();
        fontDescriptor._updated = true;
        switch (fontFamily) {
            case PdfCjkFontFamily.hanyangSystemsGothicMedium:
                this._fillHanyangSystemsGothicMedium(fontDescriptor, fontFamily, fontMetrics);
                break;
            case PdfCjkFontFamily.hanyangSystemsShinMyeongJoMedium:
                this._fillHanyangSystemsShinMyeongJoMedium(fontDescriptor, fontFamily, fontMetrics);
                break;
            case PdfCjkFontFamily.heiseiKakuGothicW5:
                this._fillHeiseiKakuGothicW5(fontDescriptor, fontStyle, fontFamily, fontMetrics);
                break;
            case PdfCjkFontFamily.heiseiMinchoW3:
                this._fillHeiseiMinchoW3(fontDescriptor, fontFamily, fontMetrics);
                break;
            case PdfCjkFontFamily.monotypeHeiMedium:
                this._fillMonotypeHeiMedium(fontDescriptor, fontFamily, fontMetrics);
                break;
            case PdfCjkFontFamily.monotypeSungLight:
                this._fillMonotypeSungLight(fontDescriptor, fontFamily, fontMetrics);
                break;
            case PdfCjkFontFamily.sinoTypeSongLight:
                this._fillSinoTypeSongLight(fontDescriptor, fontFamily, fontMetrics);
                break;
        }
        return fontDescriptor;
    };
    return _PdfCjkFontDescriptorFactory;
}());
/**
 * Public enum to define font style.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF standard font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.regular);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfFontStyle;
(function (PdfFontStyle) {
    /**
     * Specifies the font style `regular`.
     */
    PdfFontStyle[PdfFontStyle["regular"] = 0] = "regular";
    /**
     * Specifies the font style `bold`.
     */
    PdfFontStyle[PdfFontStyle["bold"] = 1] = "bold";
    /**
     * Specifies the font style `italic`.
     */
    PdfFontStyle[PdfFontStyle["italic"] = 2] = "italic";
    /**
     * Specifies the font style `underline`.
     */
    PdfFontStyle[PdfFontStyle["underline"] = 4] = "underline";
    /**
     * Specifies the font style `strikeout`.
     */
    PdfFontStyle[PdfFontStyle["strikeout"] = 8] = "strikeout";
})(PdfFontStyle || (PdfFontStyle = {}));
/**
 * Public enum to define font family.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF standard font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.regular);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfFontFamily;
(function (PdfFontFamily) {
    /**
     * Specifies the `helvetica` font family.
     */
    PdfFontFamily[PdfFontFamily["helvetica"] = 0] = "helvetica";
    /**
     * Specifies the `courier` font family.
     */
    PdfFontFamily[PdfFontFamily["courier"] = 1] = "courier";
    /**
     * Specifies the `timesRoman` font family.
     */
    PdfFontFamily[PdfFontFamily["timesRoman"] = 2] = "timesRoman";
    /**
     * Specifies the `symbol` font family.
     */
    PdfFontFamily[PdfFontFamily["symbol"] = 3] = "symbol";
    /**
     * Specifies the `zapfDingbats` font family.
     */
    PdfFontFamily[PdfFontFamily["zapfDingbats"] = 4] = "zapfDingbats";
})(PdfFontFamily || (PdfFontFamily = {}));
/**
 * Public enum to define CJK font family.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF CJK standard font
 * let font: PdfCjkStandardFont = new PdfCjkStandardFont(PdfCjkFontFamily.heiseiMinchoW3, 20);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('こんにちは世界', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfCjkFontFamily;
(function (PdfCjkFontFamily) {
    /**
     * Specifies the `heiseiKakuGothicW5` CJK font family.
     */
    PdfCjkFontFamily[PdfCjkFontFamily["heiseiKakuGothicW5"] = 0] = "heiseiKakuGothicW5";
    /**
     * Specifies the `heiseiMinchoW3` CJK font family.
     */
    PdfCjkFontFamily[PdfCjkFontFamily["heiseiMinchoW3"] = 1] = "heiseiMinchoW3";
    /**
     * Specifies the `hanyangSystemsGothicMedium` CJK font family.
     */
    PdfCjkFontFamily[PdfCjkFontFamily["hanyangSystemsGothicMedium"] = 2] = "hanyangSystemsGothicMedium";
    /**
     * Specifies the `hanyangSystemsShinMyeongJoMedium` CJK font family.
     */
    PdfCjkFontFamily[PdfCjkFontFamily["hanyangSystemsShinMyeongJoMedium"] = 3] = "hanyangSystemsShinMyeongJoMedium";
    /**
     * Specifies the `monotypeHeiMedium` CJK font family.
     */
    PdfCjkFontFamily[PdfCjkFontFamily["monotypeHeiMedium"] = 4] = "monotypeHeiMedium";
    /**
     * Specifies the `monotypeSungLight` CJK font family.
     */
    PdfCjkFontFamily[PdfCjkFontFamily["monotypeSungLight"] = 5] = "monotypeSungLight";
    /**
     * Specifies the `sinoTypeSongLight` CJK font family.
     */
    PdfCjkFontFamily[PdfCjkFontFamily["sinoTypeSongLight"] = 6] = "sinoTypeSongLight";
})(PdfCjkFontFamily || (PdfCjkFontFamily = {}));
var _UnicodeLine = /** @class */ (function () {
    function _UnicodeLine() {
        this._result = false;
        this._glyphIndex = [];
    }
    return _UnicodeLine;
}());

/**
 * Implements graphics path, which is a sequence of primitive graphics elements.
 *
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access the first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics object of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new pen
 * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
 * // Create a new PDF path
 * let path: PdfPath = new PdfPath();
 * // Add a line to the Graphics path
 * path.addLine(10, 250, 200, 250);
 * // Draw the path on the PDF page
 * graphics.drawPath(path, pen);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfPath = /** @class */ (function () {
    function PdfPath(points, pathTypes) {
        this._points = [];
        this._pathTypes = [];
        this._isRoundedRectangle = false;
        this._fillMode = PdfFillMode.winding;
        this._isStart = true;
        this._isXps = false;
        this._brush = undefined;
        this._pen = undefined;
        if (points && pathTypes) {
            if (Array.isArray(points) && Array.isArray(pathTypes)) {
                this._points = points;
                this._pathTypes = pathTypes;
            }
            else {
                throw new Error('Invalid constructor arguments.');
            }
        }
        else {
            this._points = [];
            this._pathTypes = [];
        }
    }
    Object.defineProperty(PdfPath.prototype, "lastPoint", {
        /**
         * Gets the last point of the path.
         *
         * @returns {number[]} The value of the last point.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the graphics object of the PDF page
         * let graphics: PdfGraphics = page.graphics;
         * // Create a new pen
         * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
         * // Create a new brush
         * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
         * // Create a new PDF path
         * let path: PdfPath = new PdfPath([[50, 50], [100, 50], [100, 100], [50, 100], [50, 50]], [0, 1, 1, 1, 1]);
         * // Get the last point of the path.
         * let lastPoint: number[] = path.lastPoint;
         * // Draw the path on the PDF page.
         * page.graphics.drawPath(path, pen, brush);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var value = [0, 0];
            var count = this._points.length;
            if (this._points.length > 0) {
                value[0] = this._points[count - 1][0];
                value[1] = this._points[count - 1][1];
            }
            return value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPath.prototype, "pathPoints", {
        /**
         * Gets the array of points that represent the x and y coordinates defining the path.
         *
         * @returns {Array<number[]>} An array of arrays of numbers, where each inner array represents a set of points.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the graphics object of the PDF page
         * let graphics: PdfGraphics = page.graphics;
         * // Create a new pen
         * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
         * // Create a new brush
         * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
         * // Create a new PDF path
         * let path: PdfPath = new PdfPath([[50, 50], [100, 50], [100, 100], [50, 100], [50, 50]], [0, 1, 1, 1, 1]);
         * // Get the path points of the path
         * let pathPoints: Array<number[]> = path.pathPoints;
         * // Draw the path on the PDF page
         * page.graphics.drawPath(path, pen, brush);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._points;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPath.prototype, "pathTypes", {
        /**
         * Gets the types of the corresponding points in the path.
         *
         * @returns {PathPointType[]} An array of `PathPointType` objects representing the types of each path point.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the graphics object of the PDF page
         * let graphics: PdfGraphics = page.graphics;
         * // Create a new pen
         * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
         * // Create a new brush
         * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
         * // Create a new PDF path
         * let path: PdfPath = new PdfPath([[50, 50], [100, 50], [100, 100], [50, 100], [50, 50]], [0, 1, 1, 1, 1]);
         * // Get the path types of the path
         * let pathTypes: PathPointType[] = path.pathTypes;
         * // Draw the path on the PDF page
         * page.graphics.drawPath(path, pen, brush);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._pathTypes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPath.prototype, "fillMode", {
        /**
         * Gets the fill mode.
         *
         * @returns {PdfFillMode} The fill mode of the PDF path.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the graphics object of the PDF page
         * let graphics: PdfGraphics = page.graphics;
         * // Create a new pen
         * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
         * // Create a new brush
         * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
         * // Create a new PDF path
         * let path: PdfPath = new PdfPath([[50, 50], [100, 50], [100, 100], [50, 100], [50, 50]], [0, 1, 1, 1, 1]);
         * // Get the fill mode of the path
         * let fillMode: PdfFillMode = path.fillMode;
         * // Draw the path on the PDF page
         * page.graphics.drawPath(path, pen, brush);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._fillMode;
        },
        /**
         * Sets the fill mode.
         *
         * @param {PdfFillMode} mode The fill mode of the path.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the graphics object of the PDF page
         * let graphics: PdfGraphics = page.graphics;
         * // Create a new pen
         * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
         * // Create a new brush
         * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
         * // Create a new PDF path
         * let path: PdfPath = new PdfPath([[50, 50], [100, 50], [100, 100], [50, 100], [50, 50]], [0, 1, 1, 1, 1]);
         * // Set the fill mode of the path
         * path.fillMode = PdfFillMode.alternate;
         * // Draw the path on the PDF page
         * page.graphics.drawPath(path, pen, brush);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (mode) {
            this._fillMode = mode;
        },
        enumerable: true,
        configurable: true
    });
    PdfPath.prototype.addPath = function (arg1, arg2) {
        if (arg1 instanceof PdfPath) {
            this._addPath(arg1._points, arg1._pathTypes);
        }
        else if (Array.isArray(arg1) && Array.isArray(arg2)) {
            this._addPath(arg1, arg2);
        }
    };
    PdfPath.prototype._addPath = function (pathPoints, pathTypes) {
        if (!pathPoints || pathPoints.length === 0) {
            throw new Error('Path points cannot be null or undefined.');
        }
        if (!pathTypes || pathTypes.length === 0) {
            throw new Error('Path types cannot be null or undefined.');
        }
        if (pathPoints.length !== pathTypes.length) {
            throw new Error('The argument arrays should be of equal length.');
        }
        for (var i = 0; i < pathPoints.length; i++) {
            if (i >= pathPoints.length || i < 0) {
                throw new Error('Index' + i + 'is out of bounds.');
            }
            this._points.push(pathPoints[Number.parseInt(i.toString(), 10)].slice());
            this._pathTypes.push(pathTypes[Number.parseInt(i.toString(), 10)]);
        }
    };
    /**
     * Adds a line segment to the path.
     *
     * @param {number} x1 The x-coordinate of the starting point of the line.
     * @param {number} y1 The y-coordinate of the starting point of the line.
     * @param {number} x2 The x-coordinate of the ending point of the line.
     * @param {number} y2 The y-coordinate of the ending point of the line.
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics object of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Create a new PDF path
     * let path: PdfPath = new PdfPath();
     * // Add a line segment to the path
     * path.addLine(10, 250, 200, 250);
     * // Draw the path on the PDF page
     * graphics.drawPath(path, pen);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfPath.prototype.addLine = function (x1, y1, x2, y2) {
        this._addPoints([x1, y1, x2, y2], PathPointType.line);
    };
    PdfPath.prototype._addLines = function (linePoints) {
        var start = linePoints[0];
        if (linePoints.length === 1) {
            this._addPoint(linePoints[0], PathPointType.line);
        }
        else {
            for (var i = 1; i < linePoints.length; i++) {
                var last = linePoints[Number.parseInt(i.toString(), 10)];
                this.addLine(start[0], start[1], last[0], last[1]);
                start = last;
            }
        }
    };
    PdfPath.prototype._addPoints = function (points, type, start, end) {
        var startIndex = (typeof start !== 'undefined') ? start : 0;
        var endIndex = (typeof end !== 'undefined') ? end : points.length;
        for (var i = startIndex; i < endIndex; i += 2) {
            var point = [points[Number.parseInt(i.toString(), 10)], points[i + 1]];
            if (i === startIndex) {
                if (this._points.length === 0 || this._isStart) {
                    this._addPoint(point, PathPointType.start);
                    this._isStart = false;
                }
                else if (this._isRoundedRectangle && (point[0] !== this.lastPoint[0] || point[1] !== this.lastPoint[1])) {
                    this._addPoint(point, PathPointType.line);
                }
                else if (point[0] !== this.lastPoint[0] && point[1] !== this.lastPoint[1]) {
                    this._addPoint(point, PathPointType.line);
                }
            }
            else {
                this._addPoint(point, type);
            }
        }
    };
    PdfPath.prototype._addPoint = function (point, type) {
        this._points.push(point);
        this._pathTypes.push(type);
    };
    /**
     * Adds an arc within a bounding rectangle using the angles that define the start and sweep of the arc.
     *
     * @param {number} x The x-coordinate of the upper-left corner of the rectangular region.
     * @param {number} y The y-coordinate of the upper-left corner of the rectangular region.
     * @param {number} width The width of the rectangular region.
     * @param {number} height The height of the rectangular region.
     * @param {number} startAngle The start angle of the arc.
     * @param {number} sweepAngle The angle between start angle and the end of the arc.
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(readFromResources('Empty.pdf'));
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics object of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Create a new PDF path
     * let path: PdfPath = new PdfPath();
     * // Add a Bezier curve to the path
     * path.addBezier(10, 100, 50, 150, 150, 150, 200, 100);
     * // Draw the path on the PDF page
     * graphics.drawPath(path, pen);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfPath.prototype.addArc = function (x, y, width, height, startAngle, sweepAngle) {
        var points = _getBezierArc(x, y, x + width, y + height, startAngle, sweepAngle);
        for (var i = 0; i < points.length; ++i) {
            var list = [points[Number.parseInt(i.toString(), 10)],
                points[++i],
                points[++i],
                points[++i],
                points[++i],
                points[++i],
                points[++i],
                points[++i]];
            this._addPoints(list, PathPointType.bezier);
        }
    };
    /**
     * Adds a rectangle to the path.
     *
     * @param {number} x The x-coordinate of the upper-left corner of the rectangle.
     * @param {number} y The y-coordinate of the upper-left corner of the rectangle.
     * @param {number} width The width of the rectangle.
     * @param {number} height The height of the rectangle.
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics object of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Create a new brush
     * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
     * // Create a new PDF path
     * let path: PdfPath = new PdfPath();
     * // Add a rectangle to the path
     * path.addRectangle(10, 20, 50, 100);
     * // Draw the path on the PDF page
     * graphics.drawPath(path, pen, brush);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfPath.prototype.addRectangle = function (x, y, width, height) {
        this.startFigure();
        this._addPoints([x, y, x + width, y, x + width, y + height, x, y + height], PathPointType.line);
        this.closeFigure();
    };
    /**
     * Adds a polygon to the path.
     *
     * @param {Array<number[]>} points The points of the polygon, where each point is an array of two numbers representing the x and y coordinates.
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics object of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Create a new brush
     * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
     * // Create a new PDF path
     * let path: PdfPath = new PdfPath();
     * // Add a polygon to the path
     * path.addPolygon([[200, 10], [300, 100], [150, 100], [200, 10]]);
     * // Draw the path on the PDF page
     * graphics.drawPath(path, pen, brush);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfPath.prototype.addPolygon = function (points) {
        var newPoints = [];
        points.forEach(function (element) {
            newPoints.push(element[0], element[1]);
        });
        this.startFigure();
        this._addPoints(newPoints, PathPointType.line);
        this.closeFigure();
    };
    /**
     * Adds an ellipse to the path.
     *
     * @param {number} x The x-coordinate of the upper-left corner of the rectangular region that bounds the ellipse.
     * @param {number} y The y-coordinate of the upper-left corner of the rectangular region that bounds the ellipse.
     * @param {number} width The width of the bounding rectangle for the ellipse.
     * @param {number} height The height of the bounding rectangle for the ellipse.
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics object of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Create a new brush
     * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
     * // Create a new PDF path
     * let path: PdfPath = new PdfPath();
     * // Add an ellipse to the path
     * path.addEllipse(200, 200, 100, 50);
     * // Draw the path on the PDF page
     * graphics.drawPath(path, pen, brush);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfPath.prototype.addEllipse = function (x, y, width, height) {
        this.startFigure();
        this.addArc(x, y, width, height, 0, 360);
        this.closeFigure();
    };
    /**
     * Adds a Bezier curve to the path using specified coordinates for the start point, two control points, and the end point.
     *
     * @param {number} startX The x-coordinate of the starting point of the Bezier curve.
     * @param {number} startY The y-coordinate of the starting point of the Bezier curve.
     * @param {number} firstX The x-coordinate of the first control point of the Bezier curve.
     * @param {number} firstY The y-coordinate of the first control point of the Bezier curve.
     * @param {number} secondX The x-coordinate of the second control point of the Bezier curve.
     * @param {number} secondY The y-coordinate of the second control point of the Bezier curve.
     * @param {number} endX The x-coordinate of the ending point of the Bezier curve.
     * @param {number} endY The y-coordinate of the ending point of the Bezier curve.
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics object of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Create a new brush
     * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
     * // Create a new PDF path
     * let path: PdfPath = new PdfPath();
     * // Add a Bezier curve to the path
     * path.addBezier(100, 100, 150, 150, 50, 250, 100, 300);
     * // Draw the path on the PDF page
     * graphics.drawPath(path, pen, brush);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfPath.prototype.addBezier = function (startX, startY, firstX, firstY, secondX, secondY, endX, endY) {
        var points = [startX, startY, firstX, firstY, secondX, secondY, endX, endY];
        this._addPoints(points, PathPointType.bezier);
    };
    PdfPath.prototype._addBezierPoints = function (pointsCollection) {
        if (pointsCollection.length < 4) {
            throw Error('Incorrect size of array points');
        }
        var bound = 3;
        var index = 0;
        var start = pointsCollection[Number.parseInt(index.toString(), 10)];
        index++;
        while ((index + bound) <= pointsCollection.length) {
            var inner1 = pointsCollection[Number.parseInt(index.toString(), 10)];
            index++;
            var inner2 = pointsCollection[Number.parseInt(index.toString(), 10)];
            index++;
            var end = pointsCollection[Number.parseInt(index.toString(), 10)];
            index++;
            this.addBezier(start[0], start[1], inner1[0], inner1[1], inner2[0], inner2[1], end[0], end[1]);
            start = end;
        }
    };
    /**
     * Adds a pie slice to the path.
     *
     * @param {number} x The x-coordinate of the upper-left corner of the bounding rectangle.
     * @param {number} y The y-coordinate of the upper-left corner of the bounding rectangle.
     * @param {number} width The width of the bounding rectangle.
     * @param {number} height The height of the bounding rectangle.
     * @param {number} startAngle The angle in degrees measured clockwise from the x-axis to the start of the pie slice.
     * @param {number} sweepAngle The angle in degrees measured clockwise from the startAngle parameter to the end of the pie slice.
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics object of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Create a new brush
     * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
     * // Create a new PDF path
     * let path: PdfPath = new PdfPath();
     * // Add a pie slice to the path
     * path.addPie(0, 20, 100, 100, 270, 45);
     * // Draw the path on the PDF page
     * graphics.drawPath(path, pen, brush);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfPath.prototype.addPie = function (x, y, width, height, startAngle, sweepAngle) {
        this.startFigure();
        this.addArc(x, y, width, height, startAngle, sweepAngle);
        this._addPoint([x + width / 2, y + height / 2], PathPointType.line);
        this.closeFigure();
    };
    /**
     * Starts a new figure in the path.
     *
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics object of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Create a new brush
     * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
     * // Create a new PDF path
     * let path: PdfPath = new PdfPath();
     * // Start a new figure in the path
     * path.startFigure();
     * // Add some path points (optional)
     * path.addLine(50, 50, 100, 50);
     * // Draw the path on the PDF page
     * graphics.drawPath(path, pen, brush);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfPath.prototype.startFigure = function () {
        this._isStart = true;
    };
    PdfPath.prototype.closeFigure = function (index) {
        if (typeof index !== 'undefined') {
            var type = this._pathTypes[Number.parseInt(index.toString(), 10)];
            type |= PathPointType.closePath;
            this._pathTypes[Number.parseInt(index.toString(), 10)] = type;
        }
        else {
            if (this._points.length > 0) {
                this.closeFigure(this._points.length - 1);
            }
            this.startFigure();
        }
    };
    /**
     * Closes all non-closed figures in the path.
     *
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics object of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Create a new brush
     * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
     * // Create a new PDF path
     * let path: PdfPath = new PdfPath([[50, 50], [100, 50], [100, 100], [50, 100], [50, 50]], [0, 1, 1, 1, 1]);
     * // Close all non-closed figures
     * path.closeAllFigures();
     * // Draw the path on the PDF page
     * page.graphics.drawPath(path, pen, brush);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfPath.prototype.closeAllFigures = function () {
        for (var i = 0; i < this._points.length; ++i) {
            var pointType = this._pathTypes[Number.parseInt(i.toString(), 10)];
            var flag = false;
            if (i !== 0 && pointType === PathPointType.start) {
                this.closeFigure(i - 1);
                flag = true;
            }
            else if (i === this._pathTypes.length - 1 && !flag && this._isXps) {
                if (this._points[0][0] === this._points[Number.parseInt(i.toString(), 10)][0] &&
                    this._points[0][1] === this._points[Number.parseInt(i.toString(), 10)][1]) {
                    this.closeFigure(i);
                }
            }
        }
    };
    PdfPath.prototype._getBounds = function () {
        var bounds = [0, 0, 0, 0];
        if (this._points.length > 0) {
            var xmin = this._points[0][0];
            var xmax = this._points[0][0];
            var ymin = this._points[0][1];
            var ymax = this._points[0][1];
            for (var i = 1; i < this._points.length; ++i) {
                var point = this._points[Number.parseInt(i.toString(), 10)];
                xmin = Math.min(point[0], xmin);
                xmax = Math.max(point[0], xmax);
                ymin = Math.min(point[1], ymin);
                ymax = Math.max(point[1], ymax);
            }
            bounds = [xmin, ymin, xmax - xmin, ymax - ymin];
        }
        return bounds;
    };
    return PdfPath;
}());

/**
 * The 'PdfImage' contains methods and properties to handle the images.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create new image object by using JPEG image data as Base64 string format
 * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
 * //Draw the image.
 * graphics.drawImage(image, 10, 20, 400, 400);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfImage = /** @class */ (function () {
    function PdfImage() {
    }
    Object.defineProperty(PdfImage.prototype, "width", {
        /**
         * Gets the width of the PDF image.
         *
         * @returns {number} image width.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the graphics of the PDF page
         * let graphics: PdfGraphics = page.graphics;
         * // Create new image object by using JPEG image data as Base64 string format
         * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
         * // Gets the width of the image.
         * let width: number = image.width;
         * //Draw the image.
         * image.draw(graphics);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._imageWidth;
        },
        /**
         * Sets the width of the PDF image.
         *
         * @param {number} value value.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the graphics of the PDF page
         * let graphics: PdfGraphics = page.graphics;
         * // Create new image object by using JPEG image data as Base64 string format
         * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
         * // Sets the width of the image.
         * image.width = 100;
         * //Draw the image.
         * image.draw(graphics);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._imageWidth = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfImage.prototype, "height", {
        /**
         * Gets the height of the PDF image.
         *
         * @returns {number} image height.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the graphics of the PDF page
         * let graphics: PdfGraphics = page.graphics;
         * // Create new image object by using JPEG image data as Base64 string format
         * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
         * // Gets the height of the image.
         * let height: number = image.height;
         * //Draw the image.
         * image.draw(graphics);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._imageHeight;
        },
        /**
         * Sets the height of the PDF image.
         *
         * @param {number} value value.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the graphics of the PDF page
         * let graphics: PdfGraphics = page.graphics;
         * // Create new image object by using JPEG image data as Base64 string format
         * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
         * // Sets the height of the image.
         * image.height = 100;
         * //Draw the image.
         * image.draw(graphics);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._imageHeight = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfImage.prototype, "physicalDimension", {
        /**
         * Gets the physical dimension of the PDF image (Read only).
         *
         * @returns {number[]} image physical dimension.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the graphics of the PDF page
         * let graphics: PdfGraphics = page.graphics;
         * // Create new image object by using JPEG image data as Base64 string format
         * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
         * // Gets the physical dimension of the image.
         * let dimension: number[] = image.physicalDimension;
         * //Draw the image.
         * image.draw(graphics);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            this._imagePhysicalDimension = this._getPointSize(this.width, this.height, this._horizontalResolution);
            return [this.width, this.height];
        },
        enumerable: true,
        configurable: true
    });
    PdfImage.prototype.draw = function (graphics, x, y) {
        if ((x === null || typeof x === 'undefined') && (y === null || typeof y === 'undefined')) {
            x = 0;
            y = 0;
        }
        var needSave = (x !== 0 || y !== 0);
        var state = null;
        if (needSave) {
            state = graphics.save();
            graphics.translateTransform(x, y);
        }
        graphics.drawImage(this, 0, 0);
        if (needSave) {
            graphics.restore(state);
        }
    };
    PdfImage.prototype._getPointSize = function (width, height, horizontalResolution) {
        if ((horizontalResolution === null || typeof horizontalResolution === 'undefined')) {
            var dpiX = 96;
            var size = this._getPointSize(width, height, dpiX);
            return size;
        }
        else {
            var ucX = new _PdfUnitConvertor();
            var ucY = new _PdfUnitConvertor();
            var ptWidth = ucX._convertUnits(width, _PdfGraphicsUnit.pixel, _PdfGraphicsUnit.point);
            var ptHeight = ucY._convertUnits(height, _PdfGraphicsUnit.pixel, _PdfGraphicsUnit.point);
            var size = [ptWidth, ptHeight];
            return size;
        }
    };
    return PdfImage;
}());

/**
 * Represents a graphics from a PDF page.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * //Create a new pen.
 * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
 * //Draw line on the page graphics.
 * graphics.drawLine(pen, 10, 10, 100, 100);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfGraphics = /** @class */ (function () {
    /**
     * Initializes a new instance of the `PdfGraphics` class.
     *
     * @param {number[]} size The graphics client size.
     * @param {_PdfContentStream} content Content stream.
     * @param {_PdfCrossReference} xref Cross reference.
     * @param {PdfPage | PdfTemplate} source Source object of the graphics.
     * @private
     */
    function PdfGraphics(size, content, xref, source) {
        this._pendingResource = []; // eslint-disable-line
        this._isItalic = false;
        this._hasResourceReference = false;
        if (source instanceof PdfPage) {
            this._source = source._pageDictionary;
            this._page = source;
        }
        else if (source instanceof PdfTemplate) {
            this._source = source._content.dictionary;
            this._template = source;
        }
        if (this._source && this._source.has('Resources')) {
            var obj = this._source.getRaw('Resources'); // eslint-disable-line
            if (obj) {
                if (obj instanceof _PdfReference) {
                    this._hasResourceReference = true;
                    this._resourceObject = xref._fetch(obj);
                }
                else if (obj instanceof _PdfDictionary) {
                    this._resourceObject = obj;
                }
            }
        }
        else {
            this._resourceObject = new _PdfDictionary();
            this._source.update('Resources', this._resourceObject);
        }
        this._crossReference = xref;
        this._sw = new _PdfStreamWriter(content);
        this._size = size;
        _addProcSet('PDF', this._resourceObject);
        this._initialize();
    }
    Object.defineProperty(PdfGraphics.prototype, "clientSize", {
        /**
         * Gets the size of the canvas reduced by margins and page templates (Read only).
         *
         * @returns {number[]} The width and height of the client area as number array.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the graphics client size.
         * let size: number[] = page.graphics.clientSize;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return [this._clipBounds[2], this._clipBounds[3]];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphics.prototype, "_matrix", {
        get: function () {
            if (typeof this._m === 'undefined') {
                this._m = new _PdfTransformationMatrix();
            }
            return this._m;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphics.prototype, "_resources", {
        get: function () {
            var _this = this;
            if (typeof this._resourceMap === 'undefined') {
                this._resourceMap = new Map();
                if (this._resourceObject && this._resourceObject.has('Font')) {
                    var fonts = this._resourceObject.get('Font');
                    if (fonts && fonts.size > 0) {
                        fonts.forEach(function (key, value) {
                            if (value !== null && typeof value !== 'undefined' && value instanceof _PdfReference) {
                                _this._resourceMap.set(value, _PdfName.get(key));
                            }
                        });
                    }
                }
                if (this._resourceObject.has('XObject')) {
                    var other = this._resourceObject.get('XObject');
                    if (other && other.size > 0) {
                        other.forEach(function (key, value) {
                            if (value !== null && typeof value !== 'undefined' && value instanceof _PdfReference) {
                                _this._resourceMap.set(value, _PdfName.get(key));
                            }
                        });
                    }
                }
                if (this._resourceObject.has('ExtGState')) {
                    var state = this._resourceObject.get('ExtGState');
                    if (state && state.size > 0) {
                        if (!this._transparencies) {
                            this._transparencies = new Map();
                        }
                        state.forEach(function (key, value) {
                            if (value !== null && typeof value !== 'undefined' && value instanceof _PdfReference) {
                                _this._setTransparencyData(value, _PdfName.get(key));
                            }
                        });
                    }
                }
            }
            return this._resourceMap;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Save the current graphics state.
     *
     * @returns {PdfGraphicsState} graphics state.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new font
     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // Save the graphics
     * let state: PdfGraphicsState = graphics.save();
     * //Set graphics translate transform.
     * graphics.translateTransform(100, 100);
     * //Draws the String.
     * graphics.drawString("Hello world!", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));
     * //Restore the graphics.
     * graphics.restore(state);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfGraphics.prototype.save = function () {
        var state = new PdfGraphicsState(this, this._matrix);
        state._textRenderingMode = this._textRenderingMode;
        state._charSpacing = this._characterSpacing;
        state._textScaling = this._textScaling;
        state._wordSpacing = this._wordSpacing;
        state._currentBrush = this._currentBrush;
        state._currentPen = this._currentPen;
        state._currentFont = this._currentFont;
        this._graphicsState.push(state);
        this._sw._saveGraphicsState();
        return state;
    };
    /**
     * Restore the graphics state.
     *
     * @param {PdfGraphicsState} state graphics state.
     * @returns {void} restore of the graphics state.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new font
     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // Save the graphics
     * let state: PdfGraphicsState = graphics.save();
     * //Set graphics translate transform.
     * graphics.translateTransform(100, 100);
     * //Draws the String.
     * graphics.drawString("Hello world!", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));
     * //Restore the graphics.
     * graphics.restore(state);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfGraphics.prototype.restore = function (state) {
        if (this._graphicsState.length > 0) {
            if (typeof state === 'undefined') {
                this._doRestore();
            }
            else {
                if (this._graphicsState.length > 0 && this._graphicsState.indexOf(state) !== -1) {
                    while (this._graphicsState.length > 0) {
                        if (this._doRestore() === state) {
                            break;
                        }
                    }
                }
            }
        }
    };
    PdfGraphics.prototype._doRestore = function () {
        var state = this._graphicsState.pop();
        this._m = state._transformationMatrix;
        this._currentBrush = state._currentBrush;
        this._currentPen = state._currentPen;
        this._currentFont = state._currentFont;
        this._characterSpacing = state._charSpacing;
        this._wordSpacing = state._wordSpacing;
        this._textScaling = state._textScaling;
        this._textRenderingMode = state._textRenderingMode;
        this._sw._restoreGraphicsState();
        return state;
    };
    PdfGraphics.prototype.drawRectangle = function (x, y, width, height, first, second) {
        this._beginMarkContent();
        var result = this._setPenBrush(first, second);
        this._sw._appendRectangle(x, y, width, height);
        this._drawGraphicsPath(result.pen, result.brush);
        this._endMarkContent();
    };
    /**
     * Draws a Bezier curve using a specified pen and coordinates for the start point, two control points, and end point.
     *
     * @param {number} startX The x-coordinate of the starting point of the Bezier curve.
     * @param {number} startY The y-coordinate of the starting point of the Bezier curve.
     * @param {number} firstX The x-coordinate of the first control point of the Bezier curve.
     * @param {number} firstY The y-coordinate of the first control point of the Bezier curve.
     * @param {number} secondX The x-coordinate of the second control point of the Bezier curve.
     * @param {number} secondY The y-coordinate of the second control point of the Bezier curve.
     * @param {number} endX The x-coordinate of the ending point of the Bezier curve.
     * @param {number} endY The y-coordinate of the ending point of the Bezier curve.
     * @param {PdfPen} pen The pen that determines the stroke color, width, and style of the Bezier curve.
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Draw a Bezier curve on the page graphics
     * graphics.drawBezier(50, 100, 200, 50, 100, 150, 150, 100, pen);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfGraphics.prototype.drawBezier = function (startX, startY, firstX, firstY, secondX, secondY, endX, endY, pen) {
        this._beginMarkContent();
        this._stateControl(pen, null, null);
        this._sw._beginPath(startX, startY);
        this._sw._appendBezierSegment(firstX, firstY, secondX, secondY, endX, endY);
        this._drawGraphicsPath(pen);
        this._endMarkContent();
    };
    PdfGraphics.prototype.drawPie = function (x, y, width, height, startAngle, sweepAngle, first, second) {
        this._beginMarkContent();
        var result = this._setPenBrush(first, second);
        this._constructPiePath(x, y, x + width, y + height, startAngle, sweepAngle);
        this._sw._appendLineSegment(x + width / 2, y + height / 2);
        this._drawGraphicsPath(result.pen, result.brush, null, true);
        this._endMarkContent();
    };
    PdfGraphics.prototype.drawPolygon = function (points, first, second) {
        this._beginMarkContent();
        if (points.length > 0) {
            var result = this._setPenBrush(first, second);
            this._sw._beginPath(points[0][0], points[0][1]);
            for (var i = 1; i < points.length; i++) {
                this._sw._appendLineSegment(points[Number.parseInt(i.toString(), 10)][0], points[Number.parseInt(i.toString(), 10)][1]);
            }
            this._drawGraphicsPath(result.pen, result.brush, PdfFillMode.winding, true);
        }
        this._endMarkContent();
    };
    PdfGraphics.prototype.drawEllipse = function (x, y, width, height, first, second) {
        this._beginMarkContent();
        var result = this._setPenBrush(first, second);
        this._constructArcPath(x, y, x + width, y + height, 0, 360);
        this._drawGraphicsPath(result.pen, result.brush, PdfFillMode.winding, true);
        this._endMarkContent();
    };
    /**
     * Draw arc on the page graphics.
     *
     * @param {number} x The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the arc shape comes.
     * @param {number} y The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the arc shape comes.
     * @param {number} width Width of the bounding rectangle that defines the ellipse from which the arc shape comes.
     * @param {number} height Height of the bounding rectangle that defines the ellipse from which the arc shape comes.
     * @param {number} startAngle Angle measured in degrees clockwise from the x-axis to the first side of the arc shape.
     * @param {number} sweepAngle Angle measured in degrees clockwise from the startAngle parameter to the second side of the arc shape.
     * @param {PdfPen} pen Pen that determines the stroke color, width, and style of the arc.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Draw an arc on the page graphics
     * graphics.drawArc(10, 20, 100, 200, 20, 30, pen);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfGraphics.prototype.drawArc = function (x, y, width, height, startAngle, sweepAngle, pen) {
        if (sweepAngle !== 0) {
            this._beginMarkContent();
            this._stateControl(pen);
            this._constructArcPath(x, y, x + width, y + height, startAngle, sweepAngle);
            this._drawGraphicsPath(pen, null, PdfFillMode.winding, false);
            this._endMarkContent();
        }
    };
    PdfGraphics.prototype._beginMarkContent = function () {
        if (this._layer) {
            this._layer._beginLayer(this);
        }
    };
    PdfGraphics.prototype._endMarkContent = function () {
        if (this._layer) {
            if (this._layer._isEndState && this._layer._parentLayer.length !== 0) {
                for (var i = 0; i < this._layer._parentLayer.length; i++) {
                    this._sw._write('EMC');
                }
            }
            if (this._layer._isEndState) {
                this._sw._write('EMC');
            }
        }
    };
    PdfGraphics.prototype.drawImage = function (arg1, arg2, arg3, arg4, arg5) {
        this._beginMarkContent();
        if (typeof arg2 === 'number' && typeof arg3 === 'number' && typeof arg4 === 'undefined') {
            var size = arg1.physicalDimension;
            this.drawImage(arg1, arg2, arg3, size[0], size[1]);
        }
        else {
            arg1._save();
            var matrix = new _PdfTransformationMatrix();
            this._getTranslateTransform(arg2, (arg3 + arg5), matrix);
            this._getScaleTransform(arg4, arg5, matrix);
            this._sw._write('q');
            this._sw._modifyCtm(matrix);
            var sourceDictionary = void 0;
            var keyName = void 0;
            var isNew = true;
            if (this._resourceObject.has('XObject')) {
                var obj = this._resourceObject.getRaw('XObject'); // eslint-disable-line
                if (obj instanceof _PdfDictionary) {
                    sourceDictionary = obj;
                }
                if (sourceDictionary) {
                    isNew = false;
                }
            }
            if (isNew) {
                sourceDictionary = new _PdfDictionary(this._crossReference);
                this._resourceObject.update('XObject', sourceDictionary);
            }
            if (typeof keyName === 'undefined') {
                keyName = _PdfName.get(_getNewGuidString());
            }
            if (this._crossReference) {
                this._updateImageResource(arg1, keyName, sourceDictionary, this._crossReference);
                this._source.update('Resources', this._resourceObject);
                this._source._updated = true;
            }
            else {
                this._pendingResource.push({ 'resource': arg1, 'key': keyName, 'source': sourceDictionary });
            }
            this._sw._executeObject(keyName);
            this._sw._write('Q');
            this._sw._write('\r\n');
            _addProcSet('ImageB', this._resourceObject);
            _addProcSet('ImageC', this._resourceObject);
            _addProcSet('ImageI', this._resourceObject);
            _addProcSet('Text', this._resourceObject);
        }
        this._endMarkContent();
    };
    /**
     * Draws a PDF template onto the page graphics.
     *
     * @param {PdfTemplate} template The PDF template to be drawn.
     * @param {{x: number, y: number, width: number, height: number}} bounds The bounds of the template.
     * @param {number} bounds.x The x-coordinate of the upper-left corner where the template will be drawn.
     * @param {number} bounds.y The y-coordinate of the upper-left corner where the template will be drawn.
     * @param {number} bounds.width The width of the area where the template will be drawn.
     * @param {number} bounds.height The height of the area where the template will be drawn.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Get the first annotation of the page
     * let annotation: PdfRubberStampAnnotation = page.annotations.at(0) as PdfRubberStampAnnotation;
     * // Get the appearance template of the annotation
     * let template: PdfTemplate = annotation.createTemplate();
     * // Get the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Draw the template on the page graphics within the specified bounds
     * graphics.drawTemplate(template, { x: 10, y: 20, width: template.size[0], height: template.size[1] });
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfGraphics.prototype.drawTemplate = function (template, bounds) {
        var _this = this;
        this._beginMarkContent();
        if (typeof template !== 'undefined') {
            if (template._isExported || template._isResourceExport) {
                if (this._crossReference) {
                    template._crossReference = this._crossReference;
                    template._importStream(true, template._isResourceExport);
                }
                else {
                    template._importStream(false, template._isResourceExport);
                    this._pendingResource.push(template);
                }
            }
            var scaleX = (template && template._size[0] > 0) ? bounds.width / template._size[0] : 1;
            var scaleY = (template && template._size[1] > 0) ? bounds.height / template._size[1] : 1;
            var needScale = !(Math.trunc(scaleX * 1000) / 1000 === 1 && Math.trunc(scaleY * 1000) / 1000 === 1);
            var cropBox = void 0;
            var mediaBox = void 0;
            if (this._page) {
                cropBox = this._page.cropBox;
                mediaBox = this._page.mediaBox;
                if (this._page._pageDictionary.has('CropBox') && this._page._pageDictionary.has('MediaBox')) {
                    if (cropBox[0] > 0 && cropBox[1] > 0 && mediaBox[0] < 0 && mediaBox[1] < 0) {
                        this.translateTransform(cropBox[0], -cropBox[1]);
                        bounds.x = -cropBox[0];
                        bounds.y = cropBox[1];
                    }
                }
            }
            var state = this.save();
            var matrix = new _PdfTransformationMatrix();
            if (this._page) {
                var needTransform = (this._page._pageDictionary.has('CropBox') &&
                    this._page._pageDictionary.has('MediaBox') && cropBox && mediaBox &&
                    cropBox[0] === mediaBox[0] && cropBox[1] === mediaBox[1] && cropBox[2] === mediaBox[2] && cropBox[3] === mediaBox[3]) ||
                    (this._page._pageDictionary.has('MediaBox') && mediaBox && mediaBox[3] === 0);
                matrix._translate(bounds.x, -(bounds.y + ((this._page._origin[0] >= 0 || needTransform) ? bounds.height : 0)));
            }
            else {
                matrix._translate(bounds.x, -(bounds.y + bounds.height));
            }
            var scaleApplied = false;
            if (template._content && template._content.dictionary) {
                var dictionary = template._content.dictionary;
                if (dictionary.has('Matrix') && dictionary.has('BBox')) {
                    var templateMatrix = dictionary.getArray('Matrix');
                    var templateBox = dictionary.getArray('BBox');
                    if (templateMatrix && templateBox && templateMatrix.length > 5 && templateBox.length > 3) {
                        var templateScaleX = Number.parseFloat(_numberToString(-templateMatrix[1]));
                        var templateScaleY = Number.parseFloat(_numberToString(templateMatrix[2]));
                        var roundScaleX = Number.parseFloat(_numberToString(scaleX));
                        var roundScaleY = Number.parseFloat(_numberToString(scaleY));
                        if (roundScaleX === templateScaleX &&
                            roundScaleY === templateScaleY &&
                            templateBox[2] === template._size[0] &&
                            templateBox[3] === template._size[1] && template._isAnnotationTemplate
                            && template._needScale && needScale) {
                            matrix = new _PdfTransformationMatrix();
                            matrix._translate(bounds.x - templateMatrix[4], -(bounds.y + templateMatrix[5]));
                            matrix._scale(1, 1);
                            scaleApplied = true;
                        }
                        else if (templateBox[0] !== 0 && templateBox[1] !== 0 && templateBox[0] === bounds.x &&
                            this._page && template._isSignature) {
                            matrix._translate(bounds.x - templateBox[0], -this._page.size[1]);
                            matrix._scale(scaleX, scaleY);
                            scaleApplied = true;
                        }
                    }
                }
            }
            if (needScale && !scaleApplied) {
                matrix._scale(scaleX, scaleY);
            }
            this._sw._modifyCtm(matrix);
            var sourceDictionary = void 0;
            var isReference = false;
            var keyName_1;
            var isNew = true;
            var ref_1;
            if (this._resourceObject.has('XObject')) {
                var obj = this._resourceObject.getRaw('XObject'); // eslint-disable-line
                if (obj) {
                    if (obj instanceof _PdfReference) {
                        isReference = true;
                        sourceDictionary = this._crossReference._fetch(obj);
                    }
                    else if (obj instanceof _PdfDictionary) {
                        sourceDictionary = obj;
                    }
                }
                if (sourceDictionary) {
                    isNew = false;
                    this._resources.forEach(function (value, key) {
                        if (key && key instanceof _PdfReference) {
                            var base = _this._crossReference._fetch(key);
                            if (base && template && base === template._content) {
                                keyName_1 = value;
                                ref_1 = key;
                            }
                        }
                    });
                }
            }
            if (isNew) {
                sourceDictionary = new _PdfDictionary(this._crossReference);
                this._resourceObject.update('XObject', sourceDictionary);
            }
            if (typeof keyName_1 === 'undefined') {
                keyName_1 = _PdfName.get(_getNewGuidString());
                if (template && template._content.reference) {
                    ref_1 = template._content.reference;
                }
                else if (this._crossReference) {
                    ref_1 = this._crossReference._getNextReference();
                }
                else {
                    this._pendingResource.push({ 'resource': template._content, 'key': keyName_1, 'source': sourceDictionary });
                }
                if (ref_1 && this._crossReference) {
                    if (!this._crossReference._cacheMap.has(ref_1) && template && template._content) {
                        this._crossReference._cacheMap.set(ref_1, template._content);
                    }
                    sourceDictionary.update(keyName_1.name, ref_1);
                    this._resources.set(ref_1, keyName_1);
                }
                this._resourceObject._updated = true;
            }
            if (isReference) {
                this._resourceObject._updated = true;
            }
            if (this._hasResourceReference) {
                this._source._updated = true;
            }
            this._sw._executeObject(keyName_1);
            this.restore(state);
            _addProcSet('ImageB', this._resourceObject);
            _addProcSet('ImageC', this._resourceObject);
            _addProcSet('ImageI', this._resourceObject);
            _addProcSet('Text', this._resourceObject);
        }
        this._endMarkContent();
    };
    PdfGraphics.prototype._processResources = function (crossReference) {
        this._crossReference = crossReference;
        if (this._pendingResource.length > 0) {
            for (var i = 0; i < this._pendingResource.length; i++) {
                var entry = this._pendingResource[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                if (entry instanceof PdfTemplate) {
                    entry._crossReference = crossReference;
                    entry._updatePendingResource(crossReference);
                }
                else if (entry.resource instanceof _PdfBaseStream) {
                    var reference = void 0;
                    if (entry.resource._reference) {
                        reference = entry.resource._reference;
                    }
                    else {
                        reference = crossReference._getNextReference();
                        entry.resource._reference = reference;
                    }
                    if (!crossReference._cacheMap.has(reference) && entry.resource) {
                        crossReference._cacheMap.set(reference, entry.resource);
                    }
                    entry.source.update(entry.key.name, reference);
                    this._resources.set(reference, entry.key);
                }
                else if (entry.resource instanceof PdfImage) {
                    this._updateImageResource(entry.resource, entry.key, entry.source, crossReference);
                }
                else if (entry.resource instanceof PdfFont) {
                    this._updateFontResource(entry.resource, entry.key, entry.source, crossReference);
                }
                this._source.update('Resources', this._resourceObject);
                this._source._updated = true;
            }
            this._pendingResource = [];
        }
    };
    PdfGraphics.prototype._updateImageResource = function (image, keyName, source, crossReference) {
        var reference;
        if (image._reference) {
            reference = image._reference;
        }
        else {
            reference = crossReference._getNextReference();
            image._reference = reference;
        }
        if (!crossReference._cacheMap.has(reference)) {
            if (image && image._imageStream && image._imageStream.dictionary) {
                crossReference._cacheMap.set(reference, image._imageStream);
                image._imageStream.dictionary._updated = true;
                if (image._maskStream && image._maskStream.dictionary) {
                    var ref = void 0;
                    if (image._maskReference) {
                        ref = image._maskReference;
                    }
                    else {
                        ref = crossReference._getNextReference();
                        image._maskReference = ref;
                    }
                    crossReference._cacheMap.set(ref, image._maskStream);
                    image._maskStream.dictionary._updated = true;
                    image._imageStream.dictionary.set('SMask', ref);
                }
            }
        }
        source.update(keyName.name, reference);
        this._resources.set(reference, keyName);
        this._resourceObject._updated = true;
    };
    PdfGraphics.prototype._updateFontResource = function (font, keyName, source, crossReference) {
        var reference;
        if (font._reference) {
            reference = font._reference;
        }
        else {
            reference = crossReference._getNextReference();
            font._reference = reference;
        }
        if (!crossReference._cacheMap.has(reference)) {
            if (font._dictionary) {
                crossReference._cacheMap.set(reference, font._dictionary);
                source.update(keyName.name, reference);
                this._resources.set(reference, keyName);
            }
            else if (font instanceof PdfTrueTypeFont) {
                var internal = font._fontInternal;
                if (internal && internal._fontDictionary) {
                    crossReference._cacheMap.set(reference, internal._fontDictionary);
                }
                source.update(keyName.name, reference);
                this._resources.set(reference, keyName);
            }
        }
    };
    PdfGraphics.prototype.drawPath = function (path, first, second) {
        this._beginMarkContent();
        var result = this._setPenBrush(first, second);
        if (result.pen || result.brush) {
            this._buildUpPath(path._points, path._pathTypes);
            this._drawGraphicsPath(result.pen, result.brush, path.fillMode, false);
        }
        this._endMarkContent();
    };
    /**
     * Draws a rounded rectangle on the page graphics.
     *
     * @param {number} x The x-coordinate of the upper-left corner of the rounded rectangle.
     * @param {number} y The y-coordinate of the upper-left corner of the rounded rectangle.
     * @param {number} width The width of the rounded rectangle.
     * @param {number} height The height of the rounded rectangle.
     * @param {number} radius The radius of the rounded corners of the rectangle.
     * @param {PdfPen} pen The pen that determines the stroke color, width, and style of the rectangle.
     * @param {PdfBrush} brush The brush that determines the fill color and texture of the rectangle.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Create a new brush
     * let brush: PdfBrush = new PdfBrush([0, 0, 255]);
     * // Draw a rounded rectangle on the page graphics
     * graphics.drawRoundedRectangle(10, 20, 100, 200, 5, pen, brush);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfGraphics.prototype.drawRoundedRectangle = function (x, y, width, height, radius, pen, brush) {
        if (pen === null) {
            throw new Error('pen');
        }
        if (brush === null) {
            throw new Error('brush');
        }
        var bounds = [x, y, width, height];
        var diameter = radius * 2;
        var size = [diameter, diameter];
        var arc = [bounds[0], bounds[1], size[0], size[1]];
        var path = new PdfPath();
        if (radius === 0) {
            path.addRectangle(bounds[0], bounds[1], bounds[2], bounds[3]);
            this.drawPath(path, pen, brush);
        }
        else {
            path._isRoundedRectangle = true;
            path.addArc(arc[0], arc[1], arc[2], arc[3], 180, 90);
            arc[0] = (bounds[0] + bounds[2]) - diameter;
            path.addArc(arc[0], arc[1], arc[2], arc[3], 270, 90);
            arc[1] = (bounds[1] + bounds[3]) - diameter;
            path.addArc(arc[0], arc[1], arc[2], arc[3], 0, 90);
            arc[0] = bounds[0];
            path.addArc(arc[0], arc[1], arc[2], arc[3], 90, 90);
            path.closeFigure();
            this.drawPath(path, pen, brush);
        }
    };
    PdfGraphics.prototype._constructArcPath = function (x1, y1, x2, y2, start, sweep) {
        var points = _getBezierArc(x1, y1, x2, y2, start, sweep);
        if (points.length === 8) {
            return;
        }
        var point = [points[0], points[1], points[2], points[3], points[4], points[5], points[6], points[7]];
        this._sw._beginPath(point[0], point[1]);
        for (var i = 0; i < points.length; i = i + 8) {
            point = [points[Number.parseInt(i.toString(), 10)],
                points[i + 1],
                points[i + 2],
                points[i + 3],
                points[i + 4],
                points[i + 5],
                points[i + 6],
                points[i + 7]];
            this._sw._appendBezierSegment(point[2], point[3], point[4], point[5], point[6], point[7]);
        }
    };
    PdfGraphics.prototype._constructPiePath = function (x1, y1, x2, y2, start, sweep) {
        var points = _getBezierArc(x1, y1, x2, y2, start, sweep);
        if (points.length === 8) {
            var point = [points[0], points[1], points[2], points[3], points[4], points[5], points[6], points[7]];
            this._sw._beginPath(point[0], point[1]);
            for (var i = 0; i < points.length; i = i + 8) {
                point = [points[Number.parseInt(i.toString(), 10)],
                    points[i + 1],
                    points[i + 2],
                    points[i + 3],
                    points[i + 4],
                    points[i + 5],
                    points[i + 6],
                    points[i + 7]];
                this._sw._appendBezierSegment(point[2], point[3], point[4], point[5], point[6], point[7]);
            }
        }
    };
    PdfGraphics.prototype._writePen = function (pen) {
        var lineWidth = pen._width;
        var pattern = pen._dashPattern;
        var setPattern = [];
        for (var i = 0; i < pattern.length; ++i) {
            setPattern[i] = pattern[i] * pen._width; // eslint-disable-line
        }
        this._sw._setLineDashPattern(setPattern, pen._dashOffset * lineWidth);
        this._sw._setLineWidth(pen._width);
        this._sw._setLineJoin(pen._lineJoin);
        this._sw._setLineCap(pen._lineCap);
        if (pen._miterLimit > 0) {
            this._sw._setMiterLimit(pen._miterLimit);
        }
        this._sw._setColor(pen._color, true);
    };
    /**
     * Draw text on the page graphics.
     *
     * @param {string} value The string to be drawn.
     * @param {PdfFont} font The font used to draw the string.
     * @param {number[]} bounds An array specifying the bounds [x, y, width, height] where the string will be drawn.
     * @param {PdfPen} pen The pen that determines the stroke color, width, and style of the string.
     * @param {PdfBrush} brush The brush that determines the fill color and texture of the string.
     * @param {PdfStringFormat} format The format that specifies text layout information such as alignment, line spacing, and trimming.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Create a new font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.helvetica, 12);
     * // Create a new string format
     * let format: PdfStringFormat = new PdfStringFormat();
     * format.alignment = PdfTextAlignment.center;
     * // Draw text on the page graphics
     * graphics.drawString('Hello World', font, [10, 20, 100, 200], pen, new PdfBrush([0, 0, 255]), format);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfGraphics.prototype.drawString = function (value, font, bounds, pen, brush, format) {
        this._beginMarkContent();
        var layouter = new _PdfStringLayouter();
        if (!format) {
            format = new PdfStringFormat();
        }
        var result = layouter._layout(value, font, format, [bounds[2], bounds[3]]);
        if (!result._empty) {
            var rect = this._checkCorrectLayoutRectangle(result._actualSize, bounds[0], bounds[1], format);
            if (bounds[2] <= 0) {
                bounds[0] = rect[0];
                bounds[2] = rect[2];
            }
            if (bounds[3] <= 0) {
                bounds[1] = rect[1];
                bounds[3] = rect[3];
            }
            this._drawStringLayoutResult(result, font, pen, brush, bounds, format);
        }
        _addProcSet('Text', this._resourceObject);
        this._endMarkContent();
    };
    PdfGraphics.prototype._buildUpPath = function (points, types) {
        for (var i = 0; i < points.length; i++) {
            var point = points[Number.parseInt(i.toString(), 10)];
            var type = types[Number.parseInt(i.toString(), 10)];
            switch (type & 0xf) {
                case PathPointType.start:
                    this._sw._beginPath(point[0], point[1]);
                    break;
                case PathPointType.bezier:
                    var result = this._getBezierPoint(points, types, i); // eslint-disable-line
                    i = result.index;
                    var first = result.point; // eslint-disable-line
                    result = this._getBezierPoint(points, types, i);
                    i = result.index;
                    var second = result.point; // eslint-disable-line
                    this._sw._appendBezierSegment(point[0], point[1], first[0], first[1], second[0], second[1]);
                    break;
                case PathPointType.line:
                    this._sw._appendLineSegment(point[0], point[1]);
                    break;
                default:
                    throw new Error('Incorrect path formation.');
            }
            type = types[Number.parseInt(i.toString(), 10)];
            if ((type & PathPointType.closePath) === PathPointType.closePath) {
                this._sw._closePath();
            }
        }
    };
    PdfGraphics.prototype._getBezierPoint = function (points, types, index) {
        if (types[Number.parseInt(index.toString(), 10)] !== PathPointType.bezier) {
            throw new Error('Malforming path.');
        }
        index++;
        return { 'index': index, 'point': points[Number.parseInt(index.toString(), 10)] };
    };
    PdfGraphics.prototype._initialize = function () {
        this._mediaBoxUpperRightBound = 0;
        this._characterSpacing = -1;
        this._wordSpacing = -1;
        this._textScaling = -100;
        this._textRenderingMode = -1;
        this._graphicsState = [];
        this._clipBounds = [0, 0, this._size[0], this._size[1]];
        this._colorSpaceInitialized = false;
        this._startCutIndex = -1;
    };
    PdfGraphics.prototype._initializeCurrentColorSpace = function () {
        if (!this._colorSpaceInitialized) {
            this._sw._setColorSpace('DeviceRGB', true);
            this._sw._setColorSpace('DeviceRGB', false);
            this._colorSpaceInitialized = true;
        }
    };
    PdfGraphics.prototype._brushControl = function (brush) {
        this._sw._setColor(brush._color, false);
        this._currentBrush = brush;
    };
    PdfGraphics.prototype._penControl = function (pen) {
        this._currentPen = pen;
        this._writePen(pen);
        this._currentPen = pen;
    };
    PdfGraphics.prototype._fontControl = function (font, format) {
        var _this = this;
        var size = font._metrics._getSize(format);
        this._currentFont = font;
        var sourceDictionary;
        var isReference = false;
        var keyName;
        var isNew = true;
        var ref;
        var hasResource = false;
        if (this._resourceObject.has('Font')) {
            var obj = this._resourceObject.getRaw('Font'); // eslint-disable-line
            if (obj !== null && typeof obj !== 'undefined') {
                if (obj instanceof _PdfReference) {
                    isReference = true;
                    sourceDictionary = this._crossReference._fetch(obj);
                }
                else if (obj instanceof _PdfDictionary) {
                    sourceDictionary = obj;
                }
            }
            if (typeof sourceDictionary !== 'undefined' && sourceDictionary !== null) {
                isNew = false;
                this._resources.forEach(function (value, key) {
                    if (_this._crossReference) {
                        if (key !== null && typeof key !== 'undefined') {
                            var dictionary = _this._crossReference._fetch(key);
                            if (dictionary && ((font instanceof PdfStandardFont && dictionary === font._dictionary) ||
                                (font instanceof PdfTrueTypeFont && dictionary === font._fontInternal._fontDictionary))) {
                                keyName = value;
                                ref = key;
                                hasResource = true;
                            }
                        }
                    }
                    else if (font._reference && font._reference === key) {
                        keyName = value;
                        ref = key;
                        hasResource = true;
                    }
                });
            }
        }
        if (isNew) {
            sourceDictionary = new _PdfDictionary(this._crossReference);
            this._resourceObject.update('Font', sourceDictionary);
        }
        if (typeof keyName === 'undefined') {
            keyName = _PdfName.get(_getNewGuidString());
            if (!ref) {
                if (font._reference) {
                    ref = font._reference;
                    sourceDictionary.update(keyName.name, ref);
                }
                else if (this._crossReference) {
                    ref = this._crossReference._getNextReference();
                }
                else {
                    this._pendingResource.push({ 'resource': font, 'key': keyName, 'source': sourceDictionary });
                }
            }
            if (ref && this._crossReference) {
                if (!font._reference) {
                    font._reference = ref;
                }
                if (font._dictionary) {
                    this._crossReference._cacheMap.set(ref, font._dictionary);
                    sourceDictionary.update(keyName.name, ref);
                }
                else if (font instanceof PdfTrueTypeFont) {
                    var internal = font._fontInternal;
                    if (internal && internal._fontDictionary) {
                        this._crossReference._cacheMap.set(ref, internal._fontDictionary);
                    }
                    sourceDictionary.update(keyName.name, ref);
                }
            }
            if (!hasResource) {
                this._resources.set(ref, keyName);
            }
        }
        if (isReference) {
            this._resourceObject._updated = true;
        }
        if (this._hasResourceReference) {
            this._source._updated = true;
        }
        this._sw._setFont(keyName.name, size);
    };
    PdfGraphics.prototype._setPenBrush = function (first, second) {
        var pen;
        var brush;
        if (first) {
            if (first instanceof PdfPen) {
                pen = first;
            }
            else {
                brush = first;
            }
        }
        if (second && second instanceof PdfBrush) {
            brush = second;
        }
        this._stateControl(pen, brush, null);
        return { pen: pen, brush: brush };
    };
    PdfGraphics.prototype._stateControl = function (pen, brush, font, format) {
        if (pen || brush) {
            this._initializeCurrentColorSpace();
        }
        if (pen) {
            this._penControl(pen);
        }
        if (brush) {
            this._brushControl(brush);
        }
        if (font) {
            this._fontControl(font, format);
        }
    };
    PdfGraphics.prototype._drawStringLayoutResult = function (result, font, pen, brush, layoutRectangle, format) {
        if (!result._empty) {
            var allowPartialLines = (format && typeof format.lineLimit !== 'undefined' && !format.lineLimit);
            var shouldClip = (typeof format === 'undefined' || (format && typeof format.noClip !== 'undefined'
                && !format.noClip));
            var clipRegion = allowPartialLines && shouldClip;
            var state = void 0;
            if (clipRegion) {
                state = this.save();
                var clipBounds = [layoutRectangle[0], layoutRectangle[1], result._actualSize[0], result._actualSize[1]];
                if (layoutRectangle[2] > 0) {
                    clipBounds[2] = layoutRectangle[2];
                }
                if (format.lineAlignment === PdfVerticalAlignment.middle) {
                    clipBounds[1] += (layoutRectangle[3] - clipBounds[3]) / 2;
                }
                else if (format.lineAlignment === PdfVerticalAlignment.bottom) {
                    clipBounds[1] += (layoutRectangle[3] - clipBounds[3]);
                }
                this.setClip(clipBounds);
            }
            if (font && font instanceof PdfTrueTypeFont && font._fontInternal &&
                font._fontInternal instanceof _UnicodeTrueTypeFont && font.isItalic) {
                if (!font._fontInternal._ttfMetrics._isItalic) {
                    state = this.save();
                    this._isItalic = true;
                }
            }
            this._applyStringSettings(font, pen, brush, format);
            var textScaling = (typeof format !== 'undefined' && format !== null) ? format.horizontalScalingFactor : 100.0;
            if (textScaling !== this._textScaling) {
                this._sw._setTextScaling(textScaling);
                this._textScaling = textScaling;
            }
            var verticalAlignShift = this._getTextVerticalAlignShift(result._actualSize[1], layoutRectangle[3], format);
            var height = (typeof format === 'undefined' || format === null || format.lineSpacing === 0) ?
                font._metrics._getHeight(format) :
                format.lineSpacing + font._metrics._getHeight(format);
            var script = (format !== null && typeof format !== 'undefined' &&
                format.subSuperScript === PdfSubSuperScript.subScript);
            var shift = 0;
            shift = (script) ? height - (font.height + font._metrics._getDescent(format)) : (height - font._metrics._getAscent(format));
            if (format && format.lineAlignment === PdfVerticalAlignment.bottom) {
                if (layoutRectangle[3] - result._actualSize[1] !== 0 &&
                    (layoutRectangle[3] - result._actualSize[1]) < (font._metrics._size / 2) - 1) {
                    if (Number.parseFloat(_numberToString(layoutRectangle[3])) <=
                        Number.parseFloat(_numberToString(font._metrics._getHeight(format)))) {
                        shift = -(height / font._metrics._size);
                    }
                }
            }
            var matrix = new _PdfTransformationMatrix();
            if (this._isItalic) {
                this.translateTransform(layoutRectangle[0] + font.size / 5, layoutRectangle[1] - shift + verticalAlignShift);
                this._skewTransform(0, -11);
            }
            else {
                matrix._translate(layoutRectangle[0], (-(layoutRectangle[1] + font._metrics._getHeight(format)) -
                    (font._metrics._getDescent(format) > 0 ? -font._metrics._getDescent(format) : font._metrics._getDescent(format))) -
                    verticalAlignShift);
                this._sw._modifyTM(matrix);
            }
            if (layoutRectangle[3] < font._metrics._size) {
                if ((result._actualSize[1] - layoutRectangle[3]) < (font._metrics._size / 2) - 1) {
                    verticalAlignShift = 0;
                }
            }
            if (verticalAlignShift !== 0) {
                if (format !== null && format.lineAlignment === PdfVerticalAlignment.bottom) {
                    if (layoutRectangle[3] - result._actualSize[1] !== 0 &&
                        (layoutRectangle[3] - result._actualSize[1]) > (font._metrics._size / 2) - 1) {
                        verticalAlignShift -= (shift - (height - font._metrics._size)) / 2;
                    }
                }
            }
            if (this._isItalic) {
                this._sw._startNextLine(0, 0);
                this._sw._setLeading(+height);
            }
            this._drawLayoutResult(result, font, format, layoutRectangle);
            if (verticalAlignShift !== 0) {
                this._sw._startNextLine(0, -(verticalAlignShift - result._lineHeight));
            }
            _addProcSet('Text', this._resourceObject);
            this._sw._endText();
            if (this._isItalic) {
                this.restore(state);
            }
            this._underlineStrikeoutText(brush, result, font, layoutRectangle, format);
            if (clipRegion) {
                this.restore(state);
            }
        }
    };
    PdfGraphics.prototype._getNextPage = function () {
        var page;
        var pageCount = this._crossReference._document.pageCount;
        if (this._page._pageIndex <= pageCount - 2) {
            page = this._crossReference._document.getPage(this._page._pageIndex + 1);
        }
        else {
            page = this._crossReference._document.addPage();
        }
        return page;
    };
    PdfGraphics.prototype._applyStringSettings = function (font, pen, brush, format) {
        var tm = _TextRenderingMode.fill;
        var setLineWidth = false;
        if (pen && brush) {
            tm = _TextRenderingMode.fillStroke;
        }
        else if (pen) {
            tm = _TextRenderingMode.stroke;
        }
        else if (brush) {
            tm = _TextRenderingMode.fill;
        }
        if (font && font instanceof PdfTrueTypeFont && (font.isUnicode || (font._style & PdfFontStyle.bold) !== 0)) {
            var fontName = font._fontInternal._metrics._postScriptName;
            var isBoldFont = false;
            if (fontName && fontName.toLocaleLowerCase().includes('bold')) {
                isBoldFont = true;
            }
            if (font._fontInternal && font._fontInternal._metrics && font._fontInternal._metrics._isBold !==
                font.isBold && font.isBold === true && !isBoldFont) {
                if (!pen && brush) {
                    pen = new PdfPen(brush._color, 1);
                }
                tm = _TextRenderingMode.fillStroke;
                setLineWidth = true;
            }
        }
        if (format && format.clipPath) {
            tm |= _TextRenderingMode.clipFlag;
        }
        this._sw._beginText();
        this._stateControl(pen, brush, font, format);
        if (tm !== this._textRenderingMode) {
            this._sw._setTextRenderingMode(tm);
            this._textRenderingMode = tm;
        }
        var cs = (typeof format !== 'undefined' && format !== null) ? format.characterSpacing : 0;
        if (cs !== this._characterSpacing) {
            this._sw._setCharacterSpacing(cs);
            this._characterSpacing = cs;
        }
        var ws = (typeof format !== 'undefined' && format !== null) ? format.wordSpacing : 0;
        if (ws !== this._wordSpacing) {
            this._sw._setWordSpacing(ws);
            this._wordSpacing = ws;
        }
        if (font && setLineWidth) {
            this._sw._setLineWidth(font.size / 30);
        }
    };
    PdfGraphics.prototype._drawLayoutResult = function (result, font, format, layoutRectangle) {
        var height = (typeof format === 'undefined' || format === null || format.lineSpacing === 0) ?
            font._metrics._getHeight(format) :
            format.lineSpacing + font._metrics._getHeight(format);
        var lines = result._lines;
        var ttfFont = font;
        var unicode = (ttfFont !== null && ttfFont.isUnicode);
        for (var i = 0, len = lines.length; (i < len && i !== this._startCutIndex); i++) {
            var lineInfo = lines[Number.parseInt(i.toString(), 10)];
            var lineWidth = lineInfo._width;
            var hAlignShift = this._getHorizontalAlignShift(lineWidth, layoutRectangle[2], format) +
                this._getLineIndent(lineInfo, format, layoutRectangle[2], (i === 0));
            if (hAlignShift !== 0) {
                this._sw._startNextLine(hAlignShift, 0);
            }
            if (unicode) {
                this._drawUnicodeLine(lineInfo, layoutRectangle[2], font, format);
            }
            else {
                this._drawAsciiLine(lineInfo, layoutRectangle[2], format, font);
            }
            if ((i + 1 !== len)) {
                var vAlignShift = this._getTextVerticalAlignShift(result._actualSize[1], layoutRectangle[3], format);
                var matrix = new _PdfTransformationMatrix();
                var baseline = ((-(layoutRectangle[1] + font._metrics._getHeight(format)) -
                    font._metrics._getDescent(format)) -
                    vAlignShift) -
                    (height * (i + 1));
                matrix._translate(layoutRectangle[0], baseline);
                this._sw._modifyTM(matrix);
            }
        }
    };
    PdfGraphics.prototype._drawUnicodeLine = function (lineInfo, width, font, format) {
        var line = lineInfo._text;
        var rtl = (format !== null && typeof format !== 'undefined' && format.rightToLeft);
        var useWordSpace = (format !== null && typeof format !== 'undefined' && format.wordSpacing > 0);
        var ttfFont = font;
        var wordSpacing = this._justifyLine(lineInfo, width, format, ttfFont);
        var rtlRender = new _RtlRenderer();
        if (rtl || (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.none)) {
            var blocks = [];
            var rightAlign = (format !== null && typeof format !== 'undefined' && format.alignment === PdfTextAlignment.right);
            if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.none) {
                blocks = rtlRender._layout(line, ttfFont, (format.textDirection === PdfTextDirection.rightToLeft) ? true : false, useWordSpace, format);
            }
            else {
                blocks = rtlRender._layout(line, ttfFont, rightAlign, useWordSpace, format);
            }
            var words = [];
            if (blocks.length > 1) {
                if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.none) {
                    words = rtlRender._splitLayout(line, ttfFont, (format.textDirection === PdfTextDirection.rightToLeft) ? true : false, useWordSpace, format);
                }
            }
            else {
                words = [line];
            }
            this._drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);
        }
        else {
            if (useWordSpace) {
                var result = this._breakUnicodeLine(line, ttfFont, null);
                var blocks = result.tokens;
                var words = result.words;
                this._drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);
            }
            else {
                var token = this._convertToUnicode(line, ttfFont);
                this._sw._showNextLineText(token, true);
            }
        }
    };
    PdfGraphics.prototype._drawUnicodeBlocks = function (blocks, words, font, format, wordSpacing) {
        if (blocks !== null && typeof blocks !== 'undefined' && blocks.length > 0 && words !== null && typeof words !== 'undefined' &&
            words.length > 0 && font !== null && typeof font !== 'undefined') {
            this._sw._startNextLine();
            var x = 0;
            var xShift = 0;
            var firstLineIndent = 0;
            var paragraphIndent = 0;
            try {
                if (format !== null && typeof format !== 'undefined') {
                    firstLineIndent = format.firstLineIndent;
                    paragraphIndent = format.paragraphIndent;
                    format.firstLineIndent = 0;
                    format.paragraphIndent = 0;
                }
                var spaceWidth = font._getCharacterWidth(_StringTokenizer._whiteSpace, format) + wordSpacing;
                var characterSpacing = (format !== null) ? format.characterSpacing : 0;
                var wordSpace = (format !== null && typeof format !== 'undefined' && wordSpacing === 0) ? format.wordSpacing : 0;
                spaceWidth += characterSpacing + wordSpace;
                for (var i = 0; i < blocks.length; i++) {
                    var token = blocks[i]; //eslint-disable-line
                    var word = words[i]; //eslint-disable-line
                    var tokenWidth = 0;
                    if (x !== 0) {
                        this._sw._startNextLine(x, 0);
                    }
                    if (word.length > 0) {
                        tokenWidth += font.measureString(word, format)[0];
                        tokenWidth += characterSpacing;
                        this._sw._showText(token);
                    }
                    if (i !== blocks.length - 1) {
                        x = tokenWidth + spaceWidth;
                        xShift += x;
                    }
                }
                if (xShift > 0) {
                    this._sw._startNextLine(-xShift, 0);
                }
            }
            finally {
                if (format !== null && typeof format !== 'undefined') {
                    format.firstLineIndent = firstLineIndent;
                    format.paragraphIndent = paragraphIndent;
                }
            }
        }
    };
    PdfGraphics.prototype._breakUnicodeLine = function (line, ttfFont, words) {
        var tokens = [];
        if (line !== null && typeof line !== 'undefined' && line.length > 0) {
            words = line.split(null);
            for (var i = 0; i < words.length; i++) {
                var word = words[i]; //eslint-disable-line
                var token = this._convertToUnicode(word, ttfFont);
                tokens[Number.parseInt(i.toString(), 10)] = token;
            }
        }
        return { tokens: tokens, words: words };
    };
    PdfGraphics.prototype._convertToUnicode = function (text, ttfFont) {
        var token = null;
        if (text !== null && typeof text !== 'undefined' && ttfFont !== null && typeof ttfFont !== 'undefined' &&
            ttfFont._fontInternal instanceof _UnicodeTrueTypeFont) {
            var ttfReader = ttfFont._fontInternal._ttfReader;
            ttfFont._setSymbols(text);
            token = ttfReader._convertString(text);
            var bytes = _stringToUnicodeArray(token);
            token = _bytesToString(bytes);
        }
        return token;
    };
    PdfGraphics.prototype._getTextVerticalAlignShift = function (textHeight, boundsHeight, format) {
        var shift = 0;
        if (boundsHeight >= 0 && (typeof format !== 'undefined' && format !== null) && format.lineAlignment !== PdfVerticalAlignment.top) {
            switch (format.lineAlignment) {
                case PdfVerticalAlignment.middle:
                    shift = (boundsHeight - textHeight) / 2;
                    break;
                case PdfVerticalAlignment.bottom:
                    shift = boundsHeight - textHeight;
                    break;
            }
        }
        return shift;
    };
    PdfGraphics.prototype._getHorizontalAlignShift = function (lineWidth, boundsWidth, format) {
        var shift = 0;
        if (boundsWidth >= 0 && (typeof format !== 'undefined' && format !== null) && format.alignment !== PdfTextAlignment.left) {
            switch (format.alignment) {
                case PdfTextAlignment.center:
                    shift = (boundsWidth - lineWidth) / 2;
                    break;
                case PdfTextAlignment.right:
                    shift = boundsWidth - lineWidth;
                    break;
            }
        }
        return shift;
    };
    PdfGraphics.prototype._getLineIndent = function (lineInfo, format, width, firstLine) {
        var lineIndent = 0;
        var firstParagraphLine = ((lineInfo._lineType & _LineType.firstParagraphLine) > 0);
        if (format && firstParagraphLine) {
            lineIndent = (firstLine) ? format.firstLineIndent : format.paragraphIndent;
            lineIndent = (width > 0) ? Math.min(width, lineIndent) : lineIndent;
        }
        return lineIndent;
    };
    PdfGraphics.prototype._drawAsciiLine = function (lineInfo, width, format, font) {
        this._justifyLine(lineInfo, width, format, font);
        var value = '';
        if (lineInfo._text.indexOf('(') !== -1 || lineInfo._text.indexOf(')') !== -1) {
            for (var i = 0; i < lineInfo._text.length; i++) {
                if (lineInfo._text[Number.parseInt(i.toString(), 10)] === '(') {
                    value += '\\\('; // eslint-disable-line
                }
                else if (lineInfo._text[Number.parseInt(i.toString(), 10)] === ')') {
                    value += '\\\)'; // eslint-disable-line
                }
                else {
                    value += lineInfo._text[Number.parseInt(i.toString(), 10)];
                }
            }
        }
        if (value === '') {
            value = lineInfo._text;
        }
        this._sw._showNextLineText('(' + value + ')');
    };
    PdfGraphics.prototype._justifyLine = function (lineInfo, boundsWidth, format, font) {
        var line = lineInfo._text;
        var lineWidth = lineInfo._width;
        var shouldJustify = this._shouldJustify(lineInfo, boundsWidth, format, font);
        var hasWordSpacing = (format && format.wordSpacing !== 0);
        var whitespacesCount = font._getCharacterCount(line, [' ', '\t']);
        var wordSpace = 0;
        if (shouldJustify) {
            if (hasWordSpacing) {
                lineWidth -= (whitespacesCount * format.wordSpacing);
            }
            wordSpace = (boundsWidth - lineWidth) / whitespacesCount;
            this._sw._setWordSpacing(wordSpace);
        }
        else if (format && format.alignment === PdfTextAlignment.justify) {
            this._sw._setWordSpacing(0);
        }
        return wordSpace;
    };
    PdfGraphics.prototype._shouldJustify = function (lineInfo, boundsWidth, format, font) {
        var line = lineInfo._text;
        var lineWidth = lineInfo._width;
        var justifyStyle = (format && format.alignment === PdfTextAlignment.justify);
        var goodWidth = (boundsWidth >= 0 && lineWidth < boundsWidth);
        var whitespacesCount = font._getCharacterCount(line, [' ', '\t']);
        var hasSpaces = (whitespacesCount > 0 && line[0] !== ' ');
        var goodLineBreakStyle = ((lineInfo._lineType & _LineType.layoutBreak) > 0);
        return (justifyStyle && goodWidth && hasSpaces && goodLineBreakStyle);
    };
    PdfGraphics.prototype._underlineStrikeoutText = function (brush, result, font, layoutRectangle, format) {
        if (font.isUnderline || font.isStrikeout) {
            var linePen = this._createUnderlineStrikeoutPen(brush, font);
            if (typeof linePen !== 'undefined' && linePen !== null) {
                var shift = this._getTextVerticalAlignShift(result._actualSize[1], layoutRectangle[3], format);
                var underlineYOffset = layoutRectangle[1] + shift + font._metrics._getAscent(format) + 1.5 * linePen._width;
                var strikeoutYOffset = layoutRectangle[1] + shift + font._metrics._getHeight(format) / 2 + 1.5 * linePen._width;
                var lines = result._lines;
                for (var i = 0; i < result._lineCount; i++) {
                    var lineInfo = lines[Number.parseInt(i.toString(), 10)];
                    var lineWidth = lineInfo._width;
                    var hShift = this._getHorizontalAlignShift(lineWidth, layoutRectangle[2], format);
                    var lineIndent = this._getLineIndent(lineInfo, format, layoutRectangle[2], (i === 0));
                    var x1 = layoutRectangle[0] + hShift;
                    var x2 = (!this._shouldJustify(lineInfo, layoutRectangle[2], format, font)) ?
                        x1 + lineWidth - lineIndent :
                        x1 + layoutRectangle[2] - lineIndent;
                    if (font.isUnderline) {
                        this.drawLine(linePen, x1, underlineYOffset, x2, underlineYOffset);
                        underlineYOffset += result._lineHeight;
                    }
                    if (font.isStrikeout) {
                        this.drawLine(linePen, x1, strikeoutYOffset, x2, strikeoutYOffset);
                        strikeoutYOffset += result._lineHeight;
                    }
                }
            }
        }
    };
    /**
     * Draws a line on the page graphics.
     *
     * @param {PdfPen} pen The pen that determines the stroke color, width, and style of the line.
     * @param {number} x1 The x-coordinate of the starting point of the line.
     * @param {number} y1 The y-coordinate of the starting point of the line.
     * @param {number} x2 The x-coordinate of the ending point of the line.
     * @param {number} y2 The y-coordinate of the ending point of the line.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Draw a line on the page graphics
     * graphics.drawLine(pen, 10, 10, 100, 100);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfGraphics.prototype.drawLine = function (pen, x1, y1, x2, y2) {
        this._beginMarkContent();
        this._stateControl(pen);
        this._sw._beginPath(x1, y1);
        this._sw._appendLineSegment(x2, y2);
        this._sw._strokePath();
        _addProcSet('PDF', this._resourceObject);
        this._endMarkContent();
    };
    PdfGraphics.prototype._createUnderlineStrikeoutPen = function (brush, font) {
        return new PdfPen(brush._color, font._metrics._size / 20);
    };
    PdfGraphics.prototype._checkCorrectLayoutRectangle = function (textSize, x, y, format) {
        var layoutedRectangle = [x, y, textSize[0], textSize[0]];
        if (format) {
            switch (format.alignment) {
                case PdfTextAlignment.center:
                    layoutedRectangle[0] = layoutedRectangle[0] - layoutedRectangle[2] / 2;
                    break;
                case PdfTextAlignment.right:
                    layoutedRectangle[0] = layoutedRectangle[0] - layoutedRectangle[2];
                    break;
            }
            switch (format.lineAlignment) {
                case PdfVerticalAlignment.middle:
                    layoutedRectangle[1] = layoutedRectangle[1] - layoutedRectangle[3] / 2;
                    break;
                case PdfVerticalAlignment.bottom:
                    layoutedRectangle[1] = layoutedRectangle[1] - layoutedRectangle[3];
                    break;
            }
        }
        return layoutedRectangle;
    };
    PdfGraphics.prototype._drawGraphicsPath = function (pen, brush, fillMode, needClosing) {
        if (typeof fillMode === 'undefined') {
            fillMode = PdfFillMode.winding;
        }
        var isBrush = (typeof brush !== 'undefined' && brush !== null);
        var isPen = (typeof pen !== 'undefined' && pen !== null);
        var isEvenOdd = fillMode === PdfFillMode.alternate;
        if (isPen && isBrush) {
            if (needClosing) {
                this._sw._closeFillStrokePath(isEvenOdd);
            }
            else {
                this._sw._fillStrokePath(isEvenOdd);
            }
        }
        else if (!isPen && !isBrush) {
            this._sw._endPath();
        }
        else if (isPen) {
            if (needClosing) {
                this._sw._closeStrokePath();
            }
            else {
                this._sw._strokePath();
            }
        }
        else {
            if (needClosing) {
                this._sw._closeFillPath(isEvenOdd);
            }
            else {
                this._sw._fillPath(isEvenOdd);
            }
        }
    };
    PdfGraphics.prototype._initializeCoordinates = function (page) {
        var cbox;
        if (page) {
            var location_1 = [0, 0];
            var needTransformation = false;
            if (page._pageDictionary.has('CropBox') && page._pageDictionary.has('MediaBox')) {
                cbox = page._pageDictionary.getArray('CropBox');
                var mbox = page._pageDictionary.getArray('MediaBox');
                if (cbox[0] === mbox[0] && cbox[1] === mbox[1] && cbox[2] === mbox[2] && cbox[3] === mbox[3]) {
                    needTransformation = true;
                }
                if (cbox[0] > 0 && cbox[3] > 0 && mbox[0] < 0 && mbox[1] < 0) {
                    this.translateTransform(cbox[0], -cbox[3]);
                    location_1[0] = -cbox[0];
                    location_1[1] = cbox[3];
                }
                else if (!page._pageDictionary.has('CropBox')) {
                    needTransformation = true;
                }
                if (needTransformation) {
                    this._sw._writeComment('Change co-ordinate system to left/top.');
                    if (this._cropBox) {
                        this.translateTransform(this._cropBox[0], -this._cropBox[3]);
                    }
                    else {
                        if (-(page._origin[1]) < this._mediaBoxUpperRightBound || this._mediaBoxUpperRightBound === 0) {
                            this.translateTransform(0, -this._size[1]);
                        }
                        else {
                            this.translateTransform(0, -this._mediaBoxUpperRightBound);
                        }
                    }
                }
            }
        }
        else {
            this._sw._writeComment('Change co-ordinate system to left/top.');
            if (this._mediaBoxUpperRightBound !== (-this._size[1])) {
                if (this._cropBox) {
                    cbox = this._cropBox;
                    if (cbox[0] > 0 || cbox[1] > 0 || this._size[0] === cbox[2] || this._size[1] === cbox[3]) {
                        this.translateTransform(cbox[0], -cbox[3]);
                    }
                    else {
                        if (this._mediaBoxUpperRightBound === this._size[1] || this._mediaBoxUpperRightBound === 0) {
                            this.translateTransform(0, -this._size[1]);
                        }
                        else {
                            this.translateTransform(0, -this._mediaBoxUpperRightBound);
                        }
                    }
                }
                else {
                    if (this._mediaBoxUpperRightBound === this._size[1] || this._mediaBoxUpperRightBound === 0) {
                        this.translateTransform(0, -this._size[1]);
                    }
                    else {
                        this.translateTransform(0, -this._mediaBoxUpperRightBound);
                    }
                }
            }
        }
    };
    /**
     * Represents a scale transform of the graphics.
     *
     * @param {number} scaleX Scale factor in the x direction.
     * @param {number} scaleY Scale factor in the y direction.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new font
     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // Save the current graphics state
     * let state: PdfGraphicsState = graphics.save();
     * // Apply scale transform
     * graphics.scaleTransform(0.5, 0.5);
     * // Draw a string with the scaled transformation
     * graphics.drawString("Hello world!", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));
     * // Restore the graphics to its previous state
     * graphics.restore(state);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfGraphics.prototype.scaleTransform = function (scaleX, scaleY) {
        var matrix = new _PdfTransformationMatrix();
        matrix._scale(scaleX, scaleY);
        this._sw._modifyCtm(matrix);
        this._matrix._multiply(matrix);
    };
    /**
     * Represents a translate transform of the graphics.
     *
     * @param {number} x x-coordinate of the translation.
     * @param {number} y y-coordinate of the translation.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new font
     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // Save the current graphics state
     * let state: PdfGraphicsState = graphics.save();
     * // Apply translate transform
     * graphics.translateTransform(100, 100);
     * // Draw a string with the translation applied
     * graphics.drawString("Hello world!", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));
     * // Restore the graphics to its previous state
     * graphics.restore(state);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfGraphics.prototype.translateTransform = function (x, y) {
        var matrix = new _PdfTransformationMatrix();
        matrix._translate(x, -y);
        this._sw._modifyCtm(matrix);
        this._matrix._multiply(matrix);
    };
    /**
     * Represents a rotate transform of the graphics.
     *
     * @param {number} angle Angle of rotation in degrees.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new font
     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // Save the current graphics state
     * let state: PdfGraphicsState = graphics.save();
     * // Apply rotate transform
     * graphics.rotateTransform(-90);
     * // Draw a string with the rotation applied
     * graphics.drawString("Hello world!", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));
     * // Restore the graphics to its previous state
     * graphics.restore(state);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfGraphics.prototype.rotateTransform = function (angle) {
        var matrix = new _PdfTransformationMatrix();
        matrix._rotate(-angle);
        this._sw._modifyCtm(matrix);
        this._matrix._multiply(matrix);
    };
    /**
     * Represents a clipping region of this graphics.
     *
     * @param {number[]} bounds Rectangle structure that represents the new clip region, specified as [x, y, width, height].
     * @param {PdfFillMode} mode Member of the PdfFillMode enumeration that specifies the filling operation to use.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new font
     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // Set clipping region
     * graphics.setClip([0, 0, 50, 12], PdfFillMode.alternate);
     * // Draw a string within the clipping region
     * graphics.drawString("Hello world!", font, [0, 0, 100, 200], undefined, new PdfBrush([0, 0, 255]));
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfGraphics.prototype.setClip = function (bounds, mode) {
        if (typeof mode === 'undefined') {
            mode = PdfFillMode.winding;
        }
        this._sw._appendRectangle(bounds[0], bounds[1], bounds[2], bounds[3]);
        this._sw._clipPath(mode === PdfFillMode.alternate);
    };
    /**
     * Sets the transparency for the graphics.
     *
     * @param {number} stroke The transparency value for strokes.
     * @param {number} fill The transparency value for fills.
     * @param {PdfBlendMode} mode The blend mode to use.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new font
     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // Set transparency
     * graphics.setTransparency(0.5, 0.5, PdfBlendMode.multiply);
     * // Draw the string
     * graphics.drawString("Hello world!", font, [0, 0, 100, 200], undefined, new PdfBrush([0, 0, 255]));
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfGraphics.prototype.setTransparency = function (stroke, fill, mode) {
        if (typeof fill === 'undefined') {
            fill = stroke;
        }
        if (typeof mode === 'undefined') {
            mode = PdfBlendMode.normal;
        }
        if (typeof this._transparencies === 'undefined') {
            this._transparencies = new Map();
        }
        var transparencyKey = 'CA:' + stroke.toString() + '_ca:' + fill.toString() + '_BM:' + mode.toString();
        var transparencyData;
        if (this._transparencies.size > 0) {
            this._transparencies.forEach(function (value, key) {
                if (value === transparencyKey) {
                    transparencyData = key;
                }
            });
        }
        if (!transparencyData) {
            transparencyData = new _TransparencyData();
            var transparencyDict = new _PdfDictionary();
            transparencyDict.update('CA', stroke);
            transparencyDict.update('ca', fill);
            transparencyDict.update('BM', _reverseMapBlendMode(mode));
            var ref = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(ref, transparencyDict);
            transparencyData._dictionary = transparencyDict;
            transparencyData._key = transparencyKey;
            transparencyData._name = _PdfName.get(_getNewGuidString());
            transparencyData._reference = ref;
            var dictionary = void 0;
            var isReference = false;
            if (this._resourceObject.has('ExtGState')) {
                var obj = this._resourceObject.getRaw('ExtGState'); // eslint-disable-line
                if (obj !== null && typeof obj !== 'undefined') {
                    if (obj instanceof _PdfReference) {
                        isReference = true;
                        dictionary = this._crossReference._fetch(obj);
                    }
                    else if (obj instanceof _PdfDictionary) {
                        dictionary = obj;
                    }
                }
            }
            else {
                dictionary = new _PdfDictionary(this._crossReference);
                this._resourceObject.update('ExtGState', dictionary);
            }
            dictionary.update(transparencyData._name.name, ref);
            if (isReference) {
                this._resourceObject._updated = true;
            }
            if (this._hasResourceReference) {
                this._source._updated = true;
            }
        }
        this._sw._setGraphicsState(transparencyData._name);
    };
    PdfGraphics.prototype._setTransparencyData = function (ref, name) {
        this._resourceMap.set(ref, name);
        var dictionary = this._crossReference._fetch(ref);
        var stroke = 0;
        var fill = 0;
        var mode = 0;
        if (dictionary) {
            if (dictionary.has('CA')) {
                stroke = dictionary.get('CA');
            }
            if (dictionary.has('ca')) {
                fill = dictionary.get('ca');
            }
            if (dictionary.has('ca')) {
                fill = dictionary.get('ca');
            }
            if (dictionary.has('BM')) {
                mode = _mapBlendMode(dictionary.get('BM'));
            }
        }
        var tkey = 'CA:' + stroke.toString() + '_ca:' + fill.toString() + '_BM:' + mode.toString();
        var tdata = new _TransparencyData();
        tdata._dictionary = dictionary;
        tdata._key = tkey;
        tdata._name = name;
        tdata._reference = ref;
        this._transparencies.set(tdata, tkey);
    };
    PdfGraphics.prototype._getTranslateTransform = function (x, y, input) {
        input._translate(x, -y);
        return input;
    };
    PdfGraphics.prototype._getScaleTransform = function (x, y, input) {
        if (input === null || typeof input === 'undefined') {
            input = new _PdfTransformationMatrix();
        }
        input._scale(x, y);
        return input;
    };
    PdfGraphics.prototype._clipTranslateMargins = function (clipBounds) {
        this._clipBounds = clipBounds;
        this._sw._writeComment('Clip margins.');
        this._sw._appendRectangle(clipBounds[0], clipBounds[1], clipBounds[2], clipBounds[3]);
        this._sw._closePath();
        this._sw._clipPath(false);
        this._sw._writeComment('Translate co-ordinate system.');
        this.translateTransform(clipBounds[0], clipBounds[1]);
    };
    PdfGraphics.prototype._skewTransform = function (angleX, angleY) {
        var matrix = new _PdfTransformationMatrix();
        this._getSkewTransform(angleX, angleY, matrix);
        this._sw._modifyCtm(matrix);
        matrix._multiply(matrix);
    };
    PdfGraphics.prototype._getSkewTransform = function (angleX, angleY, input) {
        input._skew(-angleX, -angleY);
        return input;
    };
    return PdfGraphics;
}());
var _PdfTransformationMatrix = /** @class */ (function () {
    function _PdfTransformationMatrix() {
        this._matrix = new _Matrix(1, 0, 0, 1, 0, 0);
    }
    _PdfTransformationMatrix.prototype._translate = function (x, y) {
        this._matrix._translate(x, y);
    };
    _PdfTransformationMatrix.prototype._scale = function (x, y) {
        this._matrix._elements[0] = x;
        this._matrix._elements[3] = y;
    };
    _PdfTransformationMatrix.prototype._rotate = function (angle) {
        angle = (angle * Math.PI) / 180;
        this._matrix._elements[0] = Math.cos(angle);
        this._matrix._elements[1] = Math.sin(angle);
        this._matrix._elements[2] = -Math.sin(angle);
        this._matrix._elements[3] = Math.cos(angle);
    };
    _PdfTransformationMatrix.prototype._multiply = function (matrix) {
        this._matrix._multiply(matrix._matrix);
    };
    _PdfTransformationMatrix.prototype._toString = function () {
        var builder = '';
        for (var i = 0, len = this._matrix._elements.length; i < len; i++) {
            builder += _floatToString(this._matrix._elements[Number.parseInt(i.toString(), 10)]) + ' ';
        }
        return builder;
    };
    _PdfTransformationMatrix.prototype._skew = function (angleX, angleY) {
        var tanA = Math.tan(this._degreeToRadians(angleX));
        var tanB = Math.tan(this._degreeToRadians(angleY));
        var skew = new _Matrix(1, tanA, tanB, 1, 0, 0);
        this._matrix._multiply(skew);
    };
    _PdfTransformationMatrix.prototype._degreeToRadians = function (degreesX) {
        var degreeRadFactor = Math.PI / 180;
        return degreeRadFactor * degreesX;
    };
    return _PdfTransformationMatrix;
}());
var _Matrix = /** @class */ (function () {
    function _Matrix(arg1, arg2, arg3, arg4, arg5, arg6) {
        if (typeof arg1 === 'undefined') {
            this._elements = [];
        }
        else if (typeof arg1 === 'number') {
            this._elements = [arg1, arg2, arg3, arg4, arg5, arg6];
        }
        else {
            this._elements = arg1;
        }
    }
    Object.defineProperty(_Matrix.prototype, "_offsetX", {
        get: function () {
            return this._elements[4];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_Matrix.prototype, "_offsetY", {
        get: function () {
            return this._elements[5];
        },
        enumerable: true,
        configurable: true
    });
    _Matrix.prototype._clone = function () {
        return new _Matrix(this._elements.slice());
    };
    _Matrix.prototype._translate = function (x, y) {
        this._elements[4] = x;
        this._elements[5] = y;
    };
    _Matrix.prototype._transform = function (points) {
        var x = points[0];
        var y = points[1];
        var x2 = x * this._elements[0] + y * this._elements[2] + this._offsetX;
        var y2 = x * this._elements[1] + y * this._elements[3] + this._offsetY;
        return [x2, y2];
    };
    _Matrix.prototype._multiply = function (matrix) {
        this._elements = [(this._elements[0] * matrix._elements[0] + this._elements[1] * matrix._elements[2]),
            (this._elements[0] * matrix._elements[1] + this._elements[1] * matrix._elements[3]),
            (this._elements[2] * matrix._elements[0] + this._elements[3] * matrix._elements[2]),
            (this._elements[2] * matrix._elements[1] + this._elements[3] * matrix._elements[3]),
            (this._offsetX * matrix._elements[0] + this._offsetY * matrix._elements[2] + matrix._offsetX),
            (this._offsetX * matrix._elements[1] + this._offsetY * matrix._elements[3] + matrix._offsetY)];
    };
    return _Matrix;
}());
/**
 * Represents a state of the graphics from a PDF page.
 *
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new font
 * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
 * // Save the graphics state
 * let state: PdfGraphicsState = graphics.save();
 * // Set graphics translate transform
 * graphics.translateTransform(100, 100);
 * // Draw the string
 * graphics.drawString("Hello world!", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));
 * // Restore the graphics state
 * graphics.restore(state);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfGraphicsState = /** @class */ (function () {
    /**
     * Initializes a new instance of the `PdfGraphicsState` class.
     *
     * @private
     * @param {PdfGraphics} graphics Graphics.
     * @param {_PdfTransformationMatrix} matrix Matrix.
     *
     */
    function PdfGraphicsState(graphics, matrix) {
        if (graphics) {
            this._g = graphics;
            this._transformationMatrix = matrix;
        }
        this._charSpacing = 0;
        this._wordSpacing = 0;
        this._textScaling = 100;
        this._textRenderingMode = _TextRenderingMode.fill;
    }
    return PdfGraphicsState;
}());
var _TransparencyData = /** @class */ (function () {
    function _TransparencyData() {
    }
    return _TransparencyData;
}());
var _TextRenderingMode;
(function (_TextRenderingMode) {
    _TextRenderingMode[_TextRenderingMode["fill"] = 0] = "fill";
    _TextRenderingMode[_TextRenderingMode["stroke"] = 1] = "stroke";
    _TextRenderingMode[_TextRenderingMode["fillStroke"] = 2] = "fillStroke";
    _TextRenderingMode[_TextRenderingMode["none"] = 3] = "none";
    _TextRenderingMode[_TextRenderingMode["clipFlag"] = 4] = "clipFlag";
    _TextRenderingMode[_TextRenderingMode["clipFill"] = 4] = "clipFill";
    _TextRenderingMode[_TextRenderingMode["clipStroke"] = 5] = "clipStroke";
    _TextRenderingMode[_TextRenderingMode["clipFillStroke"] = 6] = "clipFillStroke";
    _TextRenderingMode[_TextRenderingMode["clip"] = 7] = "clip";
})(_TextRenderingMode || (_TextRenderingMode = {}));
/**
 * Represents a brush for the PDF page.
 *
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new brush
 * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
 * // Draw a rectangle using brush
 * graphics.drawRectangle(10, 10, 100, 100, brush);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfBrush = /** @class */ (function () {
    /**
     * Initializes a new instance of the `PdfBrush` class.
     *
     * @param {number[]} color Color.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new brush
     * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
     * // Draw a rectangle using brush
     * graphics.drawRectangle(10, 10, 100, 100, brush);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    function PdfBrush(color) {
        this._color = typeof color !== 'undefined' ? color : [0, 0, 0];
    }
    return PdfBrush;
}());
/**
 * Represents a pen for the PDF page.
 *
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new pen
 * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
 * // Draw a rectangle using pen
 * graphics.drawRectangle(150, 50, 50, 50, pen);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfPen = /** @class */ (function () {
    /**
     * Initializes a new instance of the `PdfPen` class.
     *
     * @param {number[]} color Color.
     * @param {number} width Width.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Draw a rectangle using pen
     * graphics.drawRectangle(150, 50, 50, 50, pen);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    function PdfPen(color, width) {
        this._color = color;
        this._width = width;
        this._dashOffset = 0;
        this._dashPattern = [];
        this._dashStyle = PdfDashStyle.solid;
        this._miterLimit = 0;
        this._lineCap = PdfLineCap.flat;
        this._lineJoin = PdfLineJoin.miter;
    }
    return PdfPen;
}());
var _PdfUnitConvertor = /** @class */ (function () {
    function _PdfUnitConvertor() {
        this._horizontalResolution = 96;
        this._proportions = this._updateProportions(this._horizontalResolution);
    }
    _PdfUnitConvertor.prototype._updateProportions = function (pixel) {
        return [pixel / 2.54, pixel / 6.0, 1, pixel / 72.0, pixel, pixel / 300.0, pixel / 25.4];
    };
    _PdfUnitConvertor.prototype._convertUnits = function (value, from, to) {
        return this._convertFromPixels(this._convertToPixels(value, from), to);
    };
    _PdfUnitConvertor.prototype._convertFromPixels = function (value, to) {
        var index = to;
        return (value / this._proportions[Number.parseInt(index.toString(), 10)]);
    };
    _PdfUnitConvertor.prototype._convertToPixels = function (value, from) {
        var index = from;
        return (value * this._proportions[Number.parseInt(index.toString(), 10)]);
    };
    return _PdfUnitConvertor;
}());

var _XmlWriter = /** @class */ (function () {
    function _XmlWriter(isAppearance) {
        if (isAppearance === void 0) { isAppearance = false; }
        this._position = 0;
        this._bufferText = '';
        this._buffer = new Uint8Array(0);
        this._namespaceStack = [];
        this._elementStack = [];
        if (!isAppearance) {
            this._currentState = 'Initial';
            this._namespaceStack.push(new _Namespace());
            this._elementStack.push(new _XmlElement());
            this._namespaceStack[0]._set('xmlns', 'http://www.w3.org/2000/xmlns/', 'Special');
            this._namespaceStack.push(new _Namespace());
            this._namespaceStack[1]._set('xml', 'http://www.w3.org/XML/1998/namespace', 'Special');
            this._namespaceStack.push(new _Namespace());
            this._namespaceStack[2]._set('', '', 'Implied');
            this._elementStack[0]._set('', '', '', this._namespaceStack.length - 1);
        }
        else {
            this._currentState = 'StartDocument';
            this._skipNamespace = true;
        }
        this._attributeStack = [];
    }
    Object.defineProperty(_XmlWriter.prototype, "buffer", {
        get: function () {
            this._flush();
            return this._buffer;
        },
        enumerable: true,
        configurable: true
    });
    _XmlWriter.prototype._writeStartDocument = function (standalone) {
        if (this._currentState !== 'Initial' || typeof this._buffer === 'undefined') {
            throw new Error('InvalidOperationException: Wrong Token');
        }
        this._currentState = 'StartDocument';
        this._rawText('<?xml version="1.0" encoding="utf-8');
        if (typeof standalone !== 'undefined' && standalone !== null) {
            this._rawText('" standalone="');
            this._rawText(standalone ? 'yes' : 'no');
        }
        this._rawText('"?>');
    };
    _XmlWriter.prototype._writeStartElement = function (localName, prefix, namespace) {
        if (typeof this._buffer === 'undefined') {
            throw new Error('InvalidOperationException: Wrong Token');
        }
        if (typeof localName === 'undefined' || localName === null || localName.length === 0) {
            throw new Error('ArgumentException: localName cannot be undefined, null or empty');
        }
        this._checkName(localName);
        if (this._currentState === 'Initial') {
            this._writeStartDocument();
        }
        if (this._currentState === 'StartElement') {
            this._startElementContent();
        }
        this._currentState = 'StartElement';
        if (typeof prefix === 'undefined' || prefix === null) {
            if (typeof namespace !== 'undefined' && namespace !== null) {
                prefix = this._lookupPrefix(namespace);
            }
            if (typeof prefix === 'undefined' || prefix === null) {
                prefix = '';
            }
        }
        else if (prefix.length > 0) {
            if (typeof namespace === 'undefined' || namespace === null) {
                namespace = this._lookupNamespace(prefix);
            }
            if (typeof namespace === 'undefined' || namespace === null || (typeof namespace !== 'undefined' && namespace.length === 0)) {
                throw new Error('ArgumentException: Cannot use a prefix with an empty namespace');
            }
        }
        if (typeof namespace === 'undefined' || namespace === null) {
            namespace = this._lookupNamespace(prefix);
        }
        this._writeStartElementInternal(prefix, localName, namespace);
    };
    _XmlWriter.prototype._writeEndElement = function () {
        if (this._currentState === 'StartElement') {
            this._startElementContent();
            this._currentState = 'ElementContent';
        }
        else if (this._currentState === 'ElementContent') {
            this._currentState = 'ElementContent';
        }
        this._currentState = 'EndElement';
        var top = this._elementStack.length - 1;
        this._writeEndElementInternal(this._elementStack[Number.parseInt(top.toString(), 10)]._prefix, this._elementStack[Number.parseInt(top.toString(), 10)]._localName);
        this._namespaceStack.splice(this._elementStack[Number.parseInt(top.toString(), 10)]._previousTop + 1);
        this._elementStack.splice(top);
        // if (this._bufferText.length > 10240) {
        //     this._flush();
        // }
    };
    _XmlWriter.prototype._writeElementString = function (localName, value, prefix, namespace) {
        this._writeStartElement(localName, prefix, namespace);
        if (typeof value !== 'undefined' && value !== null && value.length !== 0) {
            this._writeString(value);
        }
        this._writeEndElement();
    };
    _XmlWriter.prototype._writeAttributeString = function (localName, value, prefix, namespace) {
        this._writeStartAttribute(localName, value, prefix, namespace);
        this._writeStringInternal(value, true);
        this._writeEndAttribute();
    };
    _XmlWriter.prototype._writeString = function (text) {
        this._writeInternal(text, false);
    };
    _XmlWriter.prototype._writeRaw = function (text) {
        this._writeInternal(text, true);
    };
    _XmlWriter.prototype._writeInternal = function (text, isRawString) {
        if (text !== null && typeof text !== 'undefined') {
            if (this._currentState !== 'StartElement' && this._currentState !== 'ElementContent') {
                throw new Error('InvalidOperationException: Wrong Token');
            }
            if (this._currentState === 'StartElement') {
                this._startElementContent();
            }
            this._currentState = 'ElementContent';
            if (isRawString) {
                this._rawText(text);
            }
            else {
                this._writeStringInternal(text, false);
            }
        }
    };
    _XmlWriter.prototype._save = function () {
        while (this._elementStack.length - 1 > 0) {
            this._writeEndElement();
        }
        if (this._bufferText !== '') {
            this._flush();
        }
        return this._buffer;
    };
    _XmlWriter.prototype._destroy = function () {
        this._buffer = undefined;
        for (var i = 0; i < this._namespaceStack.length; i++) {
            this._namespaceStack[Number.parseInt(i.toString(), 10)]._destroy();
        }
        this._namespaceStack = [];
        for (var i = 0; i < this._elementStack.length; i++) {
            this._elementStack[Number.parseInt(i.toString(), 10)]._destroy();
        }
        this._elementStack = [];
        this._bufferText = '';
        this._position = 0;
    };
    _XmlWriter.prototype._flush = function () {
        if (this._buffer && this._bufferText && this._bufferText !== '') {
            if (this._buffer.length > 0) {
                var buffer = new Array(this._bufferText.length);
                for (var i = 0; i < this._bufferText.length; i++) {
                    buffer[Number.parseInt(i.toString(), 10)] = this._bufferText.charCodeAt(i) & 0xff;
                }
                var array = new Uint8Array(this._buffer.length + buffer.length);
                array.set(this._buffer);
                array.set(buffer, this._buffer.length);
                this._buffer = array;
            }
            else {
                this._buffer = _stringToBytes(this._bufferText);
            }
            this._bufferText = '';
        }
    };
    _XmlWriter.prototype._writeStartAttribute = function (localName, value, prefix, namespace) {
        if (typeof localName === 'undefined' || localName === null || localName.length === 0) {
            if (prefix === 'xmlns') {
                localName = 'xmlns';
                prefix = '';
            }
            else {
                throw new Error('ArgumentException: localName cannot be undefined, null or empty');
            }
        }
        if (this._currentState !== 'StartElement') {
            throw new Error('InvalidOperationException: Wrong Token');
        }
        this._checkName(localName);
        this._writeStartAttributePrefixAndNameSpace(localName, value, prefix, namespace);
    };
    _XmlWriter.prototype._writeStartAttributePrefixAndNameSpace = function (localName, value, prefix, namespace) {
        if (typeof prefix === 'undefined' || prefix === null) {
            if (typeof namespace !== 'undefined' && namespace !== null) {
                if (!(localName === 'xmlns' && namespace === 'http://www.w3.org/2000/xmlns/')) {
                    prefix = this._lookupPrefix(namespace);
                }
            }
            if (typeof prefix === 'undefined' || prefix === null) {
                prefix = '';
            }
        }
        if (typeof namespace === 'undefined' || namespace === null) {
            if (typeof prefix !== 'undefined' && prefix !== null && prefix.length > 0) {
                namespace = this._lookupNamespace(prefix);
            }
            if (typeof namespace === 'undefined' || namespace === null) {
                namespace = '';
            }
        }
        this._writeStartAttributeSpecialAttribute(prefix, localName, namespace, value);
    };
    _XmlWriter.prototype._writeStartAttributeSpecialAttribute = function (prefix, localName, namespace, value) {
        if (prefix.length === 0) {
            if (localName[0] === 'x' && localName === 'xmlns') {
                this._skipPushAndWrite(prefix, localName, namespace);
                this._pushNamespaceExplicit('', value);
                return;
            }
            else if (namespace.length > 0) {
                prefix = this._lookupPrefix(namespace);
            }
        }
        else {
            if (prefix[0] === 'x') {
                if (prefix === 'xmlns') {
                    this._skipPushAndWrite(prefix, localName, namespace);
                    this._pushNamespaceExplicit(localName, value);
                    return;
                }
                else if (prefix === 'xml') {
                    if (localName === 'space' || localName === 'lang') {
                        this._skipPushAndWrite(prefix, localName, namespace);
                        return;
                    }
                }
            }
            if (namespace.length === 0) {
                prefix = '';
            }
        }
        if (typeof prefix !== 'undefined' && prefix !== null && prefix.length !== 0) {
            this._pushNamespaceImplicit(prefix, namespace);
        }
        this._skipPushAndWrite(prefix, localName, namespace);
    };
    _XmlWriter.prototype._writeEndAttribute = function () {
        this._currentState = 'StartElement';
        this._bufferText += '"';
    };
    _XmlWriter.prototype._writeStartElementInternal = function (prefix, localName, namespace) {
        this._bufferText += '<';
        if (prefix.length > 0) {
            this._rawText(prefix);
            this._bufferText += ':';
        }
        this._rawText(localName);
        var top = this._elementStack.length;
        this._elementStack.push(new _XmlElement());
        this._elementStack[Number.parseInt(top.toString(), 10)]._set(prefix, localName, namespace, this._namespaceStack.length - 1);
        this._pushNamespaceImplicit(prefix, namespace);
        for (var i = 0; i < this._attributeStack.length; i++) {
            this._attributeStack[Number.parseInt(i.toString(), 10)]._destroy();
        }
        this._attributeStack = [];
    };
    _XmlWriter.prototype._writeEndElementInternal = function (prefix, localName) {
        if (this._position !== this._bufferText.length + 1) {
            this._bufferText += '</';
            if (typeof prefix !== 'undefined' && prefix !== null && prefix.length !== 0) {
                this._rawText(prefix);
                this._bufferText += ':';
            }
            this._rawText(localName);
            this._bufferText += '>';
        }
        else {
            this._bufferText = this._bufferText.substring(0, this._bufferText.length - 1);
            this._bufferText += ' />';
        }
    };
    _XmlWriter.prototype._writeStartAttributeInternal = function (prefix, localName) {
        this._bufferText += ' ';
        if (typeof prefix !== 'undefined' && prefix !== null && prefix.length > 0) {
            this._rawText(prefix);
            this._bufferText += ':';
        }
        this._rawText(localName);
        this._bufferText += '="';
    };
    _XmlWriter.prototype._writeNamespaceDeclaration = function (prefix, namespaceUri) {
        if (!this._skipNamespace) {
            this._writeStartNamespaceDeclaration(prefix);
            this._writeStringInternal(namespaceUri, true);
            this._bufferText += '"';
        }
    };
    _XmlWriter.prototype._writeStartNamespaceDeclaration = function (prefix) {
        if (typeof prefix === 'undefined' || prefix === null || prefix.length === 0) {
            this._rawText(' xmlns="');
        }
        else {
            this._rawText(' xmlns:');
            this._rawText(prefix);
            this._bufferText += '=';
            this._bufferText += '"';
        }
    };
    _XmlWriter.prototype._writeStringInternal = function (text, inAttributeValue) {
        if (typeof text === 'undefined' || text === null) {
            text = '';
        }
        text = text.replace(/\&/g, '&amp;'); // eslint-disable-line
        text = text.replace(/\</g, '&lt;'); // eslint-disable-line
        text = text.replace(/\>/g, '&gt;'); // eslint-disable-line
        if (inAttributeValue) {
            text = text.replace(/\"/g, '&quot;'); // eslint-disable-line
        }
        this._bufferText += text;
        if (!inAttributeValue) {
            this._position = 0;
        }
    };
    _XmlWriter.prototype._startElementContent = function () {
        var start = this._elementStack[this._elementStack.length - 1]._previousTop;
        for (var i = this._namespaceStack.length - 1; i > start; i--) {
            if (this._namespaceStack[Number.parseInt(i.toString(), 10)]._kind === 'NeedToWrite') {
                this._writeNamespaceDeclaration(this._namespaceStack[Number.parseInt(i.toString(), 10)]._prefix, this._namespaceStack[Number.parseInt(i.toString(), 10)]._namespaceUri);
            }
        }
        this._bufferText += '>';
        this._position = this._bufferText.length + 1;
    };
    _XmlWriter.prototype._rawText = function (text) {
        this._bufferText += text;
    };
    _XmlWriter.prototype._addNamespace = function (prefix, ns, kind) {
        var top = this._namespaceStack.length;
        this._namespaceStack.push(new _Namespace());
        this._namespaceStack[Number.parseInt(top.toString(), 10)]._set(prefix, ns, kind);
    };
    _XmlWriter.prototype._lookupPrefix = function (namespace) {
        for (var i = this._namespaceStack.length - 1; i >= 0; i--) {
            if (this._namespaceStack[Number.parseInt(i.toString(), 10)]._namespaceUri === namespace) {
                return this._namespaceStack[Number.parseInt(i.toString(), 10)]._prefix;
            }
        }
        return undefined;
    };
    _XmlWriter.prototype._lookupNamespace = function (prefix) {
        for (var i = this._namespaceStack.length - 1; i >= 0; i--) {
            if (this._namespaceStack[Number.parseInt(i.toString(), 10)]._prefix === prefix) {
                return this._namespaceStack[Number.parseInt(i.toString(), 10)]._namespaceUri;
            }
        }
        return undefined;
    };
    _XmlWriter.prototype._lookupNamespaceIndex = function (prefix) {
        for (var i = this._namespaceStack.length - 1; i >= 0; i--) {
            if (this._namespaceStack[Number.parseInt(i.toString(), 10)]._prefix === prefix) {
                return i;
            }
        }
        return -1;
    };
    _XmlWriter.prototype._pushNamespaceImplicit = function (prefix, ns) {
        var kind;
        var existingNsIndex = this._lookupNamespaceIndex(prefix);
        var isValid = true;
        if (existingNsIndex !== -1) {
            if (existingNsIndex > this._elementStack[this._elementStack.length - 1]._previousTop) {
                if (this._namespaceStack[Number.parseInt(existingNsIndex.toString(), 10)]._namespaceUri !== ns) {
                    throw new Error('XmlException namespace Uri needs to be the same as the one that is already declared');
                }
                isValid = false;
            }
            else {
                if (this._namespaceStack[Number.parseInt(existingNsIndex.toString(), 10)]._kind === 'Special') {
                    if (prefix === 'xml') {
                        if (ns !== this._namespaceStack[Number.parseInt(existingNsIndex.toString(), 10)]._namespaceUri) {
                            throw new Error('InvalidArgumentException: Xml String');
                        }
                        else {
                            kind = 'Implied';
                        }
                    }
                    else {
                        throw new Error('InvalidArgumentException: Prefix "xmlns" is reserved for use by XML.');
                    }
                }
                else {
                    kind = (this._namespaceStack[Number.parseInt(existingNsIndex.toString(), 10)]._namespaceUri === ns) ?
                        'Implied' :
                        'NeedToWrite';
                }
            }
        }
        else {
            if ((ns === 'http://www.w3.org/XML/1998/namespace' && prefix !== 'xml') ||
                (ns === 'http://www.w3.org/2000/xmlns/' && prefix !== 'xmlns')) {
                throw new Error('InvalidArgumentException');
            }
            kind = 'NeedToWrite';
        }
        if (isValid) {
            this._addNamespace(prefix, ns, kind);
        }
    };
    _XmlWriter.prototype._pushNamespaceExplicit = function (prefix, ns) {
        var existingNsIndex = this._lookupNamespaceIndex(prefix);
        if (existingNsIndex !== -1) {
            if (existingNsIndex > this._elementStack[this._elementStack.length - 1]._previousTop) {
                this._namespaceStack[Number.parseInt(existingNsIndex.toString(), 10)]._kind = 'Written';
                return;
            }
        }
        this._addNamespace(prefix, ns, 'Written');
        return;
    };
    _XmlWriter.prototype._addAttribute = function (prefix, localName, namespaceName) {
        var top = this._attributeStack.length;
        this._attributeStack.push(new _XmlAttribute());
        this._attributeStack[Number.parseInt(top.toString(), 10)]._set(prefix, localName, namespaceName);
        for (var i = 0; i < top; i++) {
            if (this._attributeStack[Number.parseInt(i.toString(), 10)]._isDuplicate(prefix, localName, namespaceName)) {
                throw new Error('XmlException: duplicate attribute name');
            }
        }
    };
    _XmlWriter.prototype._skipPushAndWrite = function (prefix, localName, namespace) {
        this._addAttribute(prefix, localName, namespace);
        this._writeStartAttributeInternal(prefix, localName);
    };
    _XmlWriter.prototype._checkName = function (text) {
        var format = /[ !@#$%^&*()+\=\[\]{};':"\\|,<>\/?]/; // eslint-disable-line
        if (format.test(text)) {
            throw new Error('InvalidArgumentException: invalid name character');
        }
    };
    return _XmlWriter;
}());
var _Namespace = /** @class */ (function () {
    function _Namespace() {
    }
    _Namespace.prototype._set = function (prefix, namespaceUri, kind) {
        this._prefix = prefix;
        this._namespaceUri = namespaceUri;
        this._kind = kind;
    };
    _Namespace.prototype._destroy = function () {
        this._prefix = undefined;
        this._namespaceUri = undefined;
        this._kind = undefined;
    };
    return _Namespace;
}());
var _XmlElement = /** @class */ (function () {
    function _XmlElement() {
    }
    _XmlElement.prototype._set = function (prefix, localName, namespaceUri, previousTop) {
        this._previousTop = previousTop;
        this._prefix = prefix;
        this._namespaceUri = namespaceUri;
        this._localName = localName;
    };
    _XmlElement.prototype._destroy = function () {
        this._previousTop = undefined;
        this._prefix = undefined;
        this._localName = undefined;
        this._namespaceUri = undefined;
    };
    return _XmlElement;
}());
var _XmlAttribute = /** @class */ (function () {
    function _XmlAttribute() {
    }
    _XmlAttribute.prototype._set = function (prefix, localName, namespaceUri) {
        this._prefix = prefix;
        this._namespaceUri = namespaceUri;
        this._localName = localName;
    };
    _XmlAttribute.prototype._isDuplicate = function (prefix, localName, namespaceUri) {
        return ((this._localName === localName) && ((this._prefix === prefix) || (this._namespaceUri === namespaceUri)));
    };
    _XmlAttribute.prototype._destroy = function () {
        this._prefix = undefined;
        this._namespaceUri = undefined;
        this._localName = undefined;
    };
    return _XmlAttribute;
}());

var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _ExportHelper = /** @class */ (function () {
    function _ExportHelper() {
        this._asPerSpecification = false;
        this._fileName = '';
        this._formKey = '';
        this._exportEmptyFields = false;
        this._groupReferences = new Map();
        this._groupHolders = [];
        this._richTextPrefix = '<?xml version="1.0"?>';
        this._table = new Map(); // eslint-disable-line
        this._fields = new Map();
        this._richTextValues = new Map();
        this._jsonData = [];
        this._openingBrace = 123;
        this._openingBracket = 91;
        this._closingBrace = 125;
        this._closingBracket = 93;
        this._colon = 58;
        this._doubleQuotes = 34;
        this._comma = 44;
        this._space = 32;
        this.fdfString = '';
        this._xmlImport = false;
    }
    _ExportHelper.prototype._exportFormFieldsData = function (field) {
        var textValue = '';
        if (field !== null && typeof field !== 'undefined' && field.export) {
            var type = _getInheritableProperty(field._dictionary, 'FT', false, true, 'Parent');
            if (type && type.name !== null && typeof type.name !== 'undefined') {
                var font = this._getEncodedFontDictionary(field._dictionary);
                var fieldName = field.name;
                if (font !== null && typeof font !== 'undefined') {
                    fieldName = this._getEncodedValue(fieldName, font);
                }
                var value = void 0; // eslint-disable-line
                var selectedValue = void 0;
                switch (type.name) {
                    case 'Tx':
                        textValue = _getInheritableProperty(field._dictionary, 'V', false, true, 'Parent');
                        if (textValue !== null && typeof textValue !== 'undefined') {
                            textValue = this._getEncodedValue(textValue, font);
                            this._table.set(fieldName, textValue);
                        }
                        else if (this._exportEmptyFields) {
                            textValue = '';
                            this._table.set(fieldName, textValue);
                        }
                        break;
                    case 'Ch':
                        value = _getInheritableProperty(field._dictionary, 'V', true, true, 'Parent');
                        if (value !== null && typeof value !== 'undefined') {
                            selectedValue = this._getExportValue(value);
                        }
                        if (!value && field._dictionary.has('I') && (field instanceof PdfListBoxField || field instanceof PdfComboBoxField)) {
                            selectedValue = field._obtainSelectedValue();
                        }
                        if (selectedValue !== null && typeof selectedValue !== 'undefined') {
                            if (typeof selectedValue === 'string' && selectedValue !== '') {
                                selectedValue = this._getEncodedValue(selectedValue, font);
                                textValue = selectedValue;
                                this._table.set(fieldName, textValue);
                            }
                            else if (selectedValue instanceof Array && selectedValue.length > 0) {
                                var values = [];
                                for (var i = 0; i < selectedValue.length; i++) {
                                    values.push(this._getEncodedValue(selectedValue[Number.parseInt(i.toString(), 10)], font));
                                }
                                this._table.set(fieldName, values);
                                return values;
                            }
                        }
                        else if (this._exportEmptyFields) {
                            textValue = '';
                            this._table.set(fieldName, textValue);
                        }
                        break;
                    case 'Btn':
                        value = _getInheritableProperty(field._dictionary, 'V', false, true, 'Parent');
                        if (value !== null && typeof value !== 'undefined') {
                            var text = this._getExportValue(value, field);
                            if (text !== null && typeof text !== 'undefined' && text !== '') {
                                var radioButton = void 0;
                                if (field instanceof PdfRadioButtonListField) {
                                    radioButton = field;
                                }
                                if (!field._dictionary.has('Opt') ||
                                    (radioButton !== null &&
                                        typeof radioButton !== 'undefined'
                                        && radioButton.selectedIndex === -1)) {
                                    text = this._getEncodedValue(text, font);
                                    textValue = text;
                                    this._table.set(fieldName, textValue);
                                }
                                else {
                                    if (field._dictionary.has('Opt')) {
                                        var options = field._dictionary.getArray('Opt');
                                        var index = Number.parseInt(text, 10);
                                        if (index === null || typeof index === 'undefined' || Number.isNaN(index)) {
                                            index = 0;
                                        }
                                        if (options !== null && typeof options !== 'undefined') {
                                            var current = void 0;
                                            if (radioButton) {
                                                current = options[radioButton.selectedIndex];
                                            }
                                            else {
                                                current = options[Number.parseInt(index.toString(), 10)];
                                            }
                                            if (current !== null && typeof current !== 'undefined') {
                                                text = current;
                                            }
                                            if (text !== null && typeof text !== 'undefined' && text !== '') {
                                                text = this._getEncodedValue(text, font);
                                                textValue = text;
                                                this._table.set(fieldName, textValue);
                                            }
                                        }
                                    }
                                }
                            }
                            else if (field instanceof PdfRadioButtonListField || field instanceof PdfCheckBoxField) {
                                if (this._exportEmptyFields) {
                                    textValue = text;
                                }
                                else {
                                    textValue = 'Off';
                                }
                                this._table.set(fieldName, textValue);
                            }
                        }
                        else {
                            if (field instanceof PdfRadioButtonListField) {
                                textValue = field._getAppearanceStateValue();
                                if (!textValue) {
                                    if (this._exportEmptyFields) {
                                        textValue = '';
                                    }
                                    else {
                                        textValue = 'Off';
                                    }
                                }
                                this._table.set(fieldName, textValue);
                            }
                            else {
                                var widget = field.itemAt(field._defaultIndex);
                                var dictionary = void 0;
                                if (widget) {
                                    dictionary = widget._dictionary;
                                }
                                else {
                                    dictionary = field._dictionary;
                                }
                                if (dictionary && dictionary.has('AS')) {
                                    textValue = dictionary.get('AS').name;
                                    this._table.set(fieldName, textValue);
                                }
                                else if (this._exportEmptyFields) {
                                    textValue = '';
                                    this._table.set(fieldName, textValue);
                                }
                            }
                        }
                        break;
                }
            }
        }
        return textValue;
    };
    _ExportHelper.prototype._exportFormFieldData = function (field) {
        var type = _getInheritableProperty(field._dictionary, 'FT', false, true, 'Parent');
        if (type && type.name !== null && typeof type.name !== 'undefined') {
            var font = this._getEncodedFontDictionary(field._dictionary);
            var fieldName = field.name;
            if (font !== null && typeof font !== 'undefined') {
                fieldName = this._getEncodedValue(fieldName, font);
            }
            var textValue = void 0;
            var value = void 0; // eslint-disable-line
            switch (type.name) {
                case 'Tx':
                    textValue = _getInheritableProperty(field._dictionary, 'V', false, true, 'Parent');
                    if (this._asPerSpecification) {
                        if (field._dictionary.has('RV')) {
                            textValue = _getInheritableProperty(field._dictionary, 'RV', false, true, 'Parent');
                            if (textValue !== null && typeof textValue !== 'undefined') {
                                textValue += this._key;
                                this._formKey = this._key;
                                this._table.set(fieldName, textValue);
                            }
                        }
                        else if (textValue !== null && typeof textValue !== 'undefined') {
                            textValue = this._getEncodedValue(textValue, font);
                            var replaceValue = textValue;
                            if (field instanceof PdfTextBoxField && field.multiLine) {
                                replaceValue = replaceValue.replace('\n', '');
                                replaceValue = replaceValue.replace('\r', '\r\n');
                                textValue = replaceValue;
                            }
                            this._table.set(fieldName, textValue);
                        }
                    }
                    else {
                        if (textValue !== null && typeof textValue !== 'undefined') {
                            textValue = this._getEncodedValue(textValue, font);
                            this._table.set(fieldName, textValue);
                        }
                        else if (this._exportEmptyFields) {
                            this._table.set(fieldName, '');
                        }
                    }
                    break;
                case 'Ch':
                    value = _getInheritableProperty(field._dictionary, 'V', true, true, 'Parent');
                    if (this._asPerSpecification) {
                        if (field instanceof PdfListField) {
                            if (Array.isArray(value)) {
                                this._table.set(fieldName, value);
                            }
                            else {
                                if (typeof value === 'string') {
                                    value = this._getEncodedValue(value, font);
                                    this._table.set(fieldName, value);
                                }
                                else if ((value === null || typeof value === 'undefined') && field._dictionary.has('I')) {
                                    var selectedValue = field._obtainSelectedValue();
                                    if (selectedValue !== null && typeof selectedValue !== 'undefined') {
                                        if (typeof selectedValue === 'string' && selectedValue !== '') {
                                            selectedValue = this._getEncodedValue(selectedValue, font);
                                            this._table.set(fieldName, textValue);
                                        }
                                        else if (selectedValue instanceof Array && selectedValue.length > 0) {
                                            var values = [];
                                            for (var i = 0; i < selectedValue.length; i++) {
                                                values.push(this._getEncodedValue(selectedValue[Number.parseInt(i.toString(), 10)], font));
                                            }
                                            this._table.set(fieldName, values);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else {
                        var selectedValue = void 0;
                        if (value !== null && typeof value !== 'undefined') {
                            selectedValue = this._getExportValue(value);
                        }
                        if (!value && field._dictionary.has('I') && (field instanceof PdfListBoxField || field instanceof PdfComboBoxField)) {
                            selectedValue = field._obtainSelectedValue();
                        }
                        if (selectedValue !== null && typeof selectedValue !== 'undefined') {
                            if (typeof selectedValue === 'string' && selectedValue !== '') {
                                selectedValue = this._getEncodedValue(selectedValue, font);
                                this._table.set(fieldName, selectedValue);
                            }
                            else if (selectedValue instanceof Array && selectedValue.length > 0) {
                                var values = [];
                                for (var i = 0; i < selectedValue.length; i++) {
                                    values.push(this._getEncodedValue(selectedValue[Number.parseInt(i.toString(), 10)], font));
                                }
                                this._table.set(fieldName, values);
                            }
                            else if (this._exportEmptyFields) {
                                this._table.set(fieldName, '');
                            }
                        }
                        else if (this._exportEmptyFields) {
                            this._table.set(fieldName, '');
                        }
                    }
                    break;
                case 'Btn':
                    value = _getInheritableProperty(field._dictionary, 'V', false, true, 'Parent');
                    if (value !== null && typeof value !== 'undefined') {
                        var text = this._getExportValue(value, field);
                        if (text !== null && typeof text !== 'undefined' && text !== '') {
                            if (this._asPerSpecification && this._format !== 'XML') {
                                text = _hexStringToString(text);
                            }
                            var radioButton = void 0;
                            if (field instanceof PdfRadioButtonListField) {
                                radioButton = field;
                            }
                            if (!field._dictionary.has('Opt') ||
                                (radioButton !== null &&
                                    typeof radioButton !== 'undefined'
                                    && radioButton.selectedIndex === -1)) {
                                text = this._getEncodedValue(text, font);
                                this._table.set(fieldName, text);
                            }
                            else {
                                if (field._dictionary.has('Opt')) {
                                    var options = field._dictionary.getArray('Opt');
                                    var index = Number.parseInt(text, 10);
                                    if (index === null || typeof index === 'undefined' || Number.isNaN(index)) {
                                        index = 0;
                                    }
                                    if (options !== null && typeof options !== 'undefined') {
                                        var current = void 0;
                                        if (radioButton) {
                                            current = options[radioButton.selectedIndex];
                                        }
                                        else {
                                            current = options[Number.parseInt(index.toString(), 10)];
                                        }
                                        if (current !== null && typeof current !== 'undefined') {
                                            text = current;
                                        }
                                        if (text !== null && typeof text !== 'undefined' && text !== '') {
                                            text = this._getEncodedValue(text, font);
                                            this._table.set(fieldName, text);
                                        }
                                    }
                                }
                            }
                        }
                        else if (field instanceof PdfRadioButtonListField || field instanceof PdfCheckBoxField) {
                            if (this._exportEmptyFields) {
                                this._table.set(fieldName, text);
                            }
                            else {
                                this._table.set(fieldName, 'Off');
                            }
                        }
                    }
                    else {
                        if (field instanceof PdfRadioButtonListField) {
                            var text = field._getAppearanceStateValue();
                            if (!text) {
                                if (this._exportEmptyFields) {
                                    text = '';
                                }
                                else {
                                    text = 'Off';
                                }
                            }
                            this._table.set(fieldName, text);
                        }
                        else {
                            var widget = field.itemAt(field._defaultIndex);
                            var dictionary = void 0;
                            if (widget) {
                                dictionary = widget._dictionary;
                            }
                            else {
                                dictionary = field._dictionary;
                            }
                            if (dictionary && dictionary.has('AS')) {
                                this._table.set(fieldName, dictionary.get('AS').name);
                            }
                            else if (this._exportEmptyFields) {
                                this._table.set(fieldName, '');
                            }
                        }
                    }
                    break;
            }
        }
    };
    _ExportHelper.prototype._getAnnotationType = function (dictionary) {
        var type = '';
        if (dictionary && dictionary.has('Subtype')) {
            var subtype = dictionary.get('Subtype');
            if (subtype) {
                type = subtype.name;
            }
        }
        return type;
    };
    _ExportHelper.prototype._getValue = function (primitive, isJson) {
        if (isJson === void 0) { isJson = false; }
        var value = '';
        if (typeof primitive !== 'undefined' && primitive !== null) {
            if (primitive instanceof _PdfName) {
                value = primitive.name;
            }
            else if (typeof primitive === 'boolean') {
                value = primitive ? isJson ? 'true' : 'yes' : isJson ? 'false' : 'no';
            }
            else if (typeof primitive === 'string') {
                value = this._getValidString(primitive);
            }
            else if (Array.isArray(primitive)) {
                var colorArray = primitive; // eslint-disable-line
                if (colorArray.length > 0) {
                    value = this._getValue(colorArray[0], isJson);
                }
                for (var i = 1; i < colorArray.length; i++) {
                    value += ',' + this._getValue(colorArray[Number.parseInt(i.toString(), 10)], isJson);
                }
            }
            else if (typeof primitive === 'number') {
                value = primitive.toString();
            }
        }
        return value;
    };
    _ExportHelper.prototype._getColor = function (primitive) {
        var color = '';
        if (primitive && Array.isArray(primitive) && primitive.length >= 3) {
            var r = Math.round(primitive[0] * 255).toString(16).toUpperCase();
            var g = Math.round(primitive[1] * 255).toString(16).toUpperCase();
            var b = Math.round(primitive[2] * 255).toString(16).toUpperCase();
            color = '#' + (r.length === 1 ? ('0' + r) : r) + (g.length === 1 ? ('0' + g) : g) + (b.length === 1 ? ('0' + b) : b);
        }
        return color;
    };
    _ExportHelper.prototype._getValidString = function (value) {
        if (value.indexOf('\n') !== -1) {
            value = value.replace(/\n/g, '\\n');
        }
        if (value.indexOf('\r') !== -1) {
            value = value.replace(/\r/g, '\\r');
        }
        return value;
    };
    _ExportHelper.prototype._getEncodedFontDictionary = function (source) {
        var font;
        var kids; // eslint-disable-line
        if (source.has('Kids') && !source.has('AP')) {
            kids = source.getArray('Kids');
        }
        if (source.has('AP') || (kids !== null && typeof kids !== 'undefined' && Array.isArray(kids))) {
            var appearance = void 0;
            if (kids !== null && typeof kids !== 'undefined' && kids.length > 0) {
                var kid = kids[0];
                if (kid !== null && typeof kid !== 'undefined' && kid.has('AP')) {
                    appearance = kid.get('AP');
                }
            }
            else {
                appearance = source.get('AP');
            }
            if (appearance !== null && typeof appearance !== 'undefined' && appearance.has('N')) {
                var normal = appearance.get('N');
                if (normal !== null && typeof normal !== 'undefined' && normal instanceof _PdfBaseStream && normal.dictionary.has('Resources')) {
                    var resource = normal.dictionary.get('Resources');
                    if (resource !== null && typeof resource !== 'undefined' && resource.has('Font')) {
                        font = resource.get('Font');
                    }
                }
            }
        }
        return font;
    };
    _ExportHelper.prototype._getEncodedValue = function (value, dictionary) {
        var _this = this;
        var text = value;
        var structure;
        if (this._encodeDictionary !== null && typeof this._encodeDictionary !== 'undefined') {
            structure = new _FontStructure(this._encodeDictionary);
            return this._replaceNotUsedCharacters(text, structure);
        }
        else {
            var root = this._document.form._dictionary;
            if (root !== null && typeof root !== 'undefined' && root.has('DR')) {
                var resource = root.get('DR');
                if (resource !== null && typeof resource !== 'undefined' && resource.has('Encoding')) {
                    var encoding = resource.get('Encoding');
                    if (encoding !== null && typeof encoding !== 'undefined' && encoding.has('PDFDocEncoding')) {
                        var pdfEncoding = encoding.get('PDFDocEncoding');
                        if (pdfEncoding !== null && typeof pdfEncoding !== 'undefined' && pdfEncoding.has('Differences')) {
                            var encodingDictionary = new _PdfDictionary(this._crossReference);
                            encodingDictionary.set('Differences', pdfEncoding.get('Differences'));
                            var reference = this._crossReference._getNextReference();
                            this._crossReference._cacheMap.set(reference, encodingDictionary);
                            var fontEncodeDictionary = new _PdfDictionary(this._crossReference);
                            fontEncodeDictionary.set('Subtype', _PdfName.get('Type1'));
                            fontEncodeDictionary.set('Encoding', reference);
                            structure = new _FontStructure(fontEncodeDictionary);
                            if (structure !== null &&
                                typeof structure !== 'undefined' &&
                                structure.differencesDictionary !== null &&
                                typeof structure.differencesDictionary !== 'undefined' &&
                                structure.differencesDictionary.size > 0) {
                                this._encodeDictionary = fontEncodeDictionary;
                                return this._replaceNotUsedCharacters(text, structure);
                            }
                        }
                    }
                }
            }
            if (value !== null &&
                typeof value !== 'undefined' &&
                dictionary !== null &&
                typeof dictionary !== 'undefined' &&
                dictionary.size > 0) {
                var result_1;
                var isSkip_1 = false;
                dictionary.forEach(function (key, value) {
                    if (!isSkip_1 && value !== null && typeof value !== 'undefined') {
                        var fontDictionary = void 0;
                        if (value instanceof _PdfDictionary) {
                            fontDictionary = value;
                        }
                        else if (value instanceof _PdfReference) {
                            var holder = _this._crossReference._fetch(value); // eslint-disable-line
                            if (holder !== null && typeof holder !== 'undefined' && holder instanceof _PdfDictionary) {
                                fontDictionary = holder;
                            }
                        }
                        if (fontDictionary) {
                            structure = new _FontStructure(fontDictionary);
                            result_1 = _this._replaceNotUsedCharacters(text, structure);
                            isSkip_1 = true;
                        }
                    }
                });
                if (!isSkip_1) {
                    return result_1;
                }
            }
            return text;
        }
    };
    _ExportHelper.prototype._replaceNotUsedCharacters = function (input, structure) {
        var updatedString = '';
        var differencesDictionary = structure.differencesDictionary;
        for (var i = 0; i < input.length; i++) {
            var text = input[Number.parseInt(i.toString(), 10)];
            var code = input.charCodeAt(i);
            if (differencesDictionary.has(text)) {
                var difference = differencesDictionary.get(text);
                if ((difference.length > 1 && structure._fontType !== 'Type3') ||
                    (code > 127 && code <= 255 && structure._fontType === 'Type1' &&
                        structure._baseFontEncoding !== 'WinAnsiEncoding' &&
                        structure._fontEncoding === 'Encoding' && structure._fontName === 'ZapfDingbats')) {
                    updatedString += text;
                }
                else {
                    updatedString += difference;
                }
            }
            else {
                updatedString += text;
            }
        }
        return updatedString;
    };
    _ExportHelper.prototype._getExportValue = function (primitive, field) {
        var value;
        if (primitive !== null && typeof primitive !== 'undefined') {
            if (field !== null && typeof field !== 'undefined') {
                if (primitive instanceof _PdfName) {
                    value = primitive.name;
                }
                else if (typeof primitive === 'string') {
                    value = primitive;
                }
                if (value !== null &&
                    typeof value !== 'undefined' &&
                    value !== '' &&
                    field instanceof PdfRadioButtonListField &&
                    field.selectedIndex !== -1) {
                    var item = field.itemAt(field.selectedIndex);
                    if (item !== null && typeof item !== 'undefined' && item.value === value) {
                        value = item.value;
                    }
                }
            }
            else {
                if (primitive instanceof _PdfName) {
                    value = primitive.name;
                }
                else if (typeof primitive === 'string') {
                    value = primitive;
                }
                else if (Array.isArray(primitive)) {
                    var values = [];
                    for (var i = 0; i < primitive.length; i++) {
                        var element = primitive[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                        if (element instanceof _PdfName) {
                            values.push(element.name);
                        }
                        else if (typeof element === 'string') {
                            values.push(element);
                        }
                    }
                    return values;
                }
            }
        }
        return value;
    };
    _ExportHelper.prototype._addReferenceToGroup = function (reference, dictionary) {
        var name = dictionary.get('NM');
        if (name && name !== '') {
            this._groupReferences.set(name, reference);
            if (dictionary.has('IRT')) {
                this._groupHolders.push(dictionary);
            }
        }
        else if (!name && dictionary.has('IRT')) {
            name = dictionary.get('IRT');
            if (name && name !== '' && this._groupReferences.has(name)) {
                dictionary.update('IRT', this._groupReferences.get(name));
            }
        }
    };
    _ExportHelper.prototype._handlePopup = function (annotations, reference, annotationDictionary, pageDictionary) {
        if (annotationDictionary && annotationDictionary.has('Popup')) {
            var popupReference = annotationDictionary.getRaw('Popup');
            var popup = annotationDictionary.get('Popup');
            if (popup && popup instanceof _PdfDictionary) {
                if (popupReference && popup) {
                    popup.update('Parent', reference);
                }
                var popupAnnotation = annotations._parseAnnotation(popup);
                var index = annotations._annotations.length;
                annotations._annotations.push(reference);
                pageDictionary.set('Annots', annotations._annotations);
                pageDictionary._updated = true;
                annotations._parsedAnnotations.set(index, popupAnnotation);
            }
        }
    };
    _ExportHelper.prototype._importField = function () {
        var _this = this;
        var form = this._document.form;
        var count = form.count;
        if (count) {
            this._fields.forEach(function (value, key) {
                var richTextValue;
                if (_this._richTextValues.size > 0 && _this._richTextValues.has(key)) {
                    richTextValue = _this._richTextValues.get(key);
                }
                var index = form._getFieldIndex(key);
                if (index !== -1 && index < count) {
                    var field = form.fieldAt(index);
                    if (field && field !== null && typeof field !== 'undefined') {
                        if (richTextValue && richTextValue !== '') {
                            field._dictionary.update('RV', richTextValue);
                        }
                        _this._importFieldData(field, value);
                    }
                }
            });
        }
    };
    _ExportHelper.prototype._importFieldData = function (field, values) {
        if (values !== null &&
            typeof values !== 'undefined' &&
            values.length > 0 &&
            field !== null &&
            typeof field !== 'undefined' &&
            !field.readOnly) {
            var value = values[0];
            if (field instanceof PdfTextBoxField) {
                if (value !== null && typeof value !== 'undefined') {
                    if (field instanceof PdfTextBoxField && field.multiLine) {
                        value = value.replace('\r\n', '\r');
                        value = value.replace('\n', '\r');
                    }
                    field.text = value;
                }
            }
            else if (field instanceof PdfListBoxField || field instanceof PdfComboBoxField) {
                var selectedValues_1;
                if (values.length > 1) {
                    selectedValues_1 = values;
                }
                else {
                    if (this._xmlImport) {
                        selectedValues_1 = (value.indexOf(',') !== -1 ? value.split(',') : [value]);
                    }
                    else {
                        selectedValues_1 = [value.indexOf(',') !== -1 ? value.split(',')[0] : value];
                    }
                }
                var indexes_1 = [];
                var options_1 = field._options;
                if (options_1 && options_1.length > 0) {
                    options_1.forEach(function (option) {
                        if (selectedValues_1.indexOf(option[0]) !== -1 || selectedValues_1.indexOf(option[1]) !== -1) {
                            indexes_1.push(options_1.indexOf(option));
                        }
                    });
                }
                if (indexes_1.length > 0) {
                    field.selectedIndex = indexes_1;
                    if (field instanceof PdfComboBoxField && this._asPerSpecification && field._dictionary.has('AP')) {
                        delete field._dictionary._map.AP;
                        field._dictionary._updated = true;
                    }
                }
            }
            else if (field instanceof PdfCheckBoxField) {
                var lowerCase = value.toLowerCase();
                if (this._containsExportValue(value, field) || lowerCase === 'on' || lowerCase === 'yes') {
                    field.checked = true;
                }
                else {
                    field.checked = false;
                }
            }
            else if (field instanceof PdfRadioButtonListField) {
                var index = -1;
                for (var i = 0; i < field._kidsCount; i++) {
                    var item = field.itemAt(i);
                    if (item && item.value && item.value === value) {
                        index = i;
                        break;
                    }
                }
                if (index !== -1 && field.selectedIndex !== index) {
                    field.selectedIndex = index;
                }
            }
        }
    };
    _ExportHelper.prototype._containsExportValue = function (value, field) {
        var result = false;
        if (field._kidsCount > 0) {
            for (var i = 0; i < field._kidsCount; i++) {
                var kid = field.itemAt(i);
                if (kid && this._checkSelected(kid._dictionary, value)) {
                    return true;
                }
            }
        }
        else {
            result = this._checkSelected(field._dictionary, value);
            if (!result && this._asPerSpecification && field._dictionary.has('AS')) {
                var asEntry = field._dictionary.get('AS');
                if (asEntry && (asEntry.name === 'Off' || asEntry.name === 'No')) {
                    if (field._dictionary.has('Opt')) {
                        var options = field._dictionary.getArray('Opt');
                        if (options && options.length > 0) {
                            options.forEach(function (option) {
                                if (option === value) {
                                    result = true;
                                }
                            });
                        }
                    }
                }
                else {
                    result = true;
                }
            }
        }
        return result;
    };
    _ExportHelper.prototype._checkSelected = function (dictionary, value) {
        if (dictionary && dictionary.has('AP')) {
            var appearance = dictionary.get('AP');
            if (appearance && appearance instanceof _PdfDictionary && appearance.has('N')) {
                var normalTemplate = appearance.get('N');
                if (normalTemplate &&
                    normalTemplate instanceof _PdfDictionary &&
                    normalTemplate.has(value) &&
                    !(value.toLocaleLowerCase() === 'off' || value.toLocaleLowerCase() === 'no')) {
                    return true;
                }
            }
        }
        return false;
    };
    _ExportHelper.prototype._dispose = function () {
        this.exportAppearance = undefined;
        this._asPerSpecification = undefined;
        this._skipBorderStyle = undefined;
        this._fileName = undefined;
        this._document = undefined;
        this._crossReference = undefined;
        this._isAnnotationExport = undefined;
        this._isAnnotationImport = undefined;
        this._key = undefined;
        this._formKey = undefined;
        this._exportEmptyFields = undefined;
        this._groupReferences = undefined;
        this._groupHolders = undefined;
        this._encodeDictionary = undefined;
        this._annotationTypes = undefined;
        this._annotationAttributes = undefined;
        this._xmlDocument = undefined;
        this._parser = undefined;
        this._table = undefined;
        this._fields = undefined;
        this._richTextValues = undefined;
        this._jsonData = undefined;
    };
    return _ExportHelper;
}());
var _XfdfDocument = /** @class */ (function (_super) {
    __extends$2(_XfdfDocument, _super);
    function _XfdfDocument(fileName) {
        var _this = _super.call(this) || this;
        if (fileName !== null && typeof fileName !== 'undefined') {
            _this._fileName = fileName;
        }
        return _this;
    }
    // #region Export Annotations
    _XfdfDocument.prototype._exportAnnotations = function (document) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = true;
        return this._save();
    };
    _XfdfDocument.prototype._exportFormFields = function (document) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        this._key = _getNewGuidString();
        return this._save();
    };
    _XfdfDocument.prototype._save = function () {
        var writer = new _XmlWriter();
        writer._writeStartDocument();
        writer._writeStartElement('xfdf');
        writer._writeAttributeString(null, 'http://ns.adobe.com/xfdf/', 'xmlns', null);
        writer._writeAttributeString('space', 'preserve', 'xml', null);
        if (this._isAnnotationExport) {
            writer._writeStartElement('annots');
            if (this._document) {
                for (var i = 0; i < this._document.pageCount; i++) {
                    var page = this._document.getPage(i);
                    var annotations = page.annotations;
                    for (var j = 0; j < annotations.count; j++) {
                        var annotation = annotations.at(j);
                        if (annotation && (!this._annotationTypes ||
                            this._annotationTypes.length === 0 ||
                            (this._annotationTypes && this._annotationTypes.length > 0 && this._checkAnnotationType(annotation)))) {
                            this._exportAnnotationData(annotation, writer, i);
                        }
                    }
                }
            }
            writer._writeEndElement();
        }
        else {
            var form = this._document.form;
            if (form !== null && typeof form !== 'undefined') {
                this._exportEmptyFields = form.exportEmptyFields;
                var count = this._document.form.count;
                for (var i = 0; i < count; i++) {
                    var field = this._document.form.fieldAt(i);
                    if (field !== null && typeof field !== 'undefined' && field.export) {
                        this._exportFormFieldData(field);
                    }
                }
                this._writeFormFieldData(writer, this._asPerSpecification);
            }
        }
        if (!this._asPerSpecification) {
            writer._writeStartElement('f');
            writer._writeAttributeString('href', this._fileName);
        }
        var result = writer._save();
        writer._destroy();
        return result;
    };
    _XfdfDocument.prototype._writeFormFieldData = function (writer, isAcrobat) {
        var _this = this;
        if (isAcrobat === void 0) { isAcrobat = false; }
        if (isAcrobat) {
            writer._writeStartElement('f');
            writer._writeAttributeString('href', this._fileName);
            writer._writeEndElement();
            var elements = this._getElements(this._table); // eslint-disable-line
            if (elements && elements.size > 0) {
                writer._writeStartElement('fields');
                var flag_1 = false;
                elements.forEach(function (value, key) {
                    writer._writeStartElement('field');
                    writer._writeAttributeString('name', key.toString());
                    if (Array.isArray(value)) {
                        value.forEach(function (item) {
                            writer._writeStartElement('value');
                            writer._writeString(item.toString());
                            writer._writeEndElement();
                            flag_1 = true;
                        });
                    }
                    if (value instanceof Map) {
                        _this._writeFieldName(value, writer);
                    }
                    else if (!flag_1 && !value.toString().endsWith(_this._formKey) || (!flag_1 && _this._formKey === '')) {
                        writer._writeStartElement('value');
                        writer._writeString(value.toString());
                        writer._writeEndElement();
                    }
                    else if (_this._formKey !== '' && value.toString().endsWith(_this._formKey)) {
                        writer._writeStartElement('value-richtext');
                        var text = value.toString();
                        if (text.startsWith('<?xml version="1.0"?>')) {
                            text = text.substring(21);
                        }
                        var start = text.length - _this._formKey.length;
                        text = text.substring(0, start) + text.substring(start + _this._formKey.length);
                        writer._writeRaw(text);
                        writer._writeEndElement();
                    }
                    writer._writeEndElement();
                    flag_1 = false;
                });
                writer._writeEndElement();
            }
            writer._writeStartElement('ids');
            var hasId = false;
            if (this._crossReference._root.has('ID')) {
                var id = this._crossReference._root.getArray('ID');
                if (id && id.length >= 1) {
                    writer._writeAttributeString('original', id[0]);
                    writer._writeAttributeString('modified', id[1]);
                    hasId = true;
                }
            }
            if (!hasId) {
                writer._writeAttributeString('original', '');
                writer._writeAttributeString('modified', '');
            }
            writer._writeEndElement();
        }
        else {
            writer._writeStartElement('fields');
            this._table.forEach(function (value, key) {
                writer._writeStartElement('field');
                writer._writeAttributeString('name', key.toString());
                if (Array.isArray(value)) {
                    value.forEach(function (item) {
                        writer._writeStartElement('value');
                        writer._writeString(item.toString());
                        writer._writeEndElement();
                    });
                }
                else {
                    writer._writeStartElement('value');
                    writer._writeString(value.toString());
                    writer._writeEndElement();
                }
                writer._writeEndElement();
            });
            writer._writeEndElement();
        }
    };
    _XfdfDocument.prototype._writeFieldName = function (value, writer) {
        var _this = this;
        value.forEach(function (value, key) {
            if (value instanceof Map) {
                writer._writeStartElement('field');
                writer._writeAttributeString('name', key.toString());
                _this._writeFieldName(value, writer);
                writer._writeEndElement();
            }
            else {
                writer._writeStartElement('field');
                writer._writeAttributeString('name', key.toString());
                if (Array.isArray(value)) {
                    value.forEach(function (item) {
                        writer._writeStartElement('value');
                        writer._writeString(item.toString());
                        writer._writeEndElement();
                    });
                }
                else {
                    if (!value.toString().endsWith(_this._formKey) || _this._formKey === '') {
                        writer._writeStartElement('value');
                        writer._writeString(value.toString());
                    }
                    else {
                        writer._writeStartElement('value-richtext');
                        var text = value.toString();
                        if (text.startsWith('<?xml version="1.0"?>')) {
                            text = text.substring(21);
                        }
                        var start = text.length - _this._formKey.length;
                        text = text.substring(0, start) + text.substring(start + _this._formKey.length);
                        writer._writeRaw(text);
                    }
                    writer._writeEndElement();
                }
                writer._writeEndElement();
            }
        });
    };
    _XfdfDocument.prototype._getElements = function (table) {
        var _this = this;
        var elements = new Map(); // eslint-disable-line
        table.forEach(function (value, key) {
            var parentElements = elements; // eslint-disable-line
            if (key.toString().indexOf('.') !== -1) {
                var values = key.toString().split('.');
                for (var i = 0; i < values.length; i++) {
                    var element = values[Number.parseInt(i.toString(), 10)];
                    if (parentElements.has(element)) {
                        _this._getElements(parentElements[element]); // eslint-disable-line
                        parentElements = parentElements[element]; // eslint-disable-line
                    }
                    else {
                        if (i === values.length - 1) {
                            parentElements.set(element, value);
                        }
                        else {
                            var newTable = new Map(); // eslint-disable-line
                            parentElements.set(element, newTable);
                            parentElements = newTable;
                        }
                    }
                }
            }
            else {
                parentElements.set(key, value);
            }
        });
        return elements;
    };
    _XfdfDocument.prototype._checkAnnotationType = function (annotation) {
        return (typeof annotation._type !== 'undefined' && this._annotationTypes.indexOf(annotation._type) !== -1);
    };
    _XfdfDocument.prototype._exportAnnotationData = function (annotation, writer, pageIndex) {
        if (annotation._dictionary &&
            !(annotation instanceof PdfFileLinkAnnotation ||
                annotation instanceof PdfTextWebLinkAnnotation ||
                annotation instanceof PdfDocumentLinkAnnotation ||
                annotation instanceof PdfUriAnnotation)) {
            this._writeAnnotationData(writer, pageIndex, annotation);
        }
    };
    _XfdfDocument.prototype._writeAnnotationData = function (writer, pageIndex, source) {
        var hasAppearance = false;
        var annotation;
        var dictionary;
        if (source instanceof PdfAnnotation) {
            annotation = source;
            dictionary = source._dictionary;
        }
        else {
            dictionary = source;
        }
        var type = this._getAnnotationType(dictionary);
        this._skipBorderStyle = false;
        if (type && type !== '') {
            if (!this._annotationAttributes) {
                this._annotationAttributes = [];
            }
            writer._writeStartElement(type.toLowerCase());
            writer._writeAttributeString('page', pageIndex.toString());
            var lineAnnotation = void 0;
            var points = void 0;
            switch (type) {
                case 'Line':
                    lineAnnotation = annotation;
                    points = lineAnnotation.linePoints;
                    writer._writeAttributeString('start', points[0].toString() + ',' + points[1].toString());
                    writer._writeAttributeString('end', points[2].toString() + ',' + points[3].toString());
                    break;
                case 'Stamp':
                    hasAppearance = true;
                    break;
                case 'Square':
                    hasAppearance = true;
                    break;
            }
            if (dictionary && dictionary.has('BE') && dictionary.has('BS')) {
                var borderEffect = dictionary.get('BE');
                if (borderEffect && borderEffect.has('S')) {
                    this._skipBorderStyle = true;
                }
            }
            this._writeDictionary(dictionary, pageIndex, writer, hasAppearance);
            writer._writeEndElement();
            this._annotationAttributes = [];
        }
    };
    _XfdfDocument.prototype._writeDictionary = function (dictionary, pageIndex, writer, hasAppearance) {
        var _this = this;
        var isBorderStyle = false;
        if (dictionary.has('Type')) {
            var type = dictionary.get('Type');
            isBorderStyle = (type && type.name === 'Border' && this._skipBorderStyle);
        }
        dictionary.forEach(function (key, value) {
            if (!((!hasAppearance && key === 'AP') || key === 'P' || key === 'Parent')) {
                var entry = void 0; // eslint-disable-line
                if (value instanceof _PdfReference) {
                    entry = dictionary.get(key);
                }
                if (entry && entry instanceof _PdfDictionary) {
                    switch (key) {
                        case 'BS':
                            _this._writeDictionary(entry, pageIndex, writer, false);
                            break;
                        case 'BE':
                            _this._writeDictionary(entry, pageIndex, writer, false);
                            break;
                        case 'IRT':
                            if (entry.has('NM')) {
                                writer._writeAttributeString('inreplyto', _this._getValue(entry.get('NM')));
                            }
                            break;
                    }
                }
                else if (value instanceof _PdfDictionary) {
                    _this._writeDictionary(value, pageIndex, writer, false);
                }
                else if ((!isBorderStyle) || (isBorderStyle && key !== 'S')) {
                    _this._writeAttribute(writer, key, value);
                }
            }
        });
        if ((this.exportAppearance || hasAppearance) && dictionary.has('AP')) {
            var stream = this._getAppearanceString(dictionary.get('AP'));
            if (stream && stream.length > 0) {
                writer._writeStartElement('appearance');
                writer._writeRaw(_encode(stream));
                writer._writeEndElement();
            }
        }
        if (dictionary.has('Measure')) {
            this._exportMeasureDictionary(dictionary.get('Measure'), writer);
        }
        if (dictionary.has('Sound')) {
            var sound = dictionary.get('Sound');
            if (sound && sound.dictionary) {
                var soundDictionary = sound.dictionary;
                if (soundDictionary.has('B')) {
                    writer._writeAttributeString('bits', this._getValue(soundDictionary.get('B')));
                }
                if (soundDictionary.has('C')) {
                    writer._writeAttributeString('channels', this._getValue(soundDictionary.get('C')));
                }
                if (soundDictionary.has('E')) {
                    writer._writeAttributeString('encoding', this._getValue(soundDictionary.get('E')));
                }
                if (soundDictionary.has('R')) {
                    writer._writeAttributeString('rate', this._getValue(soundDictionary.get('R')));
                }
                if (soundDictionary.has('Length') && soundDictionary.get('Length') > 0) {
                    var data = _byteArrayToHexString(sound.getBytes());
                    if (data && data !== '') {
                        writer._writeStartElement('data');
                        writer._writeAttributeString('MODE', 'raw');
                        writer._writeAttributeString('encoding', 'hex');
                        if (soundDictionary.has('Length')) {
                            writer._writeAttributeString('length', this._getValue(soundDictionary.get('Length')));
                        }
                        if (soundDictionary.has('Filter')) {
                            writer._writeAttributeString('filter', this._getValue(soundDictionary.get('Filter')));
                        }
                        writer._writeRaw(data);
                        writer._writeEndElement();
                    }
                }
            }
        }
        else if (dictionary.has('FS')) {
            var fsDictionary = dictionary.get('FS');
            if (fsDictionary) {
                if (fsDictionary.has('F')) {
                    writer._writeAttributeString('file', this._getValue(fsDictionary.get('F')));
                }
                if (fsDictionary.has('EF')) {
                    var efDictionary = fsDictionary.get('EF');
                    if (efDictionary && efDictionary.has('F')) {
                        var fStream = efDictionary.get('F');
                        if (fStream && fStream.dictionary) {
                            var fDictionary = fStream.dictionary;
                            if (fDictionary.has('Params')) {
                                var paramsDictionary = fDictionary.get('Params');
                                if (paramsDictionary) {
                                    if (paramsDictionary.has('CreationDate')) {
                                        var value = this._getValue(paramsDictionary.get('CreationDate'));
                                        writer._writeAttributeString('creation', value);
                                    }
                                    if (paramsDictionary.has('ModificationDate')) {
                                        var value = this._getValue(paramsDictionary.get('ModificationDate'));
                                        writer._writeAttributeString('modification', value);
                                    }
                                    if (paramsDictionary.has('Size')) {
                                        writer._writeAttributeString('size', this._getValue(paramsDictionary.get('Size')));
                                    }
                                    if (paramsDictionary.has('CheckSum')) {
                                        var value = this._getValue(paramsDictionary.get('CheckSum'));
                                        var checksum = _stringToBytes(value);
                                        var hexString = _byteArrayToHexString(checksum);
                                        writer._writeAttributeString('checksum', hexString);
                                    }
                                }
                            }
                            var data = _byteArrayToHexString(fStream.getBytes());
                            if (data && data !== '') {
                                writer._writeStartElement('data');
                                writer._writeAttributeString('MODE', 'raw');
                                writer._writeAttributeString('encoding', 'hex');
                                if (fDictionary.has('Length')) {
                                    writer._writeAttributeString('length', this._getValue(fDictionary.get('Length')));
                                }
                                if (fDictionary.has('Filter')) {
                                    writer._writeAttributeString('filter', this._getValue(fDictionary.get('Filter')));
                                }
                                writer._writeRaw(data);
                                writer._writeEndElement();
                            }
                        }
                    }
                }
            }
        }
        if (dictionary.has('Vertices')) {
            writer._writeStartElement('vertices');
            var vertices = dictionary.getArray('Vertices');
            if (vertices && vertices.length > 0) {
                var elementCount = vertices.length;
                if (elementCount % 2 === 0) {
                    var value = '';
                    for (var i = 0; i < elementCount - 1; i++) {
                        value += this._getValue(vertices[Number.parseInt(i.toString(), 10)]) + (i % 2 !== 0 ? ';' : ',');
                    }
                    value += this._getValue(vertices[elementCount - 1]);
                    if (value && value !== '') {
                        writer._writeRaw(value);
                    }
                }
            }
            writer._writeEndElement();
        }
        if (dictionary.has('Popup')) {
            var popup = dictionary.get('Popup');
            if (popup) {
                this._writeAnnotationData(writer, pageIndex, popup);
            }
        }
        if (dictionary.has('DA')) {
            var defaultAppearance = dictionary.get('DA');
            if (defaultAppearance) {
                this._writeRawData(writer, 'defaultappearance', defaultAppearance);
            }
        }
        if (dictionary.has('DS')) {
            var defaultStyle = dictionary.get('DS');
            if (defaultStyle) {
                this._writeRawData(writer, 'defaultstyle', defaultStyle);
            }
        }
        if (dictionary.has('InkList')) {
            var inkList = dictionary.getArray('InkList');
            if (inkList && inkList.length > 0) {
                writer._writeStartElement('inklist');
                for (var j = 0; j < inkList.length; j++) {
                    writer._writeElementString('gesture', this._getValue(inkList[Number.parseInt(j.toString(), 10)]));
                }
                writer._writeEndElement();
            }
        }
        if (dictionary.has('RC')) {
            var value = dictionary.get('RC');
            if (value && value !== '') {
                var index = value.indexOf('<body');
                if (index > 0) {
                    value = value.substring(index);
                }
                this._writeRawData(writer, 'contents-richtext', value);
            }
        }
        if (dictionary.has('Contents')) {
            var value = dictionary.get('Contents');
            if (value && value.length > 0) {
                writer._writeStartElement('contents');
                writer._writeString(value);
                writer._writeEndElement();
            }
        }
    };
    _XfdfDocument.prototype._getAppearanceString = function (appearance) {
        var textWriter = new _XmlWriter(true);
        textWriter._writeStartElement('DICT');
        textWriter._writeAttributeString('KEY', 'AP');
        this._writeAppearanceDictionary(textWriter, appearance);
        textWriter._writeEndElement();
        var buffer = textWriter.buffer;
        textWriter._destroy();
        return buffer;
    };
    _XfdfDocument.prototype._writeAppearanceDictionary = function (writer, dictionary) {
        var _this = this;
        if (dictionary && dictionary.size > 0) {
            dictionary.forEach(function (key, value) {
                _this._writeObject(writer, value instanceof _PdfReference ? dictionary.get(key) : value, dictionary, key);
            });
        }
    };
    _XfdfDocument.prototype._writeObject = function (writer, primitive, dictionary, key, isNewReference) {
        if (primitive !== null && typeof primitive !== 'undefined') {
            if (primitive instanceof _PdfName) {
                this._writePrefix(writer, 'NAME', key);
                writer._writeAttributeString('VAL', primitive.name);
                writer._writeEndElement();
            }
            else if (Array.isArray(primitive)) {
                this._writePrefix(writer, 'ARRAY', key);
                if (dictionary.has(key)) {
                    this._writeArray(writer, dictionary.getArray(key), dictionary);
                }
                else {
                    this._writeArray(writer, primitive, dictionary);
                }
                writer._writeEndElement();
            }
            else if (typeof primitive === 'string') {
                this._writePrefix(writer, 'STRING', key);
                writer._writeAttributeString('VAL', primitive);
                writer._writeEndElement();
            }
            else if (typeof primitive === 'number') {
                if (Number.isInteger(primitive)) {
                    this._writePrefix(writer, 'INT', key);
                    writer._writeAttributeString('VAL', primitive.toString());
                }
                else {
                    this._writePrefix(writer, 'FIXED', key);
                    writer._writeAttributeString('VAL', primitive.toFixed(6));
                }
                writer._writeEndElement();
            }
            else if (typeof primitive === 'boolean') {
                this._writePrefix(writer, 'BOOL', key);
                writer._writeAttributeString('VAL', primitive ? 'true' : 'false');
                writer._writeEndElement();
            }
            else if (primitive instanceof _PdfDictionary) {
                this._writePrefix(writer, 'DICT', key);
                this._writeAppearanceDictionary(writer, primitive);
                writer._writeEndElement();
            }
            else if (primitive === null) {
                this._writePrefix(writer, 'NULL', key);
                writer._writeEndElement();
            }
            else if (primitive instanceof _PdfBaseStream && primitive.dictionary) {
                var streamDictionary = primitive.dictionary;
                this._writePrefix(writer, 'STREAM', key);
                writer._writeAttributeString('DEFINE', '');
                if ((streamDictionary.has('Subtype') &&
                    this._getValue(streamDictionary.get('Subtype')) === 'Image') ||
                    (!streamDictionary.has('Type') && !streamDictionary.has('Subtype'))) {
                    var data = void 0;
                    if (isNewReference) {
                        if (streamDictionary.has('Filter') && streamDictionary.get('Filter').name === 'DCTDecode') {
                            data = primitive.getString(true);
                        }
                        else {
                            data = _compressStream(primitive, true);
                        }
                    }
                    else {
                        data = primitive.getString(true);
                    }
                    if (!streamDictionary.has('Length') && data && data !== '') {
                        streamDictionary.update('Length', primitive.length);
                    }
                    this._writeAppearanceDictionary(writer, streamDictionary);
                    writer._writeStartElement('DATA');
                    writer._writeAttributeString('MODE', 'RAW');
                    writer._writeAttributeString('ENCODING', 'HEX');
                    if (data && data !== '') {
                        writer._writeRaw(data);
                    }
                }
                else {
                    var data = primitive.getString();
                    if (!streamDictionary.has('Length') && data && data !== '') {
                        streamDictionary.update('Length', primitive.length);
                    }
                    data = data.replace(/</g, '&lt;');
                    data = data.replace(/>/g, '&gt;');
                    this._writeAppearanceDictionary(writer, streamDictionary);
                    writer._writeStartElement('DATA');
                    writer._writeAttributeString('MODE', 'FILTERED');
                    writer._writeAttributeString('ENCODING', 'ASCII');
                    if (data && data !== '') {
                        writer._writeRaw(data);
                    }
                }
                writer._writeEndElement();
                writer._writeEndElement();
            }
            else if (primitive instanceof _PdfReference && this._crossReference) {
                this._writeObject(writer, this._crossReference._fetch(primitive), dictionary, key, primitive._isNew);
            }
        }
    };
    _XfdfDocument.prototype._writePrefix = function (writer, name, key) {
        writer._writeStartElement(name);
        if (key) {
            writer._writeAttributeString('KEY', key);
        }
    };
    _XfdfDocument.prototype._writeArray = function (writer, array, dictionary) {
        var _this = this;
        array.forEach(function (entry) {
            _this._writeObject(writer, entry, dictionary);
        });
    };
    _XfdfDocument.prototype._getFormatedString = function (value, isParsing) {
        if (isParsing === void 0) { isParsing = false; }
        if (isParsing) {
            value = value.replace('&amp;', '&');
            value = value.replace('&lt;', '<');
            value = value.replace('&gt;', '>');
        }
        else {
            value = value.replace('&', '&amp;');
            value = value.replace('<', '&lt;');
            value = value.replace('>', '&gt;');
        }
        return value;
    };
    _XfdfDocument.prototype._writeAttribute = function (writer, key, primitive) {
        var bytes;
        if (this._annotationAttributes && this._annotationAttributes.indexOf(key) === -1) {
            switch (key) {
                case 'C':
                    this._writeColor(writer, primitive, 'color', 'c');
                    break;
                case 'IC':
                    this._writeColor(writer, primitive, 'interior-color');
                    break;
                case 'M':
                    this._writeAttributeString(writer, 'date', primitive);
                    break;
                case 'NM':
                    this._writeAttributeString(writer, 'name', primitive);
                    break;
                case 'Name':
                    this._writeAttributeString(writer, 'icon', primitive);
                    break;
                case 'Subj':
                    this._writeAttributeString(writer, 'subject', primitive);
                    break;
                case 'T':
                    this._writeAttributeString(writer, 'title', primitive);
                    break;
                case 'Rotate':
                    this._writeAttributeString(writer, 'rotation', primitive);
                    break;
                case 'W':
                    this._writeAttributeString(writer, 'width', primitive);
                    break;
                case 'LE':
                    if (primitive && Array.isArray(primitive)) {
                        if (primitive.length === 2) {
                            writer._writeAttributeString('head', this._getValue(primitive[0]));
                            writer._writeAttributeString('tail', this._getValue(primitive[1]));
                        }
                    }
                    else if (primitive instanceof _PdfName) {
                        this._writeAttributeString(writer, 'head', primitive);
                    }
                    break;
                case 'S':
                    if (this._annotationAttributes.indexOf('style') === -1) {
                        switch (this._getValue(primitive)) {
                            case 'D':
                                writer._writeAttributeString('style', 'dash');
                                break;
                            case 'C':
                                writer._writeAttributeString('style', 'cloudy');
                                break;
                            case 'S':
                                writer._writeAttributeString('style', 'solid');
                                break;
                            case 'B':
                                writer._writeAttributeString('style', 'bevelled');
                                break;
                            case 'I':
                                writer._writeAttributeString('style', 'inset');
                                break;
                            case 'U':
                                writer._writeAttributeString('style', 'underline');
                                break;
                        }
                        this._annotationAttributes.push('style');
                    }
                    break;
                case 'D':
                    this._writeAttributeString(writer, 'dashes', primitive);
                    break;
                case 'I':
                    this._writeAttributeString(writer, 'intensity', primitive);
                    break;
                case 'RD':
                    this._writeAttributeString(writer, 'fringe', primitive);
                    break;
                case 'IT':
                    this._writeAttributeString(writer, 'IT', primitive);
                    break;
                case 'RT':
                    this._writeAttributeString(writer, 'replyType', primitive, true);
                    break;
                case 'LL':
                    this._writeAttributeString(writer, 'leaderLength', primitive);
                    break;
                case 'LLE':
                    this._writeAttributeString(writer, 'leaderExtend', primitive);
                    break;
                case 'Cap':
                    this._writeAttributeString(writer, 'caption', primitive);
                    break;
                case 'Q':
                    this._writeAttributeString(writer, 'justification', primitive);
                    break;
                case 'CP':
                    this._writeAttributeString(writer, 'caption-style', primitive);
                    break;
                case 'CL':
                    this._writeAttributeString(writer, 'callout', primitive);
                    break;
                case 'QuadPoints':
                    this._writeAttributeString(writer, 'coords', primitive);
                    break;
                case 'CA':
                    this._writeAttributeString(writer, 'opacity', primitive);
                    break;
                case 'F':
                    if (typeof primitive === 'number' && this._annotationAttributes.indexOf('flags') === -1) {
                        var flag = _annotationFlagsToString(primitive);
                        writer._writeAttributeString('flags', flag);
                        this._annotationAttributes.push('flags');
                    }
                    break;
                case 'InkList':
                case 'Type':
                case 'Subtype':
                case 'P':
                case 'Parent':
                case 'L':
                case 'Contents':
                case 'RC':
                case 'DA':
                case 'DS':
                case 'FS':
                case 'MeasurementTypes':
                case 'Vertices':
                case 'GroupNesting':
                case 'ITEx':
                    break;
                case 'TextMarkupContent':
                    bytes = _stringToBytes(primitive);
                    this._writeAttributeString(writer, key.toLowerCase(), _byteArrayToHexString(bytes));
                    break;
                default:
                    this._writeAttributeString(writer, key.toLowerCase(), primitive);
                    break;
            }
        }
    };
    _XfdfDocument.prototype._writeAttributeString = function (writer, attribute, primitive, isLowerCase) {
        if (isLowerCase === void 0) { isLowerCase = false; }
        if (this._annotationAttributes.indexOf(attribute) === -1) {
            var value = this._getValue(primitive);
            writer._writeAttributeString(attribute, isLowerCase ? value.toLowerCase() : value);
            this._annotationAttributes.push(attribute);
        }
    };
    _XfdfDocument.prototype._writeRawData = function (writer, name, value) {
        if (value && value !== '') {
            writer._writeStartElement(name);
            writer._writeRaw(value);
            writer._writeEndElement();
        }
    };
    _XfdfDocument.prototype._writeColor = function (writer, primitive, attribute, tag) {
        var color = this._getColor(primitive);
        if (typeof primitive === 'number' && tag) {
            var c = this._getValue(primitive);
            if (c && c !== '' && this._annotationAttributes.indexOf(tag) === -1) {
                writer._writeAttributeString(tag, c);
                this._annotationAttributes.push(tag);
            }
        }
        if (color && color !== '' && this._annotationAttributes.indexOf(attribute) === -1) {
            writer._writeAttributeString(attribute, color);
            this._annotationAttributes.push(attribute);
        }
    };
    _XfdfDocument.prototype._exportMeasureDictionary = function (dictionary, writer) {
        writer._writeStartElement('measure');
        if (dictionary) {
            if (dictionary.has('R')) {
                writer._writeAttributeString('rateValue', this._getValue(dictionary.get('R')));
            }
            if (dictionary.has('A')) {
                var array = dictionary.getArray('A');
                writer._writeStartElement('area');
                this._exportMeasureFormatDetails(array[0], writer);
                writer._writeEndElement();
            }
            if (dictionary.has('D')) {
                var array = dictionary.getArray('D');
                writer._writeStartElement('distance');
                this._exportMeasureFormatDetails(array[0], writer);
                writer._writeEndElement();
            }
            if (dictionary.has('X')) {
                var array = dictionary.getArray('X');
                writer._writeStartElement('xformat');
                this._exportMeasureFormatDetails(array[0], writer);
                writer._writeEndElement();
            }
        }
        writer._writeEndElement();
    };
    _XfdfDocument.prototype._exportMeasureFormatDetails = function (measurementDetails, writer) {
        if (measurementDetails.has('C')) {
            writer._writeAttributeString('c', this._getValue(measurementDetails.get('C')));
        }
        if (measurementDetails.has('F')) {
            writer._writeAttributeString('f', this._getValue(measurementDetails.get('F')));
        }
        if (measurementDetails.has('D')) {
            writer._writeAttributeString('d', this._getValue(measurementDetails.get('D')));
        }
        if (measurementDetails.has('RD')) {
            writer._writeAttributeString('rd', this._getValue(measurementDetails.get('RD')));
        }
        if (measurementDetails.has('U')) {
            writer._writeAttributeString('u', this._getValue(measurementDetails.get('U')));
        }
        if (measurementDetails.has('RT')) {
            writer._writeAttributeString('rt', this._getValue(measurementDetails.get('RT')));
        }
        if (measurementDetails.has('SS')) {
            writer._writeAttributeString('ss', this._getValue(measurementDetails.get('SS')));
        }
        if (measurementDetails.has('FD')) {
            writer._writeAttributeString('fd', this._getValue(measurementDetails.get('FD')));
        }
    };
    //#endregion Export Annotations
    //#region Import Annotations
    _XfdfDocument.prototype._importAnnotations = function (document, data) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        var xml = _bytesToString(data, true);
        this._xmlDocument = (new DOMParser()).parseFromString(xml, 'text/xml');
        this._isAnnotationImport = true;
        this._readXmlData(this._xmlDocument.documentElement);
    };
    _XfdfDocument.prototype._importFormData = function (document, data) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        this._xmlDocument = (new DOMParser()).parseFromString(_bytesToString(data, true), 'text/xml');
        this._readXmlData(this._xmlDocument.documentElement);
    };
    _XfdfDocument.prototype._readXmlData = function (root) {
        if (root && root.nodeType === 1) {
            this._checkXfdf(root);
            if (this._isAnnotationImport) {
                var xList = root.getElementsByTagName('annots');
                if (xList && xList.length > 0) {
                    for (var i = 0; i < xList.length; i++) {
                        var child = xList.item(i);
                        if (child && child.localName === 'annots' && child.hasChildNodes()) {
                            var childeNodes = child.childNodes;
                            for (var j = 0; j < childeNodes.length; j++) {
                                var childNode = childeNodes.item(j);
                                if (childNode && childNode.nodeType === 1) {
                                    var element = childNode;
                                    if (element && element.nodeType === 1) {
                                        this._parseAnnotationData(element);
                                    }
                                }
                            }
                        }
                    }
                }
                if (this._groupHolders.length > 0) {
                    for (var i = 0; i < this._groupHolders.length; i++) {
                        var dictionary = this._groupHolders[Number.parseInt(i.toString(), 10)];
                        var inReplyTo = dictionary.get('IRT');
                        if (inReplyTo && inReplyTo !== '') {
                            if (this._groupReferences.has(inReplyTo)) {
                                dictionary.update('IRT', this._groupReferences.get(inReplyTo));
                            }
                            else {
                                delete dictionary._map.IRT;
                            }
                        }
                    }
                }
                this._groupHolders = [];
                this._groupReferences = new Map();
            }
            else {
                this._parseFormData(root);
            }
        }
        this._dispose();
    };
    _XfdfDocument.prototype._checkXfdf = function (element) {
        if (element.nodeName !== 'xfdf') {
            throw new Error('Invalid XFDF file.');
        }
    };
    _XfdfDocument.prototype._parseFormData = function (root) {
        var list = root.getElementsByTagName('f');
        if (list && list.length > 0) {
            var fileNameElement = list.item(0);
            if (fileNameElement && fileNameElement.localName === 'f' && fileNameElement.hasAttribute('href')) {
                var fileName = fileNameElement.getAttribute('href');
                if (fileName && fileName !== '') {
                    this._fileName = fileName;
                }
            }
        }
        list = root.getElementsByTagName('ids');
        if (list && list.length > 0) {
            this._asPerSpecification = true;
        }
        var child = root.childNodes;
        if (child && child.length > 0) {
            for (var i = 0; i < child.length; i++) {
                var childNode = child.item(i);
                if (childNode && childNode.nodeType === 1) {
                    var element = childNode;
                    if (element && element.localName === 'fields' && element.hasChildNodes()) {
                        var fieldList = element.childNodes;
                        var elements = [];
                        for (var j = 0; j < fieldList.length; j++) {
                            var field = fieldList.item(j);
                            if (field && field.nodeType === 1) {
                                var filedElement = field;
                                if (filedElement && filedElement.localName === 'field') {
                                    elements.push(filedElement);
                                }
                            }
                        }
                        this._importFormNodes(elements);
                    }
                }
            }
        }
        this._importField();
    };
    _XfdfDocument.prototype._importFormNodes = function (list) {
        for (var i = 0; i < list.length; i++) {
            var child = list[Number.parseInt(i.toString(), 10)];
            var fieldName = '';
            if (child) {
                if (child.hasAttribute('name')) {
                    fieldName = child.getAttribute('name');
                }
                if (fieldName && fieldName !== '') {
                    var values = child.getElementsByTagName('value');
                    if (values && values.length > 0) {
                        var node = child;
                        var textName = '';
                        while (node.localName !== 'fields') {
                            if (textName.length > 0) {
                                textName = '.' + textName;
                            }
                            var skip = false;
                            if (node.hasAttribute('name')) {
                                var name_1 = node.getAttribute('name');
                                if (name_1 && name_1 !== '') {
                                    textName = name_1 + textName;
                                    skip = true;
                                }
                            }
                            if (!skip) {
                                textName += node.localName;
                            }
                            node = node.parentElement;
                        }
                        fieldName = textName;
                        var dataValues = void 0;
                        if (this._fields.has(fieldName)) {
                            dataValues = this._fields.get(fieldName);
                        }
                        else {
                            dataValues = [];
                        }
                        for (var j = 0; j < values.length; j++) {
                            dataValues.push(values.item(j).textContent);
                        }
                        this._fields.set(fieldName, dataValues);
                    }
                    else {
                        values = child.getElementsByTagName('value-richtext');
                        if (values && values.length > 0) {
                            var element = values.item(0);
                            if (element) {
                                var node = child;
                                var textName = '';
                                while (node.localName !== 'fields') {
                                    if (textName.length > 0) {
                                        textName = '.' + textName;
                                    }
                                    var skip = false;
                                    if (node.hasAttribute('name')) {
                                        var name_2 = node.getAttribute('name');
                                        if (name_2 && name_2 !== '') {
                                            textName = name_2 + textName;
                                            skip = true;
                                        }
                                    }
                                    if (!skip) {
                                        textName += node.localName;
                                    }
                                    node = node.parentElement;
                                }
                                fieldName = textName;
                                var richText = element.textContent;
                                if (element.childNodes && element.childNodes.length > 0) {
                                    var childNode = element.childNodes[0];
                                    if (childNode && childNode.hasChildNodes()) {
                                        richText = '';
                                        var childNodes = childNode.childNodes;
                                        for (var j = void 0; j < childNodes.length; j++) {
                                            richText += childNodes.item(j).textContent + '\r';
                                        }
                                        if (richText.length > 0) {
                                            richText = richText.substring(0, richText.length - 1);
                                        }
                                        else {
                                            richText = element.textContent;
                                        }
                                    }
                                }
                                var dataValues = void 0;
                                if (this._fields.has(fieldName)) {
                                    dataValues = this._fields.get(fieldName);
                                }
                                else {
                                    dataValues = [];
                                }
                                for (var j = 0; j < values.length; j++) {
                                    dataValues.push(richText);
                                }
                                this._fields.set(fieldName, dataValues);
                                if (!this._richTextValues.has(fieldName)) {
                                    this._richTextValues.set(fieldName, element.innerHTML);
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    _XfdfDocument.prototype._parseAnnotationData = function (element) {
        if (element) {
            var pageIndex = -1;
            if (element.hasAttributes && element.hasAttribute('page')) {
                pageIndex = Number.parseInt(element.getAttribute('page'), 10);
                if (pageIndex >= 0 && pageIndex < this._document.pageCount) {
                    var page = this._document.getPage(pageIndex);
                    var annotationDictionary = this._getAnnotationDictionary(page, element);
                    if (annotationDictionary && annotationDictionary.size > 0) {
                        var pageDictionary = page._pageDictionary;
                        if (pageDictionary) {
                            var annotations = page.annotations;
                            var annotation = annotations._parseAnnotation(annotationDictionary);
                            if (annotation) {
                                annotation._isImported = true;
                                var reference = this._crossReference._getNextReference();
                                this._crossReference._cacheMap.set(reference, annotationDictionary);
                                if (annotationDictionary.has('NM') || annotationDictionary.has('IRT')) {
                                    this._addReferenceToGroup(reference, annotationDictionary);
                                }
                                annotation._ref = reference;
                                var index = annotations._annotations.length;
                                annotations._annotations.push(reference);
                                if (annotations._comments && annotations._comments.length > 0) {
                                    annotations._comments = [];
                                }
                                pageDictionary.set('Annots', annotations._annotations);
                                pageDictionary._updated = true;
                                annotations._parsedAnnotations.set(index, annotation);
                                this._handlePopup(annotations, reference, annotationDictionary, pageDictionary);
                            }
                        }
                    }
                }
            }
        }
    };
    _XfdfDocument.prototype._getAnnotationDictionary = function (page, element) {
        var dictionary = new _PdfDictionary(this._crossReference);
        dictionary.update('Type', _PdfName.get('Annot'));
        var isValidType = true;
        switch (element.localName.toLowerCase()) {
            case 'line':
                dictionary.update('Subtype', _PdfName.get('Line'));
                if (element.hasAttribute('start') && element.hasAttribute('end')) {
                    var points_1 = [];
                    element.getAttribute('start').split(',').forEach(function (value) {
                        points_1.push(Number.parseFloat(value));
                    });
                    element.getAttribute('end').split(',').forEach(function (value) {
                        points_1.push(Number.parseFloat(value));
                    });
                    if (points_1.length === 4) {
                        dictionary.update('L', points_1);
                    }
                }
                this._addLineEndStyle(dictionary, element);
                break;
            case 'circle':
                dictionary.update('Subtype', _PdfName.get('Circle'));
                break;
            case 'square':
                dictionary.update('Subtype', _PdfName.get('Square'));
                break;
            case 'polyline':
                dictionary.update('Subtype', _PdfName.get('PolyLine'));
                this._addLineEndStyle(dictionary, element);
                break;
            case 'polygon':
                dictionary.update('Subtype', _PdfName.get('Polygon'));
                this._addLineEndStyle(dictionary, element);
                break;
            case 'ink':
                dictionary.update('Subtype', _PdfName.get('Ink'));
                break;
            case 'popup':
                dictionary.update('Subtype', _PdfName.get('Popup'));
                break;
            case 'text':
                dictionary.update('Subtype', _PdfName.get('Text'));
                break;
            case 'freetext':
                dictionary.update('Subtype', _PdfName.get('FreeText'));
                this._addLineEndStyle(dictionary, element);
                break;
            case 'stamp':
                dictionary.update('Subtype', _PdfName.get('Stamp'));
                break;
            case 'highlight':
                dictionary.update('Subtype', _PdfName.get('Highlight'));
                break;
            case 'squiggly':
                dictionary.update('Subtype', _PdfName.get('Squiggly'));
                break;
            case 'underline':
                dictionary.update('Subtype', _PdfName.get('Underline'));
                break;
            case 'strikeout':
                dictionary.update('Subtype', _PdfName.get('StrikeOut'));
                break;
            case 'fileattachment':
                dictionary.update('Subtype', _PdfName.get('FileAttachment'));
                break;
            case 'sound':
                dictionary.update('Subtype', _PdfName.get('Sound'));
                break;
            case 'caret':
                dictionary.update('Subtype', _PdfName.get('Caret'));
                break;
            case 'redact':
                dictionary.update('Subtype', _PdfName.get('Redact'));
                break;
            default:
                isValidType = false;
                break;
        }
        if (isValidType) {
            this._addAnnotationData(dictionary, element, page);
        }
        return dictionary;
    };
    _XfdfDocument.prototype._addAnnotationData = function (dictionary, element, page) {
        this._addBorderStyle(dictionary, element);
        this._applyAttributeValues(dictionary, element.attributes);
        this._parseInnerElements(dictionary, element, page);
        this._addMeasureDictionary(dictionary, element);
    };
    _XfdfDocument.prototype._addBorderStyle = function (dictionary, element) {
        var borderEffectDictionary = new _PdfDictionary(this._crossReference);
        var borderStyleDictionary = new _PdfDictionary(this._crossReference);
        if (element.hasAttribute('width')) {
            borderStyleDictionary.update('W', Number.parseFloat(element.getAttribute('width')));
        }
        var isBasicStyle = true;
        if (element.hasAttribute('style')) {
            var style = '';
            switch (element.getAttribute('style')) {
                case 'dash':
                    style = 'D';
                    break;
                case 'solid':
                    style = 'S';
                    break;
                case 'bevelled':
                    style = 'B';
                    break;
                case 'inset':
                    style = 'I';
                    break;
                case 'underline':
                    style = 'U';
                    break;
                case 'cloudy':
                    style = 'C';
                    isBasicStyle = false;
                    break;
            }
            if (style !== '') {
                (isBasicStyle ? borderStyleDictionary : borderEffectDictionary).update('S', _PdfName.get(style));
                if (!isBasicStyle && element.hasAttribute('intensity')) {
                    borderEffectDictionary.update('I', Number.parseFloat(element.getAttribute('intensity')));
                }
                else if (element.hasAttribute('dashes')) {
                    var dashes_1 = [];
                    element.getAttribute('dashes').split(',').forEach(function (value) {
                        dashes_1.push(Number.parseFloat(value));
                    });
                    borderStyleDictionary.update('D', dashes_1);
                }
            }
        }
        if (borderEffectDictionary.size > 0) {
            dictionary.update('BE', borderEffectDictionary);
        }
        if (borderStyleDictionary.size > 0) {
            borderStyleDictionary.update('Type', 'Border');
            dictionary.update('BS', borderStyleDictionary);
        }
    };
    _XfdfDocument.prototype._applyAttributeValues = function (dictionary, attributes) {
        for (var i = 0; i < attributes.length; i++) {
            var attribute = attributes[Number.parseInt(i.toString(), 10)];
            var value = attribute.value;
            var values = void 0;
            var leaderExtend = void 0;
            switch (attribute.name.toLowerCase()) {
                case 'page':
                case 'start':
                case 'end':
                case 'width':
                case 'head':
                case 'tail':
                case 'style':
                case 'intensity':
                case 'itex':
                    break;
                case 'state':
                    this._addString(dictionary, 'State', value);
                    break;
                case 'statemodel':
                    this._addString(dictionary, 'StateModel', value);
                    break;
                case 'replytype':
                    if (value === 'group') {
                        dictionary.update('RT', _PdfName.get('Group'));
                    }
                    break;
                case 'inreplyto':
                    this._addString(dictionary, 'IRT', value);
                    break;
                case 'rect':
                    values = this._obtainPoints(value);
                    if (values && values.length === 4) {
                        dictionary.update('Rect', values);
                    }
                    break;
                case 'color':
                    values = _convertToColor(value);
                    if (values && values.length === 3) {
                        dictionary.update('C', [values[0] / 255, values[1] / 255, values[2] / 255]);
                    }
                    break;
                case 'interior-color':
                    values = _convertToColor(value);
                    if (values && values.length === 3) {
                        dictionary.update('IC', [values[0] / 255, values[1] / 255, values[2] / 255]);
                    }
                    break;
                case 'date':
                    this._addString(dictionary, 'M', value);
                    break;
                case 'creationdate':
                    this._addString(dictionary, 'CreationDate', value);
                    break;
                case 'name':
                    this._addString(dictionary, 'NM', value);
                    break;
                case 'icon':
                    if (value && value !== '') {
                        dictionary.update('Name', _PdfName.get(value));
                    }
                    break;
                case 'subject':
                    this._addString(dictionary, 'Subj', this._getFormatedString(value, true));
                    break;
                case 'title':
                    this._addString(dictionary, 'T', this._getFormatedString(value, true));
                    break;
                case 'rotation':
                    this._addInt(dictionary, 'Rotate', value);
                    break;
                case 'justification':
                    this._addInt(dictionary, 'Q', value);
                    break;
                case 'fringe':
                    this._addFloatPoints(dictionary, this._obtainPoints(value), 'RD');
                    break;
                case 'it':
                    if (value && value !== '') {
                        dictionary.update('IT', _PdfName.get(value));
                    }
                    break;
                case 'leaderlength':
                    this._addFloat(dictionary, 'LL', value);
                    break;
                case 'leaderextend':
                    leaderExtend = Number.parseFloat(value);
                    if (typeof leaderExtend !== 'undefined') {
                        dictionary.update('LLE', leaderExtend);
                    }
                    break;
                case 'caption':
                    if (value && value !== '') {
                        dictionary.update('Cap', value.toLowerCase() === 'yes' ? true : false);
                    }
                    break;
                case 'caption-style':
                    if (value && value !== '') {
                        dictionary.update('CP', _PdfName.get(value));
                    }
                    break;
                case 'callout':
                    this._addFloatPoints(dictionary, this._obtainPoints(value), 'CL');
                    break;
                case 'coords':
                    this._addFloatPoints(dictionary, this._obtainPoints(value), 'QuadPoints');
                    break;
                case 'border':
                    this._addFloatPoints(dictionary, this._obtainPoints(value), 'Border');
                    break;
                case 'opacity':
                    this._addFloat(dictionary, 'CA', value);
                    break;
                case 'flags':
                    if (value && value !== '') {
                        var annotFlag = PdfAnnotationFlag.default;
                        var flags = value.split(',');
                        for (var i_1 = 0; i_1 < flags.length; i_1++) {
                            var flagType = _stringToAnnotationFlags(flags[Number.parseInt(i_1.toString(), 10)]);
                            if (i_1 === 0) {
                                annotFlag = flagType;
                            }
                            else {
                                annotFlag |= flagType;
                            }
                        }
                        dictionary.update('F', annotFlag);
                    }
                    break;
                case 'open':
                    if (value && value !== '') {
                        dictionary.update('Open', (value === 'true' || value === 'yes') ? true : false);
                    }
                    break;
                case 'calibrate':
                    this._addString(dictionary, 'Calibrate', value);
                    break;
                case 'customdata':
                    this._addString(dictionary, 'CustomData', value);
                    break;
                case 'overlaytext':
                    dictionary.update('OverlayText', value);
                    break;
                case 'repeat':
                    dictionary.update('Repeat', (value === 'true' || value === 'yes') ? true : false);
                    break;
                default:
                    if (this._document._allowImportCustomData) {
                        this._addString(dictionary, attribute.name, value);
                    }
                    break;
            }
        }
    };
    _XfdfDocument.prototype._obtainPoints = function (value) {
        var points = [];
        value.split(',').forEach(function (value) {
            points.push(Number.parseFloat(value));
        });
        return points;
    };
    _XfdfDocument.prototype._parseInnerElements = function (dictionary, element, page) {
        if (element.hasChildNodes) {
            var children = element.childNodes;
            var _loop_1 = function (index) {
                var child = children[Number.parseInt(index.toString(), 10)];
                if (child.nodeType === 1) {
                    var childElement = child;
                    var textContent = child.textContent;
                    var innerHTML = childElement.innerHTML;
                    switch (child.nodeName.toLowerCase()) {
                        case 'popup':
                            if (childElement && childElement.hasAttributes) {
                                var popupDictionary = this_1._getAnnotationDictionary(page, childElement);
                                if (popupDictionary.size > 0) {
                                    var reference = this_1._crossReference._getNextReference();
                                    this_1._crossReference._cacheMap.set(reference, popupDictionary);
                                    dictionary.update('Popup', reference);
                                    if (popupDictionary.has('NM')) {
                                        this_1._addReferenceToGroup(reference, popupDictionary);
                                    }
                                }
                            }
                            break;
                        case 'contents':
                            if (textContent && textContent !== '') {
                                dictionary.update('Contents', this_1._getFormatedString(textContent, true));
                            }
                            break;
                        case 'contents-richtext':
                            if (innerHTML && innerHTML !== '') {
                                dictionary.update('RC', this_1._richTextPrefix + innerHTML);
                            }
                            break;
                        case 'defaultstyle':
                            this_1._addString(dictionary, 'DS', textContent);
                            break;
                        case 'defaultappearance':
                            this_1._addString(dictionary, 'DA', textContent);
                            break;
                        case 'vertices':
                            if (textContent && textContent !== '') {
                                var vertices_1 = [];
                                textContent.split(',').forEach(function (value) {
                                    if (value.indexOf(';') !== -1) {
                                        value.split(';').forEach(function (innerValue) {
                                            vertices_1.push(innerValue);
                                        });
                                    }
                                    else {
                                        vertices_1.push(value);
                                    }
                                });
                                if (vertices_1.length > 0) {
                                    var verticesArray_1 = [];
                                    vertices_1.forEach(function (value) {
                                        verticesArray_1.push(Number.parseFloat(value));
                                    });
                                    dictionary.update('Vertices', verticesArray_1);
                                }
                            }
                            break;
                        case 'appearance':
                            this_1._addAppearanceData(child, dictionary);
                            break;
                        case 'inklist':
                            if (child.hasChildNodes) {
                                var inkListCollection = [];
                                var childNodes = child.childNodes;
                                var _loop_2 = function (i) {
                                    var inkChild = childNodes[Number.parseInt(i.toString(), 10)];
                                    if (inkChild && inkChild.nodeType === 1) {
                                        var inkChildElement = inkChild;
                                        if (inkChildElement.nodeName.toLowerCase() === 'gesture') {
                                            if (inkChildElement.textContent && inkChildElement.textContent !== '') {
                                                var points_2 = [];
                                                inkChildElement.textContent.split(',').forEach(function (value) {
                                                    if (value.indexOf(';') !== -1) {
                                                        value.split(';').forEach(function (innerValue) {
                                                            points_2.push(innerValue);
                                                        });
                                                    }
                                                    else {
                                                        points_2.push(value);
                                                    }
                                                });
                                                if (points_2.length > 0) {
                                                    var pointsArray_1 = [];
                                                    points_2.forEach(function (value) {
                                                        pointsArray_1.push(Number.parseFloat(value));
                                                    });
                                                    inkListCollection.push(pointsArray_1);
                                                }
                                            }
                                        }
                                    }
                                };
                                for (var i = 0; i < childNodes.length; i++) {
                                    _loop_2(i);
                                }
                                dictionary.update('InkList', inkListCollection);
                            }
                            break;
                        case 'data':
                            this_1._addStreamData(child, dictionary, element);
                            break;
                    }
                }
            };
            var this_1 = this;
            for (var index = 0; index < children.length; index++) {
                _loop_1(index);
            }
        }
    };
    _XfdfDocument.prototype._addStreamData = function (child, dictionary, parent) {
        if (child && child.textContent && child.textContent !== '') {
            var raw = _hexStringToByteArray(child.textContent, true);
            if (raw && raw.length > 0) {
                if (dictionary.has('Subtype')) {
                    var subtype = dictionary.get('Subtype');
                    if (subtype && subtype.name === 'FileAttachment') {
                        this._addFileAttachment(dictionary, parent, raw);
                    }
                    else if (subtype && subtype.name === 'Sound') {
                        this._addSound(dictionary, parent, raw);
                    }
                }
            }
        }
    };
    _XfdfDocument.prototype._addSound = function (dictionary, element, raw) {
        var soundStream = new _PdfContentStream(raw);
        soundStream.dictionary._crossReference = this._crossReference;
        soundStream.dictionary.update('Type', _PdfName.get('Sound'));
        if (element.hasAttribute('bits')) {
            this._addInt(soundStream.dictionary, 'B', element.getAttribute('bits'));
        }
        if (element.hasAttribute('rate')) {
            this._addInt(soundStream.dictionary, 'R', element.getAttribute('rate'));
        }
        if (element.hasAttribute('channels')) {
            this._addInt(soundStream.dictionary, 'C', element.getAttribute('channels'));
        }
        if (element.hasAttribute('encoding')) {
            var value = element.getAttribute('encoding');
            if (value && value !== '') {
                soundStream.dictionary.update('E', _PdfName.get(value));
            }
        }
        if (element.hasAttribute('filter')) {
            soundStream.dictionary.update('Filter', _PdfName.get('FlateDecode'));
        }
        var soundReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(soundReference, soundStream);
        dictionary.update('Sound', soundReference);
    };
    _XfdfDocument.prototype._addFileAttachment = function (dictionary, element, raw) {
        var fileDictionary = new _PdfDictionary(this._crossReference);
        fileDictionary.update('Type', _PdfName.get('Filespec'));
        if (element.hasAttribute('file')) {
            var value = element.getAttribute('file');
            this._addString(fileDictionary, 'F', value);
            this._addString(fileDictionary, 'UF', value);
        }
        var fileStream = new _PdfContentStream(raw);
        fileStream.dictionary._crossReference = this._crossReference;
        var param = new _PdfDictionary(this._crossReference);
        if (element.hasAttribute('size')) {
            var size = Number.parseInt(element.getAttribute('size'), 10);
            if (typeof size !== 'undefined') {
                param.update('Size', size);
                fileStream.dictionary.update('DL', size);
            }
        }
        if (element.hasAttribute('modification')) {
            this._addString(param, 'ModDate', element.getAttribute('modification'));
        }
        if (element.hasAttribute('creation')) {
            this._addString(param, 'CreationDate', element.getAttribute('creation'));
        }
        fileStream.dictionary.update('Params', param);
        if (element.hasAttribute('mimetype')) {
            this._addString(fileStream.dictionary, 'Subtype', element.getAttribute('mimetype'));
        }
        fileStream.dictionary.update('Filter', _PdfName.get('FlateDecode'));
        var embeddedFile = new _PdfDictionary(this._crossReference);
        var reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, fileStream);
        embeddedFile.update('F', reference);
        fileDictionary.update('EF', embeddedFile);
        var fileReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(fileReference, fileDictionary);
        dictionary.update('FS', fileReference);
    };
    _XfdfDocument.prototype._addAppearanceData = function (element, dictionary) {
        var innerText = element.textContent;
        if (innerText && innerText !== '') {
            var document_1 = (new DOMParser()).parseFromString(atob(innerText), 'text/xml');
            if (document_1 && document_1.hasChildNodes) {
                var childNodes = document_1.childNodes;
                if (childNodes && childNodes.length === 1) {
                    var rootNode = childNodes[0];
                    if (rootNode && rootNode.nodeType === 1) {
                        var rootElement = rootNode;
                        if (rootElement.nodeName.toUpperCase() === 'DICT' && rootElement.hasAttribute('KEY')) {
                            var key = rootElement.getAttribute('KEY');
                            if (key && key === 'AP' && rootElement.hasChildNodes) {
                                var appearance = new _PdfDictionary(this._crossReference);
                                childNodes = rootElement.childNodes;
                                for (var i = 0; i < childNodes.length; i++) {
                                    this._getAppearance(appearance, childNodes[Number.parseInt(i.toString(), 10)]);
                                }
                                if (appearance.size > 0) {
                                    dictionary.update('AP', appearance);
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    _XfdfDocument.prototype._getAppearance = function (source, child) {
        var appearance = source instanceof _PdfDictionary ? source : source.dictionary;
        if (child && child.nodeType === 1) {
            var element = child;
            if (element && element.localName) {
                var stream = void 0;
                var dictionary = void 0;
                var data = void 0;
                switch (element.localName) {
                    case 'STREAM':
                        stream = this._getStream(element);
                        if (stream) {
                            var reference = this._crossReference._getNextReference();
                            this._crossReference._cacheMap.set(reference, stream);
                            this._addKey(reference, appearance, element);
                        }
                        break;
                    case 'DICT':
                        dictionary = this._getDictionary(element);
                        if (dictionary) {
                            var reference = this._crossReference._getNextReference();
                            this._crossReference._cacheMap.set(reference, dictionary);
                            this._addKey(reference, appearance, element);
                        }
                        break;
                    case 'ARRAY':
                        this._addKey(this._getArray(element), appearance, element);
                        break;
                    case 'FIXED':
                        this._addKey(this._getFixed(element), appearance, element);
                        break;
                    case 'INT':
                        this._addKey(this._getInt(element), appearance, element);
                        break;
                    case 'STRING':
                        this._addKey(this._getString(element), appearance, element);
                        break;
                    case 'NAME':
                        this._addKey(this._getName(element), appearance, element);
                        break;
                    case 'BOOL':
                        this._addKey(this._getBoolean(element), appearance, element);
                        break;
                    case 'DATA':
                        data = this._getData(element);
                        if (data && data.length > 0 && source instanceof _PdfContentStream) {
                            source._bytes = data;
                            var isImage = false;
                            if (appearance && appearance.has('Subtype')) {
                                var type = appearance.get('Subtype');
                                isImage = type && type.name === 'Image';
                            }
                            if (isImage) {
                                source._isCompress = false;
                            }
                            else {
                                if (source.dictionary.has('Length')) {
                                    delete source.dictionary._map.Length;
                                }
                                if (source.dictionary.has('Filter')) {
                                    delete source.dictionary._map.Filter;
                                }
                            }
                        }
                        break;
                }
            }
        }
    };
    _XfdfDocument.prototype._getStream = function (element) {
        var stream = new _PdfContentStream([]);
        stream.dictionary._crossReference = this._crossReference;
        if (element.hasChildNodes) {
            var childNodes = element.childNodes;
            for (var i = 0; i < childNodes.length; i++) {
                var child = childNodes[Number.parseInt(i.toString(), 10)];
                if (child && child.nodeType === 1) {
                    this._getAppearance(stream, child);
                }
            }
        }
        return stream;
    };
    _XfdfDocument.prototype._getDictionary = function (element) {
        var dictionary = new _PdfDictionary(this._crossReference);
        if (element.hasChildNodes) {
            var childNodes = element.childNodes;
            for (var i = 0; i < childNodes.length; i++) {
                var child = childNodes[Number.parseInt(i.toString(), 10)];
                if (child && child.nodeType === 1) {
                    this._getAppearance(dictionary, child);
                }
            }
        }
        return dictionary;
    };
    _XfdfDocument.prototype._getArray = function (element) {
        var array = []; // eslint-disable-line
        if (element.hasChildNodes) {
            var childNodes = element.childNodes;
            for (var i = 0; i < childNodes.length; i++) {
                var child = childNodes[Number.parseInt(i.toString(), 10)];
                if (child && child.nodeType === 1) {
                    this._addArrayElements(array, child);
                }
            }
        }
        return array;
    };
    _XfdfDocument.prototype._getData = function (element) {
        var data = [];
        if (element && element.textContent &&
            element.textContent !== '' &&
            element.hasAttribute('MODE') && element.hasAttribute('ENCODING')) {
            var mode = element.getAttribute('MODE');
            var encoding = element.getAttribute('ENCODING');
            if (mode && encoding) {
                var innerText = this._getFormatedString(element.textContent, true);
                if (mode === 'FILTERED' && encoding === 'ASCII') {
                    data = _stringToBytes(innerText, true);
                }
                else if (mode === 'RAW' && encoding === 'HEX') {
                    data = _hexStringToByteArray(innerText, true);
                }
            }
        }
        return data;
    };
    _XfdfDocument.prototype._addArrayElements = function (array, child) {
        if (child && child.nodeType === 1) {
            var element = child;
            var stream = void 0;
            var dictionary = void 0;
            var value = void 0; // eslint-disable-line
            var floatValue = void 0;
            var intValue = void 0;
            var name_3;
            var bool = void 0;
            switch (element.localName) {
                case 'STREAM':
                    stream = this._getStream(element);
                    if (stream) {
                        var reference = this._crossReference._getNextReference();
                        stream.reference = reference;
                        this._crossReference._cacheMap.set(reference, stream);
                        array.push(reference);
                    }
                    break;
                case 'DICT':
                    dictionary = this._getDictionary(element);
                    if (dictionary) {
                        var reference = this._crossReference._getNextReference();
                        this._crossReference._cacheMap.set(reference, dictionary);
                        array.push(reference);
                    }
                    break;
                case 'ARRAY':
                    value = this._getArray(element);
                    if (value) {
                        array.push(value);
                    }
                    break;
                case 'FIXED':
                    floatValue = this._getFixed(element);
                    if (typeof floatValue !== 'undefined' && !isNaN(floatValue)) {
                        array.push(floatValue);
                    }
                    break;
                case 'INT':
                    intValue = this._getInt(element);
                    if (typeof intValue !== 'undefined' && !isNaN(intValue)) {
                        array.push(intValue);
                    }
                    break;
                case 'NAME':
                    name_3 = this._getName(element);
                    if (name_3) {
                        array.push(name_3);
                    }
                    break;
                case 'BOOL':
                    bool = this._getBoolean(element);
                    if (typeof bool !== 'undefined' && bool !== null) {
                        array.push(bool);
                    }
                    break;
            }
        }
    };
    _XfdfDocument.prototype._getFixed = function (element) {
        var value;
        if (element && element.hasAttribute('VAL')) {
            value = Number.parseFloat(element.getAttribute('VAL'));
        }
        return value;
    };
    _XfdfDocument.prototype._getInt = function (element) {
        var value;
        if (element && element.hasAttribute('VAL')) {
            value = Number.parseInt(element.getAttribute('VAL'), 10);
        }
        return value;
    };
    _XfdfDocument.prototype._getString = function (element) {
        var value;
        if (element && element.hasAttribute('VAL')) {
            value = element.getAttribute('VAL');
        }
        return value;
    };
    _XfdfDocument.prototype._getName = function (element) {
        var value;
        if (element && element.hasAttribute('VAL')) {
            value = _PdfName.get(element.getAttribute('VAL'));
        }
        return value;
    };
    _XfdfDocument.prototype._getBoolean = function (element) {
        var value;
        if (element && element.hasAttribute('VAL')) {
            value = element.getAttribute('VAL') === 'true' ? true : false;
        }
        return value;
    };
    _XfdfDocument.prototype._addMeasureDictionary = function (dictionary, element) {
        var measurement;
        var area;
        var distance;
        var xformat;
        if (element.hasChildNodes) {
            var childNodes = element.childNodes;
            for (var i = 0; i < childNodes.length; i++) {
                var childElement = childNodes[Number.parseInt(i.toString(), 10)];
                if (childElement && childElement.localName === 'measure') {
                    measurement = childElement;
                    break;
                }
            }
        }
        var measureDictionary = new _PdfDictionary(this._crossReference);
        var dDict = new _PdfDictionary(this._crossReference);
        var aDict = new _PdfDictionary(this._crossReference);
        var xDict = new _PdfDictionary(this._crossReference);
        var dArray = [];
        var aArray = [];
        var xArray = [];
        if (measurement) {
            measureDictionary.update('Type', _PdfName.get('Measure'));
            if (measurement.hasAttribute('rateValue')) {
                var attribute = measurement.getAttribute('rateValue');
                if (attribute && attribute !== '') {
                    measureDictionary.update('R', attribute);
                }
            }
            if (measurement.hasChildNodes) {
                var childNodes = measurement.childNodes;
                for (var i = 0; i < childNodes.length; i++) {
                    var child = childNodes[Number.parseInt(i.toString(), 10)];
                    if (child && child.nodeType === 1) {
                        var childElement = child;
                        switch (childElement.nodeName.toLowerCase()) {
                            case 'distance':
                                distance = childElement;
                                break;
                            case 'area':
                                area = childElement;
                                break;
                            case 'xformat':
                                xformat = childElement;
                                break;
                        }
                    }
                }
            }
        }
        if (xformat) {
            this._addElements(xformat, xDict);
            xArray.push(xDict);
        }
        if (distance) {
            this._addElements(distance, dDict);
            dArray.push(dDict);
        }
        if (area) {
            this._addElements(area, aDict);
            aArray.push(aDict);
        }
        measureDictionary.set('A', aArray);
        measureDictionary.set('D', dArray);
        measureDictionary.set('X', xArray);
        if (measureDictionary.size > 0 && measureDictionary.has('Type')) {
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, measureDictionary);
            dictionary.update('Measure', reference);
        }
    };
    _XfdfDocument.prototype._addElements = function (element, dictionary) {
        if (element.hasAttribute('d')) {
            this._addFloat(dictionary, 'D', element.getAttribute('d'));
        }
        if (element.hasAttribute('c')) {
            this._addFloat(dictionary, 'C', element.getAttribute('c'));
        }
        if (element.hasAttribute('rt')) {
            dictionary.update('RT', element.getAttribute('rt'));
        }
        if (element.hasAttribute('rd')) {
            dictionary.update('RD', element.getAttribute('rt'));
        }
        if (element.hasAttribute('ss')) {
            dictionary.update('SS', element.getAttribute('ss'));
        }
        if (element.hasAttribute('u')) {
            dictionary.update('U', element.getAttribute('u'));
        }
        if (element.hasAttribute('f')) {
            dictionary.update('F', _PdfName.get(element.getAttribute('f')));
        }
        if (element.hasAttribute('fd')) {
            dictionary.update('FD', element.getAttribute('fd') === 'yes' ? true : false);
        }
    };
    _XfdfDocument.prototype._addString = function (dictionary, key, value) {
        if (value && value !== '') {
            dictionary.update(key, value);
        }
    };
    _XfdfDocument.prototype._addInt = function (dictionary, key, value) {
        var intValue = Number.parseInt(value, 10);
        if (typeof intValue !== 'undefined') {
            dictionary.update(key, intValue);
        }
    };
    _XfdfDocument.prototype._addFloat = function (dictionary, key, value) {
        var floatValue = Number.parseFloat(value);
        if (typeof floatValue !== 'undefined') {
            dictionary.update(key, floatValue);
        }
    };
    _XfdfDocument.prototype._addFloatPoints = function (dictionary, points, key) {
        if (points && points.length > 0) {
            dictionary.update(key, points);
        }
    };
    _XfdfDocument.prototype._addKey = function (primitive, dictionary, element) {
        if (typeof primitive !== 'undefined' && primitive !== null && element.hasAttribute('KEY')) {
            dictionary.update(element.getAttribute('KEY'), primitive);
        }
    };
    _XfdfDocument.prototype._addLineEndStyle = function (dictionary, element) {
        var beginLineStyle = '';
        if (element.hasAttribute('head')) {
            beginLineStyle = element.getAttribute('head');
        }
        var endLineStyle = '';
        if (element.hasAttribute('tail')) {
            endLineStyle = element.getAttribute('tail');
        }
        if (beginLineStyle && beginLineStyle !== '') {
            if (endLineStyle && endLineStyle !== '') {
                var lineEndingStyles = [];
                lineEndingStyles.push(_PdfName.get(beginLineStyle));
                lineEndingStyles.push(_PdfName.get(endLineStyle));
                dictionary.update('LE', lineEndingStyles);
            }
            else {
                dictionary.update('LE', _PdfName.get(beginLineStyle));
            }
        }
        else if (endLineStyle && endLineStyle !== '') {
            dictionary.update('LE', _PdfName.get(endLineStyle));
        }
    };
    return _XfdfDocument;
}(_ExportHelper));
var _FontStructure = /** @class */ (function () {
    function _FontStructure(dictionary) {
        this._baseFontEncoding = '';
        this._dictionary = dictionary;
        this._fontType = this._dictionary.get('Subtype').name;
    }
    Object.defineProperty(_FontStructure.prototype, "differencesDictionary", {
        get: function () {
            if (!this._differencesDictionary) {
                this._differencesDictionary = this._getDifferencesDictionary();
            }
            return this._differencesDictionary;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_FontStructure.prototype, "baseFontEncoding", {
        get: function () {
            return this._baseFontEncoding;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_FontStructure.prototype, "fontEncoding", {
        get: function () {
            if (!this._fontEncoding) {
                this._fontEncoding = this._getFontEncoding();
            }
            return this._fontEncoding;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_FontStructure.prototype, "fontName", {
        get: function () {
            if (!this._fontName) {
                this._fontName = this._getFontName();
            }
            return this._fontName;
        },
        enumerable: true,
        configurable: true
    });
    _FontStructure.prototype._getFontEncoding = function () {
        var encoding = '';
        if (this._dictionary !== null && typeof this._dictionary !== 'undefined' && this._dictionary.has('Encoding')) {
            var baseFont = this._dictionary.get('Encoding'); // eslint-disable-line
            if (baseFont instanceof _PdfName) {
                encoding = baseFont.name;
            }
            else if (baseFont instanceof _PdfDictionary) {
                if (baseFont.has('BaseEncoding')) {
                    var baseFontEncoding = baseFont.get('BaseEncoding');
                    if (baseFontEncoding && baseFontEncoding instanceof _PdfName) {
                        this._baseFontEncoding = baseFontEncoding.name;
                    }
                }
                if (baseFont.has('Type')) {
                    var fontEncoding = baseFont.get('Type');
                    if (fontEncoding !== null && typeof fontEncoding !== 'undefined') {
                        encoding = fontEncoding.name;
                    }
                }
            }
        }
        if (encoding.toString() === 'identity#2dh' || encoding === 'CMap') {
            encoding = 'Identity-H';
        }
        return encoding;
    };
    _FontStructure.prototype._getDifferencesDictionary = function () {
        var result = new Map();
        if (this._dictionary !== null && typeof this._dictionary !== 'undefined' && this._dictionary.has('Encoding')) {
            var encoding = this._dictionary.get('Encoding');
            if (encoding !== null &&
                typeof encoding !== 'undefined' &&
                encoding instanceof _PdfDictionary &&
                encoding.has('Differences')) {
                var differences = encoding.getArray('Differences'); // eslint-disable-line
                var count = 0;
                if (differences !== null && typeof differences !== 'undefined') {
                    for (var i = 0; i < differences.length; i++) {
                        var text = '';
                        var item = differences[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                        if (typeof item === 'number') {
                            text = item.toString();
                            count = Number.parseInt(text, 10);
                        }
                        else if (item instanceof _PdfName) {
                            text = item.name;
                            if (this._fontType === 'Type1' && text === '.notdef') {
                                text = ' ';
                                result.set(count.toString(), _getLatinCharacter(text));
                            }
                            else {
                                text = _getLatinCharacter(text);
                                text = _getSpecialCharacter(text);
                                if (!result.has(count.toString())) {
                                    result.set(count.toString(), _getLatinCharacter(text));
                                }
                                count++;
                            }
                        }
                    }
                }
            }
        }
        return result;
    };
    _FontStructure.prototype._getFontName = function () {
        var fontName = '';
        if (this._dictionary !== null && typeof this._dictionary !== 'undefined' && this._dictionary.has('BaseFont')) {
            var baseFont = this._dictionary.get('BaseFont');
            var font = baseFont.name;
            if (font.indexOf('#20') !== -1 && font.indexOf('+') === -1) {
                var index = font.lastIndexOf('#20');
                font = font.substring(0, index);
                font += '+';
            }
            if (baseFont.name.indexOf('+') !== -1) {
                fontName = baseFont.name.split('+')[1];
            }
            else {
                fontName = baseFont.name;
            }
            if (fontName.indexOf('-') !== -1) {
                fontName = fontName.split('-')[0];
            }
            else if (fontName.indexOf(',') !== -1) {
                fontName = fontName.split(',')[0];
            }
            if (fontName.indexOf('MT') !== -1) {
                fontName = fontName.replace('MT', '');
            }
            if (fontName.indexOf('#20') !== -1) {
                fontName = fontName.replace('#20', ' ');
            }
            if (fontName.indexOf('#') !== -1) {
                fontName = this._decodeHexFontName(fontName);
            }
        }
        return fontName;
    };
    _FontStructure.prototype._decodeHexFontName = function (fontName) {
        var result = fontName;
        for (var i = 0; i < fontName.length; i++) {
            if (fontName[Number.parseInt(i.toString(), 10)] === '#') {
                var hexValue = fontName[i + 1] + fontName[i + 2];
                var value = Number.parseInt(hexValue, 16);
                if (value !== 0) {
                    result = result.replace("#" + hexValue, String.fromCharCode(value));
                    i += 2;
                }
                if (result.indexOf('#') === -1) {
                    break;
                }
            }
        }
        return result;
    };
    return _FontStructure;
}());

var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _JsonDocument = /** @class */ (function (_super) {
    __extends$3(_JsonDocument, _super);
    function _JsonDocument(fileName) {
        var _this = _super.call(this) || this;
        _this._isImport = false;
        _this._isColorSpace = false;
        _this._isDuplicate = false;
        _this._isGroupingSupport = false;
        if (fileName !== null && typeof fileName !== 'undefined') {
            _this._fileName = fileName;
        }
        return _this;
    }
    // #region Export Annotations
    _JsonDocument.prototype._exportAnnotations = function (document) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = true;
        this._exportAnnotationData(document, document.pageCount);
        return this._save();
    };
    _JsonDocument.prototype._exportFormFields = function (document) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        var form = this._document.form;
        if (form !== null && typeof form !== 'undefined') {
            this._exportEmptyFields = form.exportEmptyFields;
            var count = this._document.form.count;
            for (var i = 0; i < count; i++) {
                var field = this._document.form.fieldAt(i);
                this._exportFormFieldsData(field);
            }
            this._writeFormFieldData();
        }
        return this._save();
    };
    _JsonDocument.prototype._save = function () {
        var result = new Uint8Array(this._jsonData);
        this._jsonData = [];
        return result;
    };
    _JsonDocument.prototype._writeFormFieldData = function () {
        var _this = this;
        this._jsonData.push(this._openingBrace);
        var index = 0;
        this._table.forEach(function (value, key) {
            key = _this._getValidString(key);
            _this._jsonData.push(_this._doubleQuotes);
            _this._jsonData = _stringToBytes(key, true, false, _this._jsonData);
            if (typeof value === 'string' || (Array.isArray(value) && value.length === 1)) {
                value = _this._getValidString(typeof value === 'string' ? value : value[0]);
                _this._jsonData.push(_this._doubleQuotes, _this._colon, _this._doubleQuotes);
                _this._jsonData = _stringToBytes(value, true, false, _this._jsonData);
                _this._jsonData.push(_this._doubleQuotes);
            }
            else {
                _this._jsonData.push(_this._doubleQuotes, _this._colon, _this._openingBracket);
                for (var j = 0; j < value.length; j++) {
                    _this._jsonData.push(_this._doubleQuotes);
                    var entry = value[Number.parseInt(j.toString(), 10)];
                    for (var k = 0; k < entry.length; k++) {
                        _this._jsonData.push(entry.charCodeAt(k));
                    }
                    _this._jsonData.push(_this._doubleQuotes);
                    if (j < value.length - 1) {
                        _this._jsonData.push(_this._comma);
                    }
                }
                _this._jsonData.push(_this._closingBracket);
            }
            if (index < _this._table.size - 1) {
                _this._jsonData.push(_this._comma);
            }
            index++;
        });
        this._jsonData.push(this._closingBrace);
    };
    _JsonDocument.prototype._exportAnnotationData = function (document, pageCount) {
        var _this = this;
        var isAnnotationAdded = false;
        this._jsonData.push(this._openingBrace, this._doubleQuotes, 112, 100, 102, 65, 110, 110, 111, 116, 97, 116, 105, 111, 110, this._doubleQuotes, this._colon, this._openingBrace);
        for (var i = 0; i < pageCount; i++) {
            var page = document.getPage(i);
            if (page && page.annotations.count > 0) {
                this._jsonData.push(i !== 0 && isAnnotationAdded ? this._comma : this._space, this._doubleQuotes);
                var pageNumber = _stringToBytes(i.toString(), true, false, []);
                pageNumber.forEach(function (entry) {
                    _this._jsonData.push(entry);
                });
                this._jsonData.push(this._doubleQuotes, this._colon, this._openingBrace, this._doubleQuotes, 115, 104, 97, 112, 101, 65, 110, 110, 111, 116, 97, 116, 105, 111, 110, this._doubleQuotes, this._colon, this._openingBracket);
                isAnnotationAdded = true;
            }
            var count = 0;
            for (var k = 0; k < page.annotations.count; k++) {
                var annotation = page.annotations.at(k);
                if (annotation) {
                    if (count !== 0) {
                        this._jsonData.push(this._comma);
                    }
                    count++;
                    this._exportAnnotation(annotation, i);
                    this._jsonData = _stringToBytes(this._convertToJson(this._table), true, false, this._jsonData);
                    this._table.clear();
                }
            }
            if (page && page.annotations.count > 0) {
                this._jsonData.push(this._closingBracket, this._closingBrace);
            }
        }
        this._jsonData.push(this._closingBrace, this._closingBrace);
    };
    _JsonDocument.prototype._exportAnnotation = function (annotation, index) {
        var hasAppearance = false;
        var dictionary = annotation._dictionary;
        var type = this._getAnnotationType(annotation._dictionary);
        this._skipBorderStyle = false;
        if (type && type !== '') {
            this._table.set('type', type);
            this._table.set('page', index.toString());
            var lineAnnotation = void 0;
            var points = void 0;
            switch (type) {
                case 'Line':
                    lineAnnotation = annotation;
                    points = lineAnnotation.linePoints;
                    this._table.set('start', points[0].toString() + ',' + points[1].toString());
                    this._table.set('end', points[2].toString() + ',' + points[3].toString());
                    break;
                case 'Stamp':
                    hasAppearance = true;
                    break;
                case 'Square':
                    hasAppearance = true;
                    break;
            }
            if (dictionary && dictionary.has('BE') && dictionary.has('BS')) {
                var borderEffect = dictionary.get('BE');
                if (borderEffect && borderEffect.has('S')) {
                    this._skipBorderStyle = true;
                }
            }
            this._writeDictionary(dictionary, index, hasAppearance);
        }
    };
    _JsonDocument.prototype._writeDictionary = function (dictionary, pageIndex, hasAppearance) {
        var _this = this;
        var isBorderStyle = false;
        if (dictionary && dictionary.has('Type')) {
            var type = dictionary.get('Type');
            isBorderStyle = (type && type.name === 'Border' && this._skipBorderStyle);
        }
        dictionary.forEach(function (key, value) {
            if (!((!hasAppearance && key === 'AP') || key === 'P' || key === 'Parent')) {
                var entry = void 0; // eslint-disable-line
                if (value instanceof _PdfReference) {
                    entry = dictionary.get(key);
                }
                if (entry && entry instanceof _PdfDictionary) {
                    switch (key) {
                        case 'BS':
                        case 'BE':
                            _this._writeDictionary(entry, pageIndex, false);
                            break;
                        case 'IRT':
                            if (entry.has('NM')) {
                                _this._table.set('inreplyto', _this._getValue(entry.get('NM'), true));
                            }
                            break;
                    }
                }
                else if (value instanceof _PdfDictionary) {
                    _this._writeDictionary(value, pageIndex, false);
                }
                else if ((!isBorderStyle) || (isBorderStyle && key !== 'S')) {
                    _this._writeAttribute(key, value, dictionary);
                }
            }
        });
        if (dictionary.has('Measure')) {
            this._exportMeasureDictionary(dictionary.get('Measure'));
        }
        if ((this.exportAppearance || hasAppearance) && dictionary.has('AP')) {
            var stream = this._getAppearanceString(dictionary.get('AP'));
            if (stream && stream.length > 0) {
                this._table.set('appearance', _encode(stream));
            }
        }
        if (dictionary.has('Sound')) {
            var sound = dictionary.get('Sound');
            if (sound && sound.dictionary) {
                var soundDictionary = sound.dictionary;
                if (soundDictionary.has('B')) {
                    this._table.set('bits', this._getValue(soundDictionary.get('B'), true));
                }
                if (soundDictionary.has('C')) {
                    this._table.set('channels', this._getValue(soundDictionary.get('C'), true));
                }
                if (soundDictionary.has('E')) {
                    this._table.set('encoding', this._getValue(soundDictionary.get('E'), true));
                }
                if (soundDictionary.has('R')) {
                    this._table.set('rate', this._getValue(soundDictionary.get('R'), true));
                }
                if (soundDictionary.has('Length') && soundDictionary.get('Length') > 0) {
                    var data = _byteArrayToHexString(sound.getBytes());
                    if (data && data !== '') {
                        this._table.set('MODE', 'raw');
                        this._table.set('encoding', 'hex');
                        if (soundDictionary.has('Length')) {
                            this._table.set('length', this._getValue(soundDictionary.get('Length'), true));
                        }
                        if (soundDictionary.has('Filter')) {
                            this._table.set('filter', this._getValue(soundDictionary.get('Filter'), true));
                        }
                        this._table.set('data', data);
                    }
                }
            }
        }
        else if (dictionary.has('FS')) {
            var fsDictionary = dictionary.get('FS');
            if (fsDictionary) {
                if (fsDictionary.has('F')) {
                    this._table.set('file', this._getValue(fsDictionary.get('F'), true));
                }
                if (fsDictionary.has('EF')) {
                    var efDictionary = fsDictionary.get('EF');
                    if (efDictionary && efDictionary.has('F')) {
                        var fStream = efDictionary.get('F');
                        if (fStream && fStream.dictionary) {
                            var fDictionary = fStream.dictionary;
                            if (fDictionary.has('Params')) {
                                var paramsDictionary = fDictionary.get('Params');
                                if (paramsDictionary) {
                                    if (paramsDictionary.has('CreationDate')) {
                                        var value = this._getValue(paramsDictionary.get('CreationDate'), true);
                                        this._table.set('creation', value);
                                    }
                                    if (paramsDictionary.has('ModificationDate')) {
                                        var value = this._getValue(paramsDictionary.get('ModificationDate'), true);
                                        this._table.set('modification', value);
                                    }
                                    if (paramsDictionary.has('Size')) {
                                        this._table.set('size', this._getValue(paramsDictionary.get('Size'), true));
                                    }
                                    if (paramsDictionary.has('CheckSum')) {
                                        var value = this._getValue(paramsDictionary.get('CheckSum'), true);
                                        var checksum = _stringToBytes(value);
                                        var hexString = _byteArrayToHexString(checksum);
                                        this._table.set('checksum', hexString);
                                    }
                                }
                            }
                            var data = _byteArrayToHexString(fStream.getBytes());
                            if (data && data !== '') {
                                this._table.set('MODE', 'raw');
                                this._table.set('encoding', 'hex');
                                if (fDictionary.has('Length')) {
                                    this._table.set('length', this._getValue(fDictionary.get('Length'), true));
                                }
                                if (fDictionary.has('Filter')) {
                                    this._table.set('filter', this._getValue(fDictionary.get('Filter'), true));
                                }
                                this._table.set('data', data);
                            }
                        }
                    }
                }
            }
        }
    };
    _JsonDocument.prototype._writeColor = function (primitive, attribute, tag) {
        var color = this._getColor(primitive);
        if (typeof primitive === 'number' && tag) {
            var c = this._getValue(primitive, true);
            if (c && c !== '') {
                this._table.set(tag, c);
            }
        }
        if (color && color !== '') {
            this._table.set(attribute, color);
        }
    };
    _JsonDocument.prototype._writeAttributeString = function (attribute, primitive, isLowerCase) {
        if (isLowerCase === void 0) { isLowerCase = false; }
        var value = this._getValue(primitive, true);
        this._table.set(attribute, isLowerCase ? value.toLowerCase() : value);
    };
    _JsonDocument.prototype._writeAttribute = function (key, primitive, dictionary) {
        var value;
        var rcValue;
        var bytes;
        switch (key) {
            case 'C':
                this._writeColor(primitive, 'color', 'c');
                break;
            case 'IC':
                this._writeColor(primitive, 'interior-color');
                break;
            case 'DA':
                value = dictionary.get('DA');
                if (value) {
                    this._table.set('defaultappearance', value);
                }
                break;
            case 'M':
                this._writeAttributeString('date', primitive);
                break;
            case 'NM':
                this._table.set('name', primitive);
                break;
            case 'Name':
                this._writeAttributeString('icon', primitive);
                break;
            case 'Subj':
                this._writeAttributeString('subject', primitive);
                break;
            case 'T':
                this._writeAttributeString('title', primitive);
                break;
            case 'Rect':
                value = this._getValue(primitive, true);
                if (value) {
                    var rectArray = value.split(',');
                    var subTable = new Map();
                    subTable.set('x', rectArray[0]);
                    subTable.set('y', rectArray[1]);
                    subTable.set('width', rectArray[2]);
                    subTable.set('height', rectArray[3]);
                    this._table.set(key.toLowerCase(), this._convertToJson(subTable));
                }
                break;
            case 'CreationDate':
                this._writeAttributeString('creationdate', primitive);
                break;
            case 'Rotate':
                this._writeAttributeString('rotation', primitive);
                break;
            case 'W':
                this._writeAttributeString('width', primitive);
                break;
            case 'LE':
                if (primitive && Array.isArray(primitive)) {
                    if (primitive.length === 2) {
                        this._table.set('head', this._getValue(primitive[0], true));
                        this._table.set('tail', this._getValue(primitive[1], true));
                    }
                }
                else if (primitive instanceof _PdfName) {
                    this._writeAttributeString('head', primitive);
                }
                break;
            case 'S':
                switch (this._getValue(primitive, true)) {
                    case 'D':
                        this._table.set('style', 'dash');
                        break;
                    case 'C':
                        this._table.set('style', 'cloudy');
                        break;
                    case 'S':
                        this._table.set('style', 'solid');
                        break;
                    case 'B':
                        this._table.set('style', 'bevelled');
                        break;
                    case 'I':
                        this._table.set('style', 'inset');
                        break;
                    case 'U':
                        this._table.set('style', 'underline');
                        break;
                }
                break;
            case 'D':
                this._writeAttributeString('dashes', primitive);
                break;
            case 'I':
                this._writeAttributeString('intensity', primitive);
                break;
            case 'RD':
                this._writeAttributeString('fringe', primitive);
                break;
            case 'IT':
                this._writeAttributeString('IT', primitive);
                break;
            case 'RT':
                this._writeAttributeString('replyType', primitive, true);
                break;
            case 'LL':
                this._writeAttributeString('leaderLength', primitive);
                break;
            case 'LLE':
                this._writeAttributeString('leaderExtend', primitive);
                break;
            case 'Cap':
                this._writeAttributeString('caption', primitive);
                break;
            case 'CP':
                this._writeAttributeString('caption-style', primitive);
                break;
            case 'CL':
                this._writeAttributeString('callout', primitive);
                break;
            case 'QuadPoints':
                this._writeAttributeString('coords', primitive);
                break;
            case 'CA':
                this._writeAttributeString('opacity', primitive);
                break;
            case 'F':
                if (typeof primitive === 'number') {
                    var flag = _annotationFlagsToString(primitive);
                    this._table.set('flags', flag);
                }
                break;
            case 'Contents':
                value = dictionary.get('Contents');
                if (value && value.length > 0) {
                    this._table.set('contents', this._getValidString(value));
                }
                break;
            case 'InkList':
                this._writeInkList(dictionary);
                break;
            case 'Vertices':
                this._writeVertices(dictionary);
                break;
            case 'DS':
                value = dictionary.get('DS');
                if (_isNullOrUndefined(value)) {
                    var styleTable = new Map();
                    var textStyle = value.split(';');
                    for (var i = 0; i < textStyle.length; i++) {
                        var text = textStyle[Number.parseInt(i.toString(), 10)].split(':');
                        if (text && text.length > 0 && text[0] && text[0].length > 1 && text[0].startsWith(' ')) {
                            text[0] = text[0].substring(1);
                        }
                        styleTable.set(text[0], text[1]);
                    }
                    this._table.set('defaultStyle', this._convertToJson(styleTable));
                }
                break;
            case 'AllowedInteractions':
                if (primitive) {
                    var bytes_1 = _stringToBytes(primitive);
                    var styleTable = new Map();
                    styleTable.set('unicodeData', _byteArrayToHexString(bytes_1));
                    this._table.set(key, this._convertToJson(styleTable));
                }
                break;
            case 'RC':
                rcValue = dictionary.get('RC');
                if (typeof rcValue === 'string' && rcValue.includes('<body')) {
                    var index = rcValue.indexOf('<body');
                    if (index > 0) {
                        rcValue = rcValue.substring(index);
                    }
                    this._writeAttributeString('contents-richtext', rcValue);
                }
                break;
            case 'Type':
            case 'Subtype':
            case 'P':
            case 'Parent':
            case 'L':
            case 'FS':
            case 'MeasurementTypes':
            case 'GroupNesting':
            case 'ITEx':
                break;
            case 'TextMarkupContent':
                bytes = _stringToBytes(primitive);
                this._writeAttributeString(key, _byteArrayToHexString(bytes));
                break;
            case 'Border':
            case 'A':
            case 'R':
            case 'X':
            case 'ca':
                this._writeAttributeString(key.toLowerCase(), primitive);
                break;
            default:
                if (typeof primitive === 'string' && primitive.startsWith('{') && primitive.endsWith('}')) {
                    this._table.set(key, primitive);
                }
                else {
                    this._writeAttributeString(key, primitive);
                }
                break;
        }
    };
    _JsonDocument.prototype._writeVertices = function (dictionary) {
        var vertices = dictionary.getArray('Vertices');
        if (_isNullOrUndefined(vertices) && vertices.length > 0) {
            var elementCount = vertices.length;
            if (elementCount % 2 === 0) {
                var vertice = '';
                for (var i = 0; i < elementCount - 1; i++) {
                    vertice += this._getValue(vertices[Number.parseInt(i.toString(), 10)], true) + (i % 2 !== 0 ? ';' : ',');
                }
                vertice += this._getValue(vertices[elementCount - 1], true);
                if (vertice && vertice !== '') {
                    this._table.set('vertices', vertice);
                }
            }
        }
    };
    _JsonDocument.prototype._writeInkList = function (dictionary) {
        var inkList = dictionary.getArray('InkList');
        if (inkList && inkList.length > 0) {
            var points = new Map();
            var json = '[';
            for (var j = 0; j < inkList.length; j++) {
                json += '[' + this._getValue(inkList[Number.parseInt(j.toString(), 10)], true) + ']';
                if (j < inkList.length - 1) {
                    json += ',';
                }
            }
            json += ']';
            points.set('gesture', json);
            this._table.set('inklist', this._convertToJson(points));
        }
    };
    _JsonDocument.prototype._exportMeasureDictionary = function (dictionary) {
        if (dictionary) {
            if (dictionary.has('Type')) {
                this._table.set('type1', 'Measure');
            }
            if (dictionary.has('R')) {
                this._table.set('ratevalue', this._getValue(dictionary.get('R'), true));
            }
            if (dictionary.has('SubType')) {
                this._table.set('SubType', this._getValue(dictionary.get('SubType'), true));
            }
            if (dictionary.has('TargetUnitConversion')) {
                this._table.set('TargetUnitConversion', this._getValue(dictionary.get('TargetUnitConversion'), true));
            }
            if (dictionary.has('A')) {
                var array = dictionary.getArray('A');
                if (array && array.length > 0 && array[0]) {
                    this._exportMeasureFormatDetails('area', array[0]);
                }
            }
            if (dictionary.has('D')) {
                var array = dictionary.getArray('D');
                if (array && array.length > 0 && array[0]) {
                    this._exportMeasureFormatDetails('distance', array[0]);
                }
            }
            if (dictionary.has('X')) {
                var array = dictionary.getArray('X');
                if (array && array.length > 0 && array[0]) {
                    this._exportMeasureFormatDetails('xformat', array[0]);
                }
            }
            if (dictionary.has('T')) {
                var array = dictionary.getArray('T');
                if (array && array.length > 0 && array[0]) {
                    this._exportMeasureFormatDetails('tformat', array[0]);
                }
            }
            if (dictionary.has('V')) {
                var array = dictionary.getArray('V');
                if (array && array.length > 0 && array[0]) {
                    this._exportMeasureFormatDetails('vformat', array[0]);
                }
            }
        }
    };
    _JsonDocument.prototype._exportMeasureFormatDetails = function (key, measurementDetails) {
        var details = new Map();
        if (measurementDetails) {
            if (measurementDetails.has('C')) {
                details.set('c', this._getValue(measurementDetails.get('C'), true));
            }
            if (measurementDetails.has('F')) {
                details.set('f', this._getValue(measurementDetails.get('F'), true));
            }
            if (measurementDetails.has('D')) {
                details.set('d', this._getValue(measurementDetails.get('D'), true));
            }
            if (measurementDetails.has('RD')) {
                details.set('rd', this._getValue(measurementDetails.get('RD'), true));
            }
            if (measurementDetails.has('U')) {
                details.set('u', this._getValue(measurementDetails.get('U'), true));
            }
            if (measurementDetails.has('RT')) {
                details.set('rt', this._getValue(measurementDetails.get('RT'), true));
            }
            if (measurementDetails.has('SS')) {
                details.set('ss', this._getValue(measurementDetails.get('SS'), true));
            }
            if (measurementDetails.has('FD')) {
                details.set('fd', this._getValue(measurementDetails.get('FD'), true));
            }
        }
        this._table.set(key, this._convertToJson(details));
    };
    _JsonDocument.prototype._getAppearanceString = function (appearance) {
        var parentTable = new Map();
        var appearanceTable = new Map();
        this._writeAppearanceDictionary(appearanceTable, appearance);
        parentTable.set('ap', this._convertToJson(appearanceTable));
        return _stringToBytes(this._convertToJson(parentTable));
    };
    _JsonDocument.prototype._writeAppearanceDictionary = function (table, dictionary) {
        var _this = this;
        if (dictionary && dictionary.size > 0) {
            dictionary.forEach(function (key, value) {
                if (key === 'OC' && value instanceof Array || (key !== 'P' && key !== 'Parent' && key !== 'Dest' && key !== 'OC' && !(key === 'AP' && _this._isGroupingSupport))) {
                    _this._writeObject(table, ((value instanceof _PdfReference) ? dictionary.get(key) : value), dictionary, key);
                }
            });
        }
    };
    _JsonDocument.prototype._writeObject = function (table, value, dictionary, key, array, isColorSpace, isNewReference) {
        if (isColorSpace === void 0) { isColorSpace = false; }
        if (isNewReference === void 0) { isNewReference = false; }
        if (value instanceof _PdfName) {
            value.name = this._getValidString(value.name);
            this._writeTable('name', value.name, table, key, array);
        }
        else if (Array.isArray(value)) {
            var list = [];
            if (key === 'ColorSpace' || isColorSpace) {
                this._writeArray(list, value, dictionary, true);
            }
            else {
                this._writeArray(list, value, dictionary);
            }
            this._isColorSpace = false;
            this._writeTable('array', this._convertToJsonArray(list), table, key, array);
        }
        else if (typeof value === 'string') {
            var isTabSpace = false;
            if (value.indexOf('\t') !== -1) {
                isTabSpace = true;
            }
            if (key !== 'AllowedInteractions') {
                value = this._getValidString(value);
            }
            if (this._isColorSpace || key === 'AllowedInteractions' || this._hasUnicodeCharacters(value) || isTabSpace) {
                var bytes = _stringToBytes(value);
                this._writeTable('unicodeData', _byteArrayToHexString(bytes), table, key, array);
                isTabSpace = false;
            }
            else {
                this._writeTable('string', value, table, key, array);
            }
        }
        else if (typeof value === 'number') {
            this._writeTable(Number.isInteger(value) ? 'int' : 'fixed', value.toString(), table, key, array);
        }
        else if (typeof value === 'boolean') {
            this._writeTable('boolean', value ? 'true' : 'false', table, key, array);
        }
        else if (value instanceof _PdfDictionary) {
            var subTable = new Map();
            this._writeAppearanceDictionary(subTable, value);
            this._writeTable('dict', this._convertToJson(subTable), table, key, array);
        }
        else if (value instanceof _PdfBaseStream && value.dictionary) {
            var dataTable = new Map(); // eslint-disable-line
            var streamTable = new Map(); // eslint-disable-line
            var streamDictionary = value.dictionary;
            var data = void 0;
            var baseStream = value; // eslint-disable-line
            var isImageStream = false;
            if (streamDictionary.has('Subtype') && streamDictionary.get('Subtype').name === 'Image') {
                isImageStream = true;
            }
            if (isNewReference && isImageStream) {
                if (value.dictionary.has('Filter') && value.dictionary.get('Filter').name === 'DCTDecode') {
                    data = value.getString(true);
                }
                else {
                    data = _compressStream(value, true);
                }
            }
            else if (isImageStream && baseStream.stream) {
                if (baseStream.stream instanceof _PdfStream) {
                    if (typeof baseStream._initialized === 'boolean' && baseStream._cipher) {
                        var streamLength = baseStream.stream.end - baseStream.stream.start;
                        baseStream.getBytes(streamLength);
                        var bytes = baseStream.buffer.subarray(0, baseStream.bufferLength);
                        data = baseStream.getString(true, bytes);
                    }
                    else {
                        var stream = baseStream.stream;
                        data = baseStream.getString(true, stream.getByteRange(stream.start, stream.end));
                    }
                }
                else if (baseStream.stream.stream) {
                    var flateStream = baseStream.stream; // eslint-disable-line
                    if (flateStream.stream instanceof _PdfStream && typeof flateStream._initialized === 'boolean' && flateStream._cipher) {
                        var streamLength = flateStream.stream.end - flateStream.stream.start;
                        flateStream.getBytes(streamLength);
                        var bytes = flateStream.buffer.subarray(0, flateStream.bufferLength);
                        data = flateStream.getString(true, bytes);
                    }
                    else if (flateStream.stream instanceof _PdfStream) {
                        var stream = flateStream.stream;
                        data = flateStream.getString(true, stream.getByteRange(stream.start, stream.end));
                    }
                }
                else {
                    data = value.getString(true);
                }
            }
            else {
                data = value.getString(true);
            }
            if (!streamDictionary.has('Length') && data && data !== '') {
                streamDictionary.update('Length', value.length);
            }
            this._writeAppearanceDictionary(streamTable, streamDictionary);
            var type = void 0;
            if (streamDictionary.has('Subtype')) {
                type = this._getValue(streamDictionary.get('Subtype'));
            }
            if ((!streamDictionary.has('Type') && !streamDictionary.has('Subtype')) ||
                (streamDictionary.has('Subtype') &&
                    (type === 'Image' || type === 'Form' || type === 'CIDFontType0C' || type === 'OpenType'))) {
                dataTable.set('mode', 'raw');
                dataTable.set('encoding', 'hex');
            }
            else {
                dataTable.set('mode', 'filtered');
                dataTable.set('encoding', 'ascii');
            }
            if (data && data !== '') {
                dataTable.set('bytes', data);
            }
            streamTable.set('data', this._convertToJson(dataTable));
            this._writeTable('stream', this._convertToJson(streamTable), table, key, array);
        }
        else if (value instanceof _PdfReference && this._crossReference) {
            this._writeObject(table, this._crossReference._fetch(value), dictionary, key, array, isColorSpace, value._isNew);
        }
        else if (value === null || typeof value === 'undefined') {
            this._writeTable('null', 'null', table, key, array);
        }
    };
    _JsonDocument.prototype._writeTable = function (tableKey, value, table, key, array) {
        var map = new Map();
        map.set(tableKey, value);
        if (key) {
            table.set(key, this._convertToJson(map));
        }
        else if (array) {
            array.push(map);
        }
    };
    _JsonDocument.prototype._writeArray = function (array, value, dictionary, isColorSpace) {
        if (isColorSpace === void 0) { isColorSpace = false; }
        for (var i = 0; i < value.length; i++) {
            if (isColorSpace && typeof value[Number.parseInt(i.toString(), 10)] === 'string') {
                this._isColorSpace = true;
            }
            this._writeObject(null, value[Number.parseInt(i.toString(), 10)], dictionary, null, array, isColorSpace);
        }
    };
    _JsonDocument.prototype._convertToJson = function (table) {
        var j = 0;
        var json = '{';
        table.forEach(function (value, key) {
            if (value.startsWith('{') || value.startsWith('[')) {
                if (key === 'AllowedInteractions') {
                    json += "\"" + key + "\":" + value;
                }
                else {
                    json += '"' + key + '":' + value;
                }
            }
            else {
                if (value.startsWith(' ') && value.length > 1 && (value[1] === '[' || value[1] === '{')) {
                    value = value.substring(1);
                }
                json += '"' + key + '":"' + value + '"';
            }
            if (j < table.size - 1) {
                json += ',';
            }
            j++;
        });
        return json + '}';
    };
    _JsonDocument.prototype._hasUnicodeCharacters = function (value) {
        var unicodeRegex = /[^\x00-\x7F]/; // eslint-disable-line
        return value.split('').some(function (char) { return unicodeRegex.exec(char) !== null; }); // eslint-disable-line
    };
    _JsonDocument.prototype._convertToJsonArray = function (array) {
        var json = '[';
        for (var i = 0; i < array.length; i++) {
            json += this._convertToJson(array[Number.parseInt(i.toString(), 10)]);
            if (i < array.length - 1) {
                json += ',';
            }
        }
        return json + ']';
    };
    // #import
    _JsonDocument.prototype._parseJson = function (document, data) {
        this._document = document;
        this._crossReference = document._crossReference;
        var stringData = _bytesToString(data, true);
        if (stringData.startsWith('{') && !stringData.endsWith('}')) {
            while (stringData.length > 0 && !stringData.endsWith('}')) {
                stringData = stringData.substring(0, stringData.length - 1);
            }
        }
        return JSON.parse(stringData);
    };
    _JsonDocument.prototype._importFormData = function (document, data) {
        var _this = this;
        var json = this._parseJson(document, data); // eslint-disable-line
        if (json) {
            var keys = Object.keys(json);
            if (keys && keys.length > 0) {
                var _loop_1 = function (i) {
                    var key = keys[Number.parseInt(i.toString(), 10)];
                    var value = json[key]; // eslint-disable-line
                    if (Array.isArray(value)) {
                        if (this_1._fields.has('key')) {
                            value.forEach(function (entry) {
                                _this._fields.get(key).push(entry);
                            });
                        }
                        else {
                            this_1._fields.set(key, value);
                        }
                    }
                    else {
                        if (this_1._fields.has('key')) {
                            this_1._fields.get(key).push(value);
                        }
                        else {
                            this_1._fields.set(key, [value]);
                        }
                    }
                };
                var this_1 = this;
                for (var i = 0; i < keys.length; i++) {
                    _loop_1(i);
                }
                this._importField();
            }
        }
    };
    _JsonDocument.prototype._importAnnotations = function (document, data) {
        var _this = this;
        this._isImport = true;
        var json = this._parseJson(document, data); // eslint-disable-line
        if (json) {
            var keys = Object.keys(json);
            if (keys.indexOf('pdfAnnotation') !== -1) {
                var pageAnnotations_1 = json.pdfAnnotation; // eslint-disable-line
                var pageCount_1 = document.pageCount;
                var pageKeys = Object.keys(pageAnnotations_1);
                if (pageKeys && pageKeys.length > 0) {
                    pageKeys.forEach(function (key) {
                        var pageIndex = Number.parseInt(key, 10);
                        if (typeof pageIndex !== 'undefined' && pageIndex < pageCount_1) {
                            var page_1 = document.getPage(pageIndex);
                            var pageAnnotation = pageAnnotations_1[key]; // eslint-disable-line
                            if (pageAnnotation) {
                                var pageAnnotationKeys = Object.keys(pageAnnotation);
                                if (pageAnnotationKeys && pageAnnotationKeys.length > 0 && pageAnnotationKeys.indexOf('shapeAnnotation') !== -1) {
                                    var annotations = pageAnnotation['shapeAnnotation']; // eslint-disable-line
                                    if (annotations && annotations.length > 0) {
                                        annotations.forEach(function (annotation) {
                                            var annotationKeys = Object.keys(annotation);
                                            if (annotationKeys && annotationKeys.length > 0 && annotationKeys.indexOf('type') !== -1) {
                                                var dictionary = new _PdfDictionary(_this._crossReference);
                                                dictionary.update('Type', _PdfName.get('Annot'));
                                                var isValidType = true;
                                                switch (annotation['type'].toLowerCase()) {
                                                    case 'line':
                                                        dictionary.update('Subtype', _PdfName.get('Line'));
                                                        break;
                                                    case 'circle':
                                                        dictionary.update('Subtype', _PdfName.get('Circle'));
                                                        break;
                                                    case 'square':
                                                        dictionary.update('Subtype', _PdfName.get('Square'));
                                                        break;
                                                    case 'polyline':
                                                        dictionary.update('Subtype', _PdfName.get('PolyLine'));
                                                        break;
                                                    case 'polygon':
                                                        dictionary.update('Subtype', _PdfName.get('Polygon'));
                                                        break;
                                                    case 'ink':
                                                        dictionary.update('Subtype', _PdfName.get('Ink'));
                                                        break;
                                                    case 'popup':
                                                        dictionary.update('Subtype', _PdfName.get('Popup'));
                                                        break;
                                                    case 'text':
                                                        dictionary.update('Subtype', _PdfName.get('Text'));
                                                        break;
                                                    case 'freetext':
                                                        dictionary.update('Subtype', _PdfName.get('FreeText'));
                                                        break;
                                                    case 'stamp':
                                                        dictionary.update('Subtype', _PdfName.get('Stamp'));
                                                        break;
                                                    case 'highlight':
                                                        dictionary.update('Subtype', _PdfName.get('Highlight'));
                                                        break;
                                                    case 'squiggly':
                                                        dictionary.update('Subtype', _PdfName.get('Squiggly'));
                                                        break;
                                                    case 'underline':
                                                        dictionary.update('Subtype', _PdfName.get('Underline'));
                                                        break;
                                                    case 'strikeout':
                                                        dictionary.update('Subtype', _PdfName.get('StrikeOut'));
                                                        break;
                                                    case 'fileattachment':
                                                        dictionary.update('Subtype', _PdfName.get('FileAttachment'));
                                                        break;
                                                    case 'sound':
                                                        dictionary.update('Subtype', _PdfName.get('Sound'));
                                                        break;
                                                    case 'redact':
                                                        dictionary.update('Subtype', _PdfName.get('Redact'));
                                                        break;
                                                    case 'caret':
                                                        dictionary.update('Subtype', _PdfName.get('Caret'));
                                                        break;
                                                    default:
                                                        isValidType = false;
                                                        break;
                                                }
                                                if (isValidType) {
                                                    _this._addAnnotationData(dictionary, annotation, annotationKeys);
                                                    var pageDictionary = page_1._pageDictionary;
                                                    if (pageDictionary) {
                                                        var annotations_1 = page_1.annotations;
                                                        var annotation_1 = annotations_1._parseAnnotation(dictionary);
                                                        if (annotation_1) {
                                                            annotation_1._isImported = true;
                                                            var reference = _this._crossReference._getNextReference();
                                                            _this._crossReference._cacheMap.set(reference, dictionary);
                                                            if (dictionary.has('NM') || dictionary.has('IRT')) {
                                                                _this._addReferenceToGroup(reference, dictionary);
                                                            }
                                                            annotation_1._ref = reference;
                                                            var index = annotations_1._annotations.length;
                                                            annotations_1._annotations.push(reference);
                                                            if (annotations_1._comments && annotations_1._comments.length > 0) {
                                                                annotations_1._comments = [];
                                                            }
                                                            pageDictionary.set('Annots', annotations_1._annotations);
                                                            pageDictionary._updated = true;
                                                            annotations_1._parsedAnnotations.set(index, annotation_1);
                                                            _this._handlePopup(annotations_1, reference, dictionary, pageDictionary);
                                                        }
                                                    }
                                                }
                                            }
                                        });
                                    }
                                }
                            }
                        }
                    });
                }
                if (this._groupHolders.length > 0) {
                    for (var i = 0; i < this._groupHolders.length; i++) {
                        var dictionary = this._groupHolders[Number.parseInt(i.toString(), 10)];
                        var inReplyTo = dictionary.get('IRT');
                        if (inReplyTo && inReplyTo !== '') {
                            if (this._groupReferences.has(inReplyTo)) {
                                dictionary.update('IRT', this._groupReferences.get(inReplyTo));
                            }
                            else {
                                delete dictionary._map.IRT;
                            }
                        }
                    }
                }
                this._groupHolders = [];
                this._groupReferences = new Map();
            }
        }
    };
    _JsonDocument.prototype._addAnnotationData = function (dictionary, annotation, annotationKeys) {
        var _this = this;
        var borderEffectDictionary = new _PdfDictionary(this._crossReference);
        var borderStyleDictionary = new _PdfDictionary(this._crossReference);
        var dataStream = new Map();
        var linePoints = [];
        var beginLineStyle;
        var endLineStyle;
        var values = '';
        var rect;
        var outColor;
        annotationKeys.forEach(function (key) {
            var value = annotation[key]; // eslint-disable-line
            switch (key.toLowerCase()) {
                case 'start':
                case 'end':
                    _this._addLinePoints(value, linePoints);
                    if (linePoints.length === 4) {
                        dictionary.update('L', linePoints);
                        linePoints = [];
                    }
                    break;
                case 'itex':
                    break;
                case 'state':
                    _this._addString(dictionary, 'State', value);
                    break;
                case 'statemodel':
                    _this._addString(dictionary, 'StateModel', value);
                    break;
                case 'replytype':
                    if (value.toLowerCase() === 'group') {
                        dictionary.update('RT', _PdfName.get('Group'));
                    }
                    break;
                case 'inreplyto':
                    _this._addString(dictionary, 'IRT', value);
                    break;
                case 'dashes':
                case 'width':
                case 'intensity':
                case 'style':
                    _this._addBorderStyle(key, value, borderEffectDictionary, borderStyleDictionary);
                    break;
                case 'rect':
                    rect = value;
                    if (rect) {
                        var points = [];
                        points.push(Number.parseFloat(rect.x));
                        points.push(Number.parseFloat(rect.y));
                        points.push(Number.parseFloat(rect.width));
                        points.push(Number.parseFloat(rect.height));
                        if (points && points.length === 4) {
                            dictionary.update('Rect', points);
                        }
                    }
                    break;
                case 'color':
                    value = _convertToColor(value);
                    if (value && value.length === 3) {
                        dictionary.update('C', [value[0] / 255, value[1] / 255, value[2] / 255]);
                    }
                    break;
                case 'oc':
                    if (value && dictionary.get('Subtype').name === 'Redact') {
                        outColor = value.split(',');
                        var color_1 = [];
                        outColor.forEach(function (entry) {
                            color_1.push(Number.parseFloat(entry));
                        });
                        if (color_1 && color_1.length > 0) {
                            dictionary.update('OC', color_1);
                        }
                    }
                    break;
                case 'interior-color':
                    value = _convertToColor(value);
                    if (value && value.length === 3) {
                        dictionary.update('IC', [value[0] / 255, value[1] / 255, value[2] / 255]);
                    }
                    break;
                case 'date':
                    _this._addString(dictionary, 'M', value);
                    break;
                case 'creationdate':
                    _this._addString(dictionary, 'CreationDate', value);
                    break;
                case 'name':
                    _this._addString(dictionary, 'NM', value);
                    break;
                case 'icon':
                    if (value) {
                        dictionary.update('Name', _PdfName.get(value));
                    }
                    break;
                case 'subject':
                    _this._addString(dictionary, 'Subj', value);
                    break;
                case 'title':
                    _this._addString(dictionary, 'T', value);
                    break;
                case 'rotation':
                    dictionary.update('Rotate', Number.parseFloat(value));
                    break;
                case 'fringe':
                    _this._addFloatPoints(dictionary, 'RD', _this._parseFloatPoints(value));
                    break;
                case 'it':
                    if (value) {
                        dictionary.update('IT', _PdfName.get(value));
                    }
                    break;
                case 'leaderlength':
                    dictionary.update('LL', Number.parseFloat(value));
                    break;
                case 'leaderextend':
                    dictionary.update('LLE', Number.parseFloat(value));
                    break;
                case 'caption':
                    _this._addBoolean(dictionary, 'Cap', value.toLowerCase());
                    break;
                case 'caption-style':
                    if (value) {
                        dictionary.update('CP', _PdfName.get(value));
                    }
                    break;
                case 'callout':
                    _this._addFloatPoints(dictionary, 'CL', _this._parseFloatPoints(value));
                    break;
                case 'coords':
                    _this._addFloatPoints(dictionary, 'QuadPoints', _this._parseFloatPoints(value));
                    break;
                case 'border':
                    _this._addFloatPoints(dictionary, 'Border', _this._parseFloatPoints(value));
                    break;
                case 'opacity':
                    dictionary.update('CA', Number.parseFloat(value));
                    break;
                case 'defaultstyle':
                    if (value) {
                        var styleKeys_1 = Object.keys(value);
                        if (styleKeys_1 && styleKeys_1.length > 0) {
                            var style_1 = '';
                            var count_1 = 0;
                            styleKeys_1.forEach(function (styleKey) {
                                var styleValue = value[styleKey]; // eslint-disable-line
                                style_1 += styleKey + ':' + styleValue;
                                if (count_1 < styleKeys_1.length - 1) {
                                    style_1 += ';';
                                }
                                count_1++;
                            });
                            _this._addString(dictionary, 'DS', style_1);
                        }
                    }
                    break;
                case 'defaultappearance':
                    _this._addString(dictionary, 'DA', value);
                    break;
                case 'contents-richtext':
                    if (typeof value === 'string') {
                        _this._addString(dictionary, 'RC', value);
                    }
                    break;
                case 'flags':
                    if (value && typeof value === 'string') {
                        var annotFlag = PdfAnnotationFlag.default;
                        var flags = value.split(',');
                        for (var i = 0; i < flags.length; i++) {
                            var flagType = _stringToAnnotationFlags(flags[Number.parseInt(i.toString(), 10)]);
                            if (i === 0) {
                                annotFlag = flagType;
                            }
                            else {
                                annotFlag |= flagType;
                            }
                        }
                        dictionary.update('F', annotFlag);
                    }
                    break;
                case 'open':
                    _this._addBoolean(dictionary, 'Open', value.toLowerCase());
                    break;
                case 'repeat':
                    _this._addBoolean(dictionary, 'Repeat', value.toLowerCase());
                    break;
                case 'overlaytext':
                    _this._addString(dictionary, 'OverlayText', value);
                    break;
                case 'contents':
                    if (typeof value === 'string') {
                        if (value.indexOf('\\r') !== -1) {
                            value = value.replace('\\r', '\r');
                        }
                        if (value) {
                            _this._addString(dictionary, 'Contents', value);
                        }
                    }
                    break;
                case 'q':
                    dictionary.update('Q', Number.parseInt(value, 10));
                    break;
                case 'inklist':
                    if (value) {
                        var gestureKeys = Object.keys(value);
                        if (gestureKeys && gestureKeys.length > 0 && gestureKeys.indexOf('gesture') !== -1) {
                            var gesture = value.gesture;
                            if (gesture && gesture.length > 0) {
                                dictionary.update('InkList', gesture);
                            }
                        }
                    }
                    break;
                case 'head':
                    beginLineStyle = value;
                    break;
                case 'tail':
                    endLineStyle = value;
                    break;
                case 'creation':
                case 'modification':
                case 'file':
                case 'bits':
                case 'channels':
                case 'encoding':
                case 'rate':
                case 'length':
                case 'filter':
                case 'mode':
                case 'size':
                    dataStream.set(key, value);
                    break;
                case 'data':
                    values = value;
                    break;
                case 'vertices':
                    if (value && typeof value === 'string') {
                        var split = value.split(/[,;]/);
                        if (split && split.length > 0) {
                            var vertices = [];
                            for (var i = 0; i < split.length; i++) {
                                vertices.push(Number.parseFloat(split[Number.parseInt(i.toString(), 10)]));
                            }
                            if (vertices.length > 0 && vertices.length % 2 === 0) {
                                dictionary.update('Vertices', vertices);
                            }
                        }
                    }
                    break;
                case 'appearance':
                    _this._addAppearanceData(dictionary, value);
                    break;
                case 'allowedinteractions':
                    if (value) {
                        if (value && typeof value === 'string') {
                            _this._addString(dictionary, 'AllowedInteractions', value);
                        }
                        else {
                            var interactionKeys = Object.keys(value);
                            if (interactionKeys && interactionKeys.length > 0 && interactionKeys.indexOf('unicodeData') !== -1) {
                                var convertString = JSON.stringify(value['unicodeData']);
                                convertString = convertString.substring(1, convertString.length - 1);
                                value = _bytesToString(_hexStringToByteArray(convertString, false), true);
                                _this._addString(dictionary, 'AllowedInteractions', value);
                            }
                        }
                    }
                    break;
                default:
                    if (_this._document._allowImportCustomData && key !== 'type' && key !== 'page') {
                        _this._addString(dictionary, key, typeof value === 'string' ? value : JSON.stringify(value));
                    }
                    break;
            }
        });
        this._addMeasureDictionary(dictionary, annotation, annotationKeys);
        if (beginLineStyle) {
            if (endLineStyle) {
                dictionary.update('LE', [_PdfName.get(beginLineStyle), _PdfName.get(endLineStyle)]);
            }
            else {
                dictionary.update('LE', beginLineStyle);
            }
        }
        else if (endLineStyle) {
            dictionary.update('LE', endLineStyle);
        }
        if (borderStyleDictionary.size > 0) {
            borderStyleDictionary.update('Type', _PdfName.get('Border'));
            var reference = this._crossReference._getNextReference();
            borderStyleDictionary.objId = reference.objectNumber + ' ' + reference.generationNumber;
            this._crossReference._cacheMap.set(reference, borderStyleDictionary);
            dictionary.update('BS', reference);
        }
        if (borderEffectDictionary.size > 0) {
            var reference = this._crossReference._getNextReference();
            borderStyleDictionary.objId = reference.objectNumber + ' ' + reference.generationNumber;
            this._crossReference._cacheMap.set(reference, borderEffectDictionary);
            dictionary.update('BE', reference);
        }
        this._addStreamData(dictionary, dataStream, values);
    };
    _JsonDocument.prototype._addLinePoints = function (value, linePoints) {
        if (value && value.indexOf(',') !== -1) {
            var points = value.split(',');
            points.forEach(function (point) {
                linePoints.push(Number.parseFloat(point));
            });
        }
    };
    _JsonDocument.prototype._addString = function (dictionary, key, value) {
        if (value) {
            dictionary.update(key, value);
        }
    };
    _JsonDocument.prototype._addBoolean = function (dictionary, key, value) {
        if (value) {
            dictionary.update(key, value === 'yes' || value === 'true');
        }
    };
    _JsonDocument.prototype._addBorderStyle = function (key, value, borderEffectDictionary, borderStyleDictionary) {
        var style = '';
        var isBasicStyle = true;
        switch (value) {
            case 'dash':
                style = 'D';
                break;
            case 'solid':
                style = 'S';
                break;
            case 'bevelled':
                style = 'B';
                break;
            case 'inset':
                style = 'I';
                break;
            case 'underline':
                style = 'U';
                break;
            case 'cloudy':
                style = 'C';
                isBasicStyle = false;
                break;
        }
        switch (key.toLowerCase()) {
            case 'width':
                borderStyleDictionary.update('W', Number.parseFloat(value));
                break;
            case 'intensity':
                borderEffectDictionary.update('I', Number.parseFloat(value));
                break;
            case 'dashes':
                if (value && value.indexOf(',') !== -1) {
                    borderStyleDictionary.update('D', this._parseFloatPoints(value));
                }
                break;
        }
        if (style) {
            if (isBasicStyle) {
                borderStyleDictionary.update('S', _PdfName.get(style));
            }
            else {
                borderEffectDictionary.update('S', _PdfName.get(style));
            }
        }
    };
    _JsonDocument.prototype._parseFloatPoints = function (value) {
        var dashes = value.split(',');
        var dashArray = [];
        dashes.forEach(function (dash) {
            dashArray.push(Number.parseFloat(dash));
        });
        return dashArray;
    };
    _JsonDocument.prototype._addFloatPoints = function (dictionary, key, value) {
        if (value && value.length > 0) {
            dictionary.update(key, value);
        }
    };
    _JsonDocument.prototype._addMeasureDictionary = function (dictionary, annotation, annotationKeys) {
        var measureDictionary = new _PdfDictionary(this._crossReference);
        var aArray = [];
        var dArray = [];
        var xArray = [];
        var tArray = [];
        var vArray = [];
        measureDictionary.set('A', aArray);
        measureDictionary.set('D', dArray);
        measureDictionary.set('X', xArray);
        measureDictionary.set('T', tArray);
        measureDictionary.set('V', vArray);
        if (annotationKeys.indexOf('ratevalue') !== -1) {
            this._addString(measureDictionary, 'R', annotation['ratevalue']);
        }
        if (annotationKeys.indexOf('subtype') !== -1) {
            this._addString(measureDictionary, 'Subtype', annotation['subtype']);
        }
        if (annotationKeys.indexOf('targetunitconversion') !== -1) {
            this._addString(measureDictionary, 'TargetUnitConversion', annotation['targetunitconversion']);
        }
        if (annotationKeys.indexOf('area') !== -1) {
            aArray.push(this._readDictionaryElements(annotation['area']));
        }
        if (annotationKeys.indexOf('distance') !== -1) {
            dArray.push(this._readDictionaryElements(annotation['distance']));
        }
        if (annotationKeys.indexOf('xformat') !== -1) {
            xArray.push(this._readDictionaryElements(annotation['xformat']));
        }
        if (annotationKeys.indexOf('tformat') !== -1) {
            tArray.push(this._readDictionaryElements(annotation['tformat']));
        }
        if (annotationKeys.indexOf('vformat') !== -1) {
            vArray.push(this._readDictionaryElements(annotation['vformat']));
        }
        if (annotationKeys.indexOf('type1') !== -1) {
            measureDictionary.set('Type', _PdfName.get('Measure'));
            var reference = this._crossReference._getNextReference();
            measureDictionary.objId = reference.objectNumber + ' ' + reference.generationNumber;
            this._crossReference._cacheMap.set(reference, measureDictionary);
            dictionary.update('Measure', reference);
        }
    };
    _JsonDocument.prototype._readDictionaryElements = function (elements) {
        var keys = Object.keys(elements);
        var dictionary = new _PdfDictionary(this._crossReference);
        if (keys && keys.length > 0) {
            keys.forEach(function (key) {
                var value = elements[key]; // eslint-disable-line
                if (key && value) {
                    switch (key) {
                        case 'd':
                            dictionary.set('D', Number.parseFloat(value));
                            break;
                        case 'c':
                            dictionary.set('C', Number.parseFloat(value));
                            break;
                        case 'rt':
                            dictionary.set('RT', value);
                            break;
                        case 'rd':
                            dictionary.set('RD', value);
                            break;
                        case 'ss':
                            dictionary.set('SS', value);
                            break;
                        case 'u':
                            dictionary.set('U', value);
                            break;
                        case 'f':
                            dictionary.set('F', _PdfName.get(value));
                            break;
                        case 'fd':
                            dictionary.set('FD', value);
                            break;
                        case 'type':
                            dictionary.set('Type', _PdfName.get(value));
                            break;
                    }
                }
            });
        }
        return dictionary;
    };
    _JsonDocument.prototype._addStreamData = function (dictionary, data, values) {
        var _this = this;
        var subtype = dictionary.get('Subtype').name;
        var bytes = _hexStringToByteArray(values, true);
        if (subtype === 'Sound') {
            var soundStream_1 = new _PdfContentStream(bytes);
            soundStream_1.dictionary._crossReference = this._crossReference;
            soundStream_1.dictionary.update('Type', _PdfName.get('Sound'));
            data.forEach(function (value, key) {
                if (key && value) {
                    switch (key) {
                        case 'bits':
                        case 'rate':
                        case 'channels':
                            soundStream_1.dictionary.set(key, Number.parseInt(value, 10));
                            break;
                        case 'encoding':
                            soundStream_1.dictionary.set('E', _PdfName.get(value));
                            break;
                        case 'filter':
                            soundStream_1.dictionary.set('Filter', _PdfName.get('FlateDecode'));
                            break;
                    }
                }
            });
            soundStream_1.reference = this._crossReference._getNextReference();
            soundStream_1.dictionary.objId = soundStream_1.reference.objectNumber + ' ' + soundStream_1.reference.generationNumber;
            this._crossReference._cacheMap.set(soundStream_1.reference, soundStream_1);
            dictionary.update('Sound', soundStream_1.reference);
        }
        else if (subtype === 'FileAttachment') {
            var fileDictionary_1 = new _PdfDictionary(this._crossReference);
            fileDictionary_1.update('Type', _PdfName.get('Filespec'));
            var fileStream_1 = new _PdfContentStream(bytes);
            fileStream_1.dictionary._crossReference = this._crossReference;
            var param_1 = new _PdfDictionary(this._crossReference);
            data.forEach(function (value, key) {
                if (key && value) {
                    var size = void 0;
                    switch (key) {
                        case 'file':
                            _this._addString(fileDictionary_1, 'F', value);
                            _this._addString(fileDictionary_1, 'UF', value);
                            break;
                        case 'size':
                            size = Number.parseInt(value, 10);
                            if (typeof size !== 'undefined') {
                                param_1.update('Size', size);
                                fileStream_1.dictionary.update('DL', size);
                            }
                            break;
                        case 'creation':
                            _this._addString(param_1, 'CreationDate', value);
                            break;
                        case 'modification':
                            _this._addString(param_1, 'ModificationDate', value);
                            break;
                    }
                }
            });
            fileStream_1.dictionary.update('Params', param_1);
            fileStream_1.dictionary.update('Filter', _PdfName.get('FlateDecode'));
            fileStream_1.reference = this._crossReference._getNextReference();
            fileStream_1.dictionary.objId = fileStream_1.reference.objectNumber + ' ' + fileStream_1.reference.generationNumber;
            this._crossReference._cacheMap.set(fileStream_1.reference, fileStream_1);
            var embeddedFile = new _PdfDictionary(this._crossReference);
            embeddedFile.update('F', fileStream_1.reference);
            fileDictionary_1.update('EF', embeddedFile);
            var reference = this._crossReference._getNextReference();
            fileDictionary_1.objId = reference.objectNumber + ' ' + reference.generationNumber;
            this._crossReference._cacheMap.set(reference, fileDictionary_1);
            dictionary.update('FS', reference);
        }
    };
    _JsonDocument.prototype._addAppearanceData = function (dictionary, data) {
        if (data) {
            var encoded = _decode(data, false);
            var decoded = _bytesToString(encoded);
            if (decoded.startsWith('{') && !decoded.endsWith('}')) {
                while (decoded.length > 0 && !decoded.endsWith('}')) {
                    decoded = decoded.substring(0, decoded.length - 1);
                }
            }
            var json = JSON.parse(decoded); // eslint-disable-line
            if (json) {
                var keys = Object.keys(json);
                if (keys && keys.length > 0 && keys.indexOf('ap') !== -1) {
                    dictionary.update('AP', this._parseDictionary(json['ap']));
                }
            }
        }
    };
    _JsonDocument.prototype._parseAppearance = function (element) {
        var _this = this;
        var value; // eslint-disable-line
        var keys = Object.keys(element);
        if (keys.indexOf('name') !== -1) {
            value = _PdfName.get(element.name);
        }
        else if (keys.indexOf('int') !== -1) {
            value = Number.parseInt(element.int, 10);
        }
        else if (keys.indexOf('fixed') !== -1) {
            value = Number.parseFloat(element.fixed);
        }
        else if (keys.indexOf('string') !== -1) {
            value = element.string;
        }
        else if (keys.indexOf('boolean') !== -1) {
            value = element.boolean === 'true' ? true : false;
        }
        else if (keys.indexOf('array') !== -1) {
            var array = element.array; // eslint-disable-line
            value = [];
            array.forEach(function (element) {
                value.push(_this._parseAppearance(element));
            });
        }
        else if (keys.indexOf('dict') !== -1) {
            var dictionary = this._parseDictionary(element.dict);
            if (dictionary.size > 0) {
                value = this._crossReference._getNextReference();
                dictionary.objId = value.objectNumber + ' ' + value.generationNumber;
                this._crossReference._cacheMap.set(value, dictionary);
            }
            else {
                value = new _PdfDictionary(this._crossReference);
            }
        }
        else if (keys.indexOf('stream') !== -1) {
            var stream = this._parseStream(element.stream);
            value = this._crossReference._getNextReference();
            stream.reference = value;
            stream.dictionary.objId = value.objectNumber + ' ' + value.generationNumber;
            this._crossReference._cacheMap.set(value, stream);
        }
        else if (keys.indexOf('unicodeData') !== -1) {
            value = _bytesToString(_hexStringToByteArray(element.unicodeData, false), true);
        }
        else {
            value = null;
        }
        return value;
    };
    _JsonDocument.prototype._parseDictionary = function (element) {
        var _this = this;
        var result = new _PdfDictionary(this._crossReference);
        if (element) {
            var keys = Object.keys(element);
            if (keys && keys.length > 0) {
                keys.forEach(function (key) {
                    var value = element[key]; // eslint-disable-line
                    if (key !== 'data') {
                        var primitive = _this._parseAppearance(value); // eslint-disable-line
                        result.update(key, primitive);
                    }
                });
            }
        }
        return result;
    };
    _JsonDocument.prototype._parseStream = function (element) {
        var result;
        var keys = Object.keys(element);
        if (element && keys.indexOf('data')) {
            var data = element.data; // eslint-disable-line
            var bytes = void 0;
            if (data) {
                var dataKeys = Object.keys(data);
                if (dataKeys && dataKeys.indexOf('bytes') !== -1) {
                    var byteString = data.bytes;
                    if (byteString) {
                        bytes = _hexStringToByteArray(byteString, true);
                    }
                }
            }
            if (!bytes) {
                bytes = [];
            }
            var stream = new _PdfContentStream(bytes);
            if (this._crossReference) {
                this._parseStreamElements(stream, element);
            }
            else {
                stream._pendingResources = JSON.stringify(element);
            }
            result = stream;
        }
        return result;
    };
    _JsonDocument.prototype._parseStreamElements = function (stream, element) {
        if (typeof element === 'undefined' && stream._pendingResources) {
            element = JSON.parse(stream._pendingResources);
        }
        if (element) {
            var dictionary = this._parseDictionary(element);
            var isImage = false;
            if (dictionary && dictionary.has('Subtype')) {
                var type = dictionary.get('Subtype');
                isImage = type && type.name === 'Image';
            }
            if (isImage || (this._isImport && stream._isCompress)) {
                stream._isCompress = false;
            }
            else {
                if (dictionary.has('Length')) {
                    delete dictionary._map.Length;
                }
                if (dictionary.has('Filter')) {
                    delete dictionary._map.Filter;
                }
            }
            stream.dictionary = dictionary;
        }
    };
    _JsonDocument.prototype._getValidString = function (value) {
        if (value.indexOf('\\') !== -1) {
            value = value.replace(/\\/g, '\\\\');
        }
        if (value.indexOf('"') !== -1) {
            value = value.replace(/"/g, '\\"');
        }
        if (value.indexOf('[') !== -1) {
            value = value.replace(/\[/g, '\\[');
        }
        if (value.indexOf(']') !== -1) {
            value = value.replace(/\[/g, '\\]');
        }
        if (value.indexOf('{') !== -1) {
            value = value.replace(/\[/g, '\\{');
        }
        if (value.indexOf('}') !== -1) {
            value = value.replace(/\}/g, '\\}');
        }
        if (value.indexOf('\n') !== -1) {
            value = value.replace(/\n/g, '\\n');
        }
        if (value.indexOf('\r') !== -1) {
            value = value.replace(/\r/g, '\\r');
        }
        return value;
    };
    return _JsonDocument;
}(_ExportHelper));

/**
 * `PdfTemplate` class represents the template of the PDF.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new rubber stamp annotation
 * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 100, 100, 50);
 * // Get the normal appearance of the annotation
 * let normalAppearance: PdfTemplate = annotation.appearance.normal;
 * // Create new image object by using JPEG image data as Base64 string format
 * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
 * // Draw the image as the custom appearance for the annotation
 * normalAppearance.graphics.drawImage(image, 0, 0, 100, 50);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfTemplate = /** @class */ (function () {
    function PdfTemplate(value, crossReference) {
        this._isExported = false;
        this._isResourceExport = false;
        this._isSignature = false;
        this._crossReference = crossReference;
        if (value instanceof _PdfBaseStream) {
            this._content = value;
            if (!this._content.dictionary.has('Type') || !this._content.dictionary.has('Subtype')) {
                this._initialize();
            }
            var bounds = this._content.dictionary.getArray('BBox');
            if (bounds && bounds.length > 3) {
                var rect = _toRectangle(bounds);
                this._size = [rect.width, rect.height];
                this._templateOriginalSize = this._size;
            }
            this._isReadOnly = true;
        }
        else {
            if (typeof value !== 'undefined') {
                this._size = [value[2], value[3]];
                this._content = new _PdfContentStream([]);
                this._content.dictionary._crossReference = this._crossReference;
                this._initialize();
                this._content.dictionary.set('BBox', [value[0], value[1], value[0] + value[2], value[1] + value[3]]);
            }
            else {
                this._isReadOnly = true;
            }
        }
        this._writeTransformation = true;
    }
    Object.defineProperty(PdfTemplate.prototype, "graphics", {
        /**
         * Get the graphics of the PDF template. (Read only)
         *
         * @returns {PdfGraphics} The graphics object of the PDF template.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new rubber stamp annotation
         * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 100, 100, 50);
         * // Access the graphics of the normal appearance
         * let graphics: PdfGraphics = annotation.appearance.normal.graphics;
         * // Create new image object by using JPEG image data as Base64 string format
         * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
         * // Draw the image as the custom appearance for the annotation
         * graphics.drawImage(image, 0, 0, 100, 50);
         * // Add annotation to the page
         * page.annotations.add(annotation);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isReadOnly) {
                return null;
            }
            if (typeof this._g === 'undefined') {
                this._g = new PdfGraphics(this._size, this._content, this._crossReference, this);
                if (this._writeTransformation) {
                    this._g._initializeCoordinates();
                }
                this._g._isTemplateGraphics = true;
            }
            return this._g;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTemplate.prototype, "size", {
        /**
         * Get the size of the PDF template. (Read only)
         *
         * @returns {number[]} Template width and height as number array.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new rubber stamp annotation
         * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 100, 100, 50);
         * // Access the normal template of the appearance
         * let template: PdfTemplate = appearance.normal;
         * // Get the width and height of the PDF template as number array.
         * let size: number[] = template.size;
         * // Create new image object by using JPEG image data as Base64 string format
         * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
         * // Draw the image as the custom appearance for the annotation
         * template.graphics.drawImage(image, 0, 0, size[0], size[1]);
         * // Add annotation to the page
         * page.annotations.add(annotation);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTemplate.prototype, "_originalSize", {
        /**
         * Get the original size of the PDF template. (Read only)
         *
         * Remarks: The `_originalSize` property is internal and provides access to the original dimensions of the PDF template.
         *
         * @returns {number[]} Template original width and height as number array.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new rubber stamp annotation
         * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 100, 100, 50);
         * // Access the normal template of the appearance
         * let template: PdfTemplate = appearance.normal;
         * // Get the width and height of the PDF template as number array
         * let size: number[] = template._originalSize;
         * // Create new image object by using JPEG image data as Base64 string format
         * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
         * // Draw the image as the custom appearance for the annotation
         * template.graphics.drawImage(image, 0, 0, size[0], size[1]);
         * // Add annotation to the page
         * page.annotations.add(annotation);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._templateOriginalSize;
        },
        enumerable: true,
        configurable: true
    });
    PdfTemplate.prototype._initialize = function () {
        this._content.dictionary.set('Type', _PdfName.get('XObject'));
        this._content.dictionary.set('Subtype', _PdfName.get('Form'));
    };
    PdfTemplate.prototype._exportStream = function (dictionary, crossReference) {
        var jsonDocument = new _JsonDocument();
        jsonDocument._crossReference = crossReference;
        jsonDocument._isAnnotationExport = true;
        var resourceTable = new Map();
        jsonDocument._writeObject(resourceTable, dictionary.get('N'), dictionary, 'normal');
        this._appearance = jsonDocument._convertToJson(resourceTable);
        jsonDocument._dispose();
    };
    PdfTemplate.prototype._importStream = function (hasCrossReference, isResourceExport) {
        var jsonDocument = new _JsonDocument();
        if (hasCrossReference) {
            jsonDocument._crossReference = this._crossReference;
        }
        var json = JSON.parse(this._appearance); // eslint-disable-line    
        if (json) {
            var entryKey = isResourceExport ? 'resources' : 'normal'; // eslint-disable-line
            var entry = json[entryKey]; // eslint-disable-line    
            if (entry) {
                if (isResourceExport) {
                    var resourceDictionary = jsonDocument._parseDictionary(entry['dict']);
                    if (hasCrossReference) {
                        this._content.dictionary.update('Resources', resourceDictionary);
                    }
                }
                else {
                    this._content = jsonDocument._parseStream(entry['stream']);
                    if (hasCrossReference) {
                        this._content.dictionary._crossReference = this._crossReference;
                        this._content.dictionary._updated = true;
                    }
                }
            }
        }
        jsonDocument._dispose();
    };
    PdfTemplate.prototype._updatePendingResource = function (crossReference) {
        if (this._content._pendingResources && this._content._pendingResources !== '') {
            var jsonDocument = new _JsonDocument();
            jsonDocument._crossReference = crossReference;
            jsonDocument._parseStreamElements(this._content);
            this._content._pendingResources = '';
            jsonDocument._dispose();
        }
    };
    return PdfTemplate;
}());

var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Represents base class for all action types.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access button field
 * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
 * // Access the second page
 * let secondPage: PdfPage = document.getPage(2);
 * // Create a PdfDestination for the specified page
 * let destination: PdfDestination = new PdfDestination(secondPage)
 * // Create a new PdfGoToAction with the specified destination
 * let gotoAction: PdfGoToAction = new PdfGoToAction(destination);
 * // Get the GoTo action to the mouse enter property of the button field
 * let pdfAction: PdfAction = field.actions.mouseEnter;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 */
var PdfAction = /** @class */ (function () {
    function PdfAction() {
    }
    Object.defineProperty(PdfAction.prototype, "next", {
        /**
         * Get the next action to be performed after the action represented by this instance.
         *
         * @returns {PdfAction} The next action to be executed.
         *
         * Represents an action which goes to a destination in the current document.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Access the page1
         * let Page1: PdfPage = document.getPage(1);
         * // Create a PdfGoToAction for navigating to the specified page.
         * let action: PdfGoToAction = new PdfGoToAction(page1);
         * // Set the destination page for the action
         * action.destination = new PdfDestination(secondPage);
         * // Set the GoTo action to the mouse enter property of the button field
         * field1.actions.mouseEnter = action1;
         * // Access the page
         * let page: PdfPage = document.getPage(2);
         * // Access button field
         * let field1: PdfButtonField = document.form.fieldAt(1) as PdfButtonField;
         * // Create a new GoTo action with the specified page
         * let gotoAction: PdfGoToAction = new PdfGoToAction(page);
         * // Set the next property
         * gotoAction.next = action;
         * // Set the GoTo action to the mouse enter property of the button field
         * field1.actions.mouseEnter = gotoAction;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         */
        get: function () {
            return this._next;
        },
        /**
         * Set the next action to be performed after the action represented by this instance.
         *
         * @param {PdfAction} value The next action to be executed.
         *
         * Represents an action which goes to a destination in the current document.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Access the page1
         * let Page1: PdfPage = document.getPage(1);
         * let action: PdfGoToAction = new PdfGoToAction(page1);
         * // Set the destination page for the action
         * action.destination = new PdfDestination(secondPage);
         * // Set the GoTo action to the mouse enter property of the button field
         * field1.actions.mouseEnter = action1;
         * // Access the third page
         * let page: PdfPage = document.getPage(2);
         * // Access button field
         * let field1: PdfButtonField = document.form.fieldAt(1) as PdfButtonField;
         * // Create a new GoTo action with the specified page
         * let gotoAction: PdfGoToAction = new PdfGoToAction(page);
         * // Set the next property
         * gotoAction.next = action;
         * // Set the GoTo action to the mouse enter property of the button field
         * field1.actions.mouseEnter = gotoAction;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         */
        set: function (value) {
            this._next = value;
            var reference = this._page._crossReference._getNextReference();
            this._page._crossReference._cacheMap.set(reference, value._dictionary);
            value._dictionary.objId = reference.toString();
            this._dictionary.update('Next', reference);
        },
        enumerable: true,
        configurable: true
    });
    return PdfAction;
}());
/**
 * Represents an action which goes to a destination in the current document.
 *
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access button field
 * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
 * // Access the second page
 * let secondPage: PdfPage = document.getPage(2);
 * // Create a PdfDestination for the specified page
 * let destination: PdfDestination = new PdfDestination(secondPage)
 * // Create a new PdfGoToAction with the specified destination
 * let gotoAction: PdfGoToAction = new PdfGoToAction(destination);
 * // Set the goto action to the button
 * field.actions.mouseEnter = gotoAction;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 */
var PdfGoToAction = /** @class */ (function (_super) {
    __extends$4(PdfGoToAction, _super);
    function PdfGoToAction(arg) {
        var _this = _super.call(this) || this;
        if (arg instanceof PdfDestination) {
            _this._destination = arg;
            _this._page = arg.page;
        }
        else {
            _this._page = arg;
            _this._destination = new PdfDestination(arg, [0, 0]);
        }
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', new _PdfName('Action'));
        _this._dictionary.update('S', new _PdfName('GoTo'));
        return _this;
    }
    Object.defineProperty(PdfGoToAction.prototype, "destination", {
        /**
         * Get the destination to be navigated.
         *
         * @returns {PdfDestination} The destination to be navigated.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Get the action value from button field
         * let action: PdfAction = field.actions.mouseEnter.destination;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._destination;
        },
        /**
         * Set the destination to be navigated.
         *
         * @param {PdfDestination} value The destination to be navigated.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Access the second page
         * let secondPage: PdfPage = document.getPage(2);
         * // Create a new GoTo action with the specified page
         * let gotoAction: PdfGoToAction = new PdfGoToAction(secondPage);
         * // Set the destination location within the specified page for the PdfGoToAction
         * gotoAction.Destination = new PdfDestination(secondPage, [0, 100]);
         * // Set the goto action to the button
         * field.actions.mouseEnter = gotoAction;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         */
        set: function (value) {
            this._destination = value;
        },
        enumerable: true,
        configurable: true
    });
    return PdfGoToAction;
}(PdfAction));
/**
 * Represents actions to be performed as response to field events.
 *
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access button field
 * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
 * // Access the second page
 * let secondPage: PdfPage = document.getPage(2);
 * // Create a PdfDestination for the specified page
 * let destination: PdfDestination = new PdfDestination(secondPage)
 * // Create a new PdfGoToAction with the specified destination
 * let gotoAction: PdfGoToAction = new PdfGoToAction(destination);
 * // Get the pdf field actions
 * let fieldActions: PdfFieldActions = field.actions;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 */
var PdfFieldActions = /** @class */ (function () {
    /**
     * Initializes a new instance of the `PdfFieldActions` class.
     *
     * @private
     * @param {PdfField} field field items.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access button field
     * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
     * // Access the second page
     * let secondPage: PdfPage = document.getPage(2);
     * // Create a PdfDestination for the specified page
     * let destination: PdfDestination = new PdfDestination(secondPage)
     * // Creates a new PdfGoToAction with the specified destination
     * let gotoAction: PdfGoToAction = new PdfGoToAction(destination);
     * // Set the goto action to the button
     * field.actions.mouseEnter = gotoAction;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     */
    function PdfFieldActions(field) {
        this._field = field;
    }
    Object.defineProperty(PdfFieldActions.prototype, "mouseEnter", {
        /**
         * Get the action to be performed when the mouse cursor enters the field area.
         *
         * @returns {PdfAction} The action to be executed when the mouse enters the field area.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Get the action to be executed when the mouse enters the field area
         * let action: PdfAction = field.actions.mouseEnter;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._mouseEnter) {
                this._mouseEnter = this._getPdfAction('E');
            }
            return this._mouseEnter;
        },
        /**
         * Set the action to be performed when the mouse cursor enters the field area.
         *
         * @param {PdfAction} value The action to be executed when the mouse enters the field area.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Access the second page
         * let secondPage: PdfPage = document.getPage(2);
         * // Create a new GoTo action with the specified page
         * let gotoAction: PdfGoToAction = new PdfGoToAction(secondPage);
         * // Set the destination location within the specified page for the PdfGoToAction
         * gotoAction.Destination = new PdfDestination(secondPage, [0, 100]);
         * // Set the GoTo action to the mouse enter property of the button field
         * field.actions.mouseEnter = gotoAction;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         */
        set: function (value) {
            if (value) {
                this._mouseEnter = value;
                this._updateAction(this._mouseEnter, 'E');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFieldActions.prototype, "mouseLeave", {
        /**
         * Get the action to be performed when the cursor exits the fields area.
         *
         * @returns {PdfAction} The action to be executed when the mouse exists the field area.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Get the action to be executed when the mouse leave the field area.
         * let action: PdfAction = field.actions.mouseLeave;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._mouseLeave) {
                this._mouseLeave = this._getPdfAction('X');
            }
            return this._mouseLeave;
        },
        /**
         * Set the action to be performed when the cursor exits the fields area.
         *
         * @param {PdfAction} value The action to be executed when the mouse exists the field area.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Access the second page
         * let secondPage: PdfPage = document.getPage(2);
         * // Create a new GoTo action with the specified page
         * let gotoAction: PdfGoToAction = new PdfGoToAction(secondPage);
         * // Set the destination location within the specified page for the PdfGoToAction
         * gotoAction.Destination = new PdfDestination(secondPage, [0, 100]);
         * // Set the GoTo action to the mouse leave property of the button field
         * field.actions.mouseLeave = gotoAction;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         */
        set: function (value) {
            if (value) {
                this._mouseLeave = value;
                this._updateAction(this._mouseLeave, 'X');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFieldActions.prototype, "mouseUp", {
        /**
         * Get the action to be performed when the mouse button is released inside the field area.
         *
         * @returns {PdfAction} The action to be executed when the mouse released inside the field area.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Get the action to be executed when the mouse up the field area.
         * let action: PdfAction = field.actions.mouseUp;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._mouseUp) {
                this._mouseUp = this._getPdfAction('U');
            }
            return this._mouseUp;
        },
        /**
         * Set the action to be performed when the mouse button is released inside the field area.
         *
         * @param {PdfAction} value The action to be executed when the mouse released inside the field area.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Access the second page
         * let secondPage: PdfPage = document.getPage(2);
         * // Create a new GoTo action with the specified page
         * let gotoAction: PdfGoToAction = new PdfGoToAction(secondPage);
         * // Set the destination location within the specified page for the PdfGoToAction
         * gotoAction.Destination = new PdfDestination(secondPage, [0, 100]);
         * // Set the GoTo action to the mouse up property of the button field
         * field.actions.mouseUp = gotoAction;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         */
        set: function (value) {
            if (value) {
                this._mouseUp = value;
                this._updateAction(this._mouseUp, 'U');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFieldActions.prototype, "mouseDown", {
        /**
         * Get the action to be performed when the mouse button is pressed inside the field’s area.
         *
         * @returns {PdfAction} The action to be executed when the mouse button is pressed inside the field area.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Get the action to be executed when the mouse down the field area.
         * let action: PdfAction = field.actions.mouseDown;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._mouseDown) {
                this._mouseDown = this._getPdfAction('D');
            }
            return this._mouseDown;
        },
        /**
         * Set the action to be performed when the mouse button is pressed inside the field’s area.
         *
         * @param {PdfAction} value The action to be executed when the mouse button is pressed inside the field area.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Access the second page
         * let secondPage: PdfPage = document.getPage(2);
         * // Create a new GoTo action with the specified page
         * let gotoAction: PdfGoToAction = new PdfGoToAction(secondPage);
         * // Set the destination location within the specified page for the PdfGoToAction
         * gotoAction.Destination = new PdfDestination(secondPage, [0, 100]);
         * // Set the GoTo action to the mouse down property of the button field
         * field.actions.mouseDown = gotoAction;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         */
        set: function (value) {
            if (value) {
                this._mouseDown = value;
                this._updateAction(this._mouseDown, 'D');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFieldActions.prototype, "gotFocus", {
        /**
         * Get the action to be performed when the field receives the input focus.
         *
         * @returns {PdfAction} The action to be executed when the field receives the input focus.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Get the action to be executed when the got focus the field area.
         * let action: PdfAction = field.actions.gotFocus;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._gotFocus) {
                this._gotFocus = this._getPdfAction('Fo');
            }
            return this._gotFocus;
        },
        /**
         * Set the action to be performed when the field receives the input focus.
         *
         * @param {PdfAction} value The action to be executed when the field receives the input focus.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Access the second page
         * let secondPage: PdfPage = document.getPage(2);
         * // Create a new GoTo action with the specified page
         * let gotoAction: PdfGoToAction = new PdfGoToAction(secondPage);
         * // Set the destination location within the specified page for the PdfGoToAction
         * gotoAction.Destination = new PdfDestination(secondPage, [0, 100]);
         * // Set the GoTo action to the got focus property of the button field
         * field.actions.gotFocus = gotoAction;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         */
        set: function (value) {
            if (value) {
                this._gotFocus = value;
                this._updateAction(this._gotFocus, 'Fo');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFieldActions.prototype, "lostFocus", {
        /**
         * Get the action to be performed when the field loses the input focus.
         *
         * @returns {PdfAction} The action to be executed when the field loses the input focus.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Get the action to be executed when the lost focus the field area.
         * let action: PdfAction = field.actions.lostFocus;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._lostFocus) {
                this._lostFocus = this._getPdfAction('Bl');
            }
            return this._lostFocus;
        },
        /**
         * Set the action to be performed when the field loses the input focus.
         *
         * @param {PdfAction} value The action to be executed when the field loses the input focus.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Access the second page
         * let secondPage: PdfPage = document.getPage(2);
         * // Create a new GoTo action with the specified page
         * let gotoAction: PdfGoToAction = new PdfGoToAction(secondPage);
         * // Set the destination location within the specified page for the PdfGoToAction
         * gotoAction.Destination = new PdfDestination(secondPage, [0, 100]);
         * // Set the GoTo action to the lost focus property of the button field
         * field.actions.lostFocus = gotoAction;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         */
        set: function (value) {
            if (value) {
                this._lostFocus = value;
                this._updateAction(this._lostFocus, 'Bl');
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfFieldActions.prototype._updateAction = function (action, key) {
        var widget;
        if (this._field._kidsCount > 0) {
            widget = this._field.itemAt(0);
            if (widget && widget._dictionary && action instanceof PdfGoToAction) {
                var dictionary = new _PdfDictionary();
                var page = action._page;
                var destination = action.destination;
                if (destination._destinationMode === PdfDestinationMode.location) {
                    action._dictionary.update('D', [page._ref, new _PdfName('XYZ'), destination.location[0], page.size[1], destination.zoom]);
                }
                else if (destination._destinationMode === PdfDestinationMode.fitR) {
                    action._dictionary.update('D', [page._ref, new _PdfName('FitR'), 0, 0, 0, 0]);
                }
                else if (destination._destinationMode === PdfDestinationMode.fitH) {
                    action._dictionary.update('D', [page._ref, new _PdfName('FitH'), page.size[1]]);
                }
                else if (destination._destinationMode === PdfDestinationMode.fitToPage) {
                    action._dictionary.update('D', [page._ref, new _PdfName('Fit')]);
                }
                dictionary.set(key, action._dictionary);
                dictionary._updated = true;
                widget._dictionary.update('AA', dictionary);
            }
        }
    };
    PdfFieldActions.prototype._getPdfAction = function (key) {
        var result;
        var widget = this._field.itemAt(0);
        if (widget && widget._dictionary && widget._dictionary.has('AA')) {
            var action = widget._dictionary.get('AA');
            if (action && action.has(key)) {
                var dictionary = action.get(key);
                if (dictionary && dictionary.has('S')) {
                    var type = dictionary.get('S');
                    if (type && type.name === 'GoTo' && dictionary.has('D')) {
                        if (!dictionary._crossReference) {
                            dictionary._crossReference = widget._crossReference;
                        }
                        result = new PdfGoToAction(_obtainDestination(dictionary, 'D'));
                    }
                }
            }
        }
        return result;
    };
    return PdfFieldActions;
}());

var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * `PdfField` class represents the base class for form field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access the form field at index 0
 * let field: PdfField = document.form.fieldAt(0);
 * // Gets the count of the loaded field items
 * let count: number = field.itemsCount;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfField = /** @class */ (function () {
    function PdfField() {
        this._enableGrouping = false;
        this._isDuplicatePage = false;
        this._visible = true;
        this._isTransparentBackColor = false;
        this._isTransparentBorderColor = false;
        this._defaultFont = new PdfStandardFont(PdfFontFamily.helvetica, 8);
        this._appearanceFont = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);
        this._defaultItemFont = new PdfStandardFont(PdfFontFamily.timesRoman, 12);
        this._flatten = false;
        this._hasData = false;
        this._circleCaptionFont = new PdfStandardFont(PdfFontFamily.helvetica, 8, PdfFontStyle.regular);
        this._isUpdating = false;
        this._isImport = false;
    }
    Object.defineProperty(PdfField.prototype, "itemsCount", {
        /**
         * Gets the count of the loaded field items (Read only).
         *
         * @returns {number} Items count.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the count of the loaded field items
         * let count: number = field.itemsCount;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._kids ? this._kids.length : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "form", {
        /**
         * Gets the form object of the field (Read only).
         *
         * @returns {PdfForm} Form.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the form object of the field
         * let form: PdfForm = field.form;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._form;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "name", {
        /**
         * Gets the name of the field (Read only).
         *
         * @returns {string} Field name.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the name of the field
         * let name: string = field.name;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._name === 'undefined') {
                var names = _getInheritableProperty(this._dictionary, 'T', false, false, 'Parent');
                if (names && names.length > 0) {
                    if (names.length === 1) {
                        this._name = names[0];
                    }
                    else {
                        this._name = names.join('.');
                    }
                }
            }
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "actualName", {
        /**
         * Gets the actual name of the field (Read only).
         *
         * @private
         * @returns {string} Actual name.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the actual name of the field
         * let name: string = field.actualName;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._actualName === 'undefined' && this._dictionary && this._dictionary.has('T')) {
                var name_1 = this._dictionary.get('T');
                if (name_1 && typeof name_1 === 'string') {
                    this._actualName = name_1;
                }
            }
            return this._actualName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "mappingName", {
        /**
         * Gets the mapping name to be used when exporting interactive form field data from the document.
         *
         * @returns {string} Mapping name.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the mapping name of the field
         * let name: string = field.mappingName;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._mappingName === 'undefined' && this._dictionary.has('TM')) {
                var name_2 = this._dictionary.get('TM');
                if (name_2 && typeof name_2 === 'string') {
                    this._mappingName = name_2;
                }
            }
            return this._mappingName;
        },
        /**
         * Sets the mapping name to be used when exporting interactive form field data from the document.
         *
         * @param {string} value Mapping name.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets the mapping name of the field
         * field.mappingName = ‘Author’;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof this.mappingName === 'undefined' || this._mappingName !== value) {
                this._mappingName = value;
                this._dictionary.update('TM', value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "toolTip", {
        /**
         * Gets the tool tip of the form field.
         *
         * @returns {string} Tooltip.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the tool tip value of the field
         * let toolTip: string = field.toolTip;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._alternateName === 'undefined' && this._dictionary && this._dictionary.has('TU')) {
                var name_3 = this._dictionary.get('TU');
                if (name_3 && typeof name_3 === 'string') {
                    this._alternateName = name_3;
                }
            }
            return this._alternateName;
        },
        /**
         * Sets the tool tip of the form field.
         *
         * @param {string} value Tooltip.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets the tool tip value of the field
         * field.toolTip = ‘Author of the document’;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof this.toolTip === 'undefined' || this._alternateName !== value) {
                this._alternateName = value;
                this._dictionary.update('TU', value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "visibility", {
        /**
         * Gets the form field visibility.
         *
         * @returns {PdfFormFieldVisibility} Field visibility option.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the form field visibility.
         * let visibility: PdfFormFieldVisibility = field.visibility;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var value;
            if (this._isLoaded) {
                value = PdfFormFieldVisibility.visible;
                var widget = this.itemAt(this._defaultIndex);
                var flag = PdfAnnotationFlag.default;
                if (widget && widget._hasFlags) {
                    flag = widget.flags;
                }
                else if (this._dictionary.has('F')) {
                    flag = this._dictionary.get('F');
                }
                else {
                    return PdfFormFieldVisibility.visibleNotPrintable;
                }
                var flagValue = 3;
                if ((flag & PdfAnnotationFlag.hidden) === PdfAnnotationFlag.hidden) {
                    flagValue = 0;
                }
                if ((flag & PdfAnnotationFlag.noView) === PdfAnnotationFlag.noView) {
                    flagValue = 1;
                }
                if ((flag & PdfAnnotationFlag.print) !== PdfAnnotationFlag.print) {
                    flagValue &= 2;
                }
                switch (flagValue) {
                    case 0:
                        value = PdfFormFieldVisibility.hidden;
                        break;
                    case 1:
                        value = PdfFormFieldVisibility.hiddenPrintable;
                        break;
                    case 2:
                        value = PdfFormFieldVisibility.visibleNotPrintable;
                        break;
                    case 3:
                        value = PdfFormFieldVisibility.visible;
                        break;
                }
            }
            else {
                if (typeof this._visibility === 'undefined') {
                    this._visibility = PdfFormFieldVisibility.visible;
                }
                value = this._visibility;
            }
            return value;
        },
        /**
         * Sets the form field visibility.
         *
         * @param {PdfFormFieldVisibility} value visibility.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets the form field visibility.
         * field.visibility = PdfFormFieldVisibility.visible;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            var widget = this.itemAt(this._defaultIndex);
            if (this._isLoaded) {
                if (widget && (!widget._hasFlags || this.visibility !== value)) {
                    _updateVisibility(widget._dictionary, value);
                    this._dictionary._updated = true;
                }
                else if (!this._dictionary.has('F') || this.visibility !== value) {
                    _updateVisibility(this._dictionary, value);
                    this._dictionary._updated = true;
                }
            }
            else {
                if (this.visibility !== value) {
                    this._visibility = value;
                    switch (value) {
                        case PdfFormFieldVisibility.hidden:
                            widget.flags = PdfAnnotationFlag.hidden;
                            break;
                        case PdfFormFieldVisibility.hiddenPrintable:
                            widget.flags = (PdfAnnotationFlag.noView | PdfAnnotationFlag.print);
                            break;
                        case PdfFormFieldVisibility.visible:
                            widget.flags = PdfAnnotationFlag.print;
                            break;
                        case PdfFormFieldVisibility.visibleNotPrintable:
                            widget.flags = PdfAnnotationFlag.default;
                            break;
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "bounds", {
        /**
         * Gets the bounds.
         *
         * @returns {{ x: number, y: number, width: number, height: number }} Bounds.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the bounds of list box field.
         * let bounds: {x: number, y: number, width: number, height: number} = field.bounds;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var value;
            var widget = this.itemAt(this._defaultIndex);
            if (widget) {
                widget._page = this.page;
            }
            if (widget && widget.bounds) {
                value = widget.bounds;
            }
            else if (this._dictionary && this._dictionary.has('Rect')) {
                value = _calculateBounds(this._dictionary, this.page);
            }
            if (typeof value === 'undefined' || value === null) {
                value = { x: 0, y: 0, width: 0, height: 0 };
            }
            return value;
        },
        /**
         * Sets the bounds.
         *
         * @param {{ x: number, y: number, width: number, height: number }} value bounds.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets the bounds.
         * field.bounds = {x: 10, y: 10, width: 100, height: 20};
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value.x === 0 && value.y === 0 && value.width === 0 && value.height === 0) {
                throw new Error('Cannot set empty bounds');
            }
            var widget = this.itemAt(this._defaultIndex);
            if (this._isLoaded) {
                if (typeof widget === 'undefined' || this._dictionary.has('Rect')) {
                    this._dictionary.update('Rect', _getUpdatedBounds([value.x, value.y, value.width, value.height], this.page));
                }
                else {
                    widget._page = this.page;
                    widget.bounds = value;
                }
            }
            else {
                widget._page = this.page;
                widget.bounds = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "rotate", {
        /**
         * Gets the rotation angle of the field.
         *
         * @returns {number} angle.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the rotation angle of the form field.
         * let rotate: number = field.rotate;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var widget = this.itemAt(this._defaultIndex);
            var angle;
            if (widget && typeof widget.rotate !== 'undefined') {
                angle = widget.rotate;
            }
            else if (this._dictionary.has('R')) {
                angle = this._dictionary.get('R');
            }
            else {
                for (var i = 0; i < this._kidsCount && typeof angle === 'undefined'; i++) {
                    if (i !== this._defaultIndex) {
                        widget = this.itemAt(i);
                        if (widget && typeof widget.rotate !== 'undefined') {
                            angle = widget.rotate;
                        }
                    }
                }
            }
            if (typeof angle === 'undefined') {
                angle = 0;
            }
            return angle;
        },
        /**
         * Sets the rotation angle of the field.
         *
         * @param {number} value rotation angle.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets the rotation angle.
         * field.rotate = 90;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            var widget = this.itemAt(this._defaultIndex);
            if (widget) {
                widget.rotate = value;
            }
            else if (!this._dictionary.has('R') || this._dictionary.get('R') !== value) {
                this._dictionary.update('R', value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "color", {
        /**
         * Gets the fore color of the field.
         *
         * @returns {number[]} R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the fore color of the field.
         * let color: number[] = field.color;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var value;
            var widget = this.itemAt(this._defaultIndex);
            if (widget && widget.color) {
                value = widget.color;
            }
            else if (this._defaultAppearance) {
                value = this._da.color;
            }
            return value;
        },
        /**
         * Sets the fore color of the field.
         *
         * @param {number[]} value R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets the fore color of the field.
         * field.color = [255, 0, 0];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            var widget = this.itemAt(this._defaultIndex);
            if (widget && widget.color && _isNullOrUndefined(value)) {
                widget.color = value;
            }
            else {
                var isNew = false;
                if (!this._defaultAppearance) {
                    this._da = new _PdfDefaultAppearance('');
                    isNew = true;
                }
                if (isNew || this._da.color !== value) {
                    this._da.color = value;
                    this._dictionary.update('DA', this._da.toString());
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "backColor", {
        /**
         * Gets the background color of the field.
         *
         * @returns {number[]} R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the background color of the field.
         * let backColor: number[] = field.backColor;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._parseBackColor(false);
        },
        /**
         * Sets the background color of the field.
         *
         * @param {number[]} value R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets the background color of the field.
         * field.backColor = [255, 0, 0];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._updateBackColor(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "borderColor", {
        /**
         * Gets the border color of the field.
         *
         * @returns {number[]} R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the border color of the field.
         * let borderColor: number[] = field.borderColor;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._parseBorderColor(true);
        },
        /**
         * Sets the border color of the field.
         *
         * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets the border color of the field.
         * field.borderColor = [255, 0, 0];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._updateBorderColor(value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "readOnly", {
        /**
         * Gets a value indicating whether read only.
         *
         * @returns {boolean} read only or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets a value indicating whether read only.
         * let readOnly: boolean = field.readOnly;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return (this._fieldFlags & _FieldFlag.readOnly) !== 0;
        },
        /**
         * Sets a value indicating whether read only.
         *
         * @param {boolean} value read only or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets a value indicating whether read only.
         * field.readOnly = true;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                this._fieldFlags |= _FieldFlag.readOnly;
            }
            else {
                if (this._fieldFlags === _FieldFlag.readOnly) {
                    this._fieldFlags |= _FieldFlag.default;
                }
                this._fieldFlags &= ~_FieldFlag.readOnly;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "required", {
        /**
         * Gets a value indicating whether the field is required.
         *
         * @returns {boolean} required or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets a value indicating whether the field is required.
         * let required: boolean = field.required;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return (this._fieldFlags & _FieldFlag.required) !== 0;
        },
        /**
         * Sets a value indicating whether the field is required.
         *
         * @param {boolean} value required or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets a value indicating whether the field is required.
         * field.required = true;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                this._fieldFlags |= _FieldFlag.required;
            }
            else {
                this._fieldFlags &= ~_FieldFlag.required;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "visible", {
        /**
         * Gets a value indicating the visibility of the field (Read only).
         *
         * @returns {boolean} visible or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets a value indicating the visibility of the field.
         * let visible: boolean = field.visible;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoaded) {
                var widget = this.itemAt(this._defaultIndex);
                var flag = PdfAnnotationFlag.default;
                if (widget && widget._hasFlags) {
                    flag = widget.flags;
                }
                else if (this._dictionary.has('F')) {
                    flag = this._dictionary.get('F');
                }
                return flag !== PdfAnnotationFlag.hidden;
            }
            else {
                return this._visible;
            }
        },
        /**
         * Sets a value indicating the visibility of the field.
         * Only applicable for newly created PDF form fields.
         *
         * @param {boolean} value or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets a value indicating the visibility of the field
         * field.visible = true;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (!this._isLoaded && this._visible !== value && !value) {
                this._visible = value;
                this.itemAt(this._defaultIndex).flags = PdfAnnotationFlag.hidden;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "border", {
        /**
         * Gets the width, style and dash of the border of the field.
         *
         * @returns {PdfInteractiveBorder} Border properties.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the width, style and dash of the border of the field.
         * let border: PdfInteractiveBorder = field.border;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var widget = this.itemAt(this._defaultIndex);
            var value;
            if (widget && widget._dictionary.has('BS')) {
                value = widget.border;
            }
            else {
                value = new PdfInteractiveBorder();
                if (!(this instanceof PdfButtonField)) {
                    value._width = 0;
                }
                value._dictionary = this._dictionary;
                if (this._dictionary !== null && typeof this._dictionary !== 'undefined' && this._dictionary.has('BS')) {
                    var border = this._dictionary.get('BS');
                    if (border) {
                        if (border.has('W')) {
                            value._width = border.get('W');
                        }
                        if (border.has('S')) {
                            var borderStyle = border.get('S');
                            if (borderStyle) {
                                switch (borderStyle.name) {
                                    case 'D':
                                        value._style = PdfBorderStyle.dashed;
                                        break;
                                    case 'B':
                                        value._style = PdfBorderStyle.beveled;
                                        break;
                                    case 'I':
                                        value._style = PdfBorderStyle.inset;
                                        break;
                                    case 'U':
                                        value._style = PdfBorderStyle.underline;
                                        break;
                                    default:
                                        value._style = PdfBorderStyle.solid;
                                        break;
                                }
                            }
                        }
                        if (border.has('D')) {
                            value._dash = border.getArray('D');
                        }
                    }
                }
            }
            return value;
        },
        /**
         * Sets the width, style and dash of the border of the field.
         *
         * @param {PdfInteractiveBorder} value Border properties.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets the width, style and dash of the border of the field.
         * field.border = new PdfInteractiveBorder(2, PdfBorderStyle.solid);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            var widget = this.itemAt(this._defaultIndex);
            if (widget) {
                this._updateBorder(widget._dictionary, value);
            }
            else {
                this._updateBorder(this._dictionary, value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "rotationAngle", {
        /**
         * Gets the rotation of the field (Read only).
         *
         * @returns {PdfRotationAngle} Rotation angle.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the rotation of the field.
         * let rotate: PdfRotationAngle = field.rotationAngle;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var value = PdfRotationAngle.angle0;
            var widget = this.itemAt(this._defaultIndex);
            if (widget) {
                value = widget.rotationAngle;
            }
            return value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "export", {
        /**
         * Gets a value indicating whether the field is allow to export data or not.
         *
         * @returns {boolean} Allow to export data or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets a value indicating whether the field is allow to export data or not.
         * let export: boolean = field.export;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return !((this._fieldFlags & _FieldFlag.noExport) !== 0);
        },
        /**
         * Sets a value indicating whether the field is allow to export data or not.
         *
         * @param {boolean} value Allow to export data or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets a value indicating whether the field is allow to export data or not.
         * field.export = true;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                this._fieldFlags &= ~_FieldFlag.noExport;
            }
            else {
                this._fieldFlags |= _FieldFlag.noExport;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "tabIndex", {
        /**
         * Gets the tab index of annotation in current page.
         *
         * @returns {number} tab index.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the tab index of annotation in current page.
         * let tabIndex: number = field.tabIndex;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoaded) {
                var annots = void 0;
                if (this.page._pageDictionary.has('Annots')) {
                    annots = this.page._pageDictionary.get('Annots');
                }
                if (this._kids && this._kids.length > 0) {
                    for (var i = 0; i < this._kids.length; i++) {
                        var reference = this._kids[Number.parseInt(i.toString(), 10)];
                        if (reference) {
                            if (this.page._pageDictionary.has('Annots')) {
                                if (annots) {
                                    var index1 = annots.indexOf(reference);
                                    if (index1 !== -1) {
                                        return index1;
                                    }
                                }
                            }
                        }
                    }
                }
                else if (this._dictionary && this._dictionary.has('Subtype') && this._dictionary.get('Subtype').name === 'Widget') {
                    if (this._ref) {
                        if (annots) {
                            var index1 = annots.indexOf(this._ref);
                            if (index1 !== -1) {
                                return index1;
                            }
                        }
                    }
                }
                return -1;
            }
            else {
                return this._tabIndex;
            }
        },
        /**
         * Sets the tab index of a annotation in the current page.
         *
         * @param {number} value index.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets the tab index of annotation in current page.
         * field.tabIndex = 5;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._tabIndex = value;
            if (this._isLoaded) {
                var page = this.page;
                if (page &&
                    (page.tabOrder === PdfFormFieldsTabOrder.manual ||
                        (this.form && this.form._tabOrder === PdfFormFieldsTabOrder.manual))) {
                    if (page._pageDictionary.has('Annots')) {
                        var annots = page._pageDictionary.get('Annots');
                        var annotationCollection = new PdfAnnotationCollection(annots, this._crossReference, page);
                        page._annotations = annotationCollection;
                        var index = annots.indexOf(this._ref);
                        if (index < 0) {
                            index = this._annotationIndex;
                        }
                        var annotations = page.annotations._reArrange(this._ref, this._tabIndex, index);
                        page._pageDictionary.update('Annots', annotations);
                        page._pageDictionary._updated = true;
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "page", {
        /**
         * Gets the page object of the form field (Read only).
         *
         * @returns {PdfPage} Page object.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the page object of the form field.
         * let page: PdfPage = field.page;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._page) {
                var widget = this.itemAt(this._defaultIndex);
                var dictionary = (typeof widget !== 'undefined') ? widget._dictionary : this._dictionary;
                var document_1;
                if (this._crossReference) {
                    document_1 = this._crossReference._document;
                }
                var page = void 0;
                if (dictionary && dictionary.has('P')) {
                    var ref = dictionary.getRaw('P');
                    if (ref && document_1) {
                        for (var i = 0; i < document_1.pageCount; i++) {
                            var entry = document_1.getPage(i);
                            if (entry && entry._ref === ref) {
                                page = entry;
                                break;
                            }
                        }
                    }
                }
                if (!page && document_1) {
                    var widgetRef = (typeof widget !== 'undefined') ? widget._ref : this._ref;
                    if (!page && widgetRef) {
                        page = _findPage(document_1, widgetRef);
                    }
                    if (!page && this._kids && this._kids.length > 0) {
                        for (var i = 0; i < this._kids.length; i++) {
                            page = _findPage(document_1, this._kids[Number.parseInt(i.toString(), 10)]);
                            if (page) {
                                break;
                            }
                        }
                    }
                }
                this._page = page;
            }
            return this._page;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "flatten", {
        /**
         * Gets the boolean flag indicating whether the form field have been flattened or not.
         *
         * @returns {boolean} Flatten.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first field
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the boolean flag indicating whether the form field have been flattened or not.
         * let flatten: boolean = field.flatten;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._flatten;
        },
        /**
         * Sets the boolean flag indicating whether the form field have been flattened or not.
         *
         * @param {boolean} value Flatten.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first field
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets the boolean flag indicating whether the form field have been flattened or not.
         * field.flatten = true;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._flatten = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "_grayBrush", {
        get: function () {
            if (!this._gray) {
                this._gray = new PdfBrush([128, 128, 128]);
            }
            return this._gray;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "_silverBrush", {
        get: function () {
            if (!this._silver) {
                this._silver = new PdfBrush([198, 198, 198]);
            }
            return this._silver;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "_whiteBrush", {
        get: function () {
            if (!this._white) {
                this._white = new PdfBrush([255, 255, 255]);
            }
            return this._white;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "_blackBrush", {
        get: function () {
            if (!this._black) {
                this._black = new PdfBrush([0, 0, 0]);
            }
            return this._black;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "_kidsCount", {
        get: function () {
            return this._kids ? this._kids.length : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "_hasBackColor", {
        get: function () {
            if (this._isLoaded) {
                var mkDictionary = this._mkDictionary;
                if (!mkDictionary) {
                    var item = this.itemAt(this._defaultIndex);
                    if (item && item._dictionary.has('MK')) {
                        mkDictionary = item._dictionary.get('MK');
                    }
                }
                return (mkDictionary && mkDictionary.has('BG'));
            }
            else {
                return !this._isTransparentBackColor;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "_hasBorderColor", {
        get: function () {
            if (this._isLoaded) {
                var mkDictionary = this._mkDictionary;
                if (!mkDictionary) {
                    var item = this.itemAt(this._defaultIndex);
                    if (item && item._dictionary.has('MK')) {
                        mkDictionary = item._dictionary.get('MK');
                    }
                }
                return (mkDictionary && mkDictionary.has('BC'));
            }
            else {
                return !this._isTransparentBorderColor;
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfField.prototype._parseBackColor = function (hasTransparency) {
        var value;
        if ((!hasTransparency) || ((this._isLoaded && this._hasBackColor) || (!this._isLoaded && !this._isTransparentBackColor))) {
            var widget = this.itemAt(this._defaultIndex);
            if (widget && widget.backColor) {
                value = widget.backColor;
            }
            else if (this._mkDictionary) {
                var mkDict = this._mkDictionary;
                if (mkDict && mkDict.has('BG')) {
                    var bgArray = mkDict.getArray('BG');
                    if (bgArray) {
                        value = _parseColor(bgArray);
                    }
                }
            }
            if (typeof value === 'undefined' || value === null) {
                value = [255, 255, 255];
            }
        }
        return value;
    };
    PdfField.prototype._parseBorderColor = function (hasTransparency) {
        var value;
        if ((!hasTransparency) || ((this._isLoaded && this._hasBorderColor) || (!this._isLoaded && !this._isTransparentBorderColor))) {
            var widget = this.itemAt(this._defaultIndex);
            if (widget && widget.borderColor) {
                value = widget.borderColor;
            }
            else if (this._mkDictionary) {
                var mkDict = this._mkDictionary;
                if (mkDict.has('BC')) {
                    var bgArray = mkDict.getArray('BC');
                    if (bgArray) {
                        value = _parseColor(bgArray);
                    }
                }
            }
            if (typeof value === 'undefined' || value === null) {
                value = [0, 0, 0];
            }
        }
        return value;
    };
    PdfField.prototype._updateBackColor = function (value, hasTransparency) {
        if (hasTransparency === void 0) { hasTransparency = false; }
        if (hasTransparency && _isNullOrUndefined(value) && value.length === 4 && value[3] !== 255) {
            this._isTransparentBackColor = true;
            if (this._dictionary && this._dictionary.has('BG')) {
                delete this._dictionary._map.BG;
            }
            var mkDictionary = this._mkDictionary;
            if (mkDictionary && mkDictionary.has('BG')) {
                delete mkDictionary._map.BG;
                this._dictionary._updated = true;
            }
            var item = this.itemAt(this._defaultIndex);
            if (item) {
                item.backColor = value;
            }
        }
        else {
            this._isTransparentBackColor = false;
            var widget = this.itemAt(this._defaultIndex);
            if (widget && widget.backColor !== value) {
                widget.backColor = value;
            }
            else {
                var mkDictionary = this._mkDictionary;
                if (typeof mkDictionary === 'undefined') {
                    var dictionary = new _PdfDictionary(this._crossReference);
                    dictionary.update('BG', [Number.parseFloat((value[0] / 255).toFixed(3)),
                        Number.parseFloat((value[1] / 255).toFixed(3)),
                        Number.parseFloat((value[2] / 255).toFixed(3))]);
                    this._dictionary.update('MK', dictionary);
                }
                else if (!mkDictionary.has('BG') || _parseColor(mkDictionary.getArray('BG')) !== value) {
                    mkDictionary.update('BG', [Number.parseFloat((value[0] / 255).toFixed(3)),
                        Number.parseFloat((value[1] / 255).toFixed(3)),
                        Number.parseFloat((value[2] / 255).toFixed(3))]);
                    this._dictionary._updated = true;
                }
            }
        }
    };
    PdfField.prototype._updateBorderColor = function (value, hasTransparency) {
        if (hasTransparency === void 0) { hasTransparency = false; }
        if (hasTransparency && value.length === 4 && value[3] !== 255) {
            this._isTransparentBorderColor = true;
            if (this._dictionary.has('BC')) {
                delete this._dictionary._map.BC;
            }
            var mkDictionary = this._mkDictionary;
            if (mkDictionary && mkDictionary.has('BC')) {
                delete mkDictionary._map.BC;
                if (this._dictionary.has('BS')) {
                    var bsDictionary = this._dictionary.get('BS');
                    if (bsDictionary && bsDictionary.has('W')) {
                        delete bsDictionary._map.W;
                    }
                }
                this._dictionary._updated = true;
            }
            var item = this.itemAt(this._defaultIndex);
            if (item) {
                item.borderColor = value;
            }
        }
        else {
            this._isTransparentBorderColor = false;
            var widget = this.itemAt(this._defaultIndex);
            if (widget && widget.borderColor !== value) {
                widget.borderColor = value;
            }
            else {
                var mkDictionary = this._mkDictionary;
                if (typeof mkDictionary === 'undefined') {
                    var dictionary = new _PdfDictionary(this._crossReference);
                    dictionary.update('BC', [Number.parseFloat((value[0] / 255).toFixed(3)),
                        Number.parseFloat((value[1] / 255).toFixed(3)),
                        Number.parseFloat((value[2] / 255).toFixed(3))]);
                    this._dictionary.update('MK', dictionary);
                }
                else if (!mkDictionary.has('BC') || _parseColor(mkDictionary.getArray('BC')) !== value) {
                    mkDictionary.update('BC', [Number.parseFloat((value[0] / 255).toFixed(3)),
                        Number.parseFloat((value[1] / 255).toFixed(3)),
                        Number.parseFloat((value[2] / 255).toFixed(3))]);
                    this._dictionary._updated = true;
                }
            }
        }
    };
    /**
     * Gets the field item as `PdfWidgetAnnotation` at the specified index.
     *
     * @param {number} index Item index.
     * @returns {PdfWidgetAnnotation} Loaded PDF form field item at the specified index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the loaded form field
     * let field: PdfField = document.form.fieldAt(0);
     * // Access the count of the field items.
     * let count: number = field.count;
     * // Access the first item
     * let item: PdfWidgetAnnotation = field.itemAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfField.prototype.itemAt = function (index) {
        var item;
        if (index >= 0 && index < this._kidsCount) {
            if (this._parsedItems.has(index)) {
                item = this._parsedItems.get(index);
            }
            else {
                var dictionary = void 0;
                var reference = this._kids[Number.parseInt(index.toString(), 10)];
                if (reference && reference instanceof _PdfReference) {
                    dictionary = this._crossReference._fetch(reference);
                }
                if (dictionary) {
                    item = PdfWidgetAnnotation._load(dictionary, this._crossReference);
                    item._ref = reference;
                    this._parsedItems.set(index, item);
                }
            }
        }
        return item;
    };
    /**
     * Sets the flag to indicate the new appearance creation.
     *
     * @param {boolean} value Set appearance.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Set boolean flag to create a new appearance stream for form fields.
     * document.form.fieldAt(0).setAppearance(true);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfField.prototype.setAppearance = function (value) {
        this._setAppearance = value;
    };
    /**
     * Gets the value associated with the specified key.
     *
     * @param {string} name Key.
     * @returns {string} Value associated with the key.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the value associated with the key 'Author'.
     * let value: string = document.form.fieldAt(0).getValue('Author');
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfField.prototype.getValue = function (name) {
        var value;
        if (this._dictionary && this._dictionary.has(name)) {
            var element = this._dictionary.get(name); // eslint-disable-line
            if (element !== null && typeof element !== 'undefined' && element instanceof _PdfName) {
                value = element.name;
            }
            else if (typeof element === 'string') {
                value = element;
            }
            else {
                throw new Error('PdfException: ' + name + ' is not found');
            }
        }
        else {
            throw new Error('PdfException: ' + name + ' is not found');
        }
        return value;
    };
    /**
     * Sets the value associated with the specified key.
     *
     * @param {string} name Key.
     * @param {string} value Value associated with the key..
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Set custom value
     * field.setValue('Author', 'John');
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfField.prototype.setValue = function (name, value) {
        if (name && name !== '' && value && value !== '') {
            this._dictionary.update(name, value);
        }
    };
    /**
     * Remove the form field item from the specified index.
     *
     * @param {number} index Item index to remove.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Remove the first item of the form field
     * field.removeItemAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfField.prototype.removeItemAt = function (index) {
        if (this._dictionary !== null && typeof this._dictionary !== 'undefined' && this._dictionary.has('Kids') && this.itemsCount > 0) {
            var item = this.itemAt(index);
            if (item && item._ref) {
                var page = item._getPage();
                if (page) {
                    page._removeAnnotation(item._ref);
                }
                this._kids.splice(index, 1);
                this._dictionary.set('Kids', this._kids);
                this._dictionary._updated = true;
                this._parsedItems.delete(index);
                if (this._parsedItems.size > 0) {
                    var parsedItems_1 = new Map();
                    this._parsedItems.forEach(function (value, key) {
                        if (key > index) {
                            parsedItems_1.set(key - 1, value);
                        }
                        else {
                            parsedItems_1.set(key, value);
                        }
                    });
                    this._parsedItems = parsedItems_1;
                }
            }
        }
    };
    /**
     * Remove the specified form field item.
     *
     * @param {PdfWidgetAnnotation} item Item to remove.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Remove the first item of the form field
     * field.removeItem(field.itemAt(0));
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfField.prototype.removeItem = function (item) {
        if (item && item._ref) {
            var index = this._kids.indexOf(item._ref);
            if (index !== -1) {
                this.removeItemAt(index);
            }
        }
    };
    Object.defineProperty(PdfField.prototype, "_fieldFlags", {
        get: function () {
            if (typeof this._flags === 'undefined') {
                this._flags = _getInheritableProperty(this._dictionary, 'Ff', false, true, 'Parent');
                if (typeof this._flags === 'undefined') {
                    this._flags = _FieldFlag.default;
                }
            }
            return this._flags;
        },
        set: function (value) {
            if (this._fieldFlags !== value) {
                this._flags = value;
                this._dictionary.update('Ff', value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "_defaultAppearance", {
        get: function () {
            if (typeof this._da === 'undefined') {
                var da = _getInheritableProperty(this._dictionary, 'DA', false, true, 'Parent');
                if (da && da !== '') {
                    this._da = new _PdfDefaultAppearance(da);
                }
            }
            return this._da;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfField.prototype, "_mkDictionary", {
        get: function () {
            var value;
            if (this._dictionary && this._dictionary.has('MK')) {
                value = this._dictionary.get('MK');
            }
            return value;
        },
        enumerable: true,
        configurable: true
    });
    PdfField.prototype._updateBorder = function (dictionary, value) {
        var bs;
        var isNew = false;
        if (dictionary && dictionary.has('BS')) {
            bs = dictionary.get('BS');
        }
        else {
            bs = new _PdfDictionary(this._crossReference);
            dictionary.update('BS', bs);
            isNew = true;
        }
        if (typeof value.width !== 'undefined') {
            bs.update('W', value.width);
            dictionary._updated = true;
        }
        else if (isNew) {
            bs.update('W', 0);
        }
        if (typeof value.style !== 'undefined') {
            bs.update('S', _mapBorderStyle(value.style));
            dictionary._updated = true;
        }
        else if (isNew) {
            bs.update('S', _mapBorderStyle(PdfBorderStyle.solid));
        }
        if (typeof value.dash !== 'undefined') {
            bs.update('D', value.dash);
            dictionary._updated = true;
        }
    };
    PdfField.prototype._checkFieldFlag = function (dictionary) {
        var flag = dictionary.get('F');
        return (typeof flag !== 'undefined' && flag === 6);
    };
    PdfField.prototype._initializeFont = function (font) {
        this._font = font;
        var document = this._crossReference._document;
        var resource;
        if (document) {
            if (document.form._dictionary.has('DR')) {
                resource = document.form._dictionary.get('DR');
            }
            else {
                resource = new _PdfDictionary(this._crossReference);
            }
        }
        var fontDict;
        var isReference = false;
        if (resource && resource.has('Font')) {
            var obj = resource.getRaw('Font'); // eslint-disable-line
            if (obj && obj instanceof _PdfReference) {
                isReference = true;
                fontDict = this._crossReference._fetch(obj);
            }
            else if (obj instanceof _PdfDictionary) {
                fontDict = obj;
            }
        }
        if (!fontDict) {
            fontDict = new _PdfDictionary(this._crossReference);
            resource.update('Font', fontDict);
        }
        var keyName;
        var reference;
        var hasFont = false;
        if (this._font && (this._font._key !== null && typeof this._font._key !== 'undefined') && this._font._reference) {
            keyName = _PdfName.get(this._font._key);
            reference = this._font._reference;
            hasFont = true;
        }
        else {
            keyName = _PdfName.get(_getNewGuidString());
            reference = this._crossReference._getNextReference();
            if (this._font) {
                this._font._key = keyName.name;
                this._font._reference = reference;
            }
        }
        if (reference && !hasFont) {
            if (font instanceof PdfTrueTypeFont) {
                if (this._font._pdfFontInternals) {
                    this._crossReference._cacheMap.set(reference, this._font._pdfFontInternals);
                    this._font._reference = reference;
                }
            }
            else if (this._font._dictionary) {
                this._crossReference._cacheMap.set(reference, this._font._dictionary);
                fontDict.update(keyName.name, reference);
                resource._updated = true;
                document.form._dictionary.update('DR', resource);
                document.form._dictionary._updated = true;
            }
        }
        fontDict.update(keyName.name, reference);
        resource._updated = true;
        document.form._dictionary.update('DR', resource);
        document.form._dictionary._updated = true;
        this._fontName = keyName.name;
        var defaultAppearance = new _PdfDefaultAppearance();
        defaultAppearance.fontName = this._fontName;
        defaultAppearance.fontSize = this._font._size;
        defaultAppearance.color = this.color ? this.color : [0, 0, 0];
        if (this._dictionary.has('Kids')) {
            var widgetDictionary = this._dictionary.getArray('Kids');
            for (var i = 0; i < widgetDictionary.length; i++) {
                var widget = this.itemAt(i);
                var dictionary = widgetDictionary[Number.parseInt(i.toString(), 10)];
                dictionary.update('DA', defaultAppearance.toString());
                if (widget) {
                    widget._da = defaultAppearance;
                }
            }
        }
        else if (this._dictionary.has('Subtype') && this._dictionary.get('Subtype').name === 'Widget') {
            this._dictionary.update('DA', defaultAppearance.toString());
        }
        if (isReference) {
            resource._updated = true;
        }
    };
    PdfField.prototype._drawRectangularControl = function (g, parameter) {
        g.drawRectangle(parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3], parameter.backBrush);
        this._drawBorder(g, parameter.bounds, parameter.borderPen, parameter.borderStyle, parameter.borderWidth);
        switch (parameter.borderStyle) {
            case PdfBorderStyle.inset:
                this._drawLeftTopShadow(g, parameter.bounds, parameter.borderWidth, this._grayBrush);
                this._drawRightBottomShadow(g, parameter.bounds, parameter.borderWidth, this._silverBrush);
                break;
            case PdfBorderStyle.beveled:
                this._drawLeftTopShadow(g, parameter.bounds, parameter.borderWidth, this._whiteBrush);
                this._drawRightBottomShadow(g, parameter.bounds, parameter.borderWidth, parameter.shadowBrush);
                break;
        }
    };
    PdfField.prototype._drawBorder = function (g, bounds, borderPen, style, borderWidth) {
        if (borderPen && borderWidth > 0) {
            if (style === PdfBorderStyle.underline) {
                g.drawLine(borderPen, bounds[0], bounds[0] + bounds[3] - borderWidth / 2, bounds[0] + bounds[2], bounds[1] + bounds[3] - borderWidth / 2);
            }
            else {
                g.drawRectangle(bounds[0] + borderWidth / 2, bounds[1] + borderWidth / 2, bounds[2] - borderWidth, bounds[3] - borderWidth, borderPen);
            }
        }
    };
    PdfField.prototype._drawLeftTopShadow = function (g, bounds, width, brush) {
        var path = new PdfPath();
        var points = [];
        points.push([bounds[0] + width, bounds[1] + width]);
        points.push([bounds[0] + width, (bounds[1] + bounds[3]) - width]);
        points.push([bounds[0] + 2 * width, (bounds[1] + bounds[3]) - 2 * width]);
        points.push([bounds[0] + 2 * width, bounds[1] + 2 * width]);
        points.push([(bounds[0] + bounds[2]) - 2 * width, bounds[1] + 2 * width]);
        points.push([(bounds[0] + bounds[2]) - width, bounds[1] + width]);
        path.addPolygon(points);
        g.drawPath(path, brush);
    };
    PdfField.prototype._drawRightBottomShadow = function (g, bounds, width, brush) {
        var path = new PdfPath();
        var points = [];
        points.push([bounds[0] + width, (bounds[1] + bounds[3]) - width]);
        points.push([bounds[0] + 2 * width, (bounds[1] + bounds[3]) - 2 * width]);
        points.push([(bounds[0] + bounds[2]) - 2 * width, (bounds[1] + bounds[3]) - 2 * width]);
        points.push([(bounds[0] + bounds[2]) - 2 * width, bounds[1] + 2 * width]);
        points.push([bounds[0] + bounds[2] - width, bounds[1] + width]);
        points.push([(bounds[0] + bounds[2]) - width, (bounds[1] + bounds[3]) - width]);
        path.addPolygon(points);
        g.drawPath(path, brush);
    };
    PdfField.prototype._drawRadioButton = function (graphics, parameter, checkSymbol, state) {
        if (checkSymbol === 'l') {
            var bounds = parameter.bounds;
            var diameter = bounds[2];
            if (this._enableGrouping) {
                diameter = Math.min(bounds[2], bounds[3]);
            }
            switch (state) {
                case _PdfCheckFieldState.checked:
                case _PdfCheckFieldState.unchecked:
                    graphics.drawEllipse(bounds[0], bounds[1], diameter, bounds[3], parameter.backBrush);
                    break;
                case _PdfCheckFieldState.pressedChecked:
                case _PdfCheckFieldState.pressedUnchecked:
                    if ((parameter.borderStyle === PdfBorderStyle.beveled) || (parameter.borderStyle === PdfBorderStyle.underline)) {
                        graphics.drawEllipse(bounds[0], bounds[1], bounds[2], bounds[3], parameter.backBrush);
                    }
                    else {
                        graphics.drawEllipse(bounds[0], bounds[1], diameter, bounds[3], parameter.shadowBrush);
                    }
                    break;
            }
            this._drawRoundBorder(graphics, bounds, parameter.borderPen, parameter.borderWidth);
            this._drawRoundShadow(graphics, parameter, state);
            if (state === _PdfCheckFieldState.checked || state === _PdfCheckFieldState.pressedChecked) {
                var outward = [bounds[0] + parameter.borderWidth / 2,
                    bounds[1] + parameter.borderWidth / 2,
                    diameter - parameter.borderWidth,
                    bounds[3] - parameter.borderWidth];
                graphics.drawEllipse(outward[0] + (outward[2] / 4), outward[1] + (outward[2] / 4), outward[2] - (outward[2] / 2), outward[3] - (outward[2] / 2), parameter.foreBrush);
            }
        }
        else {
            this._drawCheckBox(graphics, parameter, checkSymbol, state);
        }
    };
    PdfField.prototype._drawRoundBorder = function (graphics, bounds, borderPen, borderWidth) {
        if (bounds[0] !== 0 || bounds[1] !== 0 || bounds[2] !== 0 || bounds[3] !== 0) {
            graphics.drawEllipse(bounds[0] + borderWidth / 2, bounds[1] + borderWidth / 2, (this._enableGrouping ?
                Math.min(bounds[2], bounds[3]) : bounds[2]) - borderWidth, bounds[3] - borderWidth, borderPen);
        }
    };
    PdfField.prototype._drawRoundShadow = function (graphics, parameter, state) {
        var borderWidth = parameter.borderWidth;
        var inflateValue = -1.5 * borderWidth;
        var x = parameter.bounds[0] + inflateValue;
        var y = parameter.bounds[1] + inflateValue;
        var width = parameter.bounds[2] + (2 * inflateValue);
        var height = parameter.bounds[3] + (2 * inflateValue);
        var shadowBrush = parameter.shadowBrush;
        if (shadowBrush) {
            var shadowColor = shadowBrush._color;
            var leftTop = void 0;
            var rightBottom = void 0;
            switch (parameter.borderStyle) {
                case PdfBorderStyle.beveled:
                    switch (state) {
                        case _PdfCheckFieldState.pressedChecked:
                        case _PdfCheckFieldState.pressedUnchecked:
                            leftTop = new PdfPen(shadowColor, borderWidth);
                            rightBottom = new PdfPen([255, 255, 255], borderWidth);
                            break;
                        case _PdfCheckFieldState.checked:
                        case _PdfCheckFieldState.unchecked:
                            leftTop = new PdfPen([255, 255, 255], borderWidth);
                            rightBottom = new PdfPen(shadowColor, borderWidth);
                            break;
                    }
                    break;
                case PdfBorderStyle.inset:
                    switch (state) {
                        case _PdfCheckFieldState.pressedChecked:
                        case _PdfCheckFieldState.pressedUnchecked:
                            leftTop = new PdfPen([0, 0, 0], borderWidth);
                            rightBottom = new PdfPen([0, 0, 0], borderWidth);
                            break;
                        case _PdfCheckFieldState.checked:
                        case _PdfCheckFieldState.unchecked:
                            leftTop = new PdfPen([128, 128, 128], borderWidth);
                            rightBottom = new PdfPen([192, 192, 192], borderWidth);
                            break;
                    }
                    break;
            }
            if (leftTop && rightBottom) {
                graphics.drawArc(x, y, width, height, 135, 180, leftTop);
                graphics.drawArc(x, y, width, height, -45, 180, rightBottom);
            }
        }
    };
    PdfField.prototype._drawCheckBox = function (graphics, parameter, checkSymbol, state, font) {
        switch (state) {
            case _PdfCheckFieldState.unchecked:
            case _PdfCheckFieldState.checked:
                if (parameter.borderPen || parameter.backBrush) {
                    graphics.drawRectangle(parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3], parameter.backBrush);
                }
                break;
            case _PdfCheckFieldState.pressedChecked:
            case _PdfCheckFieldState.pressedUnchecked:
                if ((parameter.borderStyle === PdfBorderStyle.beveled || parameter.backBrush) ||
                    (parameter.borderStyle === PdfBorderStyle.underline)) {
                    if (parameter.borderPen || parameter.backBrush) {
                        graphics.drawRectangle(parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3], parameter.backBrush);
                    }
                }
                else if (parameter.borderPen || parameter.shadowBrush) {
                    graphics.drawRectangle(parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3], parameter.shadowBrush);
                }
                break;
        }
        var rectangle = parameter.bounds;
        this._drawBorder(graphics, parameter.bounds, parameter.borderPen, parameter.borderStyle, parameter.borderWidth);
        if ((state === _PdfCheckFieldState.pressedChecked) || (state === _PdfCheckFieldState.pressedUnchecked)) {
            switch (parameter.borderStyle) {
                case PdfBorderStyle.inset:
                    this._drawLeftTopShadow(graphics, parameter.bounds, parameter.borderWidth, this._blackBrush);
                    this._drawRightBottomShadow(graphics, parameter.bounds, parameter.borderWidth, this._whiteBrush);
                    break;
                case PdfBorderStyle.beveled:
                    this._drawLeftTopShadow(graphics, parameter.bounds, parameter.borderWidth, parameter.shadowBrush);
                    this._drawRightBottomShadow(graphics, parameter.bounds, parameter.borderWidth, this._whiteBrush);
                    break;
            }
        }
        else {
            switch (parameter.borderStyle) {
                case PdfBorderStyle.inset:
                    this._drawLeftTopShadow(graphics, parameter.bounds, parameter.borderWidth, this._grayBrush);
                    this._drawRightBottomShadow(graphics, parameter.bounds, parameter.borderWidth, this._silverBrush);
                    break;
                case PdfBorderStyle.beveled:
                    this._drawLeftTopShadow(graphics, parameter.bounds, parameter.borderWidth, this._whiteBrush);
                    this._drawRightBottomShadow(graphics, parameter.bounds, parameter.borderWidth, parameter.shadowBrush);
                    break;
            }
        }
        var yOffset = 0;
        var size = 0;
        switch (state) {
            case _PdfCheckFieldState.pressedChecked:
            case _PdfCheckFieldState.checked:
                if (!font) {
                    var extraBorder = parameter.borderStyle === PdfBorderStyle.beveled ||
                        parameter.borderStyle === PdfBorderStyle.inset;
                    var borderWidth = parameter.borderWidth;
                    if (extraBorder) {
                        borderWidth *= 2;
                    }
                    var xPosition = Math.max((extraBorder ? 2 * parameter.borderWidth : parameter.borderWidth), 1);
                    var xOffset = Math.min(borderWidth, xPosition);
                    size = (parameter.bounds[2] > parameter.bounds[3]) ? parameter.bounds[3] : parameter.bounds[2];
                    var fontSize = size - 2 * xOffset;
                    font = new PdfStandardFont(PdfFontFamily.zapfDingbats, fontSize);
                    if (parameter.bounds[2] > parameter.bounds[3]) {
                        yOffset = ((parameter.bounds[3] - font._metrics._getHeight()) / 2);
                    }
                }
                else {
                    font = new PdfStandardFont(PdfFontFamily.zapfDingbats, font._size);
                }
                if (size === 0) {
                    size = parameter.bounds[3];
                }
                if (parameter.pageRotationAngle !== PdfRotationAngle.angle0 || parameter.rotationAngle > 0) {
                    var state_1 = graphics.save();
                    var size_1 = graphics._size;
                    if (parameter.pageRotationAngle !== PdfRotationAngle.angle0) {
                        if (parameter.pageRotationAngle === PdfRotationAngle.angle90) {
                            graphics.translateTransform(size_1[1], 0);
                            graphics.rotateTransform(90);
                            var y = size_1[1] - (rectangle[0] + rectangle[2]);
                            var x = rectangle[1];
                            rectangle = [x, y, rectangle[3], rectangle[2]];
                        }
                        else if (parameter.pageRotationAngle === PdfRotationAngle.angle180) {
                            graphics.translateTransform(size_1[0], size_1[1]);
                            graphics.rotateTransform(-180);
                            var x = size_1[0] - (rectangle[0] + rectangle[2]);
                            var y = size_1[1] - (rectangle[1] + rectangle[3]);
                            rectangle = [x, y, rectangle[2], rectangle[3]];
                        }
                        else if (parameter.pageRotationAngle === PdfRotationAngle.angle270) {
                            graphics.translateTransform(0, size_1[0]);
                            graphics.rotateTransform(270);
                            var x = size_1[0] - (rectangle[1] + rectangle[3]);
                            var y = rectangle[0];
                            rectangle = [x, y, rectangle[3], rectangle[2]];
                        }
                    }
                    if (parameter.rotationAngle > 0) {
                        if (parameter.rotationAngle === 90) {
                            if (parameter.pageRotationAngle === PdfRotationAngle.angle90) {
                                graphics.translateTransform(0, size_1[1]);
                                graphics.rotateTransform(-90);
                                var x = size_1[1] - (rectangle[1] + rectangle[3]);
                                var y = rectangle[0];
                                rectangle = [x, y, rectangle[3], rectangle[2]];
                            }
                            else {
                                if (rectangle[2] > rectangle[3]) {
                                    graphics.translateTransform(0, size_1[1]);
                                    graphics.rotateTransform(-90);
                                    rectangle = [parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3]];
                                }
                                else {
                                    var z = rectangle[0];
                                    rectangle[0] = -(rectangle[1] + rectangle[3]);
                                    rectangle[1] = z;
                                    var height = rectangle[3];
                                    rectangle[3] = rectangle[2] > font._metrics._getHeight() ? rectangle[2] : font._metrics._getHeight();
                                    rectangle[2] = height;
                                    graphics.rotateTransform(-90);
                                    rectangle = [rectangle[0], rectangle[1], rectangle[2], rectangle[3]];
                                }
                            }
                        }
                        else if (parameter.rotationAngle === 270) {
                            graphics.translateTransform(size_1[0], 0);
                            graphics.rotateTransform(-270);
                            var x = rectangle[1];
                            var y = size_1[0] - (rectangle[0] + rectangle[2]);
                            rectangle = [x, y, rectangle[3], rectangle[2]];
                        }
                        else if (parameter.rotationAngle === 180) {
                            graphics.translateTransform(size_1[0], size_1[1]);
                            graphics.rotateTransform(-180);
                            var x = size_1[0] - (rectangle[0] + rectangle[2]);
                            var y = size_1[1] - (rectangle[1] + rectangle[3]);
                            rectangle = [x, y, rectangle[2], rectangle[3]];
                        }
                        graphics.drawString(checkSymbol, font, [rectangle[0], rectangle[1] - yOffset, rectangle[2], rectangle[3]], null, parameter.foreBrush, new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle));
                        graphics.restore(state_1);
                    }
                    else {
                        graphics.drawString(checkSymbol, font, [rectangle[0], rectangle[1] - yOffset, rectangle[2], rectangle[3]], null, parameter.foreBrush, new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle));
                    }
                    break;
                }
        }
    };
    PdfField.prototype._addToKid = function (item) {
        if (this._dictionary && this._dictionary.has('Kids')) {
            this._kids = this._dictionary.get('Kids');
        }
        else {
            this._kids = [];
            this._dictionary.update('Kids', this._kids);
            this._parsedItems = new Map();
        }
        if (this._kids.indexOf(item._ref) === -1) {
            var currentIndex = this._kidsCount;
            item._index = currentIndex;
            this._kids.push(item._ref);
            this._parsedItems.set(currentIndex, item);
        }
    };
    PdfField.prototype._drawTemplate = function (template, page, bounds) {
        if (template && page) {
            var graphics = page.graphics;
            graphics.save();
            if (page.rotation === PdfRotationAngle.angle90) {
                graphics.translateTransform(graphics._size[1], 0);
                graphics.rotateTransform(90);
            }
            else if (page.rotation === PdfRotationAngle.angle180) {
                graphics.translateTransform(graphics._size[0], graphics._size[1]);
                graphics.rotateTransform(-180);
            }
            else if (page.rotation === PdfRotationAngle.angle270) {
                graphics.translateTransform(0, graphics._size[0]);
                graphics.rotateTransform(270);
            }
            graphics._sw._setTextRenderingMode(_TextRenderingMode.fill);
            graphics.drawTemplate(template, bounds);
            graphics.restore();
        }
    };
    PdfField.prototype._addToOptions = function (item, field) {
        if (field instanceof PdfListBoxField) {
            field._listValues.push(item._text);
        }
        field._options.push([item._value, item._text]);
        field._dictionary.set('Opt', field._options);
        field._dictionary._updated = true;
        if (!item._isFont && item._pdfFont) {
            this._initializeFont(item._pdfFont);
        }
    };
    PdfField.prototype._addAppearance = function (dictionary, template, key) {
        var appearance = new _PdfDictionary();
        if (dictionary && dictionary.has('AP')) {
            appearance = dictionary.get('AP');
            _removeDuplicateReference(dictionary.get('AP'), this._crossReference, key);
        }
        else {
            appearance = new _PdfDictionary(this._crossReference);
            dictionary.update('AP', appearance);
        }
        var reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, template._content);
        appearance.update(key, reference);
    };
    PdfField.prototype._rotateTextBox = function (rect, size, angle) {
        var rectangle = [0, 0, 0, 0];
        if (angle === PdfRotationAngle.angle180) {
            rectangle = [size[0] - (rect[0] + rect[2]), size[1] - (rect[1] + rect[3]), rect[2], rect[3]];
        }
        else if (angle === PdfRotationAngle.angle270) {
            rectangle = [rect[1], size[0] - (rect[0] + rect[2]), rect[3], rect[2]];
        }
        else if (angle === PdfRotationAngle.angle90) {
            rectangle = [size[1] - (rect[1] + rect[3]), rect[0], rect[3], rect[2]];
        }
        return rectangle;
    };
    PdfField.prototype._checkIndex = function (value, length) {
        if (value < 0 || (value !== 0 && value >= length)) {
            throw Error('Index out of range.');
        }
    };
    PdfField.prototype._getAppearanceStateValue = function () {
        var value;
        if (this._dictionary && this._dictionary.has('Kids')) {
            for (var i = 0; i < this._kidsCount; i++) {
                var item = this.itemAt(i);
                if (item && item._dictionary && item._dictionary.has('AS')) {
                    var state = item._dictionary.get('AS');
                    if (state && state.name !== 'Off') {
                        value = state.name;
                        break;
                    }
                }
            }
        }
        else if (this._dictionary && this._dictionary.has('AS')) {
            var state = this._dictionary.get('AS');
            if (state && state.name !== 'Off') {
                value = state.name;
            }
        }
        return value;
    };
    PdfField.prototype._getTextAlignment = function () {
        if (this._textAlignment === null || typeof this._textAlignment === 'undefined') {
            if (this._isLoaded) {
                var widget = this.itemAt(this._defaultIndex);
                if (widget && widget._dictionary && widget._dictionary.has('Q')) {
                    this._textAlignment = widget._dictionary.get('Q');
                }
                else if (this._dictionary.has('Q')) {
                    this._textAlignment = this._dictionary.get('Q');
                }
                else {
                    this._textAlignment = PdfTextAlignment.left;
                }
            }
            else {
                this._textAlignment = PdfTextAlignment.left;
            }
        }
        return this._textAlignment;
    };
    PdfField.prototype._setTextAlignment = function (value) {
        var widget = this.itemAt(this._defaultIndex);
        if (this._isLoaded && !this.readOnly) {
            if (widget && widget._dictionary) {
                widget._dictionary.update('Q', value);
            }
            else {
                this._dictionary.update('Q', value);
            }
        }
        if (!this._isLoaded && this._textAlignment !== value) {
            if (widget && widget._dictionary) {
                widget._dictionary.update('Q', value);
            }
            else if (this._dictionary) {
                this._dictionary.update('Q', value);
            }
        }
        this._textAlignment = value;
        this._stringFormat = new PdfStringFormat(value, PdfVerticalAlignment.middle);
    };
    PdfField.prototype._parseItems = function () {
        var collection = [];
        for (var i = 0; i < this.itemsCount; i++) {
            collection.push(this.itemAt(i));
        }
        return collection;
    };
    return PdfField;
}());
/**
 * `PdfTextBoxField` class represents the text box field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access text box field
 * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfTextBoxField = /** @class */ (function (_super) {
    __extends$5(PdfTextBoxField, _super);
    function PdfTextBoxField(page, name, bounds) {
        var _this = _super.call(this) || this;
        _this._autoResizeText = false;
        if (page && name && bounds) {
            _this._initialize(page, name, bounds);
        }
        return _this;
    }
    /**
     * Parse an existing text box field.
     *
     * @private
     * @param {PdfForm} form Form object.
     * @param {_PdfDictionary} dictionary Field dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference object.
     * @param {_PdfReference} reference Field reference.
     * @returns {PdfTextBoxField} Text box field.
     */
    PdfTextBoxField._load = function (form, dictionary, crossReference, reference) {
        var field = new PdfTextBoxField();
        field._isLoaded = true;
        field._form = form;
        field._dictionary = dictionary;
        field._crossReference = crossReference;
        field._ref = reference;
        if (field._dictionary.has('Kids')) {
            field._kids = field._dictionary.get('Kids');
        }
        field._defaultIndex = 0;
        field._parsedItems = new Map();
        return field;
    };
    Object.defineProperty(PdfTextBoxField.prototype, "text", {
        /**
         * Gets the value of the text box field.
         *
         * @returns {string} Text.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Gets the text value from text box field
         * let text: string = field.text;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._text === 'undefined') {
                if (this._isLoaded) {
                    var text = _getInheritableProperty(this._dictionary, 'V', false, true, 'Parent');
                    if (text) {
                        this._text = _stringToPdfString(text);
                    }
                    else {
                        var widget = this.itemAt(this._defaultIndex);
                        if (widget) {
                            text = widget._dictionary.get('V');
                            if (text) {
                                this._text = _stringToPdfString(text);
                            }
                        }
                    }
                }
                else {
                    this._text = '';
                }
            }
            return this._text;
        },
        /**
         * Sets the value of the text box field.
         *
         * @param {string} value Text.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Sets the text value to text box field
         * field.text = ‘Syncfusion’;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._isLoaded) {
                if (!this.readOnly) {
                    if (!(this._dictionary.has('V') && this._dictionary.get('V') === value)) {
                        this._dictionary.update('V', value);
                    }
                    var widget = this.itemAt(this._defaultIndex);
                    if (widget && !(widget._dictionary.has('V') && widget._dictionary.get('V') === value)) {
                        widget._dictionary.update('V', value);
                    }
                }
            }
            else if (this._text !== value) {
                this._dictionary.update('V', value);
                this._text = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextBoxField.prototype, "textAlignment", {
        /**
         * Gets the text alignment in a text box.
         *
         * @returns {PdfTextAlignment} Text alignment.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Gets the text alignment from text box field
         * let alignment: PdfTextAlignment = field.textAlignment;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._getTextAlignment();
        },
        /**
         * Sets the text alignment in a text box.
         *
         * @param {PdfTextAlignment} value Text alignment.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Sets the text alignment of form field as center
         * field.textAlignment = PdfTextAlignment.center;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._textAlignment !== value) {
                this._setTextAlignment(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextBoxField.prototype, "defaultValue", {
        /**
         * Gets the default value of the field.
         *
         * @returns {string} Default value.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Gets the default value from the text box field
         * let value: string = field.defaultValue;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._defaultValue === 'undefined') {
                var text = _getInheritableProperty(this._dictionary, 'DV', false, true, 'Parent');
                if (text) {
                    this._defaultValue = text;
                }
            }
            return this._defaultValue;
        },
        /**
         * Sets the default value of the field.
         *
         * @param {string} value Default value.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Sets the default value of the text box field
         * field.defaultValue = 'Syncfusion';
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this.defaultValue) {
                this._dictionary.update('DV', value);
                this._defaultValue = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextBoxField.prototype, "multiLine", {
        /**
         * Gets a value indicating whether this `PdfTextBoxField` is multiline.
         *
         * @returns {boolean} multiline.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Gets a value indicating whether this `PdfTextBoxField` is multiline.
         * let multiLine: boolean = field.multiLine;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return (this._fieldFlags & _FieldFlag.multiLine) !== 0;
        },
        /**
         * Sets a value indicating whether this `PdfTextBoxField` is multiline.
         *
         * @param {boolean} value multiLine or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Sets a value indicating whether this `PdfTextBoxField` is multiline.
         * field.multiLine = false;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                this._fieldFlags |= _FieldFlag.multiLine;
            }
            else {
                this._fieldFlags &= ~_FieldFlag.multiLine;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextBoxField.prototype, "password", {
        /**
         * Gets a value indicating whether this `PdfTextBoxField` is password.
         *
         * @returns {boolean} password.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Gets a value indicating whether this `PdfTextBoxField` is password.
         * let password: boolean = field.password;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return (this._fieldFlags & _FieldFlag.password) !== 0;
        },
        /**
         * Sets a value indicating whether this `PdfTextBoxField` is password.
         *
         * @param {boolean} value password or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Sets a value indicating whether this `PdfTextBoxField` is password.
         * field.password = false;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                this._fieldFlags |= _FieldFlag.password;
            }
            else {
                this._fieldFlags &= ~_FieldFlag.password;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextBoxField.prototype, "scrollable", {
        /**
         * Gets a value indicating whether this `PdfTextBoxField` is scrollable.
         *
         * @returns {boolean} scrollable.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Gets a value indicating whether this `PdfTextBoxField` is scrollable.
         * let scrollable: boolean = field.scrollable;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return !((this._fieldFlags & _FieldFlag.doNotScroll) !== 0);
        },
        /**
         * Sets a value indicating whether this `PdfTextBoxField` is scrollable.
         *
         * @param {boolean} value scrollable or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Sets a value indicating whether this `PdfTextBoxField` is scrollable.
         * field.scrollable = false;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                this._fieldFlags &= ~_FieldFlag.doNotScroll;
            }
            else {
                this._fieldFlags |= _FieldFlag.doNotScroll;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextBoxField.prototype, "spellCheck", {
        /**
         * Gets a value indicating whether to check spelling.
         *
         * @returns {boolean} spellCheck.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Gets a value indicating whether to check spelling
         * let spellCheck: boolean = field.spellCheck;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return !((this._fieldFlags & _FieldFlag.doNotSpellCheck) !== 0);
        },
        /**
         * Sets a value indicating whether to check spelling.
         *
         * @param {boolean} value spellCheck or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Sets a value indicating whether to check spelling
         * field.spellCheck = false;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                this._fieldFlags &= ~_FieldFlag.doNotSpellCheck;
            }
            else {
                this._fieldFlags |= _FieldFlag.doNotSpellCheck;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextBoxField.prototype, "insertSpaces", {
        /**
         * Meaningful only if the MaxLength property is set and the Multiline, Password properties are false.
         * If set, the field is automatically divided into as many equally spaced positions, or combs,
         * as the value of MaxLength, and the text is laid out into those combs.
         *
         * @returns {boolean} insertSpaces.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Gets a value indicating whether this `PdfTextBoxField` is insertSpaces.
         * let insertSpaces: boolean = field.insertSpaces;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var flags = this._fieldFlags;
            return ((_FieldFlag.comb & flags) !== 0) &&
                ((flags & _FieldFlag.multiLine) === 0) &&
                ((flags & _FieldFlag.password) === 0) &&
                ((flags & _FieldFlag.fileSelect) === 0);
        },
        /**
         * Meaningful only if the MaxLength property is set and the Multiline, Password properties are false.
         * If set, the field is automatically divided into as many equally spaced positions, or combs,
         * as the value of MaxLength, and the text is laid out into those combs.
         *
         * @param {boolean} value insertSpaces.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Sets a value indicating whether this `PdfTextBoxField` is insertSpaces.
         * field.insertSpaces = false;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                this._fieldFlags |= _FieldFlag.comb;
            }
            else {
                this._fieldFlags &= ~_FieldFlag.comb;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextBoxField.prototype, "highlightMode", {
        /**
         * Gets the highlight mode of the field.
         *
         * @returns {PdfHighlightMode} highlight mode.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Gets the highlight mode of text box field
         * let mode: PdfHighlightMode = field.highlightMode;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var widget = this.itemAt(this._defaultIndex);
            var mode;
            if (widget && typeof widget.highlightMode !== 'undefined') {
                mode = widget.highlightMode;
            }
            else if (this._dictionary && this._dictionary.has('H')) {
                var name_4 = this._dictionary.get('H');
                mode = _mapHighlightMode(name_4.name);
            }
            return (typeof mode !== 'undefined') ? mode : PdfHighlightMode.noHighlighting;
        },
        /**
         * Sets the highlight mode of the field.
         *
         * @param {PdfHighlightMode} value highlight mode.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Sets the highlight mode of text box field as outline
         * field.highlightMode = PdfHighlightMode.outline;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            var widget = this.itemAt(this._defaultIndex);
            if (widget && (typeof widget.highlightMode === 'undefined' || widget.highlightMode !== value)) {
                widget.highlightMode = value;
            }
            else if (!this._dictionary.has('H') || _mapHighlightMode(this._dictionary.get('H')) !== value) {
                this._dictionary.update('H', _reverseMapHighlightMode(value));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextBoxField.prototype, "maxLength", {
        /**
         * Gets the maximum length of the field, in characters.
         *
         * @returns {number} maximum length.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Gets the maximum length of the field, in characters.
         * let maxLength: number = field.maxLength;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._maxLength === 'undefined') {
                var length_1 = _getInheritableProperty(this._dictionary, 'MaxLen', false, true, 'Parent');
                this._maxLength = (typeof length_1 !== 'undefined' && Number.isInteger(length_1)) ? length_1 : 0;
            }
            return this._maxLength;
        },
        /**
         * Sets the maximum length of the field, in characters.
         *
         * @param {number} value maximum length.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Sets the maximum length of the field, in characters.
         * field.maxLength = 20;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this.maxLength !== value) {
                this._dictionary.update('MaxLen', value);
                this._maxLength = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextBoxField.prototype, "isAutoResizeText", {
        /**
         * Gets the flag indicating whether the auto resize text enabled or not.
         * Note: Applicable only for newly created PDF fields.
         *
         * @returns {boolean} Enable or disable auto resize text.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Gets the flag indicating whether the auto resize text enabled or not.
         * let isAutoResize: boolean = field.isAutoResizeText;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._autoResizeText;
        },
        /**
         * Sets the flag indicating whether the auto resize text enabled or not.
         * Note: Applicable only for newly created PDF fields.
         *
         * @param {boolean} value Enable or disable auto resize text.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Sets the flag indicating whether the auto resize text enabled or not.
         * field.isAutoResizeText = false;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._autoResizeText = value;
            var widget = this.itemAt(this._defaultIndex);
            if (widget) {
                widget._isAutoResize = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextBoxField.prototype, "font", {
        /**
         * Gets the font of the field.
         *
         * @returns {PdfFont} font.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Gets the font of the field.
         * let font: PdfFont = field.font;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._font) {
                return this._font;
            }
            else {
                var widget = this.itemAt(this._defaultIndex);
                this._font = _obtainFontDetails(this._form, widget, this);
            }
            return this._font;
        },
        /**
         * Sets the font of the field.
         *
         * @param {PdfFont} value font.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Sets the font of the field
         * field.font = new PdfStandardFont(PdfFontFamily.helvetica, 12, PdfFontStyle.bold);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value && value instanceof PdfFont) {
                this._font = value;
                this._initializeFont(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextBoxField.prototype, "backColor", {
        /**
         * Gets the background color of the field.
         *
         * @returns {number[]} R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the background color of the field.
         * let backColor: number[] = field.backColor;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._parseBackColor(true);
        },
        /**
         * Sets the background color of the field.
         *
         * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the text box field at index 0
         * let firstName: PdfField = document.form.fieldAt(0);
         * // Sets the background color of the field.
         * firstName.backColor = [255, 0, 0];
         * // Access the text box field at index 1
         * let secondName: PdfField = document.form.fieldAt(1);
         * // Sets the background color of the field to transparent.
         * secondName.backColor = [0, 0, 0, 0];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._updateBackColor(value, true);
        },
        enumerable: true,
        configurable: true
    });
    PdfTextBoxField.prototype._initialize = function (page, name, bounds) {
        this._crossReference = page._crossReference;
        this._page = page;
        this._name = name;
        this._text = '';
        this._defaultValue = '';
        this._defaultIndex = 0;
        this._spellCheck = false;
        this._insertSpaces = false;
        this._multiline = false;
        this._password = false;
        this._scrollable = false;
        this._dictionary = new _PdfDictionary(this._crossReference);
        this._ref = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(this._ref, this._dictionary);
        this._dictionary.objId = this._ref.toString();
        this._dictionary.update('FT', _PdfName.get('Tx'));
        this._dictionary.update('T', name);
        this._fieldFlags |= _FieldFlag.doNotSpellCheck;
        this._createItem(bounds);
        this._initializeFont(this._defaultFont);
    };
    PdfTextBoxField.prototype._createItem = function (bounds) {
        var widget = new PdfWidgetAnnotation();
        widget._create(this._page, bounds, this);
        widget.textAlignment = PdfTextAlignment.left;
        this._stringFormat = new PdfStringFormat(widget.textAlignment, PdfVerticalAlignment.middle);
        widget._dictionary.update('MK', new _PdfDictionary(this._crossReference));
        widget._mkDictionary.update('BC', [0, 0, 0]);
        widget._mkDictionary.update('BG', [1, 1, 1]);
        widget._mkDictionary.update('CA', this.actualName);
        this._addToKid(widget);
    };
    PdfTextBoxField.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (isFlatten || this._setAppearance || this._form._setAppearance) {
            var count = this._kidsCount;
            if (this._isLoaded) {
                if (count > 0) {
                    for (var i = 0; i < count; i++) {
                        var item = this.itemAt(i);
                        if (item) {
                            this._postProcess(isFlatten, item);
                        }
                    }
                }
                else if ((isFlatten || this._form._setAppearance || this._setAppearance) && !this._checkFieldFlag(this._dictionary)) {
                    this._postProcess(isFlatten);
                }
            }
            else if (isFlatten || this._form._setAppearance || this._setAppearance) {
                for (var i = 0; i < count; i++) {
                    var item = this.itemAt(i);
                    if (item && !this._checkFieldFlag(item._dictionary)) {
                        var template = this._createAppearance(isFlatten, item);
                        if (isFlatten) {
                            this._drawTemplate(template, item._page, { x: item.bounds.x, y: item.bounds.y, width: template._size[0], height: template._size[1] });
                        }
                        else {
                            this._addAppearance(item._dictionary, template, 'N');
                        }
                        item._dictionary._updated = !isFlatten;
                    }
                }
            }
            if (isFlatten) {
                this._dictionary._updated = false;
            }
        }
    };
    PdfTextBoxField.prototype._postProcess = function (isFlatten, widget) {
        var template;
        var bounds;
        var source = widget ? widget : this;
        if ((widget !== null && typeof widget !== 'undefined' && widget._setAppearance && widget._enableGrouping) || this._form._setAppearance || this._setAppearance || (isFlatten && !source._dictionary.has('AP'))) {
            template = this._createAppearance(isFlatten, source);
        }
        else if (source._dictionary.has('AP')) {
            var appearanceStream = void 0;
            var dictionary = source._dictionary.get('AP');
            if (dictionary && dictionary.has('N')) {
                appearanceStream = dictionary.get('N');
                var reference = dictionary.getRaw('N');
                if (reference) {
                    appearanceStream.reference = reference;
                }
                if (appearanceStream) {
                    template = new PdfTemplate(appearanceStream, this._crossReference);
                }
            }
        }
        if (template) {
            if (isFlatten) {
                var page = source instanceof PdfWidgetAnnotation ? source._getPage() : source.page;
                if (page) {
                    var graphics = page.graphics;
                    graphics.save();
                    if (page.rotation === PdfRotationAngle.angle90) {
                        graphics.translateTransform(graphics._size[0], graphics._size[1]);
                        graphics.rotateTransform(90);
                    }
                    else if (page.rotation === PdfRotationAngle.angle180) {
                        graphics.translateTransform(graphics._size[0], graphics._size[1]);
                        graphics.rotateTransform(-180);
                    }
                    else if (page.rotation === PdfRotationAngle.angle270) {
                        graphics.translateTransform(graphics._size[0], graphics._size[1]);
                        graphics.rotateTransform(270);
                    }
                    bounds = { x: source.bounds.x, y: source.bounds.y, width: template._size[0], height: template._size[1] };
                    graphics.drawTemplate(template, bounds);
                    graphics.restore();
                }
                source._dictionary._updated = false;
            }
            else {
                this._addAppearance(source._dictionary, template, 'N');
            }
        }
    };
    PdfTextBoxField.prototype._createAppearance = function (isFlatten, widget) {
        var bounds = widget.bounds;
        var template = new PdfTemplate([0, 0, bounds.width, bounds.height], this._crossReference);
        _setMatrix(template, null);
        template._writeTransformation = false;
        var graphics = template.graphics;
        var parameter = new _PaintParameter();
        parameter.bounds = [0, 0, bounds.width, bounds.height];
        var backcolor = widget.backColor;
        if (backcolor) {
            parameter.backBrush = new PdfBrush(backcolor);
        }
        parameter.foreBrush = new PdfBrush(widget.color);
        var border = widget.border;
        if (widget.borderColor) {
            if (border.width === 0) {
                widget.borderColor = [255, 255, 255];
            }
            parameter.borderPen = new PdfPen(widget.borderColor, border.width);
        }
        parameter.borderWidth = border.width;
        parameter.borderStyle = border.style;
        if (backcolor) {
            var shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
            var color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                shadowColor[1] >= 0 ? shadowColor[1] : 0,
                shadowColor[2] >= 0 ? shadowColor[2] : 0];
            parameter.shadowBrush = new PdfBrush(color);
        }
        parameter.rotationAngle = widget.rotate;
        parameter.insertSpaces = this.insertSpaces;
        var text = this.text;
        var pdfFont;
        var stringFormat;
        var enableGrouping = false;
        if (text === null || typeof text === 'undefined') {
            text = '';
        }
        if (this.password) {
            var password = '';
            for (var i = 0; i < text.length; i++) {
                password += '*';
            }
            text = password;
        }
        if (this.maxLength && text.length > this.maxLength) {
            text = text.substring(0, this.maxLength);
        }
        parameter.required = this.required;
        if (!this.required) {
            graphics._sw._beginMarkupSequence('Tx');
            graphics._initializeCoordinates();
        }
        if (widget !== null && typeof widget !== 'undefined' && widget instanceof PdfWidgetAnnotation && widget._enableGrouping) {
            enableGrouping = true;
        }
        if (enableGrouping && widget.font !== null && typeof widget.font !== 'undefined') {
            pdfFont = widget.font;
            if (pdfFont.size === 0) {
                pdfFont._size = 8;
                pdfFont._fontMetrics._size = 0;
            }
        }
        else if (typeof this._font === 'undefined' || this._font === null) {
            this._font = this._defaultFont;
        }
        if (enableGrouping && widget.textAlignment !== null && typeof widget.textAlignment !== 'undefined') {
            stringFormat = stringFormat = new PdfStringFormat(widget.textAlignment, PdfVerticalAlignment.middle);
        }
        else if (typeof this._stringFormat === 'undefined' || this._stringFormat === null) {
            if (typeof this.textAlignment === 'undefined' || this.textAlignment === null) {
                this._stringFormat = new PdfStringFormat(this.textAlignment, PdfVerticalAlignment.middle);
            }
            else {
                this._stringFormat = new PdfStringFormat(PdfTextAlignment.left, PdfVerticalAlignment.middle);
            }
        }
        if (_isRightToLeftCharacters(text)) {
            this._stringFormat.textDirection = PdfTextDirection.rightToLeft;
        }
        if (enableGrouping) {
            this._drawTextBox(graphics, parameter, text, pdfFont, stringFormat, this.multiLine, this.scrollable, this.maxLength);
        }
        else {
            this._drawTextBox(graphics, parameter, text, this._font, this._stringFormat, this.multiLine, this.scrollable, this.maxLength);
        }
        if (!this.required) {
            graphics._sw._endMarkupSequence();
        }
        return template;
    };
    PdfTextBoxField.prototype._drawTextBox = function (g, parameter, text, font, format, multiline, scroll, maxLength) {
        if (typeof maxLength !== 'undefined') {
            if (parameter.insertSpaces) {
                var width = 0;
                if (typeof maxLength !== 'undefined' && maxLength > 0 && this.borderColor) {
                    width = parameter.bounds[2] / maxLength;
                    g.drawRectangle(parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3], parameter.borderPen, parameter.backBrush);
                    var current = text;
                    for (var i = 0; i < maxLength; i++) {
                        if (format.alignment === PdfTextAlignment.right) {
                            if (maxLength - current.length <= i) {
                                text = current[i - (maxLength - current.length)];
                            }
                            else {
                                text = '';
                            }
                        }
                        else {
                            if (format.alignment === PdfTextAlignment.center && current.length < maxLength) {
                                var startlocation = Math.floor(maxLength / 2 - Math.ceil(current.length / 2));
                                if (i >= startlocation && i < startlocation + current.length) {
                                    text = current[i - startlocation];
                                }
                                else {
                                    text = '';
                                }
                            }
                            else {
                                if (current.length > i) {
                                    text = current[Number.parseInt(i.toString(), 10)];
                                }
                                else {
                                    text = '';
                                }
                            }
                        }
                        parameter.bounds[2] = width;
                        var stringFormat = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
                        this._drawTextBox(g, parameter, text, font, stringFormat, multiline, scroll);
                        parameter.bounds[0] = parameter.bounds[0] + width;
                        if (parameter.borderWidth) {
                            g.drawLine(parameter.borderPen, parameter.bounds[0], parameter.bounds[1], parameter.bounds[0], parameter.bounds[1] + parameter.bounds[3]);
                        }
                    }
                }
                else {
                    this._drawTextBox(g, parameter, text, font, format, multiline, scroll);
                }
            }
            else {
                this._drawTextBox(g, parameter, text, font, format, multiline, scroll);
            }
        }
        else {
            if (g._isTemplateGraphics && parameter.required) {
                g.save();
                g._initializeCoordinates();
            }
            if (!parameter.insertSpaces) {
                this._drawRectangularControl(g, parameter);
            }
            if (g._isTemplateGraphics && parameter.required) {
                g.restore();
                g.save();
                g._sw._beginMarkupSequence('Tx');
                g._initializeCoordinates();
            }
            var rectangle = [parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3]];
            var rotate = this.rotate;
            if (rotate !== null && typeof rotate !== 'undefined' && rotate === 90) {
                rectangle[1] = rectangle[2] / 2;
            }
            if (parameter.borderStyle === PdfBorderStyle.beveled || parameter.borderStyle === PdfBorderStyle.inset) {
                rectangle[0] = rectangle[0] + 4 * parameter.borderWidth;
                rectangle[2] = rectangle[2] - 8 * parameter.borderWidth;
            }
            else {
                rectangle[0] = rectangle[0] + 2 * parameter.borderWidth;
                rectangle[2] = rectangle[2] - 4 * parameter.borderWidth;
            }
            if (multiline) {
                var tempheight = (typeof format === 'undefined' || format === null || format.lineSpacing === 0) ?
                    font._metrics._getHeight() :
                    format.lineSpacing;
                var ascent = font._metrics._getAscent(format);
                var shift = tempheight - ascent;
                if (text.indexOf('\n') !== -1) {
                    if (rectangle[0] === 0 && rectangle[1] === 1) {
                        rectangle[1] = -(rectangle[1] - shift);
                    }
                }
                else if (rectangle[0] === 0 && rectangle[1] === 1) {
                    rectangle[1] = -(rectangle[1] - shift);
                }
                if (parameter.isAutoFontSize) {
                    if (parameter.borderWidth !== 0) {
                        rectangle[1] = rectangle[1] + 2.5 * parameter.borderWidth;
                    }
                }
            }
            if ((g._page &&
                typeof g._page.rotation !== 'undefined' &&
                g._page.rotation !== PdfRotationAngle.angle0) ||
                parameter.rotationAngle > 0) {
                var state = g.save();
                if (typeof parameter.pageRotationAngle !== 'undefined' && parameter.pageRotationAngle !== PdfRotationAngle.angle0) {
                    if (parameter.pageRotationAngle === PdfRotationAngle.angle90) {
                        g.translateTransform(g._size[1], 0);
                        g.rotateTransform(90);
                        var y = g._size[1] - (rectangle[0] + rectangle[2]);
                        var x = rectangle[1];
                        rectangle = [x, y, rectangle[3], rectangle[2]];
                    }
                    else if (parameter.pageRotationAngle === PdfRotationAngle.angle180) {
                        g.translateTransform(g._size[0], g._size[1]);
                        g.rotateTransform(-180);
                        var x = g._size[0] - (rectangle[0] + rectangle[2]);
                        var y = g._size[1] - (rectangle[1] + rectangle[3]);
                        rectangle = [x, y, rectangle[2], rectangle[3]];
                    }
                    else if (parameter.pageRotationAngle === PdfRotationAngle.angle270) {
                        g.translateTransform(0, g._size[0]);
                        g.rotateTransform(270);
                        var x = g._size[0] - (rectangle[1] + rectangle[3]);
                        var y = rectangle[0];
                        rectangle = [x, y, rectangle[3], rectangle[2]];
                    }
                }
                if (parameter.rotationAngle) {
                    if (parameter.rotationAngle === 90) {
                        if (parameter.pageRotationAngle === PdfRotationAngle.angle90) {
                            g.translateTransform(0, g._size[1]);
                            g.rotateTransform(-90);
                            var x = g._size[1] - (rectangle[1] + rectangle[3]);
                            var y = rectangle[0];
                            rectangle = [x, y, rectangle[3], rectangle[2]];
                            parameter.stringFormat = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
                        }
                        else {
                            if (rectangle[2] > rectangle[3]) {
                                g.translateTransform(0, g._size[1]);
                                g.rotateTransform(-90);
                                rectangle = [parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3]];
                                rectangle[1] = (rectangle[2] / 2) - (8 * parameter.borderWidth);
                            }
                            else {
                                var z = rectangle[0];
                                rectangle[0] = -(rectangle[1] + rectangle[3]);
                                rectangle[1] = z;
                                var height = rectangle[3];
                                rectangle[3] = rectangle[2] > font._metrics._getHeight() ? rectangle[2] : font._metrics._getHeight();
                                rectangle[2] = height;
                                g.rotateTransform(-90);
                            }
                        }
                    }
                    else if (parameter.rotationAngle === 270) {
                        g.translateTransform(g._size[0], 0);
                        g.rotateTransform(-270);
                        rectangle = [parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3]];
                        rectangle[1] = (rectangle[2] / 2) - (8 * parameter.borderWidth);
                    }
                    else if (parameter.rotationAngle === 180) {
                        g.translateTransform(g._size[0], g._size[1]);
                        g.rotateTransform(-180);
                        var x = g._size[0] - (rectangle[0] + rectangle[2]);
                        var y = g._size[1] - (rectangle[1] + rectangle[3]);
                        rectangle = [x, y, rectangle[2], rectangle[3]];
                    }
                }
                g.drawString(text, font, rectangle, null, parameter.foreBrush, format);
                g.restore(state);
            }
            else {
                g.drawString(text, font, rectangle, null, parameter.foreBrush, format);
            }
            if (g._isTemplateGraphics && parameter.required) {
                g._sw._endMarkupSequence();
                g.restore();
            }
        }
    };
    return PdfTextBoxField;
}(PdfField));
/**
 * `PdfButtonField` class represents the button field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0);
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new button field
 * let field: PdfButtonField = new PdfButtonField(page , 'Button1', {x: 100, y: 40, width: 100, height: 20});
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfButtonField = /** @class */ (function (_super) {
    __extends$5(PdfButtonField, _super);
    function PdfButtonField(page, name, bounds) {
        var _this = _super.call(this) || this;
        if (page && name && bounds) {
            _this._initialize(page, name, bounds);
        }
        return _this;
    }
    Object.defineProperty(PdfButtonField.prototype, "actions", {
        /**
         * Gets the actions of the field. [Read-Only]
         *
         * @returns {PdfFieldActions} The actions.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Get the action value from button field
         * let action: PdfAction = field.actions.mouseEnter;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._actions) {
                this._actions = new PdfFieldActions(this);
            }
            return this._actions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfButtonField.prototype, "text", {
        /**
         * Gets value of the text box field.
         *
         * @returns {string} Text.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access text box field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Gets the text value from button field
         * let text: string = field.text;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoaded) {
                if (typeof this._text === 'undefined') {
                    var widget = this.itemAt(this._defaultIndex);
                    if (widget && widget._mkDictionary && widget._mkDictionary.has('CA')) {
                        this._text = widget._mkDictionary.get('CA');
                    }
                    else if (this._mkDictionary && this._mkDictionary.has('CA')) {
                        this._text = this._mkDictionary.get('CA');
                    }
                }
                if (typeof this._text === 'undefined') {
                    var value = _getInheritableProperty(this._dictionary, 'V', false, true, 'Parent');
                    if (value) {
                        this._text = value;
                    }
                }
            }
            if (typeof this._text === 'undefined') {
                this._text = '';
            }
            return this._text;
        },
        /**
         * Sets value of the text box field.
         *
         * @param {string} value Text.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Sets the text value of form field
         * field.text = ’Click to submit’;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._isLoaded && !this.readOnly) {
                var widget = this.itemAt(this._defaultIndex);
                if (widget && widget._dictionary) {
                    this._assignText(widget._dictionary, value);
                }
                else {
                    this._assignText(this._dictionary, value);
                }
            }
            if (!this._isLoaded && this._text !== value) {
                var widget = this.itemAt(this._defaultIndex);
                this._assignText(widget._dictionary, value);
                this._text = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfButtonField.prototype, "textAlignment", {
        /**
         * Gets the text alignment in a button field.
         *
         * @returns {PdfTextAlignment} Text alignment.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Gets the text alignment from button field
         * let alignment: PdfTextAlignment = field.textAlignment;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._getTextAlignment();
        },
        /**
         * Sets the text alignment in a button field.
         *
         * @param {PdfTextAlignment} value Text alignment.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Sets the text alignment of form field as center
         * field.textAlignment = PdfTextAlignment.center;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._textAlignment !== value) {
                this._setTextAlignment(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfButtonField.prototype, "highlightMode", {
        /**
         * Gets the highlight mode of the field.
         *
         * @returns {PdfHighlightMode} highlight mode.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Gets the highlight mode from button field
         * let highlightMode: PdfHighlightMode = field. highlightMode;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var widget = this.itemAt(this._defaultIndex);
            var mode;
            if (widget && typeof widget.highlightMode !== 'undefined') {
                mode = widget.highlightMode;
            }
            else if (this._dictionary && this._dictionary.has('H')) {
                var highlight = this._dictionary.get('H');
                mode = _mapHighlightMode(highlight.name);
            }
            return (typeof mode !== 'undefined') ? mode : PdfHighlightMode.invert;
        },
        /**
         * Sets the highlight mode of the field.
         *
         * @param {PdfHighlightMode} value highlight mode.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access button field
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Sets the highlight mode of button field as outline
         * field.highlightMode = PdfHighlightMode.outline;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            var widget = this.itemAt(this._defaultIndex);
            if (widget && (typeof widget.highlightMode === 'undefined' || widget.highlightMode !== value)) {
                widget.highlightMode = value;
            }
            else if (!this._dictionary.has('H') || _mapHighlightMode(this._dictionary.get('H')) !== value) {
                this._dictionary.update('H', _reverseMapHighlightMode(value));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfButtonField.prototype, "font", {
        /**
         * Gets the font of the field.
         *
         * @returns {PdfFont} font.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Gets the font of the field.
         * let font: PdfFont = field.font;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._font) {
                return this._font;
            }
            else {
                var widget = this.itemAt(this._defaultIndex);
                this._font = _obtainFontDetails(this._form, widget, this);
            }
            return this._font;
        },
        /**
         * Sets the font of the field.
         *
         * @param {PdfFont} value font.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
         * // Sets the font of the field
         * field.font = new PdfStandardFont(PdfFontFamily.helvetica, 12, PdfFontStyle.bold);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value && value instanceof PdfFont) {
                this._font = value;
                this._initializeFont(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfButtonField.prototype, "backColor", {
        /**
         * Gets the background color of the field.
         *
         * @returns {number[]} R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the background color of the field.
         * let backColor: number[] = field.backColor;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._parseBackColor(true);
        },
        /**
         * Sets the background color of the field.
         *
         * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the button field at index 0
         * let submitButton: PdfField = document.form.fieldAt(0);
         * // Sets the background color of the field.
         * submitButton.backColor = [255, 0, 0];
         * // Access the button field at index 1
         * let cancelButton: PdfField = document.form.fieldAt(1);
         * // Sets the background color of the field to transparent.
         * cancelButton.backColor = [0, 0, 0, 0];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._updateBackColor(value, true);
        },
        enumerable: true,
        configurable: true
    });
    PdfButtonField.prototype._assignText = function (fieldDictionary, value) {
        var dictionary;
        if (fieldDictionary && fieldDictionary.has('MK')) {
            dictionary = fieldDictionary.get('MK');
        }
        else {
            dictionary = new _PdfDictionary(this._crossReference);
            fieldDictionary.set('MK', dictionary);
        }
        dictionary.update('CA', value);
        fieldDictionary._updated = true;
    };
    /**
     * Parse an existing button field.
     *
     * @private
     * @param {PdfForm} form Form object.
     * @param {_PdfDictionary} dictionary Field dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference object.
     * @param {_PdfReference} reference Field reference.
     * @returns {PdfButtonField} Button field.
     */
    PdfButtonField._load = function (form, dictionary, crossReference, reference) {
        var field = new PdfButtonField();
        field._isLoaded = true;
        field._form = form;
        field._dictionary = dictionary;
        field._crossReference = crossReference;
        field._ref = reference;
        if (field._dictionary.has('Kids')) {
            field._kids = field._dictionary.get('Kids');
        }
        field._defaultIndex = 0;
        field._parsedItems = new Map();
        return field;
    };
    PdfButtonField.prototype._initialize = function (page, name, bounds) {
        this._crossReference = page._crossReference;
        this._page = page;
        this._name = name;
        this._defaultIndex = 0;
        this._dictionary = new _PdfDictionary(this._crossReference);
        this._ref = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(this._ref, this._dictionary);
        this._dictionary.objId = this._ref.toString();
        this._dictionary.update('FT', _PdfName.get('Btn'));
        this._dictionary.update('T', name);
        this._fieldFlags |= _FieldFlag.pushButton;
        this._initializeFont(this._defaultFont);
        this._createItem(bounds);
    };
    PdfButtonField.prototype._createItem = function (bounds) {
        var widget = new PdfWidgetAnnotation();
        widget._create(this._page, bounds, this);
        widget.textAlignment = PdfTextAlignment.center;
        this._stringFormat = new PdfStringFormat(widget.textAlignment, PdfVerticalAlignment.middle);
        widget._dictionary.update('MK', new _PdfDictionary(this._crossReference));
        widget._mkDictionary.update('BC', [0, 0, 0]);
        widget._mkDictionary.update('BG', [.827451, .827451, .827451]);
        widget._mkDictionary.update('CA', (typeof this._name !== 'undefined' && this._name !== null) ? this._name : this._actualName);
        this._addToKid(widget);
    };
    PdfButtonField.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (isFlatten || this._setAppearance || this._form._setAppearance) {
            var count = this._kidsCount;
            if (this._isLoaded) {
                if (count > 0) {
                    for (var i = 0; i < count; i++) {
                        var item = this.itemAt(i);
                        if (item) {
                            this._postProcess(isFlatten, item);
                        }
                    }
                }
                else if ((isFlatten || this._form._setAppearance || this._setAppearance) && !this._checkFieldFlag(this._dictionary)) {
                    this._postProcess(isFlatten);
                }
            }
            else if (isFlatten || this._form._setAppearance || this._setAppearance) {
                for (var i = 0; i < count; i++) {
                    var item = this.itemAt(i);
                    if (item && !this._checkFieldFlag(item._dictionary)) {
                        var template = this._createAppearance(item);
                        if (isFlatten) {
                            this._drawTemplate(template, item._getPage(), { x: item.bounds.x, y: item.bounds.y, width: template._size[0], height: template._size[1] });
                        }
                        else {
                            this._addAppearance(item._dictionary, template, 'N');
                            var pressed = this._createAppearance(item, true);
                            if (pressed) {
                                this._addAppearance(item._dictionary, pressed, 'D');
                            }
                        }
                        item._dictionary._updated = !isFlatten;
                    }
                }
            }
            if (isFlatten) {
                this._dictionary._updated = false;
            }
        }
    };
    PdfButtonField.prototype._postProcess = function (isFlatten, widget) {
        var template;
        var bounds;
        var source = widget ? widget : this;
        if ((widget !== null && typeof widget !== 'undefined' && widget._setAppearance && widget._enableGrouping) || this._form._setAppearance || this._setAppearance || (isFlatten && !source._dictionary.has('AP'))) {
            template = this._createAppearance(source);
        }
        else if (source._dictionary.has('AP')) {
            var appearanceStream = void 0;
            var dictionary = source._dictionary.get('AP');
            if (dictionary && dictionary.has('N')) {
                appearanceStream = dictionary.get('N');
                var reference = dictionary.getRaw('N');
                if (reference) {
                    appearanceStream.reference = reference;
                }
                if (appearanceStream) {
                    template = new PdfTemplate(appearanceStream, this._crossReference);
                }
            }
        }
        if (template) {
            if (isFlatten) {
                var page = source instanceof PdfWidgetAnnotation ? source._getPage() : source.page;
                if (page) {
                    var graphics = page.graphics;
                    graphics.save();
                    if (page.rotation === PdfRotationAngle.angle90) {
                        graphics.translateTransform(graphics._size[0], graphics._size[1]);
                        graphics.rotateTransform(90);
                    }
                    else if (page.rotation === PdfRotationAngle.angle180) {
                        graphics.translateTransform(graphics._size[0], graphics._size[1]);
                        graphics.rotateTransform(-180);
                    }
                    else if (page.rotation === PdfRotationAngle.angle270) {
                        graphics.translateTransform(graphics._size[0], graphics._size[1]);
                        graphics.rotateTransform(270);
                    }
                    bounds = { x: source.bounds.x, y: source.bounds.y, width: template._size[0], height: template._size[1] };
                    graphics.drawTemplate(template, bounds);
                    graphics.restore();
                }
                source._dictionary._updated = false;
            }
            else {
                this._addAppearance(source._dictionary, template, 'N');
            }
        }
    };
    PdfButtonField.prototype._createAppearance = function (widget, isPressed) {
        if (isPressed === void 0) { isPressed = false; }
        var bounds = widget.bounds;
        var template = new PdfTemplate([0, 0, bounds.width, bounds.height], this._crossReference);
        var parameter = new _PaintParameter();
        parameter.bounds = [0, 0, bounds.width, bounds.height];
        var text;
        var font;
        var stringFormat;
        var enableGrouping = false;
        var isSizeZero = false;
        var backcolor = widget.backColor;
        if (backcolor) {
            parameter.backBrush = new PdfBrush(backcolor);
        }
        parameter.foreBrush = new PdfBrush(widget.color);
        var border = widget.border;
        if (widget.borderColor) {
            parameter.borderPen = new PdfPen(widget.borderColor, border.width);
        }
        parameter.borderWidth = border.width;
        parameter.borderStyle = border.style;
        if (backcolor) {
            var shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
            var color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                shadowColor[1] >= 0 ? shadowColor[1] : 0,
                shadowColor[2] >= 0 ? shadowColor[2] : 0];
            parameter.shadowBrush = new PdfBrush(color);
        }
        parameter.rotationAngle = widget.rotate;
        if (widget !== null && typeof widget !== 'undefined' && widget instanceof PdfWidgetAnnotation && widget._enableGrouping) {
            enableGrouping = true;
        }
        if (enableGrouping) {
            if (widget._mkDictionary && widget._mkDictionary && widget._mkDictionary.has('CA')) {
                text = widget._mkDictionary.get('CA');
            }
            else {
                text = '';
            }
            if (typeof widget.font !== 'undefined' && widget.font.size !== null && widget.font.size !== 0) {
                font = widget.font;
            }
            stringFormat = new PdfStringFormat(widget.textAlignment, PdfVerticalAlignment.middle);
        }
        else if (typeof this._font === 'undefined' || this._font === null) {
            this._font = this._defaultFont;
        }
        if (this._isLoaded && widget instanceof PdfWidgetAnnotation &&
            widget !== null && typeof widget !== 'undefined' && widget._defaultAppearance) {
            var fontName = widget._defaultAppearance.fontName;
            if (fontName === null || typeof fontName === 'undefined') {
                fontName = 'Helvetica';
            }
            var fontSize = widget._defaultAppearance.fontSize;
            if (fontSize === null || typeof fontSize === 'undefined') {
                fontSize = this._defaultFont.size;
            }
            else if (fontSize === 0) {
                isSizeZero = true;
            }
            var previousFont = void 0;
            var currentFont = void 0;
            var font_1;
            this._stringFormat = new PdfStringFormat();
            this._stringFormat.lineAlignment = PdfVerticalAlignment.middle;
            this._stringFormat.alignment = PdfTextAlignment.center;
            if (fontSize !== null && typeof fontSize !== 'undefined' && fontName) {
                font_1 = _mapFont(fontName, fontSize, PdfFontStyle.regular, widget);
            }
            if (font_1 !== null && typeof font_1 !== 'undefined') {
                currentFont = font_1;
            }
            else {
                currentFont = this._defaultFont;
            }
            var textWidth = currentFont.measureString(this.text, this._stringFormat);
            if (isSizeZero && currentFont && currentFont instanceof PdfStandardFont) {
                if (this._isLoaded && !widget._dictionary.has('AP')) {
                    var width = widget.bounds.width - 8 * border.width;
                    var height = widget.bounds.height - 8 * border.width;
                    while (textWidth[0] < width || textWidth[1] < height) {
                        previousFont = currentFont;
                        currentFont = new PdfStandardFont(currentFont.fontFamily, currentFont._size + 1);
                        textWidth = currentFont.measureString(this.text, this._stringFormat);
                        if (textWidth[0] > width || textWidth[1] > height) {
                            currentFont = previousFont;
                            break;
                        }
                    }
                    this._font = currentFont;
                }
            }
        }
        if (enableGrouping) {
            if (isPressed) {
                this._drawPressedButton(template.graphics, parameter, text, font, stringFormat);
            }
            else {
                this._drawButton(template.graphics, parameter, text, font, stringFormat);
            }
        }
        else {
            if (isPressed) {
                this._drawPressedButton(template.graphics, parameter, this.text, this._font, this._stringFormat);
            }
            else {
                this._drawButton(template.graphics, parameter, this.text, this._font, this._stringFormat);
            }
        }
        return template;
    };
    PdfButtonField.prototype._drawButton = function (g, parameter, text, font, format) {
        this._drawRectangularControl(g, parameter);
        var rectangle = parameter.bounds;
        if ((g._page &&
            typeof g._page.rotation !== 'undefined' &&
            g._page.rotation !== PdfRotationAngle.angle0) ||
            parameter.rotationAngle > 0) {
            var state = g.save();
            if (typeof parameter.pageRotationAngle !== 'undefined' && parameter.pageRotationAngle !== PdfRotationAngle.angle0) {
                if (parameter.pageRotationAngle === PdfRotationAngle.angle90) {
                    g.translateTransform(g._size[1], 0);
                    g.rotateTransform(90);
                    var y = g._size[1] - (rectangle[0] + rectangle[2]);
                    var x = rectangle[1];
                    rectangle = [x, y, rectangle[3], rectangle[2]];
                }
                else if (parameter.pageRotationAngle === PdfRotationAngle.angle180) {
                    g.translateTransform(g._size[0], g._size[1]);
                    g.rotateTransform(-180);
                    var x = g._size[0] - (rectangle[0] + rectangle[2]);
                    var y = g._size[1] - (rectangle[1] + rectangle[3]);
                    rectangle = [x, y, rectangle[2], rectangle[3]];
                }
                else if (parameter.pageRotationAngle === PdfRotationAngle.angle270) {
                    g.translateTransform(0, g._size[0]);
                    g.rotateTransform(270);
                    var x = g._size[0] - (rectangle[1] + rectangle[3]);
                    var y = rectangle[0];
                    rectangle = [x, y, rectangle[3], rectangle[2]];
                }
            }
            if (parameter.rotationAngle) {
                if (parameter.rotationAngle === 90) {
                    if (parameter.pageRotationAngle === PdfRotationAngle.angle90) {
                        g.translateTransform(0, g._size[1]);
                        g.rotateTransform(-90);
                        var x = g._size[1] - (rectangle[1] + rectangle[3]);
                        var y = rectangle[0];
                        rectangle = [x, y, rectangle[3], rectangle[2]];
                    }
                    else {
                        if (rectangle[2] > rectangle[3]) {
                            g.translateTransform(0, g._size[1]);
                            g.rotateTransform(-90);
                            rectangle = [parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3]];
                        }
                        else {
                            var z = rectangle[0];
                            rectangle[0] = -(rectangle[1] + rectangle[3]);
                            rectangle[1] = z;
                            var height = rectangle[3];
                            rectangle[3] = rectangle[2] > font._metrics._getHeight() ? rectangle[2] : font._metrics._getHeight();
                            rectangle[2] = height;
                            g.rotateTransform(-90);
                        }
                    }
                }
                else if (parameter.rotationAngle === 270) {
                    g.translateTransform(g._size[0], 0);
                    g.rotateTransform(-270);
                    var x = rectangle[1];
                    var y = g._size[0] - (rectangle[0] + rectangle[2]);
                    rectangle = [x, y, rectangle[3], rectangle[2]];
                }
                else if (parameter.rotationAngle === 180) {
                    g.translateTransform(g._size[0], g._size[1]);
                    g.rotateTransform(-180);
                    var x = g._size[0] - (rectangle[0] + rectangle[2]);
                    var y = g._size[1] - (rectangle[1] + rectangle[3]);
                    rectangle = [x, y, rectangle[2], rectangle[3]];
                }
            }
            g.drawString(text, font, rectangle, null, parameter.foreBrush, format);
            g.restore(state);
        }
        else {
            g.drawString(text, font, rectangle, null, parameter.foreBrush, format);
        }
    };
    PdfButtonField.prototype._drawPressedButton = function (g, parameter, text, font, format) {
        switch (parameter.borderStyle) {
            case PdfBorderStyle.inset:
                g.drawRectangle(parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3], parameter.shadowBrush);
                break;
            default:
                g.drawRectangle(parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3], parameter.backBrush);
                break;
        }
        this._drawBorder(g, parameter.bounds, parameter.borderPen, parameter.borderStyle, parameter.borderWidth);
        var rectangle = [parameter.borderWidth,
            parameter.borderWidth,
            parameter.bounds[2] - parameter.borderWidth,
            parameter.bounds[3] - parameter.borderWidth];
        g.drawString(text, font, rectangle, null, parameter.foreBrush, format);
        switch (parameter.borderStyle) {
            case PdfBorderStyle.inset:
                this._drawLeftTopShadow(g, parameter.bounds, parameter.borderWidth, this._grayBrush);
                this._drawRightBottomShadow(g, parameter.bounds, parameter.borderWidth, this._silverBrush);
                break;
            case PdfBorderStyle.beveled:
                this._drawLeftTopShadow(g, parameter.bounds, parameter.borderWidth, parameter.shadowBrush);
                this._drawRightBottomShadow(g, parameter.bounds, parameter.borderWidth, this._whiteBrush);
                break;
            default:
                this._drawLeftTopShadow(g, parameter.bounds, parameter.borderWidth, parameter.shadowBrush);
                break;
        }
    };
    return PdfButtonField;
}(PdfField));
/**
 * `PdfCheckBoxField` class represents the check box field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0);
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new check box field
 * let field: PdfCheckBoxField = new PdfCheckBoxField('CheckBox1', {x: 100, y: 40, width: 20, height: 20}, page);
 * // Sets the checked flag as true.
 * field.checked = true;
 * // Sets the tool tip value
 * field.toolTip = 'Checked';
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfCheckBoxField = /** @class */ (function (_super) {
    __extends$5(PdfCheckBoxField, _super);
    function PdfCheckBoxField(name, bounds, page) {
        var _this = _super.call(this) || this;
        if (page && name && bounds) {
            _this._initialize(page, name, bounds);
        }
        return _this;
    }
    /**
     * Parse an existing check box field.
     *
     * @private
     * @param {PdfForm} form Form object.
     * @param {_PdfDictionary} dictionary Field dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference object.
     * @param {_PdfReference} reference Field reference.
     * @returns {PdfCheckBoxField} Check box field.
     */
    PdfCheckBoxField._load = function (form, dictionary, crossReference, reference) {
        var field = new PdfCheckBoxField();
        field._isLoaded = true;
        field._form = form;
        field._dictionary = dictionary;
        field._crossReference = crossReference;
        field._ref = reference;
        field._defaultIndex = 0;
        field._parsedItems = new Map();
        if (field._dictionary.has('Kids')) {
            field._kids = field._dictionary.get('Kids');
        }
        else {
            var item = PdfStateItem._load(dictionary, crossReference, field);
            item._isLoaded = true;
            item._ref = reference;
            field._parsedItems.set(0, item);
        }
        return field;
    };
    /**
     * Gets the item at the specified index.
     *
     * @param {number} index Index of the field item.
     * @returns {PdfStateItem} Field item at the index.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the check box field
     * let field: PdfCheckBoxField = form.fieldAt(0) as PdfCheckBoxField;
     * // Gets the first list item.
     * let item: PdfStateItem = field.itemAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfCheckBoxField.prototype.itemAt = function (index) {
        if (index < 0 || (index !== 0 && index >= this._kidsCount)) {
            throw Error('Index out of range.');
        }
        var item;
        if (this._parsedItems.has(index)) {
            item = this._parsedItems.get(index);
        }
        else {
            var dictionary = void 0;
            if (index >= 0 && this._kids && this._kids.length > 0 && index < this._kids.length) {
                var ref = this._kids[Number.parseInt(index.toString(), 10)];
                if (ref && ref instanceof _PdfReference) {
                    dictionary = this._crossReference._fetch(ref);
                }
                if (dictionary) {
                    item = PdfStateItem._load(dictionary, this._crossReference, this);
                    item._isLoaded = true;
                    item._ref = ref;
                    this._parsedItems.set(index, item);
                }
            }
        }
        return item;
    };
    Object.defineProperty(PdfCheckBoxField.prototype, "font", {
        /**
         * Gets the font of the field.
         *
         * @returns {PdfFont} font.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
         * // Gets the font of the field.
         * let font: PdfFont = field.font;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._font) {
                return this._font;
            }
            else {
                var widget = this.itemAt(this._defaultIndex);
                this._font = _obtainFontDetails(this._form, widget, this);
            }
            return this._font;
        },
        /**
         * Sets the font of the field.
         *
         * @param {PdfFont} value font.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
         * // Sets the font of the field
         * field.font = new PdfStandardFont(PdfFontFamily.helvetica, 12, PdfFontStyle.bold);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value && value instanceof PdfFont) {
                this._font = value;
                this._initializeFont(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfCheckBoxField.prototype, "checked", {
        /**
         * Gets the flag indicating whether the field is checked or not.
         *
         * @returns {boolean} Checked.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Access the check box field
         * let field: PdfCheckBoxField = form.fieldAt(0) as PdfCheckBoxField;
         * // Gets the flag indicating whether the field is checked or not.
         * let checked: Boolean = field.checked;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return (this._kidsCount > 0) ? this.itemAt(this._defaultIndex).checked : _checkField(this._dictionary);
        },
        /**
         * Sets the flag indicating whether the field is checked or not.
         *
         * @param {boolean} value Checked.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Access the check box field
         * let field: PdfCheckBoxField = form.fieldAt(0) as PdfCheckBoxField;
         * // Sets the flag indicating whether the field is checked or not.
         * field.checked = true;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this.checked !== value) {
                if (this._kidsCount > 0) {
                    this.itemAt(this._defaultIndex).checked = value;
                }
                if (value) {
                    if (this._isLoaded) {
                        var entry = _getItemValue((this._kidsCount > 0) ?
                            this.itemAt(this._defaultIndex)._dictionary : this._dictionary);
                        this._dictionary.update('V', _PdfName.get(entry));
                        this._dictionary.update('AS', _PdfName.get(entry));
                    }
                    else {
                        this._dictionary.update('V', _PdfName.get('Yes'));
                        this._dictionary.update('AS', _PdfName.get('Yes'));
                    }
                }
                else {
                    if (this._dictionary.has('V')) {
                        delete this._dictionary._map.V;
                    }
                    if (this._dictionary.has('AS')) {
                        delete this._dictionary._map.AS;
                    }
                }
                this._dictionary._updated = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfCheckBoxField.prototype, "textAlignment", {
        /**
         * Gets the text alignment in a check box field.
         *
         * @returns {PdfTextAlignment} Text alignment.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access check box field
         * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
         * // Gets the text alignment from check box field
         * let alignment: PdfTextAlignment = field.textAlignment;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._getTextAlignment();
        },
        /**
         * Sets the text alignment in a check box field.
         *
         * @param {PdfTextAlignment} value Text alignment.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access check box field
         * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
         * // Sets the text alignment of form field as center
         * field.textAlignment = PdfTextAlignment.center;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._textAlignment !== value) {
                this._setTextAlignment(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfCheckBoxField.prototype, "backColor", {
        /**
         * Gets the background color of the field.
         *
         * @returns {number[]} R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the background color of the field.
         * let backColor: number[] = field.backColor;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._parseBackColor(true);
        },
        /**
         * Sets the background color of the field.
         *
         * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the check box field at index 0
         * let checkBox1: PdfField = document.form.fieldAt(0);
         * // Sets the background color of the field.
         * checkBox1.backColor = [255, 0, 0];
         * // Access the check box field at index 1
         * let checkBox2: PdfField = document.form.fieldAt(1);
         * // Sets the background color of the field to transparent.
         * checkBox2.backColor = [0, 0, 0, 0];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._updateBackColor(value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfCheckBoxField.prototype, "borderColor", {
        /**
         * Gets the border color of the field.
         *
         * @returns {number[]} R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the border color of the field.
         * let borderColor: number[] = field.borderColor;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._parseBorderColor(true);
        },
        /**
         * Sets the border color of the field.
         *
         * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets the border color of the field.
         * field.borderColor = [255, 0, 0];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._updateBorderColor(value, true);
            if (this._isLoaded) {
                this._setAppearance = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfCheckBoxField.prototype._initialize = function (page, name, bounds) {
        this._crossReference = page._crossReference;
        this._page = page;
        this._name = name;
        this._defaultIndex = 0;
        this._dictionary = new _PdfDictionary(this._crossReference);
        this._ref = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(this._ref, this._dictionary);
        this._dictionary.objId = this._ref.toString();
        this._dictionary.update('FT', _PdfName.get('Btn'));
        this._dictionary.update('T', name);
        this._createItem(bounds);
    };
    PdfCheckBoxField.prototype._createItem = function (bounds) {
        var widget = new PdfStateItem();
        widget._create(this._page, bounds, this);
        widget.textAlignment = PdfTextAlignment.center;
        this._stringFormat = new PdfStringFormat(widget.textAlignment, PdfVerticalAlignment.middle);
        widget._dictionary.update('MK', new _PdfDictionary(this._crossReference));
        widget._mkDictionary.update('BC', [0, 0, 0]);
        widget._mkDictionary.update('BG', [1, 1, 1]);
        widget.style = PdfCheckBoxStyle.check;
        widget._dictionary.update('DA', '/TiRo 0 Tf 0 0 0 rg');
        this._addToKid(widget);
    };
    PdfCheckBoxField.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        var count = this._kidsCount;
        if (!this._isLoaded) {
            for (var i = 0; i < count; i++) {
                var item = this.itemAt(i);
                if (item) {
                    var state = item.checked ? _PdfCheckFieldState.checked : _PdfCheckFieldState.unchecked;
                    item._postProcess(item.checked ? 'Yes' : 'Off');
                    if (isFlatten) {
                        var template = this._createAppearance(item, state);
                        this._drawTemplate(template, item._getPage(), item.bounds);
                    }
                    else {
                        this._drawAppearance(item);
                    }
                    item._dictionary._updated = !isFlatten;
                }
            }
        }
        else if (isFlatten || this._setAppearance || this._dictionary._updated || this._isImport) {
            if (count > 0) {
                for (var i = 0; i < count; i++) {
                    var item = this.itemAt(i);
                    if (item) {
                        if (!this._checkFieldFlag(item._dictionary)) {
                            if (isFlatten) {
                                var template = void 0;
                                var state = item.checked ?
                                    _PdfCheckFieldState.checked :
                                    _PdfCheckFieldState.unchecked;
                                if (this._setAppearance || this._form._setAppearance || !item._dictionary.has('AP')) {
                                    template = this._createAppearance(item, state);
                                }
                                else {
                                    template = _getStateTemplate(state, item);
                                }
                                this._drawTemplate(template, item._getPage(), item.bounds);
                            }
                            else if (this._setAppearance || this._form._setAppearance || !item._isLoaded) {
                                item._postProcess(item.checked ? 'Yes' : 'Off');
                                this._drawAppearance(item);
                            }
                        }
                        item._dictionary._updated = !isFlatten;
                    }
                }
            }
            else {
                var style = this.checked ?
                    _PdfCheckFieldState.checked :
                    _PdfCheckFieldState.unchecked;
                this._drawTemplate(_getStateTemplate(style, this), this.page, this.bounds);
            }
        }
        this._dictionary._updated = !isFlatten;
    };
    PdfCheckBoxField.prototype._createAppearance = function (widget, state) {
        var bounds = widget.bounds;
        var parameter = new _PaintParameter();
        parameter.bounds = [0, 0, bounds.width, bounds.height];
        var backcolor = widget.backColor;
        if (backcolor) {
            parameter.backBrush = new PdfBrush(backcolor);
        }
        parameter.foreBrush = new PdfBrush(widget.color);
        var border = widget.border;
        if (widget.borderColor) {
            parameter.borderPen = new PdfPen(widget.borderColor, border.width);
        }
        parameter.borderWidth = border.width;
        parameter.borderStyle = border.style;
        if (backcolor) {
            var shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
            var color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                shadowColor[1] >= 0 ? shadowColor[1] : 0,
                shadowColor[2] >= 0 ? shadowColor[2] : 0];
            parameter.shadowBrush = new PdfBrush(color);
        }
        parameter.rotationAngle = widget.rotate;
        var template = new PdfTemplate(parameter.bounds, this._crossReference);
        var graphics = template.graphics;
        if (widget._styleText) {
            this._drawCheckBox(graphics, parameter, widget._styleText, state);
        }
        else {
            this._drawCheckBox(graphics, parameter, _styleToString(widget._style), state);
        }
        return template;
    };
    PdfCheckBoxField.prototype._drawAppearance = function (item, itemValue) {
        var appearance = new _PdfDictionary();
        if (item._dictionary.has('AP')) {
            appearance = item._dictionary.get('AP');
            if (appearance) {
                if (appearance.has('N')) {
                    _removeReferences(appearance.get('N'), this._crossReference, 'Yes', 'Off');
                }
                if (appearance.has('D')) {
                    _removeReferences(appearance.get('D'), this._crossReference, 'Yes', 'Off');
                }
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            _removeDuplicateReference(appearance, this._crossReference, 'D');
        }
        else {
            var reference = this._crossReference._getNextReference();
            appearance = new _PdfDictionary(this._crossReference);
            this._crossReference._cacheMap.set(reference, appearance);
            item._dictionary.update('AP', reference);
        }
        var normalChecked = this._createAppearance(item, _PdfCheckFieldState.checked);
        var normalCheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(normalCheckedReference, normalChecked._content);
        var normalUnchecked = this._createAppearance(item, _PdfCheckFieldState.unchecked);
        var normalUncheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(normalUncheckedReference, normalUnchecked._content);
        var normalDictionary = new _PdfDictionary(this._crossReference);
        if (itemValue !== null && typeof itemValue !== 'undefined') {
            normalDictionary.update(itemValue, normalCheckedReference);
        }
        else {
            normalDictionary.update('Yes', normalCheckedReference);
        }
        normalDictionary.update('Off', normalUncheckedReference);
        var normalReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(normalReference, normalDictionary);
        appearance.update('N', normalReference);
        var pressChecked = this._createAppearance(item, _PdfCheckFieldState.pressedChecked);
        var pressCheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(pressCheckedReference, pressChecked._content);
        var pressUnchecked = this._createAppearance(item, _PdfCheckFieldState.pressedUnchecked);
        var pressUncheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(pressUncheckedReference, pressUnchecked._content);
        var pressedDictionary = new _PdfDictionary(this._crossReference);
        if (itemValue !== null && typeof itemValue !== 'undefined') {
            pressedDictionary.update(itemValue, pressCheckedReference);
        }
        else {
            pressedDictionary.update('Yes', pressCheckedReference);
        }
        pressedDictionary.update('Off', pressUncheckedReference);
        var pressedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(pressedReference, pressedDictionary);
        appearance.update('D', pressedReference);
        item._dictionary._updated = true;
    };
    return PdfCheckBoxField;
}(PdfField));
/**
 * `PdfRadioButtonListField` class represents the radio button field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0);
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new radio button list field
 * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');
 * // Create and add first item
 * let first: PdfRadioButtonListItem = field.add('1-9', {x: 100, y: 140, width: 20, height: 20});
 * // Create and add second item
 * let second: PdfRadioButtonListItem = new PdfRadioButtonListItem('10-49', {x: 100, y: 170, width: 20, height: 20}, page);
 * field.add(second);
 * // Sets selected index of the radio button list field
 * field.selectedIndex = 0;
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfRadioButtonListField = /** @class */ (function (_super) {
    __extends$5(PdfRadioButtonListField, _super);
    function PdfRadioButtonListField(page, name) {
        var _this = _super.call(this) || this;
        _this._selectedIndex = -1;
        if (page && name) {
            _this._initialize(page, name);
        }
        return _this;
    }
    /**
     * Parse an existing radio button list field.
     *
     * @private
     * @param {PdfForm} form Form object.
     * @param {_PdfDictionary} dictionary Field dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference object.
     * @param {_PdfReference} reference Field reference.
     * @returns {PdfRadioButtonListField} Radio button list field.
     */
    PdfRadioButtonListField._load = function (form, dictionary, crossReference, reference) {
        var field = new PdfRadioButtonListField();
        field._isLoaded = true;
        field._form = form;
        field._dictionary = dictionary;
        field._crossReference = crossReference;
        field._ref = reference;
        if (field._dictionary.has('Kids')) {
            field._kids = field._dictionary.get('Kids');
        }
        field._defaultIndex = 0;
        field._parsedItems = new Map();
        if (field._kidsCount > 0) {
            field._retrieveOptionValue();
        }
        return field;
    };
    Object.defineProperty(PdfRadioButtonListField.prototype, "checked", {
        /**
         * Gets the flag indicating whether the field is checked or not (Read only).
         *
         * @returns {boolean} Checked.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Access the radio button list field
         * let field: PdfRadioButtonListField = form.fieldAt(0) as PdfRadioButtonListField;
         * // Gets the flag indicating whether the field is checked or not.
         * let checked: boolean = field.checked;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var check = false;
            if (this._kidsCount > 0) {
                check = this.itemAt(this._defaultIndex).checked;
            }
            return check;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRadioButtonListField.prototype, "selectedIndex", {
        /**
         * Gets the selected item index.
         *
         * @returns {number} Index.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Access the radio button list field
         * let field: PdfRadioButtonListField = form.fieldAt(0) as PdfRadioButtonListField;
         * // Gets the selected index.
         * let index: number = field.selectedIndex;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoaded && this._selectedIndex === -1) {
                this._selectedIndex = this._obtainSelectedIndex();
            }
            return this._selectedIndex;
        },
        /**
         * Sets the selected item index.
         *
         * @param {number} value Selected index.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Create a new radio button list field
         * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');
         * // Create and add first item
         * let first: PdfRadioButtonListItem = field.add('1-9', {x: 100, y: 140, width: 20, height: 20});
         * // Create and add second item
         * let second: PdfRadioButtonListItem = new PdfRadioButtonListItem('10-49', {x: 100, y: 170, width: 20, height: 20}, page);
         * field.add(second);
         * // Sets selected index of the radio button list field
         * field.selectedIndex = 0;
         * // Add the field into PDF form
         * form.add(field);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this.selectedIndex !== value) {
                this._selectedIndex = value;
                for (var i = 0; i < this._kidsCount; i++) {
                    var item = this.itemAt(i);
                    if (i === value) {
                        item._dictionary.update('AS', _PdfName.get(item.value));
                        var name_5 = _PdfName.get(item.value);
                        this._dictionary.update('V', name_5);
                        this._dictionary.update('DV', name_5);
                    }
                    else {
                        item._dictionary.update('AS', _PdfName.get('Off'));
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRadioButtonListField.prototype, "borderColor", {
        /**
         * Gets the border color of the field.
         *
         * @returns {number[]} R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the border color of the field.
         * let borderColor: number[] = field.borderColor;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._parseBorderColor(!this._isLoaded);
        },
        /**
         * Sets the border color of the field.
         *
         * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets the border color of the field.
         * field.borderColor = [255, 0, 0];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._updateBorderColor(value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the item at the specified index.
     *
     * @param {number} index Index of the field item.
     * @returns {PdfRadioButtonListItem} Field item at the index.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the radio button list field
     * let field: PdfRadioButtonListField = form.fieldAt(0) as PdfRadioButtonListField;
     * // Gets the first list item.
     * let item: PdfRadioButtonListField = field.itemAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfRadioButtonListField.prototype.itemAt = function (index) {
        if (index < 0 || (index !== 0 && index >= this._kidsCount)) {
            throw Error('Index out of range.');
        }
        var item;
        if (this._parsedItems.has(index)) {
            item = this._parsedItems.get(index);
        }
        else {
            var dictionary = void 0;
            if (index >= 0 && this._kids && this._kids.length > 0 && index < this._kids.length) {
                var ref = this._kids[Number.parseInt(index.toString(), 10)];
                if (ref && ref instanceof _PdfReference) {
                    dictionary = this._crossReference._fetch(ref);
                }
                if (dictionary) {
                    item = PdfRadioButtonListItem._load(dictionary, this._crossReference, this);
                    item._ref = ref;
                    item._index = index;
                    this._parsedItems.set(index, item);
                }
            }
        }
        return item;
    };
    PdfRadioButtonListField.prototype.add = function (value, bounds) {
        if (value instanceof PdfRadioButtonListItem) {
            value._field = this;
            value._dictionary.update('Parent', this._ref);
            value._setField(this);
            return this._kidsCount;
        }
        else {
            return new PdfRadioButtonListItem(value, bounds, this);
        }
    };
    /**
     * Remove the radio button list item from the specified index.
     *
     * @param {number} index Item index to remove.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Remove the first item of the form field
     * field.removeItemAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfRadioButtonListField.prototype.removeItemAt = function (index) {
        var item = this.itemAt(index);
        if (item && item._ref) {
            var page = item._getPage();
            if (page) {
                page._removeAnnotation(item._ref);
            }
            this._kids.splice(index, 1);
            this._dictionary.set('Kids', this._kids);
            this._dictionary._updated = true;
            this._parsedItems.delete(index);
            if (this._parsedItems.size > 0) {
                var parsedItems_2 = new Map();
                this._parsedItems.forEach(function (value, key) {
                    if (key > index) {
                        parsedItems_2.set(key - 1, value);
                    }
                    else {
                        parsedItems_2.set(key, value);
                    }
                });
                this._parsedItems = parsedItems_2;
            }
            if (this._dictionary.has('Opt')) {
                var options = this._dictionary.getArray('Opt');
                if (options && options.length > 0) {
                    options.splice(index, 1);
                    this._dictionary.set('Opt', options);
                }
            }
        }
    };
    /**
     * Remove the specified radio button list field item.
     *
     * @param {PdfRadioButtonListItem} item Item to remove.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Remove the first item of the form field
     * field.removeItem(field.itemAt(0));
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfRadioButtonListField.prototype.removeItem = function (item) {
        if (item && item._ref) {
            var index = this._kids.indexOf(item._ref);
            if (index !== -1) {
                this.removeItemAt(index);
            }
        }
    };
    PdfRadioButtonListField.prototype._initialize = function (page, name) {
        this._defaultIndex = 0;
        this._crossReference = page._crossReference;
        this._page = page;
        this._name = name;
        this._dictionary = new _PdfDictionary(this._crossReference);
        this._ref = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(this._ref, this._dictionary);
        this._dictionary.objId = this._ref.toString();
        this._dictionary.update('FT', _PdfName.get('Btn'));
        this._dictionary.update('T', name);
        this._parsedItems = new Map();
        this._fieldFlags |= _FieldFlag.radio;
    };
    PdfRadioButtonListField.prototype._retrieveOptionValue = function () {
        if (this._dictionary.has('Opt')) {
            var options = this._dictionary.getArray('Opt');
            if (options && options.length > 0) {
                var itemsCount = this._kidsCount;
                var count = options.length <= itemsCount ? options.length : itemsCount;
                for (var i = 0; i < count; i++) {
                    if (options[Number.parseInt(i.toString(), 10)]) {
                        this.itemAt(i)._optionValue = options[Number.parseInt(i.toString(), 10)];
                    }
                }
            }
        }
    };
    PdfRadioButtonListField.prototype._obtainSelectedIndex = function () {
        var index = -1;
        for (var i = 0; i < this._kidsCount; ++i) {
            var item = this.itemAt(i);
            if (item) {
                var checkName = _getInheritableProperty(item._dictionary, 'V', false, true, 'Parent');
                if (checkName && item._dictionary.has('AS')) {
                    var asName = item._dictionary.get('AS');
                    if (asName && asName.name.toLowerCase() !== 'off') {
                        if (checkName instanceof _PdfName && checkName.name.toLowerCase() !== 'off') {
                            if (asName.name === checkName.name || item._optionValue === checkName.name) {
                                index = i;
                                break;
                            }
                        }
                        else if (typeof checkName === 'string' && checkName.toLowerCase() !== 'off') {
                            if (asName.name === checkName || item._optionValue === checkName) {
                                index = i;
                                break;
                            }
                        }
                    }
                }
            }
        }
        return index;
    };
    PdfRadioButtonListField.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        var count = this._kidsCount;
        if (this._isLoaded) {
            if (count > 0) {
                for (var i = 0; i < count; i++) {
                    var item = this.itemAt(i);
                    if (item && !this._checkFieldFlag(item._dictionary)) {
                        if (isFlatten) {
                            var template = void 0;
                            var state = this.selectedIndex === i ?
                                _PdfCheckFieldState.checked :
                                _PdfCheckFieldState.unchecked;
                            if (this._setAppearance || this._form._setAppearance || !item._dictionary.has('AP')) {
                                template = this._createAppearance(item, state);
                            }
                            else {
                                template = _getStateTemplate(state, item);
                            }
                            this._drawTemplate(template, item._getPage(), item.bounds);
                        }
                        else if (this._setAppearance || this._form._setAppearance || !item._isLoaded) {
                            item._postProcess(this.selectedIndex === i ? item.value : 'Off');
                            this._drawAppearance(item);
                        }
                        item._dictionary._updated = !isFlatten;
                    }
                }
            }
            else {
                var style = this.selectedIndex !== -1 ?
                    _PdfCheckFieldState.checked :
                    _PdfCheckFieldState.unchecked;
                this._drawTemplate(_getStateTemplate(style, this), this.page, this.bounds);
            }
        }
        else {
            for (var i = 0; i < count; i++) {
                var item = this.itemAt(i);
                var state = this.selectedIndex === i ? _PdfCheckFieldState.checked : _PdfCheckFieldState.unchecked;
                if (!this._isDuplicatePage) {
                    item._dictionary.update('AS', _PdfName.get(this.selectedIndex === i ? item.value : 'Off'));
                }
                if (isFlatten) {
                    var template = this._createAppearance(item, state);
                    this._drawTemplate(template, item._getPage(), item.bounds);
                }
                else if (!this._isDuplicatePage) {
                    item._postProcess(this.selectedIndex === i ? item.value : 'Off');
                    this._drawAppearance(item);
                }
                item._dictionary._updated = !isFlatten;
            }
        }
        this._dictionary._updated = !isFlatten;
    };
    PdfRadioButtonListField.prototype._createAppearance = function (widget, state) {
        var bounds = widget.bounds;
        var parameter = new _PaintParameter();
        parameter.bounds = [0, 0, bounds.width, bounds.height];
        var backcolor = widget.backColor;
        if (backcolor) {
            parameter.backBrush = new PdfBrush(backcolor);
        }
        parameter.foreBrush = new PdfBrush(widget.color);
        var border = widget.border;
        if (widget.borderColor) {
            parameter.borderPen = new PdfPen(widget.borderColor, border.width);
        }
        parameter.borderWidth = border.width;
        parameter.borderStyle = border.style;
        if (backcolor) {
            var shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
            var color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                shadowColor[1] >= 0 ? shadowColor[1] : 0,
                shadowColor[2] >= 0 ? shadowColor[2] : 0];
            parameter.shadowBrush = new PdfBrush(color);
        }
        parameter.rotationAngle = widget.rotate;
        var template = new PdfTemplate(parameter.bounds, this._crossReference);
        var graphics = template.graphics;
        if (widget._styleText) {
            this._drawRadioButton(graphics, parameter, widget._styleText, state);
        }
        else {
            this._drawRadioButton(graphics, parameter, _styleToString(widget.style), state);
        }
        return template;
    };
    PdfRadioButtonListField.prototype._drawAppearance = function (item) {
        var appearance = new _PdfDictionary();
        if (item._dictionary.has('AP')) {
            appearance = item._dictionary.get('AP');
            if (appearance) {
                if (appearance.has('N')) {
                    _removeReferences(appearance.get('N'), this._crossReference, item.value, 'Off');
                }
                if (appearance.has('D')) {
                    _removeReferences(appearance.get('D'), this._crossReference, item.value, 'Off');
                }
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            _removeDuplicateReference(appearance, this._crossReference, 'D');
        }
        else {
            var reference = this._crossReference._getNextReference();
            appearance = new _PdfDictionary(this._crossReference);
            this._crossReference._cacheMap.set(reference, appearance);
            item._dictionary.update('AP', reference);
        }
        var normalChecked = this._createAppearance(item, _PdfCheckFieldState.checked);
        var normalCheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(normalCheckedReference, normalChecked._content);
        var normalUnchecked = this._createAppearance(item, _PdfCheckFieldState.unchecked);
        var normalUncheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(normalUncheckedReference, normalUnchecked._content);
        var normalDictionary = new _PdfDictionary(this._crossReference);
        var actualValue = item.value;
        if (!actualValue && item._enableGrouping) {
            actualValue = 'check' + item._index;
        }
        normalDictionary.update(actualValue, normalCheckedReference);
        normalDictionary.update('Off', normalUncheckedReference);
        var normalReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(normalReference, normalDictionary);
        appearance.update('N', normalReference);
        var pressChecked = this._createAppearance(item, _PdfCheckFieldState.pressedChecked);
        var pressCheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(pressCheckedReference, pressChecked._content);
        var pressUnchecked = this._createAppearance(item, _PdfCheckFieldState.pressedUnchecked);
        var pressUncheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(pressUncheckedReference, pressUnchecked._content);
        var pressedDictionary = new _PdfDictionary(this._crossReference);
        pressedDictionary.update(actualValue, pressCheckedReference);
        pressedDictionary.update('Off', pressUncheckedReference);
        var pressedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(pressedReference, pressedDictionary);
        appearance.update('D', pressedReference);
        item._dictionary._updated = true;
    };
    return PdfRadioButtonListField;
}(PdfField));
/**
 * Represents the base class for list box and combo box fields.
 *
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0);
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Access the combo box field
 * let comboBoxField: PdfListField = form.fieldAt(0) as PdfListField;
 * // Gets the count of the loaded combo box field items.
 * let comboItemsCount: number = comboBoxField.itemsCount;
 * // Access the list box field
 * let listBoxField: PdfListField = form.fieldAt(1) as PdfListField;
 * // Gets the count of the loaded list box field items.
 * let ListItemsCount: number = listBoxField.itemsCount;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfListField = /** @class */ (function (_super) {
    __extends$5(PdfListField, _super);
    function PdfListField() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(PdfListField.prototype, "itemsCount", {
        /**
         * Gets the count of the loaded field items (Read only).
         *
         * @returns {number} Items count.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Access the combo box field
         * let comboBoxField: PdfComboBoxField = form.fieldAt(0) as PdfComboBoxField;
         * // Gets the count of the loaded combo box field items.
         * let comboItemsCount: number = comboBoxField.itemsCount;
         * // Access the list box field
         * let listBoxField: PdfListBoxField = form.fieldAt(1) as PdfListBoxField;
         * // Gets the count of the loaded list box field items.
         * let ListItemsCount: number = listBoxField.itemsCount;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._options.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListField.prototype, "bounds", {
        /**
         * Gets the bounds.
         *
         * @returns {{ x: number, y: number, width: number, height: number }} Bounds.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Access the combo box field
         * let comboBoxField: PdfComboBoxField = form.fieldAt(0) as PdfComboBoxField;
         * // Gets the bounds of combo box field.
         * let comboBoxBounds: {x: number, y: number, width: number, height: number} = comboBoxField.bounds;
         * // Access the combo box field
         * let listBoxField: PdfListBoxField = form.fieldAt(1) as PdfListBoxField;
         * // Gets the bounds of list box field.
         * let listBoxBounds: {x: number, y: number, width: number, height: number} = listBoxField.bounds;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var value;
            var widget = this.itemAt(this._defaultIndex);
            if (widget) {
                widget._page = this.page;
            }
            if (widget && widget.bounds) {
                value = widget.bounds;
            }
            else if (this._dictionary.has('Rect')) {
                value = _calculateBounds(this._dictionary, this.page);
            }
            if (value) {
                return value;
            }
            else if (this._bounds) {
                return this._bounds;
            }
            return value;
        },
        /**
         * Sets the bounds.
         *
         * @param {{ x: number, y: number, width: number, height: number }} value bounds.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Access the combo box field
         * let comboBoxField: PdfComboBoxField = form.fieldAt(0) as PdfComboBoxField;
         * // Sets the bounds of combo box field.
         * comboBoxField.bounds = {x: 10, y: 10, width: 100, height: 30};
         * // Access the list box field
         * let listBoxField: PdfListBoxField = form.fieldAt(1) as PdfListBoxField;
         * // Sets the bounds of list box field.
         * listBoxField.bounds = {x: 10, y: 50, width: 100, height: 30};
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value.x === 0 && value.y === 0 && value.width === 0 && value.height === 0) {
                throw new Error('Cannot set empty bounds');
            }
            var widget = this.itemAt(this._defaultIndex);
            if (this._isLoaded) {
                if (typeof widget === 'undefined' || this._dictionary.has('Rect')) {
                    this._dictionary.update('Rect', _getUpdatedBounds([value.x, value.y, value.width, value.height], this.page));
                }
                else {
                    widget._page = this.page;
                    widget.bounds = value;
                }
            }
            else {
                if (widget) {
                    widget._page = this.page;
                    widget.bounds = value;
                }
                else {
                    this._bounds = value;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListField.prototype, "selectedIndex", {
        /**
         * Gets the selected item index or indexes.
         *
         * @returns {number | number[]} Index.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Access the combo box field
         * let comboBoxfield: PdfComboBoxField = form.fieldAt(0) as PdfComboBoxField;
         * // Gets the selected item index or indexes from combo box field.
         * let comboBoxIndex: number = comboBoxfield.selectedIndex;
         * // Access the list box field
         * let listBoxField: PdfListBoxField = form.fieldAt(1) as PdfListBoxField;
         * // Gets the selected item index or indexes from list box field.
         * let listBoxIndex: number = listBoxField.selectedIndex;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var value = this._dictionary.get('I');
            if (typeof value === 'undefined') {
                return [];
            }
            else {
                if (value.length === 1) {
                    return value[0];
                }
                else {
                    return value;
                }
            }
        },
        /**
         * Sets the selected item index or indexes.
         *
         * @param {number | number[]} value Selected index.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Create a new list box field
         * let listField: PdfListField = new PdfListBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
         * // Add list items to the field.
         * listField.addItem(new PdfListFieldItem('English', 'English'));
         * listField.addItem(new PdfListFieldItem('French', 'French'));
         * listField.addItem(new PdfListFieldItem('German', 'German'));
         * // Sets the selected index
         * listField.selectedIndex = 2;
         * // Sets the flag indicates whether the list box allows multiple selections.
         * listField.multiSelect = true;
         * // Add the field into PDF form
         * form.add(listField);
         * // Create a new combo box field
         * let comboField: PdfComboBoxField = new PdfComboBoxField(page, 'list1', {x: 100, y: 160, width: 100, height: 50});
         * // Add list items to the field.
         * comboField.addItem(new PdfListFieldItem('English', 'English'));
         * comboField.addItem(new PdfListFieldItem('French', 'French'));
         * comboField.addItem(new PdfListFieldItem('German', 'German'));
         * // Sets the selected index
         * comboField.selectedIndex = 2;
         * // Sets the flag indicates whether the combo box allows multiple selections.
         * comboField.multiSelect = true;
         * // Add the field into PDF form
         * form.add(comboField);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            var _this = this;
            var length = this._options.length;
            if (typeof value === 'number') {
                this._checkIndex(value, length);
                this._dictionary.update('I', [value]);
                this._dictionary.update('V', [this._options[Number.parseInt(value.toString(), 10)][0]]);
            }
            else {
                var values_1 = [];
                value.forEach(function (entry) {
                    _this._checkIndex(entry, length);
                    values_1.push(_this._options[Number.parseInt(entry.toString(), 10)][0]);
                });
                this._dictionary.update('I', value);
                this._dictionary.update('V', values_1);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListField.prototype, "selectedValue", {
        /**
         * Gets the selected item value or values.
         *
         * @returns {string | string[]} Selected values.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Access the list box field
         * let listBoxField: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;
         * // Gets the selected item value or values from list box field.
         * if (listBoxField.multiSelect) {
         *     let listBoxValues: string[]; = listBoxField.selectedValue;
         * } else {
         *    let listBoxValues: string = listBoxField.selectedValue;
         * }
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var _this = this;
            var values = [];
            if (this._dictionary && this._dictionary.has('V')) {
                var value = this._dictionary.getArray('V'); // eslint-disable-line
                if (typeof value !== 'undefined') {
                    if (Array.isArray(value)) {
                        value.forEach(function (element) {
                            values.push(element);
                        });
                    }
                    else if (typeof value === 'string') {
                        values.push(value);
                    }
                }
            }
            if (values.length === 0 && this._dictionary && this._dictionary.has('I')) {
                var value = this._dictionary.get('I');
                if (value && value.length > 0) {
                    value.forEach(function (index) {
                        values.push(_this._options[Number.parseInt(index.toString(), 10)][0]);
                    });
                }
            }
            if (values.length === 1) {
                return values[0];
            }
            else {
                return values;
            }
        },
        /**
         * Sets the selected item value or values.
         *
         * @param {string | string[]} value Selected values.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Create a new list box field
         * let listField: PdfListField = new PdfListBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
         * // Add list items to the field.
         * listField.addItem(new PdfListFieldItem('English', 'English'));
         * listField.addItem(new PdfListFieldItem('French', 'French'));
         * listField.addItem(new PdfListFieldItem('German', 'German'));
         * // Sets the flag indicates whether the list box allows multiple selections.
         * listField.multiSelect = true;
         * // Sets the selected values
         * listField.selectedValue = ['English', 'German'];
         * // Add the field into PDF form
         * form.add(listField);
         * // Create a new combo box field
         * let comboField: PdfComboBoxField = new PdfComboBoxField(page, 'list1', {x: 100, y: 160, width: 100, height: 50});
         * // Add list items to the field.
         * comboField.addItem(new PdfListFieldItem('English', 'English'));
         * comboField.addItem(new PdfListFieldItem('French', 'French'));
         * comboField.addItem(new PdfListFieldItem('German', 'German'));
         * // Sets the selected value
         * comboField.selectedValue = ['French'];
         * // Add the field into PDF form
         * form.add(comboField);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            var _this = this;
            if (typeof value === 'string') {
                var index = this._tryGetIndex(value);
                if (index !== -1) {
                    this._dictionary.update('I', [index]);
                    this._dictionary.update('V', [value]);
                }
            }
            else {
                var values_2 = [];
                var indices_1 = [];
                value.forEach(function (entry) {
                    var index = _this._tryGetIndex(entry);
                    if (index !== -1) {
                        indices_1.push(index);
                        values_2.push(entry);
                    }
                });
                if (values_2.length > 0) {
                    this._dictionary.update('I', indices_1);
                    this._dictionary.update('V', values_2);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListField.prototype, "multiSelect", {
        /**
         * Gets the flag indicates whether the list field allows multiple selections.
         *
         * @returns {boolean} Value indicates whether the list field allows multiple selections.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Access the combo box field
         * let comboBoxField: PdfComboBoxField = form.fieldAt(0) as PdfComboBoxField;
         * // Gets the flag indicates whether the combo box allows multiple selections.
         * let comboBoxFlag: Boolean = comboBoxField.multiSelect;
         * // Access the list box field
         * let listBoxField: PdfListBoxField = form.fieldAt(1) as PdfListBoxField;
         * // Gets the flag indicates whether the list box allows multiple selections.
         * let listBoxFlag: boolean = listBoxField.multiSelect;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoaded) {
                return (this._fieldFlags & _FieldFlag.multiSelect) !== 0;
            }
            else {
                return this._multiSelect;
            }
        },
        /**
         * Sets the flag indicates whether the list field allows multiple selections.
         *
         * @param {boolean} value Indicates whether the list field allows multiple selections.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Create a new list box field
         * let listField: PdfListField = new PdfListBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
         * // Add list items to the field.
         * listField.addItem(new PdfListFieldItem('English', 'English'));
         * listField.addItem(new PdfListFieldItem('French', 'French'));
         * listField.addItem(new PdfListFieldItem('German', 'German'));
         * // Sets the selected index
         * listField.selectedIndex = 2;
         * // Sets the flag indicates whether the list box allows multiple selections.
         * listField.multiSelect = true;
         * // Add the field into PDF form
         * form.add(listField);
         * // Create a new combo box field
         * let comboField: PdfComboBoxField = new PdfComboBoxField(page, 'list1', {x: 100, y: 160, width: 100, height: 50});
         * // Add list items to the field.
         * comboField.addItem(new PdfListFieldItem('English', 'English'));
         * comboField.addItem(new PdfListFieldItem('French', 'French'));
         * comboField.addItem(new PdfListFieldItem('German', 'German'));
         * // Sets the selected index
         * comboField.selectedIndex = 2;
         * // Sets the flag indicates whether the combo box allows multiple selections.
         * comboField.multiSelect = true;
         * // Add the field into PDF form
         * form.add(comboField);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this.multiSelect !== value) {
                this._multiSelect = value;
                if (value) {
                    this._fieldFlags |= _FieldFlag.multiSelect;
                }
                else {
                    this._fieldFlags &= ~_FieldFlag.multiSelect;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListField.prototype, "editable", {
        /**
         * Gets the flag indicates whether the list field is editable.
         *
         * @returns {boolean} Value indicates whether the list field is editable.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Access the combo box field
         * let comboBoxField: PdfComboBoxField = form.fieldAt(0) as PdfComboBoxField;
         * // Gets the flag indicates whether the combo box is editable.
         * let comboBoxFlag: Boolean = comboBoxField.editable;
         * // Access the list box field
         * let listBoxField: PdfListBoxField = form.fieldAt(1) as PdfListBoxField;
         * // Gets the flag indicates whether the list box is editable.
         * let listBoxFlag: boolean = listBoxField.editable;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoaded) {
                return (this._fieldFlags & _FieldFlag.edit) !== 0;
            }
            else {
                return this._editable;
            }
        },
        /**
         * Sets the flag indicates whether the list field is editable.
         *
         * @param {boolean} value Indicates whether the list field is editable.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Create a new list box field
         * let listField: PdfListField = new PdfListBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
         * // Add list items to the field.
         * listField.addItem(new PdfListFieldItem('English', 'English'));
         * listField.addItem(new PdfListFieldItem('French', 'French'));
         * listField.addItem(new PdfListFieldItem('German', 'German'));
         * // Sets the selected index
         * listField.selectedIndex = 2;
         * // Sets the flag indicates whether the list box is editable.
         * listField.editable = true;
         * // Add the field into PDF form
         * form.add(listField);
         * // Create a new combo box field
         * let comboField: PdfComboBoxField = new PdfComboBoxField(page, 'list1', {x: 100, y: 160, width: 100, height: 50});
         * // Add list items to the field.
         * comboField.addItem(new PdfListFieldItem('English', 'English'));
         * comboField.addItem(new PdfListFieldItem('French', 'French'));
         * comboField.addItem(new PdfListFieldItem('German', 'German'));
         * // Sets the selected index
         * comboField.selectedIndex = 2;
         * // Sets the flag indicates whether the combo box is editable.
         * comboField.editable = true;
         * // Add the field into PDF form
         * form.add(comboField);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._editable !== value) {
                this._editable = value;
                if (value) {
                    this._fieldFlags |= _FieldFlag.edit;
                }
                else {
                    this._fieldFlags &= ~_FieldFlag.edit;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListField.prototype, "font", {
        /**
         * Gets the font of the field.
         *
         * @returns {PdfFont} font.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfListBoxField = document.form.fieldAt(0) as PdfListBoxField;
         * // Gets the font of the field.
         * let font: PdfFont = field.font;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._font) {
                return this._font;
            }
            else {
                var widget = this.itemAt(this._defaultIndex);
                this._font = _obtainFontDetails(this._form, widget, this);
            }
            return this._font;
        },
        /**
         * Sets the font of the field.
         *
         * @param {PdfFont} value font.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfListBoxField = document.form.fieldAt(0) as PdfListBoxField;
         * // Sets the font of the field
         * field.font = new PdfStandardFont(PdfFontFamily.helvetica, 12, PdfFontStyle.bold);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value && value instanceof PdfFont) {
                this._font = value;
                this._initializeFont(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListField.prototype, "textAlignment", {
        /**
         * Gets the text alignment in a combo box field.
         *
         * @returns {PdfTextAlignment} Text alignment.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access combo box field
         * let field: PdfComboBoxField = document.form.fieldAt(0) as PdfComboBoxField;
         * // Gets the text alignment from combo box field
         * let alignment: PdfTextAlignment = field.textAlignment;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._getTextAlignment();
        },
        /**
         * Sets the text alignment in a combo box field.
         *
         * @param {PdfTextAlignment} value Text alignment.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access combo box field
         * let field: PdfComboBoxField = document.form.fieldAt(0) as PdfComboBoxField;
         * // Sets the text alignment of form field as center
         * field.textAlignment = PdfTextAlignment.center;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._textAlignment !== value) {
                this._setTextAlignment(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListField.prototype, "backColor", {
        /**
         * Gets the background color of the field.
         *
         * @returns {number[]} R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the background color of the field.
         * let backColor: number[] = field.backColor;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._parseBackColor(true);
        },
        /**
         * Sets the background color of the field.
         *
         * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the list field at index 0
         * let list1: PdfField = document.form.fieldAt(0);
         * // Sets the background color of the field.
         * list1.backColor = [255, 0, 0];
         * // Access the list field at index 1
         * let list2: PdfField = document.form.fieldAt(1);
         * // Sets the background color of the field to transparent.
         * list2.backColor = [0, 0, 0, 0];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._updateBackColor(value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListField.prototype, "_options", {
        get: function () {
            if (!this._optionArray) {
                if (this._dictionary && this._dictionary.has('Opt')) {
                    this._optionArray = this._dictionary.getArray('Opt');
                }
                else {
                    this._optionArray = [];
                    this._dictionary.update('Opt', this._optionArray);
                }
            }
            return this._optionArray;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the item at the specified index.
     *
     * @param {number} index Index of the field item.
     * @returns {PdfListFieldItem} Field item at the index.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the list box field
     * let listBox: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;
     * // Gets the first list item.
     * let listBoxItem: PdfListFieldItem = listBox.itemAt(0);
     * // Access the combo box field
     * let comboBox: PdfComboBoxField = form.fieldAt(1) as PdfComboBoxField;
     * // Gets the first list item.
     * let comboBoxItem: PdfListFieldItem = comboBox.itemAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfListField.prototype.itemAt = function (index) {
        var item;
        if (index < this._kidsCount) {
            if (this._parsedItems.has(index)) {
                item = this._parsedItems.get(index);
            }
            else {
                var dictionary = void 0;
                var reference = this._kids[Number.parseInt(index.toString(), 10)];
                if (reference && reference instanceof _PdfReference) {
                    dictionary = this._crossReference._fetch(reference);
                }
                if (dictionary) {
                    item = PdfListFieldItem._load(dictionary, this._crossReference, this);
                    item._index = index;
                    item._ref = reference;
                    if (this._options && this._options.length > 0 && index < this._options.length) {
                        item._text = this._options[Number.parseInt(index.toString(), 10)][1];
                    }
                    else {
                        item._text = '';
                    }
                    this._parsedItems.set(index, item);
                }
            }
        }
        else {
            if (this._parsedItems.has(index)) {
                item = this._parsedItems.get(index);
            }
            else if (this._kidsCount > 0 && this._kids && this._kids.length > 0) {
                var dictionary = void 0;
                var reference = void 0;
                if (this._kidsCount === 1) {
                    reference = this._kids[0];
                }
                else {
                    reference = this._kids[Number.parseInt(index.toString(), 10)];
                }
                if (reference && reference instanceof _PdfReference) {
                    dictionary = this._crossReference._fetch(reference);
                }
                if (dictionary) {
                    item = PdfListFieldItem._load(dictionary, this._crossReference, this);
                    item._index = index;
                    item._ref = reference;
                    if (this._options && this._options.length > 0 && index < this._options.length) {
                        item._text = this._options[Number.parseInt(index.toString(), 10)][1];
                    }
                    else {
                        item._text = '';
                    }
                    this._parsedItems.set(index, item);
                }
            }
        }
        return item;
    };
    /**
     * Add list item.
     *
     * @param {PdfListFieldItem} item Item to add.
     * @returns {number} Index of the field item.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Create a new list box field
     * let listField: PdfListField = new PdfListBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
     * // Add list items to the field.
     * listField.addItem(new PdfListFieldItem('English', 'English'));
     * listField.addItem(new PdfListFieldItem('French', 'French'));
     * listField.addItem(new PdfListFieldItem('German', 'German'));
     * // Sets the selected index
     * listField.selectedIndex = 2;
     * // Sets the flag indicates whether the list box allows multiple selections.
     * listField.multiSelect = true;
     * // Add the field into PDF form
     * form.add(listField);
     * // Create a new combo box field
     * let comboField: PdfComboBoxField = new PdfComboBoxField(page, 'list1', {x: 100, y: 160, width: 100, height: 50});
     * // Add list items to the field.
     * comboField.addItem(new PdfListFieldItem('English', 'English'));
     * comboField.addItem(new PdfListFieldItem('French', 'French'));
     * comboField.addItem(new PdfListFieldItem('German', 'German'));
     * // Sets the selected index
     * comboField.selectedIndex = 2;
     * // Sets the flag indicates whether the combo box allows multiple selections.
     * comboField.multiSelect = true;
     * // Add the field into PDF form
     * form.add(comboField);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfListField.prototype.addItem = function (item) {
        this._addToOptions(item, this);
        return this._listValues.length - 1;
    };
    /**
     * Remove the list item from the specified index.
     *
     * @param {number} index Item index to remove.
     * @returns {void} Nothing.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the list box field
     * let listBoxField: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;
     * // Remove the list item from the list box field
     * listBoxField.removeItemAt(1);
     * // Access the combo box field
     * let comboBoxField: PdfComboBoxField = form.fieldAt(1) as PdfComboBoxField;
     * // Remove the list item from the combo box field
     * comboBoxField.removeItemAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfListField.prototype.removeItemAt = function (index) {
        var item = this.itemAt(index);
        if (item && item._ref) {
            this._parsedItems.delete(index);
            if (this._parsedItems.size > 0) {
                var parsedItems_3 = new Map();
                this._parsedItems.forEach(function (value, key) {
                    if (key > index) {
                        parsedItems_3.set(key - 1, value);
                    }
                    else {
                        parsedItems_3.set(key, value);
                    }
                });
                this._parsedItems = parsedItems_3;
            }
            if (this._dictionary && this._dictionary.has('Opt')) {
                var options = this._options;
                if (options && options.length > 0) {
                    options.splice(index, 1);
                    this._dictionary.set('Opt', options);
                    this._optionArray = options;
                    this._dictionary._updated = true;
                }
            }
        }
    };
    /**
     * Remove the list item.
     *
     * @param {PdfListFieldItem} item Item to remove.
     * @returns {void} Nothing.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the list box field
     * let listBoxField: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;
     * // Remove the list item from the list box field
     * listBoxField.removeItem(listBoxField.itemAt(1));
     * // Access the combo box field
     * let comboBoxField: PdfComboBoxField = form.fieldAt(1) as PdfComboBoxField;
     * // Remove the list item from the combo box field
     * comboBoxField.removeItem(comboBoxField.itemAt(0));
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfListField.prototype.removeItem = function (item) {
        if (item && item.text) {
            var index = void 0;
            for (var i = 0; i < this.itemsCount; i++) {
                var fieldItem = this.itemAt(i);
                if (fieldItem && item === fieldItem && fieldItem.text === item.text) {
                    index = i;
                    break;
                }
            }
            if (index !== -1) {
                this.removeItemAt(index);
            }
        }
    };
    PdfListField.prototype._initialize = function (page, name, bounds) {
        this._defaultIndex = 0;
        this._crossReference = page._crossReference;
        this._page = page;
        this._name = name;
        this._dictionary = new _PdfDictionary(this._crossReference);
        this._ref = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(this._ref, this._dictionary);
        this._dictionary.objId = this._ref.toString();
        this._dictionary.update('FT', _PdfName.get('Ch'));
        this._dictionary.update('T', name);
        this._parsedItems = new Map();
        this._listValues = [];
        this._kids = [];
        this.bounds = bounds;
        this._addEmptyWidget();
    };
    PdfListField.prototype._obtainFont = function (item) {
        var fontFamily = '';
        var fontSize = 1;
        if (item && (item._dictionary.has('DS') || item._dictionary.has('DA'))) {
            if (item._dictionary.has('DS')) {
                var collection = item._dictionary.get('DS').split(';');
                for (var i = 0; i < collection.length; i++) {
                    var entry = collection[Number.parseInt(i.toString(), 10)].split(':');
                    if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-family') !== -1) {
                        fontFamily = entry[1];
                    }
                    else if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-size') !== -1) {
                        if (entry[1].endsWith('pt')) {
                            fontSize = Number.parseFloat(entry[1].replace('pt', ''));
                        }
                    }
                    else if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-style') === -1 && collection[Number.parseInt(i.toString(), 10)].indexOf('font') !== -1) {
                        var name_6 = entry[1];
                        var split = name_6.split(' ');
                        for (var j = 0; j < split.length; j++) {
                            if (split[Number.parseInt(j.toString(), 10)] !== '' && !split[Number.parseInt(j.toString(), 10)].endsWith('pt')) {
                                fontFamily += split[Number.parseInt(j.toString(), 10)] + ' ';
                            }
                            if (split[Number.parseInt(j.toString(), 10)].endsWith('pt')) {
                                fontSize = Number.parseFloat(split[Number.parseInt(j.toString(), 10)].replace('pt', ''));
                            }
                        }
                        while (fontFamily !== ' ' && fontFamily.endsWith(' ')) {
                            fontFamily = fontFamily.substring(0, fontFamily.length - 2);
                        }
                        if (fontFamily.indexOf(',') !== -1) {
                            fontFamily = fontFamily.split(',')[0];
                        }
                    }
                }
            }
            else {
                var value = item._dictionary.get('DA');
                if (value && value !== '' && value.indexOf('Tf') !== -1) {
                    var textCollection = value.split(' ');
                    for (var i = 0; i < textCollection.length; i++) {
                        if (textCollection[Number.parseInt(i.toString(), 10)].indexOf('Tf') !== -1) {
                            fontFamily = textCollection[i - 2];
                            while (fontFamily !== '' && fontFamily.length > 1 && fontFamily[0] === '/') {
                                fontFamily = fontFamily.substring(1);
                            }
                            fontSize = Number.parseFloat(textCollection[i - 1]);
                        }
                    }
                    var height = 0.0;
                    if (fontSize === 0) {
                        var font = new PdfStandardFont(PdfFontFamily.helvetica, height);
                        if (font !== null) {
                            height = this._getFontHeight(font._fontFamily);
                            if (Number.isNaN(height) || height === 0) {
                                height = 12;
                            }
                            font._size = height;
                            fontSize = height;
                        }
                    }
                }
            }
            fontFamily = fontFamily.trim();
            switch (fontFamily) {
                case 'Helv':
                    this._font = new PdfStandardFont(PdfFontFamily.helvetica, fontSize, PdfFontStyle.regular);
                    break;
                case 'Courier':
                case 'Cour':
                    this._font = new PdfStandardFont(PdfFontFamily.courier, fontSize, PdfFontStyle.regular);
                    break;
                case 'Symb':
                    this._font = new PdfStandardFont(PdfFontFamily.symbol, fontSize, PdfFontStyle.regular);
                    break;
                case 'TiRo':
                    this._font = new PdfStandardFont(PdfFontFamily.timesRoman, fontSize, PdfFontStyle.regular);
                    break;
                case 'ZaDb':
                    this._font = new PdfStandardFont(PdfFontFamily.zapfDingbats, fontSize, PdfFontStyle.regular);
                    break;
                default:
                    this._font = new PdfStandardFont(PdfFontFamily.helvetica, fontSize, PdfFontStyle.regular);
                    break;
            }
        }
        return this._font;
    };
    PdfListField.prototype._obtainSelectedValue = function () {
        var _this = this;
        var result = [];
        if (this._dictionary.has('V')) {
            var primitive = this._dictionary.get('V'); // eslint-disable-line
            var array = this._dictionary.getArray('V'); // eslint-disable-line
            if (primitive !== null && typeof primitive !== 'undefined') {
                if (typeof primitive === 'string') {
                    result.push(primitive);
                }
                else if (Array.isArray(primitive)) {
                    array.forEach(function (element) {
                        result.push(element);
                    });
                }
            }
        }
        else {
            var selectedIndexes = this._dictionary.get('I');
            if (selectedIndexes !== null &&
                typeof selectedIndexes !== 'undefined' &&
                selectedIndexes.length > 0 &&
                selectedIndexes[0] > -1 &&
                this._options &&
                this._options.length > 0) {
                selectedIndexes.forEach(function (index) {
                    result.push(_this._options[Number.parseInt(index.toString(), 10)][0]);
                });
            }
        }
        return result;
    };
    PdfListField.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (isFlatten || this._setAppearance || this._form._setAppearance) {
            var count = this._kidsCount;
            if (this._kids && this._kids.length > 0) {
                if (count > 1) {
                    for (var i = 0; i < count; i++) {
                        var item = this.itemAt(i);
                        if (item && !this._checkFieldFlag(item._dictionary)) {
                            var template = this._createAppearance(item);
                            if (isFlatten) {
                                var page = item._getPage();
                                if (page) {
                                    this._drawTemplate(template, page, item.bounds);
                                }
                            }
                            else {
                                this._addAppearance(item._dictionary, template, 'N');
                            }
                            item._dictionary._updated = !isFlatten;
                        }
                    }
                }
                else {
                    var item = this.itemAt(0);
                    var template = this._createAppearance();
                    if (isFlatten) {
                        var page = this.page;
                        if (page) {
                            this._drawTemplate(template, page, this.bounds);
                        }
                    }
                    else {
                        this._addAppearance(item._dictionary, template, 'N');
                    }
                    item._dictionary._updated = !isFlatten;
                }
            }
            else if (this._dictionary) {
                var template = this._createAppearance();
                if (isFlatten) {
                    var page = this.page;
                    if (page) {
                        this._drawTemplate(template, page, this.bounds);
                    }
                }
                else {
                    this._addAppearance(this._dictionary, template, 'N');
                }
            }
            this._dictionary._updated = !isFlatten;
        }
    };
    PdfListField.prototype._tryGetIndex = function (value) {
        var index = -1;
        if (this._options && this._options.length > 0) {
            for (var i = 0; i < this._options.length; i++) {
                if (value === this._options[Number.parseInt(i.toString(), 10)][0]) {
                    index = i;
                    break;
                }
            }
        }
        return index;
    };
    PdfListField.prototype._addEmptyWidget = function () {
        var widget = new PdfWidgetAnnotation();
        widget._create(this._page, this.bounds, this);
        this._addToKid(widget);
        widget._dictionary.update('MK', new _PdfDictionary(this._crossReference));
        widget._mkDictionary.update('BC', [0, 0, 0]);
        widget._mkDictionary.update('BG', [1, 1, 1]);
        widget._dictionary.update('DA', '/TiRo 0 Tf 0 0 0 rg');
    };
    return PdfListField;
}(PdfField));
/**
 * `PdfComboBoxField` class represents the combo box field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0);
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new combo box field
 * let field: PdfComboBoxField = new PdfComboBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
 * // Add list items to the field.
 * field.addItem(new PdfListFieldItem('English', 'English'));
 * field.addItem(new PdfListFieldItem('French', 'French'));
 * field.addItem(new PdfListFieldItem('German', 'German'));
 * // Sets the selected index
 * field.selectedIndex = 2;
 * // Sets the flag indicates whether the combo box allows multiple selections.
 * field.multiSelect = true;
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfComboBoxField = /** @class */ (function (_super) {
    __extends$5(PdfComboBoxField, _super);
    function PdfComboBoxField(page, name, bounds) {
        var _this = _super.call(this) || this;
        if (page && name && bounds) {
            _this._initialize(page, name, bounds);
            _this._fieldFlags |= _FieldFlag.combo;
        }
        return _this;
    }
    Object.defineProperty(PdfComboBoxField.prototype, "_isAutoFontSize", {
        /**
         * Gets the boolean flag indicates whether the combo box field is auto size.
         *
         * @private
         * @returns {boolean} Returns the boolean value to check auto size.
         */
        get: function () {
            var isAutoFontSize = false;
            if (this._isLoaded && this._form) {
                var acroForm = this._form._dictionary;
                if (acroForm && acroForm.has('DA')) {
                    var fontString = acroForm.get('DA');
                    if (fontString) {
                        var defaultAppearance = new _PdfDefaultAppearance(fontString);
                        if (defaultAppearance.fontSize === 0) {
                            if (this._kids && this._kids.length > 0) {
                                var fontSize = false;
                                if (this._dictionary.has('DA')) {
                                    fontString = this._dictionary.get('DA');
                                    if (fontString) {
                                        defaultAppearance = new _PdfDefaultAppearance(fontString);
                                        if (defaultAppearance && defaultAppearance.fontSize > 0) {
                                            fontSize = true;
                                        }
                                    }
                                }
                                if (!fontSize) {
                                    for (var i = 0; i < this._kids.length; i++) {
                                        var dictionary = void 0;
                                        var reference = this._kids[Number.parseInt(i.toString(), 10)];
                                        if (reference && reference instanceof _PdfReference) {
                                            dictionary = this._crossReference._fetch(reference);
                                        }
                                        if (dictionary) {
                                            if (dictionary.has('DA')) {
                                                fontString = dictionary.get('DA');
                                                var height = 0;
                                                if (fontString) {
                                                    defaultAppearance = new _PdfDefaultAppearance(fontString);
                                                    if (defaultAppearance) {
                                                        height = defaultAppearance.fontSize;
                                                    }
                                                }
                                                if (height === 0) {
                                                    isAutoFontSize = true;
                                                }
                                            }
                                            else {
                                                isAutoFontSize = true;
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                if (this._dictionary.has('DA')) {
                                    fontString = this._dictionary.get('DA');
                                    var height = 0;
                                    if (fontString) {
                                        defaultAppearance = new _PdfDefaultAppearance(fontString);
                                        if (defaultAppearance) {
                                            height = defaultAppearance.fontSize;
                                        }
                                    }
                                    if (height === 0) {
                                        isAutoFontSize = true;
                                    }
                                }
                                else {
                                    isAutoFontSize = true;
                                }
                            }
                        }
                    }
                }
            }
            return isAutoFontSize;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Parse an existing combo box field.
     *
     * @private
     * @param {PdfForm} form Form object.
     * @param {_PdfDictionary} dictionary Field dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference object.
     * @param {_PdfReference} reference Field reference.
     * @returns {PdfComboBoxField} Combo box field.
     */
    PdfComboBoxField._load = function (form, dictionary, crossReference, reference) {
        var field = new PdfComboBoxField();
        field._isLoaded = true;
        field._form = form;
        field._dictionary = dictionary;
        field._crossReference = crossReference;
        field._ref = reference;
        if (field._dictionary.has('Kids')) {
            field._kids = field._dictionary.get('Kids');
        }
        var options = field._dictionary.getArray('Opt');
        if (options !== null && typeof options !== 'undefined') {
            field._listValues = new Array(options.length);
        }
        field._defaultIndex = 0;
        field._parsedItems = new Map();
        if (field._kidsCount > 0) {
            field._retrieveOptionValue();
        }
        return field;
    };
    PdfComboBoxField.prototype._retrieveOptionValue = function () {
        if (this._dictionary.has('Opt')) {
            var options = this._dictionary.getArray('Opt');
            if (options && options.length > 0) {
                var itemsCount = this._kidsCount;
                var count = options.length <= itemsCount ? options.length : itemsCount;
                for (var i = 0; i < count; i++) {
                    var text = options[Number.parseInt(i.toString(), 10)][1];
                    if (text) {
                        this.itemAt(i)._text = text ? text : '';
                    }
                }
            }
        }
    };
    PdfComboBoxField.prototype._createAppearance = function (item) {
        var parameter = new _PaintParameter();
        if (item) {
            var bounds = item.bounds;
            var page = item._getPage();
            if (item._isLoaded && page && typeof page.rotation !== 'undefined' && page.rotation !== PdfRotationAngle.angle0) {
                parameter.bounds = this._rotateTextBox([bounds.x, bounds.y, bounds.width, bounds.height], page.size, page.rotation);
            }
            else {
                parameter.bounds = [0, 0, bounds.width, bounds.height];
            }
            var backcolor = item.backColor;
            if (backcolor) {
                parameter.backBrush = new PdfBrush(backcolor);
            }
            parameter.foreBrush = new PdfBrush(item.color);
            var border = item.border;
            if (item.borderColor) {
                parameter.borderPen = new PdfPen(item.borderColor, border.width);
            }
            parameter.borderStyle = border.style;
            parameter.borderWidth = border.width;
            if (backcolor) {
                var shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
                var color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                    shadowColor[1] >= 0 ? shadowColor[1] : 0,
                    shadowColor[2] >= 0 ? shadowColor[2] : 0];
                parameter.shadowBrush = new PdfBrush(color);
            }
            var alignment = typeof item.textAlignment !== 'undefined' ? item.textAlignment : PdfTextAlignment.left;
            var verticalAlignment = this.multiSelect ? PdfVerticalAlignment.top : PdfVerticalAlignment.middle;
            parameter.stringFormat = new PdfStringFormat(alignment, verticalAlignment);
        }
        else {
            var bounds = this.bounds;
            if (bounds) {
                if (this._isLoaded &&
                    this.page &&
                    typeof this.page.rotation !== 'undefined' &&
                    this.page.rotation !== PdfRotationAngle.angle0) {
                    parameter.bounds = this._rotateTextBox([bounds.x, bounds.y, bounds.width, bounds.height], this.page.size, this.page.rotation);
                }
                else {
                    parameter.bounds = [0, 0, bounds.width, bounds.height];
                }
            }
            var backcolor = this.backColor;
            if (backcolor) {
                parameter.backBrush = new PdfBrush(backcolor);
            }
            parameter.foreBrush = new PdfBrush(this.color);
            var border = this.border;
            if (this.borderColor) {
                parameter.borderPen = new PdfPen(this.borderColor, border.width);
            }
            parameter.borderStyle = border.style;
            parameter.borderWidth = border.width;
            if (backcolor) {
                var shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
                var color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                    shadowColor[1] >= 0 ? shadowColor[1] : 0,
                    shadowColor[2] >= 0 ? shadowColor[2] : 0];
                parameter.shadowBrush = new PdfBrush(color);
            }
            parameter.rotationAngle = this.rotationAngle;
            if (this.rotate !== null && typeof this.rotate !== 'undefined') {
                parameter.rotationAngle = this.rotate;
            }
            var alignment = typeof this.textAlignment !== 'undefined' ? this.textAlignment : PdfTextAlignment.left;
            var verticalAlignment = this.multiSelect ? PdfVerticalAlignment.top : PdfVerticalAlignment.middle;
            parameter.stringFormat = new PdfStringFormat(alignment, verticalAlignment);
        }
        parameter.required = this.required;
        if (parameter.bounds === null || typeof parameter.bounds === 'undefined') {
            parameter.bounds = [0, 0, 0, 0];
        }
        var template = new PdfTemplate(parameter.bounds, this._crossReference);
        var graphics = template.graphics;
        graphics._sw._clear();
        if (!this.required) {
            graphics._sw._beginMarkupSequence('Tx');
            graphics._initializeCoordinates();
        }
        if (this._isLoaded) {
            var font = void 0;
            if (item) {
                font = this._obtainFont(item);
            }
            if (typeof font === 'undefined' || font === null) {
                font = this._appearanceFont;
            }
            this._drawComboBox(graphics, parameter, font, parameter.stringFormat);
        }
        else {
            if (!this._font) {
                this._font = new PdfStandardFont(PdfFontFamily.timesRoman, this._getFontHeight(PdfFontFamily.helvetica));
            }
            this._drawComboBox(graphics, parameter, this._font, parameter.stringFormat);
        }
        if (!this.required) {
            graphics._sw._endMarkupSequence();
        }
        return template;
    };
    PdfComboBoxField.prototype._drawComboBox = function (graphics, parameter, font, stringFormat) {
        if (graphics._isTemplateGraphics && parameter.required) {
            graphics.save();
            graphics._initializeCoordinates();
        }
        this._drawRectangularControl(graphics, parameter);
        if (graphics._isTemplateGraphics && parameter.required) {
            graphics.restore();
            graphics.save();
            graphics._sw._beginMarkupSequence('Tx');
            graphics._initializeCoordinates();
        }
        var options = this._options;
        var selectedIndexes = this._dictionary.get('I');
        var i = -1;
        if (selectedIndexes && selectedIndexes.length > 0) {
            i = selectedIndexes[0];
        }
        if (i >= 0 && i < options.length) {
            var item = options[Number.parseInt(i.toString(), 10)]; // eslint-disable-line 
            var location_1 = [0, 0];
            var borderWidth = parameter.borderWidth;
            var doubleBorderWidth = 2 * borderWidth;
            var defaultPadding = 2;
            var padding = (parameter.borderStyle === PdfBorderStyle.inset || parameter.borderStyle === PdfBorderStyle.beveled);
            if (padding) {
                location_1[0] = 2 * doubleBorderWidth;
                location_1[1] = 2 * borderWidth;
            }
            else {
                location_1[0] = doubleBorderWidth + defaultPadding;
                location_1[1] = 1 * borderWidth + (defaultPadding - 1);
            }
            var brush = parameter.foreBrush;
            var rect = parameter.bounds;
            var width = rect[2] - doubleBorderWidth;
            var rectangle = rect;
            if (padding) {
                rectangle[3] -= doubleBorderWidth;
            }
            else {
                rectangle[3] -= borderWidth;
            }
            graphics.setClip(rectangle, PdfFillMode.winding);
            if (parameter.rotationAngle === 0) {
                var x = rect[0] + borderWidth;
                if (padding) {
                    x += borderWidth;
                    width -= doubleBorderWidth;
                }
                brush = new PdfBrush([153, 193, 218]);
                graphics.drawRectangle(x, location_1[1], width, rect[3], brush);
                brush = new PdfBrush([0, 0, 0]);
            }
            var value = void 0;
            if (item && Array.isArray(item)) {
                value = item[1] ? item[1] : item[0];
            }
            else {
                value = item;
            }
            if (value) {
                var itemTextBound = [location_1[0], location_1[1], width - location_1[0], rect[3]];
                if (parameter.rotationAngle > 0) {
                    var state = graphics.save();
                    if (parameter.rotationAngle === 90) {
                        graphics.translateTransform(0, graphics._size[1]);
                        graphics.rotateTransform(-90);
                        var x_1 = graphics._size[1] - (rectangle[1] + rectangle[3]);
                        var y = rectangle[0];
                        rectangle = [x_1, y, rectangle[3] + rectangle[2], rectangle[2]];
                    }
                    else if (parameter.rotationAngle === 270) {
                        graphics.translateTransform(graphics._size[0], 0);
                        graphics.rotateTransform(-270);
                        var x_2 = rectangle[1];
                        var y = graphics._size[0] - (rectangle[0] + rectangle[2]);
                        rectangle = [x_2, y, rectangle[3] + rectangle[2], rectangle[2]];
                    }
                    else if (parameter.rotationAngle === 180) {
                        graphics.translateTransform(graphics._size[0], graphics._size[1]);
                        graphics.rotateTransform(-180);
                        var x_3 = graphics._size[0] - (rectangle[0] + rectangle[2]);
                        var y = graphics._size[1] - (rectangle[1] + rectangle[3]);
                        rectangle = [x_3, y, rectangle[2], rectangle[3]];
                    }
                    var x = rect[0] + borderWidth;
                    if (padding) {
                        x += borderWidth;
                        width -= doubleBorderWidth;
                    }
                    brush = new PdfBrush([153, 193, 218]);
                    graphics.drawRectangle(x, location_1[1], width, rect[3], brush);
                    brush = new PdfBrush([0, 0, 0]);
                    graphics.drawString(value, font, itemTextBound, null, brush, stringFormat);
                    graphics.restore(state);
                }
                else {
                    graphics.drawString(value, font, itemTextBound, null, brush, stringFormat);
                }
            }
        }
        if (graphics._isTemplateGraphics && parameter.required) {
            graphics._sw._endMarkupSequence();
            graphics.restore();
        }
    };
    PdfComboBoxField.prototype._getFontHeight = function (fontFamily) {
        var values = this._dictionary.get('I');
        var s;
        var itemFont;
        var format;
        var options;
        var bounds;
        var borderWidth = this.border.width;
        if (this._isLoaded) {
            itemFont = new PdfStandardFont(fontFamily, 12);
            format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
            options = this._dictionary.getArray('Opt');
            bounds = this.bounds;
            var widths_1 = [];
            if (values && values.length > 0) {
                values.forEach(function (entry) {
                    widths_1.push(itemFont.measureString(options[Number.parseInt(entry.toString(), 10)][1], [0, 0], format, 0, 0)[0]);
                });
            }
            else if (options.length > 0) {
                var max = itemFont.measureString(options[0][1], [0, 0], format, 0, 0)[0];
                for (var i = 1; i < options.length; ++i) {
                    var width = itemFont.measureString(options[Number.parseInt(i.toString(), 10)][1], [0, 0], format, 0, 0)[0];
                    max = Math.max(max, width);
                    widths_1.push(max);
                }
            }
            s = (widths_1.length > 0) ? ((12 * (bounds.width - 4 * borderWidth)) / ((widths_1.sort())[widths_1.length - 1])) : 12;
        }
        else {
            s = 0;
            if (values && values.length > 0) {
                itemFont = new PdfStandardFont(fontFamily, 12);
                format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
                options = this._dictionary.getArray('Opt');
                var selectedValue = this.selectedValue; // eslint-disable-line
                var width = itemFont.measureString((selectedValue !== null && typeof selectedValue === 'string') ? selectedValue :
                    options[values[0]][1], [0, 0], format, 0, 0)[0];
                bounds = this.bounds;
                if (width) {
                    s = (12 * (bounds.width - 4 * borderWidth)) / width;
                }
                else {
                    s = 12;
                }
            }
            else {
                return s;
            }
        }
        var fontSize = 0;
        if (values && values.length > 0) {
            if (s !== 12) {
                itemFont = new PdfStandardFont(fontFamily, s);
                var selectedValue = this.selectedValue; // eslint-disable-line
                var text = (selectedValue !== null && typeof selectedValue === 'string') ? selectedValue :
                    options[values[0]][1];
                var textSize = itemFont.measureString(text);
                if (textSize[0] > bounds.width || textSize[1] > bounds.height) {
                    var width = bounds.width - 4 * borderWidth;
                    var h = bounds.height - 4 * borderWidth;
                    var min = 0.248;
                    for (var i = 1; i <= bounds.height; i++) {
                        itemFont = new PdfStandardFont(fontFamily, i);
                        var size = itemFont.measureString(text);
                        if (size[0] > bounds.width || size[1] > h) {
                            fontSize = i;
                            do {
                                fontSize = fontSize - 0.001;
                                itemFont = new PdfStandardFont(fontFamily, fontSize);
                                var textWidth = itemFont.getLineWidth(text, format);
                                if (fontSize < min) {
                                    itemFont._size = min;
                                    break;
                                }
                                size = itemFont.measureString(text, [0, 0], format, 0, 0);
                                if (textWidth < width && size[1] < h) {
                                    itemFont._size = fontSize;
                                    break;
                                }
                            } while (fontSize > min);
                            s = fontSize;
                            break;
                        }
                    }
                }
            }
        }
        else if (s > 12) {
            s = 12;
        }
        return s;
    };
    return PdfComboBoxField;
}(PdfListField));
/**
 * `PdfListBoxField` class represents the list box field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0);
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new list box field
 * let field: PdfListBoxField = new PdfListBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
 * // Add list items to the field.
 * field.addItem(new PdfListFieldItem('English', 'English'));
 * field.addItem(new PdfListFieldItem('French', 'French'));
 * field.addItem(new PdfListFieldItem('German', 'German'));
 * // Sets the selected index
 * field.selectedIndex = 2;
 * // Sets the flag indicates whether the list box allows multiple selections.
 * field.multiSelect = true;
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfListBoxField = /** @class */ (function (_super) {
    __extends$5(PdfListBoxField, _super);
    function PdfListBoxField(page, name, bounds) {
        var _this = _super.call(this) || this;
        if (page && name && bounds) {
            _this._initialize(page, name, bounds);
        }
        return _this;
    }
    /**
     * Parse an existing list box field of the PDF document.
     *
     * @private
     * @param {number} form maximum length.
     * @param {_PdfDictionary} dictionary maximum length.
     * @param {_PdfCrossReference} crossReference maximum length.
     * @param {_PdfReference} reference maximum length.
     * @returns {PdfListBoxField} List box field.
     */
    PdfListBoxField._load = function (form, dictionary, crossReference, reference) {
        var field = new PdfListBoxField();
        field._isLoaded = true;
        field._form = form;
        field._dictionary = dictionary;
        field._crossReference = crossReference;
        field._ref = reference;
        if (field._dictionary.has('Kids')) {
            field._kids = field._dictionary.get('Kids');
        }
        field._defaultIndex = 0;
        field._parsedItems = new Map();
        if (field._kidsCount > 0) {
            field._retrieveOptionValue();
        }
        return field;
    };
    PdfListBoxField.prototype._retrieveOptionValue = function () {
        if (this._dictionary.has('Opt')) {
            var options = this._dictionary.getArray('Opt');
            var itemsCount = this._kidsCount;
            var count = options.length <= itemsCount ? options.length : itemsCount;
            this._listValues = new Array(count);
            if (options && options.length > 0) {
                var index = this._dictionary.get('I');
                if (Array.isArray(index) && index.length > 0) {
                    index = index[0];
                    this._selectedIndex = index;
                }
                for (var i = 0; i < count; i++) {
                    var item = this.itemAt(i);
                    if (item) {
                        if (_isNullOrUndefined(index) && this._listValues !== null && typeof this._listValues !== 'undefined') {
                            var value = options[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                            if (Array.isArray(value)) {
                                this._listValues[Number.parseInt(i.toString(), 10)] = value[1];
                            }
                            else {
                                this._listValues[Number.parseInt(i.toString(), 10)] = value;
                            }
                            if (i === index) {
                                item._text = this._listValues[Number.parseInt(i.toString(), 10)];
                                this._selectedIndex = i;
                            }
                            else {
                                item._text = this._listValues[Number.parseInt(i.toString(), 10)];
                            }
                        }
                        else {
                            item._text = '';
                        }
                    }
                }
            }
        }
    };
    PdfListBoxField.prototype._createAppearance = function (item) {
        var parameter = new _PaintParameter();
        if (item) {
            var bounds = item.bounds;
            var page = item._getPage();
            if (item._isLoaded && page && typeof page.rotation !== 'undefined' && page.rotation !== PdfRotationAngle.angle0) {
                parameter.bounds = this._rotateTextBox([bounds.x, bounds.y, bounds.width, bounds.height], page.size, page.rotation);
            }
            else {
                parameter.bounds = [0, 0, bounds.width, bounds.height];
            }
            var backcolor = item.backColor;
            if (backcolor) {
                parameter.backBrush = new PdfBrush(backcolor);
            }
            parameter.foreBrush = new PdfBrush(item.color);
            var border = item.border;
            if (item.borderColor) {
                parameter.borderPen = new PdfPen(item.borderColor, border.width);
            }
            parameter.borderStyle = border.style;
            parameter.borderWidth = border.width;
            if (backcolor) {
                var shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
                var color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                    shadowColor[1] >= 0 ? shadowColor[1] : 0,
                    shadowColor[2] >= 0 ? shadowColor[2] : 0];
                parameter.shadowBrush = new PdfBrush(color);
            }
            if (item._enableGrouping && typeof item.rotate === 'undefined') {
                parameter.rotationAngle = 0;
            }
            else {
                parameter.rotationAngle = item.rotate;
            }
            var alignment = typeof item.textAlignment !== 'undefined' ? item.textAlignment : PdfTextAlignment.left;
            var verticalAlignment = this.multiSelect ? PdfVerticalAlignment.top : PdfVerticalAlignment.middle;
            parameter.stringFormat = new PdfStringFormat(alignment, verticalAlignment);
        }
        else {
            var bounds = this.bounds;
            if (this._isLoaded &&
                this.page &&
                typeof this.page.rotation !== 'undefined' &&
                this.page.rotation !== PdfRotationAngle.angle0) {
                parameter.bounds = this._rotateTextBox([bounds.x, bounds.y, bounds.width, bounds.height], this.page.size, this.page.rotation);
            }
            else {
                parameter.bounds = [0, 0, bounds.width, bounds.height];
            }
            var backcolor = this.backColor;
            if (backcolor) {
                parameter.backBrush = new PdfBrush(backcolor);
            }
            parameter.foreBrush = new PdfBrush(this.color);
            var border = this.border;
            if (this.borderColor) {
                parameter.borderPen = new PdfPen(this.borderColor, border.width);
            }
            parameter.borderStyle = border.style;
            parameter.borderWidth = border.width;
            if (backcolor) {
                var shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
                var color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                    shadowColor[1] >= 0 ? shadowColor[1] : 0,
                    shadowColor[2] >= 0 ? shadowColor[2] : 0];
                parameter.shadowBrush = new PdfBrush(color);
            }
            parameter.rotationAngle = this.rotationAngle;
            if (this.rotate !== null && typeof this.rotate !== 'undefined') {
                parameter.rotationAngle = this.rotate;
            }
            var alignment = typeof this.textAlignment !== 'undefined' ? this.textAlignment : PdfTextAlignment.left;
            var verticalAlignment = this.multiSelect ? PdfVerticalAlignment.top : PdfVerticalAlignment.middle;
            parameter.stringFormat = new PdfStringFormat(alignment, verticalAlignment);
        }
        parameter.required = this.required;
        var template = new PdfTemplate(parameter.bounds, this._crossReference);
        var graphics = template.graphics;
        graphics._sw._clear();
        if (!this.required) {
            graphics._sw._beginMarkupSequence('Tx');
            graphics._initializeCoordinates();
        }
        if (this._isLoaded) {
            var font = this._obtainFont(item);
            if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {
                font = this._appearanceFont;
            }
            this._drawListBox(graphics, parameter, font, parameter.stringFormat);
        }
        else {
            if (!this._font) {
                this._font = this._defaultItemFont;
            }
            this._drawListBox(graphics, parameter, this._font, parameter.stringFormat);
        }
        if (!this.required) {
            graphics._sw._endMarkupSequence();
        }
        return template;
    };
    PdfListBoxField.prototype._drawListBox = function (graphics, parameter, font, stringFormat) {
        if (graphics._isTemplateGraphics && parameter.required) {
            graphics.save();
            graphics._initializeCoordinates();
        }
        this._drawRectangularControl(graphics, parameter);
        if (graphics._isTemplateGraphics && parameter.required) {
            graphics.restore();
            graphics.save();
            graphics._sw._beginMarkupSequence('Tx');
            graphics._initializeCoordinates();
        }
        var options = this._options;
        var _loop_1 = function (index) {
            var item = options[Number.parseInt(index.toString(), 10)];
            var location_2 = [];
            var borderWidth = parameter.borderWidth;
            var doubleBorderWidth = 2 * borderWidth;
            var defaultPadding = 2;
            var padding = (parameter.borderStyle === PdfBorderStyle.inset || parameter.borderStyle === PdfBorderStyle.beveled);
            if (padding) {
                location_2.push(2 * doubleBorderWidth);
                location_2.push((index + 2) * borderWidth + font._metrics._getHeight() * index);
            }
            else {
                location_2.push(doubleBorderWidth + defaultPadding);
                location_2.push((index + 1) * borderWidth + font._metrics._getHeight() * index + (defaultPadding - 1));
            }
            var brush = parameter.foreBrush;
            var rect = parameter.bounds;
            var width = rect[2] - doubleBorderWidth;
            var rectangle = rect;
            if (padding) {
                rectangle[3] -= doubleBorderWidth;
            }
            else {
                rectangle[3] -= borderWidth;
            }
            graphics.setClip(rectangle, PdfFillMode.winding);
            var selected = false;
            var selectedIndexes = this_1._dictionary.get('I');
            if (selectedIndexes !== null && typeof selectedIndexes !== 'undefined' && selectedIndexes.length > 0) {
                selectedIndexes.forEach(function (selectedIndex) {
                    selected = selected || (selectedIndex === index);
                });
            }
            if (parameter.rotationAngle === 0) {
                if (selected) {
                    var x = rect[0] + borderWidth;
                    if (padding) {
                        x += borderWidth;
                        width -= doubleBorderWidth;
                    }
                    brush = new PdfBrush([153, 193, 218]);
                    graphics.drawRectangle(x, location_2[1], width, font._metrics._getHeight(), brush);
                    brush = new PdfBrush([0, 0, 0]);
                }
            }
            var value = item[1] ? item[1] : item[0];
            var itemTextBound = [location_2[0], location_2[1], width - location_2[0], font._metrics._getHeight()];
            if (parameter.rotationAngle > 0) {
                var state = graphics.save();
                if (parameter.rotationAngle === 90) {
                    graphics.translateTransform(0, graphics._size[1]);
                    graphics.rotateTransform(-90);
                    var x = graphics._size[1] - (rectangle[1] + rectangle[3]);
                    var y = rectangle[0];
                    rectangle = [x, y, rectangle[3] + rectangle[2], rectangle[2]];
                }
                else if (parameter.rotationAngle === 270) {
                    graphics.translateTransform(graphics._size[0], 0);
                    graphics.rotateTransform(-270);
                    var x = rectangle[1];
                    var y = graphics._size[0] - (rectangle[0] + rectangle[2]);
                    rectangle = [x, y, rectangle[3] + rectangle[2], rectangle[2]];
                }
                else if (parameter.rotationAngle === 180) {
                    graphics.translateTransform(graphics._size[0], graphics._size[1]);
                    graphics.rotateTransform(-180);
                    var x = graphics._size[0] - (rectangle[0] + rectangle[2]);
                    var y = graphics._size[1] - (rectangle[1] + rectangle[3]);
                    rectangle = [x, y, rectangle[2], rectangle[3]];
                }
                if (selected) {
                    var x = rect[0] + borderWidth;
                    if (padding) {
                        x += borderWidth;
                        width -= doubleBorderWidth;
                    }
                    brush = new PdfBrush([153, 193, 218]);
                    graphics.drawRectangle(x, location_2[1], width, font._metrics._getHeight(), brush);
                    brush = new PdfBrush([0, 0, 0]);
                }
                graphics.drawString(value, font, itemTextBound, null, brush, stringFormat);
                graphics.restore(state);
            }
            else {
                graphics.drawString(value, font, itemTextBound, null, brush, stringFormat);
            }
        };
        var this_1 = this;
        for (var index = 0; index < options.length; ++index) {
            _loop_1(index);
        }
        if (graphics._isTemplateGraphics && parameter.required) {
            graphics._sw._endMarkupSequence();
            graphics.restore();
        }
    };
    PdfListBoxField.prototype._getFontHeight = function (fontFamily) {
        var itemFont = new PdfStandardFont(fontFamily, 12, PdfFontStyle.regular);
        var format = new PdfStringFormat(PdfTextAlignment.left, PdfVerticalAlignment.middle);
        var s = 0;
        if (_isNullOrUndefined(this._listValues) && this._listValues.length > 0) {
            var max = itemFont.measureString(this._listValues[0], [0, 0], format, 0, 0)[0];
            for (var i = 1; i < this._listValues.length; ++i) {
                var value = itemFont.measureString(this._listValues[Number.parseInt(i.toString(), 10)], [0, 0], format, 0, 0)[0];
                max = (max > value) ? max : value;
            }
            s = ((12 * (this.bounds.width - 4 * this.border.width)) / max);
            s = (s > 12) ? 12 : s;
        }
        return s;
    };
    return PdfListBoxField;
}(PdfListField));
/**
 * `PdfSignatureField` class represents the signature field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0);
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new signature field
 * let field: PdfSignatureField = new PdfSignatureField(page, 'Signature', {x: 10, y: 10, width: 100, height: 50});
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfSignatureField = /** @class */ (function (_super) {
    __extends$5(PdfSignatureField, _super);
    function PdfSignatureField(page, name, bounds) {
        var _this = _super.call(this) || this;
        _this._isSigned = false;
        if (page && name && bounds) {
            _this._initialize(page, name, bounds);
        }
        return _this;
    }
    Object.defineProperty(PdfSignatureField.prototype, "isSigned", {
        /**
         * Gets the flag to indicate whether the field is signed or not.
         *
         * @returns {boolean} Returns true if the field is signed; otherwise, false.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the loaded signature field
         * let field: PdfSignatureField = document.form.fieldAt(0) as PdfSignatureField;
         * // Get the signed status of the field
         * let isSigned: boolean = field.isSigned;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._isSigned) {
                this._checkSigned();
            }
            return this._isSigned;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfSignatureField.prototype, "backColor", {
        /**
         * Gets the background color of the field.
         *
         * @returns {number[]} R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the background color of the field.
         * let backColor: number[] = field.backColor;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._parseBackColor(true);
        },
        /**
         * Sets the background color of the field.
         *
         * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the signature field at index 0
         * let field1: PdfField = document.form.fieldAt(0);
         * // Sets the background color of the field.
         * field1.backColor = [255, 0, 0];
         * // Access the signature field at index 1
         * let field2: PdfField = document.form.fieldAt(1);
         * // Sets the background color of the field to transparent.
         * field2.backColor = [0, 0, 0, 0];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._updateBackColor(value, true);
        },
        enumerable: true,
        configurable: true
    });
    PdfSignatureField._load = function (form, dictionary, crossReference, reference) {
        var field = new PdfSignatureField();
        field._isLoaded = true;
        field._form = form;
        field._dictionary = dictionary;
        field._crossReference = crossReference;
        field._ref = reference;
        if (field._dictionary.has('Kids')) {
            field._kids = field._dictionary.get('Kids');
        }
        field._defaultIndex = 0;
        field._parsedItems = new Map();
        return field;
    };
    PdfSignatureField.prototype._initialize = function (page, name, bounds) {
        this._crossReference = page._crossReference;
        this._page = page;
        this._name = name;
        this._dictionary = new _PdfDictionary(this._crossReference);
        this._ref = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(this._ref, this._dictionary);
        this._dictionary.objId = this._ref.toString();
        this._dictionary.update('FT', _PdfName.get('Sig'));
        this._dictionary.update('T', name);
        this._defaultIndex = 0;
        this._initializeFont(this._defaultFont);
        this._createItem(bounds);
    };
    PdfSignatureField.prototype._createItem = function (bounds) {
        var widget = new PdfWidgetAnnotation();
        widget._create(this._page, bounds, this);
        widget._dictionary.update('MK', new _PdfDictionary(this._crossReference));
        widget._mkDictionary.update('BC', [0, 0, 0]);
        widget._mkDictionary.update('BG', [1, 1, 1]);
        widget._dictionary.update('DA', this._fontName + " 8 Tf 0 0 0 rg");
        this._addToKid(widget);
    };
    PdfSignatureField.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        var needAppearance = this._setAppearance || this._form._setAppearance;
        if (isFlatten || needAppearance) {
            var count = this._kidsCount;
            if (count > 0) {
                for (var i = 0; i < count; i++) {
                    var item = this.itemAt(i);
                    if (item && item._dictionary && (needAppearance || (isFlatten && !item._dictionary.has('AP')))) {
                        var template = this._createAppearance(item, isFlatten);
                        this._addAppearance(item._dictionary, template, 'N');
                    }
                }
            }
        }
        if (isFlatten) {
            var count = this._kidsCount;
            if (count > 0) {
                var firstItemTemplate = void 0;
                for (var i = 0; i < count; i++) {
                    var item = this.itemAt(i);
                    if (item && item._dictionary) {
                        var page = item._getPage();
                        if (page) {
                            if (!firstItemTemplate && i === 0) {
                                firstItemTemplate = this._getItemTemplate(item._dictionary);
                            }
                            this._flattenSignature(item._dictionary, page, item.bounds, firstItemTemplate);
                        }
                    }
                }
            }
            else {
                this._flattenSignature(this._dictionary, this.page, this.bounds);
            }
        }
    };
    PdfSignatureField.prototype._createAppearance = function (widget, isFlatten) {
        var bounds = widget.bounds;
        var template = new PdfTemplate([0, 0, bounds.width, bounds.height], this._crossReference);
        _setMatrix(template, null);
        template._writeTransformation = false;
        var graphics = template.graphics;
        var parameter = new _PaintParameter();
        parameter.bounds = [0, 0, bounds.width, bounds.height];
        var backcolor = widget.backColor;
        if (isFlatten && backcolor) {
            parameter.backBrush = new PdfBrush(backcolor);
        }
        parameter.foreBrush = new PdfBrush(widget.color);
        var border = widget.border;
        if (widget.borderColor) {
            parameter.borderPen = new PdfPen(widget.borderColor, border.width);
        }
        parameter.borderWidth = border.width;
        parameter.borderStyle = border.style;
        if (backcolor) {
            var shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
            var color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                shadowColor[1] >= 0 ? shadowColor[1] : 0,
                shadowColor[2] >= 0 ? shadowColor[2] : 0];
            parameter.shadowBrush = new PdfBrush(color);
        }
        parameter.rotationAngle = widget.rotate;
        graphics.save();
        graphics._initializeCoordinates();
        this._drawRectangularControl(graphics, parameter);
        graphics.restore();
        return template;
    };
    PdfSignatureField.prototype._flattenSignature = function (dictionary, page, bounds, signatureTemplate) {
        var template;
        if (dictionary.has('AP')) {
            var appearanceDictionary = dictionary.get('AP');
            if (appearanceDictionary && appearanceDictionary.has('N')) {
                var appearanceStream = appearanceDictionary.get('N');
                var reference = appearanceDictionary.getRaw('N');
                if (reference && appearanceStream) {
                    appearanceStream.reference = reference;
                }
                if (appearanceStream) {
                    if (signatureTemplate) {
                        template = signatureTemplate;
                    }
                    else {
                        template = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                    if (template && page) {
                        var graphics = page.graphics;
                        var state = graphics.save();
                        if (this.isSigned) {
                            template._isSignature = true;
                        }
                        if (page.rotation !== PdfRotationAngle.angle0) {
                            graphics.drawTemplate(template, this._calculateTemplateBounds(bounds, page, template, graphics));
                        }
                        else {
                            graphics.drawTemplate(template, bounds);
                        }
                        graphics.restore(state);
                    }
                }
            }
        }
        else if (signatureTemplate && page) {
            template = signatureTemplate;
            var graphics = page.graphics;
            var state = graphics.save();
            if (page.rotation !== PdfRotationAngle.angle0) {
                graphics.drawTemplate(template, this._calculateTemplateBounds(bounds, page, template, graphics));
            }
            else {
                graphics.drawTemplate(template, bounds);
            }
            graphics.restore(state);
        }
    };
    PdfSignatureField.prototype._calculateTemplateBounds = function (bounds, page, template, graphics) {
        var x = bounds.x;
        var y = bounds.y;
        if (page) {
            var graphicsRotation = this._obtainGraphicsRotation(graphics._matrix);
            if (graphicsRotation === 90) {
                graphics.translateTransform(template._size[1], 0);
                graphics.rotateTransform(90);
                x = bounds.x;
                y = -(page._size[1] - bounds.y - bounds.height);
            }
            else if (graphicsRotation === 180) {
                graphics.translateTransform(template._size[0], template._size[1]);
                graphics.rotateTransform(180);
                x = -(page._size[0] - (bounds.x + template._size[0]));
                y = -(page._size[1] - bounds.y - template._size[1]);
            }
            else if (graphicsRotation === 270) {
                graphics.translateTransform(0, template._size[0]);
                graphics.rotateTransform(270);
                x = -(page._size[0] - bounds.x - bounds.width);
                y = bounds.y;
            }
        }
        return { x: x, y: y, width: bounds.width, height: bounds.height };
    };
    PdfSignatureField.prototype._obtainGraphicsRotation = function (matrix) {
        var angle = Math.round(Math.atan2(matrix._matrix._elements[2], matrix._matrix._elements[0]) * 180 / Math.PI);
        switch (angle) {
            case -90:
                angle = 90;
                break;
            case -180:
                angle = 180;
                break;
            case 90:
                angle = 270;
                break;
        }
        return angle;
    };
    PdfSignatureField.prototype._getItemTemplate = function (dictionary) {
        var template;
        if (dictionary && dictionary.has('AP')) {
            var appearanceDictionary = dictionary.get('AP');
            if (appearanceDictionary && appearanceDictionary.has('N')) {
                var appearanceStream = appearanceDictionary.get('N');
                var reference = appearanceDictionary.getRaw('N');
                if (reference) {
                    appearanceStream.reference = reference;
                }
                if (appearanceStream) {
                    template = new PdfTemplate(appearanceStream, this._crossReference);
                }
            }
        }
        return template;
    };
    PdfSignatureField.prototype._checkSigned = function () {
        if (this._dictionary && this._dictionary.has('V')) {
            var dictionary = this._dictionary.get('V');
            if (dictionary !== null && typeof dictionary !== 'undefined' && dictionary.size > 0) {
                this._isSigned = true;
            }
        }
    };
    return PdfSignatureField;
}(PdfField));
var _PdfDefaultAppearance = /** @class */ (function () {
    function _PdfDefaultAppearance(da) {
        var color;
        var fontName = '';
        var fontSize = 0;
        if (da && typeof da === 'string' && da !== '') {
            var sliced = da.split(' ');
            for (var i = 0; i < sliced.length; i++) {
                switch (sliced[Number.parseInt(i.toString(), 10)]) {
                    case 'g':
                        color = [Number.parseFloat(sliced[i - 1])];
                        break;
                    case 'rg':
                        color = [Number.parseFloat(sliced[i - 3]), Number.parseFloat(sliced[i - 2]), Number.parseFloat(sliced[i - 1])];
                        break;
                    case 'k':
                        color = [Number.parseFloat(sliced[i - 4]), Number.parseFloat(sliced[i - 3]), Number.parseFloat(sliced[i - 2]),
                            Number.parseFloat(sliced[i - 1])];
                        break;
                    case 'Tf':
                        fontSize = Number.parseFloat(sliced[i - 1]);
                        fontName = sliced[i - 2].substring(1);
                        if (fontName.includes('#2C')) {
                            fontName.replace('#2C', ',');
                        }
                        break;
                }
            }
        }
        this.fontName = fontName;
        this.fontSize = fontSize;
        this.color = (typeof color !== 'undefined') ? _parseColor(color) : [0, 0, 0];
    }
    _PdfDefaultAppearance.prototype.toString = function () {
        var color = [Number.parseFloat((this.color[0] / 255).toFixed(3)),
            Number.parseFloat((this.color[1] / 255).toFixed(3)),
            Number.parseFloat((this.color[2] / 255).toFixed(3))];
        return '/' +
            this.fontName +
            ' ' +
            this.fontSize +
            ' Tf ' +
            color[0].toString() +
            ' ' +
            color[1].toString() +
            ' ' +
            color[2].toString() +
            ' rg';
    };
    return _PdfDefaultAppearance;
}());

/**
 * `PdfAppearance` class represents the appearance of the annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new rubber stamp annotation
 * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 100, 100, 50);
 * // Get the appearance of the annotation
 * let appearance: PdfAppearance = annotation.appearance;
 * // Create new image object by using JPEG image data as Base64 string format
 * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
 * // Draw the image as the custom appearance for the annotation
 * appearance.normal.graphics.drawImage(image, 0, 0, 100, 50);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAppearance = /** @class */ (function () {
    /**
     * Initializes a new instance of the `PdfAppearance` class.
     *
     * @param {PdfAnnotation} annot - The annotation.
     * @param {number[]} bounds - The bounds.
     * @private
     */
    function PdfAppearance(annot, bounds) {
        this._dictionary = new _PdfDictionary();
        if (_isNullOrUndefined(bounds)) {
            this._bounds = bounds;
        }
        else {
            this._bounds = [];
        }
        this._annotations = annot;
        this._crossReference = annot._crossReference;
        this._initialize();
    }
    Object.defineProperty(PdfAppearance.prototype, "normal", {
        /**
         * Get the normal appearance of the annotation.
         *
         * @returns {PdfTemplate} Returns the normal appearance of the annotation.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new rubber stamp annotation
         * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 100, 100, 50);
         * // Get the appearance of the annotation
         * let appearance: PdfAppearance = annotation.appearance;
         * // Access the normal template of the appearance
         * let template: PdfTemplate = appearance.normal;
         * // Create new image object by using JPEG image data as Base64 string format
         * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
         * // Draw the image as the custom appearance for the annotation
         * template.graphics.drawImage(image, 0, 0, 100, 50);
         * // Add annotation to the page
         * page.annotations.add(annotation);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._templateNormal && this._dictionary && this._dictionary.has('AP')) {
                this._templateNormal = this._dictionary.get('N');
            }
            return this._templateNormal;
        },
        /**
         * Set the normal appearance of the annotation.
         *
         * @param {PdfTemplate} value The normal appearance of the annotation.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new rubber stamp annotation
         * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 100, 100, 50);
         * // Get the appearance of the annotation
         * let appearance: PdfAppearance = annotation.appearance;
         * // Access the normal template of the appearance
         * let template: PdfTemplate = appearance.normal;
         * // Create new image object by using JPEG image data as Base64 string format
         * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
         * // Draw the image as the custom appearance for the annotation
         * template.graphics.drawImage(image, 0, 0, 100, 50);
         * // Add annotation to the page
         * page.annotations.add(annotation);
         * // Add a new rubber stamp annotation to the page
         * const annotation2: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 200, 100, 50);
         * // Set the normal appearance of the annotation
         * annotation2.appearance.normal = annotation.appearance.normal;
         * // Add annotation to the page
         * page.annotations.add(annotation2);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                this._templateNormal = value;
                this._dictionary.set('N', this._templateNormal);
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfAppearance.prototype._initialize = function () {
        this.normal = new PdfTemplate(this._bounds, this._crossReference);
    };
    return PdfAppearance;
}());

var __extends$6 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Represents the base class for annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfAnnotation = page.annotations.at(0);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAnnotation = /** @class */ (function () {
    function PdfAnnotation() {
        this._isImported = false;
        this._isLoaded = false;
        this._setAppearance = false;
        this._isExport = false;
        this._opacity = 1;
        this._isAllRotation = true;
        this._flatten = false;
        this._hasData = false;
        this._popUpFont = new PdfStandardFont(PdfFontFamily.helvetica, 10.5);
        this._authorBoldFont = new PdfStandardFont(PdfFontFamily.helvetica, 10.5, PdfFontStyle.bold);
        this._lineCaptionFont = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);
        this._circleCaptionFont = new PdfStandardFont(PdfFontFamily.helvetica, 8, PdfFontStyle.regular);
        this._isTransparentColor = false;
        this._isRotated = false;
        this._isChanged = false;
    }
    Object.defineProperty(PdfAnnotation.prototype, "author", {
        /**
         * Gets the author of the annotation.
         *
         * @returns {string} Author.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * //Get the author of the annotation.
         * let author: string = annotation.author;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._author === 'undefined' && this._dictionary.has('Author')) {
                var author = this._dictionary.get('Author');
                if (author) {
                    this._author = author;
                }
            }
            if (typeof this._author === 'undefined' && this._dictionary.has('T')) {
                var author = this._dictionary.get('T');
                if (author) {
                    this._author = author;
                }
            }
            return this._author;
        },
        /**
         * Sets the author of the annotation.
         *
         * @param {string} value Author.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the author of the annotation.
         * annotation.author = ‘Syncfusion’;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._isLoaded && typeof value === 'string' && value !== this.author) {
                var hasKey = false;
                if (this._dictionary && this._dictionary.has('T')) {
                    this._dictionary.update('T', value);
                    this._author = value;
                    hasKey = true;
                }
                if (this._dictionary && this._dictionary.has('Author')) {
                    this._dictionary.update('Author', value);
                    this._author = value;
                    hasKey = true;
                }
                if (!hasKey) {
                    this._dictionary.update('T', value);
                    this._author = value;
                }
            }
            if (!this._isLoaded && typeof value === 'string') {
                this._dictionary.update('T', value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "border", {
        /**
         * Gets the border of the annotation.
         *
         * @returns {PdfAnnotationBorder} Annotation border.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the border of the annotation.
         * let border: PdfAnnotationBorder = annotation.border;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._border === 'undefined') {
                var value = new PdfAnnotationBorder();
                value._dictionary = this._dictionary;
                if (this._dictionary && this._dictionary.has('Border')) {
                    var border = this._dictionary.getArray('Border');
                    if (border && border.length >= 3) {
                        value._hRadius = border[0];
                        value._vRadius = border[1];
                        value._width = border[2];
                    }
                }
                if (this._dictionary && this._dictionary.has('BS')) {
                    var border = this._dictionary.get('BS');
                    if (border) {
                        if (border.has('W')) {
                            var width = border.get('W');
                            if (typeof width !== 'undefined' && !Number.isNaN(width)) {
                                value._width = width;
                            }
                        }
                        if (border.has('S')) {
                            var style = border.get('S');
                            if (style) {
                                switch (style.name) {
                                    case 'D':
                                        value._style = PdfBorderStyle.dashed;
                                        break;
                                    case 'B':
                                        value._style = PdfBorderStyle.beveled;
                                        break;
                                    case 'I':
                                        value._style = PdfBorderStyle.inset;
                                        break;
                                    case 'U':
                                        value._style = PdfBorderStyle.underline;
                                        break;
                                    default:
                                        value._style = PdfBorderStyle.solid;
                                        break;
                                }
                            }
                        }
                        if (border.has('D')) {
                            var dash = border.getArray('D');
                            if (dash) {
                                value._dash = dash;
                            }
                        }
                    }
                }
                this._border = value;
            }
            return this._border;
        },
        /**
         * Sets the border of the annotation.
         *
         * @param {PdfAnnotationBorder} value Border.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Initializes a new instance of the ` PdfAnnotationBorder ` class.
         * let border: PdfAnnotationBorder = new PdfAnnotationBorder ();
         * //Sets the width of the annotation border.
         * border.width = 10;
         * //Sets the style of the annotation border.
         * border.style = PdfBorderStyle.dashed;
         * //Sets the dash pattern of the annotation border.
         * border.dash = [1, 2, 1];
         * // Sets the border to the PDF annotation
         * annotation.border = border;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            var current = this.border;
            var width;
            if (!this._isLoaded || (typeof value.width !== 'undefined' && current.width !== value.width)) {
                width = value.width;
            }
            var hRadius;
            if (!this._isLoaded || (typeof value.hRadius !== 'undefined' && current.hRadius !== value.hRadius)) {
                hRadius = value.hRadius;
            }
            var vRadius;
            if (!this._isLoaded || (typeof value.vRadius !== 'undefined' && current.vRadius !== value.vRadius)) {
                vRadius = value.vRadius;
            }
            var style;
            if (!this._isLoaded || (typeof value.style !== 'undefined' && current.style !== value.style)) {
                style = value.style;
            }
            var dash;
            if (typeof value.dash !== 'undefined' && current.dash !== value.dash) {
                dash = value.dash;
            }
            if (!this._isWidget && this._dictionary && this._dictionary.has('Border') || (width || vRadius || hRadius)) {
                this._border._hRadius = typeof hRadius !== 'undefined' ? hRadius : current.hRadius;
                this._border._vRadius = typeof vRadius !== 'undefined' ? vRadius : current.vRadius;
                this._border._width = typeof width !== 'undefined' ? width : current.width;
                this._dictionary.update('Border', [this._border.hRadius, this._border.vRadius, this._border.width]);
            }
            if (this._dictionary !== null && this._dictionary && this._dictionary.has('BS') || (width || style || dash)) {
                this._border._width = typeof width !== 'undefined' ? width : current.width;
                this._border._style = typeof style !== 'undefined' ? style : current.style;
                this._border._dash = typeof dash !== 'undefined' ? dash : current.dash;
                var bs = this._dictionary.has('BS') ? this._dictionary.get('BS') : new _PdfDictionary(this._crossReference);
                bs.update('Type', _PdfName.get('Border'));
                bs.update('W', this._border.width);
                bs.update('S', _mapBorderStyle(this._border.style));
                if (typeof this._border.dash !== 'undefined') {
                    bs.update('D', this._border.dash);
                }
                this._dictionary.update('BS', bs);
                this._dictionary._updated = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "flags", {
        /**
         * Gets the flags of the annotation.
         *
         * @returns {PdfAnnotationFlag} Annotation flag.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the flags of the annotation.
         * let flag: PdfAnnotationFlag = annotation.flags;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._annotFlags === 'undefined') {
                this._annotFlags = PdfAnnotationFlag.default;
                if (this._dictionary && this._dictionary.has('F')) {
                    this._annotFlags = this._dictionary.get('F');
                }
            }
            return this._annotFlags;
        },
        /**
         * Sets the flags of the annotation.
         *
         * @param {PdfAnnotationFlag} value flag value.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the flags of the annotation.
         * annotation.flags = PdfAnnotationFlag.print;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined' && value !== this._annotFlags) {
                this._annotFlags = value;
                this._dictionary.update('F', value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "color", {
        /**
         * Gets the fore color of the annotation.
         *
         * @returns {number[]} R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the color of the annotation.
         * let color: number[] = annotation.color;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._color === 'undefined' && this._dictionary.has('C')) {
                this._color = _parseColor(this._dictionary.getArray('C'));
            }
            return this._color;
        },
        /**
         * Sets the fore color of the annotation.
         *
         * @param {number[]} value R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the color of the annotation.
         * annotation.color = [255, 0, 0];
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined' && value.length === 3) {
                var extColor = this.color;
                if (!this._isLoaded || typeof extColor === 'undefined' || (extColor[0] !== value[0] || extColor[1] !== value[1] || extColor[2] !== value[2])) {
                    this._color = value;
                    this._dictionary.update('C', [Number.parseFloat((value[0] / 255).toFixed(7)),
                        Number.parseFloat((value[1] / 255).toFixed(7)),
                        Number.parseFloat((value[2] / 255).toFixed(7))]);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "innerColor", {
        /**
         * Gets the inner color of the annotation.
         *
         * @returns {number[]} R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the inner color of the annotation.
         * let innerColor: number[] = annotation.innerColor;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._innerColor === 'undefined' && this._dictionary.has('IC')) {
                this._innerColor = _parseColor(this._dictionary.getArray('IC'));
            }
            return this._innerColor;
        },
        /**
         * Sets the inner color of the annotation.
         *
         * @param {number[]} value R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the inner color of the annotation.
         * annotation.innerColor = [255, 0, 0];
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined' && value.length === 3) {
                var extColor = this.innerColor;
                if (!this._isLoaded ||
                    typeof extColor === 'undefined' ||
                    (extColor[0] !== value[0] || extColor[1] !== value[1] || extColor[2] !== value[2])) {
                    this._innerColor = value;
                    this._dictionary.update('IC', [Number.parseFloat((value[0] / 255).toFixed(7)),
                        Number.parseFloat((value[1] / 255).toFixed(7)),
                        Number.parseFloat((value[2] / 255).toFixed(7))]);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "creationDate", {
        /**
         * Gets the creation date of the annotation.
         *
         * @returns {Date} Creation date.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * //Get the creation date of the annotation.
         * let creationDate: Date = annotation.creationDate;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if ((typeof this._creationDate === 'undefined' || this._creationDate === null) && this._dictionary.has('CreationDate')) {
                var value = this._dictionary.get('CreationDate'); // eslint-disable-line
                if (value !== null && typeof value === 'string') {
                    this._creationDate = this._stringToDate(value);
                }
            }
            return this._creationDate;
        },
        /**
         * Sets the creation date of the annotation.
         *
         * @param {Date} value Creation date.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * //Set the creation date of the annotation.
         * annotation.creationDate = new Date();
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._creationDate = value;
            this._dictionary.update('CreationDate', this._dateToString(value));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "modifiedDate", {
        /**
         * Gets the modification date of the annotation.
         *
         * @returns {Date} Modified date.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * //Get the modified date of the annotation.
         * let modifiedDate: Date = annotation.modifiedDate;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if ((typeof this._modifiedDate === 'undefined' || this._modifiedDate === null)) {
                var value = void 0; // eslint-disable-line
                if (this._dictionary && this._dictionary.has('ModDate')) {
                    value = this._dictionary.get('ModDate');
                }
                else if (this._dictionary.has('M')) {
                    value = this._dictionary.get('M');
                }
                if (value !== null && typeof value === 'string') {
                    this._modifiedDate = this._stringToDate(value);
                }
            }
            return this._modifiedDate;
        },
        /**
         * Sets the modification date of the annotation.
         *
         * @param {Date} value Modified date.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * //Set the modified date of the annotation.
         * annotation.modifiedDate = new Date();
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._modifiedDate = value;
            this._dictionary.update('M', this._dateToString(value));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "bounds", {
        /**
         * Gets the bounds of the annotation.
         *
         * @returns {{x: number, y: number, width: number, height: number}} Bounds.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the bounds of the annotation.
         * let bounds: {x: number, y: number, width: number, height: number} = annotation.bounds;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoaded) {
                this._bounds = _calculateBounds(this._dictionary, this._page);
            }
            return this._bounds;
        },
        /**
         * Sets the bounds of the annotation.
         *
         * @param {{x: number, y: number, width: number, height: number}} value bounds.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the bounds of the annotation.
         * annotation.bounds = {x: 10, y: 10, width: 150, height: 5};
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                this._isBounds = true;
                if (this._isLoaded) {
                    if ((value.x !== this.bounds.x) || (value.y !== this.bounds.y) ||
                        (value.width !== this.bounds.width) || (value.height !== this.bounds.height)) {
                        var size = this._page.size;
                        if (size) {
                            var y = size[1] - (value.y + value.height);
                            var height = y + value.height;
                            this._dictionary.update('Rect', [value.x, y, value.x + value.width, height]);
                            this._bounds = value;
                            this._isChanged = true;
                        }
                    }
                }
                else {
                    this._bounds = value;
                    this._isChanged = true;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "caption", {
        /**
         * Gets the caption of the annotation.
         *
         * @returns {PdfAnnotationCaption} Annotation caption.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the caption of the annotation.
         * let caption: PdfAnnotationCaption = annotation.caption;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._caption === 'undefined') {
                var value = new PdfAnnotationCaption();
                value._dictionary = this._dictionary;
                if (this._dictionary && this._dictionary.has('Cap')) {
                    value._cap = this._dictionary.get('Cap');
                }
                if (this._dictionary && this._dictionary.has('CP')) {
                    var capType = this._dictionary.get('CP');
                    if (capType) {
                        value._type = capType.name === 'Top' ? PdfLineCaptionType.top : PdfLineCaptionType.inline;
                    }
                }
                if (this._dictionary && this._dictionary.has('CO')) {
                    value._offset = this._dictionary.getArray('CO');
                }
                this._caption = value;
            }
            return this._caption;
        },
        /**
         * Sets the caption of the annotation.
         *
         * @param {PdfAnnotationCaption} value Annottion caption.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Create and set annotation caption values
         * annotation.caption = new PdfAnnotationCaption(true, PdfLineCaptionType.inline, [10, 10]);
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            var current = this.caption;
            if (value) {
                if (!this._isLoaded || value.cap !== current.cap) {
                    this._caption.cap = value.cap;
                }
                if (!this._isLoaded || value.type !== current.type) {
                    this._caption.type = value.type;
                }
                if (!this._isLoaded || value.offset !== current.offset) {
                    this._caption.offset = value.offset;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "opacity", {
        /**
         * Gets the opacity of the annotation.
         *
         * @returns {number} Opacity in between 0 t0 1.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * //Get the opacity of the annotation.
         * let opacity: number = annotation.opacity;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary && this._dictionary.has('CA')) {
                var opacity = this._dictionary.get('CA');
                if (typeof opacity !== 'undefined') {
                    this._opacity = opacity;
                }
            }
            return this._opacity;
        },
        /**
         * Sets the opacity of the annotation.
         *
         * @param {number} value opacity in between 0 t0 1.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the opacity of the annotation.
         * annotation.opacity = 0.5;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined' && !Number.isNaN(value)) {
                if (value >= 0 && value <= 1) {
                    this._dictionary.update('CA', value);
                    this._opacity = value;
                }
                else if (value < 0) {
                    this._dictionary.update('CA', 0);
                }
                else {
                    this._dictionary.update('CA', 1);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "subject", {
        /**
         * Gets the subject of the annotation.
         *
         * @returns {string} Subject.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * //Get the subject of the annotation.
         * let subject: string = annotation.subject;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._subject === 'undefined') {
                this._subject = this._dictionary.get('Subject', 'Subj');
            }
            return this._subject;
        },
        /**
         * Sets the subject of the annotation.
         *
         * @param {string} value Subject.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the subject of the annotation.
         * annotation.subject = 'Line Annotation';
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value === 'string' && this.subject !== value) {
                this._dictionary.update('Subj', value);
                this._subject = value;
                if (this._dictionary.has('Subject')) {
                    this._dictionary.update('Subject', value);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "name", {
        /**
         * Gets the name of the annotation.
         *
         * @returns {string} Name.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * //Get the name of the annotation.
         * let name: string = annotation.name;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._name === 'undefined' && this._dictionary.has('NM')) {
                this._name = this._dictionary.get('NM');
            }
            return this._name;
        },
        /**
         * Sets the name of the annotation.
         *
         * @param {string} value Name.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the name of the annotation.
         * annotation.name = 'LineAnnotation';
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value === 'string') {
                this._dictionary.update('NM', value);
                this._name = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "text", {
        /**
         * Gets the text of the annotation.
         *
         * @returns {string} Text.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * //Get the text of the annotation.
         * let text: string = annotation.text;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._text === 'undefined' && this._dictionary.has('Contents')) {
                this._text = this._dictionary.get('Contents');
            }
            return this._text;
        },
        /**
         * Sets the text of the annotation.
         *
         * @param {string} value Text.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the text of the annotation.
         * annotation.text = ‘LineAnnotation’;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value === 'string') {
                this._text = this._dictionary.get('Contents');
                if (value !== this._text) {
                    this._dictionary.update('Contents', value);
                    this._text = value;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "rotationAngle", {
        /**
         * Gets the rotation of the annotation.
         *
         * @returns {PdfRotationAngle} Rotation angle.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * //Get the rotation angle of the annotation.
         * let rotationAngle: PdfRotationAngle = annotation.rotationAngle;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._rotate === 'undefined' && this._dictionary && this._dictionary.has('Rotate')) {
                this._rotate = (this._dictionary.get('Rotate') / 90);
            }
            if (this._rotate === null || typeof this._rotate === 'undefined') {
                this._rotate = PdfRotationAngle.angle0;
            }
            return this._rotate;
        },
        /**
         * Sets the rotation of the annotation.
         *
         * @param {PdfRotationAngle} value rotation angle.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the rotation angle of the annotation.
         * annotation.rotationAngle = PdfRotationAngle.angle180;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            var prevRotate = this.rotationAngle;
            if (typeof value !== 'undefined' && typeof prevRotate !== 'undefined') {
                value = ((value + prevRotate) % 4);
            }
            this._dictionary.update('Rotate', value * 90);
            this._isRotated = true;
            this._rotate = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "rotate", {
        /**
         * Gets the rotation angle of the annotation (Read only).
         *
         * @returns {number} Rotation angle.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * //Get the rotation angle of the annotation.
         * let rotate: number = annotation.rotate;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var angle = this._getRotationAngle();
            if (angle < 0) {
                angle = 360 + angle;
            }
            if (angle >= 360) {
                angle = 360 - angle;
            }
            return angle;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "flattenPopups", {
        /**
         * Gets the boolean flag indicating whether annotation's popup have been flattened or not.
         *
         * @returns {boolean} Flatten Popup.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the boolean flag indicating whether annotation's popup have been flattened or not.
         * let flattenPopups: boolean = annotation.flattenPopups;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._isFlattenPopups;
        },
        /**
         * Sets the boolean flag indicating whether the annotation’s popup have been flattened or not.
         *
         * @param {boolean} value Flatten Popup.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the boolean flag indicating whether the annotation’s popup have been flattened or not.
         * annotation.flattenPopups = false;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined') {
                this._isFlattenPopups = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "flatten", {
        /**
         * Gets the boolean flag indicating whether the annotation have been flattened or not.
         *
         * @returns {boolean} Flatten.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the boolean flag indicating whether the annotation have been flattened or not.
         * let flatten: boolean = annotation.flatten;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._flatten;
        },
        /**
         * Sets the boolean flag indicating whether the annotation have been flattened or not.
         *
         * @param {boolean} value Flatten.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the boolean flag indicating whether the annotation have been flattened or not.
         * annotation.flatten = true;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._flatten = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "_hasFlags", {
        get: function () {
            return this._dictionary.has('F');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "_degreeToRadian", {
        get: function () {
            if (typeof this._ratio === 'undefined') {
                this._ratio = Math.PI / 180;
            }
            return this._ratio;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotation.prototype, "layer", {
        /**
         * Gets the `PdfLayer` of the annotation.
         *
         * @returns {PdfLayer} PDF layer to the annotation.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Get the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the first annotation on the page
         * let annotation: PdfAnnotation = page.annotations.at(0);
         * // Get the layer of the annotation
         * let layer: PdfLayer = annotation.layer;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._layer) {
                this._layer = this._getDocumentLayer();
            }
            return this._layer;
        },
        /**
         * Set the `PdfLayer` to the annotation.
         *
         * @param {PdfLayer} value PDF layer to the annotation.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Get the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the collection of layers in the document
         * let layers: PdfLayerCollection = document.layers;
         * // Add a new layer to the document with the name 'Layer1'
         * let layer: PdfLayer = layers.add('Layer1');
         * // Access the first annotation on the page
         * let annotation: PdfAnnotation = page.annotations.at(0);
         * // Assign the layer to the annotation
         * annotation.layer = layer;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (!this._layer) {
                this._layer = value;
                if (this._layer) {
                    this._dictionary.update('OC', this._layer._referenceHolder);
                }
                else {
                    delete this._dictionary._map['OC'];
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set the boolean flag to create a new appearance stream for annotations.
     *
     * @param {boolean} value Set appearance.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Set the boolean flag to create a new appearance stream for annotations.
     * document.getPage(0).annotations.at(0).setAppearance(true);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfAnnotation.prototype.setAppearance = function (value) {
        this._setAppearance = value;
        if (value) {
            this._dictionary._updated = true;
        }
    };
    /**
     * Gets the values associated with the specified key.
     *
     * @param {string} name Key.
     * @returns {string[]} Values associated with the key.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the values associated with the key 'Author'.
     * let values: string[] = document.getPage(0).annotations.at(0).getValues('Author');
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfAnnotation.prototype.getValues = function (name) {
        var values = [];
        if (this._dictionary && this._dictionary.has(name)) {
            var value = this._dictionary.get(name); // eslint-disable-line
            if (Array.isArray(value)) {
                value = this._dictionary.getArray(name);
                for (var i = 0; i < value.length; i++) {
                    var element = value[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                    if (element instanceof _PdfName) {
                        values.push(element.name);
                    }
                    else if (typeof element === 'string') {
                        values.push(element);
                    }
                    else if (typeof element === 'number') {
                        values.push(element.toString());
                    }
                }
            }
            else if (value instanceof _PdfName) {
                values.push(value.name);
            }
            else if (typeof value === 'string') {
                values.push(value);
            }
            else {
                throw new Error('PdfException: ' + name + ' is not found');
            }
        }
        else {
            throw new Error('PdfException: ' + name + ' is not found');
        }
        return values;
    };
    /**
     * Sets the values associated with the specified key.
     *
     * @param {string} name Key.
     * @param {string} value Value associated with the key..
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the annotation at index 0
     * let annotation: PdfAnnotation = document.getPage(0).annotations.at(0);
     * // Set Unknown state and model
     * annotation.setValues('State', 'StateModel');
     * annotation.setValues('StateModel', 'CustomState');
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfAnnotation.prototype.setValues = function (name, value) {
        if (name && name !== '' && value && value !== '') {
            this._dictionary.update(name, value);
        }
    };
    //Implementation
    PdfAnnotation.prototype._initialize = function (page, dictionary) {
        this._page = page;
        this._crossReference = page._crossReference;
        if (dictionary) {
            this._dictionary = dictionary;
        }
        if (!this._isLoaded) {
            this._dictionary.set('P', this._page._ref);
            this._dictionary.assignXref(this._crossReference);
        }
    };
    PdfAnnotation.prototype._getRotationAngle = function () {
        var angle = 0;
        if (this._dictionary) {
            if (this._dictionary.has('Rotate')) {
                angle = this._dictionary.get('Rotate');
            }
            else if (this._dictionary.has('Rotation')) {
                angle = this._dictionary.get('Rotation');
            }
        }
        return angle;
    };
    PdfAnnotation.prototype._getMediaOrCropBox = function (page) {
        var cropOrMediaBox;
        if (page && page._pageDictionary && page._pageDictionary.has('MediaBox')) {
            cropOrMediaBox = page._pageDictionary.get('MediaBox');
        }
        else if (page && page._pageDictionary && page._pageDictionary.has('CropBox')) {
            cropOrMediaBox = page._pageDictionary.get('CropBox');
        }
        return cropOrMediaBox;
    };
    PdfAnnotation.prototype._getBoundsValue = function (linePoints) {
        var count = 0;
        if (_isNullOrUndefined(linePoints)) {
            count = linePoints.length;
        }
        var x = [];
        var y = [];
        if (count > 0) {
            var points = [];
            for (var i = 0; i < linePoints.length; i++) {
                var value = linePoints[Number.parseInt(i.toString(), 10)];
                points.push(value);
            }
            var x1 = 0;
            var y1 = 0;
            for (var i = 0; i < points.length; i++) {
                if (i % 2 === 0) {
                    x[Number.parseInt(x1.toString(), 10)] = points[Number.parseInt(i.toString(), 10)];
                    x1++;
                }
                else {
                    y[Number.parseInt(y1.toString(), 10)] = points[Number.parseInt(i.toString(), 10)];
                    y1++;
                }
            }
        }
        x.sort(function (a, b) { return a > b ? 1 : -1; });
        y.sort(function (a, b) { return a > b ? 1 : -1; });
        return { x: x[0], y: y[0], width: x[x.length - 1] - x[0], height: y[y.length - 1] - y[0] };
    };
    PdfAnnotation.prototype._validateTemplateMatrix = function (dictionary, template) {
        var isRotatedMatrix = false;
        var isValidMatrix = true;
        if (template === null || typeof template === 'undefined') {
            if (dictionary && dictionary.has('Matrix')) {
                var matrix = dictionary.getArray('Matrix');
                if (matrix && matrix.length > 3) {
                    if (typeof matrix[0] !== 'undefined' &&
                        typeof matrix[1] !== 'undefined' &&
                        typeof matrix[2] !== 'undefined' &&
                        typeof matrix[3] !== 'undefined') {
                        if (matrix[0] === 1 && matrix[1] === 0 && matrix[2] === 0 && matrix[3] === 1) {
                            isRotatedMatrix = true;
                            var locationX = 0;
                            var locationY = 0;
                            var templateX = 0;
                            var templateY = 0;
                            if (matrix.length > 4) {
                                templateX = -matrix[4];
                                if (matrix.length > 5) {
                                    templateY = -matrix[5];
                                }
                            }
                            var annotationBounds = void 0;
                            if (this._dictionary && this._dictionary.has('Rect')) {
                                annotationBounds = this._dictionary.getArray('Rect');
                                if (annotationBounds && annotationBounds.length > 1) {
                                    locationX = annotationBounds[0];
                                    locationY = annotationBounds[1];
                                }
                            }
                            if (!(locationX === templateX && locationY === templateY) && templateX === 0 && templateY === 0) {
                                this._locationDisplaced = true;
                            }
                        }
                    }
                }
            }
            else {
                isRotatedMatrix = true;
            }
            return isRotatedMatrix;
        }
        else {
            var point = this.bounds;
            if (dictionary && dictionary.has('Matrix')) {
                var box = dictionary.getArray('BBox');
                var matrix = dictionary.getArray('Matrix');
                if (matrix && box && matrix.length > 3 && box.length > 2) {
                    if (typeof matrix[0] !== 'undefined' &&
                        typeof matrix[1] !== 'undefined' &&
                        typeof matrix[2] !== 'undefined' &&
                        typeof matrix[3] !== 'undefined') {
                        if (matrix[0] === 1 && matrix[1] === 0 && matrix[2] === 0 && matrix[3] === 1) {
                            if (typeof box[0] !== 'undefined' &&
                                typeof box[1] !== 'undefined' &&
                                typeof box[2] !== 'undefined' &&
                                typeof box[3] !== 'undefined') {
                                if (this._page && box[0] !== -(matrix[4]) && box[1] !== -(matrix[5]) ||
                                    (box[0] === 0 && -matrix[4] === 0)) {
                                    var graphics = this._page.graphics;
                                    var state = graphics.save();
                                    if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                                        graphics.setTransparency(this._opacity);
                                    }
                                    point.x -= box[0];
                                    point.y += box[1];
                                    graphics.drawTemplate(template, point);
                                    graphics.restore(state);
                                    this._page.annotations.remove(this);
                                    isValidMatrix = false;
                                }
                            }
                        }
                    }
                }
            }
            return isValidMatrix;
        }
    };
    PdfAnnotation.prototype._flattenAnnotationTemplate = function (template, isNormalMatrix) {
        var graphics = this._page.graphics;
        var currentBounds = this.bounds;
        if (this instanceof PdfLineAnnotation && this._dictionary && !this._dictionary.has('AP')) {
            if (this._isLoaded) {
                currentBounds = this._bounds;
            }
            else {
                if (this instanceof PdfLineAnnotation && !this.measure) {
                    currentBounds = _toRectangle([this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height]);
                }
                else {
                    if (this._setAppearance && this.flatten && !this.measure) {
                        currentBounds = this._bounds;
                    }
                    else {
                        currentBounds = _toRectangle([this.bounds.x, this.bounds.y,
                            this.bounds.width, this.bounds.height]);
                    }
                }
            }
            if (this._page) {
                var size = this._page.size;
                var mBox = this._page.mediaBox;
                var cropBox = this._page.cropBox;
                if (cropBox && Array.isArray(cropBox) && cropBox.length === 4 && this._page._pageDictionary.has('CropBox') &&
                    !this._isLoaded && !this._flatten) {
                    if ((cropBox[0] !== 0 || cropBox[1] !== 0 || size[0] === cropBox[2] ||
                        size[1] === cropBox[3]) && (currentBounds.x !== cropBox[0])) {
                        currentBounds.x -= cropBox[0];
                        currentBounds.y = cropBox[3] - (currentBounds.y + currentBounds.height);
                    }
                    else {
                        currentBounds.y = size[1] - (currentBounds.y + currentBounds.height);
                    }
                }
                else if (mBox && Array.isArray(mBox) && mBox.length === 4 && this._page._pageDictionary.has('MediaBox') &&
                    !this._isLoaded && !this._flatten) {
                    if (mBox[0] > 0 || mBox[1] > 0 || size[0] === mBox[2] || size[1] === mBox[3]) {
                        currentBounds.x -= mBox[0];
                        currentBounds.y = mBox[3] - (currentBounds.y + currentBounds.height);
                    }
                    else {
                        currentBounds.y = size[1] - (currentBounds.y + currentBounds.height);
                    }
                }
                else {
                    if (this instanceof PdfLineAnnotation && !this.measure && !this._isLoaded) {
                        currentBounds.y = size[1] - (currentBounds.y + currentBounds.height);
                    }
                    else {
                        if (this._setAppearance && this.flatten && !this.measure) {
                            currentBounds = this.bounds;
                        }
                        else if (!this._isLoaded) {
                            currentBounds.y = size[1] - (currentBounds.y + currentBounds.height);
                        }
                    }
                }
            }
            else {
                currentBounds.y = currentBounds.y + currentBounds.height;
            }
        }
        if (typeof currentBounds !== 'undefined' && currentBounds !== null) {
            var state = graphics.save();
            this._page._needInitializeGraphics = true;
            if (this._type === _PdfAnnotationType.rubberStampAnnotation) {
                var needScale = true;
                if (this._dictionary && this._dictionary.has('AP')) {
                    var dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        var appearanceStream = dictionary.get('N');
                        if (this.rotate === PdfRotationAngle.angle270 && this._page.rotation === PdfRotationAngle.angle270
                            && appearanceStream.dictionary.has('Matrix')) {
                            var matrix = appearanceStream.dictionary.getArray('Matrix');
                            if (matrix && matrix.length === 6 && matrix[4] === 0 && matrix[5] !== 0) {
                                needScale = false;
                            }
                        }
                    }
                    if (!isNormalMatrix && this.rotate !== PdfRotationAngle.angle180 && needScale) {
                        template._isAnnotationTemplate = true;
                        template._needScale = true;
                    }
                }
            }
            if (!isNormalMatrix && this._type !== _PdfAnnotationType.rubberStampAnnotation) {
                template._isAnnotationTemplate = true;
                template._needScale = true;
            }
            if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                graphics.setTransparency(this._opacity);
            }
            var bounds = this._calculateTemplateBounds(currentBounds, this._page, template, isNormalMatrix, graphics);
            if (this._type === _PdfAnnotationType.rubberStampAnnotation) {
                var size = void 0;
                var location_1;
                if (this.rotate === PdfRotationAngle.angle0) {
                    size = [bounds.width, bounds.height];
                    location_1 = [bounds.x, bounds.y];
                }
                else {
                    size = template._size;
                    location_1 = [bounds.x, bounds.y];
                }
                var isRotatedMatrix = false;
                if (this.rotate !== PdfRotationAngle.angle0 && template._content) {
                    if (template._content.dictionary.has('Matrix')) {
                        var matrix = template._content.dictionary.getArray('Matrix');
                        if (matrix && matrix.length === 6 && matrix[4] === 0 && matrix[5] !== 0) {
                            isRotatedMatrix = true;
                        }
                    }
                }
                var scaleX = (template._size[0] > 0) ? bounds.width / template._size[0] : 1;
                var scaleY = (template._size[1] > 0) ? bounds.height / template._size[1] : 1;
                var needScale = !(Math.trunc(scaleX * 1000) / 1000 === 1 && Math.trunc(scaleY * 1000) / 1000 === 1);
                if (this.rotate !== PdfRotationAngle.angle0 && isRotatedMatrix) {
                    if (this.rotate === PdfRotationAngle.angle90) {
                        if (this._page && this._page.rotation === PdfRotationAngle.angle270) {
                            if (needScale && !(bounds.x === 0 && bounds.y === 0)) {
                                location_1[0] += (size[0] - size[1]);
                                location_1[1] += size[0];
                            }
                            else {
                                location_1[0] += size[1];
                                location_1[1] += (size[0] - size[1]) + (size[0] - size[1]);
                            }
                        }
                        else if (!needScale) {
                            location_1[0] += size[1];
                        }
                    }
                    else if (this.rotate === PdfRotationAngle.angle270) {
                        if (this._page && this._page.rotation === PdfRotationAngle.angle270) {
                            if (needScale && template._isAnnotationTemplate) {
                                location_1[1] = bounds.y - bounds.width;
                            }
                            else if (needScale) {
                                location_1[1] += (size[0] - size[1]);
                            }
                        }
                        else {
                            if (!needScale && !(bounds.x === 0 && bounds.y === 0)) {
                                location_1[1] += -(size[0]);
                            }
                            else {
                                location_1[1] += -(size[0] - size[1]);
                            }
                        }
                    }
                    else if (this.rotate === PdfRotationAngle.angle180) {
                        location_1[0] += size[0];
                        location_1[1] += -(size[1]);
                    }
                }
            }
            if (!template._content.dictionary.has('Matrix') && template._content.dictionary.has('BBox')) {
                var box = template._content.dictionary.getArray('BBox');
                bounds.x -= box[0];
                bounds.y += box[1];
            }
            if (this instanceof PdfAngleMeasurementAnnotation && !this._isLoaded) {
                bounds = _calculateBounds(this._dictionary, this._page);
            }
            graphics.drawTemplate(template, bounds);
            graphics.restore(state);
        }
        this._page.annotations.remove(this);
    };
    PdfAnnotation.prototype._calculateTemplateBounds = function (bounds, page, template, isNormalMatrix, graphics) {
        var annotationBounds = bounds;
        var x = bounds.x;
        var y = bounds.y;
        var width = bounds.width;
        var height = bounds.height;
        if (!isNormalMatrix) {
            var rect = this._dictionary.getArray('Rect');
            if (rect) {
                annotationBounds = _toRectangle(rect);
            }
        }
        if (typeof page !== 'undefined') {
            var graphicsRotation = this._obtainGraphicsRotation(graphics._matrix);
            if (graphicsRotation === 90) {
                graphics.translateTransform(template._size[1], 0);
                graphics.rotateTransform(90);
                if (isNormalMatrix || (typeof this._rotate !== 'undefined' && this._rotate === PdfRotationAngle.angle180)) {
                    x = bounds.x;
                    if (!this._locationDisplaced) {
                        y = -(page.size[1] - bounds.y - bounds.height);
                    }
                    else if (page._origin && page._o[1] !== 0) {
                        y = bounds.y + bounds.height;
                    }
                    else {
                        y = -(page.size[1] - (bounds.height + bounds.y) + (bounds.height - template._size[1]));
                    }
                }
                else {
                    x = bounds.x;
                    y = -(page.size[1] - (bounds.height + bounds.y) + (bounds.width - template._size[1]));
                    width = bounds.height;
                    height = bounds.width;
                }
            }
            else if (graphicsRotation === 180) {
                graphics.translateTransform(template._size[0], template._size[1]);
                graphics.rotateTransform(180);
                if (isNormalMatrix) {
                    x = -(page.size[0] - (bounds.x + bounds.width));
                    y = -(page.size[1] - bounds.y - bounds.height);
                }
                else {
                    x = -(page.size[0] - (bounds.x + template._size[0]));
                    y = -(page.size[1] - bounds.y - template._size[1]);
                    if (typeof this.rotationAngle !== 'undefined' &&
                        (this._rotate === PdfRotationAngle.angle90 ||
                            this._rotate === PdfRotationAngle.angle270)) {
                        y = (-(page.size[1] - bounds.y - template._size[1]) - (bounds.width - bounds.height));
                        width = bounds.height;
                        height = bounds.width;
                    }
                }
            }
            else if (graphicsRotation === 270) {
                graphics.translateTransform(0, template._size[0]);
                graphics.rotateTransform(270);
                if (isNormalMatrix || (typeof this.rotationAngle !== 'undefined' && this._rotate === PdfRotationAngle.angle180)) {
                    x = -(page.size[0] - bounds.x - bounds.width);
                    y = bounds.y;
                }
                else {
                    x = -(page.size[0] - annotationBounds.x - template._size[0]);
                    var matrix = template._content.dictionary.getArray('Matrix');
                    var box = template._content.dictionary.getArray('BBox');
                    if (matrix && box && matrix[5] !== box[2]) {
                        y = bounds.y - (bounds.height - bounds.width);
                    }
                    else {
                        y = (bounds.y + bounds.height) - bounds.width;
                    }
                    width = bounds.height;
                    height = bounds.width;
                }
            }
            else if (graphicsRotation === 0) {
                if (!isNormalMatrix &&
                    (typeof this.rotationAngle !== 'undefined' &&
                        (this.rotationAngle === PdfRotationAngle.angle90 ||
                            this.rotationAngle === PdfRotationAngle.angle270))) {
                    x = bounds.x;
                    y = (bounds.y + bounds.height - bounds.width);
                    width = bounds.height;
                    height = bounds.width;
                }
            }
        }
        return { x: x, y: y, width: width, height: height };
    };
    PdfAnnotation.prototype._obtainGraphicsRotation = function (matrix) {
        var radians = Math.atan2(matrix._matrix._elements[2], matrix._matrix._elements[0]);
        var angle = Math.round(radians * 180 / Math.PI);
        switch (angle) {
            case -90:
                angle = 90;
                break;
            case -180:
                angle = 180;
                break;
            case 90:
                angle = 270;
                break;
        }
        return angle;
    };
    PdfAnnotation.prototype._removeAnnotation = function (page, annotation) {
        if (page && annotation) {
            page.annotations.remove(annotation);
            page._pageDictionary._updated = true;
        }
    };
    PdfAnnotation.prototype._drawCloudStyle = function (graphics, brush, pen, radius, overlap, points, isAppearance) {
        if (_isNullOrUndefined(points) && this._isClockWise(points)) {
            var sortedPoints = [];
            for (var i = points.length - 1; i >= 0; i--) {
                sortedPoints.push(points[Number.parseInt(i.toString(), 10)]);
            }
            points = sortedPoints;
        }
        var circles = [];
        var circleOverlap = 2 * radius * overlap;
        var previousPoint;
        if (_isNullOrUndefined(points)) {
            previousPoint = points[points.length - 1];
        }
        else {
            points = [];
        }
        for (var i = 0; i < points.length; i++) {
            var currentPoint = points[Number.parseInt(i.toString(), 10)];
            var dx = currentPoint[0] - previousPoint[0];
            var dy = currentPoint[1] - previousPoint[1];
            var length_1 = Math.sqrt(dx * dx + dy * dy);
            dx = dx / length_1;
            dy = dy / length_1;
            for (var a = 0; a + 0.1 * circleOverlap < length_1; a += circleOverlap) {
                var cur = new _CloudStyleArc();
                cur.point = [previousPoint[0] + a * dx, previousPoint[1] + a * dy];
                circles.push(cur);
            }
            previousPoint = currentPoint;
        }
        var previousCurvedStyleArc = circles[circles.length - 1];
        for (var i = 0; i < circles.length; i++) {
            var currentCurvedStyleArc = circles[Number.parseInt(i.toString(), 10)];
            var angle = this._getIntersectionDegrees(previousCurvedStyleArc.point, currentCurvedStyleArc.point, radius);
            previousCurvedStyleArc.endAngle = angle[0];
            currentCurvedStyleArc.startAngle = angle[1];
            previousCurvedStyleArc = currentCurvedStyleArc;
        }
        var path = new PdfPath();
        for (var i = 0; i < circles.length; i++) {
            var current = circles[Number.parseInt(i.toString(), 10)];
            var startAngle = current.startAngle % 360;
            var endAngle = current.endAngle % 360;
            var sweepAngel = 0;
            if (startAngle > 0 && endAngle < 0) {
                sweepAngel = (180 - startAngle) + (180 - (endAngle < 0 ? -endAngle : endAngle));
            }
            else if (startAngle < 0 && endAngle > 0) {
                sweepAngel = -startAngle + endAngle;
            }
            else if (startAngle > 0 && endAngle > 0) {
                var difference = 0;
                if (startAngle > endAngle) {
                    difference = startAngle - endAngle;
                    sweepAngel = 360 - difference;
                }
                else {
                    sweepAngel = endAngle - startAngle;
                }
            }
            else if (startAngle < 0 && endAngle < 0) {
                var difference = 0;
                if (startAngle > endAngle) {
                    difference = startAngle - endAngle;
                    sweepAngel = 360 - difference;
                }
                else {
                    sweepAngel = -(startAngle + (-endAngle));
                }
            }
            if (sweepAngel < 0) {
                sweepAngel = -sweepAngel;
            }
            current.endAngle = sweepAngel;
            path.addArc(current.point[0] - radius, current.point[1] - radius, 2 * radius, 2 * radius, startAngle, sweepAngel);
        }
        path.closeFigure();
        var tempPoints = [];
        if (isAppearance) {
            for (var i = 0; i < path._points.length; i++) {
                tempPoints.push([path._points[Number.parseInt(i.toString(), 10)][0], -path._points[Number.parseInt(i.toString(), 10)][1]]);
            }
        }
        var pdfpath;
        if (isAppearance) {
            pdfpath = new PdfPath();
            pdfpath._points = tempPoints;
            pdfpath._pathTypes = path._pathTypes;
        }
        else {
            pdfpath = new PdfPath();
            pdfpath._points = path._points;
            pdfpath._pathTypes = path._pathTypes;
        }
        if (_isNullOrUndefined(brush)) {
            graphics.drawPath(pdfpath, brush);
        }
        var incise = 180 / (Math.PI * 3);
        path = new PdfPath();
        for (var i = 0; i < circles.length; i++) {
            var current = circles[Number.parseInt(i.toString(), 10)];
            path.addArc(current.point[0] - radius, current.point[1] - radius, 2 * radius, 2 * radius, current.startAngle, current.endAngle + incise);
        }
        path.closeFigure();
        tempPoints = [];
        if (isAppearance) {
            for (var i = 0; i < path._points.length; i++) {
                tempPoints.push([path._points[Number.parseInt(i.toString(), 10)][0], -path._points[Number.parseInt(i.toString(), 10)][1]]);
            }
        }
        if (isAppearance) {
            pdfpath = new PdfPath();
            pdfpath._points = tempPoints;
            pdfpath._pathTypes = path._pathTypes;
        }
        else {
            pdfpath = new PdfPath();
            pdfpath._points = path._points;
            pdfpath._pathTypes = path._pathTypes;
        }
        graphics.drawPath(pdfpath, pen);
    };
    PdfAnnotation.prototype._isClockWise = function (points) {
        var sum = 0;
        if (_isNullOrUndefined(points)) {
            for (var i = 0; i < points.length; i++) {
                var first = points[Number.parseInt(i.toString(), 10)];
                var second = points[(i + 1) % points.length];
                sum += (second[0] - first[0]) * (second[1] + first[1]);
            }
        }
        return sum > 0;
    };
    PdfAnnotation.prototype._getIntersectionDegrees = function (first, second, radius) {
        var dx = second[0] - first[0];
        var dy = second[1] - first[1];
        var length = Math.sqrt(dx * dx + dy * dy);
        var a = 0.5 * length / radius;
        if (a < -1) {
            a = -1;
        }
        else if (a > 1) {
            a = 1;
        }
        var radian = Math.atan2(dy, dx);
        var cosvalue = Math.acos(a);
        return [(radian - cosvalue) * (180 / Math.PI), (Math.PI + radian + cosvalue) * (180 / Math.PI)];
    };
    PdfAnnotation.prototype._obtainStyle = function (borderPen, rectangle, borderWidth, parameter) {
        var dash = this.border.dash;
        if (dash && dash.length > 0) {
            var dashPattern = [];
            var isDash = false;
            for (var i = 0; i < dash.length; i++) {
                dashPattern[Number.parseInt(i.toString(), 10)] = dash[Number.parseInt(i.toString(), 10)];
                if (dashPattern[Number.parseInt(i.toString(), 10)] > 0) {
                    isDash = true;
                }
            }
            if (isDash && this.border.style === PdfBorderStyle.dashed) {
                borderPen._dashStyle = PdfDashStyle.dash;
                borderPen._dashPattern = dashPattern;
            }
        }
        if (parameter) {
            if (parameter instanceof _PaintParameter) {
                if (!this._isBounds && this._dictionary.has('RD')) {
                    var array = this._dictionary.getArray('RD');
                    if (array) {
                        rectangle[0] = rectangle[0] + array[0];
                        rectangle[1] = rectangle[1] + borderWidth + array[1];
                        rectangle[2] = rectangle[2] - (array[0] + array[2]);
                        rectangle[3] = rectangle[3] - (array[1] + array[3]);
                    }
                }
                else {
                    rectangle[0] = rectangle[0] + borderWidth;
                    rectangle[1] = rectangle[1] + borderWidth;
                    rectangle[2] = rectangle[2] - this.border.width;
                    rectangle[3] = rectangle[3] - this.border.width;
                }
                parameter.bounds = rectangle;
            }
            else {
                if (parameter.intensity !== 0 && parameter.style === PdfBorderEffectStyle.cloudy) {
                    var radius = parameter.intensity * 5;
                    rectangle[0] = rectangle[0] + radius + borderWidth;
                    rectangle[1] = rectangle[1] + radius + borderWidth;
                    rectangle[2] = rectangle[2] - (2 * radius) - 2 * borderWidth;
                    rectangle[3] = rectangle[3] - (2 * radius) - 2 * borderWidth;
                }
                else {
                    rectangle[0] = rectangle[0] + borderWidth;
                    rectangle[1] = rectangle[1] + borderWidth;
                    rectangle[2] = rectangle[2] - this.border.width;
                    rectangle[3] = this.bounds.height - this.border.width;
                }
            }
        }
        else {
            if (!this._isBounds && this._dictionary && this._dictionary.has('RD')) {
                var array = this._dictionary.getArray('RD');
                if (array) {
                    rectangle[0] = rectangle[0] + array[0];
                    rectangle[1] = rectangle[1] + borderWidth + array[1];
                    rectangle[2] = rectangle[2] - (2 * array[2]);
                    rectangle[3] = rectangle[3] - this.border.width;
                    rectangle[3] = rectangle[3] - (2 * array[3]);
                }
            }
            else {
                rectangle[1] = rectangle[1] + borderWidth;
                rectangle[3] = this.bounds.height - this.border.width;
            }
        }
        return rectangle;
    };
    PdfAnnotation.prototype._createRectangleAppearance = function (borderEffect) {
        var width = this.border.width;
        var rdArray = this._dictionary.getArray('RD');
        if (!rdArray && borderEffect !== null && typeof borderEffect !== 'undefined' && borderEffect.intensity !== 0 && borderEffect.style === PdfBorderEffectStyle.cloudy) {
            var cloudRectangle = { x: this.bounds.x - borderEffect.intensity * 5 - width / 2,
                y: this.bounds.y - borderEffect.intensity * 5 - width / 2,
                width: this.bounds.width + borderEffect.intensity * 10 + width,
                height: this.bounds.height + borderEffect.intensity * 10 + width };
            var radius = borderEffect.intensity * 5;
            rdArray = [radius + width / 2, radius + width / 2, radius + width / 2, radius + width / 2];
            this._dictionary.set('RD', rdArray);
            this.bounds = cloudRectangle;
        }
        if (!this._isBounds && rdArray) {
            var cloudRectangle = { x: this.bounds.x + rdArray[0],
                y: this.bounds.y + rdArray[1],
                width: this.bounds.width - rdArray[2] * 2,
                height: this.bounds.height - rdArray[3] * 2 };
            if (borderEffect.intensity !== 0 && borderEffect.style === PdfBorderEffectStyle.cloudy) {
                cloudRectangle.x = cloudRectangle.x - borderEffect.intensity * 5 - width / 2;
                cloudRectangle.y = cloudRectangle.y - borderEffect.intensity * 5 - width / 2;
                cloudRectangle.width = cloudRectangle.width + borderEffect.intensity * 10 + width;
                cloudRectangle.height = cloudRectangle.height + borderEffect.intensity * 10 + width;
                var radius = borderEffect.intensity * 5;
                this._dictionary.set('RD', [radius + width / 2, radius + width / 2, radius + width / 2, radius + width / 2]);
            }
            else {
                delete this._dictionary._map.RD;
            }
            this.bounds = cloudRectangle;
        }
        var borderWidth = width / 2;
        var nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];
        var template = new PdfTemplate(nativeRectangle, this._crossReference);
        _setMatrix(template, this._getRotationAngle());
        if (borderEffect.intensity !== 0 && borderEffect.style === PdfBorderEffectStyle.cloudy) {
            template._writeTransformation = false;
        }
        var graphics = template.graphics;
        var parameter = new _PaintParameter();
        if (this.innerColor) {
            parameter.backBrush = new PdfBrush(this._innerColor);
        }
        if (width > 0 && this.color) {
            parameter.borderPen = new PdfPen(this._color, width);
        }
        if (this.color) {
            parameter.foreBrush = new PdfBrush(this._color);
        }
        var rectangle = this._obtainStyle(parameter.borderPen, nativeRectangle, borderWidth, borderEffect);
        if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
            graphics.save();
            graphics.setTransparency(this._opacity);
        }
        if (borderEffect.intensity !== 0 && borderEffect.style === PdfBorderEffectStyle.cloudy) {
            this._drawRectangleAppearance(rectangle, graphics, parameter, borderEffect.intensity);
        }
        else {
            graphics.drawRectangle(rectangle[0], rectangle[1], rectangle[2], rectangle[3], parameter.borderPen, parameter.backBrush);
        }
        if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
            graphics.restore();
        }
        return template;
    };
    PdfAnnotation.prototype._drawRectangleAppearance = function (rectangle, graphics, parameter, intensity) {
        var graphicsPath = new PdfPath();
        if (_isNullOrUndefined(rectangle) && rectangle.length === 4) {
            graphicsPath.addRectangle(rectangle[0], rectangle[1], rectangle[2], rectangle[3]);
        }
        var radius = 0;
        if (_isNullOrUndefined(intensity)) {
            radius = intensity * 4.25;
        }
        if (radius > 0) {
            var points = [];
            for (var i = 0; i < graphicsPath._points.length; i++) {
                var sublist = [graphicsPath._points[Number.parseInt(i.toString(), 10)][0],
                    -graphicsPath._points[Number.parseInt(i.toString(), 10)][1]];
                points.push(sublist);
            }
            graphicsPath = new PdfPath();
            graphicsPath.addPolygon(points);
            this._drawCloudStyle(graphics, parameter.backBrush, parameter.borderPen, radius, 0.833, graphicsPath._points, false);
        }
        else {
            graphics.drawRectangle(rectangle[0], rectangle[1], rectangle[2], rectangle[3], parameter.borderPen, parameter.backBrush);
        }
    };
    PdfAnnotation.prototype._createCircleAppearance = function () {
        var nativeBounds = [0, 0, this.bounds.width, this.bounds.height];
        var template = new PdfTemplate(nativeBounds, this._crossReference);
        _setMatrix(template, this._getRotationAngle());
        if (this._dictionary.has('BE')) {
            template._writeTransformation = false;
        }
        if (typeof this.color === 'undefined') {
            this._isTransparentColor = true;
        }
        var graphics = template.graphics;
        var width = this.border.width;
        var borderPen = new PdfPen(this.color, width);
        var parameter = new _PaintParameter();
        if (this.innerColor) {
            parameter.backBrush = new PdfBrush(this._innerColor);
        }
        if (width > 0) {
            parameter.borderPen = borderPen;
        }
        if (this.color) {
            parameter.foreBrush = new PdfBrush(this._color);
        }
        parameter.borderWidth = width;
        var borderWidth = width / 2;
        var rectangle = this._obtainStyle(borderPen, nativeBounds, borderWidth);
        if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
            graphics.save();
            graphics.setTransparency(this._opacity);
        }
        if (this._dictionary.has('BE')) {
            this._drawCircleAppearance(rectangle, borderWidth, graphics, parameter);
        }
        else {
            graphics.drawEllipse(rectangle[0] + borderWidth, rectangle[1], rectangle[2] - width, rectangle[3], parameter.borderPen, parameter.backBrush);
        }
        if (typeof this._opacity !== 'undefined' && this._opacity < 1) {
            graphics.restore();
        }
        return template;
    };
    PdfAnnotation.prototype._drawCircleAppearance = function (rectangle, borderWidth, graphics, parameter) {
        var radius = 0;
        if (this._dictionary.has('RD')) {
            var array = this._dictionary.getArray('RD');
            if (array && array.length > 0) {
                radius = array[0];
            }
        }
        if (radius > 0) {
            var rect = [rectangle[0] + borderWidth,
                -rectangle[1] - rectangle[3],
                rectangle[2] - this.border.width,
                rectangle[3]];
            var left = rect[0];
            var top_1 = rect[1];
            var right = rect[0] + rect[2];
            var bottom = rect[1] + rect[3];
            var controlPointList = [];
            controlPointList.push([right, bottom]);
            controlPointList.push([left, bottom]);
            controlPointList.push([left, top_1]);
            controlPointList.push([right, top_1]);
            var startPointList = [];
            startPointList.push([right, top_1 + (rect[3] / 2)]);
            startPointList.push([left + rect[2] / 2, bottom]);
            startPointList.push([left, top_1 + (rect[3] / 2)]);
            startPointList.push([left + (rect[2] / 2), top_1]);
            var endPointList = [];
            endPointList.push([left + rect[2] / 2, bottom]);
            endPointList.push([left, top_1 + (rect[3] / 2)]);
            endPointList.push([left + (rect[2] / 2), top_1]);
            endPointList.push([right, top_1 + (rect[3] / 2)]);
            var points = [];
            for (var i = 0; i < controlPointList.length; i++) {
                this._createBezier(startPointList[Number.parseInt(i.toString(), 10)], controlPointList[Number.parseInt(i.toString(), 10)], endPointList[Number.parseInt(i.toString(), 10)], points);
            }
            this._drawCloudStyle(graphics, parameter.backBrush, parameter.borderPen, radius, 0.833, points, false);
        }
        else {
            graphics.drawEllipse(rectangle[0] + borderWidth, -rectangle[1], rectangle[2] - this.border.width, -rectangle[3], parameter.borderPen, parameter.backBrush);
        }
    };
    PdfAnnotation.prototype._createBezier = function (first, second, third, bezierPoints) {
        bezierPoints.push(first);
        this._populateBezierPoints(first, second, third, 0, bezierPoints);
        bezierPoints.push(third);
    };
    PdfAnnotation.prototype._populateBezierPoints = function (first, second, third, currentIteration, bezierPoints) {
        if (currentIteration < 2) {
            var midPoint1 = this._midPoint(first, second);
            var midPoint2 = this._midPoint(second, third);
            var midPoint3 = this._midPoint(midPoint1, midPoint2);
            currentIteration++;
            this._populateBezierPoints(first, midPoint1, midPoint3, currentIteration, bezierPoints);
            bezierPoints.push(midPoint3);
            this._populateBezierPoints(midPoint3, midPoint2, third, currentIteration, bezierPoints);
        }
    };
    PdfAnnotation.prototype._midPoint = function (first, second) {
        return [(first[0] + second[0]) / 2, (first[1] + second[1]) / 2];
    };
    PdfAnnotation.prototype._getAngle = function (linePoints) {
        var x1 = linePoints[0];
        var y1 = linePoints[1];
        var x2 = linePoints[2];
        var y2 = linePoints[3];
        var angle = 0;
        if (x2 - x1 === 0) {
            angle = (y2 > y1) ? 90 : 270;
        }
        else {
            var angleRatio = (y2 - y1) / (x2 - x1);
            var radians = Math.atan(angleRatio);
            angle = radians * (180 / Math.PI);
            if ((x2 - x1) < 0 || (y2 - y1) < 0) {
                angle += 180;
            }
            if ((x2 - x1) > 0 && (y2 - y1) < 0) {
                angle -= 180;
            }
            if (angle < 0) {
                angle += 360;
            }
        }
        return angle;
    };
    PdfAnnotation.prototype._getAxisValue = function (value, angle, length) {
        return [value[0] + Math.cos(angle * this._degreeToRadian) * length,
            value[1] + Math.sin(angle * this._degreeToRadian) * length];
    };
    PdfAnnotation.prototype._drawLineEndStyle = function (axisPoint, graphics, angle, pen, brush, style, length, isBegin) {
        var arraowAngle;
        var count;
        var startPoint;
        var first;
        var second;
        var third;
        var fourth;
        var path;
        switch (style) {
            case PdfLineEndingStyle.square:
                graphics.drawRectangle(axisPoint[0] - (3 * length), -(axisPoint[1] + (3 * length)), (6 * length), (6 * length), pen, brush);
                break;
            case PdfLineEndingStyle.circle:
                graphics.drawEllipse(axisPoint[0] - (3 * length), -(axisPoint[1] + (3 * length)), (6 * length), (6 * length), pen, brush);
                break;
            case PdfLineEndingStyle.openArrow:
                arraowAngle = isBegin ? 30 : 150;
                count = 9 * length;
                startPoint = this._getAxisValue(axisPoint, angle, (isBegin ? length : (-length)));
                first = this._getAxisValue(startPoint, (angle + arraowAngle), count);
                second = this._getAxisValue(startPoint, (angle - arraowAngle), count);
                path = new PdfPath();
                path._pen = pen;
                path.addLine(startPoint[0], -startPoint[1], first[0], -first[1]);
                path.addLine(startPoint[0], -startPoint[1], second[0], -second[1]);
                graphics._stateControl(pen, null, null);
                graphics._buildUpPath(path._points, path._pathTypes);
                graphics._drawGraphicsPath(pen, null, path._fillMode, false);
                break;
            case PdfLineEndingStyle.closedArrow:
                arraowAngle = isBegin ? 30 : 150;
                count = 9 * length;
                startPoint = this._getAxisValue(axisPoint, angle, (isBegin ? length : (-length)));
                first = this._getAxisValue(startPoint, (angle + arraowAngle), count);
                second = this._getAxisValue(startPoint, (angle - arraowAngle), count);
                graphics.drawPolygon([[startPoint[0], -startPoint[1]], [first[0], -first[1]], [second[0], -second[1]]], pen, brush);
                break;
            case PdfLineEndingStyle.rOpenArrow:
                arraowAngle = isBegin ? 150 : 30;
                count = 9 * length;
                startPoint = this._getAxisValue(axisPoint, angle, (isBegin ? (-length) : length));
                first = this._getAxisValue(startPoint, (angle + arraowAngle), count);
                second = this._getAxisValue(startPoint, (angle - arraowAngle), count);
                path = new PdfPath();
                path._pen = pen;
                path.addLine(startPoint[0], -startPoint[1], first[0], -first[1]);
                path.addLine(startPoint[0], -startPoint[1], second[0], -second[1]);
                graphics._stateControl(pen, null, null);
                graphics._buildUpPath(path._points, path._pathTypes);
                graphics._drawGraphicsPath(pen, null, path._fillMode, false);
                break;
            case PdfLineEndingStyle.rClosedArrow:
                arraowAngle = isBegin ? 150 : 30;
                count = 9 * length;
                startPoint = this._getAxisValue(axisPoint, angle, (isBegin ? (-length) : length));
                first = this._getAxisValue(startPoint, (angle + arraowAngle), count);
                second = this._getAxisValue(startPoint, (angle - arraowAngle), count);
                graphics.drawPolygon([[startPoint[0], -startPoint[1]], [first[0], -first[1]], [second[0], -second[1]]], pen, brush);
                break;
            case PdfLineEndingStyle.slash:
                count = 9 * length;
                first = this._getAxisValue(axisPoint, (angle + 60), count);
                second = this._getAxisValue(axisPoint, (angle - 120), count);
                graphics.drawLine(pen, axisPoint[0], -axisPoint[1], first[0], -first[1]);
                graphics.drawLine(pen, axisPoint[0], -axisPoint[1], second[0], -second[1]);
                break;
            case PdfLineEndingStyle.diamond:
                count = 3 * length;
                first = this._getAxisValue(axisPoint, 180, count);
                second = this._getAxisValue(axisPoint, 90, count);
                third = this._getAxisValue(axisPoint, 0, count);
                fourth = this._getAxisValue(axisPoint, -90, count);
                graphics.drawPolygon([[first[0], -first[1]], [second[0], -second[1]], [third[0], -third[1]], [fourth[0], -fourth[1]]], pen, brush);
                break;
            case PdfLineEndingStyle.butt:
                count = 3 * length;
                first = this._getAxisValue(axisPoint, (angle + 90), count);
                second = this._getAxisValue(axisPoint, (angle - 90), count);
                graphics.drawLine(pen, first[0], -first[1], second[0], -second[1]);
                break;
        }
    };
    PdfAnnotation.prototype._drawLineStyle = function (start, end, graphics, angle, pen, brush, lineStyle, length) {
        if (length === 0) {
            length = 1;
            pen = null;
        }
        this._drawLineEndStyle(start, graphics, angle, pen, brush, lineStyle.begin, length, true);
        this._drawLineEndStyle(end, graphics, angle, pen, brush, lineStyle.end, length, false);
    };
    PdfAnnotation.prototype._obtainFontDetails = function () {
        var fontFamily = '';
        var fontSize;
        var style = PdfFontStyle.regular;
        if (this._dictionary.has('DS') || this._dictionary.has('DA')) {
            var fontStyle = void 0;
            if (this._dictionary.has('DS')) {
                var collection = this._dictionary.get('DS').split(';');
                for (var i = 0; i < collection.length; i++) {
                    var entry = collection[Number.parseInt(i.toString(), 10)].split(':');
                    if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-family') !== -1) {
                        fontFamily = entry[1];
                    }
                    else if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-size') !== -1) {
                        if (entry[1].endsWith('pt')) {
                            fontSize = Number.parseFloat(entry[1].replace('pt', ''));
                        }
                    }
                    else if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-style') !== -1 || collection[Number.parseInt(i.toString(), 10)].indexOf('style') !== -1) {
                        fontStyle = entry[1];
                    }
                    else if (collection[Number.parseInt(i.toString(), 10)].indexOf('font') !== -1) {
                        var name_1 = entry[1];
                        var split = name_1.split(' ');
                        for (var j = 0; j < split.length; j++) {
                            if (split[Number.parseInt(j.toString(), 10)] !== '' && !split[Number.parseInt(j.toString(), 10)].endsWith('pt')) {
                                fontFamily += split[Number.parseInt(j.toString(), 10)] + ' ';
                            }
                            if (split[Number.parseInt(j.toString(), 10)].endsWith('pt')) {
                                fontSize = Number.parseFloat(split[Number.parseInt(j.toString(), 10)].replace('pt', ''));
                            }
                        }
                        while (fontFamily !== ' ' && fontFamily.endsWith(' ')) {
                            fontFamily = fontFamily.substring(0, fontFamily.length - 1);
                        }
                        if (fontFamily.indexOf(',') !== -1) {
                            fontFamily = fontFamily.split(',')[0];
                        }
                    }
                }
            }
            else {
                var value = this._dictionary.get('DA');
                if (value && value !== '' && value.indexOf('Tf') !== -1) {
                    var textCollection = value.split(' ');
                    for (var i = 0; i < textCollection.length; i++) {
                        if (textCollection[Number.parseInt(i.toString(), 10)].indexOf('Tf') !== -1) {
                            fontFamily = textCollection[i - 2];
                            while (fontFamily !== '' && fontFamily.length > 1 && fontFamily[0] === '/') {
                                fontFamily = fontFamily.substring(1);
                            }
                            fontSize = Number.parseFloat(textCollection[i - 1]);
                        }
                    }
                }
            }
            if (fontStyle && fontStyle !== '') {
                var styleArray = [fontStyle];
                if (fontStyle.includes(':')) {
                    styleArray = fontStyle.split(':');
                }
                else if (fontStyle.includes(',')) {
                    styleArray = fontStyle.split(',');
                }
                if (styleArray) {
                    styleArray.forEach(function (entry) {
                        entry = entry.trim();
                        switch (entry.toLowerCase()) {
                            case 'bold':
                                style |= PdfFontStyle.bold;
                                break;
                            case 'italic':
                                style |= PdfFontStyle.italic;
                                break;
                            case 'strikeout':
                                style |= PdfFontStyle.strikeout;
                                break;
                            case 'underline':
                                style |= PdfFontStyle.underline;
                                break;
                        }
                    });
                }
            }
            if (fontFamily) {
                fontFamily = fontFamily.trim();
            }
        }
        return { name: fontFamily, size: fontSize, style: style };
    };
    PdfAnnotation.prototype._obtainFont = function () {
        var fontData = this._obtainFontDetails();
        return _mapFont(fontData.name, fontData.size, fontData.style, this);
    };
    PdfAnnotation.prototype._getEqualPdfGraphicsUnit = function (measurementUnit, unitString) {
        var graphicsUnit;
        switch (measurementUnit) {
            case PdfMeasurementUnit.inch:
                graphicsUnit = _PdfGraphicsUnit.inch;
                unitString = 'in';
                break;
            case PdfMeasurementUnit.centimeter:
                graphicsUnit = _PdfGraphicsUnit.centimeter;
                unitString = 'cm';
                break;
            case PdfMeasurementUnit.millimeter:
                graphicsUnit = _PdfGraphicsUnit.millimeter;
                unitString = 'mm';
                break;
            case PdfMeasurementUnit.pica:
                graphicsUnit = _PdfGraphicsUnit.pica;
                unitString = 'p';
                break;
            case PdfMeasurementUnit.point:
                graphicsUnit = _PdfGraphicsUnit.point;
                unitString = 'pt';
                break;
            default:
                graphicsUnit = _PdfGraphicsUnit.inch;
                unitString = 'in';
                break;
        }
        return { graphicsUnit: graphicsUnit, unitString: unitString };
    };
    PdfAnnotation.prototype._createMeasureDictionary = function (unitString) {
        var d = new _PdfDictionary();
        d.set('C', 1);
        d.set('D', 100);
        d.set('F', _PdfName.get('D'));
        d.set('RD', '.');
        d.set('RT', '');
        d.set('SS', '');
        d.set('U', unitString);
        var a = new _PdfDictionary();
        a.set('C', 1);
        a.set('D', 100);
        a.set('F', _PdfName.get('D'));
        a.set('RD', '.');
        a.set('RT', '');
        a.set('SS', '');
        a.set('U', 'sq ' + unitString);
        var x = new _PdfDictionary();
        if (unitString === 'in') {
            x.set('C', 0.0138889);
        }
        else if (unitString === 'cm') {
            x.set('C', 0.0352778);
        }
        else if (unitString === 'mm') {
            x.set('C', 0.352778);
        }
        else if (unitString === 'pt') {
            x.set('C', 1);
        }
        else if (unitString === 'p') {
            x.set('C', 0.0833333);
        }
        x.set('D', 100);
        x.set('F', _PdfName.get('D'));
        x.set('RD', '.');
        x.set('RT', '');
        x.set('SS', '');
        x.set('U', unitString);
        var measureDictionary = new _PdfDictionary();
        measureDictionary.set('A', [a]);
        measureDictionary.set('D', [d]);
        measureDictionary.set('R', '1 ' + unitString + ' = 1 ' + unitString);
        measureDictionary.set('Type', _PdfName.get('Measure'));
        measureDictionary.set('X', [x]);
        return measureDictionary;
    };
    PdfAnnotation.prototype._colorToHex = function (col) {
        if (col) {
            return '#' + this._componentToHex(col[0]) + this._componentToHex(col[1]) + this._componentToHex(col[2]);
        }
        else {
            return '#' + this._componentToHex(0) + this._componentToHex(0) + this._componentToHex(0);
        }
    };
    PdfAnnotation.prototype._componentToHex = function (c) {
        var hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    };
    PdfAnnotation.prototype._getRotatedBounds = function (bounds, rotateAngle) {
        if (bounds.width > 0 && bounds.height > 0) {
            var matrix = new _PdfTransformationMatrix();
            matrix._rotate(rotateAngle);
            var corners = [];
            corners.push([bounds.x, bounds.y]);
            corners.push([bounds.x + bounds.width, bounds.y]);
            corners.push([bounds.x + bounds.width, bounds.y + bounds.height]);
            corners.push([bounds.x, bounds.y + bounds.height]);
            for (var i = 0; i < corners.length; i++) {
                corners[Number.parseInt(i.toString(), 10)] = matrix._matrix._transform(corners[Number.parseInt(i.toString(), 10)]);
            }
            var path = new PdfPath();
            path.addRectangle(bounds.x, bounds.y, bounds.width, bounds.height);
            for (var i = 0; i < 4; i++) {
                path._points[Number.parseInt(i.toString(), 10)] = corners[Number.parseInt(i.toString(), 10)];
            }
            var minX = corners[0][0];
            var maxX = corners[3][0];
            var minY = corners[0][1];
            var maxY = corners[3][1];
            for (var i = 0; i < 4; i++) {
                if (corners[Number.parseInt(i.toString(), 10)][0] < minX) {
                    minX = corners[Number.parseInt(i.toString(), 10)][0];
                }
                if (corners[Number.parseInt(i.toString(), 10)][0] > maxX) {
                    maxX = corners[Number.parseInt(i.toString(), 10)][0];
                }
                if (corners[Number.parseInt(i.toString(), 10)][1] < minY) {
                    minY = corners[Number.parseInt(i.toString(), 10)][1];
                }
                if (corners[Number.parseInt(i.toString(), 10)][1] > maxY) {
                    maxY = corners[Number.parseInt(i.toString(), 10)][1];
                }
            }
            return { x: bounds.x, y: bounds.y, width: Math.round(maxX - minX), height: Math.round(maxY - minY) };
        }
        return bounds;
    };
    PdfAnnotation.prototype._flattenPopUp = function () {
        this._flattenPop(this._page, this.color, this.bounds, this.border, this.author, this.subject, this.text);
    };
    PdfAnnotation.prototype._flattenPop = function (_page, color, boundsValue, border, author, subject, text) {
        var clientSize = [0, 0];
        if (_page && _page.size) {
            clientSize = _page.size;
        }
        var x = clientSize[0] - 180;
        var annotBounds = boundsValue;
        var y = (annotBounds.y + 142) < clientSize[1] ? annotBounds.y : clientSize[1] - 142;
        var bounds = [x, y, 180, 142];
        if (this._dictionary.has('Popup')) {
            var dictionary = this._dictionary.get('Popup');
            if (dictionary) {
                var rectValue = this._dictionary.getArray('Rect');
                if (rectValue && rectValue.length === 4) {
                    var left = rectValue[0];
                    var top_2 = rectValue[1];
                    var width = rectValue[2];
                    var height = rectValue[3];
                    bounds = [left, top_2, width - left, height - top_2];
                }
            }
        }
        if (typeof color === 'undefined') {
            color = [0, 0, 0];
        }
        var backBrush = new PdfBrush(color);
        var borderWidth = border.width / 2;
        var pen = new PdfPen([0, 0, 0], 1);
        var track = 0;
        var aBrush = new PdfBrush(this._getForeColor(color));
        if (typeof author !== 'undefined' && author !== null && author !== '') {
            track = this._drawAuthor(author, subject, bounds, backBrush, aBrush, _page, track, border);
        }
        else if (typeof subject !== 'undefined' && subject !== null && subject !== '') {
            var titleRect = [bounds[0] + borderWidth, bounds[1] + borderWidth, bounds[2] - border.width, 40];
            this._saveGraphics(_page, PdfBlendMode.hardLight);
            if (this._isTransparentColor) {
                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen);
            }
            else {
                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);
            }
            _page.graphics.restore();
            var contentRect = [titleRect[0] + 11, titleRect[1], titleRect[2], titleRect[3] / 2];
            contentRect = [contentRect[0], (contentRect[1] + contentRect[3] - 2), contentRect[2], titleRect[3] / 2];
            this._saveGraphics(_page, PdfBlendMode.normal);
            this._drawSubject(subject, contentRect, _page);
            _page.graphics.restore();
            track = 40;
        }
        else {
            this._saveGraphics(_page, PdfBlendMode.hardLight);
            var titleRect = [bounds[0] + borderWidth, bounds[1] + borderWidth, bounds[2] - border.width, 20];
            if (this._isTransparentColor) {
                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen);
            }
            else {
                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);
            }
            track = 20;
            _page.graphics.restore();
        }
        var rect = [bounds[0] + borderWidth, bounds[1] + borderWidth + track,
            bounds[2] - border.width, bounds[3] - (track + border.width)];
        this._saveGraphics(_page, PdfBlendMode.hardLight);
        _page.graphics.drawRectangle(rect[0], rect[1], rect[2], rect[3], new PdfPen([0, 0, 0], 1), new PdfBrush([255, 255, 255]));
        rect[0] += 11;
        rect[1] += 5;
        rect[2] -= 22;
        _page.graphics.restore();
        this._saveGraphics(_page, PdfBlendMode.normal);
        if (typeof text !== 'undefined' && text !== null && text !== '') {
            _page.graphics.drawString(text, this._popUpFont, rect, null, new PdfBrush([0, 0, 0]), null);
        }
        _page.graphics.restore();
    };
    PdfAnnotation.prototype._flattenLoadedPopUp = function () {
        var content = '';
        if (this._dictionary.has('Contents')) {
            content = this._dictionary.get('Contents');
        }
        var author = this.author;
        var subject = this.subject;
        var pen = new PdfPen([0, 0, 0], 1);
        if (!this._dictionary.has('Popup')) {
            this._flattenPop(this._page, this.color, this.bounds, this.border, author, subject, content);
            this._page.annotations.remove(this);
        }
        else {
            var bounds = this._getRectangleBoundsValue();
            if (typeof this.color === 'undefined') {
                this.color = [0, 0, 0];
            }
            var backBrush = new PdfBrush(this.color);
            var borderWidth = this.border.width / 2;
            var track = 0;
            var aBrush = new PdfBrush(this._getForeColor(this.color));
            if (typeof this.author !== 'undefined' && this.author !== null && this.author !== '') {
                track = this._drawAuthor(this.author, this.subject, bounds, backBrush, aBrush, this._page, track, this.border);
            }
            else if (typeof this.subject !== 'undefined' && this.subject !== null && this.subject !== '') {
                var titleRect = [bounds[0] + borderWidth, bounds[1] + borderWidth, bounds[2] - this.border.width, 40];
                this._saveGraphics(this._page, PdfBlendMode.hardLight);
                this._page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);
                this._page.graphics.restore();
                var contentRect = [titleRect[0] + 11, titleRect[1], titleRect[2], titleRect[3] / 2];
                contentRect = [contentRect[0], (contentRect[1] + contentRect[3] - 2), contentRect[2], titleRect[3] / 2];
                this._saveGraphics(this._page, PdfBlendMode.normal);
                this._drawSubject(this.subject, contentRect, this._page);
                track = 40;
                this._page.graphics.restore();
            }
            else {
                this._saveGraphics(this._page, PdfBlendMode.hardLight);
                var titleRect = [bounds[0] + borderWidth, bounds[1] + borderWidth, bounds[2] - this.border.width, 20];
                this._page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);
                track = 20;
                this._page.graphics.restore();
            }
            this._saveGraphics(this._page, PdfBlendMode.hardLight);
            var rect = [bounds[0] + borderWidth, bounds[1] + borderWidth + track,
                bounds[2] - this.border.width, bounds[3] - (track + this.border.width)];
            this._page.graphics.drawRectangle(rect[0], rect[1], rect[2], rect[3], pen, new PdfBrush([255, 255, 255]));
            rect[0] += 11;
            rect[1] += 5;
            rect[2] -= 22;
            this._page.graphics.restore();
            this._saveGraphics(this._page, PdfBlendMode.normal);
            this._page.graphics.restore();
            //let xmlData: Array<any> = Array<any>();
            // if (this._dictionary.has('RC')) {
            //     //xmlData = this.parseXMLData();
            // }
            // if (xmlData !== null) {
            //     // Need to add xml data code
            // } else {
            if (typeof content !== 'undefined' && content !== null && content !== '') {
                this._page.graphics.drawString(content, this._popUpFont, rect, null, new PdfBrush([0, 0, 0]), null);
            }
            // }
            this._page.graphics.restore();
            this._page.annotations.remove(this);
        }
    };
    PdfAnnotation.prototype._getRectangleBoundsValue = function () {
        if (this._dictionary.has('Popup')) {
            var dic = this._dictionary.get('Popup');
            var rect = dic.getArray('Rect');
            if (rect !== null) {
                if (this._page !== null) {
                    if (rect[1] === 0 && rect[3] === 0) {
                        rect[1] = rect[1] + rect[3];
                    }
                    else {
                        rect[1] = this._page._size[1] - (rect[1] + rect[3]);
                    }
                }
                else {
                    rect[1] = (rect[1] - rect[3]);
                }
                return rect;
            }
            else {
                return [0, 0, 0, 0];
            }
        }
        else {
            return [0, 0, 0, 0];
        }
    };
    PdfAnnotation.prototype._getForeColor = function (color) {
        var fore = (((color[0] + color[1] + color[2]) / 3) > 128) ? [0, 0, 0] : [255, 255, 255];
        return fore;
    };
    PdfAnnotation.prototype._drawAuthor = function (author, subject, bounds, backBrush, aBrush, _page, trackingHeight, border) {
        var borderWidth = this.border.width / 2;
        var pen = new PdfPen([0, 0, 0], 1);
        var format = new PdfStringFormat(PdfTextAlignment.left, PdfVerticalAlignment.middle);
        var titleRect = [bounds[0] + borderWidth, bounds[1] + borderWidth, bounds[2] - border.width, 20];
        if (typeof subject !== 'undefined' && subject !== null && subject !== '') {
            titleRect[3] += 20;
            trackingHeight = titleRect[3];
            this._saveGraphics(_page, PdfBlendMode.hardLight);
            if (this._isTransparentColor) {
                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen);
            }
            else {
                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);
            }
            _page.graphics.restore();
            var contentRect = [titleRect[0] + 11, titleRect[1], titleRect[2], titleRect[3] / 2];
            this._saveGraphics(this._page, PdfBlendMode.normal);
            _page.graphics.drawString(author, this._authorBoldFont, contentRect, null, aBrush, format);
            contentRect = [contentRect[0], (contentRect[1] + contentRect[3] - 2), contentRect[2], titleRect[3] / 2];
            this._drawSubject(subject, contentRect, _page);
            _page.graphics.restore();
        }
        else {
            this._saveGraphics(_page, PdfBlendMode.hardLight);
            if (this._isTransparentColor) {
                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen);
            }
            else {
                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);
            }
            _page.graphics.restore();
            var contentRect = [titleRect[0] + 11, titleRect[1], titleRect[2], titleRect[3]];
            this._saveGraphics(_page, PdfBlendMode.normal);
            _page.graphics.drawString(author, this._popUpFont, contentRect, null, aBrush, format);
            trackingHeight = titleRect[3];
            _page.graphics.restore();
        }
        return trackingHeight;
    };
    PdfAnnotation.prototype._drawSubject = function (subject, contentRect, _page) {
        var format = new PdfStringFormat(PdfTextAlignment.left, PdfVerticalAlignment.middle);
        _page.graphics.drawString(subject, this._authorBoldFont, contentRect, null, new PdfBrush([0, 0, 0]), format);
    };
    PdfAnnotation.prototype._saveGraphics = function (_page, blendMode) {
        _page.graphics.save();
        _page.graphics.setTransparency(0.8, 0.8, blendMode);
    };
    PdfAnnotation.prototype._getBorderColorString = function (color) {
        return (color[0] / 255).toFixed(3) + ' ' + (color[1] / 255).toFixed(3) + ' ' + (color[2] / 255).toFixed(3) + ' rg ';
    };
    PdfAnnotation.prototype._stringToDate = function (date) {
        var dateFormat = new Date();
        if (date[0] === 'D' && date[1] === ':') {
            var year = date.substring(2, 6);
            var month = date.substring(6, 8);
            var day = date.substring(8, 10);
            var hour = date.substring(10, 12);
            var minute = date.substring(12, 14);
            var second = date.substring(14, 16);
            var difference = 0;
            if (date.length === 23) {
                var timeZone = date.substring(16, 22);
                if (timeZone !== '+05\'30\'') {
                    var signature = timeZone[0];
                    var timeZoneHour = timeZone.substring(1, 3);
                    var timeZonMinute = timeZone.substring(4, 6);
                    difference = 5.5 - (signature === '-' ? -1 : 1) * (parseInt(timeZoneHour, 10) + (parseInt(timeZonMinute, 10) / 60));
                }
            }
            dateFormat = new Date(year + '-' + month + '-' + day + 'T' + hour + ':' + minute + ':' + second);
            if (difference !== 0) {
                dateFormat.setTime(dateFormat.getTime() + (difference * 60 * 60 * 1000));
            }
        }
        else if (date.indexOf('/') !== -1) {
            var list = date.split('/');
            var year = list[2].split(' ')[0];
            var month = list[0];
            if (month !== '10' && month !== '11' && month !== '12') {
                month = '0' + month;
            }
            var day = list[1];
            var hour = list[2].split(' ')[1].split(':')[0];
            var minute = list[2].split(' ')[1].split(':')[1];
            var second = list[2].split(' ')[1].split(':')[2];
            dateFormat = new Date(year + '-' + month + '-' + day + 'T' + hour + ':' + minute + ':' + second);
        }
        else {
            dateFormat = new Date(date);
        }
        return dateFormat;
    };
    PdfAnnotation.prototype._dateToString = function (dateTime) {
        var month = (dateTime.getMonth() + 1).toString();
        if (month !== '10' && month !== '11' && month !== '12') {
            month = '0' + month;
        }
        var date = (dateTime.getDate()).toString();
        if (Number.parseInt(date) < 10) { // eslint-disable-line
            date = '0' + date;
        }
        var hours = (dateTime.getHours()).toString();
        if (Number.parseInt(hours) < 10) { // eslint-disable-line
            hours = '0' + hours;
        }
        var minutes = (dateTime.getMinutes()).toString();
        if (Number.parseInt(minutes) < 10) { // eslint-disable-line
            minutes = '0' + minutes;
        }
        var seconds = (dateTime.getSeconds()).toString();
        if (Number.parseInt(seconds) < 10) { // eslint-disable-line
            seconds = '0' + seconds;
        }
        return 'D:' + dateTime.getFullYear().toString() + month + date + hours + minutes + seconds + '+05\'30\'';
    };
    PdfAnnotation.prototype._obtainNativeRectangle = function () {
        var rect = [this._bounds.x, this._bounds.y, this.bounds.x + this._bounds.width, this.bounds.y + this._bounds.height];
        var cropBoxOrMediaBox = this._getCropOrMediaBox();
        if (this._page) {
            var size = this._page.size;
            rect[1] = size[1] - rect[3];
            if (cropBoxOrMediaBox && cropBoxOrMediaBox.length > 2 && (cropBoxOrMediaBox[0] !== 0 || cropBoxOrMediaBox[1] !== 0)) {
                rect[0] += cropBoxOrMediaBox[0];
                rect[1] += cropBoxOrMediaBox[1];
            }
        }
        return rect;
    };
    PdfAnnotation.prototype._getPoints = function (polygonPoints) {
        var cropOrMediaBox = this._getCropOrMediaBox();
        var points = polygonPoints;
        if (cropOrMediaBox && cropOrMediaBox.length > 3 && typeof cropOrMediaBox[0] === 'number' && typeof cropOrMediaBox[1] === 'number' && (cropOrMediaBox[0] !== 0 || cropOrMediaBox[1] !== 0)) {
            var modifiedPoints = [];
            for (var i = 0; i < points.length; i++) {
                modifiedPoints.push(points[Number.parseInt(i.toString(), 10)]);
            }
            for (var j = 0; j < modifiedPoints.length; j = j + 2) {
                var x = modifiedPoints[Number.parseInt(j.toString(), 10)];
                var y = modifiedPoints[j + 1];
                if (cropOrMediaBox) {
                    points[Number.parseInt(j.toString(), 10)] = x + cropOrMediaBox[0];
                    if (this._page._pageDictionary.has('MediaBox') && !this._page._pageDictionary.has('CropBox') && cropOrMediaBox[3] === 0 && cropOrMediaBox[1] > 0) {
                        points[j + 1] = y + cropOrMediaBox[3];
                    }
                    else {
                        points[j + 1] = y + cropOrMediaBox[1];
                    }
                }
            }
        }
        return points;
    };
    PdfAnnotation.prototype._getCropOrMediaBox = function () {
        var cropOrMediaBox;
        if (this._page) {
            cropOrMediaBox = this._page.cropBox;
            if (!cropOrMediaBox || cropOrMediaBox.length === 0) {
                cropOrMediaBox = this._page.mediaBox;
            }
        }
        if (cropOrMediaBox && cropOrMediaBox[3] < 0) {
            var y = cropOrMediaBox[1];
            var height = cropOrMediaBox[3];
            cropOrMediaBox[3] = y;
            cropOrMediaBox[1] = height;
        }
        return cropOrMediaBox;
    };
    PdfAnnotation.prototype._getDocumentLayer = function () {
        if (this._dictionary.has('OC')) {
            var reference = this._dictionary.getRaw('OC');
            var page = this._page;
            if (reference && page && this._crossReference._document) {
                var layerCollection = this._crossReference._document.layers;
                if (layerCollection) {
                    this._isMatched(layerCollection, reference, page);
                }
            }
        }
        return this.layer;
    };
    PdfAnnotation.prototype._isMatched = function (layerCollection, expectedReference, page) {
        for (var i = 0; i < layerCollection.count; i++) {
            var reference = layerCollection.at(i)._referenceHolder;
            if (reference && reference === expectedReference) {
                if (layerCollection.at(i).name) {
                    this._layer = layerCollection.at(i);
                    break;
                }
            }
            else if (layerCollection.at(i).layers && layerCollection.at(i).layers.count > 0) {
                this._isMatched(layerCollection.at(i).layers, expectedReference, page);
            }
        }
    };
    return PdfAnnotation;
}());
/**
 * Represents the annotations which have comments and review history.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfComment = page.annotations.at(0) as PdfComment;
 * // Gets the comments of annotation
 * let comment : PdfPopupAnnotationCollection = annotation.comments;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfComment = /** @class */ (function (_super) {
    __extends$6(PdfComment, _super);
    function PdfComment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(PdfComment.prototype, "comments", {
        /**
         * Gets the comments of the PDF annotation (Read only).
         *
         * @returns {PdfPopupAnnotationCollection} Annotation comments
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Access the annotation at index 0
         * let annotation: PdfRectangleAnnotation = page.annotations.at(0) as PdfRectangleAnnotation;
         * // Gets the comments of the PDF annotation
         * let comments: PdfPopupAnnotationCollection = annotation.comments;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._comments) {
                return this._comments;
            }
            else {
                return this._comments = new PdfPopupAnnotationCollection(this, false);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfComment.prototype, "reviewHistory", {
        /**
         * Gets the review history of the PDF annotation (Read only).
         *
         * @returns {PdfPopupAnnotationCollection} Annotation review history.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Access the annotation at index 0
         * let annotation: PdfRectangleAnnotation = page.annotations.at(0) as PdfRectangleAnnotation;
         * // Gets the comments of the PDF annotation
         * let comments: PdfPopupAnnotationCollection = annotation.reviewHistory;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._reviewHistory) {
                return this._reviewHistory;
            }
            else {
                return this._reviewHistory = new PdfPopupAnnotationCollection(this, true);
            }
        },
        enumerable: true,
        configurable: true
    });
    return PdfComment;
}(PdfAnnotation));
/**
 * `PdfLineAnnotation` class represents the line annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new line annotation with line points
 * const annotation: PdfLineAnnotation = new PdfLineAnnotation([10, 50, 250, 50]);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfLineAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfLineAnnotation, _super);
    function PdfLineAnnotation(linePoints) {
        var _this = _super.call(this) || this;
        _this._unit = PdfMeasurementUnit.centimeter;
        _this._unitString = '';
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('Line'));
        if (linePoints !== null && typeof linePoints !== 'undefined') {
            _this.linePoints = linePoints;
        }
        _this._type = _PdfAnnotationType.lineAnnotation;
        return _this;
    }
    Object.defineProperty(PdfLineAnnotation.prototype, "linePoints", {
        /**
         * Gets the line points of the line annotation.
         *
         * @returns {number[]} Line points.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the line points of the line annotation.
         * let linePoints : number[] = annotation.linePoints;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._linePoints === 'undefined' && this._dictionary.has('L')) {
                var points = this._dictionary.getArray('L');
                if (points) {
                    this._linePoints = points;
                }
            }
            return this._linePoints;
        },
        /**
         * Sets the line points of the line annotation.
         *
         * @param {number[]} value Line points.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the line points of the line annotation.
         * annotation.linePoints = [10, 50, 250, 50];
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (Array.isArray(value) && (typeof this._linePoints === 'undefined' || _areNotEqual(value, this._linePoints))) {
                if (value.length === 4) {
                    this._dictionary.update('L', value);
                    this._linePoints = value;
                }
                else {
                    throw new Error('Line points length should be 4.');
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLineAnnotation.prototype, "leaderExt", {
        /**
         * Gets the line extension of the line annotation.
         *
         * @returns {number} Leader line extension.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the line extension of the line annotation.
         * let leaderExt: number = annotation.leaderExt;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._leaderExt === 'undefined' && this._dictionary.has('LLE')) {
                var leaderExt = this._dictionary.get('LLE');
                if (typeof leaderExt !== 'undefined') {
                    this._leaderExt = leaderExt;
                }
            }
            return this._leaderExt;
        },
        /**
         * Sets the line extension of the line annotation.
         *
         * @param {number} value Line extension.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the line extension of the line annotation.
         * annotation.leaderExt = 4;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (!Number.isNaN(value)) {
                this._dictionary.update('LLE', value);
                this._leaderExt = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLineAnnotation.prototype, "leaderLine", {
        /**
         * Gets the leader line of the line annotation.
         *
         * @returns {number} Leader line.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the leader line of the line annotation.
         * let leaderLine: number = annotation.leaderLine;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._leaderLine === 'undefined' && this._dictionary.has('LL')) {
                var leaderLine = this._dictionary.get('LL');
                if (typeof leaderLine !== 'undefined') {
                    this._leaderLine = leaderLine;
                }
            }
            return this._leaderLine;
        },
        /**
         * Sets the leader line of the line annotation.
         *
         * @param {number} value Leader line.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the leader line of the line annotation.
         * annotation.leaderLine = 5;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (!Number.isNaN(value) && this.leaderExt !== 0) {
                this._dictionary.update('LL', value);
                this._leaderLine = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLineAnnotation.prototype, "lineEndingStyle", {
        /**
         * Gets the line ending style of the line annotation.
         *
         * @returns {PdfAnnotationLineEndingStyle} Line ending style.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the line ending style of the line annotation.
         * let lineEndingStyle: PdfAnnotationLineEndingStyle = annotation.lineEndingStyle;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._lineEndingStyle === 'undefined') {
                var value = new PdfAnnotationLineEndingStyle();
                value._dictionary = this._dictionary;
                if (this._dictionary.has('LE')) {
                    var lineStyles = this._dictionary.getArray('LE');
                    if (lineStyles && Array.isArray(lineStyles)) {
                        value._begin = _mapLineEndingStyle(lineStyles[0].name);
                        value._end = _mapLineEndingStyle(lineStyles[1].name);
                    }
                }
                this._lineEndingStyle = value;
            }
            return this._lineEndingStyle;
        },
        /**
         * Sets the line ending style of the line annotation.
         *
         * @param {PdfAnnotationLineEndingStyle} value Line ending style.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the line ending style of the line annotation.
         * annotation.lineEndingStyle = new PdfAnnotationLineEndingStyle(PdfLineEndingStyle.openArrow, PdfLineEndingStyle.closeArrow);
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            var style = this.lineEndingStyle;
            if (style.begin !== value.begin || style.end !== value.end) {
                style.begin = value.begin;
                style.end = value.end;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLineAnnotation.prototype, "leaderOffset", {
        /**
         * Gets the leader offset of the line annotation.
         *
         * @returns {number} Leader offset.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the leader offset value of the line annotation
         * let leaderOffset: number = annotation.leaderOffset;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._leaderOffset === 'undefined' && this._dictionary.has('LLO')) {
                var leaderOffset = this._dictionary.get('LLO');
                if (typeof leaderOffset !== 'undefined' && leaderOffset >= 0) {
                    this._leaderOffset = leaderOffset;
                }
            }
            return this._leaderOffset;
        },
        /**
         * Sets the leader offset of the line annotation.
         *
         * @param {number} value Leader line offset.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the leader offset of the line annotation.
         * annotation.leaderOffset = 1;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (!Number.isNaN(value)) {
                this._dictionary.update('LLO', value);
                this._leaderOffset = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLineAnnotation.prototype, "lineIntent", {
        /**
         * Gets the line intent of the line annotation.
         *
         * @returns {PdfLineIntent} Line intent.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the line intent value of the line annotation
         * let lineIntent: PdfLineIntent = annotation.lineIntent;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._lineIntent === 'undefined' && this._dictionary.has('IT')) {
                var lineIntent = this._dictionary.get('IT');
                if (lineIntent) {
                    this._lineIntent = lineIntent.name === 'LineDimension' ? PdfLineIntent.lineDimension : PdfLineIntent.lineArrow;
                }
            }
            return this._lineIntent;
        },
        /**
         * Sets the line intent of the line annotation.
         *
         * @param {PdfLineIntent} value Line intent.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the line intent of the line annotation.
         * annotation.lineIntent = PdfLineIntent.lineDimension;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined' && value !== this.lineIntent) {
                this._lineIntent = value;
                this._dictionary.update('IT', _PdfName.get(value === PdfLineIntent.lineDimension ? 'LineDimension' : 'LineArrow'));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLineAnnotation.prototype, "measure", {
        /**
         * Gets the flag to have measurement dictionary of the line annotation.
         *
         * @returns {boolean} measure.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the flag to have measurement dictionary of the line annotation.
         * let measure: boolean = annotation.measure;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._measure === 'undefined') {
                this._measure = this._dictionary.has('Measure');
            }
            return this._measure;
        },
        /**
         * Sets the flag to add measurement dictionary to the line annotation.
         *
         * @param {boolean} value Measure.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the flag to have measurement dictionary of the line annotation.
         * annotation.measure = true;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                if (!this._isLoaded) {
                    this._measure = value;
                    this.caption.cap = true;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLineAnnotation.prototype, "unit", {
        /**
         * Gets the measurement unit of the annotation.
         *
         * @returns {PdfMeasurementUnit} Measurement unit.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the measurement unit of the annotation.
         * let unit: PdfMeasurementUnit = annotation.unit;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._unit === 'undefined' || this._isLoaded) {
                this._unit = PdfMeasurementUnit.centimeter;
                if (this._dictionary.has('Contents')) {
                    var text = this._dictionary.get('Contents');
                    this._unitString = text.substring(text.length - 2);
                    this._unit = _mapMeasurementUnit(this._unitString);
                }
            }
            return this._unit;
        },
        /**
         * Sets the measurement unit of the line annotation.
         *
         * @param {PdfMeasurementUnit} value Measurement unit.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the measurement unit of the annotation.
         * annotation.unit = PdfMeasurementUnit.centimeter;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._measure) {
                if (!this._isLoaded && typeof value !== 'undefined') {
                    this._unit = value;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfLineAnnotation._load = function (page, dictionary) {
        var annot = new PdfLineAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfLineAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfLineAnnotation.prototype._postProcess = function (flatten) {
        if (typeof this.linePoints === 'undefined' || this.linePoints === null) {
            throw new Error('Line points cannot be null or undefined');
        }
        else {
            var cropOrMediaBox = this._getCropOrMediaBox();
            if (cropOrMediaBox && cropOrMediaBox.length > 3 && this.linePoints.length > 3 && typeof cropOrMediaBox[0] === 'number' && typeof cropOrMediaBox[1] === 'number' && (cropOrMediaBox[0] !== 0 || cropOrMediaBox[1] !== 0)) {
                this._linePoints[0] += cropOrMediaBox[0];
                this._linePoints[1] += cropOrMediaBox[1];
                this._linePoints[2] += cropOrMediaBox[0];
                this._linePoints[3] += cropOrMediaBox[1];
                this._dictionary.update('L', this._linePoints);
            }
        }
        if (!this._dictionary.has('Cap')) {
            this._dictionary.set('Cap', false);
        }
        if (!this._dictionary.has('CP')) {
            this._dictionary.set('CP', _PdfName.get('Inline'));
        }
        if (!this._dictionary.has('LE')) {
            this.lineEndingStyle = new PdfAnnotationLineEndingStyle();
        }
        if (!this._dictionary.has('LL')) {
            this.leaderLine = 0;
        }
        if (!this._dictionary.has('LLE')) {
            this.leaderExt = 0;
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
            this._isTransparentColor = true;
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (this.border.dash === null || typeof this.border.dash === 'undefined') {
            this.border.dash = [];
            if (this.border.style === PdfBorderStyle.dashed) {
                this.border.dash = [3, 1];
            }
            else if (this.border.style === PdfBorderStyle.dot) {
                this.border.dash = [1, 1];
            }
        }
        if (this._measure) {
            this._appearanceTemplate = this._createLineMeasureAppearance(flatten);
        }
        else {
            var isUpdated = false;
            if (this._setAppearance) {
                this._appearanceTemplate = this._createAppearance();
                if (this._page._isNew && !(this._flatten || flatten)) {
                    var boundsArray = this._obtainLineBounds();
                    var bounds = {
                        x: boundsArray[0],
                        y: boundsArray[1], width: boundsArray[2], height: boundsArray[3]
                    };
                    this._bounds = bounds;
                    var updatedBounds = [this._bounds.x,
                        this._bounds.y,
                        this._bounds.x + this._bounds.width,
                        this._bounds.y + this._bounds.height];
                    this._dictionary.update('Rect', updatedBounds);
                    isUpdated = true;
                }
            }
            else {
                var bounds = this._obtainLineBounds();
                var rectangleBounds = _fromRectangle({ x: bounds[0], y: bounds[1], width: bounds[2], height: bounds[3] });
                if (this._page._isNew && this._page._pageSettings && this._setAppearance && !this.flatten) {
                    rectangleBounds = _updateBounds(this, bounds);
                }
                this.bounds = { x: rectangleBounds[0], y: rectangleBounds[1], width: rectangleBounds[2], height: rectangleBounds[3] };
                this._dictionary.update('Rect', rectangleBounds);
                isUpdated = true;
            }
            if (this._dictionary.has('Measure') && !isUpdated) {
                var boundsArray = this._obtainLineBounds();
                var bounds = { x: boundsArray[0],
                    y: boundsArray[1], width: boundsArray[2], height: boundsArray[3] };
                this._bounds = bounds;
                var updatedBounds = void 0;
                if (this._page && this._page._isNew && this._page._pageSettings && !this._setAppearance && !this.flatten) {
                    updatedBounds = _updateBounds(this);
                }
                else {
                    updatedBounds = [this._bounds.x,
                        this._bounds.y,
                        this._bounds.x + this._bounds.width,
                        this._bounds.y + this._bounds.height];
                }
                this._dictionary.update('Rect', updatedBounds);
                if (this.flatten && !this.measure && this._page && this._page.size && Array.isArray(this._page.size) &&
                    this._page.size.length >= 2) {
                    this._bounds = { x: boundsArray[0], y: this._page.size[1] - (boundsArray[1] + boundsArray[3]),
                        width: boundsArray[2], height: boundsArray[3] };
                }
            }
        }
    };
    PdfLineAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                if (this._dictionary.has('Measure')) {
                    this._appearanceTemplate = this._createLineMeasureAppearance(isFlatten);
                }
                else {
                    this._appearanceTemplate = this._createAppearance();
                }
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    var appearanceStream = dictionary.get('N');
                    if (appearanceStream) {
                        var reference = dictionary.getRaw('N');
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate) {
                if (isFlatten) {
                    if (!this._dictionary.has('AP')) {
                        this._appearanceTemplate = this._createAppearance();
                    }
                    else {
                        var dictionary = this._dictionary.get('AP');
                        if (dictionary !== null && typeof dictionary !== 'undefined' && dictionary.has('N')) {
                            var appearanceStream = dictionary.get('N');
                            if (appearanceStream) {
                                var reference = dictionary.getRaw('N');
                                if (reference) {
                                    appearanceStream.reference = reference;
                                }
                                this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                            }
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups && isFlatten) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
        }
        else if (isFlatten) {
            this._page.annotations.remove(this);
        }
        var appearance;
        if (!isFlatten && this._setAppearance && !this.measure) {
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                var reference = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference, appearance);
                this._dictionary.update('AP', reference);
            }
        }
        else if (this.measure && this._setAppearance && !this._dictionary.has('AP')) {
            var reference = this._crossReference._getNextReference();
            appearance = new _PdfDictionary(this._crossReference);
            this._crossReference._cacheMap.set(reference, appearance);
            this._dictionary.update('AP', reference);
        }
        if (appearance && this._appearanceTemplate && this._appearanceTemplate._content) {
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    };
    PdfLineAnnotation.prototype._createLineMeasureAppearance = function (_isFlatten) {
        var nativeRectangle = [0, 0, 0, 0];
        var area = this._convertToUnit();
        var linePoints1 = this._obtainLinePoints();
        var points = [];
        for (var j = 0; j < linePoints1.length; j = j + 2) {
            points.push([linePoints1[Number.parseInt(j.toString(), 10)], (linePoints1[j + 1])]);
        }
        var graphicsPath = new PdfPath();
        graphicsPath._points = points;
        graphicsPath._pathTypes = [0, 1];
        var rectPath = graphicsPath._getBounds();
        this._bounds = { x: rectPath[0], y: rectPath[1], width: rectPath[2], height: rectPath[3] };
        var borderPen = new PdfPen(typeof this.color !== 'undefined' ? this._color : [0, 0, 0], this.border.width);
        var backBrush;
        if (this.innerColor) {
            backBrush = new PdfBrush(this._innerColor);
        }
        nativeRectangle = this._obtainLineBounds();
        var template = new PdfTemplate(nativeRectangle, this._crossReference);
        _setMatrix(template, 0);
        var parameter = new _PaintParameter();
        template._writeTransformation = false;
        var graphics = template.graphics;
        parameter.borderPen = borderPen;
        if (this.border.style === PdfBorderStyle.dashed) {
            parameter.borderPen._dashStyle = PdfDashStyle.dash;
            parameter.borderPen._dashPattern = [3, 1];
        }
        else if (this.border.style === PdfBorderStyle.dot) {
            parameter.borderPen._dashStyle = PdfDashStyle.dot;
            parameter.borderPen._dashPattern = [1, 1];
        }
        parameter.backBrush = backBrush;
        parameter.foreBrush = new PdfBrush(this.color);
        var linePoints = this._obtainLinePoints();
        var font = this._obtainFont();
        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {
            font = this._lineCaptionFont;
            this._pdfFont = font;
        }
        if (typeof linePoints !== 'undefined' && linePoints.length === 4) {
            var format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
            var fontSize = font.measureString(area.toFixed(2) + ' ' + this._unitString, [0, 0], format, 0, 0);
            var angle = this._getAngle(this._linePoints);
            var leaderLine = 0;
            var lineAngle = 0;
            if (this.leaderLine < 0) {
                leaderLine = -(this.leaderLine);
                lineAngle = angle + 180;
            }
            else {
                leaderLine = this.leaderLine;
                lineAngle = angle;
            }
            var offset = (typeof this.leaderOffset !== 'undefined') ? (leaderLine + this.leaderOffset) : leaderLine;
            var startPoint = this._getAxisValue([this._linePoints[0], this._linePoints[1]], (lineAngle + 90), offset);
            var endPoint = this._getAxisValue([this._linePoints[2], this._linePoints[3]], (lineAngle + 90), offset);
            var lineDistance = (Math.sqrt(Math.pow((endPoint[0] - startPoint[0]), 2) +
                Math.pow((endPoint[1] - startPoint[1]), 2)));
            var centerWidth = lineDistance / 2 - ((fontSize[0] / 2) + this.border.width);
            var first = this._getAxisValue(startPoint, angle, centerWidth);
            var second = this._getAxisValue(endPoint, (angle + 180), centerWidth);
            var start = (this.lineEndingStyle.begin === PdfLineEndingStyle.openArrow ||
                this.lineEndingStyle.begin === PdfLineEndingStyle.closedArrow) ?
                this._getAxisValue(startPoint, angle, this.border.width) :
                startPoint;
            var end = (this.lineEndingStyle.end === PdfLineEndingStyle.openArrow ||
                this.lineEndingStyle.end === PdfLineEndingStyle.closedArrow) ?
                this._getAxisValue(endPoint, angle, -this.border.width) :
                endPoint;
            var state = void 0;
            if (this.opacity && this._opacity < 1) {
                state = graphics.save();
                graphics.setTransparency(this._opacity);
            }
            if (this.caption.type === PdfLineCaptionType.top || (!this.caption.cap && this.caption.type === PdfLineCaptionType.inline)) {
                graphics.drawLine(borderPen, start[0], -start[1], end[0], -end[1]);
            }
            else {
                graphics.drawLine(borderPen, start[0], -start[1], first[0], -first[1]);
                graphics.drawLine(borderPen, end[0], -end[1], second[0], -second[1]);
            }
            if (this.opacity && this._opacity < 1) {
                graphics.restore(state);
            }
            this._drawLineStyle(startPoint, endPoint, graphics, angle, borderPen, backBrush, this.lineEndingStyle, this.border.width);
            var leaderExt = (typeof this.leaderExt !== 'undefined' ? this._leaderExt : 0);
            var beginLineExt = this._getAxisValue(startPoint, (lineAngle + 90), leaderExt);
            graphics.drawLine(borderPen, startPoint[0], -startPoint[1], beginLineExt[0], -beginLineExt[1]);
            var endLineExt = this._getAxisValue(endPoint, (lineAngle + 90), leaderExt);
            graphics.drawLine(borderPen, endPoint[0], -endPoint[1], endLineExt[0], -endLineExt[1]);
            var beginLeaderLine = this._getAxisValue(startPoint, (lineAngle - 90), leaderLine);
            graphics.drawLine(borderPen, startPoint[0], -startPoint[1], beginLeaderLine[0], -beginLeaderLine[1]);
            var endLeaderLine = this._getAxisValue(endPoint, (lineAngle - 90), leaderLine);
            graphics.drawLine(borderPen, endPoint[0], -endPoint[1], endLeaderLine[0], -endLeaderLine[1]);
            var midpoint = lineDistance / 2;
            var centerPoint = this._getAxisValue(startPoint, angle, midpoint);
            var captionPosition = void 0;
            var height = font._metrics._getHeight();
            if (this.caption.type === PdfLineCaptionType.top) {
                captionPosition = this._getAxisValue(centerPoint, (angle + 90), height);
            }
            else {
                captionPosition = this._getAxisValue(centerPoint, (angle + 90), (height / 2));
            }
            graphics.translateTransform(captionPosition[0], -captionPosition[1]);
            graphics.rotateTransform(-angle);
            graphics.drawString(area.toFixed(2) + ' ' + this._unitString, font, [(-fontSize[0] / 2), 0, 0, 0], null, parameter.foreBrush);
            graphics.restore();
        }
        if ((typeof _isFlatten !== 'undefined' && !_isFlatten) || !this._isLoaded) {
            template._content.dictionary._updated = true;
            var ref = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(ref, template._content);
            template._content.reference = ref;
            var nativeRectangle1 = [this.bounds.x,
                this.bounds.y + this.bounds.height,
                this.bounds.width,
                this.bounds.height];
            var size = this._page.size;
            nativeRectangle1[1] = size[1] - (this.bounds.y + this.bounds.height);
            if (this._isBounds && !this.measure) {
                nativeRectangle = nativeRectangle1;
                this._dictionary.update('Rect', [nativeRectangle1[0], nativeRectangle1[1], nativeRectangle1[2], nativeRectangle1[3]]);
            }
            else {
                this._dictionary.update('Rect', [nativeRectangle[0], nativeRectangle[1], nativeRectangle[2], nativeRectangle[3]]);
            }
            var ds = 'font:' +
                font._metrics._postScriptName +
                ' ' +
                font._size +
                'pt; color:' +
                this._colorToHex(this.color);
            this._dictionary.update('DS', ds);
            if (typeof _isFlatten !== 'undefined' && !_isFlatten) {
                if (this._dictionary.has('AP')) {
                    _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
                }
                var dic = new _PdfDictionary();
                dic.set('N', ref);
                dic._updated = true;
                this._dictionary.set('AP', dic);
                var measureDictionary = this._createMeasureDictionary(this._unitString);
                var reference = this._crossReference._getNextReference();
                this._crossReference._cacheMap.set(reference, measureDictionary);
                measureDictionary._updated = true;
                if (this._dictionary.has('Measure')) {
                    _removeDuplicateReference(this._dictionary, this._crossReference, 'Measure');
                }
                this._dictionary.update('Measure', reference);
            }
            var lineStyles = [];
            lineStyles.push(_PdfName.get(_reverseMapEndingStyle(this.lineEndingStyle.begin)));
            lineStyles.push(_PdfName.get(_reverseMapEndingStyle(this.lineEndingStyle.end)));
            this._dictionary.update('LE', lineStyles);
            if (this._linePoints !== null) {
                this._dictionary.update('L', this._linePoints);
            }
            else {
                throw new Error('LinePoints cannot be null');
            }
            this._dictionary.update('C', [Number.parseFloat((this.color[0] / 255).toFixed(3)),
                Number.parseFloat((this.color[1] / 255).toFixed(3)),
                Number.parseFloat((this.color[2] / 255).toFixed(3))]);
            var offset = this._dictionary.has('LLO') ? this.leaderOffset : 0;
            this._dictionary.update('Subtype', new _PdfName('Line'));
            if (this._text && this._text !== '') {
                this._dictionary.update('Contents', this._text + ' ' + area.toFixed(2) + ' ' + this._unitString);
            }
            else {
                this._dictionary.update('Contents', area.toFixed(2) + ' ' + this._unitString);
            }
            this._dictionary.update('IT', new _PdfName('LineDimension'));
            this._dictionary.update('LLE', this.leaderExt);
            this._dictionary.update('LLO', offset);
            this._dictionary.update('LL', this.leaderLine);
            this._dictionary.update('CP', _PdfName.get(this.caption.type === PdfLineCaptionType.top ? 'Top' : 'Inline'));
            this._dictionary.update('Cap', this.caption.cap);
            var bounds = [nativeRectangle[0],
                nativeRectangle[1],
                nativeRectangle[0] + nativeRectangle[2],
                nativeRectangle[1] + nativeRectangle[3]];
            this._dictionary.update('Rect', bounds);
            this._bounds = { x: bounds[0], y: bounds[1], width: bounds[2], height: bounds[3] };
        }
        return template;
    };
    PdfLineAnnotation.prototype._calculateAngle = function (startPointX, startPointY, endPointX, endPointY) {
        return -(Math.atan2((endPointY - startPointY), (endPointX - startPointX)) * (180 / Math.PI));
    };
    PdfLineAnnotation.prototype._calculateLineBounds = function (linePoints, leaderLineExt, leaderLine, leaderOffset, lineStyle, borderWidth) {
        var bounds = { x: 0, y: 0, width: 0, height: 0 };
        if (linePoints && linePoints.length === 4) {
            var angle = this._getAngle(linePoints);
            var leaderLines = 0;
            var lineAngle = 0;
            if (leaderLine < 0) {
                leaderLines = -(leaderLine);
                lineAngle = angle + 180;
            }
            else {
                leaderLines = leaderLine;
                lineAngle = angle;
            }
            var x1y1 = [linePoints[0], linePoints[1]];
            var x2y2 = [linePoints[2], linePoints[3]];
            if (leaderOffset !== 0) {
                var offsetPoint1 = this._getAxisValue(x1y1, (lineAngle + 90), leaderOffset);
                var offsetPoint2 = this._getAxisValue(x2y2, (lineAngle + 90), leaderOffset);
                linePoints[0] = offsetPoint1[0];
                linePoints[1] = offsetPoint1[1];
                linePoints[2] = offsetPoint2[0];
                linePoints[3] = offsetPoint2[1];
            }
            var startingPoint = this._getAxisValue(x1y1, (lineAngle + 90), leaderLines + leaderOffset);
            var endingPoint = this._getAxisValue(x2y2, (lineAngle + 90), leaderLines + leaderOffset);
            var beginLineLeader = this._getAxisValue(x1y1, (lineAngle + 90), leaderLineExt + leaderLines + leaderOffset);
            var endLineLeader = this._getAxisValue(x2y2, (lineAngle + 90), leaderLineExt + leaderLines + leaderOffset);
            var beginLinePoint = this._getLinePoint(lineStyle.begin, borderWidth);
            var endLinePoint = this._getLinePoint(lineStyle.end, borderWidth);
            var widthX = [];
            var heightY = [];
            if ((lineAngle >= 45 && lineAngle <= 135) || (lineAngle >= 225 && lineAngle <= 315)) {
                widthX[0] = beginLinePoint.y;
                heightY[0] = beginLinePoint.x;
                widthX[1] = endLinePoint.y;
                heightY[1] = endLinePoint.x;
            }
            else {
                widthX[0] = beginLinePoint.x;
                heightY[0] = beginLinePoint.y;
                widthX[1] = endLinePoint.x;
                heightY[1] = endLinePoint.y;
            }
            var width = Math.max(widthX[0], widthX[1]);
            var height = Math.max(heightY[0], heightY[1]);
            if (width === 0) {
                width = 1;
            }
            if (height === 0) {
                height = 1;
            }
            if (startingPoint[0] === Math.min(startingPoint[0], endingPoint[0])) {
                startingPoint[0] -= width * borderWidth;
                endingPoint[0] += width * borderWidth;
                startingPoint[0] = Math.min(startingPoint[0], linePoints[0]);
                startingPoint[0] = Math.min(startingPoint[0], beginLineLeader[0]);
                endingPoint[0] = Math.max(endingPoint[0], linePoints[2]);
                endingPoint[0] = Math.max(endingPoint[0], endLineLeader[0]);
            }
            else {
                startingPoint[0] += width * borderWidth;
                endingPoint[0] -= width * borderWidth;
                startingPoint[0] = Math.max(startingPoint[0], linePoints[0]);
                startingPoint[0] = Math.max(startingPoint[0], beginLineLeader[0]);
                endingPoint[0] = Math.min(endingPoint[0], linePoints[2]);
                endingPoint[0] = Math.min(endingPoint[0], endLineLeader[0]);
            }
            if (startingPoint[1] === Math.min(startingPoint[1], endingPoint[1])) {
                startingPoint[1] -= height * borderWidth;
                endingPoint[1] += height * borderWidth;
                startingPoint[1] = Math.min(startingPoint[1], linePoints[1]);
                startingPoint[1] = Math.min(startingPoint[1], beginLineLeader[1]);
                endingPoint[1] = Math.max(endingPoint[1], linePoints[3]);
                endingPoint[1] = Math.max(endingPoint[1], endLineLeader[1]);
            }
            else {
                startingPoint[1] += height * borderWidth;
                endingPoint[1] -= height * borderWidth;
                startingPoint[1] = Math.max(startingPoint[1], linePoints[1]);
                startingPoint[1] = Math.max(startingPoint[1], beginLineLeader[1]);
                endingPoint[1] = Math.min(endingPoint[1], linePoints[3]);
                endingPoint[1] = Math.min(endingPoint[1], endLineLeader[1]);
            }
            bounds = this._getBounds([{ x: startingPoint[0], y: startingPoint[1] }, { x: endingPoint[0], y: endingPoint[1] }]);
        }
        return bounds;
    };
    PdfLineAnnotation.prototype._getLinePoint = function (style, borderWidth) {
        var point = { x: 0, y: 0 };
        if (style) {
            switch (style) {
                case PdfLineEndingStyle.square:
                case PdfLineEndingStyle.circle:
                case PdfLineEndingStyle.diamond:
                    point.x = 3;
                    point.y = 3;
                    break;
                case PdfLineEndingStyle.openArrow:
                case PdfLineEndingStyle.closedArrow:
                    point.x = 1;
                    point.y = 5;
                    break;
                case PdfLineEndingStyle.rOpenArrow:
                case PdfLineEndingStyle.rClosedArrow:
                    point.x = 9 + (borderWidth / 2);
                    point.y = 5 + (borderWidth / 2);
                    break;
                case PdfLineEndingStyle.slash:
                    point.x = 5;
                    point.y = 9;
                    break;
                case PdfLineEndingStyle.butt:
                    point.x = 1;
                    point.y = 3;
                    break;
                default:
                    point.x = 0;
                    point.y = 0;
                    break;
            }
        }
        return point;
    };
    PdfLineAnnotation.prototype._getBounds = function (points) {
        var bounds = { x: 0, y: 0, width: 0, height: 0 };
        if (points.length > 0) {
            var xmin = points[0].x;
            var xmax = points[0].x;
            var ymin = points[0].y;
            var ymax = points[0].y;
            for (var i = 1; i < points.length; ++i) {
                var point = points[Number.parseInt(i.toString(), 10)];
                xmin = Math.min(point.x, xmin);
                xmax = Math.max(point.x, xmax);
                ymin = Math.min(point.y, ymin);
                ymax = Math.max(point.y, ymax);
            }
            bounds.x = xmin;
            bounds.y = ymin;
            bounds.width = xmax - xmin;
            bounds.height = ymax - ymin;
        }
        return bounds;
    };
    PdfLineAnnotation.prototype._obtainLineBounds = function () {
        var bounds = this.bounds;
        if (typeof this.linePoints !== 'undefined' && this._linePoints.length === 4) {
            var leaderOffset = this._dictionary.has('LLO') ? this.leaderOffset : 0;
            var leaderExt = this._dictionary.has('LLE') ? this.leaderExt : 0;
            var leaderLine = this._dictionary.has('LL') ? this.leaderLine : 0;
            bounds = this._calculateLineBounds(this._linePoints, leaderExt, leaderLine, leaderOffset, this.lineEndingStyle, this.border.width);
            bounds = { x: bounds.x - 8, y: bounds.y - 8, width: (bounds.width + 2 * 8), height: (bounds.height + 2 * 8) };
        }
        return [bounds.x, bounds.y, bounds.width, bounds.height];
    };
    PdfLineAnnotation.prototype._createAppearance = function () {
        var template = new PdfTemplate(this._obtainLineBounds(), this._crossReference);
        var parameter = new _PaintParameter();
        _setMatrix(template, 0);
        template._writeTransformation = false;
        var graphics = template.graphics;
        var pen = new PdfPen(typeof this.color !== 'undefined' ? this._color : [0, 0, 0], this.border.width);
        if (this.border.style === PdfBorderStyle.dashed) {
            pen._dashStyle = PdfDashStyle.dash;
            pen._dashPattern = [3, 1];
        }
        else if (this.border.style === PdfBorderStyle.dot) {
            pen._dashStyle = PdfDashStyle.dot;
            pen._dashPattern = [1, 1];
        }
        parameter.borderPen = pen;
        parameter.foreBrush = new PdfBrush(this.color);
        var brush;
        if (this.innerColor) {
            brush = new PdfBrush(this._innerColor);
        }
        var font = this._obtainFont();
        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {
            font = this._lineCaptionFont;
            this._pdfFont = font;
        }
        if (!this.text && !this._dictionary.has('Contents')) {
            this.text = this.subject;
        }
        var format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
        var lineWidth = 0;
        if (this.caption.cap) {
            lineWidth = font.measureString(this.text ? this.text : '', [0, 0], format, 0, 0)[0]; //66.71001;
        }
        if (typeof this.linePoints !== 'undefined' && this._linePoints.length === 4) {
            var angle = this._getAngle(this._linePoints);
            var leaderLine = 0;
            var lineAngle = 0;
            var leaderLineValue = this.leaderLine;
            if (leaderLineValue === null || typeof leaderLineValue === 'undefined') {
                this._leaderLine = 0;
                leaderLineValue = 0;
            }
            if (leaderLineValue < 0) {
                leaderLine = -(leaderLineValue);
                lineAngle = angle + 180;
            }
            else {
                leaderLine = leaderLineValue;
                lineAngle = angle;
            }
            var offset = (typeof this.leaderOffset !== 'undefined') ? (leaderLine + this.leaderOffset) : leaderLine;
            var startPoint = this._getAxisValue([this._linePoints[0], this._linePoints[1]], (lineAngle + 90), offset);
            var endPoint = this._getAxisValue([this._linePoints[2], this._linePoints[3]], (lineAngle + 90), offset);
            var lineDistance = (Math.sqrt(Math.pow((endPoint[0] - startPoint[0]), 2) +
                Math.pow((endPoint[1] - startPoint[1]), 2)));
            var centerWidth = lineDistance / 2 - ((lineWidth / 2) + this.border.width);
            var first = this._getAxisValue(startPoint, angle, centerWidth);
            var second = this._getAxisValue(endPoint, (angle + 180), centerWidth);
            var start = (this.lineEndingStyle.begin === PdfLineEndingStyle.openArrow ||
                this.lineEndingStyle.begin === PdfLineEndingStyle.closedArrow) ?
                this._getAxisValue(startPoint, angle, this.border.width) :
                startPoint;
            var end = (this.lineEndingStyle.end === PdfLineEndingStyle.openArrow ||
                this.lineEndingStyle.end === PdfLineEndingStyle.closedArrow) ?
                this._getAxisValue(endPoint, angle, -this.border.width) :
                endPoint;
            if (this.opacity && this._opacity < 1) {
                var state = graphics.save();
                graphics.setTransparency(this._opacity);
                this._drawLine(graphics, pen, start, end, first, second);
                graphics.restore(state);
            }
            else {
                this._drawLine(graphics, pen, start, end, first, second);
            }
            this._drawLineStyle(startPoint, endPoint, graphics, angle, pen, brush, this.lineEndingStyle, this.border.width);
            var leaderExt = (typeof this.leaderExt !== 'undefined' ? this._leaderExt : 0);
            var beginLineExt = this._getAxisValue(startPoint, (lineAngle + 90), leaderExt);
            graphics.drawLine(pen, startPoint[0], -startPoint[1], beginLineExt[0], -beginLineExt[1]);
            var endLineExt = this._getAxisValue(endPoint, (lineAngle + 90), leaderExt);
            graphics.drawLine(pen, endPoint[0], -endPoint[1], endLineExt[0], -endLineExt[1]);
            var beginLeaderLine = this._getAxisValue(startPoint, (lineAngle - 90), leaderLine);
            graphics.drawLine(pen, startPoint[0], -startPoint[1], beginLeaderLine[0], -beginLeaderLine[1]);
            var endLeaderLine = this._getAxisValue(endPoint, (lineAngle - 90), leaderLine);
            graphics.drawLine(pen, endPoint[0], -endPoint[1], endLeaderLine[0], -endLeaderLine[1]);
            var midpoint = lineDistance / 2;
            var centerPoint = this._getAxisValue(startPoint, angle, midpoint);
            var captionPosition = void 0;
            var height = font._metrics._getHeight();
            if (this.caption.type === PdfLineCaptionType.top) {
                if (this._measure) {
                    captionPosition = this._getAxisValue(centerPoint, (angle + 90), 2 * height);
                }
                else {
                    captionPosition = this._getAxisValue(centerPoint, (angle + 90), height);
                }
            }
            else {
                if (this._measure) {
                    captionPosition = this._getAxisValue(centerPoint, (angle + 90), 3 * (height / 2));
                }
                else {
                    captionPosition = this._getAxisValue(centerPoint, (angle + 90), (height / 2));
                }
            }
            graphics.translateTransform(captionPosition[0], -captionPosition[1]);
            graphics.rotateTransform(-angle);
            if (this.caption.cap) {
                graphics.drawString(this.text, font, [(-lineWidth / 2), 0, 0, 0], null, parameter.foreBrush);
            }
            graphics.restore();
            var bounds = this._obtainLineBounds();
            var rectangleBounds = _fromRectangle({ x: bounds[0], y: bounds[1], width: bounds[2], height: bounds[3] });
            this.bounds = { x: rectangleBounds[0], y: rectangleBounds[1], width: rectangleBounds[2], height: rectangleBounds[3] };
            if ((!this.measure) && (!this._dictionary.has('Measure'))) {
                this._dictionary.update('Rect', [rectangleBounds[0], rectangleBounds[1], rectangleBounds[2], rectangleBounds[3]]);
            }
        }
        return template;
    };
    PdfLineAnnotation.prototype._drawLine = function (graphics, pen, start, end, first, second) {
        if (typeof this.text === 'undefined' ||
            this._text === '' ||
            this.caption.type === PdfLineCaptionType.top ||
            (!this.caption.cap && this.caption.type === PdfLineCaptionType.inline)) {
            graphics.drawLine(pen, start[0], -start[1], end[0], -end[1]);
        }
        else {
            graphics.drawLine(pen, start[0], -start[1], first[0], -first[1]);
            graphics.drawLine(pen, end[0], -end[1], second[0], -second[1]);
        }
    };
    PdfLineAnnotation.prototype._convertToUnit = function () {
        var points = this._obtainLinePoints();
        var data = new Array(points.length / 2);
        var count = 0;
        for (var j = 0; j < points.length; j = j + 2) {
            data[Number.parseInt(count.toString(), 10)] = [points[Number.parseInt(j.toString(), 10)], (points[j + 1])];
            count++;
        }
        var distance = Math.sqrt(Math.pow((data[1][0] - data[0][0]), 2) + Math.pow((data[1][1] - data[0][1]), 2));
        var value = this._getEqualPdfGraphicsUnit(this.unit, this._unitString);
        this._unitString = value.unitString;
        return (new _PdfUnitConvertor())._convertUnits(distance, _PdfGraphicsUnit.point, value.graphicsUnit);
    };
    PdfLineAnnotation.prototype._obtainLinePoints = function () {
        var points = [];
        if (this.linePoints) {
            for (var i = 0; i < this._linePoints.length; i++) {
                points[Number.parseInt(i.toString(), 10)] = this._linePoints[Number.parseInt(i.toString(), 10)];
            }
        }
        return points;
    };
    return PdfLineAnnotation;
}(PdfComment));
/**
 * `PdfCircleAnnotation` class represents the circle annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new circle annotation with circle bounds
 * const annotation: PdfCircleAnnotation = new PdfCircleAnnotation(10, 10, 100, 100);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfCircleAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfCircleAnnotation, _super);
    function PdfCircleAnnotation(x, y, width, height) {
        var _this = _super.call(this) || this;
        _this._unit = PdfMeasurementUnit.centimeter;
        _this._measureType = PdfCircleMeasurementType.diameter;
        _this._unitString = '';
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('Circle'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            _this.bounds = { x: x, y: y, width: width, height: height };
        }
        _this._type = _PdfAnnotationType.circleAnnotation;
        return _this;
    }
    Object.defineProperty(PdfCircleAnnotation.prototype, "measure", {
        /**
         * Gets the flag to have measurement dictionary of the circle annotation.
         *
         * @returns {boolean} measure.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;
         * // Gets the flag to have measurement dictionary of the circle annotation.
         * let measure: boolean = annotation.measure;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._measure === 'undefined' && this._dictionary.has('Measure')) {
                this._measure = this._dictionary.get('Measure');
            }
            return this._measure;
        },
        /**
         * Sets the flag to add measurement dictionary to the annotation.
         *
         * @param {boolean} value Measure.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;
         * // Sets the flag to have measurement dictionary of the circle annotation.
         * annotation.measure = true;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                if (!this._isLoaded) {
                    this._measure = value;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfCircleAnnotation.prototype, "unit", {
        /**
         * Gets the measurement unit of the annotation.
         *
         * @returns {PdfMeasurementUnit} Measurement unit.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;
         * // Gets the measurement unit of the annotation.
         * let unit: PdfMeasurementUnit = annotation.unit;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._unit === 'undefined' || this._isLoaded) {
                this._unit = PdfMeasurementUnit.centimeter;
                if (this._dictionary.has('Contents')) {
                    var text = this._dictionary.get('Contents');
                    this._unitString = text.substring(text.length - 2);
                    this._unit = _mapMeasurementUnit(this._unitString);
                }
            }
            return this._unit;
        },
        /**
         * Sets the measurement unit of the annotation.
         *
         * @param {PdfMeasurementUnit} value Measurement unit.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;
         * // Sets the measurement unit of the annotation.
         * annotation.unit = PdfMeasurementUnit.centimeter;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._measure) {
                if (!this._isLoaded && typeof value !== 'undefined') {
                    this._unit = value;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfCircleAnnotation.prototype, "measureType", {
        /**
         * Gets the measurement type of the annotation.
         *
         * @returns {PdfCircleMeasurementType} Measurement type.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;
         * // Gets the measurement type of the annotation.
         * let type: PdfCircleMeasurementType = annotation.type;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary.has('Contents')) {
                var text = this._dictionary.get('Contents');
                this._unitString = text.substring(text.length - 2);
                this._unit = _mapMeasurementUnit(this._unitString);
                var value = text.substring(0, text.length - 2);
                var converter = new _PdfUnitConvertor();
                var radius = converter._convertUnits(this.bounds.width / 2, _PdfGraphicsUnit.point, _mapGraphicsUnit(this._unitString));
                if (radius.toString() === value) {
                    this._measureType = PdfCircleMeasurementType.radius;
                }
                else {
                    this._measureType = PdfCircleMeasurementType.diameter;
                }
            }
            return this._measureType;
        },
        /**
         * Sets the measurement type of the annotation.
         *
         * @param {PdfCircleMeasurementType} value Measurement type.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;
         * // Sets the measurement type of the annotation.
         * annotation.type = PdfCircleMeasurementType.diameter;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._measure) {
                if (!this._isLoaded && typeof value !== 'undefined') {
                    this._measureType = value;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfCircleAnnotation._load = function (page, dictionary) {
        var annot = new PdfCircleAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfCircleAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfCircleAnnotation.prototype._postProcess = function (isFlatten) {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
            this._isTransparentColor = true;
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (this._measure) {
            this._appearanceTemplate = this._createCircleMeasureAppearance(isFlatten);
        }
        else {
            this._dictionary.update('Rect', _updateBounds(this));
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createCircleAppearance();
            }
        }
    };
    PdfCircleAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                if (this._dictionary.has('Measure')) {
                    this._appearanceTemplate = this._createCircleMeasureAppearance(isFlatten);
                }
                else {
                    this._appearanceTemplate = this._createCircleAppearance();
                }
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    var appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate && isFlatten) {
                if (!this._dictionary.has('AP')) {
                    this._appearanceTemplate = this._createCircleAppearance();
                }
                else {
                    var dictionary = this._dictionary.get('AP');
                    if (dictionary !== null && typeof dictionary !== 'undefined' && dictionary.has('N')) {
                        var appearanceStream = dictionary.get('N');
                        var reference = dictionary.getRaw('N');
                        if (appearanceStream) {
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups && isFlatten) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
        }
        else if (isFlatten) {
            this._page.annotations.remove(this);
        }
        if (!isFlatten && this._setAppearance && !this.measure) {
            var appearance = void 0;
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                var reference_1 = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference_1, appearance);
                this._dictionary.update('AP', reference_1);
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    };
    PdfCircleAnnotation.prototype._createCircleMeasureAppearance = function (_isFlatten) {
        var borderWidth = this.border.width;
        var font = this._obtainFont();
        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {
            font = this._circleCaptionFont;
            this._pdfFont = font;
        }
        var area = this._convertToUnit();
        var format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
        var str = area.toFixed(2) + ' ' + this._unitString;
        var fontsize = font.measureString(str, [0, 0], format, 0, 0);
        var color = this.color ? this.color : [0, 0, 0];
        var borderPen = new PdfPen(color, borderWidth);
        var nativeRectangle = [this.bounds.x,
            (this.bounds.y + this.bounds.height),
            this.bounds.width,
            this.bounds.height];
        nativeRectangle[1] = nativeRectangle[1] - nativeRectangle[3];
        var template = new PdfTemplate(nativeRectangle, this._crossReference);
        var parameter = new _PaintParameter();
        template._writeTransformation = false;
        var graphics = template.graphics;
        var width = borderWidth / 2;
        parameter.borderPen = borderPen;
        if (this.innerColor) {
            parameter.backBrush = new PdfBrush(this._innerColor);
        }
        parameter.foreBrush = new PdfBrush(color);
        var rect = [nativeRectangle[0],
            -nativeRectangle[1] - nativeRectangle[3],
            nativeRectangle[2],
            nativeRectangle[3]];
        graphics.save();
        graphics.drawEllipse(rect[0] + width, rect[1] + width, rect[2] - borderWidth, rect[3] - borderWidth, new PdfPen(color, this.border.width));
        if (this._measureType === PdfCircleMeasurementType.diameter) {
            graphics.save();
            graphics.translateTransform(nativeRectangle[0], -nativeRectangle[1]);
            var x = (nativeRectangle[3] / 2) - (fontsize[0] / 2);
            graphics.drawLine(parameter.borderPen, 0, -nativeRectangle[3] / 2, nativeRectangle[0] + nativeRectangle[2], -nativeRectangle[3] / 2);
            graphics.translateTransform(x, -(nativeRectangle[3] / 2) - font._metrics._getHeight());
            graphics.drawString(area.toFixed(2) + ' ' + this._unitString, font, [0, 0, 0, 0], null, parameter.foreBrush);
            graphics.restore();
        }
        else {
            graphics.save();
            graphics.translateTransform(nativeRectangle[0], -nativeRectangle[1]);
            var x = (nativeRectangle[2] / 2) + ((nativeRectangle[2] / 4) - (fontsize[0] / 2));
            graphics.drawLine(parameter.borderPen, nativeRectangle[2] / 2, -nativeRectangle[3] / 2, nativeRectangle[0] + nativeRectangle[2], -nativeRectangle[3] / 2);
            graphics.translateTransform(x, -(nativeRectangle[3] / 2) - font._metrics._getHeight());
            graphics.drawString(area.toFixed(2) + ' ' + this._unitString, font, [0, 0, 0, 0], null, parameter.foreBrush);
            graphics.restore();
        }
        graphics.restore();
        if ((typeof _isFlatten !== 'undefined' && !_isFlatten) || !this._isLoaded) {
            if (this._dictionary.has('AP')) {
                _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
            }
            var dic = new _PdfDictionary();
            graphics._template._content.dictionary._updated = true;
            var ref = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(ref, graphics._template._content);
            graphics._template._content.reference = ref;
            dic.set('N', ref);
            dic._updated = true;
            this._dictionary.set('AP', dic);
            this._dictionary.update('Rect', _updateBounds(this));
            if (this._dictionary.has('Measure')) {
                _removeDuplicateReference(this._dictionary, this._crossReference, 'Measure');
            }
            var measureDictionary = this._createMeasureDictionary(this._unitString);
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, measureDictionary);
            measureDictionary._updated = true;
            this._dictionary.update('Measure', reference);
            this._dictionary.update('Subtype', new _PdfName('Circle'));
            if (this._text && this._text !== '') {
                this._dictionary.update('Contents', this._text + ' ' + area.toFixed(2) + ' ' + this._unitString);
            }
            else {
                this._dictionary.update('Contents', area.toFixed(2) + ' ' + this._unitString);
            }
            var ds = 'font:' +
                font._metrics._postScriptName +
                ' ' +
                font._size +
                'pt; color:' +
                this._colorToHex(this.color);
            this._dictionary.update('DS', ds);
        }
        return template;
    };
    PdfCircleAnnotation.prototype._convertToUnit = function () {
        var converter = new _PdfUnitConvertor();
        var value = this._getEqualPdfGraphicsUnit(this.unit, this._unitString);
        this._unitString = value.unitString;
        var radius = converter._convertUnits(this.bounds.width / 2, _PdfGraphicsUnit.point, value.graphicsUnit);
        if (this._measureType === PdfCircleMeasurementType.diameter) {
            radius = 2 * radius;
        }
        return radius;
    };
    return PdfCircleAnnotation;
}(PdfComment));
/**
 * `PdfEllipseAnnotation` class represents the ellipse annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new ellipse annotation with bounds
 * const annotation: PdfEllipseAnnotation = new PdfEllipseAnnotation(10, 10, 100, 100);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfEllipseAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfEllipseAnnotation, _super);
    function PdfEllipseAnnotation(x, y, width, height) {
        var _this = _super.call(this) || this;
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('Circle'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            _this.bounds = { x: x, y: y, width: width, height: height };
        }
        _this._type = _PdfAnnotationType.ellipseAnnotation;
        return _this;
    }
    PdfEllipseAnnotation._load = function (page, dictionary) {
        var annot = new PdfEllipseAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfEllipseAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfEllipseAnnotation.prototype._postProcess = function (isFlatten) {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
            this._isTransparentColor = true;
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
            this._appearanceTemplate = this._createCircleAppearance();
        }
        this._dictionary.update('Rect', _updateBounds(this));
    };
    PdfEllipseAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createCircleAppearance();
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    var appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate && isFlatten) {
                if (!this._dictionary.has('AP')) {
                    this._appearanceTemplate = this._createCircleAppearance();
                }
                else {
                    var dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        var appearanceStream = dictionary.get('N');
                        var reference = dictionary.getRaw('N');
                        if (appearanceStream) {
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
        }
        else if (isFlatten) {
            this._page.annotations.remove(this);
        }
        if (!isFlatten && this._setAppearance) {
            var appearance = void 0;
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                var reference_2 = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference_2, appearance);
                this._dictionary.update('AP', reference_2);
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    };
    return PdfEllipseAnnotation;
}(PdfComment));
/**
 * `PdfSquareAnnotation` class represents the square annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new square annotation with bounds
 * const annotation: PdfSquareAnnotation = new PdfSquareAnnotation(10, 10, 100, 100);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfSquareAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfSquareAnnotation, _super);
    function PdfSquareAnnotation(x, y, width, height) {
        var _this = _super.call(this) || this;
        _this._unit = PdfMeasurementUnit.centimeter;
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('Square'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            _this.bounds = { x: x, y: y, width: width, height: height };
        }
        _this._type = _PdfAnnotationType.squareAnnotation;
        return _this;
    }
    Object.defineProperty(PdfSquareAnnotation.prototype, "borderEffect", {
        /**
         * Gets the border effect of the square annotation.
         *
         * @returns {PdfBorderEffect} Border effect.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
         * // Gets the border effect of the square annotation.
         * let borderEffect : PdfBorderEffect = annotation.borderEffect;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._borderEffect === 'undefined') {
                var value = new PdfBorderEffect();
                value._dictionary = this._dictionary;
                if (this._dictionary.has('BE')) {
                    var dictionary = this._dictionary.get('BE');
                    value._intensity = dictionary.get('I');
                    value._style = _mapBorderEffectStyle(dictionary.get('S').name);
                }
                this._borderEffect = value;
            }
            return this._borderEffect;
        },
        /**
         * Sets the border effect of the square annotation.
         *
         * @param {PdfBorderEffect} value Border effect.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
         * // Sets the border effect of the square annotation.
         * annotation.borderEffect.intensity = 1;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined') {
                this._borderEffect = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfSquareAnnotation.prototype, "measure", {
        /**
         * Gets the flag to have measurement dictionary of the Square annotation.
         *
         * @returns {boolean} measure.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
         * // Gets the flag to have measurement dictionary of the square annotation.
         * let measure: boolean = annotation.measure;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._measure === 'undefined' && this._dictionary.has('Measure')) {
                this._measure = this._dictionary.get('Measure');
            }
            return this._measure;
        },
        /**
         * Sets the flag to add measurement dictionary to the annotation.
         *
         * @param {boolean} value Measure.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
         * // Sets the flag to have measurement dictionary of the square annotation.
         * annotation.measure = true;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined') {
                if (!this._isLoaded) {
                    this._measure = value;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfSquareAnnotation.prototype, "unit", {
        /**
         * Gets the measurement unit of the annotation.
         *
         * @returns {PdfMeasurementUnit} Measurement unit.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
         * // Gets the measurement unit of the annotation.
         * let unit: PdfMeasurementUnit = annotation.unit;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._unit === 'undefined') {
                this._unit = PdfMeasurementUnit.centimeter;
                if (this._dictionary.has('Contents')) {
                    var text = this._dictionary.get('Contents');
                    this._unitString = text.substring(text.length - 2);
                    this._unit = _mapMeasurementUnit(this._unitString);
                }
            }
            return this._unit;
        },
        /**
         * Sets the measurement unit of the annotation.
         *
         * @param {PdfMeasurementUnit} value Measurement unit.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
         * // Sets the measurement unit of the annotation.
         * annotation.unit = PdfMeasurementUnit.centimeter;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._measure) {
                if (!this._isLoaded && typeof value !== 'undefined') {
                    this._unit = value;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfSquareAnnotation._load = function (page, dictionary) {
        var annot = new PdfSquareAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfSquareAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfSquareAnnotation.prototype._postProcess = function (isFlatten) {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
            this._isTransparentColor = true;
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (this._measure) {
            this._appearanceTemplate = this._createSquareMeasureAppearance(isFlatten);
        }
        else {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);
            }
            this._dictionary.update('Rect', _updateBounds(this));
            if (typeof this._intensity === 'undefined' &&
                typeof this._borderEffect !== 'undefined' &&
                this._borderEffect.style === PdfBorderEffectStyle.cloudy) {
                var dictionary = new _PdfDictionary(this._crossReference);
                dictionary.set('I', this.borderEffect._intensity);
                if (this.borderEffect._style === PdfBorderEffectStyle.cloudy) {
                    dictionary.set('S', _PdfName.get('C'));
                }
                this._dictionary.update('BE', dictionary);
            }
        }
    };
    PdfSquareAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                if (this._dictionary.has('Measure')) {
                    this._appearanceTemplate = this._createSquareMeasureAppearance(isFlatten);
                }
                else {
                    this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);
                }
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    var appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate && isFlatten) {
                if (!this._dictionary.has('AP')) {
                    this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);
                }
                else {
                    var dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        var appearanceStream = dictionary.get('N');
                        var reference = dictionary.getRaw('N');
                        if (appearanceStream) {
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups && !this.measure) {
            if (this._isLoaded && !this._dictionary.has('Measure')) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
        }
        else if (isFlatten) {
            this._page.annotations.remove(this);
        }
        if (!isFlatten && this._setAppearance && !this.measure) {
            var appearance = void 0;
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                var reference_3 = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference_3, appearance);
                this._dictionary.update('AP', reference_3);
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    };
    PdfSquareAnnotation.prototype._createSquareMeasureAppearance = function (_isFlatten) {
        var borderWidth = this.border.width;
        var font = this._obtainFont();
        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {
            font = this._circleCaptionFont;
            this._pdfFont = font;
        }
        var area = this._calculateAreaOfSquare();
        var format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
        var str = area.toFixed(2) + ' sq ' + this._unitString;
        var fontsize = font.measureString(str, [0, 0], format, 0, 0);
        var borderPen = new PdfPen(this.color, borderWidth);
        var backBrush;
        if (this.innerColor) {
            backBrush = new PdfBrush(this._innerColor);
        }
        var nativeRectangle = [this.bounds.x,
            (this.bounds.y + this.bounds.height),
            this.bounds.width,
            this.bounds.height];
        var appearanceBounds = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];
        var appearance = new PdfAppearance(this, appearanceBounds);
        nativeRectangle[1] = nativeRectangle[1] - nativeRectangle[3];
        appearance.normal = new PdfTemplate(nativeRectangle, this._crossReference);
        var template = appearance.normal;
        var parameter = new _PaintParameter();
        template._writeTransformation = false;
        var graphics = appearance.normal.graphics;
        var width = borderWidth / 2;
        parameter.borderPen = borderPen;
        parameter.backBrush = backBrush;
        parameter.foreBrush = new PdfBrush(this.color);
        var rect = [nativeRectangle[0],
            -nativeRectangle[1] - nativeRectangle[3],
            nativeRectangle[2],
            nativeRectangle[3]];
        graphics.drawRectangle(rect[0] + width, rect[1] + width, rect[2] - borderWidth, rect[3] - borderWidth, new PdfPen(this.color, this.border.width));
        graphics.save();
        graphics.translateTransform(nativeRectangle[0], -nativeRectangle[1]);
        var x = (nativeRectangle[2] / 2) - (fontsize[0] / 2);
        var y = (nativeRectangle[3] / 2) - (fontsize[1] / 2);
        graphics.translateTransform(x, -y - font._metrics._getHeight());
        graphics.drawString((area.toFixed(2) + ' sq ' + this._unitString), font, [0, 0, 0, 0], null, parameter.foreBrush);
        graphics.restore();
        if ((typeof _isFlatten !== 'undefined' && !_isFlatten) || !this._isLoaded) {
            if (this._dictionary.has('AP')) {
                _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
            }
            var dic = new _PdfDictionary();
            var tem = graphics._template._content;
            tem.dictionary._updated = true;
            var ref = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(ref, tem);
            graphics._template._content.reference = ref;
            dic.set('N', ref);
            dic._updated = true;
            this._dictionary.set('AP', dic);
            var nativeRectangle1 = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];
            var size = this._page.size;
            nativeRectangle1[1] = size[1] - (this.bounds.y + this.bounds.height);
            nativeRectangle1[2] = (this.bounds.x + this.bounds.width);
            nativeRectangle1[3] = size[1] - this.bounds.y;
            if (this._isBounds) {
                nativeRectangle = nativeRectangle1;
            }
            if (this._page._isNew && this._page._pageSettings) {
                nativeRectangle1 = _updateBounds(this);
            }
            this._dictionary.update('Rect', [nativeRectangle1[0], nativeRectangle1[1], nativeRectangle1[2], nativeRectangle1[3]]);
            if (this._dictionary.has('Measure')) {
                _removeDuplicateReference(this._dictionary, this._crossReference, 'Measure');
            }
            var reference = this._crossReference._getNextReference();
            var measureDictionary = this._createMeasureDictionary(this._unitString);
            this._crossReference._cacheMap.set(reference, measureDictionary);
            measureDictionary._updated = true;
            this._dictionary.update('Measure', reference);
            var ds = 'font:' +
                font._metrics._postScriptName +
                ' ' +
                font._size +
                'pt; color:' +
                this._colorToHex(this.color);
            this._dictionary.update('DS', ds);
            if (this._text && this._text !== '') {
                this._dictionary.update('Contents', this._text + ' ' + area.toFixed(2) + ' sq ' + this._unitString);
            }
            else {
                this._dictionary.update('Contents', area.toFixed(2) + ' sq ' + this._unitString);
            }
            this._dictionary.update('Subject', ('Area Measurement'));
            if (typeof this.subject === 'undefined') {
                this._dictionary.update('Subject', ('Area Measurement'));
            }
            this._dictionary.update('MeasurementTypes', 129);
            this._dictionary.update('Subtype', new _PdfName('Square'));
            this._dictionary.update('IT', new _PdfName('SquareDimension'));
            var elements = this._dictionary.getArray('Rect');
            var vertices = new Array(elements.length * 2);
            vertices[0] = elements[0];
            vertices[1] = elements[3];
            vertices[2] = elements[0];
            vertices[3] = elements[1];
            vertices[4] = elements[2];
            vertices[5] = elements[1];
            vertices[6] = elements[2];
            vertices[7] = elements[3];
            this._dictionary.update('Vertices', vertices);
        }
        return template;
    };
    PdfSquareAnnotation.prototype._calculateAreaOfSquare = function () {
        var area;
        var converter = new _PdfUnitConvertor();
        var value;
        if (this.bounds.width === this.bounds.height) {
            value = this._getEqualPdfGraphicsUnit(this.unit, this._unitString);
            this._unitString = value.unitString;
            var width = converter._convertUnits(this.bounds.width, _PdfGraphicsUnit.point, value.graphicsUnit);
            area = width * width;
        }
        else {
            value = this._getEqualPdfGraphicsUnit(this.unit, this._unitString);
            this._unitString = value.unitString;
            var width = converter._convertUnits(this.bounds.width, _PdfGraphicsUnit.point, value.graphicsUnit);
            value = this._getEqualPdfGraphicsUnit(this.unit, this._unitString);
            this._unitString = value.unitString;
            var height = converter._convertUnits(this.bounds.height, _PdfGraphicsUnit.point, value.graphicsUnit);
            area = width * height;
        }
        return area;
    };
    return PdfSquareAnnotation;
}(PdfComment));
/**
 * `PdfRectangleAnnotation` class represents the rectangle annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new square annotation with bounds
 * const annotation: PdfRectangleAnnotation = new PdfRectangleAnnotation(10, 10, 200, 100);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfRectangleAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfRectangleAnnotation, _super);
    function PdfRectangleAnnotation(x, y, width, height) {
        var _this = _super.call(this) || this;
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('Square'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            _this.bounds = { x: x, y: y, width: width, height: height };
        }
        _this._type = _PdfAnnotationType.rectangleAnnotation;
        return _this;
    }
    Object.defineProperty(PdfRectangleAnnotation.prototype, "borderEffect", {
        /**
         * Gets the border effect of the rectangle annotation.
         *
         * @returns {PdfBorderEffect} Border effect.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRectangleAnnotation = page.annotations.at(0) as PdfRectangleAnnotation;
         * // Gets the border effect of the rectangle annotation.
         * let borderEffect: PdfBorderEffect = annotation.borderEffect;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._borderEffect === 'undefined') {
                var value = new PdfBorderEffect();
                value._dictionary = this._dictionary;
                if (this._dictionary.has('BE')) {
                    var dictionary = this._dictionary.get('BE');
                    value._intensity = dictionary.get('I');
                    value._style = _mapBorderEffectStyle(dictionary.get('S').name);
                }
                this._borderEffect = value;
            }
            return this._borderEffect;
        },
        /**
         * Sets the border effect of the rectangle annotation.
         *
         * @param {PdfBorderEffect} value Border effect.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRectangleAnnotation = page.annotations.at(0) as PdfRectangleAnnotation;
         * // Sets the border effect of rectangle annotation.
         * annotation. borderEffect.style = PdfBorderEffectStyle.cloudy;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined') {
                this._borderEffect = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfRectangleAnnotation._load = function (page, dictionary) {
        var annot = new PdfRectangleAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfRectangleAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfRectangleAnnotation.prototype._postProcess = function (isFlatten) {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dic = new _PdfDictionary(this._crossReference);
            dic.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dic);
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
            this._isTransparentColor = true;
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        this._dictionary.update('Rect', _updateBounds(this));
        if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
            this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);
        }
        if (typeof this._intensity === 'undefined' &&
            typeof this._borderEffect !== 'undefined' &&
            this._borderEffect.style === PdfBorderEffectStyle.cloudy) {
            var dic = new _PdfDictionary(this._crossReference);
            dic.set('I', this.borderEffect._intensity);
            if (this.borderEffect._style === PdfBorderEffectStyle.cloudy) {
                dic.set('S', _PdfName.get('C'));
            }
            this._dictionary.update('BE', dic);
        }
    };
    PdfRectangleAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    var appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate && isFlatten) {
                if (!this._dictionary.has('AP')) {
                    this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);
                }
                else {
                    var dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        var appearanceStream = dictionary.get('N');
                        var reference = dictionary.getRaw('N');
                        if (appearanceStream) {
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            if (isNormalMatrix && this._page && this._page.rotation !== PdfRotationAngle.angle0 ||
                this._isValidTemplateMatrix(this._appearanceTemplate._content.dictionary, this.bounds, this._appearanceTemplate)) {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
        }
        else if (isFlatten) {
            this._page.annotations.remove(this);
        }
        if (!isFlatten && this._setAppearance) {
            var appearance = void 0;
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                var reference_4 = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference_4, appearance);
                this._dictionary.update('AP', reference_4);
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    };
    PdfRectangleAnnotation.prototype._isValidTemplateMatrix = function (dictionary, bounds, appearanceTemplate) {
        var isValidMatrix = true;
        var pointF = bounds;
        if (dictionary && dictionary.has('Matrix')) {
            var box = dictionary.getArray('BBox');
            var matrix = dictionary.getArray('Matrix');
            if (matrix && box && matrix.length > 3 && box.length > 2) {
                if (typeof matrix[0] !== 'undefined' &&
                    typeof matrix[1] !== 'undefined' &&
                    typeof matrix[2] !== 'undefined' &&
                    typeof matrix[3] !== 'undefined') {
                    if (matrix[0] === 1 && matrix[1] === 0 && matrix[2] === 0 && matrix[3] === 1) {
                        if (typeof box[0] !== 'undefined' &&
                            typeof box[1] !== 'undefined' &&
                            typeof box[2] !== 'undefined' &&
                            typeof box[3] !== 'undefined') {
                            if (Math.round(box[0]) !== Math.round(-(matrix[4])) && Math.round(box[1]) !== Math.round(-(matrix[5])) ||
                                box[0] === 0 && Math.round(-(matrix[4])) === 0) {
                                var graphics = this._page.graphics;
                                var state = graphics.save();
                                if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                                    graphics.setTransparency(this._opacity);
                                }
                                pointF.x -= box[0];
                                pointF.y += box[1];
                                graphics.drawTemplate(appearanceTemplate, pointF);
                                graphics.restore(state);
                                this._page.annotations.remove(this);
                                isValidMatrix = false;
                            }
                        }
                    }
                }
            }
        }
        return isValidMatrix;
    };
    return PdfRectangleAnnotation;
}(PdfComment));
/**
 * `PdfPolygonAnnotation` class represents the polygon annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new polygon annotation with bounds
 * const annotation: PdfPolygonAnnotation = new PdfPolygonAnnotation([100, 300, 150, 200, 300, 200, 350, 300, 300, 400, 150, 400]);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfPolygonAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfPolygonAnnotation, _super);
    function PdfPolygonAnnotation(points) {
        var _this = _super.call(this) || this;
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('Polygon'));
        if (typeof points !== 'undefined') {
            _this._points = points;
        }
        _this._type = _PdfAnnotationType.polygonAnnotation;
        return _this;
    }
    Object.defineProperty(PdfPolygonAnnotation.prototype, "borderEffect", {
        /**
         * Gets the border effect of the polygon annotation.
         *
         * @returns {PdfBorderEffect} Border effect.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPolygonAnnotation = page.annotations.at(0) as PdfPolygonAnnotation;
         * // Gets the border effect of the polygon annotation.
         * let borderEffect: PdfBorderEffect = annotation.borderEffect;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._borderEffect === 'undefined') {
                var value = new PdfBorderEffect();
                value._dictionary = this._dictionary;
                if (this._dictionary.has('BE')) {
                    var dictionary = this._dictionary.get('BE');
                    value._intensity = dictionary.get('I');
                    value._style = _mapBorderEffectStyle(dictionary.get('S').name);
                }
                this._borderEffect = value;
            }
            return this._borderEffect;
        },
        /**
         * Sets the border effect of the polygon annotation.
         *
         * @param {PdfBorderEffect} value Border effect.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPolygonAnnotation = page.annotations.at(0) as PdfPolygonAnnotation;
         * // Sets the border effect of the polygon annotation
         * annotation.borderEffect.style = PdfBorderEffectStyle.cloudy ;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined') {
                this._borderEffect = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPolygonAnnotation.prototype, "lineExtension", {
        /**
         * Gets the line extension of the polygon annotation.
         *
         * @returns {number} Line extension.
         *  ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPolygonAnnotation = page.annotations.at(0) as PdfPolygonAnnotation;
         * // Gets the line extension of the polygon annotation
         * let lineExtension: number = annotation.lineExtension;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._lineExtension === 'undefined' && this._dictionary.has('LLE')) {
                var lineExt = this._dictionary.get('LLE');
                if (typeof lineExt !== 'undefined' && lineExt >= 0) {
                    this._lineExtension = lineExt;
                }
            }
            return this._lineExtension;
        },
        /**
         * Sets the line extension of the polygon annotation.
         *
         * @param {number} value Line extension.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPolygonAnnotation = page.annotations.at(0) as PdfPolygonAnnotation;
         * // Sets the line extension of the polygon annotation
         * annotation.lineExtension = 5;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (!Number.isNaN(value)) {
                if (value >= 0) {
                    this._dictionary.update('LLE', value);
                    this._lineExtension = value;
                }
                else {
                    throw new Error('LineExtension should be non negative number');
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    //Implementation
    PdfPolygonAnnotation._load = function (page, dictionary) {
        var annot = new PdfPolygonAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfPolygonAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfPolygonAnnotation.prototype._postProcess = function (isFlatten) {
        if (typeof this._points === 'undefined' || this._points === null) {
            throw new Error('Points cannot be null or undefined');
        }
        if (!this._dictionary.has('LLE')) {
            this.lineExtension = 0;
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
            this._isTransparentColor = true;
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dic = new _PdfDictionary(this._crossReference);
            dic.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dic);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        var array = [];
        for (var i = 0; i < this._points.length; i++) {
            var value = this._points[Number.parseInt(i.toString(), 10)];
            array.push(value);
        }
        this._points = this._getPoints(this._points);
        if (array[0] !== array[array.length - 2] || array[1] !== array[array.length - 1]) {
            this._points.push(this._points[0]);
            this._points.push(this._points[1]);
        }
        var polygonBounds = this._getBoundsValue(this._points);
        var bounds = [polygonBounds.x,
            polygonBounds.y,
            polygonBounds.x + polygonBounds.width,
            polygonBounds.y + polygonBounds.height];
        this._dictionary.update('Rect', bounds);
        this._dictionary.update('LLE', this._lineExtension);
        if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
            this._appearanceTemplate = this._createPolygonAppearance(isFlatten);
        }
        this._dictionary.update('Vertices', this._points);
        if (typeof this._intensity === 'undefined' &&
            typeof this._borderEffect !== 'undefined' &&
            this._borderEffect.style === PdfBorderEffectStyle.cloudy) {
            var dic = new _PdfDictionary(this._crossReference);
            dic.set('I', this.borderEffect._intensity);
            if (this.borderEffect._style === PdfBorderEffectStyle.cloudy) {
                dic.set('S', _PdfName.get('C'));
            }
            this._dictionary.update('BE', dic);
        }
    };
    PdfPolygonAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        this._flatten = isFlatten;
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createPolygonAppearance(isFlatten);
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    var appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate && isFlatten) {
                if (this._dictionary.has('AP')) {
                    var dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        var appearanceStream = dictionary.get('N');
                        var reference = dictionary.getRaw('N');
                        if (appearanceStream) {
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
        }
        if (isFlatten) {
            if (this._appearanceTemplate) {
                var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
                if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {
                    var box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                    if (box && box.length >= 2) {
                        this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                    }
                }
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
            else {
                this._page.annotations.remove(this);
            }
        }
        if (!isFlatten && this._setAppearance) {
            var appearance = void 0;
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                var reference_5 = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference_5, appearance);
                this._dictionary.update('AP', reference_5);
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    };
    PdfPolygonAnnotation.prototype._createPolygonAppearance = function (flatten) {
        if (typeof flatten !== 'undefined' && flatten) {
            var borderPen = void 0;
            if (this.color && this.border.width > 0) {
                borderPen = new PdfPen(this.color, this.border.width);
            }
            var backgroundBrush = void 0;
            if (this.innerColor) {
                backgroundBrush = new PdfBrush(this.innerColor);
            }
            var graphics = this._page.graphics;
            if (borderPen || backgroundBrush) {
                var state = void 0;
                if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                    state = graphics.save();
                    graphics.setTransparency(this._opacity);
                }
                if (this.borderEffect.intensity !== 0 && this.borderEffect.style === PdfBorderEffectStyle.cloudy) {
                    var radius = this.borderEffect.intensity * 4 + 0.5 * this.border.width;
                    var graphicsPath = new PdfPath();
                    graphicsPath.addPolygon(this._getLinePoints());
                    this._drawCloudStyle(graphics, backgroundBrush, borderPen, radius, 0.833, graphicsPath._points, false);
                }
                else {
                    graphics.drawPolygon(this._getLinePoints(), borderPen, backgroundBrush);
                }
                if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                    graphics.restore(state);
                }
            }
            return graphics._template;
        }
        else {
            var boundsValue = void 0;
            var rect = { x: 0, y: 0, width: 0, height: 0 };
            if (typeof this._points === 'undefined' && this._dictionary.has('Vertices')) {
                this._points = this._dictionary.get('Vertices');
                boundsValue = this._getBoundsValue(this._points);
            }
            else {
                boundsValue = this._getBoundsValue(this._points);
            }
            if (typeof this._borderEffect !== 'undefined' &&
                typeof this.borderEffect.intensity !== 'undefined' && this.borderEffect.intensity !== 0 &&
                this._borderEffect.style === PdfBorderEffectStyle.cloudy) {
                rect.x = boundsValue.x - (this.borderEffect.intensity * 5) - this.border.width;
                rect.y = boundsValue.y - (this.borderEffect.intensity * 5) - this.border.width;
                rect.width = boundsValue.width + (this.borderEffect.intensity * 10) + (2 * this.border.width);
                rect.height = boundsValue.height + (this.borderEffect.intensity * 10) + (2 * this.border.width);
            }
            else {
                rect.x = boundsValue.x - this.border.width;
                rect.y = boundsValue.y - this.border.width;
                rect.width = boundsValue.width + (2 * this.border.width);
                rect.height = boundsValue.height + (2 * this.border.width);
            }
            var appearance = new PdfAppearance(this, [rect.x, rect.y, rect.width, rect.height]);
            appearance.normal = new PdfTemplate([rect.x, rect.y, rect.width, rect.height], this._crossReference);
            var template = appearance.normal;
            _setMatrix(template, this._getRotationAngle());
            template._writeTransformation = false;
            var graphics = appearance.normal.graphics;
            var parameter = new _PaintParameter();
            if (this.innerColor) {
                parameter.backBrush = new PdfBrush(this._innerColor);
            }
            if (this.border.width > 0 && this.color) {
                parameter.borderPen = new PdfPen(this._color, this.border.width);
            }
            if (this.color) {
                parameter.foreBrush = new PdfBrush(this._color);
            }
            if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                graphics.save();
                graphics.setTransparency(this._opacity);
            }
            else {
                graphics.save();
            }
            if (_isNullOrUndefined(this.borderEffect) && _isNullOrUndefined(this.borderEffect.intensity) &&
                this.borderEffect.intensity !== 0 && this.borderEffect.style === PdfBorderEffectStyle.cloudy) {
                var radius = this.borderEffect.intensity * 4 + 0.5 * this.border.width;
                var graphicsPath = new PdfPath();
                graphicsPath.addPolygon(this._getLinePoints());
                this._drawCloudStyle(graphics, parameter.backBrush, parameter.borderPen, radius, 0.833, graphicsPath._points, false);
            }
            else {
                graphics.drawPolygon(this._getLinePoints(), parameter.borderPen, parameter.backBrush);
            }
            if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                graphics.restore();
            }
            graphics.restore();
            if (this._isBounds) {
                template._content.dictionary._updated = true;
                this._dictionary.update('LLE', this.lineExtension);
                this._dictionary.update('Vertices', this._points);
            }
            this._dictionary.update('Rect', [rect.x, rect.y, rect.x + rect.width, rect.y + rect.height]);
            return template;
        }
    };
    PdfPolygonAnnotation.prototype._getLinePoints = function () {
        var polygonPoints;
        var pageSize = this._page.size;
        var pageHeight = pageSize[1];
        var pageWidth = pageSize[0];
        if (this._dictionary.has('Vertices') && !this._isBounds) {
            var rotation = void 0;
            if (this._page._pageDictionary.has('Rotate')) {
                rotation = this._page._pageDictionary.get('Rotate');
            }
            if (this._page && this._page.rotation) {
                if (this._page.rotation === PdfRotationAngle.angle90) {
                    rotation = 90;
                }
                else if (this._page.rotation === PdfRotationAngle.angle180) {
                    rotation = 180;
                }
                else if (this._page.rotation === PdfRotationAngle.angle270) {
                    rotation = 270;
                }
            }
            var linePoints = this._dictionary.getArray('Vertices');
            if (linePoints) {
                var points_1 = [];
                linePoints.forEach(function (value) {
                    points_1.push(value);
                });
                polygonPoints = [];
                for (var j = 0; j < points_1.length; j = j + 2) {
                    if (this.flatten) {
                        polygonPoints.push([points_1[Number.parseInt(j.toString(), 10)], (pageHeight - points_1[j + 1])]);
                    }
                    else {
                        polygonPoints.push([points_1[Number.parseInt(j.toString(), 10)], -points_1[j + 1]]);
                    }
                }
                if (rotation) {
                    if (rotation === 270) {
                        for (var k = 0; k < polygonPoints.length; k++) {
                            var x = polygonPoints[Number.parseInt(k.toString(), 10)][0];
                            polygonPoints[Number.parseInt(k.toString(), 10)][0] = polygonPoints[Number.parseInt(k.toString(), 10)][1];
                            polygonPoints[Number.parseInt(k.toString(), 10)][1] = pageWidth - x;
                        }
                    }
                    else if (rotation === 90) {
                        for (var k = 0; k < polygonPoints.length; k++) {
                            var x = polygonPoints[Number.parseInt(k.toString(), 10)][0];
                            if (this._page._origin[1] !== 0) {
                                polygonPoints[Number.parseInt(k.toString(), 10)][0] = pageHeight -
                                    (polygonPoints[Number.parseInt(k.toString(), 10)][1] - pageHeight);
                            }
                            else {
                                polygonPoints[Number.parseInt(k.toString(), 10)][0] = pageHeight -
                                    polygonPoints[Number.parseInt(k.toString(), 10)][1];
                            }
                            polygonPoints[Number.parseInt(k.toString(), 10)][1] = x;
                        }
                    }
                    else if (rotation === 180) {
                        for (var k = 0; k < polygonPoints.length; k++) {
                            var x = polygonPoints[Number.parseInt(k.toString(), 10)][0];
                            polygonPoints[Number.parseInt(k.toString(), 10)][0] = pageWidth - x;
                            polygonPoints[Number.parseInt(k.toString(), 10)][1] = pageHeight -
                                polygonPoints[Number.parseInt(k.toString(), 10)][1];
                        }
                    }
                }
            }
        }
        else if (this._points) {
            var points_2 = [];
            this._points.forEach(function (value) {
                points_2.push(value);
            });
            polygonPoints = [];
            for (var j = 0; j < this._points.length; j = j + 2) {
                if (this.flatten) {
                    polygonPoints.push([points_2[Number.parseInt(j.toString(), 10)], (pageHeight - points_2[j + 1])]);
                }
                else {
                    polygonPoints.push([points_2[Number.parseInt(j.toString(), 10)], -points_2[j + 1]]);
                }
            }
        }
        return polygonPoints;
    };
    return PdfPolygonAnnotation;
}(PdfComment));
/**
 * `PdfPolyLineAnnotation` class represents the polyline annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new poly line annotation with bounds
 * const annotation: PdfPolyLineAnnotation = new PdfPolyLineAnnotation ([100, 300, 150, 200, 300, 200, 350, 300, 300, 400, 150, 400]);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfPolyLineAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfPolyLineAnnotation, _super);
    function PdfPolyLineAnnotation(points) {
        var _this = _super.call(this) || this;
        _this._beginLine = PdfLineEndingStyle.none;
        _this._endLine = PdfLineEndingStyle.none;
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('PolyLine'));
        if (typeof points !== 'undefined') {
            _this._points = points;
        }
        else {
            _this._points = [];
        }
        _this._type = _PdfAnnotationType.polyLineAnnotation;
        return _this;
    }
    Object.defineProperty(PdfPolyLineAnnotation.prototype, "beginLineStyle", {
        /**
         * Gets the begin line ending style of the annotation.
         *
         * @returns {PdfLineEndingStyle} Begin line ending style.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;
         * // Gets the begin line ending style of the annotation.
         * let beginLineStyle: PdfLineEndingStyle = annotation.beginLineStyle;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary.has('LE')) {
                var lineStyles = this._dictionary.getArray('LE');
                if (lineStyles && Array.isArray(lineStyles)) {
                    this._beginLine = _mapLineEndingStyle(lineStyles[0].name);
                }
            }
            return this._beginLine;
        },
        /**
         * Sets the begin line ending style of the annotation.
         *
         * @param {PdfLineEndingStyle} value Begin line ending style.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;
         * // Sets the begin line ending style of the annotation.
         * annotation.beginLineStyle = PdfLineEndingStyle.slash;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._beginLine) {
                this._beginLine = value;
                if (this._dictionary) {
                    var lineStyle = [];
                    lineStyle.push(_PdfName.get(_reverseMapEndingStyle(value)));
                    lineStyle.push(_PdfName.get(_reverseMapEndingStyle(this.endLineStyle)));
                    this._dictionary.update('LE', lineStyle);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPolyLineAnnotation.prototype, "endLineStyle", {
        /**
         * Gets the end line ending style of the annotation.
         *
         * @returns {PdfLineEndingStyle} End line ending style.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;
         * // Gets the end line ending style of the annotation.
         * let endLineStyle: PdfLineEndingStyle = annotation.endLineStyle;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary.has('LE')) {
                var lineStyles = this._dictionary.getArray('LE');
                if (lineStyles && Array.isArray(lineStyles)) {
                    this._endLine = _mapLineEndingStyle(lineStyles[1].name);
                }
            }
            return this._endLine;
        },
        /**
         * Sets the end line ending style of the annotation.
         *
         * @param {PdfLineEndingStyle} value End line ending style.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;
         * // Sets the end line ending style of the annotation.
         * annotation.endLineStyle = PdfLineEndingStyle.square;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._endLine) {
                this._endLine = value;
                if (this._dictionary) {
                    var lineStyle = [];
                    lineStyle.push(_PdfName.get(_reverseMapEndingStyle(this.beginLineStyle)));
                    lineStyle.push(_PdfName.get(_reverseMapEndingStyle(value)));
                    this._dictionary.update('LE', lineStyle);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPolyLineAnnotation.prototype, "lineExtension", {
        /**
         * Gets the line extension of the square annotation.
         *
         * @returns {number} Line extension.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;
         * // Gets the line extension of annotation.
         * let lineExtension: number = annotation.lineExtension;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._lineExtension === 'undefined' && this._dictionary.has('LLE')) {
                var lineExt = this._dictionary.get('LLE');
                if (typeof lineExt !== 'undefined' && lineExt >= 0) {
                    this._lineExtension = lineExt;
                }
            }
            return this._lineExtension;
        },
        /**
         * Sets the line extension of the square annotation.
         *
         * @param {number} value Line extension.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;
         * // Sets the line extension of the annotation.
         * annotation.lineExtension = 3;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (!Number.isNaN(value)) {
                if (value >= 0) {
                    this._dictionary.update('LLE', value);
                    this._lineExtension = value;
                }
                else {
                    throw new Error('LineExtension should be non negative number');
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfPolyLineAnnotation._load = function (page, dictionary) {
        var annot = new PdfPolyLineAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfPolyLineAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfPolyLineAnnotation.prototype._postProcess = function (isFlatten) {
        if (typeof this._points === 'undefined' || this._points === null) {
            throw new Error('Points cannot be null or undefined');
        }
        if (!this._dictionary.has('LLE')) {
            this.lineExtension = 0;
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
            this._isTransparentColor = true;
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        var points = this._getLinePoints();
        var pathTypes = [];
        pathTypes.push(0);
        for (var i = 1; i < points.length; i++) {
            pathTypes.push(1);
        }
        this._polylinePoints = points;
        this._pathTypes = pathTypes;
        var path = new PdfPath();
        path._points = points;
        path._pathTypes = pathTypes;
        this._dictionary.update('Vertices', this._points);
        var lineStyle = [];
        lineStyle.push(_PdfName.get(_reverseMapEndingStyle(this.beginLineStyle)));
        lineStyle.push(_PdfName.get(_reverseMapEndingStyle(this.endLineStyle)));
        this._dictionary.update('LE', lineStyle);
        this._dictionary.update('LLE', this._lineExtension);
        var polyLineBounds = this._getBoundsValue(this._points);
        var rectangle = [polyLineBounds.x,
            polyLineBounds.y,
            polyLineBounds.x + polyLineBounds.width,
            polyLineBounds.y + polyLineBounds.height];
        this._dictionary.update('Rect', rectangle);
        if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
            this._appearanceTemplate = this._createPolyLineAppearance(isFlatten);
        }
    };
    PdfPolyLineAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        this._flatten = isFlatten;
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createPolyLineAppearance(isFlatten);
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    var appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate && isFlatten) {
                if (!this._dictionary.has('AP')) {
                    this._appearanceTemplate = this._createPolyLineAppearance(isFlatten);
                }
                else {
                    var dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        var appearanceStream = dictionary.get('N');
                        var reference = dictionary.getRaw('N');
                        if (appearanceStream) {
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
        }
        if (isFlatten) {
            if (this._appearanceTemplate) {
                var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
                if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {
                    var box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                    if (box) {
                        this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                    }
                }
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
            else {
                this._page.annotations.remove(this);
            }
        }
        if (!isFlatten && this._setAppearance) {
            var appearance = void 0;
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                var reference_6 = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference_6, appearance);
                this._dictionary.update('AP', reference_6);
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    };
    PdfPolyLineAnnotation.prototype._createPolyLineAppearance = function (flatten) {
        var color = this.color ? this.color : [0, 0, 0];
        if (typeof flatten !== 'undefined' && flatten) {
            var borderPen = void 0;
            if (this.border.width > 0) {
                borderPen = new PdfPen(color, this.border.width);
            }
            var graphics = this._page.graphics;
            if (borderPen) {
                var state = void 0;
                if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                    state = graphics.save();
                    graphics.setTransparency(this._opacity);
                }
                var points = this._getLinePoints();
                var pathTypes = [];
                pathTypes.push(0);
                if (points && points.length > 0) {
                    for (var i = 1; i < points.length; i++) {
                        pathTypes.push(1);
                    }
                    var path = new PdfPath();
                    path._points = points;
                    path._pathTypes = pathTypes;
                    graphics.drawPath(path, borderPen);
                    if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                        graphics.restore(state);
                    }
                }
            }
            return graphics._template;
        }
        else {
            var boundsValue = void 0;
            var rect = { x: 0, y: 0, width: 0, height: 0 };
            if (typeof this._points === 'undefined' && this._dictionary.has('Vertices')) {
                this._points = this._dictionary.get('Vertices');
                boundsValue = this._getBoundsValue(this._points);
            }
            else {
                boundsValue = this._getBoundsValue(this._points);
            }
            rect.x = boundsValue.x - this.border.width;
            rect.y = boundsValue.y - this.border.width;
            rect.width = boundsValue.width + (2 * this.border.width);
            rect.height = boundsValue.height + (2 * this.border.width);
            var appearance = new PdfAppearance(this, [rect.x, rect.y, rect.width, rect.height]);
            appearance.normal = new PdfTemplate([rect.x, rect.y, rect.width, rect.height], this._crossReference);
            var template = appearance.normal;
            _setMatrix(template, this._getRotationAngle());
            template._writeTransformation = false;
            var graphics = appearance.normal.graphics;
            var parameter = new _PaintParameter();
            if (this.innerColor) {
                parameter.backBrush = new PdfBrush(this._innerColor);
            }
            if (this.border.width > 0 && color) {
                parameter.borderPen = new PdfPen(color, this.border.width);
            }
            if (color) {
                parameter.foreBrush = new PdfBrush(color);
            }
            if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                graphics.save();
                graphics.setTransparency(this._opacity);
            }
            else {
                graphics.save();
            }
            var path = new PdfPath();
            if (typeof this._polylinePoints !== 'undefined' && this._polylinePoints !== null) {
                path._points = this._polylinePoints;
            }
            else {
                path._points = this._getLinePoints();
            }
            if (typeof this._pathTypes !== 'undefined' && this._polylinePoints !== null) {
                path._pathTypes = this._pathTypes;
            }
            else {
                this._pathTypes = [];
                this._pathTypes.push(0);
                for (var i = 1; i < path._points.length; i++) {
                    this._pathTypes.push(1);
                }
                path._pathTypes = this._pathTypes;
            }
            graphics.drawPath(path, parameter.borderPen, parameter.backBrush);
            if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                graphics.restore();
            }
            graphics.restore();
            if (this._isBounds) {
                template._content.dictionary._updated = true;
                var lineStyle = [];
                lineStyle.push(_PdfName.get(_reverseMapEndingStyle(this.beginLineStyle)));
                lineStyle.push(_PdfName.get(_reverseMapEndingStyle(this.endLineStyle)));
                this._dictionary.update('LE', lineStyle);
                this._dictionary.update('LLE', this.lineExtension);
                this._dictionary.update('Vertices', this._points);
            }
            this._dictionary.update('Rect', [rect.x, rect.y, rect.x + rect.width, rect.y + rect.height]);
            return template;
        }
    };
    PdfPolyLineAnnotation.prototype._getLinePoints = function () {
        var pageSize = this._page.size;
        var pageHeight = pageSize[1];
        var points;
        if (this._dictionary.has('Vertices') && !this._isBounds && (!this._setAppearance || (this._setAppearance && this.flatten))) {
            var linePoints = this._dictionary.getArray('Vertices');
            if (linePoints) {
                points = [];
                for (var j = 0; j < linePoints.length; j = j + 2) {
                    points.push([linePoints[Number.parseInt(j.toString(), 10)], (pageHeight - linePoints[j + 1])]);
                }
            }
        }
        else if (this._points) {
            this._points = this._getPoints(this._points);
            var polyLinepoints_1 = [];
            this._points.forEach(function (value) {
                polyLinepoints_1.push(value);
            });
            points = [];
            for (var j = 0; j < polyLinepoints_1.length; j = j + 2) {
                if (this.flatten) {
                    points.push([polyLinepoints_1[Number.parseInt(j.toString(), 10)], (pageHeight - polyLinepoints_1[j + 1])]);
                }
                else {
                    points.push([polyLinepoints_1[Number.parseInt(j.toString(), 10)], -polyLinepoints_1[j + 1]]);
                }
            }
        }
        return points;
    };
    return PdfPolyLineAnnotation;
}(PdfComment));
/**
 * `PdfAngleMeasurementAnnotation` class represents the angle measurement annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new angle measurement annotation
 * const annotation: PdfAngleMeasurementAnnotation = new PdfAngleMeasurementAnnotation([[100, 700], [150, 650], [100, 600]]);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAngleMeasurementAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfAngleMeasurementAnnotation, _super);
    function PdfAngleMeasurementAnnotation(points) {
        var _this = _super.call(this) || this;
        _this._linePoints = [];
        _this._firstIntersectionPoint = [0, 0];
        _this._secondIntersectionPoint = [0, 0];
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('PolyLine'));
        if (typeof points !== 'undefined' && points.length > 0) {
            if (points.length > 6) {
                throw new Error('Points length should not be greater than 3');
            }
            _this._pointArray = points;
            for (var i = 0; i < points.length; i++) {
                _this._linePoints.push(points[Number.parseInt(i.toString(), 10)][0]);
                _this._linePoints.push(points[Number.parseInt(i.toString(), 10)][1]);
            }
        }
        _this._type = _PdfAnnotationType.angleMeasurementAnnotation;
        return _this;
    }
    Object.defineProperty(PdfAngleMeasurementAnnotation.prototype, "measure", {
        /**
         * Gets the flag to have measurement dictionary of the angle measurement annotation.
         *
         * @returns {boolean} measure.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfAngleMeasurementAnnotation = page.annotations.at(0) as PdfAngleMeasurementAnnotation;
         * // Gets the flag to have measurement dictionary of the angle annotation.
         * let measure: boolean = annotation.measure;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._measure === 'undefined' && this._dictionary.has('Measure')) {
                this._measure = this._dictionary.get('Measure');
            }
            return this._measure;
        },
        /**
         * Sets the flag to add measurement dictionary to the annotation.
         *
         * @param {boolean} value Measure.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfAngleMeasurementAnnotation = page.annotations.at(0) as PdfAngleMeasurementAnnotation;
         * // Sets the flag to add measurement dictionary to the annotation.
         * annotation.measure = true;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value && !this._isLoaded) {
                this._measure = value;
                this.caption.cap = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfAngleMeasurementAnnotation._load = function (page, dictionary) {
        var annot = new PdfAngleMeasurementAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfAngleMeasurementAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfAngleMeasurementAnnotation.prototype._postProcess = function () {
        if (!this._pointArray) {
            throw new Error('Points cannot be null or undefined');
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
            this._isTransparentColor = true;
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        this._appearanceTemplate = this._createAngleMeasureAppearance();
    };
    PdfAngleMeasurementAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (this._isLoaded) {
            if (!isFlatten && this._setAppearance) {
                this._appearanceTemplate = this._createAngleMeasureAppearance();
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    var appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess();
            if (!this._appearanceTemplate) {
                if (isFlatten) {
                    if (!this._dictionary.has('AP')) {
                        this._appearanceTemplate = this._createAngleMeasureAppearance();
                    }
                    else {
                        var dictionary = this._dictionary.get('AP');
                        if (dictionary && dictionary.has('N')) {
                            var appearanceStream = dictionary.get('N');
                            var reference = dictionary.getRaw('N');
                            if (appearanceStream) {
                                if (reference) {
                                    appearanceStream.reference = reference;
                                }
                                this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                            }
                        }
                    }
                }
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {
                var box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                if (box) {
                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                }
            }
            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
        }
        else if (isFlatten) {
            this._page.annotations.remove(this);
        }
    };
    PdfAngleMeasurementAnnotation.prototype._createAngleMeasureAppearance = function () {
        var borderWidth = this.border.width;
        var font = this._obtainFont();
        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {
            font = this._circleCaptionFont;
            this._pdfFont = font;
        }
        var format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
        var angle = (this._calculateAngle() * (180.0 / Math.PI));
        if (angle < 0) {
            angle = -angle;
        }
        if (angle > 180) {
            angle = 360 - angle;
        }
        this._dictionary.update('Vertices', this._linePoints);
        var ds = 'font:' +
            font._metrics._postScriptName +
            ' ' +
            font._size +
            'pt; color:' +
            this._colorToHex(this.color);
        this._dictionary.update('DS', ds);
        if (this.text === (' ' + angle.toFixed(2) + '°')) {
            this._dictionary.update('Contents', this.text);
        }
        else if (this.text) {
            this._dictionary.update('Contents', this.text);
        }
        if (typeof this.subject === 'undefined') {
            this._dictionary.update('Subject', 'Angle Measurement');
        }
        this._dictionary.update('MeasurementTypes', 1152);
        this._dictionary.update('Subtype', new _PdfName('PolyLine'));
        this._dictionary.update('IT', new _PdfName('PolyLineAngle'));
        var measureDictionary = new _PdfDictionary();
        var d = [];
        var t = [];
        var a = [];
        var x = [];
        var v = [];
        measureDictionary.set('Type', _PdfName.get('measureDictionary'));
        measureDictionary.set('R', '1 in = 1 in');
        measureDictionary.set('Subtype', 'RL');
        measureDictionary.set('TargetUnitConversion', 0.1388889);
        var dDictionary = new _PdfDictionary();
        dDictionary.set('U', 'in');
        dDictionary.set('Type', 'NumberFormat');
        dDictionary.set('C', 1);
        dDictionary.set('D', 1);
        dDictionary.set('SS', '');
        d.push(dDictionary);
        var tDictionary = new _PdfDictionary();
        tDictionary.set('U', '°');
        tDictionary.set('Type', 'NumberFormat');
        tDictionary.set('C', 1);
        tDictionary.set('D', 1);
        tDictionary.set('FD', true);
        tDictionary.set('SS', '');
        t.push(tDictionary);
        var aDictionary = new _PdfDictionary();
        aDictionary.set('U', 'sq in');
        aDictionary.set('Type', 'NumberFormat');
        aDictionary.set('C', 1);
        aDictionary.set('D', 1);
        aDictionary.set('FD', true);
        aDictionary.set('SS', '');
        a.push(aDictionary);
        var vDictionary = new _PdfDictionary();
        vDictionary.set('U', 'cu in');
        vDictionary.set('Type', 'NumberFormat');
        vDictionary.set('C', 1);
        vDictionary.set('D', 1);
        vDictionary.set('FD', true);
        vDictionary.set('SS', '');
        v.push(vDictionary);
        var xDictionary = new _PdfDictionary();
        xDictionary.set('U', 'in');
        xDictionary.set('Type', 'NumberFormat');
        xDictionary.set('C', 1);
        xDictionary.set('D', 1);
        xDictionary.set('SS', '');
        x.push(xDictionary);
        measureDictionary.set('D', d);
        measureDictionary.set('T', t);
        measureDictionary.set('A', a);
        measureDictionary.set('X', x);
        measureDictionary.set('V', v);
        if (this._dictionary.has('Measure')) {
            _removeDuplicateReference(this._dictionary, this._crossReference, 'Measure');
        }
        var reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, measureDictionary);
        measureDictionary._updated = true;
        this._dictionary.update('Measure', reference);
        var rectValue = [0, 0, 0, 0];
        var boundsValue = this._getAngleBoundsValue();
        var points = this._obtainLinePoints();
        var pathTypes = [];
        pathTypes.push(0);
        for (var i = 1; i < points.length; i++) {
            pathTypes.push(1);
        }
        var graphicspath = new PdfPath();
        graphicspath.addRectangle(points[1][0] - this._radius, -(points[1][1] + this._radius), 2 * this._radius, 2 * this._radius);
        var size = font.measureString(angle.toString() + '°', [0, 0], format, 0, 0);
        var midPoint = [(this._firstIntersectionPoint[0] + this._secondIntersectionPoint[0]) / 2,
            ((this._firstIntersectionPoint[1] + this._secondIntersectionPoint[1]) / 2)];
        var center = [points[1][0], -points[1][1]];
        var x1 = points[1][0] + this._radius * Math.cos((this._startAngle + (this._sweepAngle / 2)) * (Math.PI / 180.0));
        var y = points[1][1] + this._radius * Math.sin((this._startAngle + (this._sweepAngle / 2)) * (Math.PI / 180.0));
        var start = [midPoint[0], midPoint[1]];
        var xDiff = start[0] - center[0];
        var yDiff = start[1] - center[1];
        var midpointAngle = ((Math.atan2(yDiff, xDiff)) * (180.0 / Math.PI));
        var left = false;
        var right = false;
        var up = false;
        var down = false;
        if (midpointAngle > 0) {
            if (midpointAngle < 45) {
                right = true;
            }
            else if (midpointAngle >= 45 && midpointAngle < 135) {
                up = true;
            }
            else {
                left = true;
            }
        }
        else {
            midpointAngle = -midpointAngle;
            if (midpointAngle === 0) {
                (new PdfPath()).addRectangle(boundsValue[0], boundsValue[1], boundsValue[2], boundsValue[3]);
            }
            else if (midpointAngle < 45) {
                right = true;
            }
            else if (midpointAngle >= 45 && midpointAngle < 135) {
                down = true;
            }
            else {
                left = true;
            }
        }
        if (rectValue[0] === 0 && rectValue[1] === 0 && rectValue[2] === 0 && rectValue[3] === 0) {
            rectValue = boundsValue;
            this.bounds = { x: boundsValue[0], y: boundsValue[1], width: boundsValue[2], height: boundsValue[3] };
        }
        var path = new PdfPath();
        path._pathTypes = pathTypes;
        path._points = points;
        this._dictionary.set('Rect', [rectValue[0], rectValue[1], rectValue[0] + rectValue[2], rectValue[1] + rectValue[3]]);
        var appearance = new PdfAppearance(this, boundsValue);
        appearance.normal = new PdfTemplate(rectValue, this._crossReference);
        var template = appearance.normal;
        template._writeTransformation = false;
        var graphics = appearance.normal.graphics;
        var width = borderWidth / 2;
        var pen = new PdfPen(this._color, width);
        if (this.border.style === PdfBorderStyle.dashed) {
            pen._dashStyle = PdfDashStyle.dash;
        }
        var brush = new PdfBrush(this._color);
        graphics.save();
        graphics.drawPath(path, pen);
        path.addArc(points[1][0] - this._radius, points[1][1] - this._radius, 2 * this._radius, 2 * this._radius, this._startAngle, this._sweepAngle);
        if (up) {
            graphics.drawString(angle.toString() + '°', font, [x1 - (size[0] / 2), -(-y + font._metrics._getHeight() + 2), 0, 0], null, brush);
        }
        else if (right) {
            graphics.drawString(angle.toString() + '°', font, [x1 + 2, -(-y + font._metrics._getHeight() / 2), 0, 0], null, brush);
        }
        else if (left) {
            graphics.drawString(angle.toString() + '°', font, [x1 - size[0] - 2, -(-y + font._metrics._getHeight() / 2), 0, 0], null, brush);
        }
        else if (down) {
            graphics.drawString(angle.toString() + '°', font, [x1 - (size[0] / 2), (y + 2), 0, 0], null, brush);
        }
        graphics.restore();
        graphics._template._content.dictionary._updated = true;
        var reference1 = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference1, graphics._template._content);
        graphics._template._content.reference = reference1;
        if (this._dictionary.has('AP')) {
            _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
        }
        var appearanceDictionary = new _PdfDictionary();
        appearanceDictionary.set('N', reference1);
        appearanceDictionary._updated = true;
        this._dictionary.set('AP', appearanceDictionary);
        return template;
    };
    PdfAngleMeasurementAnnotation.prototype._getAngleBoundsValue = function () {
        var points = this._obtainLinePoints();
        for (var i = 0; i < points.length; i++) {
            points[Number.parseInt(i.toString(), 10)][1] = -points[Number.parseInt(i.toString(), 10)][1];
        }
        var path = new PdfPath();
        path._points = points;
        path._pathTypes = [0, 1, 1];
        return path._getBounds();
    };
    PdfAngleMeasurementAnnotation.prototype._obtainLinePoints = function () {
        var points;
        var collection;
        if (this._linePoints) {
            points = new Array(this._linePoints.length);
            for (var i = 0; i < this._linePoints.length; i++) {
                points[Number.parseInt(i.toString(), 10)] = this._linePoints[Number.parseInt(i.toString(), 10)];
            }
            collection = new Array(points.length / 2);
            var count = 0;
            for (var j = 0; j < points.length; j = j + 2) {
                collection[Number.parseInt(count.toString(), 10)] = [points[Number.parseInt(j.toString(), 10)], -points[j + 1]];
                count++;
            }
        }
        return collection;
    };
    PdfAngleMeasurementAnnotation.prototype._calculateAngle = function () {
        var points = [0, 0];
        if (typeof this._linePoints !== 'undefined' && this._linePoints.length === 0 && this._isLoaded) {
            if (this._dictionary.has('Vertices')) {
                this._linePoints = this._dictionary.get('Vertices');
            }
        }
        for (var i = 0; i < this._linePoints.length; i++) {
            points[Number.parseInt(i.toString(), 10)] = this._linePoints[Number.parseInt(i.toString(), 10)];
        }
        var collection = [];
        for (var j = 0; j < points.length; j = j + 2) {
            collection.push([points[Number.parseInt(j.toString(), 10)], points[j + 1]]);
        }
        var point1 = collection[0];
        var point2 = collection[1];
        var point3 = collection[2];
        var firstLineDistance = Math.sqrt(Math.pow((point2[0] - point1[0]), 2) + Math.pow((point2[1] - point1[1]), 2));
        var secondLineDistance = Math.sqrt(Math.pow((point2[0] - point3[0]), 2) + Math.pow((point2[1] - point3[1]), 2));
        this._radius = Math.min(firstLineDistance, secondLineDistance) / 4;
        var graphicsPath = new PdfPath();
        graphicsPath._points = collection;
        graphicsPath._pathTypes = [0, 1, 1];
        var intersectionPoint1;
        var intersectionPoint2;
        var value = this._findLineCircleIntersectionPoints(point2[0], point2[1], this._radius, point1, point2, intersectionPoint1, intersectionPoint2);
        intersectionPoint1 = value.first;
        intersectionPoint2 = value.second;
        if (this._firstIntersectionPoint[0] === 0 && this._firstIntersectionPoint[1] === 0) {
            this._firstIntersectionPoint = intersectionPoint2;
        }
        intersectionPoint1 = [0, 0];
        intersectionPoint2 = [0, 0];
        value = this._findLineCircleIntersectionPoints(point2[0], point2[1], this._radius, point3, point2, intersectionPoint1, intersectionPoint2);
        intersectionPoint1 = value.first;
        intersectionPoint2 = value.second;
        if (this._secondIntersectionPoint[0] === 0 && this._secondIntersectionPoint[1] === 0) {
            this._secondIntersectionPoint = intersectionPoint2;
        }
        var xDiff = this._firstIntersectionPoint[0] - point2[0];
        var yDiff = this._firstIntersectionPoint[1] - point2[1];
        var startAngle = (Math.atan2(yDiff, xDiff) * (180.0 / Math.PI));
        xDiff = this._secondIntersectionPoint[0] - point2[0];
        yDiff = this._secondIntersectionPoint[1] - point2[1];
        var sweepAngle = (Math.atan2(yDiff, xDiff) * (180.0 / Math.PI));
        startAngle = startAngle > 0 ? startAngle = 360 - startAngle : -startAngle;
        sweepAngle = sweepAngle > 0 ? sweepAngle = 360 - sweepAngle : -sweepAngle;
        if (startAngle === 180 && sweepAngle === 0) {
            this._startAngle = startAngle;
            this._sweepAngle = 180;
        }
        else if (startAngle === 0 && sweepAngle === 180) {
            this._startAngle = sweepAngle;
            this._sweepAngle = 180;
        }
        else if (startAngle < 180) {
            if (startAngle > sweepAngle) {
                this._startAngle = sweepAngle;
                this._sweepAngle = startAngle - sweepAngle;
            }
            else if (startAngle + 180 < sweepAngle) {
                this._startAngle = sweepAngle;
                this._sweepAngle = (360 - sweepAngle) + startAngle;
            }
            else {
                this._startAngle = startAngle;
                this._sweepAngle = sweepAngle - startAngle;
            }
        }
        else {
            if (startAngle < sweepAngle) {
                this._startAngle = startAngle;
                this._sweepAngle = sweepAngle - startAngle;
            }
            else if (startAngle - 180 > sweepAngle) {
                this._startAngle = startAngle;
                this._sweepAngle = (360 - startAngle) + sweepAngle;
            }
            else {
                this._startAngle = sweepAngle;
                this._sweepAngle = startAngle - sweepAngle;
            }
        }
        return (Math.atan2((point3[0] - point2[0]), (point3[1] - point2[1])) -
            Math.atan2((point1[0] - point2[0]), (point1[1] - point2[1])));
    };
    PdfAngleMeasurementAnnotation.prototype._findLineCircleIntersectionPoints = function (centerX, centerY, radius, point1, point2, intersection1, intersection2) {
        var dx = point2[0] - point1[0];
        var dy = point2[1] - point1[1];
        var a = dx * dx + dy * dy;
        var b = 2 * (dx * (point1[0] - centerX) + dy * (point1[1] - centerY));
        var c = (point1[0] - centerX) * (point1[0] - centerX) + (point1[1] - centerY) * (point1[1] - centerY) - radius * radius;
        var e = b * b - 4 * a * c;
        if ((a <= 0.0000001) || (e < 0)) {
            intersection1 = [Number.NaN, Number.NaN];
            intersection2 = [Number.NaN, Number.NaN];
        }
        else if (e === 0) {
            var t = -b / (2 * a);
            intersection1 = [point1[0] + t * dx, point1[1] + t * dy];
            intersection2 = [Number.NaN, Number.NaN];
        }
        else {
            var t = ((-b + Math.sqrt(e)) / (2 * a));
            intersection1 = [point1[0] + t * dx, point1[1] + t * dy];
            t = ((-b - Math.sqrt(e)) / (2 * a));
            intersection2 = [point1[0] + t * dx, point1[1] + t * dy];
        }
        return { first: intersection1, second: intersection2 };
    };
    return PdfAngleMeasurementAnnotation;
}(PdfComment));
/**
 * `PdfInkAnnotation` class represents the ink annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new ink annotation with the bounds and ink points
 * const annotation: PdfInkAnnotation = new PdfInkAnnotation([0, 0, 300, 400], [40, 300, 60, 100, 40, 50, 40, 300]);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfInkAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfInkAnnotation, _super);
    function PdfInkAnnotation(points, linePoints) {
        var _this = _super.call(this) || this;
        _this._inkPointsCollection = [];
        _this._previousCollection = [];
        _this._isModified = false;
        _this._isEnableControlPoints = true;
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('Ink'));
        if (typeof points !== 'undefined') {
            _this._points = points;
            _this.bounds = { x: points[0], y: points[1], width: points[2], height: points[3] };
        }
        if (typeof linePoints !== 'undefined') {
            _this._linePoints = linePoints;
        }
        _this._type = _PdfAnnotationType.inkAnnotation;
        return _this;
    }
    Object.defineProperty(PdfInkAnnotation.prototype, "inkPointsCollection", {
        /**
         * Gets the ink points collection of the annotation.
         *
         * @returns {Array<number[]>} Ink points collection.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfInkAnnotation = page.annotations.at(0) as PdfInkAnnotation;
         * // Get the ink points collection of the annotation
         * let inkPointsCollection: Array<number[]> = annotation.inkPointsCollection;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._inkPointsCollection.length === 0 && this._dictionary.has('InkList')) {
                var inkList = this._dictionary.get('InkList');
                if (Array.isArray(inkList) && inkList.length > 0) {
                    this._inkPointsCollection = inkList;
                }
            }
            return this._inkPointsCollection;
        },
        /**
         * Sets the ink points collection of the annotation.
         *
         * @param {Array<number[]>} value Ink points collection.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * // Create a new ink annotation
         * const annotation: PdfInkAnnotation = new PdfInkAnnotation([0, 0, 300, 400], [40, 300, 60, 100, 40, 50, 40, 300]);
         * // Set the ink points collection of the annotation
         * annotation.inkPointsCollection = [[422, 690, 412, 708, 408, 715, 403, 720, 400, 725], [420, 725, 420, 715, 415, 705, 400, 690, 405, 695]];
         * // Add annotation to the page
         * page.annotations.add(annotation);
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (Array.isArray(value) && value.length > 0 && value !== this._inkPointsCollection) {
                this._inkPointsCollection = value;
                this._isModified = true;
                if (this._isLoaded) {
                    this._dictionary.update('InkList', value);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfInkAnnotation._load = function (page, dictionary) {
        var annot = new PdfInkAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfInkAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfInkAnnotation.prototype._postProcess = function () {
        if (typeof this._points === 'undefined' || this._points === null) {
            throw new Error('Points cannot be null or undefined');
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
            this._isTransparentColor = true;
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        var nativeRectangle = this._addInkPoints();
        var bounds = [nativeRectangle[0],
            nativeRectangle[1],
            nativeRectangle[0] + nativeRectangle[2],
            nativeRectangle[1] + nativeRectangle[3]];
        this._dictionary.update('Rect', bounds);
        if (this._setAppearance) {
            var appearance = new PdfAppearance(this, nativeRectangle);
            appearance.normal = new PdfTemplate(nativeRectangle, this._crossReference);
            var template = appearance.normal;
            _setMatrix(template, this._getRotationAngle());
            template._writeTransformation = false;
            this._appearanceTemplate = this._createInkAppearance(template);
            if (this._dictionary.has('AP')) {
                _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
            }
            var dictionary = new _PdfDictionary();
            this._appearanceTemplate._content.dictionary._updated = true;
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            this._appearanceTemplate._content.reference = reference;
            dictionary.set('N', reference);
            dictionary._updated = true;
            this._dictionary.set('AP', dictionary);
        }
    };
    PdfInkAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        this._isFlatten = isFlatten;
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                if (this._inkPointsCollection.length === 0) {
                    this._inkPointsCollection = this._obtainInkListCollection();
                }
                var rect = this._getInkBoundsValue();
                var template = new PdfTemplate(rect, this._crossReference);
                var box = template._content.dictionary.getArray('BBox');
                var angle = this._getRotationAngle();
                if (box && angle !== null && typeof angle !== 'undefined') {
                    template._content.dictionary.set('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                }
                template._writeTransformation = false;
                this._appearanceTemplate = this._createInkAppearance(template);
                this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
                if (!isFlatten) {
                    if (this._dictionary.has('AP')) {
                        _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
                    }
                    var dictionary = new _PdfDictionary();
                    this._appearanceTemplate._content.dictionary._updated = true;
                    var reference = this._crossReference._getNextReference();
                    this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
                    this._appearanceTemplate._content.reference = reference;
                    dictionary.set('N', reference);
                    dictionary._updated = true;
                    this._dictionary.set('AP', dictionary);
                }
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    var appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess();
            if (!this._appearanceTemplate) {
                if (isFlatten) {
                    if (!this._dictionary.has('AP')) {
                        if (this._inkPointsCollection.length === 0) {
                            this._inkPointsCollection = this._obtainInkListCollection();
                        }
                        var rect = this._getInkBoundsValue();
                        var template = new PdfTemplate(rect, this._crossReference);
                        _setMatrix(template, this._getRotationAngle());
                        template._writeTransformation = false;
                        this._appearanceTemplate = this._createInkAppearance(template);
                        this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
                    }
                    else {
                        var dictionary = this._dictionary.get('AP');
                        if (dictionary && dictionary.has('N')) {
                            var appearanceStream = dictionary.get('N');
                            var reference = dictionary.getRaw('N');
                            if (appearanceStream) {
                                if (reference) {
                                    appearanceStream.reference = reference;
                                }
                                this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                            }
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten &&
            this._appearanceTemplate &&
            this._appearanceTemplate._size !== null &&
            typeof this._appearanceTemplate._size !== 'undefined') {
            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {
                var box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                if (box) {
                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                }
            }
            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
        }
        else if (isFlatten) {
            this._page.annotations.remove(this);
        }
        if (isFlatten && !this.flattenPopups && this._dictionary.has('Popup')) {
            var reference = this._dictionary.getRaw('Popup');
            if (this._page._pageDictionary.has('Annots')) {
                var annots = this._page._pageDictionary.getRaw('Annots'); // eslint-disable-line
                if (annots && Array.isArray(annots) && annots.length > 0) {
                    var index = annots.indexOf(reference);
                    if (index >= 0) {
                        this._page.annotations.removeAt(index);
                    }
                }
            }
        }
    };
    PdfInkAnnotation.prototype._createInkAppearance = function (template) {
        var graphics = template.graphics;
        if (this._inkPointsCollection !== null &&
            this._inkPointsCollection.length > 0 &&
            this.color !== null &&
            typeof this._color !== 'undefined') {
            for (var l = 0; l < this._inkPointsCollection.length; l++) {
                var isDot = false;
                if (this._inkPointsCollection[Number.parseInt(l.toString(), 10)].length % 2 === 0) {
                    var inkPoints = this._inkPointsCollection[Number.parseInt(l.toString(), 10)];
                    if (inkPoints.length === 2) {
                        var locx = inkPoints[0] - 0.5;
                        var locy = inkPoints[1] - 0.5;
                        var locw = inkPoints[0] + 0.5;
                        var loch = inkPoints[1] + 0.5;
                        inkPoints = [locx, locy, locw, loch];
                        isDot = true;
                    }
                    var point = new Array(inkPoints.length / 2);
                    var count = 0;
                    for (var j = 0; j < inkPoints.length; j = j + 2) {
                        point[Number.parseInt(count.toString(), 10)] = [inkPoints[Number.parseInt(j.toString(), 10)], inkPoints[j + 1]];
                        count++;
                    }
                    var pathPointCont = count + (count * 2) - 2;
                    var pathPoints = new Array(pathPointCont);
                    if (this._isEnableControlPoints) {
                        var p1 = [];
                        var p2 = [];
                        var value = this._getControlPoints(point, p1, p2);
                        p1 = value.controlP1;
                        p2 = value.controlP2;
                        var index = 0;
                        for (var i = 0; i < pathPointCont - 1; i = i + 3) {
                            pathPoints[Number.parseInt(i.toString(), 10)] = point[Number.parseInt(index.toString(), 10)];
                            pathPoints[i + 1] = p1[Number.parseInt(index.toString(), 10)];
                            pathPoints[i + 2] = p2[Number.parseInt(index.toString(), 10)];
                            index++;
                        }
                    }
                    else {
                        if (count % 3 === 1) {
                            pathPointCont = count;
                            pathPoints = new Array(pathPointCont);
                            pathPoints = point;
                        }
                        else if (count % 3 === 0) {
                            pathPointCont = count + 1;
                            pathPoints = new Array(pathPointCont);
                            for (var i = 0; i < point.length; i++) {
                                pathPoints[Number.parseInt(i.toString(), 10)] = point[Number.parseInt(i.toString(), 10)];
                            }
                        }
                        else {
                            pathPointCont = count + 2;
                            pathPoints = new Array(pathPointCont);
                            for (var i = 0; i < point.length; i++) {
                                pathPoints[Number.parseInt(i.toString(), 10)] = point[Number.parseInt(i.toString(), 10)];
                            }
                            pathPoints[pathPointCont - 2] = point[point.length - 2];
                        }
                    }
                    pathPoints[pathPointCont - 1] = point[point.length - 1];
                    if (pathPoints !== null) {
                        var pointsCollection = pathPoints;
                        for (var k = 0; k < pointsCollection.length; k++) {
                            var point_1 = pointsCollection[Number.parseInt(k.toString(), 10)];
                            pointsCollection[Number.parseInt(k.toString(), 10)] = [point_1[0], (-point_1[1])];
                        }
                        var path1 = new PdfPath();
                        var path2 = null;
                        if (isDot) {
                            var width = point[1][0] - point[0][0];
                            var height = point[1][1] - point[0][1];
                            path1.addEllipse(point[0][0] + (0.5), -(point[0][1] + height + (0.5)), width, height);
                            path2 = new PdfPath();
                            path2._pathTypes = path1._pathTypes;
                            path2._points = path1._points;
                        }
                        else if (point.length === 2) {
                            path1.addLine(point[0][0], -point[0][1], point[1][0], -point[1][1]);
                            path2 = new PdfPath();
                            path2._pathTypes = path1._pathTypes;
                            path2._points = path1._points;
                        }
                        else {
                            path1._addBezierPoints(pointsCollection);
                            path2 = new PdfPath();
                            path2._pathTypes = path1._pathTypes;
                            path2._points = pointsCollection;
                        }
                        var borderPen = new PdfPen(this.color, this.border.width);
                        if (this._isLoaded) {
                            borderPen._lineCap = PdfLineCap.round;
                        }
                        if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                            var state = graphics.save();
                            graphics.setTransparency(this._opacity);
                            graphics.drawPath(path2, borderPen);
                            graphics.restore(state);
                        }
                        else {
                            graphics.drawPath(path2, borderPen);
                        }
                    }
                }
            }
            if (this._isFlatten) {
                this.bounds = { x: this.bounds.x,
                    y: (this._page.size[1] - (this.bounds.y + this.bounds.height)),
                    width: this.bounds.width,
                    height: this.bounds.height };
            }
        }
        return template;
    };
    PdfInkAnnotation.prototype._getControlPoints = function (point, p1, p2) {
        if (point === null) {
            throw new Error('pointCollection');
        }
        var pointCount = point.length - 1;
        if (pointCount < 1) {
            throw new Error('At least two knot PointFs required pointCollection');
        }
        if (pointCount === 1) {
            p1 = [[((2 * point[0][0] + point[1][0]) / 3), ((2 * point[0][1] + point[1][1]) / 3)]];
            p2 = [[(2 * p1[0][0] - point[0][0]), (2 * p1[0][1] - point[0][1])]];
        }
        var rightVector = [];
        for (var i = 1; i < pointCount - 1; ++i) {
            rightVector[Number.parseInt(i.toString(), 10)] = 4 * point[Number.parseInt(i.toString(), 10)][0] + 2 * point[i + 1][0];
        }
        rightVector[0] = point[0][0] + 2 * point[1][0];
        rightVector[pointCount - 1] = (8 * point[pointCount - 1][0] + point[Number.parseInt(pointCount.toString(), 10)][0]) / 2.0;
        var xValue = this._getSingleControlPoint(rightVector);
        for (var i = 1; i < pointCount - 1; ++i) {
            rightVector[Number.parseInt(i.toString(), 10)] = 4 * point[Number.parseInt(i.toString(), 10)][1] + 2 * point[i + 1][1];
        }
        rightVector[0] = point[0][1] + 2 * point[1][1];
        rightVector[pointCount - 1] = (8 * point[pointCount - 1][1] + point[Number.parseInt(pointCount.toString(), 10)][1]) / 2.0;
        var yValue = this._getSingleControlPoint(rightVector);
        p1 = new Array(pointCount);
        p2 = new Array(pointCount);
        for (var i = 0; i < pointCount; ++i) {
            p1[Number.parseInt(i.toString(), 10)] = [xValue[Number.parseInt(i.toString(), 10)], yValue[Number.parseInt(i.toString(), 10)]];
            if (i < pointCount - 1) {
                p2[Number.parseInt(i.toString(), 10)] = [2 * point[i + 1][0] - xValue[i + 1], 2 * point[i + 1][1] - yValue[i + 1]];
            }
            else {
                var x = (point[Number.parseInt(pointCount.toString(), 10)][0] + xValue[pointCount - 1]) / 2;
                var y = (point[Number.parseInt(pointCount.toString(), 10)][1] + yValue[pointCount - 1]) / 2;
                p2[Number.parseInt(i.toString(), 10)] = [x, y];
            }
        }
        return { controlP1: p1, controlP2: p2 };
    };
    PdfInkAnnotation.prototype._getSingleControlPoint = function (rightVector) {
        var count = rightVector.length;
        var vector = [];
        var tmpVector = [];
        var divisor = 2.0;
        vector[0] = rightVector[0] / divisor;
        for (var i = 1; i < count; i++) {
            tmpVector[Number.parseInt(i.toString(), 10)] = 1 / divisor;
            divisor = (i < count - 1 ? 4.0 : 3.5) - tmpVector[Number.parseInt(i.toString(), 10)];
            vector[Number.parseInt(i.toString(), 10)] = (rightVector[Number.parseInt(i.toString(), 10)] - vector[i - 1]) / divisor;
        }
        for (var i = 1; i < count; i++) {
            vector[count - i - 1] -= tmpVector[count - i] * vector[count - i];
        }
        return vector;
    };
    PdfInkAnnotation.prototype._addInkPoints = function () {
        var _this = this;
        var inkCollection = [];
        if (this._linePoints !== null && (this._previousCollection.length === 0 || this._isModified)) {
            this._inkPointsCollection.unshift(this._linePoints);
        }
        var isEqual = _checkInkPoints(this._inkPointsCollection, this._previousCollection);
        if (this._inkPointsCollection !== null && !isEqual) {
            for (var i = 0; i < this._inkPointsCollection.length; i++) {
                var inkList = this._inkPointsCollection[Number.parseInt(i.toString(), 10)].slice();
                inkCollection.push(inkList);
            }
            this._dictionary.update('InkList', inkCollection);
        }
        if (this._inkPointsCollection.length > 0 && (!isEqual || this._isModified)) {
            this._inkPointsCollection.forEach(function (inkList) {
                _this._previousCollection.push(inkList);
                _this._isModified = false;
            });
        }
        var cropOrMediaBox = this._getCropOrMediaBox();
        var containsCropOrMediaBox = false;
        if (cropOrMediaBox && cropOrMediaBox.length > 3 && typeof cropOrMediaBox[0] === 'number' && typeof cropOrMediaBox[1] === 'number' && (cropOrMediaBox[0] !== 0 || cropOrMediaBox[1] !== 0)) {
            containsCropOrMediaBox = true;
            for (var i = 0; i < inkCollection.length; i++) {
                var inkList = inkCollection[Number.parseInt(i.toString(), 10)];
                var modifiedInkList = inkList;
                for (var j = 0; j < inkList.length; j = j + 2) {
                    var x = inkList[Number.parseInt(j.toString(), 10)];
                    var y = inkList[j + 1];
                    x = x + cropOrMediaBox[0];
                    if (this._page._pageDictionary.has('MediaBox') && !this._page._pageDictionary.has('CropBox') && cropOrMediaBox[3] === 0 && cropOrMediaBox[1] > 0) {
                        y = y + cropOrMediaBox[3];
                    }
                    else {
                        y = y + cropOrMediaBox[1];
                    }
                    modifiedInkList[Number.parseInt(j.toString(), 10)] = x;
                    modifiedInkList[j + 1] = y;
                    inkCollection[Number.parseInt(i.toString(), 10)] = modifiedInkList;
                }
            }
            this._dictionary.update('InkList', inkCollection);
        }
        if (this._isEnableControlPoints || containsCropOrMediaBox) {
            return this._getInkBoundsValue(inkCollection);
        }
        else {
            if (!this._isFlatten) {
                this._updateInkListCollection(inkCollection);
            }
            return [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];
        }
    };
    PdfInkAnnotation.prototype._updateInkListCollection = function (inkCollection) {
        for (var i = 0; i < inkCollection.length; i++) {
            var inkList = [];
            for (var j = 0; j < inkCollection[Number.parseInt(i.toString(), 10)].length; j++) {
                inkList.push(inkCollection[Number.parseInt(i.toString(), 10)][Number.parseInt(j.toString(), 10)]);
            }
            this._inkPointsCollection[Number.parseInt(i.toString(), 10)] = inkList;
        }
    };
    PdfInkAnnotation.prototype._getInkBoundsValue = function (inkCollection) {
        var bounds = [0, 0, 0, 0];
        if (this._points) {
            this.bounds = { x: this._points[0], y: this._points[1], width: this._points[2], height: this._points[3] };
        }
        bounds = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];
        var borderWidth = this.border.width;
        if (this._inkPointsCollection !== null) {
            if (this._inkPointsCollection.length > 0) {
                var termsList = [];
                for (var i = 0; i < this._inkPointsCollection.length; i++) {
                    var subList = this._inkPointsCollection[Number.parseInt(i.toString(), 10)];
                    if (subList !== null) {
                        if (subList.length % 2 === 0) {
                            for (var j = 0; j < subList.length; j++) {
                                termsList.push(subList[Number.parseInt(j.toString(), 10)]);
                            }
                        }
                    }
                }
                var isTwoPoints = false;
                if (!this._isLoaded && termsList.length === 2) {
                    isTwoPoints = true;
                    termsList.push((termsList[0] + 1));
                    termsList.push((termsList[1] + 1));
                }
                var pointCollection = new Array(termsList.length / 2);
                var count = 0;
                for (var j = 0; j < termsList.length; j = j + 2) {
                    pointCollection[Number.parseInt(count.toString(), 10)] = [termsList[Number.parseInt(j.toString(), 10)],
                        termsList[j + 1]];
                    count++;
                }
                if (this._isLoaded) {
                    if (pointCollection.length > 0) {
                        var xMin = 0;
                        var yMin = 0;
                        var xMax = 0;
                        var yMax = 0;
                        var first = true;
                        for (var i = 0; i < pointCollection.length; i++) {
                            var point = pointCollection[Number.parseInt(i.toString(), 10)];
                            if (first) {
                                xMin = point[0];
                                yMin = point[1];
                                first = false;
                            }
                            else {
                                if (point[0] < xMin) {
                                    xMin = point[0];
                                }
                                else if (point[0] > xMax) {
                                    xMax = point[0];
                                }
                                if (point[1] < yMin) {
                                    yMin = point[1];
                                }
                                else if (point[1] > yMax) {
                                    yMax = point[1];
                                }
                            }
                        }
                        bounds = [xMin, yMin, xMax - xMin, yMax - yMin];
                        this.bounds = { x: bounds[0], y: bounds[1], width: bounds[2], height: bounds[3] };
                        if (this._isFlatten || this._setAppearance) {
                            bounds[0] = this.bounds.x - borderWidth;
                            bounds[1] = this.bounds.y - borderWidth;
                            bounds[2] = this.bounds.width + (2 * borderWidth);
                            bounds[3] = this.bounds.height + (2 * borderWidth);
                        }
                    }
                    else {
                        if (this._points) {
                            bounds = this._points;
                        }
                        else if (pointCollection.length > 0) {
                            bounds = this._dictionary.get('Rect');
                        }
                        else {
                            bounds = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];
                        }
                    }
                }
                else if (inkCollection) {
                    bounds = this._calculateInkBounds(pointCollection, bounds, borderWidth, isTwoPoints, inkCollection);
                }
                else {
                    bounds = this._calculateInkBounds(pointCollection, bounds, borderWidth, isTwoPoints);
                }
                this.bounds = { x: bounds[0], y: bounds[1], width: bounds[2], height: bounds[3] };
            }
        }
        return bounds;
    };
    PdfInkAnnotation.prototype._calculateInkBounds = function (pointCollection, bounds, borderWidth, isTwoPoints, inkCollection) {
        if (pointCollection.length > 5) {
            var xMin = 0;
            var yMin = 0;
            var xMax = 0;
            var yMax = 0;
            var first = true;
            for (var i = 0; i < pointCollection.length; i++) {
                var point = pointCollection[Number.parseInt(i.toString(), 10)];
                if (first) {
                    xMin = point[0];
                    yMin = point[1];
                    xMax = point[0];
                    yMax = point[1];
                    first = false;
                }
                else {
                    if (point[0] < xMin) {
                        xMin = point[0];
                    }
                    else if (point[0] > xMax) {
                        xMax = point[0];
                    }
                    if (point[1] < yMin) {
                        yMin = point[1];
                    }
                    else if (point[1] > yMax) {
                        yMax = point[1];
                    }
                }
            }
            var cropOrMediaBox = this._getCropOrMediaBox();
            if (bounds[2] < xMax) {
                xMax = bounds[2];
            }
            else if (cropOrMediaBox) {
                xMax = xMax - xMin;
            }
            if (bounds[3] < yMax) {
                yMax = bounds[3];
            }
            else if (cropOrMediaBox) {
                yMax = yMax - yMin;
            }
            if (cropOrMediaBox) {
                xMin = xMin + cropOrMediaBox[0];
                yMin = yMin + cropOrMediaBox[1];
            }
            bounds = [xMin, yMin, xMax, yMax];
            if (this._isFlatten || this._setAppearance) {
                var factor = isTwoPoints ? 2 : 3;
                bounds[0] = bounds[0] - borderWidth;
                bounds[1] = bounds[1] - borderWidth;
                bounds[2] = bounds[2] + (factor * borderWidth);
                bounds[3] = bounds[3] + (factor * borderWidth);
            }
        }
        else {
            if (typeof this._points === 'undefined' && pointCollection.length > 0) {
                bounds = this._dictionary.get('Rect');
            }
            else {
                bounds = this._points;
            }
        }
        if (!this._isFlatten && inkCollection) {
            this._updateInkListCollection(inkCollection);
        }
        return bounds;
    };
    PdfInkAnnotation.prototype._obtainInkListCollection = function () {
        var path = [];
        if (this._dictionary.has('InkList')) {
            var inkList = this._dictionary.getArray('InkList');
            var list = [];
            for (var i = 0; i < inkList.length; i++) {
                var innerList = inkList[Number.parseInt(i.toString(), 10)];
                for (var j = 0; j < innerList.length; j++) {
                    list.push(innerList[Number.parseInt(j.toString(), 10)]);
                }
                path.push(list);
                if (list.length === innerList.length) {
                    list = [];
                }
            }
        }
        return path;
    };
    return PdfInkAnnotation;
}(PdfComment));
/**
 * `PdfPopupAnnotation` class represents the popup annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new popup annotation
 * const annotation: PdfPopupAnnotation = new PdfPopupAnnotation('Test popup annotation', 10, 40, 30, 30);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfPopupAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfPopupAnnotation, _super);
    function PdfPopupAnnotation(text, x, y, width, height) {
        var _this = _super.call(this) || this;
        _this._icon = PdfPopupIcon.note;
        _this._iconString = '';
        _this._stateModel = PdfAnnotationStateModel.none;
        _this._state = PdfAnnotationState.none;
        _this._open = false;
        _this._isReview = false;
        _this._isComment = false;
        _this._comment = 'q 1 1 1 rg 0 i 1 w 4 M 1 j 0 J []0 d 1 0 0 1 9 5.0908 cm 7.74 12.616 m -7.74 12.616 l -8.274 12.616 -8.707 12.184 -8.707 11.649 c h f Q 0 G ';
        _this._commentSecondHalf = '0 i 0.60 w 4 M 1 j 0 J [0 100]1 d  1 0 0 1 9 5.0908 cm 4.1 1.71 m -0.54 -2.29 l  -0.54 1.71 l  -5.5 1.71 l  -5.5 14.42 l  10.5 14.42 l  10.5 1.71 l  4.1 1.71 l -2.33 9.66 m 7.34 9.66 l 7.34 8.83 l -2.33 8.83 l -2.33 9.66 l -2.33 7.28 m 5.88 7.28 l 5.88 6.46 l -2.33 6.46 l -2.33 7.28 l 14.9 23.1235 m -14.9 23.1235 l -14.9 -20.345 l 14.9 -20.345 l 14.9 23.1235 l b ';
        _this._note = '0 G 0 i 0.61 w 4 M 0 j 0 J []0 d  q 1 0 0 1 16.959 1.3672 cm 0 0 m 0 -0.434 -0.352 -0.785 -0.784 -0.785 c -14.911 -0.785 l -15.345 -0.785 -15.696 -0.434 -15.696 0 c -15.696 17.266 l -15.696 17.699 -15.345 18.051 -14.911 18.051 c -0.784 18.051 l -0.352 18.051 0 17.699 0 17.266 c h b Q q 1 0 0 1 4.4023 13.9243 cm 0 0 m 9.418 0 l S Q q 1 0 0 1 4.4019 11.2207 cm 0 0 m 9.418 0 l S Q q 1 0 0 1 4.4023 8.5176 cm 0 0 m 9.418 0 l S Q q 1 0 0 1 4.4023 5.8135 cm 0 0 m 9.418 0 l S Q ';
        _this._help = 'q 1 1 1 rg 0 i 1 w 4 M 1 j 0 J []0 d 1 0 0 1 12.1465 10.5137 cm -2.146 9.403 m -7.589 9.403 -12.001 4.99 -12.001 -0.453 c -12.001 -5.895 -7.589 -10.309 -2.146 -10.309 c 3.296 -10.309 7.709 -5.895 7.709 -0.453 c 7.709 4.99 3.296 9.403 -2.146 9.403 c h f Q ';
        _this._helpSecondHalf = ' 0 G 0 i 0.59 w 4 M 1 j 0 J []0 d  1 0 0 1 12.1465 10.5137 cm 0 0 m -0.682 -0.756 -0.958 -1.472 -0.938 -2.302 c -0.938 -2.632 l -3.385 -2.632 l -3.403 -2.154 l -3.459 -1.216 -3.147 -0.259 -2.316 0.716 c -1.729 1.433 -1.251 2.022 -1.251 2.647 c -1.251 3.291 -1.674 3.715 -2.594 3.751 c -3.202 3.751 -3.937 3.531 -4.417 3.2 c -5.041 5.205 l -4.361 5.591 -3.274 5.959 -1.968 5.959 c 0.46 5.959 1.563 4.616 1.563 3.089 c 1.563 1.691 0.699 0.771 0 0 c -2.227 -6.863 m -2.245 -6.863 l -3.202 -6.863 -3.864 -6.146 -3.864 -5.189 c -3.864 -4.196 -3.182 -3.516 -2.227 -3.516 c -1.233 -3.516 -0.589 -4.196 -0.57 -5.189 c -0.57 -6.146 -1.233 -6.863 -2.227 -6.863 c -2.146 9.403 m -7.589 9.403 -12.001 4.99 -12.001 -0.453 c -12.001 -5.895 -7.589 -10.309 -2.146 -10.309 c 3.296 -10.309 7.709 -5.895 7.709 -0.453 c 7.709 4.99 3.296 9.403 -2.146 9.403 c b ';
        _this._insert = ' 0 i 0.59 w 4 M 0 j 0 J []0 d  1 0 0 1 8.5386 19.8545 cm 0 0 m -8.39 -19.719 l 8.388 -19.719 l h B ';
        _this._key = 'q 1 1 1 rg 0 i 1 w 4 M 1 j 0 J []0 d 1 0 0 1 6.5 12.6729 cm 0.001 5.138 m -2.543 5.138 -4.604 3.077 -4.604 0.534 c -4.604 -1.368 -3.449 -3.001 -1.802 -3.702 c -1.802 -4.712 l -0.795 -5.719 l -1.896 -6.82 l -0.677 -8.039 l -1.595 -8.958 l -0.602 -9.949 l -1.479 -10.829 l -0.085 -12.483 l 1.728 -10.931 l 1.728 -3.732 l 1.737 -3.728 1.75 -3.724 1.76 -3.721 c 3.429 -3.03 4.604 -1.385 4.604 0.534 c 4.604 3.077 2.542 5.138 0.001 5.138 c f Q ';
        _this._keySecondHalf = ' 0 G 0 i 0.59 w 4 M 1 j 0 J []0 d  q 1 0 0 1 6.4995 20 cm 0 0 m -6.205 -12.713 l 6.205 -12.713 l h b Q q 1 0 0 1 1.1909 6.2949 cm 0 0 m 1.278 0 l 1.353 0 1.362 -0.02 1.391 -0.066 c 2.128 -1.363 3.78 -4.275 3.966 -4.713 c 3.985 -4.713 l 3.976 -4.453 3.957 -3.91 3.957 -3.137 c 3.957 -0.076 l 3.957 -0.02 3.976 0 4.041 0 c 4.956 0 l 5.021 0 5.04 -0.029 5.04 -0.084 c 5.04 -6.049 l 5.04 -6.113 5.021 -6.133 4.947 -6.133 c 3.695 -6.133 l 3.621 -6.133 3.611 -6.113 3.574 -6.066 c 3.052 -4.955 1.353 -2.063 0.971 -1.186 c 0.961 -1.186 l 0.999 -1.68 0.999 -2.146 1.008 -3.025 c 1.008 -6.049 l 1.008 -6.104 0.989 -6.133 0.933 -6.133 c 0.009 -6.133 l -0.046 -6.133 -0.075 -6.123 -0.075 -6.049 c -0.075 -0.066 l -0.075 -0.02 -0.056 0 0 0 c f Q q 1 0 0 1 9.1367 3.0273 cm 0 0 m 0.075 0 0.215 -0.008 0.645 -0.008 c 1.4 -0.008 2.119 0.281 2.119 1.213 c 2.119 1.969 1.633 2.381 0.737 2.381 c 0.354 2.381 0.075 2.371 0 2.361 c h -1.146 3.201 m -1.146 3.238 -1.129 3.268 -1.082 3.268 c -0.709 3.275 0.02 3.285 0.729 3.285 c 2.613 3.285 3.248 2.314 3.258 1.232 c 3.258 -0.27 2.007 -0.914 0.607 -0.914 c 0.327 -0.914 0.057 -0.914 0 -0.904 c 0 -2.789 l 0 -2.836 -0.019 -2.865 -0.074 -2.865 c -1.082 -2.865 l -1.119 -2.865 -1.146 -2.846 -1.146 -2.799 c h f Q ';
        _this._newParagraph = '1 0.819611 0 rg 0 G 0 i 0.58 w 4 M 0 j 0 J []0 d ';
        _this._newParagraphSecondHalf = ' 0 G 0 i 0.59 w 4 M 1 j 0 J []0 d  q 1 0 0 1 6.4995 20 cm 0 0 m -6.205 -12.713 l 6.205 -12.713 l h b Q q 1 0 0 1 1.1909 6.2949 cm 0 0 m 1.278 0 l 1.353 0 1.362 -0.02 1.391 -0.066 c 2.128 -1.363 3.78 -4.275 3.966 -4.713 c 3.985 -4.713 l 3.976 -4.453 3.957 -3.91 3.957 -3.137 c 3.957 -0.076 l 3.957 -0.02 3.976 0 4.041 0 c 4.956 0 l 5.021 0 5.04 -0.029 5.04 -0.084 c 5.04 -6.049 l 5.04 -6.113 5.021 -6.133 4.947 -6.133 c 3.695 -6.133 l 3.621 -6.133 3.611 -6.113 3.574 -6.066 c 3.052 -4.955 1.353 -2.063 0.971 -1.186 c 0.961 -1.186 l 0.999 -1.68 0.999 -2.146 1.008 -3.025 c 1.008 -6.049 l 1.008 -6.104 0.989 -6.133 0.933 -6.133 c 0.009 -6.133 l -0.046 -6.133 -0.075 -6.123 -0.075 -6.049 c -0.075 -0.066 l -0.075 -0.02 -0.056 0 0 0 c f Q q 1 0 0 1 9.1367 3.0273 cm 0 0 m 0.075 0 0.215 -0.008 0.645 -0.008 c 1.4 -0.008 2.119 0.281 2.119 1.213 c 2.119 1.969 1.633 2.381 0.737 2.381 c 0.354 2.381 0.075 2.371 0 2.361 c h -1.146 3.201 m -1.146 3.238 -1.129 3.268 -1.082 3.268 c -0.709 3.275 0.02 3.285 0.729 3.285 c 2.613 3.285 3.248 2.314 3.258 1.232 c 3.258 -0.27 2.007 -0.914 0.607 -0.914 c 0.327 -0.914 0.057 -0.914 0 -0.904 c 0 -2.789 l 0 -2.836 -0.019 -2.865 -0.074 -2.865 c -1.082 -2.865 l -1.119 -2.865 -1.146 -2.846 -1.146 -2.799 c h f Q ';
        _this._paragraph = 'q 1 1 1 rg 0 i 1 w 4 M 1 j 0 J []0 d 1 0 0 1 19.6973 10.0005 cm 0 0 m 0 -5.336 -4.326 -9.662 -9.663 -9.662 c -14.998 -9.662 -19.324 -5.336 -19.324 0 c -19.324 5.335 -14.998 9.662 -9.663 9.662 c -4.326 9.662 0 5.335 0 0 c h f Q ';
        _this._paragraphSecondHalf = '0 G 0 i 0.59 w 4 M 1 j 0 J []0 d  q 1 0 0 1 19.6973 10.0005 cm 0 0 m 0 -5.336 -4.326 -9.662 -9.663 -9.662 c -14.998 -9.662 -19.324 -5.336 -19.324 0 c -19.324 5.335 -14.998 9.662 -9.663 9.662 c -4.326 9.662 0 5.335 0 0 c h S Q q 1 0 0 1 11.6787 2.6582 cm 0 0 m -1.141 0 l -1.227 0 -1.244 0.052 -1.227 0.139 c -0.656 1.157 -0.52 2.505 -0.52 3.317 c -0.52 3.594 l -2.833 3.783 -5.441 4.838 -5.441 8.309 c -5.441 10.778 -3.714 12.626 -0.57 13.024 c -0.535 13.508 -0.381 14.129 -0.242 14.389 c -0.207 14.44 -0.174 14.475 -0.104 14.475 c 1.088 14.475 l 1.156 14.475 1.191 14.458 1.175 14.372 c 1.105 14.095 0.881 13.127 0.881 12.402 c 0.881 9.431 0.932 7.324 0.95 4.06 c 0.95 2.298 0.708 0.813 0.189 0.07 c 0.155 0.034 0.103 0 0 0 c b Q ';
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('Text'));
        if (typeof text !== 'undefined') {
            _this.text = text;
        }
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            _this.bounds = { x: x, y: y, width: width, height: height };
        }
        _this._type = _PdfAnnotationType.popupAnnotation;
        return _this;
    }
    Object.defineProperty(PdfPopupAnnotation.prototype, "open", {
        /**
         * Gets the boolean flag indicating whether annotation has open or not.
         *
         * @returns {boolean} Caption.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
         * // Gets the boolean flag indicating whether annotation has open or not.
         * let open: boolean =  annotation.open;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary.has('Open')) {
                this._open = this._dictionary.get('Open');
            }
            return this._open;
        },
        /**
         * Sets the boolean flag indicating whether annotation has open or not.
         *
         * @param {boolean} value Open.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
         * // Sets the boolean flag indicating whether annotation has open or not.
         * annotation.open = true;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined') {
                this._open = value;
                this._dictionary.update('Open', this._open);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPopupAnnotation.prototype, "icon", {
        /**
         * Gets the icon type of the popup annotation.
         *
         * @returns {PdfPopupIcon} Annotation icon.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
         * // Gets the icon type of the popup annotation.
         * let icon: PdfPopupIcon = annotation.icon;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary.has('Name')) {
                this._icon = _mapPopupIcon(this._dictionary.get('Name').name);
            }
            return this._icon;
        },
        /**
         * Sets the icon type of the popup annotation.
         *
         * @param {PdfPopupIcon} value Annotation icon.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
         * // Sets the icon type of the popup annotation.
         * annotation.icon = PdfPopupIcon.newParagraph;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined') {
                this._icon = value;
                this._dictionary.update('Name', _PdfName.get(this._obtainIconName(this._icon)));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPopupAnnotation.prototype, "stateModel", {
        /**
         * Gets the state model of the popup annotation.
         *
         * @returns {PdfAnnotationStateModel} Annotation State Model.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
         * // Gets the state model of the popup annotation.
         * let stateModel: PdfAnnotationStateModel = annotation.stateModel;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary.has('StateModel')) {
                this._stateModel = _mapAnnotationStateModel(this._dictionary.get('StateModel'));
            }
            return this._stateModel;
        },
        /**
         * Sets the state model of the popup annotation.
         *
         * @param {PdfAnnotationStateModel} value Annotation State Model.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
         * // Sets the state model of the popup annotation.
         * annotation.stateModel = PdfAnnotationStateModel.marked;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined') {
                this._stateModel = value;
                this._dictionary.update('StateModel', _reverseMapAnnotationStateModel(this._stateModel));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPopupAnnotation.prototype, "state", {
        /**
         * Gets the state of the popup annotation.
         *
         * @returns {PdfAnnotationState} Annotation State.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
         * // Gets the state of the popup annotation.
         * let state: PdfAnnotationState = annotation.state;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary.has('State')) {
                this._state = _mapAnnotationState(this._dictionary.get('State'));
            }
            return this._state;
        },
        /**
         * Sets the state of the popup annotation.
         *
         * @param {PdfAnnotationState} value Annotation State.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
         * // Sets the state of the popup annotation.
         * annotation.state = PdfAnnotationState.completed;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined') {
                this._state = value;
                this._dictionary.update('State', _reverseMapAnnotationState(this._state));
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfPopupAnnotation._load = function (page, dictionary) {
        var annot = new PdfPopupAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        if (dictionary.has('IRT')) {
            annot._isReview = _checkReview(dictionary);
            if (!annot._isReview) {
                annot._isComment = _checkComment(dictionary);
            }
        }
        return annot;
    };
    PdfPopupAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfPopupAnnotation.prototype._postProcess = function () {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            this._bounds = { x: 0, y: 0, width: 0, height: 0 };
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        var rectangle = [this.bounds.x, this.bounds.y, (this.bounds.x + this.bounds.width),
            (this.bounds.y + this.bounds.height)];
        this._dictionary.update('Rect', rectangle);
        if (this._setAppearance) {
            this._appearanceTemplate = this._createPopupAppearance();
            if (this._appearanceTemplate) {
                if (this._dictionary.has('AP')) {
                    _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
                }
                var dictionary = new _PdfDictionary();
                this._appearanceTemplate._content.dictionary._updated = true;
                var reference = this._crossReference._getNextReference();
                this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
                this._appearanceTemplate._content.reference = reference;
                dictionary.set('N', reference);
                dictionary._updated = true;
                this._dictionary.set('AP', dictionary);
            }
        }
        this._dictionary.update('Rect', _updateBounds(this));
    };
    PdfPopupAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (this._isLoaded) {
            if (!this._appearanceTemplate && this._isFlattenPopups && this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    var appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                    if (this._appearanceTemplate !== null) {
                        var state = this._page.graphics.save();
                        if (this.opacity < 1) {
                            this._page.graphics.setTransparency(this.opacity);
                        }
                        this._page.graphics.drawTemplate(this._appearanceTemplate, this.bounds);
                        this._page.graphics.restore(state);
                    }
                }
            }
        }
        else {
            this._postProcess();
            if (!this._appearanceTemplate) {
                if (isFlatten) {
                    if (!this._dictionary.has('AP')) {
                        this._appearanceTemplate = this._createPopupAppearance();
                    }
                    else {
                        var dictionary = this._dictionary.get('AP');
                        if (dictionary && dictionary.has('N')) {
                            var appearanceStream = dictionary.get('N');
                            var reference = dictionary.getRaw('N');
                            if (appearanceStream) {
                                if (reference) {
                                    appearanceStream.reference = reference;
                                }
                                this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                            }
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups && this.flatten) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
        }
        if (isFlatten) {
            this._removeAnnotation(this._page, this);
        }
    };
    PdfPopupAnnotation.prototype._createPopupAppearance = function () {
        var nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];
        var template = new PdfTemplate(nativeRectangle, this._crossReference);
        var graphics = template.graphics;
        graphics._sw._clear();
        if (this.opacity < 1) {
            graphics.save();
            graphics.setTransparency(this.opacity);
        }
        switch (this.icon) {
            case PdfPopupIcon.comment:
                graphics._sw._write(this._comment);
                graphics._sw._setColorSpace(this.color, _PdfColorSpace.rgb, false);
                graphics._sw._write(this._commentSecondHalf);
                break;
            case PdfPopupIcon.paragraph:
                graphics._sw._write(this._paragraph);
                graphics._sw._setColorSpace(this.color, _PdfColorSpace.rgb, false);
                graphics._sw._write(this._paragraphSecondHalf);
                break;
            case PdfPopupIcon.help:
                graphics._sw._write(this._help);
                graphics._sw._setColorSpace(this.color, _PdfColorSpace.rgb, false);
                graphics._sw._write(this._helpSecondHalf);
                break;
            case PdfPopupIcon.note:
                graphics._sw._setColorSpace(this.color, _PdfColorSpace.rgb, false);
                graphics._sw._write(this._note);
                break;
            case PdfPopupIcon.insert:
                graphics._sw._write('0 G ');
                graphics._sw._setColorSpace(this.color, _PdfColorSpace.rgb, false);
                graphics._sw._write(this._insert);
                break;
            case PdfPopupIcon.key:
                graphics._sw._write(this._key);
                graphics._sw._setColorSpace(this.color, _PdfColorSpace.rgb, false);
                graphics._sw._write(this._keySecondHalf);
                break;
            case PdfPopupIcon.newParagraph:
                graphics._sw._write(this._newParagraph);
                graphics._sw._setColorSpace(this.color, _PdfColorSpace.rgb, false);
                graphics._sw._write(this._newParagraphSecondHalf);
                break;
        }
        if (this.opacity < 1) {
            graphics.restore();
        }
        return template;
    };
    PdfPopupAnnotation.prototype._obtainIconName = function (icon) {
        switch (icon) {
            case PdfPopupIcon.note:
                this._iconString = 'Note';
                break;
            case PdfPopupIcon.comment:
                this._iconString = 'Comment';
                break;
            case PdfPopupIcon.help:
                this._iconString = 'Help';
                break;
            case PdfPopupIcon.insert:
                this._iconString = 'Insert';
                break;
            case PdfPopupIcon.key:
                this._iconString = 'Key';
                break;
            case PdfPopupIcon.newParagraph:
                this._iconString = 'NewParagraph';
                break;
            case PdfPopupIcon.paragraph:
                this._iconString = 'Paragraph';
                break;
        }
        return this._iconString;
    };
    return PdfPopupAnnotation;
}(PdfComment));
/**
 * `PdfFileLinkAnnotation` class represents the link annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new file link annotation
 * let annotation: PdfFileLinkAnnotation = new PdfFileLinkAnnotation(10, 40, 30, 30, "image.png");
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfFileLinkAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfFileLinkAnnotation, _super);
    function PdfFileLinkAnnotation(x, y, width, height, fileName) {
        var _this = _super.call(this) || this;
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('Link'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            _this.bounds = { x: x, y: y, width: width, height: height };
        }
        if (typeof fileName !== 'undefined' && fileName !== null) {
            _this._fileName = fileName;
        }
        _this._type = _PdfAnnotationType.fileLinkAnnotation;
        return _this;
    }
    Object.defineProperty(PdfFileLinkAnnotation.prototype, "action", {
        /**
         * Gets the action of the annotation.
         *
         * @returns {string} Action.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFileLinkAnnotation = page.annotations.at(0) as PdfFileLinkAnnotation;
         * // Gets the action of the annotation.
         * let action: string = annotation.action;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._action === 'undefined' && this._dictionary.has('A')) {
                var dictionary = this._dictionary.get('A');
                if (dictionary && dictionary.has('Next')) {
                    var action = dictionary.get('Next');
                    if (Array.isArray(action)) {
                        for (var i = 0; i < action.length; i++) {
                            var reference = action[Number.parseInt(i.toString(), 10)];
                            if (reference && reference instanceof _PdfReference) {
                                var actionDictionary = this._crossReference._fetch(reference);
                                if (actionDictionary.has('JS')) {
                                    this._action = actionDictionary.get('JS');
                                }
                            }
                        }
                    }
                }
            }
            return this._action;
        },
        /**
         * Sets the action of the annotation.
         *
         * @param {string} value Action.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFileLinkAnnotation = page.annotations.at(0) as PdfFileLinkAnnotation;
         * // Sets the action of the annotation.
         * annotation.action = ‘syncfusion’;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (!this._isLoaded && typeof value === 'string') {
                this._action = value;
            }
            if (this._isLoaded && typeof value === 'string') {
                if (this.action !== value && this._dictionary.has('A')) {
                    var dictionary = this._dictionary.get('A');
                    if (dictionary && dictionary.has('Next')) {
                        var action = dictionary.get('Next');
                        if (Array.isArray(action)) {
                            for (var i = 0; i < action.length; i++) {
                                var reference = action[Number.parseInt(i.toString(), 10)];
                                if (reference && reference instanceof _PdfReference) {
                                    var actionDictionary = this._crossReference._fetch(reference);
                                    if (actionDictionary.has('JS')) {
                                        actionDictionary.update('JS', value);
                                        this._action = value;
                                        this._dictionary._updated = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfFileLinkAnnotation._load = function (page, dictionary) {
        var annot = new PdfFileLinkAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfFileLinkAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfFileLinkAnnotation.prototype._postProcess = function () {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        this._addAction();
        this._dictionary.update('Rect', _updateBounds(this));
    };
    PdfFileLinkAnnotation.prototype._addAction = function () {
        var _this = this;
        if (this._dictionary.has('A')) {
            var action = this._dictionary.get('A');
            if (action) {
                if (typeof this._action !== 'undefined' && this._action !== null && action.has('Next')) {
                    var nextAction = action.get('Next');
                    if (Array.isArray(nextAction) && nextAction.length > 0) {
                        nextAction.forEach(function (reference) {
                            if (reference && reference instanceof _PdfReference && reference._isNew) {
                                _this._crossReference._cacheMap.delete(reference);
                            }
                        });
                    }
                }
                if (action.has('F')) {
                    _removeDuplicateReference(action, this._crossReference, 'F');
                }
            }
            _removeDuplicateReference(this._dictionary, this._crossReference, 'A');
        }
        var dictionary = new _PdfDictionary();
        dictionary.set('Type', _PdfName.get('Action'));
        dictionary.set('S', _PdfName.get('Launch'));
        var fileDictionary = new _PdfDictionary();
        fileDictionary.set('Type', _PdfName.get('Filespec'));
        fileDictionary.set('UF', this._fileName);
        if (typeof this._action !== 'undefined' && this._action !== null) {
            var actionDictionary = new _PdfDictionary();
            actionDictionary.set('Type', _PdfName.get('Action'));
            actionDictionary.set('S', _PdfName.get('JavaScript'));
            actionDictionary.set('JS', this._action);
            var ref = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(ref, actionDictionary);
            actionDictionary._updated = true;
            dictionary.set('Next', [ref]);
        }
        var reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, fileDictionary);
        fileDictionary._updated = true;
        dictionary.set('F', reference);
        dictionary._updated = true;
        this._dictionary.set('A', dictionary);
    };
    PdfFileLinkAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (!this._isLoaded) {
            this._postProcess();
        }
        if (isFlatten) {
            var appearanceStream = void 0;
            if (this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                var template = new PdfTemplate(appearanceStream, this._crossReference);
                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    };
    return PdfFileLinkAnnotation;
}(PdfAnnotation));
/**
 * `PdfUriAnnotation` class represents the URI annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new URI annotation
 * let annotation: PdfUriAnnotation = new PdfUriAnnotation(100, 150, 200, 100, ‘http://www.google.com’);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfUriAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfUriAnnotation, _super);
    function PdfUriAnnotation(x, y, width, height, uri) {
        var _this = _super.call(this) || this;
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('Link'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            _this.bounds = { x: x, y: y, width: width, height: height };
        }
        if (typeof uri !== 'undefined' && uri !== null) {
            _this._uri = uri;
        }
        _this._type = _PdfAnnotationType.uriAnnotation;
        return _this;
    }
    Object.defineProperty(PdfUriAnnotation.prototype, "uri", {
        /**
         * Gets the uri of the annotation.
         *
         * @returns {string} Uri.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfUriAnnotation = page.annotations.at(0) as PdfUriAnnotation;
         * // Gets the uri of the annotation.
         * let uri: string = annotation.uri;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._uri === 'undefined' && this._dictionary.has('A')) {
                var linkDict = this._dictionary.get('A');
                if (linkDict.has('URI')) {
                    this._uri = linkDict.get('URI');
                }
            }
            return this._uri;
        },
        /**
         * Sets the uri of the annotation.
         *
         * @param {string} value Uri.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new URI annotation
         * let annotation: PdfUriAnnotation = new PdfUriAnnotation(100, 150, 200, 100);
         * // Sets the uri of the annotation
         * annotation.uri = ‘http://www.google.com’;
         * // Add annotation to the page
         * page.annotations.add(annotation);
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value === 'string') {
                if (this._isLoaded && this._dictionary.has('A') && value !== this.uri) {
                    var linkDict = this._dictionary.get('A');
                    if (linkDict.has('URI')) {
                        this._uri = value;
                        linkDict.update('URI', value);
                        this._dictionary._updated = true;
                    }
                }
                else {
                    this._uri = value;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfUriAnnotation._load = function (page, dictionary) {
        var annot = new PdfUriAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfUriAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfUriAnnotation.prototype._postProcess = function () {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        this._addAction();
        this._dictionary.update('Rect', _updateBounds(this));
    };
    PdfUriAnnotation.prototype._addAction = function () {
        var dictionary = new _PdfDictionary();
        dictionary.set('Type', _PdfName.get('Action'));
        dictionary.set('S', _PdfName.get('URI'));
        if (typeof this._uri !== 'undefined') {
            dictionary.set('URI', this._uri);
        }
        dictionary._updated = true;
        this._dictionary.set('A', dictionary);
        this._dictionary.update('Border', [this.border.hRadius, this.border.vRadius, this.border.width]);
    };
    PdfUriAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (!this._isLoaded) {
            this._postProcess();
        }
        if (isFlatten) {
            var appearanceStream = void 0;
            if (this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                var template = new PdfTemplate(appearanceStream, this._crossReference);
                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    };
    return PdfUriAnnotation;
}(PdfAnnotation));
/**
 * `PdfDocumentLinkAnnotation` class represents the document link annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new document link annotation
 * let annotation: PdfDocumentLinkAnnotation = new PdfDocumentLinkAnnotation(100, 150, 40, 60);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfDocumentLinkAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfDocumentLinkAnnotation, _super);
    function PdfDocumentLinkAnnotation(x, y, width, height) {
        var _this = _super.call(this) || this;
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('Link'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            _this.bounds = { x: x, y: y, width: width, height: height };
        }
        _this._type = _PdfAnnotationType.documentLinkAnnotation;
        return _this;
    }
    Object.defineProperty(PdfDocumentLinkAnnotation.prototype, "destination", {
        /**
         * Gets the destination of the annotation.
         *
         * @returns {PdfDestination} Destination.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfDocumentLinkAnnotation = page.annotations.at(0) as PdfDocumentLinkAnnotation;
         * // Gets the destination of the annotation.
         * let destination: PdfDestination =annotation.destination;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoaded && !this._destination) {
                this.destination = this._obtainDestination();
            }
            return this._destination;
        },
        /**
         * Sets the destination of the annotation.
         *
         * @param {PdfDestination} value Destination.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Access the annotation at index 0
         * let annotation: PdfDocumentLinkAnnotation = page.annotations.at(0) as PdfDocumentLinkAnnotation;
         * // Initializes a new instance of the `PdfDestination` class.
         * let destination: PdfDestination = new PdfDestination();
         * // Sets the zoom factor.
         * destination.zoom = 20;
         * // Sets the page where the destination is situated.
         * destination.page = page;
         * // Sets the mode of the destination.
         * destination.mode = PdfDestinationMode.fitToPage;
         * // Sets the location of the destination.
         * destination.location = [20, 20];
         * // Sets the bounds of the destination.
         * destination.destinationBounds = [20, 20, 100, 50];
         * // Sets destination to document link annotation.
         * annotation.destination = destination;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                this._destination = value;
                if (this._isLoaded) {
                    this._destination._initializePrimitive();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfDocumentLinkAnnotation._load = function (page, dictionary) {
        var annot = new PdfDocumentLinkAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfDocumentLinkAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfDocumentLinkAnnotation.prototype._postProcess = function () {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        this._addDocument();
        this._dictionary.update('Rect', _updateBounds(this));
    };
    PdfDocumentLinkAnnotation.prototype._obtainDestination = function () {
        if (this._dictionary.has('Dest')) {
            var array = this._dictionary.get('Dest'); // eslint-disable-line
            var holder = void 0;
            if (typeof array === 'string') {
                array = this._getDestination(array);
            }
            if (array && array[0] instanceof _PdfReference) {
                holder = array[0];
            }
            if ((typeof holder === 'undefined' || holder === null) && array && typeof array[0] === 'number') {
                var pageNumber = array[0];
                var page = this._crossReference._document.getPage(pageNumber);
                if (page) {
                    var mode = array[1];
                    if (mode.name === 'XYZ') {
                        var left = array[2];
                        var top_3 = array[3];
                        var zoom = array[4];
                        var topValue = (typeof top_3 !== 'undefined' && top_3 !== null) ? (page.size[1] - top_3) : 0;
                        var leftValue = (typeof left !== 'undefined' && left !== null) ? left : 0;
                        this._destination = new PdfDestination(page, [leftValue, topValue]);
                        if (typeof zoom !== 'undefined' && zoom !== null) {
                            this._destination.zoom = zoom;
                        }
                        if ((typeof left === 'undefined' && left === null) || (typeof top_3 === 'undefined' && top_3 === null)
                            || (typeof zoom === 'undefined' && zoom === null)) {
                            this._destination._setValidation(false);
                        }
                    }
                    else {
                        this._destination = new PdfDestination(page);
                        this._destination.mode = PdfDestinationMode.fitToPage;
                    }
                }
            }
            if (holder) {
                var index = _getPageIndex(this._crossReference._document, this._crossReference._fetch(holder));
                if (index >= 0) {
                    var page = this._crossReference._document.getPage(index);
                    if (page && array[1] instanceof _PdfName) {
                        var mode = array[1];
                        if (mode) {
                            if (mode.name === 'XYZ') {
                                var left = array[2];
                                var top_4 = array[3];
                                var zoom = array[4];
                                var topValue = (typeof top_4 !== 'undefined' && top_4 !== null) ? (page.size[1] - top_4) : 0;
                                var leftValue = (typeof left !== 'undefined' && left !== null) ? left : 0;
                                this._destination = new PdfDestination(page, [leftValue, topValue]);
                                if (typeof zoom !== 'undefined' && zoom !== null) {
                                    this._destination.zoom = zoom;
                                }
                                if ((typeof left === 'undefined' && left === null) || (typeof top_4 === 'undefined' && top_4 === null)
                                    || (typeof zoom === 'undefined' && zoom === null)) {
                                    this._destination._setValidation(false);
                                }
                            }
                            else if (mode.name === 'Fit') {
                                this._destination = new PdfDestination(page);
                                this._destination.mode = PdfDestinationMode.fitToPage;
                            }
                        }
                    }
                }
                else {
                    this._destination = new PdfDestination();
                    var zoom = array[4];
                    var mode = array[1];
                    if (typeof zoom !== 'undefined' && zoom !== null) {
                        this._destination.zoom = zoom;
                    }
                    if (mode.name === 'Fit') {
                        this._destination.mode = PdfDestinationMode.fitToPage;
                    }
                    else if (mode.name === 'XYZ') {
                        var left = array[2];
                        var topValue = array[3];
                        if ((typeof left === 'undefined' && left === null) || (typeof topValue === 'undefined' && topValue === null)
                            || (typeof zoom === 'undefined' && zoom === null)) {
                            this._destination._setValidation(false);
                        }
                    }
                    this._destination._index = index;
                }
            }
        }
        else if (this._dictionary.has('A') && !this._destination) {
            var action = this._dictionary.get('A');
            if (action.has('D')) {
                var reference = action.get('D'); // eslint-disable-line
                if (reference !== null && typeof reference !== 'undefined') {
                    var referenceArray = void 0; // eslint-disable-line
                    if (Array.isArray(reference)) {
                        referenceArray = reference;
                    }
                    else if (reference && reference instanceof _PdfReference) {
                        var referenceValue = this._crossReference._fetch(reference); // eslint-disable-line
                        if (Array.isArray(referenceValue)) {
                            referenceArray = referenceValue;
                        }
                    }
                    else if (typeof reference === 'string') {
                        referenceArray = this._getDestination(reference);
                    }
                    if (referenceArray && (referenceArray[0] instanceof _PdfReference || typeof referenceArray[0] === 'number')) {
                        var document_1 = this._crossReference._document;
                        var index = void 0;
                        if (referenceArray[0] instanceof _PdfReference) {
                            index = _getPageIndex(document_1, this._crossReference._fetch(referenceArray[0]));
                        }
                        else {
                            index = referenceArray[0];
                        }
                        var page = document_1.getPage(index);
                        if (page) {
                            var mode = referenceArray[1];
                            if (mode.name === 'FitBH' || mode.name === 'FitH') {
                                var top_5 = referenceArray[2];
                                var topValue = (typeof top_5 !== 'undefined' && top_5 !== null) ? (page.size[1] - top_5) : 0;
                                this._destination = new PdfDestination(page, [0, topValue]);
                                if (typeof top_5 === 'undefined' || top_5 === null) {
                                    this._destination._setValidation(false);
                                }
                            }
                            else if (mode.name === 'XYZ') {
                                var left = referenceArray[2];
                                var top_6 = referenceArray[3];
                                var zoom = referenceArray[4];
                                var topValue = (typeof top_6 !== 'undefined' && top_6 !== null) ? (page.size[1] - top_6) : 0;
                                var leftValue = (typeof left !== 'undefined' && left !== null) ? left : 0;
                                this._destination = new PdfDestination(page, [leftValue, topValue]);
                                if (typeof zoom !== 'undefined' && zoom !== null) {
                                    this._destination.zoom = zoom;
                                }
                                if ((typeof left !== 'undefined' && left !== null) || (typeof top_6 !== 'undefined' && top_6 !== null)
                                    || (typeof zoom !== 'undefined' && zoom !== null)) {
                                    this._destination._setValidation(false);
                                }
                            }
                            else if (mode.name === 'FitR') {
                                if (referenceArray.length === 6) {
                                    var left = referenceArray[2];
                                    var bottom = referenceArray[3];
                                    var right = referenceArray[4];
                                    var top_7 = referenceArray[5];
                                    this._destination = new PdfDestination(page, [left, bottom, right, top_7]);
                                }
                            }
                            else if (mode.name === 'Fit') {
                                this._destination = new PdfDestination(page);
                                this._destination.mode = PdfDestinationMode.fitToPage;
                            }
                        }
                    }
                }
            }
        }
        return this._destination;
    };
    PdfDocumentLinkAnnotation.prototype._getDestination = function (name) {
        var document = this._crossReference._document;
        var destinationArray; // eslint-disable-line
        if (document) {
            destinationArray = this._getNamedDestination(document, name);
        }
        return destinationArray;
    };
    PdfDocumentLinkAnnotation.prototype._getNamedDestination = function (document, result) {
        var destination; // eslint-disable-line
        var catalog = document._catalog;
        if (catalog && catalog._catalogDictionary && catalog._catalogDictionary.has('Names')) {
            var names = catalog._catalogDictionary.get('Names');
            if (names && names.has('Dests')) {
                var kids = names.get('Dests');
                if (kids) {
                    var ref = this._getNamedObjectFromTree(kids, result);
                    destination = this._extractDestination(ref, document);
                }
            }
        }
        return destination;
    };
    PdfDocumentLinkAnnotation.prototype._extractDestination = function (ref, document) {
        var dict; // eslint-disable-line
        var destinationArray; // eslint-disable-line
        if (ref && ref instanceof _PdfReference) {
            dict = document._crossReference._fetch(ref);
        }
        if (dict) {
            if (dict instanceof _PdfDictionary && dict.has('D')) {
                destinationArray = dict.getRaw('D');
            }
            else if (Array.isArray(dict)) {
                destinationArray = dict;
            }
        }
        return destinationArray ? destinationArray : ref;
    };
    PdfDocumentLinkAnnotation.prototype._getNamedObjectFromTree = function (kids, name) {
        var found = false;
        var currentDictionary = kids;
        var reference;
        while (!found && currentDictionary) {
            if (currentDictionary && currentDictionary.has('Kids')) {
                currentDictionary = this._getProperKid(currentDictionary, name);
            }
            else if (currentDictionary && currentDictionary.has('Names')) {
                reference = this._findName(currentDictionary, name);
                found = true;
            }
        }
        return reference;
    };
    PdfDocumentLinkAnnotation.prototype._findName = function (current, name) {
        var names = current.get('Names'); // eslint-disable-line
        var halfLength = names.length / 2;
        var lowerIndex = 0;
        var topIndex = halfLength - 1;
        var half = 0;
        var found = false;
        var destinationReference;
        while (!found) {
            half = Math.floor((lowerIndex + topIndex) / 2);
            if (lowerIndex > topIndex) {
                break;
            }
            var result = names[Number.parseInt(half.toString(), 10) * 2]; // eslint-disable-line
            if (result && result instanceof _PdfReference) {
                result = current._crossReference._fetch(result);
            }
            var cmp = this._stringCompare(name, result);
            if (cmp > 0) {
                lowerIndex = half + 1;
            }
            else if (cmp < 0) {
                topIndex = half - 1;
            }
            else {
                found = true;
                break;
            }
        }
        if (found) {
            destinationReference = names[half * 2 + 1];
        }
        return destinationReference;
    };
    PdfDocumentLinkAnnotation.prototype._getProperKid = function (kids, name) {
        var kidsArray; // eslint-disable-line
        var kid;
        if (kids && kids.has('Kids')) {
            kidsArray = kids.getRaw('Kids');
        }
        if (kidsArray && Array.isArray(kidsArray) && kidsArray.length !== 0) {
            kidsArray = kids.getArray('Kids');
            for (var i = 0; i < kidsArray.length; i++) {
                kid = kidsArray[Number.parseInt(i.toString(), 10)];
                if (this._checkLimits(kid, name)) {
                    break;
                }
            }
        }
        return kid;
    };
    PdfDocumentLinkAnnotation.prototype._checkLimits = function (kid, result) {
        var found = false;
        if (kid && kid.has('Limits')) {
            var limits = kid.get('Limits'); // eslint-disable-line
            var lowerLimit = limits[0];
            var higherLimit = limits[1];
            var lowCompare = this._stringCompare(lowerLimit, result);
            var highCompare = this._stringCompare(higherLimit, result);
            if (lowCompare === 0 || highCompare === 0) {
                found = true;
            }
            else if (lowCompare < 0 && highCompare > 0) {
                found = true;
            }
        }
        return found;
    };
    PdfDocumentLinkAnnotation.prototype._stringCompare = function (limits, result) {
        var byteArray = _stringToBytes(limits);
        var byteArray1 = _stringToBytes(result);
        var commonSize = Math.min(byteArray.length, byteArray1.length);
        var resultValue = 0;
        for (var i = 0; i < commonSize; i++) {
            var byte = byteArray[Number.parseInt(i.toString(), 10)];
            var byte1 = byteArray1[Number.parseInt(i.toString(), 10)];
            resultValue = byte - byte1;
            if (resultValue !== 0) {
                break;
            }
        }
        if (resultValue === 0) {
            resultValue = byteArray.length - byteArray1.length;
        }
        return resultValue;
    };
    PdfDocumentLinkAnnotation.prototype._addDocument = function () {
        if (this.destination) {
            this._dictionary.set('Dest', this.destination._array);
        }
    };
    PdfDocumentLinkAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (!this._isLoaded) {
            this._postProcess();
        }
        else if (this._destination) {
            this._dictionary.update('Dest', this._destination._array);
        }
        if (isFlatten) {
            var appearanceStream = void 0;
            if (this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                var template = new PdfTemplate(appearanceStream, this._crossReference);
                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    };
    return PdfDocumentLinkAnnotation;
}(PdfAnnotation));
/**
 * `PdfTextWebLinkAnnotation` class represents the link annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF string format
 * const format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.left, PdfVerticalAlignment.top);
 * // Create a new standard font
 * const font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);
 * // Get the text size
 * let size: number[] = font.measureString("Syncfusion Site", format, [0, 0], 0, 0);
 * // Create a new text web link annotation
 * let annot: PdfTextWebLinkAnnotation = new PdfTextWebLinkAnnotation(50, 40, size[0], size[1], [0, 0, 0], [165, 42, 42], 1);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfTextWebLinkAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfTextWebLinkAnnotation, _super);
    function PdfTextWebLinkAnnotation(x, y, width, height, brushColor, penColor, penWidth, text) {
        var _this = _super.call(this) || this;
        _this._isActionAdded = false;
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('Link'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            _this.bounds = { x: x, y: y, width: width, height: height };
        }
        _this._textWebLink = typeof text !== 'undefined' && text !== null ? text : '';
        if (typeof brushColor !== 'undefined' && brushColor !== null) {
            _this._brush = new PdfBrush(brushColor);
        }
        if (typeof penColor !== 'undefined' && penColor !== null) {
            _this._pen = new PdfPen(penColor, penWidth ? penWidth : 1);
        }
        _this._type = _PdfAnnotationType.textWebLinkAnnotation;
        return _this;
    }
    Object.defineProperty(PdfTextWebLinkAnnotation.prototype, "font", {
        /**
         * Gets the font of the annotation.
         *
         * @returns {PdfFont} font.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfTextWebLinkAnnotation = page.annotations.at(0) as PdfTextWebLinkAnnotation;
         * // Gets the font of the annotation.
         * let font: PdfFont = annotation.font;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._font;
        },
        /**
         * Sets the font of the annotation.
         *
         * @param {PdfFont} value font.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfTextWebLinkAnnotation = page.annotations.at(0) as PdfTextWebLinkAnnotation;
         * // Sets the font of the annotation.
         * annotation.font = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._font = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextWebLinkAnnotation.prototype, "url", {
        /**
         * Gets the url of the annotation.
         *
         * @returns {string} Url.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfTextWebLinkAnnotation = page.annotations.at(0) as PdfTextWebLinkAnnotation;
         * // Gets the URL of the annotation.
         * let url: string = annotation.url;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._url === 'undefined' && this._dictionary.has('A')) {
                var linkDict = this._dictionary.get('A');
                if (linkDict.has('URI')) {
                    this._url = linkDict.get('URI');
                }
            }
            return this._url;
        },
        /**
         * Sets the url of the annotation.
         *
         * @param {string} value Url.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfTextWebLinkAnnotation = page.annotations.at(0) as PdfTextWebLinkAnnotation;
         * // Sets the URL of the annotation.
         * annotation.url = ‘http://www.syncfusion.com’;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value === 'string') {
                if (this._isLoaded && this._dictionary.has('A')) {
                    var linkSource = this._dictionary._get('A'); // eslint-disable-line
                    var linkDict = this._dictionary.get('A');
                    if (linkDict && linkDict.has('URI')) {
                        this._url = value;
                        linkDict.update('URI', value);
                        if (!(linkSource instanceof _PdfReference)) {
                            this._dictionary._updated = linkDict._updated;
                        }
                    }
                }
                else {
                    this._url = value;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfTextWebLinkAnnotation._load = function (page, dictionary) {
        var annot = new PdfTextWebLinkAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfTextWebLinkAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfTextWebLinkAnnotation.prototype._postProcess = function () {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        if (!this._isActionAdded) {
            this._addAction();
            this._isActionAdded = true;
        }
        this._dictionary.update('Rect', _updateBounds(this));
    };
    PdfTextWebLinkAnnotation.prototype._addAction = function () {
        var rect = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];
        if (typeof this.font === 'undefined' || this.font === null) {
            this.font = this._lineCaptionFont;
        }
        var format = new PdfStringFormat(PdfTextAlignment.left, PdfVerticalAlignment.top);
        this._page.graphics.drawString(this._textWebLink, this.font, rect, this._pen, this._brush, format);
        var dictionary = new _PdfDictionary();
        dictionary.set('Type', _PdfName.get('Action'));
        dictionary.set('S', _PdfName.get('URI'));
        if (typeof this._url !== 'undefined') {
            dictionary.set('URI', this._url);
        }
        dictionary._updated = true;
        this._dictionary.set('A', dictionary);
        this._dictionary.update('Border', [0, 0, 0]);
    };
    PdfTextWebLinkAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (!this._isLoaded) {
            this._postProcess();
        }
        if (isFlatten) {
            var appearanceStream = void 0;
            if (this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                var template = new PdfTemplate(appearanceStream, this._crossReference);
                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    };
    return PdfTextWebLinkAnnotation;
}(PdfAnnotation));
/**
 * `PdfAttachmentAnnotation` class represents the attachment annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new attachment annotation
 * const annotation: PdfAttachmentAnnotation = new PdfAttachmentAnnotation(300, 200, 30, 30, "Nature.jpg", imageData);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAttachmentAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfAttachmentAnnotation, _super);
    function PdfAttachmentAnnotation(x, y, width, height, fileName, data) {
        var _this = _super.call(this) || this;
        _this._icon = PdfAttachmentIcon.pushPin;
        _this._iconString = '';
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('FileAttachment'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            _this.bounds = { x: x, y: y, width: width, height: height };
        }
        if (typeof fileName !== 'undefined') {
            _this._fileName = fileName;
        }
        _this._stream = new _PdfStream(typeof data === 'string' ? _decode(data) : data);
        _this._type = _PdfAnnotationType.fileAttachmentAnnotation;
        return _this;
    }
    Object.defineProperty(PdfAttachmentAnnotation.prototype, "icon", {
        /**
         * Gets the icon type of the attachment annotation.
         *
         * @returns {PdfAttachmentIcon} Annotation icon.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfAttachmentAnnotation = page.annotations.at(0) as PdfAttachmentAnnotation;
         * // Gets the icon type of the attachment annotation.
         * let icon: PdfAttachmentIcon = annotation.icon;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary.has('Name')) {
                this._icon = _mapAttachmentIcon(this._dictionary.get('Name').name);
            }
            return this._icon;
        },
        /**
         * Sets the icon type of the attachment annotation.
         *
         * @param {PdfAttachmentIcon} value Annotation icon.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as  PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfAttachmentAnnotation = page.annotations.at(0) as PdfAttachmentAnnotation;
         * // Sets the icon type of the attachment annotation.
         * annotation.icon = PdfAttachmentIcon.pushPin;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined') {
                this._icon = value;
                this._dictionary.update('Name', _PdfName.get(this._obtainIconName(this._icon)));
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfAttachmentAnnotation._load = function (page, dictionary) {
        var annot = new PdfAttachmentAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfAttachmentAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfAttachmentAnnotation.prototype._postProcess = function () {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        this._dictionary.update('Rect', _updateBounds(this));
        this._addAttachment();
    };
    PdfAttachmentAnnotation.prototype._addAttachment = function () {
        if (this._dictionary.has('FS')) {
            var fileSpecification = this._dictionary.get('FS');
            if (fileSpecification && fileSpecification.has('EF')) {
                var embeddedFile = fileSpecification.get('EF');
                if (embeddedFile && embeddedFile.has('F')) {
                    _removeDuplicateReference(embeddedFile, this._crossReference, 'F');
                }
            }
            _removeDuplicateReference(this._dictionary, this._crossReference, 'FS');
        }
        var fileSpectDictionary = new _PdfDictionary();
        fileSpectDictionary.set('Type', _PdfName.get('Filespec'));
        fileSpectDictionary.set('Desc', this._fileName);
        fileSpectDictionary.set('F', this._fileName);
        fileSpectDictionary.set('UF', this._fileName);
        var fileDictionary = new _PdfDictionary();
        fileDictionary.set('Type', _PdfName.get('EmbeddedFile'));
        var paramsDictionary = new _PdfDictionary();
        var dateTime = new Date();
        paramsDictionary.set('CreationDate', dateTime.toTimeString());
        paramsDictionary.set('ModDate', new Date().toTimeString());
        paramsDictionary.set('Size', this._stream.length);
        fileDictionary.set('Params', paramsDictionary);
        this._stream.dictionary = new _PdfDictionary();
        this._stream.dictionary = fileDictionary;
        fileDictionary._crossReference = this._crossReference;
        var char1 = this._crossReference._newLine.charCodeAt(0);
        var char2 = this._crossReference._newLine.charCodeAt(1);
        var buffer = [char1, char2, 37, 80, 68, 70, 45];
        fileDictionary._crossReference._writeObject(this._stream, buffer);
        var reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, this._stream);
        fileDictionary._updated = true;
        var efileDictionary = new _PdfDictionary();
        efileDictionary.set('F', reference);
        fileSpectDictionary.set('EF', efileDictionary);
        var fsReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(fsReference, fileSpectDictionary);
        fileSpectDictionary._updated = true;
        this._dictionary.update('FS', fsReference);
    };
    PdfAttachmentAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (!this._isLoaded) {
            this._postProcess();
        }
        if (isFlatten) {
            var appearanceStream = void 0;
            if (this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                var template = new PdfTemplate(appearanceStream, this._crossReference);
                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    };
    PdfAttachmentAnnotation.prototype._obtainIconName = function (icon) {
        switch (icon) {
            case PdfAttachmentIcon.pushPin:
                this._iconString = 'PushPin';
                break;
            case PdfAttachmentIcon.tag:
                this._iconString = 'Tag';
                break;
            case PdfAttachmentIcon.graph:
                this._iconString = 'Graph';
                break;
            case PdfAttachmentIcon.paperClip:
                this._iconString = 'Paperclip';
                break;
        }
        return this._iconString;
    };
    return PdfAttachmentAnnotation;
}(PdfComment));
/**
 * `Pdf3DAnnotation` class represents the 3D annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: Pdf3DAnnotation = page.annotations.at(0) as Pdf3DAnnotation;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var Pdf3DAnnotation = /** @class */ (function (_super) {
    __extends$6(Pdf3DAnnotation, _super);
    /**
     * Initializes a new instance of the `Pdf3DAnnotation` class.
     *
     * @private
     */
    function Pdf3DAnnotation() {
        var _this = _super.call(this) || this;
        _this._type = _PdfAnnotationType.movieAnnotation;
        return _this;
    }
    Pdf3DAnnotation._load = function (page, dictionary) {
        var annot = new Pdf3DAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    Pdf3DAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    Pdf3DAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (isFlatten) {
            var appearanceStream = void 0;
            if (this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                var template = new PdfTemplate(appearanceStream, this._crossReference);
                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    };
    return Pdf3DAnnotation;
}(PdfAnnotation));
/**
 * `PdfTextMarkupAnnotation` class represents the text markup annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new text markup annotation
 * let annotation: PdfTextMarkupAnnotation = new PdfTextMarkupAnnotation('Text markup', 50, 100, 100, 50);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfTextMarkupAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfTextMarkupAnnotation, _super);
    function PdfTextMarkupAnnotation(text, x, y, width, height) {
        var _this = _super.call(this) || this;
        _this._textMarkupType = PdfTextMarkupAnnotationType.highlight;
        _this._quadPoints = new Array(8);
        _this._boundsCollection = [];
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        if (typeof text !== 'undefined') {
            _this._text = text;
        }
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            _this.bounds = { x: x, y: y, width: width, height: height };
        }
        _this._type = _PdfAnnotationType.textMarkupAnnotation;
        return _this;
    }
    Object.defineProperty(PdfTextMarkupAnnotation.prototype, "bounds", {
        /**
         * Gets the bounds of the text markup annotation.
         *
         * @returns {{x: number, y: number, width: number, height: number}} Bounds.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;
         * // Gets the bounds of the annotation.
         * let bounds: {x: number, y: number, width: number, height: number} = annotation.bounds;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoaded) {
                this._bounds = _calculateBounds(this._dictionary, this._page);
            }
            return this._bounds;
        },
        /**
         * Sets the bounds of the text markup annotation.
         *
         * @param {{x: number, y: number, width: number, height: number}} value bounds.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;
         * // Sets the bounds of the annotation.
         * annotation.bounds = {x: 10, y: 10, width: 150, height: 5};
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                if (this._isLoaded) {
                    if ((value.x !== this.bounds.x) || (value.y !== this.bounds.y) ||
                        (value.width !== this.bounds.width) || (value.height !== this.bounds.height)) {
                        var size = this._page.size;
                        if (size) {
                            var y = size[1] - (value.y + value.height);
                            var height = y + value.height;
                            this._dictionary.update('Rect', [value.x, y, value.x + value.width, height]);
                            this._bounds = value;
                            this._isChanged = true;
                        }
                    }
                }
                else {
                    this._bounds = value;
                    var nativeRectangle = this._obtainNativeRectangle();
                    this._dictionary.update('Rect', _fromRectangle({ x: nativeRectangle[0], y: nativeRectangle[1], width: nativeRectangle[2], height: nativeRectangle[3] }));
                    this._isChanged = true;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextMarkupAnnotation.prototype, "textMarkUpColor", {
        /**
         * Gets the text markup color of the annotation.
         *
         * @returns {number[]} Text markup color as R, G, B color array in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;
         * // Gets the textMarkUp Color type of the attachment annotation.
         * let textMarkUpColor: number[] = annotation.textMarkUpColor;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._textMarkUpColor === 'undefined' && this._dictionary.has('C')) {
                this._textMarkUpColor = _parseColor(this._dictionary.getArray('C'));
            }
            return this._textMarkUpColor;
        },
        /**
         * Sets the text markup color of the annotation.
         *
         * @param {number[]} value R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;
         * // Sets the textMarkUp Color type of the attachment annotation.
         * annotation.textMarkUpColor = [255, 255, 255];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined' && value.length === 3) {
                var extColor = this.color;
                if (!this._isLoaded ||
                    typeof extColor === 'undefined' ||
                    (extColor[0] !== value[0] || extColor[1] !== value[1] || extColor[2] !== value[2])) {
                    this._color = value;
                    this._textMarkUpColor = value;
                    this._dictionary.update('C', [Number.parseFloat((value[0] / 255).toFixed(3)),
                        Number.parseFloat((value[1] / 255).toFixed(3)),
                        Number.parseFloat((value[2] / 255).toFixed(3))]);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextMarkupAnnotation.prototype, "textMarkupType", {
        /**
         * Gets the markup type of the annotation.
         *
         * @returns {PdfTextMarkupAnnotationType} Markup type.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;
         * // Gets the markup type of the annotation.
         * let textMarkupType: PdfTextMarkupAnnotationType = annotation.textMarkupType;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary.has('Subtype')) {
                var text = this._dictionary.get('Subtype');
                this._textMarkupType = _mapMarkupAnnotationType(text.name);
            }
            return this._textMarkupType;
        },
        /**
         * Sets the markup type of the annotation.
         *
         * @param {PdfTextMarkupAnnotationType} value Markup type.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;
         * // Sets the markup type of the annotation.
         * annotation.textMarkupType = PdfTextMarkupAnnotationType.squiggly;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined') {
                this._textMarkupType = value;
                this._dictionary.update('Subtype', _PdfName.get(_reverseMarkupAnnotationType(value)));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfTextMarkupAnnotation.prototype, "boundsCollection", {
        /**
         * Gets the markup bounds collection of the annotation.
         *
         * @returns {Array<number[]>} Markup bounds.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as  PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfTextMarkupAnnotation =  page.annotations.at(0) as PdfTextMarkupAnnotation;
         * // Gets the markup bounds collection of the annotation.
         * let boundsCollection : Array<number[]> = annotation.boundsCollection;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoaded) {
                var collection = [];
                if (this._dictionary.has('QuadPoints')) {
                    var points = this._dictionary.getArray('QuadPoints');
                    if (points && points.length > 0) {
                        var count = points.length / 8;
                        for (var i = 0; i < count; i++) {
                            var x = points[4 + (i * 8)] - points[i * 8];
                            var y = points[5 + (i * 8)] - points[1 + (i * 8)];
                            var height = Math.sqrt((x * x) + (y * y));
                            x = points[6 + (i * 8)] - points[4 + (i * 8)];
                            y = points[7 + (i * 8)] - points[5 + (i * 8)];
                            var width = Math.sqrt((x * x) + (y * y));
                            var rect = [points[i * 8], this._page.size[1] - points[1 + (i * 8)], width, height];
                            collection.push(rect);
                        }
                    }
                }
                return collection;
            }
            return this._boundsCollection;
        },
        /**
         * Sets the markup bounds collection of the annotation.
         *
         * @param {Array<number[]>} value Markup bounds.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;
         * // Sets the markup bounds collection of the  annotation.
         * annotation.boundsCollection = [[50, 50, 100, 100], [201, 101, 61, 31], [101, 401, 61, 31]];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (!this._isLoaded && typeof value !== 'undefined') {
                if (value.length > 0) {
                    this._quadPoints = new Array((value.length * 8));
                    for (var i = 0; i < value.length; i++) {
                        this._boundsCollection.push(value[Number.parseInt(i.toString(), 10)]);
                    }
                }
                else {
                    this._quadPoints = new Array(8);
                    this._boundsCollection = value;
                }
                this._isChanged = true;
            }
            if (this._isLoaded && typeof value !== 'undefined') {
                var isChanged = false;
                if (this.boundsCollection.length === value.length) {
                    for (var i = 0; i < value.length; i++) {
                        var values = value[Number.parseInt(i.toString(), 10)];
                        for (var j = 0; j < values.length; j++) {
                            if (value[Number.parseInt(i.toString(), 10)][Number.parseInt(j.toString(), 10)] !==
                                this.boundsCollection[Number.parseInt(i.toString(), 10)][Number.parseInt(j.toString(), 10)]) {
                                isChanged = true;
                                break;
                            }
                        }
                    }
                }
                else {
                    isChanged = true;
                }
                if (isChanged) {
                    this._quadPoints = new Array((value.length * 8));
                    var pageHeight = this._page.size[1];
                    for (var i = 0; i < value.length; i++) {
                        this._quadPoints[0 + (Number.parseInt(i.toString(), 10) * 8)] = value[Number.parseInt(i.toString(), 10)][0];
                        this._quadPoints[1 + (Number.parseInt(i.toString(), 10) * 8)] = pageHeight -
                            value[Number.parseInt(i.toString(), 10)][1];
                        this._quadPoints[2 + (Number.parseInt(i.toString(), 10) * 8)] = value[Number.parseInt(i.toString(), 10)][0] +
                            value[Number.parseInt(i.toString(), 10)][2];
                        this._quadPoints[3 + (Number.parseInt(i.toString(), 10) * 8)] = pageHeight -
                            value[Number.parseInt(i.toString(), 10)][1];
                        this._quadPoints[4 + (Number.parseInt(i.toString(), 10) * 8)] = value[Number.parseInt(i.toString(), 10)][0];
                        this._quadPoints[5 + (Number.parseInt(i.toString(), 10) * 8)] = this._quadPoints[1 + (i * 8)] -
                            value[Number.parseInt(i.toString(), 10)][3];
                        this._quadPoints[6 + (Number.parseInt(i.toString(), 10) * 8)] = value[Number.parseInt(i.toString(), 10)][0] +
                            value[Number.parseInt(i.toString(), 10)][2];
                        this._quadPoints[7 + (Number.parseInt(i.toString(), 10) * 8)] = this._quadPoints[5 +
                            (Number.parseInt(i.toString(), 10) * 8)];
                    }
                    this._dictionary.update('QuadPoints', this._quadPoints);
                    this._isChanged = true;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfTextMarkupAnnotation._load = function (page, dictionary) {
        var annot = new PdfTextMarkupAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfTextMarkupAnnotation.prototype._obtainNativeRectangle = function () {
        var nativeRectangle = [this._bounds.x, this._bounds.y + this._bounds.height, this._bounds.width, this._bounds.height];
        var cropOrMediaBox;
        if (this._page) {
            var size = this._page.size;
            nativeRectangle[1] = size[1] - nativeRectangle[1];
            cropOrMediaBox = this._getCropOrMediaBox();
        }
        if (cropOrMediaBox) {
            if (cropOrMediaBox[3] < 0) {
                var yCrop = cropOrMediaBox[1];
                var heightCrop = cropOrMediaBox[3];
                cropOrMediaBox[1] = heightCrop;
                cropOrMediaBox[3] = yCrop;
            }
            if (cropOrMediaBox.length > 2 && (cropOrMediaBox[0] !== 0 || cropOrMediaBox[1] !== 0)) {
                nativeRectangle[0] += cropOrMediaBox[0];
                if (this._page && this._page._pageDictionary.has('MediaBox') && !this._page._pageDictionary.has('CropBox') && cropOrMediaBox[1] > 0 && cropOrMediaBox[3] === 0) {
                    nativeRectangle[1] += cropOrMediaBox[3];
                }
                else {
                    nativeRectangle[1] += cropOrMediaBox[1];
                }
            }
        }
        return nativeRectangle;
    };
    PdfTextMarkupAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfTextMarkupAnnotation.prototype._postProcess = function () {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            dictionary.set('W', this.border.width);
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (!this._dictionary.has('C')) {
            this._isTransparentColor = true;
        }
        var size = this._page.size;
        this._dictionary.update('Subtype', _PdfName.get(_reverseMarkupAnnotationType(this._textMarkupType)));
        if (this._isChanged) {
            this._setQuadPoints(size);
            this._dictionary.update('Rect', _updateBounds(this));
        }
        if (this._setAppearance) {
            this._appearanceTemplate = this._createMarkupAppearance();
            if (!this._isLoaded && this._boundsCollection.length > 1 && this._isChanged) {
                var native = this._obtainNativeRectangle();
                this._dictionary.update('Rect', [native[0], native[1], native[0] + native[2], native[1] + native[3]]);
            }
            if (this._dictionary.has('AP')) {
                _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
            }
            var dictionary = new _PdfDictionary();
            this._appearanceTemplate._content.dictionary._updated = true;
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            this._appearanceTemplate._content.reference = reference;
            dictionary.set('N', reference);
            dictionary._updated = true;
            this._dictionary.set('AP', dictionary);
        }
        if (typeof this._text !== 'undefined' && this._text !== null) {
            this._dictionary.set('Contents', this._text);
        }
        this._isChanged = false;
    };
    PdfTextMarkupAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createMarkupAppearance();
                if (!isFlatten) {
                    if (this._dictionary.has('AP')) {
                        _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
                    }
                    var dictionary = new _PdfDictionary();
                    this._appearanceTemplate._content.dictionary._updated = true;
                    var reference = this._crossReference._getNextReference();
                    this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
                    this._appearanceTemplate._content.reference = reference;
                    dictionary.set('N', reference);
                    dictionary._updated = true;
                    this._dictionary.set('AP', dictionary);
                }
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    var appearanceStream = dictionary.get('N');
                    if (appearanceStream) {
                        var reference = dictionary.getRaw('N');
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess();
            if (!this._appearanceTemplate) {
                if (isFlatten) {
                    if (!this._dictionary.has('AP')) {
                        this._appearanceTemplate = this._createMarkupAppearance();
                    }
                    else {
                        var dictionary = this._dictionary.get('AP');
                        if (dictionary && dictionary.has('N')) {
                            var appearanceStream = dictionary.get('N');
                            if (appearanceStream) {
                                var reference = dictionary.getRaw('N');
                                if (reference) {
                                    appearanceStream.reference = reference;
                                }
                                this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                            }
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            if (!this._appearanceTemplate._content.dictionary.has('Matrix') && !this._isLoaded) {
                var box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                if (box) {
                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                }
            }
            if (isNormalMatrix && typeof this._page.rotation !== 'undefined' && this._page.rotation !== PdfRotationAngle.angle0) {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
            else if (isNormalMatrix && this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary, this._appearanceTemplate)) {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
            else if (!this._dictionary.has('AP') && this._appearanceTemplate) {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
        }
        else if (isFlatten) {
            this._page.annotations.remove(this);
        }
    };
    PdfTextMarkupAnnotation.prototype._createMarkupAppearance = function () {
        var width = 0;
        var height = 0;
        var rectangle;
        if (this.boundsCollection.length > 1) {
            var pdfPath = new PdfPath();
            for (var i = 0; i < this.boundsCollection.length; i++) {
                var bounds = [];
                bounds[0] = this.boundsCollection[Number.parseInt(i.toString(), 10)][0];
                bounds[1] = this.boundsCollection[Number.parseInt(i.toString(), 10)][1];
                bounds[2] = this.boundsCollection[Number.parseInt(i.toString(), 10)][2];
                bounds[3] = this.boundsCollection[Number.parseInt(i.toString(), 10)][3];
                pdfPath.addRectangle(bounds[0], bounds[1], bounds[2], bounds[3]);
            }
            var rect = pdfPath._getBounds();
            rectangle = { x: rect[0], y: rect[1], width: rect[2], height: rect[3] };
            this.bounds = rectangle;
            width = rectangle.width;
            height = rectangle.height;
        }
        else {
            if (this._dictionary.has('QuadPoints')) {
                var quadPoints = this._dictionary.get('QuadPoints');
                if (this._quadPoints !== null) {
                    for (var i = 0; i < (quadPoints.length / 8); i++) {
                        if (this._isLoaded) {
                            var point = new Array();
                            var j = 0;
                            for (var k = 0; k < quadPoints.length;) {
                                var x1 = quadPoints[Number.parseInt(k.toString(), 10)];
                                var y1 = quadPoints[k + 1];
                                point[Number.parseInt(j.toString(), 10)] = [x1, y1];
                                k = k + 2;
                                j++;
                            }
                            var path = new PdfPath();
                            path._addLines(point);
                            var rect = path._getBounds();
                            rectangle = { x: rect[0], y: rect[1], width: rect[2], height: rect[3] };
                            width = rectangle.width;
                            height = rectangle.height;
                        }
                        else {
                            var x = Math.floor(quadPoints[4 + (i * 8)]) - Math.floor(quadPoints[0 + (i * 8)]);
                            var y = Math.floor(quadPoints[5 + (i * 8)]) - Math.floor(quadPoints[1 + (i * 8)]);
                            height = Math.sqrt((x * x) + (y * y));
                            x = Math.floor(quadPoints[6 + (i * 8)]) - Math.floor(quadPoints[4 + (i * 8)]);
                            y = Math.floor(quadPoints[7 + (i * 8)]) - Math.floor(quadPoints[5 + (i * 8)]);
                            width = Math.sqrt((x * x) + (y * y));
                            this.bounds = { x: this.bounds.x, y: this.bounds.y, width: width, height: height };
                        }
                    }
                }
            }
        }
        var nativeRectangle = [0, 0, width, height];
        var template = new PdfTemplate(nativeRectangle, this._crossReference);
        _setMatrix(template, this._getRotationAngle());
        var graphics = template.graphics;
        if (typeof this.opacity !== 'undefined') {
            graphics.setTransparency(this.opacity, this.opacity, PdfBlendMode.multiply);
        }
        if (this.textMarkUpColor) {
            var pdfPen = new PdfPen(this.textMarkUpColor, this.border.width);
            var brush = new PdfBrush(this.textMarkUpColor);
            var x1 = 0;
            var y1 = 0;
            var w1 = 0;
            var h1 = 0;
            if (this.boundsCollection.length > 1) {
                for (var i = 0; i < this.boundsCollection.length; i++) {
                    var bounds = [];
                    bounds[0] = this.boundsCollection[Number.parseInt(i.toString(), 10)][0];
                    bounds[1] = this.boundsCollection[Number.parseInt(i.toString(), 10)][1];
                    bounds[2] = this.boundsCollection[Number.parseInt(i.toString(), 10)][2];
                    bounds[3] = this.boundsCollection[Number.parseInt(i.toString(), 10)][3];
                    if (this.textMarkupType === PdfTextMarkupAnnotationType.highlight) {
                        graphics.drawRectangle(bounds[0] - rectangle.x, bounds[1] - rectangle.y, bounds[2], bounds[3], brush);
                    }
                    else if (this.textMarkupType === PdfTextMarkupAnnotationType.underline) {
                        x1 = bounds[0] - rectangle.x;
                        y1 = (bounds[1] - rectangle.y) + (bounds[3] - ((bounds[3] / 2) / 3));
                        w1 = bounds[2] + (bounds[0] - rectangle.x);
                        h1 = (bounds[1] - rectangle.y) + (bounds[3] - ((bounds[3] / 2) / 3));
                        graphics.drawLine(pdfPen, x1, y1, w1, h1);
                    }
                    else if (this.textMarkupType === PdfTextMarkupAnnotationType.strikeOut) {
                        x1 = bounds[0] - rectangle.x;
                        y1 = (bounds[1] - rectangle.y) + (bounds[3] - (bounds[3] / 2));
                        w1 = bounds[2] + (bounds[0] - rectangle.x);
                        h1 = (bounds[1] - rectangle.y) + (bounds[3] - (bounds[3] / 2));
                        graphics.drawLine(pdfPen, x1, y1, w1, h1);
                    }
                    else if (this.textMarkupType === PdfTextMarkupAnnotationType.squiggly) {
                        pdfPen._width = bounds[3] * 0.02;
                        graphics.save();
                        graphics.translateTransform(bounds[0] - rectangle.x, (bounds[1] - rectangle.y));
                        graphics.setClip([0, 0, bounds[2], bounds[3]]);
                        graphics.drawPath(this._drawSquiggly(bounds[2], bounds[3]), pdfPen);
                        graphics.restore();
                    }
                }
            }
            else {
                if (this.textMarkupType === PdfTextMarkupAnnotationType.highlight) {
                    graphics.drawRectangle(0, 0, width, height, brush);
                }
                else if (this.textMarkupType === PdfTextMarkupAnnotationType.underline) {
                    graphics.drawLine(pdfPen, 0, height - ((height / 2) / 3), width, height - ((height / 2) / 3));
                }
                else if (this.textMarkupType === PdfTextMarkupAnnotationType.strikeOut) {
                    graphics.drawLine(pdfPen, 0, height / 2, width, height / 2);
                }
                else if (this.textMarkupType === PdfTextMarkupAnnotationType.squiggly) {
                    pdfPen._width = height * 0.02;
                    graphics.drawPath(this._drawSquiggly(Math.round(width), Math.round(height)), pdfPen);
                }
                if (this._isLoaded) {
                    var defaultRect = [rectangle.x, rectangle.y, rectangle.x + rectangle.width, rectangle.y + rectangle.height];
                    var rect = this._setAppearance ? _updateBounds(this) : defaultRect;
                    this._dictionary.update('Rect', rect);
                }
            }
        }
        return template;
    };
    PdfTextMarkupAnnotation.prototype._drawSquiggly = function (width, height) {
        if (Math.floor(width) % 2 !== 0 || Math.round(width) > width) {
            width = Math.floor(width) + 1;
        }
        var path = new PdfPath();
        var pathPoints = new Array();
        var pathPointsCount = Math.ceil((width / height) * 16);
        var length = width / (pathPointsCount / 2);
        var location = parseFloat(((length + length) * 0.6).toFixed(2));
        var zigZag = location;
        var x = 0;
        for (var i = 0; i < pathPointsCount; i++) {
            var y = ((height - location) + zigZag) - (height * 0.02);
            var temp = [x, parseFloat(y.toFixed(2))];
            pathPoints.push(temp);
            if (zigZag === 0) {
                zigZag = location;
            }
            else {
                zigZag = 0;
            }
            x = x + length;
        }
        path._addLines(pathPoints);
        return path;
    };
    PdfTextMarkupAnnotation.prototype._setQuadPoints = function (pageSize) {
        var textQuadLocation = [];
        var pageHeight = pageSize[1];
        var margins;
        if (this._page && this._page._isNew && this._page._pageSettings && this._page._pageSettings.margins) {
            var margin = this._page._pageSettings.margins;
            margins = { left: margin.left, top: margin.top, right: margin.right, bottom: margin.bottom };
        }
        else {
            margins = { left: 0, top: 0, right: 0, bottom: 0 };
        }
        if (this.bounds.x !== 0 && this.bounds.y !== 0 && this.bounds.width !== 0 && this.bounds.height !== 0) {
            this._boundsCollection[0] = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];
        }
        var noofRect = this._quadPoints.length / 8;
        var cropOrMediaBox = this._getMediaOrCropBox(this._page);
        var isContainscropOrMediaBox = false;
        if (!this._isLoaded && cropOrMediaBox && cropOrMediaBox.length > 3 && !this.flatten) {
            var cropOrMediaBoxX = cropOrMediaBox[0];
            var cropOrMediaBoxY = cropOrMediaBox[1];
            if (cropOrMediaBoxX !== 0 || cropOrMediaBoxY !== 0) {
                for (var i = 0; i < noofRect; i++) {
                    var locationX = this._boundsCollection[Number.parseInt(i.toString(), 10)][0] + margins.left + cropOrMediaBoxX;
                    var locationY = cropOrMediaBoxY + margins.top;
                    textQuadLocation[0 + (i * 8)] = locationX + margins.left;
                    textQuadLocation[1 + (i * 8)] = (pageHeight - (-locationY)) - margins.top -
                        this._boundsCollection[Number.parseInt(i.toString(), 10)][1];
                    textQuadLocation[2 + (i * 8)] = (locationX + this._boundsCollection[Number.parseInt(i.toString(), 10)][2]) +
                        margins.left;
                    textQuadLocation[3 + (i * 8)] = (pageHeight - (-locationY)) - margins.top -
                        this._boundsCollection[Number.parseInt(i.toString(), 10)][1];
                    textQuadLocation[4 + (i * 8)] = locationX + margins.left;
                    textQuadLocation[5 + (i * 8)] = (textQuadLocation[1 + (i * 8)] -
                        this._boundsCollection[Number.parseInt(i.toString(), 10)][3]);
                    textQuadLocation[6 + (i * 8)] = (locationX + this._boundsCollection[Number.parseInt(i.toString(), 10)][2]) +
                        margins.left;
                    textQuadLocation[7 + (i * 8)] = textQuadLocation[5 + (i * 8)];
                }
                isContainscropOrMediaBox = true;
            }
        }
        if (!isContainscropOrMediaBox) {
            for (var i = 0; i < noofRect; i++) {
                var locationX = this._boundsCollection[Number.parseInt(i.toString(), 10)][0];
                var locationY = this._boundsCollection[Number.parseInt(i.toString(), 10)][1];
                textQuadLocation[0 + (i * 8)] = locationX + margins.left;
                textQuadLocation[1 + (i * 8)] = (pageHeight - locationY) - margins.top;
                textQuadLocation[2 + (i * 8)] = (locationX + this._boundsCollection[Number.parseInt(i.toString(), 10)][2]) + margins.left;
                textQuadLocation[3 + (i * 8)] = (pageHeight - locationY) - margins.top;
                textQuadLocation[4 + (i * 8)] = locationX + margins.left;
                textQuadLocation[5 + (i * 8)] = (textQuadLocation[1 + (i * 8)] -
                    this._boundsCollection[Number.parseInt(i.toString(), 10)][3]);
                textQuadLocation[6 + (i * 8)] = (locationX + this._boundsCollection[Number.parseInt(i.toString(), 10)][2]) + margins.left;
                textQuadLocation[7 + (i * 8)] = textQuadLocation[5 + (i * 8)];
            }
        }
        this._points = textQuadLocation;
        this._dictionary.set('QuadPoints', this._points);
    };
    return PdfTextMarkupAnnotation;
}(PdfComment));
/**
 * `PdfWatermarkAnnotation` class represents the watermark annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new water mark annotation
 * const annotation: PdfWatermarkAnnotation = new PdfWatermarkAnnotation('Water Mark', 50, 100, 100, 50);
 * // Set the color of the annotation
 * annotation.color = [0, 0, 0];
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfWatermarkAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfWatermarkAnnotation, _super);
    function PdfWatermarkAnnotation(text, x, y, width, height) {
        var _this = _super.call(this) || this;
        _this._watermarkText = '';
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('Watermark'));
        if (typeof text !== 'undefined') {
            _this._watermarkText = text;
            _this.text = text;
        }
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            _this.bounds = { x: x, y: y, width: width, height: height };
        }
        _this._type = _PdfAnnotationType.watermarkAnnotation;
        return _this;
    }
    PdfWatermarkAnnotation._load = function (page, dictionary) {
        var annot = new PdfWatermarkAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfWatermarkAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfWatermarkAnnotation.prototype._postProcess = function () {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (typeof this.color === 'undefined') {
            this.color = [0, 0, 0];
        }
        this._appearanceTemplate = this._createWatermarkAppearance();
        this._dictionary.update('Rect', _updateBounds(this));
        if (typeof this.opacity !== 'undefined' && this._opacity !== 1.0) {
            this._dictionary.set('CA', this._opacity);
        }
    };
    PdfWatermarkAnnotation.prototype._createWatermarkAppearance = function () {
        var font = this._obtainFont();
        if ((typeof font === 'undefined' || font === null) || ((!this._isLoaded || (this._page && this._page._isDuplicate)) && font.size === 1)) {
            font = this._lineCaptionFont;
            this._pdfFont = font;
        }
        this._rotateAngle = this._getRotationAngle();
        if (typeof this.rotationAngle !== 'undefined' && this._rotate !== PdfRotationAngle.angle0 || this._rotateAngle !== PdfRotationAngle.angle0) {
            if (this._rotateAngle === 0) {
                this._rotateAngle = this.rotationAngle * 90;
            }
            this.bounds = this._getRotatedBounds(this.bounds, this._rotateAngle);
        }
        var nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];
        var appearance = new PdfAppearance(this, nativeRectangle);
        appearance.normal = new PdfTemplate(nativeRectangle, this._crossReference);
        var template = appearance.normal;
        _setMatrix(template, this._rotateAngle);
        var graphics = appearance.normal.graphics;
        var width = this.border.width / 2;
        var format = new PdfStringFormat(PdfTextAlignment.left, PdfVerticalAlignment.top);
        var borderPen = new PdfPen(this.color, width);
        var backBrush;
        if (this.innerColor) {
            backBrush = new PdfBrush(this._innerColor);
        }
        if (this._isLoaded) {
            if (this._dictionary.has('Contents')) {
                this._watermarkText = this._dictionary.get('Contents');
            }
            this._dictionary.update('Contents', this._watermarkText);
        }
        else {
            this._dictionary.update('Contents', this._watermarkText);
        }
        if (typeof this._watermarkText !== 'undefined') {
            graphics.drawString(this._watermarkText, font, [0, 0, 0, 0], borderPen, backBrush, format);
        }
        if (this._dictionary.has('AP')) {
            var dictionary_1 = this._dictionary.get('AP'); // eslint-disable-line
            if (dictionary_1 && dictionary_1 instanceof _PdfDictionary) {
                _removeDuplicateReference(dictionary_1, this._crossReference, 'N');
            }
        }
        var dictionary = new _PdfDictionary();
        graphics._template._content.dictionary._updated = true;
        var reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, graphics._template._content);
        graphics._template._content.reference = reference;
        dictionary.set('N', reference);
        dictionary._updated = true;
        this._dictionary.set('AP', dictionary);
        return template;
    };
    PdfWatermarkAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (this._isLoaded) {
            if (!isFlatten) {
                this._appearanceTemplate = this._createWatermarkAppearance();
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    var appearanceStream = dictionary.get('N');
                    if (appearanceStream) {
                        var reference = dictionary.getRaw('N');
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess();
            if (!this._appearanceTemplate) {
                if (isFlatten) {
                    if (!this._dictionary.has('AP')) {
                        this._appearanceTemplate = this._createWatermarkAppearance();
                    }
                    else {
                        var dictionary = this._dictionary.get('AP');
                        if (dictionary && dictionary.has('N')) {
                            var appearanceStream = dictionary.get('N');
                            if (appearanceStream) {
                                var reference = dictionary.getRaw('N');
                                if (reference) {
                                    appearanceStream.reference = reference;
                                }
                                this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                            }
                        }
                    }
                }
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {
                var box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                if (box) {
                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                }
            }
            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
        }
        else if (isFlatten) {
            this._page.annotations.remove(this);
        }
    };
    return PdfWatermarkAnnotation;
}(PdfAnnotation));
/**
 * `PdfRubberStampAnnotation` class represents the rubber stamp annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new rubber stamp annotation
 * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation (50, 100, 100, 50);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfRubberStampAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfRubberStampAnnotation, _super);
    function PdfRubberStampAnnotation(x, y, width, height) {
        var _this = _super.call(this) || this;
        _this._icon = PdfRubberStampAnnotationIcon.draft;
        _this._stampWidth = 0;
        _this._iconString = '';
        _this.rotateAngle = 0;
        _this._alterRotateBounds = true;
        _this._stampAppearanceFont = new PdfStandardFont(PdfFontFamily.helvetica, 20, PdfFontStyle.italic | PdfFontStyle.bold);
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('Stamp'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            _this.bounds = { x: x, y: y, width: width, height: height };
        }
        _this._type = _PdfAnnotationType.rubberStampAnnotation;
        return _this;
    }
    Object.defineProperty(PdfRubberStampAnnotation.prototype, "icon", {
        /**
         * Gets the icon type of the rubber stamp annotation.
         *
         * @returns {PdfRubberStampAnnotationIcon} Annotation icon.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRubberStampAnnotation = page.annotations.at(0) as PdfRubberStampAnnotation;
         * // Gets the icon type of the rubber stamp annotation.
         * let icon: PdfRubberStampAnnotationIcon = annotation.icon;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary.has('Name')) {
                this._icon = _mapRubberStampIcon(this._dictionary.get('Name').name);
            }
            return this._icon;
        },
        /**
         * Sets the icon type of the rubber stamp annotation.
         *
         * @param {PdfRubberStampAnnotationIcon} value Annotation icon.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRubberStampAnnotation = page.annotations.at(0) as PdfRubberStampAnnotation;
         * // Sets the icon type of the rubber stamp annotation.
         * annotation.icon = PdfRubberStampAnnotationIcon.completed;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined') {
                this._icon = value;
                this._dictionary.update('Name', _PdfName.get('#' + this._obtainIconName(this._icon)));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRubberStampAnnotation.prototype, "appearance", {
        /**
         * Get the appearance of the rubber stamp annotation. (Read only)
         *
         * @returns {PdfAppearance} Returns the appearance of the annotation.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Create a new rubber stamp annotation
         * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 100, 100, 50);
         * // Get the appearance of the annotation
         * let appearance: PdfAppearance = annotation.appearance;
         * // Access the normal template of the appearance
         * let template: PdfTemplate = appearance.normal;
         * // Create new image object by using JPEG image data as Base64 string format
         * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
         * // Draw the image as the custom appearance for the annotation
         * template.graphics.drawImage(image, 0, 0, 100, 50);
         * // Add annotation to the page
         * page.annotations.add(annotation);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoaded) {
                return null;
            }
            if (typeof this._appearance === 'undefined') {
                var nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];
                this._appearance = new PdfAppearance(this, nativeRectangle);
                this._appearance.normal = new PdfTemplate(nativeRectangle, this._crossReference);
            }
            return this._appearance;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create an appearance template for a rubber stamp annotation.
     *
     * @returns {PdfTemplate} Returns the appearance template of the annotation.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRubberStampAnnotation = page.annotations.at(0) as PdfRubberStampAnnotation;
     * // Gets the appearance template of the annotation.
     * let template: PdfTemplate = annotation.createTemplate();
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfRubberStampAnnotation.prototype.createTemplate = function () {
        var template;
        if (this._isLoaded) {
            if (this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    var appearanceStream = dictionary.get('N');
                    if (appearanceStream) {
                        template = new PdfTemplate();
                        template._isExported = true;
                        var templateDictionary = appearanceStream.dictionary;
                        var matrix = templateDictionary.getArray('Matrix');
                        var bounds = templateDictionary.getArray('BBox');
                        if (matrix) {
                            var mMatrix = [];
                            for (var i = 0; i < matrix.length; i++) {
                                var value = matrix[Number.parseInt(i.toString(), 10)];
                                mMatrix[Number.parseInt(i.toString(), 10)] = value;
                            }
                            if (bounds && bounds.length > 3) {
                                var rect = _toRectangle(bounds);
                                var rectangle = this._transformBBox(rect, mMatrix);
                                template._size = [rectangle[2], rectangle[3]];
                                template._templateOriginalSize = [rect.width, rect.height];
                            }
                        }
                        else if (bounds) {
                            templateDictionary.update('Matrix', [1, 0, 0, 1, -bounds[0], -bounds[1]]);
                            template._size = [bounds[2], bounds[3]];
                        }
                        template._exportStream(dictionary, this._crossReference);
                    }
                }
            }
            else {
                template = this._createRubberStampAppearance();
            }
        }
        return template;
    };
    Object.defineProperty(PdfRubberStampAnnotation.prototype, "_innerTemplateBounds", {
        get: function () {
            var innerBounds;
            if (this._isLoaded) {
                innerBounds = this._obtainInnerBounds();
                innerBounds.x = this.bounds.x;
                innerBounds.y = this.bounds.y;
            }
            return innerBounds;
        },
        enumerable: true,
        configurable: true
    });
    PdfRubberStampAnnotation._load = function (page, dictionary) {
        var annot = new PdfRubberStampAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfRubberStampAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfRubberStampAnnotation.prototype._postProcess = function () {
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (!this._dictionary.has('C')) {
            this._isTransparentColor = true;
        }
        if (this._dictionary.has('AP') && this._isLoaded && !this._isRotated) {
            this._parseStampAppearance();
        }
        else {
            this._appearanceTemplate = this._createRubberStampAppearance();
        }
    };
    PdfRubberStampAnnotation.prototype._transformBBox = function (bBoxValue, matrix) {
        var xCoordinate = [];
        var yCoordinate = [];
        var point1 = this._transformPoint(bBoxValue.x, bBoxValue.y + bBoxValue.height, matrix);
        xCoordinate[0] = point1[0];
        yCoordinate[0] = point1[1];
        var point2 = this._transformPoint(bBoxValue.x + bBoxValue.width, bBoxValue.y, matrix);
        xCoordinate[1] = point2[0];
        yCoordinate[1] = point2[1];
        var point3 = this._transformPoint(bBoxValue.x, bBoxValue.y, matrix);
        xCoordinate[2] = point3[0];
        yCoordinate[2] = point3[1];
        var point4 = this._transformPoint(bBoxValue.x + bBoxValue.width, bBoxValue.y + bBoxValue.height, matrix);
        xCoordinate[3] = point4[0];
        yCoordinate[3] = point4[1];
        var rect = [this._minValue(xCoordinate), this._minValue(yCoordinate),
            this._maxValue(xCoordinate), this._maxValue(yCoordinate)];
        return rect;
    };
    PdfRubberStampAnnotation.prototype._transformPoint = function (x, y, matrix) {
        var point = [];
        point[0] = x * matrix[0] + y * matrix[2] + matrix[4];
        point[1] = x * matrix[1] + y * matrix[3] + matrix[5];
        return point;
    };
    PdfRubberStampAnnotation.prototype._minValue = function (values) {
        var minimum = values[0];
        for (var i = 1; i < values.length; i++) {
            if (values[Number.parseInt(i.toString(), 10)] < minimum) {
                minimum = values[Number.parseInt(i.toString(), 10)];
            }
        }
        return minimum;
    };
    PdfRubberStampAnnotation.prototype._maxValue = function (values) {
        var maximum = values[0];
        for (var i = 1; i < values.length; i++) {
            if (values[Number.parseInt(i.toString(), 10)] > maximum) {
                maximum = values[Number.parseInt(i.toString(), 10)];
            }
        }
        return maximum;
    };
    PdfRubberStampAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        var isTransformBBox = false;
        if (this._isLoaded && (this._setAppearance || isFlatten || this._isExport)) {
            if ((!isFlatten && !this._isExport) || this._setAppearance || this._isRotated) {
                this._appearanceTemplate = this._createRubberStampAppearance();
            }
            if (!this._appearanceTemplate && (this._isExport || isFlatten) && this._dictionary.has('AP')) {
                isTransformBBox = this._parseStampAppearance();
            }
        }
        else {
            if (!(this._isImported && this._dictionary.has('AP'))) {
                this._postProcess();
            }
            if ((!this._appearanceTemplate) && (isFlatten || this._isImported)) {
                if (!this._dictionary.has('AP')) {
                    this._appearanceTemplate = this._createRubberStampAppearance();
                }
                else {
                    var dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        var appearanceStream = dictionary.get('N');
                        if (appearanceStream) {
                            var reference = dictionary.getRaw('N');
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {
                var box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                if (box) {
                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                }
            }
            if (isTransformBBox) {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isTransformBBox);
            }
            else {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
        }
        else if (isFlatten) {
            this._page.annotations.remove(this);
        }
    };
    PdfRubberStampAnnotation.prototype._parseStampAppearance = function () {
        var isTransformBBox = false;
        var dictionary = this._dictionary.get('AP');
        if (dictionary && dictionary.has('N')) {
            var appearanceStream = dictionary.get('N');
            if (appearanceStream) {
                var reference = dictionary.getRaw('N');
                if (reference) {
                    appearanceStream.reference = reference;
                }
                var isStamp = false;
                if (this._type === _PdfAnnotationType.rubberStampAnnotation) {
                    var isRotated = false;
                    var size = void 0;
                    var rect = void 0;
                    if (appearanceStream) {
                        isRotated = (this._page.rotation === PdfRotationAngle.angle0 &&
                            this.rotationAngle === PdfRotationAngle.angle0);
                        if (!isRotated) {
                            isRotated = (this._page.rotation !== PdfRotationAngle.angle0 &&
                                this.rotationAngle === PdfRotationAngle.angle0);
                        }
                    }
                    this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    isStamp = true;
                    isTransformBBox = isRotated ? true : false;
                    if (isTransformBBox) {
                        var matrix = appearanceStream.dictionary.getArray('Matrix');
                        if (matrix) {
                            var mMatrix = [];
                            for (var i = 0; i < matrix.length; i++) {
                                var value = matrix[Number.parseInt(i.toString(), 10)];
                                mMatrix[Number.parseInt(i.toString(), 10)] = value;
                            }
                            var bounds = appearanceStream.dictionary.getArray('BBox');
                            if (bounds && bounds.length > 3) {
                                rect = _toRectangle(bounds);
                                var rectangle = this._transformBBox(rect, mMatrix);
                                size = [rectangle[2], rectangle[3]];
                                this._appearanceTemplate._size = size;
                            }
                            else {
                                size = [rect.width, rect.height];
                            }
                        }
                    }
                    else if (rect) {
                        size = [rect.width, rect.height];
                    }
                }
                if (!isStamp) {
                    this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                }
            }
        }
        return isTransformBBox;
    };
    PdfRubberStampAnnotation.prototype._createRubberStampAppearance = function () {
        var nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];
        var appearance;
        if (this._appearance) {
            appearance = this._appearance;
            if (!this._dictionary.has('Name')) {
                this._dictionary.update('Name', _PdfName.get('#23CustomStamp'));
            }
        }
        else {
            this._iconString = this._obtainIconName(this.icon);
            this._dictionary.update('Name', _PdfName.get('#23' + this._iconString));
            appearance = new PdfAppearance(this, nativeRectangle);
            appearance.normal = new PdfTemplate(nativeRectangle, this._crossReference);
        }
        var template = appearance.normal;
        if (this._alterRotateBounds && typeof this._rotate !== 'undefined' && (this._rotate !== PdfRotationAngle.angle0 || this._getRotationAngle() !== 0)) {
            this.rotateAngle = this._getRotationAngle();
            if (this.rotateAngle === 0) {
                this.rotateAngle = this.rotationAngle * 90;
            }
            this.bounds = this._getRotatedBounds(this.bounds, this.rotateAngle);
        }
        else {
            this.rotateAngle = this._getRotationAngle();
        }
        _setMatrix(template, this.rotateAngle);
        if (!this._appearance) {
            this._drawStampAppearance(template);
        }
        if (this._dictionary.has('AP')) {
            _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
        }
        var dictionary = new _PdfDictionary();
        template._content.dictionary._updated = true;
        var reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, template._content);
        template._content.reference = reference;
        dictionary.set('N', reference);
        dictionary._updated = true;
        this._dictionary.set('AP', dictionary);
        this._dictionary.set('Border', [this.border.hRadius, this.border.vRadius, this.border.width]);
        this._dictionary.update('Rect', _updateBounds(this));
        return template;
    };
    PdfRubberStampAnnotation.prototype._drawStampAppearance = function (template) {
        var stringFormat = new PdfStringFormat();
        stringFormat.alignment = PdfTextAlignment.center;
        stringFormat.lineAlignment = PdfVerticalAlignment.middle;
        var backBrush = new PdfBrush(this._obtainBackGroundColor());
        var borderPen = new PdfPen(this._obtainBorderColor(), this.border.width);
        var graphics = template.graphics;
        graphics.save();
        graphics.scaleTransform(template._size[0] / (this._stampWidth + 4), (template._size[1] / 28));
        var rubberFont = this._stampAppearanceFont;
        this._drawRubberStamp(graphics, borderPen, backBrush, rubberFont, stringFormat);
        graphics.restore();
    };
    PdfRubberStampAnnotation.prototype._obtainIconName = function (icon) {
        switch (icon) {
            case PdfRubberStampAnnotationIcon.approved:
                this._iconString = 'Approved';
                this._stampWidth = 126;
                break;
            case PdfRubberStampAnnotationIcon.asIs:
                this._iconString = 'AsIs';
                this._stampWidth = 75;
                break;
            case PdfRubberStampAnnotationIcon.confidential:
                this._iconString = 'Confidential';
                this._stampWidth = 166;
                break;
            case PdfRubberStampAnnotationIcon.departmental:
                this._iconString = 'Departmental';
                this._stampWidth = 186;
                break;
            case PdfRubberStampAnnotationIcon.draft:
                this._iconString = 'Draft';
                this._stampWidth = 90;
                break;
            case PdfRubberStampAnnotationIcon.experimental:
                this._iconString = 'Experimental';
                this._stampWidth = 176;
                break;
            case PdfRubberStampAnnotationIcon.expired:
                this._iconString = 'Expired';
                this._stampWidth = 116;
                break;
            case PdfRubberStampAnnotationIcon.final:
                this._iconString = 'Final';
                this._stampWidth = 90;
                break;
            case PdfRubberStampAnnotationIcon.forComment:
                this._iconString = 'ForComment';
                this._stampWidth = 166;
                break;
            case PdfRubberStampAnnotationIcon.forPublicRelease:
                this._iconString = 'ForPublicRelease';
                this._stampWidth = 240;
                break;
            case PdfRubberStampAnnotationIcon.notApproved:
                this._iconString = 'NotApproved';
                this._stampWidth = 186;
                break;
            case PdfRubberStampAnnotationIcon.notForPublicRelease:
                this._iconString = 'NotForPublicRelease';
                this._stampWidth = 290;
                break;
            case PdfRubberStampAnnotationIcon.sold:
                this._iconString = 'Sold';
                this._stampWidth = 75;
                break;
            case PdfRubberStampAnnotationIcon.topSecret:
                this._iconString = 'TopSecret';
                this._stampWidth = 146;
                break;
            case PdfRubberStampAnnotationIcon.completed:
                this._iconString = 'Completed';
                this._stampWidth = 136;
                break;
            case PdfRubberStampAnnotationIcon.void:
                this._iconString = 'Void';
                this._stampWidth = 75;
                break;
            case PdfRubberStampAnnotationIcon.informationOnly:
                this._iconString = 'InformationOnly';
                this._stampWidth = 230;
                break;
            case PdfRubberStampAnnotationIcon.preliminaryResults:
                this._iconString = 'PreliminaryResults';
                this._stampWidth = 260;
                break;
        }
        return this._iconString;
    };
    PdfRubberStampAnnotation.prototype._obtainBackGroundColor = function () {
        var color = [];
        var red;
        var green;
        var blue;
        if (this._icon === PdfRubberStampAnnotationIcon.notApproved ||
            this._icon === PdfRubberStampAnnotationIcon.void) {
            red = 251;
            green = 222;
            blue = 221;
            color = [red, green, blue];
        }
        else if (this._icon === PdfRubberStampAnnotationIcon.approved ||
            this._icon === PdfRubberStampAnnotationIcon.final ||
            this._icon === PdfRubberStampAnnotationIcon.completed) {
            red = 229;
            green = 238;
            blue = 222;
            color = [red, green, blue];
        }
        else {
            red = 219;
            green = 227;
            blue = 240;
            color = [red, green, blue];
        }
        return color;
    };
    PdfRubberStampAnnotation.prototype._obtainBorderColor = function () {
        var color = [];
        var red;
        var green;
        var blue;
        if (this._icon === PdfRubberStampAnnotationIcon.notApproved ||
            this._icon === PdfRubberStampAnnotationIcon.void) {
            red = 151;
            green = 23;
            blue = 15;
            color = [red, green, blue];
        }
        else if (this._icon === PdfRubberStampAnnotationIcon.approved ||
            this._icon === PdfRubberStampAnnotationIcon.final ||
            this._icon === PdfRubberStampAnnotationIcon.completed) {
            red = 73;
            green = 110;
            blue = 38;
            color = [red, green, blue];
        }
        else {
            red = 24;
            green = 37;
            blue = 100;
            color = [red, green, blue];
        }
        return color;
    };
    PdfRubberStampAnnotation.prototype._drawRubberStamp = function (graphics, pen, brush, font, format) {
        graphics.drawRoundedRectangle(2, 1, this._stampWidth, 26, 3, pen, brush);
        var pdfBrush = new PdfBrush(this._obtainBorderColor());
        graphics.drawString(this._iconString.toUpperCase(), font, [(this._stampWidth / 2) + 1, 15, 0, 0], null, pdfBrush, format);
    };
    PdfRubberStampAnnotation.prototype._obtainInnerBounds = function () {
        var bounds = { x: 0, y: 0, width: 0, height: 0 };
        if (this._dictionary && this._dictionary.has('AP')) {
            var appearanceDictionary = this._dictionary.get('AP');
            if (appearanceDictionary && appearanceDictionary.has('N')) {
                var normalAppearance = appearanceDictionary.get('N');
                if (normalAppearance && typeof normalAppearance.dictionary !== 'undefined') {
                    var normalAppearanceDictionary = normalAppearance.dictionary;
                    if (normalAppearanceDictionary.has('BBox')) {
                        var values = normalAppearanceDictionary.getArray('BBox');
                        if (values && values.length === 4) {
                            bounds = _toRectangle(values);
                        }
                    }
                }
            }
        }
        return bounds;
    };
    return PdfRubberStampAnnotation;
}(PdfComment));
/**
 * `PdfSoundAnnotation` class represents the sound annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfSoundAnnotation = page.annotations.at(0) as PdfSoundAnnotation;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfSoundAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfSoundAnnotation, _super);
    /**
     * Initializes a new instance of the `PdfSoundAnnotation` class.
     *
     * @private
     */
    function PdfSoundAnnotation() {
        var _this = _super.call(this) || this;
        _this._type = _PdfAnnotationType.soundAnnotation;
        return _this;
    }
    PdfSoundAnnotation._load = function (page, dictionary) {
        var annot = new PdfSoundAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfSoundAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfSoundAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (isFlatten) {
            var appearanceStream = void 0;
            if (this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                var template = new PdfTemplate(appearanceStream, this._crossReference);
                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    };
    return PdfSoundAnnotation;
}(PdfComment));
/**
 * `PdfFreeTextAnnotation` class represents the free text annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new free text annotation
 * const annotation: PdfFreeTextAnnotation = new PdfFreeTextAnnotation(50, 100, 100, 50);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfFreeTextAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfFreeTextAnnotation, _super);
    function PdfFreeTextAnnotation(x, y, width, height) {
        var _this = _super.call(this) || this;
        _this._intentString = '';
        _this._markUpFont = new PdfStandardFont(PdfFontFamily.helvetica, 7, PdfFontStyle.regular);
        _this._textAlignment = PdfTextAlignment.left;
        _this._cropBoxValueX = 0;
        _this._cropBoxValueY = 0;
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('FreeText'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            _this.bounds = { x: x, y: y, width: width, height: height };
        }
        _this._isContentUpdated = false;
        _this._type = _PdfAnnotationType.freeTextAnnotation;
        _this._parsedXMLData = [];
        return _this;
    }
    Object.defineProperty(PdfFreeTextAnnotation.prototype, "calloutLines", {
        /**
         * Gets the callout lines of the free text annotation.
         *
         * @returns {Array<number[]>} Callout lines.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFreeTextAnnotation= page.annotations.at(0) as PdfFreeTextAnnotation;
         * // Gets the callout lines of the free text annotation.
         * let calloutLines: Array<number[]> = annotation.calloutLines;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._calloutLines === 'undefined') {
                this._calloutLines = this._getCalloutLinePoints();
            }
            return this._calloutLines;
        },
        /**
         * Sets the callout lines of the free text annotation.
         *
         * @param {Array<number[]>} value Callout lines.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
         * // Sets the callout lines of the free text annotation.
         * annotation.calloutLines = [[100, 450], [100, 200], [100, 150]];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (!this._isLoaded) {
                this._calloutLines = value;
            }
            var isChanged = false;
            if (this._isLoaded && value.length >= 2) {
                if (this._calloutLines.length === value.length) {
                    for (var i = 0; i < value.length; i++) {
                        var values = value[Number.parseInt(i.toString(), 10)];
                        for (var j = 0; j < values.length; j++) {
                            if (value[Number.parseInt(i.toString(), 10)][Number.parseInt(j.toString(), 10)] !==
                                this._calloutLines[Number.parseInt(i.toString(), 10)][Number.parseInt(j.toString(), 10)]) {
                                isChanged = true;
                                break;
                            }
                        }
                    }
                }
                else {
                    isChanged = true;
                }
            }
            if (isChanged) {
                var pageHeight = this._page.size[1];
                var lines = [];
                for (var i = 0; i < value.length; i++) {
                    if (i < value.length) {
                        lines.push(value[Number.parseInt(i.toString(), 10)][0] + this._cropBoxValueX);
                        lines.push((pageHeight + this._cropBoxValueY) - value[Number.parseInt(i.toString(), 10)][1]);
                    }
                    else {
                        break;
                    }
                }
                this._calloutLines = value;
                this._dictionary.update('CL', lines);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFreeTextAnnotation.prototype, "lineEndingStyle", {
        /**
         * Gets the line ending style of the annotation.
         *
         * @returns {PdfLineEndingStyle} Line ending style.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
         * // Gets the Line ending style of the annotation.
         * let lineEndingStyle: PdfLineEndingStyle = annotation.lineEndingStyle;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoaded) {
                this._lineEndingStyle = this._obtainLineEndingStyle();
            }
            else if (typeof this._lineEndingStyle === 'undefined') {
                this._lineEndingStyle = PdfLineEndingStyle.none;
            }
            return this._lineEndingStyle;
        },
        /**
         * Sets the line ending style of the line annotation.
         *
         * @param {PdfLineEndingStyle} value Line ending style.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
         * // Sets the line ending style of the line annotation.
         * annotation.lineEndingStyle = PdfLineEndingStyle.closedArrow;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined') {
                this._dictionary.update('LE', _PdfName.get(_reverseMapEndingStyle(value)));
            }
            this._lineEndingStyle = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFreeTextAnnotation.prototype, "textMarkUpColor", {
        /**
         * Gets the text markup color of the annotation.
         *
         * @returns {number[]} Text markup color as R, G, B color array in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
         * // Gets the text markup color of the annotation.
         * let textMarkUpColor: number[] = annotation.textMarkUpColor;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._textMarkUpColor === 'undefined') {
                var color = void 0;
                if (this._dictionary.has('TextColor')) {
                    this._textMarkUpColor = _parseColor(this._dictionary.getArray('TextColor'));
                    return this._textMarkUpColor;
                }
                if (this._dictionary.has('DS')) {
                    var collections = this._dictionary.get('DS').split(';');
                    for (var i = 0; i < collections.length; i++) {
                        if (collections[Number.parseInt(i.toString(), 10)].indexOf('color') !== -1) {
                            color = collections[Number.parseInt(i.toString(), 10)].split(':')[1];
                            if (color.startsWith('#')) {
                                color = color.substring(1);
                            }
                            this._textMarkUpColor = _convertToColor(color);
                            return this._textMarkUpColor;
                        }
                    }
                }
                if (!this._textMarkUpColor && this._dictionary.has('RC')) {
                    var rcBrush = void 0;
                    var rcColor = [];
                    if (this._parsedXMLData.length > 0 && this._parsedXMLData[3]) {
                        rcBrush = this._parsedXMLData[3];
                        rcColor = rcBrush._color;
                        this._textMarkUpColor = rcColor;
                    }
                }
            }
            return this._textMarkUpColor;
        },
        /**
         * Sets the text markup color of the annotation.
         *
         * @param {number[]} value R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
         * // Sets the text markup color of the annotation.
         * annotation.textMarkUpColor = [200, 200, 200];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined' && value.length === 3) {
                this._textMarkUpColor = value;
                this._updateStyle(this.font, value, this.textAlignment);
            }
            this._isContentUpdated = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFreeTextAnnotation.prototype, "textAlignment", {
        /**
         * Gets the text alignment of the annotation.
         *
         * @returns {PdfTextAlignment} Text alignment.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
         * // Gets the text alignment of the annotation.
         * let textAlignment: PdfTextAlignment = annotation.textAlignment;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary.has('Q')) {
                this._textAlignment = this._dictionary.get('Q');
            }
            else if (this._dictionary.has('RC')) {
                var rcAlignment = void 0;
                if (this._parsedXMLData.length > 0 && this._parsedXMLData[1]) {
                    rcAlignment = this._parsedXMLData[1];
                    this._textAlignment = rcAlignment;
                }
            }
            return this._textAlignment;
        },
        /**
         * Sets the text alignment of the annotation.
         *
         * @param {PdfTextAlignment} value Text alignment.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
         * // Sets the text alignment of the annotation.
         * annotation.textAlignment = PdfTextAlignment.justify;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._textAlignment !== value) {
                this._dictionary.update('Q', value);
            }
            this._textAlignment = value;
            this._isContentUpdated = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFreeTextAnnotation.prototype, "font", {
        /**
         * Gets the font of the annotation.
         *
         * @returns {PdfFont} font.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
         * // Gets the font of the annotation.
         * let font: PdfFont = annotation.font;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._font) {
                this._font = this._obtainFont();
                if ((this._font === null || typeof this._font === 'undefined') || (!this._isLoaded && this._font.size === 1)) {
                    this._font = this._markUpFont;
                }
            }
            return this._font;
        },
        /**
         * Sets the font of the annotation.
         *
         * @param {PdfFont} value font.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
         * // Sets the font of the annotation.
         * annotation.font = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._font = value;
            this._isContentUpdated = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFreeTextAnnotation.prototype, "borderColor", {
        /**
         * Gets the border color of the annotation.
         *
         * @returns {number[]} R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
         * // Gets the border color of the annotation.
         * let borderColor: number[] = annotation.borderColor;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._borderColor === 'undefined' && this._dictionary.has('DA')) {
                this._borderColor = this._obtainColor();
            }
            return this._borderColor;
        },
        /**
         * Sets the border color of the annotation.
         *
         * @param {number[]} value R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
         * // Sets the border color of the annotation.
         * annotation.borderColor = [150, 150, 150];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined' && value.length === 3) {
                this._borderColor = value;
                this._dictionary.update('DA', this._getBorderColorString(this.borderColor));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFreeTextAnnotation.prototype, "annotationIntent", {
        /**
         * Gets the intent of the annotation.
         *
         * @returns {PdfAnnotationIntent} Annotation intent.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
         * // Gets the intent of the annotation.
         * let annotationIntent: PdfAnnotationIntent = annotation.annotationIntent;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary.has('IT')) {
                this._annotationIntent = _mapAnnotationIntent(this._dictionary.get('IT').name);
            }
            else {
                this._annotationIntent = PdfAnnotationIntent.none;
            }
            return this._annotationIntent;
        },
        /**
         * Sets the intent of the annotation.
         *
         * @param {PdfAnnotationIntent} value Annotation intent.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
         * // Sets the intent of the annotation.
         * annotation.annotationIntent = PdfAnnotationIntent.freeTextTypeWriter;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined') {
                this._annotationIntent = value;
                if (value === PdfAnnotationIntent.none) {
                    this._dictionary.update('Subj', 'Text Box');
                }
                else {
                    this._dictionary.update('IT', _PdfName.get(this._obtainAnnotationIntent(this._annotationIntent)));
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFreeTextAnnotation.prototype, "_mkDictionary", {
        get: function () {
            var value;
            if (this._dictionary.has('MK')) {
                value = this._dictionary.get('MK');
            }
            return value;
        },
        enumerable: true,
        configurable: true
    });
    PdfFreeTextAnnotation._load = function (page, dictionary) {
        var annot = new PdfFreeTextAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        if (dictionary.has('RC')) {
            annot._parsedXMLData = annot._parseMarkupLanguageData(dictionary.get('RC'));
        }
        return annot;
    };
    PdfFreeTextAnnotation.prototype._setPaddings = function (paddings) {
        this._paddings = paddings;
    };
    PdfFreeTextAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfFreeTextAnnotation.prototype._postProcess = function (isFlatten) {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (!this._dictionary.has('C')) {
            this._isTransparentColor = true;
        }
        var cropOrMediaBox = this._getCropOrMediaBox();
        if (cropOrMediaBox && cropOrMediaBox.length > 3 && typeof cropOrMediaBox[0] === 'number' && typeof cropOrMediaBox[1] === 'number' && (cropOrMediaBox[0] !== 0 || cropOrMediaBox[1] !== 0)) {
            this._cropBoxValueX = cropOrMediaBox[0];
            this._cropBoxValueY = cropOrMediaBox[1];
        }
        if (isFlatten || this._setAppearance) {
            this._appearanceTemplate = this._createAppearance();
        }
        if (!isFlatten) {
            this._dictionary.update('Rect', _updateBounds(this));
            this._saveFreeTextDictionary();
        }
    };
    PdfFreeTextAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createAppearance();
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    var appearanceStream = dictionary.get('N');
                    if (appearanceStream) {
                        var reference = dictionary.getRaw('N');
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate && isFlatten) {
                if (!this._dictionary.has('AP')) {
                    this._appearanceTemplate = this._createAppearance();
                }
                else {
                    var dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        var appearanceStream = dictionary.get('N');
                        if (appearanceStream) {
                            var reference = dictionary.getRaw('N');
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            if (!this._appearanceTemplate._content.dictionary.has('Matrix') && !this._isLoaded) {
                var box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                if (box) {
                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                }
            }
            if (isNormalMatrix && typeof this._page.rotation !== 'undefined' && this._page.rotation !== PdfRotationAngle.angle0) {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
            else if (this._appearanceTemplate && !this._dictionary.has('AP')) {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
            else if (this._dictionary.has('AP')) {
                if (this._isValidTemplateMatrix(this._appearanceTemplate._content.dictionary, this.bounds, this._appearanceTemplate)) {
                    this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
                }
            }
        }
        else if (isFlatten) {
            this._page.annotations.remove(this);
        }
        if (this._dictionary.has('RC') && this._isContentUpdated) {
            this._updateStyle(this.font, this._textMarkUpColor, this.textAlignment);
        }
        if (!isFlatten && this._setAppearance) {
            var appearance = void 0;
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                var reference_7 = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference_7, appearance);
                this._dictionary.update('AP', reference_7);
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    };
    PdfFreeTextAnnotation.prototype._isValidTemplateMatrix = function (dictionary, bounds, appearanceTemplate) {
        var isValidMatrix = true;
        var pointF = bounds;
        if (dictionary && dictionary.has('Matrix')) {
            var box = dictionary.getArray('BBox');
            var matrix = dictionary.getArray('Matrix');
            if (matrix && box && matrix.length > 3 && box.length > 2) {
                if (typeof matrix[0] !== 'undefined' &&
                    typeof matrix[1] !== 'undefined' &&
                    typeof matrix[2] !== 'undefined' &&
                    typeof matrix[3] !== 'undefined') {
                    if (matrix[0] === 1 && matrix[1] === 0 && matrix[2] === 0 && matrix[3] === 1) {
                        if (typeof box[0] !== 'undefined' &&
                            typeof box[1] !== 'undefined' &&
                            typeof box[2] !== 'undefined' &&
                            typeof box[3] !== 'undefined') {
                            if (Math.round(box[0]) !== Math.round(-(matrix[4])) && Math.round(box[1]) !== Math.round(-(matrix[5])) ||
                                box[0] === 0 && Math.round(-(matrix[4])) === 0) {
                                var graphics = this._page.graphics;
                                var state = graphics.save();
                                if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                                    graphics.setTransparency(this._opacity);
                                }
                                pointF.x -= box[0];
                                pointF.y += box[1];
                                graphics.drawTemplate(appearanceTemplate, pointF);
                                graphics.restore(state);
                                this._page.annotations.remove(this);
                                isValidMatrix = false;
                            }
                        }
                    }
                }
            }
        }
        return isValidMatrix;
    };
    PdfFreeTextAnnotation.prototype._createAppearance = function () {
        var template;
        var borderWidth = this.border.width / 2;
        var nativeRectangle = this._obtainAppearanceBounds();
        var rotationAngle = this.rotate;
        if (rotationAngle === 0 || rotationAngle === 90 || rotationAngle === 180 || rotationAngle === 270) {
            this._isAllRotation = false;
        }
        if (rotationAngle > 0 && this._isAllRotation) {
            template = new PdfTemplate([0, 0, nativeRectangle[2], nativeRectangle[3]], this._crossReference);
        }
        else {
            template = new PdfTemplate(nativeRectangle, this._crossReference);
        }
        var box = template._content.dictionary.getArray('BBox');
        var angle = this._getRotationAngle();
        if (box && angle !== null && typeof angle !== 'undefined') {
            template._content.dictionary.set('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
        }
        var parameter = new _PaintParameter();
        var text = this._obtainText();
        template._writeTransformation = false;
        var graphics = template.graphics;
        var alignment = this._obtainTextAlignment();
        var borderColor = this._obtainColor();
        var borderPen = new PdfPen(borderColor, this.border.width);
        if (this.border.width > 0) {
            parameter.borderPen = borderPen;
        }
        var rectangle = this._obtainStyle(borderPen, nativeRectangle, borderWidth, parameter);
        if (this.color) {
            parameter.foreBrush = new PdfBrush(this._color);
        }
        if (this.textMarkUpColor) {
            parameter.backBrush = new PdfBrush(this._textMarkUpColor);
        }
        parameter.borderWidth = this.border.width;
        if (this.calloutLines && this._calloutLines.length >= 2) {
            this._drawCallOuts(graphics, borderPen);
            if (this._isLoaded && typeof this._lineEndingStyle === 'undefined') {
                this._lineEndingStyle = this.lineEndingStyle;
            }
            if (this._lineEndingStyle !== PdfLineEndingStyle.none) {
                var linePoints = this._obtainLinePoints();
                var angle_1 = this._getAngle(linePoints);
                var endPoint = this._getAxisValue([linePoints[2], linePoints[3]], 90, 0);
                this._drawLineEndStyle(endPoint, graphics, angle_1, borderPen, parameter.foreBrush, this.lineEndingStyle, this.border.width, false);
            }
            if (!this._dictionary.has('RD')) {
                rectangle = [this.bounds.x,
                    -((this._page.size[1] - (this.bounds.y + this.bounds.height))),
                    this.bounds.width,
                    -this.bounds.height];
            }
            else {
                rectangle = [rectangle[0], -rectangle[1], rectangle[2], -rectangle[3]];
            }
            rectangle[0] = rectangle[0] + this._cropBoxValueX;
            rectangle[1] = rectangle[1] - this._cropBoxValueY;
            this._calculateRectangle(rectangle);
            parameter.bounds = rectangle;
        }
        else {
            rectangle = [rectangle[0], -rectangle[1], rectangle[2], -rectangle[3]];
            parameter.bounds = rectangle;
        }
        var outerRectangle = this._obtainAppearanceBounds();
        var value = [rectangle[0] - outerRectangle[0], (-(rectangle[1])) - outerRectangle[1], rectangle[2] - outerRectangle[2],
            (((-rectangle[1]) - outerRectangle[1]) + (-rectangle[3])) - outerRectangle[3]];
        for (var i = 0; i < value.length; i++) {
            if (value[Number.parseInt(i.toString(), 10)] < 0) {
                value[Number.parseInt(i.toString(), 10)] = -value[Number.parseInt(i.toString(), 10)];
            }
        }
        this._dictionary.update('RD', value);
        if (this.opacity && this._opacity < 1) {
            graphics.save();
            graphics.setTransparency(this._opacity);
        }
        if (this.rotationAngle && this._rotate !== PdfRotationAngle.angle0) {
            graphics.save();
        }
        this._drawFreeTextRectangle(graphics, parameter, rectangle, alignment);
        if (text) {
            this._drawFreeMarkUpText(graphics, parameter, rectangle, text, alignment);
        }
        if (this.opacity && this._opacity < 1) {
            graphics.restore();
        }
        if (this.rotationAngle && this._rotate !== PdfRotationAngle.angle0) {
            graphics.restore();
        }
        var bounds = this._obtainAppearanceBounds();
        if (this.flatten) {
            this._bounds = { x: bounds[0], y: (this._page.size[1] - (bounds[1] + bounds[3])), width: bounds[2], height: bounds[3] };
        }
        this._dictionary.set('Rect', [bounds[0], bounds[1], bounds[0] + bounds[2], bounds[1] + bounds[3]]);
        return template;
    };
    PdfFreeTextAnnotation.prototype._calculateRectangle = function (innerRectangle) {
        var outerRectangle = this._obtainAppearanceBounds();
        var value = [innerRectangle[0] - outerRectangle[0],
            (-(innerRectangle[1])) - outerRectangle[1], innerRectangle[2] - outerRectangle[2],
            (((-innerRectangle[1]) - outerRectangle[1]) + (-innerRectangle[3])) - outerRectangle[3]];
        for (var i = 0; i < 4; i++) {
            if (value[Number.parseInt(i.toString(), 10)] < 0) {
                value[Number.parseInt(i.toString(), 10)] = -value[Number.parseInt(i.toString(), 10)];
            }
        }
        this._dictionary.set('RD', value);
    };
    PdfFreeTextAnnotation.prototype._obtainAnnotationIntent = function (_annotationIntent) {
        switch (_annotationIntent) {
            case PdfAnnotationIntent.freeTextCallout:
                this._intentString = 'FreeTextCallout';
                break;
            case PdfAnnotationIntent.freeTextTypeWriter:
                this._intentString = 'FreeTextTypeWriter';
                break;
        }
        return this._intentString;
    };
    PdfFreeTextAnnotation.prototype._obtainFont = function () {
        var fontData = this._obtainFontDetails();
        if (!fontData.size && this._dictionary.has('RC')) {
            var rcFont = void 0;
            if (this._parsedXMLData.length > 0 && this._parsedXMLData[0]) {
                rcFont = this._parsedXMLData[0];
            }
            if (rcFont instanceof PdfStandardFont) {
                var font = rcFont;
                fontData.size = font.size;
                fontData.style = font.style;
                fontData.name = font._fontFamily.toString();
            }
            else if (rcFont instanceof PdfCjkStandardFont) {
                var font = rcFont;
                fontData.size = font.size;
                fontData.style = font.style;
                fontData.name = font._fontFamily.toString();
            }
        }
        return _mapFont(fontData.name, fontData.size, fontData.style, this);
    };
    PdfFreeTextAnnotation.prototype._updateStyle = function (font, color, alignment) {
        var ds = 'font:' +
            font._metrics._name +
            ' ' +
            font.size +
            'pt;style:' + _reverseMapPdfFontStyle(font.style) +
            ';color:' +
            this._colorToHex(color);
        this._dictionary.update('DS', ds);
        var body = '<?xml version="1.0"?><body xmlns="http://www.w3.org/1999/xhtml" style="font:'
            + font._metrics._name + ' ' + font.size + 'pt;font-weight:'
            + (font.isBold ? 'bold' : 'normal') + ';color:' + this._colorToHex(color) + '"><p dir="ltr">';
        var textAlignment;
        var alignmentText;
        if (alignment !== null && typeof alignment !== 'undefined') {
            switch (alignment) {
                case PdfTextAlignment.left:
                    alignmentText = 'left';
                    break;
                case PdfTextAlignment.center:
                    alignmentText = 'center';
                    break;
                case PdfTextAlignment.right:
                    alignmentText = 'right';
                    break;
                case PdfTextAlignment.justify:
                    alignmentText = 'justify';
                    break;
            }
            if (alignmentText) {
                textAlignment = 'text-align:' + alignmentText + ';';
            }
        }
        var decorationText = '';
        var textDecoration;
        var italic = 'font-style:italic';
        var bold = 'font-style:bold';
        if (font.isUnderline) {
            decorationText = font.isStrikeout ? 'text-decoration:word line-through' : 'text-decoration:word';
            if (font.isItalic) {
                decorationText += ';' + italic;
            }
            else if (font.isBold) {
                decorationText += ';' + bold;
            }
        }
        else if (font.isStrikeout) {
            decorationText = 'text-decoration:line-through';
            if (font.isItalic) {
                decorationText += ';' + italic;
            }
            else if (font.isBold) {
                decorationText += ';' + bold;
            }
        }
        else {
            if (font.isItalic) {
                decorationText += italic;
            }
            else if (font.isBold) {
                decorationText += bold;
            }
        }
        if (decorationText !== '') {
            textDecoration = '<span style = "' + textAlignment + decorationText + '">' + (this.text ? this._getXmlFormattedString(this.text) : '') + '</span>';
        }
        else {
            textDecoration = '<span style = "' + textAlignment + '">' + (this.text ? this._getXmlFormattedString(this.text) : '') + '</span>';
        }
        this._dictionary.update('RC', body + textDecoration + '</p></body>');
    };
    PdfFreeTextAnnotation.prototype._drawFreeMarkUpText = function (graphics, parameter, rectangle, text, alignment) {
        var isRotation = false;
        var angle = this.rotate;
        if (this.rotationAngle === PdfRotationAngle.angle90 && !this._isAllRotation) {
            rectangle = [-rectangle[1], rectangle[0], -rectangle[3], rectangle[2]];
        }
        else if (this.rotationAngle === PdfRotationAngle.angle180 && !this._isAllRotation) {
            rectangle = [-(rectangle[2] + rectangle[0]), -rectangle[1], rectangle[2], -rectangle[3]];
        }
        else if (this.rotationAngle === PdfRotationAngle.angle270 && !this._isAllRotation) {
            rectangle = [(rectangle[1] + rectangle[3]), -(rectangle[0] + rectangle[2]), -rectangle[3], rectangle[2]];
        }
        else if (angle === 0 && !this._isAllRotation) {
            rectangle = [rectangle[0], (rectangle[1] + rectangle[3]), rectangle[2], rectangle[3]];
        }
        if ((typeof this._font === 'undefined' || this._font === null) || (!this._isLoaded && this._font.size === 1)) {
            this._font = this._markUpFont;
        }
        if (angle > 0 && this._isAllRotation) {
            isRotation = true;
            var bounds_1 = this.bounds;
            var format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
            var textSize = this._font.measureString(text, [0, 0], format, 0, 0);
            if (angle > 0 && angle <= 91) {
                graphics.translateTransform(textSize[1], -bounds_1.height);
            }
            else if (angle > 91 && angle <= 181) {
                graphics.translateTransform(bounds_1.width - textSize[1], -(bounds_1.height - textSize[1]));
            }
            else if (angle > 181 && angle <= 271) {
                graphics.translateTransform(bounds_1.width - textSize[1], -textSize[1]);
            }
            else if (angle > 271 && angle < 360) {
                graphics.translateTransform(textSize[1], -textSize[1]);
            }
            graphics.rotateTransform(angle);
            parameter.bounds = [0, 0, parameter.bounds[2], parameter.bounds[3]];
        }
        var bounds = [rectangle[0], rectangle[1], rectangle[2], rectangle[3]];
        if (this._paddings && !this._isLoaded) {
            var left = this._paddings._left;
            var top_8 = this._paddings._top;
            var right = this._paddings._right + this._paddings._left;
            var bottom = this._paddings._top + this._paddings._bottom;
            if (parameter.borderWidth > 0) {
                var first_1 = rectangle[0] + (parameter.borderWidth + left);
                var second_1 = rectangle[1] + (parameter.borderWidth + top_8);
                var third = rectangle[2] - ((parameter.borderWidth * 2) + right);
                var forth = void 0;
                if (rectangle[3] > 0) {
                    forth = rectangle[3] - ((parameter.borderWidth * 2) + bottom);
                }
                else {
                    forth = -rectangle[3] - ((parameter.borderWidth * 2) + bottom);
                }
                rectangle = [first_1, second_1, third, forth];
            }
            else {
                var first_2 = rectangle[0] + left;
                var second_2 = rectangle[1] + top_8;
                var third = rectangle[2] - right;
                var forth = void 0;
                if (rectangle[3] > 0) {
                    forth = rectangle[3] - bottom;
                }
                else {
                    forth = -rectangle[3] - bottom;
                }
                rectangle = [first_2, second_2, third, forth];
            }
        }
        else if (parameter.borderWidth > 0) {
            rectangle = [rectangle[0] + (parameter.borderWidth * 1.5),
                rectangle[1] + (parameter.borderWidth * 1.5),
                rectangle[2] - (parameter.borderWidth * 3),
                (rectangle[3] > 0) ? (rectangle[3] - (parameter.borderWidth * 3)) : (-rectangle[3] - (parameter.borderWidth * 3))];
        }
        var first = this._font._metrics._getHeight() > ((rectangle[3] > 0) ? rectangle[3] : -rectangle[3]);
        var second = this._font._metrics._getHeight() <= ((bounds[3] > 0) ? bounds[3] : -bounds[3]);
        var checkPaddingWithFontHeight = first && second;
        this._drawFreeTextAnnotation(graphics, parameter, text, this._font, checkPaddingWithFontHeight ? bounds : rectangle, true, alignment, isRotation);
    };
    PdfFreeTextAnnotation.prototype._drawFreeTextRectangle = function (graphics, parameter, rectangle, alignment) {
        var isRotation = false;
        if (this._dictionary.has('BE')) {
            for (var i = 0; i < rectangle.length; i++) {
                if (rectangle[Number.parseInt(i.toString(), 10)] < 0) {
                    rectangle[Number.parseInt(i.toString(), 10)] = -rectangle[Number.parseInt(i.toString(), 10)];
                }
            }
            this._drawAppearance(graphics, parameter, rectangle);
            if (this.rotationAngle === PdfRotationAngle.angle90 && !this._isAllRotation) {
                graphics.rotateTransform(-90);
            }
            else if (this.rotationAngle === PdfRotationAngle.angle180 && !this._isAllRotation) {
                graphics.rotateTransform(-180);
            }
            else if (this.rotationAngle === PdfRotationAngle.angle270 && !this._isAllRotation) {
                graphics.rotateTransform(-270);
            }
        }
        else {
            if (this.rotationAngle === PdfRotationAngle.angle90 && !this._isAllRotation) {
                graphics.rotateTransform(-90);
                parameter.bounds = [-rectangle[1], rectangle[2] + rectangle[0], -rectangle[3], -rectangle[2]];
            }
            else if (this.rotationAngle === PdfRotationAngle.angle180 && !this._isAllRotation) {
                graphics.rotateTransform(-180);
                parameter.bounds = [-(rectangle[2] + rectangle[0]), -(rectangle[3] + rectangle[1]), rectangle[2], rectangle[3]];
            }
            else if (this.rotationAngle === PdfRotationAngle.angle270 && !this._isAllRotation) {
                graphics.rotateTransform(-270);
                parameter.bounds = [rectangle[1] + rectangle[3], -rectangle[0], -rectangle[3], -rectangle[2]];
            }
            if (parameter.borderWidth > 0 && !this._isAllRotation) {
                rectangle = parameter.bounds;
            }
            this._drawFreeTextAnnotation(graphics, parameter, '', this._font, rectangle, false, alignment, isRotation);
        }
    };
    PdfFreeTextAnnotation.prototype._drawAppearance = function (graphics, parameter, rectangle) {
        var graphicsPath = new PdfPath();
        graphicsPath.addRectangle(rectangle[0], rectangle[1], rectangle[2], rectangle[3]);
        if (this._dictionary.has('BE')) {
            var dictionary = this._dictionary.get('BE');
            if (dictionary && dictionary.has('I')) {
                var value = dictionary.get('I');
                var radius = value === 1 ? 4 : 9;
                this._drawCloudStyle(graphics, parameter.foreBrush, parameter.borderPen, radius, 0.833, graphicsPath._points, true);
            }
        }
    };
    PdfFreeTextAnnotation.prototype._drawFreeTextAnnotation = function (g, parameter, text, font, rectangle, isSkipDrawRectangle, alignment, isRotation) {
        if (!isSkipDrawRectangle) {
            g.drawRectangle(rectangle[0], rectangle[1], rectangle[2], rectangle[3], parameter.borderPen, parameter.foreBrush);
        }
        else {
            var format = new PdfStringFormat();
            format.lineAlignment = PdfVerticalAlignment.top;
            format.alignment = alignment;
            format.lineSpacing = 0;
            if (isRotation) {
                g.drawString(text, font, parameter.bounds, null, parameter.backBrush, format);
            }
            else {
                g.drawString(text, font, rectangle, null, parameter.backBrush, format);
            }
        }
    };
    PdfFreeTextAnnotation.prototype._getCalloutLinePoints = function () {
        if (this._dictionary.has('CL')) {
            var calloutLinepoints = this._dictionary.getArray('CL');
            if (calloutLinepoints) {
                this._calloutLines = [];
                for (var i = 0; i < calloutLinepoints.length; i = i + 2) {
                    var points = [calloutLinepoints[Number.parseInt(i.toString(), 10)],
                        this._page.size[1] - calloutLinepoints[i + 1]];
                    this._calloutLines.push(points);
                }
            }
        }
        return this._calloutLines;
    };
    PdfFreeTextAnnotation.prototype._obtainAppearanceBounds = function () {
        var bounds = [0, 0, 0, 0];
        if (this.calloutLines && this._calloutLines.length > 0) {
            var path = new PdfPath();
            var pointArray = [];
            var length_2 = this._calloutLines.length === 2 ? 2 : 3;
            for (var i = 0; i < length_2; i++) {
                pointArray.push([0, 0]);
            }
            if (this._calloutLines.length >= 2) {
                this._obtainCallOutsNative();
                for (var i = 0; i < this._calloutLines.length; i++) {
                    if (i < 3) {
                        pointArray[Number.parseInt(i.toString(), 10)] = [this._calloutsClone[Number.parseInt(i.toString(), 10)][0],
                            this._calloutsClone[Number.parseInt(i.toString(), 10)][1]];
                    }
                    else {
                        break;
                    }
                }
            }
            if (pointArray.length > 0) {
                if (this.lineEndingStyle !== PdfLineEndingStyle.none) {
                    this._expandAppearance(pointArray);
                }
                path._addLines(pointArray);
            }
            path.addRectangle((this.bounds.x + this._cropBoxValueX) - 2, ((this._page.size[1] + this._cropBoxValueY) - (this.bounds.y + this.bounds.height)) - 2, this.bounds.width + (2 * 2), this.bounds.height + (2 * 2));
            bounds = path._getBounds();
        }
        else {
            bounds = [this.bounds.x + this._cropBoxValueX,
                ((this._page.size[1] + this._cropBoxValueY) - (this.bounds.y + this.bounds.height)),
                this.bounds.width,
                this.bounds.height];
        }
        return bounds;
    };
    PdfFreeTextAnnotation.prototype._obtainCallOutsNative = function () {
        if (this.calloutLines && this._calloutLines.length > 0) {
            var size = this._page.size;
            this._calloutsClone = [];
            for (var i = 0; i < this._calloutLines.length; i++) {
                this._calloutsClone.push([this._calloutLines[Number.parseInt(i.toString(), 10)][0] + this._cropBoxValueX,
                    (size[1] + this._cropBoxValueY) - this._calloutLines[Number.parseInt(i.toString(), 10)][1]]);
            }
        }
    };
    PdfFreeTextAnnotation.prototype._obtainLinePoints = function () {
        var pageHeight = this._page.size[1];
        return [this.calloutLines[1][0] + this._cropBoxValueX,
            (pageHeight + this._cropBoxValueY) - this.calloutLines[1][1],
            this.calloutLines[0][0] + this._cropBoxValueX,
            (pageHeight + this._cropBoxValueY) - this.calloutLines[0][1]];
    };
    PdfFreeTextAnnotation.prototype._obtainLineEndingStyle = function () {
        var lineEndingStyle = PdfLineEndingStyle.square;
        if (this._dictionary.has('LE')) {
            lineEndingStyle = _mapLineEndingStyle(this._dictionary.get('LE').name, lineEndingStyle);
        }
        return lineEndingStyle;
    };
    PdfFreeTextAnnotation.prototype._obtainText = function () {
        var text = '';
        var isContent = this._dictionary.has('Contents');
        if (isContent) {
            var markUpText = this._dictionary.get('Contents');
            if (markUpText) {
                text = markUpText;
            }
            if (text && text !== '') {
                this._text = text;
            }
            return text;
        }
        else if (this._dictionary.has('RC') && !isContent && text === null) {
            text = this._rcText;
            return text;
        }
        return text;
    };
    PdfFreeTextAnnotation.prototype._obtainTextAlignment = function () {
        var textAlignment = PdfTextAlignment.left;
        var hasAlignment;
        if (this._dictionary.has('Q')) {
            var value = this._dictionary.get('Q');
            if (typeof value !== 'undefined') {
                textAlignment = value;
                hasAlignment = true;
            }
        }
        else if (this._dictionary.has('RC')) {
            if (this._parsedXMLData.length > 0 && this._parsedXMLData[1]) {
                var rcAlignment = this._parsedXMLData[1];
                textAlignment = rcAlignment;
                hasAlignment = true;
            }
        }
        if (!hasAlignment && this._dictionary.has('DS')) {
            var value = this._dictionary.get('DS');
            var collections = value.split(';');
            for (var i = 0; i < collections.length; i++) {
                if (collections[Number.parseInt(i.toString(), 10)].indexOf('text-align') !== -1) {
                    switch (collections[Number.parseInt(i.toString(), 10)]) {
                        case 'left':
                            textAlignment = PdfTextAlignment.left;
                            break;
                        case 'right':
                            textAlignment = PdfTextAlignment.right;
                            break;
                        case 'center':
                            textAlignment = PdfTextAlignment.center;
                            break;
                        case 'justify':
                            textAlignment = PdfTextAlignment.justify;
                            break;
                    }
                }
            }
        }
        return textAlignment;
    };
    PdfFreeTextAnnotation.prototype._obtainColor = function () {
        var color;
        if (this._isLoaded) {
            if (this._dictionary.has('DA')) {
                var entry = this._dictionary.get('DA');
                if (Array.isArray(entry) && entry.length > 0) {
                    color = [entry[0], entry[1], entry[2]];
                }
                else if (typeof entry === 'string') {
                    this._da = new _PdfDefaultAppearance(entry);
                    color = this._da.color;
                }
            }
            else if (this._dictionary.has('MK')) {
                var mkDict = this._mkDictionary;
                if (mkDict && mkDict.has('BC')) {
                    color = _parseColor(mkDict.getArray('BC'));
                }
            }
            else {
                color = [0, 0, 0];
            }
        }
        else {
            color = this._borderColor ? this._borderColor : [0, 0, 0];
        }
        return color;
    };
    PdfFreeTextAnnotation.prototype._expandAppearance = function (pointArray) {
        var pointY = pointArray[0][1];
        var pointX = pointArray[0][0];
        if (!this._isLoaded) {
            pointY = this._page.size[1] - pointY;
        }
        if (pointY > this.bounds.y) {
            if (this.lineEndingStyle !== PdfLineEndingStyle.openArrow) {
                pointArray[0][1] -= (this.border.width * 11);
            }
        }
        else {
            pointArray[0][1] += (this.border.width * 11);
        }
        if (pointX <= this.bounds.x) {
            pointArray[0][0] -= (this.border.width * 11);
        }
        else {
            pointArray[0][0] += (this.border.width * 11);
        }
    };
    PdfFreeTextAnnotation.prototype._drawCallOuts = function (graphics, borderPen) {
        var path = new PdfPath();
        var pointArray = [];
        var length = this._calloutLines.length === 2 ? 2 : 3;
        for (var i = 0; i < length; i++) {
            pointArray.push([0, 0]);
        }
        if (this._calloutLines.length >= 2) {
            this._obtainCallOutsNative();
            for (var i = 0; i < this._calloutLines.length && i < 3; i++) {
                pointArray[Number.parseInt(i.toString(), 10)] = [this._calloutsClone[Number.parseInt(i.toString(), 10)][0],
                    -this._calloutsClone[Number.parseInt(i.toString(), 10)][1]];
            }
        }
        if (pointArray.length > 0) {
            path._addLines(pointArray);
        }
        graphics.drawPath(path, borderPen);
    };
    PdfFreeTextAnnotation.prototype._saveFreeTextDictionary = function () {
        if ((typeof this.font === 'undefined' || this.font === null) || (!this._isLoaded && this.font.size === 1)) {
            this.font = this._markUpFont;
        }
        if (typeof this.text === 'string' && this.text !== null) {
            this._dictionary.update('Contents', this.text);
        }
        if (this._isLoaded) {
            this._textAlignment = this.textAlignment;
        }
        this._dictionary.update('Q', this._textAlignment);
        if (this.annotationIntent === PdfAnnotationIntent.none) {
            this._dictionary.update('Subj', 'Text Box');
        }
        else {
            this._dictionary.update('IT', _PdfName.get(this._obtainAnnotationIntent(this._annotationIntent)));
        }
        this._updateStyle(this.font, this.textMarkUpColor, this._textAlignment);
        this._dictionary.update('DA', this._getBorderColorString(this.borderColor ? this._borderColor : [0, 0, 0]));
        if (this._calloutLines && this._calloutLines.length >= 2) {
            var pageHeight = this._page.size[1];
            var lines = [];
            for (var i = 0; i < this._calloutLines.length && i < 3; i++) {
                lines.push(this._calloutLines[Number.parseInt(i.toString(), 10)][0] + this._cropBoxValueX);
                lines.push((pageHeight + this._cropBoxValueY) - this._calloutLines[Number.parseInt(i.toString(), 10)][1]);
            }
            this._dictionary.update('CL', lines);
        }
        if (this._setAppearance) {
            var rect = this._obtainAppearanceBounds();
            this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
        }
    };
    PdfFreeTextAnnotation.prototype._getXmlFormattedString = function (markupText) {
        markupText = markupText.replace('&', '&amp;');
        markupText = markupText.replace('<', '&lt;');
        markupText = markupText.replace('>', '&gt;');
        return markupText;
    };
    PdfFreeTextAnnotation.prototype._parseMarkupLanguageData = function (rcContent) {
        var _this = this;
        var fontStyle = PdfFontStyle.regular;
        var fontCollection = []; // eslint-disable-line
        var brush = null;
        var fontName = '';
        var content = rcContent;
        var contentText = this._dictionary.has('Contents') ? this._dictionary.get('Contents') : '';
        var hasSymbol = false;
        var xdocument; // eslint-disable-line
        hasSymbol = contentText.split('').some(function (char) { return _this._isSymbol(char); });
        if (!hasSymbol) {
            if (content !== null && typeof content !== 'undefined') {
                xdocument = (new DOMParser()).parseFromString(content, 'text/xml');
                var root = xdocument.documentElement;
                var nameSpaceURI = (root && root.namespaceURI) || '';
                if (root) {
                    var styleMap = this._collectStyles(root);
                    if (styleMap.size > 0) {
                        var input = this._extractStylesToInput(styleMap);
                        var fontDetails = this._getFontDetails(input, this.font.size, this.textAlignment, fontStyle, brush); // eslint-disable-line
                        var _a = this._updateFontProperties(fontDetails, fontName, fontStyle, brush), updatedFontName = _a.fontName, updatedFontStyle = _a.fontStyle, updatedBrush = _a.brush;
                        var obtainFont = _mapFont(updatedFontName, this.font._size, updatedFontStyle, this);
                        fontCollection = this._fontCollection(fontCollection, obtainFont, nameSpaceURI, this._textAlignment, updatedBrush);
                    }
                }
            }
        }
        this._parsedXMLData = fontCollection;
        return fontCollection;
    };
    PdfFreeTextAnnotation.prototype._collectStyles = function (root, styleMap) {
        if (styleMap === void 0) { styleMap = new Map(); }
        if (!root) {
            return styleMap;
        }
        var nodeStyle = null;
        try {
            nodeStyle = window.getComputedStyle(root);
        }
        catch (error) {
            return styleMap;
        }
        styleMap.set(root.tagName.toLowerCase(), nodeStyle);
        var childNode = root.firstElementChild;
        while (childNode) {
            this._collectStyles(childNode, styleMap);
            childNode = childNode.nextElementSibling;
        }
        return styleMap;
    };
    PdfFreeTextAnnotation.prototype._extractStylesToInput = function (styleMap) {
        var input = [];
        styleMap.forEach(function (styleValue) {
            if (styleValue && styleValue.length > 0) { // Check if styleValue is valid
                for (var i = 0; i < styleValue.length; i++) {
                    var propertyName = styleValue.item(Number.parseInt(i.toString(), 10));
                    if (propertyName !== null && propertyName !== undefined) {
                        var propertyValue = styleValue.getPropertyValue(propertyName);
                        input.push(propertyName + ": " + propertyValue);
                    }
                }
            }
        });
        return input;
    };
    PdfFreeTextAnnotation.prototype._isSymbol = function (char) {
        var code = char.charCodeAt(0);
        if (char === '_' || char === '+' || char === '-' || char === '*' || char === '=') {
            return false;
        }
        return ((code >= 0x20A0 && code <= 0x20CF) ||
            (code >= 0x2200 && code <= 0x22FF) ||
            (code >= 0x2A00 && code <= 0x2AFF) ||
            (code >= 0x2100 && code <= 0x214F) ||
            (code >= 0x2300 && code <= 0x23FF) ||
            (code === 0x2B50));
    };
    PdfFreeTextAnnotation.prototype._updateFontProperties = function (fontDetails, fontName, fontStyle, brush) {
        var _this = this;
        fontDetails.forEach(function (value, property) {
            switch (property) {
                case 'font-family':
                    fontName = value;
                    break;
                case 'font-size':
                    _this.font._size = parseFloat(value);
                    break;
                case 'font-style':
                case 'font-weight':
                case 'text-decoration':
                    fontStyle = _this._obtainFontStyle(value, property);
                    break;
                case 'text-align':
                    _this._textAlignment = _this._parseTextAlignment(value);
                    break;
                case 'color':
                    brush = value;
                    break;
                case 'xfa-spacerun':
                    _this._rcText = value;
                    break;
            }
        });
        return { fontName: fontName, fontStyle: fontStyle, brush: brush };
    };
    PdfFreeTextAnnotation.prototype._obtainFontStyle = function (value, property) {
        var styleValue = parseFloat(value);
        switch (property) {
            case 'font-style':
                return styleValue === 0 ? PdfFontStyle.regular :
                    styleValue === 1 ? PdfFontStyle.bold :
                        styleValue === 2 ? PdfFontStyle.italic :
                            styleValue === 8 ? PdfFontStyle.strikeout :
                                styleValue === 4 ? PdfFontStyle.underline : PdfFontStyle.regular;
            case 'font-weight':
                return styleValue === 1 ? PdfFontStyle.bold : PdfFontStyle.regular;
            case 'text-decoration':
                return styleValue === 8 ? PdfFontStyle.strikeout :
                    styleValue === 4 ? PdfFontStyle.underline : PdfFontStyle.regular;
            default:
                return PdfFontStyle.regular;
        }
    };
    PdfFreeTextAnnotation.prototype._parseTextAlignment = function (value) {
        var alignmentValue = parseFloat(value);
        switch (alignmentValue) {
            case 0: return PdfTextAlignment.left;
            case 1: return PdfTextAlignment.center;
            case 2: return PdfTextAlignment.right;
            case 3: return PdfTextAlignment.justify;
            default: return PdfTextAlignment.left;
        }
    };
    PdfFreeTextAnnotation.prototype._getFontDetails = function (input, fontSize, textAlignment, fontStyle, brush) {
        var _this = this;
        var fontDetails = new Map(); // eslint-disable-line
        input.forEach(function (element) {
            var _a = element.split(':').map(function (item) { return item.trim(); }), property = _a[0], value = _a[1];
            if (property && value) {
                switch (property.toLowerCase()) {
                    case 'font':
                        _this._parseFont(value, fontDetails);
                        break;
                    case 'font-size':
                        fontSize = _this._parseFontSize(value);
                        fontDetails.set('font-size', fontSize);
                        break;
                    case 'font-weight':
                        fontStyle = _this._parseFontWeight(value, fontStyle);
                        fontDetails.set('font-weight', fontStyle);
                        break;
                    case 'font-family':
                        fontDetails.set('font-family', _this._parseFontFamily(value));
                        break;
                    case 'color':
                        brush = new PdfBrush(_this._rgbStringToArray(value));
                        fontDetails.set('color', brush);
                        break;
                    case 'font-style':
                        fontStyle = _this._parseFontStyle(value, fontStyle);
                        fontDetails.set('font-style', fontStyle);
                        break;
                    case 'text-decoration':
                        fontStyle = _this._parseTextDecoration(value, fontStyle);
                        fontDetails.set('text-decoration', fontStyle);
                        break;
                    case 'text-align':
                        textAlignment = _this._parseTextAlign(value);
                        fontDetails.set('text-align', textAlignment);
                        break;
                    case 'xfa-spacerun':
                        _this._rcText = value.length > 1 && value.includes('yes') ? _this._rcText + ' ' : _this._rcText;
                        fontDetails.set('xfa-spacerun', _this._rcText);
                        break;
                }
            }
        });
        return fontDetails;
    };
    PdfFreeTextAnnotation.prototype._parseFont = function (value, fontDetails) {
        var fontParts = value.split(' ').map(function (item) { return item.trim(); });
        var fontName = '';
        fontParts.forEach(function (part) {
            if (part && !part.endsWith('pt')) {
                fontName += part + ' ';
            }
            else if (part.endsWith('pt')) {
                fontDetails.set('font-size', parseFloat(part.replace('pt', '').replace(',', '.').trim()));
            }
        });
        fontDetails.set('font-family', fontName.trim().replace(/['",]/g, ''));
    };
    PdfFreeTextAnnotation.prototype._parseFontSize = function (value) {
        if (value.endsWith('pt')) {
            return parseFloat(value.replace('pt', '').replace(',', '.').trim());
        }
        return 0;
    };
    PdfFreeTextAnnotation.prototype._parseFontWeight = function (value, fontStyle) {
        if (value.includes('bold')) {
            fontStyle |= PdfFontStyle.bold;
        }
        return fontStyle;
    };
    PdfFreeTextAnnotation.prototype._parseFontFamily = function (value) {
        return value.replace(/^'+|'+$/g, '').trim();
    };
    PdfFreeTextAnnotation.prototype._parseFontStyle = function (value, fontStyle) {
        if (value.includes('normal') || value.includes('regular')) {
            return PdfFontStyle.regular;
        }
        if (value.includes('underline')) {
            return PdfFontStyle.underline;
        }
        if (value.includes('strikeout')) {
            return PdfFontStyle.strikeout;
        }
        if (value.includes('italic')) {
            return PdfFontStyle.italic;
        }
        if (value.includes('bold')) {
            return PdfFontStyle.bold;
        }
        return fontStyle;
    };
    PdfFreeTextAnnotation.prototype._parseTextDecoration = function (value, fontStyle) {
        if (value.includes('word')) {
            return PdfFontStyle.underline;
        }
        if (value.includes('line-through')) {
            return PdfFontStyle.strikeout;
        }
        return fontStyle;
    };
    PdfFreeTextAnnotation.prototype._parseTextAlign = function (value) {
        switch (value.trim().toLowerCase()) {
            case 'left': return PdfTextAlignment.left;
            case 'right': return PdfTextAlignment.right;
            case 'center': return PdfTextAlignment.center;
            case 'justify': return PdfTextAlignment.justify;
            default: return PdfTextAlignment.left;
        }
    };
    PdfFreeTextAnnotation.prototype._rgbStringToArray = function (rgbString) {
        var regex = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/;
        var match = rgbString.match(regex);
        if (match) {
            var r = parseInt(match[1], 10);
            var g = parseInt(match[2], 10);
            var b = parseInt(match[3], 10);
            return [r, g, b];
        }
        else {
            throw new Error('Invalid RGB string format');
        }
    };
    PdfFreeTextAnnotation.prototype._fontCollection = function (fontCollection, font, nameSpaceUri, alignment, brush) {
        return fontCollection.concat([font, alignment, nameSpaceUri, brush]);
    };
    return PdfFreeTextAnnotation;
}(PdfComment));
/**
 * `PdfRedactionAnnotation` class represents the redaction annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new redaction annotation
 * const annotation: PdfRedactionAnnotation = new PdfRedactionAnnotation (50, 100, 100, 50);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfRedactionAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfRedactionAnnotation, _super);
    function PdfRedactionAnnotation(x, y, width, height) {
        var _this = _super.call(this) || this;
        _this._textAlignment = PdfTextAlignment.left;
        _this._dictionary = new _PdfDictionary();
        _this._dictionary.update('Type', _PdfName.get('Annot'));
        _this._dictionary.update('Subtype', _PdfName.get('Redact'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            _this.bounds = { x: x, y: y, width: width, height: height };
        }
        _this._type = _PdfAnnotationType.redactionAnnotation;
        return _this;
    }
    Object.defineProperty(PdfRedactionAnnotation.prototype, "repeatText", {
        /**
         * Gets the boolean flag indicating whether annotation has repeat text or not.
         *
         * @returns {boolean} repeat text.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
         * // Gets the boolean flag indicating whether annotation has repeat text or not.
         * let repeatText: boolean = annotation. repeatText;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._repeat === 'undefined' && this._dictionary.has('Repeat')) {
                this._repeat = this._dictionary.get('Repeat');
            }
            return this._repeat;
        },
        /**
         * Sets the boolean flag indicating whether annotation has repeat text or not.
         *
         * @param {boolean} value repeat text.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
         * // Sets the boolean flag indicating whether annotation has repeat text or not.
         * annotation.repeatText = false;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._repeat) {
                this._repeat = value;
                if (this._dictionary) {
                    this._dictionary.update('Repeat', value);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRedactionAnnotation.prototype, "textAlignment", {
        /**
         * Gets the text alignment of the annotation.
         *
         * @returns {PdfTextAlignment} Text alignment.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
         * // Gets the text alignment of the annotation.
         * let textAlignment: PdfTextAlignment = annotation.textAlignment;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary.has('Q')) {
                this._textAlignment = this._dictionary.get('Q');
            }
            return this._textAlignment;
        },
        /**
         * Sets the text alignment of the annotation.
         *
         * @param {PdfTextAlignment} value Text alignment.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
         * // Sets the text alignment of the annotation.
         * annotation.textAlignment = PdfTextAlignment.justify;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._textAlignment !== value) {
                this._dictionary.update('Q', value);
            }
            this._textAlignment = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRedactionAnnotation.prototype, "textColor", {
        /**
         * Gets the text color of the annotation.
         *
         * @returns {number[]} R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
         * // Gets the text color of the annotation.
         * let textColor : number[] = annotation.textColor;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._textColor === 'undefined' && this._dictionary.has('C')) {
                this._textColor = _parseColor(this._dictionary.getArray('C'));
            }
            return this._textColor;
        },
        /**
         * Sets the text color of the annotation.
         *
         * @param {number[]} value R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
         * // Sets the text color of the annotation.
         * annotation.textColor = [255, 255, 255];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined' && value.length === 3) {
                var extColor = this.textColor;
                if (!this._isLoaded || typeof extColor === 'undefined' || (extColor[0] !== value[0] || extColor[1] !== value[1] || extColor[2] !== value[2])) {
                    this._textColor = value;
                    this._dictionary.update('C', [Number.parseFloat((value[0] / 255).toFixed(3)),
                        Number.parseFloat((value[1] / 255).toFixed(3)),
                        Number.parseFloat((value[2] / 255).toFixed(3))]);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRedactionAnnotation.prototype, "borderColor", {
        /**
         * Gets the border color of the annotation.
         *
         * @returns {number[]} R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
         * // Gets the border color of the annotation.
         * let borderColor: number[] = annotation.borderColor;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._borderColor === 'undefined' && this._dictionary.has('OC')) {
                this._borderColor = _parseColor(this._dictionary.getArray('OC'));
            }
            return this._borderColor;
        },
        /**
         * Sets the border color of the annotation.
         *
         * @param {number[]} value R, G, B color values in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
         * // Sets the border color of the annotation.
         * annotation.borderColor = [255, 255, 255];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value !== 'undefined' && value.length === 3) {
                var extColor = this.borderColor;
                if (!this._isLoaded || typeof extColor === 'undefined' || (extColor[0] !== value[0] || extColor[1] !== value[1] || extColor[2] !== value[2])) {
                    this._borderColor = value;
                    this._dictionary.update('OC', [Number.parseFloat((value[0] / 255).toFixed(3)),
                        Number.parseFloat((value[1] / 255).toFixed(3)),
                        Number.parseFloat((value[2] / 255).toFixed(3))]);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRedactionAnnotation.prototype, "overlayText", {
        /**
         * Gets the overlay text of the annotation.
         *
         * @returns {string} overlay text.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
         * // Gets the overlay text of the annotation.
         * let overlayText: string =annotation.overlayText;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._overlayText === 'undefined' && this._dictionary.has('OverlayText')) {
                this._overlayText = this._dictionary.get('OverlayText');
            }
            return this._overlayText;
        },
        /**
         * Sets the overlay text of the annotation.
         *
         * @param {string} value overlay text.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
         * // Sets the overlay text of the annotation.
         * annotation.overlayText = ‘syncfusion’;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value === 'string') {
                this._dictionary.update('OverlayText', value);
                this._overlayText = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRedactionAnnotation.prototype, "font", {
        /**
         * Gets the font of the annotation.
         *
         * @returns {PdfFont} font.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
         * // Gets the font of the annotation.
         * let font: PdfFont = annotation.font;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._font;
        },
        /**
         * Sets the font of the annotation.
         *
         * @param {PdfFont} value font.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
         * // Sets the font of the annotation.
         * annotation.font = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._font = value;
        },
        enumerable: true,
        configurable: true
    });
    PdfRedactionAnnotation._load = function (page, dictionary) {
        var annot = new PdfRedactionAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfRedactionAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfRedactionAnnotation.prototype._postProcess = function (isFlatten) {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        var borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (this._setAppearance) {
            this._appearanceTemplate = this._createRedactionAppearance(isFlatten);
        }
        this._dictionary.update('Rect', _updateBounds(this));
    };
    PdfRedactionAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (!this._isImported) {
            if (this._isLoaded) {
                this._appearanceTemplate = this._createRedactionAppearance(isFlatten);
            }
            else {
                this._postProcess(isFlatten);
                if (!this._appearanceTemplate) {
                    if (isFlatten) {
                        if (!this._dictionary.has('AP')) {
                            this._appearanceTemplate = this._createRedactionAppearance(isFlatten);
                        }
                        else {
                            var dictionary = this._dictionary.get('AP');
                            if (dictionary && dictionary.has('N')) {
                                var appearanceStream = dictionary.get('N');
                                if (appearanceStream) {
                                    var reference = dictionary.getRaw('N');
                                    if (reference) {
                                        appearanceStream.reference = reference;
                                    }
                                    this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                                }
                            }
                        }
                    }
                }
            }
            if (isFlatten && this._appearanceTemplate) {
                var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
                if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {
                    var box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                    if (box) {
                        this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                    }
                }
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
            else if (isFlatten) {
                this._page.annotations.remove(this);
            }
        }
    };
    PdfRedactionAnnotation.prototype._createRedactionAppearance = function (isFlatten) {
        var normalTemplate = this._createNormalAppearance();
        if (isFlatten) {
            if (this._isLoaded && this._page !== null) {
                this._page.annotations.remove(this);
            }
        }
        else {
            var borderTemplate = this._createBorderAppearance();
            if (this._dictionary.has('AP')) {
                var appearance = this._dictionary.get('AP');
                if (appearance && appearance instanceof _PdfDictionary) {
                    _removeDuplicateReference(appearance, this._crossReference, 'N');
                    _removeDuplicateReference(appearance, this._crossReference, 'R');
                }
            }
            var dictionary = new _PdfDictionary(this._crossReference);
            borderTemplate._content.dictionary._updated = true;
            var reference1 = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference1, borderTemplate._content);
            borderTemplate._content.reference = reference1;
            dictionary.set('N', reference1);
            normalTemplate._content.dictionary._updated = true;
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, normalTemplate._content);
            normalTemplate._content.reference = reference;
            dictionary.set('R', reference);
            dictionary._updated = true;
            this._dictionary.set('AP', dictionary);
        }
        return normalTemplate;
    };
    PdfRedactionAnnotation.prototype._createBorderAppearance = function () {
        var nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];
        var template = new PdfTemplate(nativeRectangle, this._crossReference);
        var width = this.border.width / 2;
        var graphics = template.graphics;
        var actualWidth = this.border.width;
        var pen;
        if (this.border.width > 0 && this.borderColor) {
            pen = new PdfPen(this.borderColor, actualWidth);
        }
        var rect = [nativeRectangle[0], nativeRectangle[1], nativeRectangle[2], nativeRectangle[3]];
        if (this.opacity < 1) {
            var state = graphics.save();
            graphics.setTransparency(this.opacity);
            graphics.drawRectangle(rect[0] + width, rect[1] + width, rect[2] - actualWidth, rect[3] - actualWidth, pen, null);
            graphics.restore(state);
        }
        else {
            graphics.drawRectangle(rect[0] + width, rect[1] + width, rect[2] - actualWidth, rect[3] - actualWidth, pen, null);
        }
        return template;
    };
    PdfRedactionAnnotation.prototype._createNormalAppearance = function () {
        var nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];
        var template = new PdfTemplate(nativeRectangle, this._crossReference);
        _setMatrix(template, this._getRotationAngle());
        var width = this.border.width / 2;
        var graphics = template.graphics;
        var parameter = new _PaintParameter();
        var borderPen;
        if (this.textColor && this.border.width > 0) {
            borderPen = new PdfPen(this.textColor, this.border.width);
        }
        var backBrush;
        var textcolor;
        if (this.innerColor) {
            backBrush = new PdfBrush(this.innerColor);
        }
        if (this.textColor) {
            textcolor = new PdfBrush(this.textColor);
        }
        else {
            textcolor = new PdfBrush([128, 128, 128]);
        }
        parameter.backBrush = backBrush;
        parameter.borderWidth = width;
        var widths = this.border.width;
        var rect = [nativeRectangle[0], nativeRectangle[1], nativeRectangle[2], nativeRectangle[3]];
        if (this.opacity < 1) {
            var state = graphics.save();
            graphics.setTransparency(this.opacity);
            graphics.drawRectangle(rect[0] + width, rect[1] + width, rect[2] - widths, rect[3] - widths, borderPen, backBrush);
            graphics.restore(state);
        }
        else {
            graphics.drawRectangle(rect[0] + width, rect[1] + width, rect[2] - widths, rect[3] - widths, borderPen, backBrush);
        }
        graphics.restore();
        if (this.overlayText && _isNullOrUndefined(this.overlayText) && this._overlayText !== '') {
            var col = 0;
            var row = 0;
            if (typeof this.font === 'undefined' || this.font === null) {
                this.font = this._lineCaptionFont;
            }
            var y = 0;
            var x = 0;
            var diff = 0;
            var rectangle = void 0;
            if (this._isLoaded) {
                this._textAlignment = this.textAlignment;
            }
            var format = new PdfStringFormat(this._textAlignment, PdfVerticalAlignment.top);
            var textsize = this.font.measureString(this.overlayText, [0, 0], format, 0, 0);
            if (this._isLoaded && typeof this._repeat === 'undefined') {
                this._repeat = this.repeatText;
            }
            if (this._repeat) {
                if (textsize[0] <= 0) {
                    textsize[0] = 1;
                }
                col = this.bounds.width / textsize[0];
                row = Math.floor(this.bounds.height / this.font._size);
                diff = Math.abs(this.bounds.width - (Math.floor(col) * textsize[0]));
                if (this._textAlignment === PdfTextAlignment.center) {
                    x = diff / 2;
                }
                if (this._textAlignment === PdfTextAlignment.right) {
                    x = diff;
                }
                for (var i = 1; i < col; i++) {
                    for (var j = 0; j < row; j++) {
                        rectangle = [x, y, 0, 0];
                        graphics.drawString(this.overlayText, this.font, rectangle, null, textcolor, null);
                        y = y + this.font._size;
                    }
                    x = x + textsize[0];
                    y = 0;
                }
            }
            else {
                diff = Math.abs(this.bounds.width - textsize[0]);
                if (this._textAlignment === PdfTextAlignment.center) {
                    x = diff / 2;
                }
                if (this._textAlignment === PdfTextAlignment.right) {
                    x = diff;
                }
                rectangle = [x, 0, this.bounds.width - this.border.width, this.bounds.height - this.border.width];
                graphics.drawString(this.overlayText, this.font, rectangle, null, textcolor, format);
            }
        }
        return template;
    };
    return PdfRedactionAnnotation;
}(PdfAnnotation));
/**
 * `PdfRichMediaAnnotation` class represents the rich media annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfRichMediaAnnotation = page.annotations.at(0) as PdfRichMediaAnnotation;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfRichMediaAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfRichMediaAnnotation, _super);
    /**
     * Initializes a new instance of the `PdfRichMediaAnnotation` class.
     *
     * @private
     */
    function PdfRichMediaAnnotation() {
        var _this = _super.call(this) || this;
        _this._type = _PdfAnnotationType.richMediaAnnotation;
        return _this;
    }
    PdfRichMediaAnnotation._load = function (page, dictionary) {
        var annot = new PdfRichMediaAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    };
    PdfRichMediaAnnotation.prototype._initialize = function (page, dictionary) {
        _super.prototype._initialize.call(this, page, dictionary);
    };
    PdfRichMediaAnnotation.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            this._flattenPopUp();
        }
        if (isFlatten) {
            var appearanceStream = void 0;
            if (this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                var template = new PdfTemplate(appearanceStream, this._crossReference);
                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    };
    return PdfRichMediaAnnotation;
}(PdfAnnotation));
/**
 * `PdfWidgetAnnotation` class represents the widget annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfWidgetAnnotation = /** @class */ (function (_super) {
    __extends$6(PdfWidgetAnnotation, _super);
    /**
     * Initializes a new instance of the `PdfWidgetAnnotation` class.
     *
     * @private
     */
    function PdfWidgetAnnotation() {
        var _this = _super.call(this) || this;
        _this._isAutoResize = false;
        _this._visibility = PdfFormFieldVisibility.visible;
        _this._isFont = false;
        _this._isTransparentBackColor = false;
        _this._isTransparentBorderColor = false;
        _this._isWidget = true;
        _this._type = _PdfAnnotationType.widgetAnnotation;
        return _this;
    }
    /**
     * Parse an existing widget annotation.
     *
     * @private
     * @param {_PdfDictionary} dictionary Widget dictionary.
     * @param {_PdfCrossReference} crossReference PDF cross reference.
     * @returns {PdfWidgetAnnotation} Widget.
     */
    PdfWidgetAnnotation._load = function (dictionary, crossReference) {
        var widget = new PdfWidgetAnnotation();
        widget._isLoaded = true;
        widget._dictionary = dictionary;
        widget._crossReference = crossReference;
        return widget;
    };
    Object.defineProperty(PdfWidgetAnnotation.prototype, "page", {
        /**
         * Gets the page object (Read only).
         *
         * @returns {PdfPage} page object.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access check box field
         * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
         * // Access first item of check box field
         * let item: PdfWidgetAnnotation = field.itemAt(0);
         * // Gets the page object.
         * let page: PdfPage = item.page;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._getPage();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfWidgetAnnotation.prototype, "color", {
        /**
         * Gets the fore color of the annotation.
         *
         * @returns {number[]} Color as R, G, B color array in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
         * // Gets the fore color of the annotation.
         * let color: number[] = annotation.color;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._color === 'undefined' && this._defaultAppearance) {
                this._color = this._da.color;
            }
            return this._color;
        },
        /**
         * Sets the fore color of the annotation.
         *
         * @param {number[]} value Color as R, G, B color array in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
         * // Sets the fore color of the annotation.
         * annotation.color = [255,255,255];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof this.color === 'undefined' || this._color !== value) {
                this._color = value;
            }
            var isNew = false;
            if (!this._defaultAppearance) {
                this._da = new _PdfDefaultAppearance('');
                isNew = true;
            }
            if (isNew || this._da.color !== value) {
                this._da.color = value;
                this._dictionary.update('DA', this._da.toString());
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfWidgetAnnotation.prototype, "backColor", {
        /**
         * Gets the back color of the annotation.
         *
         * @returns {number[]} Color as R, G, B color array in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the text box field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the back color of the annotation
         * let backColor: number[] = field.itemAt(0).backColor;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._parseBackColor();
        },
        /**
         * Sets the back color of the annotation.
         *
         * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the text box field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets the background color of the field item
         * field.itemAt(0).backColor = [255, 0, 0];
         * // Sets the background color of the field item to transparent
         * field.itemAt(1).backColor = [0, 0, 0, 0];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._updateBackColor(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfWidgetAnnotation.prototype, "_hasBackColor", {
        get: function () {
            if (this._isLoaded) {
                var mkDictionary = this._mkDictionary;
                return (mkDictionary && mkDictionary.has('BG'));
            }
            else {
                return !this._isTransparentBackColor;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfWidgetAnnotation.prototype, "_hasBorderColor", {
        get: function () {
            if (this._isLoaded) {
                var mkDictionary = this._mkDictionary;
                return (mkDictionary && mkDictionary.has('BC'));
            }
            else {
                return !this._isTransparentBorderColor;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfWidgetAnnotation.prototype, "borderColor", {
        /**
         * Gets the border color of the annotation.
         *
         * @returns {number[]} Color as R, G, B color array in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
         * // Gets the border color of the annotation.
         * let borderColor: number[] = annotation.borderColor;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._parseBorderColor();
        },
        /**
         * Sets the border color of the annotation.
         *
         * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
         * // Sets the border color of the annotation.
         * annotation.borderColor = [255,255,255];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._updateBorderColor(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfWidgetAnnotation.prototype, "rotate", {
        /**
         * Gets the rotation angle of the annotation.
         *
         * @returns {number} Rotation angle as number.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
         * // Gets the rotation angle of the annotation.
         * let rotate: number = annotation.rotate;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._rotationAngle === 'undefined') {
                if (this._mkDictionary && this._mkDictionary.has('R')) {
                    this._rotationAngle = this._mkDictionary.get('R');
                }
                else if (this._dictionary.has('R')) {
                    this._rotationAngle = this._dictionary.get('R');
                }
            }
            return this._rotationAngle;
        },
        /**
         * Sets the rotation angle of the annotation.
         *
         * @param {number} value Rotation angle as number.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
         * // Sets the rotation angle of the annotation.
         * annotation.rotate = 90;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof this.rotate === 'undefined' || this._rotationAngle !== value) {
                if (typeof this._mkDictionary === 'undefined') {
                    this._dictionary.update('MK', new _PdfDictionary(this._crossReference));
                }
                this._mkDictionary.update('R', value);
                this._rotationAngle = value;
                this._dictionary._updated = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfWidgetAnnotation.prototype, "highlightMode", {
        /**
         * Gets the highlight mode of the annotation.
         *
         * @returns {PdfHighlightMode} Highlight mode.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
         * // Gets the highlight mode of the annotation.
         * let highlightMode: PdfHighlightMode = annotation.highlightMode;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._highlightMode === 'undefined' && this._dictionary.has('H')) {
                var mode = this._dictionary.get('H');
                this._highlightMode = _mapHighlightMode(mode.name);
            }
            return this._highlightMode;
        },
        /**
         * Sets the highlight mode of the annotation.
         *
         * @param {PdfHighlightMode} value Highlight mode.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
         * // Sets the highlight mode of the annotation.
         * annotation.highlightMode = PdfHighlightMode.noHighlighting;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._highlightMode !== value) {
                this._dictionary.update('H', _reverseMapHighlightMode(value));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfWidgetAnnotation.prototype, "bounds", {
        /**
         * Gets the bounds of the annotation.
         *
         * @returns {{x: number, y: number, width: number, height: number}} Bounds.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
         * // Gets the bounds of the annotation.
         * let bounds : {x: number, y: number, width: number, height: number} = annotation.bounds;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoaded && typeof this._bounds === 'undefined') {
                this._bounds = _calculateBounds(this._dictionary, this._getPage());
            }
            if (typeof this._bounds === 'undefined' || this._bounds === null) {
                this._bounds = { x: 0, y: 0, width: 0, height: 0 };
            }
            return this._bounds;
        },
        /**
         * Sets the bounds of the annotation.
         *
         * @param {{x: number, y: number, width: number, height: number}} value Bounds
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
         * // Sets the bounds of the annotation.
         * annotation.bounds = {0, 0, 50, 50};
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value.x === 0 && value.y === 0 && value.width === 0 && value.height === 0) {
                throw new Error('Cannot set empty bounds');
            }
            this._bounds = value;
            if (this._page && this._page._isNew && this._page._pageSettings) {
                this._dictionary.update('Rect', _updateBounds(this));
            }
            else {
                this._dictionary.update('Rect', _getUpdatedBounds([value.x, value.y, value.width, value.height], this._getPage()));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfWidgetAnnotation.prototype, "textAlignment", {
        /**
         * Gets the text alignment of the annotation.
         *
         * @returns {PdfTextAlignment} Text alignment.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
         * // Gets the text alignment of the annotation.
         * let textAlignment: PdfTextAlignment = annotation.textAlignment;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._textAlignment === 'undefined' && this._dictionary.has('Q')) {
                this._textAlignment = this._dictionary.get('Q');
            }
            return this._textAlignment;
        },
        /**
         * Sets the text alignment of the annotation.
         *
         * @param {PdfTextAlignment} value Text alignment.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
         * // Sets the text alignment of the annotation.
         * annotation.textAlignment = PdfTextAlignment.left;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof this._textAlignment === 'undefined' || this._textAlignment !== value) {
                this._dictionary.update('Q', value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfWidgetAnnotation.prototype, "visibility", {
        /**
         * Gets the visibility.
         *
         * @returns {PdfFormFieldVisibility} Field visibility option.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the visibility.
         * let visibility: PdfFormFieldVisibility = field.itemAt(0).visibility;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var value;
            if (this._isLoaded) {
                value = PdfFormFieldVisibility.visible;
                var flag = PdfAnnotationFlag.default;
                if (this._hasFlags) {
                    flag = this.flags;
                    var flagValue = 3;
                    if ((flag & PdfAnnotationFlag.hidden) === PdfAnnotationFlag.hidden) {
                        flagValue = 0;
                    }
                    if ((flag & PdfAnnotationFlag.noView) === PdfAnnotationFlag.noView) {
                        flagValue = 1;
                    }
                    if ((flag & PdfAnnotationFlag.print) !== PdfAnnotationFlag.print) {
                        flagValue &= 2;
                    }
                    switch (flagValue) {
                        case 0:
                            value = PdfFormFieldVisibility.hidden;
                            break;
                        case 1:
                            value = PdfFormFieldVisibility.hiddenPrintable;
                            break;
                        case 2:
                            value = PdfFormFieldVisibility.visibleNotPrintable;
                            break;
                        case 3:
                            value = PdfFormFieldVisibility.visible;
                            break;
                    }
                }
                else {
                    value = PdfFormFieldVisibility.visibleNotPrintable;
                }
            }
            else {
                return this._visibility;
            }
            return value;
        },
        /**
         * Sets the visibility.
         *
         * @param {PdfFormFieldVisibility} value Visibility option.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the form field at index 0
         * let field: PdfField = document.form.fieldAt(0);
         * // Sets the visibility.
         * let field.itemAt(0).visibility = PdfFormFieldVisibility.hiddenPrintable;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._isLoaded) {
                _updateVisibility(this._dictionary, value);
                this._dictionary._updated = true;
            }
            else {
                switch (value) {
                    case PdfFormFieldVisibility.hidden:
                        this.flags = PdfAnnotationFlag.hidden;
                        break;
                    case PdfFormFieldVisibility.hiddenPrintable:
                        this.flags = PdfAnnotationFlag.noView | PdfAnnotationFlag.print;
                        break;
                    case PdfFormFieldVisibility.visible:
                        this.flags = PdfAnnotationFlag.print;
                        break;
                    case PdfFormFieldVisibility.visibleNotPrintable:
                        this.flags = PdfAnnotationFlag.default;
                        break;
                }
                this._visibility = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfWidgetAnnotation.prototype, "font", {
        /**
         * Gets the font of the item.
         *
         * @returns {PdfFont} font.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Access the form field at index 0
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Get the first item of the field
         * let item: PdfWidgetAnnotation = field.itemAt(0);
         * // Gets the font of the item.
         * let font: PdfFont = item.font;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._pdfFont) {
                var fontName = void 0;
                if (this._crossReference) {
                    var form = this._crossReference._document.form;
                    var fontData = this._obtainFontDetails();
                    if (form && form._dictionary.has('DR')) {
                        var resources = form._dictionary.get('DR');
                        if (resources.has('Font')) {
                            var fonts = resources.get('Font');
                            if (fonts.has(fontData.name)) {
                                var fontDictionary = fonts.get(fontData.name);
                                if (fontDictionary && fontData.name && fontDictionary.has('BaseFont')) {
                                    var baseFont = fontDictionary.get('BaseFont');
                                    var textFontStyle = PdfFontStyle.regular;
                                    if (baseFont) {
                                        fontName = baseFont.name;
                                        textFontStyle = _getFontStyle(baseFont.name);
                                        if (fontName.includes('-')) {
                                            fontName = fontName.substring(0, fontName.indexOf('-'));
                                        }
                                        this._pdfFont = _mapFont(fontName, fontData.size, textFontStyle, this);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if ((this._pdfFont === null || typeof this._pdfFont === 'undefined') || (!this._isLoaded && this._pdfFont.size === 1)) {
                this._pdfFont = this._circleCaptionFont;
            }
            return this._pdfFont;
        },
        /**
         * Sets the font of the item.
         *
         * @param {PdfFont} value font.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Access the form field at index 0
         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
         * // Get the first item of the field
         * let item: PdfWidgetAnnotation = field.itemAt(0);
         * // Set the font of the item.
         * item.font = new PdfStandardFont(PdfFontFamily.helvetica, 12, PdfFontStyle.bold);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value && value instanceof PdfFont) {
                this._pdfFont = value;
                this._initializeFont(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfWidgetAnnotation.prototype, "_defaultAppearance", {
        get: function () {
            if (typeof this._da === 'undefined' && this._dictionary.has('DA')) {
                var da = this._dictionary.get('DA');
                if (da && da !== '') {
                    this._da = new _PdfDefaultAppearance(da);
                }
            }
            return this._da;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfWidgetAnnotation.prototype, "_mkDictionary", {
        get: function () {
            var value;
            if (this._dictionary.has('MK')) {
                value = this._dictionary.get('MK');
            }
            return value;
        },
        enumerable: true,
        configurable: true
    });
    PdfWidgetAnnotation.prototype._create = function (page, bounds, field) {
        this._page = page;
        this._crossReference = page._crossReference;
        this._ref = this._crossReference._getNextReference();
        this._dictionary = new _PdfDictionary(this._crossReference);
        this._crossReference._cacheMap.set(this._ref, this._dictionary);
        this._dictionary._currentObj = this;
        this._dictionary.objId = this._ref.toString();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Widget'));
        this.flags |= PdfAnnotationFlag.print;
        this._dictionary.update('P', page._ref);
        page._addWidget(this._ref);
        this.border = new PdfAnnotationBorder();
        this.bounds = bounds;
        if (field) {
            this._field = field;
            this._dictionary.update('Parent', this._field._ref);
        }
        return this._dictionary;
    };
    PdfWidgetAnnotation.prototype._doPostProcess = function (isFlatten, recreateAppearance) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (recreateAppearance === void 0) { recreateAppearance = false; }
        if (isFlatten || recreateAppearance) {
            var appearanceStream = void 0;
            if (recreateAppearance || (isFlatten && !this._dictionary.has('AP'))) ;
            if (!appearanceStream && this._dictionary.has('AP')) {
                var dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    var reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                var bounds = void 0;
                if (isFlatten) {
                    var template = new PdfTemplate(appearanceStream, this._crossReference);
                    var page = this._getPage();
                    if (page) {
                        var graphics = page.graphics;
                        graphics.save();
                        if (page.rotation === PdfRotationAngle.angle90) {
                            graphics.translateTransform(graphics._size[0], graphics._size[1]);
                            graphics.rotateTransform(90);
                        }
                        else if (page.rotation === PdfRotationAngle.angle180) {
                            graphics.translateTransform(graphics._size[0], graphics._size[1]);
                            graphics.rotateTransform(-180);
                        }
                        else if (page.rotation === PdfRotationAngle.angle270) {
                            graphics.translateTransform(graphics._size[0], graphics._size[1]);
                            graphics.rotateTransform(270);
                        }
                        bounds = { x: this.bounds.x, y: this.bounds.y, width: template._size[0], height: template._size[1] };
                        graphics.drawTemplate(template, bounds);
                        graphics.restore();
                    }
                }
                else {
                    var appearance = void 0;
                    if (this._dictionary.has('AP')) {
                        appearance = this._dictionary.get('AP');
                    }
                    else {
                        var reference_8 = this._crossReference._getNextReference();
                        appearance = new _PdfDictionary(this._crossReference);
                        this._crossReference._cacheMap.set(reference_8, appearance);
                        this._dictionary.update('AP', reference_8);
                    }
                    _removeDuplicateReference(appearance, this._crossReference, 'N');
                    var reference = this._crossReference._getNextReference();
                    this._crossReference._cacheMap.set(reference, appearanceStream);
                    appearance.update('N', reference);
                }
            }
            this._dictionary._updated = false;
        }
    };
    PdfWidgetAnnotation.prototype._initializeFont = function (font) {
        this._pdfFont = font;
        var document;
        if (this._crossReference) {
            document = this._crossReference._document;
            var resource = void 0;
            if (document) {
                if (document.form._dictionary.has('DR')) {
                    resource = document.form._dictionary.get('DR');
                }
                else {
                    resource = new _PdfDictionary(this._crossReference);
                }
            }
            var fontDict = void 0;
            var isReference = false;
            if (resource.has('Font')) {
                var obj = resource.getRaw('Font'); // eslint-disable-line
                if (obj && obj instanceof _PdfReference) {
                    isReference = true;
                    fontDict = this._crossReference._fetch(obj);
                }
                else if (obj instanceof _PdfDictionary) {
                    fontDict = obj;
                }
            }
            if (!fontDict) {
                fontDict = new _PdfDictionary(this._crossReference);
                resource.update('Font', fontDict);
            }
            var keyName = _PdfName.get(_getNewGuidString());
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._pdfFont._dictionary);
            if (font instanceof PdfTrueTypeFont) {
                if (this._pdfFont._pdfFontInternals) {
                    this._crossReference._cacheMap.set(reference, this._pdfFont._pdfFontInternals);
                }
            }
            else if (this._pdfFont._dictionary) {
                this._crossReference._cacheMap.set(reference, this._pdfFont._dictionary);
            }
            fontDict.update(keyName.name, reference);
            resource._updated = true;
            document.form._dictionary.update('DR', resource);
            document.form._dictionary._updated = true;
            this._fontName = keyName.name;
            var defaultAppearance = new _PdfDefaultAppearance();
            defaultAppearance.fontName = this._fontName;
            defaultAppearance.fontSize = this._pdfFont._size;
            defaultAppearance.color = this.color ? this.color : [0, 0, 0];
            this._dictionary.update('DA', defaultAppearance.toString());
            if (isReference) {
                resource._updated = true;
            }
            this._isFont = true;
        }
    };
    PdfWidgetAnnotation.prototype._getPage = function () {
        if (!this._page) {
            var document_2;
            if (this._crossReference) {
                document_2 = this._crossReference._document;
            }
            var page = void 0;
            if (this._dictionary.has('P')) {
                var ref = this._dictionary.getRaw('P');
                if (ref && document_2) {
                    for (var i = 0; i < document_2.pageCount; i++) {
                        var entry = document_2.getPage(i);
                        if (entry && entry._ref === ref) {
                            page = entry;
                            break;
                        }
                    }
                }
            }
            if (!page && document_2 && this._ref) {
                page = _findPage(document_2, this._ref);
            }
            this._page = page;
        }
        return this._page;
    };
    PdfWidgetAnnotation.prototype._beginSave = function () {
        if (!this._isLoaded && !this._page._isNew) {
            var value = this._bounds;
            this._dictionary.update('Rect', _getUpdatedBounds([value.x, value.y, value.width, value.height], this._page));
        }
    };
    PdfWidgetAnnotation.prototype._parseBackColor = function () {
        var value;
        if ((this._isLoaded && this._hasBackColor) || (!this._isLoaded && !this._isTransparentBackColor)) {
            if (typeof this._backColor === 'undefined') {
                var dictionary = this._mkDictionary;
                if (dictionary && dictionary.has('BG')) {
                    var colorArray = dictionary.getArray('BG');
                    if (colorArray) {
                        this._backColor = _parseColor(colorArray);
                    }
                }
            }
            if (typeof this._backColor === 'undefined' || this._backColor === null) {
                this._backColor = [255, 255, 255];
            }
            value = this._backColor;
        }
        return value;
    };
    PdfWidgetAnnotation.prototype._parseBorderColor = function () {
        var value;
        if ((this._isLoaded && this._hasBorderColor) || (!this._isLoaded && !this._isTransparentBorderColor)) {
            if (typeof this._borderColor === 'undefined') {
                var dictionary = this._mkDictionary;
                if (dictionary && dictionary.has('BC')) {
                    var colorArray = dictionary.getArray('BC');
                    if (colorArray) {
                        this._borderColor = _parseColor(colorArray);
                    }
                }
            }
            if (typeof this._borderColor === 'undefined' || this._borderColor === null) {
                this._borderColor = [0, 0, 0];
            }
            value = this._borderColor;
        }
        return value;
    };
    PdfWidgetAnnotation.prototype._updateBackColor = function (value, setAppearance) {
        if (setAppearance === void 0) { setAppearance = false; }
        var isChanged = false;
        if (value.length === 4 && value[3] !== 255) {
            this._isTransparentBackColor = true;
            if (this._dictionary.has('BG')) {
                delete this._dictionary._map.BG;
                isChanged = true;
            }
            var mkDictionary = this._mkDictionary;
            if (mkDictionary && mkDictionary.has('BG')) {
                delete mkDictionary._map.BG;
                this._dictionary._updated = true;
                isChanged = true;
            }
        }
        else {
            this._isTransparentBackColor = false;
            if (typeof this.backColor === 'undefined' || this._backColor !== value) {
                if (typeof this._mkDictionary === 'undefined') {
                    this._dictionary.update('MK', new _PdfDictionary(this._crossReference));
                }
                this._mkDictionary.update('BG', [Number.parseFloat((value[0] / 255).toFixed(3)),
                    Number.parseFloat((value[1] / 255).toFixed(3)),
                    Number.parseFloat((value[2] / 255).toFixed(3))]);
                this._backColor = [value[0], value[1], value[2]];
                this._dictionary._updated = true;
                isChanged = true;
            }
        }
        if (setAppearance && isChanged && this._field) {
            this._field._setAppearance = true;
        }
    };
    PdfWidgetAnnotation.prototype._updateBorderColor = function (value) {
        if (value.length === 4 && value[3] !== 255) {
            this._isTransparentBorderColor = true;
            if (this._dictionary.has('BC')) {
                delete this._dictionary._map.BC;
            }
            var mkDictionary = this._mkDictionary;
            if (mkDictionary && mkDictionary.has('BC')) {
                delete mkDictionary._map.BC;
                if (this._dictionary.has('BS')) {
                    var bsDictionary = this._dictionary.get('BS');
                    if (bsDictionary && bsDictionary.has('W')) {
                        delete bsDictionary._map.W;
                    }
                }
                this._dictionary._updated = true;
            }
        }
        else {
            this._isTransparentBorderColor = false;
            if (typeof this.borderColor === 'undefined' || this.borderColor !== value) {
                if (typeof this._mkDictionary === 'undefined') {
                    this._dictionary.update('MK', new _PdfDictionary(this._crossReference));
                }
                this._mkDictionary.update('BC', [Number.parseFloat((value[0] / 255).toFixed(3)),
                    Number.parseFloat((value[1] / 255).toFixed(3)),
                    Number.parseFloat((value[2] / 255).toFixed(3))]);
                this._borderColor = [value[0], value[1], value[2]];
                this._dictionary._updated = true;
            }
        }
    };
    return PdfWidgetAnnotation;
}(PdfAnnotation));
/**
 * `PdfStateItem` class represents the check box field item objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access check box field
 * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
 * // Access first item of check box field
 * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;
 * // Sets the check box style as check
 * item.style = PdfCheckBoxStyle.check;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfStateItem = /** @class */ (function (_super) {
    __extends$6(PdfStateItem, _super);
    /**
     * Initializes a new instance of the `PdfStateItem` class.
     *
     * @private
     */
    function PdfStateItem() {
        return _super.call(this) || this;
    }
    /**
     * Parse an existing item of the field.
     *
     * @private
     * @param {_PdfDictionary} dictionary Widget dictionary.
     * @param {_PdfCrossReference} crossReference PDF cross reference.
     * @param {PdfField} field Field object.
     * @returns {PdfStateItem} Widget.
     */
    PdfStateItem._load = function (dictionary, crossReference, field) {
        var widget = new PdfStateItem();
        widget._isLoaded = true;
        widget._dictionary = dictionary;
        widget._crossReference = crossReference;
        widget._field = field;
        return widget;
    };
    Object.defineProperty(PdfStateItem.prototype, "checked", {
        /**
         * Gets the flag to indicate whether the field item is checked or not.
         *
         * @returns {boolean} Checked or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access check box field
         * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
         * // Access first item of check box field
         * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;
         * // Gets the flag to indicate whether the field item is checked or not.
         * let checked: boolean = item.checked;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return _checkField(this._dictionary);
        },
        /**
         * Sets the flag to indicate whether the field item is checked or not.
         *
         * @param {boolean} value Checked or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access check box field
         * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
         * // Access first item of check box field
         * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;
         * // Sets the style of the annotation
         * item.checked = true;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this.checked !== value) {
                if (this._field) {
                    this._setCheckedStatus(value);
                    this._field._setAppearance = true;
                }
                this._dictionary.update('AS', _PdfName.get(value ? 'Yes' : 'Off'));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfStateItem.prototype, "style", {
        /**
         * Gets the style of annotation.
         *
         * @returns {PdfCheckBoxStyle} Style of annotation.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access check box field
         * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
         * // Access first item of check box field
         * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;
         * // Gets the style of the annotation
         * let style: PdfCheckBoxStyle = item.style;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoaded) {
                var dictionary = this._mkDictionary;
                if (dictionary && dictionary.has('CA')) {
                    this._style = _stringToStyle(dictionary.get('CA'));
                }
                else {
                    this._style = PdfCheckBoxStyle.check;
                }
            }
            return this._style;
        },
        /**
         * Sets the style of annotation.
         *
         * @param {PdfCheckBoxStyle} value Style of annotation.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access check box field
         * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
         * // Access first item of check box field
         * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;
         * // Sets the style of the annotation
         * item.style = PdfCheckBoxStyle.check;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this.style !== value) {
                this._style = value;
                var dictionary = this._mkDictionary;
                if (!dictionary) {
                    dictionary = new _PdfDictionary(this._crossReference);
                    this._dictionary.update('MK', dictionary);
                }
                dictionary.update('CA', _styleToString(value));
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfStateItem.prototype._setCheckedStatus = function (value) {
        var check = value;
        var fieldValue = this._getItemValue(this._dictionary);
        this._unCheckOthers(this, fieldValue, value);
        if (check) {
            if (!fieldValue) {
                fieldValue = 'Yes';
            }
            this._field._dictionary.update('V', fieldValue);
            this._dictionary.update('AS', _PdfName.get(fieldValue));
            this._dictionary.update('V', _PdfName.get(fieldValue));
        }
        else if (this._field._dictionary) {
            if (this._field._dictionary.has('V')) {
                var v = this._field._dictionary.get('V');
                if (v && v.name === fieldValue) {
                    delete this._field._dictionary._map.V;
                }
            }
            this._field._dictionary.update('AS', _PdfName.get('Off'));
        }
    };
    PdfStateItem.prototype._unCheckOthers = function (child, value, isChecked) {
        if (!this._field._isUpdating) {
            this._field._isUpdating = true;
            var count = this._field.itemsCount;
            for (var i = 0; i < count; ++i) {
                var item = this._field.itemAt(i);
                if (item) {
                    if (item !== child) {
                        item.checked = ((this._getItemValue(item._dictionary) === value) && isChecked);
                    }
                    else if (!item.checked) {
                        item.checked = true;
                    }
                }
            }
        }
    };
    PdfStateItem.prototype._getItemValue = function (dictionary) {
        var itemValue = '';
        if (dictionary && dictionary.has('AS')) {
            var asValue = dictionary.get('AS');
            if (asValue && asValue.name !== 'Off') {
                itemValue = 'Off';
            }
        }
        if (itemValue === '') {
            if (dictionary && dictionary.has('AP')) {
                var apDictionary = dictionary.get('AP');
                if (apDictionary && apDictionary.has('N')) {
                    var normalAppearance = apDictionary.get('N');
                    var keyList_1 = [];
                    normalAppearance.forEach(function (key, value) {
                        keyList_1.push(key);
                    });
                    if (keyList_1.length > 0) {
                        for (var i = 0; i < keyList_1.length; i++) {
                            var key = keyList_1[Number.parseInt(i.toString(), 10)];
                            if (key && key !== 'Off') {
                                itemValue = key;
                                break;
                            }
                        }
                    }
                }
            }
        }
        return itemValue;
    };
    PdfStateItem.prototype._doPostProcess = function () {
        var style = this.checked ? _PdfCheckFieldState.checked : _PdfCheckFieldState.unchecked;
        var template = _getStateTemplate(style, this);
        if (template) {
            var page = this._getPage();
            if (page) {
                var graphics = page.graphics;
                graphics.save();
                if (page.rotation === PdfRotationAngle.angle90) {
                    graphics.translateTransform(graphics._size[0], graphics._size[1]);
                    graphics.rotateTransform(90);
                }
                else if (page.rotation === PdfRotationAngle.angle180) {
                    graphics.translateTransform(graphics._size[0], graphics._size[1]);
                    graphics.rotateTransform(-180);
                }
                else if (page.rotation === PdfRotationAngle.angle270) {
                    graphics.translateTransform(graphics._size[0], graphics._size[1]);
                    graphics.rotateTransform(270);
                }
                graphics._sw._setTextRenderingMode(_TextRenderingMode.fill);
                graphics.drawTemplate(template, this.bounds);
                graphics.restore();
            }
        }
        this._dictionary._updated = false;
    };
    PdfStateItem.prototype._postProcess = function (value) {
        var field = this._field;
        if (!value) {
            value = (field && field.checked) ? 'Yes' : 'Off';
        }
        this._dictionary.update('AS', _PdfName.get(value));
    };
    PdfStateItem.prototype._setField = function (field) {
        this._field = field;
        this._field._stringFormat = new PdfStringFormat(this.textAlignment, PdfVerticalAlignment.middle);
        this._field._addToKid(this);
    };
    return PdfStateItem;
}(PdfWidgetAnnotation));
/**
 * `PdfRadioButtonListItem` class represents the radio button field item objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new radio button list field
 * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');
 * // Create and add first item
 * let first: PdfRadioButtonListItem = field.add('1-9', {x: 100, y: 140, width: 20, height: 20});
 * // Create and add second item
 * let second: PdfRadioButtonListItem = new PdfRadioButtonListItem('10-49', {x: 100, y: 170, width: 20, height: 20}, page);
 * field.add(second);
 * // Create and add third item
 * let third: PdfRadioButtonListItem = new PdfRadioButtonListItem('50-59', {x: 100, y: 200, width: 20, height: 20}, field);
 * field.add(third);
 * // Sets selected index of the radio button list field
 * field.selectedIndex = 0;
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfRadioButtonListItem = /** @class */ (function (_super) {
    __extends$6(PdfRadioButtonListItem, _super);
    function PdfRadioButtonListItem(value, bounds, item) {
        var _this = _super.call(this) || this;
        if (item && value && bounds) {
            if (item instanceof PdfField) {
                _this._initializeItem(value, bounds, item.page, item);
            }
            else {
                _this._initializeItem(value, bounds, item);
            }
        }
        return _this;
    }
    /**
     * Parse an existing item of the field.
     *
     * @private
     * @param {_PdfDictionary} dictionary Widget dictionary.
     * @param {_PdfCrossReference} crossReference PDF cross reference.
     * @param {PdfField} field Field object.
     * @returns {PdfRadioButtonListItem} Widget.
     */
    PdfRadioButtonListItem._load = function (dictionary, crossReference, field) {
        var widget = new PdfRadioButtonListItem();
        widget._isLoaded = true;
        widget._dictionary = dictionary;
        widget._crossReference = crossReference;
        widget._field = field;
        return widget;
    };
    Object.defineProperty(PdfRadioButtonListItem.prototype, "selected", {
        /**
         * Gets the flag to indicate whether the field item is selected or not.
         *
         * @returns {boolean} Selected or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Create a new radio button list field
         * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');
         * // Access first list field item
         * let item: PdfRadioButtonListItem = field.itemAt(0);
         * // Gets the flag to indicate whether the field item is selected or not.
         * let selected: boolean = item.selected;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._index === this._field.selectedIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRadioButtonListItem.prototype, "value", {
        /**
         * Gets the value of the radio button list field item
         *
         * @returns {string} Value of the radio button list field item.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Create a new radio button list field
         * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');
         * // Access first list field item
         * let item: PdfRadioButtonListItem = field.itemAt(0);
         * // Gets the value of the radio button list field item
         * let value: string = item.value;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoaded && !this._optionValue) {
                this._optionValue = _getItemValue(this._dictionary);
            }
            return this._optionValue;
        },
        /**
         * Sets the value of the radio button list field item
         *
         * @param {string} option Value of the radio button list field item.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Create a new radio button list field
         * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');
         * // Access first list field item
         * let item: PdfRadioButtonListItem = field.itemAt(0);
         * // Sets the value of the radio button list field item
         * item.value = '1-9';
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (option) {
            this._optionValue = option;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRadioButtonListItem.prototype, "backColor", {
        /**
         * Gets the back color of the annotation.
         *
         * @returns {number[]} Color as R, G, B color array in between 0 to 255.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
         * // Gets the back color of the annotation
         * let backColor: number[] = annotation.backColor;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._parseBackColor();
        },
        /**
         * Sets the back color of the annotation.
         *
         * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Access the radio button list field
         * let field: PdfRadioButtonListField = form.fieldAt(0) as PdfRadioButtonListField;
         * // Sets the back color of the radio button list item
         * field.itemAt(0).backColor = [255, 255, 255];
         * // Sets the background color of the field item to transparent
         * field.itemAt(1).backColor = [0, 0, 0, 0];
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._updateBackColor(value, true);
        },
        enumerable: true,
        configurable: true
    });
    PdfRadioButtonListItem.prototype._initializeItem = function (value, bounds, page, field) {
        this._optionValue = value;
        this._page = page;
        this._create(this._page, bounds, this._field);
        this.textAlignment = PdfTextAlignment.left;
        this._dictionary.update('MK', new _PdfDictionary(this._crossReference));
        this._mkDictionary.update('BC', [0, 0, 0]);
        this._mkDictionary.update('BG', [1, 1, 1]);
        this.style = PdfCheckBoxStyle.circle;
        this._dictionary.update('DA', '/TiRo 0 Tf 0 0 0 rg');
        if (field) {
            this._setField(field);
            this._dictionary.update('Parent', field._ref);
        }
    };
    PdfRadioButtonListItem.prototype._postProcess = function (value) {
        var field = this._field;
        if (!value && field && field.selectedIndex !== -1) {
            value = field.itemAt(field.selectedIndex).value;
        }
        if (this.value === value) {
            this._dictionary.update('AS', _PdfName.get(this.value));
        }
        else {
            this._dictionary.update('AS', _PdfName.get('Off'));
        }
    };
    return PdfRadioButtonListItem;
}(PdfStateItem));
/**
 * `PdfListBoxItem` class represents the list and combo box field item objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new list box field
 * let field: PdfListBoxField = new PdfListBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
 * // Add list items to the field.
 * field.addItem(new PdfListFieldItem('English', 'English'));
 * field.addItem(new PdfListFieldItem('French', 'French'));
 * field.addItem(new PdfListFieldItem('German', 'German'));
 * // Sets the selected index
 * field.selectedIndex = 2;
 * // Sets the flag indicates whether the list box allows multiple selections.
 * field.multiSelect = true;
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfListFieldItem = /** @class */ (function (_super) {
    __extends$6(PdfListFieldItem, _super);
    function PdfListFieldItem(text, value, field) {
        var _this = _super.call(this) || this;
        if (text && value) {
            _this._initializeItem(text, value, field);
        }
        return _this;
    }
    /**
     * Parse an existing item of the field.
     *
     * @private
     * @param {_PdfDictionary} dictionary Widget dictionary.
     * @param {_PdfCrossReference} crossReference PDF cross reference.
     * @param {PdfField} field Field object.
     * @returns {PdfListFieldItem} Widget.
     */
    PdfListFieldItem._load = function (dictionary, crossReference, field) {
        var widget = new PdfListFieldItem();
        widget._isLoaded = true;
        widget._dictionary = dictionary;
        widget._crossReference = crossReference;
        widget._field = field;
        return widget;
    };
    Object.defineProperty(PdfListFieldItem.prototype, "text", {
        /**
         * Gets the text of the annotation.
         *
         * @returns {string} Text.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Create a new radio button list field
         * let field: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;
         * // Access first list field item
         * let item: PdfListFieldItem = field.itemAt(0);
         * // Gets the text of the list field item
         * let text: string = item.text;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._text === 'undefined' &&
                typeof this._field !== 'undefined' &&
                (this._field instanceof PdfListBoxField || this._field instanceof PdfComboBoxField)) {
                this._text = this._field._options[Number.parseInt(this._index.toString(), 10)][1];
            }
            return this._text;
        },
        /**
         * Sets the text of the annotation.
         *
         * @param {string} value Text.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Create a new radio button list field
         * let field: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;
         * // Access first list field item
         * let item: PdfListFieldItem = field.itemAt(0);
         * // Sets the text of the list field item
         * item.text = '1-9';
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof value === 'string' &&
                typeof this._field !== 'undefined' &&
                (this._field instanceof PdfListBoxField || this._field instanceof PdfComboBoxField)) {
                if (value !== this._field._options[Number.parseInt(this._index.toString(), 10)][1]) {
                    this._field._options[Number.parseInt(this._index.toString(), 10)][1] = value;
                    this._text = value;
                    this._field._dictionary._updated = true;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListFieldItem.prototype, "selected", {
        /**
         * Gets the flag to indicate whether the field item is selected or not (Read only).
         *
         * @returns {boolean} Selected or not.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Gets the first page of the document
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Access the PDF form
         * let form: PdfForm = document.form;
         * // Create a new radio button list field
         * let field: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;
         * // Access first list field item
         * let item: PdfListFieldItem = field.itemAt(0);
         * // Gets the flag to indicate whether the field item is selected or not.
         * let selected: boolean = item.selected;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._index === this._field.selectedIndex;
        },
        enumerable: true,
        configurable: true
    });
    PdfListFieldItem.prototype._initializeItem = function (text, value, field) {
        this._text = text;
        this._value = value;
        if (field && field instanceof PdfListBoxField) {
            field._addToOptions(this, field);
        }
    };
    return PdfListFieldItem;
}(PdfStateItem));
/**
 * `PdfAnnotationCaption` class represents the caption text and properties of annotations.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Get the first annotation of the page
 * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
 * // Create and set annotation caption values
 * annotation.caption = new PdfAnnotationCaption(true, PdfLineCaptionType.inline, [10, 10]);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAnnotationCaption = /** @class */ (function () {
    function PdfAnnotationCaption(cap, type, offset) {
        this._cap = typeof cap !== 'undefined' ? cap : false;
        this._type = typeof type !== 'undefined' ? type : PdfLineCaptionType.inline;
        this._offset = typeof offset !== 'undefined' ? offset : [0, 0];
    }
    Object.defineProperty(PdfAnnotationCaption.prototype, "cap", {
        /**
         * Gets the boolean flag indicating whether annotation has caption or not.
         *
         * @returns {boolean} Caption.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the boolean flag indicating whether annotation has caption or not.
         * let cap: boolean = annotation.caption.cap;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._cap;
        },
        /**
         * Sets the boolean flag indicating whether annotation has caption or not.
         *
         * @param {boolean} value Caption.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the boolean flag indicating whether annotation has caption or not.
         * annotation.caption.cap = true;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._cap) {
                this._cap = value;
                if (this._dictionary) {
                    this._dictionary.update('Cap', value);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotationCaption.prototype, "type", {
        /**
         * Gets the caption type of the annotation.
         *
         * @returns {PdfLineCaptionType} Caption type.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the caption type of the annotation.
         * let type: PdfLineCaptionType = annotation.caption.type;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._type;
        },
        /**
         * Sets the caption type of the annotation.
         *
         * @param {PdfLineCaptionType} value Caption type.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the caption type of the annotation.
         * annotation.caption.type = PdfLineCaptionType.inline;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._type) {
                this._type = value;
                if (this._dictionary) {
                    this._dictionary.update('CP', _PdfName.get(value === PdfLineCaptionType.top ? 'Top' : 'Inline'));
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotationCaption.prototype, "offset", {
        /**
         * Gets the offset position of the annotation.
         *
         * @returns {Array<number>} Caption offset.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the offset position of the annotation.
         * let offset: Array<number> = annotation.caption.offset;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._offset;
        },
        /**
         * Sets the offset position of the annotation.
         *
         * @param {Array<number>} value Caption offset.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Sets the offset position of the annotation.
         * annotation.caption.offset = [10, 10];
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (_areNotEqual(value, this._offset)) {
                this._offset = value;
                if (this._dictionary) {
                    this._dictionary.update('CO', value);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    return PdfAnnotationCaption;
}());
/**
 * `PdfAnnotationLineEndingStyle` class represents the line ending styles of annotations.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Get the first annotation of the page
 * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
 * // Initializes a new instance of the `PdfAnnotationLineEndingStyle` class.
 * annotation.lineEndingStyle = new PdfAnnotationLineEndingStyle(PdfLineEndingStyle.openArrow, PdfLineEndingStyle.closeArrow);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAnnotationLineEndingStyle = /** @class */ (function () {
    function PdfAnnotationLineEndingStyle(begin, end) {
        this._begin = typeof begin !== 'undefined' ? begin : PdfLineEndingStyle.none;
        this._end = typeof end !== 'undefined' ? end : PdfLineEndingStyle.none;
    }
    Object.defineProperty(PdfAnnotationLineEndingStyle.prototype, "begin", {
        /**
         * Gets the begin line ending style of the annotation.
         *
         * @returns {PdfLineEndingStyle} Begin line ending style.
         * `PdfAnnotationLineEndingStyle` class represents the line ending styles of annotations.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the begin line ending style of the annotation.
         * let begin: PdfLineEndingStyle = annotation.lineEndingStyle.begin;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._begin;
        },
        /**
         * Sets the begin line ending style of the annotation.
         *
         * @param {PdfLineEndingStyle} value Begin line ending style.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Initializes a new instance of the `PdfAnnotationLineEndingStyle` class.
         * let lineEndingStyle = new PdfAnnotationLineEndingStyle();
         * // Sets the begin line ending style of the annotation.
         * lineEndingStyle.begin = PdfLineEndingStyle.openArrow;
         * // Sets the end line ending style of the annotation.
         * lineEndingStyle.end = PdfLineEndingStyle.closeArrow;
         * // Sets the line ending style to the annotation
         * annotation.lineEndingStyle = lineEndingStyle;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._begin) {
                this._begin = value;
                if (this._dictionary) {
                    this._dictionary.update('LE', [_PdfName.get(_reverseMapEndingStyle(value)), _PdfName.get(_reverseMapEndingStyle(this._end))]);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotationLineEndingStyle.prototype, "end", {
        /**
         * Gets the begin line ending style of the annotation.
         *
         * @returns {PdfLineEndingStyle} End line ending style.
         * `PdfAnnotationLineEndingStyle` class represents the line ending styles of annotations.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the end line ending style of the annotation.
         * let end: PdfLineEndingStyle = annotation.lineEndingStyle.end;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._end;
        },
        /**
         * Sets the begin line ending style of the annotation.
         *
         * @param {PdfLineEndingStyle} value End line ending style.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Initializes a new instance of the `PdfAnnotationLineEndingStyle` class.
         * let lineEndingStyle = new PdfAnnotationLineEndingStyle();
         * // Sets the begin line ending style of the annotation.
         * lineEndingStyle.begin = PdfLineEndingStyle.openArrow;
         * // Sets the end line ending style of the annotation.
         * lineEndingStyle.end = PdfLineEndingStyle.closeArrow;
         * // Sets the line ending style to the annotation
         * annotation.lineEndingStyle = lineEndingStyle;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._end) {
                this._end = value;
                if (this._dictionary) {
                    this._dictionary.update('LE', [_PdfName.get(_reverseMapEndingStyle(this._begin)), _PdfName.get(_reverseMapEndingStyle(value))]);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    return PdfAnnotationLineEndingStyle;
}());
/**
 * `PdfInteractiveBorder` class represents the border of the field.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the PDF form field
 * let field: PdfField = document.form.fieldAt(0);
 * // Gets the width of the field border.
 * let width: number = field.border.width;
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfInteractiveBorder = /** @class */ (function () {
    function PdfInteractiveBorder(width, style, dash) {
        this._width = typeof width !== 'undefined' ? width : 1;
        this._style = typeof style !== 'undefined' ? style : PdfBorderStyle.solid;
        if (typeof dash !== 'undefined' && Array.isArray(dash)) {
            this._dash = dash;
        }
    }
    Object.defineProperty(PdfInteractiveBorder.prototype, "width", {
        /**
         * Gets the width of the field border.
         *
         * @returns {number} border width.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the PDF form field
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the width of the annotation border.
         * let width: number = field.border.width;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._width;
        },
        /**
         * Sets the width of the field border.
         *
         * @param {number} value width.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the PDF form field
         * let field: PdfField = document.form.fieldAt(0);
         * // Initializes a new instance of the `PdfInteractiveBorder` class.
         * let border: PdfInteractiveBorder = new PdfInteractiveBorder();
         * //Sets the width of the annotation border.
         * border.width = 10;
         * //Sets the style of the annotation border.
         * border.style = PdfBorderStyle.dashed;
         * //Sets the dash pattern of the annotation border.
         * border.dash = [1, 2, 1];
         * // Sets the border to the PDF form field
         * field.border = border;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._width) {
                this._width = value;
                if (this._dictionary) {
                    var bs = this._dictionary.has('BS') ? this._dictionary.get('BS') : new _PdfDictionary(this._crossReference);
                    bs.update('Type', _PdfName.get('Border'));
                    bs.update('W', this._width);
                    bs.update('S', _mapBorderStyle(this._style));
                    if (this._dash) {
                        bs.update('D', this._dash);
                    }
                    this._dictionary.update('BS', bs);
                    this._dictionary._updated = true;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfInteractiveBorder.prototype, "style", {
        /**
         * Gets the border line style of the field border.
         *
         * @returns {PdfBorderStyle} Border style.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the PDF form field
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the border line style of the annotation border.
         * let style: PdfBorderStyle = field.border.style;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._style;
        },
        /**
         * Sets the border line style of the field border.
         *
         * @param {PdfBorderStyle} value Border style.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the PDF form field
         * let field: PdfField = document.form.fieldAt(0);
         * // Initializes a new instance of the `PdfInteractiveBorder` class.
         * let border: PdfInteractiveBorder = new PdfInteractiveBorder();
         * //Sets the width of the annotation border.
         * border.width = 10;
         * //Sets the style of the annotation border.
         * border.style = PdfBorderStyle.dashed;
         * //Sets the dash pattern of the annotation border.
         * border.dash = [1, 2, 1];
         * // Sets the border to the PDF form field
         * field.border = border;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._style) {
                this._style = value;
                if (this._dictionary) {
                    var bs = this._dictionary.has('BS') ? this._dictionary.get('BS') : new _PdfDictionary(this._crossReference);
                    bs.update('Type', _PdfName.get('Border'));
                    bs.update('W', this._width);
                    bs.update('S', _mapBorderStyle(this._style));
                    if (this._dash) {
                        bs.update('D', this._dash);
                    }
                    this._dictionary.update('BS', bs);
                    this._dictionary._updated = true;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfInteractiveBorder.prototype, "dash", {
        /**
         * Gets the dash pattern of the field border.
         *
         * @returns {Array<number>} Dash pattern.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the PDF form field
         * let field: PdfField = document.form.fieldAt(0);
         * // Gets the dash pattern of the field border.
         * let dash: Array<number> = field.border.dash;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._dash;
        },
        /**
         * Sets the dash pattern of the field border.
         *
         * @param {Array<number>} value Dash pattern.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the PDF form field
         * let field: PdfField = document.form.fieldAt(0);
         * // Initializes a new instance of the `PdfInteractiveBorder` class.
         * let border: PdfInteractiveBorder = new PdfInteractiveBorder();
         * //Sets the width of the annotation border.
         * border.width = 10;
         * //Sets the style of the annotation border.
         * border.style = PdfBorderStyle.dashed;
         * //Sets the dash pattern of the annotation border.
         * border.dash = [1, 2, 1];
         * // Sets the border to the PDF form field
         * field.border = border;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (typeof this._dash === 'undefined' || _areNotEqual(value, this._dash)) {
                this._dash = value;
                if (this._dictionary) {
                    var bs = this._dictionary.has('BS') ? this._dictionary.get('BS') : new _PdfDictionary(this._crossReference);
                    bs.update('Type', _PdfName.get('Border'));
                    bs.update('W', this._width);
                    bs.update('S', _mapBorderStyle(this._style));
                    bs.update('D', this._dash);
                    this._dictionary.update('BS', bs);
                    this._dictionary._updated = true;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    return PdfInteractiveBorder;
}());
/**
 * `PdfAnnotationBorder` class represents the border properties of annotations.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Get the first annotation of the page
 * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
 * // Initializes a new instance of the ` PdfAnnotationBorder ` class.
 * let border: PdfAnnotationBorder = new PdfAnnotationBorder ();
 * //Sets the width of the annotation border.
 * border.width = 10;
 * //Sets the style of the annotation border.
 * border.style = PdfBorderStyle.dashed;
 * //Sets the dash pattern of the annotation border.
 * border.dash = [1, 2, 1];
 * // Sets the border to the PDF form field
 * annotation.border = border;
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAnnotationBorder = /** @class */ (function (_super) {
    __extends$6(PdfAnnotationBorder, _super);
    function PdfAnnotationBorder(width, hRadius, vRadius, style, dash) {
        var _this = _super.call(this, width, style, dash) || this;
        _this._hRadius = typeof hRadius !== 'undefined' ? hRadius : 0;
        _this._vRadius = typeof vRadius !== 'undefined' ? vRadius : 0;
        return _this;
    }
    Object.defineProperty(PdfAnnotationBorder.prototype, "width", {
        /**
         * Gets the width of the annotation border.
         *
         * @returns {number} border width.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the width of the annotation border.
         * let width: number = annotation.border.width;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._width;
        },
        /**
         * Sets the width of the annotation border.
         *
         * @param {number} value width.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Initializes a new instance of the ` PdfAnnotationBorder ` class.
         * let border: PdfAnnotationBorder = new PdfAnnotationBorder ();
         * //Sets the width of the annotation border.
         * border.width = 10;
         * //Sets the style of the annotation border.
         * border.style = PdfBorderStyle.dashed;
         * //Sets the dash pattern of the annotation border.
         * border.dash = [1, 2, 1];
         * // Sets the border to the PDF form field
         * annotation.border = border;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._width) {
                this._width = value;
                if (this._dictionary) {
                    this._dictionary.update('Border', [this._hRadius, this._vRadius, this._width]);
                    var bs = this._dictionary.has('BS') ? this._dictionary.get('BS') : new _PdfDictionary(this._crossReference);
                    bs.update('Type', _PdfName.get('Border'));
                    bs.update('W', this._width);
                    bs.update('S', _mapBorderStyle(this._style));
                    if (this._dash) {
                        bs.update('D', this._dash);
                    }
                    this._dictionary.update('BS', bs);
                    this._dictionary._updated = true;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotationBorder.prototype, "hRadius", {
        /**
         * Gets the horizontal radius of the annotation border.
         *
         * @returns {number} horizontal radius.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the horizontal radius of the annotation border.
         * let hRadius: number = annotation.border.hRadius;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._hRadius;
        },
        /**
         * Sets the horizontal radius of the annotation border.
         *
         * @param {number} value horizontal radius.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Initializes a new instance of the ` PdfAnnotationBorder ` class.
         * let border: PdfAnnotationBorder = new PdfAnnotationBorder ();
         * //Sets the width of the annotation border.
         * border.width = 10;
         * // Sets the horizontal radius of the annotation border.
         * border.hRadius = 2;
         * //Sets the style of the annotation border.
         * border.style = PdfBorderStyle.dashed;
         * //Sets the dash pattern of the annotation border.
         * border.dash = [1, 2, 1];
         * // Sets the border to the PDF form field
         * annotation.border = border;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._hRadius) {
                this._hRadius = value;
                if (this._dictionary) {
                    this._dictionary.update('Border', [this._hRadius, this._vRadius, this._width]);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotationBorder.prototype, "vRadius", {
        /**
         * Gets the vertical radius of the annotation border.
         *
         * @returns {number} vertical radius.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Gets the vertical radius of the annotation border.
         * let vRadius: number = annotation.border.vRadius;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._vRadius;
        },
        /**
         * Sets the vertical radius of the annotation border.
         *
         * @param {number} value vertical radius.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
         * // Initializes a new instance of the ` PdfAnnotationBorder ` class.
         * let border: PdfAnnotationBorder = new PdfAnnotationBorder ();
         * //Sets the width of the annotation border.
         * border.width = 10;
         * // Sets the vertical radius of the annotation border.
         * border.vRadius = 2;
         * //Sets the style of the annotation border.
         * border.style = PdfBorderStyle.dashed;
         * //Sets the dash pattern of the annotation border.
         * border.dash = [1, 2, 1];
         * // Sets the border to the PDF form field
         * annotation.border = border;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._vRadius) {
                this._vRadius = value;
                if (this._dictionary) {
                    this._dictionary.update('Border', [this._hRadius, this._vRadius, this._width]);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    return PdfAnnotationBorder;
}(PdfInteractiveBorder));
/**
 * `PdfBorderEffect` class represents the border effects of annotations.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Get the first annotation of the page
 * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
 * // Initializes a new instance of the `PdfBorderEffect` class.
 * let borderEffect: PdfBorderEffect = new PdfBorderEffect();
 * // Sets the intensity of the annotation border.
 * borderEffect.intensity = 2;
 * // Sets the effect style of the annotation border.
 * borderEffect.style = PdfBorderEffectStyle.cloudy;
 * // Sets border effect to the annotation.
 * annotation.borderEffect = borderEffect;
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfBorderEffect = /** @class */ (function () {
    function PdfBorderEffect(dictionary) {
        this._intensity = 0;
        if (typeof dictionary !== 'undefined' && dictionary !== null) {
            if (dictionary.has('BE')) {
                var borderEffect = this._dictionary.get('BE');
                if (borderEffect) {
                    if (borderEffect.has('I')) {
                        this._intensity = borderEffect.get('I');
                    }
                    if (borderEffect.has('S')) {
                        this._style = this._getBorderEffect(borderEffect.get('S'));
                    }
                }
            }
        }
        else {
            this._dictionary = new _PdfDictionary();
            this._dictionary.set('I', this._intensity);
            this._dictionary.set('S', this._styleToEffect(this._style));
        }
    }
    Object.defineProperty(PdfBorderEffect.prototype, "intensity", {
        /**
         * Gets the intensity of the annotation border.
         *
         * @returns {number} intensity.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
         * // Gets the intensity of the annotation border.
         * let intensity: number = annotation.borderEffect.intensity;
         * // Gets the effect style of the annotation border.
         * let style: PdfBorderEffectStyle = annotation.borderEffect.style;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._intensity;
        },
        /**
         * Sets the intensity of the annotation border.
         *
         * @param {number} value intensity.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
         * // Initializes a new instance of the `PdfBorderEffect` class.
         * let borderEffect: PdfBorderEffect = new PdfBorderEffect();
         * // Sets the intensity of the annotation border.
         * borderEffect.intensity = 2;
         * // Sets the effect style of the annotation border.
         * borderEffect.style = PdfBorderEffectStyle.cloudy;
         * // Sets border effect to the annotation.
         * annotation.borderEffect = borderEffect;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._intensity) {
                this._intensity = value;
                if (this._dictionary) {
                    var bs = this._dictionary.has('BE') ? this._dictionary.get('BE') : new _PdfDictionary(this._crossReference);
                    bs.update('I', this._intensity);
                    bs.update('S', this._styleToEffect(this._style));
                    this._dictionary.update('BE', bs);
                    this._dictionary._updated = true;
                }
                this._dictionary._updated = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfBorderEffect.prototype, "style", {
        /**
         * Gets the effect style of the annotation border.
         *
         * @returns {PdfBorderEffectStyle} effect style.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
         * // Gets the intensity of the annotation border.
         * let intensity: number = annotation.borderEffect.intensity;
         * // Gets the effect style of the annotation border.
         * let style: PdfBorderEffectStyle = annotation.borderEffect.style;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._style;
        },
        /**
         * Sets the effect style of the annotation border.
         *
         * @param {PdfBorderEffectStyle} value effect style.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the first page
         * let page: PdfPage = document.getPage(0) as PdfPage;
         * // Get the first annotation of the page
         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
         * // Initializes a new instance of the `PdfBorderEffect` class.
         * let borderEffect: PdfBorderEffect = new PdfBorderEffect();
         * // Sets the intensity of the annotation border.
         * borderEffect.intensity = 2;
         * // Sets the effect style of the annotation border.
         * borderEffect.style = PdfBorderEffectStyle.cloudy;
         * // Sets border effect to the annotation.
         * annotation.borderEffect = borderEffect;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._style) {
                this._style = value;
                if (this._dictionary) {
                    var bs = this._dictionary.has('BE') ?
                        this._dictionary.get('BE') :
                        new _PdfDictionary(this._crossReference);
                    bs.update('I', this._intensity);
                    bs.update('S', this._styleToEffect(this._style));
                    this._dictionary.update('BE', bs);
                    this._dictionary._updated = true;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfBorderEffect.prototype._getBorderEffect = function (value) {
        if (value === '/C') {
            return PdfBorderEffectStyle.cloudy;
        }
        else {
            return PdfBorderEffectStyle.solid;
        }
    };
    PdfBorderEffect.prototype._styleToEffect = function (value) {
        if (value === PdfBorderEffectStyle.cloudy) {
            return 'C';
        }
        else {
            return 'S';
        }
    };
    return PdfBorderEffect;
}());
var _PaintParameter = /** @class */ (function () {
    function _PaintParameter() {
        this.borderWidth = 1;
    }
    return _PaintParameter;
}());
var _CloudStyleArc = /** @class */ (function () {
    function _CloudStyleArc() {
        this.startAngle = 0;
        this.endAngle = 0;
    }
    return _CloudStyleArc;
}());

/**
 * The class provides methods and properties to handle the collection of `PdfAnnotation`.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access annotation coolection from first page
 * let annotations: PdfAnnotationCollection = document.getPage(0).annotations;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAnnotationCollection = /** @class */ (function () {
    /**
     * Represents a annotation collection.
     *
     * @private
     * @param {Array<_PdfReference>} array Annotation references.
     * @param {_PdfCrossReference} xref Cross reference object.
     * @param {PdfPage} page PDF page object.
     */
    function PdfAnnotationCollection(array, xref, page) {
        this._isExport = false;
        if (_isNullOrUndefined(array)) {
            this._annotations = array;
        }
        else {
            this._annotations = [];
        }
        this._page = page;
        this._crossReference = xref;
        this._parsedAnnotations = new Map();
        this._comments = [];
    }
    Object.defineProperty(PdfAnnotationCollection.prototype, "count", {
        /**
         * Gets the annotation count (Read only).
         *
         * @returns {number} Number of annotations.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the annotation count
         * let count: number = page.annotations.count;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._annotations.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the `PdfAnnotation` at the specified index.
     *
     * @param {number} index Field index.
     * @returns {PdfAnnotation} Annotation at the specified index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Access the annotation at index 0
     * let annotation: PdfAnnotation = page.annotations.at(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfAnnotationCollection.prototype.at = function (index) {
        if (index < 0 || index >= this._annotations.length) {
            throw Error('Index out of range.');
        }
        if (!this._parsedAnnotations.has(index)) {
            var dictionary = this._annotations[Number.parseInt(index.toString(), 10)];
            if (dictionary && dictionary instanceof _PdfReference) {
                dictionary = this._crossReference._fetch(dictionary);
            }
            if (dictionary && dictionary instanceof _PdfDictionary) {
                var annotation = this._parseAnnotation(dictionary);
                if (annotation) {
                    annotation._ref = this._annotations[Number.parseInt(index.toString(), 10)];
                    this._parsedAnnotations.set(index, annotation);
                }
            }
        }
        return this._parsedAnnotations.get(index);
    };
    /**
     * Add a new `PdfAnnotation` into the collection.
     *
     * @param {PdfAnnotation} annotation Annotation to add.
     * @returns {number} Annotation index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Add a new annotation into the collection
     * page.annotations.add(annotation);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfAnnotationCollection.prototype.add = function (annotation) {
        if (typeof annotation === 'undefined' || annotation === null) {
            throw Error('annotation cannot be null or undefined');
        }
        if (annotation._isLoaded) {
            throw Error('cannot add an existing annotation');
        }
        annotation._initialize(this._page);
        var reference;
        if (typeof annotation._ref !== 'undefined' && annotation._ref._isNew) {
            reference = annotation._ref;
        }
        else {
            reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, annotation._dictionary);
            annotation._ref = reference;
        }
        var index = this._annotations.length;
        this._annotations.push(reference);
        this._parsedAnnotations.set(index, annotation);
        var isAdded = false;
        if (this._page && this._page._pageDictionary.has('Annots')) {
            var collection = this._page._pageDictionary.get('Annots');
            if (collection !== null && typeof collection !== 'undefined' && collection.indexOf(reference) === -1) {
                collection.push(reference);
                this._page._pageDictionary.set('Annots', collection);
                isAdded = true;
            }
        }
        if (!isAdded) {
            this._page._pageDictionary.set('Annots', this._annotations);
        }
        this._page._pageDictionary._updated = true;
        if (annotation && annotation instanceof PdfComment) {
            this._addCommentsAndReview(annotation, annotation._dictionary.get('F'));
        }
        this._updateCustomAppearanceResource(annotation);
        return index;
    };
    /**
     * Remove an annotation from the collection.
     *
     * @param {PdfAnnotation} annotation Annotation to remove.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Access first annotation from the PDF page
     * let annotation: PdfAnnotation = page.annotations.at(0);
     * // Remove an annotation from the collection
     * page.annotations.remove(annotation);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfAnnotationCollection.prototype.remove = function (annotation) {
        if (annotation && annotation._ref) {
            var index = this._annotations.lastIndexOf(annotation._ref);
            if (index > -1) {
                this.removeAt(index);
            }
        }
    };
    /**
     * Remove an annotation from the collection at the specified index.
     *
     * @param {number} index Annotation index.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Remove an annotation from the collection
     * page.annotations.removeAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfAnnotationCollection.prototype.removeAt = function (index) {
        if (index < 0 || index >= this._annotations.length) {
            throw Error('Index out of range.');
        }
        var reference = this._annotations[Number.parseInt(index.toString(), 10)];
        if (reference && this._page) {
            var array = this._page._getProperty('Annots');
            var actualIndex = array.indexOf(reference);
            if (actualIndex > -1) {
                array.splice(actualIndex, 1);
            }
            this._page._pageDictionary.set('Annots', array);
            this._page._pageDictionary._updated = true;
            if (this._annotations.indexOf(reference) > -1) {
                this._annotations.splice(index, 1);
            }
            if (this._parsedAnnotations.has(index)) {
                this._parsedAnnotations.delete(index);
                this._reorderParsedAnnotations(index);
            }
            var crossReference = this._page._crossReference;
            if (crossReference && crossReference._cacheMap.has(reference)) {
                crossReference._cacheMap.delete(reference);
            }
        }
    };
    PdfAnnotationCollection.prototype._reorderParsedAnnotations = function (index) {
        var result = new Map();
        this._parsedAnnotations.forEach(function (value, key) {
            if (key > index) {
                result.set(key - 1, value);
            }
            else {
                result.set(key, value);
            }
        });
        this._parsedAnnotations = result;
    };
    PdfAnnotationCollection.prototype._updateCustomAppearanceResource = function (annotation) {
        if (annotation && annotation instanceof PdfRubberStampAnnotation && typeof annotation._appearance !== 'undefined') {
            annotation._appearance.normal.graphics._processResources(annotation._crossReference);
        }
    };
    PdfAnnotationCollection.prototype._addCommentsAndReview = function (annotation, flag) {
        this._updateChildReference(annotation, annotation.comments, flag);
        this._updateChildReference(annotation, annotation.reviewHistory, flag);
    };
    PdfAnnotationCollection.prototype._updateChildReference = function (annotation, collection, flag) {
        if (collection && collection.count > 0) {
            if (flag !== 30) {
                for (var i = 0; i < collection.count; i++) {
                    var childAnnotation = collection._collection[Number.parseInt(i.toString(), 10)];
                    if (childAnnotation && !childAnnotation._dictionary.has('IRT')) {
                        if (i === 0 || !collection._isReview) {
                            childAnnotation._dictionary.update('IRT', annotation._ref);
                        }
                        else {
                            childAnnotation._dictionary.update('IRT', collection._collection[i - 1]._ref);
                        }
                        if (collection._isReview) {
                            childAnnotation._isReview = true;
                        }
                        else {
                            childAnnotation._isComment = true;
                        }
                        this.add(childAnnotation);
                    }
                }
            }
            else {
                throw new Error('Could not add comments/reviews to the review');
            }
        }
    };
    PdfAnnotationCollection.prototype._parseAnnotation = function (dictionary) {
        var annot;
        if (dictionary && dictionary.has('Subtype') && this._page !== null && typeof this._page !== 'undefined') {
            var key = dictionary.get('Subtype');
            var size = dictionary.get('Rect');
            if (key) {
                var link = void 0;
                switch (key.name) {
                    case 'Line':
                        annot = PdfLineAnnotation._load(this._page, dictionary);
                        break;
                    case 'Circle':
                        if (dictionary.has('Measure')) {
                            annot = PdfCircleAnnotation._load(this._page, dictionary);
                        }
                        else {
                            var width = size[2] - size[0];
                            var height = size[3] - size[1];
                            if (width === height) {
                                annot = PdfCircleAnnotation._load(this._page, dictionary);
                            }
                            else {
                                annot = PdfEllipseAnnotation._load(this._page, dictionary);
                            }
                        }
                        break;
                    case 'Square':
                        if (size[2] === size[3]) {
                            annot = PdfSquareAnnotation._load(this._page, dictionary);
                        }
                        else {
                            annot = PdfRectangleAnnotation._load(this._page, dictionary);
                        }
                        break;
                    case 'Polygon':
                        annot = PdfPolygonAnnotation._load(this._page, dictionary);
                        break;
                    case 'PolyLine':
                        if (dictionary.has('Measure') && dictionary.has('IT')) {
                            var type = dictionary.get('IT');
                            if (type && type.name === 'PolyLineAngle') {
                                annot = PdfAngleMeasurementAnnotation._load(this._page, dictionary);
                            }
                        }
                        if (!annot) {
                            annot = PdfPolyLineAnnotation._load(this._page, dictionary);
                        }
                        break;
                    case 'Ink':
                        annot = PdfInkAnnotation._load(this._page, dictionary);
                        break;
                    case 'Popup':
                        annot = PdfPopupAnnotation._load(this._page, dictionary);
                        break;
                    case 'Text':
                        annot = PdfPopupAnnotation._load(this._page, dictionary);
                        break;
                    case 'Link':
                        if (dictionary.has('A')) {
                            link = dictionary.get('A');
                        }
                        if (link && link.has('S')) {
                            var type = link.get('S').name;
                            if (type) {
                                var isTextWebLink = this._hasValidBorder(dictionary.getArray('Border'));
                                if (type === 'URI') {
                                    annot = isTextWebLink ?
                                        PdfTextWebLinkAnnotation._load(this._page, dictionary) :
                                        this._getLinkAnnotation(dictionary);
                                }
                                else if (type === 'Launch') {
                                    annot = PdfFileLinkAnnotation._load(this._page, dictionary);
                                }
                                else if (type === 'GoToR') {
                                    annot = this._getLinkAnnotation(dictionary);
                                }
                                else if (type === 'GoTo') {
                                    annot = PdfDocumentLinkAnnotation._load(this._page, dictionary);
                                }
                            }
                        }
                        else if (key.name === 'Link') {
                            annot = PdfDocumentLinkAnnotation._load(this._page, dictionary);
                        }
                        break;
                    case 'FileAttachment':
                        annot = PdfAttachmentAnnotation._load(this._page, dictionary);
                        break;
                    case '3D':
                        annot = Pdf3DAnnotation._load(this._page, dictionary);
                        break;
                    case 'FreeText':
                        annot = PdfFreeTextAnnotation._load(this._page, dictionary);
                        break;
                    case 'Redact':
                        annot = PdfRedactionAnnotation._load(this._page, dictionary);
                        break;
                    case 'RichMedia':
                        annot = PdfRichMediaAnnotation._load(this._page, dictionary);
                        break;
                    case 'Watermark':
                        annot = PdfWatermarkAnnotation._load(this._page, dictionary);
                        break;
                    case 'Stamp':
                        annot = PdfRubberStampAnnotation._load(this._page, dictionary);
                        break;
                    case 'Sound':
                        annot = PdfSoundAnnotation._load(this._page, dictionary);
                        break;
                    case 'Highlight':
                    case 'Squiggly':
                    case 'StrikeOut':
                    case 'Underline':
                        annot = PdfTextMarkupAnnotation._load(this._page, dictionary);
                        break;
                }
            }
        }
        return annot;
    };
    PdfAnnotationCollection.prototype._getLinkAnnotation = function (dictionary) {
        var annot;
        if (this._page) {
            if (dictionary && dictionary.has('A')) {
                var remote = dictionary.get('A');
                if (remote && remote.has('S')) {
                    var link = remote.get('S');
                    if (link && link.name === 'GoToR' && remote.has('F')) {
                        annot = PdfFileLinkAnnotation._load(this._page, dictionary);
                    }
                    else if (link && link.name === 'URI') {
                        annot = PdfUriAnnotation._load(this._page, dictionary);
                    }
                }
            }
            else {
                annot = PdfUriAnnotation._load(this._page, dictionary);
            }
        }
        return annot;
    };
    PdfAnnotationCollection.prototype._hasValidBorder = function (border) {
        if (typeof border === 'undefined' || border === null) {
            return false;
        }
        for (var i = 0; i < border.length; i++) {
            var val = 0;
            var value = border[Number.parseInt(i.toString(), 10)];
            if (value !== null && typeof value !== 'undefined') {
                val = value;
            }
            if (val > 0) {
                return false;
            }
        }
        return true;
    };
    PdfAnnotationCollection.prototype._doPostProcess = function (isFlatten) {
        var index = 0;
        while (index < this.count) {
            var annotation = this.at(index);
            if (annotation) {
                var flattenValue = annotation.flatten || isFlatten;
                annotation._isExport = this._isExport;
                if (flattenValue && this._annotations.lastIndexOf(annotation._ref) === -1) {
                    index++;
                }
                annotation._doPostProcess(flattenValue);
                if (!flattenValue) {
                    index++;
                }
            }
            else {
                index++;
            }
        }
    };
    PdfAnnotationCollection.prototype._reArrange = function (ref, tabIndex, index) {
        if (this._annotations) {
            if (tabIndex > this._annotations.length) {
                tabIndex = 0;
            }
            if (index >= this._annotations.length) {
                index = this._annotations.indexOf(ref);
            }
            var annotationDictionary = this._crossReference.
                _fetch(this._annotations[Number.parseInt(index.toString(), 10)]);
            if (annotationDictionary && annotationDictionary.has('Parent')) {
                var parentReference = annotationDictionary.getRaw('Parent');
                if ((parentReference && parentReference === ref) || ref ===
                    this._annotations[Number.parseInt(index.toString(), 10)]) {
                    var temp = this._annotations[Number.parseInt(index.toString(), 10)];
                    this._annotations[Number.parseInt(index.toString(), 10)] = this._annotations[Number.parseInt(tabIndex.toString(), 10)];
                    this._annotations[Number.parseInt(tabIndex.toString(), 10)] = temp;
                }
            }
        }
        return this._annotations;
    };
    PdfAnnotationCollection.prototype._clear = function () {
        this._annotations = [];
        this._parsedAnnotations = new Map();
        this._comments = [];
    };
    return PdfAnnotationCollection;
}());
/**
 * Represents the collection of `PdfPopupAnnotation`
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access annotation collection from first page
 * let annotations: PdfRectangleAnnotation = document.getPage(0).annotations;
 * // Gets the comments of annotation
 * let comments: PdfPopupAnnotationCollection = annotation.comments;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfPopupAnnotationCollection = /** @class */ (function () {
    /**
     * Initializes a new instance of the `PdfPopupAnnotationCollection` class
     *
     * @private
     * @param {PdfAnnotation} annotation Annotation reference
     * @param {boolean} isReview Boolean flag to set review
     */
    function PdfPopupAnnotationCollection(annotation, isReview) {
        this._collection = [];
        if (annotation) {
            this._annotation = annotation;
        }
        this._isReview = isReview;
        if (annotation && this._annotation._isLoaded || annotation._page) {
            this._page = annotation._page;
            this._parentDictionary = annotation._dictionary;
            if (this._annotation._isLoaded) {
                this._parseCommentsOrReview();
            }
        }
    }
    Object.defineProperty(PdfPopupAnnotationCollection.prototype, "count", {
        /**
         * Gets the annotation count (Read only).
         *
         * @private
         * @returns {number} Number of annotations
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access annotation collection from first page
         * let annotations: PdfRectangleAnnotation = document.getPage(0).annotations;
         * // Gets the comments of annotation
         * let comments: PdfPopupAnnotationCollection = annotation.comments;
         * // Gets the count of comments
         * let count: number = comments.count;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._collection.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the popup annotation at the specified index.
     *
     * @private
     * @param {number} index Index of the annotation
     * @returns {number} Annotation at the specified index
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access annotation collection from first page
     * let annotations: PdfRectangleAnnotation = document.getPage(0).annotations;
     * // Gets the comments of annotation
     * let comments: PdfPopupAnnotationCollection = annotation.comments;
     * // Gets the first comment
     * let comment: PdfPopupAnnotation = comments.at(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfPopupAnnotationCollection.prototype.at = function (index) {
        if (index < 0 || index >= this._collection.length) {
            throw Error('Index out of range.');
        }
        return this._collection[Number.parseInt(index.toString(), 10)];
    };
    /**
     * Add a new popup annotation into the collection
     *
     * @param {PdfPopupAnnotation} annotation Annotation to add
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Create a new popup annotation
     * const popupAnnotation: PdfPopupAnnotation = new PdfPopupAnnotation('Test popup annotation', 10, 40, 30, 30);
     * popupAnnotation.author = 'Syncfusion';
     * // Add a new popup annotation into the collection
     * annotation.comments.add(popupAnnotation);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfPopupAnnotationCollection.prototype.add = function (annotation) {
        if (this._annotation._dictionary.get('F') === 30) {
            throw new Error('Could not add comments/reviews to the review');
        }
        annotation._dictionary.update('F', ((this._annotation.flags === PdfAnnotationFlag.locked) ? 128 : (this._isReview ? 30 : 28)));
        if (this._annotation && (this._annotation._isLoaded || (this._page && this._annotation._ref))) {
            this._page.annotations.add(annotation);
            var length_1 = this._collection.length;
            if (length_1 === 0 || !this._isReview) {
                annotation._dictionary.update('IRT', this._annotation._ref);
            }
            else {
                annotation._dictionary.update('IRT', this._collection[Number.parseInt((length_1 - 1).toString(), 10)]._ref);
            }
            if (this._isReview) {
                annotation._isReview = true;
            }
            else {
                annotation._isComment = true;
            }
        }
        this._collection.push(annotation);
    };
    /**
     * Remove an annotation from the collection
     *
     * @param {PdfPopupAnnotation} annotation Annotation to remove
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access annotation collection from first page
     * let annotations: PdfRectangleAnnotation = document.getPage(0).annotations;
     * // Gets the comments of annotation
     * let comments: PdfPopupAnnotationCollection = annotation.comments;
     * // Gets the first comment
     * let comment: PdfPopupAnnotation = comments.at(0);
     * // Remove the comment
     * comments.remove(comment);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfPopupAnnotationCollection.prototype.remove = function (annotation) {
        var index = this._collection.indexOf(annotation);
        if (index > -1) {
            this.removeAt(index);
        }
    };
    /**
     * Remove an annotation from the collection at the specified index
     *
     * @param {number} index Annotation index to remove
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access annotation collection from first page
     * let annotations: PdfRectangleAnnotation = document.getPage(0).annotations;
     * // Gets the comments of annotation
     * let comments: PdfPopupAnnotationCollection = annotation.comments;
     * // Remove the first comment
     * comments.removeAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfPopupAnnotationCollection.prototype.removeAt = function (index) {
        if (index > -1 && index < this._collection.length) {
            var annotation = this._collection[Number.parseInt(index.toString(), 10)];
            if (this._isReview && index < this._collection.length - 1) {
                var nextAnnotation = this._collection[Number.parseInt((index + 1).toString(), 10)];
                var previous = annotation._dictionary._get('IRT');
                nextAnnotation._dictionary.set('IRT', previous);
                nextAnnotation._dictionary._updated = true;
            }
            this._collection.splice(index, 1);
            this._page.annotations.remove(annotation);
        }
        else {
            throw new Error('Index out of range.');
        }
    };
    PdfPopupAnnotationCollection.prototype._parseCommentsOrReview = function () {
        if (this._isReview) {
            this._parseReview();
        }
        else {
            this._parseComments();
        }
    };
    PdfPopupAnnotationCollection.prototype._parseReview = function () {
        var collection;
        if (this._page) {
            collection = this._page.annotations;
        }
        var map = new Map();
        map.set(this._annotation._ref, this._annotation);
        if (collection && collection._comments && collection._comments.length > 0) {
            var remaining = [];
            for (var i = 0; i < collection._comments.length; i++) {
                var annotation = collection._comments[Number.parseInt(i.toString(), 10)];
                var reference = annotation._dictionary._get('IRT');
                if (annotation._isReview && reference && map.has(reference)) {
                    this._collection.push(annotation);
                    map.set(annotation._ref, annotation);
                }
                else {
                    remaining.push(annotation);
                }
            }
            if (remaining.length > 0) {
                collection._comments = remaining;
            }
            else {
                collection._comments = [];
            }
        }
        else if (collection) {
            var count = collection.count;
            for (var i = 0; i < count; i++) {
                var annotation = collection.at(i);
                if (annotation && annotation instanceof PdfPopupAnnotation) {
                    var dictionary = annotation._dictionary;
                    if (annotation._dictionary.has('IRT')) {
                        var reference = dictionary._get('IRT');
                        if (annotation._isReview && reference && map.has(reference)) {
                            this._collection.push(annotation);
                            map.set(annotation._ref, annotation);
                        }
                        else {
                            collection._comments.push(annotation);
                        }
                    }
                }
            }
        }
        map.clear();
    };
    PdfPopupAnnotationCollection.prototype._parseComments = function () {
        var collection;
        if (this._page) {
            collection = this._page.annotations;
        }
        if (collection && collection._comments && collection._comments.length > 0) {
            var remaining = [];
            for (var i = 0; i < collection._comments.length; i++) {
                var annotation = collection._comments[Number.parseInt(i.toString(), 10)];
                var dictionary = annotation._dictionary;
                var isReview = _checkReview(dictionary);
                var reference = dictionary._get('IRT');
                if (reference && reference === this._annotation._ref && !isReview) {
                    this._collection.push(annotation);
                }
                else {
                    remaining.push(annotation);
                }
            }
            if (remaining.length > 0) {
                collection._comments = remaining;
            }
            else {
                collection._comments = [];
            }
        }
        else if (collection) {
            var count = collection.count;
            for (var i = 0; i < count; i++) {
                var annotation = collection.at(i);
                if (annotation && annotation instanceof PdfPopupAnnotation) {
                    var dictionary = annotation._dictionary;
                    if (annotation._dictionary.has('IRT')) {
                        var isReview = _checkReview(dictionary);
                        var reference = dictionary._get('IRT');
                        if (reference && reference === this._annotation._ref && !isReview) {
                            this._collection.push(annotation);
                        }
                        else {
                            collection._comments.push(annotation);
                        }
                    }
                }
            }
        }
    };
    return PdfPopupAnnotationCollection;
}());

var __extends$7 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Represents a base class for all bookmark objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get bookmarks
 * let bookmarks: PdfBookmarkBase = document.bookmarks;
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfBookmarkBase = /** @class */ (function () {
    /**
     * Initializes a new instance of the `PdfBookmarkBase` class.
     *
     * @private
     * @param {_PdfDictionary} dictionary Outline dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference.
     *
     */
    function PdfBookmarkBase(dictionary, crossReference) {
        this._bookMarkList = [];
        this._isExpanded = false;
        this._isLoadedBookmark = false;
        this._dictionary = dictionary;
        this._crossReference = crossReference;
    }
    Object.defineProperty(PdfBookmarkBase.prototype, "count", {
        /**
         * Gets the bookmark count (Read only).
         *
         * @returns {number} Number of bookmarks.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Get bookmark count
         * let bookmarkCount: number = bookmarks.count;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoadedBookmark && this._bookMarkList.length === 0) {
                this._reproduceTree();
            }
            return this._bookMarkList.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfBookmarkBase.prototype, "isExpanded", {
        /**
         * Gets the boolean flag indicating whether the bookmark is expanded or not.
         *
         * @returns {boolean} whether the bookmark is expanded or not.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the boolean flag indicating whether the bookmark is expanded or not
         * let isExpanded: boolean = bookmark.isExpanded;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary && this._dictionary.has('Count')) {
                return (this._dictionary.get('Count') >= 0);
            }
            else {
                return this._isExpanded;
            }
        },
        /**
         * Sets the boolean flag indicating whether the bookmark is expanded or not.
         *
         * @param {boolean} value whether the bookmark is expanded or not.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Sets the boolean flag indicating whether the bookmark is expanded or not
         * bookmark.isExpanded = true;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._isExpanded = value;
            if (this.count > 0 && this._dictionary) {
                this._dictionary.update('Count', value ? this._bookMarkList.length : (-this._bookMarkList.length));
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the `PdfBookmark` at the specified index.
     *
     * @param {number} index Bookmark index.
     * @returns {PdfBookmark} Bookmark at the specified index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Get bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfBookmarkBase.prototype.at = function (index) {
        var bookmark;
        if (index < 0 || index >= this.count) {
            throw Error('Index out of range.');
        }
        if (_isNullOrUndefined(this._bookMarkList) && this._bookMarkList.length > 0 && index < this._bookMarkList.length) {
            bookmark = this._bookMarkList[Number.parseInt(index.toString(), 10)];
        }
        return bookmark;
    };
    /**
     * Gets the boolean flag indicating whether `PdfBookmark` is present or not.
     *
     * @param {PdfBookmark} outline Bookmark.
     * @returns {boolean} whether the bookmark is present or not.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Get the bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Gets the boolean flag indicating whether `PdfBookmark` is present or not.
     * let isPresent: boolean = bookmarks.contains(bookmark);
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfBookmarkBase.prototype.contains = function (outline) {
        return this._bookMarkList.indexOf(outline) !== -1;
    };
    PdfBookmarkBase.prototype.add = function (title, index) {
        var bookmark;
        if (this._dictionary) {
            var dictionary = new _PdfDictionary(this._crossReference);
            dictionary.update('Parent', this._reference);
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, dictionary);
            bookmark = new PdfBookmark(dictionary, this._crossReference);
            bookmark._reference = reference;
            bookmark.title = title;
            if (typeof index === 'undefined') {
                if (this.count === 0) {
                    this._dictionary.update('First', reference);
                    this._dictionary.update('Last', reference);
                }
                else {
                    var last = this.at(this.count - 1);
                    this._dictionary.update('Last', reference);
                    if (last && last._reference) {
                        dictionary.update('Prev', last._reference);
                        last._dictionary.update('Next', reference);
                    }
                }
                this._bookMarkList.push(bookmark);
            }
            else {
                if (index < 0 || index > this.count) {
                    throw new Error('Index out of range');
                }
                if (this.count === 0) {
                    this._dictionary.update('First', reference);
                    this._dictionary.update('Last', reference);
                    this._bookMarkList.push(bookmark);
                }
                else if (index === this.count) {
                    var last = this.at(this.count - 1);
                    this._dictionary.update('Last', reference);
                    if (last && last._reference) {
                        dictionary.update('Prev', last._reference);
                        last._dictionary.update('Next', reference);
                    }
                    this._bookMarkList.push(bookmark);
                }
                else if (index === 0) {
                    var first = this.at(0);
                    this._dictionary.update('First', reference);
                    if (first && first._reference) {
                        dictionary.update('Next', first._reference);
                        first._dictionary.update('Prev', reference);
                    }
                    this._updateBookmarkList(index, bookmark);
                }
                else {
                    var next = this.at(index);
                    var prev = this.at(index - 1);
                    if (prev && prev._reference && next && next._reference) {
                        dictionary.update('Prev', prev._reference);
                        prev._dictionary.update('Next', reference);
                        next._dictionary.update('Prev', reference);
                        dictionary.update('Next', next._reference);
                    }
                    this._updateBookmarkList(index, bookmark);
                }
            }
            this._updateCount();
        }
        return bookmark;
    };
    PdfBookmarkBase.prototype.remove = function (value) {
        if (typeof value === 'string') {
            for (var i = this._bookMarkList.length - 1; i >= 0; i--) {
                var bookmark = this.at(i);
                if (bookmark.title === value) {
                    this.remove(i);
                }
                else if (bookmark.count > 0) {
                    bookmark.remove(value);
                }
            }
        }
        else {
            if (value >= 0 && value < this.count) {
                if (this.count === 1) {
                    this._removeFirst(this._dictionary);
                    this._removeLast(this._dictionary);
                    this._removeCount(this._dictionary);
                    this._bookMarkList = [];
                }
                else {
                    if (value === 0) {
                        var next = this.at(value + 1);
                        if (this._dictionary && next && next._reference) {
                            this._removePrevious(next._dictionary);
                            this._dictionary.update('First', next._reference);
                        }
                    }
                    else if (value === this.count - 1) {
                        var prev = this.at(value - 1);
                        if (this._dictionary && prev && prev._reference) {
                            this._removeNext(prev._dictionary);
                            this._dictionary.update('Last', prev._reference);
                        }
                    }
                    else {
                        var prev = this.at(value - 1);
                        var next = this.at(value + 1);
                        if (prev && prev._reference && next && next._reference) {
                            prev._dictionary.update('Next', next._reference);
                            next._dictionary.update('Prev', prev._reference);
                        }
                    }
                    this._updateBookmarkList(value);
                    if (this._dictionary) {
                        this._updateCount();
                    }
                }
            }
        }
    };
    /**
     * Removes all the bookmark from the collection.
     *
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Remove all the bookmark from the collection.
     * bookmarks.clear();
     * // Get count after removal of all outlines.
     * let count: number = bookmarks.count;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfBookmarkBase.prototype.clear = function () {
        this._removeFirst(this._dictionary);
        this._removeLast(this._dictionary);
        this._removeCount(this._dictionary);
        this._bookMarkList = [];
    };
    PdfBookmarkBase.prototype._removeFirst = function (dictionary) {
        if (dictionary && dictionary.has('First')) {
            delete dictionary._map.First;
            dictionary._updated = true;
        }
    };
    PdfBookmarkBase.prototype._removeLast = function (dictionary) {
        if (dictionary && dictionary.has('Last')) {
            delete dictionary._map.Last;
            dictionary._updated = true;
        }
    };
    PdfBookmarkBase.prototype._removeNext = function (dictionary) {
        if (dictionary && dictionary.has('Next')) {
            delete dictionary._map.Next;
            dictionary._updated = true;
        }
    };
    PdfBookmarkBase.prototype._removePrevious = function (dictionary) {
        if (dictionary && dictionary.has('Prev')) {
            delete dictionary._map.Prev;
            dictionary._updated = true;
        }
    };
    PdfBookmarkBase.prototype._removeCount = function (dictionary) {
        if (dictionary && dictionary.has('Count')) {
            delete dictionary._map.Count;
            dictionary._updated = true;
        }
    };
    PdfBookmarkBase.prototype._updateBookmarkList = function (index, bookmark) {
        var updatedList = [];
        if (typeof bookmark === 'undefined') {
            for (var i = 0; i < this.count; i++) {
                var entry = this._bookMarkList[Number.parseInt(i.toString(), 10)];
                if (i !== index) {
                    updatedList.push(entry);
                }
                else {
                    var reference = entry._reference;
                    if (reference && this._crossReference._cacheMap.has(reference)) {
                        this._crossReference._cacheMap.get(reference)._updated = false;
                    }
                }
            }
        }
        else {
            for (var i = 0; i < this.count; i++) {
                if (i === index) {
                    updatedList.push(bookmark);
                }
                updatedList.push(this._bookMarkList[Number.parseInt(i.toString(), 10)]);
            }
        }
        this._bookMarkList = updatedList;
    };
    PdfBookmarkBase.prototype._updateCount = function () {
        if (this.isExpanded || !this._dictionary.has('Count')) {
            this._dictionary.update('Count', this._bookMarkList.length);
        }
        else {
            this._dictionary.update('Count', -this._bookMarkList.length);
        }
    };
    PdfBookmarkBase.prototype._reproduceTree = function () {
        var firstBookmark = this._getBookmark(this);
        var isBookmark = (firstBookmark) ? true : false;
        while (isBookmark && firstBookmark._dictionary) {
            this._bookMarkList.push(firstBookmark);
            firstBookmark = firstBookmark._next;
            isBookmark = (firstBookmark) ? true : false;
        }
    };
    PdfBookmarkBase.prototype._getBookmark = function (bookmarkBase, isFirst) {
        if (isFirst === void 0) { isFirst = true; }
        var bookmarkBaseDictionary = bookmarkBase._dictionary;
        var bookMark;
        if (bookmarkBaseDictionary && bookmarkBaseDictionary.has(isFirst ? 'First' : 'Last')) {
            var reference = bookmarkBaseDictionary._get(isFirst ? 'First' : 'Last');
            if (_isNullOrUndefined(reference)) {
                var bookMarkDictionary = this._crossReference._fetch(reference);
                if (bookMarkDictionary) {
                    bookMark = new PdfBookmark(bookMarkDictionary, this._crossReference);
                    bookMark._reference = reference;
                }
            }
        }
        return bookMark;
    };
    return PdfBookmarkBase;
}());
/**
 * Represents a bookmark in a PDF document
 *
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the bookmarks
 * let bookmarks: PdfBookmarkBase = document.bookmarks;
 * // Gets the bookmark at the specified index
 * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfBookmark = /** @class */ (function (_super) {
    __extends$7(PdfBookmark, _super);
    /**
     * Initializes a new instance of the `PdfBookmark` class.
     *
     * @private
     * @param {_PdfDictionary} dictionary Bookmark dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference.
     *
     */
    function PdfBookmark(dictionary, crossReference) {
        var _this = _super.call(this, dictionary, crossReference) || this;
        if (_this._dictionary && !_this._dictionary.has('Dest') && _this._dictionary.has('A')) {
            var actionDictionary = _this._dictionary.get('A');
            if (actionDictionary && actionDictionary.has('D')) {
                var destinationArray = actionDictionary.getRaw('D'); // eslint-disable-line
                _this._dictionary.update('Dest', destinationArray);
            }
        }
        _this._isLoadedBookmark = true;
        return _this;
    }
    Object.defineProperty(PdfBookmark.prototype, "destination", {
        /**
         * Gets the destination.
         *
         * @returns {PdfDestination} Page destination.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets the bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the destination
         * let destination: PdfDestination = bookmark.destination;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._destination) {
                var namedDestination = this._obtainNamedDestination();
                if (namedDestination === null || typeof namedDestination === 'undefined') {
                    this._destination = _obtainDestination(this._dictionary, 'Dest');
                }
            }
            return this._destination;
        },
        /**
         * Sets the destination.
         *
         * @param {PdfDestination} value destination.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets the bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Set the destination
         * bookmark.destination = new PdfDestination(page, [100, 200]);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                value._parent = this;
                this._destination = value;
                this._destination._initializePrimitive();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfBookmark.prototype, "namedDestination", {
        /**
         * Gets the named destination.
         *
         * @returns {PdfNamedDestination} Named destination.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the named destination
         * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._namedDestination === null || typeof this._namedDestination === 'undefined') {
                this._namedDestination = this._obtainNamedDestination();
            }
            return this._namedDestination;
        },
        /**
         * Sets the named destination.
         *
         * @param {PdfNamedDestination} value Named destination.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the named destination
         * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._namedDestination !== value && this._dictionary) {
                this._namedDestination = value;
                var dictionary = new _PdfDictionary(this._crossReference);
                dictionary.update('D', value.title);
                dictionary.update('S', _PdfName.get('GoTo'));
                var reference = this._crossReference._getNextReference();
                this._crossReference._cacheMap.set(reference, dictionary);
                this._dictionary.update('A', reference);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfBookmark.prototype, "title", {
        /**
         * Gets the bookmark title.
         *
         * @returns {string} Bookmark title.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the bookmark title
         * let bookmarkTitle: string = bookmark.title;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._title === null || typeof this._title === 'undefined') {
                if (this._dictionary && this._dictionary.has('Title')) {
                    this._title = this._dictionary.get('Title');
                }
                else {
                    this._title = '';
                }
            }
            return this._title;
        },
        /**
         * Sets the bookmark title.
         *
         * @param {string} value Bookmark title.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Sets the bookmark title
         * bookmark.title = 'Syncfusion';
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._title = value;
            if (this._dictionary) {
                this._dictionary.update('Title', value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfBookmark.prototype, "color", {
        /**
         * Gets the bookmark color.
         *
         * @returns {number[]} Bookmark color.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the bookmark color
         * let color: number[] = bookmark.color;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._color === null || typeof this._color === 'undefined') {
                if (this._dictionary && this._dictionary.has('C')) {
                    this._color = _parseColor(this._dictionary.getArray('C'));
                }
            }
            return (this._color) ? this._color : [0, 0, 0];
        },
        /**
         * Sets the bookmark color.
         *
         * @param {number[]} value Bookmark color.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Sets the bookmark color
         * bookmark.color = [255, 0, 0];
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._color = value;
            if (this._dictionary) {
                this._dictionary.update('C', [Number.parseFloat((value[0] / 255).toFixed(7)),
                    Number.parseFloat((value[1] / 255).toFixed(7)),
                    Number.parseFloat((value[2] / 255).toFixed(7))]);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfBookmark.prototype, "textStyle", {
        /**
         * Gets the text style.
         *
         * @returns {PdfTextStyle} Text style.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the textStyle
         * let textStyle: PdfTextStyle = bookmark.textStyle;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._textStyle === null || typeof this._textStyle === 'undefined') {
                this._textStyle = this._obtainTextStyle();
            }
            return this._textStyle;
        },
        /**
         * Sets the text style.
         *
         * @param {PdfTextStyle} value Text style.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Sets the textStyle
         * bookmark.textStyle = PdfTextStyle.italic;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._textStyle = value;
            this._updateTextStyle(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfBookmark.prototype, "_next", {
        get: function () {
            var nextBookmark;
            if (this._dictionary && this._dictionary.has('Next')) {
                var reference = this._dictionary._get('Next');
                if (_isNullOrUndefined(reference)) {
                    var dictionary = this._crossReference._fetch(reference);
                    if (dictionary) {
                        nextBookmark = new PdfBookmark(dictionary, this._crossReference);
                        nextBookmark._reference = reference;
                    }
                }
            }
            return nextBookmark;
        },
        enumerable: true,
        configurable: true
    });
    PdfBookmark.prototype._updateTextStyle = function (value) {
        if (value === PdfTextStyle.regular) {
            if (this._dictionary && this._dictionary.has('F')) {
                delete this._dictionary._map.F;
            }
        }
        else if (this._dictionary) {
            this._dictionary.update('F', value);
        }
    };
    PdfBookmark.prototype._obtainTextStyle = function () {
        var style = PdfTextStyle.regular;
        if (this._dictionary && this._dictionary.has('F')) {
            var flag = this._dictionary.get('F');
            var flagValue = 0;
            if (typeof flag !== 'undefined' && flag !== null) {
                flagValue = flag;
            }
            style |= flagValue;
        }
        return style;
    };
    PdfBookmark.prototype._obtainNamedDestination = function () {
        var document = this._crossReference._document;
        var destinationCollection;
        if (document) {
            destinationCollection = document._destinationCollection;
        }
        var destination; // eslint-disable-line
        var namedDestination;
        if (destinationCollection) {
            var dictionary = this._dictionary;
            if (dictionary) {
                if (dictionary.has('A')) {
                    var action = dictionary.get('A');
                    if (action && action.has('D')) {
                        destination = action.get('D');
                    }
                }
                else if (dictionary.has('Dest')) {
                    destination = dictionary.get('Dest');
                }
            }
            if (destination) {
                var value = void 0;
                if (destination instanceof _PdfName) {
                    value = destination.name;
                }
                else if (typeof destination === 'string') {
                    value = destination;
                }
                if (value) {
                    var namedDestinations = destinationCollection._namedDestinations;
                    for (var i = 0; i < namedDestinations.length; i++) {
                        namedDestination = namedDestinations[Number.parseInt(i.toString(), 10)];
                        if (namedDestination._title === value) {
                            destination = namedDestination;
                            break;
                        }
                    }
                }
            }
        }
        return namedDestination;
    };
    return PdfBookmark;
}(PdfBookmarkBase));
/**
 * Represents a named destination in a PDF document.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the bookmarks
 * let bookmarks: PdfBookmarkBase = document.bookmarks;
 * // Gets the bookmark at the specified index
 * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
 * // Gets the named destination
 * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfNamedDestination = /** @class */ (function () {
    function PdfNamedDestination(element, crossReference) {
        if (typeof element === 'string') {
            this._initialize();
            this.title = element;
        }
        else {
            this._dictionary = element;
            this._crossReference = crossReference;
        }
    }
    Object.defineProperty(PdfNamedDestination.prototype, "destination", {
        /**
         * Gets the destination.
         *
         * @returns {PdfDestination} Page destination.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets the bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the named destination
         * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
         * // Gets the destination
         * let destination: PdfDestination = namedDestination.destination;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._destination;
        },
        /**
         * Sets the destination.
         *
         * @param {PdfDestination} value destination.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets the bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the named destination
         * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
         * // Set the destination
         * namedDestination.destination = new PdfDestination(page, [100, 200]);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                value._parent = this;
                this._destination = value;
                this._destination._initializePrimitive();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfNamedDestination.prototype, "title", {
        /**
         * Gets the title.
         *
         * @returns {string} title.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets the bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the named destination
         * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
         * // Gets the title
         * let title: string = namedDestination.title;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._title;
        },
        /**
         * Sets the title.
         *
         * @param {string} value title.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets the bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the named destination
         * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
         * // Set the title
         * namedDestination.title = 'Syncfusion';
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._title && this._dictionary) {
                this._title = value;
                this._dictionary.update('Title', value);
                this._dictionary._updated = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfNamedDestination.prototype._initialize = function () {
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('S', _PdfName.get('GoTo'));
    };
    return PdfNamedDestination;
}());
var _PdfNamedDestinationCollection = /** @class */ (function () {
    function _PdfNamedDestinationCollection(dictionary, crossReference) {
        this._namedDestinations = [];
        if (dictionary) {
            this._dictionary = dictionary;
        }
        if (crossReference) {
            this._crossReference = crossReference;
        }
        if (dictionary && dictionary.has('Dests')) {
            var destination = dictionary.get('Dests');
            if (destination) {
                if (destination.has('Names')) {
                    this._addCollection(destination);
                }
                else if (destination.has('Kids')) {
                    var destinationArray = destination.getArray('Kids'); // eslint-disable-line
                    for (var i = 0; i < destinationArray.length; i++) {
                        this._findDestination(destinationArray[Number.parseInt(i.toString(), 10)]);
                    }
                }
            }
        }
    }
    _PdfNamedDestinationCollection.prototype._findDestination = function (destination) {
        if (destination) {
            if (destination.has('Names')) {
                this._addCollection(destination);
            }
            else if (destination.has('Kids')) {
                var kids = destination.getArray('Kids'); // eslint-disable-line
                if (kids && Array.isArray(kids) && kids.length > 0) {
                    for (var i = 0; i < kids.length; i++) {
                        this._findDestination(kids[Number.parseInt(i.toString(), 10)]);
                    }
                }
            }
        }
    };
    _PdfNamedDestinationCollection.prototype._addCollection = function (destination) {
        var elements = destination.getRaw('Names'); // eslint-disable-line
        var ref; // eslint-disable-line
        var dictionary;
        if (elements && elements instanceof _PdfReference) {
            ref = this._crossReference._fetch(elements);
        }
        if (ref && Array.isArray(ref) && ref.length > 0) {
            elements = ref;
        }
        if (elements && Array.isArray(elements) && elements.length > 0) {
            for (var i = 1; i < elements.length; i = i + 2) {
                var reference = elements[i]; // eslint-disable-line
                if (reference && reference instanceof _PdfReference) {
                    var destinationArray = this._crossReference._fetch(reference); // eslint-disable-line
                    if (destinationArray && Array.isArray(destinationArray) && destinationArray.length > 0) {
                        dictionary = new _PdfDictionary();
                        dictionary.update('D', destinationArray);
                    }
                    else {
                        dictionary = this._crossReference._fetch(reference);
                    }
                }
                else if ((dictionary === null || typeof dictionary === 'undefined') && Array.isArray(reference)) {
                    dictionary = new _PdfDictionary();
                    dictionary.update('D', reference);
                }
                if (dictionary) {
                    var namedDestination = new PdfNamedDestination(dictionary, this._crossReference);
                    var value = elements[i - 1];
                    var destinationObject = void 0;
                    var destinationArray = void 0; // eslint-disable-line
                    if (value) {
                        namedDestination._title = value;
                        if (dictionary.has('D')) {
                            destinationArray = dictionary.get('D');
                            destinationObject = new PdfDestination();
                            var reference_1 = destinationArray[0];
                            if (reference_1 && destinationArray && destinationArray[0] instanceof _PdfReference) {
                                var pageDictionary = this._crossReference._fetch(reference_1);
                                var loadedDocument = this._crossReference._document;
                                var index = void 0;
                                if (loadedDocument && pageDictionary) {
                                    index = _getPageIndex(loadedDocument, pageDictionary);
                                    if (typeof index !== 'undefined' && index !== null && index >= 0) {
                                        destinationObject._index = index;
                                        destinationObject.page = loadedDocument.getPage(index);
                                    }
                                }
                            }
                        }
                    }
                    if (destinationArray[1] instanceof _PdfName) {
                        var left = void 0;
                        var height = void 0;
                        var zoom = void 0;
                        var mode = destinationArray[1].name;
                        var page = destinationObject.page;
                        switch (mode) {
                            case 'Fit':
                                destinationObject._destinationMode = PdfDestinationMode.fitToPage;
                                break;
                            case 'XYZ':
                                destinationObject._destinationMode = PdfDestinationMode.location;
                                if (destinationArray.length > 2) {
                                    left = destinationArray[2];
                                }
                                if (destinationArray.length > 3) {
                                    height = destinationArray[3];
                                }
                                if (destinationArray.length > 4) {
                                    zoom = destinationArray[4];
                                }
                                if (page) {
                                    var size = page.size;
                                    var topValue = (height === null || typeof height === 'undefined') ? 0 : size[1] - height;
                                    var leftValue = (left === null || typeof left === 'undefined') ? 0 : left;
                                    destinationObject._location = [leftValue, topValue];
                                    if (page.rotation !== PdfRotationAngle.angle0) {
                                        topValue = _checkRotation(page, height, left);
                                    }
                                    destinationObject._zoom = (typeof zoom !== 'undefined' && zoom !== null) ? zoom : 0;
                                    if (left === null || height === null || zoom === null || typeof left === 'undefined'
                                        || typeof height === 'undefined' || typeof zoom === 'undefined') {
                                        destinationObject._isValid = false;
                                    }
                                }
                                break;
                            case 'FitH':
                            case 'FitBH':
                                destinationObject._destinationMode = PdfDestinationMode.fitH;
                                if (destinationArray.length >= 3) {
                                    height = destinationArray[2];
                                }
                                if (page) {
                                    var size = page.size;
                                    var topValue = (height === null || typeof height === 'undefined') ? 0 : size[1] - height;
                                    destinationObject._location = [0, topValue];
                                }
                                if (height === null || typeof height === 'undefined') {
                                    destinationObject._isValid = false;
                                }
                                break;
                            case 'FitR':
                                destinationObject._destinationMode = PdfDestinationMode.fitR;
                                break;
                        }
                    }
                    destinationObject._parent = namedDestination;
                    namedDestination._destination = destinationObject;
                    this._namedDestinations.push(namedDestination);
                }
            }
        }
    };
    return _PdfNamedDestinationCollection;
}());

/**
 * Represents a page loaded from the PDF document.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfPage = /** @class */ (function () {
    /**
     * Represents a loaded page of the PDF document.
     *
     * @private
     * @param {_PdfCrossReference} crossReference Cross reference object.
     * @param {number} pageIndex page index.
     * @param {_PdfDictionary} dictionary page Dictionary.
     * @param {_PdfReference} reference page reference.
     */
    function PdfPage(crossReference, pageIndex, dictionary, reference) {
        this._isAnnotationParsed = false;
        this._isNew = false;
        this._isDuplicate = false;
        this._pageIndex = pageIndex;
        this._pageDictionary = dictionary;
        this._crossReference = crossReference;
        this._ref = reference;
    }
    Object.defineProperty(PdfPage.prototype, "annotations", {
        /**
         * Gets the collection of the page's annotations (Read only).
         *
         * @returns {PdfAnnotationCollection} Annotation collection.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the annotation collection
         * let annotations: PdfAnnotationCollection = page.annotations;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._annotations === 'undefined') {
                if (this._pageDictionary && this._pageDictionary.has('Annots')) {
                    var annots = this._getProperty('Annots');
                    if (_isNullOrUndefined(annots) && Array.isArray(annots)) {
                        var widgets_1;
                        if (this._crossReference._document._catalog._catalogDictionary.has('AcroForm')) {
                            widgets_1 = this._crossReference._document.form._parseWidgetReferences();
                        }
                        if (widgets_1 && widgets_1.length > 0) {
                            var validAnnotations_1 = [];
                            annots.forEach(function (entry) {
                                if (widgets_1.indexOf(entry) === -1) {
                                    validAnnotations_1.push(entry);
                                }
                            });
                            this._annotations = new PdfAnnotationCollection(validAnnotations_1, this._crossReference, this);
                        }
                        else {
                            this._annotations = new PdfAnnotationCollection(annots, this._crossReference, this);
                        }
                    }
                }
                if (typeof this._annotations === 'undefined') {
                    this._annotations = new PdfAnnotationCollection([], this._crossReference, this);
                }
            }
            return this._annotations;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPage.prototype, "size", {
        /**
         * Gets the size of the page (Read only).
         *
         * @returns {number[]} Page width and height as number array.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the width and height of the PDF page as number array
         * let size: number[] = page.size;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._size === 'undefined') {
                var mBox = _getInheritableProperty(this._pageDictionary, 'MediaBox', false, true, 'Parent', 'P');
                var cBox = _getInheritableProperty(this._pageDictionary, 'CropBox', false, true, 'Parent', 'P');
                var width = 0;
                var height = 0;
                var rotate = this._pageDictionary && this._pageDictionary.has('Rotate')
                    ? _getInheritableProperty(this._pageDictionary, 'Rotate', false, true, 'Parent')
                    : 0;
                if (cBox && rotate !== null && typeof rotate !== 'undefined') {
                    width = cBox[2] - cBox[0];
                    height = cBox[3] - cBox[1];
                    var isValidCropBox = !(mBox && (mBox[2] - mBox[0]) < width);
                    if (!(((rotate === 0 || rotate === 180) && (width < height)) ||
                        ((rotate === 90 || rotate === 270) && (width > height) || isValidCropBox)) && (rotate === 0 && mBox)) {
                        width = mBox[2] - mBox[0];
                        height = mBox[3] !== 0 ? mBox[3] - mBox[1] : mBox[1];
                    }
                }
                else if (mBox) {
                    width = mBox[2] - mBox[0];
                    height = mBox[3] !== 0 ? mBox[3] - mBox[1] : mBox[1];
                }
                else {
                    this._pageDictionary.update('MediaBox', [0, 0, 612, 792]);
                    width = 612;
                    height = 792;
                }
                this._size = [Math.abs(width), Math.abs(height)];
            }
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPage.prototype, "rotation", {
        /**
         * Gets the rotation angle of the page (Read only).
         *
         * @returns {PdfRotationAngle} Page rotation angle.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the rotation angle of the page
         * let rotation: PdfRotationAngle = page.rotation;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var angle = 0;
            if (typeof this._rotation === 'undefined') {
                angle = _getInheritableProperty(this._pageDictionary, 'Rotate', false, true, 'Parent');
                if (angle < 0) {
                    angle += 360;
                }
                this._rotation = (typeof angle !== 'undefined') ? ((angle / 90) % 4) : PdfRotationAngle.angle0;
            }
            return this._rotation;
        },
        /**
         * Sets the rotation angle of the PDF page
         *
         * @param {PdfRotationAngle} value rotation angle.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Sets the rotation angle of the PDF page
         * page.rotate = PdfRotationAngle.angle90;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (!this._isNew) {
                this._rotation = value;
                var rotate = Math.floor(this._rotation) * 90;
                if (rotate >= 360) {
                    rotate = rotate % 360;
                }
                this._pageDictionary.update('Rotate', rotate);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPage.prototype, "tabOrder", {
        /**
         * Gets the tab order of a PDF form field.
         *
         * @returns {PdfFormFieldsTabOrder} tab order.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the tab order of a PDF form field.
         * let tabOrder: PdfFormFieldsTabOrder = page.tabOrder;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._obtainTabOrder();
        },
        /**
         * Sets the tab order of a PDF form field.
         *
         * @param {PdfFormFieldsTabOrder} value tab order.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Sets the tab order of a PDF form field.
         * page.tabOrder = PdfFormFieldsTabOrder.row;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._tabOrder = value;
            var tabs = '';
            if (this._tabOrder !== PdfFormFieldsTabOrder.none) {
                if (this._tabOrder === PdfFormFieldsTabOrder.row) {
                    tabs = 'R';
                }
                else if (this._tabOrder === PdfFormFieldsTabOrder.column) {
                    tabs = 'C';
                }
                else if (this._tabOrder === PdfFormFieldsTabOrder.structure) {
                    tabs = 'S';
                }
            }
            this._pageDictionary.update('Tabs', _PdfName.get(tabs));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPage.prototype, "cropBox", {
        /**
         * Gets the bounds that define the area intended for display or printing in the PDF viewer application (Read only).
         *
         * @returns {number[]} Page size as number array.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the cropBox of the PDF page as number array
         * let cropBox: number[] = page.cropBox;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._cBox === 'undefined') {
                this._cBox = _getInheritableProperty(this._pageDictionary, 'CropBox', false, true, 'Parent', 'P');
            }
            if (typeof this._cBox === 'undefined') {
                this._cBox = [0, 0, 0, 0];
            }
            return this._cBox;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPage.prototype, "mediaBox", {
        /**
         * Gets the size that specify the width and height of the page (Read only).
         *
         * @returns {number[]} Page size as number array.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the mediaBox of the PDF page as number array
         * let mediaBox: number[] = page.mediaBox;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._mBox === 'undefined') {
                this._mBox = _getInheritableProperty(this._pageDictionary, 'MediaBox', false, true, 'Parent', 'P');
            }
            if (typeof this._mBox === 'undefined') {
                this._mBox = [0, 0, 0, 0];
            }
            return this._mBox;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPage.prototype, "orientation", {
        /**
         * Gets the orientation of the page (Read only).
         *
         * @returns {PdfPageOrientation} Page orientation.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the orientation of the PDF page
         * let orientation: number[] = page.orientation;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._orientation === 'undefined') {
                if (typeof this.size !== 'undefined') {
                    var size = this.size;
                    if (size[0] > size[1]) {
                        this._orientation = PdfPageOrientation.landscape;
                    }
                    else {
                        this._orientation = PdfPageOrientation.portrait;
                    }
                }
            }
            return this._orientation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPage.prototype, "_origin", {
        get: function () {
            if (typeof this._o === 'undefined' || (this._o[0] === 0 && this._o[1] === 0)) {
                this._o = [this.mediaBox[0], this._mBox[1]];
            }
            return this._o;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPage.prototype, "graphics", {
        /**
         * Gets the graphics of the page (Read only).
         *
         * @returns {PdfGraphics} Page graphics.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the graphics of the PDF page
         * let graphics: PdfGraphics = page.graphics;
         * //Create a new pen.
         * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
         * //Draw line on the page graphics.
         * graphics.drawLine(pen, 10, 10, 100, 100);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._g === 'undefined' || this._needInitializeGraphics) {
                this._parseGraphics();
            }
            return this._g;
        },
        enumerable: true,
        configurable: true
    });
    PdfPage.prototype._addWidget = function (reference) {
        var annots;
        if (this._pageDictionary.has('Annots')) {
            var annotsRef = this._pageDictionary.getRaw('Annots'); // eslint-disable-line
            annots = this._getProperty('Annots');
            if (annotsRef && annotsRef instanceof _PdfReference) {
                delete this._pageDictionary._map.Annots;
                this._pageDictionary.update('Annots', annots);
            }
        }
        if (annots && Array.isArray(annots)) {
            annots.push(reference);
        }
        else {
            this._pageDictionary.update('Annots', [reference]);
        }
        this._pageDictionary._updated = true;
    };
    PdfPage.prototype._getProperty = function (key, getArray) {
        if (getArray === void 0) { getArray = false; }
        var value = _getInheritableProperty(this._pageDictionary, key, getArray, false); // eslint-disable-line
        if (!Array.isArray(value)) {
            return value;
        }
        if (value.length === 1 || !(value[0] instanceof _PdfDictionary)) {
            return value[0];
        }
        return _PdfDictionary.merge(this._crossReference, value);
    };
    PdfPage.prototype._parseGraphics = function () {
        this._loadContents();
        var saveStream = new _PdfContentStream([32, 113, 32, 10]);
        var saveReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(saveReference, saveStream);
        this._contents.splice(0, 0, saveReference);
        var restoreStream = new _PdfContentStream([32, 81, 32, 10]);
        var restoreReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(restoreReference, restoreStream);
        this._contents.push(restoreReference);
        var contentStream = new _PdfContentStream([]);
        var contentReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(contentReference, contentStream);
        this._contents.push(contentReference);
        this._pageDictionary.set('Contents', this._contents);
        this._pageDictionary._updated = true;
        this._initializeGraphics(contentStream);
    };
    PdfPage.prototype._loadContents = function () {
        var contents = this._pageDictionary.getRaw('Contents'); // eslint-disable-line
        var ref;
        if (contents !== null && typeof contents !== 'undefined' && contents instanceof _PdfReference) {
            ref = contents;
            contents = this._crossReference._fetch(ref);
        }
        if (contents && contents instanceof _PdfBaseStream) {
            this._contents = [ref];
        }
        else if (contents && Array.isArray(contents)) {
            this._contents = contents;
        }
        else {
            this._contents = [];
        }
    };
    PdfPage.prototype._initializeGraphics = function (stream) {
        var isInvalidCase = false;
        var llx = 0;
        var lly = 0;
        var urx = 0;
        var ury = 0;
        var size = this.size;
        var mbox = this.mediaBox;
        if (mbox && mbox.length >= 4) {
            llx = mbox[0];
            lly = mbox[1];
            urx = mbox[2];
            ury = mbox[3];
        }
        var cbox;
        if (this._pageDictionary.has('CropBox')) {
            cbox = this.cropBox;
            if (cbox && cbox.length >= 4) {
                var cx = cbox[0];
                var cy = cbox[1];
                var crx = cbox[2];
                var cry = cbox[3];
                var isValid = (cx < 0 || cy < 0 || crx < 0 || cry < 0) &&
                    (Math.floor(Math.abs(cy)) === Math.floor(Math.abs(size[1]))) &&
                    (Math.floor(Math.abs(cx)) === Math.floor(Math.abs(size[0])));
                if (isValid) {
                    this._g = new PdfGraphics([Math.max(cx, crx), Math.max(cy, cry)], stream, this._crossReference, this);
                }
                else {
                    this._g = new PdfGraphics(size, stream, this._crossReference, this);
                    this._g._cropBox = cbox;
                }
            }
            else {
                this._g = new PdfGraphics(size, stream, this._crossReference, this);
            }
        }
        else if ((llx < 0 || lly < 0 || urx < 0 || ury < 0) &&
            (Math.floor(Math.abs(lly)) === Math.floor(Math.abs(size[1]))) &&
            (Math.floor(Math.abs(urx)) === Math.floor(Math.abs(size[0])))) {
            var width = Math.max(llx, urx);
            var height = Math.max(lly, ury);
            if (width <= 0 || height <= 0) {
                isInvalidCase = true;
                if (llx < 0) {
                    llx = -llx;
                }
                if (lly < 0) {
                    lly = -lly;
                }
                if (urx < 0) {
                    urx = -urx;
                }
                if (ury < 0) {
                    ury = -ury;
                }
                width = Math.max(llx, urx);
                height = Math.max(lly, ury);
            }
            this._g = new PdfGraphics([width, height], stream, this._crossReference, this);
        }
        else {
            this._g = new PdfGraphics(size, stream, this._crossReference, this);
        }
        if (this._pageDictionary.has('MediaBox')) {
            this._g._mediaBoxUpperRightBound = isInvalidCase ? -lly : ury;
        }
        this._graphicsState = this._g.save();
        var origin = this._origin;
        if ((origin[0] >= 0 && origin[1] >= 0) || Math.sign(origin[0]) !== Math.sign(origin[1])) {
            this._g._initializeCoordinates();
        }
        else {
            this._g._initializeCoordinates(this);
        }
        //Need to code - set transparency group
        if (!this._isNew) {
            var rotation = this.rotation;
            if (!Number.isNaN(rotation) && (rotation !== PdfRotationAngle.angle0 || this._pageDictionary.has('Rotate'))) {
                var rotate = void 0;
                if (this._pageDictionary.has('Rotate')) {
                    rotate = this._pageDictionary.get('Rotate');
                }
                else {
                    rotate = rotation * 90;
                }
                var clip = this._g._clipBounds;
                if (rotate === 90) {
                    this._g.translateTransform(0, size[1]);
                    this._g.rotateTransform(-90);
                    this._g._clipBounds = [clip[0], clip[1], size[0], size[1]];
                }
                else if (rotate === 180) {
                    this._g.translateTransform(size[0], size[1]);
                    this._g.rotateTransform(-180);
                }
                else if (rotate === 270) {
                    this._g.translateTransform(size[0], 0);
                    this._g.rotateTransform(-270);
                    this._g._clipBounds = [clip[0], clip[1], size[1], size[0]];
                }
            }
        }
        if (this._isNew && this._pageSettings) {
            var clipBounds = this._getActualBounds(this._pageSettings);
            this._g._clipTranslateMargins(clipBounds);
        }
        this._needInitializeGraphics = false;
    };
    PdfPage.prototype._getActualBounds = function (pageSettings) {
        var actualSize = pageSettings._getActualSize();
        return [pageSettings.margins.left, pageSettings.margins.top, actualSize[0], actualSize[1]];
    };
    PdfPage.prototype._fetchResources = function () {
        if (typeof this._resourceObject === 'undefined') {
            if (this._pageDictionary && this._pageDictionary.has('Resources')) {
                var obj = this._pageDictionary.getRaw('Resources'); // eslint-disable-line
                if (obj !== null && typeof obj !== 'undefined' && obj instanceof _PdfReference) {
                    this._hasResourceReference = true;
                    this._resourceObject = this._crossReference._fetch(obj);
                }
                else if (obj && obj instanceof _PdfDictionary) {
                    this._resourceObject = obj;
                }
            }
            else {
                this._resourceObject = new _PdfDictionary(this._crossReference);
                this._pageDictionary.update('Resources', this._resourceObject);
            }
        }
        return this._resourceObject;
    };
    PdfPage.prototype._getCropOrMediaBox = function () {
        var box;
        if (this._pageDictionary) {
            if (this._pageDictionary.has('CropBox')) {
                box = this._pageDictionary.getArray('CropBox');
            }
            else if (this._pageDictionary.has('MediaBox')) {
                box = this._pageDictionary.getArray('MediaBox');
            }
        }
        return box;
    };
    PdfPage.prototype._beginSave = function () {
        if (typeof this._graphicsState !== 'undefined') {
            this.graphics.restore(this._graphicsState);
            this._graphicsState = null;
            this._needInitializeGraphics = true;
        }
    };
    PdfPage.prototype._destroy = function () {
        this._pageDictionary = undefined;
        this._size = undefined;
        this._mBox = undefined;
        this._cBox = undefined;
        this._o = undefined;
        this._g = undefined;
        this._graphicsState = undefined;
        this._contents = undefined;
    };
    PdfPage.prototype._obtainTabOrder = function () {
        if (this._pageDictionary && this._pageDictionary.has('Tabs')) {
            var tabOrder = this._pageDictionary.get('Tabs');
            if (tabOrder === _PdfName.get('R')) {
                this._tabOrder = PdfFormFieldsTabOrder.row;
            }
            else if (tabOrder === _PdfName.get('C')) {
                this._tabOrder = PdfFormFieldsTabOrder.column;
            }
            else if (tabOrder === _PdfName.get('S')) {
                this._tabOrder = PdfFormFieldsTabOrder.structure;
            }
            else if (tabOrder === _PdfName.get('W')) {
                this._tabOrder = PdfFormFieldsTabOrder.widget;
            }
        }
        if (this._tabOrder === null || typeof this._tabOrder === 'undefined') {
            this._tabOrder = PdfFormFieldsTabOrder.none;
        }
        return this._tabOrder;
    };
    PdfPage.prototype._removeAnnotation = function (reference) {
        if (this._pageDictionary && this._pageDictionary.has('Annots')) {
            var annots = this._getProperty('Annots');
            if (_isNullOrUndefined(annots) && Array.isArray(annots)) {
                var index = annots.indexOf(reference);
                if (index >= 0) {
                    annots.splice(index, 1);
                }
                this._pageDictionary.set('Annots', annots);
                this._pageDictionary._updated = true;
            }
        }
    };
    Object.defineProperty(PdfPage.prototype, "_contentTemplate", {
        get: function () {
            this._fetchResources();
            var targetArray = this._combineContent();
            var targetStream = new _PdfContentStream(Array.from(targetArray));
            var template = new PdfTemplate(targetStream, this._crossReference);
            template._content.dictionary.set('Resources', this._resourceObject);
            if (this.cropBox[0] > 0 || this.cropBox[1] > 0) {
                template._content.dictionary.set('BBox', this.cropBox);
                template._size = [this.cropBox[0], this.cropBox[1]];
            }
            else if (this.mediaBox[0] > 0 || this.mediaBox[1] > 0) {
                template._content.dictionary.set('BBox', this.mediaBox);
                template._size = [this.mediaBox[0], this.mediaBox[1]];
            }
            else {
                template._content.dictionary.set('BBox', [0, 0, this.size[0], this.size[1]]);
                template._size = [this.size[0], this.size[1]];
            }
            return template;
        },
        enumerable: true,
        configurable: true
    });
    PdfPage.prototype._combineIntoSingleArray = function (arrays) {
        var totalLength = arrays.reduce(function (length, arr) { return length + arr.length; }, 0);
        var targetArray = new Uint8Array(totalLength);
        var offset = 0;
        arrays.forEach(function (sourceArray) {
            targetArray.set(sourceArray, offset);
            offset += sourceArray.length;
        });
        return targetArray;
    };
    PdfPage.prototype._combineContent = function () {
        var list = [];
        var array;
        this._loadContents();
        var count = this._contents.length;
        list.push(new Uint8Array([32, 113, 32, 10]));
        for (var i = 0; i < count; i++) {
            var reference = this._contents[Number.parseInt(i.toString(), 10)];
            var base = this._crossReference._fetch(reference); // eslint-disable-line
            if (base) {
                if (base instanceof _PdfContentStream) {
                    array = new Uint8Array(base._bytes);
                }
                else if (base instanceof _PdfBaseStream) {
                    array = base.getBytes();
                }
                if (array) {
                    list.push(array);
                    list.push(new Uint8Array([13, 10]));
                }
            }
        }
        list.push(new Uint8Array([32, 81, 32, 10]));
        list.push(new Uint8Array([13, 10]));
        var targetArray = this._combineIntoSingleArray(list);
        return targetArray;
    };
    return PdfPage;
}());
/**
 * `PdfDestination` class represents the PDF destination.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access the annotation at index 0
 * let annotation: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
 * // Initializes a new instance of the `PdfDestination` class.
 * let destination: PdfDestination = new PdfDestination();
 * // Sets the zoom factor.
 * destination.zoom = 20;
 * // Sets the page where the destination is situated.
 * destination.page = page;
 * // Sets the mode of the destination.
 * destination.mode = PdfDestinationMode.fitToPage;
 * // Sets the location of the destination.
 * destination.location = [20, 20];
 * // Sets the bounds of the destination.
 * destination.destinationBounds = [20, 20, 100, 50];
 * // Sets destination to  document link annotation.
 * annotation.destination = destination;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfDestination = /** @class */ (function () {
    function PdfDestination(page, location) {
        this._location = [0, 0];
        this._destinationMode = PdfDestinationMode.location;
        this._zoom = 0;
        this._isValid = true;
        this._index = 0;
        this._destinationBounds = [0, 0, 0, 0];
        this._array = Array(); // eslint-disable-line
        if (typeof page !== 'undefined' && page !== null) {
            if (page.rotation === PdfRotationAngle.angle180) {
                this._location = [page.graphics._size[0], this._location[1]];
            }
            else if (page.rotation === PdfRotationAngle.angle90) {
                this._location = [0, 0];
            }
            else if (page.rotation === PdfRotationAngle.angle270) {
                this._location = [page.graphics._size[0], 0];
            }
            else {
                this._location = [0, this._location[1]];
            }
            this._page = page;
            this._index = page._pageIndex;
        }
        if (typeof location !== 'undefined' && location.length === 2) {
            this._location = location;
        }
        if (typeof location !== 'undefined' && location.length === 4) {
            this._location = [location[0], location[1]];
            this._destinationBounds = location;
        }
    }
    Object.defineProperty(PdfDestination.prototype, "zoom", {
        /**
         * Gets the zoom factor.
         *
         * @returns {number} zoom.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * //Access the annotation at index 0
         * let annot: PdfDocumentLinkAnnotation = page.annotations.at(0) as PdfDocumentLinkAnnotation;
         * // Gets the zoom factor of the destination.
         * let zoom: number = annot.destination.zoom;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._zoom;
        },
        /**
         * Sets the zoom factor.
         *
         * @param {number} value zoom.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the annotation at index 0
         * let annotation: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
         * // Initializes a new instance of the `PdfDestination` class.
         * let destination: PdfDestination = new PdfDestination();
         * // Sets the zoom factor.
         * destination.zoom = 20;
         * // Sets the page where the destination is situated.
         * destination.page = page;
         * // Sets the mode of the destination.
         * destination.mode = PdfDestinationMode.fitToPage;
         * // Sets the location of the destination.
         * destination.location = [20, 20];
         * // Sets the bounds of the destination.
         * destination.destinationBounds = [20, 20, 100, 50];
         * // Sets destination to  document link annotation.
         * annotation.destination = destination;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._zoom) {
                this._zoom = value;
                this._initializePrimitive();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDestination.prototype, "page", {
        /**
         * Gets the page where the destination is situated.
         *
         * @returns {PdfPage} page.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * //Access the annotation at index 0
         * let annot: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
         * // Gets the page of the destination.
         * let page: PdfPage = annot.destination.page;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._page;
        },
        /**
         * Sets the page where the destination is situated.
         *
         * @param {PdfPage} value page.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the annotation at index 0
         * let annotation: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
         * // Initializes a new instance of the `PdfDestination` class.
         * let destination: PdfDestination = new PdfDestination();
         * // Sets the zoom factor.
         * destination.zoom = 20;
         * // Sets the page where the destination is situated.
         * destination.page = page;
         * // Sets the mode of the destination.
         * destination.mode = PdfDestinationMode.fitToPage;
         * // Sets the location of the destination.
         * destination.location = [20, 20];
         * // Sets the bounds of the destination.
         * destination.destinationBounds = [20, 20, 100, 50];
         * // Sets destination to  document link annotation.
         * annotation.destination = destination;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._page) {
                this._page = value;
                this._initializePrimitive();
                this._index = value._pageIndex;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDestination.prototype, "pageIndex", {
        /**
         * Gets the page index of bookmark destination (Read only).
         *
         * @returns {number} index.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * //Access the annotation at index 0
         * let annot: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
         * // Gets the page index of the destination.
         * let pageIndex: number = annot.destination.pageIndex;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDestination.prototype, "mode", {
        /**
         * Gets the mode of the destination.
         *
         * @returns {PdfDestinationMode} page.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * //Access the annotation at index 0
         * let annot: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
         * // Gets the mode of the destination.
         * let mode: PdfDestinationMode = annot.destination.mode;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._destinationMode;
        },
        /**
         * Sets the mode of the destination.
         *
         * @param {PdfDestinationMode} value page.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the annotation at index 0
         * let annotation: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
         * // Initializes a new instance of the `PdfDestination` class.
         * let destination: PdfDestination = new PdfDestination();
         * // Sets the zoom factor.
         * destination.zoom = 20;
         * // Sets the page where the destination is situated.
         * destination.page = page;
         * // Sets the mode of the destination.
         * destination.mode = PdfDestinationMode.fitToPage;
         * // Sets the location of the destination.
         * destination.location = [20, 20];
         * // Sets the bounds of the destination.
         * destination.destinationBounds = [20, 20, 100, 50];
         * // Sets destination to document link annotation.
         * annotation.destination = destination;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._destinationMode) {
                this._destinationMode = value;
                this._initializePrimitive();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDestination.prototype, "location", {
        /**
         * Gets the location of the destination.
         *
         * @returns {number[]} page.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the annotation at index 0
         * let annot: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
         * // Gets the location of the destination.
         * let location: number[] = annot.destination.location;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._location;
        },
        /**
         * Sets the location of the destination.
         *
         * @param {number[]} value page.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the annotation at index 0
         * let annotation: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
         * // Initializes a new instance of the `PdfDestination` class.
         * let destination: PdfDestination = new PdfDestination();
         * // Sets the zoom factor.
         * destination.zoom = 20;
         * // Sets the page where the destination is situated.
         * destination.page = page;
         * // Sets the mode of the destination.
         * destination.mode = PdfDestinationMode.fitToPage;
         * // Sets the location of the destination.
         * destination.location = [20, 20];
         * // Sets the bounds of the destination.
         * destination.destinationBounds = [20, 20, 100, 50];
         * // Sets destination to  document link annotation.
         * annotation.destination = destination;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._location) {
                this._location = value;
                this._initializePrimitive();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDestination.prototype, "destinationBounds", {
        /**
         * Gets the bounds of the destination.
         *
         * @returns {number[]} bounds.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the annotation at index 0
         * let annot: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
         * // Gets the bounds of the destination.
         * let destinationBounds: number[] = annot.destination.destinationBounds;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._destinationBounds;
        },
        /**
         * Sets the bounds of the destination.
         *
         * @param {number[]} value bounds.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the annotation at index 0
         * let annotation: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
         * // Initializes a new instance of the `PdfDestination` class.
         * let destination: PdfDestination = new PdfDestination();
         * // Sets the zoom factor.
         * destination.zoom = 20;
         * // Sets the page where the destination is situated.
         * destination.page = page;
         * // Sets the mode of the destination.
         * destination.mode = PdfDestinationMode.fitToPage;
         * // Sets the location of the destination.
         * destination.location = [20, 20];
         * // Sets the bounds of the destination.
         * destination.destinationBounds = [20, 20, 100, 50];
         * // Sets destination to  document link annotation.
         * annotation.destination = destination;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._destinationBounds) {
                this._destinationBounds = value;
                this._initializePrimitive();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDestination.prototype, "isValid", {
        /**
         * Gets a value indicating whether this instance is valid (Read only).
         *
         * @returns {boolean} value indicating whether this instance is valid.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the annotation at index 0
         * let annot: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
         * // Gets a value indicating whether this instance is valid.
         * let isValid: boolean = annot.destination.isValid;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._isValid;
        },
        enumerable: true,
        configurable: true
    });
    PdfDestination.prototype._setValidation = function (value) {
        this._isValid = value;
    };
    PdfDestination.prototype._initializePrimitive = function () {
        this._array = [];
        var page = this._page;
        if (page && page._pageDictionary) {
            var element = page._pageDictionary;
            if (typeof element !== 'undefined' && element !== null) {
                this._array.push(this._page._ref);
            }
            switch (this._destinationMode) {
                case PdfDestinationMode.location:
                    this._array.push(_PdfName.get('XYZ'));
                    if (typeof page !== 'undefined' && page !== null) {
                        this._array.push(this._location[0]);
                        this._array.push(this._page.graphics._size[1] - this._location[1]);
                    }
                    else {
                        this._array.push(0);
                        this._array.push(0);
                    }
                    this._array.push(this._zoom);
                    break;
                case PdfDestinationMode.fitToPage:
                    this._array.push(_PdfName.get('Fit'));
                    break;
                case PdfDestinationMode.fitR:
                    this._array.push(_PdfName.get('FitR'));
                    this._array.push(this._destinationBounds[0]);
                    this._array.push(this._destinationBounds[1]);
                    this._array.push(this._destinationBounds[2]);
                    this._array.push(this._destinationBounds[3]);
                    break;
                case PdfDestinationMode.fitH:
                    this._array.push(_PdfName.get('FitH'));
                    this._array.push((typeof page !== 'undefined' && page !== null) ? page._size[1] - this._location[1] : 0);
                    break;
            }
            if (this._parent) {
                this._parent._dictionary.set(this._parent instanceof PdfNamedDestination ? 'D' : 'Dest', this._array);
                this._parent._dictionary._updated = true;
            }
        }
    };
    return PdfDestination;
}());

var _ImageDecoder = /** @class */ (function () {
    function _ImageDecoder() {
        this._format = _ImageFormat.unknown;
        this._height = 0;
        this._width = 0;
        this._bitsPerComponent = 8;
        this._position = 0;
        this._noOfComponents = -1;
    }
    _ImageDecoder.prototype._reset = function () {
        this._position = 0;
    };
    _ImageDecoder.prototype._getBuffer = function (index) {
        return this._stream[Number.parseInt(index.toString(), 10)];
    };
    _ImageDecoder.prototype._read = function (buffer, offset, count, stream) {
        if (stream && Array.isArray(stream)) {
            var result = 0;
            if (count <= stream.length && stream.length - offset >= count) {
                for (var i = 0; i < count; i++) {
                    buffer[Number.parseInt(i.toString(), 10)] = stream[Number.parseInt(offset.toString(), 10)];
                    offset++;
                    result++;
                }
            }
            return { 'outputBuffer': buffer, 'offset': offset, 'length': result };
        }
        else {
            for (var index = offset; index < count; index++) {
                var position = this._position;
                buffer[Number.parseInt(index.toString(), 10)] = this._getBuffer(position);
                this._position++;
            }
        }
    };
    _ImageDecoder.prototype._readString = function (length) {
        var result = '';
        for (var i = 0; i < length; i++) {
            result += String.fromCharCode(this._readByte());
        }
        return result;
    };
    _ImageDecoder.prototype._seek = function (length) {
        this._position += length;
    };
    _ImageDecoder.prototype._readByte = function () {
        if (this._position < this._stream.byteLength) {
            var value = this._getBuffer(this._position);
            this._position += 1;
            return value;
        }
        else {
            throw new Error('Error decoding JPEG image. Invalid offset.');
        }
    };
    _ImageDecoder.prototype._toUnsigned16 = function (value) {
        value = value & 0xFFFF;
        return value < 0 ? (value + 0x10000) : value;
    };
    _ImageDecoder.prototype._readUnsigned32 = function (offset) {
        var i1 = this._getBuffer(offset + 3);
        var i2 = this._getBuffer(offset + 2);
        var i3 = this._getBuffer(offset + 1);
        var i4 = this._getBuffer(offset);
        return i1 | (i2 << 8) | (i3 << 16) | (i4 << 24);
    };
    return _ImageDecoder;
}());

var __extends$8 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _JpegDecoder = /** @class */ (function (_super) {
    __extends$8(_JpegDecoder, _super);
    /**
     * Initializes a new instance of the `_JpegDecoder` class.
     *
     * @private
     * @param {Uint8Array} stream byte array.
     */
    function _JpegDecoder(stream) {
        var _this = _super.call(this) || this;
        _this._stream = stream;
        _this._initialize();
        return _this;
    }
    Object.defineProperty(_JpegDecoder.prototype, "_imageDataAsNumberArray", {
        get: function () {
            return this._imageData;
        },
        enumerable: true,
        configurable: true
    });
    _JpegDecoder.prototype._initialize = function () {
        this._format = _ImageFormat.jpeg;
        this._readHeader();
        this._reset();
        this._imageData = new Uint8Array(this._stream.byteLength);
        this._read(this._imageData, 0, this._imageData.byteLength);
    };
    _JpegDecoder.prototype._readHeader = function () {
        this._reset();
        var imgData = new Uint8Array(this._stream.byteLength);
        this._read(imgData, 0, imgData.byteLength);
        var i = 4;
        var length = this._getBuffer(i) * 256 + this._getBuffer(i + 1);
        var isLengthExceed = false;
        while (i < imgData.byteLength) {
            i += length;
            if (i < imgData.byteLength) {
                if (this._getBuffer(i + 1) === 192) {
                    this._height = this._getBuffer(i + 5) * 256 + this._getBuffer(i + 6);
                    this._width = this._getBuffer(i + 7) * 256 + this._getBuffer(i + 8);
                    this._noOfComponents = this._getBuffer(i + 9);
                    if (this._width !== 0 && this._height !== 0) {
                        return;
                    }
                }
                else {
                    i += 2;
                    length = this._getBuffer(i) * 256 + this._getBuffer(i + 1);
                }
            }
            else {
                isLengthExceed = true;
                break;
            }
        }
        if (isLengthExceed) {
            this._reset();
            this._seek(2);
            this._readExceededJpegImage();
        }
    };
    _JpegDecoder.prototype._getImageDictionary = function () {
        var data = []; // eslint-disable-line
        this._imageStream = new _PdfStream(data, new _PdfDictionary());
        this._imageStream.isImageStream = true;
        var tempString = '';
        var decodedString = '';
        for (var i = 0; i < this._imageDataAsNumberArray.byteLength; i++) {
            tempString += ' ' + String.fromCharCode(this._getBuffer(i));
        }
        for (var i = 0; i < tempString.length; i++) {
            if (i % 2 !== 0) {
                decodedString += tempString[Number.parseInt(i.toString(), 10)];
            }
        }
        this._imageStream.data = [decodedString];
        this._imageStream._isCompress = false;
        var dictionary = new _PdfDictionary();
        dictionary.set('Type', new _PdfName('XObject'));
        dictionary.set('Subtype', new _PdfName('Image'));
        dictionary.set('Width', this._width);
        dictionary.set('Height', this._height);
        dictionary.set('BitsPerComponent', this._bitsPerComponent);
        dictionary.set('Filter', new _PdfName('DCTDecode'));
        dictionary.set('ColorSpace', new _PdfName(this._getColorSpace()));
        dictionary.set('DecodeParms', this._getDecodeParams());
        this._imageStream.dictionary = dictionary;
        this._imageStream.bytes = new Uint8Array(this._imageStream.data[0].length);
        for (var i = 0; i < this._imageStream.data[0].length; i++) {
            this._imageStream.bytes[Number.parseInt(i.toString(), 10)] = this._imageStream.data[0].charCodeAt(i);
        }
        this._imageStream.end = this._imageStream.bytes.length;
        this._imageStream.dictionary._updated = true;
        return this._imageStream;
    };
    _JpegDecoder.prototype._getColorSpace = function () {
        if (this._noOfComponents === 1) {
            return 'DeviceGray';
        }
        else if (this._noOfComponents === 4) {
            return 'DeviceCMYK';
        }
        return 'DeviceRGB';
    };
    _JpegDecoder.prototype._getDecodeParams = function () {
        var decodeParams = new _PdfDictionary();
        decodeParams.set('Columns', this._width);
        decodeParams.set('BlackIs1', true);
        decodeParams.set('K', -1);
        decodeParams.set('Predictor', 15);
        decodeParams.set('BitsPerComponent', this._bitsPerComponent);
        return decodeParams;
    };
    _JpegDecoder.prototype._skipStream = function () {
        var length = this._getBuffer(this._position) << 8 | this._getBuffer(this._position + 1);
        this._seek(2);
        if (length < 2) {
            throw new Error('Error decoding JPEG image');
        }
        else if (length > 0) {
            this._seek(length - 2);
        }
    };
    _JpegDecoder.prototype._readExceededJpegImage = function () {
        var isContinueReading = true;
        while (isContinueReading) {
            var marker = this._getMarker();
            switch (marker) {
                case 0x00C0:
                case 0x00C1:
                case 0x00C2:
                case 0x00C3:
                case 0x00C5:
                case 0x00C6:
                case 0x00C7:
                case 0x00C9:
                case 0x00CA:
                case 0x00CB:
                case 0x00CD:
                case 0x00CE:
                case 0x00CF:
                    this._seek(3);
                    this._height = this._getBuffer(this._position) << 8 | this._getBuffer(this._position + 1);
                    this._seek(2);
                    this._width = this._getBuffer(this._position) << 8 | this._getBuffer(this._position + 1);
                    this._seek(2);
                    this._noOfComponents = this._getBuffer(this._position);
                    this._seek(1);
                    isContinueReading = false;
                    break;
                default:
                    this._skipStream();
                    break;
            }
        }
    };
    _JpegDecoder.prototype._getMarker = function () {
        var skippedByte = 0;
        var marker = this._readByte();
        while (marker !== 255) {
            skippedByte++;
            marker = this._readByte();
        }
        do {
            marker = this._readByte();
        } while (marker === 255);
        if (skippedByte !== 0) {
            throw new Error('Error decoding JPEG image');
        }
        return this._toUnsigned16(marker);
    };
    return _JpegDecoder;
}(_ImageDecoder));

var _InflaterState;
(function (_InflaterState) {
    _InflaterState[_InflaterState["readingHeader"] = 0] = "readingHeader";
    _InflaterState[_InflaterState["readingBFinal"] = 1] = "readingBFinal";
    _InflaterState[_InflaterState["readingBType"] = 2] = "readingBType";
    _InflaterState[_InflaterState["readingNlCodes"] = 3] = "readingNlCodes";
    _InflaterState[_InflaterState["readingNdCodes"] = 4] = "readingNdCodes";
    _InflaterState[_InflaterState["readingCodes"] = 5] = "readingCodes";
    _InflaterState[_InflaterState["readingClCodes"] = 6] = "readingClCodes";
    _InflaterState[_InflaterState["readingTcBefore"] = 7] = "readingTcBefore";
    _InflaterState[_InflaterState["readingTcAfter"] = 8] = "readingTcAfter";
    _InflaterState[_InflaterState["decodeTop"] = 9] = "decodeTop";
    _InflaterState[_InflaterState["iLength"] = 10] = "iLength";
    _InflaterState[_InflaterState["fLength"] = 11] = "fLength";
    _InflaterState[_InflaterState["dCode"] = 12] = "dCode";
    _InflaterState[_InflaterState["unCompressedAligning"] = 13] = "unCompressedAligning";
    _InflaterState[_InflaterState["unCompressedByte1"] = 14] = "unCompressedByte1";
    _InflaterState[_InflaterState["unCompressedByte2"] = 15] = "unCompressedByte2";
    _InflaterState[_InflaterState["unCompressedByte3"] = 16] = "unCompressedByte3";
    _InflaterState[_InflaterState["unCompressedByte4"] = 17] = "unCompressedByte4";
    _InflaterState[_InflaterState["decodeUnCompressedBytes"] = 18] = "decodeUnCompressedBytes";
    _InflaterState[_InflaterState["srFooter"] = 19] = "srFooter";
    _InflaterState[_InflaterState["rFooter"] = 20] = "rFooter";
    _InflaterState[_InflaterState["vFooter"] = 21] = "vFooter";
    _InflaterState[_InflaterState["done"] = 22] = "done";
})(_InflaterState || (_InflaterState = {}));
var _BlockType;
(function (_BlockType) {
    _BlockType[_BlockType["unCompressedType"] = 0] = "unCompressedType";
    _BlockType[_BlockType["staticType"] = 1] = "staticType";
    _BlockType[_BlockType["dynamicType"] = 2] = "dynamicType";
})(_BlockType || (_BlockType = {}));

var _DecompressedOutput = /** @class */ (function () {
    function _DecompressedOutput() {
        this._end = 0;
        this._usedBytes = 0;
        this._dOutput = Array(_DecompressedOutput._dOutSize).fill(0);
        this._end = 0;
        this._usedBytes = 0;
    }
    Object.defineProperty(_DecompressedOutput.prototype, "_unusedBytes", {
        get: function () {
            return _DecompressedOutput._dOutSize - this._usedBytes;
        },
        enumerable: true,
        configurable: true
    });
    _DecompressedOutput.prototype._write = function (b) {
        this._dOutput[this._end++] = b;
        this._end &= _DecompressedOutput._dOutMask;
        ++this._usedBytes;
    };
    _DecompressedOutput.prototype._writeLD = function (length, distance) {
        this._usedBytes += length;
        var copyStart = (this._end - distance) & _DecompressedOutput._dOutMask;
        var border = _DecompressedOutput._dOutSize - length;
        if (copyStart <= border && this._end < border) {
            if (length <= distance) {
                _copyRange(this._dOutput, this._end, this._dOutput, copyStart, copyStart + length);
                this._end += length;
            }
            else {
                while (length-- > 0) {
                    this._dOutput[this._end++] = this._dOutput[copyStart++];
                }
            }
        }
        else {
            while (length-- > 0) {
                this._dOutput[this._end++] = this._dOutput[copyStart++];
                this._end &= _DecompressedOutput._dOutMask;
                copyStart &= _DecompressedOutput._dOutMask;
            }
        }
    };
    _DecompressedOutput.prototype._copyFrom = function (input, length) {
        length = Math.min(Math.min(length, _DecompressedOutput._dOutSize - this._usedBytes), input._bytes);
        var copied;
        var tailLen = _DecompressedOutput._dOutSize - this._end;
        if (length > tailLen) {
            copied = input._copyTo(this._dOutput, this._end, tailLen);
            if (copied === tailLen) {
                copied += input._copyTo(this._dOutput, 0, length - tailLen);
            }
        }
        else {
            copied = input._copyTo(this._dOutput, this._end, length);
        }
        this._end = (this._end + copied) & _DecompressedOutput._dOutMask;
        this._usedBytes += copied;
        return copied;
    };
    _DecompressedOutput.prototype._copyTo = function (output, offset, length) {
        var end;
        if (length > this._usedBytes) {
            end = this._end;
            length = this._usedBytes;
        }
        else {
            end = (this._end - this._usedBytes + length) & _DecompressedOutput._dOutMask;
        }
        var copied = length;
        var tailLen = length - end;
        var sourceStart = _DecompressedOutput._dOutSize - tailLen;
        if (tailLen > 0) {
            for (var i = 0; i < tailLen && i + sourceStart < this._dOutput.length && i + offset < output.length; i++) {
                output[offset + i] = this._dOutput[sourceStart + i];
            }
            var sourceStartIndex_1 = _DecompressedOutput._dOutSize - tailLen;
            _copyRange(output, offset, this._dOutput, sourceStartIndex_1, sourceStartIndex_1 + tailLen);
            offset += tailLen;
            length = end;
        }
        sourceStart = end - length;
        var sourceStartIndex = end - length;
        _copyRange(output, offset, this._dOutput, sourceStartIndex, end);
        this._usedBytes -= copied;
        return { 'count': copied, 'data': output };
    };
    _DecompressedOutput._dOutSize = 32768;
    _DecompressedOutput._dOutMask = 32767;
    return _DecompressedOutput;
}());

var _InBuffer = /** @class */ (function () {
    function _InBuffer() {
        this._bBuffer = 0;
        this._bInBuffer = 0;
        this._begin = 0;
        this._end = 0;
    }
    Object.defineProperty(_InBuffer.prototype, "_bytes", {
        get: function () {
            return (this._end - this._begin) + Math.floor(this._bInBuffer / 8);
        },
        enumerable: true,
        configurable: true
    });
    _InBuffer.prototype._needsInput = function () {
        return this._begin === this._end;
    };
    _InBuffer.prototype._availableBits = function (count) {
        if (this._bInBuffer < count) {
            if (this._needsInput()) {
                return false;
            }
            this._bBuffer |= _toUnsigned(this._buffer[this._begin++], 32) << this._bInBuffer;
            this._bInBuffer += 8;
            if (this._bInBuffer < count) {
                if (this._needsInput()) {
                    return false;
                }
                this._bBuffer |= _toUnsigned(this._buffer[this._begin++], 32) << this._bInBuffer;
                this._bInBuffer += 8;
            }
        }
        return true;
    };
    _InBuffer.prototype._load16Bits = function () {
        if (this._bInBuffer < 8) {
            if (this._begin < this._end) {
                this._bBuffer |= _toUnsigned(this._buffer[this._begin++], 32) << this._bInBuffer;
                this._bInBuffer += 8;
            }
            if (this._begin < this._end) {
                this._bBuffer |= _toUnsigned(this._buffer[this._begin++], 32) << this._bInBuffer;
                this._bInBuffer += 8;
            }
        }
        else if (this._bInBuffer < 16) {
            if (this._begin < this._end) {
                this._bBuffer |= _toUnsigned(this._buffer[this._begin++], 32) << this._bInBuffer;
                this._bInBuffer += 8;
            }
        }
        return this._bBuffer;
    };
    _InBuffer.prototype._getBitMask = function (count) {
        return (_toUnsigned(1, 32) << count) - 1;
    };
    _InBuffer.prototype._getBits = function (count) {
        if (!this._availableBits(count)) {
            return -1;
        }
        var result = this._bBuffer & this._getBitMask(count);
        this._bBuffer >>= count;
        this._bInBuffer -= count;
        return result;
    };
    _InBuffer.prototype._copyTo = function (output, offset, length) {
        var bitBuffer = 0;
        while (this._bInBuffer > 0 && length > 0) {
            output[offset++] = _toUnsigned(this._bBuffer, 8);
            this._bBuffer >>= 8;
            this._bInBuffer -= 8;
            length--;
            bitBuffer++;
        }
        if (length === 0) {
            return bitBuffer;
        }
        var avail = this._end - this._begin;
        if (length > avail) {
            length = avail;
        }
        for (var i = 0; i < length && i + this._begin < this._buffer.length && i + offset < output.length; i++) {
            output[offset + i] = this._buffer[this._begin + i];
        }
        this._begin += length;
        return bitBuffer + length;
    };
    _InBuffer.prototype._setInput = function (buffer, offset, length) {
        this._buffer = buffer;
        this._begin = offset;
        this._end = offset + length;
    };
    _InBuffer.prototype._skipBits = function (n) {
        this._bBuffer >>= n;
        this._bInBuffer -= n;
    };
    _InBuffer.prototype._skipByteBoundary = function () {
        this._bBuffer >>= this._bInBuffer % 8;
        this._bInBuffer = this._bInBuffer - (this._bInBuffer % 8);
    };
    return _InBuffer;
}());

var _HuffmanTree = /** @class */ (function () {
    function _HuffmanTree() {
    }
    _HuffmanTree.prototype._load = function (code) {
        this._clArray = code;
        this._initialize();
    };
    _HuffmanTree.prototype._loadTree = function (isLengthTree) {
        this._clArray = isLengthTree ? this._getLengthTree() : this._getDepthTree();
        this._initialize();
    };
    _HuffmanTree.prototype._initialize = function () {
        if (this._clArray.length === _HuffmanTree._maxLengthTree) {
            this._tBits = 9;
        }
        else {
            this._tBits = 7;
        }
        this._tMask = (1 << this._tBits) - 1;
        this._createTable();
    };
    _HuffmanTree.prototype._getLengthTree = function () {
        var lTree = Array(_HuffmanTree._maxLengthTree).fill(0);
        for (var i = 0; i <= 143; i++) {
            lTree[Number.parseInt(i.toString(), 10)] = _toUnsigned(8, 8);
        }
        for (var i = 144; i <= 255; i++) {
            lTree[Number.parseInt(i.toString(), 10)] = _toUnsigned(9, 8);
        }
        for (var i = 256; i <= 279; i++) {
            lTree[Number.parseInt(i.toString(), 10)] = _toUnsigned(7, 8);
        }
        for (var i = 280; i <= 287; i++) {
            lTree[Number.parseInt(i.toString(), 10)] = _toUnsigned(8, 8);
        }
        return lTree;
    };
    _HuffmanTree.prototype._getDepthTree = function () {
        return Array(_HuffmanTree._maxDepthTree).fill(5);
    };
    _HuffmanTree.prototype._calculateHashCode = function () {
        var bit = Array(17).fill(0);
        for (var i = 0; i < this._clArray.length; i++) {
            bit[this._clArray[Number.parseInt(i.toString(), 10)]]++;
        }
        bit[0] = 0;
        var next = Array(17).fill(0);
        var temp = 0;
        for (var bits = 1; bits <= 16; bits++) {
            temp = (temp + bit[bits - 1]) << 1;
            next[Number.parseInt(bits.toString(), 10)] = temp;
        }
        var code = Array(_HuffmanTree._maxLengthTree).fill(0);
        for (var i = 0; i < this._clArray.length; i++) {
            var len = this._clArray[Number.parseInt(i.toString(), 10)];
            if (len > 0) {
                code[Number.parseInt(i.toString(), 10)] = this._bitReverse(next[Number.parseInt(len.toString(), 10)], len);
                next[Number.parseInt(len.toString(), 10)]++;
            }
        }
        return code;
    };
    _HuffmanTree.prototype._bitReverse = function (code, length) {
        var newcode = 0;
        do {
            newcode |= code & 1;
            newcode <<= 1;
            code >>= 1;
        } while (--length > 0);
        return newcode >> 1;
    };
    _HuffmanTree.prototype._createTable = function () {
        var codeArray = this._calculateHashCode();
        this._table = Array(1 << this._tBits).fill(0);
        this._left = Array(2 * this._clArray.length).fill(0);
        this._right = Array(2 * this._clArray.length).fill(0);
        var avail = _toSigned16(this._clArray.length);
        for (var ch = 0; ch < this._clArray.length; ch++) {
            var len = this._clArray[Number.parseInt(ch.toString(), 10)];
            if (len > 0) {
                var start = codeArray[Number.parseInt(ch.toString(), 10)];
                if (len <= this._tBits) {
                    var i = 1 << len;
                    if (start >= i) {
                        throw new Error('Invalid Data.');
                    }
                    var l = 1 << (this._tBits - len);
                    for (var j = 0; j < l; j++) {
                        this._table[Number.parseInt(start.toString(), 10)] = _toSigned16(ch);
                        start += i;
                    }
                }
                else {
                    var ofBits = len - this._tBits;
                    var bitMask = 1 << this._tBits;
                    var index = start & ((1 << this._tBits) - 1);
                    var array = this._table;
                    do {
                        var value = _toSigned16(array[Number.parseInt(index.toString(), 10)]);
                        if (value === 0) {
                            array[Number.parseInt(index.toString(), 10)] = _toSigned16(-avail);
                            value = _toSigned16(-avail);
                            avail++;
                        }
                        if (value > 0) {
                            throw new Error('Invalid Data.');
                        }
                        if ((start & bitMask) === 0) {
                            array = this._left;
                        }
                        else {
                            array = this._right;
                        }
                        index = -value;
                        bitMask <<= 1;
                        ofBits--;
                    } while (ofBits !== 0);
                    array[Number.parseInt(index.toString(), 10)] = _toSigned16(ch);
                }
            }
        }
    };
    _HuffmanTree.prototype._getNextSymbol = function (input) {
        var bitBuffer = input._load16Bits();
        if (input._bInBuffer === 0) {
            return -1;
        }
        var symbol = this._table[bitBuffer & this._tMask];
        if (symbol < 0) {
            var mask = _toUnsigned((1 << this._tBits), 32);
            do {
                symbol = -symbol;
                if ((bitBuffer & mask) === 0) {
                    symbol = this._left[Number.parseInt(symbol.toString(), 10)];
                }
                else {
                    symbol = this._right[Number.parseInt(symbol.toString(), 10)];
                }
                mask <<= 1;
            } while (symbol < 0);
        }
        var codeLength = this._clArray[Number.parseInt(symbol.toString(), 10)];
        if (codeLength <= 0) {
            throw new Error('Invalid Data.');
        }
        if (codeLength > input._bInBuffer) {
            return -1;
        }
        input._skipBits(codeLength);
        return symbol;
    };
    _HuffmanTree._maxLengthTree = 288;
    _HuffmanTree._maxDepthTree = 32;
    _HuffmanTree._nCLength = 19;
    return _HuffmanTree;
}());

/* eslint-disable */
var _Inflater = /** @class */ (function () {
    function _Inflater() {
        this._extraLengthBits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
        this._staticDistanceTreeTable = [0x00, 0x10, 0x08, 0x18, 0x04, 0x14, 0x0c, 0x1c, 0x02, 0x12, 0x0a, 0x1a, 0x06, 0x16, 0x0e, 0x1e,
            0x01, 0x11, 0x09, 0x19, 0x05, 0x15, 0x0d, 0x1d, 0x03, 0x13, 0x0b, 0x1b, 0x07, 0x17, 0x0f, 0x1f];
        this._lengthBase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115,
            131, 163, 195, 227, 258];
        this._distanceBasePosition = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049,
            3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
        this._codeOrder = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        this._bfinal = 0;
        this._bLength = 0;
        this._blBuffer = [0, 0, 0, 0];
        this._blockType = _BlockType.unCompressedType;
        this._caSize = 0;
        this._clCodeCount = 0;
        this._extraBits = 0;
        this._lengthCode = 0;
        this._length = 0;
        this._llCodeCount = 0;
        this._output = new _DecompressedOutput();
        this._input = new _InBuffer();
        this._loopCounter = 0;
        this._codeList = Array(_HuffmanTree._maxLengthTree + _HuffmanTree._maxDepthTree).fill(0);
        this._cltcl = Array(_HuffmanTree._nCLength).fill(0);
        this._inflaterState = _InflaterState.readingBFinal;
    }
    Object.defineProperty(_Inflater.prototype, "_finished", {
        get: function () {
            return this._inflaterState === _InflaterState.done || this._inflaterState === _InflaterState.vFooter;
        },
        enumerable: true,
        configurable: true
    });
    _Inflater.prototype._setInput = function (inputBytes, offset, length) {
        this._input._setInput(inputBytes, offset, length);
    };
    _Inflater.prototype._inflate = function (bytes, offset, length) {
        var i = 0;
        do {
            var result = this._output._copyTo(bytes, offset, length);
            var copied = result.count;
            bytes = result.data;
            if (copied > 0) {
                offset += copied;
                i += copied;
                length -= copied;
            }
            if (length === 0) {
                break;
            }
        } while (!this._finished && this._decode());
        return { 'count': i, 'data': bytes };
    };
    _Inflater.prototype._decode = function () {
        var eob = false;
        var result = false;
        if (this._finished) {
            return true;
        }
        if (this._inflaterState === _InflaterState.readingBFinal) {
            if (!this._input._availableBits(1)) {
                return false;
            }
            this._bfinal = this._input._getBits(1);
            this._inflaterState = _InflaterState.readingBType;
        }
        if (this._inflaterState === _InflaterState.readingBType) {
            if (!this._input._availableBits(2)) {
                this._inflaterState = _InflaterState.readingBType;
                return false;
            }
            this._blockType = this._getBlockType(this._input._getBits(2));
            if (this._blockType === _BlockType.dynamicType) {
                this._inflaterState = _InflaterState.readingNlCodes;
            }
            else if (this._blockType === _BlockType.staticType) {
                this._llTree = new _HuffmanTree();
                this._llTree._loadTree(true);
                this._distanceTree = new _HuffmanTree();
                this._distanceTree._loadTree(false);
                this._inflaterState = _InflaterState.decodeTop;
            }
            else if (this._blockType === _BlockType.unCompressedType) {
                this._inflaterState = _InflaterState.unCompressedAligning;
            }
        }
        if (this._blockType === _BlockType.dynamicType) {
            if (this._getInflaterStateValue(this._inflaterState) < this._getInflaterStateValue(_InflaterState.decodeTop)) {
                result = this._decodeDynamicBlockHeader();
            }
            else {
                var returnedValue = this._decodeBlock(eob);
                result = returnedValue.result;
                eob = returnedValue.eob;
                this._output = returnedValue.output;
            }
        }
        else if (this._blockType === _BlockType.staticType) {
            var returnedValue = this._decodeBlock(eob);
            result = returnedValue.result;
            eob = returnedValue.eob;
            this._output = returnedValue.output;
        }
        else if (this._blockType === _BlockType.unCompressedType) {
            var returnedValue = this._decodeUncompressedBlock(eob);
            result = returnedValue.result;
            eob = returnedValue.eob;
            this._output = returnedValue.output;
        }
        if (eob && (this._bfinal !== 0)) {
            this._inflaterState = _InflaterState.done;
        }
        return result;
    };
    _Inflater.prototype._decodeUncompressedBlock = function (endBlock) {
        endBlock = false;
        while (true) {
            switch (this._inflaterState) {
                case _InflaterState.unCompressedAligning:
                    this._input._skipByteBoundary();
                    this._inflaterState = _InflaterState.unCompressedByte1;
                    if (!this._unCompressedByte()) {
                        return { 'result': false, 'eob': endBlock, 'output': this._output };
                    }
                    break;
                case _InflaterState.unCompressedByte1:
                case _InflaterState.unCompressedByte2:
                case _InflaterState.unCompressedByte3:
                case _InflaterState.unCompressedByte4:
                    if (!this._unCompressedByte()) {
                        return { 'result': false, 'eob': endBlock, 'output': this._output };
                    }
                    break;
                case _InflaterState.decodeUnCompressedBytes:
                    this._bLength -= this._output._copyFrom(this._input, this._bLength);
                    if (this._bLength === 0) {
                        this._inflaterState = _InflaterState.readingBFinal;
                        endBlock = true;
                        return { 'result': true, 'eob': endBlock, 'output': this._output };
                    }
                    if (this._output._unusedBytes === 0) {
                        return { 'result': true, 'eob': endBlock, 'output': this._output };
                    }
                    return { 'result': false, 'eob': endBlock, 'output': this._output };
            }
        }
    };
    _Inflater.prototype._unCompressedByte = function () {
        var bits = this._input._getBits(8);
        if (bits < 0) {
            return false;
        }
        var inflaterstate = this._getInflaterStateValue(this._inflaterState);
        var unCompressedByte = this._getInflaterStateValue(_InflaterState.unCompressedByte1);
        this._blBuffer[inflaterstate - unCompressedByte] = _toUnsigned(bits, 8);
        if (this._inflaterState === _InflaterState.unCompressedByte4) {
            this._bLength = this._blBuffer[0] + (this._blBuffer[1]) * 256;
            if (_toUnsigned(this._bLength, 16) !== _toUnsigned((~(this._blBuffer[2] + (this._blBuffer[3]) * 256)), 16)) {
                throw new Error('Ivalid block length.');
            }
        }
        this._inflaterState = this._getInflaterState(this._getInflaterStateValue(this._inflaterState) + 1);
        return true;
    };
    _Inflater.prototype._decodeBlock = function (endBlock) {
        endBlock = false;
        var fb = this._output._unusedBytes;
        while (fb > 258) {
            var symbol = void 0;
            var dCodeResult = void 0;
            var fLengthResult = void 0;
            var inLengthResult = void 0;
            switch (this._inflaterState) {
                case _InflaterState.decodeTop:
                    symbol = this._llTree._getNextSymbol(this._input);
                    if (symbol < 0) {
                        return { 'result': false, 'eob': endBlock, 'output': this._output };
                    }
                    if (symbol < 256) {
                        this._output._write(_toUnsigned(symbol, 8));
                        --fb;
                    }
                    else if (symbol === 256) {
                        endBlock = true;
                        this._inflaterState = _InflaterState.readingBFinal;
                        return { 'result': true, 'eob': endBlock, 'output': this._output };
                    }
                    else {
                        symbol -= 257;
                        if (symbol < 8) {
                            symbol += 3;
                            this._extraBits = 0;
                        }
                        else if (symbol === 28) {
                            symbol = 258;
                            this._extraBits = 0;
                        }
                        else {
                            if (symbol < 0 || symbol >= this._extraLengthBits.length) {
                                throw new Error('Invalid data.');
                            }
                            this._extraBits = this._extraLengthBits[Number.parseInt(symbol.toString(), 10)];
                        }
                        this._length = symbol;
                        inLengthResult = this._inLength(fb);
                        fb = inLengthResult.fb;
                        if (!inLengthResult.value) {
                            return { 'result': false, 'eob': endBlock, 'output': this._output };
                        }
                    }
                    break;
                case _InflaterState.iLength:
                    inLengthResult = this._inLength(fb);
                    fb = inLengthResult.fb;
                    if (!inLengthResult.value) {
                        return { 'result': false, 'eob': endBlock, 'output': this._output };
                    }
                    break;
                case _InflaterState.fLength:
                    fLengthResult = this._fLength(fb);
                    fb = fLengthResult.fb;
                    if (!fLengthResult.value) {
                        return { 'result': false, 'eob': endBlock, 'output': this._output };
                    }
                    break;
                case _InflaterState.dCode:
                    dCodeResult = this._dcode(fb);
                    fb = dCodeResult.fb;
                    if (!dCodeResult.value) {
                        return { 'result': false, 'eob': endBlock, 'output': this._output };
                    }
                    break;
            }
        }
        return { 'result': true, 'eob': endBlock, 'output': this._output };
    };
    _Inflater.prototype._inLength = function (fb) {
        if (this._extraBits > 0) {
            this._inflaterState = _InflaterState.iLength;
            var bits = this._input._getBits(this._extraBits);
            if (bits < 0) {
                return { 'value': false, 'fb': fb };
            }
            if (this._length < 0 || this._length >= this._lengthBase.length) {
                throw new Error('Invalid data.');
            }
            this._length = this._lengthBase[this._length] + bits;
        }
        this._inflaterState = _InflaterState.fLength;
        var fLengthResult = this._fLength(fb);
        fb = fLengthResult.fb;
        if (!fLengthResult.value) {
            return { 'value': false, 'fb': fb };
        }
        return { 'value': true, 'fb': fb };
    };
    _Inflater.prototype._fLength = function (fb) {
        if (this._blockType === _BlockType.dynamicType) {
            this._distanceCode = this._distanceTree._getNextSymbol(this._input);
        }
        else {
            this._distanceCode = this._input._getBits(5);
            if (this._distanceCode >= 0) {
                this._distanceCode = this._staticDistanceTreeTable[this._distanceCode];
            }
        }
        if (this._distanceCode < 0) {
            return { 'value': false, 'fb': fb };
        }
        this._inflaterState = _InflaterState.dCode;
        var dCodeResult = this._dcode(fb);
        fb = dCodeResult.fb;
        if (!dCodeResult.value) {
            return { 'value': false, 'fb': fb };
        }
        return { 'value': true, 'fb': fb };
    };
    _Inflater.prototype._dcode = function (fb) {
        var offset;
        if (this._distanceCode > 3) {
            this._extraBits = (this._distanceCode - 2) >> 1;
            var bits = this._input._getBits(this._extraBits);
            if (bits < 0) {
                return { 'value': false, 'fb': fb };
            }
            offset = this._distanceBasePosition[this._distanceCode] + bits;
        }
        else {
            offset = this._distanceCode + 1;
        }
        this._output._writeLD(this._length, offset);
        fb -= this._length;
        this._inflaterState = _InflaterState.decodeTop;
        return { 'value': true, 'fb': fb };
    };
    _Inflater.prototype._decodeDynamicBlockHeader = function () {
        switch (this._inflaterState) {
            case _InflaterState.readingNlCodes:
                this._llCodeCount = this._input._getBits(5);
                if (this._llCodeCount < 0) {
                    return false;
                }
                this._llCodeCount += 257;
                this._inflaterState = _InflaterState.readingNdCodes;
                if (!this._readingNDCodes()) {
                    return false;
                }
                break;
            case _InflaterState.readingNdCodes:
                if (!this._readingNDCodes()) {
                    return false;
                }
                break;
            case _InflaterState.readingCodes:
                if (!this._readingCodes()) {
                    return false;
                }
                break;
            case _InflaterState.readingClCodes:
                if (!this._readingCLCodes()) {
                    return false;
                }
                break;
            case _InflaterState.readingTcBefore:
            case _InflaterState.readingTcAfter:
                if (!this._readingTCBefore()) {
                    return false;
                }
                break;
        }
        var literalTreeCodeLength = Array(_HuffmanTree._maxLengthTree).fill(0);
        _copyRange(literalTreeCodeLength, 0, this._codeList, 0, this._llCodeCount);
        var distanceTreeCodeLength = Array(_HuffmanTree._maxDepthTree).fill(0);
        _copyRange(distanceTreeCodeLength, 0, this._codeList, this._llCodeCount, this._llCodeCount + this._dCodeCount);
        this._llTree = new _HuffmanTree();
        this._llTree._load(literalTreeCodeLength);
        this._distanceTree = new _HuffmanTree();
        this._distanceTree._load(distanceTreeCodeLength);
        this._inflaterState = _InflaterState.decodeTop;
        return true;
    };
    _Inflater.prototype._readingNDCodes = function () {
        this._dCodeCount = this._input._getBits(5);
        if (this._dCodeCount < 0) {
            return false;
        }
        this._dCodeCount += 1;
        this._inflaterState = _InflaterState.readingCodes;
        if (!this._readingCodes()) {
            return false;
        }
        return true;
    };
    _Inflater.prototype._readingCodes = function () {
        this._clCodeCount = this._input._getBits(4);
        if (this._clCodeCount < 0) {
            return false;
        }
        this._clCodeCount += 4;
        this._loopCounter = 0;
        this._inflaterState = _InflaterState.readingClCodes;
        if (!this._readingCLCodes()) {
            return false;
        }
        return true;
    };
    _Inflater.prototype._readingCLCodes = function () {
        while (this._loopCounter < this._clCodeCount) {
            var bits = this._input._getBits(3);
            if (bits < 0) {
                return false;
            }
            this._cltcl[this._codeOrder[this._loopCounter]] = _toUnsigned(bits, 8);
            ++this._loopCounter;
        }
        for (var i = this._clCodeCount; i < this._codeOrder.length; i++) {
            this._cltcl[this._codeOrder[Number.parseInt(i.toString(), 10)]] = 0;
        }
        this._clTree = new _HuffmanTree();
        this._clTree._load(this._cltcl);
        this._caSize = this._llCodeCount + this._dCodeCount;
        this._loopCounter = 0;
        this._inflaterState = _InflaterState.readingTcBefore;
        if (!this._readingTCBefore()) {
            return false;
        }
        return true;
    };
    _Inflater.prototype._readingTCBefore = function () {
        while (this._loopCounter < this._caSize) {
            if (this._inflaterState === _InflaterState.readingTcBefore) {
                this._lengthCode = this._clTree._getNextSymbol(this._input);
                if (this._lengthCode < 0) {
                    return false;
                }
            }
            if (this._lengthCode <= 15) {
                this._codeList[this._loopCounter++] = _toUnsigned(this._lengthCode, 8);
            }
            else {
                if (!this._input._availableBits(7)) {
                    this._inflaterState = _InflaterState.readingTcAfter;
                    return false;
                }
                var repeatCount = void 0;
                if (this._lengthCode === 16) {
                    if (this._loopCounter === 0) {
                        throw new Error('Invalid data.');
                    }
                    var previousCode = _toUnsigned(this._codeList[this._loopCounter - 1], 8);
                    repeatCount = this._input._getBits(2) + 3;
                    if (this._loopCounter + repeatCount > this._caSize) {
                        throw new Error('Invalid data.');
                    }
                    for (var j = 0; j < repeatCount; j++) {
                        this._codeList[this._loopCounter++] = previousCode;
                    }
                }
                else if (this._lengthCode === 17) {
                    repeatCount = this._input._getBits(3) + 3;
                    if (this._loopCounter + repeatCount > this._caSize) {
                        throw new Error('Invalid data.');
                    }
                    for (var j = 0; j < repeatCount; j++) {
                        this._codeList[this._loopCounter++] = 0;
                    }
                }
                else {
                    repeatCount = this._input._getBits(7) + 11;
                    if (this._loopCounter + repeatCount > this._caSize) {
                        throw new Error('Invalid data.');
                    }
                    for (var j = 0; j < repeatCount; j++) {
                        this._codeList[this._loopCounter++] = 0;
                    }
                }
            }
            this._inflaterState = _InflaterState.readingTcBefore;
        }
        return true;
    };
    _Inflater.prototype._getBlockType = function (type) {
        if (type === _BlockType.unCompressedType) {
            return _BlockType.unCompressedType;
        }
        else if (type === _BlockType.staticType) {
            return _BlockType.staticType;
        }
        else {
            return _BlockType.dynamicType;
        }
    };
    _Inflater.prototype._getInflaterState = function (value) {
        switch (value) {
            case 0:
                return _InflaterState.readingHeader;
            case 2:
                return _InflaterState.readingBFinal;
            case 3:
                return _InflaterState.readingBType;
            case 4:
                return _InflaterState.readingNlCodes;
            case 5:
                return _InflaterState.readingNdCodes;
            case 6:
                return _InflaterState.readingCodes;
            case 7:
                return _InflaterState.readingClCodes;
            case 8:
                return _InflaterState.readingTcBefore;
            case 9:
                return _InflaterState.readingTcAfter;
            case 10:
                return _InflaterState.decodeTop;
            case 11:
                return _InflaterState.iLength;
            case 12:
                return _InflaterState.fLength;
            case 13:
                return _InflaterState.dCode;
            case 15:
                return _InflaterState.unCompressedAligning;
            case 16:
                return _InflaterState.unCompressedByte1;
            case 17:
                return _InflaterState.unCompressedByte2;
            case 18:
                return _InflaterState.unCompressedByte3;
            case 19:
                return _InflaterState.unCompressedByte4;
            case 20:
                return _InflaterState.decodeUnCompressedBytes;
            case 21:
                return _InflaterState.srFooter;
            case 22:
                return _InflaterState.rFooter;
            case 23:
                return _InflaterState.vFooter;
            case 24:
                return _InflaterState.done;
            default:
                return _InflaterState.readingHeader;
        }
    };
    _Inflater.prototype._getInflaterStateValue = function (state) {
        switch (state) {
            case _InflaterState.readingHeader:
                return 0;
            case _InflaterState.readingBFinal:
                return 2;
            case _InflaterState.readingBType:
                return 3;
            case _InflaterState.readingNlCodes:
                return 4;
            case _InflaterState.readingNdCodes:
                return 5;
            case _InflaterState.readingCodes:
                return 6;
            case _InflaterState.readingClCodes:
                return 7;
            case _InflaterState.readingTcBefore:
                return 8;
            case _InflaterState.readingTcAfter:
                return 9;
            case _InflaterState.decodeTop:
                return 10;
            case _InflaterState.iLength:
                return 11;
            case _InflaterState.fLength:
                return 12;
            case _InflaterState.dCode:
                return 13;
            case _InflaterState.unCompressedAligning:
                return 15;
            case _InflaterState.unCompressedByte1:
                return 16;
            case _InflaterState.unCompressedByte2:
                return 17;
            case _InflaterState.unCompressedByte3:
                return 18;
            case _InflaterState.unCompressedByte4:
                return 19;
            case _InflaterState.decodeUnCompressedBytes:
                return 20;
            case _InflaterState.srFooter:
                return 21;
            case _InflaterState.rFooter:
                return 22;
            case _InflaterState.vFooter:
                return 23;
            case _InflaterState.done:
                return 24;
            default:
                return 0;
        }
    };
    return _Inflater;
}());

var _DeflateStream = /** @class */ (function () {
    function _DeflateStream(data, offset, leaveOpen) {
        if (_isNullOrUndefined(data)) {
            this._data = data;
        }
        else {
            this._data = [];
        }
        if (_isNullOrUndefined(leaveOpen)) {
            this._leaveOpen = leaveOpen;
        }
        this._offset = offset;
        this._inflater = new _Inflater();
        this._buffer = Array(8192).fill(0);
    }
    _DeflateStream.prototype._read = function (array, offset, count) {
        var length;
        var cOffset = offset;
        var rCount = count;
        while (true) { // eslint-disable-line
            var inflateResult = this._inflater._inflate(array, cOffset, rCount);
            length = inflateResult.count;
            array = inflateResult.data;
            cOffset += length;
            rCount -= length;
            if (rCount === 0) {
                break;
            }
            if (this._inflater._finished) {
                break;
            }
            var result = this._readBytes();
            var bytes = result.count;
            this._buffer = result.buffer;
            if (bytes === 0) {
                break;
            }
            this._inflater._setInput(this._buffer, 0, bytes);
        }
        return { count: count - rCount, data: array };
    };
    _DeflateStream.prototype._readBytes = function () {
        if (_isNullOrUndefined(this._offset) && this._offset >= this._data.length) {
            return { buffer: [], count: 0 };
        }
        else {
            var count = 0;
            for (var i = 0; i < this._buffer.length && i + this._offset < this._data.length; i++) {
                this._buffer[Number.parseInt(i.toString(), 10)] = this._data[this._offset + i];
                count++;
            }
            this._offset += count;
            return { buffer: this._buffer, count: count };
        }
    };
    return _DeflateStream;
}());

var __extends$9 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* eslint-disable */
var _PngDecoder = /** @class */ (function (_super) {
    __extends$9(_PngDecoder, _super);
    /**
     * Initializes a new instance of the `_PngDecoder` class.
     *
     * @private
     * @param {Uint8Array} stream byte array.
     */
    function _PngDecoder(stream) {
        var _this = _super.call(this) || this;
        _this._stream = stream;
        _this._format = _ImageFormat.png;
        _this._isRedGreenBlue = false;
        _this._isDecode = false;
        _this._shades = false;
        _this._ideateDecode = true;
        _this._colors = 0;
        _this._bitsPerPixel = 0;
        _this._idatLength = 0;
        _this._inputBands = 0;
        _this._position = 8;
        _this._initialize();
        return _this;
    }
    _PngDecoder.prototype._initialize = function () {
        var header;
        var result = this._hasValidChunkType(header);
        while (result.hasValidChunk) {
            header = result.type;
            switch (header) {
                case _PngChunkTypes.iHDR:
                    this._readHeader();
                    break;
                case _PngChunkTypes.iDAT:
                    this._readImageData();
                    break;
                case _PngChunkTypes.sRGB:
                    this._isRedGreenBlue = true;
                    this._ignoreChunk();
                    break;
                case _PngChunkTypes.pLTE:
                    this._readPhotoPlate();
                    break;
                case _PngChunkTypes.iEND:
                    this._decodeImageData();
                    break;
                case _PngChunkTypes.tRNS:
                    this._readTransparency();
                    break;
                case _PngChunkTypes.tEXt:
                case _PngChunkTypes.iTXt:
                case _PngChunkTypes.zTXt:
                case _PngChunkTypes.hIST:
                case _PngChunkTypes.sBIT:
                case _PngChunkTypes.iCCP:
                case _PngChunkTypes.pHYs:
                case _PngChunkTypes.tIME:
                case _PngChunkTypes.bKGD:
                case _PngChunkTypes.gAMA:
                case _PngChunkTypes.cHRM:
                case _PngChunkTypes.unknown:
                    this._ignoreChunk();
                    break;
            }
            result = this._hasValidChunkType(header);
        }
    };
    _PngDecoder.prototype._hasValidChunkType = function (type) {
        type = _PngChunkTypes.unknown;
        if (this._position + 8 <= this._stream.byteLength) {
            this._currentChunkLength = this._readUnsigned32(this._position);
            this._seek(4);
            var chunk = this._readString(4);
            var header = this._getChunkType(chunk);
            if (typeof header !== 'undefined' && header !== null) {
                type = header;
                return { 'type': type, 'hasValidChunk': true };
            }
            if (this._stream.byteLength === this._position) {
                return { 'type': type, 'hasValidChunk': false };
            }
            else {
                return { 'type': type, 'hasValidChunk': true };
            }
        }
        else {
            return { 'type': type, 'hasValidChunk': false };
        }
    };
    _PngDecoder.prototype._ignoreChunk = function () {
        if (this._currentChunkLength > 0) {
            this._seek(this._currentChunkLength + 4);
        }
    };
    _PngDecoder.prototype._readHeader = function () {
        this._header = new _PngHeader();
        this._header._width = this._readUnsigned32(this._position);
        this._seek(4);
        this._header._height = this._readUnsigned32(this._position);
        this._seek(4);
        this._header._bitDepth = this._readByte();
        this._header._colorType = this._readByte();
        this._header._compression = this._readByte();
        this._header._filter = this._getFilterType(this._readByte());
        this._header._interlace = this._readByte();
        this._colors = (this._header._colorType === 3 || (this._header._colorType & 2) === 0) ? 1 : 3;
        this._width = this._header._width;
        this._height = this._header._height;
        this._bitsPerComponent = this._header._bitDepth;
        this._setBitsPerPixel();
        this._seek(4);
    };
    _PngDecoder.prototype._setBitsPerPixel = function () {
        this._bitsPerPixel = this._header._bitDepth === 16 ? 2 : 1;
        if (this._header._colorType === 0) {
            this._idatLength = Number.parseInt(((this._bitsPerComponent * this._width + 7) / 8).toString(), 10) * this._height;
            this._inputBands = 1;
        }
        else if (this._header._colorType === 2) {
            this._idatLength = this._width * this._height * 3;
            this._inputBands = 3;
            this._bitsPerPixel *= 3;
        }
        else if (this._header._colorType === 3) {
            if (this._header._interlace === 1 || this._header._interlace === 0) {
                this._idatLength = Number.parseInt(((this._header._bitDepth * this._width + 7) / 8).toString(), 10) * this._height;
            }
            this._inputBands = 1;
            this._bitsPerPixel = 1;
        }
        else if (this._header._colorType === 4) {
            this._idatLength = this._width * this._height;
            this._inputBands = 2;
            this._bitsPerPixel *= 2;
        }
        else if (this._header._colorType === 6) {
            this._idatLength = this._width * 3 * this._height;
            this._inputBands = 4;
            this._bitsPerPixel *= 4;
        }
    };
    _PngDecoder.prototype._readImageData = function () {
        if (!this._encodedStream || this._encodedStream.length === 0) {
            this._encodedStream = [];
        }
        if (this._currentChunkLength <= this._stream.byteLength && this._stream.byteLength - this._position >= this._currentChunkLength) {
            for (var i = 0; i < this._currentChunkLength; i++) {
                this._encodedStream.push(this._readByte());
            }
        }
        this._seek(4);
    };
    _PngDecoder.prototype._readPhotoPlate = function () {
        if (this._header._colorType === 3) {
            this._colorSpace = [];
            this._colorSpace.push(_PdfName.get('Indexed'));
            this._colorSpace.push(this._getPngColorSpace());
            this._colorSpace.push(this._currentChunkLength / 3 - 1);
            var buffer = new Uint8Array(this._currentChunkLength);
            this._read(buffer, 0, this._currentChunkLength);
            this._colorSpace.push(_bytesToString(buffer));
            this._seek(4);
        }
        else {
            this._ignoreChunk();
        }
    };
    _PngDecoder.prototype._readTransparency = function () {
        if (this._header._colorType === 3) {
            var alpha = new Uint8Array(this._currentChunkLength);
            this._read(alpha, 0, this._currentChunkLength);
            this._seek(4);
            this._alpha = [];
            for (var i = 0; i < alpha.length; i++) {
                this._alpha.push(alpha[Number.parseInt(i.toString(), 10)]);
                var sh = alpha[Number.parseInt(i.toString(), 10)] & 0xff;
                if (sh !== 0 && sh !== 255) {
                    this._shades = true;
                }
            }
        }
        else {
            this._ignoreChunk();
        }
    };
    _PngDecoder.prototype._getPngColorSpace = function () {
        if (!this._isRedGreenBlue) {
            if ((this._header._colorType & 2) === 0) {
                return _PdfName.get('DeviceGray');
            }
            else {
                return _PdfName.get('DeviceRGB');
            }
        }
        else {
            var colorspace = [];
            var calRGB = new _PdfDictionary();
            var whitePoint = [1, 1, 1];
            var gammaArray = [2.2, 2.2, 2.2];
            calRGB.set('Gamma', gammaArray);
            if (this._isRedGreenBlue) {
                var wpX = 0.3127;
                var wpY = 0.329;
                var redX = 0.64;
                var redY = 0.33;
                var greenX = 0.3;
                var greenY = 0.6;
                var bX = 0.15;
                var bY = 0.06;
                var t = wpY * ((greenX - bX) * redY - (redX - bX) * greenY + (redX - greenX) * bY);
                var alphaY = redY * ((greenX - bX) * wpY - (wpX - bX) * greenY + (wpX - greenX) * bY) / t;
                var alphaX = alphaY * redX / redY;
                var alphaZ = alphaY * ((1 - redX) / redY - 1);
                var blueY = -greenY * ((redX - bX) * wpY - (wpX - bX) * redY + (wpX - redX) * bY) / t;
                var blueX = blueY * greenX / greenY;
                var blueZ = blueY * ((1 - greenX) / greenY - 1);
                var colorY = bY * ((redX - greenX) * wpY - (wpX - greenX) * wpY + (wpX - redX) * greenY) / t;
                var colorX = colorY * bX / bY;
                var colorZ = colorY * ((1 - bX) / bY - 1);
                var whiteX = alphaX + blueX + colorX;
                var whiteY = 1;
                var whiteZ = alphaZ + blueZ + colorZ;
                whitePoint = [whiteX, whiteY, whiteZ];
                calRGB.set('Matrix', [alphaX, alphaY, alphaZ, blueX, blueY, blueZ, colorX, colorY, colorZ]);
            }
            calRGB.set('WhitePoint', whitePoint);
            colorspace.push(_PdfName.get('CalRGB'));
            colorspace.push(calRGB);
            return colorspace;
        }
    };
    _PngDecoder.prototype._decodeImageData = function () {
        var header = this._header;
        this._isDecode = (header._interlace === 1) || (header._bitDepth === 16) || ((header._colorType & 4) !== 0) || this._shades;
        if (this._isDecode) {
            if ((header._colorType & 4) !== 0 || this._shades) {
                this._maskData = Array(this._width * this._height).fill(0);
            }
            if (this._encodedStream) {
                this._dataStream = this._getDeflatedData(this._encodedStream);
                this._dataStreamOffset = 0;
            }
            if (this._idatLength > 0) {
                this._decodedImageData = Array(this._idatLength).fill(0);
            }
            this._readDecodeData();
            if (this._decodedImageData && this._decodedImageData.length === 0 && this._shades) {
                this._ideateDecode = false;
                this._decodedImageData = this._encodedStream;
            }
        }
        else {
            this._ideateDecode = false;
            this._decodedImageData = this._encodedStream;
        }
    };
    _PngDecoder.prototype._getDeflatedData = function (data) {
        var idatData = data.slice(2, data.length - 4);
        var deflateStream = new _DeflateStream(idatData, 0, true);
        var buffer = Array(4096).fill(0);
        var numRead = 0;
        var outputData = [];
        do {
            var result = deflateStream._read(buffer, 0, buffer.length);
            numRead = result.count;
            buffer = result.data;
            for (var i = 0; i < numRead; i++) {
                outputData.push(buffer[Number.parseInt(i.toString(), 10)]);
            }
        } while (numRead > 0);
        return outputData;
    };
    _PngDecoder.prototype._readDecodeData = function () {
        if (this._header._interlace !== 1) {
            this._decodeData(0, 0, 1, 1, this._width, this._height);
        }
        else {
            this._decodeData(0, 0, 8, 8, Math.floor((this._width + 7) / 8), Math.floor((this._height + 7) / 8));
            this._decodeData(4, 0, 8, 8, Math.floor((this._width + 3) / 8), Math.floor((this._height + 7) / 8));
            this._decodeData(0, 4, 4, 8, Math.floor((this._width + 3) / 4), Math.floor((this._height + 3) / 8));
            this._decodeData(2, 0, 4, 4, Math.floor((this._width + 1) / 4), Math.floor((this._height + 3) / 4));
            this._decodeData(0, 2, 2, 4, Math.floor((this._width + 1) / 2), Math.floor((this._height + 1) / 4));
            this._decodeData(1, 0, 2, 2, Math.floor(this._width / 2), Math.floor((this._height + 1) / 2));
            this._decodeData(0, 1, 1, 2, this._width, Math.floor(this._height / 2));
        }
    };
    _PngDecoder.prototype._decodeData = function (xOffset, yOffset, xStep, yStep, width, height) {
        if ((width === 0) || (height === 0)) {
            return;
        }
        else {
            var bytesPerRow = Math.floor((this._inputBands * width * this._header._bitDepth + 7) / 8);
            var current = Array(bytesPerRow).fill(0);
            var prior = Array(bytesPerRow).fill(0);
            for (var sourceY = 0, destinationY = yOffset; sourceY < height; sourceY++, destinationY += yStep) {
                var filter = this._dataStream[this._dataStreamOffset];
                this._dataStreamOffset = this._dataStreamOffset + 1;
                this._dataStreamOffset = this._readStream(this._dataStream, this._dataStreamOffset, current, bytesPerRow);
                switch (this._getFilterType(filter)) {
                    case _PngFilterTypes.none:
                        break;
                    case _PngFilterTypes.sub:
                        this._decompressSub(current, bytesPerRow, this._bitsPerPixel);
                        break;
                    case _PngFilterTypes.up:
                        this._decompressUp(current, prior, bytesPerRow);
                        break;
                    case _PngFilterTypes.average:
                        this._decompressAverage(current, prior, bytesPerRow, this._bitsPerPixel);
                        break;
                    case _PngFilterTypes.paeth:
                        this._decompressPaeth(current, prior, bytesPerRow, this._bitsPerPixel);
                        break;
                    default:
                        throw new Error('Unknown PNG filter');
                }
                this._processPixels(current, xOffset, xStep, destinationY, width);
                var tmp = prior;
                prior = current;
                current = tmp;
            }
        }
    };
    _PngDecoder.prototype._readStream = function (stream, streamOffset, data, count) {
        var result = this._read(data, streamOffset, count, stream);
        data = result.outputBuffer;
        streamOffset = result.offset;
        var n = result.length;
        if (n <= 0) {
            throw new Error('Insufficient data');
        }
        return streamOffset;
    };
    _PngDecoder.prototype._decompressSub = function (data, count, bitsPerPixel) {
        for (var i = bitsPerPixel; i < count; i++) {
            data[Number.parseInt(i.toString(), 10)] = _toUnsigned((data[Number.parseInt(i.toString(), 10)] & 0xff)
                + (data[i - bitsPerPixel] & 0xff), 8);
        }
    };
    _PngDecoder.prototype._decompressUp = function (data, pData, count) {
        for (var i = 0; i < count; i++) {
            data[Number.parseInt(i.toString(), 10)] = _toUnsigned((data[Number.parseInt(i.toString(), 10)] & 0xff)
                + (pData[Number.parseInt(i.toString(), 10)] & 0xff), 8);
        }
    };
    _PngDecoder.prototype._decompressAverage = function (data, pData, count, bitsPerPixel) {
        var val;
        var pp;
        var pr;
        for (var i = 0; i < bitsPerPixel; i++) {
            val = data[Number.parseInt(i.toString(), 10)] & 0xff;
            pr = pData[Number.parseInt(i.toString(), 10)] & 0xff;
            data[Number.parseInt(i.toString(), 10)] = _toUnsigned(Math.floor((val) + pr / 2), 8);
        }
        for (var i = bitsPerPixel; i < count; i++) {
            val = data[Number.parseInt(i.toString(), 10)] & 0xff;
            pp = data[i - bitsPerPixel] & 0xff;
            pr = pData[Number.parseInt(i.toString(), 10)] & 0xff;
            data[Number.parseInt(i.toString(), 10)] = _toUnsigned(Math.floor((val + Math.floor((pp + pr) / 2))), 8);
        }
    };
    _PngDecoder.prototype._decompressPaeth = function (data, pData, count, bitsPerPixel) {
        var val;
        var pp;
        var pr;
        var prp;
        for (var i = 0; i < bitsPerPixel; i++) {
            val = data[Number.parseInt(i.toString(), 10)] & 0xff;
            pr = pData[Number.parseInt(i.toString(), 10)] & 0xff;
            data[Number.parseInt(i.toString(), 10)] = _toUnsigned(val + pr, 8);
        }
        for (var i = bitsPerPixel; i < count; i++) {
            val = data[Number.parseInt(i.toString(), 10)] & 0xff;
            pp = data[i - bitsPerPixel] & 0xff;
            pr = pData[Number.parseInt(i.toString(), 10)] & 0xff;
            prp = pData[i - bitsPerPixel] & 0xff;
            data[Number.parseInt(i.toString(), 10)] = _toUnsigned((val + this._paethPredictor(pp, pr, prp)), 8);
        }
    };
    _PngDecoder.prototype._paethPredictor = function (a, b, c) {
        var p = a + b - c;
        var pa = Math.abs(p - a);
        var pb = Math.abs(p - b);
        var pc = Math.abs(p - c);
        if ((pa <= pb) && (pa <= pc)) {
            return a;
        }
        else if (pb <= pc) {
            return b;
        }
        else {
            return c;
        }
    };
    _PngDecoder.prototype._processPixels = function (data, x, step, y, width) {
        var sourceX = 0;
        var destX = 0;
        var size = 0;
        var pixel = this._getPixel(data);
        if (this._header._colorType === 0 || this._header._colorType === 3 || this._header._colorType === 4) {
            size = 1;
        }
        else if (this._header._colorType === 2 || this._header._colorType === 6) {
            size = 3;
        }
        if (this._decodedImageData && this._decodedImageData.length > 0) {
            destX = x;
            var depth = (this._header._bitDepth === 16) ? 8 : this._header._bitDepth;
            var yStep = Math.floor((size * width * depth + 7) / 8);
            for (sourceX = 0; sourceX < width; sourceX++) {
                this._decodedImageData = this._setPixel(this._decodedImageData, pixel, this._inputBands * sourceX, size, destX, y, this._header._bitDepth, yStep);
                destX += step;
            }
        }
        var shades = (this._header._colorType & 4) !== 0 || this._shades;
        if (shades) {
            if ((this._header._colorType & 4) !== 0) {
                if (this._header._bitDepth === 16) {
                    for (var i = 0; i < width; ++i) {
                        var temp = i * this._inputBands + size;
                        var unsigned = _toUnsigned(pixel[Number.parseInt(temp.toString(), 10)], 32);
                        pixel[Number.parseInt(temp.toString(), 10)] = _toSigned32(unsigned >> 8);
                    }
                }
                var yStep = width;
                destX = x;
                for (sourceX = 0; sourceX < width; sourceX++) {
                    this._maskData = this._setPixel(this._maskData, pixel, this._inputBands * sourceX + size, 1, destX, y, 8, yStep);
                    destX += step;
                }
            }
            else {
                var yStep = width;
                var dt = [0];
                destX = x;
                for (sourceX = 0; sourceX < width; sourceX++) {
                    var index = pixel[Number.parseInt(sourceX.toString(), 10)];
                    if (index < this._alpha.length) {
                        dt[0] = this._alpha[Number.parseInt(index.toString(), 10)];
                    }
                    else {
                        dt[0] = 255;
                    }
                    this._maskData = this._setPixel(this._maskData, dt, 0, 1, destX, y, 8, yStep);
                    destX += step;
                }
            }
        }
    };
    _PngDecoder.prototype._getPixel = function (data) {
        if (this._header._bitDepth === 8) {
            var pixel = Array(data.length).fill(0);
            for (var i = 0; i < pixel.length; ++i) {
                pixel[Number.parseInt(i.toString(), 10)] = data[Number.parseInt(i.toString(), 10)] & 0xff;
            }
            return pixel;
        }
        else if (this._header._bitDepth === 16) {
            var pixel = Array(Math.floor(data.length / 2)).fill(0);
            for (var i = 0; i < pixel.length; ++i) {
                pixel[Number.parseInt(i.toString(), 10)] = ((data[i * 2] & 0xff) << 8) + (data[i * 2 + 1] & 0xff);
            }
            return pixel;
        }
        else {
            var pixel = Array(Math.floor((data.length * 8) / this._header._bitDepth)).fill(0);
            var index = 0;
            var p = Math.floor(8 / this._header._bitDepth);
            var mask = (1 << this._header._bitDepth) - 1;
            for (var n = 0; n < data.length; ++n) {
                for (var i = p - 1; i >= 0; --i) {
                    var hb = this._header._bitDepth * i;
                    var d = data[Number.parseInt(n.toString(), 10)];
                    pixel[index++] = ((hb < 1) ? d : _toSigned32(_toUnsigned(d, 32) >> hb)) & mask;
                }
            }
            return pixel;
        }
    };
    _PngDecoder.prototype._setPixel = function (imageData, data, offset, size, x, y, bitDepth, bpr) {
        if (bitDepth === 8) {
            var position = bpr * y + size * x;
            for (var i = 0; i < size; ++i) {
                imageData[position + i] = _toUnsigned(data[i + offset], 8);
            }
        }
        else if (bitDepth === 16) {
            var position = bpr * y + size * x;
            for (var i = 0; i < size; ++i) {
                imageData[position + i] = _toUnsigned((data[i + offset] >> 8), 8);
            }
        }
        else {
            var position = Math.floor((bpr * y + x) / (8 / bitDepth));
            var t = data[Number.parseInt(offset.toString(), 10)]
                << Number.parseInt((8 - bitDepth * (x % (8 / bitDepth)) - bitDepth).toString(), 10);
            imageData[Number.parseInt(position.toString(), 10)] = imageData[Number.parseInt(position.toString(), 10)] | _toUnsigned(t, 8);
        }
        return imageData;
    };
    _PngDecoder.prototype._getImageDictionary = function () {
        var data = [];
        this._imageStream = new _PdfStream(data, new _PdfDictionary());
        this._imageStream.isImageStream = true;
        var decodedString = '';
        for (var i = 0; i < this._decodedImageData.length; i++) {
            decodedString += String.fromCharCode(this._decodedImageData[Number.parseInt(i.toString(), 10)]);
        }
        this._imageStream.data = [decodedString];
        this._imageStream._isCompress = this._isDecode && this._ideateDecode;
        var dictionary = new _PdfDictionary();
        dictionary.set('Type', new _PdfName('XObject'));
        dictionary.set('Subtype', new _PdfName('Image'));
        dictionary.set('Width', this._width);
        dictionary.set('Height', this._height);
        if (this._bitsPerComponent === 16) {
            dictionary.set('BitsPerComponent', 8);
        }
        else {
            dictionary.set('BitsPerComponent', this._bitsPerComponent);
        }
        if (!this._isDecode || !this._ideateDecode) {
            dictionary.set('Filter', new _PdfName('FlateDecode'));
        }
        if ((this._header._colorType & 2) === 0) {
            dictionary.set('ColorSpace', _PdfName.get('DeviceGray'));
        }
        else {
            dictionary.set('ColorSpace', _PdfName.get('DeviceRGB'));
        }
        if (!this._isDecode || this._shades && !this._ideateDecode) {
            dictionary.set('DecodeParms', this._getDecodeParams());
        }
        this._imageStream.dictionary = dictionary;
        this._imageStream.bytes = new Uint8Array(this._imageStream.data[0].length);
        for (var i = 0; i < this._imageStream.data[0].length; i++) {
            this._imageStream.bytes[Number.parseInt(i.toString(), 10)] = this._imageStream.data[0].charCodeAt(i);
        }
        this._imageStream.end = this._imageStream.bytes.length;
        this._imageStream.dictionary._updated = true;
        this._setMask();
        return this._imageStream;
    };
    _PngDecoder.prototype._setMask = function () {
        if (this._maskData && this._maskData.length > 0) {
            this._maskStream = new _PdfStream(this._maskData, new _PdfDictionary());
            this._maskStream._isCompress = this._isDecode && this._ideateDecode;
            var dictionary = new _PdfDictionary();
            dictionary.set('Type', new _PdfName('XObject'));
            dictionary.set('Subtype', new _PdfName('Image'));
            dictionary.set('Width', this._width);
            dictionary.set('Height', this._height);
            if (this._bitsPerComponent === 16) {
                dictionary.set('BitsPerComponent', 8);
            }
            else {
                dictionary.set('BitsPerComponent', this._bitsPerComponent);
            }
            dictionary.set('ColorSpace', _PdfName.get('DeviceGray'));
            this._maskStream.dictionary = dictionary;
            this._maskStream.bytes = new Uint8Array(this._maskData);
            this._maskStream.end = this._maskStream.bytes.length;
            this._maskStream.dictionary._updated = true;
        }
    };
    _PngDecoder.prototype._getDecodeParams = function () {
        var decodeParams = new _PdfDictionary();
        decodeParams.set('Columns', this._width);
        decodeParams.set('Colors', this._colors);
        decodeParams.set('Predictor', 15);
        decodeParams.set('BitsPerComponent', this._bitsPerComponent);
        return decodeParams;
    };
    _PngDecoder.prototype._getChunkType = function (chunk) {
        switch (chunk) {
            case 'IHDR':
                return _PngChunkTypes.iHDR;
            case 'PLTE':
                return _PngChunkTypes.pLTE;
            case 'IDAT':
                return _PngChunkTypes.iDAT;
            case 'IEND':
                return _PngChunkTypes.iEND;
            case 'bKGD':
                return _PngChunkTypes.bKGD;
            case 'cHRM':
                return _PngChunkTypes.cHRM;
            case 'gAMA':
                return _PngChunkTypes.gAMA;
            case 'hIST':
                return _PngChunkTypes.hIST;
            case 'pHYs':
                return _PngChunkTypes.pHYs;
            case 'sBIT':
                return _PngChunkTypes.sBIT;
            case 'tEXt':
                return _PngChunkTypes.tEXt;
            case 'tIME':
                return _PngChunkTypes.tIME;
            case 'tRNS':
                return _PngChunkTypes.tRNS;
            case 'zTXt':
                return _PngChunkTypes.zTXt;
            case 'sRGB':
                return _PngChunkTypes.sRGB;
            case 'iCCP':
                return _PngChunkTypes.iCCP;
            case 'iTXt':
                return _PngChunkTypes.iTXt;
            case 'Unknown':
                return _PngChunkTypes.unknown;
            default:
                return null;
        }
    };
    _PngDecoder.prototype._getFilterType = function (type) {
        switch (type) {
            case 1:
                return _PngFilterTypes.sub;
            case 2:
                return _PngFilterTypes.up;
            case 3:
                return _PngFilterTypes.average;
            case 4:
                return _PngFilterTypes.paeth;
            default:
                return _PngFilterTypes.none;
        }
    };
    return _PngDecoder;
}(_ImageDecoder));
var _PngHeader = /** @class */ (function () {
    function _PngHeader() {
        this._width = 0;
        this._height = 0;
        this._colorType = 0;
        this._compression = 0;
        this._bitDepth = 0;
        this._interlace = 0;
        this._filter = _PngFilterTypes.none;
    }
    return _PngHeader;
}());
var _PngChunkTypes;
(function (_PngChunkTypes) {
    _PngChunkTypes[_PngChunkTypes["iHDR"] = 0] = "iHDR";
    _PngChunkTypes[_PngChunkTypes["pLTE"] = 1] = "pLTE";
    _PngChunkTypes[_PngChunkTypes["iDAT"] = 2] = "iDAT";
    _PngChunkTypes[_PngChunkTypes["iEND"] = 3] = "iEND";
    _PngChunkTypes[_PngChunkTypes["bKGD"] = 4] = "bKGD";
    _PngChunkTypes[_PngChunkTypes["cHRM"] = 5] = "cHRM";
    _PngChunkTypes[_PngChunkTypes["gAMA"] = 6] = "gAMA";
    _PngChunkTypes[_PngChunkTypes["hIST"] = 7] = "hIST";
    _PngChunkTypes[_PngChunkTypes["pHYs"] = 8] = "pHYs";
    _PngChunkTypes[_PngChunkTypes["sBIT"] = 9] = "sBIT";
    _PngChunkTypes[_PngChunkTypes["tEXt"] = 10] = "tEXt";
    _PngChunkTypes[_PngChunkTypes["tIME"] = 11] = "tIME";
    _PngChunkTypes[_PngChunkTypes["tRNS"] = 12] = "tRNS";
    _PngChunkTypes[_PngChunkTypes["zTXt"] = 13] = "zTXt";
    _PngChunkTypes[_PngChunkTypes["sRGB"] = 14] = "sRGB";
    _PngChunkTypes[_PngChunkTypes["iCCP"] = 15] = "iCCP";
    _PngChunkTypes[_PngChunkTypes["iTXt"] = 16] = "iTXt";
    _PngChunkTypes[_PngChunkTypes["unknown"] = 17] = "unknown";
})(_PngChunkTypes || (_PngChunkTypes = {}));
var _PngFilterTypes;
(function (_PngFilterTypes) {
    _PngFilterTypes[_PngFilterTypes["none"] = 0] = "none";
    _PngFilterTypes[_PngFilterTypes["sub"] = 1] = "sub";
    _PngFilterTypes[_PngFilterTypes["up"] = 2] = "up";
    _PngFilterTypes[_PngFilterTypes["average"] = 3] = "average";
    _PngFilterTypes[_PngFilterTypes["paeth"] = 4] = "paeth";
})(_PngFilterTypes || (_PngFilterTypes = {}));

var __extends$a = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Gets the unsigned value.
 *
 * @param {number} value input value.
 * @param {number} bits bits to process.
 * @returns {number} unsigned value.
 */
function _toUnsigned(value, bits) {
    return (value & ((Math.pow(2, bits)) - 1));
}
/**
 * Gets the signed 16 bit value.
 *
 * @param {number} value input value.
 * @returns {number} unsigned value.
 */
function _toSigned16(value) {
    return (value << 16) >> 16;
}
/**
 * Gets the signed 32 bit value.
 *
 * @param {number} value input value.
 * @returns {number} unsigned value.
 */
function _toSigned32(value) {
    return (value << 0);
}
/**
 * Copy values from one array to another.
 *
 * @param {number[]} target destination array.
 * @param {number} at target index.
 * @param {number[]} source source array.
 * @param {number} start start index.
 * @param {number} end end index.
 * @returns {void} Returns nothing.
 */
function _copyRange(target, at, source, start, end) {
    if (start === null || typeof start === 'undefined') {
        start = 0;
    }
    end = (typeof end === 'undefined') ? source.length : end;
    start = Math.max(0, Math.min(source.length, start));
    end = Math.max(0, Math.min(source.length, end));
    if (at + (end - start) > target.length) {
        target.length = at + (end - start);
    }
    for (var i = start, j = at; i < end; i++, j++) {
        target[Number.parseInt(j.toString(), 10)] = source[Number.parseInt(i.toString(), 10)];
    }
}
/**
 * Checks the type of the image using header bytes.
 *
 * @param {Uint8Array} imageData image data.
 * @param {number[]} header header bytes.
 * @returns {boolean} Header matched or not.
 */
function _checkType(imageData, header) {
    for (var i = 0; i < header.length; i++) {
        if (header[Number.parseInt(i.toString(), 10)] !== imageData[Number.parseInt(i.toString(), 10)]) {
            return false;
        }
    }
    return true;
}
/**
 * Gets the image decoder.
 *
 * @param {Uint8Array} imageData image data.
 * @returns {_ImageDecoder} Image decoder.
 */
function _getDecoder(imageData) {
    var decoder;
    if (_checkType(imageData, [255, 216])) {
        decoder = new _JpegDecoder(imageData);
    }
    else if (_checkType(imageData, [137, 80, 78, 71, 13, 10, 26, 10])) {
        decoder = new _PngDecoder(imageData);
    }
    else {
        throw new Error('Unsupported image format');
    }
    return decoder;
}
/**
 * Gets the page rotation.
 *
 * @param {PdfPage} page Page.
 * @param {number} height Height.
 * @param {number} left Left.
 * @returns {number} Page rotation.
 */
function _checkRotation(page, height, left) {
    var topValue = 0;
    left = (typeof left === 'undefined' || left === null) ? 0 : left;
    if (page.rotation === PdfRotationAngle.angle90) {
        topValue = (typeof height === 'undefined' || height === null) ? 0 : left;
    }
    else if (page.rotation === PdfRotationAngle.angle180) {
        topValue = (typeof height === 'undefined' || height === null) ? 0 : height;
    }
    else if (page.rotation === PdfRotationAngle.angle270) {
        var size = page.size;
        topValue = (typeof height === 'undefined' || height === null) ? 0 : size[0] - left;
    }
    return topValue;
}
/**
 * Gets the page index.
 *
 * @param {PdfDocument} loadedDocument Loaded document.
 * @param {_PdfDictionary} pageDictionary Page dictionary.
 * @returns {number} Page index.
 */
function _getPageIndex(loadedDocument, pageDictionary) {
    var index = -1;
    for (var i = 0; i < loadedDocument.pageCount; i++) {
        var page = loadedDocument.getPage(i);
        if (page._pageDictionary === pageDictionary) {
            index = i;
            break;
        }
    }
    return index;
}
/**
 * Convert string value from annotation flag
 *
 * @private
 * @param {PdfAnnotationFlag} flag Annotation flag.
 * @returns {string} Valid string to write into XML.
 */
function _annotationFlagsToString(flag) {
    var values = [];
    if ((flag & PdfAnnotationFlag.hidden) !== 0) {
        values.push('hidden');
    }
    if ((flag & PdfAnnotationFlag.invisible) !== 0) {
        values.push('invisible');
    }
    if ((flag & PdfAnnotationFlag.locked) !== 0) {
        values.push('locked');
    }
    if ((flag & PdfAnnotationFlag.noRotate) !== 0) {
        values.push('norotate');
    }
    if ((flag & PdfAnnotationFlag.noView) !== 0) {
        values.push('noview');
    }
    if ((flag & PdfAnnotationFlag.noZoom) !== 0) {
        values.push('nozoom');
    }
    if ((flag & PdfAnnotationFlag.print) !== 0) {
        values.push('print');
    }
    if ((flag & PdfAnnotationFlag.readOnly) !== 0) {
        values.push('readonly');
    }
    if ((flag & PdfAnnotationFlag.toggleNoView) !== 0) {
        values.push('togglenoview');
    }
    if ((flag & PdfAnnotationFlag.default) !== 0) {
        values.push('default');
    }
    return values.join(',');
}
/**
 * Convert string value to annotation flag
 *
 * @private
 * @param {string} flag String value to map
 * @returns {PdfAnnotationFlag} Annotation flag
 */
function _stringToAnnotationFlags(flag) {
    switch (flag) {
        case 'hidden':
            return PdfAnnotationFlag.hidden;
        case 'invisible':
            return PdfAnnotationFlag.invisible;
        case 'locked':
            return PdfAnnotationFlag.locked;
        case 'norotate':
            return PdfAnnotationFlag.noRotate;
        case 'noview':
            return PdfAnnotationFlag.noView;
        case 'nozoom':
            return PdfAnnotationFlag.noZoom;
        case 'print':
            return PdfAnnotationFlag.print;
        case 'readonly':
            return PdfAnnotationFlag.readOnly;
        case 'togglenoview':
            return PdfAnnotationFlag.toggleNoView;
        default:
            return PdfAnnotationFlag.default;
    }
}
/**
 * Convert string value to byte array
 *
 * @private
 * @param {string} value string value.
 * @returns {string} Valid string to write into PDF.
 */
function _stringToPdfString(value) {
    if (typeof value === 'string' && value.length > 0 && value.charCodeAt(0) >= '\xEF'.charCodeAt(0)) {
        var encoding = void 0;
        if (value[0] === '\xEF' && value[1] === '\xBB' && value[2] === '\xBF') {
            encoding = 'utf-8';
        }
        else if (value[0] === '\xFF' && value[1] === '\xFE') {
            encoding = 'utf-16le';
        }
        else if (value[0] === '\xFE' && value[1] === '\xFF') {
            encoding = 'utf-16be';
        }
        if (encoding) {
            try {
                return (new TextDecoder(encoding, { fatal: true })).decode(_stringToBytes(value));
            }
            catch (e) { } // eslint-disable-line
        }
    }
    var buffer = [];
    var translateTable = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8,
        0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192,
        0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018,
        0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d,
        0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac
    ];
    for (var i = 0; i < value.length; i++) {
        var code = translateTable[value.charCodeAt(i)];
        buffer.push(code ? String.fromCharCode(code) : value.charAt(i));
    }
    return buffer.join('');
}
/**
 * Convert string value to byte array
 *
 * @private
 * @param {string} value string value.
 * @param {boolean} isDirect Whether to return a number[] or Uint8Array.
 * @param {boolean} isPassword Whether the string is a password.
 * @param {number[]} destination Destination array.
 * @returns {number[] | Uint8Array} Byte array
 */
function _stringToBytes(value, isDirect, isPassword, destination) {
    if (isDirect === void 0) { isDirect = false; }
    if (isPassword === void 0) { isPassword = false; }
    var bytes = [];
    if (destination) {
        bytes = destination;
    }
    if (isPassword) {
        for (var i = 0; i < value.length; i++) {
            bytes.push(value.charCodeAt(i));
        }
    }
    else {
        for (var i = 0; i < value.length; i++) {
            var charCode = value.charCodeAt(i);
            if (charCode < 0x80) {
                bytes.push(charCode);
            }
            else if (charCode < 0x800) {
                bytes.push((charCode >> 6) | 0xC0);
                bytes.push((charCode & 0x3F) | 0x80);
            }
            else if (charCode < 0xD800 || charCode >= 0xE000) {
                bytes.push((charCode >> 12) | 0xE0);
                bytes.push(((charCode >> 6) & 0x3F) | 0x80);
                bytes.push((charCode & 0x3F) | 0x80);
            }
            else {
                i++;
                charCode = 0x10000 + (((charCode & 0x3FF) << 10) | (value.charCodeAt(i) & 0x3FF));
                bytes.push((charCode >> 18) | 0xF0);
                bytes.push(((charCode >> 12) & 0x3F) | 0x80);
                bytes.push(((charCode >> 6) & 0x3F) | 0x80);
                bytes.push((charCode & 0x3F) | 0x80);
            }
        }
    }
    return isDirect ? bytes : new Uint8Array(bytes);
}
/**
 * Check equal or not.
 *
 * @private
 * @param {number[]} first byte array.
 * @param {number[]} second byte array.
 * @returns {boolean} Equal or not
 */
function _areArrayEqual(first, second) {
    if (first.length !== second.length) {
        return false;
    }
    for (var i = 0; i < first.length; i++) {
        if (first[Number.parseInt(i.toString(), 10)] !== second[Number.parseInt(i.toString(), 10)]) {
            return false;
        }
    }
    return true;
}
/**
 * Convert number to string as round value with fixed decimal points 2.
 *
 * @private
 * @param {number[]} value number value.
 * @returns {boolean} Equal string.
 */
function _numberToString(value) {
    if (Number.isInteger(value)) {
        return value.toString();
    }
    return value.toFixed(7);
}
/**
 * Check whether entries in two array are equal or not.
 *
 * @private
 * @param {number[]} value first array.
 * @param {number[]} current second array.
 * @returns {boolean} Return true if for each elements are equal in both array.
 */
function _areNotEqual(value, current) {
    var result = false;
    if (value.length !== current.length) {
        return true;
    }
    for (var i = 0; i < value.length; i++) {
        if (value[i] !== current[i]) { // eslint-disable-line
            result = true;
            break;
        }
    }
    return result;
}
/**
 * Process bytes and convert as string.
 *
 * @private
 * @param {Uint8Array} bytes Input data.
 * @param {boolean} isJson Whether is json or xfdf.
 * @returns {string} String value processed from input bytes.
 */
function _bytesToString(bytes, isJson) {
    if (isJson === void 0) { isJson = false; }
    var length = bytes.length;
    var max = 8192;
    var stringBuffer = [];
    if (length < max) {
        return (isJson ? _decodeUnicodeBytes(bytes) : String.fromCharCode.apply(null, bytes));
    }
    for (var i = 0; i < length; i += max) {
        var chunkEnd = Math.min(i + max, length);
        var chunk = bytes.subarray(i, chunkEnd);
        stringBuffer.push(isJson ? _decodeUnicodeBytes(chunk) : String.fromCharCode.apply(null, chunk));
    }
    return stringBuffer.join('');
}
/**
 * Decode unicode string.
 *
 * @private
 * @param {Uint8Array} bytes Input data.
 * @returns {string} String value processed from input bytes.
 */
function _decodeUnicodeBytes(bytes) {
    var result = '';
    var i = 0;
    while (i < bytes.length) {
        var byte = bytes[i++];
        if (byte < 0x80) {
            result += String.fromCharCode(byte);
        }
        else if (byte < 0xE0) {
            result += String.fromCharCode(((byte & 0x1F) << 6) | (bytes[i++] & 0x3F));
        }
        else if (byte < 0xF0) {
            result += String.fromCharCode(((byte & 0x0F) << 12) | ((bytes[i++] & 0x3F) << 6) | (bytes[i++] & 0x3F));
        }
        else {
            var codePoint = ((byte & 0x07) << 18) | ((bytes[i++] & 0x3F) << 12) |
                ((bytes[i++] & 0x3F) << 6) | (bytes[i++] & 0x3F) - 0x10000;
            result += String.fromCharCode((codePoint >> 10) + 0xD800, (codePoint & 0x03FF) + 0xDC00);
        }
    }
    return result;
}
/**
 * Convert string to unicode array.
 *
 * @private
 * @param {string} value string value.
 * @returns {Uint8Array} unicode array
 */
function _stringToUnicodeArray(value) {
    var output = [];
    if (value !== null && typeof value !== 'undefined') {
        for (var i = 0; i < value.length; i++) {
            var code = value.charCodeAt(i);
            output.push(code / 256 >>> 0);
            output.push(code & 0xff);
        }
    }
    var unicodeArray = new Uint8Array(output);
    return unicodeArray;
}
/**
 * Convert byte array to hex string.
 *
 * @private
 * @param {Uint8Array} byteArray Byte array.
 * @returns {string} Hex string.
 */
function _byteArrayToHexString(byteArray) {
    var nextHexByte;
    var stringBuffer = [];
    for (var i = 0; i < byteArray.length; i++) {
        nextHexByte = byteArray[Number.parseInt(i.toString(), 10)].toString(16).toUpperCase();
        if (nextHexByte.length < 2) {
            nextHexByte = '0' + nextHexByte;
        }
        stringBuffer.push(nextHexByte);
    }
    return stringBuffer.join('');
}
/**
 * Convert hex string to byte array.
 *
 * @private
 * @param {string} hexString Hex string.
 * @param {boolean} isDirect Whether to return object or number[]. Default is false.
 * @returns {Uint8Array | number[]} Byte array.
 */
function _hexStringToByteArray(hexString, isDirect) {
    if (isDirect === void 0) { isDirect = false; }
    var array = [];
    if (hexString) {
        for (var i = 0; i < hexString.length; i += 2) {
            array.push(Number.parseInt(hexString.substring(i, i + 2), 16));
        }
    }
    return isDirect ? array : new Uint8Array(array);
}
/**
 * Convert hex string to normal string.
 *
 * @private
 * @param {string} hexString Hex string.
 * @returns {string} Normal string.
 */
function _hexStringToString(hexString) {
    var result = '';
    if (hexString && hexString[0] === '#') {
        hexString = hexString.substring(1);
        for (var i = 0; i < hexString.length; i += 2) {
            result += String.fromCharCode(Number.parseInt(hexString.substring(i, i + 2), 16));
        }
        return result;
    }
    return hexString;
}
/**
 * Check whether the character code is white space.
 *
 * @private
 * @param {number} ch The character code to check.
 * @returns {boolean} True if the character is space, otherwise false.
 */
function _isWhiteSpace(ch) {
    return ch === 0x20 || ch === 0x09 || ch === 0x0d || ch === 0x0a;
}
/**
 * Decode a chunk of base64 string into Uint8Array.
 *
 * @private
 * @param {string} input The base64 string to decode.
 * @returns {Uint8Array} Decoded bytes as Uint8Array.
 */
function _decodeChunk(input) {
    var key = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var chr1;
    var chr2;
    var chr3;
    var enc1;
    var enc2;
    var enc3;
    var enc4;
    var i = 0;
    var resultIndex = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, ''); // eslint-disable-line
    var totalLength = input.length * 3 / 4;
    if (input.charAt(input.length - 1) === key.charAt(64)) {
        totalLength--;
    }
    var output = new Array(totalLength | 0);
    while (i < input.length) {
        enc1 = key.indexOf(input.charAt(i++));
        enc2 = key.indexOf(input.charAt(i++));
        enc3 = key.indexOf(input.charAt(i++));
        enc4 = key.indexOf(input.charAt(i++));
        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;
        if (resultIndex < totalLength) {
            output[resultIndex++] = chr1;
        }
        if (resultIndex < totalLength) {
            output[resultIndex++] = chr2;
        }
        if (resultIndex < totalLength) {
            output[resultIndex++] = chr3;
        }
    }
    return new Uint8Array(output);
}
/**
 * Decode bytes from base64 string.
 *
 * @private
 * @param {string} input The base64 string to decode.
 * @param {boolean} isDirect Whether to return object or number[]. Default is false.
 * @returns {Uint8Array | number[]} Decoded bytes.
 */
function _decode(input, isDirect) {
    if (isDirect === void 0) { isDirect = false; }
    var chunkSize = 3000000;
    if (input.length >= chunkSize) {
        input = input.replace(/[^A-Za-z0-9+/=]/g, '');
        var outputChunks = [];
        var totalLength = 0;
        for (var i = 0; i < input.length; i += chunkSize) {
            var chunk = input.substring(i, i + chunkSize);
            var decodedChunk = _decodeChunk(chunk);
            outputChunks.push(decodedChunk);
            totalLength += decodedChunk.length;
        }
        var output = new Uint8Array(totalLength);
        var offset = 0;
        for (var _i = 0, outputChunks_1 = outputChunks; _i < outputChunks_1.length; _i++) {
            var chunk = outputChunks_1[_i];
            output.set(chunk, offset);
            offset += chunk.length;
        }
        return isDirect ? Array.from(output) : output;
    }
    else {
        var key = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        var chr1 = void 0;
        var chr2 = void 0;
        var chr3 = void 0;
        var enc1 = void 0;
        var enc2 = void 0;
        var enc3 = void 0;
        var enc4 = void 0;
        var i = 0;
        var resultIndex = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, ''); // eslint-disable-line
        var totalLength = input.length * 3 / 4;
        if (input.charAt(input.length - 1) === key.charAt(64)) {
            totalLength--;
        }
        var output = new Array(totalLength | 0);
        while (i < input.length) {
            enc1 = key.indexOf(input.charAt(i++));
            enc2 = key.indexOf(input.charAt(i++));
            enc3 = key.indexOf(input.charAt(i++));
            enc4 = key.indexOf(input.charAt(i++));
            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            if (resultIndex < totalLength) {
                output[resultIndex++] = chr1;
            }
            if (resultIndex < totalLength) {
                output[resultIndex++] = chr2;
            }
            if (resultIndex < totalLength) {
                output[resultIndex++] = chr3;
            }
        }
        return isDirect ? output : new Uint8Array(output);
    }
}
/**
 * Encode a chunk of bytes to base64 string.
 *
 * @private
 * @param {Uint8Array} bytes Bytes to encode.
 * @param {boolean} isLastChunk Defines a last chunk of bytes.
 * @returns {string} Decoded string.
 */
function _encodeChunk(bytes, isLastChunk) {
    if (isLastChunk === void 0) { isLastChunk = false; }
    var key = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var output = [];
    var length = bytes.length;
    var i = 0;
    while (i < length) {
        var byte1 = bytes[i++];
        var byte2 = i < length ? bytes[i++] : 0;
        var byte3 = i < length ? bytes[i++] : 0;
        var value1 = byte1 >> 2;
        var value2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        var value3 = ((byte2 & 15) << 2) | (byte3 >> 6);
        var value4 = byte3 & 63;
        output.push(key[Number.parseInt(value1.toString(), 10)], key[Number.parseInt(value2.toString(), 10)], i - 1 > length ? '=' : key[Number.parseInt(value3.toString(), 10)], i > length ? '=' : key[Number.parseInt(value4.toString(), 10)]);
    }
    if (isLastChunk) {
        if (length % 3 === 1) {
            output[output.length - 1] = '=';
            output[output.length - 2] = '=';
        }
        else if (length % 3 === 2) {
            output[output.length - 1] = '=';
        }
    }
    return output.join('');
}
/**
 * Encode bytes to base64 string.
 *
 * @private
 * @param {Uint8Array} bytes Bytes to encode.
 * @returns {string} Decoded string.
 */
function _encode(bytes) {
    var chunkSize = 3000000;
    var key = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var length = bytes.length;
    if (length >= chunkSize) {
        var output = [];
        if (length > chunkSize) {
            for (var start = 0; start < length; start += chunkSize) {
                var chunk = bytes.subarray(start, Math.min(start + chunkSize, length));
                if ((start + chunkSize) >= length) {
                    output.push(_encodeChunk(chunk, true));
                }
                else {
                    output.push(_encodeChunk(chunk));
                }
            }
        }
        else {
            output.push(_encodeChunk(bytes, true));
        }
        return output.join('');
    }
    else {
        var output = '';
        var currentChar = 0;
        for (var i = 0; i < bytes.length; i++) {
            if (i % 3 === 0) {
                currentChar = (bytes[Number.parseInt(i.toString(), 10)] >> 2);
                output += key[Number.parseInt(currentChar.toString(), 10)];
                currentChar = (bytes[Number.parseInt(i.toString(), 10)] << 4) & 63;
            }
            else if (i % 3 === 1) {
                currentChar += (bytes[Number.parseInt(i.toString(), 10)] >> 4);
                output += key[Number.parseInt(currentChar.toString(), 10)];
                currentChar = (bytes[Number.parseInt(i.toString(), 10)] << 2) & 63;
            }
            else if (i % 3 === 2) {
                currentChar += (bytes[Number.parseInt(i.toString(), 10)] >> 6);
                output += key[Number.parseInt(currentChar.toString(), 10)];
                currentChar = bytes[Number.parseInt(i.toString(), 10)] & 63;
                output += key[Number.parseInt(currentChar.toString(), 10)];
            }
        }
        if (bytes.length % 3 === 1) {
            output += key[Number.parseInt(currentChar.toString(), 10)] + "==";
        }
        if (bytes.length % 3 === 2) {
            output += key[Number.parseInt(currentChar.toString(), 10)] + "=";
        }
        return output;
    }
}
/**
 * Get property value in inheritable mode.
 *
 * @private
 * @param {_PdfDictionary} dictionary Input dictionary.
 * @param {string} key Input dictionary.
 * @param {boolean} isArray Search array.
 * @param {boolean} stopWhenFound Stop when found.
 * @param {string[]} parentKey Key string for parent node.
 * @returns {any} Property value.
 */
function _getInheritableProperty(dictionary, key, isArray, stopWhenFound) {
    if (isArray === void 0) { isArray = false; }
    if (stopWhenFound === void 0) { stopWhenFound = true; }
    var parentKey = [];
    for (var _i = 4; _i < arguments.length; _i++) {
        parentKey[_i - 4] = arguments[_i];
    }
    var values; // eslint-disable-line
    var refSet = new Set(); // eslint-disable-line
    while (dictionary instanceof _PdfDictionary && dictionary.objId && !refSet.has(dictionary.objId)) {
        if (dictionary.objId) {
            refSet.add(dictionary.objId);
        }
        var value = isArray ? dictionary.getArray(key) : dictionary.get(key); // eslint-disable-line
        if (value !== undefined) {
            if (stopWhenFound) {
                return value;
            }
            if (!values) {
                values = [];
            }
            values.push(value);
        }
        var index = 0;
        var hasParent = false;
        while (index < parentKey.length) {
            var element = parentKey[index]; // eslint-disable-line
            if (dictionary.has(element)) {
                dictionary = dictionary.get(element);
                hasParent = true;
                break;
            }
            index++;
        }
        if (!hasParent) {
            break;
        }
    }
    return values;
}
/**
 * Calculate bounds of annotation or field.
 *
 * @private
 * @param {_PdfDictionary} dictionary Input dictionary.
 * @param {boolean} isWidget Input page.
 * @returns {any} Bounds value.
 */
function _parseRectangle(dictionary, isWidget) {
    var rectangle = { x: 0, y: 0, width: 0, height: 0 };
    var elements = dictionary.getArray('Rect');
    if (elements && Array.isArray(elements)) {
        var x1 = elements[0];
        var y1 = elements[1];
        var x2 = elements[2];
        var y2 = elements[3];
        if (typeof x1 !== 'undefined' && typeof y1 !== 'undefined' && typeof x2 !== 'undefined' && typeof y2 !== 'undefined') {
            rectangle.x = Math.min(x1, x2);
            rectangle.y = Math.min(y1, y2);
            rectangle.width = Math.max(x1, x2) - rectangle.x;
            rectangle.height = Math.max(y1, y2) - rectangle.y;
            if (isWidget) {
                rectangle.height = parseFloat(rectangle.height.toFixed(3));
                if (elements[1] < 0) {
                    rectangle.y = elements[1];
                    if (elements[1] > elements[3]) {
                        rectangle.y -= rectangle.height;
                    }
                }
            }
        }
    }
    return rectangle;
}
/**
 * Calculate bounds of annotation or field.
 *
 * @private
 * @param {_PdfDictionary} dictionary Input dictionary.
 * @param {string} page Input page.
 * @returns {any} Bounds value.
 */
function _calculateBounds(dictionary, page) {
    var rect;
    if (dictionary.has('Rect')) {
        rect = _parseRectangle(dictionary);
        if (page) {
            var size = page.size;
            var mBox = page.mediaBox;
            var cropBox = page.cropBox;
            if (cropBox && Array.isArray(cropBox) && cropBox.length === 4 && page._pageDictionary.has('CropBox')) {
                if ((cropBox[0] !== 0 || cropBox[1] !== 0 || size[0] === cropBox[2] ||
                    size[1] === cropBox[3]) && (rect.x !== cropBox[0])) {
                    rect.x -= cropBox[0];
                    rect.y = cropBox[3] - (rect.y + rect.height);
                }
                else {
                    rect.y = size[1] - (rect.y + rect.height);
                }
            }
            else if (mBox && Array.isArray(mBox) && mBox.length === 4 && page._pageDictionary.has('MediaBox')) {
                if (mBox[0] > 0 || mBox[1] > 0 || size[0] === mBox[2] || size[1] === mBox[3]) {
                    rect.x -= mBox[0];
                    rect.y = mBox[3] - (rect.y + rect.height);
                }
                else {
                    rect.y = size[1] - (rect.y + rect.height);
                }
            }
            else {
                rect.y = size[1] - (rect.y + rect.height);
            }
        }
        else {
            rect.y = rect.y + rect.height;
        }
    }
    return rect;
}
/**
 * Calculate bounds of annotation or field.
 *
 * @private
 * @param {number[]} value array value.
 * @returns {any} Rectangle value.
 */
function _toRectangle(value) {
    return {
        x: Math.min(value[0], value[2]),
        y: Math.min(value[1], value[3]),
        width: Math.abs(value[0] - value[2]),
        height: Math.abs(value[1] - value[3])
    };
}
/**
 * Calculate bounds of annotation or field.
 *
 * @private
 * @param {any} value Rectangle value.
 * @param {any} value.x X value.
 * @param {any} value.y Y value.
 * @param {any} value.width Width value.
 * @param {any} value.height Height value.
 * @returns {number[]} Bounds value.
 */
function _fromRectangle(value) {
    return [value.x, value.y, value.x + value.width, value.y + value.height];
}
/**
 * Calculate bounds of annotation or field.
 *
 * @private
 * @param {number[]} value Input dictionary.
 * @param {string} page Input page.
 * @returns {number[]} Bounds value.
 */
function _getUpdatedBounds(value, page) {
    var x = value[0];
    var y = value[1];
    var width = value[2];
    var height = value[3];
    if (page) {
        var size = page.size;
        var pageWidth = size[0];
        var pageHeight = size[1];
        var mBox = page.mediaBox;
        var cropBox = page.cropBox;
        if (cropBox && Array.isArray(cropBox) && cropBox.length === 4) {
            if (cropBox[0] !== 0 || cropBox[1] !== 0 || pageWidth === cropBox[2] || pageHeight === cropBox[3]) {
                x += cropBox[0];
                y = cropBox[3] - (y + height);
            }
            else {
                y = pageHeight - (y + height);
            }
        }
        else if (mBox && Array.isArray(mBox) && mBox.length === 4) {
            if (mBox[0] > 0 || mBox[1] > 0 || pageWidth === mBox[2] || pageHeight === mBox[3]) {
                x -= mBox[0];
                y = mBox[3] - (y + height);
            }
            else {
                y = pageHeight - (y + height);
            }
        }
        else {
            y = pageHeight - (y + height);
        }
    }
    return [x, y, x + width, y + height];
}
/**
 * Parse RGB color.
 *
 * @private
 * @param {string} colorString Color value in string format.
 * @returns {number[]} RGB color value.
 */
function _convertToColor(colorString) {
    var color = _getColorValue(colorString);
    if (!color) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(colorString);
        if (result) {
            color = [Number.parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)];
        }
    }
    return color;
}
/**
 * Parse RGB color.
 *
 * @private
 * @param {number[]} array Color array in dictionary.
 * @returns {number[]} RGB color value.
 */
function _parseColor(array) {
    var color;
    if (array) {
        if (array.length === 1) {
            var entry = array[0];
            if (typeof entry !== 'undefined') {
                var round = Math.round(entry * 255);
                color = [round, round, round];
            }
        }
        else if (array.length === 3) {
            var r = array[0];
            var g = array[1];
            var b = array[2];
            if (typeof r !== 'undefined' && typeof g !== 'undefined' && typeof b !== 'undefined') {
                color = [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }
        }
        else if (array.length === 4) {
            var c = array[0];
            var m = array[1];
            var y = array[2];
            var k = array[3];
            if (typeof c !== 'undefined' && typeof m !== 'undefined' && typeof y !== 'undefined' && typeof k !== 'undefined') {
                var fBlack = k * 255;
                color = [Math.round(255 - Math.min(255, ((c * (255 - fBlack)) + fBlack))),
                    Math.round(255 - Math.min(255, ((m * (255 - fBlack)) + fBlack))),
                    Math.round(255 - Math.min(255, ((y * (255 - fBlack)) + fBlack)))];
            }
        }
    }
    return color;
}
/**
 * Get the border style in _PdfName.
 *
 * @private
 * @param {PdfBorderStyle} style border style in enum.
 * @returns {_PdfName} border style in _PdfName.
 */
function _mapBorderStyle(style) {
    var token = 'S';
    switch (style) {
        case PdfBorderStyle.dot:
        case PdfBorderStyle.dashed:
            token = 'D';
            break;
        case PdfBorderStyle.beveled:
            token = 'B';
            break;
        case PdfBorderStyle.inset:
            token = 'I';
            break;
        case PdfBorderStyle.underline:
            token = 'U';
            break;
    }
    return _PdfName.get(token);
}
/**
 * Get the border effect style in _PdfName.
 *
 * @private
 * @param {string} style border effect style as string.
 * @returns {PdfBorderEffectStyle} border effect style.
 */
function _mapBorderEffectStyle(style) {
    var value = PdfBorderEffectStyle.solid;
    switch (style) {
        case 'C':
            value = PdfBorderEffectStyle.cloudy;
            break;
    }
    return value;
}
/**
 * Get the string value for line ending style.
 *
 * @private
 * @param {PdfLineEndingStyle} style style in enum.
 * @returns {string} value default None.
 */
function _reverseMapEndingStyle(style) {
    var value = 'None';
    if (typeof style !== 'undefined') {
        switch (style) {
            case PdfLineEndingStyle.openArrow:
                value = 'OpenArrow';
                break;
            case PdfLineEndingStyle.closedArrow:
                value = 'ClosedArrow';
                break;
            case PdfLineEndingStyle.rOpenArrow:
                value = 'ROpenArrow';
                break;
            case PdfLineEndingStyle.rClosedArrow:
                value = 'RClosedArrow';
                break;
            case PdfLineEndingStyle.butt:
                value = 'Butt';
                break;
            case PdfLineEndingStyle.diamond:
                value = 'Diamond';
                break;
            case PdfLineEndingStyle.circle:
                value = 'Circle';
                break;
            case PdfLineEndingStyle.square:
                value = 'Square';
                break;
            case PdfLineEndingStyle.slash:
                value = 'Slash';
                break;
        }
    }
    return value;
}
/**
 * Get the enum value for line ending style.
 *
 * @private
 * @param {string} style Style value in string.
 * @param {PdfLineEndingStyle} defaultValue Default style value to return.
 * @returns {PdfLineEndingStyle} enum value default 0.
 */
function _mapLineEndingStyle(style, defaultValue) {
    var value = typeof defaultValue !== 'undefined' ? defaultValue : PdfLineEndingStyle.none;
    switch (style.toLowerCase()) {
        case 'openarrow':
            value = PdfLineEndingStyle.openArrow;
            break;
        case 'closedarrow':
            value = PdfLineEndingStyle.closedArrow;
            break;
        case 'ropenarrow':
            value = PdfLineEndingStyle.rOpenArrow;
            break;
        case 'rclosedarrow':
            value = PdfLineEndingStyle.rClosedArrow;
            break;
        case 'butt':
            value = PdfLineEndingStyle.butt;
            break;
        case 'diamond':
            value = PdfLineEndingStyle.diamond;
            break;
        case 'circle':
            value = PdfLineEndingStyle.circle;
            break;
        case 'square':
            value = PdfLineEndingStyle.square;
            break;
        case 'slash':
            value = PdfLineEndingStyle.slash;
            break;
    }
    return value;
}
/**
 * Get highlight mode.
 *
 * @private
 * @param {string} mode Mode entry in dictionary.
 * @returns {PdfHighlightMode} Highlight mode.
 */
function _mapHighlightMode(mode) {
    switch (mode) {
        case 'P':
            return PdfHighlightMode.push;
        case 'N':
            return PdfHighlightMode.noHighlighting;
        case 'O':
            return PdfHighlightMode.outline;
        default:
            return PdfHighlightMode.invert;
    }
}
/**
 * Get highlight mode as string.
 *
 * @private
 * @param {PdfHighlightMode} mode Mode entry.
 * @returns {_PdfName} Highlight mode as PDF name.
 */
function _reverseMapHighlightMode(mode) {
    switch (mode) {
        case PdfHighlightMode.push:
            return _PdfName.get('P');
        case PdfHighlightMode.noHighlighting:
            return _PdfName.get('N');
        case PdfHighlightMode.outline:
            return _PdfName.get('O');
        default:
            return _PdfName.get('I');
    }
}
/**
 * Reverse map blend mode.
 *
 * @private
 * @param {PdfBlendMode} mode Mode entry.
 * @returns {_PdfName} Blend mode as name.
 */
function _reverseMapBlendMode(mode) {
    var token = 'Normal';
    switch (mode) {
        case PdfBlendMode.multiply:
            token = 'Multiply';
            break;
        case PdfBlendMode.screen:
            token = 'Screen';
            break;
        case PdfBlendMode.overlay:
            token = 'Overlay';
            break;
        case PdfBlendMode.darken:
            token = 'Darken';
            break;
        case PdfBlendMode.lighten:
            token = 'Lighten';
            break;
        case PdfBlendMode.colorDodge:
            token = 'ColorDodge';
            break;
        case PdfBlendMode.colorBurn:
            token = 'ColorBurn';
            break;
        case PdfBlendMode.hardLight:
            token = 'HardLight';
            break;
        case PdfBlendMode.softLight:
            token = 'SoftLight';
            break;
        case PdfBlendMode.difference:
            token = 'Difference';
            break;
        case PdfBlendMode.exclusion:
            token = 'Exclusion';
            break;
        case PdfBlendMode.hue:
            token = 'Hue';
            break;
        case PdfBlendMode.saturation:
            token = 'Saturation';
            break;
        case PdfBlendMode.color:
            token = 'Color';
            break;
        case PdfBlendMode.luminosity:
            token = 'Luminosity';
            break;
        default:
            token = 'Normal';
            break;
    }
    return _PdfName.get(token);
}
/**
 * Map blend mode.
 *
 * @private
 * @param {_PdfName} token Blend mode as name.
 * @returns {PdfBlendMode} Mode value;
 */
function _mapBlendMode(token) {
    var style = PdfBlendMode.normal;
    switch (token.name) {
        case 'Multiply':
            style = PdfBlendMode.multiply;
            break;
        case 'Screen':
            style = PdfBlendMode.screen;
            break;
        case 'Overlay':
            style = PdfBlendMode.overlay;
            break;
        case 'Darken':
            style = PdfBlendMode.darken;
            break;
        case 'Lighten':
            style = PdfBlendMode.lighten;
            break;
        case 'ColorDodge':
            style = PdfBlendMode.colorDodge;
            break;
        case 'ColorBurn':
            style = PdfBlendMode.colorBurn;
            break;
        case 'HardLight':
            style = PdfBlendMode.hardLight;
            break;
        case 'SoftLight':
            style = PdfBlendMode.softLight;
            break;
        case 'Difference':
            style = PdfBlendMode.difference;
            break;
        case 'Exclusion':
            style = PdfBlendMode.exclusion;
            break;
        case 'Hue':
            style = PdfBlendMode.hue;
            break;
        case 'Saturation':
            style = PdfBlendMode.saturation;
            break;
        case 'Color':
            style = PdfBlendMode.color;
            break;
        case 'Luminosity':
            style = PdfBlendMode.luminosity;
            break;
        default:
            style = PdfBlendMode.normal;
            break;
    }
    return style;
}
/**
 * Convert float to string.
 *
 * @private
 * @param {number} value number value.
 * @returns {string} equal fixed length string value;
 */
function _floatToString(value) {
    var returnString = value.toFixed(2);
    if (returnString === '0.00') {
        returnString = '.00';
    }
    return returnString;
}
/**
 * Check and add proc set value.
 *
 * @private
 * @param {string} value entry.
 * @param {_PdfDictionary} dictionary source dictionary.
 * @returns {void} Nothing;
 */
function _addProcSet(value, dictionary) {
    var name = _PdfName.get(value);
    if (dictionary.has('ProcSet')) {
        var procset = dictionary.getArray('ProcSet');
        if (procset && procset.indexOf(name) === -1) {
            procset.push(name);
            dictionary.update('ProcSet', procset);
        }
    }
    else {
        dictionary.update('ProcSet', [name]);
    }
}
/**
 * Get new GUID string.
 *
 * @private
 * @returns {string} A new GUID string;
 */
function _getNewGuidString() {
    return 'aaaaaaaa-aaaa-4aaa-baaa-aaaaaaaaaaaa'.replace(/[ab]/g, function (c) {
        var random = Math.random() * 16 | 0;
        var result = c === 'a' ? random : (random & 0x3 | 0x8);
        return result.toString(16);
    });
}
/**
 * Escape PDF name.
 *
 * @private
 * @param {string} value name value.
 * @returns {string} equal and processed name value;
 */
function _escapePdfName(value) {
    var buffer = [];
    var start = 0;
    for (var i = 0; i < value.length; i++) {
        var char = value.charCodeAt(i);
        if (char < 0x21 ||
            char > 0x7e ||
            char === 0x23 ||
            char === 0x28 ||
            char === 0x29 ||
            char === 0x3c ||
            char === 0x3e ||
            char === 0x5b ||
            char === 0x5d ||
            char === 0x7b ||
            char === 0x7d ||
            char === 0x2f ||
            char === 0x25) {
            if (start < i) {
                buffer.push(value.substring(start, i));
            }
            buffer.push("#" + char.toString(16));
            start = i + 1;
        }
    }
    if (buffer.length === 0) {
        return value;
    }
    if (start < value.length) {
        buffer.push(value.substring(start, value.length));
    }
    return buffer.join('');
}
/**
 * Calculate bezier arc points.
 *
 * @private
 * @param {number} x1 value.
 * @param {number} y1 value.
 * @param {number} x2 value.
 * @param {number} y2 value.
 * @param {number} start value.
 * @param {number} extent value.
 * @returns {number[]} bezier arc points;
 */
function _getBezierArc(x1, y1, x2, y2, start, extent) {
    if (x1 > x2) {
        var swap = x1;
        x1 = x2;
        x2 = swap;
    }
    if (y2 > y1) {
        var swap = y1;
        y1 = y2;
        y2 = swap;
    }
    var angle;
    var count;
    if (Math.abs(extent) <= 90) {
        angle = extent;
        count = 1;
    }
    else {
        count = Math.ceil(Math.abs(extent) / 90);
        angle = extent / count;
    }
    var first = ((x1 + x2) / 2);
    var second = ((y1 + y2) / 2);
    var firstAngle = ((x2 - x1) / 2);
    var secondAngle = ((y2 - y1) / 2);
    var half = (angle * (Math.PI / 360));
    var value = (Math.abs(4.0 / 3.0 * (1.0 - Math.cos(half)) / Math.sin(half)));
    var points = [];
    for (var i = 0; (i < count); i++) {
        var zero = (((start + (i * angle)) * (Math.PI / 180)));
        var one = (((start + ((i + 1) * angle)) * (Math.PI / 180)));
        var cosZero = (Math.cos(zero));
        var cosOne = (Math.cos(one));
        var sinZero = (Math.sin(zero));
        var sinOne = (Math.sin(one));
        if ((angle > 0)) {
            points.push(first + (firstAngle * cosZero));
            points.push(second - (secondAngle * sinZero));
            points.push(first + (firstAngle * (cosZero - (value * sinZero))));
            points.push(second - (secondAngle * (sinZero + (value * cosZero))));
            points.push(first + (firstAngle * (cosOne + (value * sinOne))));
            points.push(second - (secondAngle * (sinOne - (value * cosOne))));
            points.push(first + (firstAngle * cosOne));
            points.push(second - (secondAngle * sinOne));
        }
        else {
            points.push(first + (firstAngle * cosZero));
            points.push(second - (secondAngle * sinZero));
            points.push(first + (firstAngle * (cosZero + (value * sinZero))));
            points.push(second - (secondAngle * (sinZero - (value * cosZero))));
            points.push(first + (firstAngle * (cosOne - (value * sinOne))));
            points.push(second - (secondAngle * (sinOne + (value * cosOne))));
            points.push(first + (firstAngle * cosOne));
            points.push(second - (secondAngle * sinOne));
        }
    }
    return points;
}
/**
 * Find page of the annotation.
 *
 * @private
 * @param {PdfDocument} document PDF document.
 * @param {_PdfReference} reference Annotation reference.
 * @returns {PdfPage} Page of the annotation;
 */
function _findPage(document, reference) {
    var page;
    for (var i = 0; i < document.pageCount && typeof page === 'undefined'; i++) {
        var entry = document.getPage(i);
        if (entry && entry._pageDictionary.has('Annots')) {
            var annots = entry._pageDictionary.get('Annots');
            if (annots !== null && typeof annots !== 'undefined' && annots.length > 0) {
                for (var j = 0; j < annots.length && typeof page === 'undefined'; j++) {
                    var ref = annots[Number.parseInt(j.toString(), 10)];
                    if (ref !== null && typeof ref !== 'undefined' && ref instanceof _PdfReference && ref === reference) {
                        page = entry;
                    }
                }
            }
        }
    }
    return page;
}
/**
 * Check the field is checked or not.
 *
 * @private
 * @param {_PdfDictionary} dictionary PDF dictionary.
 * @returns {boolean} True if the field is checked, otherwise false;
 */
function _checkField(dictionary) {
    var check = false;
    if (dictionary.has('AS')) {
        var state = dictionary.get('AS');
        if (state) {
            check = state.name !== 'Off';
        }
        else {
            var actual = dictionary.get('V');
            if (actual) {
                check = actual.name === _getItemValue(dictionary);
            }
        }
    }
    return check;
}
/**
 * Get item value from state item field.
 *
 * @private
 * @param {_PdfDictionary} itemDictionary PDF document.
 * @returns {string} value of item;
 */
function _getItemValue(itemDictionary) {
    var itemValue = '';
    var name;
    if (itemDictionary.has('AS')) {
        name = itemDictionary.get('AS');
        if (name !== null && name.name !== 'Off') {
            itemValue = name.name;
        }
    }
    if (itemValue === '' && itemDictionary.has('AP')) {
        var dictionary = itemDictionary.get('AP');
        if (dictionary && dictionary.has('N')) {
            var appearance = dictionary.get('N');
            if (appearance instanceof _PdfBaseStream) {
                appearance = appearance.dictionary;
            }
            if (appearance && appearance instanceof _PdfDictionary) {
                var keys_1 = [];
                appearance.forEach(function (key, value) {
                    keys_1.push(key);
                });
                for (var i = 0; i < keys_1.length; i++) {
                    if (keys_1[Number.parseInt(i.toString(), 10)] !== 'Off') {
                        itemValue = keys_1[Number.parseInt(i.toString(), 10)];
                        break;
                    }
                }
            }
        }
    }
    return itemValue;
}
/**
 * Get state item template.
 *
 * @private
 * @param {_PdfCheckFieldState} state Check field state.
 * @param {PdfStateItem | PdfField} item source to check.
 * @returns {PdfTemplate} Appearance template;
 */
function _getStateTemplate(state, item) {
    var value = state === _PdfCheckFieldState.checked ? _getItemValue(item._dictionary) : 'Off';
    var template;
    if (item._dictionary.has('AP')) {
        var dictionary = item._dictionary.get('AP');
        if (dictionary && dictionary.has('N')) {
            var appearance = dictionary.get('N');
            if (appearance && appearance instanceof _PdfBaseStream) {
                appearance = appearance.dictionary;
            }
            if (appearance && appearance instanceof _PdfDictionary && (value && value !== '' && appearance.has(value))) {
                var stream = appearance.get(value);
                var reference = appearance.getRaw(value);
                if (reference) {
                    stream.reference = reference;
                }
                if (stream) {
                    template = new PdfTemplate(stream, item._crossReference);
                }
            }
        }
    }
    return template;
}
/**
 * Get color value
 *
 * @private
 * @param {string} colorName name of the color.
 * @returns {number[]} return color value as number array.
 */
function _getColorValue(colorName) {
    var color;
    switch (colorName) {
        case 'transparent':
            color = [255, 255, 255];
            break;
        case 'aliceblue':
            color = [240, 248, 255];
            break;
        case 'antiquewhite':
            color = [250, 235, 215];
            break;
        case 'aqua':
            color = [0, 255, 255];
            break;
        case 'aquamarine':
            color = [127, 255, 212];
            break;
        case 'azure':
            color = [240, 255, 255];
            break;
        case 'beige':
            color = [245, 245, 220];
            break;
        case 'bisque':
            color = [255, 228, 196];
            break;
        case 'black':
            color = [0, 0, 0];
            break;
        case 'blanchedalmond':
            color = [255, 235, 205];
            break;
        case 'blue':
            color = [0, 0, 255];
            break;
        case 'blueviolet':
            color = [138, 43, 226];
            break;
        case 'brown':
            color = [165, 42, 42];
            break;
        case 'burlywood':
            color = [222, 184, 135];
            break;
        case 'cadetBlue':
            color = [95, 158, 160];
            break;
        case 'chartreuse':
            color = [127, 255, 0];
            break;
        case 'chocolate':
            color = [210, 105, 30];
            break;
        case 'coral':
            color = [255, 127, 80];
            break;
        case 'cornflowerblue':
            color = [100, 149, 237];
            break;
        case 'cornsilk':
            color = [255, 248, 220];
            break;
        case 'crimson':
            color = [220, 20, 60];
            break;
        case 'cyan':
            color = [0, 255, 255];
            break;
        case 'darkblue':
            color = [0, 0, 139];
            break;
        case 'darkcyan':
            color = [0, 139, 139];
            break;
        case 'darkgoldenrod':
            color = [184, 134, 11];
            break;
        case 'darkgray':
            color = [169, 169, 169];
            break;
        case 'darkgreen':
            color = [0, 100, 0];
            break;
        case 'darkkhaki':
            color = [189, 183, 107];
            break;
        case 'darkmagenta':
            color = [139, 0, 139];
            break;
        case 'darkolivegreen':
            color = [85, 107, 47];
            break;
        case 'darkorange':
            color = [255, 140, 0];
            break;
        case 'darkorchid':
            color = [153, 50, 204];
            break;
        case 'darkred':
            color = [139, 0, 0];
            break;
        case 'darksalmon':
            color = [233, 150, 122];
            break;
        case 'darkseagreen':
            color = [143, 188, 139];
            break;
        case 'darkslateblue':
            color = [72, 61, 139];
            break;
        case 'darkslategray':
            color = [47, 79, 79];
            break;
        case 'darkturquoise':
            color = [0, 206, 209];
            break;
        case 'darkviolet':
            color = [148, 0, 211];
            break;
        case 'deeppink':
            color = [255, 20, 147];
            break;
        case 'deepskyblue':
            color = [0, 191, 255];
            break;
        case 'dimgray':
            color = [105, 105, 105];
            break;
        case 'dodgerblue':
            color = [30, 144, 255];
            break;
        case 'firebrick':
            color = [178, 34, 34];
            break;
        case 'floralwhite':
            color = [255, 250, 240];
            break;
        case 'forestgreen':
            color = [34, 139, 34];
            break;
        case 'fuchsia':
            color = [255, 0, 255];
            break;
        case 'gainsboro':
            color = [220, 220, 220];
            break;
        case 'ghostwhite':
            color = [248, 248, 255];
            break;
        case 'gold':
            color = [255, 215, 0];
            break;
        case 'goldenrod':
            color = [218, 165, 32];
            break;
        case 'gray':
            color = [128, 128, 128];
            break;
        case 'green':
            color = [0, 128, 0];
            break;
        case 'greenyellow':
            color = [173, 255, 47];
            break;
        case 'honeydew':
            color = [240, 255, 240];
            break;
        case 'hotpink':
            color = [255, 105, 180];
            break;
        case 'indianred':
            color = [205, 92, 92];
            break;
        case 'indigo':
            color = [75, 0, 130];
            break;
        case 'ivory':
            color = [255, 255, 240];
            break;
        case 'khaki':
            color = [240, 230, 140];
            break;
        case 'lavender':
            color = [230, 230, 250];
            break;
        case 'lavenderblush':
            color = [255, 240, 245];
            break;
        case 'lawngreen':
            color = [124, 252, 0];
            break;
        case 'lemonchiffon':
            color = [255, 250, 205];
            break;
        case 'lightblue':
            color = [173, 216, 230];
            break;
        case 'lightcoral':
            color = [240, 128, 128];
            break;
        case 'lightcyan':
            color = [224, 255, 255];
            break;
        case 'lightgoldenrodyellow':
            color = [250, 250, 210];
            break;
        case 'lightgreen':
            color = [144, 238, 144];
            break;
        case 'lightgray':
            color = [211, 211, 211];
            break;
        case 'LightPink':
            color = [255, 182, 193];
            break;
        case 'lightsalmon':
            color = [255, 160, 122];
            break;
        case 'lightseagreen':
            color = [32, 178, 170];
            break;
        case 'lightskyblue':
            color = [135, 206, 250];
            break;
        case 'lightslategray':
            color = [119, 136, 153];
            break;
        case 'lightsteelblue':
            color = [176, 196, 222];
            break;
        case 'lightyellow':
            color = [255, 255, 224];
            break;
        case 'lime':
            color = [0, 255, 0];
            break;
        case 'limeGreen':
            color = [50, 205, 50];
            break;
        case 'linen':
            color = [250, 240, 230];
            break;
        case 'magenta':
            color = [255, 0, 255];
            break;
        case 'maroon':
            color = [128, 0, 0];
            break;
        case 'mediumaquamarine':
            color = [102, 205, 170];
            break;
        case 'mediumblue':
            color = [0, 0, 205];
            break;
        case 'mediumorchid':
            color = [186, 85, 211];
            break;
        case 'mediumpurple':
            color = [147, 112, 219];
            break;
        case 'mediumseagreen':
            color = [60, 179, 113];
            break;
        case 'mediumslateblue':
            color = [123, 104, 238];
            break;
        case 'mediumspringgreen':
            color = [0, 250, 154];
            break;
        case 'mediumturquoise':
            color = [72, 209, 204];
            break;
        case 'mediumvioletred':
            color = [199, 21, 133];
            break;
        case 'midnightblue':
            color = [25, 25, 112];
            break;
        case 'mintcream':
            color = [245, 255, 250];
            break;
        case 'mistyrose':
            color = [255, 228, 225];
            break;
        case 'moccasin':
            color = [255, 228, 181];
            break;
        case 'navajowhite':
            color = [255, 222, 173];
            break;
        case 'navy':
            color = [0, 0, 128];
            break;
        case 'oldLace':
            color = [253, 245, 230];
            break;
        case 'olive':
            color = [128, 128, 0];
            break;
        case 'olivedrab':
            color = [107, 142, 35];
            break;
        case 'orange':
            color = [255, 165, 0];
            break;
        case 'orangered':
            color = [255, 69, 0];
            break;
        case 'orchid':
            color = [218, 112, 214];
            break;
        case 'palegoldenrod':
            color = [238, 232, 170];
            break;
        case 'palegreen':
            color = [152, 251, 152];
            break;
        case 'paleturquoise':
            color = [175, 238, 238];
            break;
        case 'palebioletred':
            color = [219, 112, 147];
            break;
        case 'papayawhip':
            color = [255, 239, 213];
            break;
        case 'peachpuff':
            color = [255, 218, 185];
            break;
        case 'peru':
            color = [205, 133, 63];
            break;
        case 'pink':
            color = [255, 192, 203];
            break;
        case 'plum':
            color = [221, 160, 221];
            break;
        case 'powderblue':
            color = [176, 224, 230];
            break;
        case 'purple':
            color = [128, 0, 128];
            break;
        case 'red':
            color = [255, 0, 0];
            break;
        case 'rosybrown':
            color = [188, 143, 143];
            break;
        case 'royalblue':
            color = [65, 105, 225];
            break;
        case 'saddlebrown':
            color = [139, 69, 19];
            break;
        case 'salmon':
            color = [250, 128, 114];
            break;
        case 'sandybrown':
            color = [244, 164, 96];
            break;
        case 'seagreen':
            color = [46, 139, 87];
            break;
        case 'seashell':
            color = [255, 245, 238];
            break;
        case 'sienna':
            color = [160, 82, 45];
            break;
        case 'silver':
            color = [192, 192, 192];
            break;
        case 'skyblue':
            color = [135, 206, 235];
            break;
        case 'slateblue':
            color = [106, 90, 205];
            break;
        case 'slategray':
            color = [112, 128, 144];
            break;
        case 'snow':
            color = [255, 250, 250];
            break;
        case 'springgreen':
            color = [0, 255, 127];
            break;
        case 'steelblue':
            color = [70, 130, 180];
            break;
        case 'tan':
            color = [210, 180, 140];
            break;
        case 'teal':
            color = [0, 128, 128];
            break;
        case 'thistle':
            color = [216, 191, 216];
            break;
        case 'tomato':
            color = [255, 99, 71];
            break;
        case 'turquoise':
            color = [64, 224, 208];
            break;
        case 'violet':
            color = [238, 130, 238];
            break;
        case 'wheat':
            color = [245, 222, 179];
            break;
        case 'white':
            color = [255, 255, 255];
            break;
        case 'whitesmoke':
            color = [245, 245, 245];
            break;
        case 'yellow':
            color = [255, 255, 0];
            break;
        case 'yellowgreen':
            color = [154, 205, 50];
            break;
    }
    return color;
}
/**
 * Update box value in template bounds.
 *
 * @private
 * @param {PdfTemplate} template Template object.
 * @param {number} angle Angle value.
 * @returns {void} Nothing.
 */
function _setMatrix(template, angle) {
    var box = template._content.dictionary.getArray('BBox');
    if (box && typeof angle !== 'undefined' && angle !== null) {
        if (angle === 0) {
            template._content.dictionary.set('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
        }
        else {
            var matrix = new _PdfTransformationMatrix();
            if (angle === 90) {
                matrix._translate(box[3], -box[0]);
            }
            else if (angle === 180) {
                matrix._translate(box[2], box[3]);
            }
            else if (angle === 270) {
                matrix._translate(-box[1], box[2]);
            }
            matrix._rotate(angle);
            template._content.dictionary.set('Matrix', matrix._matrix._elements);
        }
    }
}
/**
 * Get the state item style to string
 *
 * @private
 * @param {PdfCheckBoxStyle} style State item style.
 * @returns {string} return as string value.
 */
function _styleToString(style) {
    var value = '4';
    switch (style) {
        case PdfCheckBoxStyle.circle:
            value = 'l';
            break;
        case PdfCheckBoxStyle.cross:
            value = '8';
            break;
        case PdfCheckBoxStyle.diamond:
            value = 'u';
            break;
        case PdfCheckBoxStyle.square:
            value = 'n';
            break;
        case PdfCheckBoxStyle.star:
            value = 'H';
            break;
    }
    return value;
}
/**
 * Get the string to state item style
 *
 * @private
 * @param {string} style State item style as string.
 * @returns {PdfCheckBoxStyle} return as state item style.
 */
function _stringToStyle(style) {
    var value = PdfCheckBoxStyle.check;
    switch (style) {
        case 'l':
            value = PdfCheckBoxStyle.circle;
            break;
        case '8':
            value = PdfCheckBoxStyle.cross;
            break;
        case 'u':
            value = PdfCheckBoxStyle.diamond;
            break;
        case 'n':
            value = PdfCheckBoxStyle.square;
            break;
        case 'H':
            value = PdfCheckBoxStyle.star;
            break;
    }
    return value;
}
/**
 * Map measurement unit type.
 *
 * @private
 * @param {string} unitString measurement unit as string.
 * @returns {PdfMeasurementUnit} measurement unit.
 */
function _mapMeasurementUnit(unitString) {
    var unit;
    switch (unitString) {
        case 'cm':
            unit = PdfMeasurementUnit.centimeter;
            break;
        case 'in':
            unit = PdfMeasurementUnit.inch;
            break;
        case 'mm':
            unit = PdfMeasurementUnit.millimeter;
            break;
        case 'p':
            unit = PdfMeasurementUnit.pica;
            break;
        case 'pt':
            unit = PdfMeasurementUnit.point;
            break;
        default:
            unit = PdfMeasurementUnit.centimeter;
            break;
    }
    return unit;
}
/**
 * Map markup annotation type.
 *
 * @private
 * @param {string} text markup type as string.
 * @returns {PdfTextMarkupAnnotationType} markup type as name.
 */
function _mapMarkupAnnotationType(text) {
    var type;
    switch (text) {
        case 'Highlight':
            type = PdfTextMarkupAnnotationType.highlight;
            break;
        case 'Squiggly':
            type = PdfTextMarkupAnnotationType.squiggly;
            break;
        case 'StrikeOut':
            type = PdfTextMarkupAnnotationType.strikeOut;
            break;
        case 'Underline':
            type = PdfTextMarkupAnnotationType.underline;
            break;
        default:
            type = PdfTextMarkupAnnotationType.highlight;
            break;
    }
    return type;
}
/**
 * Reverse text markup annotation type.
 *
 * @private
 * @param {PdfTextMarkupAnnotationType} type markup type.
 * @returns {string} markup type as name.
 */
function _reverseMarkupAnnotationType(type) {
    var token = 'Highlight';
    switch (type) {
        case PdfTextMarkupAnnotationType.highlight:
            token = 'Highlight';
            break;
        case PdfTextMarkupAnnotationType.squiggly:
            token = 'Squiggly';
            break;
        case PdfTextMarkupAnnotationType.strikeOut:
            token = 'StrikeOut';
            break;
        case PdfTextMarkupAnnotationType.underline:
            token = 'Underline';
            break;
        default:
            token = 'Highlight';
            break;
    }
    return token;
}
/**
 * Map graphics unit.
 *
 * @private
 * @param {string} unitString String value.
 * @returns {_PdfGraphicsUnit} PDF graphics unit.
 */
function _mapGraphicsUnit(unitString) {
    var unit;
    switch (unitString) {
        case 'cm':
            unit = _PdfGraphicsUnit.centimeter;
            break;
        case 'in':
            unit = _PdfGraphicsUnit.inch;
            break;
        case 'mm':
            unit = _PdfGraphicsUnit.millimeter;
            break;
        case 'p':
            unit = _PdfGraphicsUnit.pica;
            break;
        case 'pt':
            unit = _PdfGraphicsUnit.point;
            break;
        default:
            unit = _PdfGraphicsUnit.centimeter;
            break;
    }
    return unit;
}
/**
 * Map rubber stamp icon.
 *
 * @param {string} iconString String value.
 * @returns {PdfRubberStampAnnotationIcon} Rubber stamp icon.
 */
function _mapRubberStampIcon(iconString) {
    var icon;
    switch (iconString) {
        case '#Approved':
        case 'SBApproved':
            icon = PdfRubberStampAnnotationIcon.approved;
            break;
        case '#AsIs':
        case 'SBAsIs':
            icon = PdfRubberStampAnnotationIcon.asIs;
            break;
        case '#Completed':
        case 'SBCompleted':
            icon = PdfRubberStampAnnotationIcon.completed;
            break;
        case '#Confidential':
        case 'SBConfidential':
            icon = PdfRubberStampAnnotationIcon.confidential;
            break;
        case '#Departmental':
        case 'SBDepartmental':
            icon = PdfRubberStampAnnotationIcon.departmental;
            break;
        case '#Draft':
        case 'SBDraft':
            icon = PdfRubberStampAnnotationIcon.draft;
            break;
        case '#Experimental':
        case 'SBExperimental':
            icon = PdfRubberStampAnnotationIcon.experimental;
            break;
        case '#Expired':
        case 'SBExpired':
            icon = PdfRubberStampAnnotationIcon.expired;
            break;
        case '#Final':
        case 'SBFinal':
            icon = PdfRubberStampAnnotationIcon.final;
            break;
        case '#ForComment':
        case 'SBForComment':
            icon = PdfRubberStampAnnotationIcon.forComment;
            break;
        case '#ForPublicRelease':
        case 'SBForPublicRelease':
            icon = PdfRubberStampAnnotationIcon.forPublicRelease;
            break;
        case '#InformationOnly':
        case 'SBInformationOnly':
            icon = PdfRubberStampAnnotationIcon.informationOnly;
            break;
        case '#NotApproved':
        case 'SBNotApproved':
            icon = PdfRubberStampAnnotationIcon.notApproved;
            break;
        case '#NotForPublicRelease':
        case 'SBNotForPublicRelease':
            icon = PdfRubberStampAnnotationIcon.notForPublicRelease;
            break;
        case '#PreliminaryResults':
        case 'SBPreliminaryResults':
            icon = PdfRubberStampAnnotationIcon.preliminaryResults;
            break;
        case '#Sold':
        case 'SBSold':
            icon = PdfRubberStampAnnotationIcon.sold;
            break;
        case '#TopSecret':
        case 'SBTopSecret':
            icon = PdfRubberStampAnnotationIcon.topSecret;
            break;
        case '#Void':
        case 'SBVoid':
            icon = PdfRubberStampAnnotationIcon.void;
            break;
        default:
            icon = PdfRubberStampAnnotationIcon.draft;
            break;
    }
    return icon;
}
/**
 * Map popup icon.
 *
 * @private
 * @param {string} iconString String value.
 * @returns {PdfRubberStampAnnotationIcon} Popup icon.
 */
function _mapPopupIcon(iconString) {
    var icon;
    switch (iconString) {
        case 'Note':
            icon = PdfPopupIcon.note;
            break;
        case 'Comment':
            icon = PdfPopupIcon.comment;
            break;
        case 'Help':
            icon = PdfPopupIcon.help;
            break;
        case 'Insert':
            icon = PdfPopupIcon.insert;
            break;
        case 'Key':
            icon = PdfPopupIcon.key;
            break;
        case 'NewParagraph':
            icon = PdfPopupIcon.newParagraph;
            break;
        case 'Paragraph':
            icon = PdfPopupIcon.paragraph;
            break;
        default:
            icon = PdfPopupIcon.note;
            break;
    }
    return icon;
}
/**
 * Convert annotation state to string value.
 *
 * @private
 * @param {PdfAnnotationState} type Annotation state.
 * @returns {string} String value.
 */
function _reverseMapAnnotationState(type) {
    var token = 'None';
    switch (type) {
        case PdfAnnotationState.none:
            token = 'None';
            break;
        case PdfAnnotationState.accepted:
            token = 'Accepted';
            break;
        case PdfAnnotationState.rejected:
            token = 'Rejected';
            break;
        case PdfAnnotationState.cancel:
            token = 'Cancelled';
            break;
        case PdfAnnotationState.completed:
            token = 'Completed';
            break;
        case PdfAnnotationState.marked:
            token = 'Marked';
            break;
        case PdfAnnotationState.unmarked:
            token = 'Unmarked';
            break;
        case PdfAnnotationState.unknown:
            token = 'Unknown';
            break;
        default:
            token = 'None';
            break;
    }
    return token;
}
/**
 * Convert string value to annotation state.
 *
 * @private
 * @param {string} type String value.
 * @returns {PdfAnnotationState} Annotation state.
 */
function _mapAnnotationState(type) {
    var token = PdfAnnotationState.none;
    switch (type) {
        case 'None':
            token = PdfAnnotationState.none;
            break;
        case 'Accepted':
            token = PdfAnnotationState.accepted;
            break;
        case 'Rejected':
            token = PdfAnnotationState.rejected;
            break;
        case 'Cancelled':
            token = PdfAnnotationState.cancel;
            break;
        case 'Completed':
            token = PdfAnnotationState.completed;
            break;
        case 'Marked':
            token = PdfAnnotationState.marked;
            break;
        case 'Unmarked':
            token = PdfAnnotationState.unmarked;
            break;
        case 'Unknown':
            token = PdfAnnotationState.unknown;
            break;
    }
    return token;
}
/**
 * Convert annotation state model to string value.
 *
 * @private
 * @param {PdfAnnotationStateModel} type Annotation state model.
 * @returns {string} String value.
 */
function _reverseMapAnnotationStateModel(type) {
    var token = 'None';
    switch (type) {
        case PdfAnnotationStateModel.none:
            token = 'None';
            break;
        case PdfAnnotationStateModel.marked:
            token = 'Marked';
            break;
        case PdfAnnotationStateModel.review:
            token = 'Review';
            break;
        default:
            token = 'None';
            break;
    }
    return token;
}
/**
 * Convert string value to annotation state model.
 *
 * @private
 * @param {string} type String value.
 * @returns {PdfAnnotationStateModel} Annotation state model.
 */
function _mapAnnotationStateModel(type) {
    var token = PdfAnnotationStateModel.none;
    switch (type) {
        case 'None':
            token = PdfAnnotationStateModel.none;
            break;
        case 'Marked':
            token = PdfAnnotationStateModel.marked;
            break;
        case 'Review':
            token = PdfAnnotationStateModel.review;
            break;
    }
    return token;
}
/**
 * Map attachment icon.
 *
 * @private
 * @param {string} iconString String value.
 * @returns {PdfAttachmentIcon} Icon.
 */
function _mapAttachmentIcon(iconString) {
    var icon;
    switch (iconString) {
        case 'PushPin':
            icon = PdfAttachmentIcon.pushPin;
            break;
        case 'Tag':
            icon = PdfAttachmentIcon.tag;
            break;
        case 'Graph':
            icon = PdfAttachmentIcon.graph;
            break;
        case 'Paperclip':
            icon = PdfAttachmentIcon.paperClip;
            break;
        default:
            icon = PdfAttachmentIcon.pushPin;
            break;
    }
    return icon;
}
/**
 * Map attachment intent.
 *
 * @private
 * @param {string} intentString String value.
 * @returns {PdfAnnotationIntent} intent.
 */
function _mapAnnotationIntent(intentString) {
    var intent;
    switch (intentString) {
        case 'None':
            intent = PdfAnnotationIntent.none;
            break;
        case 'FreeTextCallout':
            intent = PdfAnnotationIntent.freeTextCallout;
            break;
        case 'FreeTextTypeWriter':
            intent = PdfAnnotationIntent.freeTextTypeWriter;
            break;
        default:
            intent = PdfAnnotationIntent.none;
            break;
    }
    return intent;
}
/**
 * Convert PDF font style to string value.
 *
 * @private
 * @param {PdfFontStyle} style Font style.
 * @returns {string} String value.
 */
function _reverseMapPdfFontStyle(style) {
    var value = [];
    if ((style & PdfFontStyle.bold) > 0) {
        value.push('Bold');
    }
    if ((style & PdfFontStyle.italic) > 0) {
        value.push('Italic');
    }
    if ((style & PdfFontStyle.underline) > 0) {
        value.push('Underline');
    }
    if ((style & PdfFontStyle.strikeout) > 0) {
        value.push('Strikeout');
    }
    if (value.length === 0) {
        return 'Regular';
    }
    return value.join(', ');
}
/**
 * Get special character.
 *
 * @private
 * @param {string} input Input string.
 * @returns {string} String value.
 */
function _getSpecialCharacter(input) {
    var result;
    switch (input) {
        case 'head2right':
            result = '\u27A2';
            break;
        case 'aacute':
            result = 'a\u0301';
            break;
        case 'eacute':
            result = 'e\u0301';
            break;
        case 'iacute':
            result = 'i\u0301';
            break;
        case 'oacute':
            result = 'o\u0301';
            break;
        case 'uacute':
            result = 'u\u0301';
            break;
        case 'circleright':
            result = '\u27B2';
            break;
        case 'bleft':
            result = '\u21E6';
            break;
        case 'bright':
            result = '\u21E8';
            break;
        case 'bup':
            result = '\u21E7';
            break;
        case 'bdown':
            result = '\u21E9';
            break;
        case 'barb4right':
            result = '\u2794';
            break;
        case 'bleftright':
            result = '\u2B04';
            break;
        case 'bupdown':
            result = '\u21F3';
            break;
        case 'bnw':
            result = '\u2B00';
            break;
        case 'bne':
            result = '\u2B01';
            break;
        case 'bsw':
            result = '\u2B03';
            break;
        case 'bse':
            result = '\u2B02';
            break;
        case 'bdash1':
            result = '\u25AD';
            break;
        case 'bdash2':
            result = '\u25AB';
            break;
        case 'xmarkbld':
            result = '\u2717';
            break;
        case 'checkbld':
            result = '\u2713';
            break;
        case 'boxxmarkbld':
            result = '\u2612';
            break;
        case 'boxcheckbld':
            result = '\u2611';
            break;
        case 'space':
            result = '\u0020';
            break;
        case 'pencil':
            result = '\u270F';
            break;
        case 'scissors':
            result = '\u2702';
            break;
        case 'scissorscutting':
            result = '\u2701';
            break;
        case 'readingglasses':
            result = '\u2701';
            break;
        case 'bell':
            result = '\u2701';
            break;
        case 'book':
            result = '\u2701';
            break;
        case 'telephonesolid':
            result = '\u2701';
            break;
        case 'telhandsetcirc':
            result = '\u2701';
            break;
        case 'envelopeback':
            result = '\u2701';
            break;
        case 'hourglass':
            result = '\u231B';
            break;
        case 'keyboard':
            result = '\u2328';
            break;
        case 'tapereel':
            result = '\u2707';
            break;
        case 'handwrite':
            result = '\u270D';
            break;
        case 'handv':
            result = '\u270C';
            break;
        case 'handptleft':
            result = '\u261C';
            break;
        case 'handptright':
            result = '\u261E';
            break;
        case 'handptup':
            result = '\u261D';
            break;
        case 'handptdown':
            result = '\u261F';
            break;
        case 'smileface':
            result = '\u263A';
            break;
        case 'frownface':
            result = '\u2639';
            break;
        case 'skullcrossbones':
            result = '\u2620';
            break;
        case 'flag':
            result = '\u2690';
            break;
        case 'pennant':
            result = '\u1F6A9';
            break;
        case 'airplane':
            result = '\u2708';
            break;
        case 'sunshine':
            result = '\u263C';
            break;
        case 'droplet':
            result = '\u1F4A7';
            break;
        case 'snowflake':
            result = '\u2744';
            break;
        case 'crossshadow':
            result = '\u271E';
            break;
        case 'crossmaltese':
            result = '\u2720';
            break;
        case 'starofdavid':
            result = '\u2721';
            break;
        case 'crescentstar':
            result = '\u262A';
            break;
        case 'yinyang':
            result = '\u262F';
            break;
        case 'om':
            result = '\u0950';
            break;
        case 'wheel':
            result = '\u2638';
            break;
        case 'aries':
            result = '\u2648';
            break;
        case 'taurus':
            result = '\u2649';
            break;
        case 'gemini':
            result = '\u264A';
            break;
        case 'cancer':
            result = '\u264B';
            break;
        case 'leo':
            result = '\u264C';
            break;
        case 'virgo':
            result = '\u264D';
            break;
        case 'libra':
            result = '\u264E';
            break;
        case 'scorpio':
            result = '\u264F';
            break;
        case 'saggitarius':
            result = '\u2650';
            break;
        case 'capricorn':
            result = '\u2651';
            break;
        case 'aquarius':
            result = '\u2652';
            break;
        case 'pisces':
            result = '\u2653';
            break;
        case 'ampersanditlc':
            result = '\u0026';
            break;
        case 'ampersandit':
            result = '\u0026';
            break;
        case 'circle6':
            result = '\u25CF';
            break;
        case 'circleshadowdwn':
            result = '\u274D';
            break;
        case 'square6':
            result = '\u25A0';
            break;
        case 'box3':
            result = '\u25A1';
            break;
        case 'boxshadowdwn':
            result = '\u2751';
            break;
        case 'boxshadowup':
            result = '\u2752';
            break;
        case 'lozenge4':
            result = '\u2B27';
            break;
        case 'lozenge6':
            result = '\u29EB';
            break;
        case 'rhombus6':
            result = '\u25C6';
            break;
        case 'xrhombus':
            result = '\u2756';
            break;
        case 'rhombus4':
            result = '\u2B25';
            break;
        case 'clear':
            result = '\u2327';
            break;
        case 'escape':
            result = '\u2353';
            break;
        case 'command':
            result = '\u2318';
            break;
        case 'rosette':
            result = '\u2740';
            break;
        case 'rosettesolid':
            result = '\u273F';
            break;
        case 'quotedbllftbld':
            result = '\u275D';
            break;
        case 'quotedblrtbld':
            result = '\u275E';
            break;
        case '.notdef':
            result = '\u25AF';
            break;
        case 'zerosans':
            result = '\u24EA';
            break;
        case 'onesans':
            result = '\u2460';
            break;
        case 'twosans':
            result = '\u2461';
            break;
        case 'threesans':
            result = '\u2462';
            break;
        case 'foursans':
            result = '\u2463';
            break;
        case 'fivesans':
            result = '\u2464';
            break;
        case 'sixsans':
            result = '\u2465';
            break;
        case 'sevensans':
            result = '\u2466';
            break;
        case 'eightsans':
            result = '\u2467';
            break;
        case 'ninesans':
            result = '\u2468';
            break;
        case 'tensans':
            result = '\u2469';
            break;
        case 'zerosansinv':
            result = '\u24FF';
            break;
        case 'onesansinv':
            result = '\u2776';
            break;
        case 'twosansinv':
            result = '\u2777';
            break;
        case 'threesansinv':
            result = '\u2778';
            break;
        case 'foursansinv':
            result = '\u2779';
            break;
        case 'circle2':
            result = '\u00B7';
            break;
        case 'circle4':
            result = '\u2022';
            break;
        case 'square2':
            result = '\u25AA';
            break;
        case 'ring2':
            result = '\u25CB';
            break;
        case 'ringbutton2':
            result = '\u25C9';
            break;
        case 'target':
            result = '\u25CE';
            break;
        case 'square4':
            result = '\u25AA';
            break;
        case 'box2':
            result = '\u25FB';
            break;
        case 'crosstar2':
            result = '\u2726';
            break;
        case 'pentastar2':
            result = '\u2605';
            break;
        case 'hexstar2':
            result = '\u2736';
            break;
        case 'octastar2':
            result = '\u2734';
            break;
        case 'dodecastar3':
            result = '\u2739';
            break;
        case 'octastar4':
            result = '\u2735';
            break;
        case 'registercircle':
            result = '\u2316';
            break;
        case 'cuspopen':
            result = '\u27E1';
            break;
        case 'cuspopen1':
            result = '\u2311';
            break;
        case 'circlestar':
            result = '\u2605';
            break;
        case 'starshadow':
            result = '\u2730';
            break;
        case 'deleteleft':
            result = '\u232B';
            break;
        case 'deleteright':
            result = '\u2326';
            break;
        case 'scissorsoutline':
            result = '\u2704';
            break;
        case 'telephone':
            result = '\u260F';
            break;
        case 'telhandset':
            result = '\u1F4DE';
            break;
        case 'handptlft1':
            result = '\u261C';
            break;
        case 'handptrt1':
            result = '\u261E';
            break;
        case 'handptlftsld1':
            result = '\u261A';
            break;
        case 'handptrtsld1':
            result = '\u261B';
            break;
        case 'handptup1':
            result = '\u261D';
            break;
        case 'handptdwn1':
            result = '\u261F';
            break;
        case 'xmark':
            result = '\u2717';
            break;
        case 'check':
            result = '\u2713';
            break;
        case 'boxcheck':
            result = '\u2611';
            break;
        case 'boxx':
            result = '\u2612';
            break;
        case 'boxxbld':
            result = '\u2612';
            break;
        case 'circlex':
            result = '=\u2314';
            break;
        case 'circlexbld':
            result = '\u2314';
            break;
        case 'prohibit':
        case 'prohibitbld':
            result = '\u29B8';
            break;
        case 'ampersanditaldm':
        case 'ampersandbld':
        case 'ampersandsans':
        case 'ampersandsandm':
            result = '\u0026';
            break;
        case 'interrobang':
        case 'interrobangdm':
        case 'interrobangsans':
        case 'interrobngsandm':
            result = '\u203D';
            break;
        case 'sacute':
            result = 'ś';
            break;
        case 'Sacute':
            result = 'Ś';
            break;
        case 'eogonek':
            result = 'ę';
            break;
        case 'cacute':
            result = 'ć';
            break;
        case 'aogonek':
            result = 'ą';
            break;
        default:
            result = input;
            break;
    }
    return result;
}
/**
 * Get latin character.
 *
 * @private
 * @param {string} input Input string.
 * @returns {string} String value.
 */
function _getLatinCharacter(input) {
    var result;
    switch (input) {
        case 'zero':
            result = '0';
            break;
        case 'one':
            result = '1';
            break;
        case 'two':
            result = '2';
            break;
        case 'three':
            result = '3';
            break;
        case 'four':
            result = '4';
            break;
        case 'five':
            result = '5';
            break;
        case 'six':
            result = '6';
            break;
        case 'seven':
            result = '7';
            break;
        case 'eight':
            result = '8';
            break;
        case 'nine':
            result = '9';
            break;
        case 'aacute':
            result = 'á';
            break;
        case 'asciicircum':
            result = '^';
            break;
        case 'asciitilde':
            result = '~';
            break;
        case 'asterisk':
            result = '*';
            break;
        case 'at':
            result = '@';
            break;
        case 'atilde':
            result = 'ã';
            break;
        case 'backslash':
            result = '\\';
            break;
        case 'bar':
            result = '|';
            break;
        case 'braceleft':
            result = '{';
            break;
        case 'braceright':
            result = '}';
            break;
        case 'bracketleft':
            result = '[';
            break;
        case 'bracketright':
            result = ']';
            break;
        case 'breve':
            result = '˘';
            break;
        case 'brokenbar':
            result = '|';
            break;
        case 'bullet3':
            result = '•';
            break;
        case 'bullet':
            result = '•';
            break;
        case 'caron':
            result = 'ˇ';
            break;
        case 'ccedilla':
            result = 'ç';
            break;
        case 'cedilla':
            result = '¸';
            break;
        case 'cent':
            result = '¢';
            break;
        case 'circumflex':
            result = 'ˆ';
            break;
        case 'colon':
            result = ':';
            break;
        case 'comma':
            result = ',';
            break;
        case 'copyright':
            result = '©';
            break;
        case 'currency1':
            result = '¤';
            break;
        case 'dagger':
            result = '†';
            break;
        case 'daggerdbl':
            result = '‡';
            break;
        case 'degree':
            result = '°';
            break;
        case 'dieresis':
            result = '¨';
            break;
        case 'divide':
            result = '÷';
            break;
        case 'dollar':
            result = '$';
            break;
        case 'dotaccent':
            result = '˙';
            break;
        case 'dotlessi':
            result = 'ı';
            break;
        case 'eacute':
            result = 'é';
            break;
        case 'middot':
            result = '˙';
            break;
        case 'edieresis':
            result = 'ë';
            break;
        case 'egrave':
            result = 'è';
            break;
        case 'ellipsis':
            result = '...';
            break;
        case 'emdash':
            result = '—';
            break;
        case 'endash':
            result = '–';
            break;
        case 'equal':
            result = '=';
            break;
        case 'eth':
            result = 'ð';
            break;
        case 'exclam':
            result = '!';
            break;
        case 'exclamdown':
            result = '¡';
            break;
        case 'florin':
            result = 'ƒ';
            break;
        case 'fraction':
            result = '⁄';
            break;
        case 'germandbls':
            result = 'ß';
            break;
        case 'grave':
            result = '`';
            break;
        case 'greater':
            result = '>';
            break;
        case 'guillemotleft4':
            result = '«';
            break;
        case 'guillemotright4':
            result = '»';
            break;
        case 'guilsinglleft':
            result = '‹';
            break;
        case 'guilsinglright':
            result = '›';
            break;
        case 'hungarumlaut':
            result = '˝';
            break;
        case 'hyphen5':
            result = '-';
            break;
        case 'iacute':
            result = 'í';
            break;
        case 'icircumflex':
            result = 'î';
            break;
        case 'idieresis':
            result = 'ï';
            break;
        case 'igrave':
            result = 'ì';
            break;
        case 'less':
            result = '<';
            break;
        case 'logicalnot':
            result = '¬';
            break;
        case 'lslash':
            result = 'ł';
            break;
        case 'Lslash':
            result = 'Ł';
            break;
        case 'macron':
            result = '¯';
            break;
        case 'minus':
            result = '−';
            break;
        case 'mu':
            result = 'μ';
            break;
        case 'multiply':
            result = '×';
            break;
        case 'ntilde':
            result = 'ñ';
            break;
        case 'numbersign':
            result = '#';
            break;
        case 'oacute':
            result = 'ó';
            break;
        case 'ocircumflex':
            result = 'ô';
            break;
        case 'odieresis':
            result = 'ö';
            break;
        case 'oe':
            result = 'oe';
            break;
        case 'ogonek':
            result = '˛';
            break;
        case 'ograve':
            result = 'ò';
            break;
        case 'onehalf':
            result = '1/2';
            break;
        case 'onequarter':
            result = '1/4';
            break;
        case 'onesuperior':
            result = '¹';
            break;
        case 'ordfeminine':
            result = 'ª';
            break;
        case 'ordmasculine':
            result = 'º';
            break;
        case 'otilde':
            result = 'õ';
            break;
        case 'paragraph':
            result = '¶';
            break;
        case 'parenleft':
            result = '(';
            break;
        case 'parenright':
            result = ')';
            break;
        case 'percent':
            result = '%';
            break;
        case 'period':
            result = '.';
            break;
        case 'periodcentered':
            result = '·';
            break;
        case 'perthousand':
            result = '‰';
            break;
        case 'plus':
            result = '+';
            break;
        case 'plusminus':
            result = '±';
            break;
        case 'question':
            result = '?';
            break;
        case 'questiondown':
            result = '¿';
            break;
        case 'quotedbl':
            result = '\'';
            break;
        case 'quotedblbase':
            result = '„';
            break;
        case 'quotedblleft':
            result = '“';
            break;
        case 'quotedblright':
            result = '”';
            break;
        case 'quoteleft':
            result = '‘';
            break;
        case 'quoteright':
            result = '’';
            break;
        case 'quotesinglbase':
            result = '‚';
            break;
        case 'quotesingle':
            result = '\'';
            break;
        case 'registered':
            result = '®';
            break;
        case 'ring':
            result = '˚';
            break;
        case 'scaron':
            result = 'š';
            break;
        case 'section':
            result = '§';
            break;
        case 'semicolon':
            result = ';';
            break;
        case 'slash':
            result = '/';
            break;
        case 'space6':
            result = ' ';
            break;
        case 'space':
            result = ' ';
            break;
        case 'udieresis':
            result = 'ü';
            break;
        case 'uacute':
            result = 'ú';
            break;
        case 'Ecircumflex':
            result = 'Ê';
            break;
        case 'hyphen':
            result = '-';
            break;
        case 'underscore':
            result = '_';
            break;
        case 'adieresis':
            result = 'ä';
            break;
        case 'ampersand':
            result = '&';
            break;
        case 'Adieresis':
            result = 'Ä';
            break;
        case 'Udieresis':
            result = 'Ü';
            break;
        case 'ccaron':
            result = 'č';
            break;
        case 'Scaron':
            result = 'Š';
            break;
        case 'zcaron':
            result = 'ž';
            break;
        case 'sterling':
            result = '£';
            break;
        case 'agrave':
            result = 'à';
            break;
        case 'ecircumflex':
            result = 'ê';
            break;
        case 'acircumflex':
            result = 'â';
            break;
        case 'Oacute':
            result = 'Ó';
            break;
        default:
            result = input;
            break;
    }
    return result;
}
/**
 * Encode value to string.
 *
 * @private
 * @param {string} value Input string.
 * @returns {string} result.
 */
function _encodeValue(value) {
    var name = '';
    for (var i = 0; i < value.length; i++) {
        var code = value.charCodeAt(i) & 0xff;
        var entry = String.fromCharCode(code);
        var hex = '';
        switch (entry) {
            case ' ':
            case '%':
            case '(':
            case ')':
            case '<':
            case '>':
            case '[':
            case ']':
            case '{':
            case '}':
            case '/':
            case '#':
                name += '#';
                hex = code.toString(16).toUpperCase();
                name += (hex.length === 1 ? ('0' + hex) : hex);
                break;
            default:
                if (code > 126 || code < 37) {
                    name += '#';
                    hex = code.toString(16).toUpperCase();
                    name += (hex.length === 1 ? ('0' + hex) : hex);
                }
                else {
                    name += entry;
                }
                break;
        }
    }
    return name;
}
/**
 * Parse and retrieve comments and review history from the annotation.
 *
 * @private
 * @param {PdfComment} annotation Input annotation.
 * @param {boolean} isReview Input is review or not.
 * @returns {PdfPopupAnnotationCollection} result.
 */
function _getCommentsOrReview(annotation, isReview) {
    if (isReview) {
        return annotation.reviewHistory;
    }
    else {
        return annotation.comments;
    }
}
/**
 * Returns true if input dictionary is belongs to the review history.
 *
 * @private
 * @param {_PdfDictionary} dictionary Input dictionary.
 * @returns {boolean} Input is review or not.
 */
function _checkReview(dictionary) {
    var flag = dictionary.get('F');
    return ((dictionary.has('State') || dictionary.has('StateModel')) && (flag === 30 || flag === 128));
}
/**
 * Returns true if input dictionary is belongs to the comments.
 *
 * @private
 * @param {_PdfDictionary} dictionary Input dictionary.
 * @returns {boolean} Input is comments or not.
 */
function _checkComment(dictionary) {
    var flag = dictionary.get('F');
    return (!(dictionary.has('State') || dictionary.has('StateModel')) && (flag === 28 || flag === 128));
}
/**
 * Update visibility.
 *
 * @private
 * @param {_PdfDictionary} dictionary Input dictionary.
 * @param {PdfFormFieldVisibility} value Visibility.
 * @returns {void} Nothing.
 */
function _updateVisibility(dictionary, value) {
    if (dictionary.has('F')) {
        delete dictionary._map.F;
        dictionary._updated = true;
    }
    switch (value) {
        case PdfFormFieldVisibility.hidden:
            dictionary.update('F', PdfAnnotationFlag.hidden);
            break;
        case PdfFormFieldVisibility.hiddenPrintable:
            dictionary.update('F', (PdfAnnotationFlag.noView | PdfAnnotationFlag.print));
            break;
        case PdfFormFieldVisibility.visible:
            if (dictionary.has('DV')) {
                delete dictionary._map.DV;
                dictionary._updated = true;
            }
            if (dictionary.has('MK')) {
                var mkDict = dictionary.get('MK');
                if (mkDict && mkDict.has('BG')) {
                    delete mkDict._map.BG;
                    mkDict._updated = true;
                }
            }
            break;
    }
}
/**
 * Remove duplicate reference.
 *
 * @private
 * @param {_PdfDictionary} dictionary Input dictionary.
 * @param {_PdfCrossReference} crossTable Cross reference table.
 * @param {string} key Key string for appearance type.
 * @returns {void} Nothing.
 */
function _removeDuplicateReference(dictionary, crossTable, key) {
    if (dictionary && dictionary.has(key)) {
        var oldAppearance = dictionary.getRaw(key);
        if (oldAppearance && oldAppearance instanceof _PdfReference && oldAppearance._isNew) {
            var appearance = dictionary.get(key); // eslint-disable-line
            if (appearance) {
                if (appearance instanceof _PdfReference) {
                    appearance = crossTable._fetch(appearance);
                }
                var appearanceDictionary = void 0;
                if (appearance instanceof _PdfDictionary) {
                    appearanceDictionary = appearance;
                }
                else if (appearance instanceof _PdfBaseStream) {
                    appearanceDictionary = appearance.dictionary;
                }
                if (appearanceDictionary && appearanceDictionary.has('Resources')) {
                    _removeDuplicateFromResources(appearanceDictionary.get('Resources'), crossTable);
                }
            }
            crossTable._cacheMap.delete(oldAppearance);
        }
    }
}
/**
 * Remove duplicate reference from resources.
 *
 * @private
 * @param {_PdfDictionary} resources Input resources.
 * @param {_PdfCrossReference} crossTable Cross reference table.
 * @returns {void} Nothing.
 */
function _removeDuplicateFromResources(resources, crossTable) {
    if (resources && resources.size > 0) {
        resources.forEach(function (key, value) {
            if (typeof key !== 'undefined' && typeof value !== 'undefined') {
                if (value instanceof _PdfReference) {
                    var reference = value;
                    if (reference._isNew) {
                        var dictionary = resources.get(key);
                        if (dictionary && dictionary instanceof _PdfDictionary) {
                            if (key === 'XObject' && dictionary.has('Resources')) {
                                _removeDuplicateFromResources(dictionary.get('Resources'), crossTable);
                            }
                            crossTable._cacheMap.delete(reference);
                        }
                    }
                }
                else if (value instanceof _PdfDictionary) {
                    if (value.has('Resources')) {
                        _removeDuplicateFromResources(value.get('Resources'), crossTable);
                    }
                    if (key === 'Font' || key === 'XObject' || key === 'ExtGState') {
                        _removeDuplicateFromResources(value, crossTable);
                    }
                }
            }
        });
    }
}
/**
 * Remove duplicate reference.
 *
 * @private
 * @param {any} normal Input.
 * @param {_PdfCrossReference} crossReference Cross reference table.
 * @param {string} firstKey Key string for appearance type.
 * @param {string} secondKey Key string for appearance type.
 * @returns {void} Nothing.
 */
function _removeReferences(normal, crossReference, firstKey, secondKey) {
    var normalElement;
    if (normal) {
        if (normal instanceof _PdfDictionary) {
            normalElement = normal;
        }
        else if (normal instanceof _PdfStream) {
            normalElement = normal.dictionary;
        }
    }
    if (normalElement) {
        _removeDuplicateReference(normalElement, crossReference, firstKey);
        _removeDuplicateReference(normalElement, crossReference, secondKey);
    }
}
var BaseException = /** @class */ (function () {
    function BaseException(message, name) {
        this.message = message;
        this.name = name;
    }
    return BaseException;
}());
var FormatError = /** @class */ (function (_super) {
    __extends$a(FormatError, _super);
    function FormatError(message) {
        return _super.call(this, message, 'FormatError') || this;
    }
    return FormatError;
}(BaseException));
var ParserEndOfFileException = /** @class */ (function (_super) {
    __extends$a(ParserEndOfFileException, _super);
    function ParserEndOfFileException(message) {
        return _super.call(this, message, 'ParserEndOfFileException') || this;
    }
    return ParserEndOfFileException;
}(BaseException));
/**
 * Gets the default string.
 *
 * @param {string} item Input string.
 * @returns {string} result.
 */
function _defaultToString(item) {
    if (Object.prototype.toString.call(item) === '[object String]') {
        return '$s' + item;
    }
    else {
        return '$o' + item.toString();
    }
}
/**
 * Gets the form field font.
 *
 * @param {PdfForm} form form.
 * @param {PdfWidgetAnnotation} widget widget annotation.
 * @param {PdfField} field field.
 * @returns {PdfFont} font.
 */
function _obtainFontDetails(form, widget, field) {
    var fontFamily = '';
    var fontSize;
    var font;
    var defaultAppearance;
    if (widget && widget._dictionary.has('DA') || field._dictionary.has('DA')) {
        if (widget && widget._dictionary.has('DA')) {
            defaultAppearance = widget._dictionary.get('DA');
        }
        else {
            defaultAppearance = field._dictionary.get('DA');
        }
    }
    if (defaultAppearance && defaultAppearance !== '' && defaultAppearance.indexOf('Tf') !== -1) {
        var textCollection = defaultAppearance.split(' ');
        for (var i = 0; i < textCollection.length; i++) {
            if (textCollection[Number.parseInt(i.toString(), 10)].indexOf('Tf') !== -1) {
                fontFamily = textCollection[i - 2];
                while (fontFamily !== '' && fontFamily.length > 1 && fontFamily[0] === '/') {
                    fontFamily = fontFamily.substring(1);
                }
                fontSize = Number.parseFloat(textCollection[i - 1]);
            }
        }
    }
    if (fontFamily) {
        fontFamily = fontFamily.trim();
    }
    if (form && form._dictionary.has('DR')) {
        var resources = form._dictionary.get('DR');
        if (resources.has('Font')) {
            var fonts = resources.get('Font');
            if (fonts.has(fontFamily)) {
                var fontDictionary = fonts.get(fontFamily);
                if (fontDictionary && fontFamily && fontDictionary.has('BaseFont')) {
                    var baseFont = fontDictionary.get('BaseFont');
                    var textFontStyle = PdfFontStyle.regular;
                    if (baseFont) {
                        defaultAppearance = baseFont.name;
                        textFontStyle = _getFontStyle(baseFont.name);
                        if (defaultAppearance.includes('-')) {
                            defaultAppearance = defaultAppearance.substring(0, defaultAppearance.indexOf('-'));
                        }
                        if (widget && widget._dictionary.has('DA')) {
                            font = _mapFont(defaultAppearance, fontSize, textFontStyle, widget);
                        }
                        else if (field && field._dictionary.has('DA')) {
                            font = _mapFont(defaultAppearance, fontSize, textFontStyle, field);
                        }
                    }
                }
            }
        }
    }
    if ((font === null || typeof font === 'undefined') && fontSize) {
        font = new PdfStandardFont(PdfFontFamily.helvetica, fontSize, PdfFontStyle.regular);
    }
    if ((font === null || typeof font === 'undefined') || (font && font.size === 1)) {
        if (widget) {
            font = widget._circleCaptionFont;
        }
        else if (field) {
            font = field._circleCaptionFont;
        }
    }
    return font;
}
/**
 * Gets the font style.
 *
 * @param {string} fontFamilyString Font family string.
 * @returns {PdfFontStyle} result.
 */
function _getFontStyle(fontFamilyString) {
    var position = fontFamilyString.indexOf('-');
    if (position < 0) {
        position = fontFamilyString.indexOf(',');
    }
    var style = PdfFontStyle.regular;
    if (position >= 0) {
        var standardName = fontFamilyString.substring(position + 1, fontFamilyString.length);
        switch (standardName) {
            case 'Bold':
            case 'BoldMT':
                style = PdfFontStyle.bold;
                break;
            case 'Italic':
            case 'ItalicMT':
            case 'Oblique':
            case 'It':
                style = PdfFontStyle.italic;
                break;
            case 'BoldItalic':
            case 'BoldItalicMT':
            case 'BoldOblique':
                style = PdfFontStyle.bold | PdfFontStyle.italic;
                break;
        }
    }
    return style;
}
/**
 * Map the font.
 *
 * @param {string} name Font name.
 * @param {number} size Font size.
 * @param {PdfFontStyle} style Font style.
 * @param {PdfAnnotation} annotation Annotation or Field.
 * @returns {PdfFont} result.
 */
function _mapFont(name, size, style, annotation) {
    var font;
    var fontFamily = name ? name : '';
    if (fontFamily.includes('-')) {
        fontFamily = fontFamily.substring(0, fontFamily.indexOf('-'));
    }
    if (typeof size === 'undefined' && annotation instanceof PdfLineAnnotation && annotation._isLoaded) {
        size = 10;
    }
    var fontSize = typeof size !== 'undefined' ? size : 1;
    if (annotation._dictionary.has('DS') || annotation._dictionary.has('DA')) {
        switch (fontFamily) {
            case 'Helv':
            case 'Helvetica':
                font = new PdfStandardFont(PdfFontFamily.helvetica, fontSize, style);
                break;
            case 'Cour':
            case 'Courier':
                font = new PdfStandardFont(PdfFontFamily.courier, fontSize, style);
                break;
            case 'Symb':
            case 'Symbol':
                font = new PdfStandardFont(PdfFontFamily.symbol, fontSize, style);
                break;
            case 'Times':
            case 'TiRo':
            case 'TimesRoman':
                font = new PdfStandardFont(PdfFontFamily.timesRoman, fontSize, style);
                break;
            case 'ZaDb':
            case 'ZapfDingbats':
                font = new PdfStandardFont(PdfFontFamily.zapfDingbats, fontSize, style);
                break;
            case 'MonotypeSungLight':
                font = new PdfCjkStandardFont(PdfCjkFontFamily.monotypeSungLight, fontSize, style);
                break;
            case 'SinoTypeSongLight':
                font = new PdfCjkStandardFont(PdfCjkFontFamily.sinoTypeSongLight, fontSize, style);
                break;
            case 'MonotypeHeiMedium':
                font = new PdfCjkStandardFont(PdfCjkFontFamily.monotypeHeiMedium, fontSize, style);
                break;
            case 'HanyangSystemsGothicMedium':
                font = new PdfCjkStandardFont(PdfCjkFontFamily.hanyangSystemsGothicMedium, fontSize, style);
                break;
            case 'HanyangSystemsShinMyeongJoMedium':
                font = new PdfCjkStandardFont(PdfCjkFontFamily.hanyangSystemsShinMyeongJoMedium, fontSize, style);
                break;
            case 'HeiseiKakuGothicW5':
                font = new PdfCjkStandardFont(PdfCjkFontFamily.heiseiKakuGothicW5, fontSize, style);
                break;
            case 'HeiseiMinchoW3':
                font = new PdfCjkStandardFont(PdfCjkFontFamily.heiseiMinchoW3, fontSize, style);
                break;
            default:
                if (annotation._dictionary.has('AP')) {
                    var fontData = _tryParseFontStream(annotation._dictionary, annotation._crossReference, annotation);
                    if (annotation._hasData) {
                        var base64String = _encode(fontData);
                        font = new PdfTrueTypeFont(base64String, fontSize, style);
                    }
                }
                break;
        }
    }
    if (font === null || typeof font === 'undefined') {
        if (annotation instanceof PdfAnnotation) {
            if (annotation._type !== _PdfAnnotationType.widgetAnnotation) {
                font = new PdfStandardFont(PdfFontFamily.helvetica, fontSize, style);
            }
            else {
                font = annotation._circleCaptionFont;
            }
        }
        else if (annotation instanceof PdfField) {
            font = annotation._circleCaptionFont;
        }
    }
    return font;
}
/**
 * Gets the font stream.
 *
 * @param {_PdfDictionary} widgetDictionary Widget dictionary.
 * @param {_PdfCrossReference} crossReference Cross reference.
 * @param {PdfAnnotation} annotation Annotation.
 * @returns {Uint8Array} result.
 */
function _tryParseFontStream(widgetDictionary, crossReference, annotation) {
    var fontData;
    var apperance = widgetDictionary.get('AP');
    if (apperance && apperance instanceof _PdfDictionary && apperance.has('N')) {
        var normal = apperance.get('N');
        if (normal && normal instanceof _PdfStream && normal.dictionary.has('Resources')) {
            var resourcesDictionary = normal.dictionary.get('Resources');
            if (resourcesDictionary && resourcesDictionary.has('Font')) {
                var fontDictionary = resourcesDictionary.get('Font');
                if (fontDictionary && fontDictionary instanceof _PdfDictionary) {
                    fontDictionary.forEach(function (key, value) {
                        if (value) {
                            var dictionary = crossReference._fetch(value);
                            if (dictionary && dictionary.has('DescendantFonts')) {
                                var descendant = dictionary.getArray('DescendantFonts'); // eslint-disable-line
                                if (descendant && descendant.length > 0) {
                                    for (var i = 0; i < descendant.length; i++) {
                                        var descendantFont = descendant[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                                        if (descendantFont && descendantFont instanceof _PdfDictionary && descendantFont.has('FontDescriptor')) {
                                            var fontDescriptor = descendantFont.get('FontDescriptor');
                                            if (fontDescriptor && fontDescriptor.has('FontFile2')) {
                                                var fontFile = fontDescriptor.get('FontFile2');
                                                if (fontFile && fontFile instanceof _PdfStream && fontFile.length > 0) {
                                                    fontData = fontFile.getByteRange(fontFile.start, fontFile.end);
                                                    if (fontData && fontData.length > 0) {
                                                        annotation._hasData = true;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            }
        }
    }
    return fontData;
}
/**
 * Gets the boolean if two arrays are equal.
 *
 * @param {Array<number[]>} inkPointsCollection Ink points collection.
 * @param {Array<number[]>} previousCollection Previous collection.
 * @returns {boolean} result.
 */
function _checkInkPoints(inkPointsCollection, previousCollection) {
    if (inkPointsCollection.length !== previousCollection.length) {
        return false;
    }
    for (var i = 0; i < inkPointsCollection.length; i++) {
        if (!_areArrayEqual(inkPointsCollection[Number.parseInt(i.toString(), 10)], previousCollection[Number.parseInt(i.toString(), 10)])) {
            return false;
        }
    }
    return true;
}
/**
 * Gets the Destination.
 *
 * @param {_PdfDictionary} dictionary widget dictionary.
 * @param {string} key bookmark or action dictionary key.
 * @returns {PdfDestination} destination.
 */
function _obtainDestination(dictionary, key) {
    var page;
    var destination;
    if (dictionary) {
        var destinationArray = void 0; // eslint-disable-line
        if (dictionary.has(key)) {
            destinationArray = dictionary.getArray(key);
        }
        var loadedDocument = dictionary._crossReference._document;
        var mode = void 0;
        if (destinationArray && Array.isArray(destinationArray) && destinationArray.length > 0) {
            var value = destinationArray[0]; // eslint-disable-line
            var left = void 0;
            var height = void 0;
            var bottom = void 0;
            var right = void 0;
            var zoom = void 0;
            if (typeof value === 'number') {
                var pageNumber = destinationArray[0];
                if (pageNumber >= 0) {
                    var document_1 = dictionary._crossReference._document;
                    if (document_1 && document_1.pageCount > pageNumber) {
                        page = document_1.getPage(pageNumber);
                    }
                    if (destinationArray.length > 1) {
                        mode = destinationArray[1];
                    }
                    if (mode && mode.name === 'XYZ') {
                        if (destinationArray.length > 2) {
                            left = destinationArray[2];
                        }
                        if (destinationArray.length > 3) {
                            height = destinationArray[3];
                        }
                        if (destinationArray.length > 4) {
                            zoom = destinationArray[4];
                        }
                        if (page) {
                            var topValue = (height === null || typeof height === 'undefined') ? 0 : page.size[1] - height;
                            var leftValue = (left === null || typeof left === 'undefined') ? 0 : left;
                            if (page.rotation !== PdfRotationAngle.angle0) {
                                _checkRotation(page, height, left);
                            }
                            destination = new PdfDestination(page, [leftValue, topValue]);
                            destination._index = pageNumber;
                            destination.zoom = (typeof zoom !== 'undefined' && zoom !== null) ? zoom : 0;
                            if (left === null || height === null || zoom === null || typeof left === 'undefined'
                                || typeof height === 'undefined' || typeof zoom === 'undefined') {
                                destination._setValidation(false);
                            }
                        }
                    }
                }
            }
            if (value instanceof _PdfDictionary) {
                var pageDictionary = value;
                var index = void 0;
                if (loadedDocument && pageDictionary) {
                    index = _getPageIndex(loadedDocument, pageDictionary);
                }
                if (typeof index !== 'undefined' && index !== null && index >= 0) {
                    page = loadedDocument.getPage(index);
                }
                if (destinationArray.length > 1) {
                    mode = destinationArray[1];
                }
                if (mode) {
                    if (mode.name === 'XYZ') {
                        if (destinationArray.length > 2) {
                            left = destinationArray[2];
                        }
                        if (destinationArray.length > 3) {
                            height = destinationArray[3];
                        }
                        if (destinationArray.length > 4) {
                            zoom = destinationArray[4];
                        }
                        if (page) {
                            var topValue = (height === null || typeof height === 'undefined') ? 0 : page.size[1] - height;
                            var leftValue = (left === null || typeof left === 'undefined') ? 0 : left;
                            if (page.rotation !== PdfRotationAngle.angle0) {
                                topValue = _checkRotation(page, height, left);
                            }
                            destination = new PdfDestination(page, [leftValue, topValue]);
                            destination._index = index;
                            destination.zoom = (typeof zoom !== 'undefined' && zoom !== null) ? zoom : 0;
                            if (left === null || height === null || zoom === null || typeof left === 'undefined' ||
                                typeof height === 'undefined' || typeof zoom === 'undefined') {
                                destination._setValidation(false);
                            }
                        }
                    }
                    else {
                        if (mode.name === 'FitR') {
                            if (destinationArray.length > 2) {
                                left = destinationArray[2];
                            }
                            if (destinationArray.length > 3) {
                                bottom = destinationArray[3];
                            }
                            if (destinationArray.length > 4) {
                                right = destinationArray[4];
                            }
                            if (destinationArray.length > 5) {
                                height = destinationArray[5];
                            }
                            if (page) {
                                left = (left === null || typeof left === 'undefined') ? 0 : left;
                                bottom = (bottom === null || typeof bottom === 'undefined') ? 0 : bottom;
                                height = (height === null || typeof height === 'undefined') ? 0 : height;
                                right = (right === null || typeof right === 'undefined') ? 0 : right;
                                destination = new PdfDestination(page, [left, bottom, right, height]);
                                destination._index = index;
                                destination.mode = PdfDestinationMode.fitR;
                            }
                        }
                        else if (mode.name === 'FitBH' || mode.name === 'FitH') {
                            if (destinationArray.length >= 3) {
                                height = destinationArray[2];
                            }
                            if (typeof index !== 'undefined' && index !== null && index >= 0) {
                                page = loadedDocument.getPage(index);
                            }
                            if (page && page.size) {
                                var topValue = (height === null || typeof height === 'undefined') ? 0 : page.size[1] - height;
                                destination = new PdfDestination(page, [0, topValue]);
                                destination._index = index;
                                destination.mode = PdfDestinationMode.fitH;
                                if (height === null || typeof height === 'undefined') {
                                    destination._setValidation(false);
                                }
                            }
                        }
                        else {
                            if (page && mode.name === 'Fit') {
                                destination = new PdfDestination(page);
                                destination._index = index;
                                destination.mode = PdfDestinationMode.fitToPage;
                            }
                        }
                    }
                }
            }
        }
    }
    return destination;
}
/**
 * Update the annotation bounds.
 *
 * @param {PdfAnnotation} annotation annotation.
 * @param {number[]} bounds annotation bounds.
 * @returns {number[]} bounds.
 */
function _updateBounds(annotation, bounds) {
    if (bounds) {
        annotation._bounds = { x: bounds[0], y: bounds[1], width: bounds[2], height: bounds[3] };
    }
    var rect;
    if (annotation._page && annotation.bounds) {
        rect = [annotation.bounds.x, annotation.bounds.y + annotation.bounds.height,
            annotation.bounds.width, annotation.bounds.height];
        if (annotation._page._isNew && annotation._page._pageSettings) {
            var pageSettings = annotation._page._pageSettings;
            var pageBounds = [pageSettings.margins.left, pageSettings.margins.top, pageSettings.size[0] -
                    (pageSettings.margins.left + pageSettings.margins.right),
                pageSettings.size[1] - (pageSettings.margins.top + pageSettings.margins.bottom)];
            rect[0] += pageBounds[0];
            rect[1] = pageSettings.size[1] - (pageBounds[1] + rect[1]);
        }
        else {
            var size = annotation._page.size;
            rect[1] = size[1] - (annotation.bounds.y + annotation.bounds.height);
            var cropBoxOrMediaBox = annotation._getCropOrMediaBox();
            if (cropBoxOrMediaBox && cropBoxOrMediaBox.length > 2 && (cropBoxOrMediaBox[0] !== 0 || cropBoxOrMediaBox[1] !== 0)) {
                rect[0] += cropBoxOrMediaBox[0];
                rect[1] += cropBoxOrMediaBox[1];
            }
        }
        return [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]];
    }
    return rect;
}
/**
 * Decode text.
 *
 * @param {string} text Text to decode.
 * @param {boolean} isColorSpace Color space or not
 * @param {boolean} isPassword Password or not
 * @returns {string} Decoded text.
 */
function _decodeText(text, isColorSpace, isPassword) {
    if (text && typeof text === 'string' && !isColorSpace && !isPassword) {
        if (text.startsWith('þÿ')) {
            text = text.substring(2);
            if (text.endsWith('ÿý')) {
                text = text.substring(0, text.length - 2);
            }
            var bytes = _stringToBytes(text, false, true);
            var result = '';
            for (var i = 0; i < bytes.length; i += 2) {
                var x = bytes[Number.parseInt(i.toString(), 10)] << 8;
                var y = bytes[Number.parseInt((i + 1).toString(), 10)];
                var codeUnit = x | y;
                result += String.fromCharCode(codeUnit);
            }
            text = result;
        }
    }
    return text;
}
/**
 * Number of bytes required to save the number.
 *
 * @param {number} input number.
 * @returns {number} number of bytes.
 */
function _getSize(input) {
    var size = 0;
    var uintMaxValue = 0xFFFFFFFF;
    var ushortMaxValue = 0xFFFF;
    var byteMaxValue = 0xFF;
    if (input <= uintMaxValue) {
        if (input <= ushortMaxValue) {
            if (input <= byteMaxValue) {
                size = 1;
            }
            else {
                size = 2;
            }
        }
        else {
            if (input <= (ushortMaxValue | (ushortMaxValue << 8))) {
                size = 3;
            }
            else {
                size = 4;
            }
        }
    }
    else {
        size = 8;
    }
    return size;
}
/**
 * Convert the string to big endian bytes.
 *
 * @param {string} input string.
 * @returns {number[]} bytes.
 */
function _stringToBigEndianBytes(input) {
    var bytes = [];
    for (var i = 0; i < input.length; i++) {
        var charCode = input.charCodeAt(Number.parseInt(i.toString(), 10));
        if (charCode <= 0xFFFF) {
            bytes.push((charCode >> 8) & 0xFF);
            bytes.push(charCode & 0xFF);
        }
    }
    return bytes;
}
/**
 * Convert number respect to ordered list number style.
 *
 * @param {number} intArabic Input value.
 * @param {PdfNumberStyle} numberStyle Number style.
 * @returns {string} String value.
 */
function _convertNumber(intArabic, numberStyle) {
    switch (numberStyle) {
        case PdfNumberStyle.none:
            return '';
        case PdfNumberStyle.numeric:
            return intArabic.toString();
        case PdfNumberStyle.lowerLatin:
            return _arabicToLetter(intArabic).toLowerCase();
        case PdfNumberStyle.lowerRoman:
            return _arabicToRoman(intArabic).toLowerCase();
        case PdfNumberStyle.upperLatin:
            return _arabicToLetter(intArabic);
        case PdfNumberStyle.upperRoman:
            return _arabicToRoman(intArabic);
    }
}
/**
 * Convert arabic numbers to roman style.
 *
 * @param {number} intArabic Input value.
 * @returns {string} String value.
 */
function _arabicToRoman(intArabic) {
    var retval = '';
    var romanNumerals = [
        [1000, 'M'], [900, 'CM'], [500, 'D'], [400, 'CD'],
        [100, 'C'], [90, 'XC'], [50, 'L'], [40, 'XL'],
        [10, 'X'], [9, 'IX'], [5, 'V'], [4, 'IV'], [1, 'I']
    ];
    for (var _i = 0, romanNumerals_1 = romanNumerals; _i < romanNumerals_1.length; _i++) {
        var _a = romanNumerals_1[_i], value = _a[0], numeral = _a[1];
        while (intArabic >= value) {
            retval += numeral;
            intArabic -= value;
        }
    }
    return retval;
}
/**
 * Convert arabic numbers to alphabet.
 *
 * @param {number} arabic Input value.
 * @returns {string} String value.
 */
function _arabicToLetter(arabic) {
    var result = '';
    while (arabic > 0) {
        var remainder = arabic % 26;
        arabic = Math.floor(arabic / 26);
        if (remainder === 0) {
            arabic--;
            remainder = 26;
        }
        result = _appendChar(remainder) + result;
    }
    return result;
}
/**
 * Convert character code to string.
 *
 * @param {number} value Input value.
 * @returns {string} String value.
 */
function _appendChar(value) {
    if (value <= 0 || value > 26) {
        throw new Error('Value can not be less 0 and greater 26');
    }
    return String.fromCharCode(64 + value);
}
/**
 * Check whether the value is null or undefined.
 *
 * @param {any} value Input value.
 * @returns {boolean} Return true if the value is null or undefined; otherwise, return false
 */
function _isNullOrUndefined(value) {
    if (value !== null && typeof value !== 'undefined') {
        return true;
    }
    return false;
}
/**
 * Compare two arrays of numbers to determine if they are equal.
 *
 * This function checks if two arrays have the same length and
 * identical elements in the same order.
 *
 * @param {number[]} arr1 - The first array to compare.
 * @param {number[]} arr2 - The second array to compare.
 * @returns {boolean} 'true' if the arrays are equal, otherwise 'false'.
 */
function _isArrayEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
        return false;
    }
    for (var i = 0, ii = arr1.length; i < ii; i++) {
        if (arr1[Number.parseInt(i.toString(), 10)] !== arr2[Number.parseInt(i.toString(), 10)]) {
            return false;
        }
    }
    return true;
}
/**
 * Defines a property on an object with specific attributes.
 *
 * @param {Object} obj - The target object on which the property will be defined.
 * @param {string} prop - The name of the property to define.
 * @param {any} value - The value to assign to the property.
 * @param {boolean} [serializable = false] - If true, the property will not be enumerable.
 * @returns {any} The value of the property that was defined.
 *
 */
function _defineProperty(obj, prop, value, serializable) {
    if (serializable === void 0) { serializable = false; }
    Object.defineProperty(obj, prop, {
        value: value,
        enumerable: !serializable,
        configurable: true,
        writable: false
    });
    return value;
}
/**
 * Compresses the content of a PDFBaseStream
 *
 * @param {_PdfBaseStream} stream - Base stream to compress.
 * @param {boolean} isExport - Denotes compress the stream as a hex-encoded string.
 * @returns {boolean} compressed string.
 */
function _compressStream(stream, isExport) {
    if (isExport === void 0) { isExport = false; }
    var value = stream.getString();
    var byteArray = [];
    for (var i = 0; i < value.length; i++) {
        byteArray.push(value.charCodeAt(i));
    }
    var dataArray = new Uint8Array(byteArray);
    var sw = new CompressedStreamWriter();
    sw.write(dataArray, 0, dataArray.length);
    sw.close();
    value = sw.getCompressedString;
    stream.dictionary.update('Filter', _PdfName.get('FlateDecode'));
    if (isExport) {
        var buffer = [];
        for (var i = 0; i < value.length; i++) {
            buffer.push(value.charCodeAt(i) & 0xff);
        }
        return _byteArrayToHexString(new Uint8Array(buffer));
    }
    return value;
}
/**
 * Check whether the input string contains any right-to-left (RTL) characters.
 *
 * @param {string} input The input string.
 * @returns {boolean} Returns true if the string contains any RTL characters; otherwise, returns false.
 */
function _isRightToLeftCharacters(input) {
    // Unicode range for RTL characters
    var rtlRegex = /[\u0590-\u08FF\uFB1D-\uFDFF\uFE70-\uFEFF]/;
    return rtlRegex.test(input);
}
/**
 * Updates the page count value in the dictionary
 *
 * @param {_PdfDictionary} dictionary - Dictionary to update page count.
 * @param {number} valueToIncrement - Page count.
 * @returns {void} Nothing.
 */
function _updatePageCount(dictionary, valueToIncrement) {
    dictionary.update('Count', dictionary.get('Count') + valueToIncrement);
    if (dictionary.has('Parent')) {
        var parentDictionary = dictionary.get('Parent');
        if (parentDictionary && parentDictionary.get('Type').name === 'Pages') {
            _updatePageCount(parentDictionary, valueToIncrement);
        }
    }
}
/**
 * Updates the page settings in the dictionary
 *
 * @param {_PdfDictionary} dictionary - Dictionary to update page settings.
 * @param {PdfPageSettings} settings - PDF page settings.
 * @returns {void} Nothing.
 */
function _updatePageSettings(dictionary, settings) {
    var bounds = [0, 0, settings.size[0], settings.size[1]];
    dictionary.update('MediaBox', bounds);
    dictionary.update('CropBox', bounds);
    var rotate = Math.floor(settings.rotation) * 90;
    if (rotate >= 360) {
        rotate = rotate % 360;
    }
    dictionary.update('Rotate', rotate);
}
/**
 * Base64 encoded string representing an empty PDF document.
 */
var _emptyPdfData = 'JVBERi0xLjQNCiWDkvr+DQoxIDAgb2JqDQo8PA0KL1R5cGUgL0NhdGFsb2cNCi9QYWdlcyAyIDAgUg0KL0Fjcm9Gb3JtIDMgMCBSDQo+Pg0KZW5kb2JqDQoyIDAgb2JqDQo8PA0KL1R5cGUgL1BhZ2VzDQovS2lkcyBbNCAwIFJdDQovQ291bnQgMQ0KL1Jlc291cmNlcyA8PD4+DQoNCi9NZWRpYUJveCBbLjAwIC4wMCA1OTUuMDAgODQyLjAwXQ0KL1JvdGF0ZSAwDQo+Pg0KZW5kb2JqDQozIDAgb2JqDQo8PA0KL0ZpZWxkcyBbXQ0KPj4NCmVuZG9iag0KNCAwIG9iag0KPDwNCi9Db3VudCAxDQovVHlwZSAvUGFnZXMNCi9LaWRzIFs1IDAgUl0NCi9QYXJlbnQgMiAwIFINCj4+DQplbmRvYmoNCjUgMCBvYmoNCjw8DQovVHlwZSAvUGFnZQ0KL1BhcmVudCA0IDAgUg0KPj4NCmVuZG9iag0KeHJlZg0KMCA2DQowMDAwMDAwMDAwIDY1NTM1IGYNCjAwMDAwMDAwMTcgMDAwMDAgbg0KMDAwMDAwMDA4OSAwMDAwMCBuDQowMDAwMDAwMjE4IDAwMDAwIG4NCjAwMDAwMDAyNTUgMDAwMDAgbg0KMDAwMDAwMDMzNCAwMDAwMCBuDQp0cmFpbGVyDQo8PA0KL1Jvb3QgMSAwIFINCi9TaXplIDYNCj4+DQoNCnN0YXJ0eHJlZg0KMzg3DQolJUVPRg0K';

/* eslint-disable */
var nameCache = Object.create(null);
var cmdCache = Object.create(null);
var refCache = Object.create(null);
var _PdfName = /** @class */ (function () {
    function _PdfName(name) {
        this.name = name;
    }
    _PdfName.get = function (name) {
        return nameCache[name] || (nameCache[name] = new _PdfName(name));
    };
    return _PdfName;
}());
var _PdfCommand = /** @class */ (function () {
    function _PdfCommand(command) {
        this.command = command;
    }
    _PdfCommand.get = function (command) {
        return cmdCache[command] || (cmdCache[command] = new _PdfCommand(command));
    };
    return _PdfCommand;
}());
var _PdfReference = /** @class */ (function () {
    function _PdfReference(objectNumber, gen) {
        this._isNew = false;
        this.objectNumber = objectNumber;
        this.generationNumber = gen;
    }
    _PdfReference.prototype.toString = function () {
        return this.objectNumber + " " + this.generationNumber;
    };
    _PdfReference.get = function (objectNumber, generationNumber) {
        var key = generationNumber === 0 ? objectNumber + "R" : objectNumber + "R" + generationNumber;
        return refCache[key] || (refCache[key] = new _PdfReference(objectNumber, generationNumber));
    };
    return _PdfReference;
}());
var _PdfReferenceSet = /** @class */ (function () {
    function _PdfReferenceSet(parent) {
        if (parent === void 0) { parent = null; }
        this._set = new Set(parent && parent._set);
    }
    _PdfReferenceSet.prototype.has = function (ref) {
        return this._set.has(ref.toString());
    };
    _PdfReferenceSet.prototype.put = function (ref) {
        this._set.add(ref.toString());
    };
    _PdfReferenceSet.prototype.remove = function (ref) {
        this._set.delete(ref.toString());
    };
    _PdfReferenceSet.prototype.clear = function () {
        this._set.clear();
    };
    return _PdfReferenceSet;
}());
var _PdfReferenceSetCache = /** @class */ (function () {
    function _PdfReferenceSetCache() {
        this._map = new Map();
    }
    Object.defineProperty(_PdfReferenceSetCache.prototype, "size", {
        get: function () {
            return this._map.size;
        },
        enumerable: true,
        configurable: true
    });
    _PdfReferenceSetCache.prototype.get = function (ref) {
        return this._map.get(ref.toString());
    };
    _PdfReferenceSetCache.prototype.has = function (ref) {
        return this._map.has(ref.toString());
    };
    _PdfReferenceSetCache.prototype.put = function (ref, obj) {
        this._map.set(ref.toString(), obj);
    };
    _PdfReferenceSetCache.prototype.set = function (objId, obj) {
        this._map.set(objId, obj);
    };
    _PdfReferenceSetCache.prototype.clear = function () {
        this._map.clear();
    };
    return _PdfReferenceSetCache;
}());
var Dictionary = /** @class */ (function () {
    function Dictionary(toStringFunction) {
        this.table = {};
        this.nElements = 0;
        this.toStr = toStringFunction || _defaultToString;
    }
    Dictionary.prototype.getValue = function (key) {
        var pair = this.table['$' + this.toStr(key)];
        if (typeof pair === 'undefined') {
            return undefined;
        }
        return pair.value;
    };
    Dictionary.prototype.setValue = function (key, value) {
        var ret;
        var k = '$' + this.toStr(key);
        var previousElement = this.table[k];
        this.nElements++;
        ret = undefined;
        this.table[k] = {
            key: key,
            value: value
        };
        return ret;
    };
    Dictionary.prototype.keys = function () {
        var keysArray = [];
        var namesOfKeys = Object.keys(this.table);
        for (var index1 = 0; index1 < namesOfKeys.length; index1++) {
            var pair1 = this.table[namesOfKeys[index1]];
            keysArray.push(pair1.key);
        }
        return keysArray;
    };
    Dictionary.prototype.containsKey = function (key) {
        var retutnValue = true;
        if (typeof this.getValue(key) === 'undefined') {
            retutnValue = true;
        }
        else {
            retutnValue = false;
        }
        return !retutnValue;
    };
    Dictionary.prototype._size = function () {
        return this.nElements;
    };
    return Dictionary;
}());
var _PdfDictionary = /** @class */ (function () {
    function _PdfDictionary(xref) {
        this._isFont = false;
        this._initialize(xref);
    }
    Object.defineProperty(_PdfDictionary.prototype, "size", {
        get: function () {
            return Object.keys(this._map).length;
        },
        enumerable: true,
        configurable: true
    });
    _PdfDictionary.prototype.assignXref = function (xref) {
        this._crossReference = xref;
    };
    _PdfDictionary.prototype.getRaw = function (key) {
        return this._map[key];
    };
    _PdfDictionary.prototype.getRawValues = function () {
        return this._map.values;
    };
    _PdfDictionary.prototype.get = function (key1, key2, key3) {
        var value = this._get(key1, key2, key3);
        if (this._crossReference && typeof value !== 'undefined' && value instanceof _PdfReference) {
            value = this._crossReference._fetch(value);
        }
        return value;
    };
    _PdfDictionary.prototype.getArray = function (key1, key2, key3) {
        var value = this.get(key1, key2, key3);
        if (this._crossReference && typeof value !== 'undefined' && Array.isArray(value)) {
            value = value.slice();
            for (var i = 0; i < value.length; i++) {
                var reference = value[Number.parseInt(i.toString(), 10)];
                if (reference !== null && typeof reference !== 'undefined' && reference instanceof _PdfReference) {
                    value[Number.parseInt(i.toString(), 10)] = this._crossReference._fetch(reference);
                }
            }
        }
        return value;
    };
    _PdfDictionary.prototype.set = function (key, value) {
        this._map[key] = value;
    };
    _PdfDictionary.prototype.has = function (key) {
        return typeof this._map[key] !== 'undefined';
    };
    _PdfDictionary.prototype.forEach = function (callback) {
        for (var key in this._map) {
            callback(key, this.getRaw(key));
        }
    };
    _PdfDictionary.prototype.update = function (key, value) {
        if (this.has(key)) {
            var prevValue = this._map[key];
            if (prevValue !== null && typeof prevValue !== 'undefined' && prevValue instanceof _PdfReference && this._crossReference) {
                prevValue = this._crossReference._fetch(prevValue);
            }
            if (prevValue !== value) {
                this._map[key] = value;
                this._updated = true;
            }
        }
        else {
            this._map[key] = value;
            this._updated = true;
        }
    };
    _PdfDictionary.getEmpty = function (xref) {
        var emptyDict = new _PdfDictionary(xref);
        emptyDict.set = function (key, value) {
            throw new Error('Should not call set on the empty dictionary.');
        };
        return emptyDict;
    };
    _PdfDictionary.merge = function (xref, dictionaryArray, mergeSubDictionary) {
        if (mergeSubDictionary === void 0) { mergeSubDictionary = false; }
        var mergedDictionary = new _PdfDictionary(xref);
        var properties = Object.create(null);
        for (var _i = 0, dictionaryArray_1 = dictionaryArray; _i < dictionaryArray_1.length; _i++) {
            var dictionary = dictionaryArray_1[_i];
            if (!(dictionary instanceof _PdfDictionary)) {
                continue;
            }
            for (var _a = 0, _b = dictionary._map; _a < _b.length; _a++) {
                var _c = _b[_a], key = _c[0], value = _c[1];
                var property = properties.get(key);
                if (typeof property === 'undefined') {
                    property = [];
                    properties.set(key, property);
                }
                else if (!mergeSubDictionary || !(value instanceof _PdfDictionary)) {
                    continue;
                }
                property.push(value);
            }
        }
        for (var _d = 0, properties_1 = properties; _d < properties_1.length; _d++) {
            var _e = properties_1[_d], name_1 = _e[0], values = _e[1];
            if (values.length === 1 || !(values[0] instanceof _PdfDictionary)) {
                mergedDictionary._map[name_1] = values[0];
                continue;
            }
            var subDict = new _PdfDictionary(xref);
            for (var _f = 0, values_1 = values; _f < values_1.length; _f++) {
                var dictionary = values_1[_f];
                for (var _g = 0, _h = dictionary._map; _g < _h.length; _g++) {
                    var _j = _h[_g], key = _j[0], value = _j[1];
                    if (typeof subDict._map[key] === 'undefined') {
                        subDict._map[key] = value;
                    }
                }
            }
            if (subDict.size > 0) {
                mergedDictionary._map[name_1] = subDict;
            }
        }
        properties.clear();
        return mergedDictionary.size > 0 ? mergedDictionary : _PdfDictionary.getEmpty(xref);
    };
    _PdfDictionary.prototype._initialize = function (xref) {
        this._map = Object.create(null);
        this.suppressEncryption = false;
        this._updated = false;
        this.isCatalog = false;
        this._isNew = false;
        if (xref) {
            this._crossReference = xref;
        }
    };
    _PdfDictionary.prototype._get = function (key1, key2, key3) {
        var value = this._map[key1];
        if (typeof value === 'undefined') {
            value = this._map[key2];
            if (typeof key2 !== 'undefined' && key2 !== null) {
                value = this._map[key2];
            }
            else if (typeof key3 !== 'undefined' && key3 !== null) {
                value = this._map[key3];
            }
        }
        return value;
    };
    return _PdfDictionary;
}());
var _PdfNull = /** @class */ (function () {
    function _PdfNull(value) {
        if (value === void 0) { value = []; }
        this.value = value;
    }
    return _PdfNull;
}());
function _clearPrimitiveCaches() {
    nameCache = Object.create(null);
    cmdCache = Object.create(null);
    refCache = Object.create(null);
}
function _isName(value, name) {
    return value instanceof _PdfName && (typeof name === 'undefined' || value.name === name);
}
function _isCommand(value, command) {
    return value instanceof _PdfCommand && (typeof command === 'undefined' || value.command === command);
}

var __extends$b = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _PdfBaseStream = /** @class */ (function () {
    function _PdfBaseStream() {
        this._isCompress = true;
        this._isImage = false;
    }
    _PdfBaseStream.prototype.getByte = function () {
        return null;
    };
    _PdfBaseStream.prototype.getBytes = function (length) {
        return null;
    };
    Object.defineProperty(_PdfBaseStream.prototype, "length", {
        get: function () {
            throw new Error('Abstract getter `length` accessed');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_PdfBaseStream.prototype, "isEmpty", {
        get: function () {
            throw new Error('Abstract getter `isEmpty` accessed');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_PdfBaseStream.prototype, "isDataLoaded", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    _PdfBaseStream.prototype.peekByte = function () {
        var peekedByte = this.getByte();
        if (peekedByte !== -1) {
            this.offset--;
        }
        return peekedByte;
    };
    _PdfBaseStream.prototype.peekBytes = function (length) {
        var bytes = this.getBytes(length);
        this.offset -= bytes.length;
        return bytes;
    };
    _PdfBaseStream.prototype.getUnsignedInteger16 = function () {
        var b0 = this.getByte();
        var b1 = this.getByte();
        if (b0 === -1 || b1 === -1) {
            return -1;
        }
        return (b0 << 8) + b1;
    };
    _PdfBaseStream.prototype.getInt32 = function () {
        var b0 = this.getByte();
        var b1 = this.getByte();
        var b2 = this.getByte();
        var b3 = this.getByte();
        return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    };
    _PdfBaseStream.prototype.getByteRange = function (begin, end) {
        return null;
    };
    _PdfBaseStream.prototype.makeSubStream = function (start, length, dictionary) {
        return null;
    };
    _PdfBaseStream.prototype.readBlock = function () {
        return null;
    };
    _PdfBaseStream.prototype.reset = function () {
        return null;
    };
    _PdfBaseStream.prototype.moveStart = function () {
        return null;
    };
    _PdfBaseStream.prototype.getString = function (isHex, bytes) {
        if (isHex === void 0) { isHex = false; }
        if (typeof bytes === 'undefined' || bytes === null) {
            bytes = this.getBytes();
        }
        if (isHex) {
            return _byteArrayToHexString(bytes);
        }
        else {
            return _bytesToString(bytes);
        }
    };
    _PdfBaseStream.prototype.skip = function (n) {
        this.offset += n || 1;
    };
    _PdfBaseStream.prototype.getBaseStreams = function () {
        return null;
    };
    return _PdfBaseStream;
}());
var _PdfStream = /** @class */ (function (_super) {
    __extends$b(_PdfStream, _super);
    function _PdfStream(arrayBuffer, dictionary, start, length) {
        var _this = _super.call(this) || this;
        _this.isImageStream = false;
        _this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
        if (typeof start !== 'undefined') {
            _this.start = start;
        }
        else {
            _this.start = 0;
        }
        _this.position = _this.start;
        _this.end = start + length || _this.bytes.length;
        _this.dictionary = dictionary;
        return _this;
    }
    Object.defineProperty(_PdfStream.prototype, "position", {
        /**
         * Gets the position of the stream.
         *
         * @returns {number} offset position.
         */
        get: function () {
            return this.offset;
        },
        /**
         * Sets the position of the stream.
         *
         * @param {number} value offset position.
         */
        set: function (value) {
            this.offset = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_PdfStream.prototype, "length", {
        /**
         * Gets the length of the stream (Read only).
         *
         * @returns {number} length.
         */
        get: function () {
            return this.end - this.start;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_PdfStream.prototype, "isEmpty", {
        /**
         * Gets a value indicating whether the stream is empty (Read only).
         *
         * @returns {boolean} stream empty or not.
         */
        get: function () {
            return this.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_PdfStream.prototype, "data", {
        /**
         * Gets the data of the stream.
         *
         * @returns {string[]} data of the stream.
         */
        get: function () {
            return this.dataStream2;
        },
        /**
         * Sets the data of the stream.
         *
         * @param {string[]} value data.
         */
        set: function (value) {
            this.dataStream2 = [];
            this.dataStream2 = value;
        },
        enumerable: true,
        configurable: true
    });
    _PdfStream.prototype.getByte = function () {
        if (this.position >= this.end) {
            return -1;
        }
        return this.bytes[this.position++];
    };
    _PdfStream.prototype.getBytes = function (length) {
        var bytes = this.bytes;
        var position = this.position;
        var strEnd = this.end;
        if (!length) {
            return bytes.subarray(position, strEnd);
        }
        var end = position + length;
        if (end > strEnd) {
            end = strEnd;
        }
        this.position = end;
        return bytes.subarray(position, end);
    };
    _PdfStream.prototype.getByteRange = function (begin, end) {
        if (begin < 0) {
            begin = 0;
        }
        if (end > this.end) {
            end = this.end;
        }
        return this.bytes.subarray(begin, end);
    };
    _PdfStream.prototype.reset = function () {
        this.position = this.start;
    };
    _PdfStream.prototype.moveStart = function () {
        this.start = this.position;
    };
    _PdfStream.prototype.makeSubStream = function (start, length, dictionary) {
        if (dictionary === void 0) { dictionary = null; }
        return new _PdfStream(this.bytes.buffer, dictionary, start, length);
    };
    _PdfStream.prototype.readBlock = function () {
        throw new Error('Abstract method `readBlock` called');
    };
    _PdfStream.prototype._clearStream = function () {
        if (this.dictionary !== null && typeof this.dictionary !== 'undefined' && this.dictionary.has('Filter')) {
            delete this.dictionary._map.Filter;
        }
        this._isCompress = true;
        this.dictionary._updated = true;
    };
    _PdfStream.prototype._write = function (text) {
        this.bytes = new Uint8Array(text.length);
        for (var i = 0; i < text.length; i++) {
            this.bytes[Number.parseInt(i.toString(), 10)] = text.charCodeAt(i);
        }
        this.end = this.bytes.length;
        this.dictionary._updated = true;
    };
    _PdfStream.prototype._writeBytes = function (data) {
        var text = '';
        for (var i = 0; i < data.length; i++) {
            text = text + String.fromCharCode(data[Number.parseInt(i.toString(), 10)]);
        }
        this.bytes = new Uint8Array(data);
        this.end = this.bytes.length;
        this.dictionary._updated = true;
    };
    return _PdfStream;
}(_PdfBaseStream));
var _PdfContentStream = /** @class */ (function (_super) {
    __extends$b(_PdfContentStream, _super);
    function _PdfContentStream(bytes) {
        var _this = _super.call(this) || this;
        if (_isNullOrUndefined(bytes)) {
            _this._bytes = bytes;
        }
        else {
            _this._bytes = [];
        }
        _this.dictionary = new _PdfDictionary();
        _this.dictionary._updated = true;
        return _this;
    }
    Object.defineProperty(_PdfContentStream.prototype, "length", {
        get: function () {
            return this._bytes.length;
        },
        enumerable: true,
        configurable: true
    });
    _PdfContentStream.prototype.write = function (data) {
        if (typeof data === 'string') {
            for (var i = 0; i < data.length; i++) {
                this._bytes.push(data.charCodeAt(i));
            }
        }
        else {
            for (var i = 0; i < data.length; i++) {
                this._bytes.push(data[Number.parseInt(i.toString(), 10)]);
            }
        }
        this.dictionary._updated = true;
    };
    _PdfContentStream.prototype.getString = function (isHex) {
        if (isHex === void 0) { isHex = false; }
        var bytes = new Uint8Array(this._bytes);
        if (typeof bytes === 'undefined' || bytes === null || typeof bytes.length === 'undefined') {
            throw new Error('Invalid argument for bytesToString');
        }
        if (isHex) {
            return _byteArrayToHexString(bytes);
        }
        else {
            var len = bytes.length;
            var max = 8192;
            if (len < max) {
                return String.fromCharCode.apply(null, bytes);
            }
            var stringBuffer = [];
            for (var i = 0; i < len; i += max) {
                stringBuffer.push(String.fromCharCode.apply(null, bytes.subarray(i, Math.min(i + max, len))));
            }
            return stringBuffer.join('');
        }
    };
    return _PdfContentStream;
}(_PdfBaseStream));
var _PdfNullStream = /** @class */ (function (_super) {
    __extends$b(_PdfNullStream, _super);
    function _PdfNullStream() {
        return _super.call(this, new Uint8Array(0)) || this;
    }
    return _PdfNullStream;
}(_PdfStream));

var _ContentParser = /** @class */ (function () {
    function _ContentParser(contentStream) {
        this._recordCollection = [];
        this._operands = [];
        this._lexer = new _ContentLexer(contentStream);
    }
    _ContentParser.prototype._readContent = function () {
        this._parseObject(_TokenType.eof);
        return this._recordCollection;
    };
    _ContentParser.prototype._parseObject = function (tokenType) {
        var symbol;
        while ((symbol = this._getNextToken()) !== _TokenType.eof) { // eslint-disable-line
            if (symbol === tokenType || symbol === _TokenType.none) {
                return;
            }
            switch (symbol) {
                case _TokenType.comment:
                    break;
                case _TokenType.number:
                    if (this._lexer._operatorParams === '-') {
                        this._operands.push('0');
                    }
                    else {
                        this._operands.push(this._lexer._operatorParams);
                    }
                    break;
                case _TokenType.real:
                    this._operands.push(this._lexer._operatorParams);
                    break;
                case _TokenType.string:
                case _TokenType.hexString:
                case _TokenType.unicodeHexString:
                case _TokenType.unicodeString:
                    this._operands.push(this._lexer._operatorParams);
                    break;
                case _TokenType.name:
                    this._operands.push(this._lexer._operatorParams);
                    break;
                case _TokenType.operator:
                    this._createRecord();
                    this._operands = [];
                    break;
                case _TokenType.beginArray:
                    break;
                case _TokenType.endArray:
                    throw new Error('Error while parsing content');
            }
        }
    };
    _ContentParser.prototype._createRecord = function () {
        var operand = this._lexer._operatorParams;
        var record = new _PdfRecord(operand, this._operands);
        record._splittedText = this._lexer._text;
        this._recordCollection.push(record);
    };
    _ContentParser.prototype._getNextToken = function () {
        return this._lexer._getNextToken();
    };
    return _ContentParser;
}());
var _ContentLexer = /** @class */ (function () {
    function _ContentLexer(data) {
        this._tokenType = _TokenType.none;
        this._currentCharacter = '\0';
        this._nextCharacter = '\0';
        this._offset = 0;
        this._text = [];
        this._data = data instanceof Uint8Array ? data : new Uint8Array(data);
    }
    _ContentLexer.prototype._getNextToken = function () {
        this._operatorParams = '';
        var value = this._moveToNextChar();
        switch (value) {
            case '%':
                return this._tokenType = this._getComment();
            case '/':
                return this._tokenType = this._getName();
            case '[':
            case '(':
                return this._tokenType = this._getLiteralString();
            case '+':
            case '-':
                return this._tokenType = this._getNumber();
            case '<':
                return this._tokenType = this._getEncodedDecimalString();
            case '.':
                return this._tokenType = this._getNumber();
            case '"':
            case '\'':
                return this._tokenType = this._getOperator();
        }
        if (!isNaN(parseInt(value, 10))) {
            return this._tokenType = this._getNumber();
        }
        if ((/[a-zA-Z]/).test(value)) {
            return this._tokenType = this._getOperator();
        }
        if (value === String.fromCharCode(65535)) {
            return this._tokenType = _TokenType.eof;
        }
        return this._tokenType = _TokenType.none;
    };
    _ContentLexer.prototype._getComment = function () {
        this._operatorParams = '';
        var value;
        var flag = (value = this._consumeValue()) !== '\x0A' && value !== String.fromCharCode(65535);
        while (flag) {
            flag = (value = this._consumeValue()) !== '\x0A' && value !== String.fromCharCode(65535);
        }
        return _TokenType.comment;
    };
    _ContentLexer.prototype._getName = function () {
        this._operatorParams = '';
        var flag = false;
        while (!flag) {
            var value = this._consumeValue();
            switch (value) {
                case '\0':
                case '\t':
                case '\x0A':
                case '\f':
                case '\x0D':
                case '\b':
                case ' ':
                case '%':
                case '(':
                case ')':
                case '<':
                case '>':
                case '[':
                case ']':
                case '/':
                    flag = true;
                    return _TokenType.name;
            }
        }
        return _TokenType.none;
    };
    _ContentLexer.prototype._getNumber = function () {
        var value = this._currentCharacter;
        if (value === '+' || value === '-') {
            this._operatorParams += this._currentCharacter;
            value = this._getNextChar();
        }
        while (!isNaN(parseInt(value, 10)) || value === '.') {
            if (!isNaN(parseInt(value, 10))) {
                this._operatorParams += this._currentCharacter;
            }
            else if (value === '.') {
                if (this._operatorParams.includes('.')) {
                    break;
                }
                else {
                    this._operatorParams += this._currentCharacter;
                }
            }
            value = this._getNextChar();
        }
        return _TokenType.number;
    };
    _ContentLexer.prototype._getOperator = function () {
        this._operatorParams = '';
        var value = this._currentCharacter;
        while (this._isOperator(value)) {
            value = this._consumeValue();
        }
        return _TokenType.operator;
    };
    _ContentLexer.prototype._isOperator = function (value) {
        if ((/[a-zA-Z]/).test(value)) {
            return true;
        }
        switch (value) {
            case '*':
            case '\'':
            case '\"': // eslint-disable-line
            case '1':
            case '0':
                return true;
        }
        return false;
    };
    _ContentLexer.prototype._getLiteralString = function () {
        this._operatorParams = '';
        var beginChar = this._currentCharacter;
        var literal;
        var value = this._consumeValue();
        var flag = true;
        var index = 0;
        var char = '';
        this._text = [];
        while (flag) {
            if (beginChar === '(') {
                literal = this._getLiteralStringValue(value);
                this._operatorParams += literal;
                value = this._getNextChar();
                flag = false;
                break;
            }
            else {
                if (value === '(') {
                    if (char !== '') {
                        this._text[Number.parseInt(index.toString(), 10)] = char.slice(0, -1);
                        char = '';
                        index++;
                    }
                    value = this._consumeValue();
                    literal = this._getLiteralStringValue(value);
                    this._text[Number.parseInt(index.toString(), 10)] = '(' + literal;
                    index++;
                    this._operatorParams += literal;
                    value = this._getNextChar();
                    char += value;
                    continue;
                }
                else if (value === ']') {
                    flag = false;
                    value = this._consumeValue();
                    break;
                }
                else if (value === '>') {
                    this._text[Number.parseInt(index.toString(), 10)] = '<' + char;
                    index++;
                    char = '';
                }
                else if (value === '<') {
                    if (char !== '') {
                        this._text[Number.parseInt(index.toString(), 10)] = char.slice(0, -1);
                        index++;
                    }
                    char = '';
                }
                value = this._consumeValue();
                char += value;
            }
        }
        return _TokenType.string;
    };
    _ContentLexer.prototype._getEncodedDecimalString = function () {
        var startChar = '<';
        var endChar = '>';
        var space = ' ';
        var parentLevel = 0;
        var value = this._consumeValue();
        var flag = true;
        while (flag) {
            if (value === startChar) {
                parentLevel++;
                value = this._consumeValue();
            }
            else if (value === endChar) {
                if (parentLevel === 0) {
                    this._consumeValue();
                    flag = false;
                    break;
                }
                else if (parentLevel === 1) {
                    value = this._consumeValue();
                    if (value === '>') {
                        parentLevel--;
                    }
                    if (parentLevel === 1 && value === space) {
                        flag = false;
                        break;
                    }
                }
                else {
                    if (value === '>') {
                        parentLevel--;
                    }
                    value = this._consumeValue();
                }
            }
            else {
                value = this._consumeValue();
                if (value === String.fromCharCode(65535)) {
                    flag = false;
                    break;
                }
            }
        }
        return _TokenType.hexString;
    };
    _ContentLexer.prototype._getLiteralStringValue = function (value) {
        var parenthesesCount = 0;
        var literal = '';
        var flag = true;
        while (flag) {
            if (value === '\\') {
                literal += value;
                value = this._getNextChar();
                literal += value;
                value = this._getNextChar();
                continue;
            }
            if (value === '(') {
                parenthesesCount++;
                literal += value;
                value = this._getNextChar();
                continue;
            }
            if (value === ')' && parenthesesCount !== 0) {
                literal += value;
                value = this._getNextChar();
                parenthesesCount--;
                continue;
            }
            if (value === ')' && parenthesesCount === 0) {
                literal += value;
                flag = false;
                return literal;
            }
            literal += value;
            value = this._getNextChar();
        }
        return literal;
    };
    _ContentLexer.prototype._consumeValue = function () {
        this._operatorParams += this._currentCharacter;
        return this._getNextChar();
    };
    _ContentLexer.prototype._moveToNextChar = function () {
        while (this._currentCharacter !== String.fromCharCode(65535)) {
            switch (this._currentCharacter) {
                case '\0':
                case '\t':
                case '\x0A':
                case '\f':
                case '\x0D':
                case '\b':
                case ' ':
                    this._getNextChar();
                    break;
                default:
                    return this._currentCharacter;
            }
        }
        return this._currentCharacter;
    };
    _ContentLexer.prototype._getNextChar = function () {
        if (this._data.length <= this._offset) {
            if (this._nextCharacter === 'Q' || (this._currentCharacter === 'D' && this._nextCharacter === 'o')) {
                this._currentCharacter = this._nextCharacter;
                this._nextCharacter = String.fromCharCode(65535);
                return this._currentCharacter;
            }
            this._currentCharacter = String.fromCharCode(65535);
            this._nextCharacter = String.fromCharCode(65535);
        }
        else {
            this._currentCharacter = this._nextCharacter;
            this._nextCharacter = String.fromCharCode(this._data[this._offset++]);
            if (this._currentCharacter === '\x0D') {
                if (this._nextCharacter === '\x0A') {
                    this._currentCharacter = this._nextCharacter;
                    if (this._data.length <= this._offset) {
                        this._nextCharacter = String.fromCharCode(65535);
                    }
                    else {
                        this._nextCharacter = String.fromCharCode(this._data[this._offset++]);
                    }
                }
                else {
                    this._currentCharacter = '\x0A';
                }
            }
        }
        return this._currentCharacter;
    };
    return _ContentLexer;
}());
var _PdfRecord = /** @class */ (function () {
    function _PdfRecord(operator, operands) {
        this._operator = operator;
        this._operands = operands;
    }
    return _PdfRecord;
}());

var __extends$c = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _PdfDecodeStream = /** @class */ (function (_super) {
    __extends$c(_PdfDecodeStream, _super);
    function _PdfDecodeStream(maybeMinBufferLength) {
        var _this = _super.call(this) || this;
        _this._rawMinBufferLength = maybeMinBufferLength || 0;
        _this.offset = 0;
        _this.bufferLength = 0;
        _this.eof = false;
        _this.buffer = new Uint8Array(0);
        _this.minBufferLength = 512;
        if (maybeMinBufferLength) {
            while (_this.minBufferLength < maybeMinBufferLength) {
                _this.minBufferLength *= 2;
            }
        }
        return _this;
    }
    Object.defineProperty(_PdfDecodeStream.prototype, "isEmpty", {
        get: function () {
            while (!this.eof && this.bufferLength === 0) {
                this.readBlock();
            }
            return this.bufferLength === 0;
        },
        enumerable: true,
        configurable: true
    });
    _PdfDecodeStream.prototype.ensureBuffer = function (requested) {
        var buffer = this.buffer;
        if (requested <= buffer.byteLength) {
            return buffer;
        }
        var size = this.minBufferLength;
        while (size < requested) {
            size *= 2;
        }
        var buffer2 = new Uint8Array(size);
        buffer2.set(buffer);
        this.buffer = buffer2;
        return this.buffer;
    };
    _PdfDecodeStream.prototype.getByte = function () {
        var position = this.offset;
        while (this.bufferLength <= position) {
            if (this.eof) {
                return -1;
            }
            this.readBlock();
        }
        return this.buffer[this.offset++];
    };
    _PdfDecodeStream.prototype.getBytes = function (length) {
        var position = this.offset;
        var end;
        if (length) {
            this.ensureBuffer(position + length);
            end = position + length;
            while (!this.eof && this.bufferLength < end) {
                this.readBlock();
            }
            var bufEnd = this.bufferLength;
            if (end > bufEnd) {
                end = bufEnd;
            }
        }
        else {
            while (!this.eof) {
                this.readBlock();
            }
            end = this.bufferLength;
        }
        this.offset = end;
        return this.buffer.subarray(position, end);
    };
    _PdfDecodeStream.prototype.reset = function () {
        this.offset = 0;
    };
    _PdfDecodeStream.prototype.makeSubStream = function (start, length, dictionary) {
        if (length === undefined) {
            while (!this.eof) {
                this.readBlock();
            }
        }
        else {
            var end = start + length;
            while (this.bufferLength <= end && !this.eof) {
                this.readBlock();
            }
        }
        return new _PdfStream(this.buffer, dictionary, start, length);
    };
    _PdfDecodeStream.prototype.getBaseStreams = function () {
        return this.stream ? this.stream.getBaseStreams() : null;
    };
    _PdfDecodeStream.prototype.moveStart = function () {
        throw new Error('Invalid call from decode stream');
    };
    _PdfDecodeStream.prototype.getByteRange = function (begin, end) {
        throw new Error('Invalid call from decode stream. begin: ' + begin + ', end: ' + end);
    };
    _PdfDecodeStream.prototype.readBlock = function () {
        throw new Error('Invalid call from decode stream');
    };
    return _PdfDecodeStream;
}(_PdfBaseStream));

var __extends$d = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _PdfDecryptStream = /** @class */ (function (_super) {
    __extends$d(_PdfDecryptStream, _super);
    function _PdfDecryptStream(stream, maybeLength, cipher) {
        var _this = _super.call(this, maybeLength) || this;
        _this._chunkSize = 512;
        _this.stream = stream;
        _this.dictionary = stream.dictionary;
        _this._cipher = cipher;
        _this._nextChunk = null;
        _this._initialized = false;
        return _this;
    }
    _PdfDecryptStream.prototype.readBlock = function () {
        var chunk;
        if (this._initialized) {
            chunk = this._nextChunk;
        }
        else {
            chunk = this.stream.getBytes(this._chunkSize);
            this._initialized = true;
        }
        if (!chunk || chunk.length === 0) {
            this.eof = true;
            return;
        }
        this._nextChunk = this.stream.getBytes(this._chunkSize);
        var hasMoreData = this._nextChunk && this._nextChunk.length > 0;
        chunk = this._cipher._decryptBlock(chunk, !hasMoreData);
        var bufferLength = this.bufferLength;
        var n = chunk.length;
        var buffer = this.ensureBuffer(bufferLength + n);
        for (var i = 0; i < n; i++) {
            buffer[bufferLength++] = chunk[Number.parseInt(i.toString(), 10)];
        }
        this.bufferLength = bufferLength;
    };
    return _PdfDecryptStream;
}(_PdfDecodeStream));

var __extends$e = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var codeLenCodeMap = new Int32Array([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
]);
var lengthDecode = new Int32Array([
    0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a,
    0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f,
    0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073,
    0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102
]);
var distDecode = new Int32Array([
    0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d,
    0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1,
    0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01,
    0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001
]);
var fixedLitCodeTab = [
    new Int32Array([
        0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0,
        0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0,
        0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0,
        0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0,
        0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8,
        0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8,
        0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8,
        0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8,
        0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4,
        0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4,
        0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4,
        0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4,
        0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc,
        0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec,
        0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc,
        0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc,
        0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2,
        0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2,
        0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2,
        0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2,
        0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca,
        0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea,
        0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da,
        0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa,
        0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6,
        0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6,
        0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6,
        0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6,
        0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce,
        0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee,
        0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de,
        0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe,
        0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1,
        0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1,
        0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1,
        0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1,
        0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9,
        0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9,
        0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9,
        0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9,
        0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5,
        0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5,
        0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5,
        0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5,
        0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd,
        0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed,
        0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd,
        0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd,
        0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3,
        0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3,
        0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3,
        0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3,
        0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb,
        0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb,
        0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db,
        0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb,
        0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7,
        0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7,
        0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7,
        0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7,
        0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf,
        0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef,
        0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df,
        0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff
    ]),
    9
];
var fixedDistCodeTab = [
    new Int32Array([
        0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c,
        0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000,
        0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d,
        0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000
    ]),
    5
];
var _PdfFlateStream = /** @class */ (function (_super) {
    __extends$e(_PdfFlateStream, _super);
    function _PdfFlateStream(stream, maybeLength) {
        var _this = _super.call(this, maybeLength) || this;
        _this.stream = stream;
        _this.dictionary = stream.dictionary;
        var cmf = stream.getByte();
        var flg = stream.getByte();
        if ((cmf & 0x0f) !== 0x08) {
            throw new FormatError("Unknown compression method in flate stream: " + cmf + ", " + flg);
        }
        if (((cmf << 8) + flg) % 31 !== 0) {
            throw new FormatError("Bad flag check in flate stream: " + cmf + ", " + flg);
        }
        if (flg & 0x20) {
            throw new FormatError("Bad flag bit set in flate stream: " + cmf + ", " + flg);
        }
        _this.codeSize = 0;
        _this.codeBuffer = 0;
        return _this;
    }
    _PdfFlateStream.prototype.getBits = function (bits) {
        var stream = this.stream;
        var codeSize = this.codeSize;
        var codeBuffer = this.codeBuffer;
        var b;
        while (codeSize < bits) {
            b = stream.getByte();
            codeBuffer |= b << codeSize;
            codeSize += 8;
        }
        b = codeBuffer & ((1 << bits) - 1);
        this.codeBuffer = codeBuffer >> bits;
        this.codeSize = codeSize -= bits;
        return b;
    };
    _PdfFlateStream.prototype.getCode = function (table) {
        var stream = this.stream;
        var codes = table[0];
        var maxLen = table[1];
        var codeSize = this.codeSize;
        var codeBuffer = this.codeBuffer;
        var b;
        while (codeSize < maxLen) {
            b = stream.getByte();
            codeBuffer |= b << codeSize;
            codeSize += 8;
        }
        var code = codes[codeBuffer & ((1 << maxLen) - 1)];
        var codeLen = code >> 16;
        var codeVal = code & 0xffff;
        if (!(codeLen < 1 || codeSize < codeLen)) {
            this.codeBuffer = codeBuffer >> codeLen;
            this.codeSize = codeSize - codeLen;
        }
        return codeVal;
    };
    _PdfFlateStream.prototype.generateHuffmanTable = function (lengths) {
        var n = lengths.length;
        var maximumLength = 0;
        var i;
        for (i = 0; i < n; ++i) {
            if (lengths[i] > maximumLength) { // eslint-disable-line
                maximumLength = lengths[i]; // eslint-disable-line
            }
        }
        var size = 1 << maximumLength;
        var codes = new Int32Array(size);
        for (var len = 1, code = 0, skip = 2; len <= maximumLength; ++len, code <<= 1, skip <<= 1) {
            for (var val = 0; val < n; ++val) {
                if (lengths[val] === len) { // eslint-disable-line
                    var code2 = 0;
                    var t = code;
                    for (i = 0; i < len; ++i) {
                        code2 = (code2 << 1) | (t & 1);
                        t >>= 1;
                    }
                    for (i = code2; i < size; i += skip) {
                        codes[i] = (len << 16) | val; // eslint-disable-line
                    }
                    ++code;
                }
            }
        }
        return [codes, maximumLength];
    };
    _PdfFlateStream.prototype.readBlock = function () {
        var buffer;
        var length;
        var stream = this.stream;
        var hdr = this.getBits(3);
        if (hdr & 1) {
            this.eof = true;
        }
        hdr >>= 1;
        if (hdr === 0) {
            var b = stream.getByte();
            var blockLen = b;
            b = stream.getByte();
            blockLen |= b << 8;
            b = stream.getByte();
            var check = b;
            b = stream.getByte();
            check |= b << 8;
            if (!(check !== (~blockLen & 0xffff) && (blockLen !== 0 || check !== 0))) {
                this.codeBuffer = 0;
                this.codeSize = 0;
                var bufferLength = this.bufferLength;
                var end = bufferLength + blockLen;
                buffer = this.ensureBuffer(end);
                this.bufferLength = end;
                if (blockLen === 0) {
                    if (stream.peekByte() === -1) {
                        this.eof = true;
                    }
                }
                else {
                    var block = stream.getBytes(blockLen);
                    buffer.set(block, bufferLength);
                    if (block.length < blockLen) {
                        this.eof = true;
                    }
                }
                return;
            }
        }
        var litCodeTable;
        var distCodeTable;
        if (hdr === 1) {
            litCodeTable = fixedLitCodeTab;
            distCodeTable = fixedDistCodeTab;
        }
        else if (hdr === 2) {
            var numLitCodes = this.getBits(5) + 257;
            var numDistCodes = this.getBits(5) + 1;
            var numCodeLenCodes = this.getBits(4) + 4;
            var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
            var i = void 0;
            for (i = 0; i < numCodeLenCodes; ++i) {
                codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3); // eslint-disable-line
            }
            var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
            length = 0;
            i = 0;
            var codes = numLitCodes + numDistCodes;
            var codeLengths = new Uint8Array(codes);
            var bitsLength = void 0;
            var bitsOffset = void 0;
            var what = void 0;
            while (i < codes) {
                var code = this.getCode(codeLenCodeTab);
                if (code === 16) {
                    bitsLength = 2;
                    bitsOffset = 3;
                    what = length;
                }
                else if (code === 17) {
                    bitsLength = 3;
                    bitsOffset = 3;
                    what = length = 0;
                }
                else if (code === 18) {
                    bitsLength = 7;
                    bitsOffset = 11;
                    what = length = 0;
                }
                else {
                    codeLengths[i++] = length = code;
                    continue;
                }
                var repeatLength = this.getBits(bitsLength) + bitsOffset;
                while (repeatLength-- > 0) {
                    codeLengths[i++] = what;
                }
            }
            litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
            distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
        }
        buffer = this.buffer;
        var limit = buffer ? buffer.length : 0;
        var position = this.bufferLength;
        while (true) { // eslint-disable-line
            var code1 = this.getCode(litCodeTable);
            if (code1 < 256) {
                if (position + 1 >= limit) {
                    buffer = this.ensureBuffer(position + 1);
                    limit = buffer.length;
                }
                buffer[position++] = code1;
                continue;
            }
            if (code1 === 256) {
                this.bufferLength = position;
                return;
            }
            code1 -= 257;
            code1 = lengthDecode[code1]; // eslint-disable-line
            var code2 = code1 >> 16;
            if (code2 > 0) {
                code2 = this.getBits(code2);
            }
            length = (code1 & 0xffff) + code2;
            code1 = this.getCode(distCodeTable);
            code1 = distDecode[code1]; // eslint-disable-line
            code2 = code1 >> 16;
            if (code2 > 0) {
                code2 = this.getBits(code2);
            }
            var dist = (code1 & 0xffff) + code2;
            if (position + length >= limit) {
                buffer = this.ensureBuffer(position + length);
                limit = buffer.length;
            }
            for (var k = 0; k < length; ++k, ++position) {
                buffer[position] = buffer[position - dist]; // eslint-disable-line
            }
        }
    };
    return _PdfFlateStream;
}(_PdfDecodeStream));

var _PdfCatalog = /** @class */ (function () {
    function _PdfCatalog(xref) {
        this._crossReference = xref;
        this._catalogDictionary = xref._getCatalogObj();
        if (!(this._catalogDictionary instanceof _PdfDictionary)) {
            throw new FormatError('Catalog object is not a dictionary.');
        }
        else {
            this._catalogDictionary.isCatalog = true;
        }
        this._topPagesDictionary = this._catalogDictionary.get('Pages');
        this.pageKidsCountCache = new _PdfReferenceSetCache();
        this.pageIndexCache = new _PdfReferenceSetCache();
    }
    Object.defineProperty(_PdfCatalog.prototype, "version", {
        get: function () {
            var value;
            if (this._catalogDictionary.has('Version')) {
                var version = this._catalogDictionary.get('Version');
                if (version) {
                    value = version.name;
                }
            }
            return value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_PdfCatalog.prototype, "pageCount", {
        get: function () {
            var obj = this._topPagesDictionary.get('Count');
            if (typeof obj === 'undefined' || !Number.isInteger(obj)) {
                throw new FormatError('Invalid page count');
            }
            return obj;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_PdfCatalog.prototype, "acroForm", {
        get: function () {
            var form;
            if (this._catalogDictionary.has('AcroForm')) {
                form = this._catalogDictionary.get('AcroForm');
            }
            if (form === null || typeof form === 'undefined') {
                form = this._createForm();
            }
            return form;
        },
        enumerable: true,
        configurable: true
    });
    /* eslint-disable */
    _PdfCatalog.prototype._createForm = function () {
        var form = new _PdfDictionary(this._crossReference);
        var ref = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(ref, form);
        this._catalogDictionary.set('AcroForm', ref);
        this._catalogDictionary._updated = true;
        this._crossReference._allowCatalog = true;
        form._updated = true;
        return form;
    };
    _PdfCatalog.prototype.getPageDictionary = function (pageIndex) {
        var nodesToVisit = [this._topPagesDictionary];
        var visitedNodes = new _PdfReferenceSet();
        var pagesRef = this._catalogDictionary.getRaw('Pages');
        if (pagesRef && pagesRef instanceof _PdfReference) {
            visitedNodes.put(pagesRef);
        }
        var xref = this._crossReference;
        var pageKidsCountCache = this.pageKidsCountCache;
        var pageIndexCache = this.pageIndexCache;
        var currentPageIndex = 0;
        while (nodesToVisit.length > 0) {
            var currentNode = nodesToVisit.pop();
            if (currentNode !== null && typeof currentNode !== 'undefined' && currentNode instanceof _PdfReference) {
                var count_1 = pageKidsCountCache.get(currentNode);
                if (count_1 >= 0 && currentPageIndex + count_1 <= pageIndex) {
                    currentPageIndex += count_1;
                    continue;
                }
                if (visitedNodes.has(currentNode)) {
                    throw new FormatError('Pages tree contains circular reference.');
                }
                visitedNodes.put(currentNode);
                var obj = xref._fetch(currentNode);
                if (obj && obj instanceof _PdfDictionary) {
                    var type = obj.getRaw('Type');
                    if (type !== null && typeof type !== 'undefined' && type instanceof _PdfReference) {
                        type = xref._fetch(type);
                    }
                    if (_isName(type, 'Page') || !obj.has('Kids')) {
                        if (!pageKidsCountCache.has(currentNode)) {
                            pageKidsCountCache.put(currentNode, 1);
                        }
                        if (!pageIndexCache.has(currentNode)) {
                            pageIndexCache.put(currentNode, currentPageIndex);
                        }
                        if (currentPageIndex === pageIndex) {
                            return { dictionary: obj, reference: currentNode };
                        }
                        currentPageIndex++;
                        continue;
                    }
                }
                nodesToVisit.push(obj);
                continue;
            }
            if (!(currentNode instanceof _PdfDictionary)) {
                throw new FormatError('Page dictionary kid reference points to wrong type of object.');
            }
            var objId = currentNode.objId;
            var count = currentNode.get('Count');
            if (count !== null && typeof count !== 'undefined' && count instanceof _PdfReference) {
                count = xref._fetch(count);
            }
            if (count !== null && typeof count !== 'undefined' && Number.isInteger(count) && count >= 0) {
                if (objId && !pageKidsCountCache.has(objId)) {
                    pageKidsCountCache.set(objId, count);
                }
                if (currentPageIndex + count <= pageIndex) {
                    currentPageIndex += count;
                    continue;
                }
            }
            var kids = currentNode.getRaw('Kids');
            if (kids !== null && typeof kids !== 'undefined' && kids instanceof _PdfReference) {
                kids = xref._fetch(kids);
            }
            if (!Array.isArray(kids)) {
                var type = currentNode.getRaw('Type');
                if (type !== null && typeof type !== 'undefined' && type instanceof _PdfReference) {
                    type = xref._fetch(type);
                }
                if (_isName(type, 'Page') || !currentNode.has('Kids')) {
                    if (currentPageIndex === pageIndex) {
                        return { dictionary: currentNode, reference: null };
                    }
                    currentPageIndex++;
                    continue;
                }
                throw new FormatError('Page dictionary kids object is not an array.');
            }
            for (var last = kids.length - 1; last >= 0; last--) {
                nodesToVisit.push(kids[last]);
            }
        }
        throw new Error("Page index " + pageIndex + " not found.");
    };
    _PdfCatalog.prototype._destroy = function () {
        if (this._catalogDictionary) {
            this._catalogDictionary = undefined;
        }
        if (this._topPagesDictionary) {
            this._topPagesDictionary = undefined;
        }
        if (this.pageIndexCache) {
            this.pageIndexCache.clear();
            this.pageIndexCache = undefined;
        }
        if (this.pageKidsCountCache) {
            this.pageKidsCountCache.clear();
            this.pageKidsCountCache = undefined;
        }
    };
    return _PdfCatalog;
}());

var __extends$f = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PdfPredictorStream = /** @class */ (function (_super) {
    __extends$f(PdfPredictorStream, _super);
    function PdfPredictorStream(stream, maybeLength, params) {
        var _this = _super.call(this, maybeLength) || this;
        if (!(params instanceof _PdfDictionary)) {
            return stream;
        }
        var predictor = (_this.predictor = params.get('Predictor') || 1);
        if (predictor <= 1) {
            return stream;
        }
        if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
            throw new FormatError("Unsupported predictor: " + predictor);
        }
        if (predictor === 2) {
            _this.readBlock = _this.readBlockTiff;
        }
        else {
            _this.readBlock = _this.readBlockPng;
        }
        _this.stream = stream;
        _this.dictionary = stream.dictionary;
        var colors = (_this.colors = params.get('Colors') || 1);
        var bits = (_this.bits = params.get('BPC', 'BitsPerComponent') || 8);
        var columns = (_this.columns = params.get('Columns') || 1);
        _this.pixBytes = (colors * bits + 7) >> 3;
        _this.rowBytes = (columns * colors * bits + 7) >> 3;
        return _this;
    }
    PdfPredictorStream.prototype.readBlockTiff = function () {
        var rowBytes = this.rowBytes;
        var bufferLength = this.bufferLength;
        var buffer = this.ensureBuffer(bufferLength + rowBytes);
        var bits = this.bits;
        var colors = this.colors;
        var rawBytes = this.stream.getBytes(rowBytes);
        this.eof = !rawBytes.length;
        if (this.eof) {
            return;
        }
        var inbuf = 0;
        var outbuf = 0;
        var inbits = 0;
        var outbits = 0;
        var position = bufferLength;
        var i;
        if (bits === 1 && colors === 1) {
            for (i = 0; i < rowBytes; ++i) {
                var c = rawBytes[i] ^ inbuf; // eslint-disable-line
                c ^= c >> 1;
                c ^= c >> 2;
                c ^= c >> 4;
                inbuf = (c & 1) << 7;
                buffer[position++] = c;
            }
        }
        else if (bits === 8) {
            for (i = 0; i < colors; ++i) {
                buffer[position++] = rawBytes[i]; // eslint-disable-line
            }
            for (; i < rowBytes; ++i) {
                buffer[position] = buffer[position - colors] + rawBytes[i]; // eslint-disable-line
                position++;
            }
        }
        else if (bits === 16) {
            var bytesPerPixel = colors * 2;
            for (i = 0; i < bytesPerPixel; ++i) {
                buffer[position++] = rawBytes[i]; // eslint-disable-line
            }
            for (; i < rowBytes; i += 2) {
                var sum = ((rawBytes[i] & 0xff) << 8) + // eslint-disable-line
                    (rawBytes[i + 1] & 0xff) +
                    ((buffer[position - bytesPerPixel] & 0xff) << 8) +
                    (buffer[position - bytesPerPixel + 1] & 0xff);
                buffer[position++] = (sum >> 8) & 0xff;
                buffer[position++] = sum & 0xff;
            }
        }
        else {
            var compArray = new Uint8Array(colors + 1);
            var bitMask = (1 << bits) - 1;
            var j = 0;
            var k = bufferLength;
            var columns = this.columns;
            for (i = 0; i < columns; ++i) {
                for (var kk = 0; kk < colors; ++kk) {
                    if (inbits < bits) {
                        inbuf = (inbuf << 8) | (rawBytes[j++] & 0xff);
                        inbits += 8;
                    }
                    compArray[kk] = (compArray[kk] + (inbuf >> (inbits - bits))) & bitMask; // eslint-disable-line
                    inbits -= bits;
                    outbuf = (outbuf << bits) | compArray[kk]; // eslint-disable-line
                    outbits += bits;
                    if (outbits >= 8) {
                        buffer[k++] = (outbuf >> (outbits - 8)) & 0xff;
                        outbits -= 8;
                    }
                }
            }
            if (outbits > 0) {
                buffer[k++] = (outbuf << (8 - outbits)) + (inbuf & ((1 << (8 - outbits)) - 1));
            }
        }
        this.bufferLength += rowBytes;
    };
    PdfPredictorStream.prototype.readBlockPng = function () {
        var rowBytes = this.rowBytes;
        var pixBytes = this.pixBytes;
        var predictor = this.stream.getByte();
        var rawBytes = this.stream.getBytes(rowBytes);
        this.eof = !rawBytes.length;
        if (this.eof) {
            return;
        }
        var bufferLength = this.bufferLength;
        var buffer = this.ensureBuffer(bufferLength + rowBytes);
        var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
        if (prevRow.length === 0) {
            prevRow = new Uint8Array(rowBytes);
        }
        var i;
        var j = bufferLength;
        var up;
        var c;
        switch (predictor) {
            case 0:
                for (i = 0; i < rowBytes; ++i) {
                    buffer[j++] = rawBytes[i]; // eslint-disable-line
                }
                break;
            case 1:
                for (i = 0; i < pixBytes; ++i) {
                    buffer[j++] = rawBytes[i]; // eslint-disable-line
                }
                for (; i < rowBytes; ++i) {
                    buffer[j] = (buffer[j - pixBytes] + rawBytes[i]) & 0xff; // eslint-disable-line
                    j++;
                }
                break;
            case 2:
                for (i = 0; i < rowBytes; ++i) {
                    buffer[j++] = (prevRow[i] + rawBytes[i]) & 0xff; // eslint-disable-line
                }
                break;
            case 3:
                for (i = 0; i < pixBytes; ++i) {
                    buffer[j++] = (prevRow[i] >> 1) + rawBytes[i]; // eslint-disable-line
                }
                for (; i < rowBytes; ++i) {
                    buffer[j] = (((prevRow[i] + buffer[j - pixBytes]) >> 1) + rawBytes[i]) & 0xff; // eslint-disable-line
                    j++;
                }
                break;
            case 4:
                for (i = 0; i < pixBytes; ++i) {
                    up = prevRow[i]; // eslint-disable-line
                    c = rawBytes[i]; // eslint-disable-line
                    buffer[j++] = up + c;
                }
                for (; i < rowBytes; ++i) {
                    up = prevRow[i]; // eslint-disable-line
                    var upLeft = prevRow[i - pixBytes];
                    var left = buffer[j - pixBytes];
                    var p = left + up - upLeft;
                    var pa = p - left;
                    if (pa < 0) {
                        pa = -pa;
                    }
                    var pb = p - up;
                    if (pb < 0) {
                        pb = -pb;
                    }
                    var pc = p - upLeft;
                    if (pc < 0) {
                        pc = -pc;
                    }
                    c = rawBytes[i]; // eslint-disable-line
                    if (pa <= pb && pa <= pc) {
                        buffer[j++] = left + c;
                    }
                    else if (pb <= pc) {
                        buffer[j++] = up + c;
                    }
                    else {
                        buffer[j++] = upLeft + c;
                    }
                }
                break;
            default:
                throw new FormatError("Unsupported predictor: " + predictor);
        }
        this.bufferLength += rowBytes;
    };
    return PdfPredictorStream;
}(_PdfDecodeStream));

var __extends$g = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _PdfEncryptor = /** @class */ (function () {
    function _PdfEncryptor(dictionary, id, password) {
        if (password === void 0) { password = ''; }
        this._isUserPassword = true;
        this._hasUserPasswordOnly = false;
        this._encryptOnlyAttachment = false;
        this._encryptMetaData = true;
        this._defaultPasswordBytes = new Uint8Array([0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41, 0x64, 0x00, 0x4e, 0x56, 0xff,
            0xfa, 0x01, 0x08, 0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80, 0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a]);
        var filter = dictionary.get('Filter');
        if (!_isName(filter, 'Standard')) {
            throw new FormatError('unknown encryption method');
        }
        this._filterName = filter.name;
        this._dictionary = dictionary;
        var algorithm = dictionary.get('V');
        if (!Number.isInteger(algorithm) || (algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5)) {
            throw new FormatError('unsupported encryption algorithm');
        }
        this._algorithm = algorithm;
        var keyLength = dictionary.get('Length');
        if (!keyLength) {
            if (algorithm <= 3) {
                keyLength = 40;
            }
            else {
                var cfDictionary = dictionary.get('CF');
                var streamCryptoName = dictionary.get('StmF');
                if (cfDictionary && streamCryptoName) {
                    cfDictionary.suppressEncryption = true;
                    var handlerDictionary = cfDictionary.get(streamCryptoName.name);
                    keyLength = (handlerDictionary && handlerDictionary.get('Length')) || 128;
                    if (keyLength < 40) {
                        keyLength <<= 3;
                    }
                }
            }
        }
        if (!Number.isInteger(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {
            throw new FormatError('invalid key length');
        }
        var ownerPassword = _stringToBytes(dictionary.get('O'), false, true).subarray(0, 32);
        var userPassword = _stringToBytes(dictionary.get('U'), false, true).subarray(0, 32);
        var flag = dictionary.get('P');
        var revision = dictionary.get('R');
        this._encryptMetaData = (algorithm === 4 || algorithm === 5) && dictionary.get('EncryptMetadata') !== false;
        var fileIdBytes = _stringToBytes(id, false, true);
        var passwordBytes;
        if (password) {
            if (revision === 6) {
                password = encodeURIComponent(password);
            }
            passwordBytes = _stringToBytes(password, false, true);
        }
        var encryptionKey;
        if (algorithm !== 5) {
            encryptionKey = this._prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flag, revision, keyLength, this._encryptMetaData);
            if (encryptionKey) {
                this._isUserPassword = true;
                if (password) {
                    var decodedPassword = this._decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
                    var ownerEncryptionKey = this._prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flag, revision, keyLength, this._encryptMetaData);
                    if (ownerEncryptionKey && _areArrayEqual(ownerEncryptionKey, encryptionKey)) {
                        this._hasUserPasswordOnly = true;
                    }
                }
            }
        }
        else {
            var ownerValidationKey = _stringToBytes(dictionary.get('O'), false, true);
            var ownerValidationSalt = ownerValidationKey.subarray(32, 40);
            var ownerKeySalt = ownerValidationKey.subarray(40, 48);
            var userValidationKey = _stringToBytes(dictionary.get('U'), false, true);
            var uBytes = userValidationKey.subarray(0, 48);
            var userValidationSalt = userValidationKey.subarray(32, 40);
            var userKeySalt = userValidationKey.subarray(40, 48);
            var ownerEncryption = _stringToBytes(dictionary.get('OE'), false, true);
            var userEncryption = _stringToBytes(dictionary.get('UE'), false, true);
            var algorithm_1;
            if (revision === 6) {
                algorithm_1 = new _AdvancedEncryption();
            }
            else {
                algorithm_1 = new _BasicEncryption();
            }
            var p = void 0;
            if (passwordBytes) {
                p = passwordBytes.subarray(0, Math.min(127, passwordBytes.length));
            }
            else {
                p = new Uint8Array([]);
            }
            if (algorithm_1._checkUserPassword(p, userValidationSalt, userPassword)) {
                encryptionKey = this._createEncryptionKey(true, p, ownerKeySalt, uBytes, userKeySalt, ownerEncryption, userEncryption, algorithm_1);
                this._isUserPassword = true;
                if (password.length && algorithm_1._checkOwnerPassword(p, ownerValidationSalt, uBytes, ownerPassword)) {
                    this._hasUserPasswordOnly = true;
                }
            }
            else if (password.length && algorithm_1._checkOwnerPassword(p, ownerValidationSalt, uBytes, ownerPassword)) {
                encryptionKey = this._createEncryptionKey(false, passwordBytes, ownerKeySalt, uBytes, userKeySalt, ownerEncryption, userEncryption, algorithm_1);
                this._isUserPassword = false;
            }
        }
        if (!encryptionKey) {
            if (password) {
                var decodedPassword = this._decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
                encryptionKey = this._prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flag, revision, keyLength, this._encryptMetaData);
                this._isUserPassword = false;
            }
            else {
                throw new Error('Cannot open an encrypted document. The password is invalid.');
            }
        }
        if (algorithm >= 4) {
            var cipherDictionary = dictionary.get('CF');
            if (cipherDictionary) {
                cipherDictionary.suppressEncryption = true;
                if (cipherDictionary.has('StdCF')) {
                    var standardCryptFilter = cipherDictionary.get('StdCF');
                    if (standardCryptFilter && standardCryptFilter.has('AuthEvent')) {
                        var event_1 = standardCryptFilter.get('AuthEvent');
                        if (event_1 && event_1.name === 'EFOpen') {
                            this._encryptOnlyAttachment = true;
                        }
                    }
                }
            }
            this._cipherDictionary = cipherDictionary;
            this._stream = dictionary.get('StmF') || _PdfName.get('Identity');
            this._string = dictionary.get('StrF') || _PdfName.get('Identity');
            this._eff = dictionary.get('EFF') || this._stream;
        }
        if (!encryptionKey && !this._encryptOnlyAttachment) {
            throw new Error('Cannot open an encrypted document. The password is invalid.');
        }
        this._encryptionKey = encryptionKey;
    }
    Object.defineProperty(_PdfEncryptor.prototype, "_md5", {
        get: function () {
            if (typeof this._messageDigest === 'undefined') {
                this._messageDigest = new _MD5();
            }
            return this._messageDigest;
        },
        enumerable: true,
        configurable: true
    });
    _PdfEncryptor.prototype._createEncryptionKey = function (isUserKey, password, ownerKeySalt, uBytes, userKeySalt, ownerEncryption, userEncryption, algorithm) {
        if (isUserKey) {
            return algorithm._getUserKey(password, userKeySalt, userEncryption);
        }
        else {
            return algorithm._getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
        }
    };
    _PdfEncryptor.prototype._prepareKeyData = function (id, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetaData) {
        var hashData = new Uint8Array(40 + ownerPassword.length + id.length);
        var i = 0;
        var j = 0;
        var n;
        if (password) {
            n = Math.min(32, password.length);
            for (; i < n; ++i) {
                hashData[Number.parseInt(i.toString(), 10)] = password[Number.parseInt(i.toString(), 10)];
            }
        }
        while (i < 32) {
            hashData[i++] = this._defaultPasswordBytes[j++];
        }
        for (j = 0, n = ownerPassword.length; j < n; ++j) {
            hashData[i++] = ownerPassword[Number.parseInt(j.toString(), 10)];
        }
        hashData[i++] = flags & 0xff;
        hashData[i++] = (flags >> 8) & 0xff;
        hashData[i++] = (flags >> 16) & 0xff;
        hashData[i++] = (flags >>> 24) & 0xff;
        for (j = 0, n = id.length; j < n; ++j) {
            hashData[i++] = id[Number.parseInt(j.toString(), 10)];
        }
        if (revision >= 4 && !encryptMetaData) {
            hashData[i++] = 0xff;
            hashData[i++] = 0xff;
            hashData[i++] = 0xff;
            hashData[i++] = 0xff;
        }
        var hash = this._md5.hash(hashData, 0, i);
        var keyLengthInBytes = keyLength >> 3;
        if (revision >= 3) {
            for (j = 0; j < 50; ++j) {
                hash = this._md5.hash(hash, 0, keyLengthInBytes);
            }
        }
        var encryptionKey = hash.subarray(0, keyLengthInBytes);
        var cipher;
        var checkData;
        if (revision >= 3) {
            for (i = 0; i < 32; ++i) {
                hashData[Number.parseInt(i.toString(), 10)] = this._defaultPasswordBytes[Number.parseInt(i.toString(), 10)];
            }
            for (j = 0, n = id.length; j < n; ++j) {
                hashData[i++] = id[Number.parseInt(j.toString(), 10)];
            }
            cipher = new _NormalCipherFour(encryptionKey);
            checkData = cipher._encryptBlock(this._md5.hash(hashData, 0, i));
            n = encryptionKey.length;
            var derivedKey = new Uint8Array(n);
            for (j = 1; j <= 19; ++j) {
                for (var k = 0; k < n; ++k) {
                    derivedKey[Number.parseInt(k.toString(), 10)] = encryptionKey[Number.parseInt(k.toString(), 10)] ^ j;
                }
                cipher = new _NormalCipherFour(derivedKey);
                checkData = cipher._encryptBlock(checkData);
            }
            for (j = 0, n = checkData.length; j < n; ++j) {
                if (userPassword[Number.parseInt(j.toString(), 10)] !== checkData[Number.parseInt(j.toString(), 10)]) {
                    return null;
                }
            }
        }
        else {
            cipher = new _NormalCipherFour(encryptionKey);
            checkData = cipher._encryptBlock(this._defaultPasswordBytes);
            for (j = 0, n = checkData.length; j < n; ++j) {
                if (userPassword[Number.parseInt(j.toString(), 10)] !== checkData[Number.parseInt(j.toString(), 10)]) {
                    return null;
                }
            }
        }
        return encryptionKey;
    };
    _PdfEncryptor.prototype._decodeUserPassword = function (password, ownerPassword, revision, keyLength) {
        var hashData = new Uint8Array(32);
        var i = 0;
        var j = 0;
        var n = Math.min(32, password.length);
        for (; i < n; ++i) {
            hashData[Number.parseInt(i.toString(), 10)] = password[Number.parseInt(i.toString(), 10)];
        }
        while (i < 32) {
            hashData[i++] = this._defaultPasswordBytes[j++];
        }
        var hash = this._md5.hash(hashData, 0, i);
        var keyLengthInBytes = keyLength >> 3;
        if (revision >= 3) {
            for (j = 0; j < 50; ++j) {
                hash = this._md5.hash(hash, 0, hash.length);
            }
        }
        var cipher;
        var userPassword;
        if (revision >= 3) {
            userPassword = ownerPassword;
            var derivedKey = new Uint8Array(keyLengthInBytes);
            for (j = 19; j >= 0; j--) {
                for (var k = 0; k < keyLengthInBytes; ++k) {
                    derivedKey[Number.parseInt(k.toString(), 10)] = hash[Number.parseInt(k.toString(), 10)] ^ j;
                }
                cipher = new _NormalCipherFour(derivedKey);
                userPassword = cipher._encryptBlock(userPassword);
            }
        }
        else {
            cipher = new _NormalCipherFour(hash.subarray(0, keyLengthInBytes));
            userPassword = cipher._encryptBlock(ownerPassword);
        }
        return userPassword;
    };
    _PdfEncryptor.prototype._createCipherTransform = function (objectNumber, generationNumber) {
        if (this._algorithm === 4 || this._algorithm === 5) {
            var stringCipher = this._buildCipherConstructor(this._cipherDictionary, this._string, objectNumber, generationNumber, this._encryptionKey);
            var streamCipher = this._buildCipherConstructor(this._cipherDictionary, this._stream, objectNumber, generationNumber, this._encryptionKey);
            return new _CipherTransform(stringCipher, streamCipher);
        }
        var key = this._buildObjectKey(objectNumber, generationNumber, this._encryptionKey, false);
        return new _CipherTransform(new _NormalCipherFour(key), new _NormalCipherFour(key));
    };
    _PdfEncryptor.prototype._buildCipherConstructor = function (cipherDictionary, name, objectNumber, generationNumber, key) {
        var cryptFilter = cipherDictionary.get(name.name);
        var cfm;
        if (cryptFilter) {
            cfm = cryptFilter.get('CFM');
        }
        if (!cfm) {
            return new _NullCipher();
        }
        switch (cfm.name) {
            case 'None':
                return new _NullCipher();
            case 'AESV2':
                return new _AdvancedEncryption128Cipher(this._buildObjectKey(objectNumber, generationNumber, key, true));
            case 'AESV3':
                return new _AdvancedEncryption256Cipher(key);
            case 'V2':
                return new _NormalCipherFour(this._buildObjectKey(objectNumber, generationNumber, key, false));
        }
        throw new FormatError('Unknown cryptography method');
    };
    _PdfEncryptor.prototype._buildObjectKey = function (objectNumber, generationNumber, encryptionKey, isAdvancedEncryption) {
        if (isAdvancedEncryption === void 0) { isAdvancedEncryption = false; }
        var key = new Uint8Array(encryptionKey.length + 9);
        var i;
        for (i = 0; i < encryptionKey.length; ++i) {
            key[Number.parseInt(i.toString(), 10)] = encryptionKey[Number.parseInt(i.toString(), 10)];
        }
        key[i++] = objectNumber & 0xff;
        key[i++] = (objectNumber >> 8) & 0xff;
        key[i++] = (objectNumber >> 16) & 0xff;
        key[i++] = generationNumber & 0xff;
        key[i++] = (generationNumber >> 8) & 0xff;
        if (isAdvancedEncryption) {
            key[i++] = 0x73;
            key[i++] = 0x41;
            key[i++] = 0x6c;
            key[i++] = 0x54;
        }
        var hash = this._md5.hash(key, 0, i);
        return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
    };
    return _PdfEncryptor;
}());
var _MD5 = /** @class */ (function () {
    function _MD5() {
        this._r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9,
            14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21,
            6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
        this._k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983,
            1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632,
            643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501,
            -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353,
            -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651,
            -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744,
            -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
    }
    _MD5.prototype.hash = function (data, offset, length) {
        var h0 = 1732584193;
        var h1 = -271733879;
        var h2 = -1732584194;
        var h3 = 271733878;
        var paddedLength = (length + 72) & ~63;
        var padded = new Uint8Array(paddedLength);
        var i = 0;
        var j = 0;
        for (; i < length; ++i) {
            padded[Number.parseInt(i.toString(), 10)] = data[offset++];
        }
        padded[i++] = 0x80;
        var n = paddedLength - 8;
        while (i < n) {
            padded[i++] = 0;
        }
        padded[i++] = (length << 3) & 0xff;
        padded[i++] = (length >> 5) & 0xff;
        padded[i++] = (length >> 13) & 0xff;
        padded[i++] = (length >> 21) & 0xff;
        padded[i++] = (length >>> 29) & 0xff;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        var w = new Int32Array(16);
        for (i = 0; i < paddedLength;) {
            for (j = 0; j < 16; ++j, i += 4) {
                w[Number.parseInt(j.toString(), 10)] = padded[Number.parseInt(i.toString(), 10)] |
                    (padded[i + 1] << 8) |
                    (padded[i + 2] << 16) |
                    (padded[i + 3] << 24);
            }
            var a = h0;
            var b = h1;
            var c = h2;
            var d = h3;
            var e = void 0;
            var f = void 0;
            for (j = 0; j < 64; ++j) {
                if (j < 16) {
                    e = (b & c) | (~b & d);
                    f = j;
                }
                else if (j < 32) {
                    e = (d & b) | (~d & c);
                    f = (5 * j + 1) & 15;
                }
                else if (j < 48) {
                    e = b ^ c ^ d;
                    f = (3 * j + 5) & 15;
                }
                else {
                    e = c ^ (b | ~d);
                    f = (7 * j) & 15;
                }
                var previous = d;
                var current = (a + e + this._k[Number.parseInt(j.toString(), 10)] + w[Number.parseInt(f.toString(), 10)]) | 0;
                var rotate = this._r[Number.parseInt(j.toString(), 10)];
                d = c;
                c = b;
                b = (b + ((current << rotate) | (current >>> (32 - rotate)))) | 0;
                a = previous;
            }
            h0 = (h0 + a) | 0;
            h1 = (h1 + b) | 0;
            h2 = (h2 + c) | 0;
            h3 = (h3 + d) | 0;
        }
        return new Uint8Array([h0 & 0xFF, (h0 >> 8) & 0xFF, (h0 >> 16) & 0xFF, (h0 >>> 24) & 0xFF, h1 & 0xFF,
            (h1 >> 8) & 0xFF, (h1 >> 16) & 0xFF, (h1 >>> 24) & 0xFF, h2 & 0xFF, (h2 >> 8) & 0xFF, (h2 >> 16) & 0xFF,
            (h2 >>> 24) & 0xFF, h3 & 0xFF, (h3 >> 8) & 0xFF, (h3 >> 16) & 0xFF, (h3 >>> 24) & 0xFF
        ]);
    };
    return _MD5;
}());
var _Sha256 = /** @class */ (function () {
    function _Sha256() {
    }
    _Sha256.prototype._rotateRight = function (x, n) {
        return (x >>> n) | (x << (32 - n));
    };
    _Sha256.prototype._sigma = function (x) {
        return this._rotateRight(x, 2) ^ this._rotateRight(x, 13) ^ this._rotateRight(x, 22);
    };
    _Sha256.prototype._sigmaPrime = function (x) {
        return this._rotateRight(x, 6) ^ this._rotateRight(x, 11) ^ this._rotateRight(x, 25);
    };
    _Sha256.prototype._littleSigma = function (x) {
        return this._rotateRight(x, 7) ^ this._rotateRight(x, 18) ^ (x >>> 3);
    };
    _Sha256.prototype._littleSigmaPrime = function (x) {
        return this._rotateRight(x, 17) ^ this._rotateRight(x, 19) ^ (x >>> 10);
    };
    _Sha256.prototype._hash = function (data, offset, length) {
        var h0 = 0x6a09e667;
        var h1 = 0xbb67ae85;
        var h2 = 0x3c6ef372;
        var h3 = 0xa54ff53a;
        var h4 = 0x510e527f;
        var h5 = 0x9b05688c;
        var h6 = 0x1f83d9ab;
        var h7 = 0x5be0cd19;
        var k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98,
            0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6,
            0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3,
            0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e,
            0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116,
            0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814,
            0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
        var paddedLength = Math.ceil((length + 9) / 64) * 64;
        var padded = new Uint8Array(paddedLength);
        var i = 0;
        var j;
        for (; i < length; ++i) {
            padded[Number.parseInt(i.toString(), 10)] = data[offset++];
        }
        padded[i++] = 0x80;
        var n = paddedLength - 8;
        while (i < n) {
            padded[i++] = 0;
        }
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = (length >>> 29) & 0xff;
        padded[i++] = (length >> 21) & 0xff;
        padded[i++] = (length >> 13) & 0xff;
        padded[i++] = (length >> 5) & 0xff;
        padded[i++] = (length << 3) & 0xff;
        var w = new Uint32Array(64);
        for (i = 0; i < paddedLength;) {
            for (j = 0; j < 16; ++j) {
                w[Number.parseInt(j.toString(), 10)] = (padded[Number.parseInt(i.toString(), 10)] << 24) |
                    (padded[i + 1] << 16) |
                    (padded[i + 2] << 8) |
                    padded[i + 3];
                i += 4;
            }
            for (j = 16; j < 64; ++j) {
                w[Number.parseInt(j.toString(), 10)] = (this._littleSigmaPrime(w[j - 2]) +
                    w[j - 7] +
                    this._littleSigma(w[j - 15]) + w[j - 16]) | 0;
            }
            var a = h0;
            var b = h1;
            var c = h2;
            var d = h3;
            var e = h4;
            var f = h5;
            var g = h6;
            var h = h7;
            var t1 = void 0;
            var t2 = void 0;
            for (j = 0; j < 64; ++j) {
                t1 = h +
                    this._sigmaPrime(e) +
                    ((e & f) ^ (~e & g)) +
                    k[Number.parseInt(j.toString(), 10)] +
                    w[Number.parseInt(j.toString(), 10)];
                t2 = this._sigma(a) + ((a & b) ^ (a & c) ^ (b & c));
                h = g;
                g = f;
                f = e;
                e = (d + t1) | 0;
                d = c;
                c = b;
                b = a;
                a = (t1 + t2) | 0;
            }
            h0 = (h0 + a) | 0;
            h1 = (h1 + b) | 0;
            h2 = (h2 + c) | 0;
            h3 = (h3 + d) | 0;
            h4 = (h4 + e) | 0;
            h5 = (h5 + f) | 0;
            h6 = (h6 + g) | 0;
            h7 = (h7 + h) | 0;
        }
        return new Uint8Array([(h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, (h0) & 0xFF, (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF,
            (h1 >> 8) & 0xFF, (h1) & 0xFF, (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, (h2) & 0xFF, (h3 >> 24) & 0xFF,
            (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, (h3) & 0xFF, (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, (h4) & 0xFF,
            (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, (h5) & 0xFF, (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF,
            (h6) & 0xFF, (h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, (h7) & 0xFF
        ]);
    };
    return _Sha256;
}());
var _Sha512 = /** @class */ (function () {
    function _Sha512() {
        this._k = [new _Word64(0x428a2f98, 0xd728ae22), new _Word64(0x71374491, 0x23ef65cd),
            new _Word64(0xb5c0fbcf, 0xec4d3b2f), new _Word64(0xe9b5dba5, 0x8189dbbc),
            new _Word64(0x3956c25b, 0xf348b538), new _Word64(0x59f111f1, 0xb605d019),
            new _Word64(0x923f82a4, 0xaf194f9b), new _Word64(0xab1c5ed5, 0xda6d8118),
            new _Word64(0xd807aa98, 0xa3030242), new _Word64(0x12835b01, 0x45706fbe),
            new _Word64(0x243185be, 0x4ee4b28c), new _Word64(0x550c7dc3, 0xd5ffb4e2),
            new _Word64(0x72be5d74, 0xf27b896f), new _Word64(0x80deb1fe, 0x3b1696b1),
            new _Word64(0x9bdc06a7, 0x25c71235), new _Word64(0xc19bf174, 0xcf692694),
            new _Word64(0xe49b69c1, 0x9ef14ad2), new _Word64(0xefbe4786, 0x384f25e3),
            new _Word64(0x0fc19dc6, 0x8b8cd5b5), new _Word64(0x240ca1cc, 0x77ac9c65),
            new _Word64(0x2de92c6f, 0x592b0275), new _Word64(0x4a7484aa, 0x6ea6e483),
            new _Word64(0x5cb0a9dc, 0xbd41fbd4), new _Word64(0x76f988da, 0x831153b5),
            new _Word64(0x983e5152, 0xee66dfab), new _Word64(0xa831c66d, 0x2db43210),
            new _Word64(0xb00327c8, 0x98fb213f), new _Word64(0xbf597fc7, 0xbeef0ee4),
            new _Word64(0xc6e00bf3, 0x3da88fc2), new _Word64(0xd5a79147, 0x930aa725),
            new _Word64(0x06ca6351, 0xe003826f), new _Word64(0x14292967, 0x0a0e6e70),
            new _Word64(0x27b70a85, 0x46d22ffc), new _Word64(0x2e1b2138, 0x5c26c926),
            new _Word64(0x4d2c6dfc, 0x5ac42aed), new _Word64(0x53380d13, 0x9d95b3df),
            new _Word64(0x650a7354, 0x8baf63de), new _Word64(0x766a0abb, 0x3c77b2a8),
            new _Word64(0x81c2c92e, 0x47edaee6), new _Word64(0x92722c85, 0x1482353b),
            new _Word64(0xa2bfe8a1, 0x4cf10364), new _Word64(0xa81a664b, 0xbc423001),
            new _Word64(0xc24b8b70, 0xd0f89791), new _Word64(0xc76c51a3, 0x0654be30),
            new _Word64(0xd192e819, 0xd6ef5218), new _Word64(0xd6990624, 0x5565a910),
            new _Word64(0xf40e3585, 0x5771202a), new _Word64(0x106aa070, 0x32bbd1b8),
            new _Word64(0x19a4c116, 0xb8d2d0c8), new _Word64(0x1e376c08, 0x5141ab53),
            new _Word64(0x2748774c, 0xdf8eeb99), new _Word64(0x34b0bcb5, 0xe19b48a8),
            new _Word64(0x391c0cb3, 0xc5c95a63), new _Word64(0x4ed8aa4a, 0xe3418acb),
            new _Word64(0x5b9cca4f, 0x7763e373), new _Word64(0x682e6ff3, 0xd6b2b8a3),
            new _Word64(0x748f82ee, 0x5defb2fc), new _Word64(0x78a5636f, 0x43172f60),
            new _Word64(0x84c87814, 0xa1f0ab72), new _Word64(0x8cc70208, 0x1a6439ec),
            new _Word64(0x90befffa, 0x23631e28), new _Word64(0xa4506ceb, 0xde82bde9),
            new _Word64(0xbef9a3f7, 0xb2c67915), new _Word64(0xc67178f2, 0xe372532b),
            new _Word64(0xca273ece, 0xea26619c), new _Word64(0xd186b8c7, 0x21c0c207),
            new _Word64(0xeada7dd6, 0xcde0eb1e), new _Word64(0xf57d4f7f, 0xee6ed178),
            new _Word64(0x06f067aa, 0x72176fba), new _Word64(0x0a637dc5, 0xa2c898a6),
            new _Word64(0x113f9804, 0xbef90dae), new _Word64(0x1b710b35, 0x131c471b),
            new _Word64(0x28db77f5, 0x23047d84), new _Word64(0x32caab7b, 0x40c72493),
            new _Word64(0x3c9ebe0a, 0x15c9bebc), new _Word64(0x431d67c4, 0x9c100d4c),
            new _Word64(0x4cc5d4be, 0xcb3e42b6), new _Word64(0x597f299c, 0xfc657e2a),
            new _Word64(0x5fcb6fab, 0x3ad6faec), new _Word64(0x6c44198c, 0x4a475817)];
    }
    _Sha512.prototype._sigma = function (result, x, buffer) {
        result.assign(x);
        result.rotateRight(28);
        buffer.assign(x);
        buffer.rotateRight(34);
        result.xor(buffer);
        buffer.assign(x);
        buffer.rotateRight(39);
        result.xor(buffer);
    };
    _Sha512.prototype._sigmaPrime = function (result, x, buffer) {
        result.assign(x);
        result.rotateRight(14);
        buffer.assign(x);
        buffer.rotateRight(18);
        result.xor(buffer);
        buffer.assign(x);
        buffer.rotateRight(41);
        result.xor(buffer);
    };
    _Sha512.prototype._littleSigma = function (result, x, buffer) {
        result.assign(x);
        result.rotateRight(1);
        buffer.assign(x);
        buffer.rotateRight(8);
        result.xor(buffer);
        buffer.assign(x);
        buffer.shiftRight(7);
        result.xor(buffer);
    };
    _Sha512.prototype._littleSigmaPrime = function (result, x, buffer) {
        result.assign(x);
        result.rotateRight(19);
        buffer.assign(x);
        buffer.rotateRight(61);
        result.xor(buffer);
        buffer.assign(x);
        buffer.shiftRight(6);
        result.xor(buffer);
    };
    _Sha512.prototype._hash = function (data, offset, length, isMode384) {
        if (isMode384 === void 0) { isMode384 = false; }
        var h0;
        var h1;
        var h2;
        var h3;
        var h4;
        var h5;
        var h6;
        var h7;
        if (isMode384) {
            h0 = new _Word64(0xcbbb9d5d, 0xc1059ed8);
            h1 = new _Word64(0x629a292a, 0x367cd507);
            h2 = new _Word64(0x9159015a, 0x3070dd17);
            h3 = new _Word64(0x152fecd8, 0xf70e5939);
            h4 = new _Word64(0x67332667, 0xffc00b31);
            h5 = new _Word64(0x8eb44a87, 0x68581511);
            h6 = new _Word64(0xdb0c2e0d, 0x64f98fa7);
            h7 = new _Word64(0x47b5481d, 0xbefa4fa4);
        }
        else {
            h0 = new _Word64(0x6a09e667, 0xf3bcc908);
            h1 = new _Word64(0xbb67ae85, 0x84caa73b);
            h2 = new _Word64(0x3c6ef372, 0xfe94f82b);
            h3 = new _Word64(0xa54ff53a, 0x5f1d36f1);
            h4 = new _Word64(0x510e527f, 0xade682d1);
            h5 = new _Word64(0x9b05688c, 0x2b3e6c1f);
            h6 = new _Word64(0x1f83d9ab, 0xfb41bd6b);
            h7 = new _Word64(0x5be0cd19, 0x137e2179);
        }
        var paddedLength = Math.ceil((length + 17) / 128) * 128;
        var padded = new Uint8Array(paddedLength);
        var i;
        for (i = 0; i < length; ++i) {
            padded[Number.parseInt(i.toString(), 10)] = data[offset++];
        }
        padded[i++] = 0x80;
        var n = paddedLength - 16;
        while (i < n) {
            padded[i++] = 0;
        }
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = (length >>> 29) & 0xff;
        padded[i++] = (length >> 21) & 0xff;
        padded[i++] = (length >> 13) & 0xff;
        padded[i++] = (length >> 5) & 0xff;
        padded[i++] = (length << 3) & 0xff;
        var w = new Array(80);
        for (i = 0; i < 80; i++) {
            w[Number.parseInt(i.toString(), 10)] = new _Word64(0, 0);
        }
        var a = new _Word64(0, 0);
        var b = new _Word64(0, 0);
        var c = new _Word64(0, 0);
        var d = new _Word64(0, 0);
        var e = new _Word64(0, 0);
        var f = new _Word64(0, 0);
        var g = new _Word64(0, 0);
        var h = new _Word64(0, 0);
        var t1 = new _Word64(0, 0);
        var t2 = new _Word64(0, 0);
        var buffer1 = new _Word64(0, 0);
        var buffer2 = new _Word64(0, 0);
        var buffer3;
        for (i = 0; i < paddedLength;) {
            var j = void 0;
            for (j = 0; j < 16; ++j) {
                w[Number.parseInt(j.toString(), 10)].high =
                    (padded[Number.parseInt(i.toString(), 10)] << 24) |
                        (padded[i + 1] << 16) |
                        (padded[i + 2] << 8) |
                        padded[i + 3];
                w[Number.parseInt(j.toString(), 10)].low =
                    (padded[i + 4] << 24) |
                        (padded[i + 5] << 16) |
                        (padded[i + 6] << 8) |
                        padded[i + 7];
                i += 8;
            }
            for (j = 16; j < 80; ++j) {
                buffer3 = w[Number.parseInt(j.toString(), 10)];
                this._littleSigmaPrime(buffer3, w[j - 2], buffer2);
                buffer3.add(w[j - 7]);
                this._littleSigma(buffer1, w[j - 15], buffer2);
                buffer3.add(buffer1);
                buffer3.add(w[j - 16]);
            }
            a.assign(h0);
            b.assign(h1);
            c.assign(h2);
            d.assign(h3);
            e.assign(h4);
            f.assign(h5);
            g.assign(h6);
            h.assign(h7);
            for (j = 0; j < 80; ++j) {
                t1.assign(h);
                this._sigmaPrime(buffer1, e, buffer2);
                t1.add(buffer1);
                buffer1.assign(e);
                buffer1.and(f);
                buffer2.assign(e);
                buffer2.not();
                buffer2.and(g);
                buffer1.xor(buffer2);
                t1.add(buffer1);
                t1.add(this._k[Number.parseInt(j.toString(), 10)]);
                t1.add(w[Number.parseInt(j.toString(), 10)]);
                this._sigma(t2, a, buffer2);
                buffer1.assign(a);
                buffer1.and(b);
                buffer2.assign(a);
                buffer2.and(c);
                buffer1.xor(buffer2);
                buffer2.assign(b);
                buffer2.and(c);
                buffer1.xor(buffer2);
                t2.add(buffer1);
                buffer3 = h;
                h = g;
                g = f;
                f = e;
                d.add(t1);
                e = d;
                d = c;
                c = b;
                b = a;
                buffer3.assign(t1);
                buffer3.add(t2);
                a = buffer3;
            }
            h0.add(a);
            h1.add(b);
            h2.add(c);
            h3.add(d);
            h4.add(e);
            h5.add(f);
            h6.add(g);
            h7.add(h);
        }
        var result;
        if (!isMode384) {
            result = new Uint8Array(64);
            h0.copyTo(result, 0);
            h1.copyTo(result, 8);
            h2.copyTo(result, 16);
            h3.copyTo(result, 24);
            h4.copyTo(result, 32);
            h5.copyTo(result, 40);
            h6.copyTo(result, 48);
            h7.copyTo(result, 56);
        }
        else {
            result = new Uint8Array(48);
            h0.copyTo(result, 0);
            h1.copyTo(result, 8);
            h2.copyTo(result, 16);
            h3.copyTo(result, 24);
            h4.copyTo(result, 32);
            h5.copyTo(result, 40);
        }
        return result;
    };
    return _Sha512;
}());
var _Word64 = /** @class */ (function () {
    function _Word64(high, low) {
        this.high = high | 0;
        this.low = low | 0;
    }
    _Word64.prototype.and = function (word) {
        this.high &= word.high;
        this.low &= word.low;
    };
    _Word64.prototype.or = function (word) {
        this.high |= word.high;
        this.low |= word.low;
    };
    _Word64.prototype.not = function () {
        this.high = ~this.high;
        this.low = ~this.low;
    };
    _Word64.prototype.xor = function (word) {
        this.high ^= word.high;
        this.low ^= word.low;
    };
    _Word64.prototype.shiftRight = function (places) {
        if (places >= 32) {
            this.low = (this.high >>> (places - 32)) | 0;
            this.high = 0;
        }
        else {
            this.low = (this.low >>> places) | (this.high << (32 - places));
            this.high = (this.high >>> places) | 0;
        }
    };
    _Word64.prototype.shiftLeft = function (places) {
        if (places >= 32) {
            this.high = this.low << (places - 32);
            this.low = 0;
        }
        else {
            this.high = (this.high << places) | (this.low >>> (32 - places));
            this.low <<= places;
        }
    };
    _Word64.prototype.rotateRight = function (places) {
        var low;
        var high;
        if (places & 32) {
            high = this.low;
            low = this.high;
        }
        else {
            low = this.low;
            high = this.high;
        }
        places &= 31;
        this.low = (low >>> places) | (high << (32 - places));
        this.high = (high >>> places) | (low << (32 - places));
    };
    _Word64.prototype.add = function (word) {
        var lowAdd = (this.low >>> 0) + (word.low >>> 0);
        var highAdd = (this.high >>> 0) + (word.high >>> 0);
        if (lowAdd > 0xffffffff) {
            highAdd += 1;
        }
        this.low = lowAdd | 0;
        this.high = highAdd | 0;
    };
    _Word64.prototype.copyTo = function (bytes, offset) {
        bytes[Number.parseInt(offset.toString(), 10)] = (this.high >>> 24) & 0xff;
        bytes[offset + 1] = (this.high >> 16) & 0xff;
        bytes[offset + 2] = (this.high >> 8) & 0xff;
        bytes[offset + 3] = this.high & 0xff;
        bytes[offset + 4] = (this.low >>> 24) & 0xff;
        bytes[offset + 5] = (this.low >> 16) & 0xff;
        bytes[offset + 6] = (this.low >> 8) & 0xff;
        bytes[offset + 7] = this.low & 0xff;
    };
    _Word64.prototype.assign = function (word) {
        this.high = word.high;
        this.low = word.low;
    };
    return _Word64;
}());
var _EncryptionKey = /** @class */ (function () {
    function _EncryptionKey() {
    }
    Object.defineProperty(_EncryptionKey.prototype, "_sha256", {
        get: function () {
            if (typeof this._sha256Obj === 'undefined') {
                this._sha256Obj = new _Sha256();
            }
            return this._sha256Obj;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_EncryptionKey.prototype, "_sha512", {
        get: function () {
            if (typeof this._sha512Obj === 'undefined') {
                this._sha512Obj = new _Sha512();
            }
            return this._sha512Obj;
        },
        enumerable: true,
        configurable: true
    });
    return _EncryptionKey;
}());
// PDF17 encryption support
var _BasicEncryption = /** @class */ (function (_super) {
    __extends$g(_BasicEncryption, _super);
    function _BasicEncryption() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    _BasicEncryption.prototype._checkOwnerPassword = function (password, ownerValidationSalt, userBytes, ownerPassword) {
        var hashData = new Uint8Array(password.length + 56);
        hashData.set(password, 0);
        hashData.set(ownerValidationSalt, password.length);
        hashData.set(userBytes, password.length + ownerValidationSalt.length);
        var result = this._sha256._hash(hashData, 0, hashData.length);
        return _areArrayEqual(result, ownerPassword);
    };
    _BasicEncryption.prototype._checkUserPassword = function (password, userValidationSalt, userPassword) {
        var hashData = new Uint8Array(password.length + 8);
        hashData.set(password, 0);
        hashData.set(userValidationSalt, password.length);
        var result = this._sha256._hash(hashData, 0, hashData.length);
        return _areArrayEqual(result, userPassword);
    };
    _BasicEncryption.prototype._getOwnerKey = function (password, ownerKeySalt, userBytes, ownerEncryption) {
        var hashData = new Uint8Array(password.length + 56);
        hashData.set(password, 0);
        hashData.set(ownerKeySalt, password.length);
        hashData.set(userBytes, password.length + ownerKeySalt.length);
        var key = this._sha256._hash(hashData, 0, hashData.length);
        return (new _AdvancedEncryption256Cipher(key))._decryptBlock(ownerEncryption, false, new Uint8Array(16));
    };
    _BasicEncryption.prototype._getUserKey = function (password, userKeySalt, userEncryption) {
        var hashData = new Uint8Array(password.length + 8);
        hashData.set(password, 0);
        hashData.set(userKeySalt, password.length);
        var key = this._sha256._hash(hashData, 0, hashData.length);
        return (new _AdvancedEncryption256Cipher(key))._decryptBlock(userEncryption, false, new Uint8Array(16));
    };
    return _BasicEncryption;
}(_EncryptionKey));
// PDF20 encryption support
var _AdvancedEncryption = /** @class */ (function (_super) {
    __extends$g(_AdvancedEncryption, _super);
    function _AdvancedEncryption() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    _AdvancedEncryption.prototype._checkOwnerPassword = function (password, ownerValidationSalt, userBytes, ownerPassword) {
        var hashData = new Uint8Array(password.length + 56);
        hashData.set(password, 0);
        hashData.set(ownerValidationSalt, password.length);
        hashData.set(userBytes, password.length + ownerValidationSalt.length);
        var result = this._hash(password, hashData, userBytes);
        return _areArrayEqual(result, ownerPassword);
    };
    _AdvancedEncryption.prototype._checkUserPassword = function (password, userValidationSalt, userPassword) {
        var hashData = new Uint8Array(password.length + 8);
        hashData.set(password, 0);
        hashData.set(userValidationSalt, password.length);
        var result = this._hash(password, hashData, new Uint8Array([]));
        return _areArrayEqual(result, userPassword);
    };
    _AdvancedEncryption.prototype._getOwnerKey = function (password, ownerKeySalt, userBytes, ownerEncryption) {
        var hashData = new Uint8Array(password.length + 56);
        hashData.set(password, 0);
        hashData.set(ownerKeySalt, password.length);
        hashData.set(userBytes, password.length + ownerKeySalt.length);
        var key = this._hash(password, hashData, userBytes);
        return (new _AdvancedEncryption256Cipher(key))._decryptBlock(ownerEncryption, false, new Uint8Array(16));
    };
    _AdvancedEncryption.prototype._getUserKey = function (password, userKeySalt, userEncryption) {
        var hashData = new Uint8Array(password.length + 8);
        hashData.set(password, 0);
        hashData.set(userKeySalt, password.length);
        var key = this._hash(password, hashData, new Uint8Array([]));
        var cipher = new _AdvancedEncryption256Cipher(key);
        return cipher._decryptBlock(userEncryption, false, new Uint8Array(16));
    };
    _AdvancedEncryption.prototype._hash = function (password, input, userBytes) {
        var data = this._sha256._hash(input, 0, input.length).subarray(0, 32);
        var encrypted = new Uint8Array([0]);
        var i = 0;
        while (i < 64 || encrypted[encrypted.length - 1] > i - 32) {
            var combinedLength = password.length + data.length + userBytes.length;
            var combinedArray = new Uint8Array(combinedLength);
            var writeOffset = 0;
            combinedArray.set(password, writeOffset);
            writeOffset += password.length;
            combinedArray.set(data, writeOffset);
            writeOffset += data.length;
            combinedArray.set(userBytes, writeOffset);
            var k1 = new Uint8Array(combinedLength * 64);
            for (var j = 0, pos = 0; j < 64; j++) {
                k1.set(combinedArray, pos);
                pos += combinedLength;
            }
            var cipher = new _AdvancedEncryption128Cipher(data.subarray(0, 16));
            encrypted = cipher._encrypt(k1, data.subarray(16, 32));
            var remainder = 0;
            for (var z = 0; z < 16; z++) {
                remainder *= 256 % 3;
                remainder %= 3;
                remainder += (encrypted[Number.parseInt(z.toString(), 10)] >>> 0) % 3;
                remainder %= 3;
            }
            if (remainder === 2) {
                data = this._sha512._hash(encrypted, 0, encrypted.length);
            }
            else if (remainder === 1) {
                data = this._sha512._hash(encrypted, 0, encrypted.length, true);
            }
            else if (remainder === 0) {
                data = this._sha256._hash(encrypted, 0, encrypted.length);
            }
            i++;
        }
        return data.subarray(0, 32);
    };
    return _AdvancedEncryption;
}(_EncryptionKey));
var _Cipher = /** @class */ (function () {
    function _Cipher() {
    }
    return _Cipher;
}());
var _NormalCipherFour = /** @class */ (function (_super) {
    __extends$g(_NormalCipherFour, _super);
    function _NormalCipherFour(key) {
        var _this = _super.call(this) || this;
        _this._a = 0;
        _this._b = 0;
        var s = new Uint8Array(256);
        for (var i = 0; i < 256; ++i) {
            s[Number.parseInt(i.toString(), 10)] = i;
        }
        var keyLength = key.length;
        for (var i = 0, j = 0; i < 256; ++i) {
            var buffer = s[Number.parseInt(i.toString(), 10)];
            j = (j + buffer + key[i % keyLength]) & 0xff;
            s[Number.parseInt(i.toString(), 10)] = s[Number.parseInt(j.toString(), 10)];
            s[Number.parseInt(j.toString(), 10)] = buffer;
        }
        _this._s = s;
        return _this;
    }
    _NormalCipherFour.prototype._encryptBlock = function (data) {
        var a = this._a;
        var b = this._b;
        var s = this._s;
        var n = data.length;
        var output = new Uint8Array(n);
        for (var i = 0; i < n; ++i) {
            a = (a + 1) & 0xff;
            var first = s[Number.parseInt(a.toString(), 10)];
            b = (b + first) & 0xff;
            var second = s[Number.parseInt(b.toString(), 10)];
            s[Number.parseInt(a.toString(), 10)] = second;
            s[Number.parseInt(b.toString(), 10)] = first;
            output[Number.parseInt(i.toString(), 10)] = data[Number.parseInt(i.toString(), 10)] ^ s[(first + second) & 0xff];
        }
        this._a = a;
        this._b = b;
        return output;
    };
    _NormalCipherFour.prototype._decryptBlock = function (data) {
        return this._encryptBlock(data);
    };
    _NormalCipherFour.prototype._encrypt = function (data) {
        return this._encryptBlock(data);
    };
    return _NormalCipherFour;
}(_Cipher));
var _AdvancedEncryptionBaseCipher = /** @class */ (function (_super) {
    __extends$g(_AdvancedEncryptionBaseCipher, _super);
    function _AdvancedEncryptionBaseCipher() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._buffer = new Uint8Array(16);
        _this._position = 0;
        _this._s = new Uint8Array([
            0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b,
            0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
            0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26,
            0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
            0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2,
            0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
            0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed,
            0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
            0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f,
            0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
            0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,
            0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
            0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14,
            0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
            0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d,
            0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
            0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f,
            0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
            0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11,
            0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
            0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f,
            0xb0, 0x54, 0xbb, 0x16
        ]);
        _this._inverseS = new Uint8Array([
            0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e,
            0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
            0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32,
            0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49,
            0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
            0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50,
            0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05,
            0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
            0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41,
            0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8,
            0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
            0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b,
            0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59,
            0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
            0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d,
            0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63,
            0x55, 0x21, 0x0c, 0x7d
        ]);
        _this._mix = new Uint32Array([
            0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927,
            0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45,
            0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb,
            0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381,
            0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf,
            0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66,
            0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28,
            0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012,
            0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec,
            0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e,
            0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd,
            0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7,
            0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89,
            0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b,
            0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815,
            0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f,
            0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa,
            0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8,
            0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36,
            0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c,
            0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742,
            0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea,
            0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4,
            0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e,
            0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360,
            0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502,
            0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87,
            0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd,
            0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3,
            0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621,
            0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f,
            0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55,
            0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26,
            0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844,
            0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba,
            0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480,
            0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce,
            0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67,
            0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929,
            0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713,
            0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed,
            0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f,
            0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3
        ]);
        return _this;
    }
    Object.defineProperty(_AdvancedEncryptionBaseCipher.prototype, "_mixCol", {
        get: function () {
            if (typeof this._mixC === 'undefined') {
                this._mixC = new Uint8Array(256);
                for (var i = 0; i < 256; i++) {
                    if (i < 128) {
                        this._mixC[Number.parseInt(i.toString(), 10)] = i << 1;
                    }
                    else {
                        this._mixC[Number.parseInt(i.toString(), 10)] = (i << 1) ^ 0x1b;
                    }
                }
            }
            return this._mixC;
        },
        enumerable: true,
        configurable: true
    });
    _AdvancedEncryptionBaseCipher.prototype._decrypt = function (input, key) {
        var t;
        var u;
        var v;
        var state = new Uint8Array(16);
        state.set(input);
        for (var j = 0, k = this._keySize; j < 16; ++j, ++k) {
            state[Number.parseInt(j.toString(), 10)] ^= key[Number.parseInt(k.toString(), 10)];
        }
        for (var i = this._cyclesOfRepetition - 1; i >= 1; --i) {
            t = state[13];
            state[13] = state[9];
            state[9] = state[5];
            state[5] = state[1];
            state[1] = t;
            t = state[14];
            u = state[10];
            state[14] = state[6];
            state[10] = state[2];
            state[6] = t;
            state[2] = u;
            t = state[15];
            u = state[11];
            v = state[7];
            state[15] = state[3];
            state[11] = t;
            state[7] = u;
            state[3] = v;
            for (var j = 0; j < 16; ++j) {
                state[Number.parseInt(j.toString(), 10)] = this._inverseS[state[Number.parseInt(j.toString(), 10)]];
            }
            for (var j = 0, k = i * 16; j < 16; ++j, ++k) {
                state[Number.parseInt(j.toString(), 10)] ^= key[Number.parseInt(k.toString(), 10)];
            }
            for (var j = 0; j < 16; j += 4) {
                var s0 = this._mix[state[Number.parseInt(j.toString(), 10)]];
                var s1 = this._mix[state[j + 1]];
                var s2 = this._mix[state[j + 2]];
                var s3 = this._mix[state[j + 3]];
                t = s0 ^ (s1 >>> 8) ^ (s1 << 24) ^ (s2 >>> 16) ^ (s2 << 16) ^ (s3 >>> 24) ^ (s3 << 8);
                state[Number.parseInt(j.toString(), 10)] = (t >>> 24) & 0xff;
                state[j + 1] = (t >> 16) & 0xff;
                state[j + 2] = (t >> 8) & 0xff;
                state[j + 3] = t & 0xff;
            }
        }
        t = state[13];
        state[13] = state[9];
        state[9] = state[5];
        state[5] = state[1];
        state[1] = t;
        t = state[14];
        u = state[10];
        state[14] = state[6];
        state[10] = state[2];
        state[6] = t;
        state[2] = u;
        t = state[15];
        u = state[11];
        v = state[7];
        state[15] = state[3];
        state[11] = t;
        state[7] = u;
        state[3] = v;
        for (var j = 0; j < 16; ++j) {
            state[Number.parseInt(j.toString(), 10)] = this._inverseS[state[Number.parseInt(j.toString(), 10)]];
            state[Number.parseInt(j.toString(), 10)] ^= key[Number.parseInt(j.toString(), 10)];
        }
        return state;
    };
    _AdvancedEncryptionBaseCipher.prototype._encryptBlock = function (input, key) {
        var s = this._s;
        var t;
        var u;
        var v;
        var state = new Uint8Array(16);
        state.set(input);
        for (var j = 0; j < 16; ++j) {
            state[Number.parseInt(j.toString(), 10)] ^= key[Number.parseInt(j.toString(), 10)];
        }
        for (var i = 1; i < this._cyclesOfRepetition; i++) {
            for (var j = 0; j < 16; ++j) {
                state[Number.parseInt(j.toString(), 10)] = s[state[Number.parseInt(j.toString(), 10)]];
            }
            v = state[1];
            state[1] = state[5];
            state[5] = state[9];
            state[9] = state[13];
            state[13] = v;
            v = state[2];
            u = state[6];
            state[2] = state[10];
            state[6] = state[14];
            state[10] = v;
            state[14] = u;
            v = state[3];
            u = state[7];
            t = state[11];
            state[3] = state[15];
            state[7] = v;
            state[11] = u;
            state[15] = t;
            for (var j = 0; j < 16; j += 4) {
                var s0 = state[j + 0];
                var s1 = state[j + 1];
                var s2 = state[j + 2];
                var s3 = state[j + 3];
                t = s0 ^ s1 ^ s2 ^ s3;
                state[j + 0] ^= t ^ this._mixCol[s0 ^ s1];
                state[j + 1] ^= t ^ this._mixCol[s1 ^ s2];
                state[j + 2] ^= t ^ this._mixCol[s2 ^ s3];
                state[j + 3] ^= t ^ this._mixCol[s3 ^ s0];
            }
            for (var j = 0, k = i * 16; j < 16; ++j, ++k) {
                state[Number.parseInt(j.toString(), 10)] ^= key[Number.parseInt(k.toString(), 10)];
            }
        }
        for (var j = 0; j < 16; ++j) {
            state[Number.parseInt(j.toString(), 10)] = s[state[Number.parseInt(j.toString(), 10)]];
        }
        v = state[1];
        state[1] = state[5];
        state[5] = state[9];
        state[9] = state[13];
        state[13] = v;
        v = state[2];
        u = state[6];
        state[2] = state[10];
        state[6] = state[14];
        state[10] = v;
        state[14] = u;
        v = state[3];
        u = state[7];
        t = state[11];
        state[3] = state[15];
        state[7] = v;
        state[11] = u;
        state[15] = t;
        for (var j = 0, k = this._keySize; j < 16; ++j, ++k) {
            state[Number.parseInt(j.toString(), 10)] ^= key[Number.parseInt(k.toString(), 10)];
        }
        return state;
    };
    _AdvancedEncryptionBaseCipher.prototype._decryptBlockHelper = function (data, finalize) {
        var sourceLength = data.length;
        var buffer = this._buffer;
        var bufferLength = this._position;
        var result = [];
        var iv = this._iv;
        for (var i = 0; i < sourceLength; ++i) {
            buffer[Number.parseInt(bufferLength.toString(), 10)] = data[Number.parseInt(i.toString(), 10)];
            ++bufferLength;
            if (bufferLength < 16) {
                continue;
            }
            var plain = this._decrypt(buffer, this._key);
            for (var j = 0; j < 16; ++j) {
                plain[Number.parseInt(j.toString(), 10)] ^= iv[Number.parseInt(j.toString(), 10)];
            }
            iv = buffer;
            result.push(plain);
            buffer = new Uint8Array(16);
            bufferLength = 0;
        }
        this._buffer = buffer;
        this._bufferLength = bufferLength;
        this._iv = iv;
        if (result.length === 0) {
            return new Uint8Array(0);
        }
        var outputLength = 16 * result.length;
        if (finalize) {
            var lastBlock = result[result.length - 1];
            var length_1 = lastBlock[15];
            if (length_1 <= 16) {
                for (var i = 15, ii = 16 - length_1; i >= ii; --i) {
                    if (lastBlock[Number.parseInt(i.toString(), 10)] !== length_1) {
                        length_1 = 0;
                        break;
                    }
                }
                outputLength -= length_1;
                result[result.length - 1] = lastBlock.subarray(0, 16 - length_1);
            }
        }
        var output = new Uint8Array(outputLength);
        for (var i = 0, j = 0; i < result.length; ++i, j += 16) {
            output.set(result[Number.parseInt(i.toString(), 10)], j);
        }
        return output;
    };
    _AdvancedEncryptionBaseCipher.prototype._decryptBlock = function (data, finalize, iv) {
        var sourceLength = data.length;
        var buffer = this._buffer;
        var bufferLength = this._position;
        if (iv) {
            this._iv = iv;
        }
        else {
            for (var i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
                buffer[Number.parseInt(bufferLength.toString(), 10)] = data[Number.parseInt(i.toString(), 10)];
            }
            if (bufferLength < 16) {
                this._bufferLength = bufferLength;
                return new Uint8Array(0);
            }
            this._iv = buffer;
            data = data.subarray(16);
        }
        this._buffer = new Uint8Array(16);
        this._bufferLength = 0;
        this._decryptBlock = this._decryptBlockHelper;
        return this._decryptBlock(data, finalize);
    };
    _AdvancedEncryptionBaseCipher.prototype._encrypt = function (data, iv) {
        var sourceLength = data.length;
        var buffer = this._buffer;
        var bufferLength = this._position;
        var result = [];
        if (!iv) {
            iv = new Uint8Array(16);
        }
        for (var i = 0; i < sourceLength; ++i) {
            buffer[Number.parseInt(bufferLength.toString(), 10)] = data[Number.parseInt(i.toString(), 10)];
            ++bufferLength;
            if (bufferLength < 16) {
                continue;
            }
            for (var j = 0; j < 16; ++j) {
                buffer[Number.parseInt(j.toString(), 10)] ^= iv[Number.parseInt(j.toString(), 10)];
            }
            var cipher = this._encryptBlock(buffer, this._key);
            iv = cipher;
            result.push(cipher);
            buffer = new Uint8Array(16);
            bufferLength = 0;
        }
        this._buffer = buffer;
        this._bufferLength = bufferLength;
        this._iv = iv;
        if (result.length === 0) {
            return new Uint8Array(0);
        }
        var outputLength = 16 * result.length;
        var output = new Uint8Array(outputLength);
        for (var i = 0, j = 0; i < result.length; ++i, j += 16) {
            output.set(result[Number.parseInt(i.toString(), 10)], j);
        }
        return output;
    };
    return _AdvancedEncryptionBaseCipher;
}(_Cipher));
var _AdvancedEncryption128Cipher = /** @class */ (function (_super) {
    __extends$g(_AdvancedEncryption128Cipher, _super);
    function _AdvancedEncryption128Cipher(key) {
        var _this = _super.call(this) || this;
        _this._cyclesOfRepetition = 10;
        _this._keySize = 160;
        _this._key = new Uint8Array([
            0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c,
            0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a,
            0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
            0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
            0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
            0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6,
            0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72,
            0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
            0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10,
            0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e,
            0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5,
            0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
            0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02,
            0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d,
            0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d,
            0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
            0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb,
            0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c,
            0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a,
            0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
            0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
            0x74, 0xe8, 0xcb, 0x8d
        ]);
        _this._key = _this._expandKey(key);
        return _this;
    }
    _AdvancedEncryption128Cipher.prototype._expandKey = function (cipherKey) {
        var count = 176;
        var s = this._s;
        var rcon = this._key;
        var result = new Uint8Array(count);
        result.set(cipherKey);
        for (var j = 16, i = 1; j < count; ++i) {
            var t1 = result[j - 3];
            var t2 = result[j - 2];
            var t3 = result[j - 1];
            var t4 = result[j - 4];
            t1 = s[Number.parseInt(t1.toString(), 10)];
            t2 = s[Number.parseInt(t2.toString(), 10)];
            t3 = s[Number.parseInt(t3.toString(), 10)];
            t4 = s[Number.parseInt(t4.toString(), 10)];
            t1 ^= rcon[Number.parseInt(i.toString(), 10)];
            for (var n = 0; n < 4; ++n) {
                result[Number.parseInt(j.toString(), 10)] = t1 ^= result[j - 16];
                result[j + 1] = t2 ^= result[j - 15];
                result[j + 2] = t3 ^= result[j - 14];
                result[j + 3] = t4 ^= result[j - 13];
                j += 4;
            }
        }
        return result;
    };
    return _AdvancedEncryption128Cipher;
}(_AdvancedEncryptionBaseCipher));
var _AdvancedEncryption256Cipher = /** @class */ (function (_super) {
    __extends$g(_AdvancedEncryption256Cipher, _super);
    function _AdvancedEncryption256Cipher(key) {
        var _this = _super.call(this) || this;
        _this._cyclesOfRepetition = 14;
        _this._keySize = 224;
        _this._key = _this._expandKey(key);
        return _this;
    }
    _AdvancedEncryption256Cipher.prototype._expandKey = function (cipherKey) {
        var count = 240;
        var s = this._s;
        var result = new Uint8Array(count);
        result.set(cipherKey);
        var r = 1;
        var t1;
        var t2;
        var t3;
        var t4;
        for (var j = 32, i = 1; j < count; ++i) {
            if (j % 32 === 16) {
                t1 = s[Number.parseInt(t1.toString(), 10)];
                t2 = s[Number.parseInt(t2.toString(), 10)];
                t3 = s[Number.parseInt(t3.toString(), 10)];
                t4 = s[Number.parseInt(t4.toString(), 10)];
            }
            else if (j % 32 === 0) {
                t1 = result[j - 3];
                t2 = result[j - 2];
                t3 = result[j - 1];
                t4 = result[j - 4];
                t1 = s[Number.parseInt(t1.toString(), 10)];
                t2 = s[Number.parseInt(t2.toString(), 10)];
                t3 = s[Number.parseInt(t3.toString(), 10)];
                t4 = s[Number.parseInt(t4.toString(), 10)];
                t1 ^= r;
                r = r << 1;
                if (r >= 256) {
                    r = (r ^ 0x1b) & 0xff;
                }
            }
            for (var n = 0; n < 4; ++n) {
                result[Number.parseInt(j.toString(), 10)] = t1 ^= result[j - 32];
                result[j + 1] = t2 ^= result[j - 31];
                result[j + 2] = t3 ^= result[j - 30];
                result[j + 3] = t4 ^= result[j - 29];
                j += 4;
            }
        }
        return result;
    };
    return _AdvancedEncryption256Cipher;
}(_AdvancedEncryptionBaseCipher));
var _NullCipher = /** @class */ (function (_super) {
    __extends$g(_NullCipher, _super);
    function _NullCipher() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    _NullCipher.prototype._decryptBlock = function (data) {
        return data;
    };
    _NullCipher.prototype._encrypt = function (data) {
        return data;
    };
    return _NullCipher;
}(_Cipher));
var _CipherTransform = /** @class */ (function () {
    function _CipherTransform(stringCipher, streamCipher) {
        this._stringCipher = stringCipher;
        this._streamCipher = streamCipher;
    }
    _CipherTransform.prototype.createStream = function (stream, length) {
        return new _PdfDecryptStream(stream, length, this._streamCipher);
    };
    _CipherTransform.prototype.decryptString = function (s) {
        var stringBytes = _stringToBytes(s, false, true);
        var decryptedBytes = this._stringCipher._decryptBlock(stringBytes, true);
        return _bytesToString(decryptedBytes);
    };
    _CipherTransform.prototype.encryptString = function (s) {
        if (this._stringCipher instanceof _AdvancedEncryptionBaseCipher) {
            var length_2 = s.length;
            var pad = 16 - (length_2 % 16);
            s += String.fromCharCode(pad).repeat(pad);
            var iv = new Uint8Array(16);
            if (typeof crypto !== 'undefined') {
                crypto.getRandomValues(iv);
            }
            else {
                for (var i = 0; i < 16; i++) {
                    iv[Number.parseInt(i.toString(), 10)] = Math.floor(256 * Math.random());
                }
            }
            var data = this._stringCipher._encrypt(_stringToBytes(s, false, true), iv);
            var buffer = new Uint8Array(16 + data.length);
            buffer.set(iv);
            buffer.set(data, 16);
            return _bytesToString(buffer);
        }
        return _bytesToString(this._stringCipher._encrypt(_stringToBytes(s, false, true)));
    };
    return _CipherTransform;
}());

var maxCacheLength = 1000;
var maxNumberLength = 5552;
var endOfFile = 'EOF';
var specialChars = [
    1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
];
var _PdfLexicalOperator = /** @class */ (function () {
    function _PdfLexicalOperator(stream) {
        this.stream = stream;
        this.nextChar();
        this.stringBuffer = [];
        this._hexStringNumber = 0;
        this.beginInlineImagePosition = -1;
    }
    _PdfLexicalOperator.prototype.nextChar = function () {
        return (this.currentChar = this.stream.getByte());
    };
    _PdfLexicalOperator.prototype.peekChar = function () {
        return this.stream.peekByte();
    };
    _PdfLexicalOperator.prototype.getNumber = function () {
        var ch = this.currentChar;
        var eNotation = false;
        var divideBy = 0;
        var sign = 0;
        if (ch === 0x2d) {
            sign = -1;
            ch = this.nextChar();
            if (ch === 0x2d) {
                ch = this.nextChar();
            }
        }
        else if (ch === 0x2b) {
            sign = 1;
            ch = this.nextChar();
        }
        if (ch === 0x0a || ch === 0x0d) {
            do {
                ch = this.nextChar();
            } while (ch === 0x0a || ch === 0x0d);
        }
        if (ch === 0x2e) {
            divideBy = 10;
            ch = this.nextChar();
        }
        if (ch < 0x30 || ch > 0x39) {
            if (_isWhiteSpace(ch) || ch === -1) {
                if (divideBy === 10 && sign === 0) {
                    return 0;
                }
                if (divideBy === 0 && sign === -1) {
                    return 0;
                }
            }
            throw new FormatError("Invalid number: " + String.fromCharCode(ch) + " (charCode " + ch + ")");
        }
        sign = sign || 1;
        var baseValue = ch - 0x30;
        var powerValue = 0;
        var powerValueSign = 1;
        ch = this.nextChar();
        while (ch >= 0) {
            if (ch >= 0x30 && ch <= 0x39) {
                var currentDigit = ch - 0x30;
                if (eNotation) {
                    powerValue = powerValue * 10 + currentDigit;
                }
                else {
                    if (divideBy !== 0) {
                        divideBy *= 10;
                    }
                    baseValue = baseValue * 10 + currentDigit;
                }
            }
            else if (ch === 0x2e) {
                if (divideBy === 0) {
                    divideBy = 1;
                }
                else {
                    break;
                }
            }
            else if (ch === 0x2d) {
                ch = this.nextChar();
                continue;
            }
            else if (ch === 0x45 || ch === 0x65) {
                ch = this.peekChar();
                if (ch === 0x2b || ch === 0x2d) {
                    powerValueSign = ch === 0x2d ? -1 : 1;
                    this.nextChar();
                }
                else if (ch < 0x30 || ch > 0x39) {
                    break;
                }
                eNotation = true;
            }
            else {
                break;
            }
            ch = this.nextChar();
        }
        if (divideBy !== 0) {
            baseValue /= divideBy;
        }
        if (eNotation) {
            baseValue *= Math.pow(10, (powerValueSign * powerValue));
        }
        return sign * baseValue;
    };
    _PdfLexicalOperator.prototype.getString = function () {
        var numParen = 1;
        var done = false;
        var stringBuffer = this.stringBuffer;
        stringBuffer.length = 0;
        var ch = this.nextChar();
        while (true) { // eslint-disable-line
            var charBuffered = false;
            switch (ch | 0) {
                case -1:
                    done = true;
                    break;
                case 0x28:
                    ++numParen;
                    stringBuffer.push('(');
                    break;
                case 0x29:
                    if (--numParen === 0) {
                        this.nextChar();
                        done = true;
                    }
                    else {
                        stringBuffer.push(')');
                    }
                    break;
                case 0x5c:
                    ch = this.nextChar();
                    switch (ch) {
                        case -1:
                            done = true;
                            break;
                        case 0x6e:
                            stringBuffer.push('\n');
                            break;
                        case 0x72:
                            stringBuffer.push('\r');
                            break;
                        case 0x74:
                            stringBuffer.push('\t');
                            break;
                        case 0x62:
                            stringBuffer.push('\b');
                            break;
                        case 0x66:
                            stringBuffer.push('\f');
                            break;
                        case 0x5c:
                        case 0x28:
                        case 0x29:
                            stringBuffer.push(String.fromCharCode(ch));
                            break;
                        case 0x30:
                        case 0x31:
                        case 0x32:
                        case 0x33:
                        case 0x34:
                        case 0x35:
                        case 0x36:
                        case 0x37:
                            var x = ch & 0x0f; // eslint-disable-line
                            ch = this.nextChar();
                            charBuffered = true;
                            if (ch >= 0x30 && ch <= 0x37) {
                                x = (x << 3) + (ch & 0x0f);
                                ch = this.nextChar();
                                if (ch >= 0x30 && ch <= 0x37) {
                                    charBuffered = false;
                                    x = (x << 3) + (ch & 0x0f);
                                }
                            }
                            stringBuffer.push(String.fromCharCode(x));
                            break;
                        case 0x0d:
                            if (this.peekChar() === 0x0a) {
                                this.nextChar();
                            }
                            break;
                        case 0x0a:
                            break;
                        default:
                            stringBuffer.push(String.fromCharCode(ch));
                            break;
                    }
                    break;
                default:
                    stringBuffer.push(String.fromCharCode(ch));
                    break;
            }
            if (done) {
                break;
            }
            if (!charBuffered) {
                ch = this.nextChar();
            }
        }
        return stringBuffer.join('');
    };
    _PdfLexicalOperator.prototype.getName = function () {
        var ch;
        var previousCh;
        var stringBuffer = this.stringBuffer;
        stringBuffer.length = 0;
        ch = this.nextChar();
        while (ch >= 0 && !specialChars[ch]) { // eslint-disable-line
            if (ch === 0x23) {
                ch = this.nextChar();
                if (specialChars[ch]) { // eslint-disable-line
                    stringBuffer.push('#');
                    break;
                }
                var x = this._toHexDigit(ch);
                if (x !== -1) {
                    previousCh = ch;
                    ch = this.nextChar();
                    var x2 = this._toHexDigit(ch);
                    if (x2 === -1) {
                        stringBuffer.push('#', String.fromCharCode(previousCh));
                        if (specialChars[ch]) { // eslint-disable-line
                            break;
                        }
                        stringBuffer.push(String.fromCharCode(ch));
                        ch = this.nextChar();
                        continue;
                    }
                    stringBuffer.push(String.fromCharCode((x << 4) | x2));
                }
                else {
                    stringBuffer.push('#', String.fromCharCode(ch));
                }
            }
            else {
                stringBuffer.push(String.fromCharCode(ch));
            }
            ch = this.nextChar();
        }
        return _PdfName.get(stringBuffer.join(''));
    };
    _PdfLexicalOperator.prototype.getHexString = function () {
        var stringBuffer = this.stringBuffer;
        stringBuffer.length = 0;
        var ch = this.currentChar;
        var isFirstHex = true;
        var firstDigit;
        var secondDigit;
        this._hexStringNumber = 0;
        while (true) { // eslint-disable-line
            if (ch < 0) {
                break;
            }
            else if (ch === 0x3e) {
                this.nextChar();
                break;
            }
            else if (specialChars[ch] === 1) { // eslint-disable-line
                ch = this.nextChar();
                continue;
            }
            else {
                if (isFirstHex) {
                    firstDigit = this._toHexDigit(ch);
                    if (firstDigit === -1) {
                        ch = this.nextChar();
                        continue;
                    }
                }
                else {
                    secondDigit = this._toHexDigit(ch);
                    if (secondDigit === -1) {
                        ch = this.nextChar();
                        continue;
                    }
                    stringBuffer.push(String.fromCharCode((firstDigit << 4) | secondDigit));
                }
                isFirstHex = !isFirstHex;
                ch = this.nextChar();
            }
        }
        return stringBuffer.join('');
    };
    _PdfLexicalOperator.prototype.getObject = function () {
        var comment = false;
        var ch = this.currentChar;
        while (true) { // eslint-disable-line
            if (ch < 0) {
                return endOfFile;
            }
            if (comment) {
                if (ch === 0x0a || ch === 0x0d) {
                    comment = false;
                }
            }
            else if (ch === 0x25) {
                comment = true;
            }
            else if (specialChars[ch] !== 1) { // eslint-disable-line
                break;
            }
            ch = this.nextChar();
        }
        switch (ch | 0) {
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
            case 0x38:
            case 0x39:
            case 0x2b:
            case 0x2d:
            case 0x2e:
                return this.getNumber();
            case 0x28:
                return this.getString();
            case 0x2f:
                return this.getName();
            case 0x5b:
                this.nextChar();
                return _PdfCommand.get('[');
            case 0x5d:
                this.nextChar();
                return _PdfCommand.get(']');
            case 0x3c:
                ch = this.nextChar();
                if (ch === 0x3c) {
                    this.nextChar();
                    return _PdfCommand.get('<<');
                }
                return this.getHexString();
            case 0x3e:
                ch = this.nextChar();
                if (ch === 0x3e) {
                    this.nextChar();
                    return _PdfCommand.get('>>');
                }
                return _PdfCommand.get('>');
            case 0x7b:
                this.nextChar();
                return _PdfCommand.get('{');
            case 0x7d:
                this.nextChar();
                return _PdfCommand.get('}');
            case 0x29:
                this.nextChar();
                throw new FormatError("Illegal character: " + ch);
        }
        var str = String.fromCharCode(ch);
        if (ch < 0x20 || ch > 0x7f) {
            var nextCh = this.peekChar();
            if (nextCh >= 0x20 && nextCh <= 0x7f) {
                this.nextChar();
                return _PdfCommand.get(str);
            }
        }
        ch = this.nextChar();
        while (ch >= 0 && !specialChars[ch]) { // eslint-disable-line
            var possibleCommand = str + String.fromCharCode(ch);
            if (str.length === 128) {
                throw new FormatError("Command token too long: " + str.length);
            }
            str = possibleCommand;
            ch = this.nextChar();
        }
        if (str === 'true') {
            return true;
        }
        if (str === 'false') {
            return false;
        }
        if (str === 'null') {
            return null;
        }
        if (str === 'BI') {
            this.beginInlineImagePosition = this.stream.position;
        }
        return _PdfCommand.get(str);
    };
    _PdfLexicalOperator.prototype.peekObj = function () {
        var streamPos = this.stream.position;
        var currentChar = this.currentChar;
        var beginInlineImagePosition = this.beginInlineImagePosition;
        var nextObj; // eslint-disable-line
        try {
            nextObj = this.getObject();
        }
        catch (ex) { } // eslint-disable-line
        this.stream.position = streamPos;
        this.currentChar = currentChar;
        this.beginInlineImagePosition = beginInlineImagePosition;
        return nextObj;
    };
    _PdfLexicalOperator.prototype.skipToNextLine = function () {
        var ch = this.currentChar;
        while (ch >= 0) {
            if (ch === 0x0d) {
                ch = this.nextChar();
                if (ch === 0x0a) {
                    this.nextChar();
                }
                break;
            }
            else if (ch === 0x0a) {
                this.nextChar();
                break;
            }
            ch = this.nextChar();
        }
    };
    _PdfLexicalOperator.prototype._toHexDigit = function (ch) {
        if (ch >= 0x30 && ch <= 0x39) {
            return ch & 0x0f;
        }
        if ((ch >= 0x41 && ch <= 0x46) || (ch >= 0x61 && ch <= 0x66)) {
            return (ch & 0x0f) + 9;
        }
        return -1;
    };
    return _PdfLexicalOperator;
}());
var _PdfParser = /** @class */ (function () {
    function _PdfParser(lexicalOperator, xref, allowStreams, recoveryMode, encryptor) {
        if (allowStreams === void 0) { allowStreams = false; }
        if (recoveryMode === void 0) { recoveryMode = false; }
        this._isColorSpace = false;
        this._isPassword = false;
        this.lexicalOperator = lexicalOperator;
        this.xref = xref;
        this.allowStreams = allowStreams;
        this.recoveryMode = recoveryMode;
        this.imageCache = new Map();
        this._encryptor = encryptor;
        this.refill();
    }
    _PdfParser.prototype.refill = function () {
        this.first = this.lexicalOperator.getObject();
        this.second = this.lexicalOperator.getObject();
    };
    _PdfParser.prototype.shift = function () {
        if (this.second instanceof _PdfCommand && this.second.command === 'ID') {
            this.first = this.second;
            this.second = null;
        }
        else {
            this.first = this.second;
            this.second = this.lexicalOperator.getObject();
        }
    };
    _PdfParser.prototype.tryShift = function () {
        try {
            this.shift();
            return true;
        }
        catch (e) {
            return false;
        }
    };
    _PdfParser.prototype.getObject = function (arguement1, arguement2, arguement3) {
        var cipherTransform;
        var first = this.first; // eslint-disable-line
        this.shift();
        if (first instanceof _PdfCommand) {
            switch (first.command) {
                case 'BI':
                    if (typeof arguement1 === 'number' && typeof arguement2 === 'number') {
                        return this.makeInlineImage(arguement1, arguement2, arguement3);
                    }
                    else if (arguement1 instanceof _CipherTransform) {
                        return this.makeInlineImage(arguement1);
                    }
                    else {
                        return this.makeInlineImage();
                    }
                case '[':
                    var array = []; // eslint-disable-line
                    while (!_isCommand(this.first, ']') && this.first !== endOfFile) {
                        var entry = void 0; // eslint-disable-line
                        if (typeof arguement1 === 'number' && typeof arguement2 === 'number') {
                            cipherTransform = this._encryptor._createCipherTransform(arguement1, arguement2);
                            entry = this.getObject(arguement1, arguement2, arguement3);
                        }
                        else if (arguement1 instanceof _CipherTransform) {
                            cipherTransform = arguement1;
                            entry = this.getObject(arguement1);
                        }
                        else {
                            entry = this.getObject(arguement1);
                        }
                        if (array.length === 0 && _isName(entry, 'Indexed')) {
                            this._isColorSpace = true;
                        }
                        entry = _decodeText(entry, this._isColorSpace, this._isPassword);
                        array.push(entry);
                    }
                    if (this.first === endOfFile) {
                        if (this.recoveryMode) {
                            return array;
                        }
                        throw new ParserEndOfFileException('End of file inside array.');
                    }
                    this._isColorSpace = false;
                    this.shift();
                    return array;
                case '<<':
                    var dictionary = new _PdfDictionary(this.xref); // eslint-disable-line
                    while (!_isCommand(this.first, '>>') && this.first !== endOfFile) {
                        if (!(this.first instanceof _PdfName)) {
                            this.shift();
                            continue;
                        }
                        var key = this.first.name;
                        if (key === 'U' || key === 'O' || key === 'ID') {
                            this._isPassword = true;
                        }
                        this.shift();
                        var isEnd = this._checkEnd();
                        if (isEnd) {
                            break;
                        }
                        if (typeof arguement1 === 'number' && typeof arguement2 === 'number') {
                            cipherTransform = this._encryptor._createCipherTransform(arguement1, arguement2);
                        }
                        var value = void 0; // eslint-disable-line
                        if (typeof arguement1 === 'number' && typeof arguement2 === 'number') {
                            value = this.getObject(arguement1, arguement2, arguement3);
                        }
                        else if (arguement1 instanceof _CipherTransform) {
                            value = this.getObject(arguement1);
                        }
                        else {
                            value = this.getObject();
                        }
                        value = _decodeText(value, this._isColorSpace, this._isPassword);
                        this._isPassword = false;
                        dictionary.set(key, value);
                    }
                    if (this.first === endOfFile) {
                        if (this.recoveryMode) {
                            return dictionary;
                        }
                        throw new ParserEndOfFileException('End of file inside dictionary.');
                    }
                    if (_isCommand(this.second, 'stream')) {
                        if (this.allowStreams === true) {
                            if (arguement1 instanceof _CipherTransform) {
                                cipherTransform = arguement1;
                            }
                            else if (arguement3 && typeof arguement2 === 'number') {
                                cipherTransform = this._encryptor._createCipherTransform(arguement1, arguement2);
                            }
                            if (typeof arguement2 === 'boolean' && arguement2) {
                                return this.makeStream(dictionary, cipherTransform, arguement2);
                            }
                            else {
                                return this.makeStream(dictionary, cipherTransform);
                            }
                        }
                        else {
                            return dictionary;
                        }
                    }
                    this.shift();
                    return dictionary;
                default:
                    return first;
            }
        }
        if (Number.isInteger(first)) {
            if (Number.isInteger(this.first) && _isCommand(this.second, 'R')) {
                var ref = _PdfReference.get(first, this.first);
                this.shift();
                this.shift();
                return ref;
            }
            return first;
        }
        if (typeof first === 'string') {
            if (arguement1 instanceof _CipherTransform) {
                cipherTransform = arguement1;
            }
            else if (typeof arguement1 === 'number' && typeof arguement2 === 'number') {
                cipherTransform = this._encryptor._createCipherTransform(arguement1, arguement2);
            }
            if (cipherTransform) {
                return cipherTransform.decryptString(first);
            }
            return first;
        }
        return first;
    };
    _PdfParser.prototype.findDiscreteDecodeInlineStreamEnd = function (stream) {
        var startPos = stream.position;
        var foundEnd = false;
        var b;
        var markerLength;
        b = stream.getByte();
        while (b !== -1) {
            if (b !== 0xff) {
                b = stream.getByte();
                continue;
            }
            switch (stream.getByte()) {
                case 0x00:
                    break;
                case 0xff:
                    stream.skip(-1);
                    break;
                case 0xd9:
                    foundEnd = true;
                    break;
                case 0xc0:
                case 0xc1:
                case 0xc2:
                case 0xc3:
                case 0xc5:
                case 0xc6:
                case 0xc7:
                case 0xc9:
                case 0xca:
                case 0xcb:
                case 0xcd:
                case 0xce:
                case 0xcf:
                case 0xc4:
                case 0xcc:
                case 0xda:
                case 0xdb:
                case 0xdc:
                case 0xdd:
                case 0xde:
                case 0xdf:
                case 0xe0:
                case 0xe1:
                case 0xe2:
                case 0xe3:
                case 0xe4:
                case 0xe5:
                case 0xe6:
                case 0xe7:
                case 0xe8:
                case 0xe9:
                case 0xea:
                case 0xeb:
                case 0xec:
                case 0xed:
                case 0xee:
                case 0xef:
                case 0xfe:
                    markerLength = stream.getUnsignedInteger16();
                    if (markerLength > 2) {
                        stream.skip(markerLength - 2);
                    }
                    else {
                        stream.skip(-2);
                    }
                    break;
            }
            if (foundEnd) {
                break;
            }
            b = stream.getByte();
        }
        var length = stream.position - startPos;
        if (b === -1) {
            stream.skip(-length);
            return this.findDefaultInlineStreamEnd(stream);
        }
        this.inlineStreamSkipEI(stream);
        return length;
    };
    _PdfParser.prototype.findDecodeInlineStreamEnd = function (stream) {
        var startPos = stream.position;
        var ch;
        while ((ch = stream.getByte()) !== -1) { // eslint-disable-line
            if (ch === 0x7e) {
                var tildePos = stream.position;
                ch = stream.peekByte();
                while (_isWhiteSpace(ch)) {
                    stream.skip();
                    ch = stream.peekByte();
                }
                if (ch === 0x3e) {
                    stream.skip();
                    break;
                }
                if (stream.position > tildePos) {
                    var maybeEI = stream.peekBytes(2);
                    if (maybeEI[0] === 0x45 && maybeEI[1] === 0x49) {
                        break;
                    }
                }
            }
        }
        var length = stream.position - startPos;
        if (ch === -1) {
            stream.skip(-length);
            return this.findDefaultInlineStreamEnd(stream);
        }
        this.inlineStreamSkipEI(stream);
        return length;
    };
    _PdfParser.prototype.findHexDecodeInlineStreamEnd = function (stream) {
        var startPos = stream.position;
        var ch;
        ch = stream.getByte();
        while (ch !== -1) {
            if (ch === 0x3e) {
                break;
            }
            ch = stream.getByte();
        }
        var length = stream.position - startPos;
        if (ch === -1) {
            stream.skip(-length);
            return this.findDefaultInlineStreamEnd(stream);
        }
        this.inlineStreamSkipEI(stream);
        return length;
    };
    _PdfParser.prototype.inlineStreamSkipEI = function (stream) {
        var state = 0;
        var ch;
        ch = stream.getByte();
        while (ch !== -1) {
            if (state === 0) {
                state = ch === 0x45 ? 1 : 0;
            }
            else if (state === 1) {
                state = ch === 0x49 ? 2 : 0;
            }
            else if (state === 2) {
                break;
            }
            ch = stream.getByte();
        }
    };
    _PdfParser.prototype.makeInlineImage = function (arguement1, arguement2, arguement3) {
        var lexicalOperator = this.lexicalOperator;
        var stream = lexicalOperator.stream;
        var dictionary = new _PdfDictionary(this.xref);
        var dictLength;
        var cipherTransform;
        if (arguement3) {
            if (arguement1 instanceof _CipherTransform) {
                cipherTransform = arguement1;
            }
            else {
                cipherTransform = this._encryptor._createCipherTransform(arguement1, arguement2);
            }
        }
        while (!_isCommand(this.first, 'ID') && this.first !== endOfFile) {
            if (!(this.first instanceof _PdfName)) {
                throw new FormatError('Dictionary key must be a name object');
            }
            var key = this.first.name;
            this.shift();
            if (this.first.name === endOfFile) {
                break;
            }
            if (arguement1 instanceof _CipherTransform) {
                dictionary.set(key, this.getObject(arguement1));
            }
            else {
                dictionary.set(key, this.getObject(arguement1, arguement2, arguement3));
            }
        }
        if (lexicalOperator.beginInlineImagePosition !== -1) {
            dictLength = stream.position - lexicalOperator.beginInlineImagePosition;
        }
        var filter = dictionary.get('F', 'Filter'); // eslint-disable-line
        var filterName;
        if (filter instanceof _PdfName) {
            filterName = filter.name;
        }
        else if (Array.isArray(filter)) {
            var reference = filter[0]; // eslint-disable-line
            var filterZero = (reference !== null && typeof reference !== 'undefined' && reference instanceof _PdfReference) ?
                this.xref._fetch(reference) :
                reference;
            if (filterZero) {
                filterName = filterZero.name;
            }
        }
        var startPos = stream.position;
        var length;
        switch (filterName) {
            case 'DCT':
            case 'DCTDecode':
                length = this.findDiscreteDecodeInlineStreamEnd(stream);
                break;
            case 'A85':
            case 'ASCII85Decode':
                length = this.findDecodeInlineStreamEnd(stream);
                break;
            case 'AHx':
            case 'ASCIIHexDecode':
                length = this.findHexDecodeInlineStreamEnd(stream);
                break;
            default:
                length = this.findDefaultInlineStreamEnd(stream);
        }
        var imageStream = stream.makeSubStream(startPos, length, dictionary); // eslint-disable-line
        var cacheKey;
        if (length < maxCacheLength && dictLength < maxNumberLength) {
            var imageBytes = imageStream.getBytes();
            imageStream.reset();
            var initialStreamPos = stream.position;
            stream.position = lexicalOperator.beginInlineImagePosition;
            var dictBytes = stream.getBytes(dictLength);
            stream.position = initialStreamPos;
            cacheKey = this._computeMaxNumber(imageBytes) + '_' + this._computeMaxNumber(dictBytes);
            var cacheEntry = this.imageCache.get(cacheKey);
            if (cacheEntry !== undefined) {
                this.second = _PdfCommand.get('EI');
                this.shift();
                cacheEntry.reset();
                return cacheEntry;
            }
        }
        if (cipherTransform) {
            imageStream = cipherTransform.createStream(imageStream, length);
        }
        imageStream = this.filter(imageStream, dictionary, length);
        imageStream.dictionary = dictionary;
        if (cacheKey !== undefined) {
            this.imageCache.set(cacheKey, imageStream);
        }
        this.second = _PdfCommand.get('EI');
        this.shift();
        return imageStream;
    };
    _PdfParser.prototype._computeMaxNumber = function (bytes) {
        var bytesLength = bytes.length;
        var a = 1;
        var b = 0;
        for (var i = 0; i < bytesLength; ++i) {
            a += bytes[i] & 0xff; // eslint-disable-line
            b += a;
        }
        return (b % 65521 << 16) | a % 65521;
    };
    _PdfParser.prototype.makeStream = function (dictionary, cipherTransform, makeFilter) {
        if (makeFilter === void 0) { makeFilter = false; }
        var lexicalOperator = this.lexicalOperator;
        var stream = lexicalOperator.stream; // eslint-disable-line
        lexicalOperator.skipToNextLine();
        var startPosition = stream.position - 1;
        var length = dictionary.get('Length');
        if (!Number.isInteger(length)) {
            length = 0;
        }
        stream.position = startPosition + length;
        lexicalOperator.nextChar();
        if (this.tryShift() && _isCommand(this.second, 'endstream')) {
            this.shift();
        }
        else {
            var endStreamSignature = new Uint8Array([0x65, 0x6e, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d]);
            var actualLength = this._findStreamLength(startPosition, endStreamSignature);
            if (actualLength < 0) {
                var end = endStreamSignature.length - 1;
                var truncatedSignature = endStreamSignature.slice(0, end);
                var maybeLength = this._findStreamLength(startPosition, truncatedSignature);
                if (maybeLength >= 0) {
                    var lastByte = stream.peekBytes(end + 1)[end]; // eslint-disable-line
                    if (_isWhiteSpace(lastByte)) {
                        actualLength = maybeLength;
                    }
                }
                if (actualLength < 0) {
                    throw new FormatError('Missing endstream command.');
                }
            }
            length = actualLength;
            lexicalOperator.nextChar();
            this.shift();
            this.shift();
        }
        this.shift();
        stream = stream.makeSubStream(startPosition, length, dictionary);
        if (!makeFilter) {
            if (cipherTransform) {
                stream = cipherTransform.createStream(stream, length);
            }
            stream = this.filter(stream, dictionary, length);
        }
        stream.dictionary = dictionary;
        return stream;
    };
    _PdfParser.prototype.filter = function (stream, dictionary, length) {
        var filter = dictionary.get('F', 'Filter'); // eslint-disable-line
        var params = dictionary.get('DP', 'DecodeParms'); // eslint-disable-line
        if (filter instanceof _PdfName) {
            return this.makeFilter(stream, filter.name, length, params);
        }
        var maybeLength = length;
        if (Array.isArray(filter)) {
            var filterArray = filter; // eslint-disable-line
            var paramsArray = params; // eslint-disable-line
            for (var i = 0; i < filterArray.length; ++i) {
                var reference = filterArray[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                filter = reference instanceof _PdfReference ? this.xref._fetch(reference) : reference;
                if (!(filter instanceof _PdfName)) {
                    throw new FormatError("Bad filter name '" + filter + "'");
                }
                params = null;
                if (Array.isArray(paramsArray) && i in paramsArray) {
                    var ref = paramsArray[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                    params = ref instanceof _PdfReference ? this.xref._fetch(ref) : ref;
                }
                stream = this.makeFilter(stream, filter.name, maybeLength, params);
                maybeLength = null;
            }
        }
        return stream;
    };
    _PdfParser.prototype.makeFilter = function (stream, name, maybeLength, params) {
        if (maybeLength === 0) {
            return new _PdfNullStream();
        }
        try {
            if (name === 'Fl' || name === 'FlateDecode') {
                if (params) {
                    return new PdfPredictorStream(new _PdfFlateStream(stream, maybeLength), maybeLength, params);
                }
                return new _PdfFlateStream(stream, maybeLength);
            }
            return stream;
        }
        catch (ex) {
            return new _PdfNullStream();
        }
    };
    _PdfParser.prototype._findStreamLength = function (startPosition, signature) {
        var stream = this.lexicalOperator.stream;
        stream.position = startPosition;
        var length = 2048;
        var signatureLength = signature.length;
        while (stream.position < stream.end) {
            var scanBytes = stream.peekBytes(length);
            var scanLength = scanBytes.length - signatureLength;
            if (scanLength <= 0) {
                break;
            }
            var position = 0;
            while (position < scanLength) {
                var j = 0;
                while (j < signatureLength && scanBytes[position + j] === signature[j]) { // eslint-disable-line
                    j++;
                }
                if (j >= signatureLength) {
                    stream.position += position;
                    return stream.position - startPosition;
                }
                position++;
            }
            stream.position += scanLength;
        }
        return -1;
    };
    _PdfParser.prototype.findDefaultInlineStreamEnd = function (stream) {
        var startPosition = stream.position;
        var n = 10;
        var state = 0;
        var ch;
        var endImagePosition;
        ch = stream.getByte();
        while (ch !== -1) {
            if (state === 0) {
                state = ch === 0x45 ? 1 : 0;
            }
            else if (state === 1) {
                state = ch === 0x49 ? 2 : 0;
            }
            else {
                if (state !== 2) {
                    throw new Error('findDefaultInlineStreamEnd - invalid state.');
                }
                if (ch === 0x20 || ch === 0xa || ch === 0xd) {
                    endImagePosition = stream.position;
                    var followingBytes = stream.peekBytes(n);
                    for (var i = 0, ii = followingBytes.length; i < ii; i++) {
                        ch = followingBytes[i]; // eslint-disable-line
                        if (ch === 0x0 && followingBytes[i + 1] !== 0x0) {
                            continue;
                        }
                        if (ch !== 0xa && ch !== 0xd && (ch < 0x20 || ch > 0x7f)) {
                            state = 0;
                            break;
                        }
                    }
                    if (state !== 2) {
                        ch = stream.getByte();
                        continue;
                    }
                    if (state === 2) {
                        break;
                    }
                }
                else {
                    state = 0;
                }
            }
            ch = stream.getByte();
        }
        if (ch === -1) {
            if (typeof endImagePosition !== 'undefined') {
                stream.skip(-(stream.position - endImagePosition));
            }
        }
        var endOffset = 4;
        stream.skip(-endOffset);
        ch = stream.peekByte();
        stream.skip(endOffset);
        if (!_isWhiteSpace(ch)) {
            endOffset--;
        }
        return stream.position - endOffset - startPosition;
    };
    _PdfParser.prototype._checkEnd = function () {
        if (this.first === endOfFile) {
            return true;
        }
        else {
            return false;
        }
    };
    return _PdfParser;
}());
/* eslint-disable */
var _Linearization = /** @class */ (function () {
    function _Linearization(stream) {
        this.isValid = false;
        var parser = new _PdfParser(new _PdfLexicalOperator(stream), null);
        var obj1 = parser.getObject();
        var obj2 = parser.getObject();
        var obj3 = parser.getObject();
        var dictionary = parser.getObject();
        this.isValid = Number.isInteger(obj1) && Number.isInteger(obj2) && _isCommand(obj3, 'obj') && typeof dictionary !== 'undefined';
        if (this.isValid) {
            var obj = dictionary.get('Linearized');
            this.isValid = typeof obj !== 'undefined' && obj > 0;
        }
        if (this.isValid) {
            var length_1 = this.getInt(dictionary, 'L');
            if (length_1 !== stream.length) {
                throw new Error('The L parameter in the linearization dictionary ' + 'does not equal the stream length.');
            }
            this.length = length_1;
            this.hints = this.getHints(dictionary);
            this.objectNumberFirst = this.getInt(dictionary, 'O');
            this.endFirst = this.getInt(dictionary, 'E');
            this.pageCount = this.getInt(dictionary, 'N');
            this.mainXRefEntriesOffset = this.getInt(dictionary, 'T');
            this.pageFirst = dictionary.has('P') ? this.getInt(dictionary, 'P', true) : 0;
        }
    }
    _Linearization.prototype.getInt = function (dictionary, name, allowZeroValue) {
        if (allowZeroValue === void 0) { allowZeroValue = false; }
        var obj = dictionary.get(name);
        if (typeof obj !== 'undefined' && Number.isInteger(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {
            return obj;
        }
        throw new Error("The '" + name + "' parameter in the linearization " + 'dictionary is invalid.');
    };
    _Linearization.prototype.getHints = function (dictionary) {
        var hints = dictionary.getArray('H');
        var hintsLength = hints.length;
        if (hints && (hintsLength === 2 || hintsLength === 4)) {
            for (var index = 0; index < hintsLength; index++) {
                var hint = hints[index];
                if (!(Number.isInteger(hint) && hint > 0)) {
                    throw new Error("Hint (" + index + ") in the linearization dictionary is invalid.");
                }
            }
            return hints;
        }
        throw new Error('Hint array in the linearization dictionary is invalid.');
    };
    return _Linearization;
}());
/* eslint-enable */

var _PdfCrossReference = /** @class */ (function () {
    function _PdfCrossReference(document, password) {
        this._version = '';
        this._newLine = '\r\n';
        this._password = password;
        this._document = document;
        this._stream = document._stream;
        this._entries = [];
        this._crossReferencePosition = Object.create(null);
        this._cacheMap = new Map(); // eslint-disable-line
        this._offsetReference = new Map(); // eslint-disable-line
        this._pendingRefs = new _PdfReferenceSet();
        this._offsets = [];
    }
    _PdfCrossReference.prototype._setStartXRef = function (startXRef) {
        this._startXRefQueue = [startXRef];
        this._prevStartXref = startXRef;
        if (typeof this._prevXRefOffset === 'undefined' || this._prevXRefOffset === null) {
            this._prevXRefOffset = startXRef;
        }
    };
    _PdfCrossReference.prototype._parse = function (recoveryMode) {
        var trailerDictionary;
        if (!recoveryMode) {
            trailerDictionary = this._readXRef();
        }
        else {
            trailerDictionary = this._indexObjects();
        }
        trailerDictionary.assignXref(this);
        var entrySize = trailerDictionary.get('Size');
        if (this._entries.length < entrySize || this._entries.length === entrySize) {
            this._nextReferenceNumber = entrySize;
        }
        else if (this._entries.length > entrySize) {
            this._nextReferenceNumber = this._entries.length > 0 ? this._entries.length : 1;
        }
        this._trailer = trailerDictionary;
        var encrypt = trailerDictionary.get('Encrypt');
        if (encrypt) {
            this._document._isEncrypted = true;
            this._ids = trailerDictionary.get('ID');
            this._permissionFlags = encrypt.get('P');
            var fileId = this._ids && this._ids.length ? this._ids[0] : '';
            encrypt.suppressEncryption = true;
            this._encrypt = new _PdfEncryptor(encrypt, fileId, this._password);
            this._document._isUserPassword = this._encrypt._isUserPassword;
            this._document._encryptOnlyAttachment = this._encrypt._encryptOnlyAttachment;
            if (this._document.fileStructure.isIncrementalUpdate) {
                this._document.fileStructure.crossReferenceType = PdfCrossReferenceType.stream;
            }
            else {
                this._document.fileStructure.crossReferenceType = PdfCrossReferenceType.table;
            }
            if (this._encrypt._encryptOnlyAttachment) {
                this._document._hasUserPasswordOnly = true;
                this._document._encryptMetaData = false;
            }
            else {
                this._document._hasUserPasswordOnly = this._encrypt._hasUserPasswordOnly;
                this._document._encryptMetaData = encrypt.has('EncryptMetadata') ? encrypt.get('EncryptMetadata') : true;
            }
        }
        var hasRoot = false;
        var root;
        try {
            root = trailerDictionary.get('Root');
        }
        catch (e) {
            throw new BaseException('Invalid cross reference', 'XRefParseException');
        }
        if (root) {
            try {
                var pagesEntry = root.get('Pages');
                if (pagesEntry) {
                    this._root = root;
                    hasRoot = true;
                }
            }
            catch (ex) {
                throw new BaseException('Invalid cross reference', 'InvalidXRef');
            }
        }
        if (!hasRoot) {
            if (!recoveryMode) {
                throw new BaseException('Invalid cross reference', 'XRefParseException');
            }
            else {
                throw new BaseException('Invalid cross reference', 'InvalidXRef');
            }
        }
    };
    _PdfCrossReference.prototype._getEntry = function (i) {
        var xrefEntry = this._entries[i]; // eslint-disable-line
        if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
            return xrefEntry;
        }
        return null;
    };
    _PdfCrossReference.prototype._fetch = function (ref, suppressEncryption) {
        var entry; // eslint-disable-line
        if (!(ref instanceof _PdfReference)) {
            throw new Error('ref object is not a reference');
        }
        var objectNumber = ref.objectNumber;
        var cacheEntry = this._cacheMap.get(ref); // eslint-disable-line
        if (typeof cacheEntry !== 'undefined') {
            if (cacheEntry instanceof _PdfDictionary && !cacheEntry.objId) {
                cacheEntry.objId = objectNumber;
            }
            return cacheEntry;
        }
        var xrefEntry = this._getEntry(objectNumber);
        if (xrefEntry === null) {
            this._cacheMap.set(ref, xrefEntry);
            return xrefEntry;
        }
        if (this._pendingRefs.has(ref)) {
            this._pendingRefs.remove(ref);
            throw new Error('circular reference');
        }
        this._pendingRefs.put(ref);
        try {
            if (xrefEntry.uncompressed) {
                entry = this._fetchUncompressed(ref, xrefEntry, suppressEncryption);
            }
            else {
                entry = this._fetchCompressed(ref, xrefEntry);
            }
            this._pendingRefs.remove(ref);
        }
        catch (ex) {
            this._pendingRefs.remove(ref);
            throw ex;
        }
        return entry;
    };
    _PdfCrossReference.prototype._fetchUncompressed = function (reference, xrefEntry, makeFilter) {
        var generationNumber = reference.generationNumber;
        var objectNumber = reference.objectNumber;
        if (xrefEntry.gen !== generationNumber) {
            throw new BaseException("Inconsistent generation in XRef: " + reference, 'XRefEntryException');
        }
        var stream = this._stream.makeSubStream(xrefEntry.offset + this._stream.start, undefined);
        var parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true, false, this._encrypt);
        var obj1 = parser.getObject();
        var obj2 = parser.getObject();
        var obj3 = parser.getObject();
        if (obj1 !== objectNumber || obj2 !== generationNumber || typeof obj3 === 'undefined') {
            throw new BaseException("Bad (uncompressed) XRef entry: " + reference, 'XRefEntryException');
        }
        var entry; // eslint-disable-line
        if (this._encrypt && !makeFilter) {
            entry = parser.getObject(reference.objectNumber, reference.generationNumber, true);
        }
        else {
            entry = parser.getObject(null, makeFilter);
        }
        if (!(entry instanceof _PdfBaseStream)) {
            this._cacheMap.set(reference, entry);
        }
        if (entry instanceof _PdfDictionary) {
            entry.objId = reference.toString();
        }
        else if (entry instanceof _PdfBaseStream) {
            entry.dictionary.objId = reference.toString();
        }
        return entry;
    };
    _PdfCrossReference.prototype._fetchCompressed = function (ref, xrefEntry) {
        var tableOffset = xrefEntry.offset;
        var stream = this._fetch(_PdfReference.get(tableOffset, 0));
        if (typeof stream === 'undefined') {
            throw new FormatError('bad ObjStm stream');
        }
        var first = stream.dictionary.get('First');
        var n = stream.dictionary.get('N');
        var gen = ref.generationNumber;
        if (!Number.isInteger(first) || !Number.isInteger(n)) {
            throw new FormatError('invalid first and n parameters for ObjStm stream');
        }
        var parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true);
        var nums = new Array(n);
        var offsets = new Array(n);
        for (var i = 0; i < n; ++i) {
            var value = parser.getObject();
            if (!Number.isInteger(value)) {
                throw new FormatError("invalid object number in the ObjStm stream: " + value);
            }
            var offset = parser.getObject();
            if (!Number.isInteger(offset)) {
                throw new FormatError("invalid object offset in the ObjStm stream: " + offset);
            }
            nums[i] = value; // eslint-disable-line
            offsets[i] = offset; // eslint-disable-line
        }
        var start = (stream.start || 0) + first;
        var entries = new Array(n); // eslint-disable-line
        for (var i = 0; i < n; ++i) {
            var length_1 = (i < n - 1 ? (offsets[i + 1] - offsets[i]) : undefined); // eslint-disable-line
            if (length_1 < 0) {
                throw new FormatError('Invalid offset in the ObjStm stream.');
            }
            parser = new _PdfParser(new _PdfLexicalOperator(stream.makeSubStream(start + offsets[i], length_1, stream.dictionary)), this, true); // eslint-disable-line
            var obj = parser.getObject(); // eslint-disable-line
            entries[i] = obj; // eslint-disable-line
            if (obj instanceof _PdfBaseStream) {
                continue;
            }
            var value = nums[i]; // eslint-disable-line
            var entry = this._entries[value]; // eslint-disable-line
            if (entry && entry.offset === tableOffset && entry.gen === i) {
                var objId = value + " " + gen;
                this._cacheMap.set(_PdfReference.get(value, gen), obj);
                if (obj instanceof _PdfDictionary) {
                    obj.objId = objId;
                }
            }
        }
        var result = entries[xrefEntry.gen]; // eslint-disable-line
        if (typeof result === 'undefined') {
            throw new BaseException("Bad (compressed) XRef entry: " + ref, 'XRefEntryException');
        }
        return result;
    };
    _PdfCrossReference.prototype._readXRef = function (recoveryMode) {
        if (recoveryMode === void 0) { recoveryMode = false; }
        var stream = this._stream;
        var startXRefParsedCache = new Set();
        try {
            while (this._startXRefQueue.length) {
                var startXRef = this._startXRefQueue[0];
                if (this._prevStartXref < startXRef) {
                    this._prevStartXref = startXRef;
                }
                if (startXRefParsedCache.has(startXRef)) {
                    this._startXRefQueue.shift();
                    continue;
                }
                startXRefParsedCache.add(startXRef);
                stream.position = startXRef + stream.start;
                var parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true);
                var obj = parser.getObject(); // eslint-disable-line
                var dictionary = void 0;
                if (_isCommand(obj, 'xref')) {
                    if (typeof this._document._fileStructure._crossReferenceType === 'undefined') {
                        this._document._fileStructure._crossReferenceType = PdfCrossReferenceType.table;
                    }
                    dictionary = this._processXRefTable(parser);
                    if (!this._topDictionary) {
                        this._topDictionary = dictionary;
                    }
                    obj = dictionary.get('XRefStm');
                    if (Number.isInteger(obj)) {
                        var position = obj; // eslint-disable-line
                        if (!(position in this._crossReferencePosition)) {
                            this._crossReferencePosition[position] = 1; // eslint-disable-line
                            this._startXRefQueue.push(position);
                        }
                    }
                }
                else if (Number.isInteger(obj)) {
                    if (typeof this._document._fileStructure._crossReferenceType === 'undefined') {
                        this._document._fileStructure._crossReferenceType = PdfCrossReferenceType.stream;
                    }
                    var gen = parser.getObject();
                    var command = parser.getObject();
                    obj = parser.getObject();
                    if (typeof gen === 'undefined' ||
                        !Number.isInteger(gen) ||
                        !_isCommand(command, 'obj') ||
                        !(obj instanceof _PdfBaseStream)) {
                        throw new FormatError('Invalid cross reference stream');
                    }
                    dictionary = this._processXRefStream(obj);
                    if (!this._topDictionary) {
                        this._topDictionary = dictionary;
                    }
                    if (!dictionary) {
                        throw new FormatError('Failed to read XRef stream');
                    }
                }
                else {
                    throw new FormatError('Invalid XRef stream header');
                }
                obj = dictionary.get('Prev');
                if (Number.isInteger(obj)) {
                    this._startXRefQueue.push(obj);
                }
                else if (obj instanceof _PdfReference) {
                    this._startXRefQueue.push(obj.objectNumber);
                }
                this._startXRefQueue.shift();
            }
            return this._topDictionary;
        }
        catch (e) {
            this._startXRefQueue.shift();
        }
        if (recoveryMode) {
            return undefined;
        }
        throw new BaseException('Invalid cross reference', 'XRefParseException');
    };
    _PdfCrossReference.prototype._readToken = function (data, offset) {
        var lf = 0xa;
        var cr = 0xd;
        var lt = 0x3c;
        var token = '';
        var ch = data[offset]; // eslint-disable-line
        while (ch !== lf && ch !== cr && ch !== lt) {
            if (++offset >= data.length) {
                break;
            }
            token += String.fromCharCode(ch);
            ch = data[offset]; // eslint-disable-line
        }
        return token;
    };
    _PdfCrossReference.prototype._skipUntil = function (data, offset, what) {
        var length = what.length;
        var dataLength = data.length;
        var skipped = 0;
        while (offset < dataLength) {
            var i = 0;
            while (i < length && data[offset + i] === what[i]) { // eslint-disable-line
                ++i;
            }
            if (i >= length) {
                break;
            }
            offset++;
            skipped++;
        }
        return skipped;
    };
    _PdfCrossReference.prototype._indexObjects = function () {
        var tab = 0x9;
        var lf = 0xa;
        var cr = 0xd;
        var space = 0x20;
        var percent = 0x25;
        var objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
        var endobjRegExp = /\bendobj[\b\s]$/;
        var nestedObjRegExp = /\s+(\d+\s+\d+\s+obj[\b\s<])$/;
        var checkContentLength = 25;
        var trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
        var startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
        var objBytes = new Uint8Array([111, 98, 106]);
        var xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
        this._entries.length = 0;
        this._cacheMap.clear();
        var stream = this._stream;
        stream.position = 0;
        var buffer = stream.getBytes();
        var length = buffer.length;
        var position = stream.start;
        var trailers = [];
        var crossReferencePosition = [];
        while (position < length) {
            var ch = buffer[position]; // eslint-disable-line
            if (ch === tab || ch === lf || ch === cr || ch === space) {
                ++position;
                continue;
            }
            if (ch === percent) {
                do {
                    ++position;
                    if (position >= length) {
                        break;
                    }
                    ch = buffer[position]; // eslint-disable-line
                } while (ch !== lf && ch !== cr);
                continue;
            }
            var token = this._readToken(buffer, position);
            var m = void 0; // eslint-disable-line
            if (token.startsWith('xref') && (token.length === 4 || /\s/.test(token[4]))) {
                position += this._skipUntil(buffer, position, trailerBytes);
                trailers.push(position);
                position += this._skipUntil(buffer, position, startxrefBytes);
            }
            else {
                m = objRegExp.exec(token);
                if (m) {
                    var objectNumber = Number.parseInt(m[1]) | 0; // eslint-disable-line
                    var gen = Number.parseInt(m[2]) | 0; // eslint-disable-line
                    var contentLength = void 0;
                    var startPos = position + token.length;
                    var updateEntries = false;
                    if (!this._entries[objectNumber]) { // eslint-disable-line
                        updateEntries = true;
                    }
                    else if (this._entries[objectNumber].gen === gen) { // eslint-disable-line
                        try {
                            var subStream = stream.makeSubStream(startPos, stream.length - startPos);
                            var lexicalOperator = new _PdfLexicalOperator(subStream);
                            var parser = new _PdfParser(lexicalOperator, null);
                            parser.getObject();
                            updateEntries = true;
                        }
                        catch (ex) {
                            updateEntries = !(ex instanceof ParserEndOfFileException);
                        }
                    }
                    if (updateEntries) {
                        var info = new _PdfObjectInformation();
                        info.offset = position - stream.start;
                        info.gen = gen;
                        info.uncompressed = true;
                        this._entries[objectNumber] = info; // eslint-disable-line
                    }
                    while (startPos < buffer.length) {
                        var endPos = startPos + this._skipUntil(buffer, startPos, objBytes) + 4;
                        contentLength = endPos - position;
                        var checkPos = Math.max(endPos - checkContentLength, startPos);
                        var tokenStr = _bytesToString(buffer.subarray(checkPos, endPos));
                        if (endobjRegExp.test(tokenStr)) {
                            break;
                        }
                        else {
                            var objToken = nestedObjRegExp.exec(tokenStr); // eslint-disable-line
                            if (objToken && objToken[1]) {
                                contentLength -= objToken[1].length;
                                break;
                            }
                        }
                        startPos = endPos;
                    }
                    var content = buffer.subarray(position, position + contentLength);
                    var xrefTagOffset = this._skipUntil(content, 0, xrefBytes);
                    if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
                        crossReferencePosition.push(position - stream.start);
                        this._crossReferencePosition[position - stream.start] = 1;
                    }
                    position += contentLength;
                }
                else if (token.startsWith('trailer') && (token.length === 7 || /\s/.test(token[7]))) {
                    trailers.push(position);
                    position += this._skipUntil(buffer, position, startxrefBytes);
                }
                else {
                    position += token.length + 1;
                }
            }
        }
        for (var i = 0; i < crossReferencePosition.length; ++i) {
            this._startXRefQueue.push(crossReferencePosition[i]); // eslint-disable-line
            this._readXRef(true);
        }
        var trailerDict;
        for (var i = 0; i < trailers.length; ++i) {
            stream.position = trailers[i]; // eslint-disable-line
            var parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true, true);
            var obj = parser.getObject(); // eslint-disable-line
            if (!_isCommand(obj, 'trailer')) {
                continue;
            }
            var dictionary = parser.getObject(); // eslint-disable-line
            if (!(dictionary instanceof _PdfDictionary)) {
                continue;
            }
            try {
                var rootDict = dictionary.get('Root'); // eslint-disable-line
                if (!(rootDict instanceof _PdfDictionary)) {
                    continue;
                }
                var pagesDict = rootDict.get('Pages'); // eslint-disable-line
                if (!(pagesDict instanceof _PdfDictionary)) {
                    continue;
                }
                var pagesCount = pagesDict.get('Count');
                if (typeof pagesCount === 'undefined' || !Number.isInteger(pagesCount)) {
                    continue;
                }
            }
            catch (ex) {
                continue;
            }
            if (dictionary.has('ID')) {
                return dictionary;
            }
            trailerDict = dictionary;
        }
        if (trailerDict) {
            return trailerDict;
        }
        if (this._topDictionary) {
            return this._topDictionary;
        }
        throw new BaseException('Invalid PDF structure.', 'InvalidPDFException');
    };
    _PdfCrossReference.prototype._processXRefTable = function (parser) {
        if (typeof this._tableState === 'undefined') {
            var tableState = new _PdfCrossTableState();
            tableState.entryNum = 0;
            tableState.streamPos = parser.lexicalOperator.stream.position;
            tableState.parserBuf1 = parser.first;
            tableState.parserBuf2 = parser.second;
            this._tableState = tableState;
        }
        var obj = this._readXRefTable(parser);
        if (!_isCommand(obj, 'trailer')) {
            throw new FormatError('Invalid XRef table: could not find trailer dictionary');
        }
        var topDictionary = parser.getObject(); // eslint-disable-line
        var dictionary;
        if (topDictionary) {
            if (topDictionary instanceof _PdfDictionary) {
                dictionary = topDictionary;
            }
            else if (topDictionary instanceof _PdfBaseStream && topDictionary.dictionary) {
                dictionary = topDictionary.dictionary;
            }
        }
        if (!dictionary) {
            throw new FormatError('Invalid cross reference: could not parse trailer dictionary');
        }
        this._tableState = undefined;
        return dictionary;
    };
    _PdfCrossReference.prototype._readXRefTable = function (parser) {
        var stream = parser.lexicalOperator.stream;
        stream.position = this._tableState.streamPos;
        parser.first = this._tableState.parserBuf1;
        parser.second = this._tableState.parserBuf2;
        var obj; // eslint-disable-line
        while (true) { // eslint-disable-line
            if (typeof this._tableState.firstEntryNum === 'undefined' || typeof this._tableState.entryCount === 'undefined') {
                obj = parser.getObject();
                if (_isCommand(obj, 'trailer')) {
                    break;
                }
                this._tableState.firstEntryNum = obj;
                this._tableState.entryCount = parser.getObject();
            }
            var first = this._tableState.firstEntryNum;
            var count = this._tableState.entryCount;
            if (!Number.isInteger(first) || !Number.isInteger(count)) {
                throw new FormatError('Invalid cross reference: wrong types in subsection header');
            }
            for (var i = this._tableState.entryNum; i < count; i++) {
                this._tableState.streamPos = stream.position;
                this._tableState.entryNum = i;
                this._tableState.parserBuf1 = parser.first;
                this._tableState.parserBuf2 = parser.second;
                var entry = new _PdfObjectInformation();
                entry.offset = parser.getObject();
                entry.gen = parser.getObject();
                var type = parser.getObject();
                if (type) {
                    switch (type.command) {
                        case 'f':
                            entry.free = true;
                            break;
                        case 'n':
                            entry.uncompressed = true;
                            break;
                    }
                }
                if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {
                    throw new FormatError("Invalid entry in cross reference subsection: " + first + ", " + count);
                }
                if (i === 0 && entry.free && first === 1) {
                    first = 0;
                }
                if (!this._entries[i + first]) {
                    this._entries[i + first] = entry;
                }
            }
            this._tableState.entryNum = 0;
            this._tableState.streamPos = stream.position;
            this._tableState.parserBuf1 = parser.first;
            this._tableState.parserBuf2 = parser.second;
            this._tableState.firstEntryNum = undefined;
            this._tableState.entryCount = undefined;
        }
        if (this._entries[0] && !this._entries[0].free) {
            throw new FormatError('Invalid XRef table: unexpected first object');
        }
        return obj;
    };
    _PdfCrossReference.prototype._processXRefStream = function (stream) {
        if (typeof this._streamState === 'undefined') {
            var streamParameters = stream.dictionary;
            var streamState = new _PdfStreamState();
            var index = streamParameters.getArray('Index');
            if (!index) {
                index = [0, streamParameters.get('Size')];
            }
            streamState.entryRanges = index;
            streamState.byteWidths = streamParameters.getArray('W');
            streamState.entryNum = 0;
            streamState.streamPos = stream.position;
            this._streamState = streamState;
        }
        this._readXRefStream(stream);
        this._streamState = undefined;
        return stream.dictionary;
    };
    _PdfCrossReference.prototype._readXRefStream = function (stream) {
        stream.position = this._streamState.streamPos;
        var typeFieldWidth = this._streamState.byteWidths[0];
        var offsetFieldWidth = this._streamState.byteWidths[1];
        var generationFieldWidth = this._streamState.byteWidths[2];
        var entryRanges = this._streamState.entryRanges;
        while (entryRanges.length > 0) {
            var first = entryRanges[0];
            var n = entryRanges[1];
            if (!Number.isInteger(first) || !Number.isInteger(n)) {
                throw new FormatError("Invalid XRef range fields: " + first + ", " + n);
            }
            if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {
                throw new FormatError("Invalid XRef entry fields length: " + first + ", " + n);
            }
            for (var i = this._streamState.entryNum; i < n; ++i) {
                this._streamState.entryNum = i;
                this._streamState.streamPos = stream.position;
                var type = 0;
                var offset = 0;
                var generation = 0;
                for (var j = 0; j < typeFieldWidth; ++j) {
                    var typeByte = stream.getByte();
                    if (typeByte === -1) {
                        throw new FormatError('invalid cross reference byte width type.');
                    }
                    type = (type << 8) | typeByte;
                }
                if (typeFieldWidth === 0) {
                    type = 1;
                }
                for (var j = 0; j < offsetFieldWidth; ++j) {
                    var offsetByte = stream.getByte();
                    if (offsetByte === -1) {
                        throw new FormatError('invalid cross reference byte width offset.');
                    }
                    offset = (offset << 8) | offsetByte;
                }
                for (var j = 0; j < generationFieldWidth; ++j) {
                    var generationByte = stream.getByte();
                    if (generationByte === -1) {
                        throw new FormatError('invalid cross reference byte width generation.');
                    }
                    generation = (generation << 8) | generationByte;
                }
                var entry = new _PdfObjectInformation();
                entry.offset = offset;
                entry.gen = generation;
                switch (type) {
                    case 0:
                        entry.free = true;
                        break;
                    case 1:
                        entry.uncompressed = true;
                        break;
                    case 2:
                        break;
                    default:
                        throw new FormatError("Invalid XRef entry type: " + type);
                }
                if (!this._entries[first + i]) {
                    this._entries[first + i] = entry;
                }
            }
            this._streamState.entryNum = 0;
            this._streamState.streamPos = stream.position;
            entryRanges.splice(0, 2);
        }
    };
    _PdfCrossReference.prototype._getCatalogObj = function () {
        return this._root;
    };
    _PdfCrossReference.prototype._save = function () {
        var buffer = [37, 80, 68, 70, 45];
        this._writeString("" + this._version + this._newLine, buffer);
        buffer.push(0x25, 0x83, 0x92, 0xfa, 0xfe);
        this._writeString(this._newLine, buffer);
        if (!this._document.fileStructure.isIncrementalUpdate) {
            this._currentLength = 0;
            var objectCollection = new _PdfMainObjectCollection(this);
            this._writeObjectCollection(objectCollection._mainObjectCollection, buffer);
            var stream = new _PdfStream(buffer);
            this._stream = stream;
            this._document._stream = stream;
            var array = new Uint8Array(this._stream.length);
            array.set(this._stream.bytes);
            array.set(buffer, 0);
            return array;
        }
        else {
            this._currentLength = this._stream.length;
            var buffer_1 = [37, 80, 68, 70, 45];
            this._writeString("" + this._version + this._newLine, buffer_1);
            buffer_1.push(0x25, 0x83, 0x92, 0xfa, 0xfe);
            this._writeString(this._newLine, buffer_1);
            if (this._document._fileStructure._crossReferenceType === PdfCrossReferenceType.stream) {
                this._saveAsStream(this._currentLength, buffer_1);
            }
            else {
                this._saveAsTable(this._currentLength, buffer_1);
            }
            var array = new Uint8Array(this._stream.length + buffer_1.length);
            array.set(this._stream.bytes);
            array.set(buffer_1, this._stream.length);
            return array;
        }
    };
    _PdfCrossReference.prototype._saveAsStream = function (currentLength, buffer) {
        var _this = this;
        var objectStreamCollection = new Map();
        this._indexes = [];
        this._indexes.push(0, 1);
        this._cacheMap.forEach(function (value, key) {
            var dictionary;
            if (value instanceof _PdfBaseStream) {
                dictionary = value.dictionary;
            }
            if (dictionary && dictionary._updated && (!dictionary.isCatalog || _this._allowCatalog)) {
                var cipher = void 0;
                if (_this._encrypt) {
                    cipher = _this._encrypt._createCipherTransform(key.objectNumber, key.generationNumber);
                }
                _this._updatedDictionary(currentLength, key, buffer, value, cipher);
            }
        });
        this._cacheMap.forEach(function (value, key) {
            if (value instanceof _PdfDictionary) {
                if (value._updated && (!value.isCatalog || _this._allowCatalog)) {
                    _this._writeArchiveStream(objectStreamCollection, key, value);
                }
            }
            else if (value instanceof _PdfBaseStream) {
                var dictionary = value.dictionary;
                if (dictionary && dictionary._updated && (!dictionary.isCatalog || _this._allowCatalog)) {
                    _this._updatedDictionary(currentLength, key, buffer, value);
                }
            }
        });
        this._objectStream = undefined;
        this._objectStreamCollection = objectStreamCollection;
        this._writeXrefStream(buffer);
    };
    _PdfCrossReference.prototype._updatedDictionary = function (currentLength, key, buffer, value, // eslint-disable-line
    cipher) {
        this._indexes.push(key.objectNumber, 1);
        this._offsets.push(currentLength + buffer.length);
        this._writeObject(value, buffer, key, cipher);
        value._updated = false;
    };
    _PdfCrossReference.prototype._writeXrefStream = function (buffer) {
        var _this = this;
        this._objectStreamCollection.forEach(function (value, key) {
            value._save(buffer, _this._currentLength);
            for (var i = 0; i < value._collection.length; i++) {
                _this._indexes.push(value._collection[Number.parseInt(i.toString(), 10)]);
            }
            _this._indexes.push(key.objectNumber, 1);
        });
        var formatValue = Math.max(_getSize(this._currentLength + buffer.length), _getSize(this._nextReferenceNumber));
        var newRef = this._getNextReference();
        this._indexes.push(newRef.objectNumber, 1);
        var newStartXref = this._currentLength + buffer.length;
        var newXref = new _PdfDictionary(this);
        newXref.set('Type', _PdfName.get('XRef'));
        newXref.set('Index', this._indexes);
        newXref.set('W', [1, formatValue, 1]);
        this._copyTrailer(newXref);
        if (this._ids && this._ids.length > 0) {
            newXref.update('ID', [this._ids[0], this._computeMessageDigest(newStartXref)]);
        }
        var newXrefData = [];
        this._writeLong(0, 1, newXrefData);
        this._writeLong(0, formatValue, newXrefData);
        this._writeLong(-1, 1, newXrefData);
        if (this._offsets.length > 0) {
            for (var index = 0; index < this._offsets.length; index++) {
                this._writeLong(1, 1, newXrefData);
                this._writeLong(this._offsets[index], formatValue, newXrefData); // eslint-disable-line
                this._writeLong(0, 1, newXrefData);
            }
        }
        if (this._objectStreamCollection.size > 0) {
            this._objectStreamCollection.forEach(function (value, key) {
                for (var index = 0; index < value._length; index++) {
                    _this._writeLong(2, 1, newXrefData);
                    _this._writeLong(key.objectNumber, formatValue, newXrefData);
                    _this._writeLong(index, 1, newXrefData);
                }
                _this._writeLong(1, 1, newXrefData);
                _this._writeLong(value._archiveOffset, formatValue, newXrefData);
                _this._writeLong(0, 1, newXrefData);
            });
        }
        this._writeLong(1, 1, newXrefData);
        this._writeLong(newStartXref, formatValue, newXrefData);
        this._writeLong(0, 1, newXrefData);
        newXref.set('Length', newXrefData.length);
        var newXrefStream = new _PdfStream(newXrefData, newXref, 0, newXrefData.length);
        var cipher;
        if (this._encrypt) {
            cipher = this._encrypt._createCipherTransform(newRef.objectNumber, newRef.generationNumber);
        }
        this._writeObject(newXrefStream, buffer, newRef, cipher, true);
        this._writeString("startxref" + this._newLine + newStartXref + this._newLine + "%%EOF" + this._newLine, buffer);
    };
    _PdfCrossReference.prototype._saveAsTable = function (currentLength, buffer) {
        var _this = this;
        var tempBuffer = '';
        this._cacheMap.forEach(function (value, key) {
            var dictionary;
            if (value instanceof _PdfDictionary) {
                dictionary = value;
            }
            else if (value instanceof _PdfBaseStream) {
                dictionary = value.dictionary;
            }
            if (dictionary && dictionary._updated && (!dictionary.isCatalog || _this._allowCatalog)) {
                var offsetString = _this._processString((currentLength + buffer.length).toString(), 10);
                var genString = _this._processString(key.generationNumber.toString(), 5);
                tempBuffer += key.objectNumber + " 1" + _this._newLine + offsetString + " " + genString + " n" + _this._newLine;
                _this._writeObject(value, buffer, key);
            }
        });
        var newStartXref = buffer.length + currentLength;
        this._writeString("xref" + this._newLine + "0 1" + this._newLine + "0000000000 65535 f" + this._newLine, buffer);
        this._writeXref(buffer, tempBuffer, newStartXref);
    };
    _PdfCrossReference.prototype._writeXref = function (buffer, tempBuffer, newStartXref) {
        this._writeString(tempBuffer, buffer);
        this._writeString("trailer" + this._newLine, buffer);
        var newXref = new _PdfDictionary(this);
        this._copyTrailer(newXref);
        this._writeDictionary(newXref, buffer, this._newLine);
        this._writeString("startxref" + this._newLine + newStartXref + this._newLine + "%%EOF" + this._newLine, buffer);
    };
    _PdfCrossReference.prototype._writeXrefTable = function (buffer) {
        var _this = this;
        var tempBuffer = '';
        var collection = this._getSortedReferences(this._offsetReference); // eslint-disable-line
        collection.forEach(function (value, key) {
            var offsetString = _this._processString(value.toString(), 10);
            var genString = _this._processString(key.generationNumber ? '0' : '', 5);
            if (value !== 0) {
                tempBuffer += offsetString + " " + genString + " n" + _this._newLine;
            }
            else {
                tempBuffer += offsetString + " " + genString + " f" + _this._newLine;
            }
        });
        var newStartXref = buffer.length;
        var xrefHeader = "xref" + this._newLine;
        var xrefEntry = "0 " + (collection.size + 1) + this._newLine;
        var initialEntry = "0000000000 65535 f" + this._newLine;
        this._writeString(xrefHeader + xrefEntry + initialEntry, buffer);
        this._writeXref(buffer, tempBuffer, newStartXref);
    };
    _PdfCrossReference.prototype._processString = function (value, length) {
        while (value.length < length) {
            value = '0' + value;
        }
        return value;
    };
    _PdfCrossReference.prototype._copyTrailer = function (newXref) {
        var reference = this._getNextReference();
        newXref.set('Size', reference.objectNumber);
        if (this._document.fileStructure.isIncrementalUpdate) {
            newXref.set('Prev', this._prevXRefOffset);
        }
        var root = this._trailer.getRaw('Root'); // eslint-disable-line
        if (typeof root !== 'undefined' && root !== null) {
            newXref.set('Root', root);
        }
        var info = this._trailer.getRaw('Info'); // eslint-disable-line
        if (typeof info !== 'undefined' && info !== null) {
            newXref.set('Info', info);
        }
        var encrypt = this._trailer.getRaw('Encrypt'); // eslint-disable-line
        if (typeof encrypt !== 'undefined' && encrypt !== null) {
            newXref.set('Encrypt', encrypt);
        }
    };
    _PdfCrossReference.prototype._computeMessageDigest = function (size) {
        var _this = this;
        var time = Math.floor(Date.now() / 1000);
        var buffer = [time.toString(), '', size.toString()];
        var info = this._trailer.getRaw('Info');
        var crossReferenceInfo = new _PdfDictionary();
        if (info && info instanceof _PdfDictionary) {
            info.forEach(function (key, value) {
                if (value && typeof value === 'string') {
                    crossReferenceInfo.set(key, _stringToPdfString(value));
                }
            });
        }
        crossReferenceInfo.forEach(function (key, value) {
            buffer.push(value);
        });
        var array = [];
        buffer.forEach(function (str) {
            _this._writeString(str, array);
        });
        return _bytesToString((new _MD5().hash(new Uint8Array(array))));
    };
    _PdfCrossReference.prototype._getNextReference = function () {
        var reference = new _PdfReference(this._nextReferenceNumber++, 0);
        reference._isNew = true;
        return reference;
    };
    _PdfCrossReference.prototype._writeObject = function (obj, // eslint-disable-line
    buffer, reference, transform, isCrossReference) {
        var _this = this;
        if (reference && reference instanceof _PdfReference) {
            this._writeString(reference.objectNumber + " " + reference.generationNumber + " obj" + this._newLine, buffer);
        }
        if (obj instanceof _PdfDictionary) {
            this._writeDictionary(obj, buffer, this._newLine, transform, isCrossReference);
        }
        else if (obj instanceof _PdfBaseStream) {
            this._writeStream(obj, buffer, transform, isCrossReference);
        }
        else if (Array.isArray(obj) && obj.length > 0) {
            this._writeString('[ ', buffer);
            obj.forEach(function (value, index) {
                if (value instanceof _PdfReference) {
                    _this._writeString(value.objectNumber + " " + value.generationNumber + " R", buffer);
                }
                else if (Array.isArray(value)) {
                    _this._writeString('[ ', buffer);
                    value.forEach(function (nestedValue) {
                        if (nestedValue instanceof _PdfReference) {
                            _this._writeString(nestedValue.objectNumber + " " + nestedValue.generationNumber + " R", buffer);
                        }
                        else if (nestedValue instanceof _PdfName) {
                            _this._writeString("/" + nestedValue.name, buffer);
                        }
                        else {
                            _this._writeString(nestedValue + " ", buffer);
                        }
                    });
                    _this._writeString(']', buffer);
                }
                else if (value instanceof _PdfName) {
                    _this._writeString("/" + value.name, buffer);
                }
                else if (value instanceof _PdfDictionary) {
                    _this._writeDictionary(value, buffer, _this._newLine, transform, isCrossReference);
                }
                else {
                    _this._writeString(value + "\n", buffer);
                }
                if (index < obj.length - 1) {
                    _this._writeString(' ', buffer);
                }
            });
            this._writeString(']', buffer);
            this._writeString('\n', buffer);
        }
        else if (typeof obj === 'number') {
            this._writeString(obj + "\n", buffer);
        }
        if (reference && reference instanceof _PdfReference) {
            this._writeString("endobj" + this._newLine, buffer);
        }
    };
    _PdfCrossReference.prototype._writeDictionary = function (dictionary, buffer, spaceChar, transform, isCrossReference) {
        var _this = this;
        if (dictionary._currentObj) {
            dictionary._currentObj._beginSave();
        }
        if (dictionary._isFont) {
            this._writeFontDictionary(dictionary);
        }
        this._writeString("<<" + spaceChar, buffer);
        dictionary.forEach(function (key, value) {
            _this._writeString("/" + _escapePdfName(key) + " ", buffer);
            _this._writeValue(value, buffer, transform, isCrossReference);
            _this._writeString(spaceChar, buffer);
        });
        this._writeString(">>" + this._newLine, buffer);
    };
    _PdfCrossReference.prototype._writeFontDictionary = function (dictionary) {
        if (dictionary.has('DescendantFonts')) {
            var fonts = dictionary.get('DescendantFonts'); // eslint-disable-line
            var reference = this._getNextReference();
            this._cacheMap.set(reference, fonts);
            dictionary.update('DescendantFonts', [reference]);
        }
        if (dictionary.has('ToUnicode')) {
            var fonts = dictionary.get('ToUnicode'); // eslint-disable-line
            var reference = this._getNextReference();
            this._cacheMap.set(reference, fonts);
            dictionary.update('ToUnicode', reference);
        }
        if (dictionary.has('FontFile2')) {
            var fonts = dictionary.get('FontFile2'); // eslint-disable-line
            var reference = this._getNextReference();
            this._cacheMap.set(reference, fonts);
            dictionary.update('FontFile2', reference);
        }
        if (dictionary.has('FontDescriptor')) {
            var fonts = dictionary.get('FontDescriptor'); // eslint-disable-line
            var reference = this._getNextReference();
            this._cacheMap.set(reference, fonts);
            dictionary.update('FontDescriptor', reference);
        }
    };
    _PdfCrossReference.prototype._writeStream = function (stream, buffer, transform, isCrossReference) {
        var value;
        var streamBuffer = [];
        if (!isCrossReference) {
            if (stream._isCompress && !stream._isImage) {
                value = _compressStream(stream);
            }
            else {
                value = stream.getString();
            }
            if (transform) {
                value = transform.encryptString(value);
            }
        }
        else {
            value = stream.getString();
        }
        this._writeString(value, streamBuffer);
        stream.dictionary.update('Length', streamBuffer.length);
        this._writeDictionary(stream.dictionary, buffer, this._newLine, transform, isCrossReference);
        this._writeString("stream" + this._newLine, buffer);
        this._writeBytes(streamBuffer, buffer);
        this._writeString(this._newLine + "endstream" + this._newLine, buffer);
    };
    _PdfCrossReference.prototype._writeValue = function (value, buffer, transform, isCrossReference) {
        if (value instanceof _PdfName) {
            if (value.name.indexOf(' ') !== -1) {
                value.name = value.name.replace(/ /g, '#20'); // eslint-disable-line
            }
            this._writeString("/" + value.name, buffer);
        }
        else if (value instanceof _PdfReference) {
            this._writeString(value.toString() + " R", buffer);
        }
        else if (Array.isArray(value)) {
            this._writeString('[', buffer);
            var first = true;
            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                var val = value_1[_i];
                if (!first) {
                    this._writeString(' ', buffer);
                }
                else {
                    first = false;
                }
                this._writeValue(val, buffer, transform, isCrossReference);
            }
            this._writeString(']', buffer);
        }
        else if (typeof value === 'string') {
            if (!isCrossReference && transform) {
                value = transform.encryptString(value);
            }
            var isUnicode = false;
            for (var i = 0; i < value.length; i++) {
                if (value.charCodeAt([i]) > 255) {
                    isUnicode = true;
                    break;
                }
            }
            if (isUnicode) {
                this._writeUnicodeString(value, buffer);
            }
            else {
                this._writeString("(" + this._escapeString(value) + ")", buffer);
            }
        }
        else if (typeof value === 'number') {
            this._writeString(_numberToString(value), buffer);
        }
        else if (typeof value === 'boolean') {
            this._writeString(value.toString(), buffer);
        }
        else if (value instanceof _PdfDictionary) {
            this._writeDictionary(value, buffer, this._newLine, transform, isCrossReference);
        }
        else if (value instanceof _PdfBaseStream) {
            this._writeStream(value, buffer, transform, isCrossReference);
        }
        else if (value === null) {
            this._writeString('null', buffer);
        }
    };
    _PdfCrossReference.prototype._writeUnicodeString = function (value, buffer) {
        var byteValues = _stringToBigEndianBytes(value);
        byteValues.unshift(254, 255);
        var data = [];
        for (var i = 0; i < byteValues.length; i++) {
            var byte = byteValues[Number.parseInt(i.toString(), 10)];
            switch (byte) {
                case 40:
                case 41:
                    data.push(92);
                    data.push(byte);
                    break;
                case 13:
                    data.push(92);
                    data.push(114);
                    break;
                case 92:
                    data.push(92);
                    data.push(byte);
                    break;
                default:
                    data.push(byte);
                    break;
            }
        }
        buffer.push('('.charCodeAt(0) & 0xff);
        for (var i = 0; i < data.length; i++) {
            buffer.push(data[Number.parseInt(i.toString(), 10)] & 0xff);
        }
        buffer.push(')'.charCodeAt(0) & 0xff);
    };
    _PdfCrossReference.prototype._writeString = function (value, buffer) {
        for (var i = 0; i < value.length; i++) {
            buffer.push(value.charCodeAt(i) & 0xff);
        }
    };
    _PdfCrossReference.prototype._writeBytes = function (data, buffer) {
        for (var i = 0; i < data.length; i++) {
            buffer.push(data[i]); // eslint-disable-line
        }
    };
    _PdfCrossReference.prototype._writeLong = function (value, count, buffer) {
        for (var i = count - 1; i >= 0; --i) {
            buffer.push(value >> (i << 3) & 0xff);
        }
    };
    _PdfCrossReference.prototype._escapeString = function (value) {
        return value.replace(/([()\\\n\r])/g, function (substring) {
            if (substring === '\n') {
                return '\\n';
            }
            else if (substring === '\r') {
                return '\\r';
            }
            return "\\" + substring;
        });
    };
    _PdfCrossReference.prototype._destroy = function () {
        this._entries = undefined;
        if (this._pendingRefs) {
            this._pendingRefs.clear();
            this._pendingRefs = undefined;
        }
        if (this._cacheMap) {
            this._cacheMap.clear();
        }
        if (this._offsetReference) {
            this._offsetReference.clear();
        }
        if (this._objectStreamCollection) {
            this._objectStreamCollection.clear();
        }
        this._offsets = [];
        this._startXRefQueue = [];
        this._root = undefined;
        this._startXRefQueue = undefined;
        this._stream = undefined;
        this._streamState = undefined;
        this._tableState = undefined;
        this._topDictionary = undefined;
        this._trailer = undefined;
        this._version = undefined;
        this._crossReferencePosition = undefined;
    };
    _PdfCrossReference.prototype._writeObjectCollection = function (objectCollection, buffer) {
        var _this = this;
        var objectStreamCollection = new Map();
        this._indexes = [];
        this._indexes.push(0, 1);
        objectCollection.forEach(function (value, key) {
            _this._writeObjectToBuffer(key, value, buffer, objectStreamCollection);
        });
        if (this._cacheMap.size > objectCollection.size) {
            this._cacheMap.forEach(function (value, key) {
                if (!objectCollection.has(key)) {
                    _this._writeObjectToBuffer(key, value, buffer, objectStreamCollection);
                }
            });
        }
        if (this._document.fileStructure._crossReferenceType === PdfCrossReferenceType.stream) {
            this._objectStream = undefined;
            this._objectStreamCollection = objectStreamCollection;
            this._writeXrefStream(buffer);
        }
        else {
            this._writeXrefTable(buffer);
        }
    };
    _PdfCrossReference.prototype._writeArchiveStream = function (objectStreamCollection, key, value) {
        if (typeof this._objectStream === 'undefined' || this._objectStream._length === 100) {
            var archiveObj = new _PdfArchievedStream(this);
            objectStreamCollection.set(archiveObj._reference, archiveObj);
            this._objectStream = archiveObj;
        }
        this._objectStream._writeObject(key, value);
    };
    _PdfCrossReference.prototype._writeObjectToBuffer = function (key, value, buffer, // eslint-disable-line
    objectStreamCollection) {
        var cipher;
        if (value instanceof _PdfDictionary && value.isCatalog) {
            this._writeToBuffer(buffer, key, value);
        }
        else if (value instanceof _PdfDictionary) {
            var type = value.get('Filter');
            var typeIsFilter = type && type.name === 'Standard';
            if (this._document.fileStructure._crossReferenceType === PdfCrossReferenceType.stream) {
                if (!typeIsFilter) {
                    this._writeArchiveStream(objectStreamCollection, key, value);
                }
                else {
                    this._writeToBuffer(buffer, key, value);
                }
            }
            else {
                this._offsetReference.set(key, buffer.length);
                this._indexes.push(key.objectNumber, 1);
                this._writeObject(value, buffer, key);
            }
        }
        else {
            if (value instanceof _PdfBaseStream) {
                var dictionary = value.dictionary;
                if (dictionary && dictionary._updated && !dictionary.isCatalog) {
                    if (this._encrypt) {
                        cipher = this._encrypt._createCipherTransform(key.objectNumber, key.generationNumber);
                    }
                    dictionary._updated = false;
                }
            }
            else if ((!Array.isArray(value) || value.length === 0) && typeof value !== 'number') {
                return;
            }
            this._writeToBuffer(buffer, key, value, cipher);
        }
    };
    _PdfCrossReference.prototype._writeToBuffer = function (buffer, key, value, cipher) {
        this._offsets.push(buffer.length);
        this._offsetReference.set(key, buffer.length);
        this._indexes.push(key.objectNumber, 1);
        this._writeObject(value, buffer, key, cipher);
    };
    _PdfCrossReference.prototype._getSortedReferences = function (collection) {
        var entriesArray = []; // eslint-disable-line
        collection.forEach(function (value, key) {
            entriesArray.push([key, value]);
        });
        entriesArray.sort(function (a, b) {
            return a[0].objectNumber - b[0].objectNumber;
        });
        var sortedCollection = new Map(); // eslint-disable-line
        var lastObjectNumber = 1;
        for (var _i = 0, entriesArray_1 = entriesArray; _i < entriesArray_1.length; _i++) {
            var _a = entriesArray_1[_i], key = _a[0], value = _a[1];
            var currentObjectNumber = key.objectNumber;
            while (lastObjectNumber < currentObjectNumber) {
                sortedCollection.set({ objectNumber: lastObjectNumber }, 0);
                lastObjectNumber++;
            }
            sortedCollection.set(key, value);
            lastObjectNumber = currentObjectNumber + 1;
        }
        return sortedCollection;
    };
    return _PdfCrossReference;
}());
var _PdfObjectInformation = /** @class */ (function () {
    function _PdfObjectInformation() {
    }
    return _PdfObjectInformation;
}());
var _PdfCrossTableState = /** @class */ (function () {
    function _PdfCrossTableState() {
    }
    return _PdfCrossTableState;
}());
var _PdfStreamState = /** @class */ (function () {
    function _PdfStreamState() {
    }
    return _PdfStreamState;
}());
var _PdfArchievedStream = /** @class */ (function () {
    function _PdfArchievedStream(crossReference) {
        this._indexes = '';
        this._length = 0;
        this._crossReference = crossReference;
        this._reference = crossReference._getNextReference();
        this._archiveXRef = '';
        this._updatedStream = [];
        this._collection = [];
    }
    _PdfArchievedStream.prototype._writeObject = function (key, value) {
        this._archiveXRef += key.objectNumber + " " + this._updatedStream.length + this._crossReference._newLine;
        this._collection.push(key.objectNumber, 1);
        this._crossReference._writeObject(value, this._updatedStream);
        this._length++;
    };
    _PdfArchievedStream.prototype._save = function (buffer, currentLength) {
        var data = [];
        this._crossReference._writeString(this._archiveXRef, data);
        this._crossReference._writeBytes(this._updatedStream, data);
        var newDict = new _PdfDictionary(this._crossReference);
        newDict.set('Type', _PdfName.get('ObjStm'));
        newDict.set('N', this._length);
        newDict.set('First', this._archiveXRef.length);
        newDict.set('Length', data.length);
        var archiveStream = new _PdfStream(data, newDict, 0, data.length);
        this._archiveOffset = currentLength + buffer.length;
        var cipher;
        if (this._crossReference._encrypt) {
            cipher = this._crossReference._encrypt._createCipherTransform(this._reference.objectNumber, this._reference.generationNumber);
        }
        this._crossReference._writeObject(archiveStream, buffer, this._reference, cipher);
    };
    return _PdfArchievedStream;
}());
var _PdfMainObjectCollection = /** @class */ (function () {
    /**
     * Initializes a new instance of the `_PdfMainObjectCollection` class.
     *
     * @private
     * @param { _PdfCrossReference } collection - The cross-reference collection containing the PDF objects.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Create a new object collection instance
     * let mainObjectCollection = new _PdfMainObjectCollection(document._crossReference);
     * // Access the main object collection
     * let objects = mainObjectCollection._mainObjectCollection;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     */
    function _PdfMainObjectCollection(collection) {
        var _this = this;
        this._pointer = 0;
        if (!(collection._cacheMap instanceof Map)) {
            throw new Error('Expected _cacheMap to be a Map.');
        }
        this._reference = [];
        this._cache = collection._cacheMap;
        this._mainObjectCollection = new Map(); // eslint-disable-line
        var foundCatalog = false;
        this._crossReference = collection;
        this._cache.forEach(function (value, key) {
            if (!foundCatalog && value instanceof _PdfDictionary && value.isCatalog) {
                _this._addToMainObjectCollection(key, value);
                foundCatalog = true;
            }
        });
        this._parseObjectCollection();
    }
    _PdfMainObjectCollection.prototype._parseObjectCollection = function () {
        var _this = this;
        var _loop_1 = function () {
            var collection = new Map(); // eslint-disable-line
            var currentIndex = 0;
            this_1._mainObjectCollection.forEach(function (value, key) {
                if (currentIndex === _this._pointer) {
                    collection.set(key, value);
                    _this._parse(key, value);
                }
                currentIndex++;
            });
            this_1._pointer++;
        };
        var this_1 = this;
        while (this._pointer < this._mainObjectCollection.size) {
            _loop_1();
        }
        this._addReferencesToMainCollection();
        return this._mainObjectCollection;
    };
    _PdfMainObjectCollection.prototype._addToMainObjectCollection = function (key, value) {
        this._reference.push(key);
        this._mainObjectCollection.set(key, value);
    };
    _PdfMainObjectCollection.prototype._parseFetchValue = function (reference) {
        var fetchvalue = this._crossReference._fetch(reference); // eslint-disable-line
        this._parse(reference, fetchvalue);
    };
    _PdfMainObjectCollection.prototype._parse = function (key, value) {
        var _this = this;
        if (value instanceof _PdfDictionary) {
            this._parseDictionary(value);
        }
        else if (value instanceof _PdfBaseStream) {
            this._parseStream(key, value);
        }
        else if (value instanceof _PdfReference) {
            this._parseFetchValue(value);
        }
        else if (Array.isArray(value) && value.length > 0) {
            var isPdfReferenceArray = value.every(function (value) { return value instanceof _PdfReference; }); // eslint-disable-line
            if (isPdfReferenceArray) {
                value.forEach(function (ref) { return _this._parseFetchValue(ref); }); // eslint-disable-line
            }
            else {
                value.forEach(function (item) {
                    if (item instanceof _PdfReference) {
                        _this._parseFetchValue(item);
                    }
                });
                if (this._reference.indexOf(key) === -1 && !this._mainObjectCollection.has(key)) {
                    this._addToMainObjectCollection(key, value);
                }
            }
        }
        else if (typeof value === 'number') {
            if (this._reference.indexOf(key) === -1 && !this._mainObjectCollection.has(key)) {
                this._addToMainObjectCollection(key, value);
            }
        }
    };
    _PdfMainObjectCollection.prototype._addReferencesToMainCollection = function () {
        var _this = this;
        var objectsToWrite = []; // eslint-disable-line
        this._cache.forEach(function (value, key) {
            if (!_this._mainObjectCollection.has(key)) {
                objectsToWrite.push({ key: key, value: value });
            }
        });
        objectsToWrite.forEach(function (_a) {
            var key = _a.key, value = _a.value;
            _this._addToMainObjectCollection(key, value);
        });
    };
    _PdfMainObjectCollection.prototype._parseDictionary = function (element) {
        var _this = this;
        element.forEach(function (key, value) {
            var processReference = function (ref) {
                if (!_this._mainObjectCollection.has(ref) && _this._reference.indexOf(ref) === -1) {
                    var fetchValue = _this._crossReference._fetch(ref); // eslint-disable-line
                    if (fetchValue instanceof _PdfReference) {
                        fetchValue = _this._crossReference._fetch(fetchValue);
                    }
                    if (fetchValue instanceof _PdfBaseStream) {
                        _this._parseStream(ref, fetchValue);
                    }
                    else {
                        _this._addToMainObjectCollection(ref, fetchValue);
                    }
                }
            };
            if (value instanceof _PdfReference) {
                processReference(value);
            }
            else if (Array.isArray(value)) {
                value.forEach(function (item) {
                    if (item instanceof _PdfReference) {
                        processReference(item);
                    }
                    else if (item instanceof _PdfDictionary) {
                        _this._parseDictionary(item);
                    }
                });
            }
            else if (value instanceof _PdfDictionary) {
                _this._parseDictionary(value);
            }
        });
    };
    _PdfMainObjectCollection.prototype._parseStream = function (key, element) {
        this._parseDictionary(element.dictionary);
        if (this._reference.indexOf(key) === -1 && !this._mainObjectCollection.has(key)) {
            var type = element.dictionary.get('Type');
            var subtype = element.dictionary.get('Subtype');
            var isUpdated = element.dictionary._updated;
            var uncompressedValue = void 0;
            if (isUpdated || (type && (type.name === 'XObject' || type.name === 'Metadata') &&
                (subtype.name === 'Form' || subtype.name === 'XML'))) {
                uncompressedValue = this._crossReference._fetch(key);
            }
            else {
                uncompressedValue = this._crossReference._fetch(key, true);
                uncompressedValue._isCompress = false;
            }
            this._addToMainObjectCollection(key, uncompressedValue);
        }
    };
    return _PdfMainObjectCollection;
}());

/**
 * Represents a PDF form.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access the form of the PDF document
 * let form: PdfForm = document.form;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfForm = /** @class */ (function () {
    /**
     * Represents a loaded from the PDF document.
     *
     * @private
     * @param {_PdfDictionary} dictionary Form dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference object.
     */
    function PdfForm(dictionary, crossReference) {
        this._isDefaultAppearance = false;
        this._hasKids = false;
        this._setAppearance = false;
        this._exportEmptyFields = false;
        this._fieldCollection = [];
        this._signFlag = _SignatureFlag.none;
        this._isNeedAppearances = false;
        this._dictionary = dictionary;
        this._crossReference = crossReference;
        this._parsedFields = new Map();
        this._fields = [];
        this._createFields();
    }
    Object.defineProperty(PdfForm.prototype, "count", {
        /**
         * Gets the fields count (Read only).
         *
         * @returns {number} Fields count.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access loaded form
         * let form: PdfForm = document.form;
         * // Gets the fields count
         * let count: number = form.count;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._fields.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfForm.prototype, "needAppearances", {
        /**
         *  Gets a value indicating whether need appearances (Read only).
         *
         * @returns {boolean} Need appearances.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access loaded form
         * let form: PdfForm = document.form;
         * // Gets the boolean flag indicating need appearances
         * let needAppearances: number = form.needAppearances;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary.has('NeedAppearances')) {
                this._needAppearances = this._dictionary.get('NeedAppearances');
            }
            return this._needAppearances;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfForm.prototype, "exportEmptyFields", {
        /**
         *  Gets a value indicating whether allow to export empty fields or not.
         *
         * @returns {boolean} Export empty fields.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access loaded form
         * let form: PdfForm = document.form;
         * // Gets a value indicating whether allow to export empty fields or not.
         * let exportEmptyFields: boolean = form.exportEmptyFields;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._exportEmptyFields;
        },
        /**
         *  Sets a value indicating whether allow to export empty fields or not.
         *
         * @param {boolean} value Export empty fields.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access loaded form
         * let form: PdfForm = document.form;
         * // Sets a value indicating whether allow to export empty fields or not.
         * form.exportEmptyFields = false;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._exportEmptyFields = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfForm.prototype, "_signatureFlag", {
        get: function () {
            return this._signFlag;
        },
        set: function (value) {
            if (value !== this._signFlag) {
                this._signFlag = value;
                this._dictionary.update('SigFlags', value);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the `PdfField` at the specified index.
     *
     * @param {number} index Field index.
     * @returns {PdfField} Loaded PDF form field at the specified index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the loaded form field
     * let field: PdfField = document.form.fieldAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfForm.prototype.fieldAt = function (index) {
        if (index < 0 || index >= this._fields.length) {
            throw Error('Index out of range.');
        }
        var field;
        if (this._parsedFields.has(index)) {
            field = this._parsedFields.get(index);
            this._isNeedAppearances = true;
        }
        else {
            var dictionary = void 0;
            var ref = this._fields[index]; // eslint-disable-line
            if (ref && ref instanceof _PdfReference) {
                dictionary = this._crossReference._fetch(ref);
            }
            if (dictionary) {
                field = this._parseFields(dictionary, ref);
                this._parsedFields.set(index, field);
                if (field && field instanceof PdfField) {
                    field._annotationIndex = index;
                }
            }
        }
        return field;
    };
    PdfForm.prototype._parseFields = function (dictionary, reference) {
        var field;
        if (dictionary) {
            var key = _getInheritableProperty(dictionary, 'FT', false, true, 'Parent');
            var fieldFlags = 0;
            var flag = _getInheritableProperty(dictionary, 'Ff', false, true, 'Parent');
            if (typeof flag !== 'undefined') {
                fieldFlags = flag;
            }
            if (key) {
                switch (key.name.toLowerCase()) {
                    case 'tx':
                        field = PdfTextBoxField._load(this, dictionary, this._crossReference, reference);
                        break;
                    case 'btn':
                        if ((fieldFlags & _FieldFlag.pushButton) !== 0) {
                            field = PdfButtonField._load(this, dictionary, this._crossReference, reference);
                        }
                        else if ((fieldFlags & _FieldFlag.radio) !== 0) {
                            field = PdfRadioButtonListField._load(this, dictionary, this._crossReference, reference);
                        }
                        else {
                            field = PdfCheckBoxField._load(this, dictionary, this._crossReference, reference);
                        }
                        break;
                    case 'ch':
                        if ((fieldFlags & _FieldFlag.combo) !== 0) {
                            field = PdfComboBoxField._load(this, dictionary, this._crossReference, reference);
                        }
                        else {
                            field = PdfListBoxField._load(this, dictionary, this._crossReference, reference);
                        }
                        break;
                    case 'sig':
                        field = PdfSignatureField._load(this, dictionary, this._crossReference, reference);
                        break;
                }
            }
        }
        return field;
    };
    /**
     * Add a new `PdfField`.
     *
     * @param {PdfField} field Field object to add.
     * @returns {number} Field index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Add a new form field
     * let index: number = document.form.add(field);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfForm.prototype.add = function (field) {
        this._fields.push(field._ref);
        this._dictionary.update('Fields', this._fields);
        this._parsedFields.set(this._fields.length - 1, field);
        field._form = this;
        this._crossReference._root._updated = true;
        if (field instanceof PdfSignatureField) {
            field._form._signatureFlag = _SignatureFlag.signatureExists | _SignatureFlag.appendOnly;
        }
        this._isNeedAppearances = true;
        return (this._fields.length - 1);
    };
    /**
     * Remove the specified PDF form field.
     *
     * @param {PdfField} field Field object to remove.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the loaded form field
     * let field: PdfField = document.form.fieldAt(3);
     * // Remove the form field
     * document.form.removeField(field);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfForm.prototype.removeField = function (field) {
        var index = this._fields.indexOf(field._ref);
        if (index >= 0) {
            this.removeFieldAt(index);
        }
    };
    /**
     * Remove the PDF form field from specified index.
     *
     * @param {number} index Field index to remove.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Remove the form field from the specified index
     * document.form.removeFieldAt(3);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfForm.prototype.removeFieldAt = function (index) {
        var field = this.fieldAt(index);
        if (field) {
            if (field._kidsCount > 0) {
                for (var i = field._kidsCount - 1; i >= 0; i--) {
                    var item = field.itemAt(i);
                    var page = void 0;
                    if (item) {
                        page = item._getPage();
                        if (page) {
                            page._removeAnnotation(item._ref);
                        }
                    }
                }
            }
            else if (field._dictionary.has('Subtype') && field._dictionary.get('Subtype').name === 'Widget') {
                var page = field.page;
                if (page) {
                    page._removeAnnotation(field._ref);
                }
            }
            this._parsedFields.delete(index);
            this._reorderParsedAnnotations(index);
        }
        this._fields.splice(index, 1);
        var document = this._crossReference._document;
        var catalog = document._catalog;
        if (this._fields.length === 0 && document && catalog && catalog._catalogDictionary) {
            catalog._catalogDictionary._updated = true;
            this._crossReference._allowCatalog = true;
        }
        this._dictionary.set('Fields', this._fields);
        this._dictionary._updated = true;
    };
    PdfForm.prototype._reorderParsedAnnotations = function (index) {
        var result = new Map();
        this._parsedFields.forEach(function (value, key) {
            if (key > index) {
                result.set(key - 1, value);
            }
            else {
                result.set(key, value);
            }
        });
        this._parsedFields = result;
    };
    /**
     * Sets the flag to indicate the new appearance creation
     * If true, appearance will not be created. Default appearance has been considered.
     * If false, new appearance stream has been created from field values and updated as normal appearance.
     *
     * @param {boolean} value Set default appearance.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Set boolean flag to create a new appearance stream for form fields.
     * document.form.setDefaultAppearance(false);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfForm.prototype.setDefaultAppearance = function (value) {
        this._setAppearance = !value;
        this._needAppearances = value;
        this._isDefaultAppearance = value;
    };
    PdfForm.prototype.orderFormFields = function (tabOrder) {
        var _this = this;
        if (tabOrder === null || typeof tabOrder === 'undefined') {
            this.orderFormFields(new Map());
        }
        else {
            var tab = void 0;
            var document_1 = this._crossReference._document;
            var value = void 0;
            if (tabOrder && tabOrder instanceof Map) {
                var setTabOrder = true;
                if (tabOrder.size > 0) {
                    this._tabCollection = tabOrder;
                }
                else {
                    setTabOrder = false;
                    this._tabCollection = tabOrder;
                }
                var fieldCollection = new Map();
                this._fieldCollection = this._getFields();
                if (_isNullOrUndefined(this._fieldCollection) && this._fieldCollection.length > 0) {
                    var page = this._fieldCollection[0].page;
                    if (page && document_1) {
                        for (var i = 0; i < this._fieldCollection.length; i++) {
                            var field = this._fieldCollection[Number.parseInt(i.toString(), 10)];
                            if (field.page) {
                                var index = _getPageIndex(document_1, this._sortItemByPageIndex(field, true)._pageDictionary);
                                if (index >= 0) {
                                    if (fieldCollection.has(index)) {
                                        value = fieldCollection.get(index);
                                        value.push(field);
                                    }
                                    else {
                                        value = [];
                                        value.push(field);
                                        fieldCollection.set(index, value);
                                    }
                                    var page_1 = document_1.getPage(index);
                                    if (!this._tabCollection.has(index)) {
                                        this._tabCollection.set(index, page_1.tabOrder);
                                    }
                                    if (setTabOrder) {
                                        page_1.tabOrder = this._tabCollection.get(index);
                                    }
                                }
                            }
                        }
                        var fieldsCount_1 = 0;
                        fieldCollection.forEach(function (value, key) {
                            _this._tabOrder = _this._tabCollection.get(key);
                            if (_this._tabOrder !== PdfFormFieldsTabOrder.structure) {
                                var fields = value;
                                fields.sort(function (pdfField1, pdfField2) {
                                    return _this._compareFields(pdfField1, pdfField2);
                                });
                                for (var j = 0; j < fields.length; j++) {
                                    var fieldIndex = _this._fieldCollection.indexOf(fields[Number.parseInt(j.toString(), 10)]);
                                    if (fieldIndex !== -1 && fieldIndex !== fieldsCount_1 + j) {
                                        var field = _this._fieldCollection[Number.parseInt(fieldIndex.toString(), 10)];
                                        _this._fieldCollection.splice(fieldIndex, 1);
                                        _this._fieldCollection.splice(fieldsCount_1 + j, 0, field);
                                    }
                                }
                            }
                            fieldsCount_1 += value.length;
                        });
                    }
                }
            }
            else {
                this._tabOrder = tabOrder;
                tab = this._getOrder(this._tabOrder);
                this._fieldCollection = this._getFields();
                this._fieldCollection.sort(function (pdfField1, pdfField2) {
                    return _this._compareFields(pdfField1, pdfField2);
                });
            }
            this._parsedFields.clear();
            for (var i = 0; i < this._fieldCollection.length; i++) {
                this._parsedFields.set(Number.parseInt(i.toString(), 10), this._fieldCollection[Number.parseInt(i.toString(), 10)]);
                this._fields[Number.parseInt(i.toString(), 10)] = this._fieldCollection[Number.parseInt(i.toString(), 10)]._ref;
                if (tab) {
                    this._fieldCollection[Number.parseInt(i.toString(), 10)].page._pageDictionary.update('Tabs', tab);
                }
            }
            this._dictionary.update('Fields', this._fields);
        }
    };
    PdfForm.prototype._createFields = function () {
        var fields; // eslint-disable-line
        if (this._dictionary.has('Fields')) {
            fields = this._dictionary.get('Fields');
        }
        var hasNoKids = false;
        var count = 0;
        var nodes = []; // eslint-disable-line
        while (typeof fields !== 'undefined' && fields !== null) {
            for (; count < fields.length; count++) {
                var ref = fields[count]; // eslint-disable-line
                var fieldDictionary = void 0;
                if (ref && ref instanceof _PdfReference) {
                    fieldDictionary = this._crossReference._fetch(ref);
                }
                var fieldFlags = 0;
                var flag = _getInheritableProperty(fieldDictionary, 'Ff', false, true, 'Parent');
                if (typeof flag !== 'undefined') {
                    fieldFlags = flag;
                }
                var fieldKids = void 0;
                if (fieldDictionary && fieldDictionary.has('Kids')) {
                    fieldKids = fieldDictionary.get('Kids');
                    if (typeof fieldKids !== 'undefined' && fieldKids.length > 0) {
                        for (var i = 0; i < fieldKids.length; i++) {
                            var reference = fieldKids[Number.parseInt(i.toString(), 10)];
                            if (reference && reference instanceof _PdfReference) {
                                var kidsDict = this._crossReference._fetch(reference);
                                if (typeof kidsDict !== 'undefined' && !kidsDict.has('Parent')) {
                                    kidsDict.update('Parent', ref);
                                }
                            }
                            else if ((fieldFlags & _FieldFlag.radio) !== 0) {
                                hasNoKids = true;
                            }
                        }
                    }
                }
                if (typeof fieldKids === 'undefined') {
                    if (fieldDictionary) {
                        if (this._fields.indexOf(ref) === -1) {
                            this._fields.push(ref);
                        }
                    }
                }
                else {
                    var isNode = (!fieldDictionary.has('FT')) || this._isNode(fieldKids);
                    if (isNode) {
                        nodes.push({ fields: fields, count: count });
                        this._hasKids = true;
                        count = -1;
                        fields = fieldKids;
                    }
                    else {
                        if (hasNoKids && (fieldFlags & _FieldFlag.radio) !== 0) {
                            continue;
                        }
                        else {
                            this._fields.push(ref);
                        }
                    }
                }
            }
            if (nodes.length === 0) {
                break;
            }
            var entry = nodes.pop(); // eslint-disable-line
            fields = entry.fields;
            count = entry.count + 1;
        }
    };
    PdfForm.prototype._isNode = function (kids) {
        var isNode = false;
        if (_isNullOrUndefined(kids) && kids.length > 0) {
            var entry = kids[0]; // eslint-disable-line
            var dictionary = void 0;
            if (_isNullOrUndefined(entry)) {
                if (entry instanceof _PdfDictionary) {
                    dictionary = entry;
                }
                else if (entry instanceof _PdfReference) {
                    dictionary = this._crossReference._fetch(entry);
                }
            }
            if (dictionary && dictionary.has('Subtype')) {
                var subtype = dictionary.get('Subtype');
                if (subtype && subtype.name !== 'Widget') {
                    isNode = true;
                }
            }
        }
        return isNode;
    };
    PdfForm.prototype._parseWidgetReferences = function () {
        var _this = this;
        if (typeof this._widgetReferences === 'undefined' && this.count > 0) {
            this._widgetReferences = [];
            this._fields.forEach(function (fieldReference) {
                var dictionary = _this._crossReference._fetch(fieldReference);
                if (dictionary) {
                    if (dictionary.has('Kids')) {
                        var fieldKids = dictionary.get('Kids');
                        if (fieldKids && fieldKids.length > 0) {
                            fieldKids.forEach(function (kidReference) {
                                var kidDictionary;
                                if (kidReference && kidReference instanceof _PdfDictionary) {
                                    kidDictionary = kidReference;
                                }
                                else if (kidReference && kidReference instanceof _PdfReference) {
                                    kidDictionary = _this._crossReference._fetch(kidReference);
                                }
                                if (kidDictionary && kidDictionary.has('Subtype')) {
                                    var subtype = kidDictionary.get('Subtype');
                                    if (subtype && subtype.name === 'Widget') {
                                        _this._widgetReferences.push(kidReference);
                                    }
                                }
                            });
                        }
                    }
                    else {
                        _this._widgetReferences.push(fieldReference);
                    }
                }
            });
        }
        return this._widgetReferences;
    };
    PdfForm.prototype._doPostProcess = function (isFlatten, pageToImport) {
        for (var i = this.count - 1; i >= 0; i--) {
            var field = this.fieldAt(i);
            if (field && !field._isLoaded && typeof field._tabIndex !== 'undefined' && field._tabIndex >= 0) {
                var page = field._page;
                if (page &&
                    page._pageDictionary.has('Annots') &&
                    (page.tabOrder === PdfFormFieldsTabOrder.manual || this._tabOrder === PdfFormFieldsTabOrder.manual)) {
                    var annots = page._pageDictionary.get('Annots');
                    var annotationCollection = new PdfAnnotationCollection(annots, this._crossReference, page);
                    page._annotations = annotationCollection;
                    for (var i_1 = 0; i_1 < field.itemsCount; i_1++) {
                        var item = field.itemAt(i_1);
                        if (item && item instanceof PdfWidgetAnnotation) {
                            var index = annots.indexOf(item._ref);
                            if (index < 0) {
                                index = field._annotationIndex;
                            }
                            if (index >= 0) {
                                var annotations = page.annotations._reArrange(field._ref, field._tabIndex, index);
                                page._pageDictionary.update('Annots', annotations);
                                page._pageDictionary._updated = true;
                            }
                        }
                    }
                }
            }
            if (field && ((pageToImport && field.page === pageToImport) || !pageToImport)) {
                if (pageToImport) {
                    field._isImport = true;
                }
                field._doPostProcess(isFlatten || field.flatten);
                if (!isFlatten && field.flatten || (isFlatten && pageToImport && field.page === pageToImport)) {
                    this.removeFieldAt(i);
                }
            }
        }
    };
    PdfForm.prototype._getFieldIndex = function (name) {
        var index = -1;
        if (this.count > 0) {
            if (!this._fieldNames) {
                this._fieldNames = [];
            }
            if (!this._indexedFieldNames) {
                this._indexedFieldNames = [];
            }
            if (!this._actualFieldNames) {
                this._actualFieldNames = [];
            }
            if (!this._indexedActualFieldNames) {
                this._indexedActualFieldNames = [];
            }
            for (var i = 0; i < this.count; i++) {
                var field = this.fieldAt(i);
                if (field) {
                    var fieldName = field.name;
                    if (fieldName) {
                        this._fieldNames.push(fieldName);
                        this._indexedFieldNames.push(fieldName.split('[')[0]);
                    }
                    var actualName = field.actualName;
                    if (actualName) {
                        this._actualFieldNames.push(actualName);
                        this._indexedActualFieldNames.push(actualName.split('[')[0]);
                    }
                }
            }
            var nameIndex = this._fieldNames.indexOf(name);
            if (nameIndex !== -1) {
                index = nameIndex;
            }
            else {
                nameIndex = this._indexedFieldNames.indexOf(name);
                if (nameIndex !== -1) {
                    index = nameIndex;
                }
                else {
                    nameIndex = this._actualFieldNames.indexOf(name);
                    if (nameIndex !== -1) {
                        index = nameIndex;
                    }
                    else {
                        nameIndex = this._indexedActualFieldNames.indexOf(name);
                        if (nameIndex !== -1) {
                            index = nameIndex;
                        }
                    }
                }
            }
        }
        return index;
    };
    PdfForm.prototype._getFields = function () {
        var fields = [];
        for (var i = 0; i < this._fields.length; i++) {
            var field = this.fieldAt(i);
            if (field && field instanceof PdfField) {
                fields.push(field);
            }
        }
        return fields;
    };
    PdfForm.prototype._getOrder = function (tabOrder) {
        if (tabOrder !== PdfFormFieldsTabOrder.none) {
            var tabs = '';
            if (tabOrder === PdfFormFieldsTabOrder.row) {
                tabs = 'R';
            }
            else if (tabOrder === PdfFormFieldsTabOrder.column) {
                tabs = 'C';
            }
            else if (tabOrder === PdfFormFieldsTabOrder.structure) {
                tabs = 'S';
            }
            return _PdfName.get(tabs);
        }
        return null;
    };
    PdfForm.prototype._compareFields = function (field1, field2) {
        var result = 0;
        var xdiff;
        var index;
        var page1 = field1.page;
        var page2 = field2.page;
        if (page1 && !page1._isNew && page1 instanceof PdfPage && page2 && !page2._isNew && page2 instanceof PdfPage) {
            var page1Index = this._sortItemByPageIndex(field1, false)._pageIndex;
            var page2Index = this._sortItemByPageIndex(field2, false)._pageIndex;
            var rectangle1 = void 0;
            if (field1._dictionary.has('Kids')) {
                rectangle1 = this._getItemRectangle(field1);
            }
            else {
                rectangle1 = this._getRectangle(field1._dictionary);
            }
            var rectangle2 = void 0;
            if (field2._dictionary.has('Kids')) {
                rectangle2 = this._getItemRectangle(field2);
            }
            else {
                rectangle2 = this._getRectangle(field2._dictionary);
            }
            var firstHeight = rectangle1[3] - rectangle1[1];
            var secondHeight = rectangle2[3] - rectangle2[1];
            if (rectangle1 && rectangle1.length >= 2 && rectangle2 && rectangle2.length >= 2) {
                var x1 = rectangle1[0];
                var y1 = rectangle1[1];
                var x2 = rectangle2[0];
                var y2 = rectangle2[1];
                if (typeof x1 === 'number' && typeof x2 === 'number' &&
                    typeof y1 === 'number' && typeof y2 === 'number') {
                    index = page1Index - page2Index;
                    if (this._tabOrder === PdfFormFieldsTabOrder.row) {
                        xdiff = this._compare(y2, y1);
                        if (xdiff !== 0) {
                            var isValid = xdiff === -1 && y1 > y2 && (y1 - firstHeight / 2) < y2;
                            isValid = isValid || (xdiff === 1 && y2 > y1 && (y2 - secondHeight / 2) < y1);
                            if (isValid) {
                                xdiff = 0;
                            }
                        }
                        if (index !== 0) {
                            result = index;
                        }
                        else if (xdiff !== 0) {
                            result = xdiff;
                        }
                        else {
                            result = this._compare(x1, x2);
                        }
                    }
                    else if (this._tabOrder === PdfFormFieldsTabOrder.column) {
                        xdiff = this._compare(x1, x2);
                        if (index !== 0) {
                            result = index;
                        }
                        else if (xdiff !== 0) {
                            result = xdiff;
                        }
                        else {
                            result = this._compare(y2, y1);
                        }
                    }
                    else if (this._tabOrder === PdfFormFieldsTabOrder.manual ||
                        this._tabOrder === PdfFormFieldsTabOrder.none ||
                        this._tabOrder === PdfFormFieldsTabOrder.structure ||
                        this._tabOrder === PdfFormFieldsTabOrder.widget) {
                        if (field1 instanceof PdfField && field2 instanceof PdfField) {
                            var field1Index = field1.tabIndex;
                            var field2Index = field2.tabIndex;
                            xdiff = this._compare(field1Index, field2Index);
                            if (index !== 0) {
                                result = index;
                            }
                            else {
                                result = xdiff;
                            }
                        }
                    }
                }
            }
        }
        return result;
    };
    PdfForm.prototype._getRectangle = function (dictionary) {
        var rect;
        if (dictionary && dictionary.has('Rect')) {
            rect = dictionary.getArray('Rect');
        }
        return rect;
    };
    PdfForm.prototype._getItemRectangle = function (field) {
        var result;
        var dictionary = field._dictionary;
        if (dictionary.has('Kids')) {
            var kids = dictionary.getArray('Kids');
            if (_isNullOrUndefined(kids) && kids.length >= 1) {
                if (kids.length === 1) {
                    result = this._getRectangle(kids[0]);
                }
                else {
                    if (field && field.itemsCount > 1) {
                        result = this._getRectangle(field.itemAt(0)._dictionary);
                    }
                    else {
                        result = this._getRectangle(kids[0]);
                    }
                }
            }
        }
        return result;
    };
    PdfForm.prototype._compare = function (x, y) {
        if (x > y) {
            return 1;
        }
        else if (x < y) {
            return -1;
        }
        else {
            return 0;
        }
    };
    PdfForm.prototype._compareKidsElement = function (x, y) {
        var xDictionary = this._crossReference._fetch(x);
        var yDictionary = this._crossReference._fetch(y);
        var xRect = this._getRectangle(xDictionary);
        var yRect = this._getRectangle(yDictionary);
        var result;
        if (xRect && xRect.length >= 2 && yRect && yRect.length >= 2) {
            var x1 = xRect[0];
            var y1 = xRect[1];
            var x2 = yRect[0];
            var y2 = yRect[1];
            if (typeof x1 === 'number' && typeof x2 === 'number' &&
                typeof y1 === 'number' && typeof y2 === 'number') {
                var xdiff = void 0;
                if (this._tabOrder === PdfFormFieldsTabOrder.row) {
                    xdiff = this._compare(y2, y1);
                    if (xdiff !== 0) {
                        result = xdiff;
                    }
                    else {
                        result = this._compare(x1, x2);
                    }
                }
                else if (this._tabOrder === PdfFormFieldsTabOrder.column) {
                    xdiff = this._compare(x1, x2);
                    if (xdiff !== 0) {
                        result = xdiff;
                    }
                    else {
                        result = this._compare(y2, y1);
                    }
                }
                else {
                    result = 0;
                }
                return result;
            }
        }
        return result;
    };
    PdfForm.prototype._sortItemByPageIndex = function (field, hasPageTabOrder) {
        var page = field.page;
        var tabOrder = this._tabOrder;
        this._tabOrder = hasPageTabOrder ? field.page.tabOrder : tabOrder;
        this._sortFieldItems(field);
        if (field._isLoaded && field._kidsCount > 1) {
            page = field.itemAt(0).page;
        }
        this._tabOrder = tabOrder;
        if (typeof page === 'undefined') {
            page = field.page;
        }
        return page;
    };
    PdfForm.prototype._sortFieldItems = function (field) {
        var _this = this;
        if (field._isLoaded && (field instanceof PdfTextBoxField ||
            field instanceof PdfListBoxField ||
            field instanceof PdfCheckBoxField ||
            field instanceof PdfRadioButtonListField)) {
            var collection = field._parseItems(); // eslint-disable-line
            collection.sort(function (item1, item2) {
                return _this._compareFieldItem(item1, item2);
            });
            field._parsedItems.clear();
            for (var i = 0; i < collection.length; i++) {
                field._parsedItems.set(i, collection[Number.parseInt(i.toString(), 10)]);
            }
        }
    };
    PdfForm.prototype._compareFieldItem = function (item1, item2) {
        var result = 0;
        if (typeof item1 !== 'undefined' && typeof item2 !== 'undefined') {
            var page1 = item1.page;
            var page2 = item2.page;
            var array1 = this._getRectangle(item1._dictionary);
            var array2 = this._getRectangle(item2._dictionary);
            if (array1 && array2) {
                var x1 = array1[0];
                var y1 = array1[1];
                var x2 = array2[0];
                var y2 = array2[1];
                var xdiff = void 0;
                if (this._tabOrder === PdfFormFieldsTabOrder.row) {
                    xdiff = this._compare(page1._pageIndex, page2._pageIndex);
                    if (xdiff !== 0) {
                        result = xdiff;
                    }
                    else {
                        xdiff = this._compare(y2, y1);
                        if (xdiff !== 0) {
                            result = xdiff;
                        }
                        else {
                            result = this._compare(x1, x2);
                        }
                    }
                }
                else if (this._tabOrder === PdfFormFieldsTabOrder.column) {
                    xdiff = this._compare(page1._pageIndex, page2._pageIndex);
                    if (xdiff !== 0) {
                        result = xdiff;
                    }
                    else {
                        xdiff = this._compare(x1, x2);
                        if (xdiff !== 0) {
                            result = xdiff;
                        }
                        else {
                            result = this._compare(y2, y1);
                        }
                    }
                }
            }
        }
        return result;
    };
    PdfForm.prototype._clear = function () {
        this._fields = [];
        this._parsedFields = new Map();
    };
    return PdfForm;
}());

var __extends$h = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _FdfDocument = /** @class */ (function (_super) {
    __extends$h(_FdfDocument, _super);
    function _FdfDocument(fileName) {
        var _this = _super.call(this) || this;
        _this._annotationObjects = new Map(); // eslint-disable-line
        _this._specialCharacters = 'âãÏÓ';
        if (fileName !== null && typeof fileName !== 'undefined') {
            _this._fileName = fileName;
        }
        return _this;
    }
    _FdfDocument.prototype._exportAnnotations = function (document) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = true;
        this._exportAnnotationData(document, document.pageCount);
        return this._save();
    };
    _FdfDocument.prototype._exportFormFields = function (document) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        this._key = _getNewGuidString();
        return this._save();
    };
    _FdfDocument.prototype._save = function () {
        var _this = this;
        var objectID = 0;
        var objectArray = [];
        if (!this._isAnnotationExport) {
            if (this._asPerSpecification) {
                this.fdfString += '%FDF-1.2\n%' + this._specialCharacters + '\r\n1 0 obj\r<</FDF<</F(';
                this.fdfString += this._fileName + ')';
                this.fdfString += '/Fields[';
            }
            else {
                this.fdfString += '%FDF-1.2\n';
            }
            var form = this._document.form;
            if (form !== null && typeof form !== 'undefined') {
                this._exportEmptyFields = form.exportEmptyFields;
                var count = this._document.form.count;
                for (var i = 0; i < count; i++) {
                    var field = this._document.form.fieldAt(i);
                    var value = this._exportFormFieldsData(field);
                    if (field instanceof PdfTextBoxField || field instanceof PdfListBoxField || field instanceof PdfComboBoxField
                        || field instanceof PdfRadioButtonListField || field instanceof PdfCheckBoxField) {
                        objectID++;
                    }
                    if (!this._asPerSpecification) {
                        if (field instanceof PdfTextBoxField || field instanceof PdfListBoxField || field instanceof PdfComboBoxField) {
                            objectArray.push(objectID);
                            this.fdfString += objectID + ' 0 obj<</T <' + this._stringToHexString(field.name) + '> /V ';
                            if (typeof value === 'string' || (Array.isArray(value) && value.length === 1)) {
                                this.fdfString += '<' + this._stringToHexString((Array.isArray(value) ? value[0] : value)) + '>';
                            }
                            else if (Array.isArray(value)) {
                                this.fdfString += '[';
                                for (var j = 0; j < value.length; j++) {
                                    this.fdfString += '<' + this._stringToHexString(value[Number.parseInt(j.toString(), 10)]) + '>';
                                    if (j !== value.length - 1) {
                                        this.fdfString += ' ';
                                    }
                                }
                                this.fdfString += ']';
                            }
                            this.fdfString += ' >>endobj\n';
                        }
                        else if (field instanceof PdfRadioButtonListField || field instanceof PdfCheckBoxField) {
                            objectArray.push(objectID);
                            this.fdfString += objectID + ' 0 obj<</T <' + this._stringToHexString(field.name) + '> /V /';
                            this.fdfString += value + ' >>endobj\n';
                        }
                    }
                    else {
                        if (field instanceof PdfTextBoxField || field instanceof PdfListBoxField || field instanceof PdfComboBoxField) {
                            objectArray.push(objectID);
                            this.fdfString += '<</T(' + field.name + ')/V';
                            if (typeof value === 'string' || (Array.isArray(value) && value.length === 1)) {
                                this.fdfString += '(' + (Array.isArray(value) ? value[0] : value) + ')';
                            }
                            else if (Array.isArray(value)) {
                                this.fdfString += '[';
                                for (var j = 0; j < value.length; j++) {
                                    this.fdfString += '(' + value[Number.parseInt(j.toString(), 10)] + ')';
                                    if (j !== value.length - 1) {
                                        this.fdfString += ' ';
                                    }
                                }
                                this.fdfString += ']';
                            }
                            this.fdfString += '>>';
                        }
                        else if (field instanceof PdfRadioButtonListField || field instanceof PdfCheckBoxField) {
                            objectArray.push(objectID);
                            this.fdfString += '<</T(' + field.name + ')/V/' + value + '>>';
                        }
                    }
                }
            }
            if (this._asPerSpecification) {
                this.fdfString += ']';
                this.fdfString += '/ID[]/UF(' + this._fileName + ')>>/Type/Catalog>>\rendobj\rtrailer\r\n<</Root 1 0 R>>\r\n';
                this.fdfString += '%%EOF\r\n';
            }
            else {
                this.fdfString += (this._table.size + 1) + ' 0 obj<</F <' + this._stringToHexString(this._fileName) + '>  /Fields [';
                for (var i = 0; i < this._table.size; i++) {
                    var field = this._document.form.fieldAt(i);
                    if (field !== null && typeof field !== 'undefined' && field.export) {
                        this.fdfString += objectArray[Number.parseInt(i.toString(), 10)] + ' 0 R ';
                    }
                }
                this.fdfString += ']>>endobj\n';
                this.fdfString += (objectArray.length + 2) + ' 0 obj<</Version /1.4 /FDF ' + (objectArray.length + 1) + ' 0 R>>endobj\n';
                this.fdfString += 'trailer\n<</Root ' + (objectArray.length + 2) + ' 0 R>>';
            }
        }
        var arrayBuffer = new ArrayBuffer(this.fdfString.length * 1);
        var result = new Uint8Array(arrayBuffer);
        result.forEach(function (val, i) {
            result[i] = _this.fdfString.charCodeAt(i); // eslint-disable-line
        });
        return result;
    };
    _FdfDocument.prototype._importAnnotations = function (document, data) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        this._checkFdf(_bytesToString(data));
        var stream = new _PdfStream(data);
        this._isAnnotationImport = true;
        var parser = new _PdfParser(new _PdfLexicalOperator(stream), null, true, false);
        this._readFdfData(parser);
        if (_isNullOrUndefined(this._annotationObjects) && this._annotationObjects.size > 0) {
            this._annotationObjects.clear();
        }
        if (_isNullOrUndefined(this._table) && this._table.size > 0) {
            this._table.clear();
        }
    };
    _FdfDocument.prototype._importFormData = function (document, data) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        this._checkFdf(_bytesToString(data));
        var stream = new _PdfStream(data);
        var parser = new _PdfParser(new _PdfLexicalOperator(stream), null, false, false);
        this._readFdfData(parser);
    };
    _FdfDocument.prototype._readFdfData = function (parser) {
        var _this = this;
        var token = parser.getObject(); // eslint-disable-line
        if (this._isAnnotationImport) {
            var key = '';
            while (token !== null && typeof token !== 'undefined' && token !== 'EOF') {
                if (token instanceof _PdfDictionary) {
                    this._table.set(key, token);
                    key = '';
                }
                else if (token instanceof _PdfStream || token instanceof _PdfFlateStream) {
                    this._table.set(key, token);
                    key = '';
                }
                else if (token !== null && Number.isInteger(token) && token !== 0) {
                    if (parser.first >= 0) {
                        key = token.toString() + ' ' + parser.first.toString();
                    }
                }
                else if (token instanceof _PdfCommand && token.command !== null && typeof token.command !== 'undefined' &&
                    token.command === 'trailer') {
                    key = token.command;
                }
                token = parser.getObject();
            }
            this._annotationObjects = this._parseAnnotationData();
            this._annotationObjects.forEach(function (value, key) {
                var dictionary = value;
                dictionary._crossReference = _this._crossReference;
                dictionary._updated = true;
                if (dictionary && dictionary.has('Page')) {
                    var pageNumber = dictionary.get('Page');
                    if (pageNumber !== null && typeof pageNumber !== 'undefined') {
                        var pageIndex = pageNumber;
                        if (pageIndex < _this._document.pageCount) {
                            var page = _this._document.getPage(pageIndex);
                            var pageDictionary = page._pageDictionary;
                            if (pageDictionary) {
                                var annotations = page.annotations;
                                var annotation = annotations._parseAnnotation(dictionary);
                                if (annotation !== null && typeof annotation !== 'undefined') {
                                    annotation._isImported = true;
                                    var reference = _this._crossReference._getNextReference();
                                    _this._crossReference._cacheMap.set(reference, dictionary);
                                    if (dictionary.has('NM') || dictionary.has('IRT')) {
                                        _this._addReferenceToGroup(reference, dictionary);
                                    }
                                    annotation._ref = reference;
                                    var index = annotations._annotations.length;
                                    annotations._annotations.push(reference);
                                    if (annotations._comments && annotations._comments.length > 0) {
                                        annotations._comments = [];
                                    }
                                    pageDictionary.set('Annots', annotations._annotations);
                                    pageDictionary._updated = true;
                                    annotations._parsedAnnotations.set(index, annotation);
                                    _this._handlePopup(annotations, reference, dictionary, pageDictionary);
                                }
                            }
                        }
                    }
                }
            });
            if (this._groupHolders && this._groupHolders.length > 0) {
                for (var i = 0; i < this._groupHolders.length; i++) {
                    var dictionary = this._groupHolders[Number.parseInt(i.toString(), 10)];
                    if (dictionary && dictionary.has('IRT')) {
                        var inReplyTo = dictionary.get('IRT');
                        if (inReplyTo) {
                            if (this._groupReferences && this._groupReferences.has(inReplyTo)) {
                                dictionary.update('IRT', this._groupReferences.get(inReplyTo));
                            }
                            else {
                                delete dictionary._map.IRT;
                            }
                        }
                    }
                }
            }
            this._groupHolders = [];
            this._groupReferences = new Map();
        }
        else {
            token = parser.getObject();
            if (!this._asPerSpecification) {
                token = parser.getObject();
                if (token instanceof _PdfCommand && token.command !== null) {
                    token = token.command;
                }
                while (token !== null && typeof token !== 'undefined' && token !== 'EOF') {
                    if (token instanceof _PdfDictionary) {
                        var t = token.getArray('T');
                        var v = void 0;
                        if (token._map.V instanceof _PdfName) {
                            v = token.getArray('V').name;
                        }
                        else {
                            v = token.getArray('V');
                        }
                        if (t !== null && t !== undefined && t.length > 0) {
                            this._table.set(t, v);
                        }
                    }
                    token = parser.getObject();
                }
            }
            else {
                while (token !== null && typeof token !== 'undefined' && token !== 'EOF') {
                    if (token instanceof _PdfDictionary && token !== null && token._map.FDF !== null && token._map.FDF !== undefined) {
                        token = token._map.FDF;
                        if (token instanceof _PdfDictionary && token._map.Fields !== null && token._map.Fields !== undefined) {
                            token = token._map.Fields;
                            if (token !== null && token !== undefined) {
                                for (var i = 0; i < token.length; i++) {
                                    var field = token[Number.parseInt(i.toString(), 10)];
                                    if (field instanceof _PdfDictionary && field !== null && field !== undefined) {
                                        var t = field.getArray('T');
                                        var v = void 0;
                                        if (field._map.V instanceof _PdfName) {
                                            v = field.getArray('V').name;
                                        }
                                        else {
                                            v = field.getArray('V');
                                        }
                                        if (t !== null && t !== undefined && t.length > 0) {
                                            this._table.set(t, v);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    token = parser.getObject();
                }
            }
            this._importField();
        }
    };
    _FdfDocument.prototype._parseAnnotationData = function () {
        var objects = new Map(); // eslint-disable-line
        var mappedObjects = new Map(); // eslint-disable-line  
        objects = this._table;
        if (objects !== null && typeof objects !== 'undefined' && objects.size > 0 && objects.has('trailer')) {
            var trailer = objects.get('trailer');
            if (trailer instanceof _PdfDictionary && trailer !== null && typeof trailer !== 'undefined' && trailer.has('Root')) {
                var holder = trailer.getRaw('Root');
                if (holder !== null && typeof holder !== 'undefined') {
                    var rootKey = holder.objectNumber.toString() + ' ' + holder.generationNumber.toString();
                    if (objects.has(rootKey)) {
                        var root = objects.get(rootKey);
                        if (root !== null && typeof root !== 'undefined' && root.has('FDF')) {
                            var fdf = root.get('FDF');
                            if (fdf !== null && typeof fdf !== 'undefined' && fdf.has('Annots')) {
                                var annots = fdf.get('Annots');
                                if (annots !== null && typeof annots !== 'undefined' && annots.length > 0) {
                                    for (var i = 0; i < annots.length; i++) {
                                        var annot = annots[Number.parseInt(i.toString(), 10)];
                                        var key = annot.objectNumber.toString() + ' ' + annot.generationNumber.toString();
                                        if (objects.has(key)) {
                                            annot = objects.get(key);
                                            mappedObjects.set(key, annot);
                                            objects.delete(key);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    objects.delete(rootKey);
                }
            }
            objects.delete('trailer');
        }
        return mappedObjects;
    };
    _FdfDocument.prototype._importField = function () {
        var _this = this;
        var form = this._document.form;
        var count = form.count;
        if (count) {
            this._table.forEach(function (value, key) {
                var textValue;
                if (_this._table.size > 0 && _this._table.has(key)) {
                    textValue = _this._table.get(key);
                }
                var index = form._getFieldIndex(key);
                if (index !== -1 && index < count) {
                    var field = form.fieldAt(index);
                    if (field) {
                        if (textValue && textValue !== '') {
                            field._dictionary.update('RV', textValue);
                        }
                        var param = [];
                        if (Array.isArray(value)) {
                            param = value;
                        }
                        else {
                            param.push(value);
                        }
                        _this._importFieldData(field, param);
                    }
                }
            });
        }
    };
    //#region Export Annotations
    _FdfDocument.prototype._exportAnnotationData = function (document, pageCount) {
        var genNumber = _StringTokenizer._whiteSpace + '0' + _StringTokenizer._whiteSpace;
        var startDictionary = '<<' + '/';
        this.fdfString += '%FDF-1.2' + '\r\n';
        var index = 2;
        var annot = new Array();
        var appearance = this.exportAppearance;
        for (var i = 0; i < pageCount; i++) {
            var page = document.getPage(i);
            if (page !== null && typeof page !== 'undefined' && page.annotations.count > 0) {
                for (var k = 0; k < page.annotations.count; k++) {
                    var annotation = page.annotations.at(k);
                    if (annotation !== null && typeof annotation !== 'undefined' && !(annotation instanceof PdfFileLinkAnnotation ||
                        annotation instanceof PdfTextWebLinkAnnotation || annotation instanceof PdfDocumentLinkAnnotation ||
                        annotation instanceof PdfUriAnnotation)) {
                        if (annotation instanceof PdfRubberStampAnnotation || annotation instanceof PdfRectangleAnnotation) {
                            var value = this._exportAnnotation(annotation, this.fdfString, index, annot, i, true);
                            index = value.index;
                            annot = value.annot;
                        }
                        else {
                            var value = this._exportAnnotation(annotation, this.fdfString, index, annot, i, appearance);
                            index = value.index;
                            annot = value.annot;
                        }
                    }
                }
            }
        }
        if (index !== 2) {
            var root = '1' + genNumber;
            this.fdfString += root + 'obj' + '\r\n' + startDictionary + 'FDF' + startDictionary + 'Annots' + '[';
            for (var i = 0; i < annot.length - 1; i++) {
                this.fdfString += annot[Number.parseInt(i.toString(), 10)] + genNumber + 'R' + ' ';
            }
            this.fdfString += annot[annot.length - 1] + genNumber + 'R' + ']' + '/' + 'F' + '(' + this._fileName + ')' + '/' + 'UF' + '(';
            this.fdfString += this._fileName + ')>>' + '/' + 'Type' + '/' + 'Catalog' + '>>' + '\r\n' + 'endobj' + '\r\n';
            this.fdfString += 'trailer' + '\r\n' + startDictionary + 'Root' + ' ' + root + 'R' + '>>' + '\r\n' + '%%EOF' + '\r\n';
        }
    };
    _FdfDocument.prototype._exportAnnotation = function (annotation, fdfString, index, annot, pageIndex, appearance) {
        this.fdfString = fdfString;
        var helper = new _FdfHelper();
        var dictionary = annotation._dictionary;
        var startObject = _StringTokenizer._whiteSpace + '0' + _StringTokenizer._whiteSpace + 'obj' + '\r\n';
        var endObject = '\r\n' + 'endobj' + '\r\n';
        this._annotationID = index.toString();
        this.fdfString += index + startObject + '<<';
        var list = new Map(); // eslint-disable-line
        var streamReference = new Array();
        annot.push(this._annotationID);
        dictionary.set('Page', pageIndex);
        var annotValue = this._getEntries(list, streamReference, index, dictionary, this.fdfString, appearance);
        index = annotValue.index;
        list = annotValue.list;
        streamReference = annotValue.streamReference;
        delete dictionary._map.Page;
        this.fdfString += '>>' + endObject;
        var _loop_1 = function () {
            var keys = Array();
            list.forEach(function (key, value) {
                keys.push(value);
            });
            for (var i = 0; i < keys.length; i++) {
                var key = keys[Number.parseInt(i.toString(), 10)];
                if (list.get(key) instanceof _PdfDictionary || list.get(key) instanceof _PdfStream ||
                    list.get(key) instanceof _PdfFlateStream) {
                    if (list.get(key) instanceof _PdfDictionary) {
                        dictionary = list.get(key);
                    }
                    else {
                        dictionary = list.get(key).dictionary;
                    }
                    if (dictionary !== null && typeof dictionary !== 'undefined') {
                        if (dictionary instanceof _PdfDictionary && dictionary.has('Type')) {
                            var type = dictionary.get('Type');
                            if (type !== null && typeof type !== 'undefined' && type.name === 'Annot') {
                                annot.push(key.toString());
                                dictionary.set('Page', pageIndex);
                            }
                        }
                        this_1.fdfString += key + startObject + '<<';
                        var value = this_1._getEntries(list, streamReference, index, dictionary, this_1.fdfString, appearance);
                        list = value.list;
                        streamReference = value.streamReference;
                        index = value.index;
                        if (dictionary instanceof _PdfDictionary && dictionary.has('Page')) {
                            delete dictionary._map.Page;
                        }
                        this_1.fdfString += '>>';
                        if (streamReference !== null && typeof streamReference !== 'undefined' && streamReference.indexOf(key) !== -1) {
                            this_1._appendStream(list.get(key), this_1.fdfString);
                        }
                        this_1.fdfString += endObject;
                    }
                }
                list.delete(key);
            }
        };
        var this_1 = this;
        while (list.size > 0) {
            _loop_1();
        }
        index++;
        helper.index = index;
        helper.annot = annot;
        return helper;
    };
    _FdfDocument.prototype._appendStream = function (value, fdfString) {
        var stream = value; // eslint-disable-line
        this.fdfString = fdfString;
        if (value instanceof _PdfFlateStream || value instanceof _PdfStream) {
            if (value instanceof _PdfFlateStream) {
                stream = value.stream;
            }
            else {
                stream = value;
            }
        }
        if (value instanceof _PdfFlateStream || value instanceof _PdfStream) {
            var byteArray = stream.getBytes();
            var dataArray = new Uint8Array(byteArray);
            var sw = new CompressedStreamWriter();
            sw.write(dataArray, 0, dataArray.length);
            sw.close();
            var compressString = sw.getCompressedString;
            this.fdfString += 'stream' + '\r\n';
            this.fdfString += compressString;
            this.fdfString += '\r\n' + 'endstream';
        }
    };
    _FdfDocument.prototype._getEntries = function (list, // eslint-disable-line
    streamReference, index, dictionary, fdfString, hasAppearance) {
        var _this = this;
        var flag = false;
        var helper = new _FdfHelper();
        this.fdfString = fdfString;
        var listDictionary = list; // eslint-disable-line
        dictionary.forEach(function (key, value) {
            if (!((!hasAppearance && key === 'AP'))) {
                if (key !== 'P') {
                    _this.fdfString += '/' + key;
                }
                if (key === 'Sound' || key === 'F' || hasAppearance) {
                    flag = true;
                }
                var primitive = value; // eslint-disable-line
                if (typeof primitive === 'string') {
                    _this.fdfString += '(' + _this._getFormattedString(primitive) + ')';
                }
                else if (primitive instanceof _PdfName) {
                    _this.fdfString += '/' + primitive.name;
                }
                else if (primitive instanceof Array) {
                    primitive = primitive; // eslint-disable-line
                    var value_1 = _this._appendArray(primitive, _this.fdfString, index, flag, listDictionary, streamReference);
                    listDictionary = value_1.list;
                    streamReference = value_1.streamReference;
                    index = value_1.index;
                }
                else if (typeof primitive === 'number') {
                    _this.fdfString += ' ' + primitive.toString();
                }
                else if (typeof primitive === 'boolean') {
                    _this.fdfString += ' ' + ((primitive) ? 'true' : 'false');
                }
                else if (primitive instanceof _PdfDictionary) {
                    _this.fdfString += '<<';
                    primitive = primitive;
                    var value_2 = _this._getEntries(listDictionary, streamReference, index, primitive, _this.fdfString, hasAppearance);
                    listDictionary = value_2.list;
                    streamReference = value_2.streamReference;
                    index = value_2.index;
                    _this.fdfString += '>>';
                }
                else if (primitive instanceof _PdfReference) {
                    var pageNumber = dictionary.get('Page');
                    if (key === 'Parent') {
                        _this.fdfString += ' ' + _this._annotationID + ' 0 R';
                        _this.fdfString += '/Page ' + pageNumber;
                    }
                    else if (key === 'IRT') {
                        if (_this._crossReference && _this._crossReference._fetch && primitive) {
                            var inReplyToDictionary = _this._crossReference._fetch(primitive);
                            if (inReplyToDictionary && inReplyToDictionary.has('NM')) {
                                var input = inReplyToDictionary.get('NM');
                                if (input !== null && typeof input !== 'undefined') {
                                    _this.fdfString += '(' + _this._getFormattedString(input) + ')';
                                }
                            }
                        }
                    }
                    else if (key !== 'P') {
                        var holder = primitive;
                        if (holder !== null && typeof holder !== 'undefined') {
                            index++;
                            _this.fdfString += ' ' + index + ' 0 R';
                            if (flag) {
                                streamReference.push(index);
                            }
                            listDictionary.set(index, dictionary.get(key));
                        }
                    }
                }
                flag = false;
            }
        });
        helper.list = listDictionary;
        helper.streamReference = streamReference;
        helper.index = index;
        return helper;
    };
    _FdfDocument.prototype._appendArray = function (array, // eslint-disable-line
    fdfString, index, flag, list, // eslint-disable-line
    streamReference) {
        this.fdfString = fdfString;
        this.fdfString += '[';
        var helper = new _FdfHelper();
        var listDictionary = list; // eslint-disable-line
        if (_isNullOrUndefined(array) && array.length > 0) {
            var count = array.length;
            for (var i = 0; i < count; i++) {
                var element = array[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                if (i !== 0 && (typeof element === 'number' || element instanceof _PdfReference || typeof element === 'boolean')) {
                    this.fdfString += ' ';
                }
                var value = this._appendElement(element, this.fdfString, index, flag, listDictionary, streamReference);
                listDictionary = value.list;
                streamReference = value.streamReference;
                index = value.index;
            }
        }
        this.fdfString += ']';
        helper.list = listDictionary;
        helper.streamReference = streamReference;
        helper.index = index;
        return helper;
    };
    _FdfDocument.prototype._appendElement = function (element, // eslint-disable-line
    fdfString, index, flag, list, // eslint-disable-line
    streamReference) {
        this.fdfString = fdfString;
        var helper = new _FdfHelper();
        var listDictionary = list; // eslint-disable-line
        if (typeof element === 'number') {
            this.fdfString += (element).toString();
        }
        else if (element instanceof _PdfName) {
            this.fdfString += (element.name.toString());
        }
        else if (element instanceof Array) {
            element = element; // eslint-disable-line
            var value = this._appendArray(element, this.fdfString, index, flag, listDictionary, streamReference);
            listDictionary = value.list;
            streamReference = value.streamReference;
            index = value.index;
        }
        else if (element instanceof _PdfDictionary) {
            this.fdfString += '<<';
            element = element;
            var value = this._getEntries(listDictionary, streamReference, index, element, this.fdfString, flag);
            listDictionary = value.list;
            streamReference = value.streamReference;
            index = value.index;
            this.fdfString += '>>';
        }
        helper.list = listDictionary;
        helper.streamReference = streamReference;
        helper.index = index;
        return helper;
    };
    _FdfDocument.prototype._getFormattedString = function (value) {
        var result = '';
        for (var i = 0; i < value.length; i++) {
            var c = value.charCodeAt(i);
            if (c === 40 || c === 41) {
                result += '\'';
            }
            result += String.fromCharCode(c);
        }
        return result;
    };
    //#endregion
    _FdfDocument.prototype._checkFdf = function (element) {
        if (element.includes(this._specialCharacters) || element.includes('Ã¢Ã£Ã\u008fÃ\u0093')) {
            this._asPerSpecification = true;
        }
        if (element.startsWith('%')) {
            var token = element.substring(1, 5);
            if (token !== 'FDF-') { // eslint-disable-line
                throw new Error('Invalid FDF file.');
            }
        }
    };
    _FdfDocument.prototype._stringToHexString = function (text) {
        var hexString = '';
        if (text !== null && typeof text !== 'undefined' && text.length > 0) {
            var bytesValue = _stringToBytes(text);
            hexString = _byteArrayToHexString(bytesValue);
        }
        return hexString;
    };
    return _FdfDocument;
}(_ExportHelper));
var _FdfHelper = /** @class */ (function () {
    function _FdfHelper() {
    }
    return _FdfHelper;
}());

var __extends$i = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _XmlDocument = /** @class */ (function (_super) {
    __extends$i(_XmlDocument, _super);
    function _XmlDocument(fileName) {
        var _this = _super.call(this) || this;
        if (fileName !== null && typeof fileName !== 'undefined') {
            _this._fileName = fileName;
        }
        return _this;
    }
    _XmlDocument.prototype._exportAnnotations = function () {
        throw new Error('Method not implemented.');
    };
    _XmlDocument.prototype._exportFormFields = function (document) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        this._format = 'XML';
        this._key = _getNewGuidString();
        return this._save();
    };
    _XmlDocument.prototype._save = function () {
        var writer = new _XmlWriter();
        writer._writeStartDocument();
        if (this._asPerSpecification) {
            writer._writeStartElement('fields');
            writer._writeAttributeString('xfdf', 'http://ns.adobe.com/xfdf-transition/', 'xmlns', null);
        }
        else {
            writer._writeStartElement('Fields');
        }
        var form = this._document.form;
        if (form !== null && typeof form !== 'undefined') {
            this._exportEmptyFields = form.exportEmptyFields;
            var count = this._document.form.count;
            for (var i = 0; i < count; i++) {
                var field = this._document.form.fieldAt(i);
                if (field !== null && typeof field !== 'undefined' && field.export) {
                    this._exportFormFieldData(field);
                }
            }
            this._writeFormFieldData(writer, this._asPerSpecification);
        }
        var result = writer._save();
        writer._destroy();
        return result;
    };
    _XmlDocument.prototype._writeFormFieldData = function (writer, isAcrobat) {
        if (isAcrobat === void 0) { isAcrobat = false; }
        if (isAcrobat) {
            this._table.forEach(function (value, key) {
                if (key.includes(' ')) {
                    var text = key.replace(/ /g, '');
                    writer._writeStartElement(text.toString());
                    writer._writeAttributeString('original', key.toString(), 'xfdf', null);
                }
                else {
                    writer._writeStartElement(key.toString());
                }
                writer._writeString(value.toString());
                writer._writeEndElement();
            });
        }
        else {
            this._table.forEach(function (value, key) {
                if (key.includes(' ')) {
                    key = key.replace(/ /g, '_x0020_');
                }
                writer._writeStartElement(key.toString());
                writer._writeString(value.toString());
                writer._writeEndElement();
            });
        }
        writer._writeEndElement();
    };
    _XmlDocument.prototype._importFormData = function (document, data) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        var value = _bytesToString(data);
        value = value.replace(/(\r\n|\n|\r)/gm, '');
        value = value.replace(/[^\x20-\x7E]/g, '');
        this._xmlDocument = (new DOMParser()).parseFromString(value, 'text/xml');
        this._checkXml(this._xmlDocument);
        this._xmlImport = true;
        this._parseFormData(this._xmlDocument.documentElement);
        this._xmlImport = false;
    };
    _XmlDocument.prototype._parseFormData = function (root) {
        var child = root.childNodes;
        if (child !== null && typeof child !== 'undefined' && child.length > 0) {
            for (var i = 0; i < child.length; i++) {
                var childNode = child.item(i);
                if (childNode !== null && typeof childNode !== 'undefined' && childNode.nodeType === 1) {
                    var element = childNode;
                    var text = '';
                    if (element.attributes !== null && typeof element.attributes !== 'undefined' && element.attributes.length > 0) {
                        var attribute = element.attributes.item(0); // eslint-disable-line
                        if (attribute !== null && typeof attribute !== 'undefined' && attribute.name === 'xfdf:original') {
                            text = attribute.value;
                        }
                    }
                    else {
                        text = element.tagName;
                    }
                    var v = element.textContent;
                    if (text !== null && text !== undefined && text.length > 0) {
                        this._table.set(text, v);
                    }
                }
            }
        }
        this._importField();
    };
    _XmlDocument.prototype._importField = function () {
        var _this = this;
        var form = this._document.form;
        var count = form.count;
        if (count) {
            this._table.forEach(function (value, key) {
                var textValue;
                if (_this._table.size > 0 && _this._table.has(key)) {
                    textValue = _this._table.get(key);
                }
                var text = key.toString();
                if (text.indexOf('_x0020_') !== -1) {
                    text = text.replace(/_x0020_/g, ' ');
                }
                var index = form._getFieldIndex(text);
                if (index !== -1 && index < count) {
                    var field = form.fieldAt(index);
                    if (field && field !== null && typeof field !== 'undefined') {
                        if (textValue && textValue !== '') {
                            field._dictionary.update('RV', textValue);
                        }
                        var param = [];
                        param.push(value);
                        _this._importFieldData(field, param);
                    }
                }
            });
        }
    };
    _XmlDocument.prototype._checkXml = function (xmlDocument) {
        if (xmlDocument.getElementsByTagName('parsererror').length > 0) {
            throw new Error('Invalid XML file.');
        }
    };
    return _XmlDocument;
}(_ExportHelper));

/**
 * `PdfFileStructure` class represents the internal structure of the PDF file.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access the internal file structure of the PDF document
 * let fileStructure: PdfFileStructure = document.fileStructure;
 * // Set the cross reference type
 * fileStructure.crossReferenceType = PdfCrossReferenceType.stream;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfFileStructure = /** @class */ (function () {
    function PdfFileStructure() {
        this._incrementalUpdate = true;
    }
    Object.defineProperty(PdfFileStructure.prototype, "crossReferenceType", {
        /**
         * Gets the cross reference type of the PDF document.
         *
         * @returns {PdfCrossReferenceType} - Returns the cross reference type of the PDF document.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the internal file structure of the PDF document
         * let fileStructure: PdfFileStructure = document.fileStructure;
         * // Get the cross reference type
         * let type: PdfCrossReferenceType = fileStructure.crossReferenceType;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._crossReferenceType;
        },
        /**
         * Sets the cross reference type of the PDF document.
         *
         * @param {PdfCrossReferenceType} value - Specifies the cross reference type of the PDF document.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the internal file structure of the PDF document
         * let fileStructure: PdfFileStructure = document.fileStructure;
         * // Set the cross reference type
         * fileStructure.crossReferenceType = PdfCrossReferenceType.stream;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._crossReferenceType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFileStructure.prototype, "isIncrementalUpdate", {
        /**
         * Gets the boolean flag indicating whether the update is incremental.
         *
         * @returns { boolean } - Returns true if the PDF document supports incremental updates, otherwise false
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the internal file structure of the PDF document
         * let fileStructure: PdfFileStructure = document.fileStructure;
         * // Get the incremental update
         * let incrementalUpdate: boolean = fileStructure.isIncrementalUpdate;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._incrementalUpdate;
        },
        /**
         * Sets the boolean flag indicating whether the update is incremental.
         *
         * @param {boolean} value - If `true`, enables incremental updates for the PDF document; otherwise, disables it.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the internal file structure of the PDF document
         * let fileStructure: PdfFileStructure = document.fileStructure;
         * // Set the incremental updates
         * fileStructure.isIncrementalUpdate = false;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._incrementalUpdate = value;
        },
        enumerable: true,
        configurable: true
    });
    return PdfFileStructure;
}());

/**
 * `PdfPageImportOptions` class represents to customize the support of import PDF pages
 *
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Options to customize the support of import PDF pages.
 * let options: PdfPageImportOptions = new PdfPageImportOptions();
 * // Sets the target page index to import
 * options.targetIndex = 1;
 * // Sets the rotation angle of the page to import
 * options.rotation = PdfRotationAngle.angle180;
 * // Sets the boolean value indicating whether the optimize resources while import pages or not
 * options.optimizeResources = true;
 * // Copy the first page and add it as second page with page rotation
 * document.importPage(0, options);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfPageImportOptions = /** @class */ (function () {
    function PdfPageImportOptions() {
        this._optimizeResources = true;
        this._groupFormFields = false;
    }
    Object.defineProperty(PdfPageImportOptions.prototype, "targetIndex", {
        /**
         * Gets the target page index to import
         *
         * @returns {PdfRotationAngle} Page rotation angle.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Options to customize the support of import PDF pages.
         * let options: PdfPageImportOptions = new PdfPageImportOptions();
         * // Gets the target page index to import
         * let targetIndex: number = options.targetIndex;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._targetIndex;
        },
        /**
         * Sets the target page index to import
         *
         * @param {number} value Target page index to import.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Options to customize the support of import PDF pages.
         * let options: PdfPageImportOptions = new PdfPageImportOptions();
         * // Sets the target page index to import
         * options.targetIndex = 1;
         * // Copy the first page and add it as second page with page rotation
         * document.importPage(0, options);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._targetIndex = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPageImportOptions.prototype, "rotation", {
        /**
         * Gets the rotation angle of the page to import
         *
         * @returns {PdfRotationAngle} Page rotation angle.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Options to customize the support of import PDF pages.
         * let options: PdfPageImportOptions = new PdfPageImportOptions();
         * // Gets the rotation angle of the page to import
         * let rotation: PdfRotationAngle = options.rotation;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._rotation;
        },
        /**
         * Sets the rotation angle of the page to import
         *
         * @param {PdfRotationAngle} value Page rotation angle.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Options to customize the support of import PDF pages.
         * let options: PdfPageImportOptions = new PdfPageImportOptions();
         * // Sets the rotation angle of the page to import
         * options.rotation = PdfRotationAngle.angle270;
         * // Copy the first page and add it as second page with page rotation
         * document.importPage(0, options);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._rotation = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPageImportOptions.prototype, "optimizeResources", {
        /**
         * Gets the boolean value indicating whether the optimize resources while import pages or not
         *
         * @returns {boolean} Indicates resource optimization.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Options to customize the support of import PDF pages.
         * let options: PdfPageImportOptions = new PdfPageImportOptions();
         * // Gets the boolean value indicating whether the optimize resources while import pages or not
         * let resource: optimizeResources = options.optimizeResources;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._optimizeResources;
        },
        /**
         * Sets the boolean value indicating whether the optimize resources while import pages or not
         *
         * @param {boolean} value Indicates resource optimization.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Options to customize the support of import PDF pages.
         * let options: PdfPageImportOptions = new PdfPageImportOptions();
         * // Sets the boolean value indicating whether the optimize resources while import pages or not
         * options.optimizeResources = true;
         * // Copy the first page and add it as second page with page rotation
         * document.importPage(0, options);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._optimizeResources = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPageImportOptions.prototype, "groupFormFields", {
        /**
         * Gets the boolean value indicating whether the form fields are grouped or not while importing pages.
         *
         * @returns {boolean} value Indicates form fields grouping.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Options to customize the support of import PDF pages.
         * let options: PdfPageImportOptions = new PdfPageImportOptions();
         * // Gets the boolean value indicating whether the form fields are grouped or not while importing pages.
         * let groupFormfields: number = options.groupFormFields;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._groupFormFields;
        },
        /**
         * Sets the boolean value indicating whether the form fields are grouped or not while importing pages.
         *
         * @param {boolean} value Indicates form fields grouping
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Options to customize the support of import PDF pages.
         * let options: PdfPageImportOptions = new PdfPageImportOptions();
         * // Sets the boolean value indicating whether the form fields are grouped or not while importing pages.
         * options.groupFormFields = true;
         * // Copy the first page and add it as second page.
         * document.importPage(0, options);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._groupFormFields = value;
        },
        enumerable: true,
        configurable: true
    });
    return PdfPageImportOptions;
}());

var _PdfMergeHelper = /** @class */ (function () {
    function _PdfMergeHelper(crossReference, destination, source, pageReference, options) {
        this._namedDestinations = []; // eslint-disable-line
        this._bookmarks = []; // eslint-disable-line
        this._fields = []; // eslint-disable-line
        this._pageReference = new Map();
        this._bookmarksPageLinkReference = new Map();
        this._destination = []; // eslint-disable-line
        this._newList = new Map();
        this._annotationLayer = new Map();
        this._isLayersPresent = false;
        this._fieldNames = [];
        this._options = new PdfPageImportOptions();
        this._kidsReference = []; // eslint-disable-line
        this._formFieldsCollection = new Map();
        this._formFields = [];
        this._isDuplicatePage = false;
        this._fieldCount = 0;
        this._crossReference = crossReference;
        this._destinationDocument = destination;
        this._sourceDocument = source;
        this._pageReference = pageReference;
        if (typeof options !== 'undefined') {
            this._options = options;
        }
        this._copier = new _PdfCopier(this._crossReference, this._sourceDocument._crossReference);
    }
    _PdfMergeHelper.prototype._importPages = function (page, index, layers, isCopiedPage, options, isSplitDocument) {
        var _this = this;
        var template;
        var newPage;
        var pageDictionary = page._pageDictionary;
        this._isDuplicatePage = isCopiedPage;
        if (!options) {
            this._options.rotation = page.rotation;
        }
        else {
            this._options.rotation = options.rotation;
        }
        if (typeof index === 'number') {
            newPage = this._insertNewPage(page, index);
        }
        else if (this._isDuplicatePage) {
            newPage = this._insertNewPage(page, page._pageIndex + 1);
        }
        else {
            newPage = this._insertNewPage(page);
        }
        if ((isCopiedPage || isSplitDocument) && this._options.optimizeResources) {
            var newContents_1 = []; // eslint-disable-line
            pageDictionary.forEach(function (key, value) {
                if (key === 'Contents' && newContents_1.length === 0) {
                    var contents = value; // eslint-disable-line
                    if (contents instanceof _PdfReference) {
                        var pageContent = isSplitDocument ? _this._copier._copy(contents) : contents; // eslint-disable-line
                        newPage._pageDictionary.update(key, pageContent);
                    }
                    else if (contents instanceof Array) {
                        for (var i = 0; i < contents.length; i++) {
                            var newContent = isSplitDocument ? (_this._copier._copy(contents[Number.parseInt(i.toString(), 10)])) : // eslint-disable-line
                                contents[Number.parseInt(i.toString(), 10)];
                            newContents_1.push(newContent);
                        }
                        newPage._pageDictionary.update(key, newContents_1);
                    }
                }
                else if (key === 'Resources' && value) {
                    var resourceValue = isSplitDocument ? _this._copier._copy(value) : value; // eslint-disable-line
                    if (resourceValue) {
                        newPage._pageDictionary.update(key, resourceValue);
                    }
                }
                else if (key !== 'Resources' && key !== 'MediaBox' && key !== 'CropBox' && key !== 'Parent' && key !== 'Annots'
                    && key !== 'Contents' && key !== 'Rotate') {
                    newPage._pageDictionary.update(key, value);
                }
            });
        }
        else {
            template = page._contentTemplate;
            newPage.graphics.drawTemplate(template, { x: 0, y: 0, width: template._size[0], height: template._size[1] });
            template._content.dictionary.update('Resources', this._copier._copy(pageDictionary.getRaw('Resources')));
            this._pageReference.set(pageDictionary, newPage);
            if (!isCopiedPage) {
                this._bookmarksPageLinkReference.set(page._ref, newPage._pageIndex);
            }
        }
        if (pageDictionary.has('Annots')) {
            this._importAnnotation(page, newPage);
            if (typeof this._options !== 'undefined' && this._options.groupFormFields && this._sourceDocument._catalog._catalogDictionary.has('AcroForm')) {
                this._formFieldsGroupingSupport(this._sourceDocument.form, page, newPage);
            }
            else if (this._sourceDocument._catalog._catalogDictionary.has('AcroForm')) {
                this._importFormField(page, this._sourceDocument.form, newPage, this._sourceDocument._crossReference);
            }
        }
        if (!isCopiedPage) {
            var bookMarkMap = this._sourceDocument._parseBookmarkDestination();
            if (bookMarkMap && bookMarkMap.has(page)) {
                var bookmarks = bookMarkMap.get(page);
                for (var i = 0; i < bookmarks.length; i++) {
                    this._bookmarks.push(bookmarks[Number.parseInt(i.toString(), 10)]);
                }
            }
        }
        if ((!isCopiedPage && layers) || !this._options.optimizeResources) {
            this._mergeLayer(newPage._pageDictionary, pageDictionary, this._sourceDocument._crossReference);
        }
        newPage._pageDictionary._updated = true;
    };
    _PdfMergeHelper.prototype._importAnnotation = function (page, newPage) {
        var array = []; // eslint-disable-line
        var dest; // eslint-disable-line
        var isDestination = false;
        var oldCollection = page.annotations;
        var count = oldCollection.count;
        for (var i = 0; i < count; i++) {
            var annotationReference = oldCollection._annotations[Number.parseInt(i.toString(), 10)];
            if (annotationReference) {
                var annotationDictionary = this._sourceDocument._crossReference._fetch(annotationReference);
                if (annotationDictionary) {
                    if (annotationDictionary.has('Dest')) {
                        dest = [];
                        var destinationArray = annotationDictionary.get('Dest'); // eslint-disable-line
                        var destination = annotationDictionary._get('Dest'); // eslint-disable-line
                        if (destinationArray instanceof Array) {
                            var destArray = destinationArray; // eslint-disable-line
                            for (var j = 0; j < destArray.length; j++) {
                                dest.push(destArray[Number.parseInt(j.toString(), 10)]);
                            }
                            isDestination = true;
                        }
                        else if (destination instanceof _PdfReference) {
                            dest.push(destination);
                        }
                    }
                    if (dest && dest.length > 0) {
                        this._destination.push(dest);
                    }
                    if (annotationDictionary.has('OC')) {
                        var reference = annotationDictionary.getRaw('OC'); // eslint-disable-line
                        if (reference instanceof _PdfReference) {
                            this._annotationLayer.set(i, reference);
                        }
                    }
                    var copiedAnnotationReference = this._copier._copy(annotationReference);
                    var copiedAnnotationDictionary = this._destinationDocument._crossReference.
                        _fetch(copiedAnnotationReference);
                    if (isDestination) {
                        copiedAnnotationDictionary.update('Dest', dest);
                    }
                    copiedAnnotationDictionary.update('P', newPage._ref);
                    this._crossReference._cacheMap.set(copiedAnnotationReference, copiedAnnotationDictionary);
                    array.push(copiedAnnotationReference);
                }
            }
            isDestination = false;
            dest = [];
        }
        if (array.length > 0) {
            newPage._pageDictionary.update('Annots', array);
        }
    };
    _PdfMergeHelper.prototype._formFieldsGroupingSupport = function (form, oldPage, newPage) {
        var array = [];
        var fieldNames = [];
        var kidsArray = [];
        var formFields;
        var drEntry = form._dictionary.get('DR');
        if (form._dictionary.has('DR')) {
            drEntry = form._dictionary.get('DR');
        }
        if (newPage._pageDictionary.has('Annots')) {
            array = newPage._pageDictionary.get('Annots');
        }
        if (oldPage._pageDictionary.has('Annots')) {
            kidsArray = oldPage._pageDictionary.get('Annots');
        }
        if (!this._isDuplicatePage) {
            formFields = this._destinationDocument.form;
            this._fieldCount = formFields.count;
            for (var k = 0; k < this._fieldCount; k++) {
                fieldNames.push(formFields.fieldAt(k).name);
            }
        }
        for (var i = 0; i < form.count; i++) {
            var field = form.fieldAt(i);
            var formField = void 0;
            var destinationKids = [];
            var sourceKids = field._dictionary.get('Kids');
            if (fieldNames.indexOf(field.name) !== -1 || this._isDuplicatePage) {
                if (!this._isDuplicatePage) {
                    formField = formFields.fieldAt(fieldNames.indexOf(field.name));
                    if (formField._dictionary.get('Kids')) {
                        destinationKids = formField._dictionary.get('Kids');
                    }
                }
                else {
                    formField = field;
                    destinationKids = sourceKids;
                }
                field._isDuplicatePage = true;
                if ((field instanceof PdfSignatureField && formField instanceof PdfSignatureField) || !(field instanceof
                    PdfSignatureField)) {
                    if (sourceKids !== undefined && sourceKids.length > 0) {
                        for (var j = 0; j < sourceKids.length; j++) {
                            var fieldItem = field.itemAt(j); // eslint-disable-line
                            if (fieldItem.page === oldPage) {
                                formField._page = newPage;
                                array = this._groupFormFieldsKids(formField, field, kidsArray, destinationKids, sourceKids, newPage._ref, array, j, i, drEntry, fieldItem);
                            }
                        }
                    }
                    else {
                        array = this._groupFormFieldsKids(formField, field, kidsArray, destinationKids, sourceKids, newPage._ref, array, 0, i, drEntry);
                    }
                }
            }
            else {
                array = this._insertFormFields(i, form._crossReference, field, form, newPage._ref, array, kidsArray);
            }
        }
        if (array.length > 0) {
            newPage._pageDictionary.update('Annots', array);
        }
    };
    _PdfMergeHelper.prototype._groupFormFieldsKids = function (destinationField, field, kidsArray, destKids, oldKids, ref, array, index, fieldIndex, drEntry, widget) {
        if (field._dictionary.has('Kids') && destinationField._dictionary.has('Kids')) {
            if (kidsArray.indexOf(oldKids[Number.parseInt(index.toString(), 10)]) !== -1) {
                var oldDictionary = field._crossReference._fetch(oldKids[Number.parseInt(index.toString(), 10)]);
                var dictionary = this._copier._copyDictionary(oldDictionary, !this._isDuplicatePage);
                dictionary.update('P', ref);
                var reference = this._crossReference._getNextReference();
                this._crossReference._cacheMap.set(reference, dictionary);
                array.push(reference);
                dictionary.update('Parent', destinationField._ref);
                destKids.push(reference);
                dictionary._updated = true;
                destinationField._dictionary._updated = true;
                if (!this._isDuplicatePage) {
                    if ((destinationField instanceof PdfTextBoxField || destinationField instanceof PdfButtonField || destinationField instanceof PdfComboBoxField) && dictionary.has('AS')) {
                        delete dictionary._map.AS;
                    }
                    this._createAppearance(destinationField, field, oldDictionary, dictionary, drEntry, widget);
                }
            }
        }
        else if (field._dictionary.has('Kids') && !destinationField._dictionary.has('Kids') || this._isDuplicatePage) {
            var fieldDictionary = this._copier._copyDictionary(destinationField._dictionary, !this._isDuplicatePage);
            this._updateFieldsWithKids(destinationField, field, fieldDictionary, index, fieldIndex, ref, oldKids, array, drEntry, destinationField._dictionary);
        }
        else if ((!field._dictionary.has('Kids') && destinationField._dictionary.has('Kids'))) {
            var fieldDict = this._copier._copyDictionary(field._dictionary);
            this._updateFieldDictionary(fieldDict, ref, destinationField._ref);
            var reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, fieldDict);
            destKids.push(reference);
            array.push(reference);
            destinationField._dictionary._updated = true;
            this._createAppearance(destinationField, field, field._dictionary, fieldDict, drEntry, widget);
        }
        else if (!field._dictionary.has('Kids') && !destinationField._dictionary.has('Kids')) {
            var fieldDictionary = this._copier._copyDictionary(destinationField._dictionary);
            var formFieldDict = this._copier._copyDictionary(field._dictionary, !this._isDuplicatePage);
            this._removeFieldDictionary(formFieldDict, ['Parent', 'FT', 'T', 'Ff']);
            formFieldDict.update('P', ref);
            this._updateFieldsWithKids(destinationField, field, fieldDictionary, index, fieldIndex, ref, oldKids, array, drEntry, formFieldDict);
        }
        return array;
    };
    _PdfMergeHelper.prototype._updateFieldsWithKids = function (destinationField, field, fieldDictionary, index, fieldIndex, ref, oldKids, array, drEntry, formFieldDictionary) {
        var newFieldReference = this._crossReference._getNextReference();
        var newFieldDict = this._createNewFieldDictionary(fieldDictionary, destinationField._dictionary);
        newFieldDict.objId = newFieldReference.toString();
        this._crossReference._cacheMap.set(newFieldReference, newFieldDict);
        var newField = this._destinationDocument.form._parseFields(newFieldDict, newFieldReference);
        destinationField._dictionary.update('Parent', newFieldReference);
        newField._dictionary._updated = true;
        this._updateFieldDictionary(fieldDictionary, ref, newFieldReference);
        this._destinationDocument.form._dictionary._updated = true;
        var oldDictionary;
        if (oldKids !== undefined && oldKids.length > 0) {
            oldDictionary = field._crossReference._fetch(oldKids[Number.parseInt(index.toString(), 10)]);
        }
        else {
            oldDictionary = formFieldDictionary;
        }
        var dictionary = this._copier._copyDictionary(oldDictionary, !this._isDuplicatePage);
        if ((destinationField instanceof PdfTextBoxField || destinationField instanceof PdfButtonField || destinationField instanceof PdfComboBoxField) && dictionary.has('AS')) {
            delete dictionary._map.AS;
        }
        var reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, dictionary);
        dictionary.update('P', ref);
        array.push(reference);
        dictionary.update('Parent', newField._ref);
        var kidsElement = [];
        kidsElement.push(destinationField._ref);
        kidsElement.push(reference);
        dictionary._updated = true;
        destinationField._dictionary._updated = true;
        newFieldDict.update('Kids', kidsElement);
        newField._kids = kidsElement;
        this._formFieldsCollection.set(fieldIndex, newFieldReference);
        this._destinationDocument.form._parsedFields.set(fieldIndex, newField);
        if (!this._isDuplicatePage) {
            this._createAppearance(newField, field, oldDictionary, dictionary, drEntry);
        }
        newFieldDict._updated = true;
    };
    _PdfMergeHelper.prototype._removeFieldDictionary = function (dictionary, keys) {
        keys.forEach(function (key) {
            if (dictionary.has(key)) {
                delete dictionary._map[key]; // eslint-disable-line
            }
        });
        return dictionary;
    };
    _PdfMergeHelper.prototype._updateFieldDictionary = function (dictionary, pageRef, parentRef) {
        dictionary = this._removeFieldDictionary(dictionary, ['Parent', 'FT', 'T', 'Ff']);
        dictionary.update('P', pageRef);
        dictionary.update('Parent', parentRef);
        dictionary._updated = true;
    };
    _PdfMergeHelper.prototype._createNewFieldDictionary = function (fieldDictionary, destDictionary) {
        var newFieldDict = new _PdfDictionary(this._crossReference);
        ['Parent', 'FT', 'T', 'V', 'Ff', 'TU', 'Opt', 'I'].forEach(function (key) {
            if (fieldDictionary.has(key)) {
                newFieldDict.update(key, fieldDictionary.get(key));
                delete fieldDictionary._map[key]; // eslint-disable-line
                delete destDictionary._map[key]; // eslint-disable-line
            }
        });
        return newFieldDict;
    };
    _PdfMergeHelper.prototype._getItemStyle = function (item, field) {
        var mkDictionary = item._dictionary.get('MK');
        if (mkDictionary && mkDictionary.has('CA')) {
            item._styleText = mkDictionary.get('CA').charAt(0);
        }
        else {
            item._styleText = (field instanceof PdfRadioButtonListField) ? 'l' : '4';
        }
    };
    _PdfMergeHelper.prototype._createAppearance = function (destinationField, field, oldDictionary, dictionary, drEntry, widget) {
        var previousIndex = destinationField._kidsCount - 1;
        var itemValue;
        if (destinationField instanceof PdfCheckBoxField) {
            var item = destinationField.itemAt(previousIndex);
            item._enableGrouping = true;
            this._getItemStyle(item, destinationField);
            if (field instanceof PdfRadioButtonListField) {
                item._dictionary.update('AS', _PdfName.get('Off'));
                itemValue = _getItemValue(oldDictionary);
            }
            else {
                item._postProcess(destinationField.checked ? 'Yes' : 'Off');
            }
            destinationField._drawAppearance(item, itemValue);
        }
        else if (destinationField instanceof PdfRadioButtonListField) {
            var item = destinationField.itemAt(previousIndex);
            this._getItemStyle(item, destinationField);
            if (item._dictionary.has('AS')) {
                item._postProcess(item._dictionary.get('AS').name);
            }
            else {
                item._postProcess('Off');
            }
            item._enableGrouping = true;
            destinationField._enableGrouping = true;
            destinationField._drawAppearance(item);
        }
        else if (destinationField instanceof PdfListField) {
            var item = destinationField.itemAt(previousIndex);
            if (typeof widget !== 'undefined') {
                item.rotationAngle = widget.rotationAngle;
            }
            if (item && !destinationField._checkFieldFlag(item._dictionary)) {
                item._enableGrouping = true;
                var template = destinationField._createAppearance(item);
                destinationField._addAppearance(item._dictionary, template, 'N');
                item._dictionary._updated = true;
            }
        }
        else if (destinationField instanceof PdfTextBoxField || destinationField instanceof PdfButtonField || destinationField instanceof
            PdfSignatureField) {
            var widgetAnnotation = PdfWidgetAnnotation._load(dictionary, this._crossReference);
            if (typeof widget !== 'undefined' && widget !== null && destinationField instanceof PdfSignatureField) {
                destinationField._createAppearance(widget, false);
            }
            else {
                widgetAnnotation.setAppearance(true);
                widgetAnnotation._enableGrouping = true;
                var pdfFont = void 0;
                if (typeof widget !== 'undefined' && widget !== null) {
                    pdfFont = this._obtainFont(widget._dictionary, drEntry);
                }
                else {
                    pdfFont = this._obtainFont(dictionary, drEntry);
                }
                widgetAnnotation._pdfFont = pdfFont;
                if (destinationField instanceof PdfSignatureField) {
                    destinationField._createAppearance(widgetAnnotation, false);
                }
                else {
                    destinationField._postProcess(false, widgetAnnotation);
                }
            }
        }
    };
    _PdfMergeHelper.prototype._obtainFont = function (item, formDictionary) {
        var fontFamily = '';
        var fontSize = 8;
        var pdfFont;
        if (item && (item.has('DS') || item.has('DA'))) {
            if (item.has('DS')) {
                var collection = item.get('DS').split(';');
                for (var i = 0; i < collection.length; i++) {
                    var entry = collection[Number.parseInt(i.toString(), 10)].split(':');
                    if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-family') !== -1) {
                        fontFamily = entry[1];
                    }
                    else if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-style') === -1 && collection[Number.parseInt(i.toString(), 10)].indexOf('font') !== -1) {
                        var name_1 = entry[1];
                        var split = name_1.split(' ');
                        for (var j = 0; j < split.length; j++) {
                            if (split[Number.parseInt(j.toString(), 10)] !== '' && !split[Number.parseInt(j.toString(), 10)].endsWith('pt')) {
                                fontFamily += split[Number.parseInt(j.toString(), 10)] + ' ';
                            }
                        }
                        while (fontFamily !== ' ' && fontFamily.endsWith(' ')) {
                            fontFamily = fontFamily.substring(0, fontFamily.length - 2);
                        }
                        if (fontFamily.indexOf(',') !== -1) {
                            fontFamily = fontFamily.split(',')[0];
                        }
                    }
                }
            }
            else {
                var value = item.get('DA');
                if (value && value !== '' && value.indexOf('Tf') !== -1) {
                    var textCollection = value.split(' ');
                    for (var i = 0; i < textCollection.length; i++) {
                        if (textCollection[Number.parseInt(i.toString(), 10)].indexOf('Tf') !== -1) {
                            fontFamily = textCollection[i - 2];
                            while (fontFamily !== '' && fontFamily.length > 1 && fontFamily[0] === '/') {
                                fontFamily = fontFamily.substring(1);
                            }
                            fontSize = Number.parseFloat(textCollection[i - 1]);
                        }
                    }
                    if (fontSize === 0) {
                        fontSize = 8;
                    }
                }
            }
        }
        fontFamily = fontFamily.trim();
        var fontStyle = PdfFontStyle.regular;
        var baseFontName;
        if (typeof formDictionary != 'undefined' && formDictionary.has('Font')) {
            var dictionary = formDictionary.get('Font').get(fontFamily);
            if (typeof dictionary !== 'undefined') {
                baseFontName = dictionary.get('BaseFont').name;
                fontStyle = this._getFontStyle(baseFontName);
            }
        }
        switch (fontFamily) {
            case 'Helv':
                pdfFont = new PdfStandardFont(PdfFontFamily.helvetica, fontSize, fontStyle);
                break;
            case 'Courier':
            case 'Cour':
                pdfFont = new PdfStandardFont(PdfFontFamily.courier, fontSize, fontStyle);
                break;
            case 'Symb':
                pdfFont = new PdfStandardFont(PdfFontFamily.symbol, fontSize, fontStyle);
                break;
            case 'TiRo':
            case 'TiIt':
                pdfFont = new PdfStandardFont(PdfFontFamily.timesRoman, fontSize, fontStyle);
                break;
            case 'ZaDb':
                pdfFont = new PdfStandardFont(PdfFontFamily.zapfDingbats, fontSize, fontStyle);
                break;
            default:
                pdfFont = new PdfStandardFont(PdfFontFamily.helvetica, fontSize, fontStyle);
                break;
        }
        return pdfFont;
    };
    _PdfMergeHelper.prototype._getFontStyle = function (fontStyle) {
        var style = PdfFontStyle.regular;
        if (fontStyle.includes('Bold')) {
            style = PdfFontStyle.bold;
        }
        else if (fontStyle.includes('Italic')) {
            style = PdfFontStyle.italic;
        }
        return style;
    };
    _PdfMergeHelper.prototype._importFormField = function (page, pdfForm, newPage, crossReference) {
        var form = this._destinationDocument.form;
        var array = [];
        if (newPage && newPage._pageDictionary && newPage._pageDictionary.has('Annots')) {
            array = newPage._pageDictionary.get('Annots');
        }
        var kidsArray = [];
        var widgetArray = [];
        if (this._destinationDocument.form._dictionary.has('Fields')) {
            var formFields = this._destinationDocument.form;
            this._fieldCount = formFields.count;
            for (var k = 0; k < this._fieldCount; k++) {
                var name_2 = formFields.fieldAt(k).name;
                this._fieldNames.push(name_2);
            }
        }
        if (page._pageDictionary.has('Annots')) {
            widgetArray = page._pageDictionary.get('Annots');
        }
        var count = pdfForm.count;
        for (var i = 0; i < count; ++i) {
            var pdfField = pdfForm.fieldAt(i);
            if (pdfField._dictionary.has('Kids')) {
                kidsArray = pdfField._dictionary.get('Kids');
                if (kidsArray.length > 1) {
                    for (var j = 0; j < kidsArray.length; j++) {
                        var fieldItem = pdfField.itemAt(j); // eslint-disable-line
                        if (fieldItem.page === page) {
                            array = this._insertFormFields(i, crossReference, pdfField, form, newPage._ref, array, widgetArray);
                            break;
                        }
                    }
                }
                else if (kidsArray.length === 1) {
                    if (pdfField.page === page) {
                        array = this._insertFormFields(i, crossReference, pdfField, form, newPage._ref, array, widgetArray);
                    }
                }
            }
            else {
                if (pdfField.page === page) {
                    array = this._insertFormFields(i, crossReference, pdfField, form, newPage._ref, array, widgetArray);
                }
            }
        }
        if (pdfForm._dictionary.has('DR')) {
            var dr = pdfForm._dictionary.get('DR');
            var drDictionary = this._copier._copyDictionary(dr); // eslint-disable-line
            var font = void 0; // eslint-disable-line
            if (drDictionary.has('Font')) {
                font = drDictionary.get('Font');
            }
            if (this._destinationDocument.form._dictionary.has('DR')) {
                var curreneDR = this._destinationDocument.form._dictionary.get('DR');
                if (curreneDR.has('Font')) {
                    var currentFont_1 = curreneDR.get('Font'); // eslint-disable-line
                    if (font) {
                        font.forEach(function (key, value) {
                            currentFont_1.set(key, value);
                        });
                    }
                    currentFont_1._updated = true;
                }
            }
            else {
                this._destinationDocument.form._dictionary.update('DR', drDictionary);
            }
        }
        if (array.length > 0) {
            newPage._pageDictionary.update('Annots', array);
        }
    };
    _PdfMergeHelper.prototype._insertFormFields = function (index, crossReference, pdfField, form, ref, array, kidsArray) {
        var dictionary = new _PdfDictionary();
        if (pdfField._dictionary.has('Kids')) {
            pdfField._dictionary.forEach(function (key, value) {
                if (key !== 'Kids') {
                    dictionary.update(key, value);
                }
            });
        }
        else {
            dictionary = this._copier._copyDictionary(pdfField._dictionary);
        }
        var newReference = this._crossReference._getNextReference();
        dictionary.objId = newReference.toString();
        var field = form._parseFields(dictionary, ref);
        this._crossReference._cacheMap.set(newReference, field._dictionary);
        if (pdfField._dictionary.has('Kids')) {
            var oldKids = pdfField._dictionary.get('Kids');
            var kids = [];
            for (var j = 0; j < oldKids.length; j++) {
                if ((kidsArray.indexOf(oldKids[Number.parseInt(j.toString(), 10)]) !== -1)) {
                    var oldDictionary = pdfField._crossReference._fetch(oldKids[Number.parseInt(j.toString(), 10)]);
                    var dict = this._copier._copyDictionary(oldDictionary);
                    dict.update('P', ref);
                    dict.update('Parent', newReference);
                    dict._updated = true;
                    var reference = this._crossReference._getNextReference();
                    this._crossReference._cacheMap.set(reference, dict);
                    array.push(reference);
                    kids.push(reference);
                }
            }
            dictionary.update('Kids', kids);
            field._kids = kids;
        }
        else {
            field._dictionary.update('P', ref);
            array.push(newReference);
        }
        field._dictionary._updated = true;
        var i = 0;
        var fieldName = field.name;
        var modified = false;
        while (this._fieldNames.indexOf(fieldName) !== -1) {
            fieldName = field.name + i;
            modified = true;
            ++i;
        }
        if (modified) {
            field._dictionary.update('T', fieldName);
            field._name = fieldName;
        }
        field._dictionary._updated = true;
        if (this._fieldCount > 0) {
            this._destinationDocument.form._parsedFields.set(this._fieldCount, field);
            field._annotationIndex = this._fieldCount;
            this._fieldCount++;
        }
        else {
            this._destinationDocument.form._parsedFields.set(index, field);
            field._annotationIndex = index;
        }
        this._destinationDocument.form._fields.push(newReference);
        return array;
    };
    _PdfMergeHelper.prototype._mergeFormFieldsWithDocument = function () {
        var pdfFields;
        if (this._formFieldsCollection.size > 0) {
            pdfFields = this._destinationDocument.form._dictionary.get('Fields');
            this._formFieldsCollection.forEach(function (value, key) {
                pdfFields[Number.parseInt(key.toString(), 10)] = value;
            });
        }
        else {
            pdfFields = this._destinationDocument.form._fields;
        }
        if (this._destinationDocument.form._dictionary.get('NeedAppearances')) {
            this._destinationDocument.form._dictionary.set('NeedAppearances', false);
        }
        this._destinationDocument.form._dictionary.set('Fields', pdfFields);
        this._destinationDocument.form._fields = pdfFields;
        this._destinationDocument.form._dictionary._updated = true;
    };
    _PdfMergeHelper.prototype._importLayers = function (ocProperties, layers) {
        this._isLayersPresent = layers;
        if (this._isLayersPresent && this._destinationDocument._catalog._catalogDictionary.has('OCProperties')) {
            var destinationOCProperties = this._destinationDocument._catalog._catalogDictionary.get('OCProperties');
            var currentOCProperties = ocProperties.get('OCProperties');
            if (destinationOCProperties.has('OCGs')) {
                var ocgs = destinationOCProperties.get('OCGs'); // eslint-disable-line
                var Cocgs = currentOCProperties.get('OCGs'); // eslint-disable-line
                if (ocgs.length > 0) {
                    for (var i = 0; i < Cocgs.length; i++) {
                        ocgs.push(Cocgs[Number.parseInt(i.toString(), 10)]);
                    }
                }
            }
            destinationOCProperties._updated = true;
            if (destinationOCProperties.has('D') && currentOCProperties.has('D')) {
                var curreneDefaultView = destinationOCProperties.get('D');
                var existingDefaultView = currentOCProperties.get('D');
                if (curreneDefaultView && existingDefaultView) {
                    if (curreneDefaultView.has('Order') && existingDefaultView.has('Order')) {
                        var order = curreneDefaultView.get('Order'); // eslint-disable-line
                        var existingOrder = existingDefaultView.get('Order'); // eslint-disable-line
                        if (order.length > 0 && existingOrder.length > 0) {
                            for (var i = 0; i < existingOrder.length; i++) {
                                order.push(existingOrder[Number.parseInt(i.toString(), 10)]);
                            }
                        }
                    }
                    else if (existingDefaultView.has('Order')) {
                        curreneDefaultView.set('Order', existingDefaultView.get('Order'));
                    }
                    if (curreneDefaultView.has('RBGroups') && existingDefaultView.has('RBGroups')) {
                        var groups = curreneDefaultView.get('RBGroups'); // eslint-disable-line
                        var existingRBGroups = existingDefaultView.get('RBGroups'); // eslint-disable-line
                        if (groups.length > 0 && existingRBGroups.length > 0) {
                            for (var i = 0; i < existingRBGroups.length; i++) {
                                groups.push(existingRBGroups[Number.parseInt(i.toString(), 10)]);
                            }
                        }
                    }
                    else if (existingDefaultView.has('RBGroups')) {
                        curreneDefaultView.set('RBGroups', existingDefaultView.get('RBGroups'));
                        curreneDefaultView._updated = true;
                    }
                    if (curreneDefaultView.has('ON') && existingDefaultView.has('ON')) {
                        var on = curreneDefaultView.get('ON'); // eslint-disable-line
                        var existingON = existingDefaultView.get('ON'); // eslint-disable-line
                        if (on.length > 0 && existingON.length > 0) {
                            for (var i = 0; i < existingON.length; i++) {
                                on.push(existingON[Number.parseInt(i.toString(), 10)]);
                            }
                        }
                    }
                    else if (existingDefaultView.has('ON')) {
                        curreneDefaultView.set('ON', existingDefaultView.get('ON'));
                    }
                    if (curreneDefaultView.has('AS') && existingDefaultView.has('AS')) {
                        var elements = curreneDefaultView.get('AS'); // eslint-disable-line
                        var existingElements = existingDefaultView.get('AS'); // eslint-disable-line
                        if (elements.length > 0 && existingElements.length > 0) {
                            var asDictionary = existingElements[0];
                            var currentASDictionary = elements[0];
                            if (asDictionary instanceof _PdfReference && currentASDictionary instanceof _PdfReference) {
                                asDictionary = this._crossReference._fetch(asDictionary);
                                currentASDictionary = this._crossReference._fetch(currentASDictionary);
                            }
                            if (asDictionary.has('OCGs') && currentASDictionary.has('OCGs')) {
                                var usageGroup = asDictionary.get('OCGs'); // eslint-disable-line
                                var currentUsageGroup = currentASDictionary.get('OCGs'); // eslint-disable-line
                                if (usageGroup.length > 0 && currentUsageGroup.length > 0) {
                                    for (var i = 0; i < usageGroup.length; i++) {
                                        currentUsageGroup.push(usageGroup[Number.parseInt(i.toString(), 10)]);
                                    }
                                }
                            }
                            for (var i = 0; i < existingElements.length; i++) {
                                elements.push(existingElements[Number.parseInt(i.toString(), 10)]);
                            }
                        }
                    }
                    else if (existingDefaultView.has('AS')) {
                        curreneDefaultView.set('AS', existingDefaultView.get('AS'));
                    }
                    if (curreneDefaultView.has('OFF') && existingDefaultView.has('OFF')) {
                        var off = curreneDefaultView.get('OFF'); // eslint-disable-line
                        var existingOff = existingDefaultView.get('OFF'); // eslint-disable-line
                        if (off.length > 0 && existingOff.length > 0) {
                            for (var i = 0; i < existingOff.length; i++) {
                                off.push(existingOff[Number.parseInt(i.toString(), 10)]);
                            }
                        }
                    }
                    else if (existingDefaultView.has('OFF')) {
                        curreneDefaultView.set('OFF', existingDefaultView.get('OFF'));
                    }
                }
                if (curreneDefaultView.has('Locked') && existingDefaultView.has('Locked')) {
                    var locked = curreneDefaultView.get('Locked'); // eslint-disable-line
                    var existingLocked = existingDefaultView.get('Locked'); // eslint-disable-line
                    if (locked.length > 0 && existingLocked.length > 0) {
                        for (var i = 0; i < existingLocked.length; i++) {
                            locked.push(existingLocked[Number.parseInt(i.toString(), 10)]);
                        }
                    }
                }
                else if (existingDefaultView.has('Locked')) {
                    curreneDefaultView.set('Locked', existingDefaultView.get('Locked'));
                }
            }
            else if (currentOCProperties.has('D')) {
                destinationOCProperties.set('D', currentOCProperties.get('D'));
            }
            destinationOCProperties._updated = true;
            this._destinationDocument._catalog._catalogDictionary._updated = true;
            this._crossReference._allowCatalog = true;
        }
        else if (this._isLayersPresent) {
            this._destinationDocument._catalog._catalogDictionary.update('OCProperties', ocProperties.get('OCProperties'));
            this._destinationDocument._catalog._catalogDictionary._updated = true;
            this._crossReference._allowCatalog = true;
        }
    };
    _PdfMergeHelper.prototype._mergeLayer = function (newPageDictionary, oldPageDictionary, crossReference) {
        var _this = this;
        var res = newPageDictionary.get('Resources');
        var xobject = res.get('XObject');
        var xobjdict; // eslint-disable-line
        if (xobject) {
            xobject.forEach(function (key, value) {
                xobjdict = _this._crossReference._fetch(value);
            });
        }
        var resource;
        if (xobjdict) {
            resource = xobjdict.dictionary.get('Resources');
        }
        var XObject; // eslint-disable-line
        var oldPageList = new Map();
        var oldPageResource = oldPageDictionary.get('Resources');
        var layerDictionary; // eslint-disable-line
        var dict; // eslint-disable-line
        if (oldPageResource.has('Properties')) {
            layerDictionary = oldPageResource.get('Properties');
            layerDictionary.forEach(function (key, value) {
                oldPageList.set(key, value);
            });
            var properties_1 = new _PdfDictionary(this._crossReference);
            oldPageList.forEach(function (value, key) {
                _this._newList.forEach(function (layerValue, layerkey) {
                    if (value === layerkey) {
                        properties_1.set(key, layerValue);
                    }
                });
            });
            resource.set('Properties', properties_1);
            resource._updated = true;
            properties_1._updated = true;
        }
        else if (oldPageResource.has('XObject')) {
            XObject = resource.get('XObject');
            layerDictionary = oldPageResource.get('XObject');
            layerDictionary.forEach(function (key, value) {
                if (value instanceof _PdfReference) {
                    dict = crossReference._fetch(value);
                    dict.dictionary.forEach(function (annotationKey, annotationValue) {
                        if (annotationKey === 'OC') {
                            _this._newList.forEach(function (layerValue, layerKey) {
                                if (layerKey === annotationValue) {
                                    if (XObject.has(key)) {
                                        var xobjDictionary = XObject.get(key); // eslint-disable-line
                                        xobjDictionary.dictionary.set(annotationKey, layerValue);
                                        xobjDictionary._updated = true;
                                    }
                                }
                            });
                        }
                    });
                }
            });
        }
        if (this._annotationLayer.size > 0) {
            var annotations_1 = newPageDictionary._get('Annots'); // eslint-disable-line
            this._annotationLayer.forEach(function (reference, index) {
                var pdfAnnotation = annotations_1[Number.parseInt(index.toString(), 10)]; // eslint-disable-line
                var annotDictionary = _this._crossReference._fetch(pdfAnnotation);
                _this._newList.forEach(function (value, oldReference) {
                    if (reference === oldReference) {
                        annotDictionary.set('OC', value);
                    }
                });
            });
        }
    };
    _PdfMergeHelper.prototype._exportBookmarks = function (document, pageCount) {
        var _this = this;
        if (this._bookmarks.length > 0) {
            var bookmark = this._bookmarks;
            var currentBase = this._destinationDocument.bookmarks;
            var current = document.bookmarks;
            var bkCollection = void 0; // eslint-disable-line
            if (current) {
                var stack = [];
                var nodeInformation = { index: 0, base: currentBase, kids: current._bookMarkList };
                if (document.pageCount !== pageCount) {
                    nodeInformation = { index: 0, base: currentBase, kids: bookmark };
                    bkCollection = [];
                }
                do {
                    var _loop_1 = function () {
                        current = nodeInformation.kids[nodeInformation.index];
                        if (bookmark.indexOf(current) !== -1 && typeof bkCollection !== 'undefined' && bkCollection.indexOf(current.title) === -1) {
                            var bm = current;
                            var newBm = currentBase.add(bm.title);
                            var dest = bm.destination;
                            newBm.color = bm.color;
                            newBm.textStyle = bm.textStyle;
                            var newDest = null;
                            var newPage_1 = null;
                            var page_1 = null;
                            var nDest = bm.namedDestination;
                            if (nDest) {
                                if (nDest.destination) {
                                    page_1 = nDest.destination.page;
                                    this_1._bookmarksPageLinkReference.forEach(function (value, key) {
                                        if (page_1._ref === key) {
                                            newPage_1 = _this._destinationDocument.getPage(value);
                                        }
                                    });
                                    if (newPage_1) {
                                        var newNameddest = this_1._getNamedDestination(nDest, newPage_1);
                                        newBm.namedDestination = newNameddest;
                                        delete newBm._dictionary._map.C;
                                        this_1._namedDestinations.push(newNameddest._title);
                                        var reference_1 = this_1._crossReference._getNextReference();
                                        this_1._crossReference._cacheMap.set(reference_1, newNameddest._dictionary);
                                        this_1._namedDestinations.push(reference_1);
                                    }
                                }
                            }
                            else if (dest) {
                                page_1 = dest.page;
                                this_1._bookmarksPageLinkReference.forEach(function (value, key) {
                                    if (page_1._ref === key) {
                                        newPage_1 = _this._destinationDocument.getPage(value);
                                    }
                                });
                                if (newPage_1) {
                                    newDest = new PdfDestination(newPage_1, dest.location);
                                    newDest.mode = dest.mode;
                                    newDest.zoom = dest.zoom;
                                    newDest.location = dest.location;
                                    newBm.destination = newDest;
                                }
                            }
                            currentBase = newBm;
                            bkCollection.push(newBm.title);
                        }
                        else if (typeof bkCollection === 'undefined' || (typeof bkCollection !== 'undefined' && bkCollection.indexOf(current.title) === -1)) {
                            var bm = current;
                            var dest = bm.destination;
                            var newDest = null;
                            var newpage_1 = null;
                            var page_2 = null;
                            var nDest = bm.namedDestination;
                            if (document.pageCount === pageCount) {
                                var newBm = currentBase.add(bm.title);
                                if (bm._dictionary.has('A')) {
                                    newBm._dictionary.update('A', bm._dictionary.get('A'));
                                }
                                newBm.textStyle = bm.textStyle;
                                newBm.color = bm.color;
                                if (nDest) {
                                    if (nDest._destination) {
                                        page_2 = nDest.destination.page;
                                        this_1._bookmarksPageLinkReference.forEach(function (value, key) {
                                            if (page_2._ref === key) {
                                                newpage_1 = _this._destinationDocument.getPage(value);
                                            }
                                        });
                                        if (newpage_1) {
                                            var newNameddest = this_1._getNamedDestination(nDest, newpage_1);
                                            newBm.namedDestination = newNameddest;
                                            delete newBm._dictionary._map.C;
                                            this_1._namedDestinations.push(newNameddest._title);
                                            var reference_2 = this_1._crossReference._getNextReference();
                                            this_1._crossReference._cacheMap.set(reference_2, newNameddest._dictionary);
                                            this_1._namedDestinations.push(reference_2);
                                        }
                                    }
                                }
                                else if (dest) {
                                    page_2 = dest.page;
                                    this_1._bookmarksPageLinkReference.forEach(function (value, key) {
                                        if (page_2._ref === key) {
                                            newpage_1 = _this._destinationDocument.getPage(value);
                                        }
                                    });
                                    if (newpage_1) {
                                        newDest = new PdfDestination(newpage_1, dest.location);
                                        newDest.mode = dest.mode;
                                        newDest.zoom = dest.zoom;
                                        newDest.location = dest.location;
                                        newBm.destination = newDest;
                                    }
                                }
                                currentBase = newBm;
                            }
                        }
                        nodeInformation.index += 1;
                        if (current.count > 0) {
                            stack.push(nodeInformation);
                            nodeInformation = { index: 0, base: currentBase, kids: current._bookMarkList };
                        }
                        else {
                            currentBase = nodeInformation.base;
                        }
                    };
                    var this_1 = this;
                    for (; nodeInformation.index < nodeInformation.kids.length;) {
                        _loop_1();
                    }
                    if (stack.length > 0) {
                        nodeInformation = stack.pop();
                        while ((nodeInformation.index === nodeInformation.kids.length) && (stack.length > 0)) {
                            nodeInformation = stack.pop();
                        }
                        currentBase = nodeInformation.base;
                    }
                } while (nodeInformation.index < nodeInformation.kids.length);
            }
            var reference = void 0;
            if (this._namedDestinations.length > 0) {
                var dictionary = new _PdfDictionary(this._crossReference);
                dictionary.update('Names', this._namedDestinations);
                reference = this._crossReference._getNextReference();
                this._crossReference._cacheMap.set(reference, dictionary);
                dictionary = new _PdfDictionary(this._crossReference);
                dictionary.update('Dests', reference);
                reference = this._crossReference._getNextReference();
                this._crossReference._cacheMap.set(reference, dictionary);
                this._destinationDocument._catalog._catalogDictionary.set('Names', reference);
            }
            this._destinationDocument._catalog._catalogDictionary._updated = true;
            this._destinationDocument._catalog._catalogDictionary.isCatalog = true;
            this._crossReference._allowCatalog = true;
        }
    };
    _PdfMergeHelper.prototype._getNamedDestination = function (nDest, page) {
        var newNamedDest = new PdfNamedDestination(nDest.title); // eslint-disable-line
        newNamedDest.destination = this._getDestination(page, nDest.destination);
        return newNamedDest;
    };
    _PdfMergeHelper.prototype._getDestination = function (page, dest) {
        var newDest = new PdfDestination(page, dest.location);
        newDest._location = dest._location;
        newDest.mode = dest.mode;
        newDest.zoom = dest.zoom;
        newDest.location = dest.location;
        return newDest;
    };
    _PdfMergeHelper.prototype._writeObject = function (document, table, value, dictionary, key, array, ref) {
        if (value instanceof _PdfName || typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
            this._writeDictionary(value, table, key, array, ref, null);
        }
        else if (Array.isArray(value)) {
            var list = []; // eslint-disable-line
            this._writeArray(document, list, value, dictionary);
            this._writeDictionary(null, table, key, array, ref, list);
        }
        else if (value instanceof _PdfDictionary) {
            var subTable = new _PdfDictionary(this._crossReference);
            this._writePropertiesDictionary(document, subTable, value);
            this._writeDictionary(null, table, key, array, ref, subTable);
        }
        else if (value instanceof _PdfReference && this._crossReference) {
            this._writeObject(document, table, document._crossReference._fetch(value), dictionary, key, array, value);
        }
        else if (value === null || typeof value === 'undefined') {
            this._writeDictionary('null', table, key, array, ref, null);
        }
    };
    _PdfMergeHelper.prototype._writeDictionary = function (value, table, key, array, ref, list) {
        if (key && value) {
            table.set(key, value);
        }
        else if (key && list) {
            table.set(key, list);
        }
        else if (list && !ref) {
            array.push(list);
        }
        else if (value) {
            array.push(value);
        }
        else if (ref) {
            var reference_3;
            if (this._newList && this._newList.size > 0) {
                this._newList.forEach(function (value, key) {
                    if (key === ref) {
                        reference_3 = value;
                    }
                });
            }
            if (reference_3) {
                array.push(reference_3);
            }
            else {
                var layerList = list;
                reference_3 = this._crossReference._getNextReference();
                this._crossReference._cacheMap.set(reference_3, layerList);
                layerList._updated = true;
                array.push(reference_3);
                this._newList.set(ref, reference_3);
            }
        }
    };
    _PdfMergeHelper.prototype._writeArray = function (document, array, value, dictionary) {
        for (var i = 0; i < value.length; i++) {
            this._writeObject(document, null, value[Number.parseInt(i.toString(), 10)], dictionary, null, array);
        }
    };
    _PdfMergeHelper.prototype._writePropertiesDictionary = function (document, table, dictionary) {
        var _this = this;
        if (dictionary && dictionary.size > 0) {
            dictionary.forEach(function (key, value) {
                _this._writeObject(document, table, ((value instanceof _PdfReference) ? dictionary.get(key) : value), dictionary, key);
            });
        }
    };
    _PdfMergeHelper.prototype._fixDestinations = function (document) {
        var pageLinkReference = this._pageReference;
        if (this._destination.length > 0) {
            for (var i = 0; i < this._destination.length; i++) {
                var dest = this._destination[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                if (dest instanceof Array) {
                    var destination = dest; // eslint-disable-line
                    if (destination.length > 0 && destination[0] && destination[0] instanceof _PdfReference) {
                        var ref = document._crossReference._fetch(destination[0]); // eslint-disable-line
                        var index = pageLinkReference.get(ref);
                        if (ref && pageLinkReference.has(ref) && index !== null) {
                            destination[0] = index._ref;
                        }
                        if (ref && pageLinkReference.has(ref) && index === null) {
                            destination[0] = null;
                        }
                    }
                }
            }
        }
    };
    _PdfMergeHelper.prototype._insertNewPage = function (page, index) {
        var newPage;
        var pagesettings = new PdfPageSettings();
        pagesettings.size = page.size;
        pagesettings.margins.left = 0;
        pagesettings.margins.top = 0;
        pagesettings.margins.right = 0;
        pagesettings.margins.bottom = 0;
        if (typeof this._options !== 'undefined' && typeof this._options.rotation !== 'undefined') {
            pagesettings.rotation = this._options.rotation;
        }
        else {
            pagesettings.rotation = page.rotation;
        }
        pagesettings.orientation = (page.size[0] > page.size[1]) ? PdfPageOrientation.landscape : PdfPageOrientation.portrait;
        if (typeof index !== 'undefined') {
            newPage = this._destinationDocument.addPage(index, pagesettings);
        }
        else {
            newPage = this._destinationDocument.addPage(pagesettings);
        }
        var pageDictionary = page._pageDictionary;
        if (pageDictionary._get('MediaBox')) {
            var mBox = pageDictionary._get('MediaBox'); // eslint-disable-line
            newPage._pageDictionary.update('MediaBox', mBox);
        }
        if (pageDictionary._get('CropBox')) {
            var cBox = pageDictionary._get('CropBox'); // eslint-disable-line
            newPage._pageDictionary.update('CropBox', cBox);
        }
        if (typeof this._options.rotation !== 'undefined' || page._pageDictionary.has('Rotate')) {
            var rotate = void 0;
            if (typeof this._options.rotation !== 'undefined') {
                rotate = Math.floor(this._options.rotation) * 90;
            }
            else {
                rotate = Math.floor(page.rotation) * 90;
            }
            rotate = rotate >= 360 ? rotate % 360 : rotate;
            newPage._pageDictionary.update('Rotate', rotate);
        }
        return newPage;
    };
    _PdfMergeHelper.prototype._objectDispose = function () {
        this._bookmarkHashTable = new Map();
        this._namedDestinations = [];
        this._bookmarks = [];
        this._pageReference = new Map();
        this._bookmarksPageLinkReference.clear();
        this._destination = [];
        this._newList = new Map();
        this._annotationLayer = new Map();
        this._fieldNames = [];
        if (this._destinationDocument && this._destinationDocument._form && this._destinationDocument._form._widgetReferences) {
            this._destinationDocument._form._widgetReferences = [];
        }
    };
    return _PdfMergeHelper;
}());
var _PdfCopier = /** @class */ (function () {
    function _PdfCopier(targetCrossReference, sourceCrossReference) {
        this._traversedObjects = new Map();
        this._isGroupingSupport = false;
        this._targetCrossReference = targetCrossReference;
        this._sourceCrossReference = sourceCrossReference;
    }
    _PdfCopier.prototype._copy = function (object) {
        var clonedObject; // eslint-disable-line
        if (object instanceof _PdfDictionary) {
            clonedObject = this._copyDictionary(object);
        }
        else if (Array.isArray(object)) {
            clonedObject = this._copyArray(object);
        }
        else if (object instanceof _PdfBaseStream) {
            clonedObject = this._copyStream(object);
        }
        else if (object instanceof _PdfReference) {
            clonedObject = this._copyReference(object);
        }
        else if (object instanceof _PdfName || typeof object === 'number' ||
            typeof object === 'string' || typeof object === 'boolean') {
            clonedObject = object;
        }
        return clonedObject;
    };
    _PdfCopier.prototype._copyDictionary = function (element, copiedPage) {
        var _this = this;
        var clonedDictionary = new _PdfDictionary(this._targetCrossReference);
        if (element && element.size > 0) {
            element.forEach(function (key, value) {
                if (key === 'OC' && value instanceof Array || (key !== 'P' && key !== 'Parent' && key !== 'Dest' && key !== 'OC' && !(key === 'AP' && copiedPage))) {
                    var copiedValue = _this._copy(value); // eslint-disable-line
                    if (copiedValue !== null && typeof copiedValue !== 'undefined') {
                        clonedDictionary.update(key, copiedValue);
                    }
                }
            });
        }
        clonedDictionary._updated = true;
        return clonedDictionary;
    };
    _PdfCopier.prototype._copyArray = function (originalArray) {
        var newArray = []; // eslint-disable-line 
        for (var i = 0; i < originalArray.length; i++) {
            newArray.push(this._copy(originalArray[Number.parseInt(i.toString(), 10)]));
        }
        return newArray;
    };
    _PdfCopier.prototype._copyStream = function (originalStream) {
        var bytes;
        var imageStream = false;
        var baseStream = originalStream; // eslint-disable-line
        if (originalStream.dictionary.has('Subtype') && originalStream.dictionary.get('Subtype').name === 'Image') {
            imageStream = true;
            if (originalStream instanceof _PdfStream) {
                bytes = originalStream.getByteRange(originalStream.offset, originalStream.end);
            }
            else if (originalStream && baseStream.stream && baseStream.stream instanceof _PdfStream) {
                if (typeof baseStream._initialized === 'boolean' && baseStream._cipher) {
                    var streamLength = baseStream.stream.end - baseStream.stream.start;
                    baseStream.getBytes(streamLength);
                    bytes = baseStream.buffer.subarray(0, baseStream.bufferLength);
                }
                else {
                    var stream = baseStream.stream;
                    bytes = stream.getByteRange(stream.start, stream.end);
                }
            }
            else if (baseStream.stream && baseStream.stream.stream) {
                var flateStream = baseStream.stream; // eslint-disable-line
                if (flateStream.stream instanceof _PdfStream && typeof flateStream._initialized === 'boolean' && flateStream._cipher) {
                    var streamLength = flateStream.stream.end - flateStream.stream.start;
                    flateStream.getBytes(streamLength);
                    bytes = flateStream.buffer.subarray(0, flateStream.bufferLength);
                }
                else if (flateStream.stream && flateStream.stream instanceof _PdfStream) {
                    var stream = flateStream.stream;
                    bytes = stream.getByteRange(stream.start, stream.end);
                }
                else {
                    bytes = [];
                }
            }
            else {
                bytes = originalStream.getBytes();
                if ((!bytes || bytes.length === 0) && originalStream instanceof _PdfContentStream) {
                    bytes = originalStream._bytes;
                }
            }
        }
        else {
            bytes = originalStream.getBytes();
            if ((!bytes || bytes.length === 0) && originalStream instanceof _PdfContentStream) {
                bytes = originalStream._bytes;
            }
        }
        var content = new _PdfContentStream(Array.from(bytes));
        content._isImage = imageStream;
        content.dictionary = this._copyDictionary(originalStream.dictionary);
        content.dictionary._updated = true;
        return content;
    };
    _PdfCopier.prototype._copyReference = function (element) {
        if (this._traversedObjects.has(element)) {
            return this._traversedObjects.get(element);
        }
        else {
            this._traversedObjects.set(element, null);
            var dereferencedValue = this._sourceCrossReference._fetch(element); // eslint-disable-line
            var copyValue = this._copy(dereferencedValue); // eslint-disable-line
            if (copyValue instanceof _PdfDictionary || copyValue instanceof _PdfBaseStream) {
                var newRef = this._addToDestination(copyValue);
                this._traversedObjects.set(element, newRef);
                return newRef;
            }
            else {
                this._traversedObjects.set(element, copyValue);
                return copyValue;
            }
        }
    };
    _PdfCopier.prototype._addToDestination = function (element) {
        var newRef = this._targetCrossReference._getNextReference();
        this._targetCrossReference._cacheMap.set(newRef, element);
        element.objId = newRef.objectNumber + " " + newRef.generationNumber;
        return newRef;
    };
    return _PdfCopier;
}());

/**
 * Represents the base class for layer objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access the collection of layers in the document
 * let layers: PdfLayerCollection = document.layers;
 * // Retrieve the first layer from the layers collection
 * let layer: PdfLayer = layers.at(0);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfLayer = /** @class */ (function () {
    /**
     * Initializes a new instance of the `PdfLayer` class.
     *
     * @private
     */
    function PdfLayer() {
        this._visible = true;
        this._printState = PdfPrintState.printWhenVisible;
        this._isEndState = false;
        this._dictionary = new _PdfDictionary();
        this._pages = [];
        this._subLayer = [];
        this._locked = false;
        this._parentLayer = [];
        this._child = [];
        this._graphicsCollection = new Map();
        this._pageGraphics = new Map();
        this._pageParsed = false;
        this._xObject = [];
        this._content = new _PdfContentStream([]);
    }
    Object.defineProperty(PdfLayer.prototype, "_layerPage", {
        get: function () {
            if (!this._pageParsed) {
                this._parseLayerPage();
            }
            return this._page;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLayer.prototype, "_layerId", {
        get: function () {
            if (!this._pageParsed) {
                this._parseLayerPage();
            }
            return this._id;
        },
        set: function (value) {
            this._id = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLayer.prototype, "name", {
        /**
         * Gets the name of the layer.
         *
         * @returns {string} Name of the layer.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the collection of layers in the document
         * let layers: PdfLayerCollection = document.layers;
         * // Retrieve the first layer from the layers collection
         * let layer: PdfLayer = layers.at(0);
         * // Retrieve the name of the layer
         * let name: string = layer.name;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._name || '';
        },
        /**
         * Sets the name of the layer.
         *
         * @param {string} name Name of the layer.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the collection of layers in the document
         * let layers: PdfLayerCollection = document.layers;
         * // Retrieve the first layer from the layers collection
         * let layer: PdfLayer = layers.at(0);
         * // Change the name of the layer
         * layer.name = 'Layer2';
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (name) {
            this._name = name;
            if (this._dictionary && this._name && this.name !== '') {
                this._dictionary.update('Name', this._name);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLayer.prototype, "visible", {
        /**
         * Gets the visibility of the layer.
         *
         * @returns {boolean} Boolean indicating whether the specified layer is visible or not.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the collection of layers in the document
         * let layers: PdfLayerCollection = document.layers;
         * // Retrieve the first layer from the layers collection
         * let layer: PdfLayer = layers.at(0);
         * // Get the visibility state of the layer
         * let isVisible: boolean = layer.visible;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary) {
                var visibility = this._dictionary.get('Visible');
                if (typeof visibility === 'boolean') {
                    this._visible = visibility;
                }
            }
            return this._visible;
        },
        /**
         * Sets the visibility of the layer.
         *
         * @param {boolean} isVisible Boolean indicating whether the specified layer is visible or not.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the collection of layers in the document
         * let layers: PdfLayerCollection = document.layers;
         * // Retrieve the first layer from the layers collection
         * let layer: PdfLayer = layers.at(0);
         * // Set the layer visibility to true
         * layer.visible = true;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (isVisible) {
            this._visible = isVisible;
            if (this._dictionary) {
                this._dictionary.update('Visible', isVisible);
            }
            this._setVisibility(isVisible);
            this._document._catalog._catalogDictionary._updated = true;
            this._crossReference._allowCatalog = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLayer.prototype, "locked", {
        /**
         * Gets the boolean indicating whether the layer is locked or not.
         *
         * @returns {boolean} Boolean indicating whether the layer is locked or not.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the collection of layers in the document
         * let layers: PdfLayerCollection = document.layers;
         * // Retrieve the first layer from the layers collection
         * let layer: PdfLayer = layers.at(0);
         * // Retrieve the lock status of the layer
         * let isLocked: boolean = layer.locked;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._locked;
        },
        /**
         * Sets the boolean indicating whether the layer is locked or not.
         *
         * @param {boolean} isLocked Boolean indicating whether the layer is locked or not.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the collection of layers in the document
         * let layers: PdfLayerCollection = document.layers;
         * // Retrieve the first layer from the layers collection
         * let layer: PdfLayer = layers.at(0);
         * // Lock the layer to prevent modifications
         * layer.locked = true;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (isLocked) {
            this._locked = isLocked;
            if (typeof isLocked === 'boolean') {
                this._setLock(isLocked);
            }
            this._document._catalog._catalogDictionary._updated = true;
            this._crossReference._allowCatalog = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLayer.prototype, "printState", {
        /**
         * Gets the print state of the layer.
         *
         * @returns {PdfPrintState} Print state.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the collection of layers in the document
         * let layers: PdfLayerCollection = document.layers;
         * // Retrieve the first layer from the layers collection
         * let layer: PdfLayer = layers.at(0);
         * // Retrieve the printState of the layer
         * let printState: PdfPrintState = layer.printState;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._printState;
        },
        /**
         * Sets the print state of the layer.
         *
         * @param {PdfPrintState} printState Print state.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the collection of layers in the document
         * let layers: PdfLayerCollection = document.layers;
         * // Retrieve the first layer from the layers collection
         * let layer: PdfLayer = layers.at(0);
         * // Set the print state to 'alwaysPrint' to ensure this layer is printed
         * layer.printState = PdfPrintState.alwaysPrint;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (printState) {
            this._printState = printState;
            if (this._printOption) {
                if (this.printState === PdfPrintState.alwaysPrint) {
                    this._printOption.update('PrintState', new _PdfName('ON'));
                }
                else if (this.printState === PdfPrintState.neverPrint) {
                    this._printOption.update('PrintState', new _PdfName('OFF'));
                }
            }
            else {
                this._setPrintState();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLayer.prototype, "layers", {
        /**
         * Gets the collection of `PdfLayer` from the layer.
         *
         * @returns {PdfLayerCollection} Layer collection.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the collection of layers in the document
         * let layers: PdfLayerCollection = document.layers;
         * // Retrieve the first layer from the layers collection
         * let layer: PdfLayer = layers.at(0);
         * // Access the collection of layers in the layer (parent layer)
         * let childLayers: PdfLayerCollection = layer.layers;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._layers) {
                this._layers = new PdfLayerCollection(this._document, this._layer);
                this._layers._subLayer = true;
            }
            return this._layers;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initializes graphics context of the layer.
     *
     * @param {PdfPage} page The PDF page.
     * @returns {PdfGraphics} Graphics of the layer content.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access the collection of layers in the document
     * let layers: PdfLayerCollection = document.layers;
     * // Add a new layer to the document with the name 'Layer1'
     * let layer: PdfLayer = layers.add('Layer1');
     * // Create graphics for the newly added layer on the specified page
     * let graphics: PdfGraphics = layer.createGraphics(page);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfLayer.prototype.createGraphics = function (page) {
        if (!this._graphics || this._needInitializeGraphics) {
            this._page = page;
            this._crossReference = page._crossReference;
            this._parseGraphics();
        }
        return this._graphics;
    };
    PdfLayer.prototype._parseGraphics = function () {
        this._loadContents();
        var saveStream = new _PdfContentStream([32, 113, 32, 10]);
        var saveReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(saveReference, saveStream);
        this._page._contents.splice(0, 0, saveReference);
        var restoreStream = new _PdfContentStream([32, 81, 32, 10]);
        var restoreReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(restoreReference, restoreStream);
        this._page._contents.push(restoreReference);
        var contentStream = new _PdfContentStream([]);
        var contentReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(contentReference, contentStream);
        this._page._contents.push(contentReference);
        this._page._pageDictionary.set('Contents', this._page._contents);
        this._page._pageDictionary._updated = true;
        this._initializeGraphics(contentStream);
        this._initializeProperties();
    };
    PdfLayer.prototype._initializeProperties = function () {
        var resource = this._graphics._resourceObject;
        if (resource && resource.has('Properties')) {
            var properties = resource.get('Properties');
            if (properties) {
                properties.update(this._id, this._referenceHolder);
            }
            else {
                var properties_1 = new _PdfDictionary();
                properties_1.update(this._id, this._referenceHolder);
                resource.update('Properties', properties_1);
            }
        }
        else {
            var properties = new _PdfDictionary();
            properties.update(this._id, this._referenceHolder);
            resource.update('Properties', properties);
        }
    };
    PdfLayer.prototype._loadContents = function () {
        var contents = this._page._pageDictionary.getRaw('Contents');
        var ref;
        if (contents && contents && contents instanceof _PdfReference) {
            ref = contents;
            contents = this._crossReference._fetch(ref);
        }
        if (contents && contents instanceof _PdfBaseStream) {
            this._page._contents = [ref];
        }
        else if (contents && Array.isArray(contents)) {
            this._page._contents = contents;
        }
        else {
            this._page._contents = [];
        }
    };
    PdfLayer.prototype._initializeGraphics = function (stream) {
        var isInvalidCase = false;
        var llx = 0;
        var lly = 0;
        var urx = 0;
        var ury = 0;
        var size = this._page.size;
        var mbox = this._page.mediaBox;
        if (mbox && mbox.length >= 4) {
            llx = mbox[0];
            lly = mbox[1];
            urx = mbox[2];
            ury = mbox[3];
        }
        var cbox;
        if (this._page._pageDictionary.has('CropBox')) {
            cbox = this._page.cropBox;
            if (cbox && cbox.length >= 4) {
                var cx = cbox[0];
                var cy = cbox[1];
                var crx = cbox[2];
                var cry = cbox[3];
                var isValid = (cx < 0 || cy < 0 || crx < 0 || cry < 0) &&
                    (Math.floor(Math.abs(cy)) === Math.floor(Math.abs(size[1]))) &&
                    (Math.floor(Math.abs(cx)) === Math.floor(Math.abs(size[0])));
                if (isValid) {
                    this._graphics = new PdfGraphics([Math.max(cx, crx), Math.max(cy, cry)], stream, this._crossReference, this._page);
                }
                else {
                    this._graphics = new PdfGraphics(size, stream, this._crossReference, this._page);
                    this._graphics._cropBox = cbox;
                }
            }
            else {
                this._graphics = new PdfGraphics(size, stream, this._crossReference, this._page);
            }
        }
        else if ((llx < 0 || lly < 0 || urx < 0 || ury < 0) &&
            (Math.floor(Math.abs(lly)) === Math.floor(Math.abs(size[1]))) &&
            (Math.floor(Math.abs(urx)) === Math.floor(Math.abs(size[0])))) {
            var width = Math.max(llx, urx);
            var height = Math.max(lly, ury);
            if (width <= 0 || height <= 0) {
                isInvalidCase = true;
                if (llx < 0) {
                    llx = -llx;
                }
                if (lly < 0) {
                    lly = -lly;
                }
                if (urx < 0) {
                    urx = -urx;
                }
                if (ury < 0) {
                    ury = -ury;
                }
                width = Math.max(llx, urx);
                height = Math.max(lly, ury);
            }
            this._graphics = new PdfGraphics([width, height], stream, this._crossReference, this._page);
        }
        else {
            this._graphics = new PdfGraphics(size, stream, this._crossReference, this._page);
        }
        if (this._page._pageDictionary.has('MediaBox')) {
            this._graphics._mediaBoxUpperRightBound = isInvalidCase ? -lly : ury;
        }
        this._graphicsState = this._graphics.save();
        var origin = this._page._origin;
        if ((origin[0] >= 0 && origin[1] >= 0) || Math.sign(origin[0]) !== Math.sign(origin[1])) {
            this._graphics._initializeCoordinates();
        }
        else {
            this._graphics._initializeCoordinates(this._page);
        }
        //Need to code - set transparency group
        if (!this._page._isNew) {
            var rotation = this._page.rotation;
            if (!Number.isNaN(rotation) && (rotation !== PdfRotationAngle.angle0 || this._page._pageDictionary.has('Rotate'))) {
                var rotate = void 0;
                if (this._page._pageDictionary.has('Rotate')) {
                    rotate = this._page._pageDictionary.get('Rotate');
                }
                else {
                    rotate = rotation * 90;
                }
                var clip = this._graphics._clipBounds;
                if (rotate === 90) {
                    this._graphics.translateTransform(0, size[1]);
                    this._graphics.rotateTransform(-90);
                    this._graphics._clipBounds = [clip[0], clip[1], size[0], size[1]];
                }
                else if (rotate === 180) {
                    this._graphics.translateTransform(size[0], size[1]);
                    this._graphics.rotateTransform(-180);
                }
                else if (rotate === 270) {
                    this._graphics.translateTransform(size[0], 0);
                    this._graphics.rotateTransform(-270);
                    this._graphics._clipBounds = [clip[0], clip[1], size[1], size[0]];
                }
            }
        }
        if (this._page._isNew && this._page._pageSettings) {
            var clipBounds = this._page._getActualBounds(this._page._pageSettings);
            this._graphics._clipTranslateMargins(clipBounds);
        }
        this._needInitializeGraphics = false;
        if (!this._graphicsCollection.has(this._graphics)) {
            this._graphicsCollection.set(this._graphics, this._graphics);
        }
        if (!this._pageGraphics.has(this._page)) {
            this._pageGraphics.set(this._page, this._graphics);
        }
        if (this._pages.indexOf(this._page) === -1) {
            this._pages.push(this._page);
        }
        this._graphics._layer = this;
    };
    PdfLayer.prototype._beginLayer = function (currentGraphics) {
        if (this._graphicsCollection) {
            if (this._graphicsCollection.has(currentGraphics)) {
                this._graphics = this._graphicsCollection.get(currentGraphics);
            }
            else {
                this._graphics = currentGraphics;
            }
        }
        if (this._graphics && this._name && this._name !== '') {
            this._graphics._isEmptyLayer = true;
            if (this._parentLayer.length !== 0) {
                for (var i = 0; i < this._parentLayer.length; i++) {
                    if (this._parentLayer[Number.parseInt(i.toString(), 10)]._id && this._parentLayer[Number.parseInt(i.toString(), 10)]._layerId !== '') {
                        this._graphics._sw._write("/OC /" + this._parentLayer[Number.parseInt(i.toString(), 10)]._id + " BDC");
                    }
                }
            }
            var data = "/OC /" + this._id + " BDC";
            if (this.name && this.name !== '') {
                this._graphics._sw._write(data);
                this._isEndState = true;
            }
            else {
                this._content.write(data);
            }
        }
    };
    PdfLayer.prototype._setVisibility = function (value) {
        var catalog = this._document._catalog._catalogDictionary;
        var ocProperties;
        if (catalog.has('OCProperties')) {
            ocProperties = catalog.get('OCProperties');
            if (!ocProperties) {
                ocProperties = new _PdfDictionary(this._crossReference);
            }
        }
        if (ocProperties) {
            var ocgOFF = void 0;
            var ocgON = void 0;
            var defaultView = ocProperties.get('D');
            if (!defaultView) {
                defaultView = new _PdfDictionary(this._crossReference);
            }
            if (defaultView) {
                if (defaultView.has('ON')) {
                    ocgON = defaultView.get('ON');
                    if (!ocgON) {
                        ocgON = [];
                    }
                }
                if (defaultView.has('OFF')) {
                    ocgOFF = defaultView.get('OFF');
                    if (!ocgOFF) {
                        ocgOFF = [];
                    }
                }
                if (this._referenceHolder) {
                    if (!value) {
                        if (ocgON) {
                            var index = ocgON.indexOf(this._referenceHolder);
                            if (index !== -1) {
                                ocgON.splice(index, 1);
                            }
                        }
                        if (ocgOFF) {
                            var index = ocgOFF.indexOf(this._referenceHolder);
                            if (index !== -1) {
                                ocgOFF.splice(index);
                            }
                        }
                        ocgOFF.push(this._referenceHolder);
                    }
                    else {
                        if (ocgOFF) {
                            var index = ocgOFF.indexOf(this._referenceHolder);
                            if (index !== -1) {
                                ocgOFF.splice(index, 1);
                            }
                        }
                        if (ocgON) {
                            var index = ocgON.indexOf(this._referenceHolder);
                            if (index !== -1) {
                                ocgON.splice(index);
                            }
                        }
                        ocgON.push(this._referenceHolder);
                    }
                }
                defaultView._updated = true;
            }
            ocProperties._updated = true;
        }
    };
    PdfLayer.prototype._setLock = function (isSetLock) {
        var catalog = this._document._catalog._catalogDictionary;
        var ocProperties;
        if (catalog.has('OCProperties')) {
            ocProperties = catalog.get('OCProperties');
            if (!ocProperties) {
                ocProperties = new _PdfDictionary(this._crossReference);
            }
        }
        if (ocProperties) {
            var defaultView = ocProperties.get('D');
            if (!defaultView) {
                defaultView = new _PdfDictionary(this._crossReference);
            }
            if (defaultView) {
                var locked = defaultView.get('Locked');
                if (this._referenceHolder) {
                    if (isSetLock) {
                        if (locked) {
                            if (locked.indexOf(this._referenceHolder) === -1) {
                                locked.push(this._referenceHolder);
                            }
                        }
                        else {
                            this._lock = [];
                            this._lock.push(this._referenceHolder);
                            defaultView.update('Locked', this._lock);
                        }
                    }
                    else if (locked) {
                        var index = locked.indexOf(this._referenceHolder);
                        if (index !== -1) {
                            locked.splice(index, 1);
                        }
                    }
                }
                defaultView._updated = true;
            }
            ocProperties._updated = true;
        }
    };
    PdfLayer.prototype._parseLayerPage = function () {
        if (this._document) {
            for (var i = 0; i < this._document.pageCount; i++) {
                var pageDictionary = this._document.getPage(i)._pageDictionary;
                var pageBase = this._document.getPage(i);
                if (pageDictionary.has('Resources')) {
                    var resources = pageDictionary.get('Resources');
                    if (resources && (resources.has('Properties') || resources.has('XObject'))) {
                        var properties = resources.get('Properties');
                        var xObject = resources.get('XObject');
                        if (properties) {
                            var map = properties._map; // eslint-disable-line
                            for (var layerValue in map) {
                                if (map[String(layerValue)] instanceof _PdfReference) {
                                    var reference = map[String(layerValue)];
                                    var dictionary = this._crossReference._fetch(reference);
                                    var layerIDName = layerValue;
                                    var isPresent = this._parseDictionary(dictionary, reference, pageBase, layerIDName);
                                    if (isPresent) {
                                        break;
                                    }
                                }
                            }
                        }
                        if (xObject) {
                            var map = xObject._map; // eslint-disable-line
                            for (var layerValue in map) {
                                if (map[String(layerValue)] instanceof _PdfReference) {
                                    var reference = map[String(layerValue)];
                                    var xobjectStream = this._crossReference._fetch(reference);
                                    var dictionary = xobjectStream.dictionary;
                                    if (dictionary.has('OC')) {
                                        var layerIdName = layerValue;
                                        var ocReference = dictionary.getRaw('OC');
                                        dictionary = this._crossReference._fetch(ocReference);
                                        var isPresent = this._parseDictionary(dictionary, ocReference, pageBase, layerIdName);
                                        if (isPresent) {
                                            this._layer._xObject.push(layerIdName);
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    PdfLayer.prototype._parseDictionary = function (dictionary, reference, pageBase, layerID) {
        var isPresent = false;
        if (dictionary.has('Name') && dictionary.has('OCGs')) {
            var refArray = dictionary.get('OCGs');
            if (!refArray) {
                reference = dictionary.getArray('OCGs');
                dictionary = dictionary.get('OCGs');
                if (dictionary && dictionary.has('Name')) {
                    isPresent = this._setLayerPage(reference, pageBase, layerID);
                }
            }
            else {
                for (var a = 0; a < refArray.length; a++) {
                    if (refArray[Number.parseInt(a.toString(), 10)] instanceof _PdfReference) {
                        reference = refArray[Number.parseInt(a.toString(), 10)];
                        dictionary = this._crossReference._fetch(reference);
                        isPresent = this._setLayerPage(reference, pageBase, layerID);
                    }
                }
            }
        }
        else if (dictionary.has('Name')) {
            isPresent = this._setLayerPage(reference, pageBase, layerID);
        }
        return isPresent;
    };
    PdfLayer.prototype._setLayerPage = function (reference, pageBase, layerID) {
        var isPresent = false;
        if (this._layer._referenceHolder && this._layer._referenceHolder === reference) {
            this._layer._pageParsed = true;
            isPresent = true;
            this._layer._layerId = layerID;
            this._layer._page = pageBase;
            if (this._layer._pages.indexOf(pageBase) === -1) {
                this._layer._pages.push(pageBase);
            }
        }
        return isPresent;
    };
    PdfLayer.prototype._setPrintState = function () {
        var catalog = this._document._catalog._catalogDictionary;
        var ocProperties;
        var usageDictionary;
        if (catalog.has('OCProperties')) {
            ocProperties = catalog.get('OCProperties');
            if (!ocProperties) {
                ocProperties = new _PdfDictionary(this._crossReference);
            }
        }
        var ocGroup = ocProperties.get('OCGs');
        if (!ocGroup) {
            ocGroup = [];
        }
        if (!this._dictionary.has('Usage')) {
            usageDictionary = new _PdfDictionary();
        }
        else {
            usageDictionary = this._dictionary.get('Usage');
        }
        this._layer._printOption = new _PdfDictionary();
        this._layer._printOption.update('Subtype', new _PdfName('Print'));
        if (this._layer._printState === PdfPrintState.neverPrint) {
            this._layer._printOption.update('PrintState', new _PdfName('OFF'));
        }
        else if (this._layer.printState === PdfPrintState.alwaysPrint) {
            this._layer._printOption.update('PrintState', new _PdfName('ON'));
        }
        var reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, this._layer._printOption);
        usageDictionary.update('Print', reference);
        this._layer._usage = usageDictionary;
        this._dictionary.update('Usage', this._layer._usage);
        var category = [];
        category.push(new _PdfName('Print'));
        var _usageApplication = new _PdfDictionary();
        _usageApplication.update('Category', category);
        _usageApplication.update('OCGs', ocGroup);
        _usageApplication.update('Event', new _PdfName('Print'));
        var usageApplication = [];
        reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, _usageApplication);
        usageApplication.push(reference);
        var defaultView = ocProperties.get('D');
        if (!defaultView) {
            defaultView = new _PdfDictionary(this._crossReference);
        }
        defaultView.update('D', usageApplication);
    };
    return PdfLayer;
}());

/**
 * The class provides methods and properties to handle the collection of `PdfLayer`.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access the collection of layers in the document
 * let layers: PdfLayerCollection = document.layers;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfLayerCollection = /** @class */ (function () {
    function PdfLayerCollection(document, layer) {
        this._subLayer = false;
        this._isLayerContainsResource = false;
        this._layerDictionary = new Map();
        this._bdcCount = 0;
        if (!this._list) {
            this._list = [];
        }
        this._crossReference = document._crossReference;
        this._catalog = document._catalog;
        this._document = document;
        if (layer) {
            this._parent = layer;
        }
        else {
            var _layerDictionary = void 0;
            var _layerReference = void 0;
            if (this._document && this._document._catalog && this._document._catalog._catalogDictionary
                && this._document._catalog._catalogDictionary.has('OCProperties')) {
                var ocProperties = this._document._catalog._catalogDictionary.get('OCProperties');
                if (ocProperties && ocProperties.has('OCGs')) {
                    var ocGroup = ocProperties.get('OCGs');
                    if (ocGroup && Array.isArray(ocGroup)) {
                        for (var i = 0; i < ocGroup.length; i++) {
                            _layerReference = ocGroup[Number.parseInt(i.toString(), 10)];
                            if (_layerReference instanceof _PdfReference) {
                                _layerDictionary = this._crossReference._fetch(_layerReference);
                                var layer_1 = new PdfLayer();
                                if (_layerDictionary) {
                                    if (_layerDictionary.has('Name')) {
                                        var layerName = _layerDictionary.get('Name');
                                        layer_1.name = layerName;
                                        layer_1._dictionary = _layerDictionary;
                                        layer_1._crossReference = this._document._crossReference;
                                        layer_1._referenceHolder = _layerReference;
                                        var layerId = _layerDictionary.get('LayerID');
                                        if (layerId) {
                                            layer_1._layerId = layerId.name;
                                        }
                                        var _print = _layerDictionary.getRaw('Usage');
                                        if (_print && _print instanceof _PdfDictionary) {
                                            var printOption = _print.get('Print');
                                            if (printOption && printOption instanceof _PdfDictionary) {
                                                layer_1._printOption = printOption;
                                                if (printOption.has('PrintState')) {
                                                    this._setPrintState(printOption, layer_1);
                                                }
                                            }
                                            var viewState = _print.get('View');
                                            if (viewState && viewState instanceof _PdfDictionary && viewState.has('ViewState')) {
                                                var view = viewState.get('ViewState');
                                                if (view.name === 'OFF') {
                                                    layer_1.visible = false;
                                                }
                                            }
                                        }
                                        if (_print && _print instanceof _PdfReference) {
                                            var printRef = this._crossReference._fetch(_print);
                                            if (printRef && printRef instanceof _PdfDictionary) {
                                                var _printOptionReference = printRef.getRaw('Print');
                                                if (_printOptionReference && _printOptionReference instanceof _PdfReference) {
                                                    var subtytpe = this._crossReference._fetch(_printOptionReference);
                                                    if (subtytpe && subtytpe instanceof _PdfDictionary) {
                                                        layer_1._printOption = subtytpe;
                                                        if (subtytpe.has('PrintState')) {
                                                            this._setPrintState(subtytpe, layer_1);
                                                        }
                                                    }
                                                }
                                                var viewStateReference = printRef.getRaw('View');
                                                if (viewStateReference && viewStateReference instanceof _PdfReference) {
                                                    var viewState = this._crossReference._fetch(viewStateReference);
                                                    if (viewState && viewState instanceof _PdfDictionary && viewState.has('ViewState')) {
                                                        var view = viewState.get('ViewState');
                                                        if (view.name === 'OFF') {
                                                            layer_1.visible = false;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    layer_1._document = document;
                                    layer_1._layer = layer_1;
                                    this._layerDictionary.set(_layerReference, layer_1);
                                    this._list.push(layer_1);
                                }
                            }
                        }
                    }
                    this._checkLayerLock(ocProperties);
                    this._checkLayerVisible(ocProperties);
                    this._checkParentLayer(ocProperties);
                    this._createLayerHierarchical(ocProperties);
                }
            }
        }
    }
    Object.defineProperty(PdfLayerCollection.prototype, "_isSkip", {
        get: function () {
            return this._bdcCount > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLayerCollection.prototype, "count", {
        /**
         * Gets the layer count.
         *
         * @returns {number} Number of layers.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the collection of layers in the document
         * let layers: PdfLayerCollection = document.layers;
         * // Retrieve layer counts from the layers collection
         * let count: number = layers.count;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._list.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the `PdfLayer` at the specified index.
     *
     * @param {number} index Layer index.
     * @returns {PdfLayer} Layer at the specified index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access the collection of layers in the document
     * let layers: PdfLayerCollection = document.layers;
     * // Retrieve the first layer from the layers collection
     * let layer: PdfLayer = layers.at(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfLayerCollection.prototype.at = function (index) {
        return this._list[Number.parseInt(index.toString(), 10)];
    };
    PdfLayerCollection.prototype.add = function (name, visible) {
        var newLayer = new PdfLayer();
        newLayer._document = this._document;
        newLayer._crossReference = this._document._crossReference;
        newLayer.name = name;
        if (visible !== null && typeof visible !== 'undefined') {
            newLayer.visible = visible;
        }
        newLayer._layerId = 'OCG_' + _getNewGuidString();
        newLayer._subLayerPosition = 0;
        newLayer._layer = newLayer;
        this._addLayer(newLayer);
        return newLayer;
    };
    PdfLayerCollection.prototype.contains = function (arg) {
        if (!arg) {
            throw new Error('Layer cannot be null or undefined');
        }
        if (typeof arg === 'string') {
            for (var i = 0; i < this._list.length; i++) {
                var layer = this._list[Number.parseInt(i.toString(), 10)];
                if (layer.name === arg) {
                    return true;
                }
            }
        }
        else if (arg instanceof PdfLayer) {
            if (this._list.indexOf(arg) !== -1) {
                return true;
            }
        }
        return false;
    };
    /**
     * Remove all the layers.
     *
     * @returns {void} Returns nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access the collection of layers in the document
     * let layers: PdfLayerCollection = document.layers;
     * // Removes all layers from the collection
     * layers.clear();
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfLayerCollection.prototype.clear = function () {
        for (var i = this._list.length - 1; i > -1; i--) {
            var layer = this._list[Number.parseInt(i.toString(), 10)];
            this._removeLayer(layer, true);
        }
        this._list.length = 0;
    };
    /**
     * Index of the specified layer.
     *
     * @param {PdfLayer} layer The layer to be checked.
     * @returns {number} Index of the layer.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access the collection of layers in the document
     * let layers: PdfLayerCollection = document.layers;
     * // Add a new layer to the document with the name 'Layer1'
     * let layer: PdfLayer = layers.add('Layer1');
     * // Find the index of the layer in the layers collection
     * let index: number = layers.indexOf(layer);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfLayerCollection.prototype.indexOf = function (layer) {
        if (!layer) {
            throw new Error('Layer cannot be null or undefined');
        }
        return this._list.indexOf(layer);
    };
    /**
     * Move the `PdfLayer` into the collection at specified index.
     *
     * @param {number} index Index of the layer.
     * @param {PdfLayer} layer Layer to move.
     * @returns {void} Returns nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access the collection of layers in the document
     * let layers: PdfLayerCollection = document.layers;
     * // Add a new layer to the document with the name 'Layer1'
     * let layer: PdfLayer = layers.add('Layer1');
     * // Add a new layer to the document with the name 'Layer2'
     * let layer1: PdfLayer = layers.add('Layer2');
     * // Move 'layer2' to the first position (index 0)
     * layers.move(0, layer2);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfLayerCollection.prototype.move = function (index, layer) {
        if (index < 0 || index >= this._list.length) {
            throw new Error('Index cannot be less than 0 or greater than array length');
        }
        if (!layer) {
            throw new Error('Layer cannot be null or undefined');
        }
        var position;
        for (var i = 0; i < this._list.length; i++) {
            if (this._list[Number.parseInt(i.toString(), 10)] === layer) {
                position = this.indexOf(this._list[Number.parseInt(i.toString(), 10)]);
                break;
            }
        }
        if (position !== null && typeof position !== 'undefined' && position !== index) {
            this._list.splice(position, 1);
            this._list.splice(index, 0, layer);
            this._insertLayer(index, layer);
        }
    };
    PdfLayerCollection.prototype.removeAt = function (arg1, arg2) {
        if (arg1 < 0 || arg1 >= this._list.length) {
            throw new Error('Index cannot be less than 0 or greater than array length');
        }
        var layer = this._list[Number.parseInt(arg1.toString(), 10)];
        this._list.splice(arg1, 1);
        if (layer) {
            this._removeLayer(layer, arg2 || false);
            if (layer._child.length > 0) {
                for (var i = 0; i < layer._child.length; i++) {
                    this._removeLayer(layer._child[Number.parseInt(i.toString(), 10)], false);
                    var index = this._list.indexOf(layer._child[Number.parseInt(i.toString(), 10)]);
                    if (index !== -1) {
                        this._list.splice(index, 1);
                    }
                }
            }
        }
    };
    PdfLayerCollection.prototype.remove = function (arg1, arg2) {
        if (arg1 instanceof PdfLayer) {
            var layer = arg1;
            var index = this._list.indexOf(layer);
            if (index !== -1) {
                this.removeAt(index, arg2 || false);
            }
        }
        else if (typeof arg1 === 'string') {
            for (var i = 0; i < this._list.length; i++) {
                var layer = this._list[Number.parseInt(i.toString(), 10)];
                var index = this._list.indexOf(layer);
                if (layer.name === arg1 && index !== -1) {
                    this.removeAt(index, arg2 || false);
                    i = i - 1;
                }
            }
        }
    };
    PdfLayerCollection.prototype._setPrintState = function (printOption, layer) {
        var printState = printOption.get('PrintState');
        if (printState && printState instanceof _PdfName) {
            if (printState.name === 'ON') {
                layer.printState = PdfPrintState.alwaysPrint;
            }
            else {
                layer.printState = PdfPrintState.neverPrint;
            }
        }
    };
    PdfLayerCollection.prototype._addLayer = function (layer) {
        this._list.push(layer);
        var index = this._list.length - 1;
        if (this._document instanceof PdfDocument) {
            this._createLayer(layer);
        }
        layer._layer = layer;
        return index;
    };
    PdfLayerCollection.prototype._createLayer = function (layer) {
        var ocProperties = new _PdfDictionary(this._crossReference);
        var ocGroups = this._createOptionalContentDictionary(layer);
        var isPresent = false;
        if (this._document && this._document._catalog && this._document._catalog._catalogDictionary.has('OCProperties') && this._isLayerContainsResource) {
            var _ocDictionary = this._document._catalog._catalogDictionary.get('OCProperties');
            if (_ocDictionary && _ocDictionary.has('OCGs')) {
                var ocgsList = _ocDictionary.get('OCGs');
                if (ocgsList && ocGroups) {
                    isPresent = true;
                    for (var _i = 0, ocGroups_1 = ocGroups; _i < ocGroups_1.length; _i++) {
                        var obj = ocGroups_1[_i];
                        if (ocgsList.indexOf(obj) === -1) {
                            ocgsList.push(obj);
                        }
                    }
                }
                if (_ocDictionary.has('D')) {
                    var defaultView = _ocDictionary.get('D');
                    if (defaultView) {
                        var on = void 0;
                        var off = void 0;
                        var _usage = void 0;
                        if (!defaultView.has('Order')) {
                            defaultView.update('Order', this._document._order);
                        }
                        if (defaultView.has('OFF')) {
                            off = defaultView.get('OFF');
                        }
                        if (defaultView.has('ON')) {
                            on = defaultView.get('ON');
                        }
                        if (defaultView.has('AS')) {
                            _usage = defaultView.get('AS');
                        }
                        if (_usage) {
                            for (var i = 0; i < _usage.length; i++) {
                                var usageDictionary = void 0;
                                var value = _usage[Number.parseInt(i.toString(), 10)];
                                if (value instanceof _PdfReference) {
                                    usageDictionary = this._crossReference._fetch(value);
                                    if (usageDictionary && usageDictionary instanceof _PdfDictionary) {
                                        var usageOcGroup = usageDictionary.get('OCGs');
                                        if (usageOcGroup && ocGroups && usageOcGroup.indexOf(layer._referenceHolder) === -1) {
                                            usageOcGroup.push(layer._referenceHolder);
                                        }
                                    }
                                }
                            }
                        }
                        if (layer.visible) {
                            if (on && ocGroups && on.indexOf(layer._referenceHolder) === -1) {
                                on.push(layer._referenceHolder);
                            }
                        }
                        else if (off && ocGroups && off.indexOf(layer._referenceHolder) === -1) {
                            off.push(layer._referenceHolder);
                        }
                    }
                }
                this._document._catalog._catalogDictionary._updated = true;
            }
        }
        if (!isPresent) {
            ocProperties.update('OCGs', ocGroups);
            ocProperties.update('D', this._createOptionalContentViews());
            this._catalog._catalogDictionary.update('OCProperties', ocProperties);
        }
        this._crossReference._allowCatalog = true;
    };
    PdfLayerCollection.prototype._createOptionalContentDictionary = function (layer) {
        var _dictionary = new _PdfDictionary(this._crossReference);
        var reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, _dictionary);
        _dictionary.update('Name', layer.name);
        _dictionary.update('Type', new _PdfName('OCG'));
        _dictionary.update('LayerID', new _PdfName(layer._layerId));
        _dictionary.update('Visible', layer.visible);
        if (layer.printState === PdfPrintState.alwaysPrint ||
            layer.printState === PdfPrintState.neverPrint ||
            layer.printState === PdfPrintState.printWhenVisible) {
            var UsageReference = this._setPrintOption(layer);
            _dictionary.update('Usage', UsageReference);
            this._document._printLayer.push(reference);
        }
        this._document._optionalContentDictionaries.push(reference);
        layer._dictionary = _dictionary;
        layer._referenceHolder = reference;
        var ocProperties = this._document._catalog._catalogDictionary.get('OCProperties');
        this._createSublayer(ocProperties, reference, layer);
        if (layer.visible) {
            this._document._on.push(reference);
        }
        else {
            this._document._off.push(reference);
        }
        this._isLayerContainsResource = true;
        return this._document._optionalContentDictionaries;
    };
    PdfLayerCollection.prototype._createOptionalContentViews = function () {
        var _optionalContent = new _PdfDictionary();
        _optionalContent.update('Name', 'Layers');
        _optionalContent.update('Order', this._document._order);
        _optionalContent.update('ON', this._document._on);
        _optionalContent.update('OFF', this._document._off);
        var category = [];
        category.push(new _PdfName('Print'));
        var _usageApplication = new _PdfDictionary();
        _usageApplication.update('Category', category);
        _usageApplication.update('OCGs', this._document._printLayer);
        _usageApplication.update('Event', new _PdfName('Print'));
        var reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, _usageApplication);
        this._document._as.push(reference);
        _optionalContent.update('AS', this._document._as);
        return _optionalContent;
    };
    PdfLayerCollection.prototype._setPrintOption = function (layer) {
        var _usage = new _PdfDictionary();
        var _print = new _PdfDictionary();
        var usageReference = this._crossReference._getNextReference();
        var printReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(usageReference, _usage);
        this._crossReference._cacheMap.set(printReference, _print);
        _print.update('Subtype', new _PdfName('Print'));
        if (layer.printState === PdfPrintState.neverPrint) {
            _print.update('PrintState', new _PdfName('OFF'));
        }
        else if (layer.printState === PdfPrintState.alwaysPrint) {
            _print.update('PrintState', new _PdfName('ON'));
        }
        layer._usage = _usage;
        layer._printOption = _print;
        _usage.update('Print', printReference);
        return usageReference;
    };
    PdfLayerCollection.prototype._createSublayer = function (ocProperties, reference, layer) {
        if (!this._subLayer) {
            if (ocProperties) {
                var order = void 0;
                var defaultview = ocProperties.get('D');
                if (defaultview) {
                    order = defaultview.get('Order');
                }
                if (order) {
                    this._document._order = order;
                }
                this._document._order.push(reference);
            }
            else {
                this._document._order.push(reference);
            }
        }
        else {
            layer._parent = this._parent;
            if (ocProperties) {
                var order = void 0;
                var defaultview = ocProperties.get('D');
                if (defaultview) {
                    order = defaultview.get('Order');
                }
                if (this._document._order && order) {
                    this._document._order = order;
                }
            }
            if (this._parent._child.length === 0) {
                this._parent._subLayer.push(reference);
            }
            else if (this._document._order.indexOf(this._parent._referenceHolder) !== -1) {
                var position = this._document._order.indexOf(this._parent._referenceHolder);
                this._document._order.splice(position + 1, 1);
                this._parent._subLayer.push(reference);
            }
            else {
                this._parent._subLayer.push(reference);
            }
            if (this._document._order.indexOf(this._parent._referenceHolder) !== -1) {
                var position = this._document._order.indexOf(this._parent._referenceHolder);
                this._document._order.splice(position + 1, 0, this._parent._subLayer);
            }
            else {
                if (this._parent._parent) {
                    if (this._parent._parent._subLayer.indexOf(this._parent._referenceHolder) !== -1) {
                        var position = this._parent._parent._subLayer.indexOf(this._parent._referenceHolder);
                        if (this._parent._subLayer.length === 1) {
                            this._parent._parent._subLayer.splice(position + 1, 0, this._parent._subLayer);
                        }
                        if (this._document._order.indexOf(this._parent._parent._referenceHolder) !== -1) {
                            var position_1 = this._document._order.indexOf(this._parent._parent._referenceHolder);
                            this._document._order.splice(position_1 + 1, 1);
                            this._document._order.splice(position_1 + 1, 0, this._parent._parent._subLayer);
                        }
                    }
                }
                else {
                    if (document instanceof PdfDocument) {
                        for (var i = 0; i < document._order.length; i++) {
                            if (Array.isArray(document._order[Number.parseInt(i.toString(), 10)])) {
                                var value = document._order[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                                var orderArray = value;
                                if (orderArray.indexOf(this._parent._referenceHolder) !== -1) {
                                    var position = orderArray.indexOf(this._parent._referenceHolder);
                                    if (this._parent._subLayer.length === 1) {
                                        orderArray.splice(position + 1, 0, this._parent._subLayer);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (this._parent._child.indexOf(layer) === -1) {
                this._parent._child.push(layer);
            }
            if (this._parent._parentLayer.length === 0) {
                layer._parentLayer.push(this._parent);
            }
            else {
                for (var i = 0; i < this._parent._parentLayer.length; i++) {
                    if (layer._parentLayer.indexOf(this._parent._parentLayer[Number.parseInt(i.toString(), 10)]) === -1) {
                        layer._parentLayer.push(this._parent._parentLayer[Number.parseInt(i.toString(), 10)]);
                    }
                }
                if (layer._parentLayer.indexOf(this._parent) === -1) {
                    layer._parentLayer.push(this._parent);
                }
            }
        }
    };
    PdfLayerCollection.prototype._checkLayerLock = function (ocProperties) {
        var locked;
        var defaultView = ocProperties.get('D');
        if (defaultView && defaultView.has('Locked')) {
            locked = defaultView.get('Locked');
        }
        if (locked) {
            for (var i = 0; i < locked.length; i++) {
                var referenceHolder = locked[Number.parseInt(i.toString(), 10)];
                if (referenceHolder && referenceHolder instanceof _PdfReference) {
                    var pdfLayer = this._layerDictionary.get(referenceHolder);
                    if (pdfLayer) {
                        pdfLayer.locked = true;
                    }
                }
            }
        }
    };
    PdfLayerCollection.prototype._checkLayerVisible = function (ocProperties) {
        var _document = this._document;
        var visible;
        if (_document._catalog && _document._catalog._catalogDictionary.has('OCProperties')) {
            var defaultView = ocProperties.get('D');
            if (defaultView && defaultView.has('OFF')) {
                visible = defaultView.get('OFF');
            }
            if (visible) {
                for (var i = 0; i < visible.length; i++) {
                    var visibleReference = visible[Number.parseInt(i.toString(), 10)];
                    if (visibleReference instanceof _PdfReference) {
                        var layerDictionary = this._layerDictionary;
                        if (layerDictionary && layerDictionary.size > 0 && visibleReference && layerDictionary.has(visibleReference)) {
                            var pdfLayer = layerDictionary.get(visibleReference);
                            if (pdfLayer) {
                                pdfLayer.visible = false;
                                if (pdfLayer._dictionary && pdfLayer._dictionary.has('Visible')) {
                                    pdfLayer._dictionary.set('Visible', false);
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    PdfLayerCollection.prototype._checkParentLayer = function (ocProperties) {
        var defaultView = ocProperties.get('D');
        if (defaultView) {
            var array = defaultView.get('Order');
            if (array) {
                this._parsingLayerOrder(null, array, this._layerDictionary);
            }
        }
    };
    PdfLayerCollection.prototype._parsingLayerOrder = function (parent, array, layerDictionary) {
        var reference;
        var layer;
        for (var i = 0; i < array.length; i++) {
            reference = array[Number.parseInt(i.toString(), 10)];
            if (reference instanceof _PdfReference) {
                if (layerDictionary.has(reference)) {
                    layer = layerDictionary.get(reference);
                }
                if (layer) {
                    if (parent) {
                        if (parent._child.indexOf(layer) === -1) {
                            parent._child.push(layer);
                        }
                        if (parent._parentLayer.length === 0) {
                            layer._parentLayer.push(parent);
                            layer._parent = parent;
                        }
                        else {
                            for (var j = 0; j < parent._parentLayer.length; j++) {
                                if (layer._parentLayer.indexOf(parent._parentLayer[Number.parseInt(j.toString(), 10)]) === -1) {
                                    if (!(parent._parentLayer[Number.parseInt(j.toString(), 10)] instanceof PdfLayer)
                                        && parent._parentLayer[Number.parseInt(j.toString(), 10)]) {
                                        layer._parentLayer.push(parent._parentLayer[Number.parseInt(j.toString(), 10)]);
                                    }
                                }
                            }
                            layer._parentLayer.push(parent);
                            layer._parent = parent;
                        }
                    }
                    if (array.length > i + 1 && (Array.isArray(array[i + 1]))) {
                        i++;
                        var pdfArray = array[i]; // eslint-disable-line
                        layer._subLayer = pdfArray;
                        this._parsingLayerOrder(layer, pdfArray, layerDictionary);
                    }
                }
            }
            else if (Array.isArray(array[Number.parseInt(i.toString(), 10)])) {
                var value = array[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                var subArray = value;
                if (!subArray || subArray.length === 0) {
                    return;
                }
                if (typeof subArray[0] === 'string') {
                    parent = null;
                    this._parsingLayerOrder(parent, subArray, layerDictionary);
                }
                else {
                    parent = null;
                    this._parsingLayerOrder(parent, array[i], layerDictionary); // eslint-disable-line
                }
            }
        }
    };
    PdfLayerCollection.prototype._createLayerHierarchical = function (ocProperties) {
        var _this = this;
        var defaultView = ocProperties.get('D');
        if (defaultView && defaultView.has('Order')) {
            if (this._layerDictionary && this._layerDictionary.size > 0) {
                this._list.splice(0, this._list.length);
                this._layerDictionary.forEach(function (_layer, _pdfReference) {
                    if (_layer instanceof PdfLayer && _pdfReference instanceof _PdfReference) {
                        if (!_layer._parent && _this._list.indexOf(_layer) === -1) {
                            _this._list.push(_layer);
                        }
                        else if (_layer._child.length > 0) {
                            _this._addChildLayer(_layer._parent);
                        }
                        else if (_layer._parent && _layer._child.length === 0 && !_layer._parent.layers.contains(_layer)) {
                            _layer._parent.layers._addNestedLayer(_layer);
                        }
                    }
                });
            }
        }
    };
    PdfLayerCollection.prototype._addChildLayer = function (layer) {
        for (var i = 0; i < layer._child.length; i++) {
            var child = layer._child[Number.parseInt(i.toString(), 10)];
            if (layer.layers.indexOf(child) === -1) {
                layer.layers._addNestedLayer(child);
            }
        }
    };
    PdfLayerCollection.prototype._addNestedLayer = function (layer) {
        this._list.push(layer);
        var index = this._list.length - 1;
        layer._layer = layer;
        return index;
    };
    PdfLayerCollection.prototype._removeLayer = function (layer, removeGraphicalContent) {
        var _dictionary;
        if (layer && this._document) {
            _dictionary = this._document._catalog._catalogDictionary;
            if (_dictionary && _dictionary.has('OCProperties')) {
                var ocProperties = _dictionary.get('OCProperties');
                if (ocProperties) {
                    var ocGroup = ocProperties.get('OCGs');
                    if (ocGroup) {
                        this._removeOCG(layer, ocGroup);
                    }
                    if (ocProperties.has('D')) {
                        var defaultView = ocProperties.get('D');
                        if (defaultView) {
                            var on = void 0;
                            var off = void 0;
                            if (defaultView.has('Order')) {
                                var order = defaultView.get('Order');
                                if (order) {
                                    var arrayList = [];
                                    this._removeOrder(layer, order, arrayList);
                                }
                            }
                            if (defaultView.has('Locked')) {
                                var locked = defaultView.get('Locked');
                                if (locked) {
                                    this._removeLocked(layer, locked);
                                }
                            }
                            if (defaultView.has('OFF')) {
                                off = defaultView.get('OFF');
                            }
                            if (defaultView.has('ON')) {
                                on = defaultView.get('ON');
                            }
                            if (defaultView.has('AS')) {
                                var _usage = defaultView.get('AS');
                                if (_usage) {
                                    this._removeUsage(layer, _usage);
                                }
                            }
                            this._removeVisible(layer, on, off);
                        }
                        defaultView._updated = true;
                    }
                    var page = layer._layerPage;
                    if (page) {
                        var resource = layer._layerPage._pageDictionary.get('Resources');
                        if (resource.has('Properties')) {
                            var properties = resource.get('Properties');
                            if (properties && properties.has(layer._layerId)) {
                                delete properties._map[layer._layerId];
                            }
                        }
                    }
                    var chacheMap = this._crossReference._cacheMap; // eslint-disable-line
                    if (chacheMap.has(layer._referenceHolder)) {
                        var dictionary = this._crossReference._cacheMap.get(layer._referenceHolder);
                        if (dictionary) {
                            var usage = dictionary.getRaw('Usage');
                            if (usage instanceof _PdfReference) {
                                dictionary = this._crossReference._cacheMap.get(usage);
                                if (dictionary) {
                                    var printReference = dictionary.getRaw('Print');
                                    chacheMap.delete(layer._referenceHolder);
                                    chacheMap.delete(usage);
                                    chacheMap.delete(printReference);
                                }
                            }
                        }
                    }
                    ocProperties._updated = true;
                    _dictionary._updated = true;
                }
                this._crossReference._allowCatalog = true;
            }
            if (removeGraphicalContent) {
                this._removeLayerContent(layer);
            }
        }
    };
    PdfLayerCollection.prototype._removeOCG = function (layer, ocGroup) {
        if (ocGroup && ocGroup.indexOf(layer._referenceHolder) !== -1) {
            ocGroup.splice(ocGroup.indexOf(layer._referenceHolder), 1);
        }
    };
    PdfLayerCollection.prototype._removeUsage = function (layer, _usage) {
        if (_usage) {
            var isRemoved = false;
            for (var i = 0; i < _usage.length; i++) {
                var usage = _usage[Number.parseInt(i.toString(), 10)];
                if (usage) {
                    var usageDictionary = void 0;
                    if (usage instanceof _PdfReference) {
                        usageDictionary = this._crossReference._fetch(_usage[Number.parseInt(i.toString(), 10)]);
                    }
                    if (usage instanceof _PdfDictionary) {
                        usageDictionary = usage;
                    }
                    if (usageDictionary) {
                        var usageOcGroup = usageDictionary.get('OCGs');
                        if (usageOcGroup) {
                            if (usageOcGroup.indexOf(layer._referenceHolder) !== -1) {
                                usageOcGroup.splice(usageOcGroup.indexOf(layer._referenceHolder), 1);
                                isRemoved = true;
                            }
                            if (isRemoved) {
                                break;
                            }
                        }
                    }
                }
            }
        }
    };
    PdfLayerCollection.prototype._removeOrder = function (layer, order, arrayList) {
        var isRemoveOrder = false;
        if (order) {
            for (var i = 0; i < order.length; i++) {
                var entry = order[Number.parseInt(i.toString(), 10)];
                if (entry && entry instanceof _PdfReference && entry === layer._referenceHolder) {
                    if (i !== order.length - 1) {
                        if (Array.isArray(order[Number.parseInt(i.toString(), 10) + 1])) {
                            order.splice(i, 2);
                            isRemoveOrder = true;
                            break;
                        }
                        else {
                            order.splice(i, 1);
                            isRemoveOrder = true;
                            break;
                        }
                    }
                    else {
                        order.splice(i, 1);
                        isRemoveOrder = true;
                        break;
                    }
                }
                else if (Array.isArray(entry)) {
                    arrayList.push(order[Number.parseInt(i.toString(), 10)]);
                }
            }
        }
        if (!isRemoveOrder && arrayList) {
            for (var i = 0; i < arrayList.length; i++) {
                order = arrayList[Number.parseInt(i.toString(), 10)];
                arrayList.splice(i, 1);
                i -= 1;
                this._removeOrder(layer, order, arrayList);
            }
        }
    };
    PdfLayerCollection.prototype._removeVisible = function (layer, on, off) {
        if (layer.visible) {
            if (on && on.indexOf(layer._referenceHolder) !== -1) {
                var index = on.indexOf(layer._referenceHolder);
                if (index > -1) {
                    on.splice(index, 1);
                }
            }
        }
        else {
            if (off && off.indexOf(layer._referenceHolder) !== -1) {
                var index = off.indexOf(layer._referenceHolder);
                if (index > -1) {
                    off.splice(index, 1);
                }
            }
        }
    };
    PdfLayerCollection.prototype._removeLocked = function (layer, locked) {
        if (locked && locked.indexOf(layer._referenceHolder) !== -1) {
            locked.splice(locked.indexOf(layer._referenceHolder), 1);
        }
    };
    PdfLayerCollection.prototype._removeLayerContent = function (layer) {
        var isSkip = false;
        var _properties;
        var _xObject;
        if (layer._layerPage) {
            for (var i = 0; i < layer._pages.length; i++) {
                var _resource = layer._pages[Number.parseInt(i.toString(), 10)]._pageDictionary.get('Resources');
                if (_resource) {
                    _properties = _resource.get('Properties');
                    _xObject = _resource.get('XObject');
                    if (_properties && layer._layerId.trim().length > 0 && _properties.has(layer._layerId)) {
                        delete _properties._map[layer._layerId];
                    }
                    if (_xObject && layer._xObject.length > 0) {
                        var map = _xObject._map; // eslint-disable-line
                        for (var _i = 0, map_1 = map; _i < map_1.length; _i++) {
                            var key = map_1[_i];
                            if (layer._xObject.indexOf(map[String(key)]) !== -1) {
                                delete _xObject._map[String(key)];
                                break;
                            }
                        }
                        if (layer._xObject.indexOf(layer._layerId) !== -1) {
                            layer._xObject.splice(layer._xObject.indexOf(layer._layerId), 1);
                        }
                    }
                }
                var content = layer._pages[i]._pageDictionary.getArray('Contents'); // eslint-disable-line
                for (var m = 0; m < content.length; m++) {
                    var data = new _PdfContentStream([]);
                    var stream = content[Number.parseInt(m.toString(), 10)];
                    var objID = stream.dictionary.objId;
                    var bytes = stream.getBytes();
                    var parser = void 0;
                    if (stream instanceof _PdfContentStream) {
                        parser = new _ContentParser(stream._bytes);
                    }
                    else {
                        parser = new _ContentParser(bytes);
                    }
                    var result = parser._readContent();
                    for (var j = 0; j < result.length; j++) {
                        var entry = result[Number.parseInt(j.toString(), 10)];
                        var _operator = entry._operator;
                        if (_operator === 'BMC' || _operator === 'EMC' || _operator === 'BDC') {
                            var operands = entry._operands;
                            this._processBeginMarkContent(layer, _operator, operands, data, objID);
                            isSkip = true;
                        }
                        if (_operator === 'Do' && layer._xObject.indexOf(entry._operands[0]) !== -1) {
                            isSkip = true;
                        }
                        if (_operator === 'q' || _operator === 'Q' ||
                            _operator === 'w' || _operator === 'J' || _operator === 'j' ||
                            _operator === 'M' || _operator === 'd' || _operator === 'ri' ||
                            _operator === 'i' || _operator === 'gs' || _operator === 'g' ||
                            _operator === 'cm' || _operator === 'G' || _operator === 'rg' ||
                            _operator === 'RG' || _operator === 'k' || _operator === 'K' ||
                            _operator === 'cs' || _operator === 'CS' || _operator === 'scn' ||
                            _operator === 'SCN' || _operator === 'sc' || _operator === 'SC') {
                            if (!isSkip) {
                                this._streamWrite(entry._operands, _operator, false, data);
                            }
                            isSkip = false;
                        }
                        else {
                            if (!isSkip) {
                                this._streamWrite(entry._operands, _operator, true, data);
                            }
                            isSkip = false;
                        }
                    }
                    if (data.length > 0 && !objID) {
                        var _pages = layer._pages[Number.parseInt(i.toString(), 10)];
                        var _reference = _pages._contents[Number.parseInt(m.toString(), 10)];
                        var contentStream = this._crossReference._fetch(_reference);
                        contentStream._bytes.length = 0;
                        contentStream.write(data.getString());
                    }
                }
                layer._pages[Number.parseInt(i.toString(), 10)]._pageDictionary._updated = true;
            }
        }
    };
    PdfLayerCollection.prototype._processBeginMarkContent = function (parser, operator, operands, data, id) {
        if (operator === 'BDC') {
            var operand = void 0;
            if (operands.length > 1 && operands[0].substring(1) === 'OC') {
                operand = operands[1].substring(1);
            }
            if (this._bdcCount > 0) {
                this._bdcCount++;
                return;
            }
            if (operand && operand === parser._layerId) {
                this._bdcCount++;
                var refArray = parser._pages[0]._pageDictionary.getRaw('Contents');
                if (id) {
                    var strParts = id.split(' ');
                    var index = refArray.indexOf(_PdfReference.get(Number(strParts[0]), Number(strParts[1])));
                    parser._pages[0]._pageDictionary.getRaw('Contents').splice(index, 1);
                }
            }
        }
        this._streamWrite(operands, operator, true, data);
        if ('EMC' === operator && this._bdcCount > 0) {
            this._bdcCount--;
        }
    };
    PdfLayerCollection.prototype._streamWrite = function (operands, operator, skip, data) {
        var pdfString;
        if (skip && this._isSkip) {
            return;
        }
        if (operands) {
            for (var _i = 0, operands_1 = operands; _i < operands_1.length; _i++) {
                var operand = operands_1[_i];
                pdfString = operand;
                data.write(pdfString);
                data.write(' ');
            }
        }
        pdfString = operator;
        data.write(pdfString);
        data.write('\r\n');
    };
    PdfLayerCollection.prototype._insertLayer = function (index, layer) {
        var reference = layer._referenceHolder;
        if (this._document) {
            var catalog = this._document._catalog._catalogDictionary;
            if (catalog.has('OCProperties')) {
                var ocDictionary = catalog.get('OCProperties');
                if (ocDictionary) {
                    var ocGroups = ocDictionary.get('OCGs');
                    if (ocDictionary.has('D')) {
                        var defaultView = ocDictionary.get('D');
                        if (defaultView) {
                            var order = defaultView.get('Order');
                            if (order && ocGroups && order.indexOf(reference) !== -1 && index < order.length) {
                                if (order[Number.parseInt(index.toString(), 10)] instanceof _PdfReference) {
                                    if (index + 1 < order.length && index + 2 < order.length) {
                                        var first = index + 1;
                                        var second = index + 2;
                                        if (order[Number.parseInt(first.toString(), 10)] instanceof _PdfReference
                                            && order[Number.parseInt(second.toString(), 10)] instanceof _PdfReference) {
                                            var position = order.indexOf(reference);
                                            order.splice(position, 1);
                                            order.splice(index, 0, reference);
                                            if (ocGroups.indexOf(reference) !== -1) {
                                                var position_2 = ocGroups.indexOf(reference);
                                                ocGroups.splice(position_2, 1);
                                                ocGroups.splice(index, 0, reference);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    return PdfLayerCollection;
}());

/**
 * Represents a PDF section, a set of pages with similar page settings.
 * ```typescript
 * // Create a new PDF document
 * let document: PdfDocument = new PdfDocument();
 * // Add a new section to the document
 * let section: PdfSection = document.addSection();
 * // Add a page to the section
 * let page: PdfPage = section.addPage();
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfSection = /** @class */ (function () {
    /**
     * Initializes a new instance of the `PdfSection` class.
     *
     * @param {PdfDocument} document PDF document.
     * @param {PdfPageSettings} settings Page settings.
     *
     * @private
     */
    function PdfSection(document, settings) {
        this._pageCount = 0;
        this._document = document;
        this._crossReference = document._crossReference;
        var sectionDictionary = new _PdfDictionary(this._crossReference);
        sectionDictionary.update('Type', _PdfName.get('Pages'));
        this._pageSettings = settings;
        _updatePageSettings(sectionDictionary, settings);
        var sectionReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(sectionReference, sectionDictionary);
        sectionDictionary.objId = sectionReference.toString();
        sectionDictionary.update('Kids', []);
        sectionDictionary.update('Count', 0);
        this._dictionary = sectionDictionary;
        this._reference = sectionReference;
        var pageCount = this._document.pageCount;
        if (pageCount === 0) {
            var parentReference = this._document._catalog._catalogDictionary._get('Pages');
            var topPagesDictionary = this._document._catalog._topPagesDictionary;
            if (topPagesDictionary) {
                if (topPagesDictionary.has('Kids')) {
                    var kids = topPagesDictionary.get('Kids');
                    if (kids) {
                        kids.push(sectionReference);
                        topPagesDictionary.update('Kids', kids);
                        sectionDictionary.update('Parent', parentReference);
                    }
                }
                else {
                    topPagesDictionary.update('Kids', [sectionReference]);
                    sectionDictionary.update('Parent', parentReference);
                }
            }
        }
        else {
            var lastPage = this._document.getPage(pageCount - 1);
            if (lastPage && lastPage._pageDictionary) {
                var parentReference = lastPage._pageDictionary._get('Parent');
                var parentDictionary = this._crossReference._fetch(parentReference);
                if (parentDictionary && parentDictionary.has('Kids')) {
                    var kids = parentDictionary.get('Kids');
                    if (kids) {
                        kids.push(sectionReference);
                        parentDictionary.update('Kids', kids);
                        sectionDictionary.update('Parent', parentReference);
                    }
                }
            }
        }
    }
    /**
     * Creates a new page and adds it to the collection.
     *
     * @returns {PdfPage} PDF page.
     *
     * ```typescript
     * // Create a new PDF document
     * let document: PdfDocument = new PdfDocument();
     * // Add a new section to the document
     * let section: PdfSection = document.addSection();
     * // Add a page to the section
     * let page: PdfPage = section.addPage();
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfSection.prototype.addPage = function () {
        var pageIndex = this._document.pageCount === 0 ? 0 : (this._document.pageCount);
        var pageDictionary = new _PdfDictionary(this._crossReference);
        pageDictionary.update('Type', _PdfName.get('Page'));
        var pageReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(pageReference, pageDictionary);
        pageDictionary.objId = pageReference.toString();
        pageDictionary.update('Parent', this._reference);
        if (this._dictionary.has('Kids')) {
            var kids = this._dictionary.get('Kids');
            if (kids) {
                kids.push(pageReference);
                this._dictionary.update('Kids', kids);
                _updatePageCount(this._dictionary, 1);
                this._document._pageCount++;
            }
        }
        else {
            this._dictionary.update('Kids', [pageReference]);
            _updatePageCount(this._dictionary, 1);
            this._document._pageCount = 1;
        }
        this._pageCount++;
        var result = new PdfPage(this._crossReference, pageIndex, pageDictionary, pageReference);
        result._pageSettings = this._pageSettings;
        result._isNew = true;
        this._document._pages.set(pageIndex, result);
        return result;
    };
    return PdfSection;
}());

/**
 * Represents a PDF document and can be used to parse an existing PDF document.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Flatten annotations and form fields
 * document.flatten = true;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfDocument = /** @class */ (function () {
    function PdfDocument(data, password) {
        this._headerSignature = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d]);
        this._startXrefSignature = new Uint8Array([0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66]);
        this._endObjSignature = new Uint8Array([0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a]);
        this._version = '';
        this._permissions = PdfPermissionFlag.default;
        this._isEncrypted = false;
        this._isUserPassword = false;
        this._hasUserPasswordOnly = false;
        this._encryptOnlyAttachment = false;
        this._encryptMetaData = false;
        this._isExport = false;
        this._allowCustomData = false;
        this._isDuplicatePage = false;
        this._isSplitDocument = false;
        this._optionalContentDictionaries = [];
        this._order = [];
        this._on = [];
        this._off = [];
        this._as = [];
        this._printLayer = [];
        this._isLoaded = true;
        if (data) {
            this._stream = new _PdfStream(typeof data === 'string' ? _decode(data) : data);
            this._fileStructure = new PdfFileStructure();
            this._crossReference = new _PdfCrossReference(this, password);
            this._pages = new Map();
            this._checkHeader();
            this._crossReference._setStartXRef(this._startXRef);
            try {
                this._parse(false);
            }
            catch (e) {
                if (e.name === 'XRefParseException') {
                    this._parse(true);
                }
                else {
                    throw e;
                }
            }
            this._crossReference._version = this._version;
        }
        else {
            this._isLoaded = false;
            this._stream = new _PdfStream([]);
            this._version = '1.4';
            this._fileStructure = new PdfFileStructure();
            this._fileStructure.isIncrementalUpdate = false;
            this._crossReference = new _PdfCrossReference(this);
            this._crossReference._version = this._version;
            this._crossReference._nextReferenceNumber = 1;
            var catalogDictionary = new _PdfDictionary(this._crossReference);
            catalogDictionary.update('Type', _PdfName.get('Catalog'));
            var catalogReference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(catalogReference, catalogDictionary);
            var trailerDictionary = new _PdfDictionary();
            trailerDictionary.update('Root', catalogReference);
            this._crossReference._trailer = trailerDictionary;
            this._crossReference._root = catalogDictionary;
            var topPagesDictionary = new _PdfDictionary(this._crossReference);
            topPagesDictionary.update('Type', _PdfName.get('Pages'));
            topPagesDictionary.update('Kids', []);
            topPagesDictionary.update('Count', 0);
            var topPagesReference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(topPagesReference, topPagesDictionary);
            catalogDictionary.update('Pages', topPagesReference);
            this._catalog = new _PdfCatalog(this._crossReference);
            this._pages = new Map();
        }
    }
    Object.defineProperty(PdfDocument.prototype, "_allowImportCustomData", {
        get: function () {
            return this._allowCustomData;
        },
        set: function (value) {
            this._allowCustomData = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocument.prototype, "_linearization", {
        get: function () {
            if (!this._linear) {
                var value = void 0;
                try {
                    value = new _Linearization(this._stream);
                }
                catch (err) { } // eslint-disable-line
                this._linear = value;
            }
            return this._linear;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocument.prototype, "_startXRef", {
        get: function () {
            var stream = this._stream;
            var startXRef = 0;
            if (this._linearization && this._linearization.isValid) {
                stream.reset();
                if (this._find(stream, this._endObjSignature)) {
                    startXRef = stream.position + 6 - stream.start;
                }
            }
            else {
                var step = 1024;
                var startXRefLength = this._startXrefSignature.length;
                var found = false;
                var position = stream.end;
                while (!found && position > 0) {
                    position -= step - startXRefLength;
                    if (position < 0) {
                        position = 0;
                    }
                    stream.position = position;
                    found = this._find(stream, this._startXrefSignature, step, true);
                }
                if (found) {
                    stream.skip(9);
                    var ch = void 0;
                    do {
                        ch = stream.getByte();
                    } while (_isWhiteSpace(ch));
                    var str = '';
                    while (ch >= 0x20 && ch <= 0x39) {
                        str += String.fromCharCode(ch);
                        ch = stream.getByte();
                    }
                    startXRef = parseInt(str, 10);
                    if (isNaN(startXRef)) {
                        startXRef = 0;
                    }
                }
            }
            return startXRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocument.prototype, "isEncrypted", {
        /**
         * Gets a value indicating whether the document is encrypted. (Read Only).
         *
         * @returns {boolean} A boolean value indicates whether the document is encrypted.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets a value indicating whether the document is encrypted.
         * let isEncrypted: boolean = document.isEncrypted;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._isEncrypted;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocument.prototype, "isUserPassword", {
        /**
         * Gets a value indicating whether the document is decrypted using the user password. (Read only).
         *
         * @returns {boolean} A boolean value indicates whether the document is decrypted using the user password.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets a value indicating whether the document is decrypted using the user password
         * let isUserPassword: boolean = document.isUserPassword;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._isUserPassword;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocument.prototype, "pageCount", {
        /**
         * Gets the page count (Read only).
         *
         * @returns {number} Number of pages
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the page count
         * let count: number = document.pageCount;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._pageCount === 'undefined') {
                this._pageCount = 0;
                if (this._linearization && this._linearization.isValid) {
                    this._pageCount = this._linearization.pageCount;
                }
                else {
                    this._pageCount = this._catalog.pageCount;
                }
            }
            return this._pageCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocument.prototype, "form", {
        /**
         * Gets the PDF form fields included in the document (Read only).
         *
         * @returns {PdfForm} Form object
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access loaded form
         * let form: PdfForm = document.form;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (typeof this._form === 'undefined') {
                this._form = new PdfForm(this._catalog.acroForm, this._crossReference);
            }
            return this._form;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocument.prototype, "flatten", {
        /**
         * Gets the boolean flag to flatten the annotations and form fields.
         *
         * @returns {boolean} Flag to flatten
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the flatten value applied
         * let flatten: boolean = document.flatten;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._flatten;
        },
        /**
         * Sets the boolean flag to flatten the annotations and form fields.
         *
         * @param {boolean} value to flatten
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Flatten PDF annotations and form fields
         * document.flatten = true;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._flatten = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocument.prototype, "permissions", {
        /**
         * Gets the permission flag of the PDF document (Read only).
         *
         * @returns {PdfPermissionFlag} permission flag. Default value is PdfPermissionFlag.default.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Gets the permission flag
         * let permission: PdfPermissionFlag = document.permissions;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._crossReference) {
                var flag = this._crossReference._permissionFlags;
                if (typeof flag !== 'undefined') {
                    this._permissions = (flag & ~-3904);
                }
            }
            return this._permissions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocument.prototype, "bookmarks", {
        /**
         * Gets the bookmarks (Read only).
         *
         * @returns {PdfBookmarkBase} Bookmarks.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var catalog = this._catalog;
            if (catalog) {
                if (catalog._catalogDictionary.has('Outlines')) {
                    var reference = catalog._catalogDictionary._get('Outlines');
                    var outlines = catalog._catalogDictionary.get('Outlines');
                    if (outlines) {
                        this._bookmarkBase = new PdfBookmarkBase(outlines, this._crossReference);
                        this._bookmarkBase._reference = reference;
                        if (outlines.has('First')) {
                            this._bookmarkBase._reproduceTree();
                        }
                    }
                }
                else {
                    var outlines = new _PdfDictionary(this._crossReference);
                    var reference = this._crossReference._getNextReference();
                    this._crossReference._cacheMap.set(reference, outlines);
                    catalog._catalogDictionary.update('Outlines', reference);
                    this._crossReference._allowCatalog = true;
                    this._bookmarkBase = new PdfBookmarkBase(outlines, this._crossReference);
                    this._bookmarkBase._reference = reference;
                }
            }
            return this._bookmarkBase;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocument.prototype, "fileStructure", {
        /**
         * Gets the internal structure of the PDF document.
         *
         * @returns {PdfFileStructure} The internal structure of the PDF document.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the internal file structure of the PDF document
         * let fileStructure: PdfFileStructure = document.fileStructure;
         * // Get the cross reference type
         * let type: PdfCrossReferenceType = fileStructure.crossReferenceType;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._fileStructure;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocument.prototype, "layers", {
        /**
         * Gets the collection of `PdfLayer` from the document.
         *
         * @returns {PdfLayerCollection} Layer collection.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the collection of layers in the document
         * let layers: PdfLayerCollection = document.layers;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (!this._layers) {
                this._layers = new PdfLayerCollection(this);
            }
            return this._layers;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the `PdfPage` at the specified index.
     *
     * @param {number} pageIndex Page index.
     * @returns {PdfPage} PDF page at the specified index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfDocument.prototype.getPage = function (pageIndex) {
        if (pageIndex < 0 || pageIndex >= this.pageCount) {
            throw new Error('Invalid page index');
        }
        var cachedPage = this._pages.get(pageIndex);
        if (cachedPage) {
            return cachedPage;
        }
        var _a = this, _catalog = _a._catalog, _linearization = _a._linearization;
        var promise;
        if (_linearization && _linearization.isValid && _linearization.pageFirst === pageIndex) {
            promise = this._getLinearizationPage(pageIndex);
        }
        else {
            promise = _catalog.getPageDictionary(pageIndex);
        }
        var page = new PdfPage(this._crossReference, pageIndex, promise.dictionary, promise.reference);
        this._pages.set(pageIndex, page);
        return page;
    };
    PdfDocument.prototype.addPage = function (arg1, arg2) {
        var settings;
        var pageIndex;
        if (typeof arg2 !== 'undefined') {
            settings = arg2;
            pageIndex = arg1;
            this._checkPageNumber(pageIndex);
        }
        else if (typeof arg1 === 'undefined') {
            settings = new PdfPageSettings();
            pageIndex = this.pageCount;
        }
        else if (arg1 instanceof PdfPageSettings) {
            settings = arg1;
            pageIndex = this.pageCount;
        }
        else {
            settings = new PdfPageSettings();
            pageIndex = arg1;
            this._checkPageNumber(pageIndex);
        }
        var sectionDictionary = new _PdfDictionary(this._crossReference);
        sectionDictionary.update('Type', _PdfName.get('Pages'));
        sectionDictionary.update('Count', 1);
        _updatePageSettings(sectionDictionary, settings);
        var sectionReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(sectionReference, sectionDictionary);
        sectionDictionary.objId = sectionReference.toString();
        var pageDictionary = new _PdfDictionary(this._crossReference);
        pageDictionary.update('Type', _PdfName.get('Page'));
        var pageReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(pageReference, pageDictionary);
        pageDictionary.objId = pageReference.toString();
        pageDictionary.update('Parent', sectionReference);
        sectionDictionary.update('Kids', [pageReference]);
        if (this.pageCount === 0) {
            var parentReference = this._catalog._catalogDictionary._get('Pages');
            if (parentReference && this._catalog._topPagesDictionary) {
                var isUpdated = false;
                if (this._catalog._topPagesDictionary.has('Kids')) {
                    var kids = this._catalog._topPagesDictionary.get('Kids');
                    if (kids) {
                        kids.push(sectionReference);
                        this._catalog._topPagesDictionary.update('Kids', kids);
                        isUpdated = true;
                    }
                }
                if (!isUpdated) {
                    this._catalog._topPagesDictionary.update('Kids', [sectionReference]);
                }
                this._catalog._topPagesDictionary.update('Count', 1);
                sectionDictionary.update('Parent', parentReference);
            }
            else {
                this._catalog._catalogDictionary.update('Pages', sectionReference);
            }
            this._pages = new Map();
            this._pageCount = 1;
        }
        else {
            var lastPage_1 = this.getPage(pageIndex === this.pageCount ? (pageIndex - 1) : pageIndex);
            if (lastPage_1 && lastPage_1._pageDictionary) {
                var parentReference = lastPage_1._pageDictionary._get('Parent');
                var parentDictionary = this._crossReference._fetch(parentReference);
                if (parentDictionary && parentDictionary.has('Kids')) {
                    var kids = parentDictionary.get('Kids');
                    if (kids) {
                        if (pageIndex === this.pageCount) {
                            kids.push(sectionReference);
                        }
                        else {
                            var newKids_1 = [];
                            kids.forEach(function (entry) {
                                if (entry === lastPage_1._ref) {
                                    newKids_1.push(sectionReference);
                                }
                                newKids_1.push(entry);
                            });
                            kids = newKids_1;
                            this._updatePageCache(pageIndex);
                        }
                        parentDictionary.update('Kids', kids);
                        sectionDictionary.update('Parent', parentReference);
                        _updatePageCount(parentDictionary, 1);
                        this._pageCount = this.pageCount + 1;
                    }
                }
            }
        }
        var result = new PdfPage(this._crossReference, pageIndex, pageDictionary, pageReference);
        result._pageSettings = settings;
        result._isNew = true;
        this._pages.set(pageIndex, result);
        return result;
    };
    PdfDocument.prototype.addSection = function (settings) {
        var result;
        if (!this._isLoaded) {
            var pageSettings = settings ? settings : new PdfPageSettings();
            result = new PdfSection(this, pageSettings);
        }
        return result;
    };
    PdfDocument.prototype.removePage = function (argument) {
        var targetPage = (argument instanceof PdfPage) ? argument : this.getPage(argument);
        this._removePage(targetPage);
    };
    PdfDocument.prototype._checkPageNumber = function (index) {
        if (index < 0 || index > this.pageCount) {
            throw new Error('Index out of range');
        }
    };
    PdfDocument.prototype._updatePageCache = function (index, isIncrement) {
        if (isIncrement === void 0) { isIncrement = true; }
        var updatedData = new Map();
        for (var i = this.pageCount - 1; i >= 0; i--) {
            var page = this.getPage(i);
            if (isIncrement) {
                if (i >= index) {
                    updatedData.set(i + 1, page);
                    page._pageIndex = i + 1;
                }
                else {
                    updatedData.set(i, page);
                }
            }
            else {
                if (i > index) {
                    updatedData.set(i - 1, page);
                    page._pageIndex = i - 1;
                }
                else if (i !== index) {
                    updatedData.set(i, page);
                }
            }
        }
        this._pages = updatedData;
        if (!isIncrement) {
            this._pageCount = this._pages.size;
        }
    };
    PdfDocument.prototype._removePage = function (pageToRemove) {
        var bookMarkMap = this._parseBookmarkDestination();
        if (bookMarkMap && bookMarkMap.has(pageToRemove)) {
            var bookmarks = bookMarkMap.get(pageToRemove);
            if (bookmarks) {
                for (var i = 0; i < bookmarks.length; i++) {
                    var bookmark = bookmarks[Number.parseInt(i.toString(), 10)];
                    if (bookmark) {
                        var bookmarkDictionary = bookmark._dictionary;
                        if (bookmarkDictionary) {
                            if (bookmarkDictionary.has('A')) {
                                bookmarkDictionary.update('A', null);
                            }
                            bookmarkDictionary.update('Dest', null);
                        }
                    }
                }
            }
        }
        this._removePageTemplates(pageToRemove);
        for (var i = this.form.count - 1; i >= 0; --i) {
            var field = this.form.fieldAt(i);
            if (field && field.page === pageToRemove) {
                this.form.removeFieldAt(i);
            }
        }
        this._updatePageCache(pageToRemove._pageIndex, false);
        this._removeParent(pageToRemove._ref, pageToRemove._pageDictionary);
        if (this._crossReference._cacheMap.has(pageToRemove._ref)) {
            pageToRemove._pageDictionary._updated = false;
        }
        if (this.pageCount === 0) {
            this._catalog._topPagesDictionary.update('Kids', []);
        }
    };
    PdfDocument.prototype._removeParent = function (referenceToRemove, dictionary) {
        if (dictionary.has('Parent')) {
            var parentReference = dictionary._get('Parent');
            var parentDictionary = this._crossReference._fetch(parentReference);
            if (parentDictionary && parentDictionary.has('Kids')) {
                var kids = parentDictionary.get('Kids');
                if (_isNullOrUndefined(kids) && kids.length === 1 && parentDictionary && parentDictionary.get('Type').name === 'Pages') {
                    this._removeParent(parentReference, parentDictionary);
                }
                else {
                    kids = kids.filter(function (item) { return item !== referenceToRemove; });
                    parentDictionary.update('Kids', kids);
                    _updatePageCount(parentDictionary, -1);
                }
            }
        }
    };
    PdfDocument.prototype._parseBookmarkDestination = function () {
        var current = this.bookmarks;
        if (typeof this._bookmarkHashTable === 'undefined' && current) {
            this._bookmarkHashTable = new Map();
            var stack = [];
            var nodeInformation = { index: 0, kids: current._bookMarkList };
            do {
                for (; nodeInformation.index < nodeInformation.kids.length;) {
                    current = nodeInformation.kids[nodeInformation.index];
                    var namedDestination = current.namedDestination;
                    if (namedDestination) {
                        if (namedDestination.destination) {
                            var page = namedDestination.destination.page;
                            var list = this._bookmarkHashTable.get(page);
                            if (!list) {
                                list = [];
                            }
                            list.push(current);
                            this._bookmarkHashTable.set(page, list);
                        }
                    }
                    else {
                        var destination = current.destination;
                        if (destination) {
                            var page = destination.page;
                            var list = this._bookmarkHashTable.get(page);
                            if (!list) {
                                list = [];
                            }
                            list.push(current);
                            this._bookmarkHashTable.set(page, list);
                        }
                    }
                    nodeInformation.index += 1;
                    if (current.count > 0) {
                        stack.push(nodeInformation);
                        nodeInformation = { index: 0, kids: current._bookMarkList };
                        continue;
                    }
                }
                if (stack.length > 0) {
                    nodeInformation = stack.pop();
                    while (nodeInformation.index === nodeInformation.kids.length && stack.length > 0) {
                        nodeInformation = stack.pop();
                    }
                }
            } while (nodeInformation.index < nodeInformation.kids.length);
        }
        return this._bookmarkHashTable;
    };
    PdfDocument.prototype._removePageTemplates = function (page) {
        var dictionary;
        if (this._catalog._catalogDictionary.has('Names')) {
            dictionary = this._catalog._catalogDictionary.get('Names');
            if (dictionary) {
                this._removeInternalTemplates(dictionary, 'Pages', page);
                this._removeInternalTemplates(dictionary, 'Templates', page);
            }
        }
    };
    PdfDocument.prototype._removeInternalTemplates = function (dictionary, key, page) {
        if (dictionary.has(key)) {
            var namedObject = dictionary.get(key);
            if (namedObject && namedObject.has('Names')) {
                var nameCollection = namedObject.getArray('Names');
                if (nameCollection && nameCollection.length > 0) {
                    var namedPageCollection = this._getUpdatedPageTemplates(nameCollection, page);
                    var namedPageDictionary = new _PdfDictionary(this._crossReference);
                    namedPageDictionary.update('Names', namedPageCollection);
                    var reference = this._crossReference._getNextReference();
                    this._crossReference._cacheMap.set(reference, namedPageDictionary);
                    namedPageDictionary.objId = reference.toString();
                    dictionary.update(key, reference);
                }
            }
        }
    };
    PdfDocument.prototype._getUpdatedPageTemplates = function (namedPages, page) {
        if (namedPages.length > 0) {
            for (var i = 1; i <= namedPages.length; i = i + 2) {
                var pageDictionary = namedPages[Number.parseInt(i.toString(), 10)];
                if (pageDictionary && page._pageDictionary === pageDictionary) {
                    namedPages.pop();
                    namedPages.pop();
                    return namedPages;
                }
            }
        }
        return namedPages;
    };
    /**
     * Reorders the pages in the PDF document.
     *
     * @param {number[]} orderArray The page sequence to arrange the pages.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Reorders the pages in the PDF document
     * document.reorderPages([3, 2, 1]);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfDocument.prototype.reorderPages = function (orderArray) {
        var _this = this;
        orderArray.forEach(function (pageNumber) {
            _this._checkPageNumber(pageNumber);
        });
        var sortedArray = this._sortedArray(orderArray);
        var ascendingOrder = orderArray.slice().sort(function (a, b) { return a - b; });
        var inputArray = Array.from({ length: this.pageCount }, function (_, i) { return i; });
        var pagesToRemove = inputArray.filter(function (element) { return sortedArray.indexOf(element) === -1; });
        for (var i = pagesToRemove.length - 1; i >= 0; i--) {
            this.removePage(pagesToRemove[Number.parseInt(i.toString(), 10)]);
        }
        var newkids = [];
        var newPages = new Map();
        var parentReference = this._catalog._catalogDictionary._get('Pages');
        var _loop_1 = function (i) {
            var indexPage = this_1.getPage(ascendingOrder.indexOf(sortedArray[Number.parseInt(i.toString(), 10)]));
            indexPage._pageIndex = i;
            newPages.set(i, indexPage);
            var sectionDictionary = new _PdfDictionary(this_1._crossReference);
            sectionDictionary.update('Type', _PdfName.get('Pages'));
            sectionDictionary.update('Count', 1);
            sectionDictionary.update('Parent', parentReference);
            var sectionReference = this_1._crossReference._getNextReference();
            sectionDictionary.objId = sectionReference.toString();
            sectionDictionary.update('Kids', [indexPage._ref]);
            newkids.push(sectionReference);
            var parentDictionary = indexPage._pageDictionary.get('Parent');
            while (parentDictionary && parentDictionary.get('Type').name === 'Pages') {
                parentDictionary.forEach(function (key, value) {
                    switch (key) {
                        case 'Parent':
                        case 'Kids':
                        case 'Type':
                        case 'Count':
                            break;
                        case 'Resources':
                            _this._cloneResources(parentDictionary.get('Resources'), sectionDictionary);
                            break;
                        default:
                            if (!sectionDictionary.has(key)) {
                                sectionDictionary.update(key, value);
                            }
                            break;
                    }
                });
                if (parentDictionary.has('Parent')) {
                    parentDictionary = parentDictionary.get('Parent');
                }
                else {
                    break;
                }
            }
            this_1._crossReference._cacheMap.set(sectionReference, sectionDictionary);
            var pageSection = this_1._crossReference._fetch(indexPage._ref);
            pageSection.update('Parent', sectionReference);
        };
        var this_1 = this;
        for (var i = 0; i < sortedArray.length; i++) {
            _loop_1(i);
        }
        this._pages = newPages;
        if (this._catalog) {
            var parentDictionary = this._catalog._topPagesDictionary;
            if (parentDictionary && parentDictionary.has('Kids')) {
                var kids = parentDictionary.get('Kids');
                kids = newkids;
                parentDictionary.update('Kids', kids);
            }
        }
    };
    PdfDocument.prototype._sortedArray = function (order) {
        var sortedArray = [];
        order.forEach(function (num) {
            if (sortedArray.indexOf(num) === -1) {
                sortedArray.push(num);
            }
        });
        return sortedArray;
    };
    PdfDocument.prototype._cloneResources = function (source, target) {
        var _this = this;
        if (!target.has('Resources')) {
            target.update('Resources', source);
        }
        else {
            var resourceDictionary_1 = target.get('Resources');
            source.forEach(function (key, value) {
                if (resourceDictionary_1.has(key)) {
                    _this._cloneInnerResources(key, value, resourceDictionary_1);
                }
                else {
                    resourceDictionary_1.update(key, value);
                }
            });
        }
    };
    PdfDocument.prototype._cloneInnerResources = function (key, value, resourceDictionary) {
        if (value instanceof _PdfDictionary) {
            var oldObject_1 = resourceDictionary.get(key);
            if (oldObject_1) {
                var hasNew_1 = false;
                oldObject_1.forEach(function (innerKey, innerValue) {
                    if (!oldObject_1.has(innerKey)) {
                        oldObject_1.update(innerKey, innerValue);
                        hasNew_1 = true;
                    }
                });
                if (hasNew_1) {
                    resourceDictionary._updated = true;
                }
            }
            else {
                resourceDictionary.update(key, value);
            }
        }
        else if (Array.isArray(value)) {
            var oldArray_1 = resourceDictionary.get(key); // eslint-disable-line
            if (oldArray_1) {
                var hasNew_2 = false;
                value.forEach(function (entry) {
                    if (oldArray_1.indexOf(entry) === -1) {
                        oldArray_1.push(entry);
                        hasNew_2 = true;
                    }
                });
                if (hasNew_2) {
                    resourceDictionary._updated = true;
                }
            }
            else {
                resourceDictionary.update(key, value);
            }
        }
    };
    PdfDocument.prototype.save = function (filename) {
        if (!this._isLoaded && this.pageCount === 0) {
            this.addSection().addPage();
        }
        this._doPostProcess(this._flatten);
        if (typeof filename === 'string') {
            Save.save(filename, new Blob([this._crossReference._save()], { type: 'application/pdf' }));
        }
        else {
            return this._crossReference._save();
        }
    };
    /**
     * Saves the document to the specified output stream and return the stream as Blob.
     *
     * @returns {Promise<{ blobData: Blob }>} Saved PDF data as `Blob`.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Save the document
     * let data: Promise<{ blobData: Blob }> = document.saveAsBlob();
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfDocument.prototype.saveAsBlob = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var obj = { blobData: new Blob([_this._crossReference._save()], { type: 'application/pdf' }) };
            resolve(obj);
        });
    };
    PdfDocument.prototype.exportAnnotations = function (arg1, arg2) {
        this._isExport = true;
        this._doPostProcessOnAnnotations();
        var helper;
        var settings;
        if (arg1 && arg1 instanceof PdfAnnotationExportSettings) {
            settings = arg1;
        }
        else if (arg2 && arg2 instanceof PdfAnnotationExportSettings) {
            settings = arg2;
        }
        if (settings) {
            if (settings.dataFormat === DataFormat.xfdf) {
                helper = new _XfdfDocument();
            }
            else if (settings.dataFormat === DataFormat.json) {
                helper = new _JsonDocument();
            }
            else if (settings.dataFormat === DataFormat.fdf) {
                helper = new _FdfDocument();
            }
            else {
                return undefined;
            }
            helper.exportAppearance = settings.exportAppearance;
        }
        else {
            helper = new _XfdfDocument();
        }
        var result = helper._exportAnnotations(this);
        if (arg1 && typeof arg1 === 'string') {
            Save.save(arg1, new Blob([result], { type: 'text/plain' }));
        }
        else {
            return result;
        }
    };
    PdfDocument.prototype.exportFormData = function (arg1, arg2) {
        this._doPostProcessOnFormFields();
        var helper;
        var settings;
        if (arg1 && arg1 instanceof PdfFormFieldExportSettings) {
            settings = arg1;
        }
        else if (arg2 && arg2 instanceof PdfFormFieldExportSettings) {
            settings = arg2;
        }
        if (settings) {
            if (settings.dataFormat === DataFormat.xfdf) {
                helper = new _XfdfDocument(settings.exportName);
            }
            else if (settings.dataFormat === DataFormat.json) {
                helper = new _JsonDocument(settings.exportName);
            }
            else if (settings.dataFormat === DataFormat.fdf) {
                helper = new _FdfDocument(settings.exportName);
            }
            else if (settings.dataFormat === DataFormat.xml) {
                helper = new _XmlDocument(settings.exportName);
            }
            else {
                return undefined;
            }
            helper._asPerSpecification = settings.asPerSpecification;
        }
        else {
            helper = new _XfdfDocument();
            helper._asPerSpecification = false;
        }
        if (arg1 && typeof arg1 === 'string') {
            Save.save(arg1, new Blob([helper._exportFormFields(this)], { type: 'text/plain' }));
        }
        else {
            return helper._exportFormFields(this);
        }
    };
    PdfDocument.prototype.importAnnotations = function (data, dataFormat) {
        if (dataFormat === DataFormat.xfdf) {
            var xfdf = new _XfdfDocument();
            xfdf._importAnnotations(this, (typeof data === 'string') ? _decode(data) : data);
        }
        else if (dataFormat === DataFormat.json) {
            var json = new _JsonDocument();
            json._importAnnotations(this, (typeof data === 'string') ? _decode(data) : data);
        }
        else if (dataFormat === DataFormat.fdf) {
            var fdf = new _FdfDocument();
            fdf._importAnnotations(this, (typeof data === 'string') ? _decode(data) : data);
        }
    };
    PdfDocument.prototype.importFormData = function (data, dataFormat) {
        if (this.form.count > 0) {
            if (dataFormat === DataFormat.xfdf) {
                var xfdf = new _XfdfDocument();
                xfdf._importFormData(this, (typeof data === 'string') ? _decode(data) : data);
            }
            else if (dataFormat === DataFormat.json) {
                var json = new _JsonDocument();
                json._importFormData(this, (typeof data === 'string') ? _decode(data) : data);
            }
            else if (dataFormat === DataFormat.fdf) {
                var fdf = new _FdfDocument();
                fdf._importFormData(this, (typeof data === 'string') ? _decode(data) : data);
            }
            else if (dataFormat === DataFormat.xml) {
                var xml = new _XmlDocument();
                xml._importFormData(this, (typeof data === 'string') ? _decode(data) : data);
            }
        }
    };
    /**
     * Disposes the current instance of `PdfDocument` class.
     *
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfDocument.prototype.destroy = function () {
        if (this._crossReference) {
            this._crossReference._destroy();
            this._crossReference = undefined;
        }
        if (this._catalog) {
            this._catalog._destroy();
            this._catalog = undefined;
        }
        this._endObjSignature = undefined;
        this._headerSignature = undefined;
        if (this._pages && this._pages.size > 0) {
            this._pages.forEach(function (value) {
                value._destroy();
            });
        }
        if (this._pages) {
            this._pages.clear();
            this._pages = undefined;
        }
        this._startXrefSignature = undefined;
        this._stream = undefined;
        this._form = undefined;
        _clearPrimitiveCaches();
        if (this._mergeHelperCache) {
            if (this._mergeHelperCache.size > 0) {
                this._mergeHelperCache.forEach(function (value) {
                    if (value) {
                        value._objectDispose();
                    }
                });
            }
            this._mergeHelperCache.clear();
            this._mergeHelperCache = undefined;
        }
    };
    Object.defineProperty(PdfDocument.prototype, "_destinationCollection", {
        get: function () {
            if (this._namedDestinationCollection === null || typeof this._namedDestinationCollection === 'undefined') {
                if (this._catalog._catalogDictionary.has('Names')) {
                    var names = this._catalog._catalogDictionary.get('Names');
                    this._namedDestinationCollection = new _PdfNamedDestinationCollection(names, this._crossReference);
                }
                else {
                    this._namedDestinationCollection = new _PdfNamedDestinationCollection();
                }
            }
            return this._namedDestinationCollection;
        },
        enumerable: true,
        configurable: true
    });
    PdfDocument.prototype._getLinearizationPage = function (pageIndex) {
        var _a = this, _catalog = _a._catalog, _linearization = _a._linearization, _crossReference = _a._crossReference;
        var ref = _PdfReference.get(_linearization.objectNumberFirst, 0);
        try {
            var obj = _crossReference._fetch(ref); // eslint-disable-line
            if (obj instanceof _PdfDictionary) {
                var type = obj.get('Type');
                if (_isName(type, 'Page') || (!obj.has('Type') && !obj.has('Kids'))) {
                    if (!_catalog.pageKidsCountCache.has(ref)) {
                        _catalog.pageKidsCountCache.put(ref, 1);
                    }
                    if (!_catalog.pageIndexCache.has(ref)) {
                        _catalog.pageIndexCache.put(ref, 0);
                    }
                    return { dictionary: obj, reference: ref };
                }
            }
            throw new FormatError('The Linearization dictionary does not point to a valid Page dictionary.');
        }
        catch (reason) {
            return _catalog.getPageDictionary(pageIndex);
        }
    };
    PdfDocument.prototype._checkHeader = function () {
        var stream = this._stream;
        stream.reset();
        if (!this._find(stream, this._headerSignature)) {
            return;
        }
        stream.moveStart();
        var version = '';
        var ch = stream.getByte();
        while (ch > 0x20) {
            if (version.length >= 12) {
                break;
            }
            version += String.fromCharCode(ch);
            ch = stream.getByte();
        }
        if (!this._version) {
            this._version = version.substring(5);
        }
    };
    PdfDocument.prototype._parse = function (recoveryMode) {
        this._crossReference._parse(recoveryMode);
        this._catalog = new _PdfCatalog(this._crossReference);
        if (this._catalog.version) {
            this._version = this._catalog.version;
        }
    };
    PdfDocument.prototype._find = function (stream, signature, limit, backwards) {
        if (limit === void 0) { limit = 1024; }
        if (backwards === void 0) { backwards = false; }
        var signatureLength = signature.length;
        var scanBytes = stream.peekBytes(limit);
        var scanLength = scanBytes.length - signatureLength;
        if (scanLength <= 0) {
            return false;
        }
        if (backwards) {
            var signatureEnd = signatureLength - 1;
            var position = scanBytes.length - 1;
            while (position >= signatureEnd) {
                var j = 0;
                while (j < signatureLength && scanBytes[position - j] === signature[signatureEnd - j]) {
                    j++;
                }
                if (j >= signatureLength) {
                    stream.position += position - signatureEnd;
                    return true;
                }
                position--;
            }
        }
        else {
            var position = 0;
            while (position <= scanLength) {
                var j = 0;
                while (j < signatureLength && scanBytes[position + j] === signature[j]) { // eslint-disable-line
                    j++;
                }
                if (j >= signatureLength) {
                    stream.position += position;
                    return true;
                }
                position++;
            }
        }
        return false;
    };
    PdfDocument.prototype._doPostProcess = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        this._doPostProcessOnFormFields(isFlatten);
        this._doPostProcessOnAnnotations(isFlatten);
    };
    PdfDocument.prototype._doPostProcessOnFormFields = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        if (this._catalog._catalogDictionary.has('AcroForm')) {
            this.form._doPostProcess(isFlatten);
            if (isFlatten) {
                var formObject = this._catalog._catalogDictionary.getRaw('AcroForm');
                var dictionary = new _PdfDictionary(this._crossReference);
                dictionary._updated = true;
                if (formObject instanceof _PdfReference) {
                    this._crossReference._cacheMap.set(formObject, dictionary);
                }
                else {
                    this.form._dictionary = dictionary;
                    this._crossReference._allowCatalog = true;
                }
                this.form._clear();
            }
            if (this.form._isDefaultAppearance) {
                this.form._dictionary.update('NeedAppearances', this.form._isDefaultAppearance);
            }
            else if (!this.form._isDefaultAppearance && this.form._dictionary.has('NeedAppearances') && this.form._isNeedAppearances) {
                this.form._dictionary.update('NeedAppearances', false);
            }
            else if (!this.form._isDefaultAppearance && this.form._dictionary.has('NeedAppearances')) {
                this.form._dictionary.update('NeedAppearances', this.form.needAppearances);
            }
        }
    };
    PdfDocument.prototype._doPostProcessOnAnnotations = function (isFlatten) {
        if (isFlatten === void 0) { isFlatten = false; }
        for (var i = 0; i < this.pageCount; i++) {
            var page = this.getPage(i);
            page.annotations._isExport = this._isExport;
            page.annotations._doPostProcess(isFlatten);
            if (isFlatten) {
                if (page._pageDictionary.has('Annots')) {
                    delete page._pageDictionary._map.Annots;
                    page._pageDictionary._updated = true;
                }
                page.annotations._clear();
            }
        }
    };
    PdfDocument.prototype._addWatermarkText = function () {
        if (this.pageCount > 0) {
            for (var index = 0; index < this._pageCount; index++) {
                var page = this.getPage(index);
                if (page) {
                    try {
                        var graphics = page.graphics;
                        graphics.save();
                        graphics.setTransparency(0.20);
                        graphics.drawRectangle(0, 0, page.size[0], 33.75, new PdfBrush([255, 255, 255]));
                        graphics.restore();
                        graphics.save();
                        graphics.setTransparency(0.50);
                        var font = new PdfStandardFont(PdfFontFamily.helvetica, 12, PdfFontStyle.regular);
                        var format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
                        graphics.drawString('Created with a trial version of Syncfusion Essential PDF', font, [0, 0, page.size[0], 33.75], null, new PdfBrush([0, 0, 0]), format);
                        graphics.restore();
                    }
                    catch (e) { } // eslint-disable-line
                }
            }
        }
    };
    PdfDocument.prototype.importPageRange = function (sourceDocument, startIndex, endIndex, options) {
        if (startIndex > endIndex || startIndex >= sourceDocument.pageCount) {
            throw new Error('The start index is greater then the end index, which might indicate the error in the program.');
        }
        this._importPages(sourceDocument, startIndex, endIndex, options);
    };
    PdfDocument.prototype._importPages = function (sourceDocument, startIndex, endIndex, options) {
        var sourceOCProperties;
        var correspondancePagecount = 0;
        var ocProperties;
        if (typeof options !== 'undefined' && typeof options.targetIndex === 'number') {
            if (options.targetIndex > this.pageCount) {
                throw new Error('The target index is out of range.');
            }
            this._targetIndex = options.targetIndex;
        }
        var pageReference = new Map();
        if (!this._isDuplicatePage) {
            for (var index = 0; index < sourceDocument.pageCount; index++) {
                var sourcepage = sourceDocument.getPage(index);
                pageReference.set(sourcepage._pageDictionary, null);
            }
        }
        var helper;
        if (!this._mergeHelperCache) {
            this._mergeHelperCache = new Map();
        }
        if (!sourceDocument._uniqueID) {
            sourceDocument._uniqueID = _getNewGuidString();
        }
        if (this._mergeHelperCache.has(sourceDocument._uniqueID)) {
            helper = this._mergeHelperCache.get(sourceDocument._uniqueID);
        }
        else {
            helper = new _PdfMergeHelper(this._crossReference, this, sourceDocument, pageReference, options);
            this._mergeHelperCache.set(sourceDocument._uniqueID, helper);
        }
        var isLayersPresent = false;
        if ((!this._isDuplicatePage && sourceDocument._catalog._catalogDictionary.has('OCProperties')) || (typeof options !== 'undefined' && !options.optimizeResources)) {
            isLayersPresent = true;
            sourceOCProperties = sourceDocument._catalog._catalogDictionary.get('OCProperties');
            ocProperties = new _PdfDictionary(this._crossReference);
            helper._writeObject(sourceDocument, ocProperties, sourceOCProperties, sourceOCProperties, 'OCProperties', null, null);
            ocProperties._updated = true;
        }
        for (var i = startIndex; i <= endIndex; i++) {
            var page = sourceDocument.getPage(i);
            sourceDocument.form._doPostProcess(sourceDocument.flatten, page);
            if (page.annotations.count > 0) {
                page.annotations._doPostProcess(sourceDocument.flatten);
                if (sourceDocument.flatten) {
                    if (page._pageDictionary.has('Annots')) {
                        delete page._pageDictionary._map.Annots;
                        page._pageDictionary._updated = true;
                    }
                    page.annotations._clear();
                }
            }
            if (sourceDocument._isSplitDocument) {
                helper._importPages(page, this._targetIndex, isLayersPresent, this._isDuplicatePage, options, sourceDocument._isSplitDocument);
            }
            else {
                helper._importPages(page, this._targetIndex, isLayersPresent, this._isDuplicatePage, options);
            }
            correspondancePagecount++;
            if (typeof this._targetIndex === 'number') {
                ++this._targetIndex;
            }
        }
        if (!this._isDuplicatePage) {
            helper._fixDestinations(sourceDocument);
        }
        helper._exportBookmarks(sourceDocument, correspondancePagecount);
        helper._mergeFormFieldsWithDocument();
        if ((isLayersPresent && !this._isDuplicatePage) || (typeof options !== 'undefined' && !options.optimizeResources)) {
            helper._importLayers(ocProperties, true);
        }
        helper._objectDispose();
        this._isDuplicatePage = false;
    };
    PdfDocument.prototype.importPage = function (arg1, arg2, options) {
        if (typeof arg1 === 'number') {
            this._isDuplicatePage = true;
            if (arg2 instanceof PdfPageImportOptions) {
                this._importPages(this, arg1, arg1, arg2);
            }
            else {
                this._importPages(this, arg1, arg1);
            }
        }
        else if (arg1 instanceof PdfPage && arg2 instanceof PdfDocument) {
            var index = arg1._pageIndex;
            this.importPageRange(arg2, index, index, options);
        }
    };
    /**
     * Splitting a PDF file into individual pages.
     *
     * @returns {void} Nothing
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * document.splitEvent = documentSplitEvent;
     * // Split PDF document into individual pages
     * document.split();
     * // Event to invoke while splitting PDF document data
     * function documentSplitEvent(sender: PdfDocument, args: PdfDocumentSplitEventArgs): void {
     *   Save.save(‘output_’ + args.splitIndex + ‘.pdf’, new Blob([args.pdfData], { type: 'application/pdf' }));
     * }
     * // Destroy the document
     * document.destroy();
     */
    PdfDocument.prototype.split = function () {
        this.splitByFixedNumber(1);
    };
    /**
     * Splits the PDF document into parts, each containing a maximum number of pages specified.
     *
     * @param {number} fixedNumber specifies the maximum number of pages in each split PDF. The default value is 1.
     * @returns {void} Nothing
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * document.splitEvent = documentSplitEvent;
     * // Split PDF document by fixed number of pages
     * document.splitByFixedNumber(1);
     * // Event to invoke while splitting PDF document data
     * function documentSplitEvent(sender: PdfDocument, args: PdfDocumentSplitEventArgs): void {
     *   Save.save(‘output_’ + args.splitIndex + ‘.pdf’, new Blob([args.pdfData], { type: 'application/pdf' }));
     * }
     * // Destroy the document
     * document.destroy();
     */
    PdfDocument.prototype.splitByFixedNumber = function (fixedNumber) {
        var pageCount = this.pageCount;
        if (this.splitEvent && pageCount >= fixedNumber && fixedNumber > 0) {
            var splitIndex = 0;
            for (var tempValue = 0; tempValue < pageCount; tempValue += fixedNumber) {
                var endIndex = Math.min(tempValue + fixedNumber - 1, pageCount - 1);
                var pdfData = this._importDocumentPages(tempValue, endIndex);
                this._invokeSplitEvent(splitIndex, pdfData);
                splitIndex++;
            }
        }
        else {
            throw new Error('Invalid split number. Split number should be greater than zero and less than or equal to page count.');
        }
    };
    /**
     * Splits the PDF document into multiple parts based on the specified page ranges.
     *
     * @param {Array<number[]>} ranges The two dimensional number array specified for start and end page indexes to split PDF documents.
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * document.splitEvent = documentSplitEvent;
     * // Split PDF document by page ranges specified
     * document.splitByPageRanges([[0, 4], [5, 9]]);
     * // Event to invoke while splitting PDF document data
     * function documentSplitEvent(sender: PdfDocument, args: PdfDocumentSplitEventArgs): void {
     *   Save.save(‘output_’ + args.splitIndex + ‘.pdf’, new Blob([args.pdfData], { type: 'application/pdf' }));
     * }
     * // Destroy the document
     * document.destroy();
     */
    PdfDocument.prototype.splitByPageRanges = function (ranges) {
        var pageCount = this.pageCount;
        if (this.splitEvent) {
            var splitIndex = 0;
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[Number.parseInt(i.toString(), 10)];
                if (Array.isArray(range) && range.length < 2) {
                    throw new Error('Invalid page range. Start and end page indexes should be specified.');
                }
                var start = range[0];
                var end = range[1];
                if (start < 0 || end < 0 || start >= pageCount || end >= pageCount || start > end) {
                    throw new Error('Invalid page range: start (${start}) and end (${end}).');
                }
                var pdfData = this._importDocumentPages(start, end);
                this._invokeSplitEvent(splitIndex, pdfData);
                splitIndex++;
            }
        }
    };
    PdfDocument.prototype._importDocumentPages = function (startIndex, endIndex) {
        this._isSplitDocument = true;
        var document = new PdfDocument();
        for (var i = startIndex; i <= endIndex; i++) {
            var page = this.getPage(i);
            document.importPage(page, this);
        }
        var result = document.save();
        document.destroy();
        return result;
    };
    PdfDocument.prototype._invokeSplitEvent = function (splitIndex, pdfData) {
        var args = new PdfDocumentSplitEventArgs(splitIndex, pdfData);
        this.splitEvent(this, args);
    };
    return PdfDocument;
}());
/**
 * Represents annotation export settings.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Sets export data format as JSON type to annotation export settings
 * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();
 * // Set the data format defined in annotation export settings
 * settings.dataFormat = DataFormat.json;
 * // Export annotations to JSON format
 * let json: Uint8Array = document.exportAnnotations(settings);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAnnotationExportSettings = /** @class */ (function () {
    function PdfAnnotationExportSettings() {
        this._format = DataFormat.xfdf;
        this._exportAppearance = false;
    }
    Object.defineProperty(PdfAnnotationExportSettings.prototype, "dataFormat", {
        /**
         * Gets the data format defined in annotation export settings.
         *
         * @returns {DataFormat} - Returns the data format.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Sets export data format as JSON type to annotation export settings
         * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();
         * // Export annotations to JSON format
         * let json: Uint8Array = document.exportAnnotations(settings);
         * // Get the data format defined in annotation export settings
         * let dataFormat: DataFormat = settings.dataFormat;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._format;
        },
        /**
         * Sets the data format defined in annotation export settings.
         *
         * @param {DataFormat} format - Specifies the data format.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Sets export data format as JSON type to annotation export settings
         * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();
         * // Set the data format defined in annotation export settings
         * settings.dataFormat = DataFormat.json;
         * // Export annotations to JSON format
         * let json: Uint8Array = document.exportAnnotations(settings);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (format) {
            this._format = format;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfAnnotationExportSettings.prototype, "exportAppearance", {
        /**
         * Gets the boolean value indicating whether the appearance of a particular object can be exported or not.
         *
         * @returns {boolean} - Returns the boolean value.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Sets the annotation export settings with enabled export appearance.
         * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();
         * // Export annotations to XFDF format
         * let xfdf: Uint8Array = document.exportAnnotations(settings);
         * // Get the boolean value indicating whether the appearance of a particular object can be exported or not
         * let appearance: boolean = settings.exportAppearance;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._exportAppearance;
        },
        /**
         * Sets the boolean value indicating whether the appearance of a particular object can be exported or not.
         *
         * @param {boolean} value - The boolean value.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Sets the annotation export settings with enabled export appearance.
         * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();
         * // Set the boolean value indicating whether the appearance of a particular object can be exported or not
         * settings.exportAppearance = true;
         * // Export annotations to XFDF format
         * let xfdf: Uint8Array = document.exportAnnotations(settings);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._exportAppearance = value;
        },
        enumerable: true,
        configurable: true
    });
    return PdfAnnotationExportSettings;
}());
/**
 * Represents form fields export settings.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Sets the form field data export settings with output data format.
 * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();
 * // Set the data format defined in form field export settings.
 * settings.dataFormat = DataFormat.json;
 * // Export form field to JSON format
 * let json: Uint8Array = document.exportFormData(settings);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfFormFieldExportSettings = /** @class */ (function () {
    function PdfFormFieldExportSettings() {
        this._format = DataFormat.xfdf;
        this._exportName = '';
        this._asPerSpecification = true;
    }
    Object.defineProperty(PdfFormFieldExportSettings.prototype, "dataFormat", {
        /**
         * Gets the data format defined in form field export settings.
         *
         * @returns {DataFormat} - Returns the data format.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Sets the form field data export settings with output data format.
         * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();
         * // Export form field to JSON format
         * let json: Uint8Array = document.exportFormData(settings);
         * // Get the data format defined in form field export settings
         * let dataFormat: DataFormat = settings.dataFormat;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._format;
        },
        /**
         * Sets the data format defined in form field export settings.
         *
         * @param {DataFormat} format - Specifies the data format.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Sets the form field data export settings with output data format.
         * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();
         * // Set the data format defined in form field export settings.
         * settings.dataFormat = DataFormat.json;
         * // Export form field to JSON format
         * let json: Uint8Array = document.exportFormData(settings);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (format) {
            this._format = format;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFormFieldExportSettings.prototype, "exportName", {
        /**
         * Gets the export name defined in form field export settings.
         *
         * @returns {string} - Returns the string value.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Sets the form field data export settings with export name.
         * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();
         * // Export form field to JSON format
         * let json: Uint8Array = document.exportFormData(settings);
         * // Get the export name defined in form field export settings
         * let name: boolean = settings.exportName;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._exportName;
        },
        /**
         * Sets the export name defined in form field export settings.
         *
         * @param {string} name - Specifies the export name of the form.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Sets the form field data export settings with export name.
         * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();
         * // Set the export name defined in form field export settings.
         * settings.exportName = ‘JobApplication’.
         * // Export form field to JSON format
         * let json: Uint8Array = document.exportFormData(settings);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (name) {
            this._exportName = name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFormFieldExportSettings.prototype, "asPerSpecification", {
        /**
         * Gets the boolean value indicating whether the data in a form field can be exported based on a certain specification.
         *
         * @returns {boolean} - Returns the boolean value.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Sets the boolean value indicating whether the data in a form field can be exported based on a certain specification.
         * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();
         * // Export form field to JSON format
         * let json: Uint8Array = document.exportFormData(settings);
         * // Get the boolean value indicating whether the data in a form field can be exported based on a certain specification.
         * let asPerSpecification: boolean = settings.asPerSpecification;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._asPerSpecification;
        },
        /**
         * Sets the boolean value indicating whether the data in a form field can be exported based on a certain specification.
         *
         * @param {boolean} value - The boolean value.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Sets the boolean value indicating whether the data in a form field can be exported based on a certain specification.
         * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();
         * // Set the boolean value indicating whether the data in a form field can be exported based on a certain specification.
         * settings.asPerSpecification = true;
         * // Export form field to JSON format
         * let json: Uint8Array = document.exportFormData(settings);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._asPerSpecification = value;
        },
        enumerable: true,
        configurable: true
    });
    return PdfFormFieldExportSettings;
}());
/**
 * The class provides various settings related to PDF pages.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Create a new PDF page settings instance
 * let pageSettings: PdfPageSettings = new PdfPageSettings();
 * // Sets the margins
 * pageSettings.margins = new PdfMargins(40);
 * // Sets the page size
 * pageSettings.size = [595, 842];
 * // Sets the page orientation
 * pageSettings.orientation = PdfPageOrientation.landscape;
 * // Add a new PDF page with page settings
 * page = document.addPage(pageSettings);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfPageSettings = /** @class */ (function () {
    /**
     * Initializes a new instance of the `PdfPageSettings` class
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Create a new PDF page settings instance
     * let pageSettings: PdfPageSettings = new PdfPageSettings();
     * // Sets the margins
     * pageSettings.margins = new PdfMargins(40);
     * // Sets the page size
     * pageSettings.size = [595, 842];
     * // Sets the page orientation
     * pageSettings.orientation = PdfPageOrientation.landscape;
     * // Add a new PDF page with page settings
     * page = document.addPage(pageSettings);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    function PdfPageSettings() {
        this._size = [595, 842];
        this._isOrientation = false;
        this._orientation = PdfPageOrientation.portrait;
        this._size = [595, 842];
        this._margins = new PdfMargins();
        this._rotation = PdfRotationAngle.angle0;
    }
    Object.defineProperty(PdfPageSettings.prototype, "orientation", {
        /**
         * Gets the orientation of the page.
         *
         * @returns {PdfPageOrientation} The orientation.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Create a new PDF page settings instance
         * let pageSettings: PdfPageSettings = new PdfPageSettings();
         * // Sets the page size
         * pageSettings.size = [842, 595];
         * // Gets the page orientation
         * let orientation: PdfPageOrientation = pageSettings.orientation;
         * // Add a new PDF page with page settings
         * page = document.addPage(pageSettings);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._orientation;
        },
        /**
         * Sets the orientation of the page.
         *
         * @param {PdfPageOrientation} value The orientation.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Create a new PDF page settings instance
         * let pageSettings: PdfPageSettings = new PdfPageSettings();
         * // Sets the page orientation
         * pageSettings.orientation = PdfPageOrientation.landscape;
         * // Add a new PDF page with page settings
         * page = document.addPage(pageSettings);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._isOrientation = true;
            if (this._orientation !== value) {
                this._orientation = value;
                this._updateSize(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPageSettings.prototype, "size", {
        /**
         * Gets the size of the page.
         *
         * @returns {number[]} The width and height of the page as number array.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Gets the width and height of the PDF page as number array
         * let size: number[] = page.size;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._size;
        },
        /**
         * Sets the width and height of the page.
         *
         * @param {number[]} value The width and height of the page as number array.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Create a new PDF page settings instance
         * let pageSettings: PdfPageSettings = new PdfPageSettings();
         * // Sets the page size
         * pageSettings.size = [595, 842];
         * // Sets the page orientation
         * pageSettings.orientation = PdfPageOrientation.landscape;
         * // Add a new PDF page with page settings
         * page = document.addPage(pageSettings);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (this._isOrientation) {
                this._updateSize(value);
            }
            else {
                this._size = value;
                this._updateOrientation();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPageSettings.prototype, "margins", {
        /**
         * Gets the margin value of the page.
         *
         * @returns {PdfMargins} PDF margins
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Create a new PDF page settings instance
         * let pageSettings: PdfPageSettings = new PdfPageSettings();
         * // Gets the margins
         * let margins: PdfMargins = pageSettings.margins;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._margins;
        },
        /**
         * Sets the margin value of the page.
         *
         * @param {PdfMargins} value PDF margins
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Create a new PDF page settings instance
         * let pageSettings: PdfPageSettings = new PdfPageSettings();
         * // Sets the margins
         * pageSettings.margins = new PdfMargins(40);
         * // Add a new PDF page with page settings
         * page = document.addPage(pageSettings);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._margins = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPageSettings.prototype, "rotation", {
        /**
         * Gets the rotation angle of the PDF page.
         *
         * @returns {PdfRotationAngle} PDF rotation angle
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Create a new PDF page settings instance
         * let pageSettings: PdfPageSettings = new PdfPageSettings();
         * // Gets the rotation angle
         * let rotation: PdfRotationAngle = pageSettings.rotation;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._rotation;
        },
        /**
         * Sets the rotation angle of the PDF page.
         *
         * @param {PdfRotationAngle} value PDF rotation angle
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Create a new PDF page settings instance
         * let pageSettings: PdfPageSettings = new PdfPageSettings();
         * // Sets the rotation angle
         * pageSettings.rotation = PdfRotationAngle.angle90;
         * // Add a new PDF page with page settings
         * page = document.addPage(pageSettings);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._rotation = value;
            if (value >= 4) {
                this._rotation = (value % 4);
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfPageSettings.prototype._updateSize = function (value) {
        var pageOrientation;
        var pageSize;
        if (Array.isArray(value)) {
            pageOrientation = this.orientation;
            pageSize = value;
        }
        else {
            pageOrientation = value;
            pageSize = this._size;
        }
        if (pageOrientation === PdfPageOrientation.portrait) {
            this._size = [Math.min(pageSize[0], pageSize[1]), Math.max(pageSize[0], pageSize[1])];
        }
        else {
            this._size = [Math.max(pageSize[0], pageSize[1]), Math.min(pageSize[0], pageSize[1])];
        }
    };
    PdfPageSettings.prototype._updateOrientation = function () {
        this._orientation = (this._size[1] >= this._size[0]) ? PdfPageOrientation.portrait : PdfPageOrientation.landscape;
    };
    PdfPageSettings.prototype._getActualSize = function () {
        var width = this._size[0] - (this._margins._left + this._margins._right);
        var height = this._size[1] - (this._margins._top + this._margins._bottom);
        return [width, height];
    };
    return PdfPageSettings;
}());
/**
 * A class representing PDF page margins.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Create a new PDF page settings instance
 * let pageSettings: PdfPageSettings = new PdfPageSettings();
 * // Sets the margins
 * pageSettings.margins = new PdfMargins(40);
 * // Sets the page size
 * pageSettings.size = [595, 842];
 * // Sets the page orientation
 * pageSettings.orientation = PdfPageOrientation.landscape;
 * // Add a new PDF page with page settings
 * page = document.addPage(pageSettings);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfMargins = /** @class */ (function () {
    function PdfMargins(all) {
        if (typeof all === 'undefined') {
            this._left = this._right = this._top = this._bottom = 40;
        }
        else {
            this._left = this._right = this._top = this._bottom = all;
        }
    }
    Object.defineProperty(PdfMargins.prototype, "left", {
        /**
         * Gets the left margin value of the page.
         *
         * @returns {number} Left margin.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Create a new PDF page settings instance
         * let pageSettings: PdfPageSettings = new PdfPageSettings();
         * // Gets the left margin
         * let left: number = pageSettings.margins.left;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._left;
        },
        /**
         * Sets the left margin value of the page.
         *
         * @param {number} value Left margin.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Create a new PDF page settings instance
         * let pageSettings: PdfPageSettings = new PdfPageSettings();
         * // Sets the margins
         * let margins: PdfMargins = new PdfMargins();
         * margins.left = 40;
         * margins.right = 40;
         * margins.top = 20;
         * margins.bottom = 20;
         * pageSettings.margins = margins;
         * // Sets the page size
         * pageSettings.size = [595, 842];
         * // Sets the page orientation
         * pageSettings.orientation = PdfPageOrientation.landscape;
         * // Add a new PDF page with page settings
         * page = document.addPage(pageSettings);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._left = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfMargins.prototype, "right", {
        /**
         * Gets the right margin value of the page.
         *
         * @returns {number} Right margin.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Create a new PDF page settings instance
         * let pageSettings: PdfPageSettings = new PdfPageSettings();
         * // Gets the right margin
         * let right: number = pageSettings.margins.right;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._right;
        },
        /**
         * Sets the right margin value of the page.
         *
         * @param {number} value - Right margin.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Create a new PDF page settings instance
         * let pageSettings: PdfPageSettings = new PdfPageSettings();
         * // Sets the margins
         * let margins: PdfMargins = new PdfMargins();
         * margins.left = 40;
         * margins.right = 40;
         * margins.top = 20;
         * margins.bottom = 20;
         * pageSettings.margins = margins;
         * // Sets the page size
         * pageSettings.size = [595, 842];
         * // Sets the page orientation
         * pageSettings.orientation = PdfPageOrientation.landscape;
         * // Add a new PDF page with page settings
         * page = document.addPage(pageSettings);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._right = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfMargins.prototype, "top", {
        /**
         * Gets the top margin value of the page.
         *
         * @returns {number} Top margin.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Create a new PDF page settings instance
         * let pageSettings: PdfPageSettings = new PdfPageSettings();
         * // Gets the top margin
         * let top: number = pageSettings.margins.top;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._top;
        },
        /**
         *Sets the top margin value of the page.
         *
         * @param {number} value Top margin.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Create a new PDF page settings instance
         * let pageSettings: PdfPageSettings = new PdfPageSettings();
         * // Sets the margins
         * let margins: PdfMargins = new PdfMargins();
         * margins.left = 40;
         * margins.right = 40;
         * margins.top = 20;
         * margins.bottom = 20;
         * pageSettings.margins = margins;
         * // Sets the page size
         * pageSettings.size = [595, 842];
         * // Sets the page orientation
         * pageSettings.orientation = PdfPageOrientation.landscape;
         * // Add a new PDF page with page settings
         * page = document.addPage(pageSettings);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._top = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfMargins.prototype, "bottom", {
        /**
         * Get the bottom margin value of the page.
         *
         * @returns {number} Bottom margin.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Create a new PDF page settings instance
         * let pageSettings: PdfPageSettings = new PdfPageSettings();
         * // Gets the bottom margin
         * let bottom: number = pageSettings.margins.bottom;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._bottom;
        },
        /**
         * Sets the bottom margin value of the page.
         *
         * @param {number} value Bottom margin.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Create a new PDF page settings instance
         * let pageSettings: PdfPageSettings = new PdfPageSettings();
         * // Sets the margins
         * let margins: PdfMargins = new PdfMargins();
         * margins.left = 40;
         * margins.right = 40;
         * margins.top = 20;
         * margins.bottom = 20;
         * pageSettings.margins = margins;
         * // Sets the page size
         * pageSettings.size = [595, 842];
         * // Sets the page orientation
         * pageSettings.orientation = PdfPageOrientation.landscape;
         * // Add a new PDF page with page settings
         * page = document.addPage(pageSettings);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._bottom = value;
        },
        enumerable: true,
        configurable: true
    });
    return PdfMargins;
}());
/**
 * Public class to provide data for the document split event, including the split index and PDF data.
 *
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * document.splitEvent = documentSplitEvent;
 * // Split PDF document by fixed number of pages
 * document.splitByFixedNumber(1);
 * // Event to invoke while splitting PDF document data
 * function documentSplitEvent(sender: PdfDocument, args: PdfDocumentSplitEventArgs): void {
 *  Save.save(‘output_’ + args.splitIndex + ‘.pdf’, new Blob([args.pdfData], { type: 'application/pdf' }));
 * }
 * // Destroy the document
 * document.destroy();
 */
var PdfDocumentSplitEventArgs = /** @class */ (function () {
    /*
     * Initializes a new instance of the `PdfDocumentSplitEventArgs` class.
     *
     * @param {number} splitIndex The fixed number to split PDF document pages. The default value is 1.
     * @param {Uint8Array} pdfData The byte array of the split PDF document data.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * document.splitEvent = documentSplitEvent;
     * // Split PDF document by fixed number of pages
     * document.splitByFixedNumber(1);
     * // Event to invoke while splitting PDF document data
     * function documentSplitEvent(sender: PdfDocument, args: PdfDocumentSplitEventArgs): void {
     *   Save.save(‘output_’ + args.splitIndex + ‘.pdf’, new Blob([args.pdfData], { type: 'application/pdf' }));
     * }
     * // Destroy the document
     * document.destroy();
     */
    function PdfDocumentSplitEventArgs(splitIndex, pdfData) {
        this._index = splitIndex;
        this._pdfData = pdfData;
    }
    Object.defineProperty(PdfDocumentSplitEventArgs.prototype, "pdfData", {
        /*
         * Gets the byte array of the PDF document data.
         *
         * @returns {Uint8Array} The byte array of the PDF document data.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * document.splitEvent = documentSplitEvent;
         * // Split PDF document by fixed number of pages
         * document.splitByFixedNumber(1);
         * // Event to invoke while splitting PDF document data
         * function documentSplitEvent(sender: PdfDocument, args: PdfDocumentSplitEventArgs): void {
         *  Save.save(‘output_’ + args.splitIndex + ‘.pdf’, new Blob([args.pdfData], { type: 'application/pdf' }));
         * }
         * // Destroy the document
         * document.destroy();
         */
        get: function () {
            return this._pdfData;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocumentSplitEventArgs.prototype, "index", {
        /*
         * Gets the split index of the PDF document.
         *
         * @returns {Uint8Array} The index that defines the number of event calls during the PDF document split.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * document.splitEvent = documentSplitEvent;
         * // Split PDF document by fixed number of pages
         * document.splitByFixedNumber(1);
         * // Event to invoke while splitting PDF document data
         * function documentSplitEvent(sender: PdfDocument, args: PdfDocumentSplitEventArgs): void {
         *  Save.save(‘output_’ + args.splitIndex + ‘.pdf’, new Blob([args.pdfData], { type: 'application/pdf' }));
         * }
         * // Destroy the document
         * document.destroy();
         */
        get: function () {
            return this._index;
        },
        enumerable: true,
        configurable: true
    });
    return PdfDocumentSplitEventArgs;
}());

var _PdfPaddings = /** @class */ (function () {
    function _PdfPaddings(left, top, right, bottom) {
        this._left = 0;
        this._right = 0;
        this._top = 0;
        this._bottom = 0;
        if (typeof left === 'undefined') {
            this._left = 0.5;
            this._right = 0.5;
            this._top = 0.5;
            this._bottom = 0.5;
        }
        else {
            this._left = left;
            this._right = right;
            this._top = top;
            this._bottom = bottom;
        }
    }
    return _PdfPaddings;
}());

/**
 * Represent the layout format class for pagination
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access the first page
 * let page: PdfPage = document.getPage(0);
 * // Create an instance of list item collection by passing the string array
 * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
 * // Create a new PDF ordered list
 * let list: PdfOrderedList = new PdfOrderedList(items);
 * // Create an instance for PDF layout format
 * let layout: PdfLayoutFormat = new PdfLayoutFormat();
 * // Set the layout format
 * layout.break = PdfLayoutBreakType.fitPage;
 * layout.layout = pdfLayoutType.paginate;
 * // Draw the items using specified bounds and layout format
 * list.draw(page, 0, 20, layout);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ````
 */
var PdfLayoutFormat = /** @class */ (function () {
    /**
     * Initializes a new instance of the `PdfLayoutFormat` class.
     *
     * @param {PdfLayoutFormat}  format Format for pagination.
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access the first page of document
     * let page: PdfPage = document.getPage(0);
     * // Add the items to list item collection by passing the array of products
     * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
     * // Create an instance of ordered list
     * let list: PdfOrderedList = new PdfOrderedList(items);
     * // Create an instance for layout format for drawing
     * let layout: PdfLayoutFormat = new PdfLayoutFormat();
     * // Set the layout format
     * layout.break = PdfLayoutBreakType.fitPage;
     * layout.layout = pdfLayoutType.paginate;
     * // Draw the items using specified bounds and layout format
     * list.draw(page, 0, 20, layout);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ````
     */
    function PdfLayoutFormat(format) {
        this._boundSet = false;
        this._paginateBounds = [];
        if (format) {
            this.break = format.break;
            this.layout = format.layout;
            this.paginateBounds = format.paginateBounds;
            this._boundSet = format._boundSet;
        }
        else {
            this.layout = PdfLayoutType.paginate;
            this.break = PdfLayoutBreakType.fitPage;
        }
    }
    Object.defineProperty(PdfLayoutFormat.prototype, "layout", {
        /**
         * Gets the layout type of the page.
         *
         * @returns {PdfLayoutType} The layout type of the page.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Add the items to list item collection by passing the array of products
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
         * // Create a ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Create a layout format for drawing
         * let pageLayout: PdfLayoutFormat = new PdfLayoutFormat();
         * // Draw the items on the page with specified bounds and layout format
         * list.draw(page, 0, 20, 500, 700, pageLayout);
         * // Retrieve the layout type applied to the page layout format
         * let layoutType: PdfLayoutType = pageLayout.layout;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._layout;
        },
        /**
         * Sets the layout type of the page.
         *
         * @param {PdfLayoutType} value the  layout type of the page.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Initialize an array of string items
         * // Add the items to list item collection by passing the array of products
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
         * // Create a new ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Create a layout format for drawing
         * let pageLayout: PdfLayoutFormat = new PdfLayoutFormat();
         * // Set the layout type to paginate for the page layout format
         * pageLayout.layout = PdfLayoutType.paginate;
         * // Draw the items on the page with specified bounds and layout format
         * list.draw(page, 0, 20, 500, 700, pageLayout);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        set: function (value) {
            this._layout = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLayoutFormat.prototype, "break", {
        /**
         * Gets the layout break type of the page.
         *
         * @returns {PdfLayoutBreakType} The layout break type of the page.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Define an array of products
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add the items to list item collection by passing the array of products
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create an instance of ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Create an layout format for drawing
         * let pageLayout: PdfLayoutFormat = new PdfLayoutFormat();
         * // Draw the items on the page
         * list.draw(page, 0, 20, 500, 700, pageLayout);
         * // Get the layout break type of the list
         * let layoutType: PdfLayoutBreakType = pageLayout.break;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._break;
        },
        /**
         * Sets the layout break type for the page.
         *
         * @param {PdfLayoutBreakType} value The layout break type to set for the page.
         * ```typescript
         * //Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Add the items to list item collection by passing the array of products
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
         * // Create a ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Create an layout format for drawing
         * let pageLayout: PdfLayoutFormat = new PdfLayoutFormat();
         * // Set the layout break type for the page
         * pageLayout.break = PdfLayoutBreakType.fitPage;
         * // Draw the items on the page
         * list.draw(page, 0, 20, 500, 700, pageLayout);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        set: function (value) {
            this._break = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLayoutFormat.prototype, "paginateBounds", {
        /**
         * Gets the paginate bounds of the page.
         *
         * @returns {number[]} Array containing the paginate bounds.
         * ```typescript
         * // Load the existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Add the items to list item collection by passing the array of products
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
         * // Create an ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Create an layout format for drawing
         * let pageLayout: PdfLayoutFormat = new PdfLayoutFormat();
         * // Draw the items on the page
         * list.draw(page, 0, 20, 500, 700, pageLayout);
         * // Get the paginate bounds
         * let layoutType: paginateBounds = pageLayout.paginateBounds;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._paginateBounds;
        },
        /**
         * Sets the paginate bounds for the page.
         *
         * @param {number[]} value Array representing the paginate bounds to set for the page.
         * ```typescript
         * // Load the existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Add the items to list item collection by passing the array of products
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
         * // Create a ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Create an layout format for page layout settings
         * let pageLayout: PdfLayoutFormat = new PdfLayoutFormat();
         * // Set the paginate bounds for the page
         * pageLayout.paginateBounds = [0, 0, 500, 700];
         * // Draw the items on the page
         * list.draw(page, 0, 20, 500, 700, pageLayout);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        set: function (value) {
            this._paginateBounds = value;
            this._boundSet = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLayoutFormat.prototype, "usePaginateBounds", {
        /**
         * Gets whether to use paginate bounds for pagination.
         *
         * @returns {boolean} Whether pagination bounds are used.
         * ```typescript
         * // Load the existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Add the items to list item collection by passing the array of products
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
         * // Create an instance of ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Create an layout format for drawing
         * let pageLayout: PdfLayoutFormat = new PdfLayoutFormat();
         * // Draw the items on the page
         * list.draw(page, 0, 20, 500, 700, pageLayout);
         * // Get whether paginate bounds are used
         * let usePaginate:  boolean = pageLayout.usePaginateBounds;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._boundSet;
        },
        enumerable: true,
        configurable: true
    });
    return PdfLayoutFormat;
}());
/**
 * Represents a class for layout result in PDF generation.
 * ```typescript
 * // Load an existing document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access the first page
 * let page: PdfPage = document.getPage(0);
 * // Add the items to list item collection by passing the array of products
 * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
 * // Create a new ordered list
 * let list: PdfOrderedList = new PdfOrderedList(items);
 * // Draw the list and access the layout result
 * let result: PdfLayoutResult = list.draw(result.page, result.bounds[0], result.bounds[1], result.bounds[2], result.bounds[3]);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfLayoutResult = /** @class */ (function () {
    /**
     * Initializes a new instance of the `PdfLayoutResult` class.
     * Remarks: Internal constructor used to create a new instance of a PDF layout result.
     *
     * @param {PdfPage} page The page where the circle annotation is to be placed.
     * @param {number[]} bounds The bounds within which the list has been drawn.
     * ```typescript
     * // Load an existing document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Add the items to list item collection by passing the array of products
     * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
     * // Create a new ordered list
     * let list: PdfOrderedList = new PdfOrderedList(items);
     * // Draw the list and access the layout result
     * let result: PdfLayoutResult = list.draw(result.page, result.bounds[0], result.bounds[1], result.bounds[2], result.bounds[3]);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    function PdfLayoutResult(page, bounds) {
        this._page = page;
        this._bounds = bounds;
    }
    Object.defineProperty(PdfLayoutResult.prototype, "Page", {
        /**
         * Gets the page associated with the layout result.
         *
         * @returns {PdfPage} value of the layout result.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Add the items to list item collection by passing the array of products
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
         * // Create a new ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Draw the list and access the layout result
         * let result: PdfLayoutResult = list.draw(result.page, result.bounds[0], result.bounds[1], result.bounds[2], result.bounds[3]);
         * // Access the page from the layout result
         * let resultPage: PdfPage = result.page;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._page;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLayoutResult.prototype, "bounds", {
        /**
         * Gets the bounds associated with the layout result.
         *
         * @returns {number[]} The bounds of the layout result.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Add the items to list item collection by passing the array of products
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
         * // Create a new ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Draw the list and access the layout result
         * let result: PdfLayoutResult = list.draw(result.page, result.bounds[0], result.bounds[1], result.bounds[2], result.bounds[3]);
         * // Access the bounds associated with layout result
         * let bounds: number[] = result.bounds;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._bounds;
        },
        enumerable: true,
        configurable: true
    });
    return PdfLayoutResult;
}());
var _PageLayoutResult = /** @class */ (function () {
    function _PageLayoutResult() {
        this.markerWrote = false;
        this.markerWidth = 0;
        this.markerX = 0;
    }
    return _PageLayoutResult;
}());
var _PdfLayoutParameters = /** @class */ (function () {
    function _PdfLayoutParameters() {
    }
    return _PdfLayoutParameters;
}());

var __extends$j = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * The 'PdfBitmap' contains methods and properties to handle the Bitmap images.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create new image object by using JPEG image data as Base64 string format
 * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
 * //Draw the image.
 * graphics.drawImage(image, 10, 20, 400, 400);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfBitmap = /** @class */ (function (_super) {
    __extends$j(PdfBitmap, _super);
    function PdfBitmap(encodedString) {
        var _this = _super.call(this) || this;
        _this._imageStatus = true;
        if (encodedString !== null && typeof encodedString !== 'undefined' && typeof encodedString === 'string') {
            _this._initializeAsync(encodedString);
        }
        else {
            _this._initializeAsync(encodedString);
        }
        return _this;
    }
    PdfBitmap.prototype._initializeAsync = function (encodedString) {
        var byteArray = new Uint8Array(encodedString.length);
        if (encodedString !== null && typeof encodedString !== 'undefined' && typeof encodedString === 'string') {
            byteArray = _decode(encodedString, false);
        }
        else if (encodedString instanceof Uint8Array) {
            byteArray = encodedString;
        }
        this._decoder = _getDecoder(byteArray);
        this.height = this._decoder._height;
        this.width = this._decoder._width;
        this._bitsPerComponent = this._decoder._bitsPerComponent;
    };
    PdfBitmap.prototype._save = function () {
        this._imageStatus = true;
        this._imageStream = this._decoder._getImageDictionary();
        if (this._decoder && this._decoder instanceof _PngDecoder) {
            var decoder = this._decoder;
            this._maskStream = decoder._maskStream;
            if (decoder._isDecode) {
                if (decoder._colorSpace) {
                    this._setColorSpace();
                }
            }
            else {
                this._setColorSpace();
            }
        }
        else {
            this._setColorSpace();
        }
    };
    PdfBitmap.prototype._setColorSpace = function () {
        var stream = this._imageStream;
        var dictionary = stream.dictionary;
        var color = dictionary.get('ColorSpace');
        var colorSpace;
        if (color.name === 'DeviceCMYK') {
            colorSpace = _PdfColorSpace.cmyk;
        }
        else if (color.name === 'DeviceGray') {
            colorSpace = _PdfColorSpace.grayScale;
        }
        if (this._decoder instanceof _PngDecoder) {
            var cs = this._decoder._colorSpace; // eslint-disable-line
            if (typeof cs !== 'undefined' && cs !== null) {
                colorSpace = _PdfColorSpace.indexed;
            }
        }
        switch (colorSpace) {
            case _PdfColorSpace.cmyk:
                dictionary.update('Decode', [1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0]);
                dictionary.update('ColorSpace', _PdfName.get('DeviceCMYK'));
                break;
            case _PdfColorSpace.grayScale:
                dictionary.update('Decode', [0.0, 1.0]);
                dictionary.update('ColorSpace', _PdfName.get('DeviceGray'));
                break;
            case _PdfColorSpace.rgb:
                dictionary.update('Decode', [0.0, 1.0, 0.0, 1.0, 0.0, 1.0]);
                dictionary.update('ColorSpace', _PdfName.get('DeviceRGB'));
                break;
            case _PdfColorSpace.indexed:
                dictionary.update('ColorSpace', this._decoder._colorSpace);
                break;
        }
    };
    return PdfBitmap;
}(PdfImage));

/**
 * Represents the items of the list.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access the first page
 * let page: PdfPage = document.getPage(0);
 * // Create an instance of list item collection by passing the string array
 * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word']);
 * // Create a new list item and add into the collection
 * items.add(new PdfListItem('PDF'));
 * // Create a new PDF ordered list
 * let list: PdfOrderedList = new PdfOrderedList(items);
 * // Draw the list items
 * list.draw(page, 0, 20);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ````
 */
var PdfListItem = /** @class */ (function () {
    /**
     * Creates a new `PdfListItem` instance with the specified text and optional settings for font, format, pen, and brush.
     *
     * @param {string} text The text content for the list item.
     * @param {object} [settings] Optional settings for the list item.
     * @param {PdfFont} [settings.font] The font used for rendering the text.
     * @param {PdfStringFormat} [settings.format] The string format used for text layout.
     * @param {PdfBrush} [settings.brush] The brush used for filling shapes or text.
     * @param {PdfPen} [settings.pen] The pen used for drawing outlines.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access the first page
     * let page: PdfPage = document.getPage(0);
     * // Create an instance of list item collection by passing the string array
     * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word']);
     * // Create a new list item
     * let item: PdfListItem = new PdfListItem('PDF', {brush: new PdfBrush([255, 0, 0])});
     * // Add the list item into the collection
     * items.add(item);
     * // Create a new PDF ordered list
     * let list: PdfOrderedList = new PdfOrderedList(items);
     * // Draw the list items
     * list.draw(page, 0, 20);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ````
     */
    function PdfListItem(text, settings) {
        this._textIndent = 0;
        if (text === null || typeof text === 'undefined') {
            throw new Error('Text cannot be null or undenfied.');
        }
        this._text = text;
        if (settings) {
            if (settings.font) {
                this._font = settings.font;
            }
            if (settings.format) {
                this._stringFormat = settings.format;
            }
            if (settings.pen) {
                this._pen = settings.pen;
            }
            if (settings.brush) {
                this._brush = settings.brush;
            }
        }
    }
    Object.defineProperty(PdfListItem.prototype, "brush", {
        /**
         * Gets the brush associated with the list item.
         *
         * @returns {PdfBrush} The brush to specify the fill color of the list item.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Create an instance of list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word']);
         * // Create a new list item
         * let item: PdfListItem = new PdfListItem('PDF', {brush: new PdfBrush([255, 0, 0])});
         * // Add the list item into the collection
         * items.add(item);
         * // Create a new PDF ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Access the brush from the list item
         * let brush: PdfBrush = item.brush;
         * // Draw the list items
         * list.draw(page, 0, 20);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._brush;
        },
        /**
         * Sets the brush associated with the list item.
         *
         * @param {PdfBrush} value The brush to specify the fill color of the list item.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Create an instance of list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word']);
         * // Create a new list item
         * let item: PdfListItem = new PdfListItem('PDF');
         * // Add the list item into the collection
         * items.add(item);
         * // Create a new PDF ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Set the fill color
         * item.brush = new PdfBrush([255, 0, 0]);
         * // Draw the list items
         * list.draw(page, 0, 20);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        set: function (value) {
            this._brush = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListItem.prototype, "pen", {
        /**
         * Gets the `PdfPen` object associated with the list item.
         *
         * @returns {PdfPen} The `PdfPen` object to specify specify stroke properties.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Create an instance of list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word']);
         * // Create a new list item
         * let item: PdfListItem = new PdfListItem('PDF', {pen: new PdfPen([255, 0, 0], 1)});
         * // Add the list item into the collection
         * items.add(item);
         * // Create a new PDF ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Access the pen from the list item
         * let pen: PdfPen = item.pen;
         * // Draw the list items
         * list.draw(page, 0, 20);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._pen;
        },
        /**
         * Sets the `Pdfpen` object associated with the list item.
         *
         * @param {PdfPen} value `PdfPen` object used to specify stroke properties.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Create an instance of list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word']);
         * // Create a new list item
         * let item: PdfListItem = new PdfListItem('PDF');
         * // Add the list item into the collection
         * items.add(item);
         * // Create a new PDF ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Set the stroke color
         * item.pen = new PdfPen([255, 0, 0], 1);
         * // Draw the list items
         * list.draw(page, 0, 20);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        set: function (value) {
            this._pen = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListItem.prototype, "font", {
        /**
         * Get the `PdfFont` object associated with the list item.
         *
         * @returns {PdfFont} The `PdfFont` object used for text rendering.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Create an instance of list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word']);
         * // Create a new list item
         * let item: PdfListItem = new PdfListItem('PDF', {pen: new PdfStandardFont(PdfFontFamily.timesRoman, 12)});
         * // Add the list item into the collection
         * items.add(item);
         * // Create a new PDF ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Access the font from the list item
         * let font: PdfFont = item.font;
         * // Draw the list items
         * list.draw(page, 0, 20);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._font;
        },
        /**
         * Sets the `PdfFont` object associated with the list item.
         *
         * @param {PdfFont} value The `PdfFont` object to be set for text rendering.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Create an instance of list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word']);
         * // Create a new list item
         * let item: PdfListItem = new PdfListItem('PDF');
         * // Add the list item into the collection
         * items.add(item);
         * // Create a new PDF ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Set the font
         * item.font = new PdfStandardFont(PdfFontFamily.timesRoman, 12);
         * // Draw the list items
         * list.draw(page, 0, 20);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        set: function (value) {
            this._font = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListItem.prototype, "stringFormat", {
        /**
         * Gets the `PdfStringFormat` object associated with the list item.
         *
         * @returns {PdfStringFormat} The `PdfStringFormat` object used to specify text formatting.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Create an instance of list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word']);
         * // Create a new list item
         * let item: PdfListItem = new PdfListItem('PDF', {format: new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom)});
         * // Add the list item into the collection
         * items.add(item);
         * // Create a new PDF ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Access the string format from the list item
         * let format: PdfStringFormat = item.stringFormat;
         * // Draw the list items
         * list.draw(page, 0, 20);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._stringFormat;
        },
        /**
         * Sets the `PdfStringFormat` object associated with the list item.
         *
         * @param {PdfStringFormat} value The`PdfStringFormat` object to be set for text formatting.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Create an instance of list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word']);
         * // Create a new list item
         * let item: PdfListItem = new PdfListItem('PDF');
         * // Add the list item into the collection
         * items.add(item);
         * // Create a new PDF ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Set the font
         * item.font = new PdfStandardFont(PdfFontFamily.timesRoman, 12);
         * // Draw the list items
         * list.draw(page, 0, 20);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        set: function (value) {
            this._stringFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListItem.prototype, "text", {
        /**
         * Gets the text content of the list item.
         *
         * @returns {string} The text content of the list item.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the first Page of the document
         * let page: PdfPage = document.getPage(0);
         * // Create an instance of an ordered list
         * let list: OrderedList =  new OrderedList();
         * // Create a list item with text 'Products'
         * let item: PdfListItem = new PdfListItem('Products');
         * // Add the item to the list collection
         * list.items.add(item1);
         * // Get the text content of the item
         * let text: string = item.text;
         * // Draw the list items on the specified page
         * list.draw(page, 10, 50. 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._text;
        },
        /**
         * Sets string format of the list item.
         *
         * @param {string} value The text content to be set.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Create an instance of list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point']);
         * // Create a new list item
         * let item: PdfListItem = new PdfListItem('Word');
         * // Add the list item into the collection
         * items.add(item);
         * // Create a new PDF ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Set the text of the list item
         * item.text = 'PDF';
         * // Draw the list items
         * list.draw(page, 0, 20);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        set: function (value) {
            this._text = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListItem.prototype, "textIndent", {
        /**
         * Gets the text indent of the list.
         *
         * @returns {number} The text indent of the list item.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Create an instance of an ordered list
         * let list: OrderedList =  new OrderedList();
         * // Create a list item with text 'Products'
         * let item: PdfListItem = new PdfListItem('Products');
         * // Add the item to the list collection
         * list.items.add(item);
         * // Get the text indent of the item
         * let textIndent: number = item.textIndent;
         * // Draw the list items on the specified page
         * list.draw(page, 10, 50. 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._textIndent;
        },
        /**
         * Sets the text indent of the list item.
         *
         * @param {number} value he text indent value to be set.
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the first Page of the document
         * let page: PdfPage = document.getPage(0);
         * // Create an instance of an ordered list
         * let list: OrderedList =  new OrderedList();
         * // Create a list item with text 'Products'
         * let item: PdfListItem = new PdfListItem('Products');
         * // Set the text indent for the item
         * item.textIndent = 30;
         * // Add the item to the list collection
         * list.items.add(item);
         * // Draw the list items on the specified page at position (10, 50)
         * list.draw(page, 10, 50. 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._textIndent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfListItem.prototype, "subList", {
        /**
         * Get the sub-list associated with the current list item.
         *
         * @returns {PdfList} The `PdfList` object representing the sub-list.
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the first Page of the document
         * let page: PdfPage = document.getPage(0);
         * // Create an instance of an ordered list
         * let list: OrderedList =  new OrderedList();
         * // Create a list item with text 'Products'
         * let item: PdfListItem = new PdfListItem('Products');
         * // Add the item to the list collection
         * list.items.add(item);
         * // create a sublist for the item
         * let sublist: OrderedList = new PdfOrderedList();
         * // Adding items to the sublist
         * subList.items.add(new PdfListItem('Sub Item 1'));
         * subList.items.add(new PdfListItem('Sub Item 2'));
         * // Set the sublist for the main list item
         * list.items._listItem[0].subList = subList;
         * // Get the sublist
         * let sublist: PdfList = list.items._listitem[0].sublist;
         * // Draw the list items on the specified page
         * list.draw(page, 10, 50. 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._subList;
        },
        /**
         * Sets the sub-list associated with the current list item.
         *
         * @param {PdfList} value The `PdfList` object to be set as the sub-list.
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the first Page of the document
         * let page: PdfPage = document.getPage(0);
         * // Create an instance of an ordered list
         * let list: OrderedList =  new OrderedList();
         * // Create a list item with text 'Products'
         * let item: PdfListItem = new PdfListItem('Products');
         * // Add the item to the list collection
         * list.items.add(item);
         * // Create a sublist for the item
         * let sublist: OrderedList = new PdfOrderedList();
         * // Adding items to the sublist
         * subList.items.add(new PdfListItem('PDF'));
         * subList.items.add(new PdfListItem('Word'));
         * subList.items.add(new PdfListItem('PPT'));
         * // Set the sublist for the main list item
         * list.items._listItem[0].subList = subList;
         * // Draw the list items on the specified page
         * list.draw(page, 10, 50. 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._subList = value;
        },
        enumerable: true,
        configurable: true
    });
    return PdfListItem;
}());
/**
 * Represents a collection of list items that can be drawn on a PDF page.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access the first page
 * let page: PdfPage = document.getPage(0);
 * // Create an instance of list item collection by passing the string array
 * let items: PdfListItemCollection = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word']);
 * // Create a new PDF ordered list
 * let list: PdfOrderedList = new PdfOrderedList(items);
 * // Draw the list items
 * list.draw(page, 0, 20);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ````
 */
var PdfListItemCollection = /** @class */ (function () {
    function PdfListItemCollection(items) {
        var _this = this;
        if (!this._listItems) {
            this._listItems = [];
        }
        if (items) {
            items.forEach(function (item) {
                _this.add(new PdfListItem(item));
            });
        }
    }
    Object.defineProperty(PdfListItemCollection.prototype, "count", {
        /**
         * Gets the count of the list item collection.
         *
         * @returns {number} The count of the list items.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Access the first page of the document
         * let page: PdfPage = document.getPage(0);
         * // Create an instance of ordered list
         * let list: PdfOrderedList = new PdfOrderedList();
         * // Initialize an array of string items
         * let products: string[] = ['Word', 'Excel', 'PDF', 'Power Point'];
         * // Add the items to list item collection by passing the array of products
         * list.items = new PdfListCollection(products);
         * / Draw the list on the page at specified bounds
         * list.draw(page,0, 10, 500, 700);
         * // Get the count of items from the list
         * let count: number = list.items.count;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._listItems.length;
        },
        enumerable: true,
        configurable: true
    });
    PdfListItemCollection.prototype.add = function (item, itemIndent) {
        if (item) {
            this._listItems.push(item);
            if (itemIndent) {
                item.textIndent = itemIndent;
            }
        }
        else {
            throw new Error('item should not be null');
        }
    };
    /**
     * Retrieves the `PdfListItem` at the specified index in the collection.
     *
     * @param {number} index The zero-based index of the item to retrieve.
     * @returns {PdfListItem} The `PdfListItem` at the specified index.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Accessing the first page of the document
     * let page: PdfPage = document.getpage(0);
     * // Create a ordered list
     * let list: PdfOrderedList = new PdfOrderedList();
     * // Initialize an array of strings
     * let products: string[] = ['Excel', 'Power Point', 'Word', 'Windows', 'MAUI'];
     * // Add the items to list item collection by passing the array of products
     * let itemCollection: PdfListItemCollection = new PdfListItemCollection(products);
     * // Retrieve a specific item from the list collection at a particular index
     * let item: PdflistItem = list.itemCollection.itemAt(1);
     * // Draw the list items on the page at specified coordinates and dimensions
     * list.draw(page, 10, 50, 500, 700);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfListItemCollection.prototype.at = function (index) {
        if (index === null) {
            throw new Error('index should not be null');
        }
        var item = this._listItems[Number.parseInt(index.toString(), 10)];
        return item;
    };
    /**
     * Removes a `PdfListItem` from the collection.
     *
     * @param {PdfListItem} item The list item to be removed from the collection.
     * @returns {void}
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(readFromResources('CircleAnnotation-Acrobat.pdf'));
     * // Access the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Create a ordered list
     * let list: PdfOrderedList = new PdfOrderedList();
     * // Initialize an array of strings
     * let products: string[] = [
     *   'PDF is a file format designed to present documents consistently across devices and platforms.',
     *   'Excel is a widely used spreadsheet application developed by Microsoft.',
     *   'PDF stands for Portable Document Format.',
     *   'PowerPoint is a presentation program developed by Microsoft for creating slideshows.',
     *   'PowerPoint is widely used in business settings for creating presentations.'
     * ];
     * // Add the items to list item collection by passing the array of products
     * let item: PdfListItemCollection = new PdfListItemCollection(products);
     * // Remove a specific item from the collection
     * let itemToRemove: PdfListItem = list.items.at(0);
     * list.items.remove(itemToRemove);
     * // Draw the list on the page at specified coordinates and dimensions
     * list.draw(page, 10, 40, 300, 500);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfListItemCollection.prototype.remove = function (item) {
        if (!item) {
            throw new Error('item should not be null');
        }
        var found = false;
        for (var i = 0; i < this._listItems.length; i++) {
            if (this._listItems[Number.parseInt(i.toString(), 10)] === item) {
                found = true;
                this._listItems.splice(Number.parseInt(i.toString(), 10), 1);
                break;
            }
        }
        if (!found) {
            throw new Error('item collection does not contain the given content');
        }
    };
    /**
     * Removes a `PdfListItem` at the specified index from the collection.
     *
     * @param {number} index The zero-based index of the item to remove.
     * @returns {void}
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(readFromResources('CircleAnnotation-Acrobat.pdf'));
     * // Access the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Create a ordered list
     * let list: PdfOrderedList = new PdfOrderedList();
     * // Initialize an array of strings
     * let products: string[] = [
     *   'PDF is a file format designed to present documents consistently across devices and platforms.',
     *   'Excel is a widely used spreadsheet application developed by Microsoft.',
     *   'PDF stands for Portable Document Format.',
     *   'PowerPoint is a presentation program developed by Microsoft for creating slideshows.',
     *   'PowerPoint is widely used in business settings for creating presentations.'
     * ];
     * // Add the items to list item collection by passing the array of products
     * let item: PdfListItemCollection = new PdfListItemCollection(products);
     * // Remove a specific item from the collection by its index
     * list.items.removeAt(1);
     * // Draw the modified list on the page at specified bounds
     * list.draw(page, 10, 40, 300, 500);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfListItemCollection.prototype.removeAt = function (index) {
        if (index < 0 || index >= this._listItems.length) {
            throw new Error('The index should be less than items count or equal to 0');
        }
        this._listItems.splice(index, 1);
    };
    /**
     * Clear the list item collection.
     *
     * @returns {void}
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(readFromResources('CircleAnnotation-Acrobat.pdf'));
     * // Access the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Create a ordered list
     * let list: PdfOrderedList = new PdfOrderedList();
     * // Initialize an array of strings
     * let products: string[] = [
     *   'PDF is a file format designed to present documents consistently across devices and platforms.',
     *   'Excel is a widely used spreadsheet application developed by Microsoft.',
     *   'PDF stands for Portable Document Format.',
     *   'PowerPoint is a presentation program developed by Microsoft for creating slideshows.',
     *   'PowerPoint is widely used in business settings for creating presentations.'
     * ];
     * // Add the items to list item collection by passing the array of products
     * let item: PdfListItemCollection = new PdfListItemCollection(products);
     * // Draw the initial list on the page at specified coordinates and dimensions
     * list.draw(page, 10, 40, 300, 500);
     * // Clear the list item collection
     * list.items.clear();
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfListItemCollection.prototype.clear = function () {
        this._listItems = [];
    };
    /**
     * Inserts a `PdfListItem` into the collection at the specified index.
     *
     * @param {number} index The zero-based index at which the item should be inserted.
     * @param {PdfListItem} item The list item to be inserted into the collection.
     * @param {number} itemIndent The indent of the list item.
     * @returns {void}
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(readFromResources('CircleAnnotation-Acrobat.pdf'));
     * // Access the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Create a ordered list
     * let list: PdfOrderedList = new PdfOrderedList();
     * // Initialize an array of strings
     * let products: string[] = [
     *   'PDF is a file format designed to present documents consistently across devices and platforms.',
     *   'Excel is a widely used spreadsheet application developed by Microsoft.',
     *   'PDF stands for Portable Document Format.',
     *   'PowerPoint is a presentation program developed by Microsoft for creating slideshows.',
     *   'PowerPoint is widely used in business settings for creating presentations.'
     * ];
     * // Add the items to list item collection by passing the array of products
     * list.items = new PdfListItemCollection(products);
     * // Create a new PdfListItem instance with some text
     * let item: PdfListItem = new PdfListItem('text');
     * // Insert the new item into the list at index 1 with an indent of 40
     * list.items.insert(1, item, 40);
     * // Draw the updated list on the page at specified coordinates and dimensions
     * list.draw(page, 10, 40, 300, 500);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfListItemCollection.prototype.insert = function (index, item, itemIndent) {
        if (index < 0 || index > this._listItems.length) {
            throw new Error('Index should be within the range of items count (inclusive).');
        }
        if (!item) {
            throw new Error('Item cannot be null.');
        }
        if (itemIndent) {
            item.textIndent = itemIndent;
        }
        this._listItems.splice(index, 0, item);
    };
    /**
     * Finds the index of a `PdfListItem` in the collection.
     *
     * @param {PdfListItem} item The list item to find in the collection.
     * @returns {number} The zero-based index of the item in the collection, or -1 if not found.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(readFromResources('CircleAnnotation-Acrobat.pdf'));
     * // Access the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Create a ordered list
     * let list: PdfOrderedList = new PdfOrderedList();
     * // Initialize an array of strings
     * let products: string[] = [
     *   'PDF is a file format designed to present documents consistently across devices and platforms.',
     *   'Excel is a widely used spreadsheet application developed by Microsoft.',
     *   'PDF stands for Portable Document Format.',
     *   'PowerPoint is a presentation program developed by Microsoft for creating slideshows.',
     *   'PowerPoint is widely used in business settings for creating presentations.'
     * ];
     * // Add the items to list item collection by passing the array of products
     * list.items = new PdfListItemCollection(products);
     * // Retrieve the first item from the collection
     * let item: PdfListItem = item._listItems[0];
     * // Find the index of the first item in the collection
     * let index: number = list.items.indexOf(item);
     * // Draw the list on the page at specified bounds
     * list.draw(page, 10, 40, 300, 500);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfListItemCollection.prototype.indexOf = function (item) {
        if (!item) {
            throw new Error('Item should be defined.');
        }
        return this._listItems.indexOf(item);
    };
    return PdfListItemCollection;
}());

var __extends$k = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Represents base class for lists.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access the first page
 * let page: PdfPage = document.getPage(0);
 * // Assign the array of string items
 * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
 * // Initialize a new brush
 * let brush: PdfBrush =  new PdfBrush([0, 255, 255])
 * // Add an item to item collection by passing the string array
 * let items: PdfListItemCollection = new PdfListItemCollection(products);
 * // Create a new instance of ordered list
 * let list: PdfList = new PdfOrderedList(items);
 * // Draw the ordered list with specified items
 * list.draw(page, 0, 20, 500, 700);
 * // Get the brush associated with the ordered list
 * let listBrush: PdfBrush = list.brush;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfList = /** @class */ (function () {
    function PdfList() {
        this._textIndent = 5;
        this._indent = 10;
        this._alignment = PdfListMarkerAlignment.left;
        this._delimiter = '.';
        this._suffix = '.';
        this._enableHierarchy = false;
        this._currentIndex = 0;
        this._size = [0, 0];
        this._defaultFont = new PdfStandardFont(PdfFontFamily.helvetica, 8);
    }
    Object.defineProperty(PdfList.prototype, "brush", {
        /**
         * Gets the `PdfBrush` object associated with the list.
         *
         * @returns {PdfBrush} The `PdfBrush` object to specify fill text rendering mode.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Initialize a new brush
         * let brush: PdfBrush =  new PdfBrush([0, 255, 255]);
         * // Add an item to item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a new instance of ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Draw the ordered list with specified items
         * list.draw(page, 0, 20, 500, 700);
         * // Get the brush associated with the ordered list
         * let listBrush: PdfBrush = list.brush;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._brush;
        },
        /**
         * Sets the `PdfBrush` object associated with the list.
         *
         * @param {PdfBrush} value The `PdfBrush` object to specify fill text rendering mode.
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add an item to item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a new Ordered list and set the brush
         * let list: PdfOrderedList = new PdfOrderedList(items, {brush: new PdfBrush([255, 0, 0])});
         * // Set fill color to the list
         * list.brush = brush;
         * // Draw the ordered list with specified items
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._brush = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfList.prototype, "pen", {
        /**
         * Gets the `PdfPen` object associated with the list.
         *
         * @returns {PdfPen} The `PdfPen` object to specify stroke properties for text rendering.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Create an instance of item collection and add the list item
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // create a new ordered list and draw the list
         * let list: PdfOrderedList = new PdfOrderedList(items, {pen: new PdfPen([0, 255, 255], 1)});
         * list.draw(page, 0, 20, 500, 700);
         * // Retrieve the pen associated with the ordered list
         * let itemPen: PdfPen = list.pen;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._pen;
        },
        /**
         * Sets the `PdfPen` object associated with the list.
         *
         * @param {PdfPen} value The `PdfPen` object to specify fill text rendering mode.
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Create an instance of item collection and add the list item
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a new pen
         * let pen: PdfPen =  new PdfPen([0, 255, 255], 1);
         * // Create a new ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Set the pen for the ordered list
         * list.pen = pen;
         * // Draw the list associated with items
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._pen = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfList.prototype, "font", {
        /**
         * Gets the font of the list item.
         *
         * @returns {PdfFont} The font used for the list items.
         * ```typescript
         * // Load the existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add an item to list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a new ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Draw the items on the page
         * list.draw(page, 0, 20, 500, 700);
         * /// Retrieve the font used for the list items
         * let itemPen: PdfFont = list.font;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._font;
        },
        /**
         * Sets the `PdfFont` object associated with the list.
         *
         * @param {PdfFont} value The `PdfPen` object to to set for the list items.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Create an instance of item collection and add the list item
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a new font for list
         * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.timesRoman, 12);
         * // Create a new ordered list with items and font
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * list.font = font;
         * // Draw the items on the page
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._font = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfList.prototype, "stringFormat", {
        /**
         * Gets the text layout format associated with the list item.
         *
         * @returns {PdfStringFormat} The `PdfStringFormat` object that specifies the text layout information.
         * ```typescript
         * // Load the existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add an items to  listitem collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a new ordered list with items
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Draw the items on the page
         * list.draw(page, 0, 20, 500, 700);
         * // Getting the text layout format used by the list items
         * let itemFormat: PdfStringFormat = list.stringFormat;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._stringFormat;
        },
        /**
         * Sets the text layout format of the list item.
         *
         * @param {PdfStringFormat} value The `PdfStringFormat` object that specifies the text layout information.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Create an instance of item collection and add the list item
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a new  format with alignment settings for list
         * let itemFormat: PdfStringFormat =  new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
         * // Add an item to list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(items);
         * // Create a ordered list with the item collection
         * let list: PdfOrderedList = new PdfOrderedList();
         * // Set the text layout format for the list
         * list.stringFormat = itemFormat;
         * // Draw the items on the page with the updated format
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        set: function (value) {
            this._stringFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfList.prototype, "indent", {
        /**
         * Gets the indent of the list.
         *
         * @returns {number} The indent value of the list.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add an item to list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a of ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Draw the list on the page associated with items
         * list.draw(page, 0, 20, 500, 700);
         * // Get the current indent value used by the list
         * let itemIndent: number = list.indent;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._indent;
        },
        /**
         * Sets the indent of the list.
         *
         * @param {number} value The indent value to set for the list.
         * ```typescript
         * //Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add an items to list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a of ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Set the indent value for the list
         * list.indent = 40;
         * // Draw the items on the page with the specified indent
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        set: function (value) {
            this._indent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfList.prototype, "textIndent", {
        /**
         * Gets the text indent of the list.
         *
         * @returns {number} The text indent of the list.
         * ```typescript
         * // Load the existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add an items to list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create an new ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Draw the list on the page associated with items
         * list.draw(page, 0, 20, 500, 700);
         * // Get the current text indent value of the list
         * let textIndent: number = list.textIndent;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._textIndent;
        },
        /**
         * Sets the text indent of the list.
         *
         * @param {number} value The text indent value to set for the list.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add an item to list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a new ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Set the text indent value for the list
         * list.textIndent = 40;
         * // Draw the items on the page with the updated text indent
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        set: function (value) {
            this._textIndent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfList.prototype, "delimiter", {
        /**
         * Gets the delimiter string used to separate items in the list.
         *
         * @returns {string} The delimiter string used in the list.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Create an instance of PdfListItemCollection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a new ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Draw the list on the page associated with items
         * list.draw(page, 0, 20, 500, 700);
         * // Get the delimiter used in the list
         * let delimiter: string = list.delimiter;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._delimiter;
        },
        /**
         * Sets the delimiter string used to separate items in the list.
         *
         * @param {string} value The delimiter string to be set.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add an item to list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a new ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Set the delimiter for the list
         * list.delimiter = ')';
         * // Draw the list on the page associated with items
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        set: function (value) {
            this._delimiter = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfList.prototype, "suffix", {
        get: function () {
            return this._suffix;
        },
        set: function (value) {
            this._suffix = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfList.prototype, "enableHierarchy", {
        /**
         * Gets a value indicating whether hierarchical structure is enabled for the list.
         *
         * @returns {boolean} `true` if hierarchical structure is enabled; otherwise, `false`.
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add an item to list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a new ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Draw the items associated with the items
         * list.draw(page, 0, 20, 500, 700);
         * // Get the hierarchical structure status
         * let enableHierarchy: boolean = list.enableHierarchy;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._enableHierarchy;
        },
        /**
         * Sets a value indicating whether hierarchical structure is enabled for the list.
         *
         * @param {boolean} value The boolean flag to enable or disable hierarchical structure.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add an item to list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a new ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Set the hierarchical structure status
         * list.enableHierarchy = true;
         * / Draw the list on the page associated with items
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        set: function (value) {
            this._enableHierarchy = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfList.prototype, "alignment", {
        /**
         * Gets the text alignment of the list.
         *
         * @returns {PdfTextAlignment} The text alignment.
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add an item to list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a new ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Draw the list on the page associated with items
         * list.draw(page, 0, 20, 500, 700);
         * // Get the alignment of the list
         * let listAlignment: PdfTextAlignment = list.alignment;
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._alignment;
        },
        /**
         * Sets the text alignment of the list.
         *
         * @param {PdfTextAlignment} value The text alignment to set for the list.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add an items to list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a new ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Set the alignment for the list
         * list.alignment = PdfTextAlignment.left;
         * // Draw the items on the page
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        set: function (value) {
            this._alignment = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfList.prototype, "items", {
        /**
         * Gets the item collection of the list.
         *
         * @returns {PdfListItemCollection} The list item collection.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add an items to list item collection by passing the string array
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Create a new ordered list
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Get the item collection
         * let collection: PdfListItemCollection = list.items;
         * // Draw the list on the page associated with item collection
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        get: function () {
            return this._itemCollection;
        },
        /**
         * Sets the item collection of the list.
         *
         * @param {PdfListItemCollection} value The list item collection.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Create a new ordered list
         * let list: PdfOrderedList = new PdfOrderedList();
         * // Sets the item collection
         * list.items = new PdfListItemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);
         * // Draw the list on the page associated with item collection
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ````
         */
        set: function (value) {
            this._itemCollection = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfList.prototype, "_markerRightToLeft", {
        get: function () {
            return this._alignment === PdfListMarkerAlignment.right;
        },
        enumerable: true,
        configurable: true
    });
    PdfList.prototype.draw = function (arg1, arg2, arg3, arg4, arg5, arg6) {
        if (arg1 instanceof PdfPage) {
            if (arg1._isNew) {
                return this._drawInternal(arg1, arg2, arg3, arg4, arg5, arg6);
            }
            else {
                (new _PdfListLayouter(this)).layout(arg1.graphics, [arg2, arg3, 0, 0]);
            }
        }
        else {
            (new _PdfListLayouter(this)).layout(arg1, [arg2, arg3, 0, 0]);
        }
    };
    PdfList.prototype._drawInternal = function (arg1, arg2, arg3, arg4, arg5, arg6) {
        var parameter = new _PdfLayoutParameters();
        parameter._page = arg1;
        if (arg4 === null || typeof arg4 === 'undefined') {
            parameter._bounds = [arg2, arg3, 0, 0];
            parameter._format = new PdfLayoutFormat();
        }
        else if (typeof arg4 === 'number') {
            parameter._bounds = [arg2, arg3, arg4, arg5];
            if (arg6) {
                parameter._format = arg6;
            }
            else {
                parameter._format = new PdfLayoutFormat();
            }
        }
        else if (arg4 instanceof PdfLayoutFormat) {
            parameter._bounds = [arg2, arg3, 0, 0];
            parameter._format = arg4;
        }
        return this._layout(parameter);
    };
    PdfList.prototype._layout = function (parameter) {
        return (new _PdfListLayouter(this)).layoutInternal(parameter);
    };
    return PdfList;
}());
/**
 * Represents an ordered list in a PDF document.
 * ```typescript
 * // Load an existing document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access the first page
 * let page: PdfPage = document.getPage(0);
 * // Define an array of strings representing items to be added
 * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
 * // Add the items to list item collection by passing the array of products
 * let items: PdfListItemCollection = new PdfListItemCollection(products);
 * // Create an instance of ordered list
 * let list: PdfOrderedList = new PdfOrderedList(items);
 * // Draw the ordered list on the page
 * list.draw(page, 0, 20, layout);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ````
 */
var PdfOrderedList = /** @class */ (function (_super) {
    __extends$k(PdfOrderedList, _super);
    function PdfOrderedList(items, settings) {
        var _this = _super.call(this) || this;
        _this._startNumber = 1;
        if (items) {
            _this._itemCollection = items;
        }
        else {
            _this._itemCollection = new PdfListItemCollection();
        }
        if (settings) {
            if (settings.font) {
                _this._font = settings.font;
            }
            if (settings.format) {
                _this._stringFormat = settings.format;
            }
            if (settings.pen) {
                _this._pen = settings.pen;
            }
            if (settings.brush) {
                _this._brush = settings.brush;
            }
            if (settings.style) {
                _this._style = settings.style;
            }
            else {
                _this._style = PdfNumberStyle.numeric;
            }
            if (settings.indent) {
                _this._indent = settings.indent;
            }
            if (settings.textIndent) {
                _this._textIndent = settings.textIndent;
            }
            if (settings.alignment) {
                _this._alignment = settings.alignment;
            }
            if (settings.delimiter) {
                _this._delimiter = settings.delimiter;
            }
            if (settings.suffix) {
                _this._suffix = settings.suffix;
            }
        }
        else {
            _this._style = PdfNumberStyle.numeric;
        }
        return _this;
    }
    Object.defineProperty(PdfOrderedList.prototype, "style", {
        /**
         * Gets the numbering style used for the ordered list.
         *
         * @returns {PdfNumberStyle} The numbering style used for the ordered list.
         *  ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add the items to list item collection by passing the array of products
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Initialize the instance of ordered list and pass the item collection
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Get the numbering style used for the ordered list
         * let style: PdfNumberStyle = list.style;
         * // Draw the ordered list on the page
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._style;
        },
        /**
         * Sets the numbering style used for the ordered list.
         *
         * @param {PdfNumberStyle} value The numbering style used for the ordered list.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         *  // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add the items to list item collection by passing the array of products
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Initialize the instance of ordered list and pass the item collection
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Define a style for the list
         * let style: PdfNumberStyle = PdfNumberStyle.lowerLatin;
         * // Set the numbering style for the list items
         * list.style = style;
         * // Draw the ordered list on the page
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._style = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfOrderedList.prototype, "startNumber", {
        /**
         * Gets the starting number used for the ordered list.
         *
         * @returns {number} The starting number of the ordered list.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add the items to list item collection by passing the array of products
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Initialize the instance of ordered list and pass the item collection
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Get the starting number used for the ordered list
         * let startnumber: number = list.startNumber;
         * // Draw the ordered list on the page
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._startNumber;
        },
        /**
         * Sets the starting number to be used for the ordered list.
         *
         * @param {number} value The starting number to set.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Assign the array of string items
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add the items to list item collection by passing the array of products
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Initialize the instance of ordered list and pass the item collection
         * let list: PdfOrderedList = new PdfOrderedList(items);
         * // Set the starting number for the ordered list
         * list.startNumber = 5;
         * // Draw the ordered list on the page
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value <= 0) {
                throw new Error('Start number should be greater than 0.');
            }
            this._startNumber = value;
        },
        enumerable: true,
        configurable: true
    });
    PdfOrderedList.prototype._getNumber = function () {
        return _convertNumber(this._startNumber + this._currentIndex, this._style);
    };
    return PdfOrderedList;
}(PdfList));
/**
 * Represents the Unordered lists.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access the first page
 * let page: PdfPage = document.getPage(0);
 * // Define the items in the unordered list
 * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
 * // Create an instance of PdfListItemCollection by passing the string array
 * let items: PdfListItemCollection = new PdfListItemCollection(products);
 * // Create an instance of PdfUnorderedList
 * let list: PdfUnorderedList = new PdfUnorderedList();
 * // Draw the unordered list on the page
 * list.draw(page, 0, 20, layout);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ````
 */
var PdfUnorderedList = /** @class */ (function (_super) {
    __extends$k(PdfUnorderedList, _super);
    function PdfUnorderedList(items, settings) {
        var _this = _super.call(this) || this;
        if (items) {
            _this._itemCollection = items;
        }
        else {
            _this._itemCollection = new PdfListItemCollection();
        }
        if (settings) {
            if (settings.font) {
                _this._font = settings.font;
            }
            if (settings.format) {
                _this._stringFormat = settings.format;
            }
            if (settings.pen) {
                _this._pen = settings.pen;
            }
            if (settings.brush) {
                _this._brush = settings.brush;
            }
            if (settings.style) {
                _this._style = settings.style;
            }
            else {
                _this._style = PdfUnorderedListStyle.disk;
            }
            if (settings.indent) {
                _this._indent = settings.indent;
            }
            if (settings.textIndent) {
                _this._textIndent = settings.textIndent;
            }
            if (settings.alignment) {
                _this._alignment = settings.alignment;
            }
            if (settings.delimiter) {
                _this._delimiter = settings.delimiter;
            }
            if (settings.suffix) {
                _this._suffix = settings.suffix;
            }
        }
        else {
            _this._style = PdfUnorderedListStyle.disk;
        }
        return _this;
    }
    Object.defineProperty(PdfUnorderedList.prototype, "style", {
        /**
         * Gets the style used for the unordered list.
         *
         * @returns {PdfUnorderedListStyle} The style used for the unordered list.
         * ```typescript
         * // Load an existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Define the items in the unordered list
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add the items to list item collection by passing the array of products
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Initialize an instance of the unordered list and pass the list item collection
         * let list: PdfUnorderedList = new PdfUnorderedList(items);
         * // Get the style used for the unordered list
         * let style: PdfUnorderedListStyle = list.style;
         * // Draw the unordered list on the page
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._style;
        },
        /**
         * Sets the style used for the unordered list.
         *
         * @param {PdfUnorderedListStyle} value The style to set for the unordered list.
         * ```typescript
         * // Load the existing document
         * let document: PdfDocument = new PdfDocument(data);
         * // Access the first page
         * let page: PdfPage = document.getPage(0);
         * // Define the items in the unordered list
         * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];
         * // Add the items to list item collection by passing the array of products
         * let items: PdfListItemCollection = new PdfListItemCollection(products);
         * // Initialize an instance of the unordered list and pass the list item collection
         * let list: PdfUnorderedList = new PdfUnorderedList(items);
         * // Initialize a style for the unordered list
         * let style: PdfUnorderedListStyle = PdfUnorderedListStyle.circle;
         * // Set the style for the unordered list items
         * list.style = style;
         * // Draw the unordered list on the page
         * list.draw(page, 0, 20, 500, 700);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            this._style = value;
        },
        enumerable: true,
        configurable: true
    });
    PdfUnorderedList.prototype._getStyledText = function () {
        switch (this._style) {
            case PdfUnorderedListStyle.disk:
                return '\x6C';
            case PdfUnorderedListStyle.square:
                return '\x6E';
            case PdfUnorderedListStyle.asterisk:
                return '\x5D';
            case PdfUnorderedListStyle.circle:
                return '\x6D';
            default:
                return '';
        }
    };
    PdfUnorderedList.prototype._draw = function (graphics, x, y, brush, pen) {
        var template = new PdfTemplate([0, 0, this._size[0], this._size[1]], graphics._crossReference);
        var bounds = [0, 0, 0, 0];
        if (pen) {
            bounds[0] = bounds[0] + pen._width;
            bounds[1] = bounds[1] + pen._width;
        }
        template.graphics.drawString(this._getStyledText(), this._unicodeFont, bounds, pen, brush);
        graphics.drawTemplate(template, { x: x, y: y, width: template.size[0], height: template.size[1] });
    };
    return PdfUnorderedList;
}(PdfList));
var _PdfListInfo = /** @class */ (function () {
    function _PdfListInfo(list, index, number) {
        this._list = list;
        this._index = index;
        this._number = number;
    }
    return _PdfListInfo;
}());
var _PdfListLayouter = /** @class */ (function () {
    function _PdfListLayouter(element) {
        this._indent = 0;
        this._information = [];
        this._markerMaxWidth = 0;
        this._finish = false;
        this._usePaginateBounds = true;
        this._resultHeight = 0;
        this._size = [0, 0];
        this._index = 0;
        this._element = element;
    }
    _PdfListLayouter.prototype.layout = function (graphics, bounds) {
        this._graphics = graphics;
        var parameter = new _PdfLayoutParameters();
        parameter._bounds = bounds;
        parameter._format = new PdfLayoutFormat();
        parameter._format.layout = PdfLayoutType.onePage;
        this.layoutInternal(parameter);
    };
    _PdfListLayouter.prototype.layoutInternal = function (parameter) {
        this._currentPage = parameter._page;
        this._bounds = parameter._bounds.slice();
        if (this._currentPage) {
            if (parameter._bounds[2] === 0 && parameter._bounds[3] === 0) {
                var pageSize = this._currentPage.graphics.clientSize;
                this._bounds[2] = pageSize[0] - this._bounds[0];
                this._bounds[3] = pageSize[1] - this._bounds[1];
            }
            this._graphics = this._currentPage.graphics;
        }
        var pageResult = new _PageLayoutResult();
        pageResult.broken = false;
        pageResult.y = this._bounds[1];
        this._curList = this._element;
        this._indent = this._curList.indent;
        this._setCurrentParameters(this._curList);
        if (!this._curList.brush) {
            this._currentBrush = new PdfBrush([0, 0, 0]);
        }
        if (!this._curList.font) {
            this._currentFont = this._curList._defaultFont;
        }
        if (this._curList instanceof PdfOrderedList) {
            this._markerMaxWidth = this._getMarkerMaxWidth(this._curList, this._information);
        }
        var useOnPage = parameter._format.layout === PdfLayoutType.onePage;
        while (!this._finish) {
            pageResult.y = this._bounds[1];
            pageResult = this._layoutOnPage(pageResult);
            if (useOnPage) {
                break;
            }
            if (this._currentPage && !this._finish) {
                this._currentPage = this._getNextPage(this._currentPage);
            }
            this._graphics = this._currentPage.graphics;
            if (parameter._bounds[2] === 0 && parameter._bounds[3] === 0) {
                var pageSize = this._currentPage.graphics.clientSize;
                this._bounds[2] = pageSize[0] - this._bounds[0];
                this._bounds[3] = pageSize[1] - this._bounds[1];
            }
            if (parameter._format && parameter._format.usePaginateBounds && this._usePaginateBounds) {
                this._bounds = parameter._format._paginateBounds;
            }
        }
        this._information = [];
        var finalBounds = [this._bounds[0], pageResult.y, this._bounds[2], this._resultHeight];
        var result = new PdfLayoutResult(this._currentPage, finalBounds);
        if (this._currentFormat) {
            this._currentFormat._isList = false;
        }
        return result;
    };
    _PdfListLayouter.prototype._layoutOnPage = function (pageResult) {
        var height = 0;
        var resultantHeight = 0;
        var y = this._bounds[1];
        var x = this._bounds[0];
        this._size = [this._bounds[2] - this._indent, this._bounds[3]];
        while (true) { // eslint-disable-line
            for (; this._index < this._curList.items.count; ++this._index) {
                var item = this._curList.items.at(this._index);
                var result = this._drawItem(pageResult, x, this._curList, this._index, this._indent, this._information, item, height, y);
                pageResult = result.pageResult;
                height = result.height;
                y = result.y;
                resultantHeight += height;
                if (pageResult.broken) {
                    return pageResult;
                }
                pageResult.markerWrote = false;
                if (item.subList && item.subList.items.count > 0) {
                    if (this._curList instanceof PdfOrderedList) {
                        var oList = this._curList;
                        oList._currentIndex = this._index;
                        var info = new _PdfListInfo(this._curList, this._index, oList._getNumber());
                        info._brush = this._currentBrush;
                        info._font = this._currentFont;
                        info._format = this._currentFormat;
                        info._pen = this._currentPen;
                        info._markerWidth = this._markerMaxWidth;
                        this._information.push(info);
                    }
                    else {
                        var info = new _PdfListInfo(this._curList, this._index);
                        info._brush = this._currentBrush;
                        info._font = this._currentFont;
                        info._format = this._currentFormat;
                        info._pen = this._currentPen;
                        this._information.push(info);
                    }
                    this._curList = item.subList;
                    if (this._curList instanceof PdfOrderedList) {
                        this._markerMaxWidth = this._getMarkerMaxWidth(this._curList, this._information);
                    }
                    this._index = -1;
                    this._indent += this._curList.indent;
                    this._size[0] = this._size[0] - this._curList.indent;
                    this._setCurrentParameters(item);
                    this._setCurrentParameters(this._curList);
                }
            }
            if (this._information.length === 0) {
                this._resultHeight = resultantHeight;
                this._finish = true;
                break;
            }
            var listInfo = this._information.pop();
            this._index = listInfo._index + 1;
            this._indent -= this._curList.indent;
            this._size[0] = this._size[0] + this._curList.indent;
            this._markerMaxWidth = listInfo._markerWidth;
            this._currentBrush = listInfo._brush;
            this._currentPen = listInfo._pen;
            this._currentFont = listInfo._font;
            this._currentFormat = listInfo._format;
            this._curList = listInfo._list;
        }
        return pageResult;
    };
    _PdfListLayouter.prototype._drawItem = function (pageResult, x, curList, index, indent, info, item, height, y) {
        var layouter = new _PdfStringLayouter();
        var result;
        var textIndent = curList.textIndent;
        var posY = height + y;
        var posX = indent + x;
        var itemHeight = 0;
        var itemSize = this._size;
        var text = item.text;
        var markerText;
        var itemBrush = this._currentBrush;
        var markerHeight = 0;
        if (item.brush) {
            itemBrush = item.brush;
        }
        var itemPen = this._currentPen;
        if (item.pen) {
            itemPen = item.pen;
        }
        var itemFont = this._currentFont;
        if (item.font) {
            itemFont = item.font;
        }
        var itemFormat = this._currentFormat;
        if (item.stringFormat) {
            itemFormat = item.stringFormat;
        }
        if ((this._size[0] <= 0 || this._size[0] < itemFont.size) && this._currentPage) {
            throw new Error('There is not enough space to layout list.');
        }
        this._size[1] = this._size[1] - height;
        if (pageResult.broken) {
            text = pageResult.itemText;
            markerText = pageResult.markerText;
        }
        var canDrawMarker = true;
        var markerResult = this._createMarkerResult(index, curList, info, item);
        if (markerResult) {
            if (curList instanceof PdfOrderedList) {
                posX += this._markerMaxWidth;
                pageResult.markerWidth = this._markerMaxWidth;
            }
            else {
                posX += markerResult._actualSize[0];
                pageResult.markerWidth = markerResult._actualSize[0];
            }
            markerHeight = markerResult._actualSize[1];
            if (this._currentPage) {
                canDrawMarker = (markerHeight < this._size[1]);
            }
            if (markerResult._empty) {
                canDrawMarker = false;
            }
        }
        else {
            posX += curList._size[0];
            pageResult.markerWidth = curList._size[0];
            markerHeight = curList._size[1];
            if (this._currentPage) {
                canDrawMarker = (markerHeight < this._size[1]);
            }
        }
        if (!markerText || markerText === '') {
            canDrawMarker = true;
        }
        if (text && canDrawMarker) {
            itemSize = this._size;
            itemSize[0] = itemSize[0] - pageResult.markerWidth;
            if (item.textIndent === 0) {
                itemSize[0] = itemSize[0] - textIndent;
            }
            else {
                itemSize[0] = itemSize[0] - item.textIndent;
            }
            if ((itemSize[0] <= 0 || itemSize[0] < itemFont.size) && this._currentPage) {
                throw new Error('Not enough space to layout the text. The marker is too long or there is not enough space to draw it.');
            }
            var itemX = posX;
            if (!curList._markerRightToLeft) {
                if (item.textIndent === 0) {
                    itemX += textIndent;
                }
                else {
                    itemX += item.textIndent;
                }
            }
            else {
                itemX -= pageResult.markerWidth;
                if (itemFormat && (itemFormat.alignment === PdfTextAlignment.right || itemFormat.alignment === PdfTextAlignment.center)) {
                    itemX -= indent;
                }
            }
            if (!this._currentPage && itemFormat) {
                itemFormat = Object.assign({}, itemFormat);
                itemFormat.alignment = PdfTextAlignment.left;
            }
            result = layouter._layout(text, itemFont, itemFormat, itemSize);
            var rect = [itemX, posY, itemSize[0], itemSize[1]];
            this._graphics._drawStringLayoutResult(result, itemFont, itemPen, itemBrush, rect, itemFormat);
            y = posY;
            itemHeight = result._actualSize[1];
        }
        height = (itemHeight < markerHeight) ? markerHeight : itemHeight;
        if ((result && result._remainder && result._remainder !== '') ||
            (markerResult && markerResult._remainder && markerResult._remainder !== '') ||
            !canDrawMarker) {
            y = 0;
            height = 0;
            if (result) {
                pageResult.itemText = result._remainder;
                if (result._remainder === item.text) {
                    canDrawMarker = false;
                }
            }
            else {
                if (canDrawMarker) {
                    pageResult.itemText = undefined;
                }
                else {
                    pageResult.itemText = item.text;
                }
            }
            if (markerResult) {
                pageResult.markerText = markerResult._remainder;
            }
            else {
                pageResult.markerText = undefined;
            }
            pageResult.broken = true;
            pageResult.y = 0;
            this._bounds[1] = 0;
        }
        else {
            pageResult.broken = false;
        }
        if (result) {
            pageResult.markerX = posX;
            if (itemFormat) {
                switch (itemFormat.alignment) {
                    case PdfTextAlignment.right:
                        pageResult.markerX = posX + itemSize[0] - result._actualSize[0];
                        break;
                    case PdfTextAlignment.center:
                        pageResult.markerX = posX + (itemSize[0] / 2) - (result._actualSize[0] / 2);
                        break;
                }
            }
            if (curList._markerRightToLeft) {
                pageResult.markerX += result._actualSize[0];
                if (item.textIndent === 0) {
                    pageResult.markerX += textIndent;
                }
                else {
                    pageResult.markerX += item.textIndent;
                }
                if (itemFormat && (itemFormat.alignment === PdfTextAlignment.right || itemFormat.alignment === PdfTextAlignment.center)) {
                    pageResult.markerX -= indent;
                }
            }
        }
        if (canDrawMarker && !pageResult.markerWrote) {
            pageResult.markerWrote = this._drawMarker(curList, item, markerResult, posY, pageResult.markerX);
            if (curList instanceof PdfOrderedList) {
                pageResult.markerWidth = markerResult._actualSize[0];
            }
            else {
                pageResult.markerWidth = curList._size[0];
            }
        }
        return { pageResult: pageResult, height: height, y: y };
    };
    _PdfListLayouter.prototype._createMarkerResult = function (index, curList, info, item) {
        if (curList instanceof PdfOrderedList) {
            return this._createOrderedMarkerResult(curList, item, index, info, false);
        }
        else {
            return this._createUnorderedMarkerResult(curList, item);
        }
    };
    _PdfListLayouter.prototype._drawMarker = function (curList, item, markerResult, posY, posX) {
        if (curList instanceof PdfOrderedList) {
            if (curList.font && markerResult) {
                if (curList.font.size > markerResult._actualSize[1]) {
                    posY += (curList.font.size / 2) - (markerResult._actualSize[1] / 2);
                    markerResult._actualSize[1] = markerResult._actualSize[1] + posY;
                }
                this._drawOrderedMarker(curList, markerResult, item, posX, posY);
            }
        }
        else {
            if (curList.font && markerResult) {
                if (curList.font.size > markerResult._actualSize[1]) {
                    posY += (curList.font.size / 2) - (markerResult._actualSize[1] / 2);
                    markerResult._actualSize[1] = markerResult._actualSize[1] + posY;
                }
            }
            this._drawUnorderedMarker(curList, markerResult, item, posX, posY);
        }
        return true;
    };
    _PdfListLayouter.prototype._drawUnorderedMarker = function (curList, markerResult, item, posX, posY) {
        var markerFont = this._getMarkerFont(curList, item);
        var markerPen = this._getMarkerPen(curList, item);
        var markerBrush = this._getMarkerBrush(curList, item);
        if (markerResult) {
            curList._size = markerResult._actualSize;
            curList._unicodeFont = new PdfStandardFont(PdfFontFamily.zapfDingbats, markerFont.size);
            curList._draw(this._graphics, posX - markerResult._actualSize[0], posY, markerBrush, markerPen);
        }
        else {
            curList._size = [markerFont.size, markerFont.size];
            curList._draw(this._graphics, posX - markerFont.size, posY, markerBrush, markerPen);
        }
    };
    _PdfListLayouter.prototype._drawOrderedMarker = function (curList, markerResult, item, posX, posY) {
        var markerFont = this._getMarkerFont(curList, item);
        var markerPen = this._getMarkerPen(curList, item);
        var markerBrush = this._getMarkerBrush(curList, item);
        var rect = [posX - this._markerMaxWidth, posY, this._markerMaxWidth, markerResult._actualSize[1]];
        var markerFormat = this._setMarkerStringFormat(curList, this._getMarkerFormat(curList, item));
        this._graphics._drawStringLayoutResult(markerResult, markerFont, markerPen, markerBrush, rect, markerFormat);
    };
    _PdfListLayouter.prototype._setCurrentParameters = function (element) {
        if (element.brush) {
            this._currentBrush = element.brush;
        }
        if (element.pen) {
            this._currentPen = element.pen;
        }
        if (element.font) {
            this._currentFont = element.font;
        }
        if (element.stringFormat) {
            this._currentFormat = element.stringFormat;
            if (element instanceof PdfList) {
                this._currentFormat._isList = true;
            }
        }
    };
    _PdfListLayouter.prototype._getMarkerMaxWidth = function (list, infromation) {
        var width = -1;
        for (var i = 0; i < list.items.count; i++) {
            var result = this._createOrderedMarkerResult(list, list.items.at(i), i + list.startNumber, infromation, true);
            if (width < result._actualSize[0]) {
                width = result._actualSize[0];
            }
        }
        return width;
    };
    _PdfListLayouter.prototype._createUnorderedMarkerResult = function (list, item) {
        var markerFont = this._getMarkerFont(list, item);
        var layouter = new _PdfStringLayouter();
        var uFont = new PdfStandardFont(PdfFontFamily.zapfDingbats, markerFont.size);
        var result = layouter._layout(list._getStyledText(), uFont, null, this._size);
        list._size = result._actualSize;
        if (list.pen) {
            result._size = [result._actualSize[0] + 2 * list.pen._width, result._actualSize[1] + 2 * list.pen._width];
        }
        return result;
    };
    _PdfListLayouter.prototype._createOrderedMarkerResult = function (list, item, index, infromation, findMaxWidth) {
        list._currentIndex = index;
        var text = '';
        if (list.style !== PdfNumberStyle.none) {
            text = list._getNumber() + list.suffix;
        }
        if (list.enableHierarchy) {
            var collection = infromation.slice();
            for (var i = 0; i < collection.length; i++) {
                var listInfo = collection[Number.parseInt(i.toString(), 10)];
                var orderedList = listInfo._list;
                if (!(orderedList && orderedList instanceof PdfOrderedList && orderedList.style !== PdfNumberStyle.none)) {
                    break;
                }
                text = listInfo._number + orderedList.delimiter + text;
                if (!orderedList.enableHierarchy) {
                    break;
                }
            }
        }
        var layouter = new _PdfStringLayouter();
        var font = this._getMarkerFont(list, item);
        var format = this._getMarkerFormat(list, item);
        var markerSize = [0, 0];
        if (!findMaxWidth) {
            markerSize[0] = this._markerMaxWidth;
            format = this._setMarkerStringFormat(list, format);
        }
        return layouter._layout(text, font, format, markerSize);
    };
    _PdfListLayouter.prototype._setMarkerStringFormat = function (list, format) {
        if (format) {
            format = Object.assign({}, format);
        }
        else {
            format = new PdfStringFormat();
        }
        if (!list.stringFormat) {
            format.alignment = PdfTextAlignment.right;
            if (list._markerRightToLeft) {
                format.alignment = PdfTextAlignment.left;
            }
        }
        if (!this._currentPage && format) {
            format = Object.assign({}, format);
            format.alignment = PdfTextAlignment.left;
        }
        return format;
    };
    _PdfListLayouter.prototype._getMarkerFont = function (list, item) {
        var markerFont = list.font;
        if (!markerFont) {
            markerFont = item.font;
            if (!markerFont) {
                markerFont = this._currentFont;
            }
        }
        list.font = markerFont;
        return markerFont;
    };
    _PdfListLayouter.prototype._getMarkerFormat = function (list, item) {
        var markerFormat = list.stringFormat;
        if (!markerFormat) {
            markerFormat = item.stringFormat;
            if (!markerFormat) {
                markerFormat = this._currentFormat;
            }
        }
        return markerFormat;
    };
    _PdfListLayouter.prototype._getMarkerPen = function (list, item) {
        var markerPen = list.pen;
        if (!markerPen) {
            markerPen = item.pen;
            if (!markerPen) {
                markerPen = this._currentPen;
            }
        }
        return markerPen;
    };
    _PdfListLayouter.prototype._getMarkerBrush = function (list, item) {
        var markerBrush = list.brush;
        if (!markerBrush) {
            markerBrush = item.brush;
            if (!markerBrush) {
                markerBrush = this._currentBrush;
            }
        }
        return markerBrush;
    };
    _PdfListLayouter.prototype._getNextPage = function (page) {
        var document = page._crossReference._document;
        if (page._pageIndex < document.pageCount - 1) {
            return document.getPage(page._pageIndex + 1);
        }
        else {
            return document.addPage();
        }
    };
    return _PdfListLayouter;
}());

export { BaseException, DataFormat, Dictionary, FormatError, ParserEndOfFileException, PathPointType, Pdf3DAnnotation, PdfAction, PdfAngleMeasurementAnnotation, PdfAnnotation, PdfAnnotationBorder, PdfAnnotationCaption, PdfAnnotationCollection, PdfAnnotationExportSettings, PdfAnnotationFlag, PdfAnnotationIntent, PdfAnnotationLineEndingStyle, PdfAnnotationState, PdfAnnotationStateModel, PdfAppearance, PdfAttachmentAnnotation, PdfAttachmentIcon, PdfBitmap, PdfBlendMode, PdfBookmark, PdfBookmarkBase, PdfBorderEffect, PdfBorderEffectStyle, PdfBorderStyle, PdfBrush, PdfButtonField, PdfCheckBoxField, PdfCheckBoxStyle, PdfCircleAnnotation, PdfCircleMeasurementType, PdfCjkFontFamily, PdfCjkStandardFont, PdfComboBoxField, PdfComment, PdfCrossReferenceType, PdfDashStyle, PdfDestination, PdfDestinationMode, PdfDocument, PdfDocumentLinkAnnotation, PdfDocumentSplitEventArgs, PdfEllipseAnnotation, PdfField, PdfFieldActions, PdfFileLinkAnnotation, PdfFileStructure, PdfFillMode, PdfFont, PdfFontFamily, PdfFontStyle, PdfForm, PdfFormFieldExportSettings, PdfFormFieldVisibility, PdfFormFieldsTabOrder, PdfFreeTextAnnotation, PdfGoToAction, PdfGraphics, PdfGraphicsState, PdfHighlightMode, PdfImage, PdfInkAnnotation, PdfInteractiveBorder, PdfLayer, PdfLayerCollection, PdfLayoutBreakType, PdfLayoutFormat, PdfLayoutResult, PdfLayoutType, PdfLineAnnotation, PdfLineCap, PdfLineCaptionType, PdfLineEndingStyle, PdfLineIntent, PdfLineJoin, PdfList, PdfListBoxField, PdfListField, PdfListFieldItem, PdfListItem, PdfListItemCollection, PdfListMarkerAlignment, PdfMargins, PdfMeasurementUnit, PdfNamedDestination, PdfNumberStyle, PdfOrderedList, PdfPage, PdfPageImportOptions, PdfPageOrientation, PdfPageSettings, PdfPath, PdfPen, PdfPermissionFlag, PdfPolyLineAnnotation, PdfPolygonAnnotation, PdfPopupAnnotation, PdfPopupAnnotationCollection, PdfPopupIcon, PdfPredictorStream, PdfPrintState, PdfRadioButtonListField, PdfRadioButtonListItem, PdfRectangleAnnotation, PdfRedactionAnnotation, PdfRichMediaAnnotation, PdfRotationAngle, PdfRubberStampAnnotation, PdfRubberStampAnnotationIcon, PdfSection, PdfSignatureField, PdfSoundAnnotation, PdfSquareAnnotation, PdfStandardFont, PdfStateItem, PdfStringFormat, PdfSubSuperScript, PdfTemplate, PdfTextAlignment, PdfTextBoxField, PdfTextDirection, PdfTextMarkupAnnotation, PdfTextMarkupAnnotationType, PdfTextStyle, PdfTextWebLinkAnnotation, PdfTrueTypeFont, PdfUnorderedList, PdfUnorderedListStyle, PdfUriAnnotation, PdfVerticalAlignment, PdfWatermarkAnnotation, PdfWidgetAnnotation, _AdvancedEncryption, _AdvancedEncryption128Cipher, _AdvancedEncryption256Cipher, _AdvancedEncryptionBaseCipher, _ArabicShape, _ArabicShapeRenderer, _BasicEncryption, _Bidirectional, _BigEndianWriter, _BlockType, _Cipher, _CipherTransform, _CjkDifferentWidth, _CjkSameWidth, _CjkWidth, _CjkWidthTable, _ContentLexer, _ContentParser, _DecompressedOutput, _DeflateStream, _EncryptionKey, _ExportHelper, _FdfDocument, _FdfHelper, _FieldFlag, _FontDescriptorFlag, _FontStructure, _HuffmanTree, _ImageDecoder, _ImageFormat, _InBuffer, _Inflater, _InflaterState, _JpegDecoder, _JsonDocument, _LineInfo, _LineType, _Linearization, _MD5, _Matrix, _Namespace, _NormalCipherFour, _NullCipher, _PageLayoutResult, _PaintParameter, _PdfAnnotationType, _PdfBaseStream, _PdfCatalog, _PdfCheckFieldState, _PdfCjkFontDescriptorFactory, _PdfCjkStandardFontMetricsFactory, _PdfColorSpace, _PdfCommand, _PdfContentStream, _PdfCopier, _PdfCrossReference, _PdfDecodeStream, _PdfDecryptStream, _PdfDefaultAppearance, _PdfDictionary, _PdfEncryptor, _PdfFlateStream, _PdfFontMetrics, _PdfGraphicsUnit, _PdfLayoutParameters, _PdfLexicalOperator, _PdfListInfo, _PdfListLayouter, _PdfMergeHelper, _PdfName, _PdfNamedDestinationCollection, _PdfNull, _PdfNullStream, _PdfPaddings, _PdfParser, _PdfRecord, _PdfReference, _PdfReferenceSet, _PdfReferenceSetCache, _PdfStandardFontMetricsFactory, _PdfStream, _PdfStreamWriter, _PdfStringLayoutResult, _PdfStringLayouter, _PdfTransformationMatrix, _PdfUnitConvertor, _PdfWordWrapType, _PngDecoder, _RtlCharacters, _RtlRenderer, _Sha256, _Sha512, _SignatureFlag, _StandardWidthTable, _StringTokenizer, _TextRenderingMode, _TokenType, _TrueTypeAppleCmapSubTable, _TrueTypeCmapEncoding, _TrueTypeCmapFormat, _TrueTypeCmapSubTable, _TrueTypeCmapTable, _TrueTypeCompositeGlyphFlag, _TrueTypeGlyph, _TrueTypeGlyphHeader, _TrueTypeHeadTable, _TrueTypeHorizontalHeaderTable, _TrueTypeLocaTable, _TrueTypeLongHorMetric, _TrueTypeMacintoshEncodingID, _TrueTypeMetrics, _TrueTypeMicrosoftCmapSubTable, _TrueTypeMicrosoftEncodingID, _TrueTypeNameRecord, _TrueTypeNameTable, _TrueTypeOS2Table, _TrueTypePlatformID, _TrueTypePostTable, _TrueTypeReader, _TrueTypeTableInfo, _TrueTypeTrimmedCmapSubTable, _UnicodeLine, _UnicodeTrueTypeFont, _WidthTable, _Word64, _XfdfDocument, _XmlAttribute, _XmlDocument, _XmlElement, _XmlWriter, _addProcSet, _annotationFlagsToString, _appendChar, _arabicToLetter, _arabicToRoman, _areArrayEqual, _areNotEqual, _byteArrayToHexString, _bytesToString, _calculateBounds, _checkComment, _checkField, _checkInkPoints, _checkReview, _checkRotation, _checkType, _clearPrimitiveCaches, _compressStream, _convertNumber, _convertToColor, _copyRange, _decode, _decodeText, _decodeUnicodeBytes, _defaultToString, _defineProperty, _emptyPdfData, _encode, _encodeValue, _escapePdfName, _findPage, _floatToString, _fromRectangle, _getBezierArc, _getColorValue, _getCommentsOrReview, _getDecoder, _getFontStyle, _getInheritableProperty, _getItemValue, _getLatinCharacter, _getNewGuidString, _getPageIndex, _getSize, _getSpecialCharacter, _getStateTemplate, _getUpdatedBounds, _hexStringToByteArray, _hexStringToString, _isArrayEqual, _isCommand, _isName, _isNullOrUndefined, _isRightToLeftCharacters, _isWhiteSpace, _mapAnnotationIntent, _mapAnnotationState, _mapAnnotationStateModel, _mapAttachmentIcon, _mapBlendMode, _mapBorderEffectStyle, _mapBorderStyle, _mapFont, _mapGraphicsUnit, _mapHighlightMode, _mapLineEndingStyle, _mapMarkupAnnotationType, _mapMeasurementUnit, _mapPopupIcon, _mapRubberStampIcon, _numberToString, _obtainDestination, _obtainFontDetails, _parseColor, _parseRectangle, _removeDuplicateFromResources, _removeDuplicateReference, _removeReferences, _reverseMapAnnotationState, _reverseMapAnnotationStateModel, _reverseMapBlendMode, _reverseMapEndingStyle, _reverseMapHighlightMode, _reverseMapPdfFontStyle, _reverseMarkupAnnotationType, _setMatrix, _stringToAnnotationFlags, _stringToBigEndianBytes, _stringToBytes, _stringToPdfString, _stringToStyle, _stringToUnicodeArray, _styleToString, _toRectangle, _toSigned16, _toSigned32, _toUnsigned, _tryParseFontStream, _updateBounds, _updatePageCount, _updatePageSettings, _updateVisibility };
//# sourceMappingURL=ej2-pdf.es5.js.map
