import { isNullOrUndefined, ChildProperty, Property, Complex, getNumericObject, isUndefined as isUndefined$1, Internationalization, getNumberDependable, defaultCurrencyCode, IntlBase, cldrData, extend, Collection, detach, getValue, Base, Event as Event$1, NotifyPropertyChanges, getUniqueID, getComponent, closest, Component, L10n, merge, removeClass, Browser, setStyleAttribute as setStyleAttribute$1, attributes, formatUnit, addClass, append, compile, remove, EventHandler, select, initializeCSPTemplate, isObject, getInstance, createElement, selectAll, rippleEffect, enableRipple, classList } from '@syncfusion/ej2-base';
import { Query, Predicate, DataManager, Deferred, DataUtil } from '@syncfusion/ej2-data';
import { Tooltip, Dialog as Dialog$1, calculatePosition, isCollide, createSpinner, showSpinner, hideSpinner } from '@syncfusion/ej2-popups';
import { Tab, TreeView, Toolbar, Item, MenuItem, Menu, ContextMenu as ContextMenu$1 } from '@syncfusion/ej2-navigations';
import { NumericTextBox, FormValidator, TextBox, ColorPicker as ColorPicker$1 } from '@syncfusion/ej2-inputs';
import { CheckBox, Button, RadioButton } from '@syncfusion/ej2-buttons';
import { DropDownList, ComboBox, AutoComplete } from '@syncfusion/ej2-dropdowns';
import { ListView } from '@syncfusion/ej2-lists';
import { DropDownButton, SplitButton } from '@syncfusion/ej2-splitbuttons';
import { beforeFltrcMenuOpen, filterCmenuSelect, filterCboxValue, filterDialogCreated, filterDialogClose, fltrPrevent, beforeCustomFilterOpen, parentsUntil, toogleCheckbox, createCboxWithWrap, getUid, ExcelFilterBase, CheckBoxFilterBase } from '@syncfusion/ej2-grids';
import { Chart as Chart$1, ColumnSeries, LineSeries, BarSeries, AreaSeries, StackingColumnSeries, StackingLineSeries, StackingBarSeries, ScatterSeries, StackingAreaSeries, Category, Legend, Tooltip as Tooltip$1, DataLabel, AccumulationChart, PieSeries, AccumulationTooltip, AccumulationDataLabel, AccumulationLegend } from '@syncfusion/ej2-charts';

/**
 * To get range indexes.
 *
 * @param {string} range - Specifies the range.
 * @param {Workbook} [context] - Optional Workbook context to derive sheet information, used when the sheet name or index is provided.
 * @param {number} [sheetIndex] - Optional sheet index to resolve sheet-specific range when context is provided.
 * @returns {number[]} - To get range indexes.
 */
function getRangeIndexes(range, context, sheetIndex) {
    let cellindexes;
    const indexes = [];
    if (range) {
        let sheet;
        if (context && !isNullOrUndefined(sheetIndex)) {
            sheet = getSheet(context, sheetIndex);
        }
        range = range.lastIndexOf('!') > -1 ? range.substring(range.lastIndexOf('!') + 1) : range;
        range = range.indexOf(':') === -1 ? range + ':' + range : range;
        const containsAlphabetsAndDigits = new RegExp(/^(?=.*[a-zA-Z])(?=.*\d)/g);
        if (!containsAlphabetsAndDigits.test(range)) {
            const refArr = range.split(':');
            range = isNullOrUndefined(range.match(/[0-9]/)) ? (refArr[0] + '1:' + refArr[1] + (sheet ? (sheet.rowCount - 1) : '1')) :
                ('A' + refArr[0] + ':' + (sheet ? getColumnHeaderText(sheet.colCount) : 'A') + refArr[1]);
        }
        range.split(':').forEach((address) => {
            cellindexes = getCellIndexes(address);
            indexes.push(cellindexes[0]);
            indexes.push(cellindexes[1]);
        });
    }
    return indexes;
}
/**
 * To get single cell indexes
 *
 * @param {string} address - Specifies the address.
 * @returns {number[]} - To get single cell indexes
 */
function getCellIndexes(address) {
    return [parseInt(address.match(/\d+/)[0], 10) - 1, getColIndex(address.match(/[A-Z]+/i)[0].toUpperCase())];
}
/**
 * To get column index from text.
 *
 * @hidden
 * @param {string} text - Specifies the text.
 * @returns {number} - To get column index from text.
 */
function getColIndex(text) {
    let colIdx = 0;
    text = text.split('').reverse().join('');
    for (let i = text.length - 1; i >= 0; i--) {
        colIdx += (text[i].charCodeAt(0) - 64) * (Math.pow(26, i));
    }
    return colIdx - 1;
}
/**
 * To get cell address from given row and column index.
 *
 * @param {number} sRow - Specifies the row.
 * @param {number} sCol - Specifies the col.
 * @returns {string} - To get cell address from given row and column index.
 */
function getCellAddress(sRow, sCol) {
    return getColumnHeaderText(sCol + 1) + (sRow + 1);
}
/**
 * To get range address from given range indexes.
 *
 * @param {number[]} range - Specifies the range.
 * @returns {string} - To get range address from given range indexes.
 */
function getRangeAddress(range) {
    return getCellAddress(range[0], range[1]) + ':' + (!isNullOrUndefined(range[2]) ?
        getCellAddress(range[2], range[3]) : getCellAddress(range[0], range[1]));
}
/**
 * To get column header cell text
 *
 * @param {number} colIndex - Specifies the colIndex.
 * @returns {string} - Get Column Header Text
 */
function getColumnHeaderText(colIndex) {
    const alphabet = 'Z';
    if (colIndex / 26 > 1) {
        return getColumnHeaderText((colIndex % 26 === 0) ? (colIndex / 26 - 1) : Math.floor(colIndex / 26))
            + String.fromCharCode((colIndex % 26) === 0 ? alphabet.charCodeAt(0) : 64 + (colIndex % 26));
    }
    else {
        return String.fromCharCode(64 + (colIndex));
    }
}
/**
 * @hidden
 * @param {SheetModel} address - Specifies the address.
 * @param {Workbook} [context] - Optional Workbook context to derive sheet information, used when the sheet name or index is provided.
 * @param {number} [sheetIndex] - Optional sheet index to resolve sheet-specific range when context is provided.
 * @returns {number[]} - Get Indexes From Address
 */
function getIndexesFromAddress(address, context, sheetIndex) {
    return getRangeIndexes(getRangeFromAddress(address), context, sheetIndex);
}
/**
 * @hidden
 * @param {SheetModel} address - Specifies the address.
 * @returns {string} - Get Range From Address.
 */
function getRangeFromAddress(address) {
    const sheetRefIndex = address.lastIndexOf('!');
    return sheetRefIndex > -1 ? address.substring(sheetRefIndex + 1) : address;
}
/**
 * Get complete address for selected range
 *
 * @hidden
 * @param {SheetModel} sheet - Specifies the sheet.
 * @returns {string} - Get complete address for selected range
 */
function getAddressFromSelectedRange(sheet) {
    return sheet.name + '!' + sheet.selectedRange;
}
/**
 * @param {Workbook} context - Specifies the context.
 * @param {string} address - Specifies the address.
 * @returns {Object} - To get Address Info
 * @hidden
 */
function getAddressInfo(context, address) {
    const sheetIndex = getSheetIndexFromAddress(context, address);
    return { sheetIndex: sheetIndex, indices: getIndexesFromAddress(address, context, sheetIndex) };
}
/**
 * @param {Workbook} context - Specifies the context.
 * @param {string} address - Specifies the address.
 * @returns {number} - return the sheet index.
 * @hidden
 */
function getSheetIndexFromAddress(context, address) {
    let sIdx;
    if (address.indexOf('!') > -1) {
        sIdx = getSheetIndex(context, getSheetNameFromAddress(address));
    }
    else {
        sIdx = context.activeSheetIndex;
    }
    return sIdx;
}
/**
 * Given range will be swapped/arranged in increasing order.
 *
 * @hidden
 * @param {number[]} range - Specifies the range.
 * @returns {number[]} - Returns the bool value.
 */
function getSwapRange(range) {
    const clonedRange = range.slice();
    if (range[0] > range[2]) {
        swap(clonedRange, 0, 2);
    }
    if (range[1] > range[3]) {
        swap(clonedRange, 1, 3);
    }
    return clonedRange;
}
/**
 * Interchange values in an array
 *
 * @param {number[]} range - Specifies the range.
 * @param {number} x - Specifies the x.
 * @param {number} y - Specifies the y.
 * @returns {void} - Interchange values in an array.
 */
function swap(range, x, y) {
    const tmp = range[x];
    range[x] = range[y];
    range[y] = tmp;
}
/**
 * @hidden
 * @param {number[]} range - Specifies the range.
 * @returns {boolean} - Returns the bool value.
 */
function isSingleCell(range) {
    return range[0] === range[2] && range[1] === range[3];
}

/**
 * Worker task.
 *
 * @param {Object} context - Specify the context.
 * @param {Function | Object} taskFn - Specify the task.
 * @param {Function} callbackFn - Specify the callbackFn.
 * @param {Object[]} data - Specify the data.
 * @param {boolean} preventCallback - Specify the preventCallback.
 * @param {Workbook} parent - Specify the Workbook instance.
 * @returns {WorkerHelper} - Worker task.
 */
function executeTaskAsync(context, taskFn, callbackFn, data, preventCallback, parent) {
    return new WorkerHelper(context, taskFn, callbackFn, data, preventCallback, parent);
}
/**
 * @hidden
 *
 * The `WorkerHelper` module is used to perform multiple actions using Web Worker asynchronously.
 */
class WorkerHelper {
    /**
     * Constructor for WorkerHelper module in Workbook library.
     *
     * @private
     * @param {Object} context - Specify the context.
     * @param {Function | Object} task - Specify the task.
     * @param {Function} defaultListener - Specify the defaultListener.
     * @param {Object[]} taskData - Specify the taskData.
     * @param {boolean} preventCallback - Specify the preventCallback.
     * @param {Workbook} parent - Specify the Workbook instance.
     */
    constructor(context, task, defaultListener, taskData, preventCallback, parent) {
        this.preventCallback = false;
        this.context = context;
        this.workerTask = task;
        this.defaultListener = defaultListener;
        this.workerData = taskData;
        this.parent = parent;
        if (preventCallback) {
            this.preventCallback = true;
        }
        this.initWorker();
    }
    /**
     * To terminate the worker task.
     *
     * @private
     * @returns {void} - To terminate the worker task.
     */
    terminate() {
        this.worker.terminate();
        URL.revokeObjectURL(this.workerUrl);
    }
    /**
     * To initiate the worker.
     *
     * @private
     * @returns {void} - To initiate the worker.
     */
    initWorker() {
        const taskBlob = new Blob([this.getFnCode()], { type: 'text/javascript' });
        this.workerUrl = URL.createObjectURL(taskBlob);
        this.worker = new Worker(this.workerUrl);
        this.worker.onmessage = this.messageFromWorker.bind(this);
        this.worker.onerror = this.onError.bind(this);
        if (!this.parent.isVue) {
            this.worker.postMessage(this.workerData);
        }
        else {
            const clonedData = JSON.parse(JSON.stringify(this.workerData));
            this.worker.postMessage(clonedData);
        }
    }
    /**
     * Method for getting response from worker.
     *
     * @param {MessageEvent} args - Specify the args.
     * @returns {void} - Method for getting response from worker.
     * @private
     */
    messageFromWorker(args) {
        this.terminate();
        this.defaultListener.apply(this.context, [args.data]);
    }
    /**
     * Method for getting error message from worker if failed.
     *
     * @param {ErrorEvent} args - Specify the args.
     * @returns {void} - Method for getting error message from worker if failed.
     * @private
     */
    onError(args) {
        this.terminate();
        if (args.message && args.message.includes('FormData')) {
            this.defaultListener.apply(this.context, [{ isFormDataError: true }]);
        }
        else {
            throw args.message || args;
        }
    }
    /**
     * Construct function code for worker.
     *
     * @private
     * @returns {string} -  Construct function code for worker.
     */
    getFnCode() {
        let workerCode = '';
        let i;
        let keys;
        let workerFunction = '';
        let isHaveFunction = false;
        if (typeof this.workerTask === 'function') {
            if (this.workerTask.toString().indexOf('function') < 0) {
                workerFunction = 'function ' + this.workerTask.toString();
            }
            else {
                workerFunction = this.workerTask.toString();
                isHaveFunction = true;
            }
            workerCode += ('self.workerTask = ' + workerFunction + '; \n');
        }
        else {
            if (typeof this.workerTask === 'object') {
                keys = Object.keys(this.workerTask);
                for (i = 0; i < keys.length; i++) {
                    if (this.workerTask[keys[i]].toString().indexOf('function') < 0) {
                        workerFunction = 'function ' + this.workerTask[keys[i]].toString();
                    }
                    else {
                        workerFunction = this.workerTask[keys[i]].toString();
                        isHaveFunction = true;
                    }
                    workerCode += ((i === 0 ? 'self.workerTask' : keys[i]) + '= ' + workerFunction + '; \n');
                }
            }
        }
        workerCode += 'self.onmessage = ' + (isHaveFunction ? '' : ' function ') +
            (this.preventCallback ? this.getMessageFn.toString() : this.getCallbackMessageFn.toString()) + '; \n';
        return workerCode;
    }
    /**
     * Get default worker task with callback.
     *
     * @private
     * @param {MessageEvent} args - Specify the args.
     * @returns {void} - Get default worker task without callback.
     */
    getCallbackMessageFn(args) {
        postMessage(this.workerTask(...args.data));
    }
    /**
     * Get default worker task without callback.
     *
     * @private
     * @param {MessageEvent} args - Specify the args.
     * @returns {void} - Get default worker task without callback.
     */
    getMessageFn(args) {
        this.workerTask(...args.data);
    }
}

/**
 * To get Workbook required modules.
 *
 * @hidden
 * @param {Workbook} context - Specifies the context.
 * @param {ModuleDeclaration[]} modules - Specifies the modules.
 * @returns {ModuleDeclaration[]} - To get Workbook required modules.
 */
function getWorkbookRequiredModules(context, modules = []) {
    modules.push({
        member: 'dataBind',
        args: [context]
    });
    modules.push({
        member: 'workbookProtectSheet',
        args: [context]
    });
    if (context.allowSave) {
        modules.push({
            member: 'workbookSave',
            args: [context]
        });
    }
    if (context.allowPrint) {
        modules.push({
            member: 'print',
            args: [context]
        });
    }
    if (context.allowOpen) {
        modules.push({
            member: 'workbookOpen',
            args: [context]
        });
    }
    if (context.allowEditing) {
        modules.push({
            member: 'workbookEdit',
            args: [context]
        });
        modules.push({
            member: 'workbookFormula',
            args: [context]
        });
    }
    if (context.allowNumberFormatting) {
        modules.push({
            member: 'workbookNumberFormat',
            args: [context]
        });
    }
    if (context.allowCellFormatting) {
        modules.push({
            member: 'workbookcellformat',
            args: [context]
        });
    }
    if (context.allowSorting) {
        modules.push({ member: 'workbookSort', args: [context] });
    }
    if (context.allowHyperlink) {
        modules.push({ member: 'workbookHyperlink', args: [context] });
    }
    if (context.allowFiltering) {
        modules.push({ member: 'workbookFilter', args: [context] });
    }
    if (context.allowFindAndReplace) {
        modules.push({ member: 'workbookfindAndReplace', args: [context] });
    }
    if (context.allowInsert) {
        modules.push({ member: 'workbookinsert', args: [context] });
    }
    if (context.allowDelete) {
        modules.push({ member: 'workbookdelete', args: [context] });
    }
    if (context.allowDataValidation) {
        modules.push({ member: 'workbookDataValidation', args: [context] });
    }
    if (context.allowMerge) {
        modules.push({ member: 'workbookmerge', args: [context] });
    }
    if (context.allowCellFormatting) {
        modules.push({ member: 'workbookConditionalFormatting', args: [context] });
    }
    if (context.allowImage) {
        modules.push({ member: 'workbookImage', args: [context] });
    }
    if (context.allowChart) {
        modules.push({ member: 'workbookChart', args: [context] });
    }
    if (context.allowAutoFill) {
        modules.push({ member: 'workbookautofill', args: [context] });
    }
    return modules;
}

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Represents the cell style.
 */
class CellStyle extends ChildProperty {
}
__decorate([
    Property('Calibri')
], CellStyle.prototype, "fontFamily", void 0);
__decorate([
    Property('bottom')
], CellStyle.prototype, "verticalAlign", void 0);
__decorate([
    Property('left')
], CellStyle.prototype, "textAlign", void 0);
__decorate([
    Property('0pt')
], CellStyle.prototype, "textIndent", void 0);
__decorate([
    Property('#000000')
], CellStyle.prototype, "color", void 0);
__decorate([
    Property('#ffffff')
], CellStyle.prototype, "backgroundColor", void 0);
__decorate([
    Property('normal')
], CellStyle.prototype, "fontWeight", void 0);
__decorate([
    Property('normal')
], CellStyle.prototype, "fontStyle", void 0);
__decorate([
    Property('11pt')
], CellStyle.prototype, "fontSize", void 0);
__decorate([
    Property('none')
], CellStyle.prototype, "textDecoration", void 0);
__decorate([
    Property('')
], CellStyle.prototype, "border", void 0);
__decorate([
    Property('')
], CellStyle.prototype, "borderTop", void 0);
__decorate([
    Property('')
], CellStyle.prototype, "borderBottom", void 0);
__decorate([
    Property('')
], CellStyle.prototype, "borderLeft", void 0);
__decorate([
    Property('')
], CellStyle.prototype, "borderRight", void 0);
/**
 * Represents the Filter Collection.
 *
 */
class FilterCollection extends ChildProperty {
}
__decorate([
    Property()
], FilterCollection.prototype, "sheetIndex", void 0);
__decorate([
    Property()
], FilterCollection.prototype, "filterRange", void 0);
__decorate([
    Property(false)
], FilterCollection.prototype, "hasFilter", void 0);
__decorate([
    Property()
], FilterCollection.prototype, "column", void 0);
__decorate([
    Property()
], FilterCollection.prototype, "criteria", void 0);
__decorate([
    Property()
], FilterCollection.prototype, "value", void 0);
__decorate([
    Property()
], FilterCollection.prototype, "dataType", void 0);
__decorate([
    Property()
], FilterCollection.prototype, "predicates", void 0);
/**
 * Represents the sort Collection.
 *
 */
class SortCollection extends ChildProperty {
}
__decorate([
    Property()
], SortCollection.prototype, "sortRange", void 0);
__decorate([
    Property()
], SortCollection.prototype, "columnIndex", void 0);
__decorate([
    Property()
], SortCollection.prototype, "order", void 0);
__decorate([
    Property()
], SortCollection.prototype, "sheetIndex", void 0);
/**
 * Represents the DefineName.
 */
class DefineName extends ChildProperty {
}
__decorate([
    Property('')
], DefineName.prototype, "name", void 0);
__decorate([
    Property('')
], DefineName.prototype, "scope", void 0);
__decorate([
    Property('')
], DefineName.prototype, "comment", void 0);
__decorate([
    Property('')
], DefineName.prototype, "refersTo", void 0);
/**
 * Configures the Protect behavior for the spreadsheet.
 *
 */
class ProtectSettings extends ChildProperty {
}
__decorate([
    Property(false)
], ProtectSettings.prototype, "selectCells", void 0);
__decorate([
    Property(false)
], ProtectSettings.prototype, "selectUnLockedCells", void 0);
__decorate([
    Property(false)
], ProtectSettings.prototype, "formatCells", void 0);
__decorate([
    Property(false)
], ProtectSettings.prototype, "formatRows", void 0);
__decorate([
    Property(false)
], ProtectSettings.prototype, "formatColumns", void 0);
__decorate([
    Property(false)
], ProtectSettings.prototype, "insertLink", void 0);
/**
 * Represents the Hyperlink.
 *
 */
class Hyperlink extends ChildProperty {
}
__decorate([
    Property('')
], Hyperlink.prototype, "address", void 0);
/**
 * Represents the DataValidation.
 */
class Validation extends ChildProperty {
}
__decorate([
    Property('WholeNumber')
], Validation.prototype, "type", void 0);
__decorate([
    Property('Between')
], Validation.prototype, "operator", void 0);
__decorate([
    Property('0')
], Validation.prototype, "value1", void 0);
__decorate([
    Property('0')
], Validation.prototype, "value2", void 0);
__decorate([
    Property(true)
], Validation.prototype, "ignoreBlank", void 0);
__decorate([
    Property(true)
], Validation.prototype, "inCellDropDown", void 0);
__decorate([
    Property(false)
], Validation.prototype, "isHighlighted", void 0);
__decorate([
    Property('')
], Validation.prototype, "address", void 0);
/**
 * Represents the Format.
 */
class Format extends ChildProperty {
}
__decorate([
    Property('General')
], Format.prototype, "format", void 0);
__decorate([
    Complex({}, CellStyle)
], Format.prototype, "style", void 0);
__decorate([
    Property(true)
], Format.prototype, "isLocked", void 0);
/**
 * Represents the Conditional Formatting.
 *
 */
class ConditionalFormat extends ChildProperty {
}
__decorate([
    Property('GreaterThan')
], ConditionalFormat.prototype, "type", void 0);
__decorate([
    Complex({}, Format)
], ConditionalFormat.prototype, "format", void 0);
__decorate([
    Property('RedFT')
], ConditionalFormat.prototype, "cFColor", void 0);
__decorate([
    Property('')
], ConditionalFormat.prototype, "value", void 0);
__decorate([
    Property('')
], ConditionalFormat.prototype, "range", void 0);
__decorate([
    Property('')
], ConditionalFormat.prototype, "action", void 0);
/**
 * Represents the Legend.
 *
 */
class LegendSettings extends ChildProperty {
}
__decorate([
    Property(true)
], LegendSettings.prototype, "visible", void 0);
__decorate([
    Property('Auto')
], LegendSettings.prototype, "position", void 0);
/**
 * Represents the DataLabelSettings.
 *
 */
class DataLabelSettings extends ChildProperty {
}
__decorate([
    Property(false)
], DataLabelSettings.prototype, "visible", void 0);
__decorate([
    Property('Auto')
], DataLabelSettings.prototype, "position", void 0);
/**
 * Represents the Border.
 *
 */
class Border extends ChildProperty {
}
__decorate([
    Property('')
], Border.prototype, "color", void 0);
__decorate([
    Property(1)
], Border.prototype, "width", void 0);
/**
 * Represents the MarkerSettings.
 *
 */
class MarkerSettings extends ChildProperty {
}
__decorate([
    Property(false)
], MarkerSettings.prototype, "visible", void 0);
__decorate([
    Property('Circle')
], MarkerSettings.prototype, "shape", void 0);
__decorate([
    Property(5)
], MarkerSettings.prototype, "size", void 0);
__decorate([
    Property(null)
], MarkerSettings.prototype, "fill", void 0);
__decorate([
    Property(true)
], MarkerSettings.prototype, "isFilled", void 0);
__decorate([
    Complex({}, Border)
], MarkerSettings.prototype, "border", void 0);
/**
 * Specifies the major grid lines in the `axis`.
 *
 */
class MajorGridLines extends ChildProperty {
}
__decorate([
    Property(0)
], MajorGridLines.prototype, "width", void 0);
/**
 * Specifies the minor grid lines in the `axis`.
 *
 */
class MinorGridLines extends ChildProperty {
}
__decorate([
    Property(0)
], MinorGridLines.prototype, "width", void 0);
/**
 * Represents the axis.
 *
 */
class Axis extends ChildProperty {
}
__decorate([
    Property('')
], Axis.prototype, "title", void 0);
__decorate([
    Complex({}, MajorGridLines)
], Axis.prototype, "majorGridLines", void 0);
__decorate([
    Complex({}, MinorGridLines)
], Axis.prototype, "minorGridLines", void 0);
__decorate([
    Property(true)
], Axis.prototype, "visible", void 0);
/**
 * Represents the Chart.
 */
class Chart extends ChildProperty {
}
__decorate([
    Property('Line')
], Chart.prototype, "type", void 0);
__decorate([
    Property('Material')
], Chart.prototype, "theme", void 0);
__decorate([
    Property(false)
], Chart.prototype, "isSeriesInRows", void 0);
__decorate([
    Complex({}, MarkerSettings)
], Chart.prototype, "markerSettings", void 0);
__decorate([
    Property('')
], Chart.prototype, "range", void 0);
__decorate([
    Property('')
], Chart.prototype, "id", void 0);
__decorate([
    Property('')
], Chart.prototype, "title", void 0);
__decorate([
    Property(290)
], Chart.prototype, "height", void 0);
__decorate([
    Property(480)
], Chart.prototype, "width", void 0);
__decorate([
    Property(0)
], Chart.prototype, "top", void 0);
__decorate([
    Property(0)
], Chart.prototype, "left", void 0);
__decorate([
    Complex({}, LegendSettings)
], Chart.prototype, "legendSettings", void 0);
__decorate([
    Complex({}, Axis)
], Chart.prototype, "primaryXAxis", void 0);
__decorate([
    Complex({}, Axis)
], Chart.prototype, "primaryYAxis", void 0);
__decorate([
    Complex({}, DataLabelSettings)
], Chart.prototype, "dataLabelSettings", void 0);
/**
 * Represents the Image.
 */
class Image$1 extends ChildProperty {
}
__decorate([
    Property('')
], Image$1.prototype, "src", void 0);
__decorate([
    Property('')
], Image$1.prototype, "id", void 0);
__decorate([
    Property(300)
], Image$1.prototype, "height", void 0);
__decorate([
    Property(400)
], Image$1.prototype, "width", void 0);
__decorate([
    Property(0)
], Image$1.prototype, "top", void 0);
__decorate([
    Property(0)
], Image$1.prototype, "left", void 0);
/**
 * Represents the AutoFillSettings.
 */
class AutoFillSettings extends ChildProperty {
}
__decorate([
    Property('FillSeries')
], AutoFillSettings.prototype, "fillType", void 0);
__decorate([
    Property(true)
], AutoFillSettings.prototype, "showFillOptions", void 0);

/**
 * Specifies Workbook internal events.
 */
/** @hidden */
const workbookDestroyed = 'workbookDestroyed';
/** @hidden */
const updateSheetFromDataSource = 'updateSheetFromDataSource';
/** @hidden */
const dataSourceChanged = 'dataSourceChanged';
/** @hidden */
const dataChanged = 'dataChanged';
/** @hidden */
const triggerDataChange = 'triggerDataChange';
/** @hidden */
const workbookOpen = 'workbookOpen';
/** @hidden */
const beginSave = 'beginSave';
/** @hidden */
const beginAction = 'actionBegin';
/** @hidden */
const sortImport = 'sortImport';
/** @hidden */
const findToolDlg = 'findToolDlg';
/** @hidden */
const exportDialog = 'exportDialog';
/** @hidden */
const setFilteredCollection = 'setFilteredCollection';
/** @hidden */
const saveCompleted = 'saveCompleted';
/** @hidden */
const applyNumberFormatting = 'applyNumber';
/** @hidden */
const getFormattedCellObject = 'getFormattedCell';
/** @hidden */
const calculateFormula = 'calculateFormula';
/** @hidden */
const refreshCellElement = 'refreshCellElem';
/** @hidden */
const setCellFormat = 'setCellFormat';
/** @hidden */
const findAllValues = 'findAllValues';
/** @hidden */
const textDecorationUpdate = 'textDecorationUpdate';
/** @hidden */
const applyCellFormat = 'applyCellFormat';
/** @hidden */
const updateUsedRange = 'updateUsedRange';
/** @hidden */
const updateRowColCount = 'updateRowColCount';
/** @hidden */
const workbookFormulaOperation = 'workbookFormulaOperation';
/** @hidden */
const workbookEditOperation = 'workbookEditOperation';
/** @hidden */
const checkDateFormat = 'checkDateFormat';
/** @hidden */
const checkNumberFormat = 'checkNumberFormat';
/** @hidden */
const parseDecimalNumber = 'parseDecimalNumber';
/** @hidden */
const getFormattedBarText = 'getFormattedBarText';
/** @hidden */
const activeCellChanged = 'activeCellChanged';
/** @hidden */
const openSuccess = 'openSuccess';
/** @hidden */
const openFailure = 'openFailure';
/** @hidden */
const sheetCreated = 'sheetCreated';
/** @hidden */
const sheetsDestroyed = 'sheetsDestroyed';
/** @hidden */
const aggregateComputation = 'aggregateComputation';
/** @hidden */
const getUniqueRange = 'getUniqueRange';
/** @hidden */
const removeUniquecol = 'removeUniquecol';
/** @hidden */
const checkUniqueRange = 'checkUniqueRange';
/** @hidden */
const reApplyFormula = 'reApplyFormula';
/** @hidden */
const clearFormulaDependentCells = 'clearFormulaDependentCells';
/** @hidden */
const formulaInValidation = 'formulaInValidation';
/** @hidden */
const beforeSort = 'beforeSort';
/** @hidden */
const initiateSort = 'initiateSort';
/** @hidden */
const updateSortedDataOnCell = 'updateSortedDataOnCell';
/** @hidden */
const sortComplete = 'sortComplete';
/** @hidden */
const sortRangeAlert = 'sortRangeAlert';
/** @hidden */
const initiatelink = 'initiatelink';
/** @hidden */
const beforeHyperlinkCreate = 'beforeHyperlinkCreate';
/** @hidden */
const afterHyperlinkCreate = 'afterHyperlinkCreate';
/** @hidden */
const beforeHyperlinkClick = 'beforeHyperlinkClick';
/** @hidden */
const afterHyperlinkClick = 'afterHyperlinkClick';
/** @hidden */
const addHyperlink = 'addHyperlink';
/** @hidden */
const setLinkModel = 'setLinkModel';
/** @hidden */
const beforeFilter = 'beforeFilter';
/** @hidden */
const initiateFilter = 'initiateFilter';
/** @hidden */
const filterComplete = 'filterComplete';
/** @hidden */
const filterRangeAlert = 'filterRangeAlert';
/** @hidden */
const clearAllFilter = 'clearAllFilter';
/** @hidden */
const wrapEvent = 'wrapText';
/** @hidden */
const onSave = 'onSave';
/** @hidden */
const insert = 'insert';
/** @hidden */
const deleteAction = 'delete';
/** @hidden */
const insertModel = 'insertModel';
/** @hidden */
const deleteModel = 'deleteModel';
/** @hidden */
const isValidation = 'isValidation';
/** @hidden */
const cellValidation = 'cellValidation';
/** @hidden */
const addHighlight = 'addHighlight';
/** @hidden */
const dataValidate = 'dataValidate';
/** @hidden */
const find = 'find';
/** @hidden */
const goto = 'gotoHandler';
/** @hidden */
const findWorkbookHandler = 'findHandler';
/** @hidden */
const replace = 'replace';
/** @hidden */
const replaceAll = 'replaceAll';
/** @hidden */
const showFindAlert = 'showFindAlert';
/** @hidden */
const findKeyUp = 'findKeyUp';
/** @hidden */
const removeHighlight = 'removeHighlight';
/** @hidden */
const queryCellInfo = 'queryCellInfo';
/** @hidden */
const count = 'count';
/** @hidden */
const findCount = 'findCount';
/** @hidden */
const protectSheetWorkBook = 'protectSheet';
/** @hidden */
const updateToggle = 'updateToggleItem';
/** @hidden */
const protectsheetHandler = 'protectsheetHandler';
/** @hidden */
const replaceAllDialog = 'replaceAllDialog';
/** @hidden */
const unprotectsheetHandler = 'unprotectsheetHandler';
/** @hidden */
const workBookeditAlert = 'editAlert';
/** @hidden */
const workbookReadonlyAlert = 'readonlyAlert';
/** @hidden */
const setLockCells = 'setLockCells';
/** @hidden */
const applyLockCells = 'applyLockCells';
/** @hidden */
const setMerge = 'setMerge';
/** @hidden */
const applyMerge = 'applyMerge';
/** @hidden */
const mergedRange = 'mergedRange';
/** @hidden */
const activeCellMergedRange = 'activeCellMergedRange';
/** @hidden */
const insertMerge = 'insertMerge';
/** @hidden */
const hideShow = 'hideShow';
/** @hidden */
const setCFRule = 'setCFRule';
/** @hidden */
const applyCF = 'applyCF';
/** @hidden */
const clearCFRule = 'clearCFRule';
/** @hidden */
const clear = 'clear';
/** @hidden */
const clearCF = 'clearCF';
/** @hidden */
const setImage = 'setImage';
/** @hidden */
const setChart = 'setChart';
/** @hidden */
const initiateChart = 'initiateChart';
/** @hidden */
const refreshRibbonIcons = 'refreshRibbonIcons';
/** @hidden */
const refreshChart = 'refreshChart';
/** @hidden */
const refreshChartSize = 'refreshChartSize';
/** @hidden */
const deleteChartColl = 'deleteChartColl';
/** @hidden */
const initiateChartModel = 'initiateChartModel';
/** @hidden */
const focusChartBorder = 'focusChartBorder';
/** @hidden */
const saveError = 'saveError';
/** @hidden */
const updateHighlight = 'updateHighlight';
/** @hidden */
const beforeInsert = 'beforeInsert';
/** @hidden */
const beforeDelete = 'beforeDelete';
/** @hidden */
const deleteHyperlink = 'deleteHyperlink';
/** @hidden */
const moveOrDuplicateSheet = 'moveOrDuplicateSheet';
/** @hidden */
const setAutoFill = 'setAutoFill';
/** @hidden */
const refreshCell = 'refreshCell';
/** @hidden */
const getFillInfo = 'getFillInfo';
/** @hidden */
const getautofillDDB = 'getautofillDDB';
/** @hidden */
const rowFillHandler = 'rowFillHandler';
/** @hidden */
const getTextSpace = 'getTextSpace';
/** @hidden */
const refreshClipboard = 'refreshClipboard';
/** @hidden */
const updateView = 'updateView';
/** @hidden */
const selectionComplete = 'selectionComplete';
/** @hidden */
const refreshInsertDelete = 'refreshInsertDelete';
/** @hidden */
const getUpdatedFormulaOnInsertDelete = 'getUpdatedFormulaOnInsertDelete';
/** @hidden */
const beforeCellUpdate = 'beforeCellUpdate';
/** @hidden */
const duplicateSheetFilterHandler = 'duplicateSheetFilterHandler';
/** @hidden */
const unMerge = 'unMerge';
/** @hidden */
const checkFormulaRef = 'checkFormulaRef';
/** @hidden */
const parseFormulaArgument = 'parseFormulaArgument';
/** @hidden */
const getCellRefValue = 'getCellRefValue';
/** @hidden */
const commputeFormulaValue = 'commputeFormulaValue';
/** @hidden */
const getChartRowIdxFromClientY = 'getChartRowIdxFromClientY';
/** @hidden */
const getChartColIdxFromClientX = 'getChartColIdxFromClientX';
/** @hidden */
const refreshChartCellOnInit = 'refreshChartCellOnInit';
/** @hidden */
const localizedFormatAction = 'localizedFormatAction';
/** @hidden */
const moveSheetHandler = 'moveSheetHandler';
/** @hidden */
const addListValidationDropdown = 'addListValidationDropdown';
/** @hidden */
const sheetRenameUpdate = 'sheetRenameUpdate';
/** @hidden */
const updateSortCollection = 'updateSortCollection';

/**
 * Check the value of the cell is number with thousand separator and currency symbol and returns the parsed value.
 *
 * @param {CellModel} cell - Specifies the cell.
 * @param {string} locale - Specifies the locale.
 * @param {string} groupSep - Specifies the group separator.
 * @param {string} decimalSep - Specifies the decimal separator.
 * @param {string} currencySym - Specifies the currency Symbol.
 * @param {boolean} isFractionalType - Defines whether the value is a fractional type or not.
 * @param {boolean} checkCurrency - Specifies the currency check.
 * @returns {Object} - returns the parsed value.
 * @hidden
 */
function checkIsNumberAndGetNumber(cell, locale, groupSep, decimalSep, currencySym, isFractionalType, checkCurrency) {
    let cellValue = cell.value;
    if (cellValue && typeof cellValue === 'string') {
        if (cellValue.includes('\n')) {
            return { isNumber: false, value: cellValue };
        }
        if (isNumber(cellValue)) {
            return { isNumber: true, value: cellValue };
        }
        if (currencySym && cellValue.includes(currencySym) && (checkCurrency || cell.format.includes(currencySym) || cell.format.includes('$'))) {
            cellValue = cellValue.replace(currencySym, '').trim();
        }
        if (groupSep && cellValue.includes(groupSep) && parseThousandSeparator(cellValue, locale, groupSep, decimalSep)) {
            cellValue = cellValue.split(groupSep).join('').trim();
        }
        if (!decimalSep) {
            decimalSep = getNumericObject(locale).decimal;
        }
        if (decimalSep !== '.' && cellValue.includes(decimalSep)) {
            cellValue = cellValue.replace(decimalSep, '.').trim();
        }
        if (isNumber(cellValue)) {
            return { isNumber: true, value: cellValue };
        }
        if (isFractionalType && cellValue.split('/').length === 2) {
            try {
                const splittedVal = cellValue.split(' ');
                if (splittedVal.length === 2 && splittedVal[0].split('/').length === 1) {
                    const result = evaluate(splittedVal[0]);
                    const result1 = evaluate(splittedVal[1]);
                    cellValue = result + result1;
                }
                else {
                    cellValue = evaluate(cellValue);
                }
                return { isNumber: true, value: cellValue };
            }
            catch (error) {
                return { isNumber: false, value: cellValue };
            }
        }
    }
    else if (isNumber(cellValue)) {
        return { isNumber: true, value: cellValue };
    }
    return { isNumber: false, value: cellValue };
}
/**
 * @param {string} value - Specifies the value.
 * @param {string} locale - Specifies the locale.
 * @param {string} groupSep - Specifies the group separator.
 * @param {string} decimalSep - Specifies the decimal separator.
 * @returns {boolean} - Returns parsed thousand separator.
 * @hidden
 */
function parseThousandSeparator(value, locale, groupSep, decimalSep) {
    let isParsed = false;
    const number = 123456;
    const parsedNum = number.toLocaleString(locale);
    const splitedNum = parsedNum.split(groupSep).reverse();
    const splitedValue = value.split(decimalSep)[0].split(groupSep);
    for (let i = 0; i < splitedValue.length; i++) {
        if (i === splitedValue.length - 1) {
            isParsed = splitedValue[i].length === splitedNum[0].length;
        }
        else {
            isParsed = !isUndefined$1(splitedNum[1]) && (i === 0 ? splitedValue[i].length <= splitedNum[1].length :
                splitedValue[i].length === splitedNum[1].length);
        }
        if (!isParsed) {
            break;
        }
    }
    return isParsed;
}

/**
 * Check whether the text is formula or not.
 *
 * @param {string} text - Specify the text.
 * @param {boolean} isEditing - Specify the isEditing.
 * @returns {boolean} - Check whether the text is formula or not.
 */
function checkIsFormula(text, isEditing) {
    return text && text[0] === '=' && (text.length > 1 || isEditing);
}
/**
 * Check whether the value is cell reference or not.
 *
 * @param {string} value - Specify the value to check.
 * @returns {boolean} - Returns boolean value
 */
function isCellReference(value) {
    let range = value;
    range = range.split('$').join('');
    if (range.indexOf(':') > -1) {
        const rangeSplit = range.split(':');
        if (isValidCellReference(rangeSplit[0]) && isValidCellReference(rangeSplit[1])) {
            return true;
        }
    }
    else if (range.indexOf(':') < 0) {
        if (isValidCellReference(range)) {
            return true;
        }
    }
    return false;
}
/**
 * Check whether the value is character or not.
 *
 * @param {string} value - Specify the value to check.
 * @returns {boolean} - Returns boolean value
 */
function isChar(value) {
    if ((value.charCodeAt(0) >= 65 && value.charCodeAt(0) <= 90) || (value.charCodeAt(0) >= 97 && value.charCodeAt(0) <= 122)) {
        return true;
    }
    return false;
}
/**
 * Check whether the range selection is on complete row.
 *
 * @param {SheetModel} sheet - Specify the sheet.
 * @param {number[]} range - Specify the range index.
 * @returns {boolean} - Returns boolean value
 * @hidden
 */
function isRowSelected(sheet, range) {
    return range[1] === 0 && range[3] === sheet.colCount - 1;
}
/**
 * Check whether the range selection is on complete column.
 *
 * @param {SheetModel} sheet - Specify the sheet.
 * @param {number[]} range - Specify the range index.
 * @returns {boolean} - Returns boolean value
 * @hidden
 */
function isColumnSelected(sheet, range) {
    return range[0] === 0 && range[2] === sheet.rowCount - 1;
}
/**
 * @param {number[]} range - Specify the range
 * @param {number} rowIdx - Specify the row index
 * @param {number} colIdx - Specify the col index
 * @returns {boolean} - Returns boolean value
 */
function inRange(range, rowIdx, colIdx) {
    return range && (rowIdx >= range[0] && rowIdx <= range[2] && colIdx >= range[1] && colIdx <= range[3]);
}
/**
 * @param {number[]} address - Specify the address
 * @param {number} rowIdx - Specify the row index
 * @param {number} colIdx - Specify the col index
 * @returns {boolean} - Returns boolean value
 */
function isInMultipleRange(address, rowIdx, colIdx) {
    let range;
    let isInRange;
    const splitedAddress = address.split(' ');
    for (let i = 0, len = splitedAddress.length; i < len; i++) {
        range = getRangeIndexes(splitedAddress[i]);
        isInRange = inRange(range, rowIdx, colIdx);
        if (isInRange) {
            break;
        }
    }
    return isInRange;
}
/** @hidden
 * @param {number[]} range - Specify the range
 * @param {number[]} testRange - Specify the test range
 * @param {boolean} isModify - Specify the boolean value
 * @returns {boolean} - Returns boolean value
 */
function isInRange(range, testRange, isModify) {
    let inRange = range[0] <= testRange[0] && range[2] >= testRange[2] && range[1] <= testRange[1] && range[3] >= testRange[3];
    if (inRange) {
        return true;
    }
    if (isModify) {
        if (testRange[0] < range[0] && testRange[2] < range[0] || testRange[0] > range[2] && testRange[2] > range[2]) {
            return false;
        }
        else {
            if (testRange[0] < range[0] && testRange[2] > range[0]) {
                testRange[0] = range[0];
                inRange = true;
            }
            if (testRange[2] > range[2]) {
                testRange[2] = range[2];
                inRange = true;
            }
        }
        if (testRange[1] < range[1] && testRange[3] < range[1] || testRange[1] > range[3] && testRange[3] > range[3]) {
            return false;
        }
        else {
            if (testRange[1] < range[1] && testRange[3] > range[1]) {
                testRange[1] = range[1];
                inRange = true;
            }
            if (testRange[3] > range[3]) {
                testRange[3] = range[3];
                inRange = true;
            }
        }
    }
    return inRange;
}
/**
 * @hidden
 * @param {string} address - Specifies the address for whole column.
 * @param {number[]} testRange - Specifies range used to split the address.
 * @param {number} colIdx - Specifies the column index.
 * @returns {string} - returns the modified address.
 */
function getSplittedAddressForColumn(address, testRange, colIdx) {
    const colName = getColumnHeaderText(colIdx + 1);
    if (address) {
        address.split(' ').forEach((addrs) => {
            const range = getRangeIndexes(addrs);
            if (isInRange(range, testRange)) {
                address = address.split(addrs).join(colName + (range[0] + 1) +
                    ':' + colName + testRange[0] + ' ' + colName + (testRange[2] + 2) +
                    ':' + colName + (range[2] + 1));
            }
            else if (isInRange(range, testRange, true)) {
                let modifiedAddress;
                if (testRange[0] > range[0]) {
                    modifiedAddress = colName + (range[0] + 1) + ':' + colName + testRange[0];
                }
                else {
                    modifiedAddress = colName + (testRange[2] + 2) + ':' + colName + (range[2] + 1);
                }
                address = address.split(addrs).join(modifiedAddress);
            }
        });
    }
    else {
        address = colName + '1:' + colName + testRange[0] + ' ' + colName + (testRange[2] + 2) + ':' + colName + '1048576';
    }
    return address;
}
/**
 * Check whether the cell is locked or not
 *
 * @param {CellModel} cell - Specify the cell.
 * @param {ColumnModel} column - Specify the column.
 * @returns {boolean} - Returns boolean value
 * @hidden
 */
function isLocked(cell, column) {
    if (!cell) {
        cell = {};
    }
    if (cell.isLocked) {
        return true;
    }
    else if (cell.isLocked === false) {
        return false;
    }
    else if (column && column.isLocked) {
        return true;
    }
    else if (!cell.isLocked && (column && column.isLocked !== false)) {
        return true;
    }
    return false;
}
/**
 * Check whether the value is cell reference or not.
 *
 * @param {string} value - Specify the value to check.
 * @returns {boolean} - Returns boolean value
 * @hidden
 */
function isValidCellReference(value) {
    const text = value;
    const startNum = 0;
    let endNum = 0;
    let cellText = '';
    const textLength = text.length;
    for (let i = 0; i < textLength; i++) {
        if (isChar(text[i])) {
            endNum++;
        }
    }
    cellText = text.substring(startNum, endNum);
    const cellTextLength = cellText.length;
    if (cellTextLength !== textLength) {
        if (cellTextLength < 4) {
            if (textLength !== 1 && (isNaN(parseInt(text, 10)))) {
                const cellColIndex = columnIndex(cellText);
                // XFD is the last column, 16384 - Maximum number of columns in excel.
                if (cellColIndex > 16384) {
                    return false;
                }
                const cellNumber = parseFloat(text.substring(endNum, textLength));
                if (cellNumber > 0 && cellNumber < 1048577) { // 1048576 - Maximum number of rows in excel.
                    return true;
                }
            }
        }
    }
    return false;
}
/**
 * To get the column index of the given cell.
 *
 * @param {string} cell - Cell address for getting column index.
 * @returns {number} - To get the column index of the given cell.
 * @hidden
 */
function columnIndex(cell) {
    let j = 0;
    let k = 0;
    cell = cell.toUpperCase();
    if (j < cell.length && cell[j] === '!') {
        j++;
        while (j < cell.length && cell[j] !== '!') {
            j++;
        }
        j++;
    }
    while (j < cell.length && isChar(cell[j])) {
        const charCode = cell[j].charCodeAt(0);
        k = k * 26 + charCode - 64;
        j++;
    }
    if (k === 0) {
        return -1;
    }
    return k;
}
/**
 * @hidden
 * @param {SheetModel} sheet - Specify the sheet
 * @param {number} index - specify the index
 * @param {boolean} increase - specify the boolean value.
 * @param {string} layout - specify the string
 * @param {number} count - specify the count.
 * @returns {number} - To skip the hidden index
 *
 */
function skipHiddenIdx(sheet, index, increase, layout = 'rows', count) {
    let rowColObj;
    if (increase) {
        for (let i = index; i < Infinity; i++) {
            rowColObj = sheet[`${layout}`];
            if (rowColObj[index] && rowColObj[index].hidden) {
                index++;
            }
            else {
                if (count) {
                    count--;
                    index++;
                }
                else {
                    break;
                }
            }
        }
    }
    else {
        for (let i = index; i > -1; i--) {
            rowColObj = sheet[`${layout}`];
            if (rowColObj[index] && rowColObj[index].hidden) {
                index--;
            }
            else {
                break;
            }
        }
    }
    return index;
}
/**
 * @param {CellStyleModel} style - Cell style.
 * @param {boolean} onActionUpdate - Specifies the action.
 * @returns {boolean} - retruns `true` is height needs to be checked.
 * @hidden
 */
function isHeightCheckNeeded(style, onActionUpdate) {
    const keys = Object.keys(style);
    return (onActionUpdate ? keys.indexOf('fontSize') > -1 : keys.indexOf('fontSize') > -1
        && Number(style.fontSize.split('pt')[0]) > 12) || keys.indexOf('fontFamily') > -1 || keys.indexOf('borderTop') > -1
        || keys.indexOf('borderBottom') > -1;
}
/**
 * @param {number[]} currIndexes - current indexes in which formula get updated
 * @param {number[]} prevIndexes - copied indexes
 * @param {SheetModel} sheet - sheet model
 * @param {Workbook} context - Represents workbook instance
 * @param {CellModel} prevCell - Copied or previous cell model
 * @param {boolean} isSort - Represents sort action
 * @returns {string} - retruns updated formula
 * @hidden
 */
function getUpdatedFormula(currIndexes, prevIndexes, sheet, context, prevCell, isSort) {
    let cIdxValue;
    let cell;
    if (prevIndexes) {
        cell = prevCell || getCell(prevIndexes[0], prevIndexes[1], sheet, false, true);
        cIdxValue = cell.formula || '';
    }
    if (cIdxValue) {
        if (isSort) {
            context.notify(clearFormulaDependentCells, { cellRef: getCellAddress(prevIndexes[0], prevIndexes[1]) });
        }
        if (cIdxValue.indexOf('=') === 0) {
            cIdxValue = cIdxValue.slice(1);
        }
        cIdxValue = cIdxValue.split('(').join(context.listSeparator).split(')').join(context.listSeparator);
        const formulaOperators = ['+', '-', '*', '/', '>=', '<=', '<>', '>', '<', '=', '%', '&'];
        let splitArray;
        let value = cIdxValue;
        for (let i = 0; i < formulaOperators.length; i++) {
            splitArray = value.split(formulaOperators[i]);
            value = splitArray.join(context.listSeparator);
        }
        splitArray = value.split(context.listSeparator);
        const newAddress = [];
        let newRef;
        let refObj;
        let isSheetRef;
        let cellRefSheet;
        let cellRef;
        for (let j = 0; j < splitArray.length; j++) {
            isSheetRef = splitArray[j].includes('!');
            if (isSheetRef) {
                const lastIndex = splitArray[j].lastIndexOf('!');
                cellRefSheet = splitArray[j].substring(0, lastIndex);
                cellRef = splitArray[j].substring(lastIndex + 1).toUpperCase();
            }
            else {
                cellRef = splitArray[j].toUpperCase();
            }
            if (isCellReference(cellRef.trim()) && !cellRef.includes('$')) {
                const leadingSpaces = getLeadingSpaces(cellRef);
                const trailingSpaces = getTrailingSpaces(cellRef);
                const range = getRangeIndexes(cellRef);
                const newRange = [currIndexes[0] - (prevIndexes[0] - range[0]), currIndexes[1] - (prevIndexes[1] - range[1]),
                    currIndexes[0] - (prevIndexes[0] - range[2]), currIndexes[1] - (prevIndexes[1] - range[3])];
                if (newRange[1] < 0 || newRange[2] < 0 || newRange[3] < 0 || (!isSort && newRange[0] < 0)) {
                    newRef = '#REF!';
                }
                else {
                    if (isSort && newRange[0] < 0) {
                        newRange[0] = newRange[2];
                    }
                    newRef = getCellAddress(newRange[0], newRange[1]);
                    if (cellRef.includes(':')) {
                        newRef += (':' + getCellAddress(newRange[2], newRange[3]));
                    }
                    newRef = isCellReference(newRef) ? newRef : '#REF!';
                }
                refObj = {};
                if (isSheetRef) {
                    newRef = `${cellRefSheet}!${newRef}`;
                }
                refObj[splitArray[j]] = `${leadingSpaces}${newRef}${trailingSpaces}`;
                if (splitArray[j].includes(':')) {
                    newAddress.splice(0, 0, refObj);
                }
                else {
                    newAddress.push(refObj);
                }
            }
        }
        let objKey;
        let objValue;
        cIdxValue = cell.formula;
        let newCIdxValue = cIdxValue;
        for (let j = 0; j < newAddress.length; j++) {
            objKey = Object.keys(newAddress[j])[0];
            objValue = newAddress[j][`${objKey}`];
            const objKeyLen = objKey.length;
            const positionIdx = newCIdxValue.indexOf(objKey);
            let emptyString = '';
            for (let idx = 0; idx < objValue.length; idx++) {
                emptyString += ' ';
            }
            cIdxValue = cIdxValue.slice(0, positionIdx) + objValue + cIdxValue.slice(positionIdx + objKeyLen);
            newCIdxValue = newCIdxValue.slice(0, positionIdx) + emptyString + newCIdxValue.slice(positionIdx + objKeyLen);
        }
        return cIdxValue;
    }
    else {
        return null;
    }
}
/**
 * Retrieves the leading spaces from a given string.
 *
 * @param {string} string - The input string from which to retrieve leading spaces.
 * @returns {string} - A string containing all leading spaces from the input string.
 * @hidden
 */
function getLeadingSpaces(string) {
    let leadingSpaces = '';
    for (let i = 0; i < string.length; i++) {
        if (string[i] === ' ') {
            leadingSpaces += ' ';
        }
        else {
            break;
        }
    }
    return leadingSpaces;
}
/**
 * Retrieves the trailing spaces from a given string.
 *
 * @param {string} string - The input string from which to retrieve trailing spaces.
 * @returns {string} - A string containing all trailing spaces from the input string.
 * @hidden
 */
function getTrailingSpaces(string) {
    let trailingSpaces = '';
    for (let i = string.length - 1; i >= 0; i--) {
        if (string[i] === ' ') {
            trailingSpaces = ' ' + trailingSpaces;
        }
        else {
            break;
        }
    }
    return trailingSpaces;
}
/**
 * @param {Workbook} context - Specifies the context.
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {CellUpdateArgs} prop - Specifies the props.
 * @param {BeforeActionData} actionData - It holds the undoRedoCollection cell details.
 * @param {boolean} isUndo - It holds the undo information.
 * @returns {boolean} - returns args cancel value.
 * @hidden */
function updateCell(context, sheet, prop, actionData, isUndo) {
    const args = { cell: prop.cell, rowIndex: prop.rowIdx, colIndex: prop.colIdx, cancel: false, sheet: sheet.name };
    if (!prop.preventEvt) { // Prevent event triggering for public method cell update.
        context.trigger(beforeCellUpdate, args);
    }
    if (!prop.eventOnly && !args.cancel) { // `eventOnly` - To trigger event and return without cell model update.
        if (prop.valChange) {
            const prevCell = getCell(args.rowIndex, args.colIndex, sheet);
            const prevCellVal = !prop.preventEvt && context.getDisplayText(prevCell);
            const isFormulaCell = !!(prevCell && prevCell.formula);
            setCell(args.rowIndex, args.colIndex, sheet, args.cell, !prop.pvtExtend);
            const cell = getCell(args.rowIndex, args.colIndex, sheet, false, true);
            if (prop.mergedCells) {
                delete cell.value;
                delete cell.formula;
            }
            if (cell.formattedText) {
                delete cell.formattedText;
            }
            const evtArgs = {
                action: 'updateCellValue',
                address: [args.rowIndex, args.colIndex], sheetIndex: getSheetIndex(context, sheet.name), value: isFormulaCell && !cell.formula ? (cell.value || (cell.value === 0 ? '0' : '')) :
                    (cell.formula || cell.value || (cell.value === 0 ? '0' : '')),
                skipFormatCheck: prop.skipFormatCheck, isRandomFormula: prop.isRandomFormula,
                isDelete: prop.isDelete, deletedRange: prop.deletedRange, fillType: prop.fillType,
                cellInformation: actionData, isRedo: !isUndo, actionName: prop.fillType,
                isPaste: prop.requestType === 'paste'
            };
            context.notify(workbookEditOperation, evtArgs);
            prop.isFormulaDependent = evtArgs.isFormulaDependent;
            if (prop.requestType && args.cell === null) {
                setCell(args.rowIndex, args.colIndex, sheet, args.cell, !prop.pvtExtend);
            }
            if (prop.cellDelete) {
                delete cell.value;
                delete cell.formula;
                delete cell.hyperlink;
            }
            if (prop.uiRefresh) {
                context.serviceLocator.getService('cell').refresh(args.rowIndex, args.colIndex, prop.lastCell, prop.td, prop.checkCF, prop.checkWrap, prop.skipFormatCheck, prop.isRandomFormula, prop.fillType);
            }
            if (!prop.preventEvt) {
                const cellDisplayText = context.getDisplayText(cell);
                if (cellDisplayText !== prevCellVal) {
                    let cellValue = getCell(args.rowIndex, args.colIndex, sheet, false, true).value;
                    cellValue = cellValue || (cellValue === 0 ? '0' : '');
                    const evtArgs = { value: cellValue, oldValue: prevCellVal, formula: cell.formula || '',
                        address: `${sheet.name}!${getCellAddress(args.rowIndex, args.colIndex)}`, displayText: cellDisplayText };
                    if (prop.requestType) {
                        evtArgs.requestType = prop.requestType;
                    }
                    context.trigger('cellSave', evtArgs);
                }
            }
        }
        else {
            setCell(args.rowIndex, args.colIndex, sheet, args.cell, !prop.pvtExtend);
        }
    }
    return args.cancel;
}
/**
 * @param {number} rowIdx - row index
 * @param {number} colIdx - column index
 * @param {SheetModel} sheet - sheet model
 * @returns {number[]} - retruns data range
 * @hidden
 */
function getDataRange(rowIdx, colIdx, sheet) {
    let sRowIdx = rowIdx;
    let eRowIdx = rowIdx;
    let sColIdx = colIdx;
    let eColIdx = colIdx;
    const usedRowIdx = sheet.usedRange.rowIndex;
    const usedColIdx = sheet.usedRange.colIndex;
    const isEmptyRow = (idx) => {
        for (let i = 0; i <= usedColIdx; i++) {
            if (!isUndefined$1(getCell(idx, i, sheet, null, true).value)) {
                return false;
            }
        }
        return true;
    };
    const isEmptyColumn = (idx) => {
        for (let i = sRowIdx; i <= eRowIdx; i++) {
            if (!isUndefined$1(getCell(i, idx, sheet, null, true).value)) {
                return false;
            }
        }
        return true;
    };
    for (let i = sRowIdx; i <= usedRowIdx; i++) { // To find end row index
        if (isUndefined$1(getCell(i, colIdx, sheet, null, true).value) && isEmptyRow(i)) {
            break;
        }
        else {
            eRowIdx = i;
        }
    }
    for (let i = sRowIdx; i >= 0; i--) { // To find start row index
        if (isUndefined$1(getCell(i, colIdx, sheet, null, true).value) && isEmptyRow(i)) {
            break;
        }
        else {
            sRowIdx = i;
        }
    }
    for (let i = sColIdx; i <= usedColIdx; i++) { // To find end column index
        if (isUndefined$1(getCell(rowIdx, i, sheet, null, true).value) && isEmptyColumn(i)) {
            break;
        }
        else {
            eColIdx = i;
        }
    }
    for (let i = sColIdx; i >= 0; i--) { // To find start column index
        if (isUndefined$1(getCell(rowIdx, i, sheet, null, true).value) && isEmptyColumn(i)) {
            break;
        }
        else {
            sColIdx = i;
        }
    }
    return [sRowIdx, sColIdx, eRowIdx, eColIdx];
}
/**
 * @param {InsertDeleteModelArgs} args - row index
 * @param {number[]} formatRange - format range index
 * @param {boolean} isAction - specifies isAction.
 * @returns {number[]} - retruns updated range
 * @hidden
 */
function insertFormatRange(args, formatRange, isAction) {
    let sltRangeIndex = getRangeIndexes(args.model.selectedRange);
    let insertStartIndex = 0;
    let insertEndIndex = 0;
    if (args.modelType === 'Column') {
        if (isAction || (args.insertType === 'before' && args.isUndoRedo)) {
            sltRangeIndex = [0, args.start, 0, args.end];
        }
        if (args.insertType === 'before') {
            if ((formatRange[1] <= sltRangeIndex[1] && formatRange[3] >= sltRangeIndex[1])) {
                insertStartIndex = 0;
                insertEndIndex = (sltRangeIndex[3] - sltRangeIndex[1]) + 1;
            }
            else if (sltRangeIndex[1] < formatRange[1]) {
                insertStartIndex = insertEndIndex = (sltRangeIndex[3] - sltRangeIndex[1]) + 1;
            }
        }
        else {
            if (args.isUndoRedo) {
                const diffValue = (args.end - args.start) + 1;
                sltRangeIndex = [0, args.start - diffValue, 0, args.end - diffValue];
            }
            if ((formatRange[1] <= sltRangeIndex[3] && formatRange[3] >= sltRangeIndex[3])) {
                insertStartIndex = 0;
                insertEndIndex = (sltRangeIndex[3] - sltRangeIndex[1]) + 1;
            }
            else if (sltRangeIndex[3] < formatRange[3]) {
                insertStartIndex = insertEndIndex = (sltRangeIndex[3] - sltRangeIndex[1]) + 1;
            }
        }
        return [formatRange[0], formatRange[1] + insertStartIndex, formatRange[2], formatRange[3] + insertEndIndex];
    }
    else {
        if (isAction || (args.insertType === 'above' && args.isUndoRedo)) {
            sltRangeIndex = [args.start, 0, args.end, 0];
        }
        if (args.insertType === 'above') {
            if ((formatRange[0] <= sltRangeIndex[0] && formatRange[2] >= sltRangeIndex[0])) {
                insertStartIndex = 0;
                insertEndIndex = (sltRangeIndex[2] - sltRangeIndex[0]) + 1;
            }
            else if (sltRangeIndex[0] < formatRange[0]) {
                insertStartIndex = insertEndIndex = (sltRangeIndex[2] - sltRangeIndex[0]) + 1;
            }
        }
        else {
            if (args.isUndoRedo) {
                const diffValue = (args.end - args.start) + 1;
                sltRangeIndex = [args.start - diffValue, 0, args.end - diffValue, 0];
            }
            if ((formatRange[0] <= sltRangeIndex[2] && formatRange[2] >= sltRangeIndex[2])) {
                insertStartIndex = 0;
                insertEndIndex = (sltRangeIndex[2] - sltRangeIndex[0]) + 1;
            }
            else if (sltRangeIndex[2] < formatRange[2]) {
                insertStartIndex = insertEndIndex = (sltRangeIndex[2] - sltRangeIndex[0]) + 1;
            }
        }
        return [formatRange[0] + insertStartIndex, formatRange[1], formatRange[2] + insertEndIndex, formatRange[3]];
    }
}
/**
 * @param {InsertDeleteModelArgs} args - row index
 * @param {number[]} formatRange - cell range index
 * @returns {number[]} - retruns data range
 * @hidden
 */
function deleteFormatRange(args, formatRange) {
    let cellRange;
    let deleteStartIndex = 0;
    let deleteEndIndex = 0;
    if (args.modelType === 'Column') {
        cellRange = [0, args.start, args.model.usedRange.rowIndex, args.end];
        if (cellRange[3] < formatRange[1]) {
            deleteStartIndex = deleteEndIndex = cellRange[3] - cellRange[1] + 1;
        }
        else if (cellRange[1] >= formatRange[1] && cellRange[3] <= formatRange[3]) {
            deleteEndIndex = cellRange[3] - cellRange[1] + 1;
        }
        else if (cellRange[1] >= formatRange[1] && cellRange[1] <= formatRange[3]) {
            deleteEndIndex = formatRange[3] - cellRange[1] + 1;
        }
        else if (cellRange[1] < formatRange[1] && cellRange[3] >= formatRange[1]) {
            deleteStartIndex = formatRange[1] - cellRange[1];
            deleteEndIndex = cellRange[3] - cellRange[1] + 1;
        }
        else if (cellRange[1] < formatRange[1] && cellRange[3] < formatRange[3]) {
            deleteStartIndex = (cellRange[3] - formatRange[1]) + (cellRange[3] - cellRange[1]) + 1;
            deleteEndIndex = cellRange[3] - cellRange[1] + 1;
        }
        return [formatRange[0], formatRange[1] - deleteStartIndex, formatRange[2], formatRange[3] - deleteEndIndex];
    }
    else {
        cellRange = [args.start, 0, args.end, args.model.usedRange.colIndex];
        if (cellRange[2] < formatRange[0]) {
            deleteStartIndex = deleteEndIndex = cellRange[2] - cellRange[0] + 1;
        }
        else if (cellRange[0] >= formatRange[0] && cellRange[2] <= formatRange[2]) {
            deleteEndIndex = cellRange[2] - cellRange[0] + 1;
        }
        else if (cellRange[0] >= formatRange[0] && cellRange[0] <= formatRange[2]) {
            deleteEndIndex = formatRange[2] - cellRange[0] + 1;
        }
        else if (cellRange[0] < formatRange[0] && cellRange[2] >= formatRange[0]) {
            deleteStartIndex = formatRange[0] - cellRange[0];
            deleteEndIndex = cellRange[2] - cellRange[0] + 1;
        }
        else if (cellRange[0] < formatRange[0] && cellRange[2] < formatRange[2]) {
            deleteStartIndex = (cellRange[2] - formatRange[0]) + (cellRange[2] - cellRange[0]) + 1;
            deleteEndIndex = cellRange[2] - cellRange[0] + 1;
        }
        return [formatRange[0] - deleteStartIndex, formatRange[1], formatRange[2] - deleteEndIndex, formatRange[3]];
    }
}
/**
 * @param {ConditionalFormat[]} curCF - Specifies current Conditional formatting.
 * @param {ConditionalFormatModel[]} cfRule - Specifies conditional formatting rules.
 * @param {number} rowIdx - Specifies the row index.
 * @param {number} colIdx -Specifies the col index.
 * @param {number[]} startRanges - Specifies conditional formatting origin index.
 * @param {number[]} fillRanges - Specifies the conditional formatting fill ranges.
 * @param {SheetModel} sheet -Specifies the conditional formatted sheet.
 * @returns {void} - Updates Conditional formatting model.
 * @hidden
 */
function updateCFModel(curCF, cfRule, rowIdx, colIdx, startRanges, fillRanges, sheet) {
    let cfRange;
    let indexes;
    for (let i = curCF.length - 1; i >= 0; i--) {
        cfRange = curCF[i].range.trim().split(',');
        for (let j = 0; j < cfRange.length; j++) {
            indexes = getRangeIndexes(cfRange[j].includes(':') ? cfRange[j] :
                `${cfRange[j]}:${cfRange[j]}`);
            if (rowIdx >= indexes[0] && colIdx >= indexes[1] && rowIdx <= indexes[2] && colIdx <= indexes[3]) {
                cfRule.push(curCF[i]);
                curCF.splice(i, 1);
                break;
            }
            else if (startRanges && startRanges[0] >= indexes[0] && startRanges[1] >= indexes[1] &&
                startRanges[0] <= indexes[2] && startRanges[1] <= indexes[3]) {
                const newCondiFormat = {
                    action: 'autofillWithCF',
                    cFColor: curCF[i].cFColor,
                    range: getRangeAddress(fillRanges),
                    type: curCF[i].type,
                    value: curCF[i].value
                };
                curCF.splice(i, 1);
                for (let i = 0, cfMembers = sheet.conditionalFormats; i < cfMembers.length; i++) {
                    if (cfMembers[i].action === 'autofillWithCF' && cfMembers[i].range === newCondiFormat.range) {
                        break;
                    }
                    else if (i === cfMembers.length - 1) {
                        cfRule.push(newCondiFormat);
                        sheet.conditionalFormats.push(newCondiFormat);
                    }
                }
                break;
            }
        }
    }
}
/**
 * @param {number} indexes - Specifies the indexes.
 * @param {string} range - Specifies the range.
 * @returns {boolean} - Return is range or not.
 * @hidden
 */
function checkRange(indexes, range) {
    const ranges = range.trim().split(',');
    let left;
    let right;
    let top;
    let bottom;
    let cfIdx;
    const checkRange = (idx) => {
        for (let i = 0; i < ranges.length; i++) {
            cfIdx = getRangeIndexes(ranges[i].includes(':') ? ranges[i] : `${ranges[i]}:${ranges[i]}`);
            if (idx[0] <= cfIdx[0] && idx[1] <= cfIdx[1] && idx[2] >= cfIdx[2] && idx[3] >= cfIdx[3]) {
                return true;
            }
            else {
                top = idx[0] >= cfIdx[0] && idx[0] <= cfIdx[2];
                bottom = idx[2] >= cfIdx[0] && idx[2] <= cfIdx[2];
                left = idx[1] >= cfIdx[1] && idx[1] <= cfIdx[3];
                right = idx[3] >= cfIdx[1] && idx[3] <= cfIdx[3];
                if (top && bottom) {
                    if (left || right || (idx[1] < cfIdx[1] && idx[3] > cfIdx[3])) {
                        if (idx[0] - cfIdx[0] > 0) {
                            return true;
                        }
                        if (cfIdx[2] - idx[2] > 0) {
                            return true;
                        }
                    }
                    if (left && idx[1] !== cfIdx[1]) {
                        return true;
                    }
                    if (right && idx[3] !== cfIdx[3]) {
                        return true;
                    }
                }
                else if (left && right) {
                    if (top || bottom || (idx[0] < cfIdx[0] && idx[2] > cfIdx[2])) {
                        if (idx[1] - cfIdx[1] > 0) {
                            return true;
                        }
                        if (cfIdx[3] - idx[3] > 0) {
                            return true;
                        }
                    }
                    if (top) {
                        if (idx[0] !== cfIdx[0]) {
                            return true;
                        }
                    }
                    else if (bottom && idx[2] !== cfIdx[2]) {
                        return true;
                    }
                }
                else if (top || bottom) {
                    if (left) {
                        if (idx[1] !== cfIdx[1]) {
                            return true;
                        }
                        if (idx[0] - cfIdx[0] > 0) {
                            return true;
                        }
                        else if (cfIdx[2] - idx[2] > 0) {
                            return true;
                        }
                    }
                    else if (right) {
                        if (idx[3] !== cfIdx[3]) {
                            return true;
                        }
                        if (idx[0] - cfIdx[0] > 0) {
                            return true;
                        }
                        else if (cfIdx[2] - idx[2] > 0) {
                            return true;
                        }
                    }
                    else if (idx[1] < cfIdx[1] && idx[3] > cfIdx[3]) {
                        return true;
                    }
                }
                else if ((left || right) && idx[0] < cfIdx[0] && idx[2] > cfIdx[2]) {
                    return true;
                }
            }
        }
        return false;
    };
    for (let j = 0; j < indexes.length; j++) {
        if (checkRange(indexes[j])) {
            return true;
        }
    }
    return false;
}
/**
 * Parse the formatted text to get the actual cell value.
 *
 * @param {string[]} valArr - Specifies the value array.
 * @param {string} context - Specifies the workbook instance.
 * @param {LocaleNumericSettings} numObj - Specifies the locale numeric options like decimal and group separators.
 * @returns {string[]} - Returns the parsed number collection.
 * @hidden
 */
function parseLocaleNumber(valArr, context, numObj) {
    let formatArgs;
    if (!numObj) {
        numObj = getNumericObject(context.locale);
    }
    for (let idx = 0; idx < valArr.length; idx++) {
        if (isNumber(valArr[idx])) {
            if (numObj.group === '.') {
                valArr[idx] = valArr[idx].toString();
                if (valArr[idx].indexOf('.') &&
                    parseThousandSeparator(valArr[idx], context.locale, numObj.group, numObj.decimal)) {
                    valArr[idx] = valArr[idx].split(numObj.group).join('');
                }
            }
        }
        else {
            formatArgs = { formattedText: valArr[idx], value: valArr[idx], format: 'General',
                cell: { value: valArr[idx], format: 'General' }, isEdit: true };
            context.notify(getFormattedCellObject, formatArgs);
            if (isNumber(formatArgs.value)) {
                valArr[idx] = formatArgs.value.toString();
            }
        }
    }
    return valArr;
}
/**
 * Returns the overall viewport indexes by including the freeze and movable part.
 *
 * @param {Workbook} parent - Specify the Workbook object.
 * @param {number} viewport - Specifies the top, bottom, left, and right index of the current viewport.
 * @param {number} viewport.topIndex - Specifies the top index of the current viewport.
 * @param {number} viewport.leftIndex - Specifies the left index of the current viewport.
 * @param {number} viewport.bottomIndex - Specifies the bottom index of the current viewport.
 * @param {number} viewport.rightIndex - Specifies the right index of the current viewport.
 * @returns {number} - Returns the viewport indexes.
 * @hidden
 */
function getViewportIndexes(parent, viewport) {
    const sheet = parent.getActiveSheet();
    const indexes = [[viewport.topIndex + parent.frozenRowCount(sheet), viewport.leftIndex + parent.frozenColCount(sheet),
            viewport.bottomIndex, viewport.rightIndex]];
    if (sheet.frozenRows || sheet.frozenColumns) {
        const froezenRow = parent.frozenRowCount(sheet);
        const froezenCol = parent.frozenColCount(sheet);
        const topLeftCell = getCellIndexes(sheet.topLeftCell);
        if (froezenRow && froezenCol) {
            indexes.push([topLeftCell[0], topLeftCell[1], froezenRow - 1, froezenCol - 1]);
            const paneTopLeftCell = getCellIndexes(sheet.paneTopLeftCell);
            indexes.push([paneTopLeftCell[0], topLeftCell[1], viewport.bottomIndex, froezenCol - 1]);
        }
        if (froezenRow) {
            indexes.push([topLeftCell[0], viewport.leftIndex + froezenCol, froezenRow - 1, viewport.rightIndex]);
        }
        if (froezenCol) {
            indexes.push([viewport.topIndex + froezenRow, topLeftCell[1], viewport.bottomIndex,
                froezenCol - 1]);
        }
    }
    return indexes;
}
/**
 * If the primary cell in the merged range row/column is hidden, then this method will update
 * the next visible row/column index within the merged range.
 *
 * @param {VisibleMergeIndexArgs} args - Specifies the args.
 * @returns {void} - Update the next visible row/column index within the merged range.
 */
function setVisibleMergeIndex(args) {
    if (isHiddenRow(args.sheet, args.rowIdx)) {
        const idx = skipHiddenIdx(args.sheet, args.rowIdx, true);
        if (idx < args.rowIdx + args.cell.rowSpan) {
            args.rowIdx = idx;
            args.isMergedHiddenCell = true;
        }
    }
    if (isHiddenCol(args.sheet, args.colIdx)) {
        const idx = skipHiddenIdx(args.sheet, args.colIdx, true, 'columns');
        if (idx < args.colIdx + args.cell.colSpan) {
            args.colIdx = idx;
            args.isMergedHiddenCell = true;
        }
    }
}
/**
 * Check whether the sheets are imported.
 *
 * @param {Workbook} context - Specifies the spreadsheet instance.
 * @returns {boolean} - It returns true if the sheets are imported otherwise false.
 * @hidden
 */
function isImported(context) {
    return context.workbookOpenModule && context.workbookOpenModule.preventFormatCheck;
}
/**
 * Return a function that will auto-detect the number format of the formatted cell value.
 *
 * @param {Workbook} context - Specifies the Workbook instance.
 * @returns {void} - Defines the common variables and returns the auto-detect number format function.
 * @hidden
 */
function getAutoDetectFormatParser(context) {
    const intl = new Internationalization();
    const eventArgs = { intl: intl, updateValue: true, value: '',
        curSymbol: getNumberDependable(context.locale, defaultCurrencyCode) };
    const options = { args: eventArgs, intl: intl };
    const localeNumObj = getNumericObject(context.locale);
    return (cell) => {
        if (!cell.format && cell.value && !isNumber(cell.value)) {
            eventArgs.cell = cell;
            eventArgs.value = cell.value;
            context.notify(checkDateFormat, eventArgs);
            if (!cell.format) {
                let cellVal = cell.value.toString();
                if (cellVal.includes(options.args.curSymbol) || cellVal.includes(localeNumObj.group) || cellVal.includes('%')) {
                    options.fResult = cellVal;
                    context.notify(checkNumberFormat, options);
                }
                else if (localeNumObj.decimal !== '.' && !isNumber(cellVal)) {
                    if (cellVal.includes(localeNumObj.decimal)) {
                        cellVal = cellVal.replace(localeNumObj.decimal, '.');
                        if (isNumber(cellVal)) {
                            cell.value = cellVal;
                        }
                    }
                }
            }
        }
    };
}
/**
 *
 * @param {DataManager} dataManager - Specifies the Datamanager.
 * @param {Predicate[]} predicates - Specifies the predicates.
 * @param {Predicate[]} equalOrPredicates - Specifies the equal or predicates.
 * @returns {Object[]} - Returns apply predicates object.
 * @hidden
 */
function applyPredicates(dataManager, predicates, equalOrPredicates) {
    let query = new Query();
    if (predicates.length) {
        query.where(Predicate.and(predicates));
    }
    let result = dataManager.executeLocal(query);
    if (equalOrPredicates) {
        for (let idx = 0, predicateCollLen = equalOrPredicates.length; idx < predicateCollLen; idx++) {
            if (!result.length) {
                break;
            }
            query = new Query();
            if (equalOrPredicates[idx].length) {
                query.where(Predicate.or(equalOrPredicates[idx]));
            }
            result = new DataManager(result).executeLocal(query);
        }
    }
    return result;
}
/**
 * Checks whether the cell is read-only or not.
 *
 * @param {CellModel} cell - The cell to check.
 * @param {ColumnModel} column - The column associated with the cell.
 * @param {RowModel} row - The row associated with the cell.
 * @returns {boolean} - Returns true if the cell is read-only, otherwise false.
 * @hidden
 */
function isReadOnly(cell, column, row) {
    return (cell && cell.isReadOnly) || (row && row.isReadOnly) || (column && column.isReadOnly);
}
/**
 * Checks whether a specific range of cells is read-only or not.
 *
 * @param {Workbook} parent - The spreadsheet instance.
 * @param {number[]} rangeIndexes - The range indexes to check.
 * @returns {boolean} - Returns true if any of the cells is read-only, otherwise false.
 * @hidden
 */
function isReadOnlyCells(parent, rangeIndexes) {
    const sheet = parent.getActiveSheet();
    let hasReadOnlyCell;
    const address = !isNullOrUndefined(rangeIndexes) ? rangeIndexes : getSwapRange(getRangeIndexes(sheet.selectedRange));
    for (let row = address[0]; row <= address[2]; row++) {
        for (let col = address[1]; col <= address[3]; col++) {
            const cell = getCell(row, col, sheet);
            if (isReadOnly(cell, getColumn(sheet, col), getRow(sheet, row))) {
                hasReadOnlyCell = true;
                break;
            }
        }
    }
    return hasReadOnlyCell;
}
/**
 * Checks whether the selected range in the sheet is an entire row or column and returns the updated range accordingly.
 *
 * @param {SheetModel} sheet -Specifies the sheet.
 * @param {string} range - Specify the range that need to be updated.
 * @returns {string} - Retruns updated range
 * @hidden
 */
function getUpdatedRange(sheet, range) {
    let updateRange = range || sheet.selectedRange;
    const indexes = getRangeIndexes(updateRange);
    const maxColCount = sheet.colCount;
    const maxRowCount = sheet.rowCount;
    if (indexes[2] === maxRowCount - 1 && indexes[0] === 0) {
        updateRange = updateRange.replace(/[0-9]/g, '');
    }
    else if (indexes[3] === maxColCount - 1 && indexes[2] === 0) {
        updateRange = updateRange.replace(/\D/g, '');
    }
    return updateRange;
}
/**
 * Updated the top border of the adjacent merged cells
 *
 * @param {Workbook} context - The spreadsheet instance.
 * @param {number[]} rowIndexes - An array of row indexes that top border need to be updated.
 * @param {number[]} colIndexes - An array of col indexes that top border need to be updated.
 * @returns {void}
 * @hidden
 */
function updateMergeBorder(context, rowIndexes, colIndexes) {
    if (!rowIndexes.length) {
        return;
    }
    const sheet = context.getActiveSheet();
    let style;
    const parent = context;
    const frozenCol = context.frozenColCount(sheet);
    const startCol = (colIndexes && colIndexes[0]) ||
        (frozenCol ? getCellIndexes(sheet.topLeftCell)[1] : parent.viewport.leftIndex);
    const endCol = (colIndexes && colIndexes[1]) || parent.viewport.rightIndex;
    rowIndexes.forEach((rowIdx) => {
        for (let col = startCol; col <= endCol; col++) {
            if (col === frozenCol) {
                col += parent.viewport.leftIndex;
            }
            const prevModel = getCell(rowIdx - 1, col, sheet, false, true);
            if (((!prevModel.rowSpan || prevModel.rowSpan === 1)
                || (!prevModel.colSpan || prevModel.colSpan === 1)) &&
                (!prevModel.style || !prevModel.style.borderBottom || prevModel.style.borderBottom === 'none')) {
                style = getCell(rowIdx, col, sheet, false, true).style;
                if (style && style.borderTop) {
                    const prevCell = context.getCell(rowIdx - 1, col);
                    if (prevCell && prevCell.style.borderBottom) {
                        const curCell = context.getCell(rowIdx, col);
                        if (curCell) {
                            prevCell.style.borderBottom = '';
                            curCell.style.borderTop = style.borderTop;
                        }
                    }
                }
            }
        }
    });
}

/**
 * @hidden
 * @param {number} val - Specifies the val.
 * @returns {string} - To get Fraction.
 */
function toFraction(val) {
    const strVal = val.toString();
    if (val === parseInt(strVal, 10)) {
        return parseInt(strVal, 10) + '  ';
    }
    else {
        const top = strVal.indexOf('.') > -1 ? strVal.split('.')[1] : 0;
        const bottom = Math.pow(10, top.toString().replace('-', '').length);
        const abs = Math.abs(getGcd(top, bottom));
        return (top / abs) + '/' + (bottom / abs);
    }
}
/**
 * @hidden
 * @param {string | number} a - Specifies the a.
 * @param {string | number} b - Specifies the b.
 * @returns {number} - To get Gcd.
 */
function getGcd(a, b) {
    a = Number(a);
    b = Number(b);
    return (b) ? getGcd(b, a % b) : a;
}
/**
 * @hidden
 * @param {number} val - Specifies the value.
 * @returns {Date} - Returns Date.
 */
function intToDate(val) {
    val = Number(val);
    val = (val > 0 && val < 1) ? (1 + val) : (val === 0) ? 1 : val;
    if (val > 60) {
        val -= 1; // Due to leap year issue of 1900 in MSExcel.
    }
    const startDate = new Date('01/01/1900');
    const startDateUTC = Date.UTC(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), startDate.getHours(), startDate.getMinutes(), startDate.getSeconds(), startDate.getMilliseconds());
    return new Date(new Date(((val - 1) * (1000 * 3600 * 24)) + startDateUTC).toUTCString().replace(' GMT', ''));
}
/* eslint-disable  @typescript-eslint/no-explicit-any */
/**
 * @hidden
 * @param {number} val - Specifies the value.
 * @param {boolean} isTime - Specifies the boolean value.
 * @param {boolean} isTimeOnly - Specifies the value is only a time without date.
 * @returns {number} - Returns number.
 */
function dateToInt(val, isTime, isTimeOnly) {
    const startDate = new Date('01/01/1900');
    const date = isDateTime(val) ? val : new Date(val);
    const startDateUTC = Date.UTC(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), startDate.getHours(), startDate.getMinutes(), startDate.getSeconds(), startDate.getMilliseconds());
    const dateUTC = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
    const diffDays = ((dateUTC - startDateUTC) / (1000 * 3600 * 24));
    return (isTime ? diffDays : parseInt(diffDays.toString(), 10)) + (isTimeOnly ? 0 : (diffDays > 60 ? 2 : 1));
}
/**
 * @hidden
 * @param {any} date - Specifies the date.
 * @returns {boolean} - Returns boolean value.
 */
function isDateTime(date) {
    return Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date.valueOf());
}
/**
 * @hidden
 * @param {string} val - Specifies the value.
 * @returns {boolean} - Returns boolean value.
 */
function isNumber(val) {
    return val - parseFloat(val) >= 0;
}
/**
 * @hidden
 * @param {string | number} val - Specifies the value.
 * @returns {string} - Returns converted value.
 */
function evaluate(val) {
    return Function('"use strict";return (' + val + ')')();
}
/**
 * @hidden
 * @param {Date | string | number} text - Specifies the text.
 * @param {Internationalization} intl - Specifies the Internationalization.
 * @param {string} locale - Specifies the locale.
 * @param {string} format - Specifies the string.
 * @param {CellModel} cell - Specify the cell.
 * @param {boolean} isDateTime -Specify is DateTime value or not.
 * @returns {ToDateArgs} - Returns Date format.
 */
function toDate(text, intl, locale, format, cell, isDateTime) {
    const defaultDateFormats = IntlBase.getDependables(cldrData, locale, null).dateObject;
    const availabelDateTimeFormat = defaultDateFormats.dateTimeFormats.availableFormats;
    const dObj = { dateObj: null, isCustom: false, type: '' };
    let dateVal;
    const updateTime = () => {
        if (dObj.type === 'time') {
            dObj.dateObj = new Date((dateVal ? dateVal.toDateString() : '01/01/1900') + ' ' + dObj.dateObj.toLocaleTimeString());
        }
    };
    if (format) {
        dObj.dateObj = intl.parseDate(text, { format: format });
        if (dObj.dateObj) {
            dObj.type = text.toString().indexOf(':') > -1 ? 'time' : 'datetime';
            updateTime();
            dObj.isCustom = true;
        }
    }
    if (isNullOrUndefined(dObj.dateObj)) {
        text = text.toString();
        if (text && text.indexOf('/') > -1 || text.indexOf('-') > 0) {
            let cFormat = (cell && cell.format) || format;
            if (cFormat) {
                const hyphenDate = cFormat.toLowerCase().includes('dd-mm-yy');
                if (hyphenDate || cFormat.toLowerCase().includes('dd/mm/yy')) {
                    cFormat = hyphenDate ? 'd-M-y' : 'd/M/y';
                    dObj.dateObj = intl.parseDate(text, { format: cFormat, skeleton: 'yMd' });
                    if (dObj.dateObj) {
                        dObj.type = 'date';
                        return dObj;
                    }
                }
            }
        }
        const parseDateTimeValue = (text) => {
            if (text.indexOf(':') < 0) {
                for (const key of Object.keys(defaultDateFormats.dateFormats)) {
                    dObj.dateObj = intl.parseDate(text, { format: defaultDateFormats.dateFormats[`${key}`], skeleton: key });
                    if (dObj.dateObj) {
                        dObj.type = 'date';
                        dObj.isCustom = false;
                        break;
                    }
                }
            }
            if (isNullOrUndefined(dObj.dateObj)) {
                let dateTimeFormat;
                for (const key of Object.keys(availabelDateTimeFormat)) {
                    dateTimeFormat = availabelDateTimeFormat[`${key}`];
                    dObj.dateObj = intl.parseDate(text, { format: dateTimeFormat, skeleton: key });
                    if (!dObj.dateObj && text.indexOf(':') > -1 && dateTimeFormat.indexOf(':') > -1) { // parsing time format without am or pm
                        dObj.dateObj = intl.parseDate(text, { format: dateTimeFormat.split(' ')[0] });
                    }
                    if (dObj.dateObj) {
                        dObj.type = text.toString().indexOf(':') > -1 ? 'time' : 'datetime';
                        updateTime();
                        dObj.isCustom = true;
                        break;
                    }
                }
            }
            if (isNullOrUndefined(dObj.dateObj)) {
                for (const key of Object.keys(defaultDateFormats.timeFormats)) {
                    dObj.dateObj = intl.parseDate(text, { format: defaultDateFormats.timeFormats[`${key}`], skeleton: key });
                    if (dObj.dateObj) {
                        dObj.type = 'time';
                        updateTime();
                        dObj.isCustom = false;
                        break;
                    }
                }
            }
        };
        if (isDateTime) {
            const dateTimeArr = text.split(' ');
            if (dateTimeArr.length >= 2) {
                parseDateTimeValue(dateTimeArr.shift());
                if (dObj.dateObj) {
                    dateVal = dObj.dateObj;
                    dObj.dateObj = null;
                    parseDateTimeValue(dateTimeArr.join(' '));
                    if (dObj.dateObj) {
                        dObj.type = 'datetime';
                    }
                }
            }
        }
        else {
            parseDateTimeValue(text);
        }
    }
    if (text !== '#DIV/0!' && !dObj.dateObj && new Date(text).toString() !== 'Invalid Date') {
        dObj.dateObj = new Date(text);
        dObj.type = 'date';
    }
    return dObj;
}
/**
 * @hidden
 * @param {string} value - Specifies the value.
 * @param {boolean} isPaste - Optional flag indicating whether the value came from a paste action.
 * @param {boolean} isFromExternalPaste - Optional flag indicating whether the value came from a getExternalCells method.
 * @returns { string | number} - ReturnsparseIntValue.
 */
function parseIntValue(value, isPaste, isFromExternalPaste) {
    if (value && value !== '.' && value !== '-') {
        let val = value.toString();
        const maxSafeIntegerLength = Number.MAX_SAFE_INTEGER.toString().length;
        if (val.startsWith('-')) {
            val = val.slice(1);
            val = val.includes('-') ? value : val;
        }
        if (/^\d*\.?\d*$/.test(val)) {
            // If the number is longer than the safe integer length.
            if (isPaste && (val.length > maxSafeIntegerLength || (isFromExternalPaste && (val.startsWith('0') || val.endsWith('0'))))) {
                return value; //skip parsefloat to get the precise value while pasting.
            }
            else {
                return parseFloat(value);
            }
        }
    }
    return value;
}

/** @hidden */
const workbookLocale = 'spreadsheetLocale';
/**
 * Workbook locale text
 *
 * @hidden
 */
const localeData = {
    SortOutOfRangeError: 'Select a cell or range inside the used range and try again.'
};

/**
 * Update data source to Sheet and returns Sheet
 *
 * @param {Workbook} context - Specifies the context.
 * @param {string} address - Specifies the address.
 * @param {boolean} columnWiseData - Specifies the bool value.
 * @param {boolean} valueOnly - Specifies the valueOnly.
 * @param {number[]} frozenIndexes - Specifies the freeze row and column start indexes, if it is scrolled.
 * @param {boolean} filterDialog - Specifies the bool value.
 * @param {string} formulaCellRef - Specifies the formulaCellRef.
 * @param {number} idx - Specifies the idx.
 * @param {boolean} skipHiddenRows - Specifies the skipHiddenRows.
 * @param {string} commonAddr - Specifies the common address for the address parameter specified with list of range separated by ','.
 * @param {number} dateValueForSpecificColIdx - Specify the dateValueForSpecificColIdx.
 * @param {Object} dateColData - Specify the dateColData.
 * @returns {Promise<Map<string, CellModel> | Object[]>} - To get the data
 * @hidden
 */
function getData(context, address, columnWiseData, valueOnly, frozenIndexes, filterDialog, formulaCellRef, idx, skipHiddenRows = true, commonAddr, dateValueForSpecificColIdx, dateColData) {
    return new Promise((resolve) => {
        resolve((() => {
            let sheetIdx;
            const lastIndex = address.lastIndexOf('!');
            if (lastIndex > -1) {
                sheetIdx = getSheetIndex(context, address.substring(0, lastIndex));
                address = address.substring(lastIndex + 1);
            }
            else {
                sheetIdx = context.activeSheetIndex;
            }
            const sheet = getSheet(context, sheetIdx);
            let indexes = getIndexesFromAddress(commonAddr || address);
            const args = {
                sheet: sheet, indexes: indexes, formulaCellRef: formulaCellRef, sheetIndex: idx,
                promise: new Promise((resolve) => { resolve((() => { })()); })
            };
            context.notify(updateSheetFromDataSource, args);
            return args.promise.then(() => {
                let i;
                let row;
                let data;
                let sRow = indexes[0];
                const frozenRow = context.frozenRowCount(sheet);
                const frozenCol = context.frozenColCount(sheet);
                const isDateCol = !!dateColData;
                if (columnWiseData) {
                    data = [];
                    let index;
                    let cells;
                    let parsedNumVal;
                    let key;
                    let cellProp;
                    let localeObj;
                    let intl;
                    let autoDetectFormatFn;
                    if (valueOnly) {
                        localeObj = getNumericObject(context.locale);
                        intl = new Internationalization(context.locale);
                    }
                    else {
                        autoDetectFormatFn = getAutoDetectFormatParser(context);
                    }
                    address.split(',').forEach((addr, addrIdx) => {
                        indexes = getRangeIndexes(addr);
                        index = 0;
                        sRow = indexes[0];
                        while (sRow <= indexes[2]) {
                            cells = data[index] || {};
                            row = getRow(sheet, sRow);
                            i = indexes[1];
                            while (i <= indexes[3]) {
                                if (skipHiddenRows && isHiddenRow(sheet, sRow) && !(filterDialog && isFilterHidden(sheet, sRow))) {
                                    sRow++;
                                    continue;
                                }
                                key = getColumnHeaderText(i + 1);
                                const cell = row ? getCell(sRow, i, sheet) : null;
                                if (valueOnly) {
                                    if (cell && (cell.value || cell.value === 0)) {
                                        if (cell.formattedText && cell.format && !cell.format.includes('*')) {
                                            if (isCustomDateTime(cell.format, false)) {
                                                cells[key] = intToDate(cell.value);
                                            }
                                            else {
                                                cells[key] = cell.formattedText.toString().trim();
                                            }
                                        }
                                        else {
                                            cells[key] = getValueFromFormat(context, cell, sRow, i, false, intl);
                                        }
                                        cellProp = cell.value;
                                        if (typeof cellProp === 'string') {
                                            if (localeObj.decimal !== '.' && cellProp.includes(localeObj.decimal)) {
                                                parsedNumVal = cellProp.replace(localeObj.decimal, '.');
                                                if (isNumber(parsedNumVal)) {
                                                    cellProp = parseFloat(parsedNumVal);
                                                }
                                            }
                                            else if (isNumber(cellProp)) {
                                                cellProp = parseFloat(cellProp);
                                            }
                                        }
                                    }
                                    else {
                                        cells[key] = '';
                                        cellProp = null;
                                    }
                                    cells[`${key}_value`] = cellProp;
                                }
                                else {
                                    if ((cell && (cell.formula || !isNullOrUndefined(cell.value))) || Object.keys(cells).length) {
                                        if (i === dateValueForSpecificColIdx) {
                                            cellProp = { value: getValueFromFormat(context, cell, sRow, i, true) };
                                            if (cellProp.value && typeof cellProp.value === 'string') {
                                                if (isNumber(cellProp.value) && !cell.value.toString().includes('\n')) {
                                                    if (!cell.format || cell.format !== '@') {
                                                        cellProp.value = parseFloat(cellProp.value);
                                                    }
                                                }
                                                else if (!cell.format) {
                                                    autoDetectFormatFn(cell);
                                                    if (isNumber(cell.value) && !cell.value.toString().includes('\n')) {
                                                        cellProp.value = parseFloat(cell.value);
                                                    }
                                                }
                                            }
                                            cells[key] = extend({}, cell, cellProp);
                                        }
                                        else {
                                            cells[key] = cell;
                                        }
                                    }
                                    if (cell && ((!!cell.rowSpan && cell.rowSpan !== 1) || (!!cell.colSpan && cell.colSpan !== 1))) {
                                        data = [{ throwMergeAlert: true }];
                                        return;
                                    }
                                }
                                if (i === indexes[3] && Object.keys(cells).length) {
                                    cells['__rowIndex'] = (sRow + 1).toString();
                                    data[index] = cells;
                                    if (isDateCol && addrIdx === 0 && !isFilterHidden(sheet, sRow)) {
                                        dateColData.push(cells);
                                    }
                                    index++;
                                }
                                i++;
                            }
                            sRow++;
                        }
                    });
                }
                else {
                    data = new Map();
                    const checkFrozenIdx = !!(!valueOnly && frozenIndexes && frozenIndexes.length);
                    while (sRow <= indexes[2]) {
                        if (checkFrozenIdx && sRow >= frozenRow && sRow < frozenIndexes[0]) {
                            sRow = frozenIndexes[0];
                            continue;
                        }
                        if (!valueOnly && isHiddenRow(sheet, sRow)) {
                            sRow++;
                            continue;
                        }
                        row = getRow(sheet, sRow);
                        i = indexes[1];
                        while (i <= indexes[3]) {
                            const eventArgs = { cell: getCell(sRow, i, sheet), address: getCellAddress(sRow, i),
                                rowIndex: sRow, colIndex: i };
                            context.trigger(queryCellInfo, eventArgs);
                            const cellObj = getCell(sRow, i, sheet, false, true);
                            if (cellObj.formula && cellObj.formula.toUpperCase().includes('UNIQUE')) {
                                context.notify(calculateFormula, { cell: cellObj, rowIdx: sRow, colIdx: i, sheetIndex: context.activeSheetIndex,
                                    address: eventArgs.address });
                            }
                            if (cellObj.colSpan > 1 && cellObj.rowSpan > 1) {
                                let cell;
                                for (let j = sRow, len = sRow + cellObj.rowSpan; j < len; j++) {
                                    for (let k = i, len = i + cellObj.colSpan; k < len; k++) {
                                        if (j === sRow && k === i) {
                                            continue;
                                        }
                                        cell = new Object();
                                        if (j !== sRow) {
                                            cell.rowSpan = sRow - j;
                                        }
                                        if (k !== i) {
                                            cell.colSpan = i - k;
                                        }
                                        if (sheet.rows[j] && sheet.rows[j].cells &&
                                            sheet.rows[j].cells[k]) {
                                            delete sheet.rows[j].cells[k].value;
                                            delete sheet.rows[j].cells[k].formula;
                                        }
                                        setCell(j, k, sheet, cell, true);
                                    }
                                }
                            }
                            else if (cellObj.colSpan > 1) {
                                for (let j = i + 1, len = i + cellObj.colSpan; j < len; j++) {
                                    setCell(sRow, j, sheet, { colSpan: i - j }, true);
                                    if (sheet.rows[sRow] && sheet.rows[sRow].cells &&
                                        sheet.rows[sRow].cells[j]) {
                                        delete sheet.rows[sRow].cells[j].value;
                                        delete sheet.rows[sRow].cells[j].formula;
                                    }
                                }
                            }
                            else if (cellObj.rowSpan > 1) {
                                for (let j = sRow + 1, len = sRow + cellObj.rowSpan; j < len; j++) {
                                    setCell(j, i, sheet, { rowSpan: sRow - j }, true);
                                    if (sheet.rows[j] && sheet.rows[j].cells &&
                                        sheet.rows[j].cells[i]) {
                                        delete sheet.rows[j].cells[i].value;
                                        delete sheet.rows[j].cells[i].formula;
                                    }
                                }
                            }
                            if (!valueOnly && isHiddenCol(sheet, i)) {
                                i++;
                                continue;
                            }
                            if (checkFrozenIdx && i >= frozenCol && i < frozenIndexes[1]) {
                                i = frozenIndexes[1];
                                continue;
                            }
                            if (cellObj.style) {
                                const style = {};
                                Object.assign(style, cellObj.style);
                                cellObj.style = style;
                            }
                            data.set(eventArgs.address, cellObj);
                            i++;
                        }
                        sRow++;
                    }
                }
                return data;
            });
        })());
    });
}
/**
 * Used to get the formatted value of the cell.
 *
 * @param {Workbook} context - Specifies the context.
 * @param {CellModel} cell - Specifies the cell model.
 * @param {number} rowIdx - Specifies the row index.
 * @param {number} colIdx - Specifies the column index.
 * @param {boolean} getIntValueFromDate - Specify the getIntValueFromDate.
 * @param {Internationalization} intl - Specifies the internationalization object.
 * @returns {string | Date | number} - Returns the formatted cell value.
 * @hidden
 */
function getValueFromFormat(context, cell, rowIdx, colIdx, getIntValueFromDate, intl) {
    if (cell) {
        if (isNullOrUndefined(cell.value)) {
            return '';
        }
        if (cell.format) {
            const args = { value: cell.value, formattedText: cell.value, cell: cell, format: cell.format,
                checkDate: !getIntValueFromDate, rowIndex: rowIdx, colIndex: colIdx, dataUpdate: true };
            context.notify(getFormattedCellObject, args);
            return args.dateObj && args.dateObj.toString() !== 'Invalid Date' ? args.dateObj : (getIntValueFromDate ? args.value :
                args.formattedText.toString().trim());
        }
        else if (getIntValueFromDate) {
            return cell.value;
        }
        else {
            let cellVal = cell.value;
            if (isNumber(cellVal)) {
                cellVal = Number(cell.value).toString();
                if (cellVal.includes('.') || cellVal.length > 11) {
                    const options = { args: { value: cellVal, updateValue: true }, fResult: cellVal,
                        cellVal: cellVal, intl: intl };
                    context.notify(parseDecimalNumber, options);
                    cellVal = options.fResult;
                }
            }
            return cellVal;
        }
    }
    else {
        return '';
    }
}
/**
 * @hidden
 * @param {SheetModel | RowModel | CellModel} model - Specifies the sheet model.
 * @param {number} idx - Specifies the index value.
 * @returns {SheetModel | RowModel | CellModel} - To process the index
 */
function getModel(model, idx) {
    let diff;
    let j;
    let prevIdx;
    if (isUndefined$1(model[idx]) || !(model[idx] && model[idx].index === idx)) {
        for (let i = 0; i <= idx; i++) {
            if (model && model[i]) {
                diff = model[i].index - i;
                if (diff > 0) {
                    model.forEach((value, index) => {
                        if (value && value.index) {
                            prevIdx = value.index;
                            j = 1;
                        }
                        if (value && !value.index && index !== 0) {
                            value.index = prevIdx + j;
                        }
                        j++;
                    });
                    while (diff--) {
                        model.splice(i, 0, null);
                    }
                    i += diff;
                }
            }
            else if (model) {
                model[i] = null;
            }
            else {
                model = [];
            }
        }
    }
    return model[idx];
}
/**
 * @hidden
 * @param {SheetModel | RowModel | CellModel} model - Specifies the sheet model.
 * @param {boolean} isSheet - Specifies the bool value.
 * @param {Workbook} context - Specifies the Workbook.
 * @param {boolean} isSort - Specifies whether to sort the unordered cell/row model in ascending order.
 * @returns {void} - To process the index
 */
function processIdx(model, isSheet, context, isSort) {
    let j;
    let diff = 0;
    let cnt;
    let len = model.length;
    if (isSort && model.length > 0) {
        // Sort the model based on the index value in ascending order
        model.sort((a, b) => {
            if (!isNullOrUndefined(a) && !isUndefined$1(a.index) && !isNullOrUndefined(b) && !isUndefined$1(b.index)) {
                return a.index - b.index; // Ascending order
            }
            return 0;
        });
    }
    for (let i = 0; i < len; i++) {
        if (!isNullOrUndefined(model[i]) && !isUndefined$1(model[i].index)) {
            cnt = diff = model[i].index - i;
            delete model[i].index;
        }
        if (diff > 0) {
            j = 0;
            while (diff--) {
                if (isSheet) {
                    context.createSheet(i + j);
                    j++;
                }
                else {
                    model.splice(i, 0, null);
                }
            }
            i += cnt;
            len += cnt;
        }
        if (isSheet) {
            if (model[i].id < 1) {
                model[i].id = getMaxSheetId(context.sheets);
                if (model[i].properties) {
                    model[i].properties.id = model[i].id;
                }
            }
            if (!model[i].name) {
                context.setSheetPropertyOnMute(model[i], 'name', 'Sheet' + getSheetNameCount(context));
            }
            let cellCnt = 0;
            model[i].rows.forEach((row) => {
                cellCnt = Math.max(cellCnt, (row && row.cells && row.cells.length - 1) || 0);
            });
            context.setSheetPropertyOnMute(model[i], 'usedRange', { rowIndex: model[i].rows.length ? model[i].rows.length - 1 : 0,
                colIndex: cellCnt });
        }
    }
}

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Configures the range processing for the spreadsheet.
 *  ```html
 * <div id='Spreadsheet'></div>
 * ```
 * ```typescript
 * let spreadsheet: Spreadsheet = new Spreadsheet({
 *      sheets: [{
 *                  name: 'First Sheet',
 *                  ranges: [{ dataSource: defaultData }],
 *                  rows: [{
 *                          index: 30,
 *                          cells: [{ index: 4, value: 'Total Amount:' },
 *                                  { formula: '=SUM(F2:F30)', style: { fontWeight: 'bold' } }]
 *                  }]
 * ...
 * });
 * spreadsheet.appendTo('#Spreadsheet');
 * ```
 */
class Range extends ChildProperty {
    setProperties(prop, muteOnChange) {
        if (this['parentObj'].isComplexArraySetter && this['controlParent'] && this['controlParent'].isAngular) {
            if (Object.keys(prop).length) {
                if (this['parentObj']['currRangeIdx'] === undefined) {
                    this['parentObj']['currRangeIdx'] = 0;
                }
                else {
                    this['parentObj']['currRangeIdx'] += 1;
                }
                const range = this['parentObj'].ranges[this['parentObj']['currRangeIdx']];
                if (range && range.info) {
                    this.info = range.info;
                }
                setTimeout(() => {
                    if (this['parentObj']['currRangeIdx'] !== undefined) {
                        delete this['parentObj']['currRangeIdx'];
                    }
                });
            }
            else if (this['controlParent'].tagObjects[0].instance && this['controlParent'].tagObjects[0].instance.hasChanges
                && !this['controlParent'].tagObjects[0].instance.isInitChanges) {
                const sheetIdx = this['controlParent'].sheets.indexOf(this['parentObj']);
                if (this['parentObj'].changedRangeIdx === undefined) {
                    let rangeIdx;
                    const tagObjects = this['controlParent'].tagObjects[0].instance.list[sheetIdx].tagObjects;
                    for (let i = 0; i < tagObjects.length; i++) {
                        if (tagObjects[i]['name'] === 'ranges') {
                            tagObjects[i]['instance'].list
                                .forEach((range, idx) => {
                                if (range.hasChanges) {
                                    rangeIdx = idx;
                                }
                            });
                            break;
                        }
                    }
                    this['parentObj'].changedRangeIdx = rangeIdx;
                }
            }
        }
        super.setProperties(prop, muteOnChange);
    }
}
__decorate$1([
    Property(null)
], Range.prototype, "dataSource", void 0);
__decorate$1([
    Property('A1')
], Range.prototype, "startCell", void 0);
__decorate$1([
    Property(null)
], Range.prototype, "query", void 0);
__decorate$1([
    Property(null)
], Range.prototype, "fieldsOrder", void 0);
__decorate$1([
    Property(true)
], Range.prototype, "showFieldAsHeader", void 0);
__decorate$1([
    Property('')
], Range.prototype, "template", void 0);
__decorate$1([
    Property('A1')
], Range.prototype, "address", void 0);
/**
 * Used range which contains end row index and end column index of the last used cell in sheet .
 */
class UsedRange extends ChildProperty {
}
__decorate$1([
    Property(0)
], UsedRange.prototype, "rowIndex", void 0);
__decorate$1([
    Property(0)
], UsedRange.prototype, "colIndex", void 0);
/**
 * Configures the sheet behavior for the spreadsheet.
 */
class Sheet extends ChildProperty {
}
__decorate$1([
    Property(null)
], Sheet.prototype, "rows", void 0);
__decorate$1([
    Property(null)
], Sheet.prototype, "columns", void 0);
__decorate$1([
    Complex({}, ProtectSettings)
], Sheet.prototype, "protectSettings", void 0);
__decorate$1([
    Collection([], Range)
], Sheet.prototype, "ranges", void 0);
__decorate$1([
    Collection([], ConditionalFormat)
], Sheet.prototype, "conditionalFormats", void 0);
__decorate$1([
    Property(0)
], Sheet.prototype, "index", void 0);
__decorate$1([
    Property('')
], Sheet.prototype, "name", void 0);
__decorate$1([
    Property(100)
], Sheet.prototype, "rowCount", void 0);
__decorate$1([
    Property(100)
], Sheet.prototype, "colCount", void 0);
__decorate$1([
    Property('A1:A1')
], Sheet.prototype, "selectedRange", void 0);
__decorate$1([
    Property('A1')
], Sheet.prototype, "activeCell", void 0);
__decorate$1([
    Complex({}, UsedRange)
], Sheet.prototype, "usedRange", void 0);
__decorate$1([
    Property('A1')
], Sheet.prototype, "topLeftCell", void 0);
__decorate$1([
    Property(true)
], Sheet.prototype, "showHeaders", void 0);
__decorate$1([
    Property(true)
], Sheet.prototype, "showGridLines", void 0);
__decorate$1([
    Property(false)
], Sheet.prototype, "isProtected", void 0);
__decorate$1([
    Property('Visible')
], Sheet.prototype, "state", void 0);
__decorate$1([
    Property(0)
], Sheet.prototype, "frozenRows", void 0);
__decorate$1([
    Property(0)
], Sheet.prototype, "frozenColumns", void 0);
__decorate$1([
    Property('A1')
], Sheet.prototype, "paneTopLeftCell", void 0);
__decorate$1([
    Property('')
], Sheet.prototype, "password", void 0);
__decorate$1([
    Property(null)
], Sheet.prototype, "standardHeight", void 0);
__decorate$1([
    Property(false)
], Sheet.prototype, "isSheetCalculated", void 0);
/**
 * To get sheet index from address.
 *
 * @hidden
 * @param {Workbook} context - Specifies the context.
 * @param {string} name - Specifies the name.
 * @returns {number} - To gget sheet index from address.
 */
function getSheetIndex(context, name) {
    let idx;
    if (name.startsWith('\'') && name.endsWith('\'')) {
        name = name.replace(/''/g, '\'').replace(/^'|'$/g, '');
    }
    for (let i = 0; i < context.sheets.length; i++) {
        if (context.sheets[i].name.toLowerCase() === name.toLowerCase()) {
            idx = i;
            break;
        }
    }
    return idx;
}
/**
 * To get sheet index from sheet id.
 *
 * @hidden
 * @param {Workbook} context - Specifies the context.
 * @param {number} id - Specifies the id.
 * @returns {number} - To get the sheet index from id.
 */
function getSheetIndexFromId(context, id) {
    let idx;
    for (let i = 0; i < context.sheets.length; i++) {
        if (context.sheets[i].id === id) {
            idx = i;
            break;
        }
    }
    return idx;
}
/**
 * To get sheet name from address.
 *
 * @hidden
 * @param {string} address - Specifies the address.
 * @returns {address} - To get Sheet Name From Address.
 */
function getSheetNameFromAddress(address) {
    const sheetRefIndex = address.lastIndexOf('!');
    return sheetRefIndex > -1 ? address.substring(0, sheetRefIndex).replace(/'/gi, '') : address.replace(/'/gi, '');
}
/**
 * To get sheet index from sheet name.
 *
 * @hidden
 * @param {Object} context - Specifies the context.
 * @param {string} name - Specifies the name.
 * @param {SheetModel} info - Specifies the sheet info.
 * @returns {number} - To get the sheet index by name.
 */
function getSheetIndexByName(context, name, info) {
    const len = info.length;
    for (let i = 0; i < len; i++) {
        if (info[i].sheet.toUpperCase() === name.toUpperCase()) {
            return info[i].index;
        }
    }
    return -1;
}
/**
 * update selected range
 *
 * @hidden
 * @param {Workbook} context - Specifies the context.
 * @param {string} range - Specifies the range.
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {boolean} isMultiRange - Specifies the boolean value.
 * @returns {void} - Update the selected range.
 */
function updateSelectedRange(context, range, sheet = {}, isMultiRange) {
    context.setSheetPropertyOnMute(sheet, 'selectedRange', isMultiRange ? sheet.selectedRange + ' ' + range : range);
}
/**
 * get selected range
 *
 * @hidden
 * @param {SheetModel} sheet - Specifies the sheet.
 * @returns {string} - Get selected range.
 */
function getSelectedRange(sheet) {
    return sheet && sheet.selectedRange || 'A1';
}
/**
 * @hidden
 * @param {SheetModel} sheet - Specifies the sheet.
 * @returns {string} - To get single selected range.
 */
function getSingleSelectedRange(sheet) {
    return sheet.selectedRange.split(' ')[0];
}
/**
 * @hidden
 * @param {Workbook} context - Specifies the context.
 * @param {number} idx - Specifies the idx.
 * @returns {SheetModel} - To get sheet.
 */
function getSheet(context, idx) {
    return context.sheets[idx];
}
/**
 * @hidden
 * @param {Workbook} context - Specifies the context.
 * @returns {number} - To get sheet name count.
 */
function getSheetNameCount(context) {
    const name = [];
    context.sheets.forEach((sheet) => {
        name.push(sheet.name.toLowerCase());
    });
    for (let i = 0; i < name.length; i++) {
        if (name.indexOf('sheet' + context.sheetNameCount) > -1) {
            context.sheetNameCount++;
        }
        else {
            return context.sheetNameCount++;
        }
    }
    return context.sheetNameCount++;
}
/**
 * @hidden
 * @param {SheetModel[]} sheets - Specifies the sheets.
 * @returns {number} - To get sheet id.
 */
function getMaxSheetId(sheets) {
    let cnt = 0;
    sheets.forEach((sheet) => {
        cnt = Math.max(sheet.id, cnt);
    });
    return cnt + 1;
}
/**
 * @hidden
 * @param {Workbook} context - Specifies the context.
 * @param {SheetModel[]} sheet - Specifies the sheet.
 * @param {boolean} isImport - Specifies is Import or not.
 * @returns {void} - To initiate sheet.
 */
function initSheet(context, sheet, isImport) {
    const sheets = sheet ? sheet : context.sheets;
    sheets.forEach((sheet) => {
        sheet.id = sheet.id || 0;
        sheet.name = sheet.name || '';
        context.setSheetPropertyOnMute(sheet, 'rowCount', sheet.rowCount || 100);
        context.setSheetPropertyOnMute(sheet, 'colCount', sheet.colCount || 100);
        context.setSheetPropertyOnMute(sheet, 'topLeftCell', sheet.topLeftCell || 'A1');
        context.setSheetPropertyOnMute(sheet, 'activeCell', sheet.activeCell || 'A1');
        context.setSheetPropertyOnMute(sheet, 'selectedRange', sheet.selectedRange || sheet.activeCell + ':' + sheet.activeCell);
        context.setSheetPropertyOnMute(sheet, 'usedRange', sheet.usedRange || { rowIndex: 0, colIndex: 0 });
        context.setSheetPropertyOnMute(sheet, 'ranges', sheet.ranges ? sheet.ranges : []);
        context.setSheetPropertyOnMute(sheet, 'rows', (sheet.rows && extend([], sheet.rows, null, true)) || []);
        context.setSheetPropertyOnMute(sheet, 'columns', sheet.columns || []);
        context.setSheetPropertyOnMute(sheet, 'showHeaders', isUndefined$1(sheet.showHeaders) ? true : sheet.showHeaders);
        context.setSheetPropertyOnMute(sheet, 'showGridLines', isUndefined$1(sheet.showGridLines) ? true : sheet.showGridLines);
        context.setSheetPropertyOnMute(sheet, 'state', sheet.state || 'Visible');
        sheet.maxHgts = sheet.maxHgts || [];
        sheet.isImportProtected = sheet.isProtected && isImport;
        sheet.protectSettings = sheet.protectSettings || { selectCells: false, formatCells: false, formatRows: false, formatColumns: false,
            insertLink: false };
        sheet.isProtected = sheet.isProtected || false;
        if (!sheet.paneTopLeftCell || sheet.paneTopLeftCell === 'A1') {
            sheet.frozenRows = sheet.frozenRows ? sheet.frozenRows : 0;
            sheet.frozenColumns = sheet.frozenColumns ? sheet.frozenColumns : 0;
            const indexes = getCellIndexes(sheet.topLeftCell);
            context.setSheetPropertyOnMute(sheet, 'paneTopLeftCell', getCellAddress(sheet.frozenRows ? indexes[0] + sheet.frozenRows : indexes[0], sheet.frozenColumns ? indexes[1] + sheet.frozenColumns : indexes[1]));
        }
        processIdx(sheet.columns);
        initRow(sheet.rows, isImport);
    });
    processIdx(sheets, true, context);
}
// function initRangeSettings(ranges: RangeModel[]): RangeModel[] {
//     ranges.forEach((range: RangeModel) => {
//         range.startCell = range.startCell || 'A1';
//         range.address = range.address || 'A1';
//         range.template = range.template || '';
//         range.showFieldAsHeader = isUndefined(range.showFieldAsHeader) ? true : range.showFieldAsHeader;
//     });
//     return ranges;
// }
/**
 * @param {RowModel[]} rows - Specifies the rows.
 * @param {boolean} isImport - Specifies the operation is from Import or not.
 * @returns {void} - Specifies the row.
 */
function initRow(rows, isImport) {
    rows.forEach((row) => {
        if (row && row.cells) {
            // Process cell indexes in ascending order when the import operation is performed.
            processIdx(row.cells, null, undefined, isImport);
        }
    });
    processIdx(rows, null, undefined, isImport);
}
/**
 * get sheet name
 *
 * @param {Workbook} context - Specifies the context.
 * @param {number} idx - Specifies the idx.
 * @returns {string} - To get sheet name.
 * @hidden
 */
function getSheetName(context, idx = context.activeSheetIndex) {
    return getSheet(context, idx).name;
}
/**
 * @param {Workbook} context - Specifies context
 * @param {number} position - position to move a sheet in the list of sheets
 * @param {number[]} sheetIndexes - Specifies the sheet indexes of the sheets which is to be moved
 * @param {boolean} action - Specifies to trigger events
 * @param {boolean} isFromUpdateAction - Specifies is from UpdateAction or not.
 * @returns {void}
 * @hidden
 */
function moveSheet(context, position, sheetIndexes, action, isFromUpdateAction) {
    const needRefresh = !!sheetIndexes;
    sheetIndexes = sheetIndexes || [context.activeSheetIndex];
    const sheetName = getSheetName(context);
    position = getNextPrevVisibleSheetIndex(context.sheets, position, context.activeSheetIndex > position);
    const args = {
        action: 'moveSheet', eventArgs: { position: position, sheetIndexes: sheetIndexes, cancel: false }
    };
    if (action) {
        context.trigger('actionBegin', args);
    }
    if (!args.eventArgs.cancel) {
        context.notify(moveSheetHandler, { prevIndex: context.activeSheetIndex, currentIndex: position });
        sheetIndexes.forEach((sIdx, idx) => {
            context.sheets.splice(position + idx, 0, context.sheets.splice(sIdx + (position > sIdx ? -1 * idx : 0), 1)[0]);
        });
        context.setProperties({
            activeSheetIndex: isFromUpdateAction ? getSheetIndex(context, sheetName)
                : (position > sheetIndexes[0] ? position - (sheetIndexes.length - 1) : position)
        }, true);
        context.notify(moveOrDuplicateSheet, { refresh: needRefresh });
        if (action) {
            delete args.eventArgs.cancel;
            context.trigger('actionComplete', args);
        }
    }
}
/**
 * @param {Workbook} context - Specifies context
 * @param {number} sheetIndex - Specifies sheetIndex to be duplicated
 * @param {boolean} action - Specifies to trigger events
 * @param {boolean} isFromUpdateAction - Specifies is from updateAction.
 * @returns {void}
 * @hidden
 */
function duplicateSheet(context, sheetIndex, action, isFromUpdateAction) {
    sheetIndex = isUndefined$1(sheetIndex) ? context.activeSheetIndex : sheetIndex;
    const args = {
        action: 'duplicateSheet', eventArgs: { sheetIndex: sheetIndex, cancel: false }
    };
    if (action) {
        context.trigger('actionBegin', args);
    }
    if (!args.eventArgs.cancel) {
        const originalSheet = getSheet(context, sheetIndex);
        const sheet = extend({}, originalSheet.properties ?
            originalSheet.properties : originalSheet, {}, true);
        sheet.id = getMaxSheetId(context.sheets);
        let name = sheet.name;
        if (/^\(\d+\)$/.test('(' + name.split(' (')[1])) {
            name = name.split(' (')[0];
        }
        const sheetNames = [];
        context.sheets.forEach((sheet) => {
            sheetNames.push(sheet.name);
        });
        for (let i = 2;; i++) {
            if (sheetNames.indexOf(name + ' (' + i + ')') === -1) {
                sheet.name = name + ' (' + i + ')';
                break;
            }
        }
        context.notify(duplicateSheetFilterHandler, { sheetIndex: sheetIndex, newSheetIndex: sheetIndex + 1 });
        context.notify(updateSortCollection, { isDuplicate: true, curSheetIndex: sheetIndex, newSheetIndex: sheetIndex + 1 });
        context.createSheet(sheetIndex + 1, [sheet]);
        context.notify(workbookFormulaOperation, { action: 'addSheet', sheetName: 'Sheet' + sheet.id, visibleName: sheet.name, sheetId: sheet.id });
        if (!isFromUpdateAction) {
            context.setProperties({ activeSheetIndex: sheetIndex + 1 }, true);
        }
        context.notify(moveOrDuplicateSheet, { refresh: true, isDuplicate: true });
        if (action) {
            delete args.eventArgs.cancel;
            context.trigger('actionComplete', args);
        }
    }
}
/**
 * @param {SheetModel[]} sheets - sheets of spreadsheet
 * @param {number} startIndex - index of the sheet to search from
 * @param {boolean} isPrevious - if set to `true`, its find the previous visible sheet index
 * @returns {number} - return next visible sheet
 */
function getNextPrevVisibleSheetIndex(sheets, startIndex, isPrevious) {
    for (let i = startIndex; isPrevious ? i >= 0 : i < sheets.length; isPrevious ? i-- : i++) {
        if (!(sheets[i].state === 'Hidden' || sheets[i].state === 'VeryHidden')) {
            startIndex = i;
            break;
        }
    }
    return startIndex;
}

var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Represents the cell.
 */
class Cell extends ChildProperty {
}
__decorate$2([
    Property('')
], Cell.prototype, "notes", void 0);
__decorate$2([
    Collection([], Image$1)
], Cell.prototype, "image", void 0);
__decorate$2([
    Collection([], Chart)
], Cell.prototype, "chart", void 0);
__decorate$2([
    Property('')
], Cell.prototype, "value", void 0);
__decorate$2([
    Property('')
], Cell.prototype, "formula", void 0);
__decorate$2([
    Property(0)
], Cell.prototype, "index", void 0);
__decorate$2([
    Property('General')
], Cell.prototype, "format", void 0);
__decorate$2([
    Complex({}, CellStyle)
], Cell.prototype, "style", void 0);
__decorate$2([
    Property('')
], Cell.prototype, "hyperlink", void 0);
__decorate$2([
    Property(false)
], Cell.prototype, "wrap", void 0);
__decorate$2([
    Property(true)
], Cell.prototype, "isLocked", void 0);
__decorate$2([
    Property('')
], Cell.prototype, "validation", void 0);
__decorate$2([
    Property(1)
], Cell.prototype, "colSpan", void 0);
__decorate$2([
    Property(1)
], Cell.prototype, "rowSpan", void 0);
__decorate$2([
    Property(false)
], Cell.prototype, "isReadOnly", void 0);
/**
 * @hidden
 * @param {number} rowIndex - Specifies the rowIndex.
 * @param {number} colIndex - Specifies the colIndex.
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {boolean} isInitRow - Specifies the isInitRow.
 * @param {boolean} returnEmptyObjIfNull - Specifies the bool value.
 * @returns {CellModel} - get the cell.
 */
function getCell(rowIndex, colIndex, sheet, isInitRow, returnEmptyObjIfNull) {
    const row = getRow(sheet, rowIndex);
    if (!row || !row.cells) {
        if (isInitRow) {
            if (!row) {
                sheet.rows[rowIndex] = { cells: [] };
            }
            else {
                sheet.rows[rowIndex].cells = [];
            }
        }
        else {
            return returnEmptyObjIfNull ? {} : null;
        }
    }
    return sheet.rows[rowIndex].cells[colIndex] || (returnEmptyObjIfNull ? {} : null);
}
/**
 * @hidden
 * @param {number} rowIndex - Specifies the rowIndex.
 * @param {number} colIndex - Specifies the colIndex.
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {CellModel} cell - Specifies the cell.
 * @param {boolean} isExtend - Specifies the bool value.
 * @param {boolean} isUpdate - If true, allows updating the existing cell data without extending.
 * @returns {void} - set the cell.
 */
function setCell(rowIndex, colIndex, sheet, cell, isExtend, isUpdate) {
    if (!sheet.rows[rowIndex]) {
        sheet.rows[rowIndex] = { cells: [] };
    }
    else if (!sheet.rows[rowIndex].cells) {
        sheet.rows[rowIndex].cells = [];
    }
    if (isExtend && sheet.rows[rowIndex].cells[colIndex] && !isUpdate) {
        extend(sheet.rows[rowIndex].cells[colIndex], cell, null, true);
    }
    else {
        sheet.rows[rowIndex].cells[colIndex] = cell;
    }
}
/**
 * @hidden
 * @param {CellStyleModel} style - Specifies the style.
 * @param {boolean} defaultKey - Specifies the defaultKey.
 * @returns {CellStyleModel} - Specifies the CellStyleModel.
 */
function skipDefaultValue(style, defaultKey) {
    const defaultProps = { fontFamily: 'Calibri', verticalAlign: 'bottom', textIndent: '0pt', backgroundColor: '#ffffff',
        color: '#000000', textAlign: 'left', fontSize: '11pt', fontWeight: 'normal', fontStyle: 'normal', textDecoration: 'none',
        border: '', borderLeft: '', borderTop: '', borderRight: '', borderBottom: '' };
    const changedProps = {};
    let styleVal;
    Object.keys(defaultKey ? defaultProps : style).forEach((propName) => {
        styleVal = style[`${propName}`];
        if (styleVal !== defaultProps[`${propName}`]) {
            changedProps[`${propName}`] = styleVal;
        }
    });
    return changedProps;
}
/**
 * @hidden
 * @param {string} address - Specifies the address.
 * @param {boolean} wrap - Specifies the wrap.
 * @param {Workbook} context - Specifies the context.
 * @param {Workbook} preventEvt - Preventing the before cell update event.
 * @param {boolean} isPublic - Specifies if the wrap operation is invoked from a public method.
 * @returns {void} - Specifies the wrap.
 */
function wrap(address, wrap = true, context, preventEvt, isPublic) {
    const addressInfo = context.getAddressInfo(address);
    const rng = addressInfo.indices;
    const sheet = getSheet(context, addressInfo.sheetIndex);
    const uiRefresh = addressInfo.sheetIndex === context.activeSheetIndex;
    let cancel = !preventEvt;
    for (let i = rng[0]; i <= rng[2]; i++) {
        for (let j = rng[1]; j <= rng[3]; j++) {
            cancel = updateCell(context, sheet, { cell: { wrap: wrap }, rowIdx: i, colIdx: j, preventEvt: preventEvt });
            if (!cancel && uiRefresh) {
                context.notify(wrapEvent, { range: [i, j, i, j], wrap: wrap, sheet: sheet, initial: true, isPublic: isPublic });
            }
        }
    }
    context.setProperties({ sheets: context.sheets }, true);
}
/**
 * @hidden
 * @param {string} format - Specifies the cell format.
 * @returns {string} - Specifies the supported color code.
 */
function getColorCode(format) {
    let code;
    if (format.indexOf('[') > -1) {
        const colorValue = format.split('[')[1].split(']')[0];
        const customColors = getCustomColors();
        if (customColors.indexOf(colorValue) > -1) {
            code = colorValue;
        }
    }
    return code;
}
/**
 * @hidden
 * @returns {string[]} - Returns the custom format colors
 */
function getCustomColors() {
    return ['Black', 'Blue', 'Cyan', 'Green', 'Magenta', 'Red', 'White', 'Yellow'];
}
/**
 * @param {string} format - Specify the format.
 * @param {boolean} checkTime - Specify the checktime.
 * @param {Object} option - Specify rhe option value.
 * @param {string} option.type - Specify the type.
 * @param {boolean} checkBoth - Specify check both values.
 * @returns {boolean} - This function is used to return is custom Data time or not.
 * @hidden
 */
function isCustomDateTime(format, checkTime, option, checkBoth) {
    let isCustom;
    if (format.includes('"')) {
        const formatSection = format.split(';');
        let endStrIdx;
        let prevChar;
        formatSection.forEach((formatCode, index) => {
            for (let idx = 0; idx < formatCode.length; idx++) {
                if (formatCode[idx] === '"' && formatCode[idx - 1] !== '\\') {
                    endStrIdx = idx;
                    do {
                        endStrIdx = formatCode.indexOf('"', endStrIdx + 1);
                        prevChar = formatCode[endStrIdx - 1];
                    } while (prevChar === '\\' || prevChar === '_' || prevChar === '*');
                    if (endStrIdx === -1) {
                        break;
                    }
                    formatCode = formatCode.substring(0, idx) + formatCode.substring(endStrIdx + 1);
                    idx--;
                }
            }
            formatSection[index] = formatCode;
        });
        format = formatSection.join(';');
    }
    if ((format.includes('d') || format.includes('y')) && !format.includes('#') && !getColorCode(format)) {
        if (option) {
            option.type = 'date';
        }
        if (checkBoth && format.includes(' ') && format.split(' ').length === 2) {
            format = format.split(' ')[1];
        }
        else {
            checkTime = false;
        }
        isCustom = true;
    }
    if (checkTime && (format.includes('h') || format.includes('m') || format.includes('s')) && !format.includes('#') &&
        !getColorCode(format)) {
        if (option) {
            option.type = option.type || '';
            option.type += 'time';
        }
        isCustom = true;
    }
    return isCustom;
}
/**
 * Represents the configuration options for the Spreadsheet when opening a document.
 */
class OpenSettings extends ChildProperty {
}
__decorate$2([
    Property(0)
], OpenSettings.prototype, "chunkSize", void 0);
__decorate$2([
    Property(3)
], OpenSettings.prototype, "retryCount", void 0);
__decorate$2([
    Property(500)
], OpenSettings.prototype, "retryAfterDelay", void 0);

/**
 * Data binding module
 */
class DataBind {
    constructor(parent) {
        this.parent = parent;
        this.requestedInfo = [];
        this.addEventListener();
    }
    addEventListener() {
        this.parent.on(updateSheetFromDataSource, this.updateSheetFromDataSourceHandler, this);
        this.parent.on(dataSourceChanged, this.dataSourceChangedHandler, this);
        this.parent.on(dataChanged, this.dataChangedHandler, this);
        this.parent.on(triggerDataChange, this.triggerDataChangeHandler, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(updateSheetFromDataSource, this.updateSheetFromDataSourceHandler);
            this.parent.off(dataSourceChanged, this.dataSourceChangedHandler);
            this.parent.off(dataChanged, this.dataChangedHandler);
            this.parent.off(triggerDataChange, this.triggerDataChangeHandler);
        }
    }
    /**
     * Update given data source to sheet.
     *
     * @param {Object} args - Specify the args.
     * @param {ExtendedSheet} args.sheet - Specify the sheet.
     * @param {number[]} args.indexes - Specify the indexes.
     * @param {Promise<CellModel>} args.promise - Specify the promise.
     * @param {number} args.rangeSettingCount - Specify the rangeSettingCount.
     * @param {string} args.formulaCellRef - Specify the formulaCellRef.
     * @param {number} args.sheetIndex - Specify the sheetIndex.
     * @param {boolean} args.loadFullData - Specify whether to load full data or not.
     * @param {boolean} args.resolveAfterFullDataLoaded - Specify the resolveAfterFullDataLoaded.
     * @param {Function} args.loadComplete - Specify the callback function that will be invoked once all the data are updated.
     * @param {boolean} args.loadFromStartCell - Specify the whether to load the data from the range startCell address.
     * @param {boolean} args.autoDetectFormat - Specify whether to auto detect format based on the cell value.
     * @param {Function} args.updateDependentCellsCallback - Specify a callback function to update the dependent cells address to refresh
     * after the data binding.
     * @returns {void} - Update given data source to sheet.
     */
    updateSheetFromDataSourceHandler(args) {
        let cell;
        let flds;
        let sCellIdx;
        let result;
        let remoteUrl;
        let dataManager;
        const requestedRange = [];
        const sRanges = [];
        let rowIdx;
        let colIdx;
        const deferred = new Deferred();
        let sRowIdx;
        let sColIdx;
        let loadedInfo;
        args.promise = deferred.promise;
        let startCellIndexes;
        const autoDetectFormat = args.autoDetectFormat;
        const autoDetectFormatFn = autoDetectFormat && getAutoDetectFormatParser(this.parent);
        if (args.sheet && args.sheet.ranges.length) {
            let prevVal;
            for (let k = args.sheet.ranges.length - 1; k >= 0; k--) {
                const range = args.sheet.ranges[k];
                startCellIndexes = getRangeIndexes(range.startCell);
                if (args.loadFromStartCell) {
                    args.indexes = startCellIndexes;
                }
                let sRange = args.indexes[0];
                let eRange = args.indexes[2];
                sRowIdx = startCellIndexes[0];
                dataManager = range.dataSource instanceof DataManager ? range.dataSource
                    : range.dataSource ? new DataManager(range.dataSource) : new DataManager();
                remoteUrl = remoteUrl || dataManager.dataSource.url;
                args.sheet.isLocalData =  !dataManager.dataSource.url;
                if (sRowIdx <= sRange) {
                    sRange = sRange - sRowIdx;
                }
                else {
                    if (sRowIdx <= eRange) {
                        eRange = eRange - sRowIdx;
                        sRange = 0;
                    }
                    else {
                        sRange = -1;
                    }
                }
                if (range.showFieldAsHeader && sRange !== 0) {
                    sRange -= 1;
                }
                let isEndReached = false;
                let insertRowCount = 0;
                this.initRangeInfo(range);
                let count = this.getMaxCount(range);
                loadedInfo = this.getLoadedInfo(sRange, eRange, range);
                sRange = loadedInfo.unloadedRange[0];
                eRange = loadedInfo.unloadedRange[1];
                if (range.info.insertRowRange) {
                    range.info.insertRowRange.forEach((range) => {
                        insertRowCount += ((range[1] - range[0]) + 1);
                    });
                    sRange -= insertRowCount;
                    eRange -= insertRowCount;
                }
                if (sRange >= count) {
                    isEndReached = true;
                }
                else if (eRange > count) {
                    eRange = count;
                }
                if (!args.loadComplete) {
                    this.requestedInfo.push({ deferred: deferred, indexes: args.indexes, isNotLoaded: loadedInfo.isNotLoaded });
                }
                if (sRange >= 0 && loadedInfo.isNotLoaded && !isEndReached) {
                    sRanges[k] = sRange;
                    requestedRange[k] = false;
                    let fieldsOrder;
                    if (range.fieldsOrder) {
                        fieldsOrder = [].slice.call(range.fieldsOrder);
                    }
                    let query = (range.query ? range.query : new Query()).clone();
                    if (!args.loadFullData) {
                        query = query.range(sRange, eRange >= count ? eRange : eRange + 1);
                    }
                    dataManager.executeQuery(query.requiresCount()).then((e) => {
                        if (!this.parent || this.parent.isDestroyed) {
                            return;
                        }
                        result = (e.result && e.result.result ? e.result.result : e.result);
                        sCellIdx = getRangeIndexes(range.startCell);
                        sRowIdx = sCellIdx[0];
                        sColIdx = sCellIdx[1];
                        if (result && result.length) {
                            if (!range.info.count) {
                                count = e.count;
                                range.info.count = e.count;
                            }
                            flds = range.info.flds || fieldsOrder || Object.keys(result[0]);
                            if (!range.info.fldLen) {
                                range.info.fldLen = flds.length;
                                range.info.flds = flds;
                            }
                            if (range.info.insertColumnRange) {
                                let insertCount = 0;
                                range.info.insertColumnRange.forEach((insertRange) => {
                                    for (let i = insertRange[0]; i <= insertRange[1]; i++) {
                                        if (i <= sColIdx) {
                                            flds.splice(0, 0, `emptyCell${insertCount}`);
                                        }
                                        else {
                                            flds.splice(i - sColIdx, 0, `emptyCell${insertCount}`);
                                        }
                                        insertCount++;
                                    }
                                });
                            }
                            if (sRanges[k] === 0 && range.showFieldAsHeader) {
                                rowIdx = sRowIdx + sRanges[k] + insertRowCount;
                                flds.forEach((field, i) => {
                                    cell = getCell(rowIdx, sColIdx + i, args.sheet, true);
                                    if (!cell) {
                                        args.sheet.rows[sRowIdx + sRanges[k]].cells[sColIdx + i] = field.includes('emptyCell') ? {}
                                            : { value: field };
                                    }
                                    else if (!field.includes('emptyCell')) {
                                        cell.value = field;
                                    }
                                });
                            }
                            result.forEach((item, i) => {
                                rowIdx = sRowIdx + sRanges[k] + i + (range.showFieldAsHeader ? 1 : 0) + insertRowCount;
                                flds.forEach((field, idx) => {
                                    colIdx = sColIdx + idx;
                                    cell = getCell(rowIdx, colIdx, args.sheet, true);
                                    if (cell) {
                                        prevVal = cell.value;
                                        if (!field.includes('emptyCell')) {
                                            setCell(rowIdx, colIdx, args.sheet, this.getCellDataFromProp(item[field]), true);
                                        }
                                    }
                                    else {
                                        prevVal = undefined;
                                        cell = args.sheet.rows[rowIdx].cells[colIdx] =
                                            field.includes('emptyCell') ? {} : this.getCellDataFromProp(item[field]);
                                    }
                                    if (autoDetectFormat) {
                                        autoDetectFormatFn(cell);
                                    }
                                    if (args.updateDependentCellsCallback && prevVal !== cell.value) {
                                        args.updateDependentCellsCallback(rowIdx, colIdx);
                                    }
                                });
                            });
                        }
                        else {
                            flds = [];
                        }
                        let totalRows;
                        if ((sRowIdx + (count || e.count)) > 0) {
                            totalRows = (sRowIdx + (count || e.count) + (range.showFieldAsHeader ? 1 : 0) + insertRowCount) - 1;
                        }
                        else {
                            totalRows = args.sheet.usedRange.rowIndex;
                        }
                        const totalCols = sColIdx + flds.length - 1 < 0 ? args.sheet.usedRange.colIndex : sColIdx + flds.length - 1;
                        if (args.loadFullData) {
                            eRange = totalRows;
                        }
                        const usedRange = { rowIndex: totalRows, colIndex: totalCols };
                        if (this.parent.scrollSettings && this.parent.scrollSettings.isFinite) {
                            usedRange.rowIndex = totalRows < args.sheet.rowCount ? totalRows : args.sheet.rowCount - 1;
                            usedRange.colIndex = totalCols < args.sheet.colCount ? totalCols : args.sheet.colCount - 1;
                        }
                        if (args.sheet.usedRange.rowIndex < usedRange.rowIndex) {
                            this.parent.setSheetPropertyOnMute(args.sheet, 'usedRange', { rowIndex: usedRange.rowIndex, colIndex: args.sheet.usedRange.colIndex });
                        }
                        if (args.sheet.usedRange.colIndex < usedRange.colIndex) {
                            this.parent.setSheetPropertyOnMute(args.sheet, 'usedRange', { rowIndex: args.sheet.usedRange.rowIndex, colIndex: usedRange.colIndex });
                        }
                        if (insertRowCount) {
                            loadedInfo = this.getLoadedInfo(sRange, eRange, range);
                            sRange = loadedInfo.unloadedRange[0];
                            eRange = loadedInfo.unloadedRange[1];
                            if (sRange > count) {
                                loadedInfo.isNotLoaded = false;
                            }
                            if (loadedInfo.isNotLoaded) {
                                if (eRange > count) {
                                    eRange = count;
                                }
                                range.info.loadedRange.push([sRange, eRange]);
                            }
                        }
                        else {
                            range.info.loadedRange.push([sRange, eRange]);
                        }
                        requestedRange[k] = true;
                        if (requestedRange.indexOf(false) === -1) {
                            let dataLoading;
                            if (eRange + sRowIdx < sRowIdx + range.info.count) {
                                if (!args.rangeSettingCount) {
                                    args.rangeSettingCount = [];
                                }
                                args.rangeSettingCount.push(k);
                                dataLoading = true;
                                //if (remoteUrl) {
                                const unloadedArgs = {
                                    sheet: args.sheet, indexes: [0, 0, totalRows, totalCols],
                                    promise: new Promise((resolve) => { resolve((() => { })()); }),
                                    rangeSettingCount: args.rangeSettingCount, loadComplete: args.loadComplete,
                                    autoDetectFormat: args.autoDetectFormat, resolveAfterFullDataLoaded: args.resolveAfterFullDataLoaded
                                };
                                this.updateSheetFromDataSourceHandler(unloadedArgs);
                                unloadedArgs.promise.then(() => {
                                    if (this.parent.getModuleName() === 'workbook') {
                                        return;
                                    }
                                    args.rangeSettingCount.pop();
                                    if (!args.rangeSettingCount.length) {
                                        this.parent.notify('created', null);
                                    }
                                    if (args.formulaCellRef) {
                                        this.notfyFormulaCellRefresh(args.formulaCellRef, args.sheetIndex);
                                    }
                                    else if (args.loadComplete) {
                                        args.loadComplete();
                                    }
                                });
                                //}
                            }
                            else if (args.formulaCellRef) {
                                this.notfyFormulaCellRefresh(args.formulaCellRef, args.sheetIndex);
                            }
                            else if (args.loadComplete) {
                                args.loadComplete();
                            }
                            if (!(dataLoading && args.resolveAfterFullDataLoaded)) {
                                this.checkResolve(args.indexes);
                                if (args.resolveAfterFullDataLoaded) {
                                    this.checkResolve([0, 0, 0, 0]);
                                }
                            }
                        }
                    });
                }
                else if (k === 0 && requestedRange.indexOf(false) === -1) {
                    if (args.loadComplete) {
                        args.loadComplete();
                    }
                    this.checkResolve(args.indexes);
                }
            }
        }
        else {
            deferred.resolve();
        }
    }
    notfyFormulaCellRefresh(formulaCellRef, sheetIndex) {
        this.parent.formulaRefCell = null;
        this.parent.notify(updateView, { indexes: getRangeIndexes(formulaCellRef), sheetIndex: sheetIndex, refreshing: true });
    }
    checkResolve(indexes) {
        let resolved;
        let isSameRng;
        let cnt = 0;
        this.requestedInfo.forEach((info, idx) => {
            isSameRng = JSON.stringify(info.indexes) === JSON.stringify(indexes);
            if (isSameRng || resolved) {
                if (idx === 0) {
                    info.deferred.resolve();
                    cnt++;
                    resolved = true;
                }
                else {
                    if (resolved && (info.isLoaded || !info.isNotLoaded)) {
                        info.deferred.resolve();
                        cnt++;
                    }
                    else if (isSameRng && resolved) {
                        info.deferred.resolve();
                        cnt++;
                    }
                    else if (isSameRng) {
                        info.isLoaded = true;
                    }
                    else {
                        resolved = false;
                    }
                }
            }
        });
        this.requestedInfo.splice(0, cnt);
    }
    getCellDataFromProp(prop) {
        const data = {};
        if (Object.prototype.toString.call(prop) === '[object Object]') {
            if (prop.formula) {
                data.formula = prop.formula;
            }
            else if (!isNullOrUndefined(prop.value)) {
                if (typeof (prop.value) === 'string') {
                    if (prop.value.indexOf('http://') === 0 || prop.value.indexOf('https://') === 0 ||
                        prop.value.indexOf('ftp://') === 0 || prop.value.indexOf('www.') === 0) {
                        data.hyperlink = prop.value;
                        data.style = { textDecoration: 'underline', color: '#00e' };
                    }
                    else {
                        data.value = prop.value;
                    }
                }
                else {
                    data.value = prop.value;
                }
            }
        }
        else {
            if (checkIsFormula(prop)) {
                data.formula = prop;
            }
            else {
                if (typeof (prop) === 'string') {
                    if (prop.indexOf('http://') === 0 || prop.indexOf('https://') === 0 ||
                        prop.indexOf('ftp://') === 0 || prop.indexOf('www.') === 0) {
                        data.hyperlink = prop;
                        data.style = { textDecoration: 'underline', color: '#00e' };
                    }
                    else {
                        data.value = prop;
                    }
                }
                else {
                    data.value = prop;
                }
            }
        }
        return data;
    }
    getLoadedInfo(sRange, eRange, range) {
        let isNotLoaded = true;
        range.info.loadedRange.forEach((range) => {
            if (range[0] <= sRange && sRange <= range[1]) {
                if (range[0] <= eRange && eRange <= range[1]) {
                    isNotLoaded = false;
                }
                else {
                    sRange = range[1] + 1;
                }
            }
            else if (range[0] <= eRange && eRange <= range[1]) {
                eRange = range[0] - 1;
            }
        });
        return { isNotLoaded: isNotLoaded, unloadedRange: [sRange, eRange] };
    }
    getMaxCount(range) {
        if (range.query) {
            const query = range.query.queries;
            for (let i = 0; i < query.length; i++) {
                if (query[i].fn === 'onTake') {
                    return Math.min(query[i].e.nos, range.info.count || query[i].e.nos);
                }
            }
        }
        return range.info.count;
    }
    initRangeInfo(range) {
        if (!range.info) {
            range.info = { loadedRange: [] };
        }
    }
    /**
     * Remove old data from sheet.
     *
     * @param {Object} args - Specify the args.
     * @param {number} args.sheetIdx - Specify the sheetIdx.
     * @param {number} args.rangeIdx - Specify the rangeIdx.
     * @param {Object[]} args.changedData - Specify the changedData.
     * @returns {void} - Remove old data from sheet.
     */
    dataSourceChangedHandler(args) {
        let row;
        const sheet = this.parent.sheets[args.sheetIdx];
        const range = sheet.ranges[args.rangeIdx];
        if (range && (this.checkRangeHasChanges(sheet, args.rangeIdx) || !range.info)) {
            const showFieldAsHeader = range.showFieldAsHeader;
            const indexes = getCellIndexes(range.startCell);
            if (range.info) {
                range.info.loadedRange.forEach((loadedRange) => {
                    for (let i = loadedRange[0]; i <= loadedRange[1] && (i < range.info.count + (showFieldAsHeader ? 1 : 0)); i++) {
                        row = sheet.rows[i + indexes[0]];
                        if (row) {
                            for (let j = indexes[1]; j < indexes[1] + range.info.fldLen; j++) {
                                if (row.cells && row.cells[j]) {
                                    delete row.cells[j];
                                }
                            }
                        }
                    }
                });
                range.info = null;
            }
            const evtArgs = {
                sheet: sheet, indexes: [0, 0, sheet.rowCount - 1, sheet.colCount - 1], loadFullData: true,
                promise: new Promise((resolve) => { resolve((() => { })()); })
            };
            this.updateSheetFromDataSourceHandler(evtArgs);
            evtArgs.promise.then(() => {
                this.parent.trigger('dataSourceChanged', { data: args.changedData, action: 'dataSourceChanged', rangeIndex: args.rangeIdx,
                    sheetIndex: args.sheetIdx });
                this.parent.notify(updateView, { sheetIndex: args.sheetIdx, checkWrap: true, checkCF: true });
            });
        }
    }
    checkRangeHasChanges(sheet, rangeIdx) {
        if (this.parent.isAngular) {
            if (sheet['changedRangeIdx'] === rangeIdx) {
                delete sheet['changedRangeIdx'];
                return true;
            }
            return false;
        }
        else {
            return true;
        }
    }
    /**
     * Triggers dataSourceChange event when cell data changes
     *
     * @param {Object} args - Specify the args.
     * @param {number} args.sheetIdx - Specify the sheetIdx.
     * @param {number} args.activeSheetIndex - Specify the activeSheetIndex.
     * @param {string} args.address - Specify the address.
     * @param {number} args.startIndex - Specify the startIndex.
     * @param {number} args.endIndex - Specify the endIndex.
     * @param {string} args.modelType - Specify the modelType.
     * @param {RowModel[]} args.deletedModel - Specify the deletedModel.
     * @param {RowModel[]} args.model - Specify the model.
     * @param {string} args.insertType - Specify the insertType.
     * @param {number} args.index - Specify the index.
     * @param {string} args.type - Specify the type.
     * @param {boolean} args.isMethod - Specify the isMethod.
     * @param {string} args.fillRange - Specify the fill range.
     * @param {string} args.range - Specify the range.
     * @param {string} args.requestType - Specify the requestType.
     * @param {Object[]} args.data - Specify the data.
     * @param {boolean}  args.isDataRequest - Specify the isDataRequest.
     * @param {string} args.pastedRange - Specify the pasted range.
     * @param {boolean} args.skipFilterCheck - Specify the skip filter check.
     * @returns {void} - Triggers dataSourceChange event when cell data changes
     */
    dataChangedHandler(args) {
        const changedData = [{}];
        let action;
        let cell;
        let dataRange;
        let startCell;
        let inRange;
        let inRangeCut;
        let deleteRowDetails;
        const sheetIdx = args.sheetIdx === undefined ? this.parent.activeSheetIndex : args.sheetIdx;
        const sheet = this.parent.sheets[sheetIdx];
        let cellIndices;
        let cutIndices;
        sheet.ranges.forEach((range, idx) => {
            if (range.dataSource) {
                let isNewRow;
                startCell = getCellIndexes(range.startCell);
                dataRange = [...startCell, startCell[0] + range.info.count + (range.showFieldAsHeader ? 0 : -1),
                    startCell[1] + range.info.fldLen - 1];
                if (args.modelType === 'Row' || args.modelType === 'Column') {
                    if (args.modelType === 'Column') {
                        if (args.insertType) {
                            inRange = dataRange[1] < args.index && dataRange[3] >= args.index;
                            cellIndices = [args.index];
                            if (!inRange) {
                                if ((dataRange[3] + 1 === args.index && args.insertType === 'after')) {
                                    args.model.forEach(() => {
                                        range.info.flds.splice(args.index - startCell[1], 0, '');
                                    });
                                    range.info.fldLen += args.model.length;
                                }
                                else if (dataRange[1] >= args.index) {
                                    range.startCell = getCellAddress(startCell[0], startCell[1] + args.model.length);
                                }
                            }
                            else {
                                args.model.forEach(() => {
                                    range.info.flds.splice(args.index - startCell[1], 0, '');
                                });
                                range.info.fldLen += args.model.length;
                            }
                        }
                        else {
                            inRange = dataRange[1] <= args.startIndex && dataRange[3] >= args.startIndex;
                            if (inRange) {
                                for (let i = args.startIndex; i <= args.endIndex; i++) {
                                    if (i <= dataRange[3]) {
                                        range.info.flds.splice(args.startIndex, 1);
                                        range.info.fldLen -= 1;
                                    }
                                }
                            }
                        }
                        return;
                    }
                    else {
                        if (args.insertType) {
                            inRange = ((!range.showFieldAsHeader && (args.insertType === 'above' || args.isMethod)) ? dataRange[0] <=
                                args.index : dataRange[0] < args.index) && dataRange[2] >= args.index;
                            cellIndices = [args.index];
                            if (!inRange) {
                                if ((dataRange[2] + 1 === args.index && args.insertType === 'below')) {
                                    isNewRow = true;
                                    range.info.count += args.model.length;
                                }
                                else if (dataRange[0] >= args.index) {
                                    range.startCell = getCellAddress(startCell[0] + args.model.length, startCell[1]);
                                }
                            }
                            else {
                                isNewRow = true;
                                range.info.count += args.model.length;
                            }
                            if (args.isMethod) {
                                return;
                            }
                        }
                        else {
                            inRange = dataRange[0] <= args.startIndex && dataRange[2] >= args.startIndex;
                            if (args.isDataRequest) {
                                cellIndices = [args.startIndex, dataRange[1], args.startIndex, dataRange[1]];
                            }
                            else {
                                action = 'delete';
                            }
                        }
                    }
                }
                else {
                    const argsAddress = args.address || args.range || args.fillRange;
                    cellIndices = getRangeIndexes(args.requestType && args.requestType.toLowerCase().includes('paste') ? args.pastedRange.substring(args.pastedRange.lastIndexOf('!') + 1) :
                        args.sheetIdx > -1 ? args.address : argsAddress.substring(argsAddress.lastIndexOf('!') + 1));
                    const dataRangeIndices = [...[range.showFieldAsHeader ? dataRange[0] + 1 : dataRange[0]], ...dataRange.slice(1, 4)];
                    if (range.showFieldAsHeader && cellIndices[0] === startCell[0]) {
                        for (let i = cellIndices[1]; i <= cellIndices[3]; i++) {
                            if (i >= dataRangeIndices[1] && i <= dataRangeIndices[3]) {
                                range.info.flds[i - startCell[1]] = getCell(startCell[0], i, sheet, false, true).value || '';
                            }
                        }
                    }
                    inRange = isInRange(dataRangeIndices, cellIndices, true);
                    if (args.requestType === 'paste' && args.copiedInfo.isCut) {
                        cutIndices = [].slice.call(args.copiedInfo.range);
                        if (range.showFieldAsHeader && cutIndices[0] === startCell[0]) {
                            for (let i = cutIndices[1]; i <= cutIndices[3]; i++) {
                                if (i >= dataRangeIndices[1] && i <= dataRangeIndices[3]) {
                                    range.info.flds[i - startCell[1]] = '';
                                }
                            }
                            inRange = false;
                        }
                        inRangeCut = isInRange(dataRangeIndices, cutIndices, true);
                    }
                }
                if (inRange || isNewRow || inRangeCut) {
                    if (args.modelType === 'Row' && !args.insertType && !args.isDataRequest) {
                        args.deletedModel.forEach((row, rowIdx) => {
                            changedData[rowIdx] = {};
                            range.info.flds.forEach((fld, idx) => {
                                if (row.cells) {
                                    cell = row.cells[startCell[1] + idx];
                                    changedData[rowIdx][`${fld}`] = this.getFormattedValue(cell);
                                }
                                else {
                                    changedData[rowIdx][`${fld}`] = null;
                                }
                            });
                            range.info.count -= 1;
                        });
                        if (args.isMethod) {
                            return;
                        }
                        deleteRowDetails = { count: args.deletedModel.length, index: args.endIndex };
                    }
                    else {
                        action = isNewRow ? 'add' : 'edit';
                        let addedCutData = 0;
                        if (inRangeCut) {
                            addedCutData = cutIndices[2] - cutIndices[0] + 1;
                            for (let i = 0; i < addedCutData; i++) {
                                changedData[i] = {};
                                range.info.flds.forEach((fld, idx) => {
                                    if (fld) {
                                        cell = getCell(cutIndices[0] + i, startCell[1] + idx, sheet);
                                        changedData[i][`${fld}`] = this.getFormattedValue(cell);
                                    }
                                });
                            }
                        }
                        if (inRange || isNewRow) {
                            const filterCheck = !args.isDataRequest && !inRangeCut && !isNewRow && !args.skipFilterCheck;
                            for (let i = 0, count = 0; i < (isNewRow ? args.model.length : (cellIndices[2] - cellIndices[0])
                                + 1 || 1); i++) {
                                if (filterCheck && isFilterHidden(sheet, cellIndices[0] + i)) {
                                    continue;
                                }
                                changedData[count + addedCutData] = {};
                                range.info.flds.forEach((fld, idx) => {
                                    if (fld) {
                                        cell = getCell(cellIndices[0] + i, startCell[1] + idx, sheet);
                                        changedData[count + addedCutData][`${fld}`] = this.getFormattedValue(cell);
                                    }
                                });
                                count++;
                            }
                        }
                    }
                    if (args.isDataRequest) {
                        args.data = changedData;
                    }
                    else {
                        this.parent.trigger('dataSourceChanged', { data: changedData, action: action, rangeIndex: idx, sheetIndex: sheetIdx });
                    }
                }
                else if (deleteRowDetails && deleteRowDetails.count && dataRange[0] > deleteRowDetails.index) {
                    range.startCell = getCellAddress(startCell[0] - deleteRowDetails.count, startCell[1]);
                }
            }
        });
    }
    getFormattedValue(cell) {
        const value = this.parent.getDisplayText(cell);
        if (value === '') {
            return null;
        }
        else if (cell && !cell.format && typeof cell.value === 'number') {
            return cell.value;
        }
        return value;
    }
    triggerDataChangeHandler(args) {
        const dataChangingActions = ['insert', 'delete', 'edit', 'cellDelete', 'cellSave', 'autofill', 'clipboard', 'clear'];
        let triggerDataChange = true;
        if ((args.action === 'delete' || args.action === 'insert') && ['Sheet'].indexOf(args.eventArgs.modelType) > -1) {
            triggerDataChange = false;
        }
        else if (args.action === 'clear' && ['Clear Formats', 'Clear Hyperlinks'].indexOf(args.eventArgs.type) > -1) {
            triggerDataChange = false;
        }
        else if (args.action === 'clipboard' && args.eventArgs.requestType === 'Formats') {
            triggerDataChange = false;
        }
        if (triggerDataChange && dataChangingActions.indexOf(args.action) > -1) {
            let evtArgs;
            if (args.isUndo && (args.action === 'delete' || args.action === 'insert')) {
                evtArgs = extend({}, args.eventArgs);
                if (args.action === 'delete') {
                    evtArgs.index = evtArgs.startIndex;
                    evtArgs.model = evtArgs.deletedModel;
                    evtArgs.insertType = 'below';
                }
                else {
                    evtArgs.startIndex = evtArgs.index;
                    evtArgs.endIndex = args.eventArgs.index + args.eventArgs.model.length - 1;
                    evtArgs.deletedModel = evtArgs.model;
                    delete evtArgs.insertType;
                }
            }
            else {
                evtArgs = args.eventArgs;
            }
            this.parent.notify(dataChanged, evtArgs);
        }
    }
    /**
     * For internal use only - Get the module name.
     *
     * @returns {string} - Get the module name.
     * @private
     */
    getModuleName() {
        return 'dataBind';
    }
    /**
     * Destroys the Data binding module.
     *
     * @returns {void} - Destroys the Data binding module.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
        this.requestedInfo = [];
    }
}

/**
 * Specifies spreadsheet internal events
 */
/** @hidden */
const ribbon = 'ribbon';
/** @hidden */
const formulaBar = 'formulaBar';
/** @hidden */
const sheetTabs = 'sheetTabs';
/** @hidden */
const refreshSheetTabs = 'refreshSheetTabs';
/** @hidden */
const isFormulaBarEdit = 'isFormulaBarEdit';
/** @hidden */
const contentLoaded = 'contentLoaded';
/** @hidden */
const mouseDown = 'mouseDown';
/** @hidden */
const spreadsheetDestroyed = 'spreadsheetDestroyed';
/** @hidden */
const editOperation = 'editOperation';
/** @hidden */
const formulaOperation = 'formulaOperation';
/** @hidden */
const formulaBarOperation = 'formulaBarOperation';
/** @hidden */
const click = 'click';
/** @hidden */
const keyUp = 'keyUp';
/** @hidden */
const keyDown = 'keyDown';
/** @hidden */
const formulaKeyUp = 'formulaKeyUp';
/** @hidden */
const formulaBarUpdate = 'formulaBarUpdate';
/** @hidden */
const onVerticalScroll = 'verticalScroll';
/** @hidden */
const onHorizontalScroll = 'horizontalScroll';
/** @hidden */
const focusRenameInput = 'focusRenameInput';
/** @hidden */
const beforeContentLoaded = 'beforeContentLoaded';
/** @hidden */
const beforeVirtualContentLoaded = 'beforeVirtualContentLoaded';
/** @hidden */
const virtualContentLoaded = 'virtualContentLoaded';
/** @hidden */
const contextMenuOpen = 'contextMenuOpen';
/** @hidden */
const cellNavigate = 'cellNavigate';
/** @hidden */
const mouseUpAfterSelection = 'mouseUpAfterSelection';
/** @hidden */
const cMenuBeforeOpen = 'contextmenuBeforeOpen';
/** @hidden */
const insertSheetTab = 'insertSheetTab';
/** @hidden */
const removeSheetTab = 'removeSheetTab';
/** @hidden */
const renameSheetTab = 'renameSheetTab';
/** @hidden */
const ribbonClick = 'ribboClick';
/** @hidden */
const refreshRibbon = 'ribbonRefresh';
/** @hidden */
const enableToolbarItems = 'enableToolbarItems';
/** @hidden */
const tabSwitch = 'tabSwitch';
/** @hidden */
const selectRange = 'selectRange';
/** @hidden */
const rangeSelectionByKeydown = 'rangeSelectionByKeydown';
/** @hidden */
const cut = 'cut';
/** @hidden */
const copy = 'copy';
/** @hidden */
const paste = 'paste';
/** @hidden */
const clearCopy = 'clearCopy';
/** @hidden */
const dataBound = 'dataBound';
/** @hidden */
const beforeDataBound = 'beforeDataBound';
/** @hidden */
const addContextMenuItems = 'addContextMenuItems';
/** @hidden */
const removeContextMenuItems = 'removeContextMenuItems';
/** @hidden */
const enableContextMenuItems = 'enableContextMenuItems';
/** @hidden */
const enableFileMenuItems = 'enableFileMenuItems';
/** @hidden */
const hideFileMenuItems = 'hideFileMenuItems';
/** @hidden */
const addFileMenuItems = 'addFileMenuItems';
/** @hidden */
const hideRibbonTabs = 'hideRibbonTabs';
/** @hidden */
const enableRibbonTabs = 'enableRibbonTabs';
/** @hidden */
const addRibbonTabs = 'addRibbonTabs';
/** @hidden */
const addToolbarItems = 'addToolbarItems';
/** @hidden */
const hideToolbarItems = 'hideToolbarItems';
/** @hidden */
const beforeRibbonCreate = 'beforeRibbonCreate';
/** @hidden */
const rowHeightChanged = 'rowHeightChanged';
/** @hidden */
const colWidthChanged = 'colWidthChanged';
/** @hidden */
const onContentScroll = 'onContentScroll';
/** @hidden */
const deInitProperties = 'deInitProperties';
/** @hidden */
const activeSheetChanged = 'activeSheetChanged';
/** @hidden */
const initiateCustomSort = 'initiateCustomSort';
/** @hidden */
const applySort = 'applySort';
/** @hidden */
const collaborativeUpdate = 'collaborativeUpdate';
/** @hidden */
const autoFit = 'autoFitRowsColumns';
/** @hidden */
const refreshFilterCellsOnResize = 'refreshFilterCellsOnResize';
/** @hidden */
const updateToggleItem = 'updateToggleItem';
/** @hidden */
const initiateHyperlink = 'initiateHyperlink';
/** @hidden */
const editHyperlink = 'editHyperlink';
/** @hidden */
const openHyperlink = 'openHyperlink';
/** @hidden */
const addNote = 'addNote';
/** @hidden */
const editNote = 'editNote';
/** @hidden */
const deleteNote = 'deleteNote';
/** @hidden */
const showNote = 'showNote';
/** @hidden */
const createNoteIndicator = 'createNoteIndicator';
/** @hidden */
const updateNoteContainer = 'updateNoteContainer';
/** @hidden */
const removeNoteContainer = 'removeNoteContainer';
/** @hidden */
const removeHyperlink = 'removeHyperlink';
/** @hidden */
const createHyperlinkElement = 'createHyperlinkElement';
/** @hidden */
const sheetNameUpdate = 'sheetNameUpdate';
/** @hidden */
const hideSheet = 'hideSheet';
/** @hidden */
const performUndoRedo = 'performUndoRedo';
/** @hidden */
const updateUndoRedoCollection = 'updateUndoRedoCollection';
/** @hidden */
const setActionData = 'setActionData';
/** @hidden */
const getBeforeActionData = 'getBeforeActionData';
/** @hidden */
const clearUndoRedoCollection = 'clearUndoRedoCollection';
/** @hidden */
const initiateFilterUI = 'initiateFilterUI';
/** @hidden */
const renderFilterCell = 'renderFilterCell';
/** @hidden */
const refreshFilterRange = 'refreshFilterRange';
/** @hidden */
const reapplyFilter = 'reapplyFilter';
/** @hidden */
const filterByCellValue = 'filterByCellValue';
/** @hidden */
const clearFilter = 'clearFilter';
/** @hidden */
const getFilteredColumn = 'getFilteredColumn';
/** @hidden */
const completeAction = 'actionComplete';
/** @hidden */
const filterCellKeyDown = 'filterCellKeyDown';
/** @hidden */
const getFilterRange = 'getFilterRange';
/** @hidden */
const setAutoFit = 'setAutoFit';
/** @hidden */
const refreshFormulaDatasource = 'refreshFormulaDatasource';
/** @hidden */
const initiateDataValidation = 'initiatedatavalidation';
/** @hidden */
const validationError = 'validationError';
/** @hidden */
const startEdit = 'startEdit';
/** @hidden */
const invalidData = 'invalidData';
/** @hidden */
const clearInvalid = 'clearInvalid';
/** @hidden */
const protectSheet = 'protectSheet';
/** @hidden */
const applyProtect = 'applyProtect';
/** @hidden */
const unprotectSheet = 'unprotectSheet';
/** @hidden */
const protectCellFormat = 'protectCellFormat';
/** @hidden */
const gotoDlg = 'renderGotoDlgt';
/** @hidden */
const findDlg = 'renderFindDlg';
/** @hidden */
const findHandler = 'findHandler';
/** @hidden */
const created = 'created';
/** @hidden */
const spreadsheetCreated = 'spreadsheetCreated';
/** @hidden */
const editAlert = 'editAlert';
/** @hidden */
const readonlyAlert = 'readonlyAlert';
/** @hidden */
const finiteAlert = 'finiteAlert';
/** @hidden */
const setUndoRedo = 'setUndoRedo';
/** @hidden */
const enableFormulaInput = 'enableFormulaInput';
/** @hidden */
const protectSelection = 'protectSelection';
/** @hidden */
const hiddenMerge = 'hiddenMerge';
/** @hidden */
const checkPrevMerge = 'checkPrevMerge';
/** @hidden */
const checkMerge = 'checkMerge';
/** @hidden */
const removeDataValidation = 'removeDataValidation';
/** @hidden */
const showAggregate = 'showAggregate';
/** @hidden */
const goToSheet = 'goToSheet';
/** @hidden */
const showSheet = 'showSheet';
/** @hidden */
const renderCFDlg = 'renderCFDlg';
/** @hidden */
const clearViewer = 'clearViewer';
/** @hidden */
const initiateFormulaReference = 'initiateFormulaReference';
/** @hidden */
const initiateCur = 'initiateCur';
/** @hidden */
const clearCellRef = 'clearCellRef';
/** @hidden */
const editValue = 'editValue';
/** @hidden */
const addressHandle = 'addressHandle';
/** @hidden */
const initiateEdit = 'initiateEdit';
/** @hidden */
const forRefSelRender = 'forRefSelRender';
/** @hidden */
const insertImage = 'insertImage';
/** @hidden */
const refreshOverlayElem = 'refreshOverlayElem';
/** @hidden */
const refreshImgCellObj = 'refreshImgCellObj';
/** @hidden */
const getRowIdxFromClientY = 'getRowIdxFromClientY';
/** @hidden */
const getColIdxFromClientX = 'getColIdxFromClientX';
/** @hidden */
const createImageElement = 'createImageElement';
/** @hidden */
const deleteImage = 'deleteImage';
/** @hidden */
const deleteChart = 'deleteChart';
/** @hidden */
const refreshChartCellObj = 'refreshChartCellObj';
/** @hidden */
const refreshChartCellModel = 'refreshChartCellModel';
/** @hidden */
const refreshImagePosition = 'refreshImagePosition';
/** @hidden */
const updateTableWidth = 'updateTableWidth';
/** @hidden */
const focusBorder = 'focusBorder';
/** @hidden */
const clearChartBorder = 'clearChartBorder';
/** @hidden */
const insertChart = 'insertChart';
/** @hidden */
const chartRangeSelection = 'chartRangeSelection';
/** @hidden */
const insertDesignChart = 'insertDesignChart';
/** @hidden */
const removeDesignChart = 'removeDesignChart';
/** @hidden */
const chartDesignTab = 'chartDesignTab';
/** @hidden */
const addChartEle = 'addChartEle';
/** @hidden */
const undoRedoForChartDesign = 'undoRedoForChartDesign';
/** @hidden */
const protectWorkbook = 'protectWorkbook';
/** @hidden */
const unProtectWorkbook = 'unProtectWorkbook';
/** @hidden */
const setProtectWorkbook = 'setProtectWorkbook';
/** @hidden */
const removeWorkbookProtection = 'removeWorkbookProtection';
/** @hidden */
const importProtectWorkbook = 'importProtectWorkbook';
/** @hidden */
const selectionStatus = 'selectionStatus';
/** @hidden */
const freeze = 'freeze';
/** @hidden */
const overlayEleSize = 'overlayEleSize';
/** @hidden */
const updateScroll = 'updateScroll';
/** @hidden */
const positionAutoFillElement = 'positionAutoFillElement';
/** @hidden */
const hideAutoFillOptions = 'hideAutoFillOptions';
/** @hidden */
const performAutoFill = 'performAutoFill';
/** @hidden */
const selectAutoFillRange = 'selectAutoFillRange';
/** @hidden */
const autoFill = 'autoFill';
/** @hidden */
const hideAutoFillElement = 'hideAutoFillElement';
/** @hidden */
const unProtectSheetPassword = 'unProtectSheetPassword';
/** @hidden */
const updateTranslate = 'updateTranslate';
/** @hidden */
const getUpdatedScrollPosition = 'getUpdatedScrollPosition';
/** @hidden */
const updateScrollValue = 'updateScrollValue';
/** @hidden */
const beforeCheckboxRender = 'beforeCheckboxfilterRenderer';
/** @hidden */
const refreshCheckbox = 'refreshCheckbox';
/** @hidden */
const renderInsertDlg = 'renderInsertDlg';
/** @hidden */
const toggleProtect = 'toggleProtect';
/** @hidden */
const propertyChange = 'propertyChange';
/** @hidden */
const updateWrapCell = 'updateWrapCell';

/**
 * Open properties.
 */
class WorkbookOpen {
    constructor(parent) {
        this.loopIndex = 0;
        this.processedLoopIndex = 0;
        this.retryCount = 0;
        this.currentDocumentId = null;
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * To open the excel file stream or excel url into the spreadsheet.
     *
     * @param {OpenArgs} options - Options to open a excel file.
     * @returns {void} - To open the excel file stream or excel url into the spreadsheet.
     */
    open(options) {
        this.load(options);
    }
    load(options, isRetryRequest) {
        if (!this.parent.allowOpen) {
            return;
        }
        if (options.jsonObject) {
            this.fetchSuccess(options.jsonObject, options, null, true, true);
            return;
        }
        const formData = new FormData();
        if (options.file) {
            formData.append('file', options.file);
        }
        else if (options.sheetIndex >= 0) {
            formData.append('sheetPassword', options.sheetPassword);
            formData.append('sheetIndex', options.sheetIndex.toString());
        }
        else {
            this.parent.isOpen = false;
            return;
        }
        const args = { passWord: '' };
        if (options.password && options.password.length) {
            args.passWord = options.password;
        }
        if (args.passWord && args.passWord.length) {
            options.password = args.passWord;
        }
        if (options.password) {
            formData.append('password', options.password);
        }
        formData.append('IsManualCalculationEnabled', (this.parent.calculationMode === 'Manual').toString());
        const eventArgs = {
            file: options.file || null,
            cancel: false,
            requestData: {
                method: 'POST',
                body: formData
            },
            password: args.passWord
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const guid = options.guid;
        if (isNullOrUndefined(options.sheetPassword) && !guid && isNullOrUndefined(isRetryRequest)) {
            this.parent.trigger('beforeOpen', eventArgs);
            this.parent.notify(beginAction, { eventArgs: eventArgs, action: 'beforeOpen' });
        }
        else if (guid) {
            formData.append('guid', guid);
        }
        if (eventArgs.cancel) {
            this.parent.isOpen = false;
            return;
        }
        const header = { chunkSize: null, documentId: null };
        if (this.parent.openSettings.chunkSize > 0 && isNullOrUndefined(options.sheetPassword)) {
            this.setToDefaults(isRetryRequest);
            if (!isNullOrUndefined(this.parent.openSettings.chunkSize) && this.parent.openSettings.chunkSize !== 0) {
                header.chunkSize = this.parent.openSettings.chunkSize.toString();
            }
            if (!isNullOrUndefined(this.currentDocumentId)) {
                header.documentId = this.currentDocumentId;
            }
            if (!isNullOrUndefined(header)) {
                formData.append('chunkPayload', JSON.stringify(header));
            }
        }
        fetch(this.parent.openUrl, eventArgs.requestData)
            .then((response) => {
            if (response.ok) {
                return response.json();
            }
            else {
                return Promise.reject({
                    status: response.status,
                    statusText: response.statusText,
                    url: response.url
                });
            }
        })
            .then((data) => this.fetchSuccess(data, eventArgs, options.orginalFile, undefined, true))
            .catch((error) => {
            if (error.toString().indexOf('Unexpected end of JSON input') === -1 && this.parent.openSettings.chunkSize > 0 && this.retryCount < this.parent.openSettings.retryCount) {
                setTimeout(() => {
                    this.retryCount++;
                    this.load(options, true);
                }, this.parent.openSettings.retryAfterDelay);
            }
            else {
                if (this.retryCount >= this.parent.openSettings.retryCount) {
                    this.retryCount = 0;
                }
                this.fetchFailure(error);
            }
        });
    }
    fetchFailure(error) {
        if (isUndefined$1(error.status) && isUndefined$1(error.statusText)) {
            error.statusText = 'Improper response';
        }
        this.parent.notify(openFailure, error);
        this.parent.isOpen = false;
    }
    fetchSuccess(data, eventArgs, file, isOpenFromJson, isImport) {
        const openError = ['UnsupportedFile', 'InvalidUrl', 'NeedPassword', 'InCorrectPassword', 'InCorrectSheetPassword',
            'CorrectSheetPassword', 'DataLimitExceeded', 'FileSizeLimitExceeded', 'ExternalWorkbook'];
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const workbookData = typeof data === 'string' ? JSON.parse(data) : data;
        const impData = workbookData.Workbook;
        if (!isNullOrUndefined(impData)) {
            if (openError.indexOf(impData) > -1) {
                if (file) {
                    eventArgs.file = file;
                }
                this.parent.notify(openSuccess, {
                    context: this, data: impData, guid: workbookData.Guid, eventArgs: eventArgs,
                    isOpenFromJson: isOpenFromJson
                });
                return;
            }
            this.updateModel(impData, isOpenFromJson, isImport);
            this.parent.notify(openSuccess, { context: this, data: impData, isOpenFromJson: isOpenFromJson, eventArgs: eventArgs });
            this.parent.isOpen = false;
            if (eventArgs && eventArgs.password && eventArgs.password.length > 0) {
                if (this.parent.showSheetTabs) {
                    this.parent.element.querySelector('.e-add-sheet-tab').removeAttribute('disabled');
                    this.parent.element.querySelector('.e-add-sheet-tab').classList.remove('e-disabled');
                }
                this.parent.password = '';
            }
        }
        else {
            const totalChunk = workbookData.chunkTotalCount;
            this.currentDocumentId = workbookData.documentId;
            this.chunkList = new Array(totalChunk);
            let processedChunkIndex = 0;
            let chunkLimit = totalChunk > this.parent.openSettings.chunkSize ? this.parent.openSettings.chunkSize : totalChunk;
            let processedLoopIndex = 0;
            this.processedLoopIndex = 0;
            const binaryString = '';
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            const instance = this;
            if (!isNullOrUndefined(totalChunk)) {
                while (processedChunkIndex < totalChunk) {
                    instance.processChunk(processedChunkIndex, chunkLimit, processedLoopIndex, binaryString, eventArgs, file, isOpenFromJson, isImport);
                    processedChunkIndex += instance.parent.openSettings.chunkSize;
                    chunkLimit = processedChunkIndex + instance.parent.openSettings.chunkSize < totalChunk ?
                        instance.parent.openSettings.chunkSize : totalChunk - processedChunkIndex;
                    processedLoopIndex++;
                    instance.processedLoopIndex++;
                }
            }
        }
    }
    processChunk(processedChunkIndex, chunkLimit, processedLoopIndex, binaryString, eventArgs, file, isOpenFromJson, isImport) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const instance = this;
        const header = {
            currentChunk: processedChunkIndex.toString(), chunkSize: chunkLimit.toString(),
            loopIndex: processedLoopIndex.toString(), documentId: this.currentDocumentId
        };
        const formData = new FormData();
        formData.append('chunkPayload', JSON.stringify(header));
        const requestEventArgs = {
            file: file || null,
            cancel: false,
            requestData: {
                method: 'POST',
                body: formData
            },
            password: eventArgs.password
        };
        fetch(this.parent.openUrl, requestEventArgs.requestData)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .then((response) => {
            if (response.ok) {
                return response.json();
            }
            else {
                return Promise.reject({
                    status: response.status,
                    statusText: response.statusText,
                    url: response.url
                });
            }
        })
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .then((data) => {
            if (data !== '') {
                let chunks = atob(data['chunk']);
                const bytes = new Uint8Array(chunks.length);
                for (let i = 0; i < chunks.length; i++) {
                    bytes[i] = chunks.charCodeAt(i);
                }
                chunks = new TextDecoder('utf-8').decode(bytes);
                instance.chunkList[data['loopIndex']] = chunks;
                instance.loopIndex++;
                if (instance.loopIndex === instance.processedLoopIndex) {
                    const splicedArray = instance.chunkList.splice(0, instance.loopIndex);
                    for (let k = 0; k < splicedArray.length; k++) {
                        binaryString += splicedArray.slice(k, k + 1).join('');
                    }
                    data = JSON.parse(binaryString);
                    instance.setToDefaults();
                    instance.fetchSuccess(data, eventArgs, file, isOpenFromJson, isImport);
                }
            }
        })
            .catch((error) => {
            if (isNullOrUndefined(instance.currentFailedChunkIndex) || instance.currentFailedChunkIndex === processedChunkIndex) {
                instance.currentFailedChunkIndex = processedChunkIndex;
                if (instance.retryCount < instance.parent.openSettings.retryCount) {
                    setTimeout(() => {
                        instance.processedLoopIndex = processedLoopIndex;
                        instance.processChunk(processedChunkIndex, chunkLimit, processedLoopIndex, binaryString, eventArgs, file, isOpenFromJson, isImport);
                        instance.retryCount++;
                    }, instance.parent.openSettings.retryAfterDelay);
                }
                else {
                    instance.retryCount = 0;
                    return instance.fetchFailure(error);
                }
            }
        });
    }
    setToDefaults(isRetryRequest) {
        this.currentFailedChunkIndex = null;
        if (!isRetryRequest) {
            this.retryCount = 0;
        }
        this.loopIndex = 0;
        this.processedLoopIndex = 0;
        this.chunkList = [];
    }
    updateModel(workbookModel, isOpenFromJson, isImport) {
        this.parent.notify(workbookFormulaOperation, { action: 'unRegisterSheet' });
        this.setSelectAllRange(workbookModel.sheets, isOpenFromJson);
        this.parent.sheetNameCount = 1;
        this.parent.sheets = [];
        this.parent.notify(sheetsDestroyed, {});
        this.parent.notify(clearUndoRedoCollection, null);
        workbookModel.activeSheetIndex = workbookModel.activeSheetIndex || workbookModel.sheets.findIndex((sheet) => sheet.state !== 'Hidden');
        this.parent.setProperties({
            'isProtected': workbookModel.isProtected || false,
            'password': workbookModel.password || '',
            'sheets': workbookModel.sheets,
            'activeSheetIndex': workbookModel.activeSheetIndex,
            'definedNames': workbookModel.definedNames || [],
            'filterCollection': workbookModel.filterCollection || [],
            'sortCollection': workbookModel.sortCollection || [],
            'listSeparator': workbookModel.listSeparator || this.parent.listSeparator
        }, true);
        if (!isNullOrUndefined(workbookModel.showSheetTabs)) {
            this.parent.showSheetTabs = workbookModel.showSheetTabs;
        }
        initSheet(this.parent, undefined, isImport);
        this.parent.notify(sheetCreated, null);
        this.parent.notify(workbookFormulaOperation, { action: 'registerSheet', isImport: true });
        this.parent.notify(workbookFormulaOperation, { action: 'initiateDefinedNames' });
        this.parent.notify(protectSheetWorkBook, null);
    }
    setSelectAllRange(sheets, isOpenFromJson) {
        let curSheet;
        let curRange;
        sheets.forEach((sheet) => {
            if (sheet.selectedRange) {
                const selectedIndex = getRangeIndexes(sheet.selectedRange);
                const rowCount = (isUndefined$1(sheet.rowCount) ? 100 : sheet.rowCount) - 1;
                const colCount = (isUndefined$1(sheet.colCount) ? 100 : sheet.colCount) - 1;
                if (selectedIndex[2] === 65535) {
                    selectedIndex[2] = rowCount;
                }
                if (selectedIndex[3] === 255) {
                    selectedIndex[3] = colCount;
                }
                if (selectedIndex[0] === 65535) {
                    selectedIndex[0] = rowCount;
                }
                if (selectedIndex[1] === 255) {
                    selectedIndex[1] = colCount;
                }
                sheet.selectedRange = getRangeAddress(selectedIndex);
            }
            if (isOpenFromJson && this.parent.isAngular) {
                for (let i = 0; i < this.parent.sheets.length; i++) {
                    curSheet = getSheet(this.parent, i);
                    if (sheet.name === curSheet.name) {
                        if (sheet.ranges) {
                            sheet.ranges.forEach((range, index) => {
                                curRange = curSheet.ranges[index];
                                if (curRange && curRange.template) {
                                    range.template = curRange.template;
                                }
                            });
                        }
                        break;
                    }
                }
            }
        });
    }
    sheetsDestroyHandler(args) {
        if (isNullOrUndefined(args.sheetIndex)) {
            this.preventFormatCheck = null;
        }
    }
    /**
     * Adding event listener for workbook open.
     *
     * @returns {void} - Adding event listener for workbook open.
     */
    addEventListener() {
        this.parent.on(workbookOpen, this.open.bind(this));
        this.parent.on(sheetsDestroyed, this.sheetsDestroyHandler, this);
    }
    /**
     * Removing event listener workbook open.
     *
     * @returns {void} - removing event listener workbook open.
     */
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(workbookOpen, this.open.bind(this));
            this.parent.off(sheetsDestroyed, this.sheetsDestroyHandler);
        }
    }
    /**
     * To Remove the event listeners
     *
     * @returns {void} - To Remove the event listeners
     */
    destroy() {
        this.removeEventListener();
        if (!this.parent.refreshing) {
            this.preventFormatCheck = null;
        }
        this.parent = null;
    }
    /**
     * Get the workbook open module name.
     *
     * @returns {string} - Get the module name.
     */
    getModuleName() {
        return 'workbookOpen';
    }
}

/**
 * @hidden
 * The `SaveWorker` module is used to perform save functionality with Web Worker.
 */
class SaveWorker {
    /**
     * Constructor for SaveWorker module in Workbook library.
     *
     * @private
     * @param {Workbook} parent - Specifies the workbook.
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Process sheet.
     *
     * @param {string} sheet - specify the sheet
     * @param {number} sheetIndex - specify the sheetIndex
     * @returns {Object} - Process sheet.
     * @hidden
     */
    processSheet(sheet, sheetIndex) {
        const parsedSheet = JSON.parse(sheet, (key, value) => {
            //Remove empty properties
            if ((Array.isArray(value) || typeof value === 'string') && !value.length) {
                return undefined;
            }
            return value;
        });
        return [sheetIndex, parsedSheet];
    }
    /**
     * Process save action.
     *
     * @param {Object} saveJSON - specify the object
     * @param {SaveOptions | Object} saveSettings - specify the saveSettings
     * @param {Object} customParams - specify the customParams
     * @param {Object} pdfLayoutSettings - specify the pdfLayoutSettings
     * @param {Function} successCallBack - specify the success callback function while invoking this method without worker.
     * @returns {void} - Process save action.
     * @hidden
     */
    processSave(saveJSON, saveSettings, customParams, pdfLayoutSettings, successCallBack) {
        const formData = new FormData();
        let i;
        let keys = Object.keys(saveSettings);
        formData.append('JSONData', JSON.stringify(saveJSON));
        for (i = 0; i < keys.length; i++) {
            formData.append(keys[i], saveSettings[keys[i]]);
        }
        keys = Object.keys(customParams);
        for (i = 0; i < keys.length; i++) {
            formData.append(keys[i], customParams[keys[i]]);
        }
        formData.append('pdfLayoutSettings', JSON.stringify(pdfLayoutSettings));
        fetch(saveSettings.url, { method: 'POST', body: formData })
            .then((response) => {
            if (response.ok) {
                return response.blob();
            }
            else {
                return Promise.reject({
                    message: response.statusText
                });
            }
        })
            .then((data) => {
            new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = () => {
                    let result = reader.result.toString();
                    const saveAsHtml = customParams['customParams'] && typeof customParams['customParams'] === 'string' &&
                        customParams['customParams'].toLowerCase() === 'saveashtml';
                    if (result.indexOf('data:text/plain;base64,') > -1 || (!saveAsHtml && result.indexOf('data:text/html;base64,') > -1) ||
                        result.indexOf('data:application/json;base64,') > -1) {
                        let str;
                        result = result.replace('data:text/plain;base64,', '');
                        result = result.replace('data:text/html;base64,', '');
                        if (result.indexOf('data:application/json;base64,') > -1) {
                            result = result.replace('data:application/json;base64,', '');
                            str = atob(result).split('.');
                        }
                        else {
                            str = atob(result).split(/(\r\n|\n|\r)/gm);
                        }
                        if (str.length) {
                            const text = str[0].length > 1 && str[0][0] === '"' ? str[0].split('"')[1] + '.' : str[0];
                            if (successCallBack) {
                                successCallBack.apply(this, [{ dialog: text }]);
                            }
                            else {
                                postMessage({ dialog: text });
                            }
                        }
                    }
                    else {
                        if (successCallBack) {
                            successCallBack.apply(this, [data]);
                        }
                        else {
                            postMessage(data);
                        }
                    }
                    resolve(reader.result);
                };
                reader.readAsDataURL(data);
            });
        })
            .catch((error) => {
            if (successCallBack) {
                successCallBack.apply(this, [{ error: error.message }]);
            }
            else {
                postMessage({ error: error.message });
            }
        });
        // try {
        //     let httpRequest: XMLHttpRequest = new XMLHttpRequest();
        //     let formData: FormData = new FormData();
        //     let i: number;
        //     let keys: string[] = Object.keys(saveSettings);
        //     httpRequest.onreadystatechange = (event: Event) => {
        //         if (httpRequest.readyState === 4 && httpRequest.status === 200) {
        //             (postMessage as Function)(httpRequest.response);
        //         }
        //     };
        //     httpRequest.onerror = (event: Event) => {
        //         (postMessage as Function)(event);
        //     };
        //     formData.append('JSONData', JSON.stringify(saveJSON));
        //     for (i = 0; i < keys.length; i++) {
        //         formData.append(keys[i], (<{ [key: string]: string }>saveSettings)[keys[i]]);
        //     }
        //     httpRequest.open('POST', saveSettings.saveUrl, false);
        //     httpRequest.send(formData);
        // } catch (e) {
        //     (postMessage as Function)({ error: e.message });
        // }
    }
}

/**
 * @hidden
 * The `WorkbookSave` module is used to handle the save action in Workbook library.
 */
class WorkbookSave extends SaveWorker {
    /**
     * Constructor for WorkbookSave module in Workbook library.
     *
     * @private
     * @param {Workbook} parent - Specifies the workbook.
     */
    constructor(parent) {
        super(parent);
        this.isProcessCompleted = false;
        this.saveJSON = {};
        this.isFullPost = false;
        this.needBlobData = false;
        this.customParams = null;
        this.pdfLayoutSettings = { fitSheetOnOnePage: false };
        this.addEventListener();
    }
    /**
     * Get the module name.
     *
     * @returns {string} - To Get the module name.
     * @private
     */
    getModuleName() {
        return 'workbookSave';
    }
    /**
     * To destroy the WorkbookSave module.
     *
     * @returns {void} - To destroy the WorkbookSave module.
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    /**
     * @hidden
     * @returns {void} - add Event Listener
     */
    addEventListener() {
        this.parent.on(beginSave, this.initiateSave, this);
        this.parent.on('getStringifyObject', this.performStringifyAction, this);
    }
    /**
     * @hidden
     * @returns {void} - remove Event Listener.
     */
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(beginSave, this.initiateSave);
            this.parent.off('getStringifyObject', this.performStringifyAction);
        }
    }
    /**
     * Initiate save process.
     *
     * @hidden
     * @param {Object} args - Specify the args.
     * @returns {void} - Initiate save process.
     */
    initiateSave(args) {
        const saveSettings = args.saveSettings;
        this.saveSettings = {
            saveType: saveSettings.saveType,
            url: saveSettings.url,
            fileName: saveSettings.fileName || 'Sample'
            //passWord: saveSettings.passWord
        };
        this.isFullPost = args.isFullPost;
        this.needBlobData = args.needBlobData;
        if (this.needBlobData) {
            this.isFullPost = false;
        }
        this.customParams = args.customParams;
        this.pdfLayoutSettings = args.pdfLayoutSettings;
        this.updateBasicSettings();
        this.processSheets(saveSettings.autoDetectFormat, args.jsonConfig);
    }
    /**
     * Update save JSON with basic settings.
     *
     * @hidden
     * @returns {void} - Update save JSON with basic settings.
     */
    updateBasicSettings() {
        const jsonStr = this.getStringifyObject(this.parent, ['sheets', '_isScalar', 'observers', 'closed', 'isStopped', 'hasError',
            '__isAsync', 'beforeCellFormat', 'beforeCellRender', 'beforeDataBound', 'beforeOpen', 'beforeSave', 'beforeSelect',
            'beforeSort', 'cellEdit', 'cellEdited', 'cellEditing', 'cellSave', 'beforeCellSave', 'contextMenuItemSelect', 'contextMenuBeforeClose',
            'contextMenuBeforeOpen', 'created', 'dataBound', 'fileMenuItemSelect', 'fileMenuBeforeClose', 'fileMenuBeforeOpen',
            'saveComplete', 'sortComplete', 'select', 'actionBegin', 'actionComplete', 'afterHyperlinkClick', 'afterHyperlinkCreate',
            'beforeHyperlinkClick', 'beforeHyperlinkCreate', 'openComplete', 'openFailure', 'queryCellInfo', 'dialogBeforeOpen',
            'dataSourceChanged', 'beforeConditionalFormat', 'beforeCellUpdate']);
        const basicSettings = JSON.parse(jsonStr);
        const sheetCount = this.parent.sheets.length;
        if (sheetCount) {
            basicSettings.sheets = [];
        }
        this.saveJSON = basicSettings;
        this.saveJSON.filterCollection = [];
    }
    /**
     * Process sheets properties.
     *
     * @param {boolean} autoDetectFormat - Auto detect the format based on the cell value.
     * @param {SerializationOptions} jsonConfig - Specify the serialization options to exclude specific features from the JSON.
     * @hidden
     * @returns {void} - Process sheets properties.
     */
    processSheets(autoDetectFormat, jsonConfig) {
        const skipProps = ['dataSource', 'startCell', 'query', 'showFieldAsHeader', 'result'];
        if (this.parent.isAngular) {
            skipProps.push('template');
        }
        if (jsonConfig) {
            if (jsonConfig.onlyValues) {
                skipProps.push(...['style', 'formula', 'format', 'conditionalFormats', 'validation',
                    'hyperlink', 'wrap', 'chart', 'image', 'notes']);
            }
            else {
                const ignoreProps = {
                    style: jsonConfig.ignoreStyle,
                    formula: jsonConfig.ignoreFormula,
                    format: jsonConfig.ignoreFormat,
                    conditionalFormats: jsonConfig.ignoreConditionalFormat,
                    validation: jsonConfig.ignoreValidation,
                    wrap: jsonConfig.ignoreWrap,
                    chart: jsonConfig.ignoreChart,
                    image: jsonConfig.ignoreImage,
                    notes: jsonConfig.ignoreNote
                };
                if (jsonConfig.ignoreFreezePane) {
                    skipProps.push(...['frozenColumns', 'frozenRows']);
                }
                for (const prop in ignoreProps) {
                    if (ignoreProps[prop]) {
                        skipProps.push(prop);
                    }
                }
            }
        }
        let isNotLoaded;
        let isDataBinding;
        let sheet;
        let range;
        for (let sheetIdx = 0, sheetCount = this.parent.sheets.length; sheetIdx < sheetCount; sheetIdx++) {
            sheet = this.parent.sheets[sheetIdx];
            isNotLoaded = false;
            isDataBinding = false;
            for (let rangeIdx = 0, rangeCount = sheet.ranges.length; rangeIdx < rangeCount; rangeIdx++) {
                range = sheet.ranges[rangeIdx];
                if (range.dataSource) {
                    isDataBinding = true;
                    if (!range.info || !range.info.loadedRange || !range.info.loadedRange.length) {
                        isNotLoaded = true;
                        break;
                    }
                }
            }
            if (isNotLoaded) {
                const loadCompleteHandler = (idx) => {
                    executeTaskAsync(this, this.processSheet, this.updateSheet, [this.getStringifyObject(this.parent.sheets[idx], skipProps, idx, false, true), idx], null, this.parent);
                };
                this.parent.notify(updateSheetFromDataSource, { sheet: sheet, sheetIndex: sheetIdx, loadComplete: loadCompleteHandler.bind(this, sheetIdx),
                    loadFromStartCell: true, autoDetectFormat: autoDetectFormat });
            }
            else {
                executeTaskAsync(this, this.processSheet, this.updateSheet, [this.getStringifyObject(sheet, skipProps, sheetIdx, autoDetectFormat && isDataBinding, true), sheetIdx], null, this.parent);
            }
        }
    }
    /**
     * Update processed sheet data.
     *
     * @hidden
     * @param {Object[]} data - Specifies the data.
     * @returns {void} - Update processed sheet data.
     */
    updateSheet(data) {
        this.saveJSON.sheets[data[0]] = data[1];
        this.isProcessCompleted = this.getSheetLength(this.saveJSON.sheets) === this.parent.sheets.length;
        if (this.isProcessCompleted) {
            this.save(this.saveSettings);
        }
    }
    getSheetLength(sheets) {
        let len = 0;
        sheets.forEach((sheet) => {
            if (sheet) {
                len++;
            }
        });
        return len;
    }
    /**
     * Save process.
     *
     * @hidden
     * @param {SaveOptions} saveSettings - Specifies the save settings props.
     * @returns {void} - Save process.
     */
    save(saveSettings) {
        const args = { cancel: false, jsonObject: this.saveJSON };
        this.parent.notify(onSave, args);
        if (!args.cancel) {
            if (this.isFullPost) {
                this.initiateFullPostSave();
                this.saveJSON = {};
            }
            else {
                executeTaskAsync(this, { 'workerTask': this.processSave }, this.updateSaveResult, [this.saveJSON, saveSettings, this.customParams, this.pdfLayoutSettings], true, this.parent);
            }
        }
    }
    /**
     * Update final save data.
     *
     * @hidden
     * @param {Object | Blob} result - specify the sve result.
     * @returns {void} - Update final save data.
     */
    updateSaveResult(result) {
        if (result.isFormDataError) {
            this.processSave(this.saveJSON, this.saveSettings, this.customParams, this.pdfLayoutSettings, this.updateSaveResult);
            return;
        }
        this.saveJSON = {};
        const args = {
            status: 'Success',
            message: '',
            url: this.saveSettings.url,
            fileName: this.saveSettings.fileName,
            saveType: this.saveSettings.saveType,
            blobData: null
        };
        if (typeof (result) === 'object' && result.error) {
            args.status = 'Failure';
            args.message = result.error.toString();
        }
        else if (typeof (result) === 'object' && result.dialog) {
            this.parent.notify(saveError, { content: result.dialog });
        }
        else {
            if (this.needBlobData) {
                args.blobData = result;
            }
            else {
                this.ClientFileDownload(result);
            }
        }
        this.parent.trigger('saveComplete', args);
        this.parent.notify(saveCompleted, args);
    }
    ClientFileDownload(blobData) {
        const anchor = this.parent.createElement('a', { attrs: { download: this.getFileNameWithExtension() } });
        const url = URL.createObjectURL(blobData);
        anchor.href = url;
        document.body.appendChild(anchor);
        anchor.click();
        URL.revokeObjectURL(url);
        document.body.removeChild(anchor);
    }
    initiateFullPostSave() {
        let keys = Object.keys(this.saveSettings);
        let i;
        const formElem = this.parent.createElement('form', { attrs: { method: 'POST', action: this.saveSettings.url } });
        let inputElem = this.parent.createElement('input', { attrs: { type: 'hidden', name: 'JSONData' } });
        inputElem.value = JSON.stringify(this.saveJSON);
        formElem.appendChild(inputElem);
        for (i = 0; i < keys.length; i++) {
            inputElem = this.parent.createElement('input', { attrs: { type: 'hidden', name: keys[i] } });
            inputElem.value = this.saveSettings[keys[i]];
            formElem.appendChild(inputElem);
        }
        keys = Object.keys(this.customParams);
        for (i = 0; i < keys.length; i++) {
            inputElem = this.parent.createElement('input', { attrs: { type: 'hidden', name: keys[i] } });
            inputElem.value = this.customParams[keys[i]];
            formElem.appendChild(inputElem);
        }
        inputElem = this.parent.createElement('input', { attrs: { type: 'hidden', name: 'pdfLayoutSettings' } });
        inputElem.value = JSON.stringify(this.pdfLayoutSettings);
        formElem.appendChild(inputElem);
        document.body.appendChild(formElem);
        formElem.submit();
        detach(formElem);
        this.parent.notify(saveCompleted, {});
    }
    performStringifyAction(args) {
        args.model = '{"jsonObject":{"Workbook":{"sheets":[';
        for (let sheetIdx = 0, sheetCount = this.parent.sheets.length - 1; sheetIdx <= sheetCount; sheetIdx++) {
            args.model += this.getStringifyObject(this.parent.sheets[sheetIdx], args.skipProps, sheetIdx) +
                (sheetIdx < sheetCount ? ',' : ']}}}');
        }
    }
    /**
     * Get stringified workbook object.
     *
     * @hidden
     * @param {object} model - Specifies the workbook or sheet model.
     * @param {string[]} skipProp - specifies the skipprop.
     * @param {number} sheetIdx - Specifies the sheet index.
     * @param {boolean} autoDetectFormat - Auto detect the format based on the cell value.
     * @param {boolean} isSaveAction - Specifies whether the call is for sheet processing during save action.
     * @returns {string} - Get stringified workbook object.
     */
    getStringifyObject(model, skipProp = [], sheetIdx, autoDetectFormat, isSaveAction) {
        if (sheetIdx === 0) {
            this.parent.notify(removeUniquecol, { clearAll: true });
        }
        if (isSaveAction) {
            this.parent.notify(setFilteredCollection, { sheetIdx: sheetIdx, isSaveAction: true, saveJson: this.saveJSON });
        }
        const chartColl = [];
        let chartModel;
        const autoDetectFormatFn = autoDetectFormat && getAutoDetectFormatParser(this.parent);
        const json = JSON.stringify(model, (key, value) => {
            if (skipProp.indexOf(key) > -1) {
                return undefined;
            }
            else if (key === 'cellStyle') {
                return this.parent.commonCellStyle;
            }
            else {
                if (value && value.cells) {
                    for (let i = 0, len = value.cells.length; i < len; i++) {
                        const cell = value.cells[i];
                        const cellIdx = [Number(key), i];
                        if (cell) {
                            if (cell.value) {
                                if (autoDetectFormat && !cell.formula) {
                                    autoDetectFormatFn(cell);
                                }
                            }
                            else if (cell.formula && cell.formula.indexOf('=UNIQUE(') < 0) {
                                if (this.parent.calculationMode === 'Automatic') {
                                    this.parent.notify(workbookFormulaOperation, {
                                        action: 'refreshCalculate', value: cell.formula, rowIndex: cellIdx[0],
                                        colIndex: i, isFormula: checkIsFormula(cell.formula), sheetIndex: sheetIdx, isRefreshing: true
                                    });
                                }
                                cell.value = getCell(cellIdx[0], i, model).value;
                            }
                            if (cell.chart) {
                                chartColl.push({ index: cellIdx, chart: cell.chart });
                                chartModel = [];
                                for (let i = 0, len = cell.chart.length; i < len; i++) {
                                    const chart = Object.assign({}, cell.chart[i]);
                                    delete chart.id;
                                    chartModel.push(chart);
                                }
                                cell.chart = chartModel;
                            }
                        }
                    }
                }
                if (key === 'validation' && value && typeof value.type === 'string' && value.type === 'Time') {
                    ['value1', 'value2'].forEach((valKey) => {
                        const val = value[valKey] && value[valKey].toString();
                        if (val && !isNumber(Number(val))) {
                            value[valKey] = this.getDateAsNumber({ range: [], cell: { value: val } }, val);
                        }
                    });
                }
                if (value && value.properties && value.maxHgts) {
                    value.properties = Object.assign({}, value.properties, { maxHgts: value.maxHgts });
                }
                // eslint-disable-next-line no-prototype-builtins
                if (value && typeof value === 'object' && value.hasOwnProperty('properties')) {
                    if (value.propName && value.propName.toString() === 'conditionalFormats') {
                        const properties = value.properties;
                        if (properties.format && properties.format.style) {
                            const style = properties.format.style;
                            if (style && style.backgroundColor === '#ffffff' && style.color === '#000000' &&
                                style.fontWeight !== 'bold' && style.fontStyle !== 'italic' && style.textDecoration !== 'underline') {
                                delete properties.format; // Remove format if it matches default cell style
                            }
                        }
                    }
                    return value.properties;
                }
                else if (value !== null) {
                    return value;
                }
                else {
                    return undefined;
                }
            }
        });
        const sheet = getSheet(this.parent, sheetIdx);
        chartColl.forEach((obj) => {
            setCell(obj.index[0], obj.index[1], sheet, { chart: obj.chart }, true);
        });
        return json;
    }
    getDateAsNumber(args, cellValue) {
        const dateEventArgs = { value: cellValue, rowIndex: args.range[0], cell: args.cell,
            colIndex: args.range[1], sheetIndex: args.sheetIdx, updatedVal: '' };
        this.parent.notify(checkDateFormat, dateEventArgs);
        return dateEventArgs.updatedVal || cellValue;
    }
    getFileNameWithExtension(filename) {
        if (!filename) {
            filename = this.saveSettings.fileName;
        }
        const fileExt = this.getFileExtension();
        const idx = filename.lastIndexOf('.');
        if (idx > -1) {
            filename = filename.substr(0, idx);
        }
        return (filename + fileExt);
    }
    getFileExtension() {
        return ('.' + this.saveSettings.saveType.toLowerCase());
    }
}

/**
 * @hidden
 */
var CommonErrors;
(function (CommonErrors) {
    CommonErrors[CommonErrors["NA"] = 0] = "NA";
    CommonErrors[CommonErrors["Value"] = 1] = "Value";
    CommonErrors[CommonErrors["Ref"] = 2] = "Ref";
    CommonErrors[CommonErrors["DivZero"] = 3] = "DivZero";
    CommonErrors[CommonErrors["Num"] = 4] = "Num";
    CommonErrors[CommonErrors["Name"] = 5] = "Name";
    CommonErrors[CommonErrors["Null"] = 6] = "Null";
    CommonErrors[CommonErrors["Calc"] = 7] = "Calc";
})(CommonErrors || (CommonErrors = {}));
/**
 * @hidden
 */
var FormulasErrorsStrings;
(function (FormulasErrorsStrings) {
    FormulasErrorsStrings[FormulasErrorsStrings["OperatorsCannotStartWithExpression"] = 0] = "OperatorsCannotStartWithExpression";
    FormulasErrorsStrings[FormulasErrorsStrings["ReservedWordAND"] = 1] = "ReservedWordAND";
    FormulasErrorsStrings[FormulasErrorsStrings["ReservedWordXOR"] = 2] = "ReservedWordXOR";
    FormulasErrorsStrings[FormulasErrorsStrings["ReservedWordIf"] = 3] = "ReservedWordIf";
    FormulasErrorsStrings[FormulasErrorsStrings["NumberContains2DecimalPoints"] = 4] = "NumberContains2DecimalPoints";
    FormulasErrorsStrings[FormulasErrorsStrings["ReservedWordElse"] = 5] = "ReservedWordElse";
    FormulasErrorsStrings[FormulasErrorsStrings["ReservedWordNOT"] = 6] = "ReservedWordNOT";
    FormulasErrorsStrings[FormulasErrorsStrings["InvalidCharInNumber"] = 7] = "InvalidCharInNumber";
    FormulasErrorsStrings[FormulasErrorsStrings["InvalidCharactersFollowingWithOperator"] = 6] = "InvalidCharactersFollowingWithOperator";
    FormulasErrorsStrings[FormulasErrorsStrings["MismatchedParentheses"] = 8] = "MismatchedParentheses";
    FormulasErrorsStrings[FormulasErrorsStrings["UnknownFormulaName"] = 9] = "UnknownFormulaName";
    FormulasErrorsStrings[FormulasErrorsStrings["RequiresASingleArgument"] = 10] = "RequiresASingleArgument";
    FormulasErrorsStrings[FormulasErrorsStrings["Requires3Args"] = 11] = "Requires3Args";
    FormulasErrorsStrings[FormulasErrorsStrings["InvalidMathArgument"] = 12] = "InvalidMathArgument";
    FormulasErrorsStrings[FormulasErrorsStrings["Requires2Args"] = 13] = "Requires2Args";
    FormulasErrorsStrings[FormulasErrorsStrings["BadIndex"] = 14] = "BadIndex";
    FormulasErrorsStrings[FormulasErrorsStrings["TooComplex"] = 15] = "TooComplex";
    FormulasErrorsStrings[FormulasErrorsStrings["CircularReference"] = 16] = "CircularReference";
    FormulasErrorsStrings[FormulasErrorsStrings["MissingFormula"] = 17] = "MissingFormula";
    FormulasErrorsStrings[FormulasErrorsStrings["ImproperFormula"] = 18] = "ImproperFormula";
    FormulasErrorsStrings[FormulasErrorsStrings["InvalidExpression"] = 19] = "InvalidExpression";
    FormulasErrorsStrings[FormulasErrorsStrings["CellEmpty"] = 20] = "CellEmpty";
    FormulasErrorsStrings[FormulasErrorsStrings["BadFormula"] = 21] = "BadFormula";
    FormulasErrorsStrings[FormulasErrorsStrings["EmptyExpression"] = 22] = "EmptyExpression";
    FormulasErrorsStrings[FormulasErrorsStrings["VirtualModeRequired"] = 23] = "VirtualModeRequired";
    FormulasErrorsStrings[FormulasErrorsStrings["MismatchedTics"] = 24] = "MismatchedTics";
    FormulasErrorsStrings[FormulasErrorsStrings["WrongNumberArguments"] = 25] = "WrongNumberArguments";
    FormulasErrorsStrings[FormulasErrorsStrings["InvalidArguments"] = 26] = "InvalidArguments";
    FormulasErrorsStrings[FormulasErrorsStrings["IterationsDoNotConverge"] = 27] = "IterationsDoNotConverge";
    FormulasErrorsStrings[FormulasErrorsStrings["CalculationOverflow"] = 29] = "CalculationOverflow";
    FormulasErrorsStrings[FormulasErrorsStrings["AlreadyRegistered"] = 28] = "AlreadyRegistered";
    FormulasErrorsStrings[FormulasErrorsStrings["MissingSheet"] = 30] = "MissingSheet";
    FormulasErrorsStrings[FormulasErrorsStrings["CannotParse"] = 31] = "CannotParse";
    FormulasErrorsStrings[FormulasErrorsStrings["ExpressionCannotEndWithAnOperator"] = 32] = "ExpressionCannotEndWithAnOperator";
    FormulasErrorsStrings[FormulasErrorsStrings["Spill"] = 33] = "Spill";
    FormulasErrorsStrings[FormulasErrorsStrings["Div"] = 34] = "Div";
})(FormulasErrorsStrings || (FormulasErrorsStrings = {}));
/**
 * @hidden
 */
var ExcelFileFormats;
(function (ExcelFileFormats) {
    ExcelFileFormats["xlsx"] = "xlsx";
    ExcelFileFormats["xlsm"] = "xlsm";
    ExcelFileFormats["xlsb"] = "xlsb";
    ExcelFileFormats["xltx"] = "xltx";
    ExcelFileFormats["xltm"] = "xltm";
    ExcelFileFormats["xls"] = "xls";
    ExcelFileFormats["xml"] = "xml";
    ExcelFileFormats["xlam"] = "xlam";
    ExcelFileFormats["xla"] = "xla";
    ExcelFileFormats["xlw"] = "xlw";
    ExcelFileFormats["xlr"] = "xlr";
    ExcelFileFormats["prn"] = "prn";
    ExcelFileFormats["txt"] = "txt";
    ExcelFileFormats["csv"] = "csv";
    ExcelFileFormats["dif"] = "dif";
    ExcelFileFormats["slk"] = "slk";
})(ExcelFileFormats || (ExcelFileFormats = {}));

/**
 * Represent the common codes for calculate
 */
class CalculateCommon {
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * For internal use only - Get the module name.
     *
     * @private
     * @returns {string} - Get the module name.
     */
    getModuleName() {
        return 'calc-common';
    }
}
/**
 * To check whether the object is undefined.
 *
 * @param {Object} value - To check the object is undefined
 * @returns {boolean} - Returns boolean value.
 * @private
 */
function isUndefined(value) {
    return ('undefined' === typeof value);
}
/**
 * @hidden
 * @param {string} value - specify the value
 * @returns {string} - get Skeleton Value.
 */
function getSkeletonVal(value) {
    switch (value) {
        case 'dd-MMM-yyyy':
        case 'dd MMM yyyy':
            value = 'medium';
            break;
        case 'MMM yyyy':
            value = 'yMMM';
            break;
        case 'MM/dd/yyyy':
        case 'dd/MM/yyyy':
        case 'dd/MM/yy':
            value = 'short';
            break;
        case 'dddd MMMM dd yyyy': //long
        case 'dd MMMM yyyy':
            value = 'long';
            break;
        case 'd MMMM yyyy':
            value = 'yMMMd';
            break;
        case 'yyyy':
            value = 'y';
            break;
        case 'h:mm':
            value = 'Hm';
            break;
        case 'h:mm tt':
            value = 'hm';
            break;
        case 'h':
            value = 'H';
            break;
        case 'h tt':
            value = 'h';
            break;
        case 'dddd':
            value = 'E';
            break;
        case 'h:mm:ss tt':
            value = 'hms';
            break;
        case 'h:mm:ss':
            value = 'Hms';
            break;
        case 'd':
            value = 'd';
            break;
        case 'd dddd':
            value = 'Ed';
            break;
        case 'M':
            value = 'M';
            break;
        case 'Md':
            value = 'Md';
            break;
        case 'MMM':
            value = 'MMM';
            break;
        case 'ddd MMM d':
            value = 'MMMEd';
            break;
        case 'MMM d':
            value = 'MMMd';
            break;
        case 'M/yyyy':
            value = 'yM';
            break;
        case 'ddd':
            value = 'E';
            break;
        default:
            value = '';
            break;
    }
    return value;
}
/**
 * To check whether the formula contains external file link.
 *
 * @param {string} formula - To check the string contains external file link.
 * @returns {boolean} - Returns boolean value.
 * @private
 */
function isExternalFileLink(formula) {
    let isExternalFile = false;
    for (const format in ExcelFileFormats) {
        if (formula.indexOf('.' + format + ']') > -1) {
            isExternalFile = true;
            break;
        }
    }
    return isExternalFile;
}

/**
 * Represents the basic formulas module.
 */
class BasicFormulas {
    constructor(parent) {
        this.formulas = [
            { formulaName: 'SUM', category: 'Math & Trig', description: 'Sums individual values, cell references or ranges.' },
            {
                formulaName: 'SUMIFS', category: 'Math & Trig',
                description: 'Sums the cells specified by a given set of conditionsor criteria.'
            },
            {
                formulaName: 'SUMPRODUCT', category: 'Math & Trig',
                description: 'Returns sum of the product of given ranges of arrays.'
            },
            { formulaName: 'ABS', category: 'Math & Trig', description: 'Returns the absolute value of a number.' },
            { formulaName: 'RAND', category: 'Math & Trig', description: 'Return a random number between 0 and 1.' },
            { formulaName: 'FLOOR', category: 'Math & Trig', description: 'Returns the round a number down to the nearest integer.' },
            { formulaName: 'CEILING', category: 'Math & Trig', description: 'Returns a number rounded up to a multiple of another number.' },
            {
                formulaName: 'SUMIF', category: 'Math & Trig',
                description: 'It will sum up cells that meet the given criteria.'
            },
            {
                formulaName: 'PRODUCT', category: 'Math & Trig',
                description: 'Multiplies all the numbers given as arguments and returns the product.'
            },
            {
                formulaName: 'AVERAGE', category: 'Statistical',
                description: 'The sum of the numbers divided by how many numbers are being averaged.'
            },
            {
                formulaName: 'AVERAGEIF', category: 'Statistical',
                description: 'Computes the average of the numbers in a range that meet the supplied criteria.'
            },
            {
                formulaName: 'COUNT', category: 'Statistical',
                description: 'Counts the numbers in the list of arguments, exclude text entries.'
            },
            { formulaName: 'COUNTA', category: 'Statistical', description: 'Counts the non-empty values in the list of arguments.' },
            {
                formulaName: 'COUNTIF', category: 'Statistical',
                description: 'Counts the number of cells in a range that meet a specified condition.'
            },
            {
                formulaName: 'COUNTIFS', category: 'Statistical',
                description: 'Counts the number of times each cells in all the ranges that meet the specific conditions.'
            },
            {
                formulaName: 'AVERAGEA', category: 'Statistical',
                description: 'Calculates the average of values in the list of arguments.Arguments can be numbers, names, arrays or references.'
            },
            {
                formulaName: 'AVERAGEIFS', category: 'Statistical',
                description: 'Conditionally returns the average of the contents of cells for the set of ranges.'
            },
            {
                formulaName: 'MIN', category: 'Statistical',
                description: 'Returns the smaller number in set of arguments.'
            },
            { formulaName: 'MAX', category: 'Statistical', description: 'Returns the largest number in set of arguments.' },
            { formulaName: 'DATE', category: 'Date', description: 'Returns the date, given the year, month and day of the month.' },
            { formulaName: 'DAY', category: 'Date', description: 'Returns the day of a given date.' },
            { formulaName: 'TODAY', category: 'Date', description: 'Returns the current date as date value.' },
            { formulaName: 'DAYS', category: 'Date', description: 'Returns the number of days between two dates.' },
            { formulaName: 'WEEKDAY', category: 'Date', description: 'Returns the day of the week corresponding to a date.' },
            {
                formulaName: 'IF', category: 'Logical',
                description: 'Returns one value if a logical expression is TRUE and another if it is FALSE'
            },
            {
                formulaName: 'AND', category: 'Logical',
                description: 'Returns TRUE if all the arguments are considered TRUE, and FALSE otherwise.'
            },
            {
                formulaName: 'IFS', category: 'Logical',
                description: 'Checks multiple conditions and returns a value corresponding to the first TRUE result.'
            },
            {
                formulaName: 'IFERROR', category: 'Logical',
                description: 'Returns a value you specify if a formula evaluates to an error; otherwise, it returns the result of the formula.'
            },
            {
                formulaName: 'CHOOSE', category: 'Lookup & Reference',
                description: 'Returns a value from a list, given an index number.'
            },
            {
                formulaName: 'INDEX', category: 'Lookup & Reference',
                description: 'Returns a value from a table, given a row and column number.'
            },
            { formulaName: 'FIND', category: 'Text', description: 'Returns the position of a string of text within another string.' },
            { formulaName: 'CONCATENATE', category: 'Text', description: ' Used to join two or more strings together.' },
            { formulaName: 'CONCAT', category: 'Text', description: 'Concatenates a list or range of text strings.' },
            { formulaName: 'SUBTOTAL', category: 'Lookup & Reference', description: 'Returns a subtotal in a list or database.' },
            { formulaName: 'RADIANS', category: 'Math & Trig', description: 'Converts degrees to radians.' },
            {
                formulaName: 'OR', category: 'Logical',
                description: 'Returns TRUE if any arguments considered TRUE, and all the arguments are FALSE it will return FALSE.'
            },
            { formulaName: 'NOT', category: 'Logical', description: 'Returns the inverse of a given logical expression.' },
            {
                formulaName: 'MATCH', category: 'Lookup & Reference',
                description: 'Returns the relative position of an checked item in range that matches a specified value in a specified order'
            },
            {
                formulaName: 'RANDBETWEEN', category: 'Math & Trig', description: 'Returns an integer random number in a specified range.'
            },
            {
                formulaName: 'SLOPE', category: 'Statistical',
                description: 'Returns the slope of the line from linear regression of the data points.'
            },
            {
                formulaName: 'INTERCEPT', category: 'Statistical',
                description: 'Calculates the point of the Y-intercept line via linear regression.'
            },
            {
                formulaName: 'RSQ', category: 'Statistical',
                description: 'Returns the square of the Pearson product moment correlation coefficient based on data points in known_ys and known_xs'
            },
            {
                formulaName: 'UNIQUE', category: 'Lookup & Reference',
                description: 'Returns a unique values from a range or array.'
            },
            {
                formulaName: 'ROUNDUP', category: 'Math & Trig', description: 'Rounds a number away from zero.'
            },
            {
                formulaName: 'ROUNDDOWN', category: 'Math & Trig', description: 'Rounds a number down, toward zero.'
            },
            {
                formulaName: 'INT', category: 'Math & Trig', description: 'Returns a number to the nearest integer.'
            },
            {
                formulaName: 'LN', category: 'Math & Trig', description: 'Returns the natural logarithm of a number.'
            },
            {
                formulaName: 'ISNUMBER', category: 'Information', description: 'Returns TRUE, if the argument is number and FALSE otherwise.'
            },
            {
                formulaName: 'ROUND', category: 'Math & Trig', description: 'Rounds a number to a specified number of digits.'
            },
            {
                formulaName: 'LOG', category: 'Math & Trig', description: 'Returns the logarithm of a number to the base that you specify.'
            },
            {
                formulaName: 'POWER', category: 'Math & Trig', description: 'Returns the result of a number raised to power.'
            },
            {
                formulaName: 'SQRT', category: 'Math & Trig', description: 'Returns the square root of a positive number.'
            },
            {
                formulaName: 'TRUNC', category: 'Math & Trig',
                description: 'Returns the truncated value of a number to a specified number of decimal places.'
            },
            {
                formulaName: 'EXP', category: 'Math & Trig', description: 'Returns e raised to the power of the given number.'
            },
            {
                formulaName: 'GEOMEAN', category: 'Statistical',
                description: 'Returns the geometric mean of an array or range of positive data.'
            },
            { formulaName: 'TEXT', category: 'Lookup & Reference', description: 'Converts a value to text in specified number format.' },
            { formulaName: 'SORT', category: 'Lookup & Reference', description: 'Sorts a range of an array.' },
            { formulaName: 'LOOKUP', category: 'Lookup & Reference', description: 'Looks for a value in a one-row or one-column range, then returns a value from the same position in a second one-row or one-column range.' },
            { formulaName: 'VLOOKUP', category: 'Lookup & Reference', description: 'Looks for a specific value in the first column of a lookup range and returns a corresponding value from a different column within the same row.' },
            { formulaName: 'HLOOKUP', category: 'Lookup & Reference', description: 'Looks for a value in the top row of the array of values and then returns a value in the same column from a row in the array that you specify.' },
            { formulaName: 'T', category: 'Text', description: 'Checks whether a value is text or not and returns the text.' },
            { formulaName: 'EXACT', category: 'Text', description: 'Checks whether a two text strings are exactly same and returns TRUE or FALSE.' },
            { formulaName: 'LEN', category: 'Text', description: 'Returns a number of characters in a given string.' },
            { formulaName: 'MOD', category: 'Math & Trig', description: 'Returns a remainder after a number is divided by divisor.' },
            { formulaName: 'ODD', category: 'Math & Trig', description: 'Rounds a positive number up and negative number down to the nearest odd integer.' },
            { formulaName: 'PI', category: 'Math & Trig', description: 'Returns the value of pi.' },
            { formulaName: 'COUNTBLANK', category: 'Statistical', description: 'Returns the number of empty cells in a specified range of cells.' },
            { formulaName: 'EVEN', category: 'Math & Trig', description: 'Rounds a positive number up and negative number down to the nearest even integer.' },
            { formulaName: 'FACT', category: 'Math & Trig', description: 'Returns the factorial of a number.' },
            { formulaName: 'DECIMAL', category: 'Math & Trig', description: 'Converts a text representation of a number in a given base into a decimal number.' },
            { formulaName: 'DEGREES', category: 'Math & Trig', description: 'Converts radians to degrees.' },
            { formulaName: 'ADDRESS', category: 'Lookup & Reference', description: 'Returns a cell reference as text, given specified row and column numbers.' },
            { formulaName: 'TIME', category: 'Date & Time', description: 'Converts hours, minutes, seconds to the time formatted text.' },
            { formulaName: 'CHAR', category: 'Text', description: 'Returns the character from the specified number.' },
            { formulaName: 'CODE', category: 'Text', description: 'Returns the numeric code for the first character in a given string.' },
            { formulaName: 'DOLLAR', category: 'Text', description: 'Converts the number to currency formatted text.' },
            { formulaName: 'SMALL', category: 'Statistical', description: 'Returns the k-th smallest value in a given array.' },
            { formulaName: 'LARGE', category: 'Statistical', description: 'Returns the k-th largest value in a given array.' },
            { formulaName: 'MEDIAN', category: 'Statistical', description: 'Returns the median of the given set of numbers.' },
            { formulaName: 'EDATE', category: 'Date & Time', description: 'Returns a date with given number of months before or after the specified date.' },
            { formulaName: 'EOMONTH', category: 'Date & Time', description: 'Returns the last day of the month that is a specified number of months before or after an initially supplied start date.' },
            { formulaName: 'DATEVALUE', category: 'Date & Time', description: 'Converts a date string into date value.' },
            { formulaName: 'HOUR', category: 'Date & Time', description: 'Returns the number of hours in a specified time string.' },
            { formulaName: 'MINUTE', category: 'Date & Time', description: 'Returns the number of minutes in a specified time string.' },
            { formulaName: 'SECOND', category: 'Date & Time', description: 'Returns the number of seconds in a specified time string.' },
            { formulaName: 'NOW', category: 'Date & Time', description: 'Returns the current date and time.' },
            { formulaName: 'MONTH', category: 'Date & Time', description: 'Returns the number of months in a specified date string.' },
            { formulaName: 'PROPER', category: 'Text', description: 'Converts a text to proper case; first letter to uppercase and other letters to lowercase.' }
        ];
        this.isConcat = false;
        this.parent = parent;
        this.init();
    }
    init() {
        let fn;
        for (let i = 0; i < this.formulas.length; i++) {
            fn = getValue('Compute' + this.formulas[i].formulaName, this).bind(this);
            this.addFormulaCollection(this.formulas[i].formulaName.toUpperCase(), fn, this.formulas[i].category, this.formulas[i].description);
        }
    }
    addFormulaCollection(formulaName, functionName, formulaCategory, description) {
        this.parent.libraryFormulas = {
            fName: formulaName, handler: functionName, category: formulaCategory,
            description: description
        };
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args
     * @returns {string | number} - Comput sum value
     */
    ComputeSUM(...args) {
        let isSubtotalFormula = false;
        let isAggregateComputation;
        let sheet;
        if (args.length) {
            const lastArgument = args[args.length - 1];
            if (lastArgument === 'isSubtotal') {
                isSubtotalFormula = true;
                args.pop();
            }
            else if (lastArgument === 'isAggregate') {
                sheet = this.parent.parentObject.getActiveSheet();
                isAggregateComputation = true;
                args.pop();
            }
        }
        if (isNullOrUndefined(args) || (args.length === 1 && args[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        let sum = 0;
        let val;
        let orgValue;
        let maxDecimalLength = 0;
        let indexes;
        if (!isNullOrUndefined(args)) {
            const argArr = args;
            const setMaxDecimalLength = (val) => {
                if (val.toString().indexOf('.') > -1) {
                    maxDecimalLength = Math.max(maxDecimalLength, val.split('.')[1].length);
                }
            };
            for (let i = 0; i < argArr.length; i++) {
                const argValue = argArr[i].toString();
                if (argValue.indexOf(':') > -1 && this.parent.isCellReference(argValue)) {
                    const cellCollection = this.parent.getCellCollection(argValue.split(this.parent.tic).join(''));
                    for (let j = 0; j < cellCollection.length; j++) {
                        if (isAggregateComputation) {
                            indexes = getCellIndexes(cellCollection[j]);
                            if (isHiddenRow(sheet, indexes[0]) || isHiddenCol(sheet, indexes[1])) {
                                continue;
                            }
                        }
                        val = !isSubtotalFormula ? this.parent.getValueFromArg(cellCollection[j]) :
                            this.parent.getValueFromArg(cellCollection[j], null, null, true);
                        if (isSubtotalFormula && val.includes('SUBTOTAL(')) {
                            continue;
                        }
                        if (this.parent.getErrorStrings().indexOf(val) > -1) {
                            return val;
                        }
                        if (isNullOrUndefined(val[0]) || isNaN(this.parent.parseFloat(val))) {
                            continue;
                        }
                        setMaxDecimalLength(val);
                        sum = sum + this.parent.parseFloat(val);
                    }
                }
                else {
                    if (argArr[i].indexOf(this.parent.tic) > -1) {
                        if (isNaN(this.parent.parseFloat(argArr[i].split(this.parent.tic).join(''))) ||
                            argArr[i].split(this.parent.tic).join('').trim() === '') {
                            return this.parent.getErrorStrings()[CommonErrors.Value];
                        }
                    }
                    if (argArr[i].split(this.parent.tic).join('') === this.parent.trueValue) {
                        argArr[i] = '1';
                    }
                    if (argArr[i].split(this.parent.tic).join('') === this.parent.falseValue) {
                        argArr[i] = '0';
                    }
                    orgValue = !isSubtotalFormula ? this.parent.getValueFromArg(argArr[i].split(this.parent.tic).join('')) :
                        this.parent.getValueFromArg(argArr[i].split(this.parent.tic).join(''), null, null, true);
                    if (isSubtotalFormula && orgValue.includes('SUBTOTAL(')) {
                        continue;
                    }
                    if (this.parent.getErrorStrings().indexOf(orgValue) > -1) {
                        return orgValue;
                    }
                    if (isNullOrUndefined(orgValue) || isNaN(this.parent.parseFloat(orgValue))) {
                        continue;
                    }
                    if (orgValue.length > 0) {
                        setMaxDecimalLength(orgValue);
                        sum = sum + this.parent.parseFloat(orgValue + '');
                    }
                }
            }
        }
        return sum.toString().indexOf('.') > -1 ? sum.toFixed(maxDecimalLength) : sum;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {string | number} - Compute the Integer.
     */
    ComputeINT(...args) {
        let argsValue;
        const errCollection = this.parent.getErrorStrings();
        if (args[0] === '' && args.length === 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args.length > 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        argsValue = this.parent.getValueFromArg(args[0]);
        if (errCollection.indexOf(argsValue) > -1) {
            return argsValue;
        }
        if (argsValue.toUpperCase() === this.parent.trueValue) {
            argsValue = '1';
        }
        else if (argsValue.toUpperCase() === this.parent.falseValue) {
            argsValue = '0';
        }
        if (!this.parent.isCellReference(args[0])) {
            if (args[0].indexOf(this.parent.tic + this.parent.tic) === -1) {
                argsValue = argsValue.split(this.parent.tic).join('');
            }
            if (argsValue.trim() === '') {
                return errCollection[CommonErrors.Value];
            }
        }
        if (argsValue.indexOf('%') > -1) {
            argsValue = (Number(argsValue.split('%')[0]) * 0.01).toString();
        }
        if (isNaN(this.parent.parseFloat(argsValue))) {
            return errCollection[CommonErrors.Value];
        }
        argsValue = this.parent.parseFloat(argsValue);
        argsValue = Math.floor(argsValue);
        return argsValue;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {Date | string} - Compute the Today.
     */
    ComputeTODAY(...args) {
        let str;
        if (args.length !== 1 || args[0] !== '') {
            str = this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else {
            const dt = new Date(Date.now());
            if (this.parent.parentObject.getModuleName() === 'spreadsheet') {
                str = this.parent.parentObject.dateToInt(dt);
                if (this.parent.parser.storedStringText.toUpperCase().indexOf('TODAY') === 0 &&
                    this.parent.cell !== '') {
                    this.parent.parentObject.setDateFormat(this.parent.getSheetId(this.parent.grid), this.parent.rowIndex(this.parent.cell) - 1, this.parent.colIndex(this.parent.cell) - 1);
                }
            }
            else {
                str = dt.getFullYear() + '/' + this.parent.calculateDate((dt.getMonth() + 1).toString()) + '/'
                    + this.parent.calculateDate(dt.getDate().toString());
            }
        }
        return str;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {number} - Compute the day from the date.
     */
    ComputeWEEKDAY(...args) {
        if ((args[0] === '' && isNullOrUndefined(args[1])) || args.length > 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        if ((args[0] === '' && args[1] === '') || args[1] === '') {
            return this.parent.getErrorStrings()[CommonErrors.Num].toString();
        }
        if (args.length === 1) {
            args.push('1');
        }
        if ((args[0].indexOf(this.parent.tic) > -1 && args[0].split(this.parent.tic).join('').trim() === '') || (args[1].split(this.parent.tic).join('').trim() === '') || (args[1].indexOf(this.parent.tic) > -1 && isNaN(this.parent.parseFloat(args[1].split(this.parent.tic).join(''))))) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        let date;
        let value;
        let day;
        if (this.parent.isCellReference(args[0])) {
            date = this.parent.getValueFromArg(args[0].split(this.parent.tic).join('')) || '0';
            if (date.indexOf(this.parent.tic) > -1) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        else {
            if ((args[0].indexOf(this.parent.tic) > -1 && isNaN(this.parent.parseFloat(args[0].split(this.parent.tic).join(''))))) {
                date = this.parent.getValueFromArg(args[0]);
            }
            else {
                date = this.parent.getValueFromArg(args[0].split(this.parent.tic).join('')) || '0';
            }
        }
        if (this.parent.isCellReference(args[1])) {
            value = this.parent.getValueFromArg(args[1].split(this.parent.tic).join('')) || '0';
        }
        else {
            value = this.parent.getValueFromArg(args[1].split(this.parent.tic).join(''));
        }
        if (this.parent.getErrorStrings().indexOf(date) > -1) {
            return date;
        }
        if (this.parent.getErrorStrings().indexOf(value) > -1) {
            return value;
        }
        date = date === this.parent.trueValue ? '1' : (date === this.parent.falseValue ? '0' : date);
        value = value === this.parent.trueValue ? '1' : (value === this.parent.falseValue ? '0' : value);
        day = this.parent.parseFloat(date);
        value = this.parent.parseFloat(value);
        if (isNaN(value) || isNaN(day)) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        if (day < 0 || day > 2958465) {
            return this.parent.getErrorStrings()[CommonErrors.Num].toString();
        }
        value = parseInt(value.toString(), 10);
        day = day < 1 ? 0 : Math.floor(day) % 7;
        switch (value) {
            case 1:
            case 17:
                day = day <= 0 ? day + 7 : day;
                break;
            case 2:
            case 11:
                day = day - 1;
                day = day <= 0 ? day + 7 : day;
                break;
            case 3:
                day = day - 2;
                day = day < 0 ? day + 7 : day;
                break;
            case 12:
                day = day + 5;
                day = day > 7 ? day - 7 : day;
                break;
            case 13:
                day = day + 4;
                day = day > 7 ? day - 7 : day;
                break;
            case 14:
                day = day + 3;
                day = day > 7 ? day - 7 : day;
                break;
            case 15:
                day = day + 2;
                day = day > 7 ? day - 7 : day;
                break;
            case 16:
                day = day + 1;
                day = day > 7 ? day - 7 : day;
                break;
            default:
                day = this.parent.getErrorStrings()[CommonErrors.Num].toString();
                break;
        }
        return day;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {string} - Compute to the Proper casing.
     */
    ComputePROPER(...args) {
        let str;
        let nestedFormula;
        const errCollection = this.parent.getErrorStrings();
        if (args.length && args[args.length - 1] === 'nestedFormulaTrue') {
            nestedFormula = true;
            args.pop();
        }
        if (isNullOrUndefined(args) || (args[0].trim() === '' && args.length === 1)) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args.length > 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        str = this.parent.getValueFromArg(args[0]).trim();
        if (errCollection.indexOf(str) > -1) {
            return str;
        }
        if (args[0].indexOf(this.parent.tic) > -1) {
            if (args[0] !== str && args[0].startsWith('n')) {
                str = this.parent.removeTics(str.trim());
            }
            else {
                str = this.parent.removeTics(args[0].trim());
                if (str.indexOf(this.parent.tic + this.parent.tic) > -1) {
                    str = str.replace(/""/g, this.parent.tic);
                }
            }
        }
        else if (!args[0].startsWith('n') && str.split('%').length === 2 && this.parent.isNumber(str.split('%')[0])) {
            str = (Number(str.split('%')[0]) / 100).toString();
        }
        str = str.toLowerCase().replace(/\b\w/g, function (char) {
            return char.toUpperCase();
        }).replace(/(\d)([a-z])/g, function (match, number, char) {
            return number + char.toUpperCase();
        });
        if (nestedFormula) {
            str = this.parent.tic + str + this.parent.tic;
        }
        return str;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {string | number} - Compute the Sum product.
     */
    ComputeSUMPRODUCT(...args) {
        if (isNullOrUndefined(args) || (args.length === 1 && args[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        let sum = 0;
        let count = 0;
        let index;
        let mulValues = null;
        const ranges = args;
        const len = [];
        for (let i = 0; i < ranges.length; i++) {
            len.push(this.parent.getCellCollection(ranges[i]).length);
        }
        for (let j = 0; j < len.length; j++) {
            if (len[j] && len[j + 1] && len[j] !== len[j + 1]) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        for (let k = 0; k < ranges.length; ++k) {
            const range = ranges[k];
            if (!range.startsWith(this.parent.tic) && this.parent.isCellReference(range)) {
                let i = range.indexOf(':');
                let startRow = this.parent.rowIndex(range.substr(0, i));
                let endRow = this.parent.rowIndex(range.substr(i + 1));
                if (!(startRow !== -1 || endRow === -1) === (startRow === -1 || endRow !== -1)) {
                    return this.parent.getErrorStrings()[CommonErrors.Name];
                }
                if (startRow > endRow) {
                    [startRow, endRow] = [endRow, startRow];
                }
                let col1 = this.parent.colIndex(range.substr(0, i));
                let col2 = this.parent.colIndex(range.substr(i + 1));
                if (col1 > col2) {
                    [col1, col2] = [col2, col1];
                }
                if (mulValues === null) {
                    count = (endRow - startRow + 1) * (col2 - col1 + 1);
                    mulValues = [];
                    for (i = 0; i < count; ++i) {
                        mulValues[i] = 1; //To create required index.
                    }
                }
                i = 0;
                for (let row = startRow; row <= endRow; ++row) {
                    for (let col = col1; col <= col2; ++col) {
                        const cellRef = this.getSheetReference(range) + this.parent.convertAlpha(col) + (row);
                        const result = this.parent.getValueFromArg(cellRef);
                        if (this.parent.getErrorStrings().indexOf(result) > -1) {
                            return result;
                        }
                        if (!isNaN(this.parent.parseFloat(result))) {
                            //To return #VALUE! error when array dimensions are mismatched.
                            if (isNaN(mulValues[i])) {
                                return this.parent.getErrorStrings()[CommonErrors.Name];
                            }
                            mulValues[i] = mulValues[i] * this.parent.parseFloat(result);
                        }
                        else {
                            mulValues[i] = 0;
                        }
                        i++;
                    }
                }
            }
            else {
                const s1 = this.parent.getValueFromArg(range);
                index = s1.indexOf('"');
                if (this.parent.getErrorStrings().indexOf(s1) > -1) {
                    return s1;
                }
                else if (index > -1) {
                    return 0;
                }
                else {
                    return this.parent.getErrorStrings()[CommonErrors.Value];
                }
            }
        }
        for (let i = 0; i < count; ++i) {
            sum += mulValues[i];
        }
        return sum;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {string | number} - Compute the Roundup.
     */
    ComputeROUNDUP(...args) {
        let str;
        let arg1;
        let arg2;
        let index;
        let num;
        const len = args.length;
        if (!isNullOrUndefined(args) && len > 2) {
            str = this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        if (len === 1 && args[0] !== '') {
            index = args[0].indexOf('"');
            arg1 = args[0].indexOf('"') > -1 ? args[0].replace('"', '') : args[0];
            arg1 = arg1.indexOf('"') > -1 ? arg1.replace('"', '') : arg1;
            arg1 = arg1.toUpperCase() === 'TRUE' ? '1' : (arg1 === 'FALSE' ? '0' : arg1);
            arg1 = this.parent.getValueFromArg(arg1);
            num = this.parent.parseFloat(arg1);
            if (num > 0) {
                num += .4999999999; // To round the number, we using this value.
            }
            else if (num < 0) {
                num -= .4999999999;
            }
            num = this.parent.parseFloat(num.toFixed(0));
            str = num.toString();
        }
        else if (len === 2) {
            index = args[0].indexOf('"') > -1 ? args[0].indexOf('"') : (args[1].indexOf('"') > -1 ? args[1].indexOf('"') : -1);
            if (this.parent.isCellReference(args[0])) {
                arg1 = this.parent.getValueFromArg(args[0]) || '0';
            }
            else {
                if (args[0].indexOf(this.parent.tic) > -1 && (args[0].split(this.parent.tic).join('') === this.parent.trueValue ||
                    args[0].split(this.parent.tic).join('') === this.parent.falseValue)) {
                    return this.parent.getErrorStrings()[CommonErrors.Value];
                }
                arg1 = this.parent.getValueFromArg(args[0]).split(this.parent.tic).join('');
            }
            if (this.parent.getErrorStrings().indexOf(arg1) > -1) {
                return arg1;
            }
            if (this.parent.isCellReference(args[1])) {
                arg2 = this.parent.getValueFromArg(args[1]) || '0';
            }
            else {
                if (args[1].indexOf(this.parent.tic) > -1 && (args[1].split(this.parent.tic).join('') === this.parent.trueValue ||
                    args[1].split(this.parent.tic).join('') === this.parent.falseValue)) {
                    return this.parent.getErrorStrings()[CommonErrors.Value];
                }
                arg2 = this.parent.getValueFromArg(args[1]).split(this.parent.tic).join('');
            }
            if (this.parent.getErrorStrings().indexOf(arg2) > -1) {
                return arg2;
            }
            arg1 = arg1.toUpperCase() === 'TRUE' ? '1' : (arg1 === 'FALSE' ? '0' : arg1);
            arg2 = arg2.toUpperCase() === 'TRUE' ? '1' : (arg2 === 'FALSE' ? '0' : arg2);
            const isInvalidNumStr = isNaN(Number(arg1)) || arg1.trim() === '';
            const isInvalidDigStr = isNaN(Number(arg2)) || arg2.trim() === '';
            if (((args[0].indexOf('"') > -1 || this.parent.isCellReference(args[0])) && isInvalidNumStr)
                || ((args[1].indexOf('"') > -1 || this.parent.isCellReference(args[1])) && isInvalidDigStr)) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            const digits = Math.ceil(this.parent.parseFloat(arg2));
            num = this.parent.parseFloat(arg1);
            if (digits > 0) {
                const decimalArr = arg1.split('.');
                const decimalCount = decimalArr.length === 2 ? (decimalArr[1].length >= digits ? digits : decimalArr[1].length) : 0;
                num = this.parent.parseFloat(this.preciseRound(num, decimalCount, 'ROUNDUP'));
                str = num.toString();
                if (isNaN(num)) {
                    if (digits.toString().indexOf('"') > -1) {
                        str = this.parent.getErrorStrings()[CommonErrors.Value];
                    }
                    else {
                        str = this.parent.getErrorStrings()[CommonErrors.Name];
                    }
                }
            }
            else {
                if (num > 0) {
                    num = (num / Math.pow(10, -digits)) + .49999;
                }
                else if (num < 0) {
                    num = (num / Math.pow(10, -digits)) - .49999;
                }
                if (num > 0 && digits < -9) {
                    num = 1 * Math.pow(10, -digits);
                }
                else {
                    num = this.parent.parseFloat(num.toFixed(0)) * Math.pow(10, -digits);
                }
                str = num.toString();
                if (isNaN(num)) {
                    str = (digits.toString().indexOf('"') > -1) ? this.parent.getErrorStrings()[CommonErrors.Value] :
                        str = this.parent.getErrorStrings()[CommonErrors.Name];
                }
            }
        }
        else {
            str = index > -1 ? this.parent.getErrorStrings()[CommonErrors.Value] :
                this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        return str;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {string | number} - Compute the Rounddown.
     */
    ComputeROUNDDOWN(...args) {
        let result;
        let arg1;
        let arg2;
        let index;
        let num;
        const len = args.length;
        if (!isNullOrUndefined(args) && len > 2) {
            result = this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        if (len === 1 && args[0] !== '') {
            index = args[0].indexOf('"');
            arg1 = args[0].indexOf('"') > -1 ? args[0].replace('"', '') : args[0];
            arg1 = arg1.indexOf('"') > -1 ? arg1.replace('"', '') : arg1;
            arg1 = arg1.toUpperCase() === 'TRUE' ? '1' : (arg1 === 'FALSE' ? '0' : arg1);
            arg1 = this.parent.getValueFromArg(arg1);
            num = this.parent.parseFloat(arg1);
            if (num > 0) {
                num -= .4999999999; // To round the number, we are using this value.
            }
            else if (num < 0) {
                num += .4999999999;
            }
            num = this.parent.parseFloat(num.toFixed(0));
            result = num.toString();
        }
        else if (len === 2) {
            index = args[0].indexOf('"') > -1 ? args[0].indexOf('"') : (args[1].indexOf('"') > -1 ? args[1].indexOf('"') : -1);
            if (this.parent.isCellReference(args[0])) {
                arg1 = this.parent.getValueFromArg(args[0]) || '0';
            }
            else {
                if (args[0].indexOf(this.parent.tic) > -1 && (args[0].split(this.parent.tic).join('') === this.parent.trueValue ||
                    args[0].split(this.parent.tic).join('') === this.parent.falseValue)) {
                    return this.parent.getErrorStrings()[CommonErrors.Value];
                }
                arg1 = this.parent.getValueFromArg(args[0]).split(this.parent.tic).join('');
            }
            if (this.parent.getErrorStrings().indexOf(arg1) > -1) {
                return arg1;
            }
            if (this.parent.isCellReference(args[1])) {
                arg2 = this.parent.getValueFromArg(args[1]) || '0';
            }
            else {
                if (args[1].indexOf(this.parent.tic) > -1 && (args[1].split(this.parent.tic).join('') === this.parent.trueValue ||
                    args[1].split(this.parent.tic).join('') === this.parent.falseValue)) {
                    return this.parent.getErrorStrings()[CommonErrors.Value];
                }
                arg2 = this.parent.getValueFromArg(args[1]).split(this.parent.tic).join('');
            }
            if (this.parent.getErrorStrings().indexOf(arg2) > -1) {
                return arg2;
            }
            arg1 = arg1.toUpperCase() === 'TRUE' ? '1' : (arg1 === 'FALSE' ? '0' : arg1);
            arg2 = arg2.toUpperCase() === 'TRUE' ? '1' : (arg2 === 'FALSE' ? '0' : arg2);
            const isInvalidNumStr = isNaN(Number(arg1)) || arg1.trim() === '';
            const isInvalidDigStr = isNaN(Number(arg2)) || arg2.trim() === '';
            if (((args[0].indexOf('"') > -1 || this.parent.isCellReference(args[0])) && isInvalidNumStr)
                || ((args[1].indexOf('"') > -1 || this.parent.isCellReference(args[1])) && isInvalidDigStr)) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            const digits = Math.ceil(this.parent.parseFloat(arg2));
            num = this.parent.parseFloat(arg1);
            if (digits > 0) {
                const decimalIndex = arg1.indexOf('.');
                let decimalCount = 0;
                if (decimalIndex !== -1) {
                    decimalCount = arg1.length - decimalIndex - 1;
                    decimalCount = decimalCount >= digits ? digits : decimalCount;
                }
                num = this.parent.parseFloat(this.preciseRound(num, decimalCount, 'ROUNDDOWN'));
                result = num.toString();
                if (isNaN(num)) {
                    if (digits.toString().indexOf('"') > -1) {
                        result = this.parent.getErrorStrings()[CommonErrors.Value];
                    }
                    else {
                        result = this.parent.getErrorStrings()[CommonErrors.Name];
                    }
                }
            }
            else {
                if (num > 0) {
                    num = (num / Math.pow(10, -digits)) - .49999;
                }
                else if (num < 0) {
                    num = (num / Math.pow(10, -digits)) + .49999;
                }
                if (num > 0 && digits < -9) {
                    num = 1 * Math.pow(10, -digits);
                }
                else {
                    num = this.parent.parseFloat(num.toFixed(0)) * Math.pow(10, -digits);
                }
                result = num.toString();
                if (isNaN(num)) {
                    result = (digits.toString().indexOf('"') > -1) ? this.parent.getErrorStrings()[CommonErrors.Value] :
                        result = this.parent.getErrorStrings()[CommonErrors.Name];
                }
            }
        }
        else {
            result = index > -1 ? this.parent.getErrorStrings()[CommonErrors.Value] :
                this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        return result;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {number | string} - Compute the count.
     */
    ComputeCOUNT(...args) {
        let isSubtotalFormula = false;
        if (args.length && args[args.length - 1] === 'isSubtotal') {
            isSubtotalFormula = true;
            args.pop();
        }
        if (isNullOrUndefined(args) || (args.length === 1 && args[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const argArr = args;
        let argVal;
        let cellColl;
        let result = 0;
        let cellValue;
        let value;
        for (let i = 0; i < argArr.length; i++) {
            argVal = argArr[i];
            if (this.parent.isCellReference(argVal)) {
                if (argVal.indexOf(':') > -1) {
                    cellColl = this.parent.getCellCollection(argVal.split(this.parent.tic).join(''));
                    for (let j = 0; j < cellColl.length; j++) {
                        cellValue = !isSubtotalFormula ? this.parent.getValueFromArg(cellColl[j]) :
                            this.parent.getValueFromArg(cellColl[j], null, null, true);
                        if (isSubtotalFormula && cellValue.includes('SUBTOTAL(')) {
                            continue;
                        }
                        if (!isNaN(this.parent.parseFloat(cellValue))) {
                            if (argVal.length > 0 && cellValue.trim() !== '') {
                                result++;
                            }
                        }
                    }
                }
                else {
                    cellValue = !isSubtotalFormula ? this.parent.getValueFromArg(argVal) :
                        this.parent.getValueFromArg(argVal, null, null, true);
                    if (isSubtotalFormula && cellValue.includes('SUBTOTAL(')) {
                        continue;
                    }
                    if (!isNaN(this.parent.parseFloat(cellValue))) {
                        if (argVal.length > 0 && cellValue.trim() !== '') {
                            result++;
                        }
                    }
                }
            }
            else {
                value = this.parent.getValueFromArg(argVal).split(this.parent.tic).join('');
                if (argVal.length === 0 && value.trim() === '') {
                    result++;
                }
                else if (!isNaN(this.parent.parseFloat(value)) || argVal === this.parent.trueValue || argVal === this.parent.falseValue) {
                    if (argVal.length > 0 && argVal.trim() !== '' && value.trim() !== '') {
                        result++;
                    }
                }
            }
        }
        return result;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {Date | string} - Compute the Date.
     */
    ComputeDATE(...args) {
        let nestedFormula;
        if (args.length && args[args.length - 1] === 'nestedFormulaTrue') {
            nestedFormula = true;
            args.pop();
        }
        if (isNullOrUndefined(args) || (args.length === 1 && args[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        if (args.length !== 3) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const argArr = [];
        for (let i = 0; i < args.length; ++i) {
            argArr[i] = this.parent.getValueFromArg(args[i]);
        }
        argArr[0] = (argArr[0] === this.parent.trueValue) ? '1' : (argArr[0] === this.parent.falseValue) ? '0' : argArr[0];
        argArr[1] = (argArr[1] === this.parent.trueValue) ? '1' : (argArr[1] === this.parent.falseValue) ? '0' : argArr[1];
        argArr[2] = (argArr[2] === this.parent.trueValue) ? '1' : (argArr[2] === this.parent.falseValue) ? '0' : argArr[2];
        for (let idx = 0; idx < argArr.length; idx++) {
            const argsValue = argArr[idx];
            if (this.parent.getErrorStrings().indexOf(argsValue) > -1) {
                return argsValue;
            }
            else if ((argsValue === '""') || (argsValue === '"0"' && args[idx] !== '"0"') || (argsValue === '"TRUE"' || argsValue === '"FALSE"')) {
                return this.parent.getErrorStrings()[CommonErrors.Value].toString();
            }
        }
        let year = Math.floor(this.parent.parseFloat(argArr[0].split(this.parent.tic).join('')));
        let month = Math.floor(this.parent.parseFloat(argArr[1].split(this.parent.tic).join('')));
        const day = Math.floor(this.parent.parseFloat(argArr[2].split(this.parent.tic).join('')));
        let days = 0;
        if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
            if ((year < 0 && month <= 12) || (year >= 10000 && month > 0)) {
                return this.parent.getErrorStrings()[CommonErrors.Num].toString();
            }
            while (month > 12) {
                month -= 12;
                year++;
            }
            days = this.parent.getSerialDateFromDate(year, month, day);
        }
        else {
            return this.parent.getErrorStrings()[CommonErrors.Value].toString();
        }
        if (days === 0) {
            return this.parent.getErrorStrings()[CommonErrors.Num].toString();
        }
        const date = this.parent.fromOADate(days);
        if (date.toString() !== 'Invalid Date') {
            if ((date.getFullYear() < 1900) || (10000 <= date.getFullYear())) {
                return this.parent.getErrorStrings()[CommonErrors.Num].toString();
            }
            if (!nestedFormula) {
                return new Internationalization(this.parent.parentObject.locale || 'en-US').formatDate(date, { type: 'date', skeleton: 'yMd' });
            }
        }
        return days.toString();
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {number | string} - Compute the ceiling.
     */
    ComputeFLOOR(...args) {
        if (isNullOrUndefined(args) || (args.length === 1 && args[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        const argArr = args;
        const argCount = argArr.length;
        let value;
        if (argCount !== 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        if ((argArr[0] === '' && argArr[1] === '') || (argArr[0] === '' && !argArr[1].includes('"'))) {
            return 0;
        }
        else if (argArr[1] === '' && !argArr[0].includes('"')) {
            argArr[1] = '0';
        }
        for (let i = 0; i < argArr.length; i++) {
            const argVal = argArr[i].split(this.parent.tic).join('').trim();
            if (argVal === '' || (argArr[i].indexOf(this.parent.tic) > -1 && isNaN(this.parent.parseFloat(argVal)))) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            if (isCellReference(argArr[i])) {
                value = this.parent.getValueFromArg(argArr[i]) || '0';
                value = (value === this.parent.trueValue) ? '1' : (value === this.parent.falseValue) ? '0' : value;
                if (value.toUpperCase().match(/[A-Z]/) || value.includes('"') || !this.parent.isNumber(value)) {
                    return this.parent.getErrorStrings()[CommonErrors.Value];
                }
            }
            else {
                value = this.parent.getValueFromArg(argArr[i].split(this.parent.tic).join(''));
                value = value === this.parent.trueValue ? '1' : (value === this.parent.falseValue ? '0' : value);
                if (value.toUpperCase().match(/[A-Z]/) || value.includes('"') || !this.parent.isNumber(value)) {
                    return this.parent.getErrorStrings()[CommonErrors.Value];
                }
            }
            argArr[i] = value;
        }
        const fnum = this.parent.parseFloat(argArr[0]);
        const significance = this.parent.parseFloat(argArr[1]);
        if (fnum > 0 && significance < 0) {
            return this.parent.getErrorStrings()[CommonErrors.Num];
        }
        if ((fnum > 0 || fnum < 0) && significance === 0) {
            return this.parent.getErrorStrings()[CommonErrors.DivZero];
        }
        if (isNaN(fnum)) {
            return this.parent.getErrorStrings()[CommonErrors.Name];
        }
        if (fnum === 0 && significance === 0) {
            return 0;
        }
        return Math.floor(fnum / significance) * significance;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {number | string} - Compute the ceiling.
     */
    ComputeCEILING(...args) {
        if (isNullOrUndefined(args) || (args.length === 1 && args[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        const argArr = args;
        const argCount = argArr.length;
        let value;
        if (argCount !== 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        if ((argArr[0] === '' && argArr[1] === '') || (argArr[0] === '' && !argArr[1].includes('"'))) {
            return 0;
        }
        else if (argArr[1] === '' && !argArr[0].includes('"')) {
            argArr[1] = '0';
        }
        for (let i = 0; i < argArr.length; i++) {
            const argVal = argArr[i].split(this.parent.tic).join('').trim();
            if (argVal === '' || (argArr[i].indexOf(this.parent.tic) > -1 && isNaN(this.parent.parseFloat(argVal)))) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            if (isCellReference(argArr[i])) {
                value = this.parent.getValueFromArg(argArr[i]) || '0';
                value = (value === this.parent.trueValue) ? '1' : (value === this.parent.falseValue) ? '0' : value;
                if (value.toUpperCase().match(/[A-Z]/) || value.includes('"') || !this.parent.isNumber(value)) {
                    return this.parent.getErrorStrings()[CommonErrors.Value];
                }
            }
            else {
                value = this.parent.getValueFromArg(argArr[i].split(this.parent.tic).join(''));
                value = (value === this.parent.trueValue) ? '1' : (value === this.parent.falseValue) ? '0' : value;
                if (value.toUpperCase().match(/[A-Z]/) || value.includes('"') || !this.parent.isNumber(value)) {
                    return this.parent.getErrorStrings()[CommonErrors.Value];
                }
            }
            argArr[i] = value;
        }
        const cnum = this.parent.parseFloat(argArr[0]);
        const significance = this.parent.parseFloat(argArr[1]);
        if (cnum > 0 && significance < 0) {
            return this.parent.getErrorStrings()[CommonErrors.Num];
        }
        if (isNaN(cnum)) {
            return this.parent.getErrorStrings()[CommonErrors.Name];
        }
        if ((cnum > 0 || cnum === 0) && significance === 0) {
            return 0;
        }
        return Math.ceil(cnum / significance) * significance;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the serialNumber.
     * @returns {number | string} - Compute the DAY.
     */
    ComputeDAY(...args) {
        let result;
        let dateVal;
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(args) || (args.length === 1 && args[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args.length > 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        if (args[0].startsWith(this.parent.tic)) {
            dateVal = args[0].split(this.parent.tic).join('');
            if (dateVal === '' || dateVal === this.parent.trueValue || dateVal === this.parent.falseValue) {
                return errCollection[CommonErrors.Value];
            }
        }
        else {
            dateVal = this.parent.getValueFromArg(args[0].split(this.parent.tic).join(''));
            if (this.parent.isCellReference(args[0]) && (dateVal.indexOf(this.parent.tic) > -1)) {
                return errCollection[CommonErrors.Value];
            }
        }
        if (errCollection.indexOf(dateVal) > -1) {
            return dateVal;
        }
        else if (Number(dateVal) < 0) {
            return errCollection[CommonErrors.Num];
        }
        else if (Math.floor(Number(dateVal)) === 0 || dateVal === this.parent.falseValue) {
            return 0;
        }
        else if (dateVal === this.parent.trueValue) {
            return 1;
        }
        result = this.parent.isNaN(Number(dateVal)) ? this.parent.parseDate(dateVal) : this.parent.intToDate(dateVal);
        if (Object.prototype.toString.call(result) === '[object Date]') { /* eslint-disable-next-line */
            result = ((new Date(result).getFullYear() < 1900) || (new Date(result).getFullYear()) > 9999) ? this.parent.isNumber(dateVal) ? 'Num' : 'NaN' : result.getDate();
        }
        if (result.toString() === 'NaN') {
            return errCollection[CommonErrors.Value];
        }
        else if (result.toString() === 'Num') {
            return errCollection[CommonErrors.Num];
        }
        return result;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {string | number} - Compute the IF value.
     */
    ComputeIF(...args) {
        let nestedFormula;
        if (args.length && args[args.length - 1] === 'nestedFormulaTrue') {
            nestedFormula = true;
            args.pop();
        }
        if (isNullOrUndefined(args) || (args.length === 1 && args[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        if (this.parent.getErrorStrings().indexOf(args[0]) > 0) {
            return args[0];
        }
        const argArr = args;
        let skipTick;
        if (argArr.length === 4 && argArr[3] === 'nestedFormulaTrue') {
            skipTick = true;
            argArr.pop();
        }
        let condition;
        let result;
        if (argArr.length > 3 || argArr.length === 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        else if (argArr.length <= 3) {
            let cellValues;
            let cellVal;
            let val = '';
            condition = this.parent.getValueFromArg(argArr[0]);
            if (this.parent.getErrorStrings().indexOf(condition) > -1) {
                return condition;
            }
            const condUpper = condition.toUpperCase();
            const parsedVal = this.parent.parseFloat(condition);
            if (condUpper === this.parent.trueValue || (parsedVal < 0 || parsedVal > 0)) {
                if (nestedFormula && argArr[1].includes(':')) {
                    cellValues = this.parent.getCellCollection(argArr[1]);
                    for (let i = 0; i < cellValues.length; i++) {
                        cellVal = this.parent.getValueFromArg(cellValues[i]);
                        if (!isNaN(this.parent.parseFloat(cellVal))) {
                            val += cellVal + ',';
                        }
                    }
                    return val.slice(0, val.length - 1);
                }
                result = argArr[1] === '' ? '0' : this.parent.getValueFromArg(argArr[1]);
            }
            else if (condUpper === this.parent.falseValue || parsedVal === 0) {
                if (isNullOrUndefined(argArr[2])) {
                    return this.parent.falseValue;
                }
                if (nestedFormula && argArr[2].includes(':')) {
                    cellValues = this.parent.getCellCollection(argArr[2]);
                    for (let i = 0; i < cellValues.length; i++) {
                        cellVal = this.parent.getValueFromArg(cellValues[i]);
                        if (!isNaN(this.parent.parseFloat(cellVal))) {
                            val += cellVal + ',';
                        }
                    }
                    return val.slice(0, val.length - 1);
                }
                result = argArr[2] === '' ? '0' : this.parent.getValueFromArg(argArr[2]);
            }
            else {
                return this.parent.formulaErrorStrings[FormulasErrorsStrings.Requires3Args];
            }
        }
        if (!skipTick && result.indexOf(this.parent.tic) > -1) {
            return result.split(this.parent.tic).join('');
        }
        else {
            return result === '' ? '0' : result;
        }
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {number | string} - Compute the IFERROR value.
     */
    ComputeIFERROR(...args) {
        if (isNullOrUndefined(args) || (args.length === 1 && args[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        const argArr = args;
        let condition;
        if (argArr.length !== 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        if (this.parent.isCellReference(argArr[0])) {
            condition = this.parent.getValueFromArg(argArr[0]) || '0';
            if (this.parent.getErrorStrings().indexOf(condition) === -1 && condition !== 'NaN') {
                return condition;
            }
        }
        else {
            condition = this.parent.getValueFromArg(argArr[0], null, true) || '0';
            if (this.parent.getErrorStrings().indexOf(condition) === -1 && condition !== 'NaN') {
                condition = condition.split(this.parent.tic).join('').trim();
                return condition;
            }
        }
        if (this.parent.isCellReference(argArr[1])) {
            condition = this.parent.getValueFromArg(argArr[1]) || '0';
        }
        else {
            condition = this.parent.getValueFromArg(argArr[1]) || '0';
            condition = condition.split(this.parent.tic).join('').trim();
        }
        return condition;
    }
    /**
     * @hidden
     * @param {string[]} range - specify the range.
     * @returns {string | number} - Compute the PRODUCT value.
     */
    ComputePRODUCT(...range) {
        let isSubtotalFormula = false;
        if (range.length && range[range.length - 1] === 'isSubtotal') {
            isSubtotalFormula = true;
            range.pop();
        }
        if (isNullOrUndefined(range) || (range.length === 1 && range[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        let product = 1;
        let val;
        let orgValue;
        let argsHit = true;
        let parseVal;
        if (!isNullOrUndefined(range)) {
            const argArr = range;
            for (let i = 0; i < argArr.length; i++) {
                const rangevalue = argArr[i];
                if (rangevalue.indexOf(':') > -1 && this.parent.isCellReference(rangevalue)) {
                    const cellCollection = this.parent.getCellCollection(rangevalue);
                    for (let j = 0; j < cellCollection.length; j++) {
                        val = !isSubtotalFormula ? this.parent.getValueFromArg(cellCollection[j]) :
                            this.parent.getValueFromArg(cellCollection[j], null, null, true);
                        if (isSubtotalFormula && val.includes('SUBTOTAL(')) {
                            continue;
                        }
                        if (!isNumber(val)) {
                            continue;
                        }
                        if (this.parent.getErrorStrings().indexOf(val) > -1) {
                            return val;
                        }
                        parseVal = this.parent.parseFloat(val);
                        if (!isNaN(parseVal)) {
                            if (val.length > 0) {
                                product = product * parseVal;
                                argsHit = false;
                            }
                        }
                    }
                }
                else if (rangevalue.indexOf(':') === -1 && this.parent.isCellReference(rangevalue)) {
                    orgValue = !isSubtotalFormula ? this.parent.getValueFromArg(argArr[i]) :
                        this.parent.getValueFromArg(argArr[i], null, null, true);
                    if (isSubtotalFormula && orgValue.includes('SUBTOTAL(')) {
                        continue;
                    }
                    if (!isNumber(orgValue)) {
                        continue;
                    }
                    if (this.parent.getErrorStrings().indexOf(orgValue) > -1) {
                        return orgValue;
                    }
                }
                else {
                    orgValue = argArr[i];
                    const isEmptyStr = orgValue.indexOf(this.parent.tic) > -1 && orgValue.split(this.parent.tic).join('').trim() === '';
                    if (isEmptyStr || (argArr[i].indexOf(this.parent.tic) > -1 && isNaN(this.parent.parseFloat(orgValue.split(this.parent.tic).join(''))))) {
                        return this.parent.getErrorStrings()[CommonErrors.Value];
                    }
                    orgValue = this.parent.getValueFromArg(argArr[i].split(this.parent.tic).join(''));
                    orgValue = (orgValue === this.parent.trueValue) ? '1' : (orgValue === this.parent.falseValue) ? '0' : orgValue.split(this.parent.tic).join('');
                    if (this.parent.getErrorStrings().indexOf(orgValue) > -1) {
                        return orgValue;
                    }
                }
                parseVal = this.parent.parseFloat(orgValue);
                if (!isNaN(parseVal)) {
                    if (orgValue.length > 0) {
                        product = product * parseVal;
                        argsHit = false;
                    }
                }
            }
        }
        return argsHit ? '0' : product.toString();
    }
    /**
     * @hidden
     * @param {string[]} args - specify the range.
     * @returns {string | number} - Compute the Choose value.
     */
    ComputeDAYS(...args) {
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(args) && (args.length === 1 && args[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args.length !== 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const processArgs = (actuaValue) => {
            let value = this.parent.getValueFromArg(actuaValue).trim();
            if (value.indexOf(this.parent.tic) > -1) {
                value = value.split(this.parent.tic).join('').trim();
                if (value === '' || this.parent.isCellReference(actuaValue) || value.toUpperCase() === this.parent.trueValue ||
                    value.toUpperCase() === this.parent.falseValue) {
                    return errCollection[CommonErrors.Value];
                }
            }
            value = value.split(this.parent.tic).join('');
            if (value.toUpperCase() === this.parent.trueValue) {
                value = '1';
            }
            else if (value === '' || value.toUpperCase() === this.parent.falseValue) {
                value = '0';
            }
            else if (Number(value) < 0) {
                return errCollection[CommonErrors.Num];
            }
            const dateCheck = { value: value.toString() };
            this.parent.parentObject.notify(checkDateFormat, dateCheck);
            if (dateCheck.isDate || dateCheck.isTime) {
                value = (this.parent.parseDate(value).getTime() / (1000 * 3600 * 24)).toString();
            }
            return value;
        };
        const endDate = processArgs(args[0]);
        if (errCollection.indexOf(endDate) > -1) {
            return endDate;
        }
        const startDate = processArgs(args[1]);
        if (errCollection.indexOf(startDate) > -1) {
            return startDate;
        }
        const result = Math.floor(Number(endDate)) - Math.floor(Number(startDate));
        if (isNaN(result)) {
            return errCollection[CommonErrors.Value];
        }
        return result;
    }
    /**
     * @hidden
     * @param {string[]} argArr - specify the range.
     * @returns {number | string | number[] | string[]} - Compute the unique.
     */
    ComputeUNIQUE(...argArr) {
        let result;
        let isComputeExp;
        const errCollection = this.parent.getErrorStrings();
        if (argArr[argArr.length - 1] === 'isComputeExp') {
            isComputeExp = true;
            argArr.pop();
        }
        if (isNullOrUndefined(argArr) || (argArr[0] === '' && argArr.length === 1)) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (argArr.length > 3) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const processArgs = (actualValue) => {
            if (isNullOrUndefined(actualValue)) {
                return this.parent.falseValue;
            }
            let value = this.parent.getValueFromArg(actualValue);
            if (errCollection.indexOf(value) > -1) {
                return value;
            }
            if (Number(value) === 0) {
                return this.parent.falseValue;
            }
            else if (Number(value) < 0 || Number(value) > 0) {
                return this.parent.trueValue;
            }
            if (!this.parent.isCellReference(actualValue)) {
                value = this.parent.removeTics(value);
            }
            if (value.toUpperCase() === this.parent.trueValue || value.toUpperCase() === this.parent.falseValue) {
                return value.toUpperCase();
            }
            else if (value.indexOf(this.parent.tic) > -1 || actualValue.indexOf(this.parent.tic) > -1) {
                return errCollection[CommonErrors.Value];
            }
            else {
                return errCollection[CommonErrors.Name];
            }
        };
        const byColumn = processArgs(argArr[1]);
        if (errCollection.indexOf(byColumn) > -1) {
            return byColumn;
        }
        const exactlyOne = processArgs(argArr[2]);
        if (errCollection.indexOf(exactlyOne) > -1) {
            return exactlyOne;
        }
        const valueCollection = [];
        if (argArr[0].indexOf(':') > -1) {
            if (isNullOrUndefined(argArr[0].match(/[0-9]/))) {
                const splitArray = argArr[0].split(':');
                argArr[0] = splitArray[0] + '1' + ':' + splitArray[1] + (this.parent.spreadSheetUsedRange[0] + 1);
            }
            else if (isNullOrUndefined(argArr[0].toUpperCase().match(/[A-Z]/))) {
                const splitArray = argArr[0].split(':');
                argArr[0] = 'A' + splitArray[0] + ':' + getAlphalabel(this.parent.spreadSheetUsedRange[1] + 1) + splitArray[1];
            }
            const rangeSplit = argArr[0].split(':');
            if (this.parent.isCellReference(rangeSplit[0]) && this.parent.isCellReference(rangeSplit[1])) {
                const collection = this.parent.dependencyCollection;
                for (let i = 0; i < collection.length && !isComputeExp; i++) {
                    if (collection[i].split(':')[0] === argArr[0].split(':')[0]) {
                        this.clearDependency(collection[i]);
                    }
                }
                if (this.parent.dependencyCollection.indexOf(argArr[0]) === -1) {
                    if (!isComputeExp) {
                        this.parent.dependencyCollection.push(argArr[0]);
                    }
                }
                else {
                    this.clearDependency(argArr[0]);
                }
                const j = argArr[0].indexOf(':');
                let swap;
                let rowIdx = this.parent.rowIndex(this.parent.substring(argArr[0], 0, j));
                let colIdx = this.parent.colIndex(this.parent.substring(argArr[0], 0, j));
                let endRowIdx = this.parent.rowIndex(this.parent.substring(argArr[0], j + 1, j + argArr[0].length - j - 1));
                let endColIdx = this.parent.colIndex(this.parent.substring(argArr[0], j + 1, j + argArr[0].length - j - 1));
                if (rowIdx > endRowIdx) {
                    swap = endRowIdx;
                    endRowIdx = rowIdx;
                    rowIdx = swap;
                }
                if (colIdx > endColIdx) {
                    swap = endColIdx;
                    endColIdx = colIdx;
                    colIdx = swap;
                }
                let sheetIndex = '';
                if (argArr[0].indexOf('!') === 0) {
                    sheetIndex = argArr[0].substring(0, argArr[0].replace('!', '').indexOf('!') + 2);
                }
                argArr[0] = sheetIndex + getAlphalabel(colIdx) + rowIdx + ':' + getAlphalabel(endColIdx) + endRowIdx;
                const colDiff = endColIdx - colIdx;
                const cellValues = this.parent.getCellCollection(argArr[0]);
                let actCell;
                let uniqueActCell;
                actCell = uniqueActCell = this.parent.actCell;
                if (byColumn === this.parent.falseValue) {
                    if (colDiff === 0) {
                        for (let i = 0; i < cellValues.length; i++) {
                            let val = this.parent.getValueFromArg(cellValues[i]);
                            val = val === '' ? '0' : val;
                            valueCollection.push(val);
                        }
                    }
                    else {
                        let temp = '';
                        let diff = colDiff;
                        for (let i = 0; i < cellValues.length; i++) {
                            if (i === cellValues.length - 1) {
                                let val = this.parent.getValueFromArg(cellValues[i]);
                                val = val === '' ? '0' : val;
                                temp = temp + val + '++';
                                valueCollection.push(temp.substring(0, temp.length - 2));
                            }
                            if (i <= diff) {
                                let val = this.parent.getValueFromArg(cellValues[i]);
                                val = val === '' ? '0' : val;
                                temp = temp + val + '++';
                            }
                            else {
                                valueCollection.push(temp.substring(0, temp.length - 2));
                                diff = colDiff + i;
                                let val = this.parent.getValueFromArg(cellValues[i]);
                                val = val === '' ? '0' : val;
                                temp = val + '++';
                            }
                        }
                    }
                }
                else {
                    let temp = '';
                    const diff = colDiff + 1;
                    const rowDiff = endRowIdx - rowIdx;
                    for (let i = 0; i < diff; i++) {
                        for (let j = 0; j <= rowDiff; j++) {
                            let val = this.parent.getValueFromArg(cellValues[j * diff + i]);
                            val = val === '' ? '0' : val;
                            temp = temp + val + '++';
                        }
                        valueCollection.push(temp.substring(0, temp.length - 2));
                        temp = '';
                    }
                }
                const uniqueCollection = [];
                const duplicateCollection = [];
                let tmp = [];
                for (let i = 0; i < valueCollection.length; i++) {
                    if (uniqueCollection.indexOf(valueCollection[i].toLowerCase()) === -1) {
                        uniqueCollection.push(valueCollection[i].toLowerCase());
                        tmp.push(valueCollection[i]);
                    }
                    else {
                        if (duplicateCollection.indexOf(valueCollection[i].toLowerCase()) === -1) {
                            duplicateCollection.push(valueCollection[i].toLowerCase());
                        }
                    }
                }
                if (exactlyOne === this.parent.trueValue) {
                    const exactOne = [];
                    for (let i = 0; i < tmp.length; i++) {
                        if (duplicateCollection.indexOf(tmp[i].toLowerCase()) === -1) {
                            exactOne.push(tmp[i]);
                        }
                    }
                    tmp = exactOne;
                    if (tmp.length === 0) {
                        return errCollection[CommonErrors.Calc];
                    }
                }
                if (isComputeExp) {
                    let computeExpResult;
                    if (colDiff !== 0) {
                        computeExpResult = [];
                        (tmp).forEach(function (item) {
                            computeExpResult = [...computeExpResult, ...item.split('++')];
                        });
                    }
                    else {
                        computeExpResult = byColumn === this.parent.falseValue ? tmp : tmp[0].split('++');
                    }
                    return computeExpResult;
                }
                if (actCell.indexOf('!') > -1) {
                    actCell = actCell.substring(actCell.lastIndexOf('!') + 1);
                }
                let actRowIdx = this.parent.rowIndex(actCell);
                let actColIdx = this.parent.colIndex(actCell);
                if (this.parent.dependencyLevel === 0) {
                    let isSpill = false;
                    if (byColumn === this.parent.falseValue) {
                        for (let i = actRowIdx, diff = tmp.length + actRowIdx; i < diff; i++) {
                            const splitValue = tmp[0].split('++');
                            for (let j = actColIdx, diff2 = splitValue.length + actColIdx; j < diff2; j++) {
                                if (i === diff - 1 && j === diff2 - 1 &&
                                    this.parent.uniqueRange.indexOf(uniqueActCell + ':' + getAlphalabel(j) + i) === -1) {
                                    this.parent.uniqueRange.push(uniqueActCell + ':' + getAlphalabel(j) + i);
                                }
                                if (this.checkSpill(j, i)) {
                                    isSpill = true;
                                }
                            }
                        }
                    }
                    else {
                        for (let i = actColIdx, diff = tmp.length + actColIdx; i < diff; i++) {
                            const splitValue = tmp[0].split('++');
                            for (let j = actRowIdx, diff2 = splitValue.length + actRowIdx; j < diff2; j++) {
                                if (i === diff - 1 && j === diff2 - 1 &&
                                    this.parent.uniqueRange.indexOf(this.parent.actCell + ':' + getAlphalabel(i) + j) === -1) {
                                    this.parent.uniqueRange.push(this.parent.actCell + ':' + getAlphalabel(i) + j);
                                }
                                if (this.checkSpill(i, j)) {
                                    isSpill = true;
                                }
                            }
                        }
                    }
                    if (isSpill) {
                        return this.parent.formulaErrorStrings[FormulasErrorsStrings.Spill];
                    }
                }
                else if (this.parent.dependencyLevel > 0 &&
                    this.parent.getValueFromArg(getAlphalabel(actColIdx) + actRowIdx, true).indexOf('#SPILL!') > -1) {
                    return this.parent.formulaErrorStrings[FormulasErrorsStrings.Spill];
                }
                if (byColumn === this.parent.falseValue) {
                    const calcFamily = this.parent.getSheetFamilyItem(this.parent.grid);
                    let token = '';
                    let cellTxt;
                    if (calcFamily.sheetNameToParentObject !== null && calcFamily.sheetNameToParentObject.size > 0) {
                        token = calcFamily.parentObjectToToken.get(this.parent.grid);
                        cellTxt = token + actCell;
                    }
                    for (let i = 0; i < tmp.length; i++) {
                        const splitValue = tmp[i].split('++');
                        if (i > 0) {
                            actRowIdx++;
                            actColIdx = this.parent.colIndex(actCell);
                        }
                        for (let j = 0; j < splitValue.length; j++) {
                            this.setValueRefresh(splitValue[j], actRowIdx, actColIdx);
                            if (i > 0 || j > 0) {
                                this.parent.refresh(token + getAlphalabel(actColIdx) + actRowIdx.toString(), cellTxt);
                            }
                            if (splitValue[j + 1]) {
                                actColIdx++;
                            }
                        }
                    }
                    result = tmp[0].split('++')[0];
                }
                else {
                    for (let i = 0; i < tmp.length; i++) {
                        const splitValue = tmp[i].split('++');
                        for (let i = 0; i < splitValue.length; i++) {
                            this.setValueRefresh(splitValue[i], actRowIdx, actColIdx);
                            if (splitValue[i + 1]) {
                                actRowIdx++;
                            }
                            else {
                                actColIdx++;
                                actRowIdx = this.parent.rowIndex(actCell);
                            }
                        }
                    }
                    result = tmp[0].split('++')[0];
                }
            }
        }
        else if (this.parent.isCellReference(argArr[0])) {
            if (this.parent.dependencyCollection.indexOf(argArr[0]) === -1) {
                if (!isComputeExp) {
                    this.parent.dependencyCollection.push(argArr[0]);
                }
            }
            else {
                this.clearDependency(argArr[0]);
            }
            result = this.parent.getValueFromArg(argArr[0]);
        }
        else {
            result = this.parent.getValueFromArg(argArr[0].trim());
            if (errCollection.indexOf(result) > -1) {
                return result;
            }
            result = this.parent.removeTics(result);
        }
        return result;
    }
    setValueRefresh(splitValue, rowIdx, colIdx) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.parent.parentObject.setValueRowCol(this.parent.getSheetId(this.parent.grid), splitValue, rowIdx, colIdx);
    }
    checkSpill(i, j) {
        let spill = false;
        const value = this.parent.getValueFromArg(getAlphalabel(i) + j, true);
        const formulaAddress = '!' + this.parent.getSheetID(this.parent.grid) + '!' + getAlphalabel(i) + j;
        let formulaString;
        if (this.parent.getFormulaInfoTable().get(formulaAddress)) {
            formulaString = this.parent.getFormulaInfoTable().get(formulaAddress).formulaText;
        }
        if (value && (value.toUpperCase().indexOf('UNIQUE') < 0 ||
            (formulaString && !formulaString.toUpperCase().includes('UNIQUE'))) &&
            value !== this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments]) {
            spill = true;
        }
        return spill;
    }
    clearDependency(value) {
        let actCell = this.parent.actCell;
        let actCellSheetName = '';
        if (actCell.lastIndexOf('!') > -1) {
            const actCellAddr = actCell;
            actCell = actCellAddr.substring(actCellAddr.lastIndexOf('!') + 1);
            actCellSheetName = actCellAddr.substring(0, actCellAddr.lastIndexOf('!')) + '!';
        }
        const actRowIdx = this.parent.rowIndex(actCell);
        const actColIdx = this.parent.colIndex(actCell);
        const j = value.indexOf(':');
        const rowIndex = this.parent.rowIndex(this.parent.substring(value, 0, j));
        const colIndex = this.parent.colIndex(this.parent.substring(value, 0, j));
        const eRowIdx = this.parent.rowIndex(this.parent.substring(value, j + 1, j + value.length - j - 1));
        const eColIdx = this.parent.colIndex(this.parent.substring(value, j + 1, j + value.length - j - 1));
        const rowDiff = eRowIdx - rowIndex + actRowIdx;
        const colDiff = eColIdx - colIndex + actColIdx;
        const formulaText = this.parent.getFormulaInfoTable().get('!' + this.parent.getSheetID(this.parent.grid) + '!' + actCell) ?
            this.parent.getFormulaInfoTable().get('!' + this.parent.getSheetID(this.parent.grid) + '!' + actCell).getFormulaText() : '';
        for (let i = actRowIdx; i <= rowDiff; i++) {
            for (let j = actColIdx; j <= colDiff; j++) {
                if (this.parent.dependencyLevel > 0 || formulaText.indexOf('UNIQUE') > -1) {
                    if (this.parent.getValueFromArg('!' + this.parent.getSheetID(this.parent.grid) + '!' +
                        getAlphalabel(actColIdx) + actRowIdx, true).indexOf('#SPILL!') > -1) {
                        return;
                    }
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    this.parent.parentObject.setValueRowCol(this.parent.getSheetID(this.parent.grid) + 1, '', i, j);
                    this.parent.refresh('!' + this.parent.getSheetID(this.parent.grid) + '!' + getAlphalabel(j) + i, actCell);
                    this.parent.actCell = actCellSheetName + actCell;
                }
            }
        }
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string} - Compute the text or null value.
     */
    ComputeT(...args) {
        let value;
        let nestedFormula;
        const errCollection = this.parent.getErrorStrings();
        if (args.length && args[args.length - 1] === 'nestedFormulaTrue') {
            nestedFormula = true;
            args.pop();
        }
        if (isNullOrUndefined(args) || (args.length === 1 && args[0].trim() === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args.length > 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        value = this.parent.getValueFromArg(args[0]).trim();
        if (errCollection.indexOf(value) > -1) {
            return value;
        }
        if (args[0].indexOf(this.parent.tic) > -1) {
            value = this.parent.removeTics(args[0].trim());
            if (value.indexOf(this.parent.tic + this.parent.tic) > -1) {
                value = value.replace(/""/g, this.parent.tic);
            }
        }
        else {
            if (value.split('%').length === 2 && this.parent.isNumber(value.split('%')[0])) {
                value = (Number(value.split('%')[0]) / 100).toString();
            }
            if (this.parent.isNumber(value) ||
                value.toUpperCase() === this.parent.trueValue || value.toUpperCase() === this.parent.falseValue) {
                return '';
            }
        }
        if (nestedFormula) {
            value = this.parent.tic + value + this.parent.tic;
        }
        return value;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the hours.
     */
    ComputeHOUR(...args) {
        if (args.length !== 1 || isNullOrUndefined(args) || args[0] === '') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        if (args[0].split(this.parent.tic).join('').trim() === '') {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        let cellVal;
        if (this.parent.isCellReference(args[0])) {
            cellVal = this.parent.getValueFromArg(args[0].split(this.parent.tic).join('')) || '0';
            if (cellVal.indexOf(this.parent.tic) > -1) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        else {
            if (args[0].indexOf(this.parent.tic) > -1 && (args[0].split(this.parent.tic).join('') === this.parent.trueValue || args[0].split(this.parent.tic).join('') === this.parent.falseValue)) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            cellVal = this.parent.getValueFromArg(args[0]).split(this.parent.tic).join('');
        }
        if (this.parent.getErrorStrings().indexOf(cellVal) > -1) {
            return cellVal;
        }
        cellVal = cellVal === this.parent.trueValue ? '1' : (cellVal === this.parent.falseValue ? '0' : cellVal);
        let date;
        if (this.parent.isNumber(cellVal)) {
            if (this.parent.parseFloat(cellVal) < 0 || this.parent.parseFloat(cellVal) > 2958465) {
                return this.parent.getErrorStrings()[CommonErrors.Num];
            }
            date = this.parent.intToTime(cellVal);
        }
        else {
            const dateCheck = { value: cellVal.toString() };
            this.parent.parentObject.notify(checkDateFormat, dateCheck);
            if (dateCheck.isDate || dateCheck.isTime) {
                date = dateCheck.dateObj;
            }
            else {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        if (date.toString() === 'Invalid Date') {
            date = new Date(Date.parse(cellVal));
        }
        if (date.toString() === 'Invalid Date') {
            const argVal = new Date(Date.now()).toLocaleDateString() + ' ' + cellVal;
            date = new Date(Date.parse(argVal));
        }
        if (date.toString() === 'Invalid Date') {
            date = this.parent.fromOADate(this.parent.parseFloat(cellVal));
        }
        if (date.toString() === 'Invalid Date') {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        if (date.getFullYear() < 1900 || date.getFullYear() > 9999) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        return date.getHours();
    }
    /**
     * @hidden
     * @param {string} argArr - specify the args.
     * @returns {string | boolean} - Compute the hours.
     */
    ComputeMINUTE(...argArr) {
        if (argArr.length !== 1 || isNullOrUndefined(argArr) || argArr[0] === '') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        if (argArr[0].split(this.parent.tic).join('').trim() === '') {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        let cellVal;
        if (this.parent.isCellReference(argArr[0])) {
            cellVal = this.parent.getValueFromArg(argArr[0].split(this.parent.tic).join('')) || '0';
            if (cellVal.indexOf(this.parent.tic) > -1) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        else {
            if (argArr[0].indexOf(this.parent.tic) > -1 && (argArr[0].split(this.parent.tic).join('') === this.parent.trueValue || argArr[0].split(this.parent.tic).join('') === this.parent.falseValue)) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            cellVal = this.parent.getValueFromArg(argArr[0]).split(this.parent.tic).join('');
        }
        if (this.parent.getErrorStrings().indexOf(cellVal) > -1) {
            return cellVal;
        }
        cellVal = cellVal === this.parent.trueValue ? '1' : (cellVal === this.parent.falseValue ? '0' : cellVal);
        let dateVal;
        if (this.parent.isNumber(cellVal)) {
            if (this.parent.parseFloat(cellVal) < 0 || this.parent.parseFloat(cellVal) > 2958465) {
                return this.parent.getErrorStrings()[CommonErrors.Num];
            }
            dateVal = this.parent.intToTime(cellVal);
        }
        else {
            const dateCheck = { value: cellVal.toString() };
            this.parent.parentObject.notify(checkDateFormat, dateCheck);
            if (dateCheck.isDate || dateCheck.isTime) {
                dateVal = dateCheck.dateObj;
            }
            else {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        if (dateVal.toString() === 'Invalid Date') {
            dateVal = new Date(Date.parse(cellVal));
        }
        if (dateVal.toString() === 'Invalid Date') {
            const argVal = new Date(Date.now()).toLocaleDateString() + ' ' + cellVal;
            dateVal = new Date(Date.parse(argVal));
        }
        if (dateVal.toString() === 'Invalid Date') {
            dateVal = this.parent.fromOADate(this.parent.parseFloat(cellVal));
        }
        if (dateVal.toString() === 'Invalid Date') {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        if (dateVal.getFullYear() < 1900 || dateVal.getFullYear() > 9999) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        return dateVal.getMinutes();
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the hours.
     */
    ComputeSECOND(...args) {
        if (args.length !== 1 || isNullOrUndefined(args) || args[0] === '') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        if (args[0].split(this.parent.tic).join('').trim() === '') {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        let cellVal;
        if (this.parent.isCellReference(args[0])) {
            cellVal = this.parent.getValueFromArg(args[0].split(this.parent.tic).join('')) || '0';
            if (cellVal.indexOf(this.parent.tic) > -1) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        else {
            if (args[0].indexOf(this.parent.tic) > -1 && (args[0].split(this.parent.tic).join('') === this.parent.trueValue || args[0].split(this.parent.tic).join('') === this.parent.falseValue)) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            cellVal = this.parent.getValueFromArg(args[0]).split(this.parent.tic).join('');
        }
        if (this.parent.getErrorStrings().indexOf(cellVal) > -1) {
            return cellVal;
        }
        cellVal = cellVal === this.parent.trueValue ? '1' : (cellVal === this.parent.falseValue ? '0' : cellVal);
        let dateValue;
        if (this.parent.isNumber(cellVal)) {
            if (this.parent.parseFloat(cellVal) < 0 || this.parent.parseFloat(cellVal) > 2958465) {
                return this.parent.getErrorStrings()[CommonErrors.Num];
            }
            dateValue = this.parent.intToTime(cellVal);
        }
        else {
            const dateCheck = { value: cellVal.toString() };
            this.parent.parentObject.notify(checkDateFormat, dateCheck);
            if (dateCheck.isDate || dateCheck.isTime) {
                dateValue = dateCheck.dateObj;
            }
            else {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        if (dateValue.toString() === 'Invalid Date') {
            dateValue = new Date(Date.parse(cellVal));
        }
        if (dateValue.toString() === 'Invalid Date') {
            const argVal = (new Date(Date.now())).toLocaleDateString() + ' ' + cellVal;
            dateValue = new Date(Date.parse(argVal));
        }
        if (dateValue.toString() === 'Invalid Date') {
            dateValue = this.parent.fromOADate(this.parent.parseFloat(cellVal));
        }
        if (dateValue.toString() === 'Invalid Date') {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        if (dateValue.getFullYear() < 1900 || dateValue.getFullYear() > 9999) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        return dateValue.getSeconds();
    }
    /**
     * @hidden
     * @param {string} argsVal - specify the args.
     * @returns {string | boolean} - Compute the months.
     */
    ComputeMONTH(...argsVal) {
        const errCollection = this.parent.getErrorStrings();
        if (argsVal.length === 1 && argsVal[0] === '') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (argsVal.length !== 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        let value = this.parent.getValueFromArg(argsVal[0]).trim();
        if (errCollection.indexOf(value) > -1) {
            return value;
        }
        if (this.parent.isCellReference(argsVal[0])) {
            if (value.indexOf(this.parent.tic) > -1) {
                return errCollection[CommonErrors.Value];
            }
            else if (value === '') {
                return 1;
            }
        }
        else {
            if (value.toUpperCase() === '"TRUE"' || value.toUpperCase() === '"FALSE"') {
                return errCollection[CommonErrors.Value];
            }
            value = value.split(this.parent.tic).join('');
        }
        if (value === '') {
            return errCollection[CommonErrors.Value];
        }
        else if (value === this.parent.trueValue || value === this.parent.falseValue ||
            (Number(value) > -1 && Number(value) < 32)) {
            return 1;
        }
        else if (Number(value) < 0) {
            return errCollection[CommonErrors.Num];
        }
        else if (value.indexOf('%') > -1) {
            value = (Number(value.split('%')[0]) * 0.01).toString();
        }
        if (this.parent.isNumber(value)) {
            value = parseInt((Math.floor(Number(value)).toString()), 10);
        }
        const date = this.parent.parseDate(value);
        if (date.toString() === 'Invalid Date') {
            if (this.parent.isNumber(value)) {
                return errCollection[CommonErrors.Num];
            }
            else {
                return errCollection[CommonErrors.Value];
            }
        }
        else if ((date.getFullYear() < 1900) || (10000 <= date.getFullYear())) {
            return errCollection[CommonErrors.Num];
        }
        return (date.getMonth() + 1).toString();
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string } - Compute the time and date value.
     */
    ComputeNOW(...args) {
        if (args.length !== 1 || args[0] !== '') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        const date = new Date(Date.now());
        const intl = new Internationalization();
        const dFormatter = intl.getDateFormat({ format: 'M/d/yyyy h:mm:ss a' });
        const dt = this.parent.parentObject.dateToInt(dFormatter(date), true);
        return dt.toString();
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the exact value or not.
     */
    ComputeEXACT(...args) {
        let result = false;
        const nestedFormula = args.length && args[args.length - 1] === 'nestedFormulaTrue';
        const errCollection = this.parent.getErrorStrings();
        if (nestedFormula) {
            args.pop();
        }
        if (!args || (!args[0] && args.length === 1)) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args.length !== 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        let value1;
        let value2;
        let isCellRef;
        if (args[0]) {
            value1 = this.parent.getValueFromArg(args[0]);
            if (errCollection.indexOf(value1) > -1) {
                return value1;
            }
            if (value1.indexOf(this.parent.tic) === -1 && value1.includes('%')) {
                value1 = (Number(value1.split('%')[0]) / 100).toString();
            }
            if (this.parent.isCellReference(args[0])) {
                isCellRef = true;
            }
            else {
                value1 = value1.split(this.parent.tic).join('');
            }
        }
        if (args[1]) {
            value2 = this.parent.getValueFromArg(args[1]);
            if (errCollection.indexOf(value2) > -1) {
                return value2;
            }
            if (value2.indexOf(this.parent.tic) === -1 && value2.includes('%')) {
                value2 = (Number(value2.split('%')[0]) / 100).toString();
            }
            if (this.parent.isCellReference(args[1])) {
                if (!isCellRef && ((value1.trim().length === 0) && (value2.trim().length === 0))) {
                    result = false;
                }
            }
            else {
                value2 = value2.split(this.parent.tic).join('');
                if (isCellRef && ((value1.trim().length === 0) && (value2.trim().length === 0))) {
                    result = false;
                }
            }
        }
        if (value1 === value2) {
            result = true;
            if (nestedFormula) {
                result = this.parent.tic + result + this.parent.tic;
            }
        }
        return result;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the exact value or not.
     */
    ComputeLEN(...args) {
        let value;
        const errorStrings = this.parent.getErrorStrings();
        if (isNullOrUndefined(args) || (args[0].trim() === '' && args.length === 1)) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args.length > 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        value = this.parent.getValueFromArg(args[0]).trim();
        if (errorStrings.indexOf(value) > -1) {
            return value;
        }
        if (args[0].indexOf(this.parent.tic) > -1) {
            if (args[0] !== value && args[0].startsWith('n')) {
                value = this.parent.removeTics(value.trim());
            }
            else {
                value = this.parent.removeTics(args[0].trim());
                if (value.indexOf(this.parent.tic + this.parent.tic) > -1) {
                    value = value.replace(/""/g, this.parent.tic);
                }
            }
        }
        else if (!args[0].startsWith('n') && value.split('%').length === 2 && this.parent.isNumber(value.split('%')[0])) {
            value = (Number(value.split('%')[0]) / 100).toString();
        }
        return value.length;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the remainder from the given numbers.
     */
    ComputeMOD(...args) {
        let value;
        if (isNullOrUndefined(args) || args.length !== 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        if (args[1] === '' && !args[0].includes('"')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.Div];
        }
        else if (args[0] === '' && !args[1].includes('"')) {
            return 0;
        }
        for (let i = 0; i < args.length; i++) {
            const argVal = args[i].split(this.parent.tic).join('').trim();
            if (argVal === '' || (args[i].indexOf(this.parent.tic) > -1 && isNaN(this.parent.parseFloat(argVal)))) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            if (isCellReference(args[i])) {
                value = this.parent.getValueFromArg(args[i]) || '0';
                value = (value === this.parent.trueValue) ? '1' : (value === this.parent.falseValue) ? '0' : value;
                if (value.toUpperCase().match(/[A-Z]/) || value.includes('"') || !this.parent.isNumber(value)) {
                    return this.parent.getErrorStrings()[CommonErrors.Value];
                }
            }
            else {
                value = this.parent.getValueFromArg(args[i].split(this.parent.tic).join(''));
                value = (value === this.parent.trueValue) ? '1' : (value === this.parent.falseValue) ? '0' : value;
                if (this.parent.getErrorStrings().indexOf(value) > -1) {
                    return value;
                }
            }
            args[i] = value;
        }
        let value1 = args[0];
        let value2 = args[1];
        if (value2 === '0' || value2 === '') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.Div];
        }
        else if (value1 === '0' || value1 === '') {
            return 0;
        }
        value1 = parseFloat(value1);
        value2 = parseFloat(value2);
        const result = ((value1 % value2) + value2) % value2;
        if (isNaN(result)) {
            return this.parent.getErrorStrings()[CommonErrors.Name];
        }
        return result;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the next odd number.
     */
    ComputeODD(...args) {
        if (isNullOrUndefined(args) || args.length !== 1 || args[0] === '') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        const argVal = args[0].split(this.parent.tic).join('').trim();
        if (argVal === '' || (args[0].indexOf(this.parent.tic) > -1 && isNaN(this.parent.parseFloat(argVal)))) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        let val;
        if (isCellReference(args[0])) {
            val = this.parent.getValueFromArg(args[0]);
            if (val === this.parent.trueValue) {
                val = '1';
            }
            else if (val === '' || val === this.parent.falseValue) {
                val = '0';
            }
            else if (val.toUpperCase().match(/[A-Z]/) || val.includes('"') || !this.parent.isNumber(val)) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        else {
            val = this.parent.getValueFromArg(args[0].split(this.parent.tic).join(''));
            if (val === '#NAME?') {
                return this.parent.getErrorStrings()[CommonErrors.Name];
            }
            if (val === this.parent.trueValue) {
                val = '1';
            }
            else if (val === '' || val === this.parent.falseValue) {
                val = '0';
            }
            else if (val.toUpperCase().match(/[A-Z]/) || !this.parent.isNumber(val)) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        let result = Math.ceil(parseInt(val, 10));
        const isOne = result === 0;
        result = result % 2 === 0 ? (result > 0 ? result + 1 : result - 1) : result;
        if (Math.ceil(parseInt(val, 10)) % 2 !== 0) {
            if (parseInt(val, 10) > 0 && parseFloat(val) > parseInt(val, 10)) {
                result = result + 2;
            }
            else if (parseInt(val, 10) < 0 && parseFloat(val) < parseInt(val, 10)) {
                result = result - 2;
            }
        }
        if (isNaN(result)) {
            return this.parent.getErrorStrings()[CommonErrors.Name];
        }
        return isOne ? 1 : result;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the next even number.
     */
    ComputeEVEN(...args) {
        if (isNullOrUndefined(args) || args.length !== 1 || args[0] === '') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        const argVal = args[0].split(this.parent.tic).join('').trim();
        if (argVal === '' || (args[0].indexOf(this.parent.tic) > -1 && isNaN(this.parent.parseFloat(argVal)))) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        let value1;
        if (isCellReference(args[0])) {
            value1 = this.parent.getValueFromArg(args[0]);
            if (value1 === this.parent.trueValue) {
                value1 = '1';
            }
            else if (value1 === '' || value1 === this.parent.falseValue) {
                value1 = '0';
            }
            else if (value1.toUpperCase().match(/[A-Z]/) || value1.includes('"') || !this.parent.isNumber(value1)) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        else {
            value1 = this.parent.getValueFromArg(args[0].split(this.parent.tic).join(''));
            if (value1 === '#NAME?') {
                return this.parent.getErrorStrings()[CommonErrors.Name];
            }
            if (value1 === this.parent.trueValue) {
                value1 = '1';
            }
            else if (value1 === '' || value1 === this.parent.falseValue) {
                value1 = '0';
            }
            else if (value1.toUpperCase().match(/[A-Z]/) || !this.parent.isNumber(value1)) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        let result = Math.ceil(parseInt(value1, 10));
        result = result % 2 === 0 ? result : (result > 0 ? result + 1 : result - 1);
        if (Math.ceil(parseInt(value1, 10)) % 2 === 0) {
            if (parseInt(value1, 10) > 0 && parseFloat(value1) > parseInt(value1, 10)) {
                result = result + 2;
            }
            else if (parseInt(value1, 10) < 0 && parseFloat(value1) < parseInt(value1, 10)) {
                result = result - 2;
            }
        }
        if (isNaN(result)) {
            return this.parent.getErrorStrings()[CommonErrors.Name];
        }
        return result;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the value of pi.
     */
    ComputePI(...args) {
        let result;
        if (args && args[0] !== '') {
            result = this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else {
            result = Math.PI;
        }
        return result;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the median value.
     */
    ComputeMEDIAN(...args) {
        let value1;
        let num = [];
        if (isNullOrUndefined(args) || args[0] === '' && args.length === 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        for (let i = 0; i < args.length; i++) {
            if (this.parent.isCellReference(args[i])) {
                if (args[i].indexOf(':') > -1) {
                    const cellCollection = this.parent.getCellCollection(args[i]);
                    for (let a = 0; a < cellCollection.length; a++) {
                        const cellValue = this.parent.getValueFromArg(cellCollection[a]);
                        if (this.parent.getErrorStrings().indexOf(cellValue) > -1) {
                            return cellValue;
                        }
                        else if (cellValue.trim() !== '') {
                            num.push(this.parent.parseFloat(cellValue));
                        }
                    }
                }
                else {
                    const cellVal = this.parent.getValueFromArg(args[i]);
                    if (this.parent.getErrorStrings().indexOf(cellVal) > -1) {
                        return cellVal;
                    }
                    else if (cellVal.trim() !== '') {
                        num.push(this.parent.parseFloat(cellVal));
                    }
                }
            }
            else if (args[i] === '' || args[i] === this.parent.falseValue && !this.parent.isCellReference(args[i])) {
                num.push(0);
            }
            else if (args[i] === this.parent.trueValue && !this.parent.isCellReference(args[i])) {
                num.push(1);
            }
            else if (args[i].indexOf(this.parent.tic) > -1 && isNaN(parseFloat(args[i].split(this.parent.tic).join('')))) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            else {
                const cValue = this.parent.getValueFromArg(args[i]).split(this.parent.tic).join('');
                if (this.parent.getErrorStrings().indexOf(cValue) > -1) {
                    return cValue;
                }
                else {
                    num.push(this.parent.parseFloat(cValue));
                }
            }
        }
        num = num.sort((n1, n2) => n1 - n2);
        let len = num.length;
        for (let j = 0; j < len; j++) {
            if (isNaN(num[j])) {
                num.splice(j, 1);
                len = num.length;
                j--;
                if (num.length === 0) {
                    break;
                }
            }
        }
        if (num.length % 2 !== 0 && !isNaN(num[parseInt((num.length / 2).toString(), 10)])) {
            value1 = num[parseInt((num.length / 2).toString(), 10)];
        }
        else if (!isNaN(num[num.length / 2]) && !isNaN(num[num.length / 2 - 1])) {
            value1 = (num[num.length / 2] + num[num.length / 2 - 1]) / 2;
        }
        else {
            return this.parent.getErrorStrings()[CommonErrors.Num];
        }
        return value1;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the edate value.
     */
    ComputeEDATE(...args) {
        if (args.length !== 2 || isNullOrUndefined(args)) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        if (args[0] === '' || args[1] === '') {
            return this.parent.getErrorStrings()[CommonErrors.NA];
        }
        if (args[0].split(this.parent.tic).join('') === '' || args[1].split(this.parent.tic).join('') === ''
            || (args[1].indexOf(this.parent.tic) > -1 && isNaN(this.parent.parseFloat(args[1].split(this.parent.tic).join(''))))) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        let dValue;
        let mValue;
        if (this.parent.isCellReference(args[0])) {
            if (args[0].indexOf(':') > -1) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            dValue = this.parent.getValueFromArg(args[0].split(this.parent.tic).join('')) || '0';
            if (dValue.indexOf(this.parent.tic) > -1) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        else {
            dValue = this.parent.getValueFromArg(args[0].split(this.parent.tic).join(''));
        }
        if (this.parent.isCellReference(args[1])) {
            if (args[1].indexOf(':') > -1) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            mValue = this.parent.getValueFromArg(args[1].split(this.parent.tic).join('')) || '0';
        }
        else {
            mValue = this.parent.getValueFromArg(args[1].split(this.parent.tic).join(''));
        }
        if (this.parent.getErrorStrings().indexOf(mValue) > -1) {
            return mValue;
        }
        mValue = parseInt(mValue, 10);
        let date;
        if (this.parent.isNumber(dValue)) {
            dValue = parseInt(dValue, 10);
            if (dValue < 0 || dValue > 2958465) {
                return this.parent.getErrorStrings()[CommonErrors.Num];
            }
            date = this.parent.fromOADate(dValue);
        }
        else {
            date = this.parent.checkDateFormat(dValue);
        }
        if (isNaN(mValue) || isNullOrUndefined(this.parent.isDate(date)) || date.getFullYear() > 9999) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        const checkDate = date.getDate();
        date.setMonth(date.getMonth() + mValue);
        if (checkDate !== date.getDate()) {
            date.setDate(0);
            //For the date like 31st of January and mValue as 1, the setMonth returns 3rd of March, so we using setDate(0) to return 28th of February.
        }
        let result = this.parent.parentObject.dateToInt(date);
        // For 0 and 1 values we are considering the same starting date as 1/1/1900, so for 0 we are decrementing the value with 1.
        if (dValue.toString() === '0') {
            result -= 1;
        }
        if (result < 0 || result > 2958465) {
            return this.parent.getErrorStrings()[CommonErrors.Num];
        }
        return result.toString();
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the number of months value.
     */
    ComputeEOMONTH(...args) {
        if (args.length !== 2 || isNullOrUndefined(args)) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        if (args[0] === '' || args[1] === '') {
            return this.parent.getErrorStrings()[CommonErrors.NA];
        }
        if (args[0].split(this.parent.tic).join('') === '' || args[1].split(this.parent.tic).join('') === ''
            || (args[1].indexOf(this.parent.tic) > -1 && isNaN(this.parent.parseFloat(args[1].split(this.parent.tic).join(''))))) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        let dateValue;
        let monthValue;
        if (this.parent.isCellReference(args[0])) {
            if (args[0].indexOf(':') > -1) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            dateValue = this.parent.getValueFromArg(args[0].split(this.parent.tic).join('')) || '0';
            if (dateValue.indexOf(this.parent.tic) > -1) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        else {
            dateValue = this.parent.getValueFromArg(args[0]).split(this.parent.tic).join('');
        }
        if (this.parent.getErrorStrings().indexOf(dateValue) > -1) {
            return dateValue;
        }
        if (this.parent.isCellReference(args[1])) {
            if (args[1].indexOf(':') > -1) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            monthValue = this.parent.getValueFromArg(args[1].split(this.parent.tic).join('')) || '0';
        }
        else {
            monthValue = this.parent.getValueFromArg(args[1].split(this.parent.tic).join(''));
        }
        if (this.parent.getErrorStrings().indexOf(monthValue) > -1) {
            return monthValue;
        }
        monthValue = parseInt(monthValue, 10);
        let date;
        if (this.parent.isNumber(dateValue)) {
            dateValue = parseInt(dateValue, 10);
            if (dateValue < 0 || dateValue > 2958465) {
                return this.parent.getErrorStrings()[CommonErrors.Num];
            }
            date = this.parent.fromOADate(dateValue);
        }
        else {
            date = this.parent.checkDateFormat(dateValue);
        }
        if (isNaN(monthValue) || isNullOrUndefined(this.parent.isDate(date)) || date.getFullYear() > 9999) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        date = new Date(date.getFullYear(), date.getMonth() + (monthValue + 1), 0);
        const result = this.parent.parentObject.dateToInt(date);
        if (result < 0 || result > 2958465 || date.getFullYear() < 1900) {
            return this.parent.getErrorStrings()[CommonErrors.Num];
        }
        return result.toString();
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the date value.
     */
    ComputeDATEVALUE(...args) {
        let dValue;
        const errCollection = this.parent.getErrorStrings();
        if (args[0] === '') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args.length > 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        dValue = this.parent.getValueFromArg(args[0]) || '0';
        if (errCollection.indexOf(dValue) > -1) {
            return dValue;
        }
        if (this.parent.isCellReference(args[0])) {
            if ((args[0].indexOf(':') > -1) || dValue.startsWith(this.parent.tic)) {
                return errCollection[CommonErrors.Value];
            }
        }
        else {
            dValue = (args[0]).split(this.parent.tic).join('') || '0';
        }
        if (!(!(this.parent.isNumber(dValue)) && !isNullOrUndefined(this.parent.isDate(dValue)))) {
            return errCollection[CommonErrors.Value];
        }
        const date = this.parent.parseDate(dValue);
        if (errCollection.indexOf(dValue) > -1) {
            return dValue;
        }
        else if (isNullOrUndefined(date) || date.toString() === 'Invalid Date' ||
            date.getFullYear() < 1900 || date.getFullYear() > 9999) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        else {
            dValue = this.parent.toOADate(date).toString();
        }
        return parseFloat(dValue).toFixed(0).toString();
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the count blank value.
     */
    ComputeCOUNTBLANK(...args) {
        let result = 0;
        if (args.length !== 1 || isNullOrUndefined(args) || !this.parent.isCellReference(args[0])) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args[0] === '') {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        else {
            const cellRange = this.parent.getCellCollection(args[0]);
            for (let i = 0; i < cellRange.length; i++) {
                if (this.parent.getValueFromArg(cellRange[i]) === '') {
                    result++;
                }
            }
        }
        return result;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the factorial value.
     */
    ComputeFACT(...args) {
        let fact = 1;
        const errCollection = this.parent.getErrorStrings();
        if (args[0] === '') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args.length !== 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        let getValue = args[0];
        if (this.parent.isCellReference(args[0]) || isNaN(Number(getValue.split(this.parent.tic).join('')))) {
            getValue = this.parent.getValueFromArg(args[0]);
            if (errCollection.indexOf(getValue) > -1) {
                return getValue;
            }
            if (getValue.startsWith(this.parent.tic) ||
                getValue.match(/^(\d*\.\d+|\d+)\s*[+\-*/]\s*(\d*\.\d+|\d+)$/)) {
                return errCollection[CommonErrors.Value];
            }
            else if (getValue === '') {
                return 1;
            }
        }
        getValue = getValue.split(this.parent.tic).join('').trim();
        if (errCollection.indexOf(getValue) > -1) {
            return getValue;
        }
        if (getValue.toUpperCase() === this.parent.trueValue || getValue.toUpperCase() === this.parent.falseValue) {
            return 1;
        }
        if (getValue.indexOf('%') > -1) {
            getValue = (Number(getValue.split('%')[0]) / 100).toString();
        }
        const value = parseInt(getValue, 10);
        if ((value < 0) || (value > 170)) {
            return errCollection[CommonErrors.Num];
        }
        else if (getValue.toUpperCase().match(/[A-Z]/) || getValue === '') {
            return errCollection[CommonErrors.Value];
        }
        else if (getValue.indexOf(':') > -1) {
            return 0;
        }
        for (let i = 1; i <= value; i++) {
            fact = fact * i;
        }
        return fact;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the decimal value.
     */
    ComputeDECIMAL(...args) {
        let value;
        const specialChars = /[@#$%^&*()?:{}|<>+-]/g;
        if (isNullOrUndefined(args) || args.length !== 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args[0].match(specialChars)) {
            return this.parent.getErrorStrings()[CommonErrors.Num];
        }
        else if (args[1].indexOf(this.parent.tic) > -1 && isNaN(this.parent.parseFloat(args[1].split(this.parent.tic).join('')))) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        else {
            let val;
            let val1;
            if (this.parent.isCellReference(args[0].toString())) {
                val = this.parent.getValueFromArg(args[0]);
            }
            else {
                val = this.parent.getValueFromArg(args[0]).split(this.parent.tic).join('');
            }
            if (this.parent.isCellReference(args[1].toString())) {
                val1 = this.parent.getValueFromArg(args[1]);
            }
            else {
                val1 = this.parent.getValueFromArg(args[1]).split(this.parent.tic).join('');
            }
            const num = parseInt(val, 10);
            const radix = parseInt(val1, 10);
            if (this.parent.getErrorStrings().indexOf(val) > -1) {
                return val;
            }
            else if (this.parent.getErrorStrings().indexOf(val1) > -1) {
                return val1;
            }
            else if (val === '' && val1 !== '') {
                return 0;
            }
            else if (val === '' || (num < 0) || (!isNaN(num) && !Number.isInteger(parseFloat(val)))) {
                return this.parent.getErrorStrings()[CommonErrors.Num];
            }
            else if (val1 === '' || (radix < 2 || radix > 36) || isNaN(radix)) {
                return this.parent.getErrorStrings()[CommonErrors.Num];
            }
            else if (isNaN(this.parent.parseFloat(val)) && this.parent.parseFloat(val1) <= 10) {
                return this.parent.getErrorStrings()[CommonErrors.Num];
            }
            value = parseInt(val, parseInt(val1, 10));
        }
        return isNaN(value) ? this.parent.getErrorStrings()[CommonErrors.Num] : value;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the degrees value.
     */
    ComputeDEGREES(...args) {
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(args) || (args[0] === '' && args.length === 1)) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args.length !== 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        let val = this.parent.getValueFromArg(args[0]).trim();
        if (errCollection.indexOf(val) > -1) {
            return val;
        }
        if (this.parent.isCellReference(args[0])) {
            if (val === '' || val.indexOf(':') > -1) {
                return 0;
            }
            else if (val.indexOf(this.parent.tic) > -1 || (isNaN(Number(val)) && !isNaN(parseInt(val, 10)))) {
                return errCollection[CommonErrors.Value];
            }
        }
        else if (val.indexOf('"TRUE"') > -1) {
            return errCollection[CommonErrors.Value];
        }
        val = val.split(this.parent.tic).join('');
        if (val.toUpperCase() === this.parent.trueValue) {
            val = '1';
        }
        else if (val.toUpperCase() === this.parent.falseValue) {
            val = '0';
        }
        else if (val.indexOf('%') > -1) {
            val = (Number(val.split('%')[0]) / 100).toString();
        }
        else if (val.toUpperCase().match(/[A-Z]/) || isNaN(parseInt(val, 10))) {
            return errCollection[CommonErrors.Value];
        }
        return parseFloat(val) * (180 / (Math.PI));
    }
    /**
     * @hidden
     * @param {string} argArr - specify the args.
     * @returns {string | boolean} - Compute the cell address.
     */
    ComputeADDRESS(...argArr) {
        let value;
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(argArr) || (argArr.length === 1 && argArr[0].trim() === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (argArr.length < 2 || argArr.length > 5) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        else if (argArr[0].split(this.parent.tic).join('').trim() === '' || argArr[1].split(this.parent.tic).join('').trim() === '') {
            return errCollection[CommonErrors.Value];
        }
        const processArgs = (actualValue) => {
            let value = this.parent.getValueFromArg(actualValue).trim();
            if (errCollection.indexOf(value) > 0) {
                return value;
            }
            if (value.toUpperCase() === this.parent.trueValue) {
                value = '1';
            }
            else if (value.toUpperCase() === this.parent.falseValue) {
                value = '0';
            }
            if (this.parent.isCellReference(actualValue) && value.indexOf(this.parent.tic) > -1) {
                return errCollection[CommonErrors.Value];
            }
            value = this.parent.removeTics(value);
            if (value.split('%').length === 2 && this.parent.isNumber(value.split('%')[0])) {
                value = (Number(value.split('%')[0]) / 100).toString();
            }
            return value;
        };
        /* For argArr[0] */
        let rowIndex = processArgs(argArr[0]);
        if (errCollection.indexOf(rowIndex) > 0) {
            return rowIndex;
        }
        rowIndex = Number(rowIndex);
        if (isNaN(rowIndex) || rowIndex < 1) {
            return errCollection[CommonErrors.Value];
        }
        else {
            rowIndex = rowIndex.toString();
        }
        /* For argArr[1] */
        let colIndex = processArgs(argArr[1]);
        if (errCollection.indexOf(colIndex) > 0) {
            return colIndex;
        }
        colIndex = Number(colIndex);
        if (isNaN(colIndex) || colIndex < 1) {
            return errCollection[CommonErrors.Value];
        }
        else {
            colIndex = colIndex.toString();
        }
        /* For argArr[2] */
        let absIndex;
        let refStyle;
        if (isNullOrUndefined(argArr[2]) || argArr[2].trim() === '') {
            absIndex = '1';
        }
        else {
            absIndex = processArgs(argArr[2]);
            if (errCollection.indexOf(absIndex) > 0) {
                return absIndex;
            }
            absIndex = Number(absIndex);
            if (isNaN(absIndex) || absIndex < 1 || absIndex > 4) {
                return errCollection[CommonErrors.Value];
            }
            else {
                absIndex = absIndex.toString();
            }
        }
        if (isNullOrUndefined(argArr[3]) || argArr[3].trim() === '') {
            refStyle = '1';
        }
        else {
            refStyle = processArgs(argArr[3]);
            if (errCollection.indexOf(refStyle) > 0) {
                return refStyle;
            }
            if (refStyle.toUpperCase() === this.parent.trueValue || Number(refStyle) > 1) {
                refStyle = '1';
            }
            else if (refStyle === '' || refStyle.toUpperCase() === this.parent.falseValue) {
                refStyle = '0';
            }
        }
        if (refStyle === '1') {
            if (absIndex === '1') {
                value = '$' + getAlphalabel(parseInt(colIndex, 10)) + '$' + parseInt(rowIndex, 10);
            }
            else if (absIndex === '2') {
                value = getAlphalabel(parseInt(colIndex, 10)) + '$' + parseInt(rowIndex, 10);
            }
            else if (absIndex === '3') {
                value = '$' + getAlphalabel(parseInt(colIndex, 10)) + parseInt(rowIndex, 10);
            }
            else if (absIndex === '4') {
                value = getAlphalabel(parseInt(colIndex, 10)) + parseInt(rowIndex, 10);
            }
        }
        else if (refStyle === '0') {
            if (absIndex === '1') {
                value = 'R' + parseInt(rowIndex, 10) + 'C' + parseInt(colIndex, 10);
            }
            else if (absIndex === '2') {
                value = 'R' + parseInt(rowIndex, 10) + 'C[' + parseInt(colIndex, 10) + ']';
            }
            else if (absIndex === '3') {
                value = 'R[' + parseInt(rowIndex, 10) + ']C' + parseInt(colIndex, 10);
            }
            else if (absIndex === '4') {
                value = 'R[' + parseInt(rowIndex, 10) + ']C[' + parseInt(colIndex, 10) + ']';
            }
        }
        else {
            return errCollection[CommonErrors.Name];
        }
        let val;
        if (!isNullOrUndefined(argArr[4]) && argArr[4] !== '') {
            val = this.parent.getValueFromArg(argArr[4]).split(this.parent.tic).join('');
            if (errCollection.indexOf(val) > 0) {
                return val;
            }
        }
        if (!isNullOrUndefined(val)) {
            value = val + '!' + value;
        }
        return value;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the time.
     */
    ComputeTIME(...args) {
        let result;
        if (isNullOrUndefined(args) || args.length !== 3) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        if (args[0].indexOf(this.parent.tic) > -1 && args[0].split(this.parent.tic).join('').trim() === '') {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        else if (args[1].indexOf(this.parent.tic) > -1 && args[1].split(this.parent.tic).join('').trim() === '') {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        else if (args[2].indexOf(this.parent.tic) > -1 && args[2].split(this.parent.tic).join('').trim() === '') {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        let hours;
        let minutes;
        let seconds;
        if (this.parent.isCellReference(args[0])) {
            hours = this.parent.getValueFromArg(args[0].split(this.parent.tic).join('')) || '0';
            if (hours.indexOf(this.parent.tic) > -1) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        else {
            if (args[0].indexOf(this.parent.tic) > -1 && (args[0].split(this.parent.tic).join('') === this.parent.trueValue || args[0].split(this.parent.tic).join('') === this.parent.falseValue)) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            hours = this.parent.getValueFromArg(args[0]).split(this.parent.tic).join('') || '0';
        }
        if (this.parent.getErrorStrings().indexOf(hours) > -1) {
            return hours;
        }
        if (isNaN(this.parent.parseFloat(hours)) && !(hours === this.parent.trueValue || hours === this.parent.falseValue)) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        if (this.parent.isCellReference(args[1])) {
            minutes = this.parent.getValueFromArg(args[1].split(this.parent.tic).join('')) || '0';
            if (minutes.indexOf(this.parent.tic) > -1) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        else {
            if (args[1].indexOf(this.parent.tic) > -1 && (args[1].split(this.parent.tic).join('') === this.parent.trueValue || args[1].split(this.parent.tic).join('') === this.parent.falseValue)) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            minutes = this.parent.getValueFromArg(args[1]).split(this.parent.tic).join('') || '0';
        }
        if (this.parent.getErrorStrings().indexOf(minutes) > -1) {
            return minutes;
        }
        if (isNaN(this.parent.parseFloat(minutes)) && !(minutes === this.parent.trueValue || minutes === this.parent.falseValue)) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        if (this.parent.isCellReference(args[2])) {
            seconds = this.parent.getValueFromArg(args[2].split(this.parent.tic).join('')) || '0';
            if (seconds.indexOf(this.parent.tic) > -1) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        else {
            if (args[2].indexOf(this.parent.tic) > -1 && (args[2].split(this.parent.tic).join('') === this.parent.trueValue || args[2].split(this.parent.tic).join('') === this.parent.falseValue)) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            seconds = this.parent.getValueFromArg(args[2]).split(this.parent.tic).join('') || '0';
        }
        if (this.parent.getErrorStrings().indexOf(seconds) > -1) {
            return seconds;
        }
        if (isNaN(this.parent.parseFloat(seconds)) && !(seconds === this.parent.trueValue || seconds === this.parent.falseValue)) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        hours = hours === this.parent.trueValue ? '1' : (hours === this.parent.falseValue ? '0' : hours);
        minutes = minutes === this.parent.trueValue ? '1' : (minutes === this.parent.falseValue ? '0' : minutes);
        seconds = seconds === this.parent.trueValue ? '1' : (seconds === this.parent.falseValue ? '0' : seconds);
        hours = parseInt(this.parent.parseFloat(hours).toString(), 10);
        minutes = parseInt(this.parent.parseFloat(minutes).toString(), 10);
        seconds = parseInt(this.parent.parseFloat(seconds).toString(), 10);
        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        if (hours > 32767 || minutes > 32767 || seconds > 32767) {
            return this.parent.getErrorStrings()[CommonErrors.Num];
        }
        const value = new Date(1900, 0, 1, hours, minutes, seconds);
        if (value.getFullYear() < 1900) {
            return this.parent.getErrorStrings()[CommonErrors.Num];
        }
        const hh = value.getHours();
        let m = value.getMinutes();
        let s = value.getSeconds();
        let dd = 'AM';
        let h = hh;
        if (h >= 12) {
            h = hh - 12;
            dd = 'PM';
        }
        if (h === 0) {
            h = 12;
        }
        m = m < 10 ? '0' + m : m;
        s = s < 10 ? '0' + s : s;
        h = h < 10 ? '0' + h : h;
        result = h + ':' + m + ':' + s + ' ' + dd;
        const timeCheck = { value: result.toString() };
        this.parent.parentObject.notify(checkDateFormat, timeCheck);
        if (timeCheck.isTime) {
            result = timeCheck.updatedVal;
        }
        return result;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the char value.
     */
    ComputeCHAR(...args) {
        let value;
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(args) || args[0] === '') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args.length !== 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        let val = this.parent.getValueFromArg(args[0]).trim();
        if (errCollection.indexOf(val) > -1) {
            return val;
        }
        else if (val.indexOf('"TRUE"') > -1 || (this.parent.isCellReference(args[0]) &&
            val.startsWith(this.parent.tic))) {
            return errCollection[CommonErrors.Value];
        }
        val = val.split(this.parent.tic).join('');
        if (this.parent.isNumber(val)) {
            val = Math.floor(Number(val)).toString();
        }
        else if (val.indexOf('%') > -1) {
            val = Math.floor(Number(val.split('%')[0]) / 100).toString();
        }
        else if (val === this.parent.trueValue) {
            val = '1';
        }
        if (val.toUpperCase().match(/^[0-9]+$/)) {
            const char = parseInt(val, 10);
            if (char > 255 || char <= 0) {
                return errCollection[CommonErrors.Value];
            }
            value = String.fromCharCode(char);
        }
        else {
            return errCollection[CommonErrors.Value];
        }
        return value;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the code value.
     */
    ComputeCODE(...args) {
        let value;
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(args) || (args.length === 1 && args[0].trim() === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args.length > 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        value = this.parent.getValueFromArg(args[0]).trim();
        if (errCollection.indexOf(value) > -1) {
            return value;
        }
        if (args[0].indexOf(this.parent.tic) > -1) {
            if (args[0] !== value && args[0].startsWith('n')) {
                value = this.parent.removeTics(value.trim());
            }
            else {
                value = this.parent.removeTics(args[0].trim());
            }
        }
        else if (!args[0].startsWith('n') && value.split('%').length === 2 && this.parent.isNumber(value.split('%')[0])) {
            value = (Number(value.split('%')[0]) / 100).toString();
        }
        if (value !== '') {
            value = value.charCodeAt(0);
        }
        else {
            return errCollection[CommonErrors.Value];
        }
        return value;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the currency value.
     */
    ComputeDOLLAR(...args) {
        let value;
        let isEmpty;
        let nestedFormula;
        if (args.length && args[args.length - 1] === 'nestedFormulaTrue') {
            nestedFormula = true;
            args.pop();
        }
        if (args.length === 1) {
            if (args[0] === '') {
                isEmpty = true;
            }
            args.push('2');
        }
        if (isNullOrUndefined(args) || args.length !== 2 || isEmpty) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        for (let i = 0; i < args.length; i++) {
            if (args[i].indexOf(this.parent.tic) > -1) {
                if (isNaN(this.parent.parseFloat(args[i]))) {
                    return this.parent.getErrorStrings()[CommonErrors.Value];
                }
            }
        }
        let val = this.parent.getValueFromArg(args[0]).split(this.parent.tic).join('');
        let val2 = this.parent.getValueFromArg(args[1]).split(this.parent.tic).join('');
        val = val === '' || val === this.parent.falseValue ? '0' : val === this.parent.trueValue ? '1' : val;
        val2 = val2 === '' || val2 === this.parent.falseValue ? '0' : val2 === this.parent.trueValue ? '1' : val2;
        if (val === '#NAME?' || val2 === '#NAME?') {
            return this.parent.getErrorStrings()[CommonErrors.Name];
        }
        if (val.toUpperCase().match(/^[-]?[0-9.]+$/) && val2.toUpperCase().match(/^[-]?[0-9.]+$/)) {
            const intl = new Internationalization();
            const decimalCount = parseInt(val2, 10);
            const divisor = Math.pow(10, -1 * decimalCount);
            let decimalValue = '';
            for (let decimalIdx = 1; decimalIdx <= decimalCount; decimalIdx++) {
                decimalValue += '0';
            }
            const roundedNumber = Math.round(this.parent.parseFloat(val) / divisor) * divisor;
            if (!isNaN(roundedNumber)) {
                value = intl.formatNumber(roundedNumber, { format: '$#,##0.' + decimalValue + ';($#,##0.' + decimalValue + ');$0.' + decimalValue });
            }
            else {
                value = this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        else {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        if (nestedFormula) {
            value = this.parent.tic + value + this.parent.tic;
        }
        return value;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the k-th smallest value.
     */
    ComputeSMALL(...args) {
        let value;
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(args) || args.length === 1 || args[0] === '') {
            if ((args[0] === '') && (args[1] === '')) {
                return errCollection[CommonErrors.Num];
            }
            else {
                return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
            }
        }
        else if (args.length > 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        let cellCollection = [];
        const valueCollection = [];
        let numArr = [];
        if (!isNullOrUndefined(args[0])) {
            let originalValue;
            if (this.parent.isCellReference(args[0])) {
                cellCollection = this.parent.getCellCollection(args[0]);
                for (let i = 0; i < cellCollection.length; i++) {
                    originalValue = this.parent.getValueFromArg(cellCollection[i]);
                    if (errCollection.indexOf(originalValue) > -1) {
                        return originalValue;
                    }
                    valueCollection.push(originalValue);
                }
            }
            else {
                originalValue = this.parent.getValueFromArg(args[0]).split(this.parent.tic).join('');
                if (errCollection.indexOf(originalValue) > -1) {
                    return originalValue;
                }
                valueCollection.push(originalValue);
            }
            for (let i = 0; i < valueCollection.length; i++) {
                if (valueCollection[i] !== '' && !isNaN(this.parent.parseFloat(valueCollection[i]))) {
                    numArr.push(this.parent.parseFloat(valueCollection[i]));
                }
            }
            if (numArr.length === 0) {
                if (isNullOrUndefined(valueCollection[0]) || args[0].indexOf(this.parent.tic) > -1) {
                    return errCollection[CommonErrors.Value];
                }
            }
        }
        numArr = numArr.sort((n1, n2) => n1 - n2);
        let smallIndex;
        if (!isNullOrUndefined(args[1])) {
            if (this.parent.isCellReference(args[1])) {
                smallIndex = this.parent.getValueFromArg(args[1]);
                if (smallIndex === '') {
                    return errCollection[CommonErrors.Num];
                }
                else if (smallIndex.trim() === '') {
                    return errCollection[CommonErrors.Value];
                }
                if (smallIndex.toUpperCase() === this.parent.trueValue) {
                    smallIndex = '1';
                }
                else if (smallIndex.toUpperCase() === this.parent.falseValue) {
                    smallIndex = '0';
                }
            }
            else {
                smallIndex = this.parent.getValueFromArg(args[1]).split(this.parent.tic).join('');
            }
            if (errCollection.indexOf(smallIndex) > -1) {
                return smallIndex;
            }
            else if (smallIndex.trim() === '') {
                return args[1].length > 0 ? errCollection[CommonErrors.Value] : errCollection[CommonErrors.Num];
            }
            else if (isNaN(this.parent.parseFloat(smallIndex))) {
                if (args[1].toUpperCase() === this.parent.trueValue) {
                    smallIndex = '1';
                }
                else if (args[1].toUpperCase() === this.parent.falseValue) {
                    smallIndex = '0';
                }
                else {
                    return errCollection[CommonErrors.Value];
                }
            }
        }
        const finalIndex = (Number(smallIndex) < 1 ? 0 : Math.floor(Number(smallIndex)));
        if (isNullOrUndefined(numArr[finalIndex - 1]) && !isNaN(Number(finalIndex))) {
            return errCollection[CommonErrors.Num];
        }
        else {
            value = numArr[finalIndex - 1];
        }
        return value;
    }
    /**
     * @hidden
     * @param {string} args - specify the args.
     * @returns {string | boolean} - Compute the k-th largest value.
     */
    ComputeLARGE(...args) {
        let value;
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(args) || args.length === 1 || args[0] === '') {
            if ((args[0] === '') && (args[1] === '')) {
                return errCollection[CommonErrors.Num];
            }
            else {
                return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
            }
        }
        else if (args.length > 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        let cellCollection = [];
        const valueCollection = [];
        let numArr = [];
        if (!isNullOrUndefined(args[0])) {
            let originalValue;
            if (this.parent.isCellReference(args[0])) {
                cellCollection = this.parent.getCellCollection(args[0]);
                for (let i = 0; i < cellCollection.length; i++) {
                    originalValue = this.parent.getValueFromArg(cellCollection[i]);
                    if (errCollection.indexOf(originalValue) > -1) {
                        return originalValue;
                    }
                    valueCollection.push(originalValue);
                }
            }
            else {
                originalValue = this.parent.getValueFromArg(args[0]).split(this.parent.tic).join('');
                if (errCollection.indexOf(originalValue) > -1) {
                    return originalValue;
                }
                valueCollection.push(originalValue);
            }
            for (let i = 0; i < valueCollection.length; i++) {
                if (valueCollection[i] !== '' && !isNaN(this.parent.parseFloat(valueCollection[i]))) {
                    numArr.push(this.parent.parseFloat(valueCollection[i]));
                }
            }
            if (numArr.length === 0) {
                if (isNullOrUndefined(valueCollection[0]) || args[0].indexOf(this.parent.tic) > -1) {
                    return errCollection[CommonErrors.Value];
                }
            }
        }
        numArr = numArr.sort((n1, n2) => n2 - n1);
        let largeIndex;
        if (!isNullOrUndefined(args[1])) {
            if (this.parent.isCellReference(args[1])) {
                largeIndex = this.parent.getValueFromArg(args[1]);
                if (largeIndex === '') {
                    return errCollection[CommonErrors.Num];
                }
                else if (largeIndex.trim() === '') {
                    return errCollection[CommonErrors.Value];
                }
                if (largeIndex.toUpperCase() === this.parent.trueValue) {
                    largeIndex = '1';
                }
                else if (largeIndex.toUpperCase() === this.parent.falseValue) {
                    largeIndex = '0';
                }
            }
            else {
                largeIndex = this.parent.getValueFromArg(args[1]).split(this.parent.tic).join('');
            }
            if (errCollection.indexOf(largeIndex) > -1) {
                return largeIndex;
            }
            else if (largeIndex.trim() === '') {
                return args[1].length > 0 ? errCollection[CommonErrors.Value] : errCollection[CommonErrors.Num];
            }
            else if (isNaN(this.parent.parseFloat(largeIndex))) {
                if (args[1].toUpperCase() === this.parent.trueValue) {
                    largeIndex = '1';
                }
                else if (args[1].toUpperCase() === this.parent.falseValue) {
                    largeIndex = '0';
                }
                else {
                    return errCollection[CommonErrors.Value];
                }
            }
        }
        const finalIndex = (Number(largeIndex) < 1 ? 0 : Math.ceil(Number(largeIndex)));
        if (isNullOrUndefined(numArr[finalIndex - 1]) && !isNaN(Number(finalIndex))) {
            return errCollection[CommonErrors.Num];
        }
        else {
            value = numArr[finalIndex - 1];
        }
        return value;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {string | number} - Compute the Choose value.
     */
    ComputeCHOOSE(...args) {
        if (isNullOrUndefined(args) || (args[0] === '' && args.length === 1)) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args.length < 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const errCollection = this.parent.getErrorStrings();
        const processArgs = (actuaValue) => {
            actuaValue = this.parent.getValueFromArg(actuaValue);
            if (actuaValue.toUpperCase() === this.parent.trueValue) {
                actuaValue = '1';
            }
            else if (actuaValue.toUpperCase() === this.parent.falseValue) {
                actuaValue = '0';
            }
            return actuaValue;
        };
        let getIndexValue;
        getIndexValue = processArgs(args[0]);
        if (errCollection.indexOf(getIndexValue) > -1) {
            return getIndexValue;
        }
        if (this.parent.isCellReference(args[0])) {
            if (args[0].indexOf(':') > -1) {
                return errCollection[CommonErrors.Value];
            }
        }
        else {
            getIndexValue = this.parent.removeTics(getIndexValue);
            if (getIndexValue.split('%').length === 2 && this.parent.isNumber(getIndexValue.split('%')[0])) {
                getIndexValue = (Number(getIndexValue.split('%')[0]) * 0.01).toString();
            }
        }
        getIndexValue = Math.floor(this.parent.parseFloat(getIndexValue));
        if (getIndexValue < 1 || isNaN(getIndexValue) || isNullOrUndefined(args[getIndexValue])) {
            return errCollection[CommonErrors.Value];
        }
        getIndexValue = args[getIndexValue];
        if (getIndexValue === '') {
            getIndexValue = '0';
        }
        if (this.parent.isCellReference(getIndexValue)) {
            if (getIndexValue.indexOf(':') > -1) {
                return errCollection[CommonErrors.Value];
            }
            return this.parent.getValueFromArg(getIndexValue);
        }
        else {
            if (getIndexValue.indexOf(this.parent.tic) > -1 && (errCollection.indexOf(getIndexValue.split(this.parent.tic).join('')) > -1 ||
                (this.parent.removeTics(getIndexValue).match(/^(\d*\.\d+|\d+)\s*[-*/]\s*(\d*\.\d+|\d+)$/)))) {
                getIndexValue = this.parent.removeTics(getIndexValue);
            }
            getIndexValue = this.parent.removeTics(this.parent.getValueFromArg(getIndexValue));
            if (getIndexValue.indexOf(this.parent.tic + this.parent.tic) > -1) {
                return getIndexValue.replace(/""/g, this.parent.tic);
            }
            if (getIndexValue.split('%').length === 2 && this.parent.isNumber(getIndexValue.split('%')[0])) {
                getIndexValue = (Number(getIndexValue.split('%')[0]) * 0.01).toString();
            }
            return getIndexValue;
        }
    }
    /**
     * @hidden
     * @param {string[]} range - specify the range.
     * @returns {string | number} - Compute the SUMIF value.
     */
    ComputeSUMIF(...range) {
        const argArr = range;
        if (argArr[0].indexOf(':') < 0 && !this.parent.isCellReference(argArr[0]) ||
            (argArr[2] && argArr[2].indexOf(':') < 0 && !this.parent.isCellReference(argArr[2]))) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.ImproperFormula];
        }
        if (argArr.length > 3 || argArr.length < 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const result = this.parent.computeSumIfAndAvgIf(range, false);
        if (typeof result === 'string' && (this.parent.formulaErrorStrings.indexOf(result)
            || this.parent.getErrorStrings().indexOf(result))) {
            return result;
        }
        return result[0];
    }
    /**
     * @hidden
     * @param {string[]} absValue - specify the absValue.
     * @returns {string | number} - Compute the AVERAGE value.
     */
    ComputeABS(...absValue) {
        const argArr = absValue;
        let cellvalue = '';
        let absVal;
        if (absValue.length === 0 || absValue.length > 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        if (argArr[0] === '') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        const argVal = argArr[0].split(this.parent.tic).join('').trim();
        if (argVal === '' || (argArr[0].indexOf(this.parent.tic) > -1 && isNaN(this.parent.parseFloat(argVal)))) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        if (this.parent.isCellReference(argArr[0])) {
            cellvalue = this.parent.getValueFromArg(argArr[0]);
            if (this.parent.getErrorStrings().indexOf(cellvalue) > -1) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            if (cellvalue === this.parent.trueValue) {
                cellvalue = '1';
            }
            if (cellvalue === '' || cellvalue === this.parent.falseValue) {
                cellvalue = '0';
            }
            absVal = this.parent.parseFloat(cellvalue);
            if (isNaN(absVal) && !this.parent.isNumber(cellvalue)) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        else {
            cellvalue = this.parent.getValueFromArg(argArr[0]).split(this.parent.tic).join();
            if (cellvalue === this.parent.trueValue) {
                cellvalue = '1';
            }
            if (cellvalue === this.parent.falseValue) {
                cellvalue = '0';
            }
            if (this.parent.getErrorStrings().indexOf(cellvalue) > -1) {
                return cellvalue;
            }
            absVal = this.parent.parseFloat(cellvalue);
            if (isNaN(absVal) && !this.parent.isNumber(cellvalue)) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        return Math.abs(absVal);
    }
    /**
     * @hidden
     * @param {string[]} args - specify the range.
     * @returns {string} - Compute the AVERAGE value.
     */
    ComputeAVERAGE(...args) {
        let isSubtotalFormula = false;
        let isAggregateComputation;
        if (args.length) {
            const lastArgument = args[args.length - 1];
            if (lastArgument === 'isSubtotal') {
                isSubtotalFormula = true;
                args.pop();
            }
            else if (lastArgument === 'isAggregate') {
                isAggregateComputation = true;
                args.pop();
            }
        }
        if (isNullOrUndefined(args) || (args.length === 1 && args[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        const argArr = args;
        for (let i = 0; i < argArr.length; i++) {
            if (argArr[i].indexOf(':') > -1) {
                if (argArr[i].indexOf(this.parent.tic) > -1) {
                    return this.parent.getErrorStrings()[CommonErrors.Value];
                }
            }
        }
        return this.parent.calculateAvg(argArr, isSubtotalFormula, isAggregateComputation);
    }
    /**
     * @hidden
     * @param {string[]} range - specify the range.
     * @returns {string | number} - Compute the AVERAGEIF value.
     */
    ComputeAVERAGEIF(...range) {
        const argList = range;
        if (argList[0].indexOf(':') < 0 && !this.parent.isCellReference(argList[0])) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.ImproperFormula];
        }
        const resultVal = this.parent.computeSumIfAndAvgIf(range, true);
        if (resultVal[1] === 0 || resultVal[0].toString() === 'NaN') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.Div];
        }
        if (typeof resultVal === 'string' && (this.parent.formulaErrorStrings.indexOf(resultVal)
            || this.parent.getErrorStrings().indexOf(resultVal))) {
            return resultVal;
        }
        return this.parent.parseFloat(resultVal[0]) / this.parent.parseFloat(resultVal[1]);
    }
    /**
     * @hidden
     * @param {string[]} range - specify the range.
     * @returns {string} - Compute the CONCATENATE value.
     */
    ComputeCONCATENATE(...range) {
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(range) || (range.length === 1 && range[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        const argsList = range;
        let result = '';
        let tempStr = '';
        for (let i = 0; i < argsList.length; i++) {
            const val = argsList[i];
            if (this.parent.isCellReference(val)) {
                if (val.indexOf(':') > -1) {
                    if (this.isConcat) {
                        const cells = this.parent.getCellCollection(val);
                        for (let i = 0; i < cells.length; i++) {
                            const tempString = this.parent.getValueFromArg(cells[i]);
                            result = result + tempString;
                        }
                    }
                    else {
                        return errCollection[CommonErrors.Value];
                    }
                }
                else {
                    if (argsList.length === 1 && argsList[0].indexOf(this.parent.tic) < 0 &&
                        !isValidCellReference(argsList[0])) {
                        return errCollection[CommonErrors.Name];
                    }
                    else {
                        tempStr = this.parent.getValueFromArg(val);
                    }
                }
                if (errCollection.indexOf(tempStr) > -1) {
                    return tempStr;
                }
            }
            else {
                if (val.startsWith(this.parent.tic) && val.endsWith(this.parent.tic) && val.indexOf('""') > -1) {
                    tempStr = val.substring(1, val.length - 1);
                    tempStr = tempStr.replace(/""/g, '"');
                }
                else {
                    tempStr = val.split(this.parent.tic).join('');
                    if (!(!(this.parent.isNumber(tempStr)) && !isNullOrUndefined(this.parent.isDate(tempStr))) || val.startsWith(' n')) {
                        tempStr = this.parent.getValueFromArg(val).split(this.parent.tic).join('');
                    }
                }
                if (errCollection.indexOf(tempStr) > -1) {
                    return tempStr;
                }
            }
            result += tempStr;
        }
        this.isConcat = false;
        return result;
    }
    /**
     * @hidden
     * @param {string[]} range - specify the range.
     * @returns {string} - Compute the CONCAT value.
     */
    ComputeCONCAT(...range) {
        this.isConcat = true;
        return this.ComputeCONCATENATE(...range);
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {string | number} - Compute the MAX value.
     */
    ComputeMAX(...args) {
        return this.parent.computeMinMax(args, 'max');
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {string} - Compute the MIN value.
     */
    ComputeMIN(...args) {
        return this.parent.computeMinMax(args, 'min');
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {string} - Compute the RAND value.
     */
    ComputeRAND(...args) {
        if (args.length === 1 && args[0] === '') {
            args.length = 0;
        }
        if (args.length > 0) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        return Math.random().toString();
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {string} - Compute the AND value.
     */
    ComputeAND(...args) {
        const argArr = args;
        if (isNullOrUndefined(args) || (argArr.length === 1 && argArr[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        return this.parent.computeAndOrNot(argArr, 'and');
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {string} - Compute the OR value.
     */
    ComputeOR(...args) {
        const argArr = args;
        if (isNullOrUndefined(args) || (argArr.length === 1 && argArr[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        return this.parent.computeAndOrNot(argArr, 'or');
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {string} - Compute the NOT value.
     */
    ComputeNOT(...args) {
        const argArr = args;
        if (isNullOrUndefined(args) || (args.length > 1 || args[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        return this.parent.computeAndOrNot(argArr, 'not');
    }
    /**
     * @hidden
     * @param {string[]} args - specify the range.
     * @returns {string | number} - Compute the find value.
     */
    ComputeFIND(...args) {
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(args) || args.length === 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args.length > 3) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const processArgs = (actuaValue) => {
            let value = this.parent.getValueFromArg(actuaValue);
            if (errCollection.indexOf(value) > -1) {
                return value;
            }
            if (!this.parent.isCellReference(actuaValue)) {
                if (value.split('%').length === 2 && this.parent.isNumber(value.split('%')[0])) {
                    value = (Number(value.split('%')[0]) * 0.01).toString();
                }
                else if (actuaValue.indexOf(this.parent.tic) > -1) {
                    if (this.parent.removeTics(actuaValue).match(/^(\d*\.\d+|\d+)\s*[-*/]\s*(\d*\.\d+|\d+)$/)) {
                        value = this.parent.getValueFromArg(this.parent.removeTics(actuaValue));
                    }
                    else if (value.indexOf(this.parent.tic + this.parent.tic) > -1) {
                        value = value.replace(/""/g, this.parent.tic);
                    }
                }
            }
            return value;
        };
        let findText;
        if (!isNullOrUndefined(args[0])) {
            findText = processArgs(args[0]);
            if (errCollection.indexOf(findText) > -1) {
                return findText;
            }
            else if (!this.parent.isCellReference(args[0])) {
                findText = this.parent.removeTics(findText);
            }
        }
        let withinText;
        if (!isNullOrUndefined(args[1])) {
            withinText = processArgs(args[1]);
            if (errCollection.indexOf(withinText) > -1) {
                return withinText;
            }
            else if (!this.parent.isCellReference(args[1])) {
                withinText = this.parent.removeTics(withinText);
            }
        }
        let startNum = 1;
        if (!isNullOrUndefined(args[2])) {
            startNum = processArgs(args[2]);
            if (errCollection.indexOf(startNum) > -1) {
                return startNum;
            }
            else if (startNum.toUpperCase() === this.parent.trueValue) {
                startNum = '1';
            }
            else if (startNum.toUpperCase() === this.parent.falseValue) {
                startNum = '0';
            }
            if (!this.parent.isCellReference(args[2])) {
                startNum = this.parent.removeTics(startNum);
            }
            startNum = this.parent.parseFloat(startNum);
            if (isNaN(startNum) || startNum <= 0) {
                return errCollection[CommonErrors.Value];
            }
        }
        startNum = withinText.indexOf(findText, startNum - 1);
        if (startNum < 0) {
            return errCollection[CommonErrors.Value];
        }
        return (Number(startNum) + Number(1)).toString();
    }
    /**
     * @hidden
     * @param {string[]} argArr - specify the range.
     * @returns {string | number} - Compute the index.
     */
    ComputeINDEX(...argArr) {
        let nestedFormula;
        let value;
        const errCollection = this.parent.getErrorStrings();
        if (argArr.length && argArr[argArr.length - 1] === 'nestedFormulaTrue') {
            nestedFormula = true;
            argArr.pop();
        }
        if (isNullOrUndefined(argArr) || (argArr.length === 1 && argArr[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (argArr.length < 2 || argArr.length > 4) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        else if (argArr[0] === '') {
            return errCollection[CommonErrors.Value];
        }
        else if (argArr[0].indexOf(':') === -1) {
            return errCollection[CommonErrors.Ref];
        }
        let row;
        let col;
        const processArgs = (actualValue) => {
            if (isNullOrUndefined(actualValue) || actualValue === '') {
                return 1;
            }
            let value = this.parent.getValueFromArg(actualValue);
            if (errCollection.indexOf(value) > -1) {
                return value;
            }
            if (value.toUpperCase() === this.parent.trueValue) {
                value = '1';
            }
            else if (value.toUpperCase() === this.parent.falseValue) {
                value = '0';
            }
            if (value.indexOf(this.parent.tic) > -1) {
                value = this.parent.removeTics(value);
                if (actualValue.indexOf(this.parent.tic) === -1 || value.trim() === '') {
                    return errCollection[CommonErrors.Value];
                }
            }
            if (value.split('%').length === 2 && this.parent.isNumber(value.split('%')[0])) {
                value = (Number(value.split('%')[0]) / 100).toString();
            }
            value = parseInt(Number(value).toString(), 10);
            if (isNaN(value) || value < 0) {
                return errCollection[CommonErrors.Value];
            }
            else if (value === 0) {
                value = 1;
            }
            return value;
        };
        value = argArr[0];
        row = processArgs(argArr[1]);
        if (errCollection.indexOf(row.toString()) > -1) {
            return row.toString();
        }
        col = processArgs(argArr[2]);
        if (errCollection.indexOf(col.toString()) > -1) {
            return col.toString();
        }
        const i = value.indexOf(':');
        const startRow = this.parent.rowIndex(value.substring(0, i));
        const endRow = this.parent.rowIndex(value.substring(i + 1));
        const startCol = this.parent.colIndex(value.substring(0, i));
        const endCol = this.parent.colIndex(value.substring(i + 1));
        if (row > endRow - startRow + 1 || col > endCol - startCol + 1) {
            return errCollection[CommonErrors.Ref];
        }
        row = startRow + row - 1;
        col = startCol + col - 1;
        value = this.parent.getValueFromArg(this.getSheetReference(value) + this.parent.convertAlpha(col) + row);
        if (value === '') {
            return 0;
        }
        if (nestedFormula && errCollection.indexOf(value) === -1 &&
            !this.parent.isNumber(value) && value !== this.parent.trueValue && value !== this.parent.falseValue) {
            return this.parent.tic + value + this.parent.tic;
        }
        return value;
    }
    getSheetReference(range) {
        return range.indexOf(this.parent.sheetToken) === 0 && range.lastIndexOf(this.parent.sheetToken) > range.indexOf(this.parent.sheetToken) ? range.substring(0, range.lastIndexOf(this.parent.sheetToken) + 1) : '';
    }
    /**
     * @hidden
     * @param {string[]} range - specify the range.
     * @returns {string | number} - Compute the if.
     */
    ComputeIFS(...range) {
        const argArr = range;
        if (isNullOrUndefined(range) || (argArr.length === 1 && argArr[0] === '') || argArr.length % 2 !== 0) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        let condition = '';
        let result = '';
        for (let i = 0; i < argArr.length; i++) {
            condition = this.parent.getValueFromArg(argArr[i]);
            if (argArr[i] === '') {
                return this.parent.getErrorStrings()[CommonErrors.NA];
            }
            if (this.parent.getErrorStrings().indexOf(condition) > -1) {
                return condition;
            }
            if (condition !== this.parent.trueValue && condition !== this.parent.falseValue) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            if (condition === this.parent.trueValue) {
                if (this.parent.isCellReference(argArr[i + 1].split(this.parent.tic).join('')) || argArr[i + 1].includes(this.parent.arithMarker)) {
                    result = this.parent.getValueFromArg(argArr[i + 1]);
                    result = result === '' ? '0' : result;
                }
                else {
                    result = argArr[i + 1] === '' ? '0' : this.parent.getValueFromArg(argArr[i + 1]);
                    if (result.indexOf(this.parent.tic) > -1) {
                        result = result.split(this.parent.tic).join('');
                    }
                }
                i = i + 1;
                return result;
            }
            else if (condition === this.parent.falseValue) {
                i = i + 1;
            }
        }
        return this.parent.getErrorStrings()[CommonErrors.NA];
    }
    /**
     * @hidden
     * @param {string[]} args - specify the range.
     * @returns {number | string} - Compute the count.
     */
    ComputeCOUNTA(...args) {
        let isSubtotalFormula = false;
        let isAggregateComputation;
        let sheet;
        if (args.length) {
            const lastArgument = args[args.length - 1];
            if (lastArgument === 'isSubtotal') {
                isSubtotalFormula = true;
                args.pop();
            }
            else if (lastArgument === 'isAggregate') {
                sheet = this.parent.parentObject.getActiveSheet();
                isAggregateComputation = true;
                args.pop();
            }
        }
        if (isNullOrUndefined(args) || (args.length === 1 && args[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const argArr = args;
        let cellColl;
        let result = 0;
        let cellValue;
        let value;
        let indexes;
        for (let i = 0; i < argArr.length; i++) {
            if (this.parent.isCellReference(argArr[i])) {
                if (argArr[i].indexOf(':') > -1) {
                    cellColl = this.parent.getCellCollection(argArr[i].split(this.parent.tic).join(''));
                    for (let j = 0; j < cellColl.length; j++) {
                        if (isAggregateComputation) {
                            indexes = getCellIndexes(cellColl[j]);
                            if (isHiddenRow(sheet, indexes[0]) || isHiddenCol(sheet, indexes[1])) {
                                continue;
                            }
                        }
                        cellValue = !isSubtotalFormula ? this.parent.getValueFromArg(cellColl[j]) :
                            this.parent.getValueFromArg(cellColl[j], null, null, true);
                        if (isSubtotalFormula && cellValue.includes('SUBTOTAL(')) {
                            continue;
                        }
                        if (cellValue.length > 0) {
                            result++;
                        }
                    }
                }
                else {
                    cellValue = !isSubtotalFormula ? this.parent.getValueFromArg(argArr[i]) :
                        this.parent.getValueFromArg(argArr[i], null, null, true);
                    if (isSubtotalFormula && cellValue.includes('SUBTOTAL(')) {
                        continue;
                    }
                    if (cellValue.length > 0) {
                        result++;
                    }
                }
            }
            else {
                value = this.parent.getValueFromArg(argArr[i]).split(this.parent.tic).join('');
                if (value.length > 0) {
                    result++;
                }
                else if (value.length === 0 && value.trim() === '') {
                    result++;
                }
            }
        }
        return result;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the range.
     * @returns {number | string} - Compute the average.
     */
    ComputeAVERAGEA(...args) {
        if (isNullOrUndefined(args) || (args.length === 1 && args[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const argArrs = args;
        let cellCol;
        let result = 0;
        let cellValue;
        let value;
        let length = 0;
        let parseValue;
        for (let k = 0; k < argArrs.length; k++) {
            if (this.parent.isCellReference(argArrs[k])) {
                if (argArrs[k].indexOf(':') > -1) {
                    cellCol = this.parent.getCellCollection(argArrs[k].split(this.parent.tic).join(''));
                    for (let j = 0; j < cellCol.length; j++) {
                        cellValue = this.parent.getValueFromArg(cellCol[j]);
                        cellValue = this.processLogicalCellValue(cellValue);
                        if (this.parent.getErrorStrings().indexOf(cellValue) > -1) {
                            return cellValue;
                        }
                        else if (isNullOrUndefined(cellValue) || cellValue === '') {
                            continue;
                        }
                        parseValue = this.parent.parseFloat(cellValue);
                        cellValue = !isNaN(parseValue) ? parseValue : 0;
                        result += cellValue;
                        length = length + 1;
                    }
                }
                else {
                    cellValue = this.parent.getValueFromArg(argArrs[k]);
                    cellValue = this.processLogicalCellValue(cellValue);
                    if (this.parent.getErrorStrings().indexOf(cellValue) > -1) {
                        return cellValue;
                    }
                    else if (isNullOrUndefined(cellValue) || cellValue === '') {
                        continue;
                    }
                    parseValue = this.parent.parseFloat(cellValue);
                    cellValue = !isNaN(parseValue) ? parseValue : 0;
                    result += cellValue;
                    length = length + 1;
                }
            }
            else {
                if (argArrs[k].indexOf(this.parent.tic) > -1) {
                    if (isNaN(this.parent.parseFloat(argArrs[k].split(this.parent.tic).join(''))) ||
                        argArrs[k].split(this.parent.tic).join('').trim() === '') {
                        return this.parent.getErrorStrings()[CommonErrors.Value];
                    }
                }
                argArrs[k] = this.processLogicalCellValue(argArrs[k]);
                value = this.parent.getValueFromArg(argArrs[k].split(this.parent.tic).join(''));
                if (this.parent.getErrorStrings().indexOf(value) > -1) {
                    return value;
                }
                result += this.parent.parseFloat(value);
                length = length + 1;
            }
        }
        if (length === 0) {
            return this.parent.getErrorStrings()[CommonErrors.DivZero];
        }
        return result / length;
    }
    processLogicalCellValue(cellValue) {
        let value = cellValue;
        if (value.toUpperCase() === this.parent.trueValue) {
            value = '1';
        }
        else if (value.toUpperCase() === this.parent.falseValue) {
            value = '0';
        }
        return value;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the range.
     * @returns {number | string} - Compute the count if.
     */
    ComputeSORT(...args) {
        let nestedFormula;
        let isStringVal;
        if (args.length && args[args.length - 1] === 'nestedFormulaTrue') {
            nestedFormula = true;
            args.pop();
        }
        const argArr = args;
        let result;
        const values = [];
        if (isNullOrUndefined(args) || args[0] === '' || argArr.length > 4) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        argArr[1] = argArr[1] ? argArr[1] : '1';
        argArr[2] = argArr[2] ? argArr[2] : '1'; // 1 = Ascending, -1 = Descending. Default is ascending order.
        argArr[3] = argArr[3] ? argArr[3] : 'FALSE'; // Default is FALSE = sort by column or row
        argArr[0] = argArr[0].split('$').join('');
        let cellCollection;
        const valueCollection = [];
        if (argArr[0].indexOf(':') > -1) {
            const rangeSplit = argArr[0].split(':');
            if (this.parent.isCellReference(rangeSplit[0]) && this.parent.isCellReference(rangeSplit[1])) {
                const j = argArr[0].indexOf(':');
                let swap;
                let rowIdx = this.parent.rowIndex(this.parent.substring(argArr[0], 0, j));
                let colIdx = this.parent.colIndex(this.parent.substring(argArr[0], 0, j));
                let eRowIdx = this.parent.rowIndex(this.parent.substring(argArr[0], j + 1, j + argArr[0].length - j - 1));
                let eColIdx = this.parent.colIndex(this.parent.substring(argArr[0], j + 1, j + argArr[0].length - j - 1));
                if (rowIdx > eRowIdx) {
                    swap = eRowIdx;
                    eRowIdx = rowIdx;
                    rowIdx = swap;
                }
                if (colIdx > eColIdx) {
                    swap = eColIdx;
                    eColIdx = colIdx;
                    colIdx = swap;
                }
                if (this.parent.isCellReference(argArr[3])) {
                    argArr[3] = this.parent.getValueFromArg(argArr[3]).toUpperCase();
                    if (argArr[3] !== this.parent.trueValue && argArr[3] !== this.parent.falseValue) {
                        if (isNumber(argArr[3])) {
                            argArr[3] = Number(argArr[3]) === 0 ? this.parent.falseValue : this.parent.trueValue;
                        }
                        else if (argArr[3] === '') {
                            argArr[3] = this.parent.falseValue;
                        }
                        else {
                            return this.parent.getErrorStrings()[CommonErrors.Value];
                        }
                    }
                }
                else {
                    isStringVal = argArr[3].startsWith(this.parent.tic) && argArr[3].endsWith(this.parent.tic);
                    argArr[3] = this.parent.getValueFromArg(argArr[3]);
                    argArr[3] = isNumber(argArr[3]) ? (Number(argArr[3]) === 0 ? this.parent.falseValue : this.parent.trueValue) :
                        argArr[3].split(this.parent.tic).join('').toUpperCase();
                    if (argArr[3] !== this.parent.trueValue && argArr[3] !== this.parent.falseValue) {
                        return this.parent.getErrorStrings()[isStringVal ? CommonErrors.Value : CommonErrors.Name];
                    }
                }
                if (this.parent.isCellReference(argArr[2])) {
                    argArr[2] = this.parent.getValueFromArg(argArr[2]);
                    argArr[2] = argArr[2] === this.parent.trueValue ? '1' : argArr[2];
                }
                else {
                    argArr[2] = this.parent.getValueFromArg(argArr[2]);
                    argArr[2] = argArr[2] === this.parent.trueValue ? '1' : argArr[2].split(this.parent.tic).join('');
                }
                argArr[2] = isNumber(argArr[2]) ? Math.floor(Number(argArr[2])).toString() : argArr[2];
                if (argArr[2] !== '1' && argArr[2] !== '-1') {
                    return this.parent.getErrorStrings().indexOf(argArr[2]) > -1 ? this.parent.getErrorStrings()[CommonErrors.Name] :
                        this.parent.getErrorStrings()[CommonErrors.Value];
                }
                const order = argArr[2] === '1' ? 'Ascending' : 'Descending';
                if (this.parent.isCellReference(argArr[1])) {
                    argArr[1] = this.parent.getValueFromArg(argArr[1]);
                    argArr[1] = isNumber(argArr[1]) ? Math.floor(Number(argArr[1])).toString() : (argArr[1] === this.parent.trueValue ? '1'
                        : (argArr[1] === this.parent.falseValue ? '0' : argArr[1]));
                    if (!isNaN(this.parseDouble(argArr[1])) ? (this.parseDouble(argArr[1]) < 1 || (argArr[3] === this.parent.trueValue ?
                        (eRowIdx - rowIdx) + 1 < this.parseDouble(argArr[1]) : (eColIdx - colIdx) + 1 < this.parseDouble(argArr[1])))
                        : true) {
                        return this.parent.getErrorStrings()[CommonErrors.Value];
                    }
                }
                else {
                    isStringVal = argArr[1].startsWith(this.parent.tic) && argArr[1].endsWith(this.parent.tic);
                    argArr[1] = this.parent.getValueFromArg(argArr[1]);
                    argArr[1] = isNumber(argArr[1]) ? Math.floor(Number(argArr[1])).toString() : (argArr[1] === this.parent.trueValue ?
                        '1' : (argArr[1] === this.parent.falseValue ? '0' : argArr[1].split(this.parent.tic).join('')));
                    if (!isNaN(this.parseDouble(argArr[1])) ? (this.parseDouble(argArr[1]) < 1 || (argArr[3] === this.parent.trueValue ?
                        (eRowIdx - rowIdx) + 1 < this.parseDouble(argArr[1]) : (eColIdx - colIdx) + 1 < this.parseDouble(argArr[1])))
                        : isStringVal) {
                        return this.parent.getErrorStrings()[CommonErrors.Value];
                    }
                }
                let sheetIdx = '';
                if (argArr[0].indexOf('!') === 0) {
                    sheetIdx = argArr[0];
                    sheetIdx = sheetIdx.replace('!', '');
                    sheetIdx = sheetIdx.indexOf('!');
                    sheetIdx = argArr[0].substring(0, sheetIdx + 2);
                }
                argArr[0] = sheetIdx + getAlphalabel(colIdx) + rowIdx + ':' + getAlphalabel(eColIdx) + eRowIdx;
                cellCollection = this.parent.getCellCollection(argArr[0]);
                for (let i = 0; i < cellCollection.length; i++) {
                    valueCollection.push(this.parent.getValueFromArg(cellCollection[i]));
                }
                const colSort = [];
                const numColl = [];
                const strColl = [];
                const booleanColl = [];
                const emptyCellColl = [];
                const totalColumn = eColIdx - colIdx + 1;
                const sortRangeValuesHandler = (value) => {
                    if (value) {
                        if (value.toUpperCase() === 'TRUE' || value.toUpperCase() === 'FALSE') {
                            booleanColl.push(value);
                            colSort.push(value);
                        }
                        else if (isNaN(this.parseDouble(value))) {
                            strColl.push(value);
                            colSort.push(value);
                        }
                        else {
                            numColl.push(this.parseDouble(value));
                            colSort.push(this.parseDouble(value));
                        }
                    }
                    else if (value === '') {
                        emptyCellColl.push(this.parseDouble(value).toString());
                        colSort.push(this.parseDouble(value).toString());
                    }
                };
                if (argArr[3] === 'TRUE') {
                    for (let i = 0; i < totalColumn; i++) {
                        sortRangeValuesHandler(valueCollection[i + ((this.parseDouble(argArr[1]) - 1) * totalColumn)]);
                    }
                }
                if (argArr[3] === 'FALSE') {
                    for (let i = 0; i < valueCollection.length; i++) {
                        sortRangeValuesHandler(valueCollection[i * totalColumn + this.parseDouble(argArr[1]) - 1]);
                    }
                }
                const sortedNumColl = numColl.length > 0 ? DataUtil.sort(numColl, null, DataUtil.fnSort(order)) : [];
                const sortedStrColl = strColl.length > 0 ? DataUtil.sort(strColl, null, DataUtil.fnSort(order)) : [];
                const sortedBooleanColl = booleanColl.length > 0 ? DataUtil.sort(booleanColl, null, DataUtil.fnSort(order)) : [];
                const sortedVal = order === 'Ascending' ? sortedNumColl.concat(sortedStrColl, sortedBooleanColl, emptyCellColl) : sortedBooleanColl.concat(sortedStrColl, sortedNumColl, emptyCellColl);
                const id = [];
                for (let a = 0; a < sortedVal.length; a++) {
                    for (let b = 0; b < colSort.length; b++) {
                        if (JSON.stringify(sortedVal[a]) === JSON.stringify(colSort[b])) {
                            if (id.indexOf(b) === -1) {
                                id.push(b);
                            }
                        }
                    }
                }
                if (argArr[3] === 'TRUE') {
                    for (let startRow = rowIdx, rowInc = 0; startRow <= eRowIdx; startRow++, rowInc++) {
                        for (let a = 0, colInc = 0; a < id.length; a++, colInc++) {
                            let cellValue = this.parent.getValueFromArg(sheetIdx + getAlphalabel(id[a] + colIdx) + startRow);
                            if (nestedFormula && cellValue !== '') {
                                values.push(cellValue);
                                continue;
                            }
                            cellValue = cellValue === '' ? '0' : cellValue;
                            let activeCell = this.parent.actCell;
                            activeCell = activeCell.indexOf('!') > -1 ? activeCell.substring(activeCell.lastIndexOf('!') + 1) :
                                activeCell;
                            const actRowIdx = this.parent.rowIndex(activeCell);
                            const actColIdx = this.parent.colIndex(activeCell);
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            this.parent.parentObject.setValueRowCol(this.parent.getSheetID(this.parent.grid) + 1, cellValue, actRowIdx + rowInc, actColIdx + colInc);
                        }
                    }
                    result = this.parent.getValueFromArg(sheetIdx + getAlphalabel(id[0] + colIdx) + rowIdx);
                }
                if (argArr[3] === 'FALSE') {
                    for (let a = 0, rowInc = 0; a < id.length; a++, rowInc++) {
                        for (let startCol = colIdx, colInc = 0; startCol <= eColIdx; startCol++, colInc++) {
                            let value = this.parent.getValueFromArg(sheetIdx + getAlphalabel(startCol) + (id[a] + rowIdx));
                            if (nestedFormula && value !== '') {
                                values.push(value);
                                continue;
                            }
                            value = value === '' ? '0' : value;
                            let activeCell = this.parent.actCell;
                            activeCell = activeCell.indexOf('!') > -1 ? activeCell.substring(activeCell.lastIndexOf('!') + 1) :
                                activeCell;
                            const actColIdx = this.parent.colIndex(activeCell);
                            const actRowIdx = this.parent.rowIndex(activeCell);
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            this.parent.parentObject.setValueRowCol(this.parent.getSheetID(this.parent.grid) + 1, value, actRowIdx + rowInc, actColIdx + colInc);
                        }
                    }
                    result = this.parent.getValueFromArg(sheetIdx + getAlphalabel(colIdx) + (id[0] + rowIdx));
                }
            }
        }
        if (nestedFormula) {
            return values.join(',');
        }
        return result === '' ? '0' : result;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the range.
     * @returns {number | string} - Compute the count if.
     */
    ComputeCOUNTIF(...args) {
        const argArr = args;
        if (isNullOrUndefined(args) || args[0] === '' || argArr.length !== 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        if (argArr[0].indexOf(':') < 0 && !this.parent.isCellReference(argArr[0])) {
            return this.parent.getErrorStrings()[CommonErrors.Name];
        }
        let cellColl;
        let result = 0;
        let cellValue;
        const stack = [];
        let op = 'equal';
        if (argArr[1] === '') {
            return 0;
        }
        const isStringVal = argArr[1].startsWith(this.parent.tic) && argArr[1].endsWith(this.parent.tic);
        let condition = argArr[1].split(this.parent.tic).join('');
        const isAsterisk = condition.includes('*');
        const isAsteriskOnly = condition === '*' || condition === '<>*';
        let criteriaValue = isAsterisk && !isAsteriskOnly ? condition.replace(/\*/g, '').trim() : condition;
        let isCellReferenceValue = false;
        if (!isStringVal && this.parent.isCellReference(criteriaValue)) {
            criteriaValue = this.parent.getValueFromArg(criteriaValue);
            isCellReferenceValue = true;
        }
        if (isAsterisk && !isAsteriskOnly) {
            const asteriskIndex = condition.indexOf('*');
            if (condition[0] === '*') {
                criteriaValue = '*' + criteriaValue;
            }
            if (condition[condition.length - 1] === '*') {
                criteriaValue += '*';
            }
            if (asteriskIndex > 0 && asteriskIndex < condition.length - 1) {
                criteriaValue = condition.substring(0, asteriskIndex) + '*' + condition.substring(asteriskIndex + 1);
            }
        }
        condition = criteriaValue;
        if (condition.startsWith('<=')) {
            op = 'lessEq';
            condition = condition.substring(2);
        }
        else if (condition.startsWith('>=')) {
            op = 'greaterEq';
            condition = condition.substring(2);
        }
        else if (condition.startsWith('<>')) {
            op = 'notEq';
            condition = condition.substring(2);
        }
        else if (condition.startsWith('<')) {
            op = 'less';
            condition = condition.substring(1);
        }
        else if (condition.startsWith('>')) {
            op = 'greater';
            condition = condition.substring(1);
        }
        else if (condition.startsWith('=')) {
            op = 'equal';
            condition = condition.substring(1);
        }
        const isWildCardCondition = condition.indexOf('*') > -1 || condition.indexOf('?') > -1;
        if ((!isStringVal && this.parent.isCellReference(condition) && !isCellReferenceValue) || condition.includes(this.parent.arithMarker)
            || (condition.includes(this.parent.getParseDecimalSeparator()) && !isWildCardCondition)) {
            condition = this.parent.getValueFromArg(condition);
        }
        if (argArr[0].indexOf(':') > -1 && this.parent.isCellReference(argArr[0])) {
            cellColl = this.parent.getCellCollection(argArr[0].split(this.parent.tic).join(''));
            for (let j = 0; j < cellColl.length; j++) {
                cellValue = this.parent.getValueFromArg(cellColl[j]);
                if (isWildCardCondition) {
                    cellValue = this.parent.findWildCardValue(condition.toLowerCase(), cellValue.toLowerCase());
                }
                stack.push(cellValue);
                stack.push(condition);
                if (this.parent.processLogical(stack, op) === this.parent.trueValue) {
                    result++;
                }
            }
        }
        return result;
    }
    /**
     * @hidden
     * @param {string[]} range - specify the range.
     * @returns {string | number} - Compute the sum if.
     */
    ComputeSUMIFS(...range) {
        const sum = this.calculateIFS(range);
        return sum;
    }
    calculateIFS(ranges, isAvgIfs) {
        if (isNullOrUndefined(ranges) || ranges[0] === '' || ranges.length < 2 || ranges.length > 127) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        if (ranges.length === 3) { // SUMIFS and AVERAGEIFS OR operation will contains only 3 arguments.
            if (ranges[2].includes(this.parent.tic + this.parent.tic)) {
                let result = '';
                let sumVal;
                const separator = this.parent.getParseArgumentSeparator();
                const criterias = ranges[2].split(this.parent.tic + this.parent.tic);
                criterias.forEach((criteria) => {
                    criteria = criteria.trim().split(this.parent.tic).join('');
                    if (criteria) {
                        sumVal = this.parent.computeIfsFormulas([ranges[0], ranges[1], criteria], this.parent.falseValue, isAvgIfs).toString();
                        result += (result ? separator : '') + sumVal;
                    }
                });
                return result;
            }
        }
        return this.parent.computeIfsFormulas(ranges, this.parent.falseValue, isAvgIfs);
    }
    /**
     * @hidden
     * @param {string[]} args - specify the range.
     * @returns {string | number} - Compute the Text.
     */
    ComputeTEXT(...args) {
        let nestedFormula;
        if (args.length && args[args.length - 1] === 'nestedFormulaTrue') {
            nestedFormula = true;
            args.pop();
        }
        const argsLength = args.length;
        const firstArg = args[0];
        const secondArg = args[1];
        if (argsLength !== 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        let s1 = firstArg;
        let s2 = secondArg;
        if (secondArg === '') {
            return this.parent.getValueFromArg(s1);
        }
        let dTime = new Date(1900, 0, 1, 0, 0, 0);
        const checkString = s1 + ',' + s2;
        const intl = new Internationalization();
        if (this.parent.getErrorStrings().indexOf(checkString) > -1) {
            return checkString;
        }
        s1 = this.parent.getValueFromArg(s1);
        if (isNumber(s1.split(this.parent.tic).join(''))) {
            s1 = s1.split(this.parent.tic).join('');
        }
        if (secondArg.startsWith('"') && secondArg.endsWith('"')) {
            s2 = s2.split(this.parent.tic).join('');
        }
        else {
            s2 = this.parent.getValueFromArg(s2);
        }
        if (s2 === '') {
            return '';
        }
        if (s1 === '' && (s2.length > 0 && (s2.toUpperCase().indexOf('M') > -1 || s2.toUpperCase().indexOf('D') > -1
            || s2.toUpperCase().indexOf('Y') > -1 || s2.toUpperCase().indexOf('S') > -1 || s2.toUpperCase().indexOf('T') > -1)
            || s2.toUpperCase().indexOf('H') > -1)) {
            s1 = dTime.toString();
        }
        let d = this.parseDouble(s1);
        if (isNaN(d) && this.parent.isDate(new Date(s1)) !== null) {
            d = this.parent.toOADate(new Date(s1));
        }
        dTime = Date.parse(s1.split(this.parent.tic).join(''));
        if (!isNaN(d) || !isNaN(dTime)) {
            if (s2.length > 0 && s2.indexOf('#') === -1 && (s2.toUpperCase().indexOf('M') > -1 || s2.toUpperCase().indexOf('D') > -1
                || s2.toUpperCase().indexOf('Y') > -1 || s2.toUpperCase().indexOf('S') > -1 || s2.toUpperCase().indexOf('T') > -1)
                || s2.toUpperCase().indexOf('H') > -1) {
                s2 = s2.split('Y').join('y').split('D').join('d').split('H').join('h');
                s2 = s2.split('S').join('s').split('m').join('M').split('AM/PM').join('tt');
                const formatChar = s2.split('');
                let isH = false;
                let isMFound = false;
                let i = 0;
                // let mcount: number = 0;
                let lastCharIndex = 0;
                for (i = 0; i < formatChar.length;) {
                    const c = formatChar[i];
                    if (c === 's' && formatChar[lastCharIndex] === 'M') {
                        formatChar[lastCharIndex] = 'm';
                        if (formatChar[lastCharIndex - 1] === 'M') {
                            formatChar[lastCharIndex - 1] = 'm';
                        }
                    }
                    if (this.parent.isChar(c)) {
                        lastCharIndex = i;
                    }
                    if (c === 'M' && isH) {
                        formatChar[i] = 'm';
                        isMFound = true;
                    }
                    if (c === 'h') {
                        isH = true;
                    }
                    else if (this.parent.isChar(c) && c !== 'M' && c !== 'h' && !isMFound) {
                        isH = false;
                        isMFound = false;
                    }
                    i++;
                }
                s2 = String(formatChar);
                s2 = s2.split(',').join('').split('\n').join(' ');
                let dt = this.parent.fromOADate(d);
                if (d === 0) {
                    dt = dTime;
                }
                const getSkeleton = getSkeletonVal(s2);
                if (getSkeleton === '') {
                    const date = dateToInt(dt);
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const dateString = this.parent.parentObject.getDisplayText({ format: s2, value: date });
                    return dateString;
                }
                const dFormatter = intl.getDateFormat({ skeleton: getSkeleton, type: 'date' });
                const formattedString = dFormatter(new Date(dt.toString()));
                s1 = formattedString;
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                s1 = this.parent.parentObject.getDisplayText({ format: s2, value: d });
            }
        }
        return nestedFormula ? this.parent.tic + s1 + this.parent.tic : s1;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the range.
     * @returns {number | string} - Compute the count if.
     */
    ComputeCOUNTIFS(...args) {
        const sum = this.parent.computeIfsFormulas(args, this.parent.trueValue);
        return sum;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the range.
     * @returns {number | string} - Compute the Average if.
     */
    ComputeAVERAGEIFS(...args) {
        const sum = this.calculateIFS(args, this.parent.trueValue);
        return sum;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the range.
     * @returns {string | number} - Compute the Match.
     */
    ComputeMATCH(...args) {
        const argArr = [...args];
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(argArr) || (argArr.length === 1 && argArr[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (argArr.length < 2 || argArr.length > 3) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        // args[0] codes
        argArr[0] = this.parent.getValueFromArg(args[0]);
        let isStringValue = argArr[0].indexOf(this.parent.tic) > -1;
        argArr[0] = argArr[0].split(this.parent.tic).join('');
        if (errCollection.indexOf(argArr[0]) > -1) {
            return argArr[0];
        }
        if (argArr[0] === '') {
            return errCollection[CommonErrors.NA];
        }
        if (isNaN(Number(argArr[0]))) {
            isStringValue = true;
        }
        // args[2] codes
        let matchType;
        if (isNullOrUndefined(args[2])) {
            argArr[2] = '1';
        }
        else {
            argArr[2] = this.parent.getValueFromArg(argArr[2]);
            if ((argArr[2].indexOf(this.parent.tic) > -1) && isNaN(Number(argArr[2].split(this.parent.tic).join('')))) {
                return errCollection[CommonErrors.Value];
            }
            if (argArr[2].toUpperCase() === this.parent.trueValue) {
                argArr[2] = '1';
            }
            else if (argArr[2].toUpperCase() === this.parent.falseValue) {
                argArr[2] = '0';
            }
        }
        matchType = parseFloat(argArr[2]);
        if ([-1, 0, 1].indexOf(matchType) === -1) {
            matchType = 0;
        }
        // args[1] codes
        const valueCollection = [];
        let cellCollection;
        let isStringCollection = false;
        if (argArr[1].indexOf(':') > -1 || this.parent.isCellReference(argArr[1])) {
            cellCollection = this.parent.getCellCollection(argArr[1]);
            for (let j = 0; j < cellCollection.length; j++) {
                const cellValue = this.parent.getValueFromArg(cellCollection[j]);
                if (cellValue.indexOf(this.parent.tic) > -1 || isNaN(Number(cellValue))) {
                    isStringCollection = true;
                }
                valueCollection[j] = cellValue.split(this.parent.tic).join('');
            }
            if ((isStringValue && !isStringCollection) || (!isStringValue && isStringCollection)) {
                return errCollection[CommonErrors.NA];
            }
        }
        let index = 0;
        let indexVal = '';
        let isIndexFound = false;
        let matchValue = !isNaN(Number(argArr[0])) ? Number(argArr[0]) : argArr[0];
        for (let i = 0; i < valueCollection.length; i++) {
            if (valueCollection[i] === '') {
                if (i === (valueCollection.length - 1)) {
                    valueCollection.pop();
                }
                continue;
            }
            else if (matchType === -1 && (isStringValue || isStringCollection)) {
                break;
            }
            const matchCollectionValue = !isNaN(Number(valueCollection[i])) ?
                Number(valueCollection[i]) : valueCollection[i];
            if (matchType === 1) {
                if (matchValue === matchCollectionValue) {
                    index = i + 1;
                    isIndexFound = true;
                    if (isNaN(Number(argArr[0]))) {
                        isStringValue = false;
                    }
                }
                else if ((matchValue > matchCollectionValue) && !isStringValue && !isIndexFound) {
                    if (!indexVal || (matchCollectionValue > (!isNaN(Number(indexVal)) ? Number(indexVal) : indexVal))) {
                        index = i + 1;
                        indexVal = valueCollection[i];
                    }
                }
            }
            else if (matchType === 0) {
                if (argArr[0].indexOf('*') > -1 || argArr[0].indexOf('?') > -1) {
                    valueCollection[i] = this.parent.findWildCardValue(argArr[0], valueCollection[i]);
                }
                if (argArr[0] === valueCollection[i]) {
                    return i + 1;
                }
            }
            else if (matchType === -1) {
                if ((Number(valueCollection[i]) > Number(valueCollection[i + 1]))
                    || i === valueCollection.length - 1) {
                    if (matchValue === matchCollectionValue) {
                        index = i + 1;
                        matchValue = undefined;
                    }
                    else if (matchValue < matchCollectionValue) {
                        if (!indexVal || (matchCollectionValue < (!isNaN(Number(indexVal)) ? Number(indexVal) : indexVal))) {
                            index = i + 1;
                            indexVal = valueCollection[i];
                        }
                    }
                }
                else {
                    return errCollection[CommonErrors.NA];
                }
            }
        }
        if (isStringValue && isStringCollection && matchType === 1) {
            return valueCollection.length;
        }
        return index ? index : errCollection[CommonErrors.NA];
    }
    /**
     * @hidden
     * @param {string[]} range - specify the range.
     * @returns {string | number} - Compute the lookup value.
     */
    ComputeLOOKUP(...range) {
        const argArr = range;
        if (isNullOrUndefined(argArr) || (argArr.length === 1 && argArr[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        return this.parent.computeLookup(argArr);
    }
    /**
     * @hidden
     * @param {string[]} range - specify the range.
     * @returns {string | number} - Compute the vlookup value.
     */
    ComputeVLOOKUP(...range) {
        const argArr = range;
        return this.parent.computeVHLookup(argArr, true);
    }
    /**
     * @hidden
     * @param {string[]} range - specify the range.
     * @returns {string | number} - Compute the hlookup value.
     */
    ComputeHLOOKUP(...range) {
        const argArr = range;
        return this.parent.computeVHLookup(argArr);
    }
    /**
     * @hidden
     * @param {string[]} argArr - specify the range.
     * @returns {string | number} - Compute the sub total value.
     */
    ComputeSUBTOTAL(...argArr) {
        let value;
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(argArr) || (argArr.length === 1 && argArr[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (argArr.length < 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        value = this.parent.getValueFromArg(argArr[0]).trim();
        if (errCollection.indexOf(value) > -1) {
            return value;
        }
        if (value.split(this.parent.tic).join('').trim() === '') {
            return errCollection[CommonErrors.Value];
        }
        if (!this.parent.isCellReference(argArr[0])) {
            value = this.parent.removeTics(value);
        }
        if (value.toUpperCase() === this.parent.trueValue) {
            value = '1';
        }
        else if (value.toUpperCase() === this.parent.falseValue) {
            value = '0';
        }
        else if (value.split('%').length === 2 && this.parent.isNumber(value.split('%')[0])) {
            value = (Number(value.split('%')[0]) / 100).toString();
        }
        value = this.parent.parseFloat(value);
        if (isNaN(value) || ((1 > value || value > 11) && (101 > value || value > 111))) {
            return errCollection[CommonErrors.Value];
        }
        const cellRef = argArr.slice(1, argArr.length);
        switch (value) {
            case 1:
            case 101:
                value = this.ComputeAVERAGE(...cellRef, 'isSubtotal');
                break;
            case 2:
            case 102:
                value = this.ComputeCOUNT(...cellRef, 'isSubtotal');
                break;
            case 3:
            case 103:
                value = this.ComputeCOUNTA(...cellRef, 'isSubtotal');
                break;
            case 4:
            case 104:
                value = this.ComputeMAX(...cellRef, 'isSubtotal');
                break;
            case 5:
            case 105:
                value = this.ComputeMIN(...cellRef, 'isSubtotal');
                break;
            case 6:
            case 106:
                value = this.ComputePRODUCT(...cellRef, 'isSubtotal');
                break;
            case 7:
            case 107:
                value = this.ComputeDAY(...cellRef);
                break;
            case 8:
            case 108:
                value = this.ComputeCONCAT(...cellRef);
                break;
            case 9:
            case 109:
                value = this.ComputeSUM(...cellRef, 'isSubtotal');
                break;
            case 10:
            case 110:
                value = this.ComputeAVERAGEA(...cellRef);
                break;
            case 11:
            case 111:
                value = this.ComputeABS(...cellRef);
                break;
            default:
                value = errCollection[CommonErrors.Value];
                break;
        }
        return value;
    }
    /**
     * @hidden
     * @param {string[]} argValue - specify the range.
     * @returns {string | number} - Compute the Radians value.
     */
    ComputeRADIANS(...argValue) {
        let value;
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(argValue) || (argValue[0] === '' && argValue.length === 1) ||
            (argValue[0].split('!').length === 2 && argValue[0].indexOf(this.parent.tic) === -1)) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (argValue.length > 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        else if (argValue[0].indexOf(':') > -1 || argValue[0].split(this.parent.tic).join('').trim() === '' ||
            argValue[0].split(this.parent.tic).join('').trim() === '!' || argValue[0].split('!').length === 2) {
            return errCollection[CommonErrors.Value];
        }
        value = this.parent.getValueFromArg(argValue[0]).trim();
        if (errCollection.indexOf(value) > -1) {
            return value;
        }
        if ((value.indexOf(this.parent.tic) > -1 && argValue[0].indexOf(this.parent.tic) === -1) ||
            value.split(this.parent.tic).length > 3) {
            return errCollection[CommonErrors.Value];
        }
        if (value.toUpperCase() === this.parent.trueValue) {
            value = '1';
        }
        else if (value.toUpperCase() === this.parent.falseValue) {
            value = '0';
        }
        else if (value.split('%').length === 2 && this.parent.isNumber(value.split('%')[0])) {
            value = (Number(value.split('%')[0]) / 100).toString();
        }
        value = this.parent.parseFloat(value.split(this.parent.tic).join(''));
        if (!isNaN(value)) {
            value = Math.PI * (value) / 180;
        }
        else {
            if (this.parent.isCellReference(argValue[0]) || argValue[0].indexOf(this.parent.tic) > -1) {
                return errCollection[CommonErrors.Value];
            }
            else {
                return errCollection[CommonErrors.Name];
            }
        }
        return value;
    }
    /**
     * @hidden
     * @param {string[]} args - specify the range.
     * @returns {string | number} - Compute the random between value.
     */
    ComputeRANDBETWEEN(...args) {
        let min;
        let max;
        if (args.length === 1 && args[0] === '') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (args.length !== 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const errCollection = this.parent.getErrorStrings();
        const processArgs = (orgValue) => {
            let actualValue;
            actualValue = this.parent.getValueFromArg(orgValue);
            if (errCollection.indexOf(actualValue) > -1) {
                return actualValue;
            }
            if (this.parent.isCellReference(orgValue)) {
                if (actualValue === '') {
                    actualValue = '0';
                }
                else if (orgValue.indexOf(':') > -1 || actualValue.match(/^(\d*\.\d+|\d+)\s*[+\-*/]\s*(\d*\.\d+|\d+)$/)) {
                    return errCollection[CommonErrors.Value];
                }
            }
            else {
                if (actualValue === '') {
                    return errCollection[CommonErrors.NA];
                }
                else if (orgValue.indexOf(this.parent.tic) > -1 && this.parent.removeTics(orgValue).match(/^(\d*\.\d+|\d+)\s*[+*]\s*(\d*\.\d+|\d+)$/)) {
                    return errCollection[CommonErrors.Value];
                }
                else if (actualValue.indexOf(this.parent.tic) > -1) {
                    actualValue = this.parent.removeTics(actualValue);
                    if (actualValue.indexOf(':') > -1) {
                        const values = actualValue.split(':');
                        if (values.length <= 3) {
                            if (!this.parent.isNumber(values[0]) || !this.parent.isNumber(values[1])) {
                                return errCollection[CommonErrors.Value];
                            }
                            let hours = Number(values[0]) + Number((Number(values[1]) / 60));
                            if (values.length === 3) {
                                if (!this.parent.isNumber(values[2])) {
                                    return errCollection[CommonErrors.Value];
                                }
                                hours += Number(Number(values[2]) / 3600);
                            }
                            actualValue = (hours / 24).toString();
                        }
                        else {
                            return errCollection[CommonErrors.Value];
                        }
                    }
                }
                if (actualValue.split('%').length === 2 && this.parent.isNumber(actualValue.split('%')[0])) {
                    actualValue = (Number(actualValue.split('%')[0]) * 0.01).toString();
                }
            }
            actualValue = parseFloat(actualValue);
            if (isNaN(actualValue)) {
                return errCollection[CommonErrors.Value];
            }
            return actualValue;
        };
        max = processArgs(args[1]);
        if (errCollection.indexOf(max) > -1) {
            return max;
        }
        min = processArgs(args[0]);
        if (errCollection.indexOf(min) > -1) {
            return min;
        }
        if (min === 0 && max === 0) {
            return '0';
        }
        else if (max < min) {
            return errCollection[CommonErrors.Num];
        }
        else {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor((Math.random() * ((max - min) + 1)) + min);
        }
    }
    /**
     * @hidden
     * @param {string[]} argValue - specify the range.
     * @returns {string | number} - Compute the slope value.
     */
    ComputeSLOPE(...argValue) {
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(argValue) || (argValue.length === 1 && argValue[0].trim() === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (argValue.length !== 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        else if (argValue[0] === '' || argValue[1] === '') {
            return errCollection[CommonErrors.Value];
        }
        const cellCollection = (actuaValue) => {
            if (actuaValue.indexOf(this.parent.tic) === -1) {
                actuaValue = this.parent.getCellCollection(actuaValue.split(this.parent.tic).join(''));
            }
            else {
                actuaValue = undefined;
            }
            return actuaValue;
        };
        let yPoints = cellCollection(argValue[0].trim());
        let xPoints = cellCollection(argValue[1].trim());
        if (isNullOrUndefined(yPoints) || isNullOrUndefined(xPoints) || (yPoints.length < 2 && xPoints.length < 2)) {
            return errCollection[CommonErrors.DivZero];
        }
        else if (yPoints.length !== xPoints.length) {
            return errCollection[CommonErrors.NA];
        }
        const dataCollection = (actuaValue) => {
            actuaValue = this.getDataCollection(actuaValue);
            for (let b = 0; b < actuaValue.length; b++) {
                if (errCollection.indexOf(actuaValue[b]) > -1) {
                    return actuaValue[b].toString();
                }
            }
            return actuaValue;
        };
        yPoints = dataCollection(yPoints);
        if (errCollection.indexOf(yPoints.toString()) > -1) {
            return yPoints.toString();
        }
        xPoints = dataCollection(xPoints);
        if (errCollection.indexOf(xPoints.toString()) > -1) {
            return xPoints.toString();
        }
        let sumXY = 0;
        let sumX2 = 0;
        let sumX = 0;
        let sumY = 0;
        let length = 0;
        for (let i = 0, len = xPoints.length; i < len; ++i) {
            if ((xPoints[i] !== '' && Number(xPoints[i]).toString() !== 'NaN') &&
                (yPoints[i] !== '' && Number(yPoints[i]).toString() !== 'NaN')) {
                sumXY += Number(xPoints[i]) * Number(yPoints[i]);
                sumX += Number(xPoints[i]);
                sumY += Number(yPoints[i]);
                sumX2 += Number(xPoints[i]) * Number(xPoints[i]);
                length++;
            }
        }
        const value = ((sumXY - (sumX * sumY) / length) / (sumX2 - (sumX * sumX) / length)).toString();
        if (value === 'NaN') {
            return errCollection[CommonErrors.DivZero];
        }
        return value;
    }
    /**
     * @hidden
     * @param {string[]} argValue - specify the range.
     * @returns {string | number} - Compute the intercept.
     */
    ComputeINTERCEPT(...argValue) {
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(argValue) || (argValue.length === 1 && argValue[0].trim() === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (argValue.length !== 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        else if (argValue[0] === '' || argValue[1] === '') {
            return errCollection[CommonErrors.Value];
        }
        const cellCollection = (actuaValue) => {
            if (actuaValue.indexOf(this.parent.tic) === -1) {
                actuaValue = this.parent.getCellCollection(actuaValue.split(this.parent.tic).join(''));
            }
            else {
                actuaValue = undefined;
            }
            return actuaValue;
        };
        let yValues = cellCollection(argValue[0].trim());
        let xValues = cellCollection(argValue[1].trim());
        if (isNullOrUndefined(yValues) || isNullOrUndefined(xValues) || (yValues.length < 2 && xValues.length < 2)) {
            return errCollection[CommonErrors.DivZero];
        }
        else if (yValues.length !== xValues.length) {
            return errCollection[CommonErrors.NA];
        }
        const dataCollection = (actuaValue) => {
            actuaValue = this.getDataCollection(actuaValue);
            for (let b = 0; b < actuaValue.length; b++) {
                if (errCollection.indexOf(actuaValue[b]) > -1) {
                    return actuaValue[b];
                }
            }
            return actuaValue;
        };
        yValues = dataCollection(yValues);
        if (errCollection.indexOf(yValues.toString()) > -1) {
            return yValues.toString();
        }
        xValues = dataCollection(xValues);
        if (errCollection.indexOf(xValues.toString()) > -1) {
            return xValues.toString();
        }
        let sumY = 0;
        let sumX = 0;
        let length = 0;
        let sumXY = 0;
        let sumX2 = 0;
        let diff;
        const calculation = (isSum) => {
            for (let i = 0, len = xValues.length; i < len; ++i) {
                if ((yValues[i] !== '' && Number(yValues[i]).toString() !== 'NaN') &&
                    (xValues[i] !== '' && Number(xValues[i]).toString() !== 'NaN')) {
                    if (isSum) {
                        sumY += Number(yValues[i]);
                        sumX += Number(xValues[i]);
                        length++;
                    }
                    else {
                        diff = Number(xValues[i]) - sumX;
                        sumXY += diff * (Number(yValues[i]) - sumY);
                        sumX2 += diff * diff;
                    }
                }
            }
        };
        calculation(true);
        sumY = sumY / length;
        sumX = sumX / length;
        calculation(false);
        const value = (sumY - sumXY / sumX2 * sumX).toString();
        if (value === 'NaN') {
            return errCollection[CommonErrors.DivZero];
        }
        return value;
    }
    /**
     * @hidden
     * @param {string[]} logValue - specify the log value.
     * @returns {string | number} - Compute the value.
     */
    ComputeLN(...logValue) {
        let cellvalue;
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(logValue) || (logValue[0] === '' && logValue.length === 1)) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (logValue.length === 0 || logValue.length > 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        cellvalue = this.parent.getValueFromArg(logValue[0]);
        if (errCollection.indexOf(cellvalue) > -1) {
            return cellvalue;
        }
        if (cellvalue.toUpperCase() === this.parent.trueValue) {
            cellvalue = '1';
        }
        else if (cellvalue.toUpperCase() === this.parent.falseValue) {
            cellvalue = '0';
        }
        if (!this.parent.isCellReference(logValue[0])) {
            cellvalue = this.parent.removeTics(cellvalue);
            if (cellvalue.trim() === '') {
                return errCollection[CommonErrors.Value];
            }
        }
        if (cellvalue.split('%').length === 2 && this.parent.isNumber(cellvalue.split('%')[0])) {
            cellvalue = (Number(cellvalue.split('%')[0]) * 0.01).toString();
        }
        cellvalue = this.parent.parseFloat(cellvalue);
        if (cellvalue <= 0) {
            return errCollection[CommonErrors.Num];
        }
        else if (isNaN(cellvalue)) {
            return errCollection[CommonErrors.Value];
        }
        return Math.log(cellvalue);
    }
    /**
     * @hidden
     * @param {string[]} logValue - specify the log value.
     * @returns {boolean | string} - Compute the Isnumber value.
     */
    ComputeISNUMBER(...logValue) {
        const argArr = logValue;
        if (logValue.length === 1 && logValue[0] === '') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (logValue.length !== 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const orgValue = (this.parent.isCellReference(argArr[0])) ? this.parent.getValueFromArg(argArr[0]) :
            this.parent.getValueFromArg(argArr[0].split(this.parent.tic).join(''));
        if (orgValue.toString() === '' || logValue.toString().startsWith(this.parent.tic)) {
            return false;
        }
        const logVal = this.parent.parseFloat(orgValue);
        return !isNaN(logVal) ? true : false;
    }
    /**
     * @hidden
     * @param {string[]} logValue - specify the log value.
     * @returns {number | string} - Compute the round value.
     */
    ComputeROUND(...logValue) {
        if (!logValue.length || logValue.length === 1 || logValue.length > 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const argArr = logValue;
        if (logValue.length === 1) {
            const orgValue = (argArr[0].split(this.parent.tic).join('') === 'TRUE')
                ? '1'
                : (argArr[0].split(this.parent.tic).join('') === 'FALSE')
                    ? '0'
                    : argArr[0];
            if (isNaN(this.parent.parseFloat(orgValue))) {
                return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
            }
            return Math.round(this.parent.parseFloat(orgValue)).toString();
        }
        let numStr = this.parent.getValueFromArg(argArr[0]);
        if (this.parent.getErrorStrings().indexOf(numStr) > -1) {
            return numStr;
        }
        let digStr = this.parent.getValueFromArg(argArr[1]);
        if (this.parent.getErrorStrings().indexOf(digStr) > -1) {
            return digStr;
        }
        numStr = numStr === 'TRUE' ? '1' : numStr === 'FALSE' ? '0' : numStr;
        digStr = digStr === 'TRUE' ? '1' : digStr === 'FALSE' ? '0' : digStr;
        numStr = numStr.split(this.parent.tic).join('');
        digStr = digStr.split(this.parent.tic).join('');
        const isInvalidNumStr = isNaN(Number(numStr)) || numStr.trim() === '';
        const isInvalidDigStr = isNaN(Number(digStr)) || digStr.trim() === '';
        if (((argArr[0].indexOf('"') > -1 || this.parent.isCellReference(argArr[0])) && isInvalidNumStr)
            || ((argArr[1].indexOf('"') > -1 || this.parent.isCellReference(argArr[1])) && isInvalidDigStr)) {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        if ((numStr === '' && digStr === '') || numStr === '') {
            return 0;
        }
        const x = this.parent.parseFloat(numStr);
        const digits = this.parent.parseFloat(digStr);
        let round;
        if (!isNaN(digits) && !isNaN(x) && digits > 0) {
            round = this.parent.parseFloat(this.preciseRound(x, digits, 'ROUND'));
        }
        else {
            const mult = Math.pow(10, -digits);
            round = Math.round(x / mult) * mult;
        }
        return round.toString();
    }
    preciseRound(numValue, decimalValue, formula) {
        const factor = Math.pow(10, decimalValue);
        const absValue = Math.abs(numValue) * factor;
        const sign = numValue >= 0 ? 1 : -1;
        const result = formula === 'ROUND' ? Math.round(absValue) : formula === 'ROUNDDOWN' ?
            Math.floor(absValue) : Math.ceil(absValue);
        return (sign * (result / factor)).toFixed(decimalValue);
    }
    /**
     * @hidden
     * @param {string[]} argArr - specify the log value.
     * @returns {boolean | string} - Compute the power value.
     */
    ComputePOWER(...argArr) {
        let power;
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(argArr) || (argArr.length === 1 && argArr[0].trim() === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (argArr.length > 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        else if (argArr[0].trim() === '' && argArr[1].trim() === '') {
            return errCollection[CommonErrors.Num];
        }
        const processArgs = (actualValue) => {
            let value = this.parent.getValueFromArg(actualValue);
            if (errCollection.indexOf(value) > -1) {
                return value;
            }
            if (value.toUpperCase() === this.parent.trueValue) {
                value = '1';
            }
            else if (value.toUpperCase() === this.parent.falseValue) {
                value = '0';
            }
            if (value.indexOf(this.parent.tic) > -1) {
                value = this.parent.removeTics(value);
                if (actualValue.indexOf(this.parent.tic) === -1 || value.trim() === '') {
                    return errCollection[CommonErrors.Value];
                }
            }
            if (value.split('%').length === 2 && this.parent.isNumber(value.split('%')[0])) {
                value = (Number(value.split('%')[0]) / 100).toString();
            }
            else if (value.indexOf('/') > -1 && this.parent.isNumber(value.split('/').join(''))) {
                return errCollection[CommonErrors.Num];
            }
            value = this.parent.parseFloat(value);
            if (isNaN(value)) {
                return errCollection[CommonErrors.Value];
            }
            return value;
        };
        const numValue = processArgs(argArr[0]);
        if (errCollection.indexOf(numValue) > -1) {
            return numValue;
        }
        const powValue = processArgs(argArr[1]);
        if (errCollection.indexOf(powValue) > -1) {
            return powValue;
        }
        if (!isNaN(numValue) && !isNaN(powValue)) {
            if (numValue === 0 && powValue < 0) {
                return errCollection[CommonErrors.DivZero];
            }
            if (numValue === 0 && powValue === 0) {
                return errCollection[CommonErrors.Num];
            }
            power = Math.pow(numValue, powValue);
            if (isNaN(power) || power === Infinity) {
                return errCollection[CommonErrors.Num];
            }
        }
        else {
            return errCollection[CommonErrors.Value];
        }
        return power.toString();
    }
    /**
     * @hidden
     * @param {string[]} args - specify the args.
     * @returns {number | string} - Computes a positive square root of the given number.
     */
    ComputeSQRT(...args) {
        let sqrtValue;
        const arrValue = args[0];
        if (args.length === 0 || args.length > 1 || arrValue === '') {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        else if (arrValue.split(this.parent.tic).join('').trim() === '') {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        if (this.parent.isCellReference(arrValue)) {
            sqrtValue = this.parent.getValueFromArg(arrValue) || '0';
            if (sqrtValue.indexOf(this.parent.tic) > -1) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        else {
            if (arrValue.indexOf(this.parent.tic) > -1 && (arrValue.split(this.parent.tic).join('') === this.parent.trueValue ||
                arrValue.split(this.parent.tic).join('') === this.parent.falseValue)) {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
            sqrtValue = this.parent.getValueFromArg(arrValue).split(this.parent.tic).join('');
        }
        if (this.parent.getErrorStrings().indexOf(sqrtValue) > -1) {
            return sqrtValue;
        }
        sqrtValue = sqrtValue === this.parent.trueValue ? '1' : sqrtValue === this.parent.falseValue ? '0' : sqrtValue;
        if (this.parent.parseFloat(sqrtValue) < 0) {
            return this.parent.getErrorStrings()[CommonErrors.Num];
        }
        else if (isNaN(this.parent.parseFloat(sqrtValue))) {
            const dateTimeCheck = { value: sqrtValue };
            this.parent.parentObject.notify(checkDateFormat, dateTimeCheck);
            if (dateTimeCheck.isDate || dateTimeCheck.isTime) {
                sqrtValue = dateTimeCheck.updatedVal;
            }
            else {
                return this.parent.getErrorStrings()[CommonErrors.Value];
            }
        }
        return Math.sqrt(this.parent.parseFloat(sqrtValue));
    }
    /**
     * @hidden
     * @param {string[]} logValue - specify the log value.
     * @returns {number | string} - Compute the log value.
     */
    ComputeLOG(...logValue) {
        let orgNumValue;
        let orgBaseValue;
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(logValue) || (logValue.length === 1 && logValue[0] === '')) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (logValue.length > 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const processArgs = (orgValue) => {
            let actualValue = this.parent.getValueFromArg(orgValue);
            if (actualValue === this.parent.trueValue) {
                actualValue = '1';
            }
            else if (actualValue === this.parent.falseValue) {
                actualValue = '0';
            }
            if (!this.parent.isCellReference(orgValue) && actualValue !== '') {
                if (actualValue.indexOf(this.parent.tic) > -1 && errCollection.indexOf(actualValue.split(this.parent.tic).join('')) === -1) {
                    actualValue = this.parent.removeTics(actualValue);
                    if (actualValue.trim() === '') {
                        return errCollection[CommonErrors.Value];
                    }
                    else if (actualValue.indexOf(':') > -1) {
                        const values = actualValue.split(':');
                        if (values.length <= 3) {
                            if (!this.parent.isNumber(values[0]) || !this.parent.isNumber(values[1])) {
                                return errCollection[CommonErrors.Value];
                            }
                            let hours = Number(values[0]) + Number((Number(values[1]) / 60));
                            if (values.length === 3) {
                                if (!this.parent.isNumber(values[2])) {
                                    return errCollection[CommonErrors.Value];
                                }
                                hours += Number(Number(values[2]) / 3600);
                            }
                            actualValue = (hours / 24).toString();
                        }
                        else {
                            return errCollection[CommonErrors.Value];
                        }
                    }
                }
                if (actualValue.split('%').length === 2 && this.parent.isNumber(actualValue.split('%')[0])) {
                    actualValue = (Number(actualValue.split('%')[0]) * 0.01).toString();
                }
            }
            return actualValue;
        };
        if (!isNullOrUndefined(logValue[0])) {
            orgNumValue = processArgs(logValue[0]);
            if (errCollection.indexOf(orgNumValue) > -1) {
                return orgNumValue;
            }
            orgNumValue = this.parent.parseFloat(orgNumValue);
        }
        orgBaseValue = 10;
        if (!isNullOrUndefined(logValue[1])) {
            orgBaseValue = processArgs(logValue[1]);
            if (errCollection.indexOf(orgBaseValue) > -1) {
                return orgBaseValue;
            }
            orgBaseValue = this.parent.parseFloat(orgBaseValue);
        }
        orgNumValue = Number(orgNumValue);
        if (isNaN(orgNumValue) || isNaN(orgBaseValue)) {
            return errCollection[CommonErrors.Value];
        }
        else if (orgNumValue <= 0 || orgBaseValue <= 0) {
            return errCollection[CommonErrors.Num];
        }
        else if (orgBaseValue === 1) {
            return errCollection[CommonErrors.DivZero];
        }
        return ((Math.log(orgNumValue) / Math.LN10) / (Math.log(orgBaseValue) / Math.LN10)).toString();
    }
    /**
     * @hidden
     * @param {string[]} logValue - specify the log value.
     * @returns {boolean | string} - Compute the trunc value.
     */
    ComputeTRUNC(...logValue) {
        let orgNumValue;
        let orgDigitValue = 0;
        const errCollection = this.parent.getErrorStrings();
        if (isNullOrUndefined(logValue) || (logValue[0] === '' && logValue.length === 1)) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (logValue.length === 0 || logValue.length > 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const processArgs = (orgValue) => {
            let actualValue = this.parent.getValueFromArg(orgValue);
            if (errCollection.indexOf(actualValue) > -1) {
                return actualValue;
            }
            if (actualValue === this.parent.trueValue) {
                actualValue = '1';
            }
            else if (actualValue === this.parent.falseValue) {
                actualValue = '0';
            }
            else if (!this.parent.isCellReference(orgValue)) {
                if (orgValue.indexOf(this.parent.tic) > -1 && this.parent.removeTics(orgValue).match(/^(\d*\.\d+|\d+)\s*[*]\s*(\d*\.\d+|\d+)$/)) {
                    actualValue = this.parent.getValueFromArg(this.parent.removeTics(orgValue));
                }
                else if (actualValue.indexOf(this.parent.tic) > -1) {
                    actualValue = this.parent.removeTics(actualValue);
                    if (actualValue.trim() === '') {
                        return errCollection[CommonErrors.Value];
                    }
                    else if (actualValue.indexOf(':') > -1) {
                        const values = actualValue.split(':');
                        if (values.length <= 3) {
                            if (!this.parent.isNumber(values[0]) || !this.parent.isNumber(values[1])) {
                                return errCollection[CommonErrors.Value];
                            }
                            let hours = Number(values[0]) + Number((Number(values[1]) / 60));
                            if (values.length === 3) {
                                if (!this.parent.isNumber(values[2])) {
                                    return errCollection[CommonErrors.Value];
                                }
                                hours += Number(Number(values[2]) / 3600);
                            }
                            actualValue = (hours / 24).toString();
                        }
                        else {
                            return errCollection[CommonErrors.Value];
                        }
                    }
                }
                if (actualValue.split('%').length === 2 && this.parent.isNumber(actualValue.split('%')[0])) {
                    actualValue = (Number(actualValue.split('%')[0]) * 0.01).toString();
                }
            }
            return actualValue;
        };
        if (!isNullOrUndefined(logValue[0])) {
            orgNumValue = processArgs(logValue[0]);
            if (errCollection.indexOf(orgNumValue) > -1) {
                return orgNumValue;
            }
            orgNumValue = this.parent.parseFloat(orgNumValue);
            if (isNaN(orgNumValue)) {
                return errCollection[CommonErrors.Value];
            }
        }
        if (!isNullOrUndefined(logValue[1])) {
            orgDigitValue = processArgs(logValue[1]);
            if (errCollection.indexOf(orgDigitValue) > -1) {
                return orgDigitValue;
            }
            orgDigitValue = this.parent.parseFloat(orgDigitValue);
            if (isNaN(orgDigitValue)) {
                return errCollection[CommonErrors.Value];
            }
        }
        orgDigitValue = Math.pow(10, Math.floor(orgDigitValue));
        orgNumValue = Number(orgNumValue);
        return ((orgNumValue < 0 ? -1 : 1) * Math.floor(orgDigitValue * Math.abs(orgNumValue)) / orgDigitValue).toString();
    }
    /**
     * @hidden
     * @param {string[]} logValue - specify the log value.
     * @returns {boolean | string} - Compute the expression.
     */
    ComputeEXP(...logValue) {
        let orgNumValue;
        const errCollection = this.parent.getErrorStrings();
        if (logValue[0] === '' && logValue.length === 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidArguments];
        }
        else if (logValue.length !== 1) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        else if (logValue[0].split(this.parent.tic).join('').trim() === '') {
            return errCollection[CommonErrors.Value];
        }
        orgNumValue = this.parent.getValueFromArg(logValue[0]);
        if (errCollection.indexOf(orgNumValue) > -1) {
            return orgNumValue;
        }
        if (orgNumValue.indexOf(this.parent.tic) > -1 && (this.parent.isCellReference(logValue[0]) ||
            isNaN(Number(orgNumValue.split(this.parent.tic).join(''))))) {
            return errCollection[CommonErrors.Value];
        }
        orgNumValue = orgNumValue.split(this.parent.tic).join('');
        if (orgNumValue === this.parent.trueValue) {
            orgNumValue = '1';
        }
        else if ((orgNumValue === this.parent.falseValue) || (orgNumValue === '')) {
            orgNumValue = '0';
        }
        else if (orgNumValue.indexOf('%') > -1) {
            orgNumValue = (Number(orgNumValue.split('%')[0]) / 100).toString();
        }
        else if (orgNumValue.indexOf(':') > -1) {
            return '0';
        }
        const logNumValue = this.parent.parseFloat(orgNumValue);
        if (isNaN(logNumValue)) {
            return errCollection[CommonErrors.Value];
        }
        else if (logNumValue > 709) {
            return errCollection[CommonErrors.Num];
        }
        return Math.exp(logNumValue).toString();
    }
    /**
     * @hidden
     * @param {string[]} logValue - specify the log value
     * @returns {boolean | string} - compute the value.
     */
    ComputeGEOMEAN(...logValue) {
        const argArr = logValue;
        let sum = 1;
        let count = 0;
        let cellVal = 0;
        let cellStr = 0;
        let dev;
        let r;
        let s;
        let cell;
        if (logValue.length === 0) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        if (argArr.length === 1 && argArr[0] === '') {
            return sum.toString();
        }
        let isBoolean;
        for (r = 0; r < argArr.length; r++) {
            if (argArr[r].indexOf(':') > -1) {
                if (argArr[0] === this.parent.tic) {
                    return this.parent.getErrorStrings()[CommonErrors.Value];
                }
                cell = this.parent.getCellCollection(argArr[r].split(this.parent.tic).join(''));
                for (s = 0; s < cell.length; s++) {
                    cellVal = this.parent.getValueFromArg(cell[s]);
                    cellStr = cellVal.split(this.parent.tic).join('');
                    isBoolean = cellStr === this.parent.trueValue || cellStr === this.parent.falseValue;
                    dev = this.parent.parseFloat(cellVal);
                    if (dev <= 0) {
                        return this.parent.getErrorStrings()[CommonErrors.Num];
                    }
                    if (isBoolean || this.parent.getErrorStrings().indexOf(cellVal) > -1) {
                        continue;
                    }
                    else if (!isNaN(dev)) {
                        count++;
                        sum = sum * dev;
                    }
                }
            }
            else {
                cellVal = this.parent.getValueFromArg(argArr[r]);
                if (this.parent.getErrorStrings().indexOf(cellVal) > -1) {
                    return cellVal;
                }
                const cellStr = cellVal.split(this.parent.tic).join('');
                if (cellVal.indexOf('"') > -1 && isNaN(this.parent.parseFloat(cellStr))) {
                    return this.parent.getErrorStrings()[CommonErrors.Value];
                }
                argArr[r] = argArr[r].startsWith('n') ? argArr[r].slice(1) : argArr[r];
                if ((cellVal === '' && argArr[r] === '')) {
                    return this.parent.getErrorStrings()[CommonErrors.Num];
                }
                if ((cellStr === 'TRUE' || cellStr === 'FALSE') && this.parent.isCellReference(argArr[r])) {
                    continue;
                }
                if (cellVal.length > 0) {
                    cellVal = cellVal.indexOf('"') > -1 ? cellStr : cellVal;
                    cellVal = (cellVal.split(this.parent.tic).join('') === 'TRUE') ? '1' :
                        (cellVal.split(this.parent.tic).join('') === 'FALSE') ? '0' : cellVal;
                    if (!this.parent.isCellReference(argArr[r])) {
                        if (isNaN(this.parent.parseFloat(cellVal))) {
                            return this.parent.getErrorStrings()[CommonErrors.Value];
                        }
                    }
                    dev = this.parent.parseFloat(cellVal);
                    if (dev <= 0) {
                        return this.parent.getErrorStrings()[CommonErrors.Num];
                    }
                    else if (!isNaN(dev)) {
                        count++;
                        sum = sum * dev;
                    }
                }
            }
        }
        if (count > 0) {
            sum = Math.pow(sum, 1 / count);
        }
        return sum.toString();
    }
    /**
     * @hidden
     * @param {string[]} range - specify the args.
     * @returns {number | string} - Returns the square of the Pearson product moment correlation coefficient based on data points in known_y's and known_x's.
     */
    ComputeRSQ(...range) {
        let validCount = 0;
        const argArr = range;
        if (argArr.length !== 2) {
            return this.parent.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        if (argArr[0] === '' || argArr[1] === '') {
            return this.parent.getErrorStrings()[CommonErrors.Value];
        }
        if (argArr[0].includes('"') || argArr[1].includes('"')) {
            return this.parent.getErrorStrings()[CommonErrors.NA];
        }
        if ((argArr[0].indexOf(':') === -1 && isCellReference(argArr[0])) && (argArr[1].indexOf(':') === -1 && isCellReference(argArr[1]))) {
            return this.parent.getErrorStrings()[CommonErrors.DivZero];
        }
        const yValuesRange = this.parent.getCellCollection(argArr[0]);
        const xValuesRange = this.parent.getCellCollection(argArr[1]);
        if ((yValuesRange.length !== xValuesRange.length)) {
            return this.parent.getErrorStrings()[CommonErrors.NA];
        }
        const xValues = this.getDataCollection(xValuesRange);
        for (let a = 0; a < xValues.length; a++) {
            if (this.parent.getErrorStrings().indexOf(xValues[a]) > -1) {
                return xValues[a];
            }
        }
        const yValues = this.getDataCollection(yValuesRange);
        for (let b = 0; b < yValues.length; b++) {
            if (this.parent.getErrorStrings().indexOf(yValues[b]) > -1) {
                return yValues[b];
            }
        }
        let xValue;
        let yValue;
        for (let i = 0; i < xValues.length; i++) {
            xValue = Number(xValues[i]);
            yValue = Number(yValues[i]);
            if (isNumber(xValue) && isNumber(yValue)) {
                validCount++;
            }
        }
        if (validCount <= 1) {
            return this.parent.getErrorStrings()[CommonErrors.DivZero];
        }
        if (validCount === 2) {
            return 1;
        }
        const meanArray = this.getMeanArray(xValues, yValues);
        const meanX = meanArray[0];
        const meanY = meanArray[1];
        const correlation = this.getCorrelation(xValues, yValues, meanX, meanY);
        return Math.pow(correlation, 2);
    }
    /**
     * @hidden
     * @param {string[]} xValues - specify the x values
     * @param {string[]} yValues - specify the y values
     * @param {number} meanX - specify the mean of x values
     * @param {number} meanY - specify the mean of y values
     * @returns {number} - Returns correlation value
     */
    getCorrelation(xValues, yValues, meanX, meanY) {
        let numerator = 0;
        let denominatorX = 0;
        let denominatorY = 0;
        let diffY;
        let diffX;
        for (let i = 0; i < xValues.length; i++) {
            if (isNumber(xValues[i]) && isNumber(yValues[i])) {
                diffX = Number(xValues[i]) - meanX;
                diffY = Number(yValues[i]) - meanY;
                numerator += diffX * diffY;
                denominatorX += Math.pow(diffX, 2);
                denominatorY += Math.pow(diffY, 2);
            }
        }
        const correlation = numerator / Math.sqrt(denominatorX * denominatorY);
        return correlation;
    }
    /**
     * @hidden
     * @param {string[]} xValues - specify the x values
     * @param {string[]} yValues - specify the y values
     * @returns {number[]} meanX - returns array of mean values of x and y values
     */
    getMeanArray(xValues, yValues) {
        let count = 0;
        let sumX = 0;
        let sumY = 0;
        let meanX = 0;
        let meanY = 0;
        for (let i = 0; i < xValues.length; i++) {
            if (isNumber(xValues[i]) && isNumber(yValues[i])) {
                sumX += Number(xValues[i]);
                sumY += Number(yValues[i]);
                count++;
            }
        }
        meanX = sumX / count;
        meanY = sumY / count;
        return [meanX, meanY];
    }
    getDataCollection(cells) {
        const cellsData = [];
        for (let i = 0, len = cells.length; i < len; i++) {
            cellsData.push(this.parent.getValueFromArg(cells[i]));
        }
        return cellsData;
    }
    /**
     * @hidden
     * @param {string} value - specify the value
     * @returns {number} - Returns parse double value.
     */
    parseDouble(value) {
        const val = this.parent.parseFloat(value.toString());
        return !isNaN(val) ? val : NaN;
    }
    /**
     * @hidden
     * @param {string} value - specify the value
     * @returns {string} - Returns spreadsheet display text.
     */
    spreadsheetDisplayText(value) {
        // eslint-disable-next-line
        if (this.parent.parentObject && this.parent.parentObject.element && this.parent.parentObject.element.classList.contains('e-spreadsheet') && this.parent.isCellReference(value)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const indexes = this.parent.parentObject.getIndexes(value);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            value = this.parent.parentObject.getDisplayText(this.parent.parentObject.
                getActiveSheet().rows[indexes.startIdx].cells[indexes.endIdx]);
        }
        return value;
    }
    /**
     * @hidden
     * @param {string} value - specify the value
     * @returns {string} - Returns spreadsheet format.
     */
    spreadsheetFormat(value) {
        // eslint-disable-next-line
        if (this.parent.parentObject && this.parent.parentObject.element && this.parent.parentObject.element.classList.contains('e-spreadsheet') && this.parent.isCellReference(value)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const index = this.parent.parentObject.getIndexes(value);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            value = this.parent.parentObject.getActiveSheet().rows[index.startIdx].cells[index.endIdx].format;
        }
        return value;
    }
}

class Parser {
    constructor(parent) {
        this.emptyStr = '';
        this.storedStringText = this.emptyStr;
        this.sheetToken = '!';
        /** @hidden */
        this.tokenAdd = 'a';
        /** @hidden */
        this.tokenSubtract = 's';
        /** @hidden */
        this.tokenMultiply = 'm';
        /** @hidden */
        this.tokenDivide = 'd';
        /** @hidden */
        this.tokenLess = 'l';
        this.charEm = 'r';
        this.charEp = 'x';
        /** @hidden */
        this.tokenGreater = 'g';
        /** @hidden */
        this.tokenEqual = 'e';
        /** @hidden */
        this.tokenLessEq = 'k';
        /** @hidden */
        this.tokenGreaterEq = 'j';
        /** @hidden */
        this.tokenNotEqual = 'o';
        /** @hidden */
        this.tokenAnd = 'c';
        this.tokenEm = 'v';
        this.tokenEp = 't';
        /** @hidden */
        this.tokenOr = String.fromCharCode(126);
        this.charAnd = 'i';
        this.charLess = '<';
        this.charGreater = '>';
        this.charEqual = '=';
        this.charLessEq = 'f';
        this.charGreaterEq = 'h';
        this.charNoEqual = 'z';
        this.stringGreaterEq = '>=';
        this.stringLessEq = '<=';
        this.stringNoEqual = '<>';
        this.stringAnd = '&';
        this.stringOr = '^';
        this.charOr = 'w';
        this.charAdd = '+';
        this.charSubtract = '-';
        this.charMultiply = '*';
        this.charDivide = '/';
        this.fixedReference = '$';
        this.spaceString = ' ';
        this.ignoreBracet = false;
        /** @hidden */
        this.isError = false;
        /** @hidden */
        this.isFormulaParsed = false;
        this.findNamedRange = false;
        this.stringsColl = new Map();
        this.tokens = [
            this.tokenAdd, this.tokenSubtract, this.tokenMultiply, this.tokenDivide, this.tokenLess,
            this.tokenGreater, this.tokenEqual, this.tokenLessEq, this.tokenGreaterEq, this.tokenNotEqual, this.tokenAnd, this.tokenOr
        ];
        this.charNOTop = String.fromCharCode(167);
        this.specialSym = ['~', '@', '#', '?'];
        this.isFailureTriggered = false;
        this.parent = parent;
    }
    /**
     * @hidden
     * @param {string} text - specify the text
     * @param {string} fkey - specify the formula key
     * @returns {string} - returns parse.
     */
    parse(text, fkey) {
        if (this.parent.isTextEmpty(text)) {
            return text;
        }
        if (isExternalFileLink(text)) {
            return this.parent.getErrorStrings()[CommonErrors.Ref];
        }
        if (this.parent.getFormulaCharacter() !== String.fromCharCode(0) && this.parent.getFormulaCharacter() === text[0]) {
            text = text.substring(1);
        }
        if (this.parent.namedRanges.size > 0 || this.parent.storedData.size > 0) {
            text = this.checkForNamedRangeAndKeyValue(text);
            this.findNamedRange = false;
        }
        text = text.replace(/[-+*/&^]+/g, (operators) => {
            let firstOp = '';
            while (1 < operators.length) {
                switch (operators.substring(0, 2)) {
                    case '++':
                        operators = '+' + operators.substring(2);
                        break;
                    case '--':
                        operators = '+' + operators.substring(2);
                        break;
                    case '+-':
                        operators = '-' + operators.substring(2);
                        break;
                    case '-+':
                        operators = '-' + operators.substring(2);
                        break;
                    case '*+':
                        operators = '*' + operators.substring(2);
                        break;
                    case '/+':
                        operators = '/' + operators.substring(2);
                        break;
                    case '^+':
                        operators = '^' + operators.substring(2);
                        break;
                    case '&+':
                        operators = '&' + operators.substring(2);
                        break;
                    case '*-':
                    case '/-':
                    case '^-':
                    case '&-':
                        firstOp = operators.substring(0, 1);
                        operators = operators.substring(1);
                        break;
                    default:
                        throw new FormulaError(this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidExpression], true);
                }
            }
            return firstOp + operators;
        });
        text = text.split('-' + '(' + '-').join('(');
        const formulaString = this.storeStrings(text);
        text = this.storedStringText;
        let i = 0;
        if (isNullOrUndefined(formulaString)) {
            text = text.split(' ').join('');
        }
        text = text.split('=>').join('>=');
        text = text.split('=<').join('<=');
        if (text[text.length - 1] !== this.parent.arithMarker || this.indexOfAny(text, this.tokens) !== (text.length - 2)) {
            text = text.toUpperCase();
        }
        if (text.indexOf(this.sheetToken) > -1) {
            const family = this.parent.getSheetFamilyItem(this.parent.grid);
            if (family.sheetNameToParentObject != null && family.sheetNameToParentObject.size > 0) {
                if (text[0] !== this.sheetToken.toString()) {
                    text = this.parent.setTokensForSheets(text);
                }
                const sheetToken = this.parent.getSheetToken(text.split(this.parent.tic).join(this.emptyStr));
                const scopedRange = this.checkScopedRange(text.split('"').join(this.emptyStr).split(this.sheetToken).join(''));
                if (isNullOrUndefined(sheetToken) && sheetToken !== '' && this.parent.namedRanges.size > 0 && scopedRange !== '') {
                    text = scopedRange;
                }
            }
        }
        text = this.markLibraryFormulas(text);
        try {
            text = this.formulaAutoCorrection(text);
        }
        catch (ex) {
            const args = {
                message: ex.message, exception: ex, isForceCalculable: ex.formulaCorrection,
                computeForceCalculate: false
            };
            if (!args.isForceCalculable) {
                throw this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidExpression];
            }
            if (!this.isFailureTriggered) {
                this.parent.trigger('onFailure', args);
                this.isFailureTriggered = true;
            }
            if (args.isForceCalculable && args.computeForceCalculate) {
                text = this.formulaAutoCorrection(text, args);
                this.parent.storedData.get(fkey).formulaText = '=' + text;
            }
            else {
                throw this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidExpression];
            }
        }
        if (!this.ignoreBracet) {
            i = text.indexOf(')');
            while (i > -1) {
                const k = text.substring(0, i).lastIndexOf('(');
                if (k === -1) {
                    throw new FormulaError(this.parent.formulaErrorStrings[FormulasErrorsStrings.MismatchedParentheses]);
                }
                if (k === i - 1) {
                    throw new FormulaError(this.parent.formulaErrorStrings[FormulasErrorsStrings.EmptyExpression]);
                }
                let s = this.emptyStr;
                if (this.ignoreBracet) {
                    s = this.parent.substring(text, k, i - k + 1);
                }
                else {
                    s = this.parent.substring(text, k + 1, i - k - 1);
                }
                try {
                    text = text.substring(0, k) + this.parseSimple(s) + text.substring(i + 1);
                }
                catch (ex) {
                    if (ex === this.parent.formulaErrorStrings[FormulasErrorsStrings.CircularReference]) {
                        throw ex;
                    }
                    const args = this.exceptionArgs(ex);
                    if (!this.isFailureTriggered) {
                        this.parent.trigger('onFailure', args);
                        this.isFailureTriggered = true;
                    }
                    const errorMessage = (typeof args.exception === 'string') ? args.exception : args.message;
                    return (this.parent.getErrorLine(ex) ? '' : '#' + this.parent.getErrorLine(ex) + ': ') + errorMessage;
                }
                i = text.indexOf(')');
            }
        }
        if (!this.ignoreBracet && text.indexOf('(') > -1) {
            throw new FormulaError(this.parent.formulaErrorStrings[FormulasErrorsStrings.MismatchedParentheses]);
        }
        text = this.parseSimple(text);
        if (formulaString !== null && formulaString.size > 0) {
            text = this.setStrings(text, formulaString);
        }
        return text;
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    exceptionArgs(ex) {
        return {
            message: ex.message, exception: ex, isForceCalculable: ex.formulaCorrection,
            computeForceCalculate: false
        };
    }
    formulaAutoCorrection(formula, args) {
        const arithemeticArr = ['*', '+', '-', '/', '^', '&'];
        const logicalSym = ['>', '=', '<'];
        let i = 0;
        let form = '';
        let op = '';
        let firstOp = '';
        let secondprevOp = '';
        let secondnextOp = '';
        let firstDigit = '';
        let secondDigit = '';
        let countDigit = 0;
        if (this.parent.formulaErrorStrings.indexOf(formula) > -1) {
            return formula;
        }
        else {
            if (this.indexOfAny(formula, this.specialSym) > -1) {
                throw new FormulaError(this.parent.formulaErrorStrings[FormulasErrorsStrings.InvalidExpression], false);
            }
            while (i < formula.length) {
                formula = formula.split('-*').join('-').split('/*').join('/').split('*/').join('*').split('-/').join('-').
                    split('*+').join('*').split('+*').join('+');
                if ((this.parent.isDigit(formula[i]) && ((formula.length > i + 1)
                    && (this.indexOfAny(formula[i + 1], arithemeticArr) > -1)) && ((formula.length > i + 2)
                    && (!isNullOrUndefined(formula[i + 2]) && this.indexOfAny(formula[i + 2], arithemeticArr) > -1))) &&
                    (formula[i + 2] !== '-' || (formula[i + 1] !== '*' && formula[i + 1] !== '/' && formula[i + 1] !== '^' && formula[i + 1] !== '&'))) {
                    if (args && args.computeForceCalculate) {
                        if (this.parent.isDigit(formula[i])) {
                            if (countDigit < 1) {
                                firstDigit = formula[i];
                                firstOp = formula[i + 1];
                                if (isNullOrUndefined(firstOp)) {
                                    firstOp = this.emptyStr;
                                }
                                firstOp = firstOp === '&' ? '' : firstOp;
                                countDigit = countDigit + 1;
                                form = form + firstDigit + firstOp;
                            }
                            else if (countDigit < 2) {
                                secondDigit = formula[i];
                                secondprevOp = formula[i - 1];
                                secondnextOp = formula[i + 1];
                                countDigit = 0;
                                if (secondprevOp === '-') {
                                    secondnextOp = isNullOrUndefined(secondnextOp) ? this.emptyStr : secondnextOp;
                                    secondnextOp = secondnextOp === '&' ? '' : secondnextOp;
                                    form = form + secondprevOp + secondDigit + secondnextOp;
                                }
                                else {
                                    secondnextOp = isNullOrUndefined(secondnextOp) ? this.emptyStr : secondnextOp;
                                    form = form + secondDigit + secondnextOp;
                                }
                            }
                            i = i + 2;
                        }
                        else {
                            form = (formula[i] === '-') ? form + formula[i] : form;
                            i = i + 1;
                        }
                    }
                    else {
                        throw this.parent.formulaErrorStrings[FormulasErrorsStrings.ImproperFormula];
                    }
                }
                else if ((this.parent.isDigit(formula[i]) || formula[i] === this.parent.rightBracket ||
                    this.parent.storedData.has(formula[i].toUpperCase())) && (isNullOrUndefined(formula[i + 1]) ||
                    this.indexOfAny(formula[i + 1], arithemeticArr) > -1)) {
                    op = isNullOrUndefined(formula[i + 1]) ? this.emptyStr : formula[i + 1];
                    op = op === '&' && formula[i + 2] !== '-' ? '' : op; // for the cases 5&3=>53 and 5&-3=>5-3.
                    form = formula[i - 1] === '-' ? form + formula[i - 1] + formula[i] + op : form + formula[i] + op;
                    i = i + 2;
                }
                else if (this.indexOfAny(formula[i], logicalSym) > -1 && !isNullOrUndefined(formula[i - 1]) &&
                    !isNullOrUndefined(formula[i + 1])) {
                    form = form + formula[i];
                    i = i + 1;
                }
                else if (formula[i] === 'q') {
                    while (formula[i] !== this.parent.leftBracket) {
                        form = form + formula[i];
                        i = i + 1;
                    }
                }
                else if (formula[i] === this.parent.leftBracket || formula[i] === this.parent.rightBracket ||
                    formula[i] === '{' || formula[i] === '}' || formula[i] === '(' ||
                    formula[i] === ')') {
                    form = form + formula[i];
                    i = i + 1;
                }
                else if (this.parent.isUpperChar(formula[i]) || formula[i].indexOf(':') > -1 || formula[i]
                    === this.parent.getParseArgumentSeparator() || (formula[i] === '%' && this.parent.isDigit(formula[i - 1]))) {
                    form = form + formula[i];
                    i = i + 1;
                }
                else if (formula[i] === this.parent.tic || formula[i] === ' ' || formula[i] ===
                    this.parent.getParseDecimalSeparator() || formula[i] === this.sheetToken || formula[i] === '$' ||
                    formula[i] === '_') {
                    form = form + formula[i];
                    i = i + 1;
                }
                else {
                    if (this.parent.isDigit(formula[i])) {
                        form = formula[i - 1] === '-' ? form + formula[i - 1] + formula[i] : form + formula[i];
                    }
                    if (formula[i] === '-' || formula[i] === '+') {
                        form = form + formula[i];
                        form = form.split('++').join('+').split('+-').join('-').split('-+').join('-');
                    }
                    if (formula[i] === '/' || formula[i] === '*' || formula[i] === '^') {
                        form = form + formula[i];
                    }
                    i = i + 1;
                }
            }
        }
        form = form === this.emptyStr ? formula : form;
        if (this.indexOfAny(form[form.length - 1], arithemeticArr) > -1) {
            form = form.substring(0, form.length - 1);
        }
        form = form.split('--').join('-').split('-+').join('-').split('+-').join('-');
        return form;
    }
    checkScopedRange(text) {
        let scopedRange = this.emptyStr;
        let b = 'NaN';
        let id = this.parent.getSheetID(this.parent.grid);
        const sheet = this.parent.getSheetFamilyItem(this.parent.grid);
        if (text[0] === this.sheetToken.toString()) {
            const i = text.indexOf(this.sheetToken, 1);
            const v = parseInt(text.substr(1, i - 1), 10);
            if (i > 1 && !this.parent.isNaN(v)) {
                text = text.substring(i + 1);
                id = v;
            }
        }
        const token = '!' + id.toString();
        if (sheet === null || sheet.sheetNameToToken == null) {
            return b;
        }
        sheet.sheetNameToToken.forEach((value, key) => {
            if (sheet.sheetNameToToken.get(key).toString() === token + '!') {
                let s = this.emptyStr;
                this.parent.namedRanges.forEach((value, key) => {
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    if (!isNullOrUndefined(this.parent.parentObject)) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        s = this.parent.parentObject.getActiveSheet().name + this.sheetToken + text.toUpperCase();
                    }
                    else {
                        s = sheet.sheetNameToToken.get(key).toUpperCase();
                    }
                    if (this.parent.getNamedRanges().has(s)) {
                        scopedRange = (this.parent.getNamedRanges().get(s)).toUpperCase();
                        b = scopedRange;
                    }
                });
            }
        });
        return b;
    }
    storeStrings(tempString) {
        let i = 0;
        let j = 0;
        let id = 0;
        let key = '';
        let storedString = null;
        let condition;
        const ticLoc = tempString.indexOf(this.parent.tic);
        if (ticLoc > -1) {
            i = tempString.indexOf(this.parent.tic);
            while (i > -1 && tempString.length > 0) {
                if (storedString === null) {
                    storedString = this.stringsColl;
                }
                j = i + 1 < tempString.length ? tempString.indexOf(this.parent.tic, i + 1) : -1;
                if (j === -1) {
                    throw new FormulaError(this.parent.formulaErrorStrings[FormulasErrorsStrings.MismatchedTics]);
                }
                condition = this.parent.substring(tempString, i, j - i + 1);
                key = this.parent.tic + this.spaceString + id.toString() + this.parent.tic;
                storedString = storedString.set(key, condition);
                tempString = tempString.substring(0, i) + key + tempString.substring(j + 1);
                i = i + key.length;
                if (i <= tempString.length) {
                    i = tempString.indexOf(this.parent.tic, i);
                }
                id++;
            }
        }
        this.storedStringText = tempString;
        return storedString;
    }
    setStrings(text, formulaString) {
        for (let i = 0; i < formulaString.size; i++) {
            formulaString.forEach((value, key) => {
                text = text.split(key).join(value);
            });
        }
        return text;
    }
    /**
     * @hidden
     * @param {string} formulaText - specify the formula text
     * @returns {string} - parse simple.
     */
    parseSimple(formulaText) {
        let needToContinue = true;
        let text = formulaText;
        if (text.length > 0 && text[0] === '+') {
            text = text.substring(1);
        }
        if (text === '#DIV/0!') {
            return '#DIV/0!';
        }
        if (text === '#NAME?') {
            return '#NAME?';
        }
        if (text === '') {
            return text;
        }
        if (this.parent.formulaErrorStrings.indexOf(text) > -1) {
            return text;
        }
        text = text.split(this.stringLessEq).join(this.charLessEq);
        text = text.split(this.stringGreaterEq).join(this.charGreaterEq);
        text = text.split(this.stringNoEqual).join(this.charNoEqual);
        text = text.split(this.stringAnd).join(this.charAnd);
        text = text.split(this.stringOr).join(this.charOr);
        text = text.split(this.fixedReference).join(this.emptyStr);
        needToContinue = true;
        const expTokenArray = [this.tokenEp, this.tokenEm];
        const mulTokenArray = [this.tokenMultiply, this.tokenDivide];
        const addTokenArray = [this.tokenAdd, this.tokenSubtract];
        const mulCharArray = [this.charMultiply, this.charDivide];
        const addCharArray = [this.charAdd, this.charSubtract];
        const compareTokenArray = [this.tokenLess, this.tokenGreater, this.tokenEqual, this.tokenLessEq,
            this.tokenGreaterEq, this.tokenNotEqual];
        const compareCharArray = [this.charLess, this.charGreater, this.charEqual, this.charLessEq,
            this.charGreaterEq, this.charNoEqual];
        const expCharArray = [this.charEp, this.charEm];
        const andTokenArray = [this.tokenAnd];
        const andCharArray = [this.charAnd];
        const orCharArray = [this.charOr];
        const orTokenArray = [this.tokenOr];
        text = this.parseSimpleOperators(text, expTokenArray, expCharArray);
        text = this.parseSimpleOperators(text, orTokenArray, orCharArray);
        if (needToContinue) {
            text = this.parseSimpleOperators(text, mulTokenArray, mulCharArray);
        }
        if (needToContinue) {
            text = this.parseSimpleOperators(text, addTokenArray, addCharArray);
        }
        if (needToContinue) {
            text = this.parseSimpleOperators(text, compareTokenArray, compareCharArray);
        }
        if (needToContinue) {
            text = this.parseSimpleOperators(text, andTokenArray, andCharArray);
        }
        return text;
    }
    /**
     * @hidden
     * @param {string} formulaText - specify the formula text
     * @param {string[]} markers -  specify the markers
     * @param {string[]} operators - specify the operators
     * @returns {string} - parse Simple Operators
     */
    parseSimpleOperators(formulaText, markers, operators) {
        if (this.parent.getErrorStrings().indexOf(formulaText) > -1) {
            return formulaText;
        }
        let text = formulaText;
        let i = 0;
        let op = '';
        for (let c = 0; c < operators.length; c++) {
            op = op + operators[c];
        }
        text = text.split('---').join('-').split('--').join('+').split(this.parent.getParseArgumentSeparator() + '-').join(this.parent.getParseArgumentSeparator() + 'u').split(this.parent.leftBracket + '-').join(this.parent.leftBracket + 'u').split('=-').join('=u');
        text = text.split(',+').join(',').split(this.parent.leftBracket + '+').join(this.parent.leftBracket).split('=+').join('=').split('>+').join('>').split('<+').join('<').split('/+').join('/').split('*+').join('*').split('++').join('+').split('*-').join('*u').split('/-').join('/u').split('w-').join('wu').split('i-').join('iu').toString();
        text = text.split('>-').join('>u').split('<-').join('<u').split('h-').join('hu').split('f-').join('fu').split('z-').join('zu');
        if (text.length > 0 && text[0] === '-') {
            text = text.substring(1).split('-').join(this.tokenOr);
            text = '0-' + text;
            text = this.parseSimpleOperators(text, [this.tokenSubtract], [this.charSubtract]);
            text = text.split(this.tokenOr).join('-');
        }
        else if (text.length > 0 && text[0] === '+') {
            text = text.substring(1);
        }
        else if (text.length > 0 && text[text.length - 1] === '+') {
            text = text.substring(0, text.length - 1);
        }
        try {
            if (this.indexOfAny(text, operators) > -1) {
                if (text.includes(' ')) {
                    let newText = '';
                    for (let index = 0; index < text.length; index++) {
                        const currChar = text[index];
                        if (operators.indexOf(currChar) >= 0) {
                            newText = newText.trim() + currChar;
                        }
                        else if (currChar === ' ' && operators.indexOf(newText[newText.length - 1]) >= 0) {
                            continue;
                        }
                        else {
                            newText += currChar;
                        }
                    }
                    text = newText;
                }
                i = this.indexOfAny(text, operators);
                const decimalSep = this.parent.getParseDecimalSeparator();
                while (i > -1) {
                    let left = '';
                    let right = '';
                    let leftIndex = 0;
                    let rightIndex = 0;
                    let isLeftBool = false;
                    const arithOp = ['*', '+', '-', '/', 'w', '=', '<', '>'];
                    const isNotOperator = text[i] === this.charNOTop;
                    let j = 0;
                    if (!isNotOperator) {
                        j = i - 1;
                        if (text[j] === this.parent.arithMarker) {
                            const k = this.findLeftMarker(text.substring(0, j - 1));
                            if (k < 0) {
                                throw new FormulaError(this.parent.formulaErrorStrings[FormulasErrorsStrings.CannotParse]);
                            }
                            left = this.parent.substring(text, k + 1, j - k - 1);
                            leftIndex = k + 1;
                        }
                        else if (text[j] === this.parent.rightBracket) {
                            let bracketCount = 0;
                            let k = j - 1;
                            while (k > 0 && (text[k] !== 'q' || bracketCount !== 0)) {
                                if (text[k] === 'q') {
                                    bracketCount--;
                                }
                                else if (text[k] === this.parent.rightBracket) {
                                    bracketCount++;
                                }
                                k--;
                            }
                            if (k < 0) {
                                throw new FormulaError(this.parent.formulaErrorStrings[FormulasErrorsStrings.CannotParse]);
                            }
                            left = this.parent.substring(text, k, j - k + 1);
                            leftIndex = k;
                        }
                        else if (text[j] === this.parent.tic[0]) {
                            const l = text.substring(0, j - 1).lastIndexOf(this.parent.tic);
                            if (l < 0) {
                                throw new FormulaError(this.parent.formulaErrorStrings[FormulasErrorsStrings.CannotParse]);
                            }
                            left = this.parent.substring(text, l, j - l + 1);
                            leftIndex = l;
                        }
                        else {
                            let period = false;
                            while (j > -1 && (this.parent.isDigit(text[j]) ||
                                (!period && (text[j] === decimalSep || text[j] === '%')))) {
                                if (!this.parent.isDigit(text[j]) && text[j] !== '%') {
                                    period = true;
                                }
                                j = j - 1;
                            }
                            if (j > -1 && period && text[j] === decimalSep) {
                                throw new FormulaError(this.parent.formulaErrorStrings[FormulasErrorsStrings.NumberContains2DecimalPoints]);
                            }
                            j = j + 1;
                            if (j === 0 || (j > 0 && !this.parent.isUpperChar(text[j - 1]))) {
                                left = 'n' + this.parent.substring(text, j, i - j);
                                leftIndex = j;
                            }
                            else if (j > 0 && text[j - 1] === 'E' && ((text.substring(j - 4, j) === 'TRUE' && (!isNullOrUndefined(text[j - 5]) ? arithOp.indexOf(text[j - 5]) > -1 : true)) ||
                                (text.substring(j - 5, j) === 'FALSE' && (!isNullOrUndefined(text[j - 6]) ? arithOp.indexOf(text[j - 6]) > -1 : true))) && (text.substring(j + 1, j + 5) === 'TRUE' || text.substring(j + 1, j + 6) === 'FALSE')) {
                                j = text.substring(j - 4, j) === 'TRUE' ? j - 4 : j - 5;
                                left = text.substring(j, i) === 'TRUE' ? 'n1' : (text.substring(j, i) === 'FALSE' ? 'n0' : left);
                                leftIndex = j;
                                isLeftBool = true;
                            }
                            else {
                                j = j - 1;
                                while (j > -1 && (this.parent.isUpperChar(text[j]) || // Check if character is uppercase alphabets.
                                    this.parent.isDigit(text[j]) || // Check if character is a digit.
                                    text[j] === '_')) { // Check if character is an underscore ('_'), for defined names cases.
                                    j = j - 1;
                                }
                                if (j > -1 && text[j] === this.sheetToken) {
                                    j = j - 1;
                                    while (j > -1 && text[j] !== this.sheetToken) {
                                        j = j - 1;
                                    }
                                    if (j > -1 && text[j] === this.sheetToken) {
                                        j = j - 1;
                                    }
                                }
                                if (j > -1 && text[j] === ':') {
                                    //// handle range operands
                                    j = j - 1;
                                    while (j > -1 && this.parent.isDigit(text[j])) {
                                        j = j - 1;
                                    }
                                    while (j > -1 && this.parent.isUpperChar(text[j])) {
                                        j = j - 1;
                                    }
                                    if (j > -1 && text[j] === this.sheetToken) {
                                        j--;
                                        while (j > -1 && text[j] !== this.sheetToken) {
                                            j--;
                                        }
                                        if (j > -1 && text[j] === this.sheetToken) {
                                            j--;
                                        }
                                    }
                                    j = j + 1;
                                    left = this.parent.substring(text, j, i - j);
                                    left = this.parent.getCellFrom(left);
                                }
                                else {
                                    let uFound = false;
                                    if (j > 0 && !this.parent.isUpperChar(text[j])) {
                                        uFound = text[j] === 'u' && text[j - 1] === this.parent.getParseArgumentSeparator();
                                    }
                                    if (!uFound) {
                                        j = j + 1;
                                    }
                                    left = this.parent.substring(text, j, i - j);
                                }
                                this.parent.updateDependentCell(left);
                                leftIndex = j;
                            }
                            if ((this.parent.namedRanges.size > 0 && this.parent.namedRanges.has(left.toUpperCase())) ||
                                (this.parent.storedData.has(left.toUpperCase()))) {
                                left = 'n' + this.checkForNamedRangeAndKeyValue(left);
                            }
                        }
                    }
                    else {
                        leftIndex = i;
                    }
                    if (i === text.length - 1) {
                        throw new FormulaError(this.parent.formulaErrorStrings[FormulasErrorsStrings.ExpressionCannotEndWithAnOperator]);
                    }
                    else {
                        j = i + 1;
                        let uFound = text[j] === 'u'; // for 3*-2
                        if (uFound) {
                            j = j + 1;
                        }
                        if (text[j] === this.parent.tic[0]) {
                            const k = text.substring(j + 1).indexOf(this.parent.tic);
                            if (k < 0) {
                                throw this.parent.formulaErrorStrings[FormulasErrorsStrings.CannotParse];
                            }
                            right = this.parent.substring(text, j, k + 2);
                            rightIndex = k + j + 2;
                        }
                        else if (text[j] === this.parent.arithMarker) {
                            const k = this.findRightMarker(text.substring(j + 1));
                            if (k < 0) {
                                throw new FormulaError(this.parent.formulaErrorStrings[FormulasErrorsStrings.CannotParse]);
                            }
                            right = this.parent.substring(text, j + 1, k);
                            rightIndex = k + j + 2;
                        }
                        else if (text[j] === 'q') {
                            let bracketCount = 0;
                            let k = j + 1;
                            while (k < text.length && (text[k] !== this.parent.rightBracket || bracketCount !== 0)) {
                                if (text[k] === this.parent.rightBracket) {
                                    bracketCount++;
                                }
                                else if (text[k] === 'q') {
                                    bracketCount--;
                                }
                                k++;
                            }
                            if (k === text.length) {
                                throw this.parent.formulaErrorStrings[FormulasErrorsStrings.CannotParse];
                            }
                            right = this.parent.substring(text, j, k - j + 1);
                            if (uFound) {
                                right = 'u' + right;
                            }
                            rightIndex = k + 1;
                        }
                        else if (this.parent.isDigit(text[j]) || text[j] === decimalSep) {
                            let period = (text[j] === decimalSep);
                            j = j + 1;
                            while (j < text.length && (this.parent.isDigit(text[j]) ||
                                (!period && text[j] === decimalSep))) {
                                if (text[j] === decimalSep) {
                                    period = true;
                                }
                                j = j + 1;
                            }
                            if (j < text.length && text[j] === '%') {
                                j += 1;
                            }
                            if (period && j < text.length && text[j] === decimalSep) {
                                throw this.parent.formulaErrorStrings[FormulasErrorsStrings.NumberContains2DecimalPoints];
                            }
                            right = 'n' + this.parent.substring(text, i + 1, j - i - 1);
                            rightIndex = j;
                        }
                        else if (this.parent.isUpperChar(text[j]) || text[j] === this.sheetToken ||
                            text[j] === 'u') {
                            if (text[j] === this.sheetToken) {
                                j = j + 1;
                                while (j < text.length && text[j] !== this.sheetToken) {
                                    j = j + 1;
                                }
                            }
                            j = j + 1;
                            let jTemp = 0;
                            let inbracket = false;
                            while (j < text.length && (this.parent.isUpperChar(text[j]) || text[j] === '_'
                                || text[j] === decimalSep || text[j] === '[' || text[j] === ']' ||
                                text[j] === '#' || text[j] === ' ' || text[j] === '%' || text[j] ===
                                decimalSep && inbracket)) {
                                if (j !== text.length - 1 && text[j] === '[' && text[j + 1] === '[') {
                                    inbracket = true;
                                }
                                if (j !== text.length - 1 && text[j] === ']' && text[j + 1] === ']') {
                                    inbracket = false;
                                }
                                j++;
                                jTemp++;
                            }
                            let noCellReference = (j === text.length) || !this.parent.isDigit(text[j]);
                            if (jTemp > 1) {
                                while (j < text.length && (this.parent.isUpperChar(text[j]) ||
                                    this.parent.isDigit(text[j]) || text[j] === ' ' || text[j] === '_')) {
                                    j++;
                                }
                                noCellReference = true;
                            }
                            while (j < text.length && this.parent.isDigit(text[j])) {
                                j = j + 1;
                            }
                            if (j < text.length && text[j] === ':') {
                                j = j + 1;
                                if (j < text.length && text[j] === this.sheetToken) {
                                    j++;
                                    while (j < text.length && text[j] !== this.sheetToken) {
                                        j = j + 1;
                                    }
                                    if (j < text.length && text[j] === this.sheetToken) {
                                        j++;
                                    }
                                }
                                while (j < text.length && this.parent.isUpperChar(text[j])) {
                                    j = j + 1;
                                }
                                while (j < text.length && this.parent.isDigit(text[j])) {
                                    j = j + 1;
                                }
                                j = j - 1;
                                right = this.parent.substring(text, i + 1, j - i);
                                right = this.parent.getCellFrom(right);
                            }
                            else {
                                j = j - 1;
                                right = this.parent.substring(text, i + 1, j - i);
                                uFound = text[j] === 'u';
                                if (uFound) {
                                    right = 'u' + right;
                                }
                            }
                            if (noCellReference && right.startsWith(this.sheetToken)) {
                                noCellReference = !this.parent.isCellReference(right);
                            }
                            if (!noCellReference) {
                                this.parent.updateDependentCell(right);
                            }
                            if ((this.parent.namedRanges.size > 0 && this.parent.namedRanges.has(right.toUpperCase()))
                                || (this.parent.storedData.has(right.toUpperCase()))) {
                                right = 'n' + this.checkForNamedRangeAndKeyValue(right);
                            }
                            const isPrevArithOp = ['*', '+', '-', '/', 'w'].indexOf(text[j - right.length]) > -1;
                            right = right === 'TRUE' && (isLeftBool || isPrevArithOp) ? 'n1' : (right === 'FALSE' && (isLeftBool || isPrevArithOp) ? 'n0' : right);
                            rightIndex = j + 1;
                        }
                    }
                    const p = op.indexOf(text[i]);
                    let s = this.parent.arithMarker + left + right + markers[p] + this.parent.arithMarker;
                    if (leftIndex > 0) {
                        s = text.substring(0, leftIndex) + s;
                    }
                    if (rightIndex < text.length) {
                        s = s + text.substring(rightIndex);
                    }
                    s = s.split(this.parent.arithMarker2).join(this.parent.arithMarker.toString());
                    text = s;
                    i = this.indexOfAny(text, operators);
                }
            }
            else {
                if (text.length > 0 && (this.parent.isUpperChar(text[0]) || text[0] === this.sheetToken)) {
                    let isCharacter = true;
                    let checkLetter = true;
                    let oneTokenFound = false;
                    const textLen = text.length;
                    for (let k = 0; k < textLen; ++k) {
                        if (text[k] === this.sheetToken) {
                            if (k > 0 && !oneTokenFound) {
                                throw this.parent.getErrorStrings()[CommonErrors.Ref];
                            }
                            oneTokenFound = true;
                            k++;
                            while (k < textLen && this.parent.isDigit(text[k])) {
                                k++;
                            }
                            if (k === textLen || text[k] !== this.sheetToken) {
                                isCharacter = false;
                                break;
                            }
                        }
                        else {
                            if (!checkLetter && this.parent.isChar(text[k])) {
                                isCharacter = false;
                                break;
                            }
                            if (this.parent.isChar(text[k]) || this.parent.isDigit(text[k]) || text[k] ===
                                this.sheetToken) {
                                checkLetter = this.parent.isUpperChar(text[k]);
                            }
                            else {
                                isCharacter = false;
                                break;
                            }
                        }
                    }
                    if (isCharacter) {
                        this.parent.updateDependentCell(text);
                    }
                }
            }
            return text;
        }
        catch (ex) {
            if (ex === this.parent.formulaErrorStrings[FormulasErrorsStrings.CircularReference]) {
                throw ex;
            }
            return ex;
        }
    }
    /**
     * @hidden
     * @param {string} text - specify the text
     * @param {string[]} operators - specify the operators
     * @returns {number} - returns index.
     */
    indexOfAny(text, operators) {
        for (let i = 0; i < text.length; i++) {
            if (operators.indexOf(text[i]) > -1) {
                return i;
            }
        }
        return -1;
    }
    /**
     * @hidden
     * @param {string} text - specify the text
     * @returns {number} - find Left Marker.
     */
    findLeftMarker(text) {
        let ret = -1;
        if (text.indexOf(this.parent.arithMarker) > -1) {
            let bracketLevel = 0;
            for (let i = text.length - 1; i >= 0; --i) {
                if (text[i] === this.parent.rightBracket) {
                    bracketLevel--;
                }
                else if (text[i] === this.parent.leftBracket) {
                    bracketLevel++;
                }
                else if (text[i] === this.parent.arithMarker && bracketLevel === 0) {
                    ret = i;
                    break;
                }
            }
        }
        return ret;
    }
    /**
     * @hidden
     * @param {string} text - specify the text.
     * @returns {number} - find Right Marker.
     */
    findRightMarker(text) {
        let ret = -1;
        if (text.indexOf(this.parent.arithMarker) > -1) {
            let bracketLevel = 0;
            for (let j = 0; j < text.length; ++j) {
                if (text[j] === this.parent.rightBracket) {
                    bracketLevel--;
                }
                else if (text[j] === this.parent.leftBracket) {
                    bracketLevel++;
                }
                else if (text[j] === this.parent.arithMarker && bracketLevel === 0) {
                    ret = j;
                    break;
                }
            }
        }
        return ret;
    }
    /**
     * @hidden
     * @param {string} formula - specify the formula
     * @param {string} fKey - specify the formula key.
     * @returns {string} - parse formula.
     */
    parseFormula(formula, fKey) {
        if (formula.length > 0 && formula[0] === this.parent.getFormulaCharacter()) {
            formula = formula.substring(1);
        }
        if (formula.indexOf('#REF!') > -1) {
            return this.parent.getErrorStrings()[CommonErrors.Ref];
        }
        if (formula.length > 0 && formula[0] === '+') {
            formula = formula.substring(1);
        }
        try {
            this.isFailureTriggered = false;
            this.isError = false;
            formula = this.parse(formula.trim(), fKey);
            this.isFormulaParsed = true;
        }
        catch (ex) {
            const args = this.exceptionArgs(ex);
            if (!this.isFailureTriggered) {
                this.parent.trigger('onFailure', args);
                this.isFailureTriggered = true;
            }
            const errorMessage = (typeof args.exception === 'string') ? args.exception : args.message;
            formula = (isNullOrUndefined(this.parent.getErrorLine(ex)) ? '' : '#' + this.parent.getErrorLine(ex) + ': ') + errorMessage;
            this.isError = true;
        }
        return formula;
    }
    /**
     * @hidden
     * @param {string} formula - specify the formula
     * @returns {string} - mark library formulas.
     */
    markLibraryFormulas(formula) {
        let bracCount = 0;
        let rightParens = formula.indexOf(')');
        if (rightParens === -1) {
            formula = this.markNamedRanges(formula);
        }
        else {
            while (rightParens > -1) {
                let parenCount = 0;
                let leftParens = rightParens - 1;
                while (leftParens > -1 && (formula[leftParens] !== '(' || parenCount !== 0)) {
                    if (formula[leftParens] === ')') {
                        parenCount++;
                    }
                    // else if (formula[leftParens] === ')') {
                    //     parenCount--;
                    // }
                    leftParens--;
                }
                if (leftParens === -1) {
                    throw new FormulaError(this.parent.formulaErrorStrings[FormulasErrorsStrings.MismatchedParentheses]);
                }
                let i = leftParens - 1;
                while (i > -1 && (this.parent.isChar(formula[i]))) {
                    i--;
                }
                const len = leftParens - i - 1;
                const libFormula = this.parent.substring(formula, i + 1, len);
                if (len > 0 && !isNullOrUndefined(this.parent.getFunction(libFormula))) {
                    let substr = this.parent.substring(formula, leftParens, rightParens - leftParens + 1);
                    const argsSep = this.parent.getParseArgumentSeparator();
                    if (libFormula === 'AREAS') {
                        this.ignoreBracet = true;
                    }
                    else {
                        this.ignoreBracet = false;
                        if (libFormula.includes('IFS') && libFormula !== 'COUNTIFS' && substr.includes('{')) {
                            const leftBraceIdx = substr.indexOf('{');
                            const criteriaStr = this.parent.substring(substr, leftBraceIdx, substr.indexOf('}') - leftBraceIdx + 1);
                            substr = substr.split(criteriaStr).join(criteriaStr.split(argsSep).join(this.parent.tic + this.parent.tic));
                        }
                    }
                    try {
                        let args;
                        substr = substr.split('(').join('').split(')').join('');
                        substr = '(' + this.formulaAutoCorrection(substr, args) + ')';
                    }
                    catch (ex) {
                        const args = {
                            message: ex.message, exception: ex,
                            isForceCalculable: ex.formulaCorrection, computeForceCalculate: false
                        };
                        if (!args.isForceCalculable) {
                            throw this.parent.formulaErrorStrings[FormulasErrorsStrings.ImproperFormula];
                        }
                        if (!this.isFailureTriggered) {
                            this.parent.trigger('onFailure', args);
                            this.isFailureTriggered = true;
                            bracCount = bracCount + 1;
                        }
                        args.computeForceCalculate = bracCount > 0 ? true : args.computeForceCalculate;
                        if (args.isForceCalculable) {
                            if (args.computeForceCalculate) {
                                substr = substr.split('(').join('').split(')').join('');
                                substr = '(' + this.formulaAutoCorrection(substr, args) + ')';
                            }
                            else {
                                throw this.parent.formulaErrorStrings[FormulasErrorsStrings.ImproperFormula];
                            }
                        }
                        else {
                            throw this.parent.formulaErrorStrings[FormulasErrorsStrings.ImproperFormula];
                        }
                    }
                    substr = this.markNamedRanges(substr);
                    substr = this.swapInnerParens(substr);
                    substr = this.addParensToArgs(substr);
                    const id = substr.lastIndexOf(argsSep);
                    if (id === -1) {
                        if (substr.length > 2 && substr[0] === '(' && substr[substr.length - 1] === ')') {
                            if (substr[1] !== '{' && substr[1] !== '(') {
                                substr = substr.substring(0, substr.length - 1) + '}' + substr.substring(substr.length - 1);
                                substr = substr[0] + '{' + substr.substring(1);
                            }
                        }
                    }
                    formula = formula.substring(0, i + 1) + 'q' + this.parent.substring(formula, i + 1, len) +
                        (substr.split('(').join(this.parent.leftBracket))
                            .split(')').join(this.parent.rightBracket) + formula.substring(rightParens + 1);
                }
                else if (len > 0) {
                    return this.parent.getErrorStrings()[CommonErrors.Name];
                }
                else {
                    let s = this.emptyStr;
                    if (leftParens > 0) {
                        s = formula.substring(0, leftParens);
                    }
                    s = s + '{' + this.parent.substring(formula, leftParens + 1, rightParens - leftParens - 1) + '}';
                    if (rightParens < formula.length) {
                        s = s + formula.substring(rightParens + 1);
                    }
                    s = this.markNamedRanges(s);
                    formula = s;
                }
                rightParens = formula.indexOf(')');
            }
        }
        formula = (formula.split('{').join('(')).split('}').join(')');
        return formula;
    }
    /**
     * @hidden
     * @param {string} fSubstr - specify the string
     * @returns {string} - swap inner parens.
     */
    swapInnerParens(fSubstr) {
        if (fSubstr.length > 2) {
            fSubstr = fSubstr[0] + fSubstr.substr(1, fSubstr.length - 2).split('(').join('{').split(')').join('}') + fSubstr[fSubstr.length - 1];
        }
        return fSubstr;
    }
    /**
     * @hidden
     * @param {string} fSubstr - specify the string
     * @returns {string} - add parens to args.
     */
    addParensToArgs(fSubstr) {
        if (fSubstr.length === 0) {
            return this.emptyStr;
        }
        const rightSides = [];
        rightSides.push(this.parent.getParseArgumentSeparator());
        rightSides.push(this.parent.rightBracket);
        let id = fSubstr.lastIndexOf(this.parent.getParseArgumentSeparator());
        let k = 0;
        if (id === -1) {
            if (fSubstr.length > 2 && fSubstr[0] === '(' && fSubstr[fSubstr.length - 1] === ')') {
                if (fSubstr[1] !== '{' && fSubstr[1] !== '(') {
                    fSubstr = fSubstr.substring(0, fSubstr.length - 1) + '}' + fSubstr.substring(fSubstr.length - 1);
                    fSubstr = fSubstr[0] + '{' + fSubstr.substring(1);
                }
                else {
                    const marker = ['+', '-', '*', '/'];
                    id = this.lastIndexOfAny(fSubstr, marker);
                    if (k === 0 && fSubstr[fSubstr.length - 1] === ')') {
                        k = fSubstr.length - 1;
                    }
                    if (k > 0) {
                        if (fSubstr[id + 1] !== '{' && fSubstr[id - 1] === '}') {
                            fSubstr = fSubstr.substr(0, k) + '}' + fSubstr.substr(k);
                            fSubstr = fSubstr.substr(0, id + 1) + '{' + fSubstr.substr(id + 1);
                        }
                    }
                }
            }
        }
        else {
            let oneTimeOnly = true;
            while (id > -1) {
                let j = this.indexOfAny(fSubstr.substring(id + 1, fSubstr.length), rightSides);
                if (j >= 0) {
                    j = id + j + 1;
                }
                else if (j === -1 && fSubstr[fSubstr.length - 1] === ')') {
                    j = fSubstr.length - 1;
                }
                if (j > 0) {
                    if (fSubstr[id + 1] !== '{' && fSubstr[j - 1] !== '}' && fSubstr[j - 1] !== '¢') {
                        fSubstr = fSubstr.substr(0, j).trim() + '}' + fSubstr.substr(j);
                        fSubstr = fSubstr.substr(0, id + 1) + '{' + fSubstr.substr(id + 1).trim();
                    }
                }
                id = fSubstr.substr(0, id).lastIndexOf(this.parent.getParseArgumentSeparator());
                if (oneTimeOnly && id === -1 && fSubstr[0] === '(') {
                    id = 0;
                    oneTimeOnly = false;
                }
            }
        }
        fSubstr = fSubstr.split('{}').join(this.emptyStr);
        return fSubstr;
    }
    /**
     * @hidden
     * @param {string} text - specify the text
     * @param {string[]} operators - specify the operators
     * @returns {number} - returns last Index Of Any.
     */
    lastIndexOfAny(text, operators) {
        for (let i = text.length - 1; i > -1; i--) {
            if (operators.indexOf(text[i]) > -1) {
                return i;
            }
        }
        return -1;
    }
    /**
     * @hidden
     * @param {string} formula - specify the formula
     * @returns {string} - mark Named Ranges.
     */
    markNamedRanges(formula) {
        const markers = [')', this.parent.getParseArgumentSeparator(), '}', '+', '-', '*', '/', '<', '>', '=', '&', ':'];
        let i = (formula.length > 0 && (formula[0] === '(' || formula[0] === '{')) ? 1 : 0;
        if (formula.indexOf('#N/A') > -1) {
            formula = formula.split('#N/A').join('#N~A');
        }
        if (formula.indexOf('#DIV/0!') > -1) {
            formula = formula.split('#DIV/0!').join('#DIV~0!');
        }
        let end = this.indexOfAny(formula.substring(i), markers);
        while (end > -1 && end + i < formula.length) {
            let scopedRange = this.emptyStr;
            let s = null;
            if ((this.parent.substring(formula, i, end)).indexOf('[') > -1) {
                s = this.getTableRange(this.parent.substring(formula, i, end));
            }
            else if (this.parent.storedData.has(this.parent.substring(formula, i, end))) {
                s = this.checkForNamedRangeAndKeyValue(this.parent.substring(formula, i, end));
            }
            else if (this.parent.namedRanges.has(this.parent.substring(formula, i, end))) {
                s = this.checkForNamedRangeAndKeyValue(this.parent.substring(formula, i, end));
            }
            if (isNullOrUndefined(s)) {
                scopedRange = this.checkScopedRange(this.parent.substring(formula, i, end));
                if (scopedRange !== 'NaN') {
                    this.findNamedRange = true;
                    s = scopedRange;
                }
                else if (this.parent.substring(formula, i, end).startsWith(this.sheetToken.toString())) ;
                if (!isNullOrUndefined(s) && this.findNamedRange) {
                    if (s.indexOf(this.fixedReference) > -1) {
                        s = s.split(this.fixedReference).join(this.emptyStr);
                    }
                }
            }
            if (!isNullOrUndefined(s)) {
                s = s.toUpperCase();
                s = this.parent.setTokensForSheets(s);
                s = this.markLibraryFormulas(s);
            }
            if (!isNullOrUndefined(s) && s !== this.emptyStr) {
                formula = formula.substring(0, i) + s + formula.substring(i + end);
                i += s.length + 1;
            }
            else {
                i += end + 1;
                while (i < formula.length && !this.parent.isUpperChar(formula[i]) && formula[i] !== this.sheetToken) {
                    i++;
                }
            }
            end = i;
            if (i < formula.length - 1 && formula[i] === '{') {
                i = i + 1;
            }
            end = this.indexOfAny(formula.substring(i), markers);
            while (end === 0 && i < formula.length - 1) {
                i++;
                end = this.indexOfAny(formula.substring(i), markers);
            }
            if ((end === -1 || formula.substring(i).indexOf('[') > -1) && i < formula.length) {
                if (formula.substring(i).indexOf('[') > -1) {
                    s = this.getTableRange(formula.substring(i));
                }
                else {
                    if (this.parent.storedData.has(formula.substring(i))) {
                        s = this.parent.storedData.size > 0 ? this.checkForNamedRangeAndKeyValue(formula.substring(i)) : s;
                    }
                    else {
                        s = this.parent.namedRanges.size > 0 ? this.checkForNamedRangeAndKeyValue(formula.substring(i)) : s;
                    }
                }
                if (isNullOrUndefined(s)) {
                    scopedRange = this.checkScopedRange(formula.substring(i));
                    if (scopedRange !== 'NaN') {
                        s = scopedRange;
                    }
                }
                if (!isNullOrUndefined(s) && s !== this.emptyStr) {
                    s = s.toUpperCase();
                    s = this.parent.setTokensForSheets(s);
                    s = this.markLibraryFormulas(s);
                    if (s != null) {
                        const val = formula.substring(i);
                        if (val[val.length - 1] === ')') {
                            formula = formula.substring(0, i) + s + ')';
                        }
                        else {
                            formula = formula.substring(0, i) + s;
                        }
                        i += s.toString().length + 1;
                    }
                }
                end = (i < formula.length) ? this.indexOfAny(formula.substring(i), markers) : -1;
            }
        }
        if (formula.indexOf('#N~A') > -1) {
            formula = formula.split('#N~A').join('#N/A');
        }
        if (formula.indexOf('#DIV~0!') > -1) {
            formula = formula.split('#DIV~0!').join('#DIV/0!');
        }
        return formula;
    }
    /**
     * @hidden
     * @param {string} text - specify the text.
     * @returns {string} - check For Named Range And Key Value
     */
    checkForNamedRangeAndKeyValue(text) {
        let scopedRange = this.emptyStr;
        if (text.indexOf('[') > -1) {
            const namerangeValue = this.getTableRange(text);
            if (!isNullOrUndefined(namerangeValue)) {
                this.findNamedRange = true;
                text = namerangeValue;
            }
        }
        scopedRange = this.checkScopedRange(text);
        if (scopedRange !== 'NaN') {
            this.findNamedRange = true;
            text = scopedRange;
        }
        else {
            if (text.indexOf(this.sheetToken) > -1) {
                const sheet = this.parent.getSheetFamilyItem(this.parent.grid);
                let value = text.split('"').join(this.emptyStr);
                value = value.substr(0, value.indexOf(this.sheetToken));
                if (sheet.sheetNameToToken.has(value.toUpperCase())) {
                    /* eslint-disable */
                    let sheetIndex = parseInt(sheet.sheetNameToToken.get(value.toUpperCase()).split(this.sheetToken).join(this.emptyStr));
                    // if (!ej.isNullOrUndefined(this.parentObject) && this.parentObject.pluginName == "ejSpreadsheet") {
                    //     var name = text.replace(value, this.parentObject.model.sheets[(sheetIndex + 1)].sheetInfo.text.toUpperCase()).split("'").join(this._string_empty);
                    //     if (this.getNamedRanges().length > 0 && this.getNamedRanges().contains(name.toUpperCase())) {
                    //         text = name;
                    //     }
                    // }
                    /* tslint-enable */
                }
            }
            if (this.parent.storedData.size > 0 && this.parent.storedData.has(text)) {
                text = 'A' + this.parent.colIndex(text);
            }
            if (this.parent.namedRanges.size > 0 && this.parent.namedRanges.has(text.toUpperCase())) {
                if (!isNullOrUndefined(this.parent.parentObject)) {
                    text = this.parse(this.parent.namedRanges.get(text.toUpperCase()));
                }
                else {
                    text = this.parse(this.parent.namedRanges.get(text.toUpperCase()));
                    text = this.parent.setTokensForSheets(text);
                    if (text.indexOf(this.fixedReference) > -1) {
                        text.split(this.fixedReference).join(this.emptyStr);
                    }
                    this.findNamedRange = true;
                }
            }
            if (this.findNamedRange) {
                if (text[0] !== '!' && text[0] !== 'q' && text[0] !== 'bq') {
                    text = this.parent.setTokensForSheets(text);
                    if (text.indexOf(this.fixedReference) > -1) {
                        text = text.split(this.fixedReference).join(this.emptyStr);
                    }
                }
            }
        }
        return text;
    }
    getTableRange(text) {
        text = text.replace(' ', this.emptyStr).toUpperCase();
        let name = text.replace(']', this.emptyStr).replace('#DATA', this.emptyStr);
        let tableName = name;
        if (name.indexOf(this.parent.getParseArgumentSeparator()) > -1) {
            tableName = name.substring(0, name.indexOf(this.parent.getParseArgumentSeparator())).replace('[', this.emptyStr);
            name = name.replace('[', this.emptyStr).replace(this.parent.getParseArgumentSeparator(), '_');
        }
        let range = this.emptyStr;
        return name.toUpperCase();
    }
    findNextEndIndex(formula, loc) {
        let count = 0;
        let l = loc;
        let found = false;
        while (!found && loc < formula.length) {
            if (formula[l] === '[') {
                count++;
            }
            else if (formula[l] === ']') {
                count--;
                if (count === 0) {
                    found = true;
                }
            }
            loc++;
        }
        loc = loc - l;
        return loc;
    }
    ;
}

var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Represents the calculate library.
 */
let Calculate = class Calculate extends Base {
    /**
     * Base constructor for creating Calculate library.
     *
     * @param {Object} parent - specify the parent
     */
    constructor(parent) {
        super(null, null);
        this.lFormulas = new Map();
        /** @hidden */
        this.storedData = new Map();
        this.keyToRowsMap = new Map();
        this.rowsToKeyMap = new Map();
        /** @hidden */
        this.rightBracket = String.fromCharCode(161);
        /** @hidden */
        this.leftBracket = String.fromCharCode(162);
        /** @hidden */
        this.sheetToken = '!';
        this.emptyString = '';
        this.leftBrace = '{';
        this.rightBrace = '}';
        this.cell = this.emptyString;
        this.cellPrefix = '!0!A';
        this.treatEmptyStringAsZero = false;
        /** @hidden */
        this.tic = '"';
        /** @hidden */
        this.singleTic = '\'';
        /** @hidden */
        this.trueValue = 'TRUE';
        /** @hidden */
        this.falseValue = 'FALSE';
        this.parseDecimalSeparator = '.';
        /** @hidden */
        this.arithMarker = String.fromCharCode(180);
        /** @hidden */
        this.arithMarker2 = this.arithMarker + this.arithMarker;
        this.dependentCells = null;
        this.dependentFormulaCells = null;
        this.minValue = Number.MIN_SAFE_INTEGER;
        this.maxValue = Number.MAX_SAFE_INTEGER;
        this.categoryCollection = ['All'];
        this.dependencyLevel = 0;
        /** @hidden */
        this.randomValues = new Map();
        /** @hidden */
        this.isRandomVal = false;
        /** @hidden */
        this.randCollection = [];
        /** @hidden */
        this.dependencyCollection = [];
        /** @hidden */
        this.uniqueRange = [];
        /**
         * @hidden
         */
        this.formulaErrorStrings = [
            'binary operators cannot start an expression',
            'cannot parse',
            'bad library',
            'invalid char in front of',
            'number contains 2 decimal points',
            'expression cannot end with an operator',
            'invalid characters following an operator',
            'invalid character in number',
            'mismatched parentheses',
            'unknown formula name',
            'requires a single argument',
            'requires 3 arguments',
            'invalid Math argument',
            'requires 2 arguments',
            '#NAME?',
            'too complex',
            '#CIRCULARREF!',
            'missing formula',
            'improper formula',
            'invalid expression',
            'cell empty',
            'bad formula',
            'empty expression',
            '',
            'mismatched string quotes',
            'wrong number of arguments',
            'invalid arguments',
            'iterations do not converge',
            'Control is already registered',
            'Calculation overflow',
            'Missing sheet',
            'cannot_parse',
            'expression_cannot_end_with_an_operator',
            '#SPILL!',
            '#DIV/0!'
        ];
        this.errorStrings = null;
        this.parseArgumentSeparator = ',';
        this.dateTime1900 = new Date(1900, 0, 1, 0, 0, 0);
        this.isParseDecimalSeparatorChanged = false;
        this.isArgumentSeparatorChanged = false;
        this.sheetFamilyID = 0;
        this.defaultFamilyItem = null;
        this.sheetFamiliesList = null;
        this.modelToSheetID = null;
        /** @hidden */
        this.tokenCount = 0;
        this.sortedSheetNames = null;
        this.tempSheetPlaceHolder = String.fromCharCode(133);
        /** @hidden */
        this.namedRanges = new Map();
        this.formulaInfoTable = null;
        this.millisecondsOfaDay = 24 * 60 * 60 * 1000;
        this.parseDateTimeSeparator = '/';
        new BasicFormulas(this);
        this.parentObject = isNullOrUndefined(parent) ? this : parent;
        this.grid = this.parentObject;
        this.parser = new Parser(this);
    }
    get libraryFormulas() {
        return this.lFormulas;
    }
    set libraryFormulas(formulaColl) {
        this.lFormulas.set(formulaColl.fName, { handler: formulaColl.handler, category: formulaColl.category, description: formulaColl.description });
    }
    /**
     * To get the argument separator to split the formula arguments.
     *
     * @returns {string} - To get the argument separator to split the formula arguments.
     */
    getParseArgumentSeparator() {
        const seperator = ',';
        if (!this.isArgumentSeparatorChanged && seperator !== this.parseArgumentSeparator) {
            this.parseArgumentSeparator = seperator;
        }
        return this.parseArgumentSeparator;
    }
    /**
     * To set the argument separator to split the formula arguments.
     *
     * @param {string} value - Argument separator based on the culture.
     * @returns {void} - To set the argument separator to split the formula arguments.
     */
    setParseArgumentSeparator(value) {
        this.parseArgumentSeparator = value;
        this.isArgumentSeparatorChanged = true;
    }
    /**
     * To get the date separator to split the date value.
     *
     * @returns {string} - To get the date separator to split the date value.
     */
    getParseDateTimeSeparator() {
        return this.parseDateTimeSeparator;
    }
    /**
     * To set whether the empty string is treated as zero or not.
     *
     * @param {boolean} value - specify the boolean.
     * @returns {void} - To set whether the empty string is treated as zero or not.
     */
    setTreatEmptyStringAsZero(value) {
        this.treatEmptyStringAsZero = value;
    }
    /**
     * To get whether the empty string is treated as zero or not.
     *
     * @returns {boolean} - To get whether the empty string is treated as zero or not.
     */
    getTreatEmptyStringAsZero() {
        return this.treatEmptyStringAsZero;
    }
    /**
     * To set the date separator to split the date value.
     *
     * @param {string} value - Argument separator based on the culture.
     * @returns {void} - To set the date separator to split the date value.
     */
    setParseDateTimeSeparator(value) {
        this.parseDateTimeSeparator = value;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onPropertyChanged(newProp, oldProp) {
        /** code snippets */
    }
    getModuleName() {
        return 'calculate';
    }
    /**
     * @hidden
     * @returns {string} - get Formula Character.
     */
    getFormulaCharacter() {
        return '=';
    }
    /**
     * @hidden
     * @param {string} text - specify the text
     * @returns {boolean} - Returns boolean value.
     */
    isUpperChar(text) {
        const charCode = text.charCodeAt(0);
        return charCode > 64 && charCode < 91;
    }
    resetKeys() {
        this.storedData.clear();
        this.keyToRowsMap.clear();
        this.rowsToKeyMap.clear();
    }
    /**
     * @hidden
     * @param {string} cellRef -  specify the cell reference
     * @returns {void} - update Dependent Cell
     */
    updateDependentCell(cellRef) {
        let formulaCell = this.cell;
        if (formulaCell !== this.emptyString) {
            const family = this.getSheetFamilyItem(this.grid);
            if (family.sheetNameToParentObject) {
                if (!formulaCell.includes(this.sheetToken)) {
                    formulaCell = family.parentObjectToToken.get(this.grid) + formulaCell;
                }
                if (!cellRef.includes(this.sheetToken)) {
                    cellRef = family.parentObjectToToken.get(this.grid) + cellRef;
                }
            }
            if (formulaCell !== cellRef) {
                const dependentCellMap = this.getDependentCells();
                if (!dependentCellMap.has(cellRef)) {
                    dependentCellMap.set(cellRef, []);
                }
                const dependentCells = dependentCellMap.get(cellRef);
                if (dependentCells.indexOf(formulaCell) === -1) {
                    const formulaDependentCellMap = this.getDependentFormulaCells();
                    const cellRefObj = {};
                    const checkCircularReference = (refCell) => {
                        if (formulaDependentCellMap.has(refCell)) {
                            const formalaRefCells = formulaDependentCellMap.get(refCell);
                            if (formalaRefCells.has(formulaCell)) {
                                throw this.formulaErrorStrings[FormulasErrorsStrings.CircularReference];
                            }
                            else if (!cellRefObj[refCell]) {
                                cellRefObj[refCell] = true;
                                formalaRefCells.forEach((refCell) => {
                                    checkCircularReference(refCell);
                                });
                            }
                        }
                    };
                    checkCircularReference(cellRef);
                    dependentCells.push(formulaCell);
                    if (!formulaDependentCellMap.has(formulaCell)) {
                        formulaDependentCellMap.set(formulaCell, new Map());
                        formulaDependentCellMap.get(formulaCell).set(cellRef, cellRef);
                    }
                    else if (!formulaDependentCellMap.get(formulaCell).has(cellRef)) {
                        formulaDependentCellMap.get(formulaCell).set(cellRef, cellRef);
                    }
                }
            }
        }
    }
    /**
     * @hidden
     * @returns {Map<string, string[]>} - get Dependent Cells
     */
    getDependentCells() {
        if (this.dependentCells == null) {
            this.dependentCells = new Map();
        }
        return this.dependentCells;
    }
    /**
     * @hidden
     * @returns {Map<string, Map<string, string>>} - get Dependent Formula Cells
     */
    getDependentFormulaCells() {
        if (this.isSheetMember()) {
            const family = this.getSheetFamilyItem(this.grid);
            if (family.sheetDependentFormulaCells == null) {
                family.sheetDependentFormulaCells = new Map();
            }
            return family.sheetDependentFormulaCells;
        }
        else {
            if (this.dependentFormulaCells == null) {
                this.dependentFormulaCells = new Map();
            }
            return this.dependentFormulaCells;
        }
    }
    /**
     * To get library formulas collection.
     *
     * @returns {Map<string, Function>} - To get library formulas collection.
     */
    getLibraryFormulas() {
        return this.lFormulas;
    }
    /**
     * To get library function.
     *
     * @param {string} libFormula - Library formula to get a corresponding function.
     * @returns {Function} - To get library function.
     */
    getFunction(libFormula) {
        if (this.getLibraryFormulas().has(libFormula.toUpperCase())) {
            return this.getLibraryFormulas().get(libFormula.toUpperCase()).handler;
        }
        else {
            return null;
        }
    }
    /**
     * @hidden
     * @param {string} val - specify the value.
     * @returns {Date} - convert integer to date.
     */
    intToDate(val) {
        let dateVal = Number(val);
        dateVal = (dateVal > 0 && dateVal < 1) ? (1 + dateVal) : (dateVal === 0) ? 1 : dateVal;
        if (dateVal > 60) {
            dateVal -= 1; // Due to leap year issue of 1900 in MSExcel.
        }
        const startDate = new Date('01/01/1900');
        const startDateUTC = Date.UTC(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), startDate.getHours(), startDate.getMinutes(), startDate.getSeconds(), startDate.getMilliseconds());
        return new Date(new Date(((dateVal - 1) * (1000 * 3600 * 24)) + startDateUTC).toUTCString().replace(' GMT', ''));
    }
    getFormulaInfoTable() {
        if (this.isSheetMember()) {
            const family = this.getSheetFamilyItem(this.grid);
            if (family.sheetFormulaInfotable === null) {
                family.sheetFormulaInfotable = new Map();
            }
            return family.sheetFormulaInfotable;
        }
        else {
            if (this.formulaInfoTable === null) {
                this.formulaInfoTable = new Map();
            }
            return this.formulaInfoTable;
        }
    }
    /**
     * To get the formula text.
     *
     * @returns {void} - To get the formula text.
     */
    getParseDecimalSeparator() {
        const seperator = '.';
        if (!this.isParseDecimalSeparatorChanged && seperator !== this.parseDecimalSeparator) {
            this.parseDecimalSeparator = seperator;
        }
        return this.parseDecimalSeparator;
    }
    /**
     * To get the formula text.
     *
     * @param {string} value - Specifies the decimal separator value.
     * @returns {void} - To get the formula text.
     */
    setParseDecimalSeparator(value) {
        this.parseDecimalSeparator = value;
        this.isParseDecimalSeparatorChanged = true;
    }
    /**
     * @hidden
     * @param {string} cellRef -  specify the cell reference
     * @returns {string} - get sheet token.
     */
    getSheetToken(cellRef) {
        let i = 0;
        let temp = this.emptyString;
        if (i < cellRef.length && cellRef[i] === this.sheetToken) {
            i++;
            while (i < cellRef.length && cellRef[i] !== this.sheetToken) {
                i++;
            }
            temp = cellRef.substring(0, i + 1);
        }
        if (i < cellRef.length) {
            return temp;
        }
        throw this.formulaErrorStrings[FormulasErrorsStrings.BadIndex];
    }
    /**
     * @hidden
     * @param {Object} grd - specify the id
     * @returns {number} - get sheet id.
     */
    getSheetID(grd) {
        const family = this.getSheetFamilyItem(grd);
        if (family.sheetNameToParentObject != null && family.sheetNameToParentObject.size > 0) {
            let token = family.parentObjectToToken.get(grd);
            if (token) {
                token = token.split(this.sheetToken).join(this.emptyString);
                const id = this.parseFloat(token);
                if (!this.isNaN(id)) {
                    return id;
                }
            }
        }
        return -1;
    }
    /**
     * @hidden
     * @param {string | number} value - specify the value.
     * @returns {number} - parse float
     */
    parseFloat(value) {
        let convertedNum = Number(value);
        if (isNaN(convertedNum) && typeof value === 'string' && value.includes(',')) {
            convertedNum = Number(value.split(',').join(''));
        }
        return convertedNum;
    }
    /**
     * To get the row index of the given cell.
     *
     * @param {string} cell - Cell address for getting row index.
     * @returns {number} - To get the row index of the given cell.
     */
    rowIndex(cell) {
        let i = 0;
        let isLetter = false;
        if (i < cell.length && cell[i] === this.sheetToken) {
            i++;
            while (i < cell.length && cell[i] !== this.sheetToken) {
                i++;
            }
            i++;
        }
        while (i < cell.length && this.isChar(cell[i])) {
            isLetter = true;
            i++;
        }
        const result = parseInt(cell.substring(i), 10);
        if (i < cell.length && !this.isNaN(result)) {
            return result;
        }
        if (isLetter) {
            return -1;
        }
        throw this.formulaErrorStrings[FormulasErrorsStrings.BadIndex];
    }
    /**
     * To get the column index of the given cell.
     *
     * @param {string} cell - Cell address for getting column index.
     * @returns {number} - To get the column index of the given cell.
     */
    colIndex(cell) {
        let j = 0;
        let k = 0;
        cell = cell.toUpperCase();
        if (j < cell.length && cell[j] === this.sheetToken) {
            j++;
            while (j < cell.length && cell[j] !== this.sheetToken) {
                j++;
            }
            j++;
        }
        while (j < cell.length && this.isChar(cell[j])) {
            const charCode = cell[j].charCodeAt(0);
            k = k * 26 + charCode - 64;
            j++;
        }
        if (k === 0) {
            return -1;
        }
        return k;
    }
    /**
     * To get the valid error strings.
     *
     * @hidden
     * @returns {string[]} - to get error strings.
     */
    getErrorStrings() {
        if (this.errorStrings === null) {
            this.errorStrings = ['#N/A', '#VALUE!', '#REF!', '#DIV/0!', '#NUM!', '#NAME?', '#NULL!', '#CALC!'];
        }
        return this.errorStrings;
    }
    /**
     * @hidden
     * @param {string} text - specify the text
     * @param {number} startIndex - specify the start index
     * @param {number} length - specify the length
     * @returns {string} - Returns sub string
     */
    substring(text, startIndex, length) {
        return text.substring(startIndex, length + startIndex);
    }
    /**
     * @hidden
     * @param {string} c - specify the characer of the string
     * @returns {boolean} - Return the boolean type
     */
    isChar(c) {
        if ((c.charCodeAt(0) >= 65 && c.charCodeAt(0) <= 90) || (c.charCodeAt(0) >= 97 && c.charCodeAt(0) <= 122)) {
            return true;
        }
        return false;
    }
    /**
     * @hidden
     * @param {Object} model - specify the model
     * @param {Object} calcId - specify the calculate instance id.
     * @returns {CalcSheetFamilyItem} - get Sheet Family Item.
     */
    getSheetFamilyItem(model, calcId) {
        if (this.sheetFamilyID === 0) {
            if (this.defaultFamilyItem == null) {
                this.defaultFamilyItem = new CalcSheetFamilyItem();
            }
            return this.defaultFamilyItem;
        }
        if (this.sheetFamiliesList == null) {
            this.sheetFamiliesList = new Map();
        }
        if (calcId === undefined) {
            calcId = this.modelToSheetID.get(model);
        }
        if (!this.sheetFamiliesList.has(calcId)) {
            this.sheetFamiliesList.set(calcId, new CalcSheetFamilyItem());
        }
        return this.sheetFamiliesList.get(calcId);
    }
    /**
     * Register a key value pair for formula.
     *
     * @param {string} key - Key for formula reference .
     * @param {string | number} value - Value for the corresponding key.
     * @returns {void} - Register a key value pair for formula.
     */
    setKeyValue(key, value) {
        key = key.toUpperCase();
        const str = value.toString().trim();
        if (!this.storedData.get(key) || str.indexOf(this.leftBrace) === 0) {
            this.storedData.set(key, new FormulaInfo());
            this.keyToRowsMap.set(key, this.keyToRowsMap.size + 1);
            this.rowsToKeyMap.set(this.rowsToKeyMap.size + 1, key);
        }
        const fInfo = this.storedData.get(key);
        if (fInfo.getFormulaText() != null && fInfo.getFormulaText().length > 0 && fInfo.getFormulaText() !== str) {
            const s1 = this.cellPrefix + this.keyToRowsMap.get(key).toString();
            const formulaDependent = this.getDependentFormulaCells().get(s1);
            if (formulaDependent != null) {
                this.clearFormulaDependentCells(s1);
            }
        }
        if (str.length > 0 && str[0] === this.getFormulaCharacter()) {
            fInfo.setFormulaText(str);
        }
        else if (fInfo.getFormulaValue() !== str) {
            fInfo.setFormulaText('');
            fInfo.setParsedFormula('');
            fInfo.setFormulaValue(str);
        }
    }
    /**
     * @hidden
     * @param {string} cell - specify the cell
     * @returns {void} - clears the  Formula Dependent Cells.
     */
    clearFormulaDependentCells(cell) {
        const dependentFormula = this.getDependentFormulaCells().get(cell);
        if (dependentFormula) {
            dependentFormula.forEach((value, key) => {
                const s = key;
                const dependent = this.getDependentCells().get(s);
                this.arrayRemove(dependent, cell);
                if (dependent.length === 0) {
                    this.getDependentCells().delete(s);
                }
            });
            this.getDependentFormulaCells().delete(cell);
        }
    }
    arrayRemove(array, value) {
        const index = array.indexOf(value);
        if (index !== -1) {
            array.splice(index, 1);
        }
        return array;
    }
    /**
     * Register a key value pair for formula.
     *
     * @param {string} key - Key for getting the corresponding value.
     * @returns {string | number} - to get key value.
     */
    getKeyValue(key) {
        key = key.toUpperCase();
        if (this.storedData.has(key) !== null) {
            const fInfo = this.storedData.get(key);
            let fText = fInfo.getFormulaText();
            if (fText.length > 0 && fText[0] === this.getFormulaCharacter()) {
                this.cell = this.cellPrefix + this.keyToRowsMap.get(key).toString();
                fText = fText.substring(1);
                try {
                    fInfo.setParsedFormula(this.parser.parseFormula(fText, key));
                }
                catch (ex) {
                    const args = {
                        message: ex.message, exception: ex, isForceCalculable: false,
                        computeForceCalculate: false
                    };
                    this.trigger('onFailure', args);
                    fInfo.setFormulaValue(args.message);
                    return this.storedData.get(key).getFormulaValue();
                }
                try {
                    fInfo.setFormulaValue(this.computeFormula(fInfo.getParsedFormula()));
                }
                catch (ex) {
                    const args = {
                        message: ex.message, exception: ex, isForceCalculable: false,
                        computeForceCalculate: false
                    };
                    this.trigger('onFailure', args);
                    const errorMessage = (typeof args.exception === 'string') ? args.exception : args.message;
                    return (isNullOrUndefined(this.getErrorLine(ex)) ? '' : '#' + this.getErrorLine(ex) + ': ') + errorMessage;
                }
            }
            return this.storedData.get(key).getFormulaValue();
        }
        else {
            return this.emptyString;
        }
    }
    getNamedRanges() {
        return this.namedRanges;
    }
    /**
     * Adds a named range to the NamedRanges collection.
     *
     * @param {string} name - Name of the named range.
     * @param {string} range - Range for the specified name.
     * @returns {boolean} - Adds a named range to the NamedRanges collection.
     */
    addNamedRange(name, range) {
        const sheetScopeName = name.split(this.sheetToken);
        if (sheetScopeName.length > 1) {
            const sheetId = (this.getSheetId(this.grid)).toString();
            const family = this.getSheetFamilyItem(sheetId);
            if (!family.parentObjectToToken.get(sheetId)) {
                return false;
            }
            name = sheetScopeName[0] + this.sheetToken + sheetScopeName[1].toUpperCase();
        }
        else {
            name = name.toUpperCase();
        }
        this.namedRanges.set(name, range);
        return true;
    }
    /**
     * Update the sheet name changes in the named range collection.
     *
     * @hidden
     * @param {string} pName - Previous name of the sheet.
     * @param {string} name -  Current name of the sheet.
     * @returns {void} - Update the sheet name changes in the named range collection.
     */
    updateNamedRange(pName, name) {
        const updatedRange = new Map();
        this.namedRanges.forEach((value, key) => {
            let updatedKey = key;
            if (key.includes(pName)) {
                const range = key.split('!');
                range[0] = name;
                updatedKey = range.join('!');
            }
            updatedRange.set(updatedKey, value);
        });
        this.namedRanges = updatedRange;
    }
    /**
     * Remove the specified named range form the named range collection.
     *
     * @param {string} name - Name of the specified named range.
     * @returns {boolean} - Remove the specified named range form the named range collection.
     */
    removeNamedRange(name) {
        name = name.toUpperCase();
        if (this.namedRanges.get(name) != null) {
            this.namedRanges.delete(name);
            return true;
        }
        return false;
    }
    /**
     * @hidden
     * @param {number} col - specify the column
     * @returns {string} - to convert the alpha.
     */
    convertAlpha(col) {
        const arrCol = [];
        let n = 0;
        const charText = 'A';
        while (col > 0) {
            col--;
            const aCharValue = charText.charCodeAt(0);
            arrCol[n] = String.fromCharCode(col % 26 + aCharValue);
            col = parseInt((col / 26).toString(), 10);
            n++;
        }
        const arr = [];
        for (let i = 0; i < n; i++) {
            arr[n - i - 1] = arrCol[i];
        }
        return arr.join('');
    }
    /**
     * @hidden
     * @param {string} cellRange - specify the cell range.
     * @returns {string} - to get cell collection.
     */
    getCellCollection(cellRange) {
        if (cellRange.indexOf(':') < 0) {
            if (!this.isCellReference(cellRange)) {
                return cellRange.split(this.getParseArgumentSeparator());
            }
            else {
                cellRange = cellRange + ':' + cellRange;
            }
        }
        let token = this.emptyString;
        const sheetTokenIndex = cellRange.indexOf(this.sheetToken);
        if (sheetTokenIndex > -1) {
            const index = sheetTokenIndex;
            let s = index + 1;
            while (s < cellRange.length) {
                if (cellRange[s] === this.sheetToken) {
                    token = cellRange.substr(0, s + 1);
                    break;
                }
                s++;
            }
        }
        let i = cellRange.indexOf(':');
        let row1;
        let row2;
        let col1;
        let col2;
        if (i > 0 && this.isChar(cellRange[i - 1])) {
            let k = i - 2;
            while (k >= 0 && this.isDigit(cellRange[k])) {
                k--;
            }
        }
        row1 = this.rowIndex(this.substring(cellRange, 0, i));
        row2 = this.rowIndex(this.substring(cellRange, i + 1, i + cellRange.length - i - 1));
        col1 = this.colIndex(this.substring(cellRange, 0, i));
        col2 = this.colIndex(this.substring(cellRange, i + 1, i + cellRange.length - i - 1));
        if (row1 > row2) {
            i = row2;
            row2 = row1;
            row1 = i;
        }
        if (col1 > col2) {
            i = col2;
            col2 = col1;
            col1 = i;
        }
        const cells = [];
        let j;
        let c = 0;
        for (i = row1; i <= row2; i++) {
            for (j = col1; j <= col2; j++) {
                cells[c] = token + this.emptyString + this.convertAlpha(j) + i.toString();
                c++;
            }
        }
        return cells;
    }
    /**
     * Compute the given formula.
     *
     * @param {string} formulaText - Specifies to compute the given formula.
     * @param {boolean} isFromComputeExpression - Specifies to confirm it was called from the ComputeExpression function.
     * @returns {string | number} - compute the given formula
     */
    computeFormula(formulaText, isFromComputeExpression) {
        return this.calculateFormula(formulaText, false, isFromComputeExpression);
    }
    calculateFormula(formulaText, refresh, isFromComputeExpression) {
        let parsedText;
        let lastIndexOfq;
        let formulatResult;
        let nestedFormula = false;
        let fNested;
        if (this.parser.isError) {
            return formulaText;
        }
        if (!this.parser.isFormulaParsed) {
            parsedText = this.parser.parseFormula(formulaText);
        }
        else {
            parsedText = formulaText;
        }
        this.parser.isFormulaParsed = false;
        try {
            lastIndexOfq = this.findLastIndexOfq(parsedText);
            if (lastIndexOfq > 0) {
                nestedFormula = true;
            }
            if (parsedText !== this.emptyString && lastIndexOfq > -1) {
                let i = lastIndexOfq + 1;
                while (i > -1) {
                    if (parsedText[i] !== this.rightBracket) {
                        i++;
                        continue;
                    }
                    const sFormula = parsedText.substring(lastIndexOfq, i + 1);
                    const libFormula = sFormula.split(this.leftBracket)[0].split('q').join(this.emptyString);
                    let args;
                    if (this.getLibraryFormulas().get(libFormula.toUpperCase()).isCustom) {
                        args = sFormula.substring(sFormula.indexOf(this.leftBracket) + 1, sFormula.indexOf(this.rightBracket))
                            .split(this.getParseArgumentSeparator());
                        let j = 0;
                        const customArgs = [];
                        let cellCol;
                        for (j = 0; j < args.length; j++) {
                            if (args[j].includes(':') && this.isCellReference(args[j])) {
                                cellCol = this.getCellCollection(args[j]);
                                if (cellCol.length > 1) {
                                    customArgs.push(args[j]);
                                    cellCol.forEach((cell) => {
                                        this.updateDependentCell(cell);
                                    });
                                }
                                else {
                                    customArgs.push(this.getValueFromArg(args[j]));
                                }
                            }
                            else {
                                customArgs.push(this.getValueFromArg(args[j]));
                            }
                        }
                        args = customArgs;
                    }
                    else {
                        const argStr = sFormula.substring(sFormula.indexOf(this.leftBracket) + 1, sFormula.indexOf(this.rightBracket));
                        args = [];
                        const separator = this.getParseArgumentSeparator();
                        let parameter = '';
                        let isInString;
                        for (let idx = 0, len = argStr.length - 1; idx <= len; idx++) {
                            if (argStr[idx] === '"') {
                                isInString = !isInString;
                            }
                            if (argStr[idx] === separator && !isInString) {
                                args.push(parameter);
                                parameter = '';
                                if (idx === len) {
                                    args.push(parameter);
                                }
                            }
                            else {
                                parameter += argStr[idx];
                                if (idx === len) {
                                    args.push(parameter);
                                }
                            }
                        }
                        if (!args.length) {
                            args = [''];
                        }
                        if (nestedFormula && libFormula) {
                            const formulas = ['IF', 'INDEX', 'SORT', 'T', 'EXACT', 'PROPER', 'DOLLAR', 'DATE', 'TEXT'];
                            if (formulas.some((formula) => formula === libFormula)) {
                                args.push('nestedFormulaTrue');
                            }
                            if (libFormula === 'IF') {
                                args.push('nestedFormulaTrue');
                            }
                        }
                        if (isFromComputeExpression && libFormula === 'UNIQUE') {
                            args.push('isComputeExp');
                        }
                    }
                    formulatResult = isNullOrUndefined(this.getFunction(libFormula)) ? this.getErrorStrings()[CommonErrors.Name] :
                        this.getFunction(libFormula)(...args);
                    if (nestedFormula) {
                        fNested = this.processNestedFormula(parsedText, sFormula, formulatResult);
                        const q = this.findLastIndexOfq(fNested);
                        if (q === 0) {
                            nestedFormula = false;
                        }
                        if (q === -1) {
                            formulatResult = this.computeValue(fNested, refresh);
                        }
                        lastIndexOfq = i = q;
                        parsedText = fNested;
                        continue;
                    }
                    break;
                }
            }
            else if (this.formulaErrorStrings.indexOf(parsedText) > -1) {
                formulatResult = parsedText;
            }
            else if (parsedText !== this.emptyString && lastIndexOfq === -1) {
                formulatResult = this.computeValue(parsedText, refresh);
            }
        }
        catch (ex) {
            const args = { message: ex.message, exception: ex, isForceCalculable: false, computeForceCalculate: false };
            this.trigger('onFailure', args);
            const errorMessage = (typeof args.exception === 'string') ? args.exception : args.message;
            formulatResult = (isNullOrUndefined(this.getErrorLine(ex)) ? '' : '#' + this.getErrorLine(ex) + ': ') + errorMessage;
        }
        return formulatResult;
    }
    /**
     * @hidden
     * @param {string[]} range - Specify the range.
     * @param {string} isAvgIf - Specify the AVERAGEIF computation.
     * @returns {number[] | string} - To compute the sum if and average if.
     */
    computeSumIfAndAvgIf(range, isAvgIf) {
        if (isNullOrUndefined(range) || range[0] === this.emptyString || range.length === 0) {
            return this.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const argArr = range;
        for (let i = 0; i < argArr.length; i++) {
            if (this.isCellReference(argArr[i]) && isNullOrUndefined(argArr[i].match(/[0-9]/)) &&
                argArr[i].indexOf('!') < 0) {
                const splitArray = argArr[i].split(':');
                argArr[i] = splitArray[0] + '1' + ':' + splitArray[1] + this.spreadSheetUsedRange[0];
            }
        }
        const argCount = argArr.length;
        if (argCount !== 2 && argCount !== 3 && argCount === 0) {
            return this.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        if (argArr[1] === '') {
            return isAvgIf ? this.getErrorStrings()[CommonErrors.DivZero] : '0';
        }
        const rangevalue = argArr[0];
        const isStringVal = argArr[1].startsWith(this.tic) && argArr[1].endsWith(this.tic);
        let criteria = argArr[1].split(this.tic).join(this.emptyString);
        if (criteria.length > 255) {
            return this.getErrorStrings()[CommonErrors.Value];
        }
        const isAsterisk = criteria.includes('*');
        const isQuestionMark = criteria.includes('?');
        let criteriaValue = isAsterisk ? criteria.replace(/\*/g, '').trim() : criteria;
        let isCellReferenceValue = false;
        if (!isStringVal && this.isCellReference(criteriaValue)) {
            criteriaValue = this.getValueFromArg(criteriaValue);
            isCellReferenceValue = true;
        }
        if (isAsterisk) {
            const asteriskIndex = criteria.indexOf('*');
            if (criteria[0] === '*') {
                criteriaValue = '*' + criteriaValue;
            }
            if (criteria[criteria.length - 1] === '*') {
                criteriaValue += '*';
            }
            if (asteriskIndex > 0 && asteriskIndex < criteria.length - 1) {
                criteriaValue = criteria.substring(0, asteriskIndex) + '*' + criteria.substring(asteriskIndex + 1);
            }
        }
        criteria = criteriaValue;
        let opt = this.parser.tokenEqual;
        if (criteria.startsWith('<=')) {
            opt = this.parser.tokenLessEq;
            criteria = criteria.substring(2);
        }
        else if (criteria.startsWith('>=')) {
            opt = this.parser.tokenGreaterEq;
            criteria = criteria.substring(2);
        }
        else if (criteria.startsWith('<>')) {
            opt = this.parser.tokenNotEqual;
            criteria = criteria.substring(2);
        }
        else if (criteria.startsWith('<')) {
            opt = this.parser.tokenLess;
            criteria = criteria.substring(1);
        }
        else if (criteria.startsWith('>')) {
            opt = this.parser.tokenGreater;
            criteria = criteria.substring(1);
        }
        else if (criteria.startsWith('=')) {
            opt = this.parser.tokenEqual;
            criteria = criteria.substring(1);
        }
        if ((!isStringVal && this.isCellReference(criteria) && !isCellReferenceValue) || criteria.includes(this.arithMarker) ||
            (criteria.includes(this.getParseDecimalSeparator()) && !isAsterisk && !isQuestionMark)) {
            criteria = this.getValueFromArg(criteria);
        }
        const checkCriteria = this.parseFloat(criteria);
        const criteriaRangeArray = argArr[0];
        let sumRange = this.getCellCollection(argCount > 2 ? argArr[2] : rangevalue);
        const criteriaRange = this.getCellCollection(criteriaRangeArray);
        if (criteriaRange.length > sumRange.length) {
            const sumEndCol = this.colIndex(sumRange[sumRange.length - 1]) +
                this.colIndex(criteriaRange[criteriaRange.length - 1]) - this.colIndex(criteriaRange[0]);
            const sumrange = argArr[2].split(':');
            sumrange[1] = (this.convertAlpha(sumEndCol) + this.rowIndex(criteriaRange[criteriaRange.length - 1])).toString();
            sumRange = this.getCellCollection(sumrange.join(':'));
        }
        const result = this.getComputeSumIfValue(criteriaRange, sumRange, criteria.toLowerCase(), checkCriteria, opt, isAsterisk, isQuestionMark);
        return [result[0], result[1]];
    }
    /**
     * @hidden
     * @param {string[]} range - specify the range
     * @returns {string} - to compute lookup
     */
    computeLookup(range) {
        let lookupArray;
        let matchArray;
        let lookupRange = [];
        let matchupRange = [];
        const checkCriteria = [];
        const findMaxVal = [];
        let lookupValue;
        let isArrayVector;
        const result = [];
        const argArr = range;
        const argCount = argArr.length;
        if (argCount === 1 || argCount > 3) {
            return this.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        if (argArr[1] === '' || argArr[2] === '') {
            return this.getErrorStrings()[CommonErrors.Value];
        }
        lookupValue = this.getValueFromArg(argArr[0]);
        if (argArr[0].indexOf(this.tic) > -1 && argArr[0].toUpperCase().split(this.tic).join('') !== this.trueValue &&
            argArr[0].toUpperCase().split(this.tic).join('') !== this.falseValue && this.isNaN(this.parseFloat(argArr[0].split(this.tic).join('')))) {
            lookupValue = lookupValue.split(this.tic).join('');
        }
        if (this.getErrorStrings().indexOf(lookupValue) > -1) {
            return lookupValue;
        }
        const rangeSplit = argArr[1].split(':');
        if (rangeSplit.length === 2 && this.isCellReference(rangeSplit[0]) && this.isCellReference(rangeSplit[1]) && argCount === 2) {
            const index = argArr[1].indexOf(':');
            let rowIdx = this.rowIndex(this.substring(argArr[1], 0, index));
            let colIdx = this.colIndex(this.substring(argArr[1], 0, index));
            let endRowIdx = this.rowIndex(this.substring(argArr[1], index + 1, index + argArr[1].length - index - 1));
            let endColIdx = this.colIndex(this.substring(argArr[1], index + 1, index + argArr[1].length - index - 1));
            if (rowIdx > endRowIdx) {
                [rowIdx, endRowIdx] = [endRowIdx, rowIdx];
            }
            if (colIdx > endColIdx) {
                [colIdx, endColIdx] = [endColIdx, colIdx];
            }
            let sheetIdx = '';
            if (argArr[1].indexOf('!') === 0) {
                sheetIdx = argArr[1];
                sheetIdx = sheetIdx.replace('!', '');
                sheetIdx = sheetIdx.indexOf('!');
                sheetIdx = argArr[1].substring(0, sheetIdx + 2);
            }
            const colCount = endColIdx - colIdx + 1;
            const rowCount = endRowIdx - rowIdx + 1;
            if (rowCount > colCount || rowCount === colCount) { // Taller than Wide. vlookup
                lookupArray = sheetIdx + getAlphalabel(colIdx) + rowIdx + ':' + getAlphalabel(colIdx) + endRowIdx;
                matchArray = sheetIdx + getAlphalabel(endColIdx) + rowIdx + ':' + getAlphalabel(endColIdx) + endRowIdx;
            }
            else if (rowCount < colCount) { // Wider than Tall. hlookup
                lookupArray = sheetIdx + getAlphalabel(colIdx) + rowIdx + ':' + getAlphalabel(endColIdx) + rowIdx;
                matchArray = sheetIdx + getAlphalabel(colIdx) + endRowIdx + ':' + getAlphalabel(endColIdx) + endRowIdx;
            }
            if (rowIdx !== endRowIdx || colIdx !== endColIdx) {
                isArrayVector = true;
            }
        }
        if (isArrayVector) {
            lookupRange = this.getCellCollection(lookupArray);
            matchupRange = this.getCellCollection(matchArray);
        }
        else {
            lookupRange = this.getCellCollection(argArr[1]);
            const arrvalue = argCount === 2 ? argArr[1] : argArr[2];
            matchupRange = this.getCellCollection(arrvalue);
            const lookupIndex = getRangeIndexes(argArr[1]);
            const matchIndex = getRangeIndexes(arrvalue);
            const isValidLookup = lookupIndex[1] === lookupIndex[3] ? true : lookupIndex[0] === lookupIndex[2];
            const isValidMatch = matchIndex[1] === matchIndex[3] ? true : matchIndex[0] === matchIndex[2];
            if (!isValidLookup || !isValidMatch) {
                return this.getErrorStrings()[CommonErrors.NA];
            }
        }
        for (let i = 0; i < lookupRange.length; i++) {
            findMaxVal.push(this.getValueFromArg(lookupRange[i]).split(this.tic).join(''));
        }
        const num = findMaxVal.map((value) => { return value === '' ? NaN : Number(value); }).sort((a, b) => a - b);
        const maxVal = num[num.length - 1];
        const minVal = num[0];
        const lookupVal = this.parseFloat(lookupValue);
        if (!this.isNaN(lookupVal)) {
            for (let a = 0; a < num.length; a++) {
                checkCriteria[a] = num[a].toString().split(this.tic).join('');
                if (!isNullOrUndefined(matchupRange[a]) && checkCriteria[a] !== '' && lookupVal === this.parseFloat(checkCriteria[a])) {
                    result.push(this.getValueFromArg(matchupRange[a]).split(this.tic).join('') || '0');
                }
            }
        }
        else {
            for (let j = 0; j < lookupRange.length; j++) {
                checkCriteria[j] = this.getValueFromArg(lookupRange[j]).split(this.tic).join('');
                if (!isNullOrUndefined(matchupRange[j]) && lookupValue !== '' && checkCriteria[j] !== '') {
                    if (lookupValue.toUpperCase() === checkCriteria[j].toUpperCase()) {
                        result.push(this.getValueFromArg(matchupRange[j]).split(this.tic).join('') || '0');
                    }
                    else if (lookupValue.indexOf('*') > -1 || lookupValue.indexOf('?') > -1) {
                        let criteriaValue = lookupValue;
                        if (lookupValue.indexOf('*') > -1) {
                            criteriaValue = criteriaValue.replace(/\*/g, '').trim();
                            if (this.isCellReference(criteriaValue)) {
                                criteriaValue = this.getValueFromArg(criteriaValue);
                            }
                            const asteriskIndex = lookupValue.indexOf('*');
                            if (lookupValue[0] === '*') {
                                criteriaValue = '*' + criteriaValue;
                            }
                            if (lookupValue[lookupValue.length - 1] === '*') {
                                criteriaValue += '*';
                            }
                            if (asteriskIndex > 0 && asteriskIndex < lookupValue.length - 1) {
                                criteriaValue = lookupValue.substring(0, asteriskIndex) + '*' + lookupValue.substring(asteriskIndex + 1);
                            }
                        }
                        const stack = [];
                        const wildcardResult = this.findWildCardValue(criteriaValue.toLowerCase(), checkCriteria[j].toLowerCase());
                        stack.push(wildcardResult);
                        stack.push(lookupValue);
                        if (this.processLogical(stack, 'equal') === this.trueValue) {
                            result.push(this.getValueFromArg(matchupRange[j]).split(this.tic).join('') || '0');
                        }
                    }
                }
            }
        }
        if (result.length > 0) {
            return result[result.length - 1];
        }
        if (lookupVal > maxVal && !isNullOrUndefined(matchupRange[lookupRange.length - 1])) {
            return this.getValueFromArg(matchupRange[lookupRange.length - 1]).split(this.tic).join('') || '0';
        }
        else if (lookupVal < minVal) {
            return this.getErrorStrings()[CommonErrors.NA];
        }
        if (findMaxVal.indexOf(lookupValue.split(this.tic).join('')) < 0 && lookupValue !== this.trueValue && lookupValue !== this.falseValue) {
            if (!this.isNaN(lookupVal) && !this.isNaN(maxVal) && !this.isNaN(minVal)) {
                const temp = [];
                for (let b = 0; b < num.length; b++) {
                    if (lookupVal > num[b]) {
                        temp.push(num[b]);
                    }
                }
                const index = temp.length - 1;
                if (!isNullOrUndefined(matchupRange[index]) && index >= 0) {
                    return this.getValueFromArg(matchupRange[index]).split(this.tic).join('') || '0';
                }
            }
            else if (this.isNaN(lookupVal) && lookupValue !== '' && /^[a-zA-Z!@#$%^&*()_+{}[\]:;<>,.?~\\/-]/.test(lookupValue)) {
                const str = findMaxVal.sort();
                const index = this.findClosestMatch(lookupValue.split(this.tic).join(''), str);
                if (!isNullOrUndefined(matchupRange[index]) && index >= 0) {
                    return this.getValueFromArg(matchupRange[index]).split(this.tic).join('') || '0';
                }
            }
        }
        return this.getErrorStrings()[CommonErrors.NA];
    }
    computeVHLookup(range, isVlookup) {
        const argArr = range;
        if (isNullOrUndefined(argArr) || argArr.length < 3 || argArr.length > 4) {
            return this.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        if (argArr[1] === '') {
            return this.getErrorStrings()[CommonErrors.NA];
        }
        let lookupValue = this.getValueFromArg(argArr[0]);
        if (lookupValue) {
            if (lookupValue.includes(this.tic)) {
                const lookupVal = lookupValue.split(this.tic).join('');
                if (lookupVal && !this.isNumber(lookupVal)) {
                    const lookupValUpper = lookupVal.toUpperCase();
                    if (lookupValUpper !== this.trueValue && lookupValUpper !== this.falseValue) {
                        lookupValue = lookupVal;
                    }
                }
            }
        }
        else {
            lookupValue = '0';
        }
        const errorStrings = this.getErrorStrings();
        if (errorStrings.indexOf(lookupValue) > -1) {
            return lookupValue;
        }
        const colIdxVal = (this.getValueFromArg(argArr[2]) || '0').split(this.tic).join('').toUpperCase();
        const colNumIdx = this.parseFloat(colIdxVal === this.trueValue ? '1' : colIdxVal);
        if (colNumIdx < 1) {
            return errorStrings[CommonErrors.Value];
        }
        let isExactMatchLookup;
        if (argArr[3]) {
            argArr[3] = this.getValueFromArg(argArr[3]).split(this.tic).join('');
            if (errorStrings.indexOf(argArr[3]) > -1) {
                return argArr[3];
            }
            const rangeLookup = argArr[3].toUpperCase();
            if (rangeLookup === this.falseValue || argArr[3] === '0') {
                isExactMatchLookup = true;
            }
            else if (!(rangeLookup === this.trueValue || argArr[3] === '1')) {
                return errorStrings[CommonErrors.Value];
            }
        }
        const rangeArr = argArr[1].split(':');
        let startIdx;
        let endIdx;
        let idx;
        let grid;
        let getLookupRangeValue;
        let getMatchRangeValue;
        if (this.isCellReference(rangeArr[0]) && this.isCellReference(rangeArr[1])) {
            let rowIdx = this.rowIndex(rangeArr[0]);
            let colIdx = this.colIndex(rangeArr[0]);
            let endRowIdx = this.rowIndex(rangeArr[1]);
            let endColIdx = this.colIndex(rangeArr[1]);
            if (rowIdx > endRowIdx) {
                [rowIdx, endRowIdx] = [endRowIdx, rowIdx];
            }
            if (colIdx > endColIdx) {
                [colIdx, endColIdx] = [endColIdx, colIdx];
            }
            if (!(rowIdx > 0 && endRowIdx <= 1048576 && colIdx > 0 && endColIdx <= 16384)) {
                return this.getErrorStrings()[CommonErrors.Name];
            }
            grid = this.grid;
            let sheetToken = '';
            const family = this.getSheetFamilyItem(grid);
            if (argArr[1].startsWith('!')) {
                sheetToken = argArr[1].substring(0, argArr[1].replace('!', '').indexOf('!') + 2);
                if (family.tokenToParentObject !== null) {
                    this.grid = family.tokenToParentObject.get(sheetToken);
                }
            }
            else if (family.parentObjectToToken !== null) {
                sheetToken = family.parentObjectToToken.get(grid);
            }
            const sheetId = this.getSheetId(this.grid);
            const sheetInfoArgs = {
                action: 'getSheetInfo', sheetInfo: []
            };
            this.parentObject.notify(workbookFormulaOperation, sheetInfoArgs);
            if (getSheetIndexByName(this.parentObject, 'Sheet' + sheetId, sheetInfoArgs.sheetInfo) === -1) {
                this.grid = grid;
                return errorStrings[CommonErrors.Ref];
            }
            const getCellValue = this.getCellValueFn(grid, this.cell, sheetId, true);
            if (isVlookup) {
                const matchIndex = colIdx + colNumIdx - 1;
                if (matchIndex > endColIdx) {
                    return errorStrings[CommonErrors.Ref];
                }
                startIdx = rowIdx;
                endIdx = endRowIdx;
                const lookupColText = sheetToken + getAlphalabel(colIdx);
                getLookupRangeValue = (idx) => {
                    return getCellValue(idx, colIdx, lookupColText + idx);
                };
                const matchColText = sheetToken + getAlphalabel(matchIndex);
                getMatchRangeValue = () => {
                    return getCellValue(idx, matchIndex, matchColText + idx) || '0';
                };
            }
            else {
                const matchIndex = rowIdx + colNumIdx - 1;
                if (matchIndex > endRowIdx) {
                    return errorStrings[CommonErrors.Ref];
                }
                startIdx = colIdx;
                endIdx = endColIdx;
                let matchColText;
                getLookupRangeValue = (idx) => {
                    matchColText = sheetToken + getAlphalabel(idx);
                    return getCellValue(rowIdx, idx, matchColText + rowIdx);
                };
                getMatchRangeValue = () => {
                    return getCellValue(matchIndex, idx, matchColText + matchIndex) || '0';
                };
            }
        }
        else {
            return errorStrings[CommonErrors.Value];
        }
        let result;
        let lookupRangeVal;
        const matchedResult = [];
        if (isExactMatchLookup) {
            let isMatchFound;
            if (this.isNumber(lookupValue)) {
                const lookupNumVal = this.parseFloat(lookupValue);
                isMatchFound = () => {
                    return lookupNumVal === this.parseFloat(lookupRangeVal);
                };
            }
            else if (lookupValue.includes('*') || lookupValue.includes('?')) {
                let criteriaValue = lookupValue;
                const asteriskIndex = lookupValue.indexOf('*');
                if (asteriskIndex > -1) {
                    criteriaValue = criteriaValue.replace(/\*/g, '').trim();
                    if (this.isCellReference(criteriaValue)) {
                        criteriaValue = this.getValueFromArg(criteriaValue);
                    }
                    if (asteriskIndex === 0) {
                        criteriaValue = '*' + criteriaValue;
                    }
                    else if (asteriskIndex === lookupValue.length - 1) {
                        criteriaValue += '*';
                    }
                    else {
                        criteriaValue = lookupValue.substring(0, asteriskIndex) + '*' + lookupValue.substring(asteriskIndex + 1);
                    }
                }
                criteriaValue = criteriaValue.toLowerCase();
                isMatchFound = () => {
                    return this.processLogical([this.findWildCardValue(criteriaValue, lookupRangeVal.toLowerCase()), lookupValue], 'equal') === this.trueValue;
                };
            }
            else {
                const lookupValUpper = lookupValue.toUpperCase();
                isMatchFound = () => {
                    return lookupValUpper === lookupRangeVal.toUpperCase();
                };
            }
            for (idx = startIdx; idx <= endIdx; idx++) {
                lookupRangeVal = getLookupRangeValue(idx);
                if (lookupRangeVal && isMatchFound()) {
                    matchedResult.push(getMatchRangeValue());
                }
            }
            result = matchedResult.length ? matchedResult[0] : errorStrings[CommonErrors.NA];
        }
        else if (lookupValue.indexOf('*') > -1 || lookupValue.indexOf('?') > -1) {
            result = errorStrings[CommonErrors.NA];
        }
        else {
            let matchVal;
            let checkMatchFn;
            if (this.isNumber(lookupValue)) {
                const lookupNumVal = this.parseFloat(lookupValue);
                const comparer = DataUtil.fnSort('');
                checkMatchFn = () => {
                    matchVal = comparer(this.isNumber(lookupRangeVal) ? this.parseFloat(lookupRangeVal) : lookupRangeVal || null, lookupNumVal);
                };
            }
            else {
                const collator = new Intl.Collator(this.parentObject.locale || 'en-US', { sensitivity: 'base' });
                checkMatchFn = () => {
                    matchVal = (!lookupRangeVal || this.isNumber(lookupRangeVal)) ? null : collator.compare(lookupRangeVal, lookupValue);
                };
            }
            let skipCheck;
            for (idx = startIdx; idx <= endIdx; idx++) {
                lookupRangeVal = getLookupRangeValue(idx);
                if (!skipCheck) {
                    checkMatchFn();
                    if (matchVal === 0) {
                        matchedResult.push(getMatchRangeValue());
                    }
                    else if (matchVal < 0) {
                        matchedResult.push(getMatchRangeValue());
                    }
                    else if (matchVal > 0 && matchedResult.length) {
                        skipCheck = true;
                    }
                }
            }
            result = matchedResult.length ? matchedResult[matchedResult.length - 1] : errorStrings[CommonErrors.NA];
        }
        this.grid = grid;
        return result;
    }
    findClosestMatch(searchValue, sortedArray) {
        let start = 0;
        let end = sortedArray.length - 1;
        while (start <= end) {
            const mid = Math.floor((start + end) / 2);
            const midValue = sortedArray[mid];
            const compareResult = this.compareStrings(searchValue.toLowerCase(), midValue.toLowerCase());
            if (compareResult === 0) {
                return mid;
            }
            else if (compareResult === 1) {
                start = mid + 1;
            }
            else {
                end = mid - 1;
            }
        }
        // If no exact match is found, return the closest match based on the entire string
        for (let i = start - 1; i >= 0; i--) {
            if (this.compareStrings(searchValue.toLowerCase(), sortedArray[i].toLowerCase()) !== -1) {
                return i;
            }
        }
        return -1; // No match found
    }
    compareStrings(str1, str2) {
        const minLength = Math.min(str1.length, str2.length);
        for (let i = 0; i < minLength; i++) {
            const charCode1 = str1.charCodeAt(i);
            const charCode2 = str2.charCodeAt(i);
            if (charCode1 < charCode2) {
                return -1;
            }
            else if (charCode1 > charCode2) {
                return 1;
            }
        }
        // If all characters are the same up to the length of the shorter string, compare lengths
        if (str1.length < str2.length) {
            return -1;
        }
        else if (str1.length > str2.length) {
            return 1;
        }
        else {
            return 0;
        }
    }
    findWildCardValue(lookVal, cellValue) {
        let finalText = '';
        if (lookVal.indexOf('?') > -1) {
            const checkRegex = RegExp(lookVal.replace(/\?/g, '[\\s\\S]'));
            if (cellValue.length === lookVal.length && this.isNaN(this.parseFloat(cellValue))) {
                if (cellValue.match(checkRegex)) {
                    finalText = lookVal;
                }
                else {
                    finalText = cellValue;
                }
            }
            else {
                finalText = cellValue;
            }
        }
        else if (lookVal.indexOf('*') > -1) {
            const index = lookVal.indexOf('*');
            let left = '';
            let right = '';
            let compRight = this.falseValue;
            let compLeft = this.falseValue;
            for (let i = index - 1; i >= 0; i--) {
                left = left + lookVal[i];
                compLeft = this.trueValue;
            }
            for (let i = index + 1; i < lookVal.length; i++) {
                right = right + lookVal[i];
                compRight = this.trueValue;
            }
            const leftVal = left === '' ? -1 : cellValue.indexOf(left.split('').reverse().join(''));
            const rightVal = right === '' ? -1 : cellValue.indexOf(right);
            if (leftVal > -1 || rightVal > -1) {
                const isLeft = left.split('').reverse().join('') === cellValue.substr(0, left.length);
                const isRight = right === cellValue.substring(cellValue.length - right.length, cellValue.length);
                if (compLeft === this.trueValue && compRight === this.trueValue &&
                    this.isNaN(this.parseFloat(left)) && this.isNaN(this.parseFloat(right))) {
                    finalText = isLeft && isRight ? lookVal : cellValue;
                }
                else if (compLeft === this.trueValue && this.isNaN(this.parseFloat(left))) {
                    finalText = isLeft ? lookVal : cellValue;
                }
                else if (compRight === this.trueValue && this.isNaN(this.parseFloat(right))) {
                    finalText = isRight ? lookVal : cellValue;
                }
            }
            else {
                finalText = cellValue;
            }
        }
        return finalText;
    }
    /**
     * @hidden
     * @param {string[] | string} criteriaRange - Specifies the criteria reange.
     * @param {string[] | string} sumRange - Specifies the sum range.
     * @param {string} criteria - Specifies the criteria against which values are checked.
     * @param {number} checkCriteria - Specifies the check criteria value.
     * @param {string} op - Specifies the operator value.
     * @param {boolean} isAsterisk - Indicates whether asterisk (*) is used as a wildcard or not.
     * @param {boolean} isQuestionMark - Indicates whether question mark (?) is used as a wildcard or not.
     * @returns {number[]} - Returns computed sum if value.
     */
    getComputeSumIfValue(criteriaRange, sumRange, criteria, checkCriteria, op, isAsterisk, isQuestionMark) {
        let sum = 0;
        let count = 0;
        // const isFirst: boolean = isAsterisk && criteria && criteria[0] === '*';
        switch (op) {
            case this.parser.tokenEqual:
                {
                    const criteriaValue = isAsterisk ? criteria.replace(/\*/g, '') : criteria;
                    for (let i = 0; i < criteriaRange.length; i++) {
                        const sumVal = this.getValueFromRange(sumRange, i);
                        const value = this.getValueFromArg(criteriaRange[i].split(this.tic).join('')).toLowerCase();
                        const val = this.parseFloat(value);
                        if (value === criteria && val === checkCriteria) {
                            const value1 = this.getValueFromArg(sumRange[i].split(this.tic).join(''));
                            const val1 = this.parseFloat(value1);
                            if (!this.isNaN(val1)) {
                                sum = sum + val1;
                                count = count + 1;
                            }
                        }
                        else if (value === criteria) {
                            if (!this.isNaN(sumVal)) {
                                sum = sum + sumVal;
                                count = count + 1;
                            }
                        }
                        else if (isAsterisk && criteriaValue && value && this.isNaN(this.parseFloat(value))) {
                            const asteriskIndex = criteria.indexOf('*');
                            if (criteria[0] === '*' && criteriaValue.length <= value.length && criteriaValue === value.slice(value.length - criteriaValue.length, value.length)) {
                                if (!this.isNaN(sumVal)) {
                                    sum = sum + sumVal;
                                    count = count + 1;
                                }
                            }
                            else if (criteria[criteria.length - 1] === '*' && criteriaValue.length <= value.length && criteriaValue === value.slice(0, criteriaValue.length)) {
                                if (!this.isNaN(sumVal)) {
                                    sum = sum + sumVal;
                                    count = count + 1;
                                }
                            }
                            else if (asteriskIndex > -1 && value.startsWith(criteria.substr(0, asteriskIndex))
                                && value.endsWith(criteria.substr(asteriskIndex + 1))) {
                                if (!this.isNaN(sumVal)) {
                                    sum = sum + sumVal;
                                    count = count + 1;
                                }
                            }
                        }
                        else if (isAsterisk && !criteriaValue && value && this.isNaN(this.parseFloat(value))) {
                            if (!this.isNaN(sumVal)) {
                                sum = sum + sumVal;
                                count = count + 1;
                            }
                        }
                        else if (isQuestionMark && criteriaValue && value && this.isNaN(this.parseFloat(value))) {
                            const checkRegex = RegExp(criteriaValue.replace(/\?/g, '[\\s\\S]'));
                            if (value.length === criteria.length && value.match(checkRegex)) {
                                if (!this.isNaN(sumVal)) {
                                    sum = sum + sumVal;
                                    count = count + 1;
                                }
                            }
                        }
                    }
                }
                break;
            case this.parser.tokenLess:
                {
                    for (let i = 0; i < criteriaRange.length; i++) {
                        const value = this.getValueFromArg(criteriaRange[i].split(this.tic).join(''));
                        const val = this.parseFloat(value);
                        if (val < checkCriteria) {
                            const value1 = this.getValueFromArg(sumRange[i].split(this.tic).join(''));
                            const val1 = this.parseFloat(value1);
                            if (!this.isNaN(val1)) {
                                sum = sum + val1;
                                count = count + 1;
                            }
                        }
                    }
                }
                break;
            case this.parser.tokenGreater:
                {
                    for (let i = 0; i < criteriaRange.length; i++) {
                        const value = this.getValueFromArg(criteriaRange[i].split(this.tic).join(''));
                        const val = this.parseFloat(value);
                        if (val > checkCriteria) {
                            const value1 = this.getValueFromArg(sumRange[i].split(this.tic).join(''));
                            const val1 = this.parseFloat(value1);
                            if (!this.isNaN(val1)) {
                                sum = sum + val1;
                                count = count + 1;
                            }
                        }
                    }
                }
                break;
            case this.parser.tokenLessEq:
                {
                    for (let i = 0; i < criteriaRange.length; i++) {
                        const value = this.getValueFromArg(criteriaRange[i].split(this.tic).join(''));
                        const val = this.parseFloat(value);
                        if (val <= checkCriteria) {
                            const value1 = this.getValueFromArg(sumRange[i].split(this.tic).join(''));
                            const val1 = this.parseFloat(value1);
                            if (!this.isNaN(val1)) {
                                sum = sum + val1;
                                count = count + 1;
                            }
                        }
                    }
                }
                break;
            case this.parser.tokenGreaterEq:
                {
                    for (let i = 0; i < criteriaRange.length; i++) {
                        const value = this.getValueFromArg(criteriaRange[i].split(this.tic).join(''));
                        const val = this.parseFloat(value);
                        if (val >= checkCriteria) {
                            const value1 = this.getValueFromArg(sumRange[i].split(this.tic).join(''));
                            const val1 = this.parseFloat(value1);
                            if (!this.isNaN(val1)) {
                                sum = sum + val1;
                                count = count + 1;
                            }
                        }
                    }
                }
                break;
            case this.parser.tokenNotEqual:
                {
                    const criteriaValue = isAsterisk ? criteria.replace(/\*/g, '') : criteria;
                    for (let i = 0; i < criteriaRange.length; i++) {
                        const sumVal = this.getValueFromRange(sumRange, i);
                        const value = this.getValueFromArg(criteriaRange[i].split(this.tic).join('')).toLowerCase();
                        const val = this.parseFloat(value);
                        if (value !== criteria && val !== checkCriteria && !isAsterisk && !isQuestionMark) {
                            const value1 = this.getValueFromArg(sumRange[i].split(this.tic).join(''));
                            const val1 = this.parseFloat(value1);
                            if (!this.isNaN(val1)) {
                                sum = sum + val1;
                                count = count + 1;
                            }
                        }
                        else if (isAsterisk && criteriaValue && value && this.isNaN(this.parseFloat(value))) {
                            const asteriskIndex = criteria.indexOf('*');
                            if (criteria[0] === '*' && criteriaValue.length <= value.length && criteriaValue !== value.slice(value.length - criteriaValue.length, value.length)) {
                                if (!this.isNaN(sumVal)) {
                                    sum = sum + sumVal;
                                    count = count + 1;
                                }
                            }
                            else if (criteria[criteria.length - 1] === '*' && criteriaValue.length <= value.length && criteriaValue !== value.slice(0, criteriaValue.length)) {
                                if (!this.isNaN(sumVal)) {
                                    sum = sum + sumVal;
                                    count = count + 1;
                                }
                            }
                            else if (asteriskIndex > -1 && !value.startsWith(criteria.substr(0, asteriskIndex))
                                || !value.endsWith(criteria.substr(asteriskIndex + 1))) {
                                if (!this.isNaN(sumVal)) {
                                    sum = sum + sumVal;
                                    count = count + 1;
                                }
                            }
                        }
                        else if (isAsterisk && !criteriaValue && !this.isNaN(this.parseFloat(value))) {
                            if (!this.isNaN(sumVal)) {
                                sum = sum + sumVal;
                                count = count + 1;
                            }
                        }
                        else if (isQuestionMark && criteriaValue && value && this.isNaN(this.parseFloat(value))) {
                            const checkRegex = RegExp(criteriaValue.replace(/\?/g, '[\\s\\S]'));
                            if (value.length !== criteria.length || !value.match(checkRegex)) {
                                if (!this.isNaN(sumVal)) {
                                    sum = sum + sumVal;
                                    count = count + 1;
                                }
                            }
                        }
                    }
                }
                break;
        }
        return [sum, count];
    }
    getValueFromRange(sumRange, index) {
        let sumRangeVal = sumRange[index];
        sumRangeVal = this.getValueFromArg(sumRangeVal);
        return this.parseFloat(sumRangeVal.toString());
    }
    /**
     * @hidden
     * @param {string[]} args - specifies the args
     * @param {string} op - specify the operator.
     * @returns {string} - Compute and or.
     */
    computeAndOrNot(args, op) {
        const isAnd = op === 'and';
        const isOr = op === 'or';
        const isNot = op === 'not';
        let result = (isAnd || isNot) ? true : false;
        let value;
        let parseVal;
        const resultant = [];
        const ranges = args;
        for (let i = 0; i < ranges.length; i++) {
            if (ranges[i] === (this.tic)) {
                return this.getErrorStrings()[CommonErrors.Value];
            }
            if (this.isCellReference(ranges[i])) {
                const cells = this.getCellCollection(ranges[i]);
                for (let j = 0; j < cells.length; j++) {
                    if (this.getErrorStrings().indexOf(cells[j]) > -1) {
                        return cells[j];
                    }
                    else if (cells[j][0] === this.tic) {
                        return this.getErrorStrings()[CommonErrors.Name];
                    }
                    value = this.getValueFromArg(cells[j]);
                    if (this.getErrorStrings().indexOf(value) > -1) {
                        return value;
                    }
                    parseVal = this.parseFloat(value);
                    if (value === this.falseValue || (value !== '' && parseVal === 0) || (isNot && value === '')) {
                        resultant.push(this.falseValue);
                    }
                    else if (value === this.trueValue || !isNaN(parseVal) && value !== '') {
                        resultant.push(this.trueValue);
                    }
                    else if (value === '' || isNaN(parseVal)) {
                        resultant.push(this.getErrorStrings()[CommonErrors.Value]);
                    }
                }
            }
            else {
                value = this.getValueFromArg(ranges[i]).split(this.tic).join('').toUpperCase();
                if (this.getErrorStrings().indexOf(value) > -1) {
                    return value;
                }
                parseVal = this.parseFloat(value);
                if (value === this.falseValue || ranges[i] === '' || (value !== '' && parseVal === 0)) {
                    resultant.push(this.falseValue);
                }
                else if (value === this.trueValue || !isNaN(parseVal) && value !== '') {
                    resultant.push(this.trueValue);
                }
                else if (value === '' || isNaN(parseVal)) {
                    resultant.push(this.getErrorStrings()[CommonErrors.Value]);
                }
            }
        }
        const containsOnlyValueError = resultant.every((item) => item === this.getErrorStrings()[CommonErrors.Value]);
        if (containsOnlyValueError) {
            return this.getErrorStrings()[CommonErrors.Value];
        }
        for (let j = 0; j < resultant.length; j++) {
            if ((isAnd || isNot) && resultant[j] === this.falseValue) {
                result = false;
                break;
            }
            if (isOr && resultant[j] === this.trueValue) {
                result = true;
                break;
            }
        }
        result = isNot ? !result : result;
        return result ? this.trueValue : this.falseValue;
    }
    /**
     * @hidden
     * @param {string} text - specify the text
     * @returns {string} - to strip out the tic from the formula arguments.
     */
    // To strip out the tic from the formula arguments.
    removeTics(text) {
        if (text.length > 1 && text[0] === this.tic[0] && text[text.length - 1] === this.tic[0]) {
            text = this.substring(text, 1, text.length - 2);
        }
        return text;
    }
    /**
     * @hidden
     * @param {string} range - specify the range
     * @returns {string} - to get cell from the range.
     */
    getCellFrom(range) {
        let cellRange = '';
        const cells = range.indexOf(':') > -1 ? range.split(':') : [range];
        //this.getCellsFromArgs(range);
        const last = cells.length - 1;
        const r1 = this.rowIndex(cells[0]);
        let x;
        if (r1 === this.rowIndex(cells[last])) {
            const c1 = this.colIndex(cells[0]);
            const c2 = this.colIndex(cells[last]);
            const c = this.colIndex(this.cell);
            if (c >= c1 && c <= c2) {
                cellRange = getAlphalabel(c).toString() + r1.toString();
            }
        }
        else if (this.colIndex(cells[0]) === this.colIndex(cells[last])) {
            x = this.colIndex(cells[0]);
            const r2 = this.rowIndex(cells[last]);
            const r = this.rowIndex(this.cell);
            if (r >= r1 && r <= r2) {
                cellRange = getAlphalabel(x).toString() + r.toString();
            }
        }
        return cellRange;
    }
    computeValue(pFormula, refresh, isIfError) {
        try {
            const stack = [];
            let i = 0;
            let sheet = '';
            stack.length = 0;
            const decimalSep = this.getParseDecimalSeparator();
            while (i < pFormula.length) {
                let uFound = pFormula[i] === 'u'; // for 3*-2
                if (uFound) {
                    i = i + 1; // for the cell reference cases, like A1*-A2.
                }
                if (pFormula[i] === this.arithMarker) {
                    i = i + 1;
                    continue;
                }
                else if (this.isDigit(pFormula[i])) {
                    let s = this.emptyString;
                    while (i < pFormula.length && (this.isDigit(pFormula[i]) ||
                        pFormula[i] === decimalSep)) {
                        s += pFormula[i] === decimalSep ? '.' : pFormula[i];
                        i = i + 1;
                    }
                    stack.push(s);
                    if (!pFormula[i]) {
                        return stack.toString();
                    }
                }
                if (pFormula[i] === this.sheetToken) {
                    sheet = pFormula[i];
                    i = i + 1;
                    while (i < pFormula.length && pFormula[i] !== this.sheetToken) {
                        sheet = sheet + pFormula[i];
                        i = i + 1;
                    }
                    if (i < pFormula.length) {
                        sheet = sheet + pFormula[i];
                        i = i + 1;
                    }
                }
                else if (this.isUpperChar(pFormula[i])) {
                    let s = this.emptyString;
                    let textName = '';
                    while (i < pFormula.length && this.isUpperChar(pFormula[i])) {
                        const char = pFormula[i];
                        s = s + char;
                        i = i + 1;
                    }
                    while (i < pFormula.length && this.isDigit(pFormula[i])) {
                        const digit = pFormula[i];
                        s = s + digit;
                        i = i + 1;
                    }
                    if (i < pFormula.length && pFormula[i] === ':') {
                        s = s + pFormula[i];
                        i = i + 1;
                        if (i < pFormula.length && pFormula[i] === this.sheetToken) {
                            s = s + pFormula[i];
                            i = i + 1;
                            while (i < pFormula.length && pFormula[i] !== this.sheetToken) {
                                s = s + pFormula[i];
                                i = i + 1;
                            }
                        }
                        while (i < pFormula.length && this.isUpperChar(pFormula[i])) {
                            s = s + pFormula[i];
                            i = i + 1;
                        }
                        while (i < pFormula.length && this.isDigit(pFormula[i])) {
                            s = s + pFormula[i];
                            i = i + 1;
                        }
                        s = sheet + this.getCellFrom(s);
                    }
                    else {
                        s = sheet + s;
                    }
                    textName = this.getParentObjectCellValue(s, refresh).toString();
                    sheet = '';
                    if (typeof textName === 'string' && this.getErrorStrings().indexOf(textName) > -1) {
                        return textName;
                    }
                    if (uFound) {
                        if (!this.isNaN(this.parseFloat(textName))) {
                            textName = (-(this.parseFloat(textName))).toString();
                        }
                        else {
                            textName = '-' + textName;
                        }
                    }
                    stack.push(textName);
                }
                else if (pFormula[i] === 'q') {
                    const leftIdx = pFormula.substring(i + 1).indexOf(this.leftBracket);
                    const j = pFormula.substring(i + leftIdx + 1).indexOf(this.rightBracket);
                    pFormula = this.substring(pFormula, i + leftIdx + 2, j - 1);
                }
                else if (pFormula[i] === this.tic[0]) {
                    let s = pFormula[i].toString();
                    i = i + 1;
                    while (i < pFormula.length && pFormula[i] !== this.tic[0]) {
                        s = s + pFormula[i];
                        i = i + 1;
                    }
                    const textName = s.split(this.tic).join(this.emptyString);
                    if (textName === this.trueValue || textName === this.falseValue ||
                        (!this.isNaN(this.parseFloat(textName)) && textName !== '')) {
                        stack.push(this.tic + textName + this.tic);
                    }
                    else {
                        stack.push(textName);
                    }
                    i = i + 1;
                }
                else if (pFormula[i] === '%' && stack.length > 0) {
                    const stackValue = stack[0];
                    const value = this.parseFloat(stackValue);
                    if (!this.isNaN(value)) {
                        stack.pop();
                        stack.push((value / 100).toString());
                    }
                    i = i + 1;
                }
                else if ((pFormula.substring(i)).indexOf(this.trueValue) === 0) {
                    stack.push(this.trueValue);
                    i += this.trueValue.length;
                }
                else if (pFormula.substring(i).indexOf(this.falseValue) === 0) {
                    stack.push(this.falseValue);
                    i += this.falseValue.length;
                }
                else if (pFormula[i] === this.tic[0] || pFormula[i] === '|') {
                    let s = pFormula[i].toString();
                    i++;
                    while (i < pFormula.length && pFormula[i] !== this.tic[0]) {
                        s = s + pFormula[i];
                        i = i + 1;
                    }
                    stack.push(s + this.tic);
                    i += 1;
                }
                else {
                    if (pFormula[i] === ' ' && i < pFormula.length - 1) {
                        i += 1;
                        continue;
                    }
                    switch (pFormula[i]) {
                        case '#':
                            {
                                let errIndex = 0;
                                if (this.getErrorStrings().indexOf(pFormula.substring(i)) > -1) {
                                    if (pFormula.indexOf('!') === -1 || pFormula.substring(i).indexOf('!') === -1) {
                                        errIndex = pFormula.indexOf('#N/A') > -1 ? (pFormula.indexOf('#N/A') + 4 + i) : pFormula.indexOf('?') + 1 + i;
                                    }
                                    else {
                                        errIndex = pFormula.indexOf('!') + 1 + i;
                                    }
                                    stack.push(this.substring(pFormula, i, errIndex - i));
                                }
                                else {
                                    errIndex = i + 1;
                                    stack.push(this.substring(pFormula, i, errIndex - i));
                                }
                                i = errIndex;
                            }
                            break;
                        case 'n':
                            {
                                i = i + 1;
                                let s = '';
                                if (pFormula[i] === 'n') {
                                    continue;
                                }
                                if (pFormula.substring(i).indexOf('Infinity') === 0) {
                                    s = 'Infinity';
                                    i += s.length;
                                }
                                else {
                                    if (pFormula[i] === 'u' || uFound || pFormula[i] === '-') {
                                        s = '-';
                                        if (!uFound) {
                                            i = i + 1;
                                        }
                                        else {
                                            uFound = false;
                                        }
                                    }
                                    while (i < pFormula.length && (this.isDigit(pFormula[i]) ||
                                        (pFormula[i] === decimalSep || pFormula[i] === '.'))) {
                                        s += pFormula[i] === decimalSep ? '.' : pFormula[i];
                                        i = i + 1;
                                    }
                                    if (i < pFormula.length && pFormula[i] === '%') {
                                        i = i + 1;
                                        if (s === '') {
                                            if (stack.length > 0) {
                                                const stackValue = stack[0];
                                                const value = this.parseFloat(stackValue);
                                                if (!this.isNaN(value)) {
                                                    stack.pop();
                                                    stack.push((value / 100).toString());
                                                }
                                            }
                                        }
                                        else {
                                            s = (this.parseFloat(s) / 100).toString();
                                        }
                                    }
                                }
                                if (s) {
                                    stack.push(s);
                                }
                            }
                            break;
                        case this.parser.tokenAdd:
                            {
                                this.getValArithmetic(stack, 'add', isIfError);
                                i = i + 1;
                            }
                            break;
                        case this.parser.tokenSubtract:
                            {
                                this.getValArithmetic(stack, 'sub', isIfError);
                                i = i + 1;
                            }
                            break;
                        case this.parser.tokenMultiply:
                            {
                                this.getValArithmetic(stack, 'mul', isIfError);
                                i = i + 1;
                            }
                            break;
                        case this.parser.tokenDivide:
                            {
                                this.getValArithmetic(stack, 'div', isIfError);
                                i = i + 1;
                            }
                            break;
                        case this.parser.tokenLess:
                            {
                                this.processLogical(stack, 'less');
                                i = i + 1;
                            }
                            break;
                        case this.parser.tokenGreater:
                            {
                                this.processLogical(stack, 'greater');
                                i = i + 1;
                            }
                            break;
                        case this.parser.tokenGreaterEq:
                            {
                                this.processLogical(stack, 'greaterEq');
                                i = i + 1;
                            }
                            break;
                        case this.parser.tokenLessEq:
                            {
                                this.processLogical(stack, 'lessEq');
                                i = i + 1;
                            }
                            break;
                        case this.parser.tokenNotEqual:
                            {
                                this.processLogical(stack, 'notEq');
                                i = i + 1;
                            }
                            break;
                        case this.parser.tokenOr:
                            {
                                this.processLogical(stack, 'or');
                                i = i + 1;
                            }
                            break;
                        case this.parser.tokenAnd:
                            {
                                this.processLogical(stack, 'and');
                                i = i + 1;
                            }
                            break;
                        case this.parser.tokenEqual:
                            {
                                this.processLogical(stack, 'equal');
                                i = i + 1;
                            }
                            break;
                        default: {
                            return this.getErrorStrings()[CommonErrors.Value];
                        }
                    }
                }
            }
            if (stack.length === 0) {
                return this.emptyString;
            }
            else {
                let s = this.emptyString;
                let countValue = stack.length;
                while (countValue > 0) {
                    const sCheck = stack.pop();
                    if (this.getErrorStrings().indexOf(sCheck) > -1) {
                        return sCheck;
                    }
                    else {
                        s = sCheck + s;
                        if (s === this.emptyString && this.isCellReference(pFormula) &&
                            this.getTreatEmptyStringAsZero()) {
                            return '0';
                        }
                        countValue--;
                    }
                }
                return s;
            }
        }
        catch (ex) {
            if (this.getErrorStrings().indexOf(ex) > -1 || this.formulaErrorStrings.indexOf(ex) > -1) {
                throw ex;
            }
            throw new FormulaError(this.formulaErrorStrings[FormulasErrorsStrings.InvalidExpression]);
        }
    }
    getValArithmetic(stack, operator, isIfError) {
        let isErrorString = false;
        let num1 = stack.pop();
        const decimalCount1 = num1.indexOf('.') !== -1 ? num1.split('.')[1].length : 0;
        const factor1 = Math.pow(10, decimalCount1);
        let num2 = stack.pop();
        const decimalCount2 = num2.indexOf('.') !== -1 ? num2.split('.')[1].length : 0;
        const factor2 = Math.pow(10, decimalCount2);
        const bigFactor = factor1 >= factor2 ? factor1 : factor2;
        const factors = factor1 * factor2;
        num1 = num1 === this.trueValue ? '1' : (num1 === this.falseValue ? '0' : num1);
        num1 = num1 === this.emptyString ? '0' : (this.getErrorStrings().indexOf(num1.toString()) < 0 ? this.parseFloat(num1 + '').toString() : num1);
        let num = Number(num1);
        if (isNaN(num) && !isIfError) {
            isErrorString = true;
            if (num1 === this.getErrorStrings()[CommonErrors.DivZero]) {
                stack.push(this.getErrorStrings()[CommonErrors.DivZero]);
            }
            else {
                stack.push(this.getErrorStrings()[CommonErrors.Value]);
            }
        }
        num2 = num2 === this.trueValue ? '1' : (num2 === this.falseValue ? '0' : num2);
        num2 = num2 === this.emptyString ? '0' : (this.getErrorStrings().indexOf(num2.toString()) < 0 ? this.parseFloat(num2 + '').toString() : num2);
        num = Number(num2);
        if (isNaN(num) && !isIfError) {
            isErrorString = true;
            if (num2 === this.getErrorStrings()[CommonErrors.DivZero]) {
                stack.push(this.getErrorStrings()[CommonErrors.DivZero]);
            }
            else {
                stack.push(this.getErrorStrings()[CommonErrors.Value]);
            }
        }
        if (operator === 'add' && !isErrorString) {
            stack.push(((((Number(num2) * bigFactor) + (Number(num1) * bigFactor)) / bigFactor)).toString());
        }
        if (operator === 'sub' && !isErrorString) {
            stack.push(((((Number(num2) * bigFactor) - (Number(num1) * bigFactor)) / bigFactor)).toString());
        }
        if (operator === 'mul' && !isErrorString) {
            stack.push(((((Number(num2) * factor2) * (Number(num1) * factor1)) / factors)).toString());
        }
        if (operator === 'div' && !isErrorString) {
            if (this.isNaN(this.parseFloat(num1)) || this.isNaN(this.parseFloat(num2))) {
                stack.push(this.getErrorStrings()[CommonErrors.Value]);
            }
            else if (this.parseFloat(num1) === 0) {
                stack.push(this.getErrorStrings()[CommonErrors.DivZero]);
            }
            else {
                stack.push(((Number(num2) * factors) / (Number(num1) * factors)).toString());
            }
        }
    }
    /**
     * Used to perform logical operation between two values.
     *
     * @hidden
     * @param {string[]} stack - Specifies the values that are used to perform the logical operation.
     * @param {string} operator - Specifies the logical operator.
     * @returns {string} - It returns whether the logical operation is TRUE or FALSE.
     */
    processLogical(stack, operator) {
        let val1;
        let val2;
        let value1;
        let value2;
        let isOnlyAsterisk;
        let result;
        let isErrorString = false;
        if (operator !== 'and' && operator !== 'equal') {
            val1 = stack.pop();
            val2 = stack.pop();
            if (this.getErrorStrings().indexOf(val1) > -1) {
                result = val1;
                isErrorString = true;
            }
            else if (this.getErrorStrings().indexOf(val2) > -1) {
                result = val2;
                isErrorString = true;
            }
            if (this.isNaN(this.parseFloat(val1)) && this.isNaN(this.parseFloat(val2))) {
                val1 = val1.toString().toLowerCase();
                val2 = val2.toString().toLowerCase();
            }
            if (!isNullOrUndefined(val1)) {
                value1 = val1.indexOf(this.tic) > -1 ? val1 : this.parseFloat(val1);
            }
            if (!isNullOrUndefined(val2)) {
                value2 = val2.indexOf(this.tic) > -1 ? val2 : this.parseFloat(val2);
            }
            if (val1 === '*' && this.isNaN(this.parseFloat(val2)) && val2 !== '') {
                isOnlyAsterisk = true;
            }
        }
        if (operator === 'less' && !isErrorString) {
            if (!this.isNaN(value1) && !this.isNaN(value2)) {
                result = (value2 < value1) ? this.trueValue : this.falseValue;
            }
            else {
                result = (val2.toUpperCase().split(this.tic).join('').localeCompare(val1.toUpperCase().split(this.tic).join('')) < 0) ?
                    this.trueValue : this.falseValue;
            }
        }
        if (operator === 'greater' && !isErrorString) {
            if (!this.isNaN(value1) && !this.isNaN(value2)) {
                result = (value2 > value1) ? this.trueValue : this.falseValue;
            }
            else {
                result = (val2.toUpperCase().split(this.tic).join('').localeCompare(val1.toUpperCase().split(this.tic).join('')) > 0) ?
                    this.trueValue : this.falseValue;
            }
        }
        if (operator === 'lessEq' && !isErrorString) {
            if (!this.isNaN(value1) && !this.isNaN(value2)) {
                result = (value2 <= value1) ? this.trueValue : this.falseValue;
            }
            else {
                result = (val2.toUpperCase().split(this.tic).join('').localeCompare(val1.toUpperCase().split(this.tic).join('')) <= 0) ?
                    this.trueValue : this.falseValue;
            }
        }
        if (operator === 'greaterEq' && !isErrorString) {
            if (!this.isNaN(value1) && !this.isNaN(value2)) {
                result = (value2 >= value1) ? this.trueValue : this.falseValue;
            }
            else {
                result = (val2.toUpperCase().split(this.tic).join('').localeCompare(val1.toUpperCase().split(this.tic).join('')) >= 0) ?
                    this.trueValue : this.falseValue;
            }
        }
        if (operator === 'notEq' && !isErrorString) {
            result = (val2 !== val1) ? this.trueValue : this.falseValue;
            if (isOnlyAsterisk) {
                result = this.falseValue;
            }
        }
        if (operator === 'and' && !isErrorString) {
            val1 = stack.pop().toString();
            val2 = '';
            if (stack.length > 0) {
                val2 = stack.pop().toString();
            }
            if (this.getErrorStrings().indexOf(val1) > -1) {
                result = val1;
            }
            else if (this.getErrorStrings().indexOf(val2) > -1) {
                result = val2;
            }
            else {
                result = this.emptyString + val2 + val1 + this.emptyString;
                result = result.split(this.tic).join('');
            }
        }
        if (operator === 'equal' && !isErrorString) {
            val1 = stack.pop();
            val2 = stack.pop();
            if (this.getErrorStrings().indexOf(val1) > -1) {
                result = val1;
            }
            else if (this.getErrorStrings().indexOf(val2) > -1) {
                result = val2;
            }
            else {
                if (this.isNaN(this.parseFloat(val1)) && this.isNaN(this.parseFloat(val2))) {
                    val1 = val1.toString().toLowerCase();
                    val2 = val2.toString().toLowerCase();
                }
                if (val1 === '*' && this.isNaN(this.parseFloat(val2)) && val2 !== '') {
                    isOnlyAsterisk = true;
                }
                result = val1 === val2 || isOnlyAsterisk ? this.trueValue : this.falseValue;
            }
        }
        if (operator === 'or' && !isErrorString) {
            result = Math.pow(this.parseFloat(value2), this.parseFloat(value1)).toString();
            result = this.isNaN(this.parseFloat(result)) ? this.getErrorStrings()[CommonErrors.Value] : result;
        }
        stack.push(result);
        return result;
    }
    /**
     * @hidden
     * @param {StoredCellInfo} sCell - specified the cell information
     * @returns {string[]} - compute stored cells
     */
    computeStoreCells(sCell) {
        const cellValue = sCell.cellValue;
        const cellRanges = sCell.cellRange;
        const criterias = sCell.criteria;
        const argArr = sCell.argArray;
        let isCriteria = sCell.isCriteria;
        let storeCell = sCell.storedCells;
        const isCountIfs = sCell.isCountIfS === this.trueValue;
        const i = sCell.countVal || 0;
        const rangeLength = isCriteria === this.trueValue ? storeCell : cellValue;
        let tempStoredCell = [];
        let criteria;
        for (let j = 0; j < rangeLength.length; j++) {
            const stack = [];
            let cellVal = this.getValueFromArg(cellValue[j]);
            const arrValue = argArr[isCountIfs ? (1 + (i * 2)) : (2 + i)];
            const isStringVal = arrValue.startsWith(this.tic) && arrValue.endsWith(this.tic);
            criteria = arrValue.trim().split(this.tic).join(this.emptyString);
            const isAsterisk = criteria.includes('*');
            const isAsteriskOnly = criteria === '*' || criteria === '<>*';
            let criteriaValue = isAsterisk && !isAsteriskOnly ? criteria.replace(/\*/g, '').trim() : criteria;
            let isCellReferenceValue = false;
            if (!isStringVal && this.isCellReference(criteriaValue)) {
                criteriaValue = this.getValueFromArg(criteriaValue);
                isCellReferenceValue = true;
            }
            if (isAsterisk && !isAsteriskOnly) {
                const asteriskIndex = criteria.indexOf('*');
                if (criteria[0] === '*') {
                    criteriaValue = '*' + criteriaValue;
                }
                if (criteria[criteria.length - 1] === '*') {
                    criteriaValue += '*';
                }
                if (asteriskIndex > 0 && asteriskIndex < criteria.length - 1) {
                    criteriaValue = criteria.substring(0, asteriskIndex) + '*' + criteria.substring(asteriskIndex + 1);
                }
            }
            criteria = criteriaValue;
            let newCell = '';
            isCriteria = isCountIfs ? this.trueValue : isCriteria;
            if (isCriteria === this.trueValue) {
                let cell = '';
                let count = 0;
                let newCount = 0;
                let prevCriteria;
                let prevCriteriaIdx;
                let prevStoreCellIdx;
                let criteriaRangeIndexes;
                storeCell[j] = isCountIfs && !i ? cellValue[j] : storeCell[j];
                cell = storeCell[j];
                if (i) {
                    prevCriteria = cellRanges[i - 1];
                    prevCriteriaIdx = prevCriteria.indexOf('!') > -1 ? getRangeIndexes(prevCriteria.substring(prevCriteria.lastIndexOf('!') + 1)) : getRangeIndexes(prevCriteria);
                    prevStoreCellIdx = cell.indexOf('!') > -1 ? getCellIndexes(cell.substring(cell.lastIndexOf('!') + 1)) : getCellIndexes(cell);
                    criteriaRangeIndexes = cellRanges[i].indexOf('!') > -1 ?
                        getRangeIndexes(cellRanges[i].substring(cellRanges[i].lastIndexOf('!') + 1)) :
                        getRangeIndexes(cellRanges[i]);
                }
                const isCriteriaFromOtherSheet = cell.indexOf('!') > -1;
                let isSumFromOtherSheet;
                let sumRangeSheet = '';
                let criteriaRangeSheet = '';
                if (isCriteriaFromOtherSheet) {
                    criteriaRangeSheet = cell.substring(0, cell.lastIndexOf('!') + 1);
                    cell = cell.substring(cell.lastIndexOf('!') + 1);
                }
                // convert the new cell ranges  for find in range with criteria.
                while (!this.isDigit(cell[count])) {
                    count = count + 1;
                }
                if (this.isCellReference(cellRanges[i]) && cellRanges[i].indexOf(':') > -1) {
                    newCell = isCountIfs && !i ? (rangeLength[j].indexOf('!') > -1 ? rangeLength[j].substring(rangeLength[j].lastIndexOf('!') + 1) : rangeLength[j]) : getCellAddress(criteriaRangeIndexes[0] + (prevStoreCellIdx[0] - prevCriteriaIdx[0]), criteriaRangeIndexes[1] +
                        (prevStoreCellIdx[1] - prevCriteriaIdx[1]));
                    isSumFromOtherSheet = cellRanges[i].indexOf('!') > -1;
                    if (isSumFromOtherSheet) {
                        sumRangeSheet = cellRanges[i].substring(0, cellRanges[i].lastIndexOf('!') + 1);
                    }
                    while (!this.isDigit(newCell[newCount])) {
                        newCount = newCount + 1;
                    }
                }
                let cellAlpha = this.substring(cell, count);
                let newCellAlpha = this.substring(newCell, newCount);
                const cellNumeric = this.substring(cell, count, cell.length - count);
                const newCellNumeric = this.substring(newCell, newCount, newCell.length - count);
                if (isCriteriaFromOtherSheet) {
                    cellAlpha = criteriaRangeSheet + cellAlpha;
                    newCellAlpha = criteriaRangeSheet + newCellAlpha;
                }
                if (cellNumeric !== newCellNumeric) {
                    storeCell[j] = this.substring(storeCell[j], isCriteriaFromOtherSheet ? (criteriaRangeSheet.length + count) : count) + newCellNumeric;
                }
                newCell = storeCell[j].split(cellAlpha).join(newCellAlpha);
                if (isSumFromOtherSheet) {
                    if (newCell.indexOf('!') > -1) {
                        newCell = newCell.substring(newCell.lastIndexOf('!') + 1);
                    }
                    newCell = sumRangeSheet + newCell;
                }
                else {
                    newCell = newCell.substring(newCell.lastIndexOf('!') + 1);
                }
                cellVal = this.getValueFromArg(newCell);
                criteria = isCountIfs ? criteria : criterias[i - 1].split(this.tic).join(this.emptyString);
            }
            let op = 'equal';
            if (criteria.startsWith('<=')) {
                op = 'lessEq';
                criteria = criteria.substring(2);
            }
            else if (criteria.startsWith('>=')) {
                op = 'greaterEq';
                criteria = criteria.substring(2);
            }
            else if (criteria.startsWith('<>')) {
                op = 'notEq';
                criteria = criteria.substring(2);
            }
            else if (criteria.startsWith('<')) {
                op = 'less';
                criteria = criteria.substring(1);
            }
            else if (criteria.startsWith('>')) {
                op = 'greater';
                criteria = criteria.substring(1);
            }
            else if (criteria.startsWith('=')) {
                op = 'equal';
                criteria = criteria.substring(1);
            }
            if ((!isStringVal && this.isCellReference(criteria) && (!isCellReferenceValue || (newCell !== '' && !isCountIfs))) || criteria.includes(this.arithMarker)) {
                criteria = this.getValueFromArg(criteria);
            }
            if (criteria.indexOf('*') > -1 || criteria.indexOf('?') > -1) {
                cellVal = this.findWildCardValue(criteria.toLowerCase(), cellVal.toLowerCase());
            }
            stack.push(cellVal.toLowerCase());
            stack.push(criteria.toLowerCase());
            if (this.processLogical(stack, op) === this.trueValue) {
                if (isCriteria === this.falseValue) {
                    tempStoredCell.push(cellValue[j]);
                }
                else {
                    tempStoredCell.push(newCell);
                }
            }
        }
        storeCell = tempStoredCell;
        tempStoredCell = [];
        return storeCell;
    }
    computeIfsFormulas(range, isCountIfs, isAvgIfs) {
        if (isCountIfs === this.trueValue && (isNullOrUndefined(range) || range[0] === '' || range.length < 2 || range.length > 127 ||
            range.length % 2 !== 0)) {
            return this.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        const argArr = range;
        const cellRanges = [];
        const criterias = [];
        let storedCell = [];
        let storedCellLength = 0;
        let sum = 0;
        for (let i = 0; i < argArr.length; i++) {
            if (argArr[i].indexOf(':') > -1 && this.isCellReference(argArr[i])) {
                cellRanges.push(argArr[i].trim());
            }
            else {
                criterias.push(argArr[i].trim());
            }
        }
        const len = [];
        for (let i = 0; i < cellRanges.length; i++) {
            len.push(this.getCellCollection(cellRanges[i]).length);
        }
        for (let j = 0; j < len.length; j++) {
            if (len[j] && len[j + 1] && len[j] !== len[j + 1]) {
                return this.getErrorStrings()[CommonErrors.Value];
            }
        }
        for (let k = 0; k < criterias.length; k++) {
            if (criterias[k] === '') {
                if (isAvgIfs === this.trueValue) {
                    return this.getErrorStrings()[CommonErrors.DivZero];
                }
                return 0;
            }
        }
        let cellvalue;
        let isCriteria;
        if (isCountIfs === this.falseValue) {
            isCriteria = this.falseValue;
            cellvalue = this.getCellCollection(cellRanges[1]);
            const sCell = {
                cellValue: cellvalue, cellRange: cellRanges, criteria: criterias,
                argArray: argArr, isCriteria: isCriteria, storedCells: storedCell, isCountIfS: isCountIfs
            };
            storedCell = this.computeStoreCells(sCell);
            storedCellLength = storedCell.length;
            if (storedCellLength === 0) {
                return isAvgIfs === this.trueValue ? this.getErrorStrings()[CommonErrors.DivZero] : 0;
            }
        }
        // Compare criteria and convert the new cell ranges.
        const startRange = isCountIfs === this.trueValue ? 0 : 2;
        for (let i = startRange; i < cellRanges.length; i++) {
            isCriteria = this.trueValue;
            isCriteria = isCountIfs === this.trueValue && i === 0 ? this.falseValue : this.trueValue;
            cellvalue = this.getCellCollection(cellRanges[i]);
            const sCell = {
                cellValue: cellvalue, cellRange: cellRanges, criteria: criterias,
                argArray: argArr, isCriteria: isCriteria, storedCells: storedCell, isCountIfS: isCountIfs, countVal: i
            };
            storedCell = this.computeStoreCells(sCell);
            storedCellLength = storedCell.length;
            if (storedCellLength === 0) {
                return isAvgIfs === this.trueValue ? this.getErrorStrings()[CommonErrors.DivZero] : 0;
            }
        }
        let avgValCount = 0;
        const sumRangeIndexes = cellRanges[0].indexOf('!') > -1 ?
            getRangeIndexes(cellRanges[0].substring(cellRanges[0].lastIndexOf('!') + 1)) : getRangeIndexes(cellRanges[0]);
        const lastCriteria = cellRanges[cellRanges.length - 1];
        const criteriaRangeIndexes = lastCriteria.indexOf('!') > -1 ?
            getRangeIndexes(lastCriteria.substring(lastCriteria.lastIndexOf('!') + 1)) : getRangeIndexes(lastCriteria);
        for (let j = 0; j < storedCell.length; j++) {
            // convert the new cell ranges  for find sum in range 0(first range)
            let cell = '';
            let newCell = '';
            let count = 0;
            let newCount = 0;
            cell = storedCell[j];
            const isCriteriaFromOtherSheet = cell.indexOf('!') > -1;
            let isSumFromOtherSheet;
            let sumRangeSheet = '';
            let criteriaRangeSheet = '';
            if (isCriteriaFromOtherSheet) {
                criteriaRangeSheet = cell.substring(0, cell.lastIndexOf('!') + 1);
                cell = cell.substring(cell.lastIndexOf('!') + 1);
            }
            while (!this.isDigit(cell[count])) {
                count = count + 1;
            }
            if (this.isCellReference(cellRanges[0]) && cellRanges[0].indexOf(':') > -1) {
                newCell = getCellAddress(sumRangeIndexes[0] + (getCellIndexes(cell)[0] - criteriaRangeIndexes[0]), sumRangeIndexes[1] + (getCellIndexes(cell)[1] - criteriaRangeIndexes[1]));
                isSumFromOtherSheet = cellRanges[0].indexOf('!') > -1;
                if (isSumFromOtherSheet) {
                    sumRangeSheet = cellRanges[0].substring(0, cellRanges[0].lastIndexOf('!') + 1);
                }
                while (!this.isDigit(newCell[newCount])) {
                    newCount = newCount + 1;
                }
            }
            let cellAlpha = this.substring(cell, count);
            let newCellAlpha = this.substring(newCell, newCount);
            const cellNumeric = this.substring(cell, count, cell.length - count);
            const newCellNumeric = this.substring(newCell, newCount, newCell.length - count);
            if (isCriteriaFromOtherSheet) {
                cellAlpha = criteriaRangeSheet + cellAlpha;
                newCellAlpha = criteriaRangeSheet + newCellAlpha;
            }
            if (cellNumeric !== newCellNumeric) {
                storedCell[j] = this.substring(storedCell[j], isCriteriaFromOtherSheet ? (criteriaRangeSheet.length + count) : count) + newCellNumeric;
            }
            cellvalue = storedCell[j].split(cellAlpha).join(newCellAlpha);
            if (isSumFromOtherSheet) {
                if (cellvalue.indexOf('!') > -1) {
                    cellvalue = cellvalue.substring(cellvalue.lastIndexOf('!') + 1);
                }
                cellvalue = sumRangeSheet + cellvalue;
            }
            else {
                cellvalue = cellvalue.substring(cellvalue.lastIndexOf('!') + 1);
            }
            if (isCountIfs === this.trueValue) {
                sum = sum + 1;
            }
            else {
                const argValue = this.getValueFromArg(cellvalue);
                const newArgValue = parseFloat(argValue === '' && isAvgIfs !== this.trueValue ? '0' : argValue);
                if (this.isNumber(newArgValue)) {
                    avgValCount++;
                    sum = sum + newArgValue;
                }
            }
        }
        if (isAvgIfs === this.trueValue) {
            sum = sum / avgValCount;
        }
        return sum;
    }
    processNestedFormula(pText, sFormula, fResult) {
        if (fResult && !fResult.toString().includes('"')) {
            const formulaEndIdx = pText.indexOf(sFormula) + sFormula.length;
            if (pText[formulaEndIdx] === '"' && this.getErrorStrings().indexOf(fResult.toString()) < 0 &&
                !this.isNumber(fResult) && fResult !== this.trueValue && fResult !== this.falseValue) {
                return pText.split(sFormula).join('"' + fResult + '"');
            }
        }
        return pText.split(sFormula).join('n' + fResult);
    }
    /**
     * @hidden
     * @param {string | number} value - Specify the value
     * @returns {boolean} -  Returns boolean value
     */
    isNaN(value) {
        if (value.toString() === 'NaN' || typeof value === 'string') {
            return true;
        }
        return false;
    }
    /**
     * @hidden
     * @param {string} val - Specifies the value.
     * @returns {boolean} - Returns boolean value.
     */
    isNumber(val) {
        return val - parseFloat(val) >= 0;
    }
    /**
     * @hidden
     * @param {number} doubleNumber - To specify the double number
     * @returns {Date} - Returns date.
     */
    fromOADate(doubleNumber) {
        doubleNumber = (doubleNumber > 0 && doubleNumber < 1) ? (1 + doubleNumber) : (doubleNumber === 0) ? 1 : doubleNumber;
        if (doubleNumber > 60) {
            doubleNumber -= 1; // Due to leap year issue of 1900 in MSExcel.
        }
        const result = new Date('01/01/1900');
        const resultDateUTC = Date.UTC(result.getFullYear(), result.getMonth(), result.getDate(), result.getHours(), result.getMinutes(), result.getSeconds(), result.getMilliseconds());
        return new Date(new Date(((doubleNumber - 1) * (this.millisecondsOfaDay)) + resultDateUTC).toUTCString().replace(' GMT', ''));
    }
    /**
     * @hidden
     * @param {number} year - Specify the year.
     * @param {number} month - Specify the month.
     * @param {number} day - Specify the day.
     * @returns {number} -  to get serial date from date.
     */
    getSerialDateFromDate(year, month, day) {
        let days = 0;
        if (year < 1900) {
            year += 1900;
        }
        let isValidMonth = false;
        while (!isValidMonth) {
            while (month > 12) {
                year++;
                month -= 12;
            }
            while (month < 1) {
                month += 12;
                year--;
            }
            isValidMonth = true;
            let tempDay = new Date(year, month, 1, -1).getDate();
            while (day > tempDay) {
                tempDay = new Date(year, month, 1, -1).getDate();
                month++;
                day -= tempDay;
                isValidMonth = false;
            }
            if (day < 1) {
                month--;
                if (month < 1) {
                    month = 12;
                    year--;
                }
                tempDay = new Date(year, month, 1, -1).getDate();
                day = tempDay + day;
                isValidMonth = false;
            }
        }
        const dateTime = Date.parse(`${year}/${month}/${day}`);
        if (!this.isNaN(dateTime)) {
            days = this.toOADate(new Date(dateTime));
        }
        return days;
    }
    /**
     * @hidden
     * @param {string | number} value - Specify the Time
     * @returns {string} -  returns to time.
     */
    intToTime(value) {
        const val = value.toString().split('.');
        if (!isNullOrUndefined(val[1])) {
            value = parseFloat(val[0] + 1 + '.' + val[1]) || value;
        }
        return this.intToDate(value.toString());
    }
    /**
     * @hidden
     * @param {Date} dateTime - Specify the date Time
     * @param {boolean} isTime - Specify the boolean value.
     * @param {boolean} isTimeOnly - Specify the value is only a time without date.
     * @returns {number} -  returns to date.
     */
    toOADate(dateTime, isTime, isTimeOnly) {
        const startDate = new Date('01/01/1900');
        const date = isDateTime(dateTime) ? dateTime : new Date(dateTime);
        const startDateUTC = Date.UTC(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), startDate.getHours(), startDate.getMinutes(), startDate.getSeconds(), startDate.getMilliseconds());
        const dateUTC = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        const diffDays = ((dateUTC - startDateUTC) / (1000 * 3600 * 24));
        return (isTime ? diffDays : parseInt(diffDays.toString(), 10)) + (isTimeOnly ? 0 : (diffDays > 60 ? 2 : 1));
    }
    /**
     * @hidden
     * @param {string} date - Specify the date
     * @returns {string} -  returns calculate Date
     */
    calculateDate(date) {
        return (this.parseFloat(date) < 10) ? '0' + date : date;
    }
    /**
     * @hidden
     * @param {string} s - Specify the s
     * @returns {boolean} -  returns boolean value.
     */
    isTextEmpty(s) {
        return s === null || s === '';
    }
    /**
     * @hidden
     * @param {string} text - Specify the text
     * @returns {boolean} -  returns boolean value.
     */
    isDigit(text) {
        const charCode = text.charCodeAt(0);
        return charCode > 47 && charCode < 58;
    }
    findLastIndexOfq(fString) {
        let lastIndexOfq = fString.lastIndexOf('q');
        const lastIndexOflLeftBracket = fString.lastIndexOf(this.leftBracket);
        while (lastIndexOflLeftBracket < lastIndexOfq) {
            lastIndexOfq = fString.substring(0, lastIndexOfq).lastIndexOf('q');
        }
        return lastIndexOfq;
    }
    /**
     * To get the exact value from argument.
     *
     * @param {string} val - Formula argument for getting a exact value.
     * @param {boolean} isUnique - It specifies unique formula or not.
     * @param {boolean} isIfError - It specifies `IFERROR` formula or not.
     * @param {boolean} isSubtotal - It specifies subtotal formula.
     * @returns {string} - To get the exact value from argument.
     */
    getValueFromArg(val, isUnique, isIfError, isSubtotal) {
        val = val.trim();
        if (!val || this.getErrorStrings().indexOf(val) > -1) {
            return val;
        }
        const firstChar = val[0];
        if (firstChar === this.tic || firstChar === this.singleTic) {
            let parsedVal = val.split(this.tic).join('');
            if (this.isNaN(this.parseFloat(parsedVal))) {
                const dateTime = this.isDate(parsedVal);
                if (dateTime && !this.isNaN(dateTime.getDate())) {
                    return this.toOADate(dateTime, true).toString();
                }
            }
            if (val.endsWith(this.tic)) {
                const decimalSep = this.getParseDecimalSeparator();
                if (decimalSep !== '.' && parsedVal.includes(decimalSep)) {
                    parsedVal = parsedVal.replace(decimalSep, '.');
                    if (this.isNumber(parsedVal)) {
                        val = parsedVal;
                    }
                }
            }
            return val;
        }
        else if (firstChar === 'u' && val.includes(this.arithMarker)) {
            // To parse - sign with brackets, cell references and nested formulas in the formula arguments. Ex: -(I13+I14+I12)/(-D2+D1) as arguments in formulas.
            val = this.parser.parseSimpleOperators(val.split('u').join('0-'), [this.parser.tokenSubtract], ['-']);
        }
        else {
            const isFirstCharUpper = this.isUpperChar(firstChar);
            if (!isFirstCharUpper) {
                const decimalSep = this.getParseDecimalSeparator();
                if (this.isDigit(firstChar) || firstChar === decimalSep || firstChar === '-' || firstChar === 'n') {
                    if (firstChar === 'n') {
                        val = val.substring(1);
                        if (val.indexOf('"n') > -1) {
                            val = val.replace('"n', '"');
                        }
                    }
                    if (decimalSep !== '.' && val.includes(decimalSep)) {
                        const parsedVal = val.replace(decimalSep, '.');
                        if (this.isNumber(parsedVal)) {
                            val = parsedVal;
                        }
                    }
                    return val;
                }
            }
        }
        const tokenAvail = firstChar === this.sheetToken;
        if (tokenAvail || (this.isUpperChar(firstChar) && !['+', '-', '/', '*', ')', ')', '{'].some((opr) => val.includes(opr)))) {
            const isCellRef = this.isCellReference(val);
            if (isCellRef && !tokenAvail) {
                const family = this.getSheetFamilyItem(this.grid);
                if (family.sheetNameToParentObject !== null && family.parentObjectToToken.has(this.grid)) {
                    val = family.parentObjectToToken.get(this.grid) + val;
                }
            }
            if (val === this.cell) {
                const dependent = this.getDependentCells().get(val);
                if (dependent != null && dependent.indexOf(val) > -1) {
                    this.arrayRemove(dependent, val);
                }
                if (!this.getDependentFormulaCells().has(this.cell)) {
                    this.clearFormulaDependentCells(this.cell);
                }
                if (!isUnique) {
                    throw new FormulaError(this.formulaErrorStrings[FormulasErrorsStrings.CircularReference]);
                }
            }
            const result = this.getParentObjectCellValue(val, false, isUnique, isSubtotal).toString();
            if (isCellRef) {
                this.updateDependentCell(val);
            }
            return result;
        }
        else {
            return this.computeValue(val, false, isIfError);
        }
    }
    isDate(date) {
        if (typeof date === 'object' || Date.parse(date) !== null) {
            let dateVal;
            if (typeof date === 'string') {
                dateVal = this.checkDateFormat(date);
            }
            else {
                dateVal = new Date(Date.parse(date));
            }
            if (dateVal >= this.dateTime1900) {
                return dateVal;
            }
            else {
                return null;
            }
        }
        else {
            return null;
        }
    }
    isValidCellReference(text) {
        const start = 0;
        let end = 0;
        let j = 0;
        const numArr = [89, 71, 69];
        let cellTxt = this.emptyString;
        if (this.namedRanges.has(text)) {
            return false;
        }
        for (let i = 0; i < text.length; i++) {
            if (this.isChar(text[i])) {
                end++;
            }
        }
        cellTxt = text.substring(start, end);
        if (cellTxt.length < 4) {
            while (j < cellTxt.length) {
                if (!isNullOrUndefined(cellTxt[j]) && cellTxt[j].charCodeAt(0) < numArr[j]) {
                    j++;
                    continue;
                }
                else if (isNullOrUndefined(cellTxt[j]) && j > 0) {
                    break;
                }
                else {
                    return false;
                }
            }
            const cellNum = this.parseFloat(text.substring(end, text.length));
            if (cellNum < 1048576) { // Maximum number of rows in excel.
                return true;
            }
        }
        return false;
    }
    /**
     * @hidden
     * @param {any} date - Specify the date
     * @returns {any} - Returns date value.
     */
    parseDate(date) {
        if (!this.isNaN(date)) {
            if (date instanceof Date) {
                return new Date(date);
            }
            const d = parseInt(date, 10);
            if (d < 0) {
                return this.getErrorStrings()[CommonErrors.Num];
            }
            if (d <= 60) {
                return new Date(this.dateTime1900.getTime() + (d - 1) * 86400000);
            }
            return new Date(this.dateTime1900.getTime() + (d - 2) * 86400000);
        }
        if (typeof date === 'string') {
            date = this.checkDateFormat(date, true);
            if (!this.isNaN(date)) {
                return date;
            }
        }
        return this.getErrorStrings()[CommonErrors.Value];
    }
    checkDateFormat(date, pvtParse) {
        if (this.parentObject.getModuleName() === 'spreadsheet' &&
            this.parentObject.locale !== 'en-US') {
            const dateEventArgs = { value: date,
                cell: { value: date } };
            this.parentObject.notify('checkDateFormat', dateEventArgs);
            if (dateEventArgs.isDate) {
                return dateEventArgs.dateObj;
            }
        }
        if (!pvtParse) {
            return new Date(Date.parse(date));
        }
        return new Date(date);
    }
    /**
     * @hidden
     * @param {string} args - Specify the args
     * @returns {boolean} - Returns boolean value.
     */
    isCellReference(args) {
        args = args.trim();
        if (args === this.emptyString) {
            return false;
        }
        args = this.setTokensForSheets(args);
        const sheetToken1 = this.getSheetToken(args);
        let containsBoth = false;
        if (sheetToken1 !== '') {
            args = args.split(sheetToken1).join(this.emptyString);
        }
        let isAlpha = false;
        let isNum = false;
        if (args.indexOf(':') !== args.lastIndexOf(':')) {
            return false;
        }
        const charArray = (args.split('').join(this.getParseArgumentSeparator())).split(this.getParseArgumentSeparator());
        for (let c = 0; c < charArray.length; c++) {
            if (this.isChar(charArray[c])) {
                isAlpha = true;
            }
            else if (this.isDigit(charArray[c])) {
                isNum = true;
            }
            else if (charArray[c] === ':') {
                if (isAlpha && isNum) {
                    containsBoth = true;
                }
                isAlpha = false;
                isNum = false;
            }
            else {
                return false;
            }
        }
        if (args.indexOf(':') > -1 && args.indexOf(this.tic) === -1) {
            if (containsBoth && isAlpha && isNum) {
                return true;
            }
            else if (((isAlpha && !isNum) || (!isAlpha && isNum)) && !containsBoth) {
                return true;
            }
            else {
                return false;
            }
        }
        if (isAlpha && isNum && args.indexOf(this.tic) === -1 && this.isValidCell(args)) {
            return true;
        }
        return false;
    }
    /**
     * @hidden
     * @param {string} text - Specify the text.
     * @returns {string} - set Tokens For Sheets.
     */
    setTokensForSheets(text) {
        const family = this.getSheetFamilyItem(this.grid);
        const sortedSheetNamesCollection = this.getSortedSheetNames();
        if (sortedSheetNamesCollection != null) {
            for (let n = 0; n < sortedSheetNamesCollection.length; n++) {
                let token = family.sheetNameToToken.get(sortedSheetNamesCollection[n]);
                token = token.split(this.sheetToken).join(this.tempSheetPlaceHolder);
                let s = this.singleTic + 'SHEET' + sortedSheetNamesCollection[n] + this.singleTic + this.sheetToken;
                if (text.indexOf(s) === -1) {
                    s = 'SHEET' + sortedSheetNamesCollection[n] + this.sheetToken;
                }
                text = text.split(s).join(token);
                s = sortedSheetNamesCollection[n] + this.sheetToken;
                text = text.split(s).join(token);
            }
        }
        text = text.split(this.tempSheetPlaceHolder).join(this.sheetToken);
        if (text.indexOf('!!') > -1) {
            text = text.replace('!!', '!');
            const textSplit = text.split('!');
            textSplit[1] = (parseInt(textSplit[1], 10) + 1).toString();
            text = textSplit.join('!');
        }
        return text;
    }
    getParentObjectCellValue(val, refresh, isUnique, isSubtotal) {
        if (val === this.trueValue || val === this.falseValue) {
            return val;
        }
        const tokenIdx = val.lastIndexOf(this.sheetToken);
        const grid = this.grid;
        let cellRef;
        if (tokenIdx > -1) {
            const family = this.getSheetFamilyItem(grid);
            if (family.tokenToParentObject !== null) {
                this.grid = family.tokenToParentObject.get(val.substring(0, tokenIdx + 1));
                cellRef = val.substring(tokenIdx + 1);
            }
            else {
                return this.getErrorStrings()[CommonErrors.Value];
            }
        }
        else {
            let j = 0;
            while (j < val.length && this.isChar(val[j])) {
                j++;
            }
            if (j === val.length) {
                return val === '' ? this.getErrorStrings()[CommonErrors.Value] : this.getErrorStrings()[CommonErrors.Name];
            }
            else {
                cellRef = val;
                const family = this.getSheetFamilyItem(grid);
                if (family.isSheetMember && family.parentObjectToToken != null) {
                    val = family.parentObjectToToken.get(this.grid) + val;
                }
            }
        }
        if (this.isDigit(cellRef[0])) {
            const alphabetStartIdx = cellRef.search(/[a-zA-Z]/);
            if (alphabetStartIdx > 0) {
                cellRef = cellRef.substring(alphabetStartIdx, cellRef.length) + cellRef.substring(0, alphabetStartIdx);
            }
        }
        const row = this.rowIndex(cellRef);
        const col = this.colIndex(cellRef);
        let result;
        if (!(row > 0 && row <= 1048576 && col > 0 && col <= 16384)) {
            result = this.getErrorStrings()[CommonErrors.Name];
        }
        else {
            const sheetId = this.getSheetId(this.grid);
            if (this.parentObject.notify) {
                const sheetInfoArgs = {
                    action: 'getSheetInfo', sheetInfo: []
                };
                this.parentObject.notify(workbookFormulaOperation, sheetInfoArgs);
                if (getSheetIndexByName(this.parentObject, 'Sheet' + sheetId, sheetInfoArgs.sheetInfo) === -1) {
                    this.grid = grid;
                    return this.getErrorStrings()[CommonErrors.Ref];
                }
            }
            result = this.getCellValueFn(grid, this.cell, sheetId, false, refresh, isUnique, isSubtotal)(row, col, val);
        }
        this.grid = grid;
        return result;
    }
    getCellValueFn(grid, actCell, sheetId, updateDependentCell, refresh, isUnique, isSubtotal) {
        let fromCell = actCell;
        if (fromCell) {
            fromCell = grid === this.grid ? '' :
                fromCell + ',' + (typeof grid === 'string' && Number(grid) > -1 ? grid : this.getSheetID(grid));
        }
        const getValueRowCol = this.parentObject.getValueRowCol.bind(this.parentObject) ||
            this.getValueRowCol.bind(this);
        return (row, col, curCell) => {
            if (actCell === curCell && !isUnique) {
                throw this.formulaErrorStrings[FormulasErrorsStrings.CircularReference];
            }
            this.cell = curCell;
            let val = getValueRowCol(sheetId, row, col, fromCell, refresh, isUnique, isSubtotal);
            if (isNullOrUndefined(val)) {
                val = this.emptyString;
            }
            else {
                val = val.toString();
                const decimalSep = this.getParseDecimalSeparator();
                if (decimalSep !== '.' && val.includes(decimalSep)) {
                    const parsedVal = val.replace(decimalSep, '.');
                    if (this.isNumber(parsedVal)) {
                        val = parsedVal;
                    }
                }
            }
            this.cell = actCell;
            if (updateDependentCell) {
                this.updateDependentCell(curCell);
            }
            return val;
        };
    }
    isValidCell(args) {
        const digitStartIdx = args.search(/\d/);
        if (digitStartIdx === 0) {
            const alphabetStartIdx = args.search(/[a-zA-Z]/);
            args = args.substring(alphabetStartIdx, args.length) + args.substring(0, alphabetStartIdx);
        }
        const row = this.rowIndex(args);
        const col = this.colIndex(args);
        return row > 0 && row <= 1048576 && col > 0 && col <= 16384;
    }
    /**
     * Returns the Sheet ID based on parent object reference.
     *
     * @hidden
     * @param {Object} grd - Specify the parent object reference.
     * @returns {number} - Returns the Sheet ID.
     */
    getSheetId(grd) {
        return grd && typeof grd === 'string' && Number(grd) > -1 ? Number(grd) : this.getSheetID(grd) + 1;
    }
    /**
     * Getting the formula result.
     *
     * @param {Object} grid - Specifies the parent object.
     * @param {number} row - Row index of the parent object or key.
     * @param {number} col - Column index of the parent object.
     * @returns {string} - Getting the formula result.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getValueRowCol(grid, row, col) {
        const key = this.rowsToKeyMap.get(row).toString();
        let result = this.getKeyValue(key).toString();
        if (result != null && result[result.length - 1] === ('%') && result.length > 1) {
            const d = this.parseFloat(result.substring(0, result.length - 1));
            if (this.isNaN(d)) {
                result = (Number(d) / 100).toString();
            }
        }
        return result;
    }
    /**
     * To add custom library formula.
     *
     * @param {string} formulaName - Custom Formula name.
     * @param {string} functionName - Custom function name.
     * @param {string} formulaDescription - Formula Description.
     * @returns {void} - To add custom library formula.
     */
    defineFunction(formulaName, functionName, formulaDescription) {
        if (typeof functionName === 'string') {
            functionName = getValue(functionName, window);
        }
        formulaName = formulaName.toUpperCase();
        this.libraryFormulas.set(formulaName, { handler: functionName, isCustom: true, description: formulaDescription });
    }
    /**
     * Specifies when changing the value.
     *
     * @param {string} grid - Parent object reference name.
     * @param {ValueChangedArgs} changeArgs - Value changed arguments.
     * @param {boolean} isCalculate - Value that allow to calculate.
     * @param {number[]} usedRangeCol - Specify the used range collection.
     * @param {boolean} refresh - Specifies for refreshing the value.
     * @param {string} sheetName - Specifies for sheet name for spreadsheet.
     * @param {boolean} isRandomFormula - Specifies for random formula values.
     * @param {boolean} randomFormulaRefreshing - Specifies for refreshing the random formula.
     * @param {boolean} isDelete - An optional flag indicating whether is from delete cells.
     * @param {number[]} deletedRange - An optional range array indicating the deleted cells.
     * @param {boolean} refreshDependentCells - Specifies dependent cell values are need to update or not.
     * @param {string} action - Specifies calculating option.
     * @returns {void} - Specifies when changing the value.
     */
    valueChanged(grid, changeArgs, isCalculate, usedRangeCol, refresh, sheetName, isRandomFormula, randomFormulaRefreshing, isDelete, deletedRange, refreshDependentCells, action) {
        const pgrid = grid;
        this.spreadSheetUsedRange = usedRangeCol;
        this.grid = grid;
        let isComputedValueChanged = true;
        let isCompute = true;
        const calcFamily = this.getSheetFamilyItem(pgrid);
        let cellTxt = getAlphalabel(changeArgs.getColIndex()) + changeArgs.getRowIndex().toString();
        this.actCell = sheetName + '!' + cellTxt;
        if (calcFamily.sheetNameToParentObject !== null && calcFamily.sheetNameToParentObject.size > 0) {
            const token = calcFamily.parentObjectToToken.get(pgrid);
            cellTxt = token + cellTxt;
        }
        const argVal = changeArgs.getFormulaValue().toUpperCase();
        if (argVal.indexOf('=RAND()') > -1 || argVal.indexOf('=NOW()') > -1 || argVal.indexOf('NOW()') > -1 || argVal.indexOf('RAND()') > -1 || argVal.indexOf('=RANDBETWEEN(') > -1 ||
            argVal.indexOf('RANDBETWEEN(') > -1 || this.randomValues.has(cellTxt)) {
            let randStrVal = this.randCollection.toString();
            if (!this.randomValues.has(cellTxt)) {
                this.randomValues.set(cellTxt, changeArgs.getFormulaValue());
                this.randCollection.push(cellTxt);
                this.isRandomVal = true;
            }
            else if (this.randomValues.has(cellTxt)) {
                if (argVal.indexOf('=RAND()') > -1 || argVal.indexOf('=NOW()') > -1 || argVal.indexOf('NOW()') > -1 || argVal.indexOf('RAND()') > -1 || argVal.indexOf('=RANDBETWEEN(') > -1 ||
                    argVal.indexOf('RANDBETWEEN(') > -1) {
                    this.randomValues.set(cellTxt, changeArgs.getFormulaValue());
                }
                else if (changeArgs.getFormulaValue().toUpperCase() !== this.randomValues.get(cellTxt.toUpperCase())) {
                    this.randomValues.delete(cellTxt);
                    randStrVal = randStrVal.split(cellTxt + this.parseArgumentSeparator).join('').split(this.parseArgumentSeparator + cellTxt).join('').split(cellTxt).join('');
                    this.randCollection = randStrVal.split(this.parseArgumentSeparator);
                }
                if (this.randomValues.size === 0 && this.randCollection.length) {
                    this.isRandomVal = false;
                    this.randomValues.clear();
                    this.randCollection = [];
                }
            }
        }
        if (changeArgs.getFormulaValue() && changeArgs.getFormulaValue()[0] === this.getFormulaCharacter()) {
            this.cell = cellTxt;
            let formula;
            if (!isNullOrUndefined(isCompute)) {
                isCompute = isCalculate;
            }
            if (this.getFormulaInfoTable().has(cellTxt)) {
                formula = this.getFormulaInfoTable().get(cellTxt);
                if (changeArgs.getFormulaValue() !== formula.getFormulaText() || formula.getParsedFormula() == null) {
                    formula.setFormulaText(changeArgs.getFormulaValue());
                    if (this.getDependentFormulaCells().has(this.cell)) {
                        this.clearFormulaDependentCells(this.cell);
                    }
                    try {
                        formula.setParsedFormula(this.parser.parseFormula(changeArgs.getFormulaValue()));
                    }
                    catch (ex) {
                        formula.setFormulaValue(ex);
                        isCompute = false;
                    }
                }
                else {
                    this.parser.isError = false;
                }
                if (isCompute) {
                    this.parser.isFormulaParsed = true;
                    const cValue = this.calculateFormula(formula.getParsedFormula(), refresh);
                    isComputedValueChanged = cValue !== formula.getFormulaValue() && (!this.parentObject.isEdit ||
                        cValue !== this.formulaErrorStrings[FormulasErrorsStrings.CircularReference]);
                    formula.setFormulaValue(cValue);
                }
            }
            else {
                formula = new FormulaInfo();
                formula.setFormulaText(changeArgs.getFormulaValue());
                if (!this.getDependentFormulaCells().has(cellTxt)) {
                    this.getDependentFormulaCells().set(cellTxt, new Map());
                }
                this.getFormulaInfoTable().set(cellTxt, formula);
                try {
                    formula.setParsedFormula(this.parser.parseFormula(changeArgs.getFormulaValue()));
                }
                catch (ex) {
                    formula.setFormulaValue(ex);
                    isCompute = false;
                }
                if (isCompute) {
                    const cValue = this.calculateFormula(formula.getParsedFormula(), refresh);
                    isComputedValueChanged = cValue !== this.formulaErrorStrings[FormulasErrorsStrings.CircularReference];
                    formula.setFormulaValue(cValue);
                }
            }
            if (isCompute) {
                /* eslint-disable */
                if (this.parentObject.setValueRowCol === undefined) {
                    this.setValueRowCol(this.getSheetID(pgrid) + 1, formula.getFormulaValue(), changeArgs.getRowIndex(), changeArgs.getColIndex());
                }
                else {
                    this.parentObject.setValueRowCol(this.getSheetId(pgrid), formula.getFormulaValue(), changeArgs.getRowIndex(), changeArgs.getColIndex(), formula.getFormulaText(), isRandomFormula);
                }
                /* eslint-enable */
            }
        }
        else if (this.getFormulaInfoTable().has(cellTxt)) {
            this.getFormulaInfoTable().delete(cellTxt);
            if (this.getDependentFormulaCells().has(cellTxt)) {
                this.clearFormulaDependentCells(cellTxt);
            }
        }
        if (isCompute && isComputedValueChanged && this.getDependentCells().has(cellTxt) &&
            (this.parentObject.calculationMode === 'Automatic' ||
                !this.parentObject.isEdit ||
                refreshDependentCells) && this.getDependentCells().get(cellTxt).toString() !== cellTxt) {
            this.refresh(cellTxt, undefined, undefined, randomFormulaRefreshing, isDelete, deletedRange, refreshDependentCells, action);
        }
    }
    /**
     * @hidden
     * @param {number} value - specify the value
     * @param {string | number} formulaValue -  specify the formula value.
     * @param {number} row - specify the row
     * @param {number} col - specify the col.
     * @returns {void} - to set value row and column.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setValueRowCol(value, formulaValue, row, col) {
        /* No Implementation */
    }
    getSortedSheetNames() {
        const family = this.getSheetFamilyItem(this.grid);
        if (family != null && family.sheetNameToToken != null) {
            const arr = [];
            family.sheetNameToToken.forEach((value, key) => {
                arr.push(key);
                arr.sort();
            });
            this.sortedSheetNames = arr;
            this.sortedSheetNames.sort();
            if (this.sortedSheetNames.length > 9 && this.sortedSheetNames[0].includes('1') && this.sortedSheetNames[1].includes('10')) {
                this.sortedSheetNames.splice(this.sortedSheetNames.indexOf('2'), 0, this.sortedSheetNames[0]);
                this.sortedSheetNames.splice(0, 1);
            }
        }
        return this.sortedSheetNames;
    }
    /**
     * @hidden
     * @param {string} error -  specify the string
     * @returns {string} - to get error line.
     */
    getErrorLine(error) {
        /* eslint-disable-next-line */
        const errorStack = error.stack ? error.stack.split('\n')[1].split(':') : null;
        return errorStack ? errorStack[errorStack.length - 2] : null; // Getting row number of the error file.
    }
    /** @hidden
     * @returns {number} - to return the sheet id
     */
    createSheetFamilyID() {
        if (this.sheetFamilyID === Number.MAX_SAFE_INTEGER) {
            this.sheetFamilyID = Number.MIN_SAFE_INTEGER;
        }
        return this.sheetFamilyID++;
    }
    /**
     * @hidden
     * @param {string[]} args - Specify the args.
     * @param {string} operation - Specify the operation.
     * @returns {string} - To compute min max.
     */
    computeMinMax(args, operation) {
        let result;
        let argVal;
        let isSubtotalFormula = false;
        let isAggregateComputation;
        let sheet;
        if (args.length) {
            const lastArgument = args[args.length - 1];
            if (lastArgument === 'isSubtotal') {
                isSubtotalFormula = true;
                args.pop();
            }
            else if (lastArgument === 'isAggregate') {
                sheet = this.parentObject.getActiveSheet();
                isAggregateComputation = true;
                args.pop();
            }
        }
        if (isNullOrUndefined(args) || args.length === 0) {
            return this.formulaErrorStrings[FormulasErrorsStrings.WrongNumberArguments];
        }
        result = (operation === 'max') ? this.minValue : this.maxValue;
        for (let k = 0, len = args.length; k < len; k++) {
            if (args[k].split(this.tic).join('').trim() === this.emptyString) {
                result = 0;
            }
        }
        const argArr = args;
        let indexes;
        if (argArr.length > 255) {
            return this.getErrorStrings()[CommonErrors.Value];
        }
        for (let i = 0; i < argArr.length; i++) {
            if (argArr[i].indexOf(':') > -1 && this.isCellReference(argArr[i])) {
                const cellValue = this.getCellCollection(argArr[i]);
                for (let j = 0; j < cellValue.length; j++) {
                    if (isAggregateComputation) {
                        indexes = getCellIndexes(cellValue[j]);
                        if (isHiddenRow(sheet, indexes[0]) || isHiddenCol(sheet, indexes[1])) {
                            continue;
                        }
                    }
                    argVal = !isSubtotalFormula ? this.getValueFromArg(cellValue[j]) :
                        this.getValueFromArg(cellValue[j], null, null, true);
                    if (isSubtotalFormula && argVal.includes('SUBTOTAL(')) {
                        continue;
                    }
                    const cellVal = this.parseFloat(argVal);
                    if (argVal === '' || this.isNaN(this.parseFloat(cellVal)) || this.getErrorStrings().indexOf(argVal) > -1) {
                        continue;
                    }
                    else {
                        result = (operation === 'max') ? Math.max(result, cellVal) : Math.min(result, cellVal);
                    }
                }
            }
            else {
                let val = !isSubtotalFormula ? this.getValueFromArg(argArr[i]) :
                    this.getValueFromArg(argArr[i], null, null, true);
                if (isSubtotalFormula && val.includes('SUBTOTAL(')) {
                    continue;
                }
                let cellVal = 0;
                const isCellRef = this.isCellReference(argArr[i]);
                const isEmptyCell = val === '' && isCellRef;
                const isStringCell = this.isNaN(this.parseFloat(val)) && isCellRef;
                const isBooleanCell = val === (this.trueValue || this.falseValue) && isCellRef;
                argArr[i] = argArr[i].startsWith('n') ? argArr[i].slice(1) : argArr[i];
                if (this.getErrorStrings().indexOf(val) > -1) {
                    return val;
                }
                if (val === this.trueValue && argArr[i] === this.trueValue) {
                    val = '1';
                }
                else if (val === this.falseValue && argArr[i] === this.falseValue) {
                    val = '0';
                }
                else if (isEmptyCell || isStringCell || isBooleanCell) {
                    continue;
                }
                if (val.indexOf('"') > -1) {
                    val = val.split(this.tic).join('');
                }
                if (this.isNaN(this.parseFloat(val))) {
                    return this.getErrorStrings()[CommonErrors.Value];
                }
                cellVal = this.parseFloat(val);
                result = operation === 'max' ? Math.max(result, cellVal) : Math.min(result, cellVal);
            }
        }
        if (result === this.minValue || result === this.maxValue) {
            result = 0;
        }
        return result.toString();
    }
    /**
     * @hidden
     * @param {string[]} args - Specify the args.
     * @param {boolean} isSubtotalFormula - Specify the args is from subtotal formula or not.
     * @param {boolean} isAggregateComputation - Specify the args is from aggregate calculation or not.
     * @returns {string} - to calculate average.
     */
    calculateAvg(args, isSubtotalFormula, isAggregateComputation) {
        const argArr = args;
        let cellColl = [];
        let cellVal;
        let value;
        let avgVal = 0;
        let countNum = 0;
        let indexes;
        let sheet;
        if (isAggregateComputation) {
            sheet = this.parentObject.getActiveSheet();
        }
        for (let k = 0; k < argArr.length; k++) {
            if (this.isCellReference(argArr[k])) {
                if (argArr[k].indexOf(':') > -1) {
                    cellColl = this.getCellCollection(argArr[k]);
                    for (let i = 0; i < cellColl.length; i++) {
                        if (isAggregateComputation) {
                            indexes = getCellIndexes(cellColl[i]);
                            if (isHiddenRow(sheet, indexes[0]) || isHiddenCol(sheet, indexes[1])) {
                                continue;
                            }
                        }
                        cellVal = !isSubtotalFormula ? this.getValueFromArg(cellColl[i]) :
                            this.getValueFromArg(cellColl[i], null, null, true);
                        if (isSubtotalFormula && cellVal.includes('SUBTOTAL(')) {
                            continue;
                        }
                        if (this.getErrorStrings().indexOf(cellVal) > -1) {
                            return cellVal;
                        }
                        else if (isNullOrUndefined(cellVal) || isNaN(this.parseFloat(cellVal)) || cellVal === '') {
                            continue;
                        }
                        avgVal = avgVal + this.parseFloat(cellVal);
                        countNum = countNum + 1;
                    }
                }
                else {
                    cellVal = !isSubtotalFormula ? this.getValueFromArg(argArr[k]) :
                        this.getValueFromArg(argArr[k], null, null, true);
                    if (isSubtotalFormula && cellVal.includes('SUBTOTAL(')) {
                        continue;
                    }
                    if (this.getErrorStrings().indexOf(cellVal) > -1) {
                        return cellVal;
                    }
                    else if (isNullOrUndefined(cellVal) || isNaN(this.parseFloat(cellVal)) || cellVal === '') {
                        continue;
                    }
                    avgVal = avgVal + this.parseFloat(cellVal);
                    countNum = countNum + 1;
                }
            }
            else {
                if (argArr[k].indexOf(this.tic) > -1) {
                    if (isNaN(this.parseFloat(argArr[k].split(this.tic).join(''))) ||
                        argArr[k].split(this.tic).join('').trim() === '') {
                        return this.getErrorStrings()[CommonErrors.Value];
                    }
                }
                if (argArr[k].length === 0 || args[k] === this.falseValue) {
                    argArr[k] = '0';
                }
                if (args[k] === this.trueValue) {
                    argArr[k] = '1';
                }
                value = this.getValueFromArg(argArr[k].split(this.tic).join(''));
                if (this.getErrorStrings().indexOf(value) > -1) {
                    return value;
                }
                avgVal = avgVal + this.parseFloat(value);
                countNum = countNum + 1;
            }
        }
        if (countNum === 0) {
            return this.getErrorStrings()[CommonErrors.DivZero];
        }
        return (avgVal / countNum).toString();
    }
    /**
     * @hidden
     * @param {string} refName - specify the reference name.
     * @param {Object | string } model - model - Specify the model.model
     * @param {number} sheetFamilyID - specify the sheet family id.
     * @returns {string} - register Grid As Sheet.
     */
    registerGridAsSheet(refName, model, sheetFamilyID) {
        if (isNullOrUndefined(this.modelToSheetID)) {
            this.modelToSheetID = new Map();
        }
        if (isNullOrUndefined(this.modelToSheetID.get(model))) {
            this.modelToSheetID.set(model, sheetFamilyID);
        }
        const family = this.getSheetFamilyItem(model);
        family.isSheetMember = true;
        const tempRef = refName.toUpperCase();
        if (family.parentObjectToToken.size === 0) {
            family.parentObjectToToken = new Map();
        }
        if (family.sheetNameToParentObject.size === 0) {
            family.sheetNameToParentObject = new Map();
        }
        if (family.sheetNameToToken.size === 0) {
            family.sheetNameToToken = new Map();
        }
        if (family.tokenToParentObject.size === 0) {
            family.tokenToParentObject = new Map();
        }
        if (!isUndefined$1(family.sheetNameToParentObject.get(tempRef))) {
            const token = family.sheetNameToToken.get(tempRef);
            family.tokenToParentObject.set(token, model);
            family.parentObjectToToken.set(model, token);
        }
        else {
            const token = this.sheetToken + this.tokenCount.toString() + this.sheetToken;
            this.tokenCount++;
            family.tokenToParentObject.set(token, model);
            family.parentObjectToToken.set(model, token);
            family.sheetNameToToken.set(tempRef, token);
            family.sheetNameToParentObject.set(tempRef, model);
        }
        return refName;
    }
    /**
     * @hidden
     * @param {string} refName - Specify the reference name
     * @param {string | Object} model - Specify the model
     * @param {boolean} unRegisterAll - Un registed all the availbe model.
     * @returns {void} - To un register grid sheet.
     */
    unregisterGridAsSheet(refName, model, unRegisterAll) {
        let modelArr = [model];
        if (unRegisterAll) {
            modelArr = [];
            if (!isNullOrUndefined(this.modelToSheetID)) {
                this.modelToSheetID.forEach((value, key) => {
                    modelArr.push(key);
                });
            }
        }
        modelArr.forEach((value) => {
            const family = this.getSheetFamilyItem(value);
            const refName1 = (unRegisterAll ? value : refName).toUpperCase();
            if (family.sheetNameToParentObject != null && family.sheetNameToParentObject.has(refName1)) {
                family.sheetNameToParentObject.delete(refName1);
                const token = family.sheetNameToToken.get(refName1);
                family.sheetNameToToken.delete(refName1);
                family.tokenToParentObject.delete(token);
                family.parentObjectToToken.delete(value);
            }
        });
    }
    /**
     * @hidden
     * @param {string} formula - Specify the formula.
     * @param {boolean} isFromComputeExpression - Specifies to confirm it was called from the ComputeExpression function.
     * @returns {string | number} - To compute the expression.
     */
    computeExpression(formula, isFromComputeExpression) {
        const parsedFormula = this.parser.parseFormula(formula);
        const calcValue = this.computeFormula(parsedFormula, isFromComputeExpression);
        return calcValue;
    }
    isSheetMember() {
        const family = this.getSheetFamilyItem(this.grid);
        return isNullOrUndefined(family) ? false : family.isSheetMember;
    }
    /**
     * To dispose the calculate engine.
     *
     * @returns {void} - To dispose the calculate engine.
     */
    dispose() {
        this.resetKeys();
        // this.dependentCells.clear();
        // this.dependentFormulaCells.clear();
        this.namedRanges.clear();
        // this.sheetFamiliesList.clear();
        this.lFormulas.clear();
    }
    refreshRandValues(cellRef) {
        let rowIdx;
        let colIdx;
        let value;
        let tokenRef = '';
        let family;
        if (this.randomValues.has(cellRef)) {
            this.randomValues.delete(cellRef);
            const randIdx = this.randCollection.indexOf(cellRef);
            if (randIdx > -1) {
                this.randCollection.splice(randIdx, 1);
            }
            if (this.randomValues.size === 0 && !this.randCollection.length) {
                this.randomValues.clear();
                this.randCollection = [];
            }
        }
        for (let i = 0; i < this.randomValues.size; i++) {
            rowIdx = this.rowIndex(this.randCollection[i]);
            colIdx = this.colIndex(this.randCollection[i]);
            tokenRef = (parseFloat(this.getSheetToken(this.randCollection[i]).split(this.sheetToken).join('')) + 1).toString();
            family = this.getSheetFamilyItem(tokenRef);
            this.grid = family.sheetNameToParentObject.get(tokenRef);
            value = this.randomValues.get(this.randCollection[i]);
            value = this.computeFormula(value);
            if (this.parentObject.setValueRowCol === undefined) {
                this.setValueRowCol(this.getSheetID(this.grid) + 1, value, rowIdx, colIdx);
            }
            else {
                this.parentObject.setValueRowCol(this.getSheetId(this.grid), value, rowIdx, colIdx);
            }
        }
    }
    refresh(cellRef, uniqueCell, dependentCell, isRandomFormula, isDelete, deletedRange, refreshDependentCells, action) {
        let refreshCells;
        if (!dependentCell) {
            refreshCells = true;
            dependentCell = [];
        }
        const family = this.getSheetFamilyItem(this.grid);
        try {
            const dependentCells = this.getDependentCells().get(cellRef);
            if (dependentCells && dependentCells.length !== 0 &&
                (this.parentObject.calculationMode === 'Automatic' ||
                    refreshDependentCells || action === 'calculate')) {
                let i;
                for (i = 0; i < dependentCells.length; i++) {
                    const dCell = dependentCells[i];
                    if ((uniqueCell && dCell.indexOf(uniqueCell) > -1) || dCell === cellRef || dependentCell.indexOf(dCell) > -1) {
                        continue;
                    }
                    const token = this.getSheetToken(dCell);
                    const sheets = this.parentObject.sheets;
                    let sheetIdx = this.parentObject.activeSheetIndex;
                    if (token.length) {
                        this.grid = family.tokenToParentObject.get(token);
                        const sheetId = Number(this.grid);
                        let sheetName = '';
                        if (!this.isNaN(sheetId) && sheets) {
                            for (let i = 0; i < sheets.length; i++) {
                                if (sheets[i].id === sheetId) {
                                    sheetName = sheets[i].name;
                                    sheetIdx = i;
                                }
                            }
                        }
                        this.actCell = sheetName + '!' + dCell.split(token)[1];
                    }
                    else {
                        this.actCell = dCell.split(token)[1];
                    }
                    try {
                        const calculateFormula = (cell, formulaInfo) => {
                            if (formulaInfo) {
                                this.cell = cell;
                                this.parser.isFormulaParsed = true;
                                formulaInfo.setFormulaValue(this.calculateFormula(formulaInfo.getParsedFormula(), true));
                            }
                        };
                        const rowIdx = this.rowIndex(dCell);
                        const colIdx = this.colIndex(dCell);
                        const formulaInfo = this.getFormulaInfoTable().get(dCell);
                        if (this.parentObject.setValueRowCol === undefined) {
                            calculateFormula(dCell, formulaInfo);
                            this.setValueRowCol(this.getSheetID(this.grid) + 1, formulaInfo.getFormulaValue(), rowIdx, colIdx);
                        }
                        else {
                            const cell = sheets && sheets[sheetIdx].rows &&
                                sheets[sheetIdx].rows[rowIdx - 1] && sheets[sheetIdx].rows[rowIdx - 1].cells &&
                                sheets[sheetIdx].rows[rowIdx - 1].cells[colIdx - 1];
                            let val;
                            if (cell && cell.formula && cell.formula.toLowerCase().includes('unique')) {
                                if (!this.uniqueCells || this.uniqueCells.indexOf(dCell) === -1) {
                                    if (!this.uniqueCells) {
                                        this.uniqueCells = [];
                                    }
                                    this.uniqueCells.push(dCell);
                                    calculateFormula(dCell, formulaInfo);
                                    val = formulaInfo.getFormulaValue();
                                    this.uniqueCells.splice(this.uniqueCells.indexOf(dCell), 1);
                                    if (!this.uniqueCells.length) {
                                        this.uniqueCells = null;
                                    }
                                }
                                else {
                                    continue;
                                }
                            }
                            else {
                                if (dependentCell.indexOf(dCell) === -1) {
                                    dependentCell.push(dCell);
                                }
                                val = null;
                            }
                            this.parentObject.setValueRowCol(this.getSheetId(this.grid), val, rowIdx, colIdx, formulaInfo.getFormulaText());
                        }
                        this.refresh(dCell, null, dependentCell, null, isDelete);
                    }
                    catch (ex) {
                        continue;
                    }
                }
            }
            if (refreshCells) {
                if (!isDelete && deletedRange && deletedRange.length === 4) {
                    const token = this.getSheetToken(cellRef);
                    const deletedCell = [];
                    for (let sRIdx = deletedRange[0], eRIdx = deletedRange[2]; sRIdx <= eRIdx; sRIdx++) {
                        for (let sCIdx = deletedRange[1], eCIdx = deletedRange[3]; sCIdx <= eCIdx; sCIdx++) {
                            if (sRIdx === eRIdx && sCIdx === eCIdx) {
                                break;
                            }
                            const cell = token + getCellAddress(sRIdx, sCIdx);
                            this.refresh(cell, null, dependentCell, null, isDelete);
                            deletedCell.push(cell);
                        }
                    }
                    const ranges = new Set(deletedCell);
                    if (dependentCell) {
                        dependentCell = dependentCell.filter((item) => !ranges.has(item));
                    }
                }
                const sheets = this.parentObject.sheets;
                if (!sheets) {
                    dependentCell = [];
                }
                dependentCell.forEach((cell) => {
                    let sheetIdx;
                    const sheetId = this.getSheetId(family.tokenToParentObject.get(this.getSheetToken(cell)));
                    for (let idx = 0; idx < sheets.length; idx++) {
                        if (sheets[idx].id === sheetId) {
                            sheetIdx = idx;
                            break;
                        }
                    }
                    const rowIdx = this.rowIndex(cell) - 1;
                    const colIdx = this.colIndex(cell) - 1;
                    const cellObj = sheets[sheetIdx].rows[rowIdx] &&
                        sheets[sheetIdx].rows[rowIdx].cells[colIdx];
                    if (cellObj) {
                        this.parentObject.notify('calculateFormula', { cell: cellObj, rowIdx: rowIdx, colIdx: colIdx, sheetIndex: sheetIdx, isDependentRefresh: true, isRandomFormula: isRandomFormula, action: action });
                    }
                });
            }
        }
        finally {
            if (this.getDependentCells().has(cellRef)) {
                this.grid = family.tokenToParentObject.get(this.getSheetToken(cellRef));
            }
        }
    }
};
__decorate$3([
    Event$1()
], Calculate.prototype, "onFailure", void 0);
Calculate = __decorate$3([
    NotifyPropertyChanges
], Calculate);
/** @hidden */
class FormulaError {
    constructor(errorMessage, formulaAutoCorrection) {
        this.formulaCorrection = false;
        this.message = errorMessage;
        this.formulaCorrection = formulaAutoCorrection;
    }
}
/** @hidden */
class FormulaInfo {
    constructor() {
        /**
         * @hidden
         */
        this.calcID = Number.MIN_VALUE + 1;
        this.calcID1 = Number.MIN_VALUE + 1;
    }
    /**
     * @hidden
     * @returns {void} - To get Formula Text
     */
    getFormulaText() {
        return this.formulaText;
    }
    /**
     * @hidden
     * @param {string} value - Specify the value
     * @returns {void} - To set Formula Text
     */
    setFormulaText(value) {
        this.formulaText = value;
    }
    /**
     * @hidden
     * @returns {string} - To get Formula Value
     */
    getFormulaValue() {
        return this.formulaValue;
    }
    /**
     * @hidden
     * @param {string | number} value - Specify the value
     * @returns {void} - To set Parsed Formula
     */
    setFormulaValue(value) {
        this.formulaValue = value;
    }
    /**
     * @hidden
     * @returns {string} - To get Parsed Formula
     */
    getParsedFormula() {
        return this.parsedFormula;
    }
    /**
     * @hidden
     * @param {string} value - Specify the value
     * @returns {void} - To set Parsed Formula
     */
    setParsedFormula(value) {
        this.parsedFormula = value;
    }
}
/** @hidden */
class CalcSheetFamilyItem {
    constructor() {
        /**
         * @hidden
         */
        this.isSheetMember = false;
        /**
         * @hidden
         */
        this.parentObjectToToken = new Map();
        /**
         * @hidden
         */
        this.sheetDependentFormulaCells = new Map();
        /**
         * @hidden
         */
        this.sheetNameToParentObject = new Map();
        /**
         * @hidden
         */
        this.sheetNameToToken = new Map();
        /**
         * @hidden
         */
        this.tokenToParentObject = new Map();
        /**
         * @hidden
         */
        this.sheetFormulaInfotable = new Map();
    }
}
/**
 * @hidden
 * @param {number} col - Specify the column
 * @returns {string} - To returns get Alphalabel.
 */
function getAlphalabel(col) {
    const cols = [];
    let n = 0;
    const charText = 'A';
    while (col > 0 && n < 9) {
        col--;
        const aCharNo = charText.charCodeAt(0);
        cols[n] = String.fromCharCode(col % 26 + aCharNo);
        col = parseInt((col / 26).toString(), 10);
        n++;
    }
    const chs = [];
    for (let i = 0; i < n; i++) {
        chs[n - i - 1] = cols[i];
    }
    return chs.join('');
}
class ValueChangedArgs {
    constructor(row, col, value) {
        this.row = row;
        this.col = col;
        this.value = value;
        this.getRowIndex = () => {
            return row;
        };
        this.setRowIndex = (value) => {
            row = value;
        };
        this.getColIndex = () => {
            return col;
        };
        this.setColIndex = (value) => {
            col = value;
        };
        this.getFormulaValue = () => {
            return value;
        };
        return this;
    }
}

/**
 * @hidden
 * The `WorkbookFormula` module is used to handle the formula operation in Workbook.
 */
class WorkbookFormula {
    /**
     * Constructor for formula module in Workbook.
     *
     * @param {Workbook} workbook - Specifies the workbook.
     * @private
     */
    constructor(workbook) {
        this.uniqueOBracket = String.fromCharCode(129);
        this.uniqueCBracket = String.fromCharCode(130);
        this.uniqueCSeparator = String.fromCharCode(131);
        this.uniqueCOperator = String.fromCharCode(132);
        this.uniquePOperator = String.fromCharCode(133);
        this.uniqueSOperator = String.fromCharCode(134);
        this.uniqueMOperator = String.fromCharCode(135);
        this.uniqueDOperator = String.fromCharCode(136);
        this.uniqueModOperator = String.fromCharCode(137);
        this.uniqueConcateOperator = String.fromCharCode(138);
        this.uniqueEqualOperator = String.fromCharCode(139);
        this.uniqueExpOperator = String.fromCharCode(140);
        this.uniqueGTOperator = String.fromCharCode(141);
        this.uniqueLTOperator = String.fromCharCode(142);
        this.sheetInfo = [];
        this.parent = workbook;
        this.init();
    }
    init() {
        this.addEventListener();
        this.initCalculate();
        this.registerSheet();
        this.parent.customFormulaCollection.forEach((value, key) => {
            this.addCustomFunction(value.handler, key, value.description);
        });
    }
    /**
     * To destroy the formula module.
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (this.parent.refreshing) {
            this.clearAllUniqueFormulaValue();
            const formulaCollect = this.calculateInstance.getLibraryFormulas();
            formulaCollect.forEach((value, key) => {
                if (value.isCustom) {
                    this.parent.customFormulaCollection.set(key, { handler: value.handler, description: value.description });
                }
            });
        }
        this.calculateInstance.dispose();
        this.calculateInstance = null;
        if (this.sheetInfo) {
            this.sheetInfo = [];
        }
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(workbookFormulaOperation, this.performFormulaOperation, this);
        this.parent.on(aggregateComputation, this.aggregateComputation, this);
        this.parent.on(getUniqueRange, this.getUniqueRange, this);
        this.parent.on(removeUniquecol, this.removeUniquecol, this);
        this.parent.on(clearFormulaDependentCells, this.clearFormulaDependentCells, this);
        this.parent.on(formulaInValidation, this.formulaInValidation, this);
        this.parent.on(refreshInsertDelete, this.refreshInsertDelete, this);
        this.parent.on(getUpdatedFormulaOnInsertDelete, this.getUpdatedFormulaOnInsertDelete, this);
        this.parent.on(checkFormulaRef, this.autoCorrectCellRef, this);
        this.parent.on(parseFormulaArgument, this.parseFormulaArgument, this);
        this.parent.on(getCellRefValue, this.getCellRefValue, this);
        this.parent.on(commputeFormulaValue, this.commputeFormulaValue, this);
        this.parent.on(sheetRenameUpdate, this.renameUpdation, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(workbookFormulaOperation, this.performFormulaOperation);
            this.parent.off(aggregateComputation, this.aggregateComputation);
            this.parent.off(getUniqueRange, this.getUniqueRange);
            this.parent.off(removeUniquecol, this.removeUniquecol);
            this.parent.off(clearFormulaDependentCells, this.clearFormulaDependentCells);
            this.parent.off(formulaInValidation, this.formulaInValidation);
            this.parent.off(refreshInsertDelete, this.refreshInsertDelete);
            this.parent.off(getUpdatedFormulaOnInsertDelete, this.getUpdatedFormulaOnInsertDelete);
            this.parent.off(checkFormulaRef, this.autoCorrectCellRef);
            this.parent.off(parseFormulaArgument, this.parseFormulaArgument);
            this.parent.off(getCellRefValue, this.getCellRefValue);
            this.parent.off(commputeFormulaValue, this.commputeFormulaValue);
            this.parent.off(sheetRenameUpdate, this.renameUpdation);
        }
    }
    /**
     * Get the module name.
     *
     * @returns {string} - Get the module name.
     * @private
     */
    getModuleName() {
        return 'workbookFormula';
    }
    initCalculate() {
        this.calculateInstance = new Calculate(this.parent);
        this.calcID = this.calculateInstance.createSheetFamilyID();
        this.calculateInstance.setTreatEmptyStringAsZero(true);
        this.calculateInstance.grid = this.parent.getActiveSheet().id.toString();
        this.calculateInstance.setParseArgumentSeparator(this.parent.listSeparator);
        const decimalSeparator = getNumericObject(this.parent.locale).decimal;
        if (decimalSeparator !== '.' && this.parent.listSeparator !== decimalSeparator) {
            this.calculateInstance.setParseDecimalSeparator(decimalSeparator);
        }
    }
    clearFormulaDependentCells(args) {
        if (args.isOpen) {
            this.calculateInstance.getDependentCells().clear();
            this.calculateInstance.getFormulaInfoTable().clear();
            this.calculateInstance.getDependentFormulaCells().clear();
            return;
        }
        let cellRef = args.cellRef.split(':')[0];
        const sheetId = this.parent.getActiveSheet().id.toString();
        const family = this.calculateInstance.getSheetFamilyItem(sheetId);
        if (family.isSheetMember && !isNullOrUndefined(family.parentObjectToToken)) {
            cellRef = family.parentObjectToToken.get(sheetId) + cellRef;
        }
        if (args.clearFormulaInfo && this.calculateInstance.getFormulaInfoTable().has(cellRef)) {
            this.calculateInstance.getFormulaInfoTable().delete(cellRef);
        }
        this.calculateInstance.clearFormulaDependentCells(cellRef);
    }
    formulaInValidation(args) {
        const col = this.calculateInstance.getLibraryFormulas().get(args.value);
        args.skip = isNullOrUndefined(col);
    }
    performFormulaOperation(args) {
        const action = args.action;
        let formulas;
        let formulaInfo;
        if (action !== 'refreshCalculate') {
            formulas = this.calculateInstance.getLibraryFormulas();
            formulaInfo = (Array.from(formulas.values()));
        }
        let collection;
        const family = this.calculateInstance.getSheetFamilyItem(args.sheetId);
        switch (action) {
            case 'getLibraryFormulas':
                args.formulaCollection = Array.from(formulas.keys());
                break;
            case 'getFormulaCategory':
                collection = ['All'];
                for (let i = 1; i < Array.from(formulas.values()).length; i++) {
                    if (collection.indexOf(formulaInfo[i].category) < 0) {
                        collection.push(formulaInfo[i].category);
                    }
                }
                args.categoryCollection = collection;
                break;
            case 'dropDownSelectFormulas':
                for (let i = 0; i < Array.from(formulas.values()).length; i++) {
                    if (args.selectCategory === formulaInfo[i].category) {
                        args.formulaCollection[i] = Array.from(formulas.keys())[i];
                    }
                }
                break;
            case 'getFormulaDescription':
                for (let i = 0; i < Array.from(formulas.values()).length; i++) {
                    if (args.selectedList === Array.from(formulas.keys())[i]) {
                        args.description = formulaInfo[i].description;
                        args.isCustom = formulaInfo[i].isCustom;
                    }
                }
                break;
            case 'registerSheet':
                this.registerSheet(args.sheetIndex, args.sheetCount);
                if (args.isImport) {
                    this.calculateInstance.setParseArgumentSeparator(this.parent.listSeparator);
                    this.updateSheetInfo();
                }
                break;
            case 'unRegisterSheet':
                this.unRegisterSheet(args.sheetIndex, args.sheetCount, args.propertyChange);
                break;
            case 'initSheetInfo':
                this.updateSheetInfo();
                break;
            case 'refreshCalculate':
                this.refreshCalculate(args);
                break;
            case 'refreshRandomFormula':
                this.refreshRandomFormula();
                this.calculateInstance.cell = '';
                break;
            case 'setArgumentSeparator':
                this.calculateInstance.setParseArgumentSeparator(this.parent.listSeparator);
                break;
            case 'addDefinedName':
                args.isAdded = this.addDefinedName(args.definedName, false, args.index, args.isEventTrigger);
                break;
            case 'removeDefinedName':
                args.isRemoved = this.removeDefinedName(args.definedName, args.scope, args.isEventTrigger);
                break;
            case 'initiateDefinedNames':
                this.initiateDefinedNames();
                break;
            case 'addSheet':
                this.sheetInfo.push({ visibleName: args.visibleName, sheet: args.sheetName, index: args.sheetId });
                break;
            case 'getSheetInfo':
                args.sheetInfo = this.sheetInfo;
                break;
            case 'deleteSheetTab':
                for (let i = 0; i < this.sheetInfo.length; i++) {
                    if (this.sheetInfo[i].index === args.sheetId) {
                        const visibleName = this.sheetInfo[i].visibleName;
                        const sheetName = this.sheetInfo[i].sheet;
                        this.sheetInfo.splice(i, 1);
                        const id = args.sheetId.toString();
                        this.sheetDeletion(sheetName, id);
                        this.calculateInstance.unregisterGridAsSheet(id, id);
                        this.definedNamesDeletion(visibleName);
                        break;
                    }
                }
                break;
            case 'getReferenceError':
                args.refError = this.referenceError();
                break;
            case 'getAlpha':
                args.col = getAlphalabel(args.col);
                break;
            case 'addCustomFunction':
                this.addCustomFunction(args.functionHandler, args.functionName, args.formulaDescription);
                break;
            case 'computeExpression':
                args.calcValue = this.calculateInstance.computeExpression(args.formula, args.isFromComputeExpression);
                break;
            case 'registerGridInCalc':
                this.calculateInstance.grid = args.sheetID;
                break;
            case 'dependentCellsAvailable':
            case 'checkFormulaAdded':
                if (family.isSheetMember && !isNullOrUndefined(family.parentObjectToToken)) {
                    args.address = family.parentObjectToToken.get(args.sheetId) + args.address;
                }
                if (action === 'checkFormulaAdded') {
                    args.added = this.calculateInstance.getFormulaInfoTable().has(args.address);
                }
                else {
                    args.isAvailable = this.calculateInstance.getDependentCells().has(args.address);
                }
                break;
            case 'calculateNow':
                this.calculateNow(args);
                break;
            case 'ClearDependentCellCollection':
                this.calculateInstance.getDependentFormulaCells().clear();
                this.calculateInstance.getDependentCells().clear();
                this.calculateInstance.getFormulaInfoTable().clear();
                break;
        }
    }
    definedNamesDeletion(sheetName) {
        const definedNames = this.parent.definedNames;
        if (definedNames && definedNames.length > 0) {
            for (let i = definedNames.length - 1; i >= 0; i--) {
                if (definedNames[i].refersTo.substring(1, definedNames[i].refersTo.lastIndexOf('!')).split('\'').join('') === sheetName) {
                    this.removeDefinedName(definedNames[i].name, definedNames[i].scope);
                }
            }
        }
    }
    referenceError() {
        return this.calculateInstance.getErrorStrings()[CommonErrors.Ref];
    }
    getSheetInfo() {
        return this.sheetInfo;
    }
    addCustomFunction(functionHandler, functionName, formulaDescription) {
        this.calculateInstance.defineFunction(functionName, functionHandler, formulaDescription);
    }
    updateSheetInfo() {
        this.sheetInfo = [];
        this.parent.sheets.forEach((sheet) => {
            this.sheetInfo.push({ visibleName: sheet.name, sheet: 'Sheet' + sheet.id, index: sheet.id });
        });
    }
    getSheetRefUpdateOnDelete() {
        const definedNames = this.calculateInstance.namedRanges;
        let keyArray;
        let valueArray;
        let isDefinedNamesAvail;
        if (definedNames && definedNames.size) {
            isDefinedNamesAvail = true;
            keyArray = Array.from(definedNames.keys());
            valueArray = Array.from(definedNames.values());
        }
        return (delSheetName, formula) => {
            let isNamedRange;
            if (isDefinedNamesAvail && !formula.includes(delSheetName)) {
                formula = formula.replace(/\w+/g, (key) => {
                    const index = keyArray.indexOf(key);
                    if (index !== -1) {
                        isNamedRange = true;
                        return valueArray[index];
                    }
                    return key;
                });
            }
            const sheetName = delSheetName.toUpperCase();
            formula = formula.toUpperCase();
            let idx = formula.indexOf(sheetName);
            while (idx > -1) {
                formula = formula.split((formula[idx - 1] === '\'' && formula[idx + sheetName.length] === '\'' ? `'${sheetName}'` : sheetName) +
                    this.calculateInstance.sheetToken).join(this.referenceError());
                idx = formula.indexOf(sheetName);
            }
            return { value: formula, isNamedRange };
        };
    }
    sheetDeletion(delSheetName, sheetId) {
        const dependentCell = this.calculateInstance.getDependentCells();
        let fInfo;
        let token;
        const family = this.calculateInstance.getSheetFamilyItem(sheetId);
        const updateSheetRef = this.getSheetRefUpdateOnDelete();
        let updatedInfo;
        dependentCell.forEach((dependentCellRefs, cellRef) => {
            dependentCellRefs.forEach((dependentCellRef) => {
                fInfo = this.calculateInstance.getFormulaInfoTable().get(dependentCellRef);
                if (!isNullOrUndefined(fInfo)) {
                    updatedInfo = updateSheetRef(delSheetName, fInfo.formulaText);
                    if (updatedInfo.value !== fInfo.formulaText) {
                        token = dependentCellRef.slice(0, dependentCellRef.lastIndexOf(this.calculateInstance.sheetToken) + 1);
                        updatedInfo.sheetId = family.tokenToParentObject.has(token) ? Number(family.tokenToParentObject.get(token)) :
                            parseInt(dependentCellRef.split('!')[1], 10) + 1;
                        this.updateDataContainer([this.calculateInstance.rowIndex(dependentCellRef) - 1, this.calculateInstance.colIndex(dependentCellRef) - 1], updatedInfo);
                        this.calculateInstance.refresh(fInfo.getParsedFormula());
                    }
                }
                token = cellRef.slice(0, cellRef.lastIndexOf(this.calculateInstance.sheetToken) + 1);
                if (sheetId === (family.tokenToParentObject.has(token) ? family.tokenToParentObject.get(token) :
                    cellRef.split('!')[1])) {
                    this.calculateInstance.getFormulaInfoTable().delete(cellRef);
                    this.calculateInstance.clearFormulaDependentCells(cellRef);
                }
            });
        });
    }
    renameUpdation(args) {
        const name = args.value;
        const pName = args.pName;
        let sheet;
        let cell;
        const uPName = args.pName.toUpperCase();
        const escapeRegx = new RegExp('[!@#$%^&()+=\';,.{}|\\":<>~_-]', 'g');
        const exp = '(?=[\'!])(?=[^"]*(?:"[^"]*"[^"]*)*$)';
        const regExp = RegExp;
        const regx = new regExp(pName.replace(escapeRegx, '\\$&') + exp, 'gi');
        const renameValidationSheetRef = (validation) => {
            if (checkIsFormula(validation.value1) && validation.value1.toUpperCase().includes(uPName) && validation.value1.match(regx)) {
                validation.value1 = validation.value1.replace(regx, name);
            }
            if (checkIsFormula(validation.value2) && validation.value2.toUpperCase().includes(uPName) && validation.value2.match(regx)) {
                validation.value2 = validation.value2.replace(regx, name);
            }
        };
        this.sheetInfo.forEach((info, index) => {
            sheet = getSheet(this.parent, index);
            if (sheet && sheet.rows && sheet.rows.length) {
                for (let i = 0, rowLen = sheet.rows.length; i < rowLen; i++) {
                    if (sheet.rows[i] && sheet.rows[i].cells) {
                        for (let j = 0, cellsLen = sheet.rows[i].cells.length; j < cellsLen; j++) {
                            cell = getCell(i, j, sheet, false, true);
                            if (cell.formula && checkIsFormula(cell.formula) && cell.formula.toUpperCase().includes(uPName) &&
                                cell.formula.match(regx)) {
                                cell.formula = cell.formula.replace(regx, name);
                            }
                            if (cell.validation) {
                                renameValidationSheetRef(cell.validation);
                            }
                        }
                    }
                }
            }
            if (sheet && sheet.columns && sheet.columns.length) {
                let column;
                for (let i = 0, colsLen = sheet.columns.length; i < colsLen; i++) {
                    column = sheet.columns[i];
                    if (column && column.validation) {
                        renameValidationSheetRef(column.validation);
                    }
                }
            }
            const definedNames = this.parent.definedNames;
            for (let i = 0; i < definedNames.length; i++) {
                if (checkIsFormula(definedNames[i].refersTo) && definedNames[i].refersTo.includes(pName) &&
                    definedNames[i].refersTo.match(regx)) {
                    definedNames[i].refersTo = definedNames[i].refersTo.replace(regx, name);
                    if (definedNames[i].scope.includes(pName)) {
                        definedNames[i].scope = name;
                    }
                }
            }
            this.calculateInstance.updateNamedRange(pName, name);
            if (info.visibleName === pName) {
                info.visibleName = name;
            }
        });
    }
    updateDataContainer(indexes, data) {
        let sheet;
        let rowData;
        let colObj;
        for (let i = 0, len = this.parent.sheets.length; i < len; i++) {
            sheet = getSheet(this.parent, i);
            if (sheet.id === data.sheetId) {
                if (indexes[0] in sheet.rows) {
                    rowData = sheet.rows[indexes[0]];
                    if (indexes[1] in rowData.cells) {
                        colObj = rowData.cells[indexes[1]];
                        colObj.formula = data.isNamedRange ? colObj.formula : data.value;
                        if (data.visible) {
                            if (i === this.parent.activeSheetIndex && sheet.activeCell === getCellAddress(indexes[0], indexes[1])) {
                                this.parent.notify(selectionComplete, {});
                            }
                        }
                        else if (this.parent.calculationMode === 'Automatic') {
                            colObj.value = this.referenceError();
                        }
                    }
                    else {
                        rowData.cells[indexes[1]] = colObj = {};
                    }
                }
                else {
                    rowData = sheet.rows[indexes[0]] = {};
                    rowData[indexes[1]] = colObj = {};
                }
                break;
            }
        }
    }
    parseSheetRef(value, addSheetQuotes) {
        let regx;
        // eslint-disable-next-line no-useless-escape
        const escapeRegx = new RegExp('[!@#$%^&()+=\';,.{}|\":<>~_-]', 'g');
        let i = 0;
        const sheetInfo = this.getSheetInfo();
        const sheetCount = sheetInfo.length;
        const temp = [];
        temp.length = 0;
        let regxTemp;
        let searchIdx;
        let idx;
        let valSearchIdx;
        let regxVisible;
        const exp = '(?=[\'!])(?=[^"]*(?:"[^"]*"[^"]*)*$)';
        const regExp = RegExp;
        for (i = 0; i < sheetCount; i++) {
            if (sheetInfo[i].sheet !== sheetInfo[i].visibleName) {
                regx = new regExp(sheetInfo[i].visibleName.replace(escapeRegx, '\\$&') + exp, 'gi');
                idx = i;
                if (value.match(regx)) {
                    for (let j = i + 1; j < sheetCount; j++) {
                        if (sheetInfo[j].visibleName.includes(sheetInfo[i].visibleName)) {
                            regxTemp = new regExp(sheetInfo[j].visibleName.replace(escapeRegx, '\\$&') + exp, 'gi');
                            searchIdx = value.search(regxTemp);
                            valSearchIdx = value.search(regx);
                            if (searchIdx > -1 && (searchIdx < valSearchIdx || (searchIdx === valSearchIdx &&
                                sheetInfo[j].visibleName.length > sheetInfo[i].visibleName.length))) {
                                regxVisible = new RegExp('Sheet', 'gi');
                                if (sheetInfo[j].visibleName.search(regxVisible) !== 0) {
                                    regx = regxTemp;
                                    idx = j;
                                }
                            }
                        }
                    }
                    value = value.replace(regx, idx + '/');
                    temp.push(idx);
                }
            }
        }
        i = 0;
        let sheetRef;
        while (i < temp.length) {
            regx = new regExp(temp[i] + '/' + exp, 'gi');
            sheetRef = addSheetQuotes ? '`' + sheetInfo[temp[i]].sheet + '`' : sheetInfo[temp[i]].sheet;
            value = value.replace(regx, sheetRef);
            i++;
        }
        return value;
    }
    registerSheet(sheetIndex = 0, sheetCount = this.parent.sheets.length) {
        let id;
        while (sheetIndex < sheetCount) {
            id = getSheet(this.parent, sheetIndex).id + '';
            this.calculateInstance.registerGridAsSheet(id, id, this.calcID);
            sheetIndex++;
        }
    }
    unRegisterSheet(sheetIndex = 0, sheetCount = this.parent.sheets.length, propertyChange) {
        let id;
        this.calculateInstance.tokenCount = 0;
        if (propertyChange) {
            this.calculateInstance.unregisterGridAsSheet(id, id, propertyChange);
        }
        else {
            while (sheetIndex < sheetCount) {
                id = getSheet(this.parent, sheetIndex).id + '';
                this.calculateInstance.unregisterGridAsSheet(id, id);
                sheetIndex++;
            }
        }
    }
    getUniqueRange(args) {
        args.range = this.calculateInstance.uniqueRange;
    }
    removeUniquecol(args) {
        if (args && args.clearAll) {
            this.clearAllUniqueFormulaValue();
            return;
        }
        const sheet = this.parent.getActiveSheet();
        for (let i = 0; i < this.calculateInstance.uniqueRange.length; i++) {
            const uniqRngAddress = this.calculateInstance.uniqueRange[i].split(':')[0].split('!');
            if (uniqRngAddress[0] === sheet.name && uniqRngAddress[1] === sheet.activeCell) {
                const range = getRangeIndexes(this.calculateInstance.uniqueRange[i]);
                this.calculateInstance.uniqueRange.splice(i, 1);
                for (let j = range[0]; j <= range[2]; j++) {
                    for (let k = range[1]; k <= range[3]; k++) {
                        const cell = getCell(j, k, this.parent.getActiveSheet());
                        cell.formula = '';
                        this.parent.updateCellDetails({ value: '', formula: '' }, getRangeAddress([j, k]), undefined, undefined, true);
                    }
                }
            }
        }
    }
    /**
     * Perform the formula calculation.
     *
     * @param {FormulaCalculateArgs} args - Specifies the formula calculation options.
     * @param {number} args.rowIndex - The index of the row.
     * @param {number} args.colIndex - The index of the column.
     * @param {string} args.value - The value of the cell.
     * @param {boolean} args.isFormula - A flag indicating whether the value is a formula.
     * @param {number} args.sheetIdx - The index of the sheet.
     * @param {boolean} args.isRefreshing - A flag indicating whether the calculation is being refreshed.
     * @param {boolean} [args.isDependentRefresh] - An optional flag indicating whether the refresh is dependent.
     * @param {boolean} [args.isRandomFormula] - An optional flag indicating whether the formula is random.
     * @param {boolean} [args.isDelete] - An optional flag indicating whether is from delete cells.
     * @param {number[]} [args.deletedRange] - An optional range array indicating the deleted cells.
     * @returns {void}
     * @private
     */
    refreshCalculate(args) {
        args.sheet = isNullOrUndefined(args.sheetIndex) ? this.parent.getActiveSheet() : getSheet(this.parent, args.sheetIndex);
        const sheetId = args.sheet.id + '';
        const family = this.calculateInstance.getSheetFamilyItem(sheetId);
        let cellRef = getColumnHeaderText(args.colIndex + 1) + (args.rowIndex + 1);
        if (family.isSheetMember && !isNullOrUndefined(family.parentObjectToToken)) {
            cellRef = family.parentObjectToToken.get(sheetId) + cellRef;
        }
        if (args.isFormula) {
            this.calculateFormula(args, cellRef);
        }
        else {
            if (this.calculateInstance.getFormulaInfoTable().has(cellRef)) {
                this.calculateInstance.getFormulaInfoTable().delete(cellRef);
                this.calculateInstance.clearFormulaDependentCells(cellRef);
            }
            this.calculateInstance.refresh(cellRef, null, null, null, args.isDelete, args.deletedRange);
            if (this.parent.calculationMode === 'Automatic') {
                this.calculateInstance.refreshRandValues(cellRef);
            }
        }
        this.calculateInstance.cell = '';
        args.isFormulaDependent = this.calculateInstance.getDependentCells().has(cellRef);
        if (args.value) {
            args.value = args.value.toString().split('^+').join('^').split('&+').join('&');
        }
    }
    calculateFormula(args, cellRef) {
        const sheet = args.sheet;
        this.autoCorrectFormula(args, sheet);
        let value = args.value;
        if (args.isClipboard && value.toUpperCase().includes('UNIQUE')) {
            setCell(args.rowIndex, args.colIndex, sheet, { value: '' }, true);
        }
        let formula = value;
        value = this.parseSheetRef(value);
        const cellArgs = new ValueChangedArgs(args.rowIndex + 1, args.colIndex + 1, value);
        const usedRange = [sheet.usedRange.rowIndex, sheet.usedRange.colIndex];
        this.calculateInstance.valueChanged(sheet.id.toString(), cellArgs, true, usedRange, args.isRefreshing, sheet.name, args.isRandomFormula, null, args.isDelete, args.deletedRange, args.isDependentRefresh, args.action);
        if (this.calculateInstance.isRandomVal === true && !args.isRandomFormula && this.parent.calculationMode === 'Automatic') {
            this.refreshRandomFormula();
        }
        const updatedCell = getCell(args.rowIndex, args.colIndex, sheet);
        if (updatedCell && formula && !args.isDependentRefresh) {
            formula = formula.toUpperCase();
            let formulaStr;
            if (formula.indexOf('=SUM(') === 0) {
                formulaStr = '=SUM(';
            }
            else if (formula.indexOf('=AVERAGE(') === 0) {
                formulaStr = '=AVERAGE(';
            }
            else if (formula.indexOf('=ROUNDDOWN(') === 0) {
                formulaStr = '=ROUNDDOWN(';
            }
            else if (formula.indexOf('=ROUNDUP(') === 0) {
                formulaStr = '=ROUNDUP(';
            }
            else if (formula.indexOf('=MOD(') === 0) {
                formulaStr = '=MOD(';
            }
            if (formulaStr) {
                formula = formula.replace(formulaStr, '');
                if (formula.includes(')')) {
                    formula = formula.slice(0, formula.lastIndexOf(')'));
                    let fStr;
                    let idx;
                    while (formula.includes('(') && formula.includes(')')) {
                        idx = formula.indexOf('(');
                        fStr = formula.slice(idx + 1);
                        formula = formula.slice(0, idx) + (fStr.includes(')') ? fStr.slice(fStr.indexOf(')') + 1) : fStr);
                    }
                }
                const cellRefArr = formula.split(this.calculateInstance.getParseArgumentSeparator());
                let cellRef;
                let fCell;
                let model;
                let sheetIdx;
                let sheetName;
                let index;
                for (let idx = 0; idx < cellRefArr.length; idx++) {
                    cellRef = cellRefArr[idx].split(':')[0];
                    if (cellRef.includes('!')) {
                        sheetName = cellRef.substring(0, cellRef.lastIndexOf('!')).split('\'').join('');
                        cellRef = cellRef.substring(cellRef.lastIndexOf('!') + 1);
                    }
                    else {
                        sheetName = '';
                    }
                    if (isCellReference(cellRef)) {
                        if (sheetName) {
                            sheetIdx = getSheetIndex(this.parent, sheetName);
                            model = sheetIdx !== undefined ? getSheet(this.parent, sheetIdx) : sheet;
                        }
                        else {
                            model = sheet;
                        }
                        index = getRangeIndexes(cellRef);
                        fCell = getCell(index[0], index[1], model);
                        const format = getTypeFromFormat(updatedCell.format);
                        const excludedFormats = ['Number', 'Currency', 'LongDate', 'Time'];
                        if (fCell && fCell.format && (!updatedCell.format || (!args.fillType &&
                            (excludedFormats.every((fmt) => format !== fmt) &&
                                getTypeFromFormat(fCell.format) !== 'Number')))) {
                            updatedCell.format = fCell.format;
                            break;
                        }
                    }
                }
            }
            else {
                const depCells = this.calculateInstance.getDependentFormulaCells().get(cellRef);
                if (depCells && depCells.size && this.calculateInstance.getFormulaInfoTable().has(cellRef) &&
                    this.calculateInstance.getFormulaInfoTable().get(cellRef).getParsedFormula().lastIndexOf('q') === -1 &&
                    !updatedCell.format) {
                    let format;
                    let fCell;
                    let sheetRef;
                    let model;
                    let sheetIdx;
                    let idx;
                    const family = this.calculateInstance.getSheetFamilyItem(null, this.calcID);
                    depCells.forEach((cellRef) => {
                        if (!format) {
                            sheetRef = cellRef.slice(0, cellRef.lastIndexOf('!') + 1);
                            cellRef = cellRef.replace(sheetRef, '');
                            if (isCellReference(cellRef)) {
                                idx = getRangeIndexes(cellRef);
                                if (family.tokenToParentObject.has(sheetRef)) {
                                    sheetIdx = getSheetIndexFromId(this.parent, Number(family.tokenToParentObject.get(sheetRef)));
                                    model = sheetIdx !== undefined ? getSheet(this.parent, sheetIdx) : sheet;
                                }
                                else {
                                    model = sheet;
                                }
                                fCell = getCell(idx[0], idx[1], model);
                                if (fCell && fCell.format) {
                                    format = fCell.format;
                                }
                            }
                        }
                    });
                    if (format) {
                        updatedCell.format = format;
                    }
                }
            }
        }
    }
    refreshRandomFormula() {
        let rowId;
        let colId;
        let refValue = '';
        const referenceCollection = this.calculateInstance.randCollection;
        if (this.calculateInstance.randomValues.size > 1 && this.calculateInstance.randomValues.size ===
            referenceCollection.length) {
            for (let i = 0; i < this.calculateInstance.randomValues.size; i++) {
                rowId = this.calculateInstance.rowIndex(referenceCollection[i]);
                colId = this.calculateInstance.colIndex(referenceCollection[i]);
                refValue = this.calculateInstance.randomValues.get(referenceCollection[i]);
                const sheetId = (parseFloat(this.calculateInstance.getSheetToken(referenceCollection[i]).split(this.calculateInstance.sheetToken).join('')) + 1).toString();
                const sheet = getSheet(this.parent, getSheetIndexFromId(this.parent, Number(sheetId)));
                if (sheet && getCell(rowId - 1, colId - 1, sheet).formula) {
                    const tempArgs = new ValueChangedArgs(rowId, colId, refValue);
                    this.calculateInstance.valueChanged(sheetId, tempArgs, true, undefined, undefined, undefined, false, true);
                }
            }
        }
    }
    autoCorrectFormula(args, sheet) {
        if (!isNullOrUndefined(args.value)) {
            let formula = args.value;
            formula = this.autoCorrectCellRef({ formula: args.value });
            formula = formula.toString();
            if (formula.split('(').length === 2 && formula.indexOf(')') < 0) {
                formula += ')';
            }
            let isEqual;
            if (formula.indexOf('=') === 0) {
                formula = formula.slice(1);
                isEqual = true;
            }
            const lessEq = formula.match(/</g);
            const greaterEq = formula.match(/>/g);
            const equal = formula.match(/=/g);
            if (lessEq) {
                let lessOp = '';
                for (let i = 0; i < lessEq.length; i++) {
                    lessOp = lessOp + lessEq[i];
                }
                formula = formula.replace(lessOp, '<');
            }
            if (greaterEq) {
                let greaterOp = '';
                for (let j = 0; j < greaterEq.length; j++) {
                    greaterOp = greaterOp + greaterEq[j];
                }
                formula = formula.replace(greaterOp, '>');
            }
            if (equal) {
                let equalOp = '';
                for (let c = 0; c < equal.length; c++) {
                    equalOp = equalOp + equal[c];
                }
                formula = formula.split(equalOp).join('=');
            }
            formula = isEqual ? '=' + formula : formula;
            if (lessEq || greaterEq || equal) {
                getCell(args.rowIndex, args.colIndex, sheet).formula = formula;
            }
            args.value = formula;
        }
    }
    correctCellReference(cellRef) {
        const cellRefArr = cellRef.split(':');
        let refArr;
        let sheetRefArr;
        let oprMatchArr;
        let isInvalid;
        let updatedRef;
        cellRefArr.forEach((cellAddr, idx) => {
            sheetRefArr = cellAddr.split('!');
            cellRef = sheetRefArr[1] || cellAddr;
            updatedRef = null;
            if (cellRef.includes('&')) {
                refArr = cellRef.split('&');
                if (this.calculateInstance.isCellReference(refArr[1].split('$').join(''))) {
                    refArr[1] = this.getUpdatedCellRef(refArr[1]);
                    updatedRef = refArr.join('&');
                }
            }
            else if (this.calculateInstance.isCellReference(cellRef.split('$').join(''))) {
                updatedRef = this.getUpdatedCellRef(cellRef);
                if (sheetRefArr.length > 1) {
                    updatedRef = sheetRefArr[0] + '!' + updatedRef;
                }
            }
            else {
                oprMatchArr = cellAddr.match(/[/+\-*^><>=<=<>]+/g);
                if (oprMatchArr) {
                    refArr = cellAddr.split(oprMatchArr[0]);
                    for (let refIdx = 0; refIdx < refArr.length; refIdx++) {
                        sheetRefArr = refArr[refIdx].split('!');
                        cellRef = sheetRefArr[1] || sheetRefArr[0];
                        if (this.calculateInstance.isCellReference(cellRef.split('$').join(''))) {
                            refArr[refIdx] = this.getUpdatedCellRef(cellRef);
                            if (sheetRefArr.length > 1) {
                                refArr[refIdx] = sheetRefArr[0] + '!' + refArr[refIdx];
                            }
                        }
                    }
                    updatedRef = refArr.join(oprMatchArr[0]);
                }
            }
            if (updatedRef && updatedRef !== cellAddr) {
                isInvalid = true;
                cellRefArr[idx] = updatedRef;
            }
        });
        return { isInvalid: isInvalid, ref: cellRefArr.join(':') };
    }
    autoCorrectCellRef(args) {
        const rightParens = args.formula.lastIndexOf(')');
        let refCorrectObj;
        if (rightParens > -1 && args.formula.split(')').length === 2) {
            let leftParens = rightParens - 1;
            while (leftParens > -1 && args.formula[leftParens] !== '(') {
                if (args.formula[leftParens] === ')') {
                    return args.formula;
                }
                leftParens--;
            }
            if (leftParens > -1) {
                const formulaArgs = args.formula.substring(leftParens + 1, rightParens);
                const listSeparator = this.calculateInstance.getParseArgumentSeparator();
                const formulaArgsArr = formulaArgs.split(listSeparator);
                let isInValidRef;
                for (let argsIdx = 0; argsIdx < formulaArgsArr.length; argsIdx++) {
                    refCorrectObj = this.correctCellReference(formulaArgsArr[argsIdx]);
                    if (refCorrectObj.isInvalid) {
                        isInValidRef = true;
                        formulaArgsArr[argsIdx] = refCorrectObj.ref;
                    }
                }
                if (isInValidRef) {
                    args.formula = args.formula.split(formulaArgs).join(formulaArgsArr.join(listSeparator));
                    args.isInvalid = true;
                }
            }
        }
        else if (args.formula.startsWith('=') && !args.formula.includes(')')) {
            refCorrectObj = this.correctCellReference(args.formula.substring(1, args.formula.length));
            if (refCorrectObj.isInvalid) {
                args.formula = '=' + refCorrectObj.ref;
                args.isInvalid = true;
            }
        }
        return args.formula;
    }
    getUpdatedCellRef(cellRef) {
        const orgCellRef = cellRef;
        cellRef = cellRef.trim();
        const isAbsolute = cellRef.indexOf('$') === 0;
        let alphabetStartIdx = cellRef.search(/[a-zA-Z]/);
        const digitStartIdx = cellRef.search(/\d/);
        alphabetStartIdx = isAbsolute ? alphabetStartIdx - 1 : alphabetStartIdx;
        if ((isAbsolute ? digitStartIdx > 1 : digitStartIdx > 0) && isNumber(cellRef.substring(digitStartIdx, cellRef.length))) {
            return orgCellRef;
        }
        else {
            return cellRef.substring(alphabetStartIdx, cellRef.length) + cellRef.substring(0, alphabetStartIdx);
        }
    }
    initiateDefinedNames() {
        const definedNames = this.parent.definedNames;
        let i = 0;
        while (i < definedNames.length) {
            const definedname = definedNames[i];
            const refersTo = this.parseSheetRef(definedname.refersTo);
            let range = getRangeFromAddress(refersTo);
            let cellRef = false;
            const isLink = refersTo.indexOf('http:') > -1 ? true : (refersTo.indexOf('https:') > -1 ? true : false);
            range = range.split('$').join('');
            range = range.split('=').join('');
            if (range.indexOf(':') > -1) {
                const rangeSplit = range.split(':');
                if ((isCellReference(rangeSplit[0]) && isCellReference(rangeSplit[1])) ||
                    ((rangeSplit[0].match(/[0-9]/) && rangeSplit[1].match(/[0-9]/)) ||
                        (rangeSplit[0].toUpperCase().match(/[A-Z]/) && rangeSplit[1].toUpperCase().match(/[A-Z]/)))) {
                    cellRef = true;
                }
            }
            else if (range.indexOf(':') < 0) {
                if (isCellReference(range)) {
                    cellRef = true;
                }
            }
            if (isLink) {
                cellRef = false;
            }
            if (cellRef) {
                this.addDefinedName(definedname, true, undefined, true);
            }
            else {
                this.removeDefinedName(definedname.name, definedname.scope, true);
                i--;
            }
            i++;
        }
    }
    /**
     * @hidden
     * Used to add defined name to workbook.
     *
     * @param {DefineNameModel} definedName - Define named range.
     * @param {boolean} isValidate - Specify the boolean value.
     * @param {number} index - Define named index.
     * @param {boolean} isEventTrigger - Specify the boolean value.
     * @returns {boolean} - Used to add defined name to workbook.
     */
    addDefinedName(definedName, isValidate, index, isEventTrigger) {
        if (index === undefined || index < -1) {
            index = this.parent.definedNames.length;
        }
        let isAdded = true;
        let sheetIdx;
        let name = definedName.name;
        if (definedName.refersTo.indexOf('!') < 0) {
            let sheetName = getSheetName(this.parent);
            sheetName = sheetName.indexOf(' ') !== -1 ? '\'' + sheetName + '\'' : sheetName;
            definedName.refersTo = sheetName + '!' + ((definedName.refersTo.indexOf('=') < 0) ?
                definedName.refersTo : definedName.refersTo.split('=')[1]);
        }
        const visibleRefersTo = definedName.refersTo;
        const refersTo = this.parseSheetRef(definedName.refersTo);
        if (definedName.scope) {
            sheetIdx = getSheetIndex(this.parent, definedName.scope);
            if (sheetIdx > -1) {
                name = getSheetName(this.parent, sheetIdx) + '!' + name;
            }
        }
        else {
            definedName.scope = 'Workbook';
        }
        if (!definedName.comment) {
            definedName.comment = '';
        }
        //need to extend once internal sheet value changes done.
        if (!isValidate && this.checkIsNameExist(definedName.name, definedName.scope)) {
            isAdded = false;
        }
        else {
            this.calculateInstance.addNamedRange(name, refersTo[0] === '=' ? refersTo.substr(1) : refersTo);
            if (refersTo[0] !== '=') {
                definedName.refersTo = '=' + visibleRefersTo;
            }
            if (this.parent.definedNames.indexOf(definedName) < 0) {
                this.parent.definedNames.splice(index, 0, definedName);
                this.parent.notify(formulaBarOperation, { action: 'setNameBoxValue', definedName: definedName });
            }
        }
        const eventArgs = { name: definedName.name, scope: definedName.scope, comment: definedName.comment,
            refersTo: definedName.refersTo, cancel: false };
        if (!isEventTrigger) {
            this.parent.notify('actionComplete', { eventArgs: eventArgs, action: 'addDefinedName' });
        }
        return isAdded;
    }
    /**
     * @hidden
     * Used to remove defined name from workbook.
     *
     * @param {string} name - Specifies the defined name.
     * @param {string} scope - Specifies the scope of the define name.
     * @param {boolean} isEventTrigger - Specify the boolean value.
     * @returns {boolean} - To Return the bool value.
     */
    removeDefinedName(name, scope, isEventTrigger) {
        let isRemoved = false;
        const scopeVal = !scope ? 'Workbook' : scope;
        const index = this.getIndexFromNameColl(name, scopeVal);
        if (index > -1) {
            let calcName = name;
            if (scope) {
                const sheetIdx = getSheetIndex(this.parent, scope);
                if (sheetIdx > -1) {
                    calcName = getSheetName(this.parent, sheetIdx) + '!' + name;
                }
            }
            this.calculateInstance.removeNamedRange(calcName);
            const removedName = this.parent.definedNames.splice(index, 1);
            this.parent.notify(formulaBarOperation, { action: 'setNameBoxValue', definedName: removedName[0], isRemove: true });
            if (!isEventTrigger) {
                const eventArgs = { name: name, scope: scopeVal, cancel: false };
                this.parent.notify('actionComplete', { eventArgs: eventArgs, action: 'removeDefinedName' });
            }
            isRemoved = true;
        }
        return isRemoved;
    }
    checkIsNameExist(name, sheetName) {
        const isExist = this.parent.definedNames.some((key) => {
            return key.name === name && (sheetName ? key.scope === sheetName : key.scope === '');
        });
        return isExist;
    }
    getIndexFromNameColl(definedName, scope = '') {
        let index = -1;
        this.parent.definedNames.filter((name, idx) => {
            if (name.name === definedName && name.scope === scope) {
                index = idx;
            }
        });
        return index;
    }
    calculateNow(args) {
        const deferred = new Deferred();
        args.promise = deferred.promise;
        let dependentCells;
        const initCalculate = () => {
            let family;
            let token;
            let sheetId;
            let cellRef;
            const options = { isRefreshing: true, action: 'calculate' };
            const formulaInfo = this.calculateInstance.getFormulaInfoTable();
            args.sheets.forEach((sheet) => {
                sheetId = sheet.id.toString();
                family = this.calculateInstance.getSheetFamilyItem(sheetId);
                token = family.isSheetMember ? family.parentObjectToToken.get(sheetId) : '';
                this.parent.setSheetPropertyOnMute(sheet, 'isSheetCalculated', true);
                options.sheet = sheet;
                sheet.rows.forEach((row, rowIdx) => {
                    options.rowIndex = rowIdx;
                    if (row && row.cells) {
                        row.cells.forEach((cell, colIdx) => {
                            if (cell && checkIsFormula(cell.formula)) {
                                cellRef = token + getColumnHeaderText(colIdx + 1) + (rowIdx + 1);
                                if (cell.value === undefined || cell.value === null || !formulaInfo.has(cellRef) || (dependentCells &&
                                    dependentCells[cellRef])) {
                                    options.colIndex = colIdx;
                                    options.value = cell.formula;
                                    this.calculateFormula(options, cellRef);
                                }
                            }
                        });
                    }
                });
            });
            deferred.resolve();
            this.calculateInstance.cell = '';
        };
        let totalLoadCount = args.sheets.length;
        const loadCompleteHandler = () => {
            totalLoadCount--;
            if (!totalLoadCount) {
                initCalculate();
                if (this.parent.calculationMode === 'Automatic' && args.scope === 'CalculateWorkbook') {
                    this.parent.setProperties({ calculationMode: 'Manual' }, true);
                }
                const sheet = this.parent.getActiveSheet();
                if (sheet.conditionalFormats && sheet.conditionalFormats.length) {
                    this.parent.notify(applyCF, { indexes: [], isAction: true, refreshAll: true, isEdit: true });
                }
            }
        };
        const getDependentCellsCheckFn = (sheet) => {
            const sheetId = sheet.id.toString();
            const family = this.calculateInstance.getSheetFamilyItem(sheetId);
            const token = family.isSheetMember ? family.parentObjectToToken.get(sheetId) : '';
            dependentCells = {};
            const dependentCellsInfo = this.calculateInstance.getDependentCells();
            return (rowIdx, colIdx) => {
                const cellAddr = token + getCellAddress(rowIdx, colIdx);
                if (dependentCellsInfo.has(cellAddr)) {
                    dependentCellsInfo.get(cellAddr).forEach((cellRef) => {
                        if (!dependentCells[cellRef]) {
                            dependentCells[cellRef] = true;
                        }
                    });
                }
            };
        };
        args.sheets.forEach((sheet) => {
            if (sheet.ranges.some((range) => range.dataSource && (!range.info || !range.info.loadedRange ||
                !range.info.loadedRange.length))) {
                this.parent.notify(updateSheetFromDataSource, { sheet: sheet, autoDetectFormat: true, loadFromStartCell: true,
                    updateDependentCellsCallback: getDependentCellsCheckFn(sheet), loadComplete: loadCompleteHandler });
            }
            else {
                loadCompleteHandler();
            }
        });
    }
    toFixed(value) {
        const num = Number(value);
        if (Math.round(num) !== num) {
            value = num.toFixed(2);
        }
        return value;
    }
    commputeFormulaValue(args) {
        const parsedSheetValue = this.parseSheetRef(args.value);
        args.value = this.calculateInstance.computeExpression(parsedSheetValue).toString();
    }
    getCellRefValue(args) {
        let sheetId;
        const sheetInfo = this.getSheetInfo();
        const sheetCount = sheetInfo.length;
        const token = this.calculateInstance.sheetToken;
        const value = args.value;
        const tokenIndex = value.lastIndexOf(token);
        if (tokenIndex !== -1) {
            let sheetName = value.substring(0, tokenIndex);
            if (sheetName.length > 0 && sheetName[0] === this.calculateInstance.getFormulaCharacter()) {
                sheetName = sheetName.substring(1, args.value.length); // To get the sheetname without '=' symbol
            }
            for (let i = 0; i < sheetCount; i++) {
                if (sheetName.toUpperCase() === sheetInfo[i].visibleName.toUpperCase()) {
                    sheetId = i;
                    break;
                }
            }
            args.value = this.calculateInstance.getValueFromArg(token + sheetId + token + value.substring(tokenIndex + 1).toUpperCase());
        }
        else if (value.length > 0 && value[0] === this.calculateInstance.getFormulaCharacter()) {
            args.value = this.calculateInstance.getValueFromArg(value.substring(1, args.value.length).toUpperCase());
        }
    }
    aggregateComputation(args) {
        const sheet = this.parent.getActiveSheet();
        let range = getSingleSelectedRange(sheet);
        const indexes = getRangeIndexes(range.split(':')[1]);
        if (indexes[0] + 1 === sheet.rowCount && indexes[1] + 1 === sheet.colCount) {
            range = `A1:${getCellAddress(sheet.usedRange.rowIndex, sheet.usedRange.colIndex)}`;
        }
        let calcValue;
        let i;
        const cellCol = this.calculateInstance.getCellCollection(range);
        for (i = 0; i < cellCol.length; i++) {
            calcValue = this.calculateInstance.getValueFromArg(cellCol[i]);
            if (isNumber(calcValue)) {
                args.countOnly = false;
                break;
            }
        }
        args.Count = this.calculateInstance.getFunction('COUNTA')(range, 'isAggregate');
        if (!args.Count || args.countOnly) {
            return;
        }
        const formulaVal = ['SUM', 'AVERAGE', 'MIN', 'MAX'];
        const formatedValues = [];
        const index = getRangeIndexes(sheet.activeCell);
        const cell = getCell(index[0], index[1], sheet, false, true);
        for (i = 0; i < 4; i++) {
            calcValue = this.toFixed(this.calculateInstance.getFunction(formulaVal[i])(range, 'isAggregate'));
            if (cell.format) {
                const eventArgs = { formattedText: calcValue, value: calcValue, format: cell.format,
                    cell: { value: calcValue, format: cell.format } };
                this.parent.notify(getFormattedCellObject, eventArgs);
                calcValue = eventArgs.formattedText;
            }
            formatedValues.push(calcValue);
        }
        args.Sum = formatedValues[0];
        args.Avg = formatedValues[1];
        args.Min = formatedValues[2];
        args.Max = formatedValues[3];
    }
    refreshInsertDelete(args) {
        if (args.modelType === 'Sheet') {
            return;
        }
        const formulaDependentCells = this.calculateInstance.getDependentFormulaCells();
        let cell;
        const sheetIndex = getSheetIndexFromId(this.parent, args.sheet.id);
        this.parent.sheets.forEach((sheet, index) => {
            for (let i = 0, rowLen = sheet.usedRange.rowIndex; i <= rowLen; i++) {
                for (let j = 0, colLen = sheet.usedRange.colIndex; j <= colLen; j++) {
                    cell = getCell(i, j, sheet, false, true);
                    if (cell.formula && checkIsFormula(cell.formula)) {
                        if (index === sheetIndex) {
                            if (args.isInsert || !(args.modelType === 'Row' ? i >= args.startIndex && i <= args.endIndex :
                                j >= args.startIndex && j <= args.endIndex)) {
                                this.updateFormula(args, cell, i, j, sheetIndex);
                            }
                        }
                        else if (cell.formula.includes(args.sheet.name)) {
                            this.updateFormula(args, cell, i, j, sheetIndex, true, sheet);
                        }
                    }
                }
            }
        });
        formulaDependentCells.clear();
        this.calculateInstance.getDependentCells().clear();
        this.calculateInstance.getFormulaInfoTable().clear();
        this.refreshNamedRange(args);
    }
    getUpdatedFormulaOnInsertDelete(args) {
        if (args.sheetNames) {
            if (!args.updateSheetRef) {
                args.updateSheetRef = this.getSheetRefUpdateOnDelete();
            }
            const previousFormula = this.parseSheetRef(args.cell.formula, false);
            let formula = previousFormula;
            args.sheetNames.forEach((sheetName) => {
                formula = args.updateSheetRef(sheetName, formula).value;
            });
            if (formula !== previousFormula) {
                args.cell.formula = formula;
            }
        }
        else {
            this.updateFormula(args.insertDeleteArgs, args.cell, args.row, args.col, args.sheetIdx, args.otherSheet, args.formulaSheet);
        }
    }
    updateFormula(args, cell, row, col, sheetIdx, otherSheet, formulaSheet) {
        let ref;
        let pVal;
        let index;
        let updated;
        let isRangeFormula;
        const containAlphabetAndDigit = new RegExp(/^(?=.*[a-zA-Z])(?=.*\d)/g);
        let isValidCellReference;
        let isFullColumn;
        if (cell.formula && cell.formula.includes('UNIQUE') && row !== undefined) {
            this.clearUniqueRange(row, col, formulaSheet || args.sheet);
        }
        const getAddress = () => {
            let range = (isAbsoluteRef ? '$' : '') + getColumnHeaderText(index[1] + 1) + (isAbsoluteRef ? '$' : '') + (index[0] + 1);
            if (index[0] !== index[2] || index[1] !== index[3]) {
                range += ':' + (isAbsoluteRef ? '$' : '') + getColumnHeaderText(index[3] + 1) + (isAbsoluteRef ? '$' : '') + (index[2] + 1);
            }
            return range;
        };
        const formulaArr = this.parseFormulaArgument({ formula: this.parseSheetRef(cell.formula, true), rangeRef: true });
        const sheetInfo = this.getSheetInfo();
        let sheetName;
        let refChanged;
        let isAbsoluteRef;
        const isSingleRangeRef = !cell.formula.includes(this.parent.listSeparator);
        for (let i = 0; i < formulaArr.length; i++) {
            ref = formulaArr[i].trim();
            isAbsoluteRef = ref.includes('$');
            if (isAbsoluteRef) {
                ref = ref.replace(/[$]/g, '');
            }
            isValidCellReference = true;
            if (this.calculateInstance.isCellReference(ref)) {
                isRangeFormula = ref.includes(':');
                pVal = i && formulaArr[i - 1].trim();
                if (pVal && pVal[pVal.length - 1] === '!') {
                    pVal = pVal.replace(/['!]/g, '');
                    sheetName = sheetInfo[sheetIdx].sheet === sheetInfo[sheetIdx].visibleName ? args.sheet.name :
                        '`' + sheetInfo[sheetIdx].sheet + '`';
                    if (pVal !== sheetName) {
                        continue;
                    }
                }
                else if (otherSheet) {
                    continue;
                }
                if (!containAlphabetAndDigit.test(ref) && ref.indexOf(':') > -1) {
                    isValidCellReference = false;
                    isFullColumn = isNullOrUndefined(ref.match(/[0-9]/)) ? true : false;
                }
                index = getSwapRange(getRangeIndexes(ref));
                updated = this.parent.updateRangeOnInsertDelete(args, index, isRangeFormula, row, col, isAbsoluteRef, isSingleRangeRef);
                if (updated) {
                    formulaArr[i] = index[2] < index[0] || index[3] < index[1] ?
                        this.calculateInstance.getErrorStrings()[CommonErrors.Ref] : !isValidCellReference ?
                        (isFullColumn ? getRangeAddress(index).replace(/\d/g, '') : getRangeAddress(index).replace(/[a-zA-Z]/g, '')) : getAddress();
                    refChanged = true;
                }
            }
        }
        let newFormula = '=' + formulaArr.join('');
        if (refChanged) {
            let regx;
            const regExp = RegExp;
            sheetInfo.forEach((info) => {
                if (newFormula.includes('`' + info.sheet + '`')) {
                    regx = new regExp('`' + info.sheet + '`', 'gi');
                    newFormula = newFormula.replace(regx, info.visibleName);
                }
            });
            if (cell.formula !== newFormula) {
                cell.formula = newFormula;
                if (!(this.parent.calculationMode === 'Manual' && (args.isInsert || args.isDelete))) {
                    cell.value = null;
                }
            }
        }
    }
    clearUniqueRange(row, col, sheet) {
        const uniqueArgs = { cellIdx: [row, col, row, col], isUnique: false, uniqueRange: '', sheetName: sheet.name };
        this.parent.notify(checkUniqueRange, uniqueArgs);
        const range = getRangeIndexes(uniqueArgs.uniqueRange);
        for (let i = range[0]; i <= range[2]; i++) {
            for (let j = range[1]; j <= range[3]; j++) {
                delete getCell(i, j, sheet, false, true).value;
            }
        }
    }
    clearAllUniqueFormulaValue() {
        const ranges = this.calculateInstance.uniqueRange;
        let cell;
        let sheet;
        let range;
        for (let i = 0; i < ranges.length; i++) {
            const lastIndex = ranges[i].lastIndexOf('!');
            sheet = getSheet(this.parent, getSheetIndex(this.parent, ranges[i].substring(0, lastIndex)));
            range = getRangeIndexes(ranges[i].substring(lastIndex + 1));
            cell = getCell(range[0], range[1], sheet);
            if (cell && cell.value === '#SPILL!') {
                continue;
            }
            for (let j = range[0]; j <= range[2]; j++) {
                for (let k = range[1]; k <= range[3]; k++) {
                    cell = getCell(j, k, sheet);
                    if (cell && cell.value) {
                        delete cell.value;
                    }
                }
            }
        }
    }
    parseFormulaArgument(args) {
        let temp;
        let str;
        let i = 0;
        const arr = [];
        let formulaVal = this.markSpecialChar(args.formula.replace('=', ''), args.rangeRef);
        const regExp = RegExp;
        const validCharRegx = new regExp(args.rangeRef ? /\(|\)|=|\^|>|<|\+|-|\*|\/|%|&/g : /\(|\)|=|\^|>|<|:|\+|-|\*|\/|%|&/g);
        const sepRegx = new regExp(this.parent.listSeparator, 'g');
        formulaVal = formulaVal.split(new regExp(validCharRegx.source + '|' + sepRegx.source, 'g'));
        const len = formulaVal.length;
        while (i < len) {
            temp = formulaVal[i];
            if (!temp) {
                i++;
                continue;
            }
            if (temp.length === 1) {
                arr.push(this.isUniqueChar(temp) ? this.getUniqueCharVal(temp) : temp);
            }
            else {
                str = temp[0];
                if (temp.indexOf('!') > 0) {
                    if (this.isUniqueChar(str)) {
                        arr.push(this.getUniqueCharVal(str));
                        temp = temp.substr(1);
                    }
                    str = temp.indexOf('!') + 1;
                    arr.push(temp.substring(0, str));
                    temp = temp.substring(str);
                    str = temp.indexOf(':');
                    if (str > -1 && temp.indexOf('!') > str) {
                        arr.push(temp.substring(0, str));
                        arr.push(':');
                        temp = temp.substring(str + 1);
                        str = temp.indexOf('!') + 1;
                        arr.push(temp.substring(0, str));
                        arr.push(temp.substring(str));
                    }
                    else {
                        arr.push(temp);
                    }
                }
                else if (this.isUniqueChar(str)) {
                    arr.push(this.getUniqueCharVal(str));
                    arr.push(temp.substr(1));
                }
                else {
                    arr.push(temp);
                }
            }
            i++;
        }
        args.formulaArr = arr;
        return arr;
    }
    getUniqueCharVal(formula) {
        switch (formula) {
            case this.uniqueOBracket:
                return '(';
            case this.uniqueCBracket:
                return ')';
            case this.uniqueCSeparator:
                return this.parent.listSeparator;
            case this.uniqueCOperator:
                return ':';
            case this.uniquePOperator:
                return '+';
            case this.uniqueSOperator:
                return '-';
            case this.uniqueMOperator:
                return '*';
            case this.uniqueDOperator:
                return '/';
            case this.uniqueModOperator:
                return '%';
            case this.uniqueConcateOperator:
                return '&';
            case this.uniqueEqualOperator:
                return '=';
            case this.uniqueExpOperator:
                return '^';
            case this.uniqueGTOperator:
                return '>';
            case this.uniqueLTOperator:
                return '<';
        }
        return '';
    }
    isUniqueChar(formula) {
        const code = formula.charCodeAt(formula);
        return code >= 129 && code <= 142;
    }
    markSpecialChar(formula, rangeRef) {
        formula = formula.replace(/\(/g, '(' + this.uniqueOBracket).replace(/\)/g, ')' + this.uniqueCBracket);
        const regEx = RegExp;
        if (rangeRef) {
            formula = formula.replace(new regEx(this.parent.listSeparator, 'g'), this.parent.listSeparator + this.uniqueCSeparator);
        }
        else {
            formula = formula.replace(new regEx(this.parent.listSeparator, 'g'), this.parent.listSeparator + this.uniqueCSeparator).replace(/:/g, `:${this.uniqueCOperator}`);
        }
        formula = formula.replace(/\+/g, '+' + this.uniquePOperator).replace(/-/g, '-' + this.uniqueSOperator);
        formula = formula.replace(/\*/g, '*' + this.uniqueMOperator).replace(/\//g, '/' + this.uniqueDOperator);
        formula = formula.replace(/&/g, '&' + this.uniqueConcateOperator);
        formula = formula.replace(/=/g, '=' + this.uniqueEqualOperator);
        formula = formula.replace(/\^/g, '^' + this.uniqueExpOperator);
        formula = formula.replace(/>/g, '>' + this.uniqueGTOperator).replace(/</g, '<' + this.uniqueLTOperator);
        return formula.replace(/%/g, '%' + this.uniqueModOperator);
    }
    refreshNamedRange(args) {
        if (args.definedNames && args.definedNames.length) {
            args.definedNames.forEach((definedName) => {
                this.parent.removeDefinedName(definedName.name, definedName.scope);
                this.parent.addDefinedName(definedName);
            });
            return;
        }
        const len = this.parent.definedNames.length;
        if (!len) {
            return;
        }
        const definedNames = Object.assign({}, this.parent.definedNames);
        let range;
        let sheetName;
        let refAddress;
        let definedName;
        let updated;
        let checkSheetName;
        let rangeAddress;
        const containAlphabetAndDigit = new RegExp(/^(?=.*[a-zA-Z])(?=.*\d)/g);
        let isValidCellReference;
        let isFullColumn;
        for (let i = 0; i < len; i++) {
            isValidCellReference = true;
            definedName = definedNames[i];
            const lastIndex = definedName.refersTo.lastIndexOf('!');
            refAddress = definedName.refersTo.substring(lastIndex + 1);
            sheetName = definedName.refersTo.substring(1, lastIndex);
            checkSheetName = sheetName;
            if (checkSheetName.match(/'/g)) {
                checkSheetName = checkSheetName.slice(1, -1);
            }
            if (checkSheetName !== args.sheet.name) {
                continue;
            }
            if (!containAlphabetAndDigit.test(refAddress) && refAddress.indexOf(':') > -1) {
                isValidCellReference = false;
                isFullColumn = isNullOrUndefined(refAddress.match(/[0-9]/)) ? true : false;
            }
            range = getRangeIndexes(refAddress);
            updated = this.parent.updateRangeOnInsertDelete(args, range);
            if (!isValidCellReference) {
                rangeAddress = isFullColumn ? getRangeAddress(range).replace(/\d/g, '') : getRangeAddress(range).replace(/[a-zA-Z]/g, '');
            }
            else {
                rangeAddress = getRangeAddress(range);
            }
            if (args.isInsert) {
                this.updateDefinedNames(definedName, sheetName, rangeAddress, updated);
            }
            else {
                if (args.modelType === 'Row') {
                    this.updateDefinedNames(definedName, sheetName, rangeAddress, updated, [range[0], range[2]], args);
                }
                else if (args.modelType === 'Column') {
                    this.updateDefinedNames(definedName, sheetName, rangeAddress, updated, [range[1], range[3]], args);
                }
            }
        }
    }
    updateDefinedNames(definedName, sheetName, rangeAddress, changed, idx, args) {
        if (!changed) {
            return;
        }
        const index = this.parent.definedNames.indexOf(definedName);
        const eventArgs = {
            action: 'removeDefinedName',
            isRemoved: false,
            definedName: definedName.name,
            scope: definedName.scope,
            isEventTrigger: true
        };
        this.parent.notify(workbookFormulaOperation, eventArgs);
        if (idx) {
            let oldDefinedName = { name: definedName.name, comment: definedName.comment, refersTo: definedName.refersTo,
                scope: definedName.scope };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            oldDefinedName = new DefineName(this.parent, 'definedNames', oldDefinedName, true);
            if (args.definedNames) {
                args.definedNames.push(oldDefinedName);
            }
            else {
                args.definedNames = [oldDefinedName];
            }
            if (idx[1] < idx[0]) {
                return;
            }
        }
        definedName.refersTo = sheetName + '!' + rangeAddress;
        this.parent.notify(workbookFormulaOperation, { action: 'addDefinedName', definedName: definedName, isAdded: false, index: index, isEventTrigger: true });
        const refreshArgs = { name: definedName.name, scope: definedName.scope, comment: definedName.comment,
            refersTo: definedName.refersTo, cancel: false };
        this.parent.notify('actionComplete', { eventArgs: refreshArgs, action: 'refreshNamedRange' });
    }
}

/**
 * Specifies number format.
 */
class WorkbookNumberFormat {
    constructor(parent) {
        this.parent = parent;
        this.localeObj = getNumericObject(this.parent.locale);
        const dependables = IntlBase.getDependables(cldrData, this.parent.locale, null).dateObject;
        if (dependables.dayPeriods && dependables.dayPeriods && dependables.dayPeriods.format && dependables.dayPeriods.format.wide) {
            this.localeObj.am = dependables.dayPeriods.format.wide.am || 'AM';
            this.localeObj.pm = dependables.dayPeriods.format.wide.pm || 'PM';
        }
        else {
            this.localeObj.am = 'AM';
            this.localeObj.pm = 'PM';
        }
        this.updateLocalizedFormats(dependables);
        this.addEventListener();
    }
    numberFormatting(args) {
        let sheetIdx = this.parent.activeSheetIndex;
        let activeSheet = true;
        if (args.range && args.range.indexOf('!') > -1) {
            sheetIdx = getSheetIndex(this.parent, args.range.substring(0, args.range.lastIndexOf('!')));
            activeSheet = sheetIdx === this.parent.activeSheetIndex;
        }
        const sheet = getSheet(this.parent, sheetIdx);
        const formatRange = args.range ? ((args.range.lastIndexOf('!') > -1) ?
            args.range.substring(args.range.lastIndexOf('!') + 1) : args.range) : sheet.selectedRange;
        const selectedRange = getSwapRange(getRangeIndexes(formatRange));
        args.curSym = getNumberDependable(this.parent.locale, defaultCurrencyCode);
        let fArgs;
        let cell;
        let prevFormat;
        let row;
        let isVisibleRow;
        for (let rowIdx = selectedRange[0]; rowIdx <= selectedRange[2]; rowIdx++) {
            row = getRow(sheet, rowIdx);
            isVisibleRow = activeSheet && !isHiddenRow(sheet, rowIdx);
            for (let colIdx = selectedRange[1]; colIdx <= selectedRange[3]; colIdx++) {
                cell = getCell(rowIdx, colIdx, sheet, false, true);
                prevFormat = cell.format;
                if (!isReadOnly(cell, sheet.columns[colIdx], row) &&
                    !updateCell(this.parent, sheet, { cell: { format: args.format }, rowIdx: rowIdx, colIdx: colIdx })) {
                    cell = getCell(rowIdx, colIdx, sheet);
                    if (!(cell.rowSpan < 0 || cell.colSpan < 0)) {
                        fArgs = { value: cell.value, format: cell.format, rowIndex: rowIdx, colIndex: colIdx, sheetIndex: sheetIdx,
                            cell: cell, refresh: activeSheet, curSymbol: args.curSym };
                        this.getFormattedCell(fArgs);
                        if (isVisibleRow) {
                            this.setCell(fArgs);
                            if (fArgs.td) {
                                this.parent.notify(refreshCellElement, fArgs);
                                if (cell.wrap && (!row || !row.customHeight) && prevFormat !== args.format) {
                                    this.parent.notify(wrapEvent, { range: [rowIdx, colIdx, rowIdx, colIdx], wrap: true, sheet: sheet, initial: true,
                                        td: fArgs.td, isOtherAction: true });
                                }
                            }
                            if (prevFormat && prevFormat !== args.format && prevFormat.includes('[') &&
                                getCustomColors().indexOf(getColorCode(args.format)) === -1) {
                                this.removeFormatColor(fArgs, { format: prevFormat, style: cell.style });
                            }
                        }
                    }
                    this.parent.setUsedRange(rowIdx, colIdx);
                }
            }
        }
        if (sheet.conditionalFormats && sheet.conditionalFormats.length) {
            this.parent.notify(applyCF, { indexes: selectedRange, isAction: true, isEdit: true });
        }
        if (this.parent.chartColl && this.parent.chartColl.length) {
            this.parent.notify(refreshChart, { range: selectedRange });
        }
    }
    isDigitPlaceHolder(char) {
        return char === '#' || char === '0' || char === '?' || char === '.';
    }
    parseToLocalizedFormat(args) {
        if (args.decimalGroupSepsChanged && (args.format.includes('.') || args.format.includes(','))) {
            let formatChar;
            let endPos;
            let prevChar;
            const formatChars = args.format.split('');
            for (let idx = 0; idx < formatChars.length; idx++) {
                formatChar = formatChars[idx];
                if (formatChar === '"') {
                    endPos = args.format.indexOf('"', idx + 1);
                    if (endPos > -1) {
                        idx = endPos;
                    }
                }
                else if (formatChar === '_' || formatChar === '*' || formatChar === '\\') {
                    idx++;
                }
                else if (formatChar === '[') {
                    endPos = args.format.indexOf(']', idx + 1);
                    if (endPos > -1) {
                        idx = endPos;
                    }
                }
                else if (formatChar === ',') {
                    if (this.isDigitPlaceHolder(formatChars[idx - 1])) {
                        formatChars[idx] = this.localeObj.group;
                    }
                }
                else if (formatChar === '.') {
                    if (formatChars[idx - 1]) {
                        prevChar = formatChars[idx - 1].toLowerCase();
                        if (!['d', 'm', 'y', 'h'].some((char) => prevChar === char)) {
                            formatChars[idx] = this.localeObj.decimal;
                        }
                    }
                    else {
                        formatChars[idx] = this.localeObj.decimal;
                    }
                }
            }
            args.format = formatChars.join('');
        }
        if (args.curChanged && args.format.includes(`"${args.curSym}"`)) {
            args.format = args.format.split(`"${args.curSym}"`).join(args.curSym);
        }
    }
    updateLocalizedFormats(dependables, isFormatMapping) {
        numberFormatsCode = {
            currency: ['$#,##0.00', '$#,##0', '$#,##0_);($#,##0)', '$#,##0_);[Red]($#,##0)', '$#,##0.00_);($#,##0.00)',
                '$#,##0.00_);[Red]($#,##0.00)'],
            accounting: ['_($* #,##0_);_($* (#,##0);_($* "-"_);_(@_)', '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
                '_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)', '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)'],
            time: dependables.timeFormats && dependables.timeFormats.medium === 'HH:mm:ss' ? 'HH:mm:ss' : 'h:mm:ss AM/PM'
        };
        const curSym = getNumberDependable(this.parent.locale, defaultCurrencyCode);
        const args = { curChanged: curSym !== '$', curSym,
            decimalGroupSepsChanged: this.localeObj.decimal !== '.' && this.localeObj.group !== ',' };
        if (args.curChanged) {
            const intl = new Internationalization(this.parent.locale);
            const formatStr = intl.getNumberPattern({ currency: '$', useGrouping: true, format: 'c0' }, true);
            if (formatStr && formatStr.endsWith('$')) {
                const curSpacing = formatStr[formatStr.indexOf('$') - 1].trim().length ? '' : ' ';
                numberFormatsCode.currency.forEach((format, index) => {
                    if (format.includes('$#,##0')) {
                        let decimalFormat = '';
                        const decimalPart = format.split('$#,##0.')[1];
                        if (decimalPart) {
                            let decimalCount = 0;
                            while (decimalPart[decimalCount] === '0') {
                                decimalFormat += '0';
                                decimalCount++;
                            }
                        }
                        if (decimalFormat) {
                            decimalFormat = `.${decimalFormat}`;
                        }
                        numberFormatsCode.currency[index] = format.split(`$#,##0${decimalFormat}`).join(`#,##0${decimalFormat}${curSpacing}"${curSym}"`);
                    }
                });
                numberFormatsCode.accounting.forEach((format, index) => {
                    if (format.slice(0, format.indexOf('#')).includes('$')) {
                        const formatArr = format.split(';');
                        let replaceIdx;
                        formatArr.forEach((formatStr, index) => {
                            if (formatStr.includes('$')) {
                                formatStr = formatStr.replace('$', '');
                                if (formatStr.includes('0)')) {
                                    replaceIdx = formatStr.indexOf('0)') + 2;
                                }
                                else {
                                    replaceIdx = formatStr.lastIndexOf(formatStr.includes('0') ? '0' : (formatStr.includes('?') ? '?' :
                                        (formatStr.includes('"-"') ? '"' : '#'))) + 1;
                                }
                                if (replaceIdx > 0) {
                                    formatArr[index] = formatStr.slice(0, replaceIdx) + curSpacing + `"${curSym}"` +
                                        formatStr.slice(replaceIdx);
                                }
                            }
                        });
                        numberFormatsCode.accounting[index] = formatArr.join(';');
                    }
                });
            }
            else {
                const updateLocalizedCurrency = (format, index, formats) => formats[index] = format.split('$').join(`"${curSym}"`);
                numberFormatsCode.currency.forEach(updateLocalizedCurrency);
                numberFormatsCode.accounting.forEach(updateLocalizedCurrency);
            }
        }
        const customFormats = ['General', '0', '0.00', '#,##0', '#,##0.00', '#,##0_);(#,##0)', '#,##0_);[Red](#,##0)',
            '#,##0.00_);(#,##0.00)', '#,##0.00_);[Red](#,##0.00)', numberFormatsCode.currency[2], numberFormatsCode.currency[3],
            numberFormatsCode.currency[4], numberFormatsCode.currency[5], '0%', '0.00%', '0.00E+00', '##0.0E+0', '# ?/?', '# ??/??',
            'm/d/yyyy', 'd-mmm-yy', 'd-mmm', 'mmm-yy', 'h:mm AM/PM', 'h:mm:ss AM/PM', 'h:mm', 'h:mm:ss', 'm/d/yyyy h:mm', 'mm:ss',
            'mm:ss.0', '@', '[h]:mm:ss', ...numberFormatsCode.accounting];
        if (isFormatMapping) {
            this.customFormats.splice(0, customFormats.length, ...customFormats);
        }
        else {
            this.customFormats = customFormats;
            this.localizedFormats = [];
        }
        const defaultFormatsId = [0, 1, 2, 3, 4, 37, 38, 39, 40, 5, 6, 7, 8, 9, 10, 11, 48, 12, 13, 14, 15, 16, 17, 18, 19, 20,
            21, 22, 45, 47, 49, 46, 42, 41, 44, 43];
        let formatIdx;
        defaultFormatsId.forEach((id, index) => {
            if (defaultFormats && defaultFormats.has(id)) {
                this.customFormats[index] = defaultFormats.get(id);
                formatIdx = [5, 6, 7, 8].indexOf(id);
                if (formatIdx > -1) {
                    numberFormatsCode.currency[formatIdx + 2] = this.customFormats[index];
                }
                else {
                    formatIdx = [42, 41, 44, 43].indexOf(id);
                    if (formatIdx > -1) {
                        numberFormatsCode.accounting[formatIdx] = this.customFormats[index];
                    }
                }
            }
            args.format = this.customFormats[index];
            this.parseToLocalizedFormat(args);
            this.localizedFormats[index] = args.format;
        });
        for (let idx = defaultFormatsId.length; idx < this.localizedFormats.length; idx++) {
            const cusFormatIdx = this.localizedFormats.findIndex((format, index) => format === this.localizedFormats[idx] && index < defaultFormatsId.length);
            if (cusFormatIdx > -1) {
                this.localizedFormats.splice(idx, 1);
                this.customFormats.splice(idx, 1);
                idx--;
            }
        }
    }
    localizedFormatAction(args) {
        if (args.action === 'getLocalizedFormats') {
            args.defaultFormats = this.customFormats;
            args.localizedFormats = this.localizedFormats;
        }
        else if (args.action === 'mapNumberFormatId') {
            this.updateLocalizedFormats(IntlBase.getDependables(cldrData, this.parent.locale, null).dateObject, true);
        }
        else {
            args.curSym = getNumberDependable(this.parent.locale, defaultCurrencyCode);
            if (args.action === 'parseToDefaultFormat') {
                this.parseToDefaultFormat(args);
            }
            else {
                // addToCustomFormats action
                args.decimalGroupSepsChanged = this.localeObj.decimal !== '.' && this.localeObj.group !== ',';
                args.curChanged = args.curSym !== '$';
                if (!args.defaultFormat) {
                    args.defaultFormat = args.format;
                    this.parseToLocalizedFormat(args);
                }
                if (this.localizedFormats.indexOf(args.format) === -1) {
                    this.localizedFormats.push(args.format);
                    this.customFormats.push(args.defaultFormat);
                }
            }
        }
    }
    parseToDefaultFormat(args) {
        const decimalSepChanged = this.localeObj.decimal !== '.' && args.format.includes(this.localeObj.decimal);
        const groupSepChanged = this.localeObj.group !== ',' && args.format.includes(this.localeObj.group);
        const curSymChanged = args.curSym !== '$' && args.format.includes(args.curSym);
        if (decimalSepChanged || groupSepChanged || curSymChanged) {
            let endPos;
            let prevChar;
            let formatChar;
            const formatSection = args.format.split(';');
            formatSection.forEach((format, index) => {
                const formatChars = format.split('');
                for (let idx = 0; idx < formatChars.length; idx++) {
                    formatChar = formatChars[idx];
                    if (formatChar === '"') {
                        idx = format.indexOf('"', idx + 1);
                    }
                    else if (formatChar === '_' || formatChar === '*' || formatChar === '\\') {
                        idx++;
                    }
                    else if (formatChar === '[') {
                        endPos = format.indexOf(']', idx + 1);
                        if (endPos > -1) {
                            idx = endPos;
                        }
                    }
                    else if (decimalSepChanged && formatChar === this.localeObj.decimal) {
                        prevChar = formatChars[idx - 1];
                        if (prevChar) {
                            prevChar = prevChar.toLowerCase();
                            if (!['d', 'm', 'y', 'h'].some((char) => prevChar === char)) {
                                formatChars[idx] = '.';
                            }
                        }
                        else {
                            formatChars[idx] = '.';
                        }
                    }
                    else if (groupSepChanged && formatChar === this.localeObj.group) {
                        if (this.isDigitPlaceHolder(formatChars[idx - 1])) {
                            formatChars[idx] = ',';
                        }
                    }
                    else if (curSymChanged) {
                        if (formatChar === args.curSym) {
                            formatChars[idx] = `"${args.curSym}"`;
                        }
                        else if (args.curSym.startsWith(formatChar) &&
                            format.substring(idx, idx + args.curSym.length) === args.curSym) {
                            formatChars.splice(idx, args.curSym.length, `"${args.curSym}"`);
                        }
                    }
                }
                formatSection[index] = formatChars.join('');
            });
            args.format = formatSection.join(';');
        }
    }
    /**
     * @hidden
     *
     * @param {Object} args - Specifies the args.
     * @returns {string} - to get formatted cell.
     */
    getFormattedCell(args) {
        let fResult = args.value === undefined || args.value === null ? '' : args.value;
        args.sheetIndex = args.sheetIndex === undefined ? this.parent.activeSheetIndex : args.sheetIndex;
        const sheet = getSheet(this.parent, args.sheetIndex);
        const cell = args.cell || getCell(args.rowIndex, args.colIndex, sheet, false, true);
        let rightAlign = false;
        const intl = new Internationalization();
        if (!args.curSymbol) {
            args.curSymbol = getNumberDependable(this.parent.locale, defaultCurrencyCode);
        }
        if ((!args.format || args.format === 'General') && !args.skipFormatCheck && (!cell.formula ||
            !cell.formula.toLowerCase().startsWith('=text('))) {
            args.type = args.format = 'General';
            if (!cell.formula || (cell.formula && cell.formula.indexOf('&-') === -1)) { // for 5&-3=>5-3.
                const dateEventArgs = { value: fResult, updatedVal: fResult, cell: cell, isEdit: args.isEdit,
                    intl: intl };
                this.checkDateFormat(dateEventArgs);
                if (dateEventArgs.isDate || dateEventArgs.isTime) {
                    rightAlign = true;
                    cell.value = args.value = dateEventArgs.updatedVal;
                    if (cell.format && cell.format !== 'General') {
                        args.format = cell.format;
                        args.type = getTypeFromFormat(args.format);
                    }
                    else {
                        cell.format = args.format = getFormatFromType(dateEventArgs.isDate ? 'ShortDate' : 'Time');
                    }
                }
            }
        }
        else {
            args.type = getTypeFromFormat(args.format);
            if (args.skipFormatCheck && !args.format && args.type === 'General') {
                args.format = 'General';
            }
        }
        if (cell.format && this.isCustomType(cell)) {
            args.type = 'Custom';
            const isTextFormat = cell.format.indexOf('@') > -1;
            if (fResult !== '' && !isTextFormat && this.isPercentageValue(fResult.toString(), args, cell)) {
                fResult = args.value.toString();
            }
            let isCustomText;
            const option = {};
            if (defaultFormats && isImported(this.parent)) {
                cell.format = args.format = this.getMatchingCustomFormat(cell.format);
            }
            const orgFormat = cell.format;
            cell.format = cell.format.split('\\').join('');
            const formats = cell.format.split(';');
            if (isCustomDateTime(formats[0], true, option, true)) {
                if (fResult !== '') {
                    args.result = this.processCustomDateTime(args, cell, option.type !== 'time', formats);
                    isCustomText = !args.formatApplied;
                }
                args.result = args.result || cell.value;
            }
            else if (formats.length > 1) {
                if (cell.format.indexOf('<') > -1 || cell.format.indexOf('>') > -1) {
                    args.result = this.processCustomConditions(cell, args);
                }
                else {
                    const numObj = checkIsNumberAndGetNumber(cell, this.parent.locale, this.localeObj.group, this.localeObj.decimal, args.curSymbol);
                    if (numObj.isNumber) {
                        cell.value = numObj.value;
                        this.processCustomAccounting(cell, args, formats, formats[0]);
                        isCustomText = false;
                    }
                    else {
                        args.result = this.processCustomText(cell, args, formats);
                        isCustomText = true;
                    }
                }
                cell.format = orgFormat;
            }
            else if (isTextFormat) {
                isCustomText = true;
                args.result = this.processCustomText(cell, args);
            }
            else {
                const numObj = checkIsNumberAndGetNumber({ value: fResult }, this.parent.locale, this.localeObj.group, this.localeObj.decimal);
                if (numObj.isNumber) {
                    cell.value = args.value = numObj.value;
                    if (cell.format.includes('E+0')) {
                        if (args.format !== cell.format) {
                            args.format = cell.format;
                        }
                        this.checkAndSetColor(args);
                        const numberFormat = args.format.split('E')[0];
                        let formatArr = numberFormat.split('.');
                        if (this.localeObj.decimal !== '.' && formatArr.length === 1) {
                            formatArr = numberFormat.split(this.localeObj.decimal);
                        }
                        args.result = formatArr[0].length > 1 ? this.scientificHashFormat(args, formatArr) : this.scientificFormat(args);
                    }
                    else {
                        args.result = this.processCustomNumberFormat(cell, args);
                        isCustomText = !isNumber(cell.value);
                    }
                }
                else {
                    if (cell.format && cell.format.includes('[')) {
                        this.removeFormatColor(args, { format: cell.format, style: cell.style });
                    }
                    isCustomText = args.dataUpdate = true;
                }
            }
            if (args.dataUpdate) {
                args.formattedText = args.result || (isNullOrUndefined(args.value) ? '' : args.value.toString());
            }
            else {
                args.value = args.result;
                args.formattedText = isNullOrUndefined(args.value) ? '' : args.value.toString();
            }
            if (isCustomText) {
                args.isRightAlign = false;
            }
            else {
                args.isRightAlign = !isNullOrUndefined(args.value);
            }
        }
        else {
            const result = this.processFormats(args, fResult, rightAlign, cell, intl, sheet);
            args.formattedText = result.fResult || (args.value === undefined || args.value === null ? '' : args.value.toString());
            args.isRightAlign = result.rightAlign;
        }
        if (args.rowIndex !== undefined) {
            if (cell.format && args.formattedText && args.formattedText !== cell.value && cell.format !== 'General') {
                cell.formattedText = args.formattedText;
            }
            else if (cell.formattedText) {
                delete cell.formattedText;
            }
        }
        return args.formattedText;
    }
    isCustomType(cell) {
        const format = getTypeFromFormat(cell.format);
        return (format === 'General' && cell.format !== 'General') || (format === 'Time' && this.parent.isEdit);
    }
    processCustomFill(format, cell, args, formatText) {
        const repeatChar = format[format.indexOf('*') + 1];
        const codes = format.split('*' + repeatChar);
        if (args.rowIndex === undefined || args.dataUpdate) {
            formatText = formatText || this.processCustomNumberFormat({ format: codes.join(''), value: cell.value }, args);
        }
        else {
            let secText;
            if (codes[1]) {
                const cellVal = parseFloat(cell.value);
                if (cellVal < 0) {
                    secText = this.processCustomNumberFormat({ format: codes[1], value: Math.abs(cellVal).toString() }, args);
                    formatText = `-${codes[0].split('\'').join('')}`;
                }
                else {
                    secText = this.processCustomNumberFormat({ format: codes[1], value: cell.value }, args);
                    formatText = codes[0].split('\'').join('');
                }
                if (cellVal === 0) {
                    secText = secText.split('0').join('');
                }
            }
            else {
                formatText = formatText || this.processCustomNumberFormat({ format: codes[0], value: cell.value }, args);
            }
            args.isRowFill = true;
            this.setCell(args);
            this.parent.notify(rowFillHandler, { cell: cell, cellEle: args.td, rowIdx: args.rowIndex, colIdx: args.colIndex, beforeFillText: formatText,
                repeatChar: repeatChar, afterFillText: secText });
            formatText = this.parent.isPrintingProcessing ? formatText + secText : formatText;
        }
        return formatText;
    }
    processCustomDateTime(args, cell, isDate, formatSections) {
        if (this.localeObj.decimal !== '.' && cell.value && cell.value.toString().includes(this.localeObj.decimal)) {
            const cellVal = cell.value.replace(this.localeObj.decimal, '.');
            if (isNumber(cellVal)) {
                cell.value = args.value = cellVal;
            }
        }
        let isCustomDate;
        const checkCustomDate = () => {
            const cellVal = cell.value.toString();
            if (cellVal.includes(this.localeObj.dateSeparator) || cellVal.indexOf('-') > 0 || cellVal.includes(this.localeObj.timeSeparator)) {
                return true;
            }
            const formats = IntlBase.getDependables(cldrData, this.parent.locale, null).dateObject;
            const months = formats.months['stand-alone'] && formats.months['stand-alone'].abbreviated;
            return months && !!Object.keys(months).find((key) => cellVal.includes(months[`${key}`]));
        };
        if (!isNumber(cell.value)) {
            isCustomDate = checkCustomDate();
            if (!isCustomDate) {
                return this.processCustomText(cell, args, formatSections);
            }
        }
        else if (formatSections.length > 1 && parseFloat(cell.value) <= 0) {
            args.formatApplied = this.processCustomAccounting(cell, args, formatSections);
            if (args.formatApplied) {
                return args.result;
            }
        }
        let type;
        let custFormat = formatSections[0];
        const intl = new Internationalization();
        const formatDateTime = (checkDate) => {
            let isValidDate;
            let dateArgs;
            if (isCustomDate) {
                let noOfDays;
                if (cell.format.includes('[h]')) {
                    const timeArr = cell.value.toString().split(':');
                    if (timeArr.length > 1 && Number(timeArr[0]) >= 24) {
                        noOfDays = Number(timeArr[0]) / 24;
                        timeArr[0] = '24';
                        cell.value = timeArr.join(':');
                    }
                }
                dateArgs = toDate(cell.value, new Internationalization(), this.parent.locale, custFormat, cell);
                isValidDate = dateArgs.dateObj && dateArgs.dateObj.toString() !== 'Invalid Date';
                if (isValidDate) {
                    if (dateArgs.dateObj.getFullYear() < 1900) {
                        return '';
                    }
                    else {
                        let dateIntVal = dateToInt(dateArgs.dateObj, cell.value.toString().includes(':'), dateArgs.type === 'time');
                        if (noOfDays >= 1) {
                            dateIntVal += noOfDays;
                            dateArgs.dateObj = intToDate(dateIntVal);
                        }
                        cell.value = dateIntVal.toString();
                    }
                }
            }
            else {
                if (this.checkAndProcessNegativeValue(args, cell.value)) {
                    args.formatApplied = true;
                    return args.formattedText;
                }
                dateArgs = { dateObj: intToDate(parseFloat(cell.value)) };
                isValidDate = dateArgs.dateObj && dateArgs.dateObj.toString() !== 'Invalid Date';
            }
            if (isValidDate) {
                if (checkDate && isDate) {
                    args.dateObj = dateArgs.dateObj;
                }
                args.formatApplied = true;
                let result;
                if (custFormat.startsWith('MM-dd-yyyy ')) { // While auto detect date time value, we will set this format only.
                    custFormat = custFormat.split(' ').splice(1).join(' ');
                    result = intl.formatDate(dateArgs.dateObj, { type: 'date', skeleton: 'yMd' }) + (custFormat ? ' ' +
                        intl.formatDate(dateArgs.dateObj, { type: type, format: custFormat }) : '');
                }
                else {
                    result = intl.formatDate(dateArgs.dateObj, { type: type, format: custFormat });
                    custFormat = custFormat.toLowerCase();
                    if (custFormat.startsWith('[h]')) {
                        const totalHours = (Number(cell.value.toString().split('.')[0]) * 24) + dateArgs.dateObj.getHours();
                        result = totalHours.toString() + result.slice(result.indexOf(']') + 1);
                    }
                    else if (custFormat.startsWith('[m')) {
                        const totalMins = (Number(cell.value.toString().split('.')[0]) * 1440) + (dateArgs.dateObj.getHours() * 60)
                            + dateArgs.dateObj.getMinutes();
                        result = totalMins.toString() + result.slice(result.indexOf(']') + 1);
                    }
                    else if (custFormat.startsWith('[s')) {
                        result = ((Number(cell.value.toString().split('.')[0]) * 86400) + (((dateArgs.dateObj.getHours() * 60) +
                            dateArgs.dateObj.getMinutes()) * 60) + dateArgs.dateObj.getSeconds()).toString();
                    }
                }
                if (isShortMeridian) {
                    return result.replace(this.localeObj.am, 'A').replace(this.localeObj.pm, 'P');
                }
                return result;
            }
            return '';
        };
        custFormat = custFormat.split('_(').join(' ').split('_)').join(' ');
        if (cell.format.indexOf('h') > -1) {
            custFormat = custFormat.split('h').join('H');
            type = 'time';
        }
        if (cell.format.indexOf('s') > -1) {
            type = 'time';
        }
        const isShortMeridian = cell.format.indexOf('A/P') > -1;
        if (cell.format.indexOf('AM/PM') > -1 || isShortMeridian) {
            custFormat = custFormat.split('H').join('h');
            custFormat = custFormat.split('A/P').join('AM/PM').split('AM/PM').join('a');
            type = 'time';
        }
        if (cell.format.indexOf('d') > -1) {
            type = 'date';
            // Split the format with ' ' for replacing d with E only for a day of the week in the MMM d, yyyy ddd format
            const formatArr = custFormat.split(' ');
            let dayMatchStr;
            let splitFormat;
            let part;
            let separator;
            for (let formatIdx = 0; formatIdx < formatArr.length; formatIdx++) {
                separator = formatArr[formatIdx].includes(this.localeObj.dateSeparator) ? this.localeObj.dateSeparator : '-';
                splitFormat = formatArr[formatIdx].split(separator);
                for (let index = 0; index < splitFormat.length; index++) {
                    part = splitFormat[index];
                    dayMatchStr = part.match(/d/g);
                    if (dayMatchStr && dayMatchStr.length > 2) {
                        splitFormat[index] = part.split('d').join('E');
                    }
                }
                formatArr[formatIdx] = splitFormat.join(separator);
            }
            custFormat = formatArr.join(' ');
        }
        if (cell.format.indexOf('m') > -1) {
            if (cell.format.indexOf('s') > -1 || cell.format.indexOf('h') > -1) {
                type = 'time';
                if (cell.format.includes(' ')) {
                    const formatArr = custFormat.split(' ');
                    if (formatArr[0].includes('d') || formatArr[0].includes('y')) {
                        formatArr[0] = formatArr[0].split('m').join('M');
                        custFormat = formatArr.join(' ');
                    }
                }
            }
            else {
                type = 'date';
                custFormat = custFormat.split('m').join('M');
                if (custFormat.includes('MMMMM')) {
                    const prevFormat = custFormat;
                    custFormat = 'MMMM';
                    const monthName = formatDateTime()[0];
                    custFormat = prevFormat.split('MMMMM').join('p');
                    return formatDateTime(args.checkDate).split('p').join(monthName);
                }
            }
        }
        return formatDateTime(args.checkDate);
    }
    processCustomConditions(cell, args) {
        if (isNumber(cell.value)) {
            const formatArr = cell.format.split(';');
            const val = Number(cell.value);
            let compareVal;
            let conditionNotMatch;
            let colorCode;
            for (let i = 0; i < formatArr.length; i++) {
                cell.format = formatArr[i];
                colorCode = getColorCode(cell.format);
                if (colorCode) {
                    cell.format = cell.format.split(`[${colorCode}]`).join('');
                }
                if (cell.format.includes('[')) {
                    compareVal = cell.format.split('[')[1].split(']')[0];
                    const ltEqualTo = compareVal.split('<=');
                    const gtEqualTo = compareVal.split('>=');
                    const lessThan = compareVal.split('<');
                    const greaterThan = compareVal.split('>');
                    if ((ltEqualTo.length === 2 && val <= Number(ltEqualTo[1])) ||
                        (gtEqualTo.length === 2 && val >= Number(gtEqualTo[1])) ||
                        (lessThan.length === 2 && val < Number(lessThan[1])) ||
                        (greaterThan.length === 2 && val > Number(greaterThan[1]))) {
                        cell.format = formatArr[i].split(`[${compareVal}]`).join('');
                        conditionNotMatch = false;
                        break;
                    }
                    conditionNotMatch = compareVal.split(/<=|>=|<|>/).length === 2;
                }
                else {
                    cell.format = formatArr[i];
                    conditionNotMatch = false;
                    break;
                }
            }
            if (conditionNotMatch) {
                this.removeFormatColor(args, { format: formatArr.join(''), style: cell.style });
                return this.processCustomFill('*#', cell, args, '#####');
            }
            return this.processCustomNumberFormat(cell, args);
        }
        else {
            return cell.value;
        }
    }
    processCustomAccounting(cell, args, formats, format) {
        const cellVal = parseFloat(cell.value);
        if (cellVal < 0) {
            if (!formats[1].includes('@')) {
                format = formats[1];
            }
        }
        else if (cellVal === 0 && formats[2] && !formats[2].includes('@')) {
            format = formats[2].includes(`${args.curSymbol}0`) ? formats[2].split('0').join('#') : formats[2];
        }
        if (format) {
            args.result = this.processCustomNumberFormat({
                format: cell.format, value: cellVal < 0 ? Math.abs(cellVal).toString() : cell.value, style: cell.style
            }, args, format);
            return true;
        }
        return false;
    }
    processCustomText(cell, args, formatSections) {
        const cellVal = cell.value || cell.value ? cell.value.toString() : '';
        let format;
        if (formatSections) {
            if (formatSections[3]) {
                format = formatSections[3];
            }
            else if (formatSections[1] && formatSections[1].includes('@')) {
                format = formatSections[1];
            }
            else {
                return cellVal;
            }
        }
        else {
            format = cell.format;
        }
        let result = this.processCustomNumberFormat({ format: format.split('@').join('#'), value: cellVal.split(cellVal).join('1') }, args);
        if (result) {
            result = result.split('1').join(cellVal);
            if (this.localeObj.decimal !== '.' && isNumber(result) && result.includes('.')) {
                result = result.replace('.', this.localeObj.decimal);
            }
        }
        return result;
    }
    thousandSeparator(count, value) {
        while (count) {
            value = value / 1000;
            count--;
        }
        return value;
    }
    getSeparatorCount(cell) {
        let count = 0;
        const codes = ['#', '0'];
        for (let i = 0; i < cell.format.length; i++) {
            if (cell.format[i] === '"' && cell.format[i - 1] !== '\\') {
                i = cell.format.indexOf('"', i + 1);
            }
            else if (cell.format[i] === ',' && !(codes.indexOf(cell.format[i + 1]) > -1)) {
                count++;
            }
        }
        return count;
    }
    processDigits(cell, customFormat) {
        customFormat = customFormat.split('?').join('0');
        let cellValue = cell.value.toString();
        cellValue = this.getFormattedNumber(customFormat, parseFloat(cellValue));
        if (cellValue && cellValue.includes(this.localeObj.decimal)) {
            const valArr = cellValue.split(this.localeObj.decimal);
            cellValue = valArr[0] + this.localeObj.decimal + valArr[1].split('0').join('  ');
        }
        return cellValue || cell.value;
    }
    processFormatWithSpace(format, cell, cellValue) {
        const space = ' ';
        const args = { cell: cell, char: space, width: 0 };
        this.parent.notify(getTextSpace, args);
        const spaceWidth = args.width;
        let count;
        const result = { format: format, formattedText: '' };
        for (let i = 0; i < format.length; i++) {
            if (format[i] === '_') {
                args.char = format[i + 1];
                this.parent.notify(getTextSpace, args);
                const textWidth = args.width;
                count = Math.round(textWidth / spaceWidth);
                format = format.replace(format[i] + format[i + 1], space.repeat(count));
            }
        }
        let lastSpaceCount = format.length - format.trim().length;
        if (lastSpaceCount > 0) {
            result.formattedText = this.getFormattedNumber(format.trim(), cellValue);
            if (format[0] === ' ') {
                let frontSpaceCount = 1;
                let idx = 1;
                while (format[idx] === ' ') {
                    frontSpaceCount++;
                    idx++;
                }
                lastSpaceCount -= frontSpaceCount;
                result.formattedText = space.repeat(frontSpaceCount) + result.formattedText;
            }
            result.formattedText += space.repeat(lastSpaceCount);
        }
        else {
            result.formattedText = this.getFormattedNumber(format, cellValue);
        }
        result.format = format;
        return result;
    }
    removeFormatColor(args, cell) {
        if (getCustomColors().indexOf(getColorCode(cell.format)) > -1) {
            args.color = cell.style && cell.style.color ? cell.style.color : '';
            this.applyColor(args);
        }
    }
    processCustomNumberFormat(cell, args, format) {
        if (!cell.format) {
            return '';
        }
        let formattedText = cell.value;
        const numArgs = checkIsNumberAndGetNumber(cell, this.parent.locale, this.localeObj.group, this.localeObj.decimal);
        if (numArgs.isNumber) {
            let isFormatted;
            let isZeroFormat;
            cell.value = numArgs.value;
            const cellValue = parseFloat(cell.value.toString());
            let customFormat = format || cell.format;
            if (cell.format.indexOf('[') > -1) {
                const colorCode = getColorCode(customFormat);
                if (colorCode) {
                    customFormat = customFormat.split(`[${colorCode}]`).join('');
                    args.color = colorCode.toLowerCase();
                    this.applyColor(args);
                }
                else {
                    this.removeFormatColor(args, cell);
                }
            }
            if (customFormat.indexOf('"') > -1 || customFormat.indexOf('\\') > -1) {
                customFormat = this.processText(customFormat);
                isZeroFormat = cellValue === 0 && !customFormat.includes('#') && !customFormat.includes('0');
                if (isZeroFormat) {
                    customFormat += '#';
                }
            }
            const separatorCount = this.getSeparatorCount(cell);
            if (separatorCount) {
                isFormatted = true;
                let result = this.thousandSeparator(separatorCount, cellValue);
                if (customFormat.indexOf('.') === -1) {
                    result = Math.round(result);
                }
                formattedText = this.getFormattedNumber(customFormat.split(',').join(''), result);
                if (result === 0) {
                    formattedText = formattedText.replace('0', '');
                }
            }
            if (customFormat.indexOf('?') > -1) {
                isFormatted = true;
                formattedText = this.processDigits(cell, customFormat);
                customFormat = customFormat.split('?').join('');
            }
            if (customFormat.indexOf('_') > -1) {
                isFormatted = true;
                const result = this.processFormatWithSpace(customFormat, cell, cellValue);
                customFormat = result.format;
                formattedText = result.formattedText;
            }
            if (formattedText && customFormat.indexOf('?') > -1) {
                formattedText = formattedText.replace('?', ' ');
            }
            if (customFormat.indexOf('*') > -1) {
                isFormatted = true;
                formattedText = this.processCustomFill(customFormat, cell, args);
            }
            if (customFormat === 'General') {
                isFormatted = true;
                formattedText = cellValue.toString();
            }
            if (!isFormatted) {
                formattedText = this.getFormattedNumber(customFormat, cellValue);
            }
            if (isZeroFormat && formattedText) {
                formattedText = formattedText.replace('0', '');
            }
            // Need to remove this line once this case is handled by core team.
            if (customFormat[0] === '#' && cellValue >= 0 && cellValue < 1) {
                const formatArr = customFormat.split('#').join('').split('.');
                if (!formatArr[0].includes('0')) {
                    if (cellValue === 0 && customFormat.includes('.') && (!formatArr[1] || !formatArr[1].includes('0'))) {
                        formattedText = this.getFormattedNumber(customFormat, 0.1);
                        formattedText = formattedText.replace('1', '');
                    }
                    const textArr = formattedText.split(this.localeObj.decimal);
                    textArr[0] = textArr[0].toString().replace(/^0+/, '');
                    formattedText = textArr.join(this.localeObj.decimal);
                }
            }
            if (formattedText === '-0') { // Need to remove this line once this case is handled by core team.
                formattedText = '0';
            }
        }
        return formattedText;
    }
    processText(format) {
        let custFormat = format;
        if (custFormat.indexOf('"') > -1) {
            custFormat = custFormat.split('"').join('\'');
        }
        else if (custFormat.indexOf('\\') > -1) {
            custFormat = custFormat.split('\\').join('');
        }
        return custFormat;
    }
    processFormats(args, fResult, isRightAlign, cell, intl, sheet) {
        let options;
        if (this.parent.isEdit && (args.type === 'Scientific' && !isNumber(args.value))) {
            args.type = 'General';
        }
        if (fResult !== '') {
            let numArgs;
            if (args.type !== 'General' && args.type !== 'Text' && this.isPercentageValue(fResult.toString(), args, cell)) {
                fResult = args.value.toString();
            }
            switch (args.type) {
                case 'General':
                    options = { args: args, fResult: fResult, intl: intl, isRightAlign: isRightAlign,
                        cell: cell, rowIdx: Number(args.rowIndex), colIdx: Number(args.colIndex), sheet: sheet };
                    if (!(options.fResult.toString().startsWith('\n') || options.fResult.toString().endsWith('\n '))) {
                        this.autoDetectGeneralFormat(options);
                    }
                    fResult = options.fResult;
                    isRightAlign = options.isRightAlign;
                    break;
                case 'Number':
                    numArgs = checkIsNumberAndGetNumber({ value: fResult }, this.parent.locale, this.localeObj.group, this.localeObj.decimal, args.curSymbol, true, true);
                    if (numArgs.isNumber) {
                        cell.value = args.value = numArgs.value;
                        fResult = this.applyNumberFormat(args, intl);
                        isRightAlign = true;
                    }
                    break;
                case 'Currency':
                    numArgs = checkIsNumberAndGetNumber({ value: fResult, format: args.format }, this.parent.locale, this.localeObj.group, this.localeObj.decimal, args.curSymbol);
                    if (numArgs.isNumber) {
                        cell.value = args.value = numArgs.value;
                        fResult = this.currencyFormat(args, intl, cell);
                        isRightAlign = true;
                    }
                    break;
                case 'Percentage':
                    numArgs = checkIsNumberAndGetNumber({ value: fResult }, this.parent.locale, this.localeObj.group, this.localeObj.decimal, args.curSymbol, true, true);
                    if (numArgs.isNumber) {
                        cell.value = args.value = numArgs.value;
                        fResult = this.percentageFormat(args, intl);
                        isRightAlign = true;
                    }
                    break;
                case 'Accounting':
                    fResult = this.accountingFormat(args, fResult, intl, cell);
                    isRightAlign = args.formatApplied;
                    break;
                case 'ShortDate':
                    fResult = this.checkAndProcessNegativeValue(args, args.value) ? args.formattedText : this.shortDateFormat(args, intl, cell);
                    isRightAlign = !!fResult;
                    break;
                case 'LongDate':
                    fResult = this.checkAndProcessNegativeValue(args, args.value) ? args.formattedText : this.longDateFormat(args, intl);
                    isRightAlign = !!fResult;
                    break;
                case 'Time':
                    fResult = this.checkAndProcessNegativeValue(args, args.value) ? args.formattedText : this.timeFormat(args, intl, cell);
                    isRightAlign = !!fResult;
                    break;
                case 'Fraction':
                    numArgs = checkIsNumberAndGetNumber({ value: fResult }, this.parent.locale, this.localeObj.group, this.localeObj.decimal, null, true);
                    if (numArgs.isNumber) {
                        cell.value = args.value = numArgs.value;
                        fResult = this.fractionFormat(args);
                        isRightAlign = true;
                    }
                    break;
                case 'Scientific':
                    numArgs = checkIsNumberAndGetNumber({ value: fResult }, this.parent.locale, this.localeObj.group, this.localeObj.decimal);
                    if (numArgs.isNumber) {
                        cell.value = args.value = numArgs.value;
                        fResult = this.scientificFormat(args);
                        isRightAlign = true;
                    }
                    break;
                case 'Text':
                    if (this.localeObj.decimal !== '.' && isNumber(fResult) && fResult.toString().includes('.')) {
                        fResult = fResult.toString().replace('.', this.localeObj.decimal);
                    }
                    isRightAlign = false;
                    break;
            }
        }
        return { fResult: fResult, rightAlign: isRightAlign };
    }
    autoDetectGeneralFormat(options) {
        const val = options.fResult;
        let prevVal;
        const addressFormula = options.args.cell && options.args.cell.formula && options.args.cell.formula.indexOf('ADDRESS(') > 0;
        const isDollarFormula = options.args.cell && options.args.cell.formula && options.args.cell.formula.indexOf('DOLLAR(') > 0;
        const isTextFormula = options.args.cell && options.args.cell.formula && options.args.cell.formula.indexOf('TEXT(') > 0;
        if (isDollarFormula && options.fResult && options.fResult.toString().includes(options.args.curSymbol) || isTextFormula) {
            return;
        }
        if (options.fResult && this.localeObj.decimal !== '.') {
            let cellVal = options.fResult.toString();
            prevVal = cellVal;
            if (cellVal.includes(this.localeObj.decimal)) {
                cellVal = cellVal.replace(this.localeObj.decimal, '.');
                if (isNumber(cellVal)) {
                    if (cellVal.includes('E')) {
                        options.fResult = cellVal;
                    }
                    else {
                        options.fResult = options.args.value = cellVal = Number(cellVal).toString();
                        setCell(options.rowIdx, options.colIdx, options.sheet, { value: cellVal }, true);
                    }
                    prevVal = cellVal.replace('.', this.localeObj.decimal);
                }
            }
        }
        if (isNumber(options.fResult)) {
            let cellVal = Number(options.fResult).toString();
            if (options.fResult.toString().includes('E')) {
                options.args.format = getFormatFromType('Scientific');
                setCell(options.rowIdx, options.colIdx, options.sheet, { value: cellVal, format: options.args.format }, true);
                options.args.value = cellVal;
                options.fResult = this.scientificFormat(options.args);
            }
            else if (options.args.format) {
                if (options.args.format.indexOf('%') > -1) {
                    options.fResult = this.percentageFormat(options.args, options.intl);
                }
                else if (options.args.format.indexOf(options.args.curSymbol) > -1) {
                    options.fResult = this.currencyFormat(options.args, options.intl, options.args.cell);
                }
                else {
                    options.fResult = this.applyNumberFormat(options.args, options.intl);
                }
            }
            if (options.args.format === 'General') {
                if (options.args.cell && options.args.cell.formula && cellVal.includes('.') && cellVal.length > 11) {
                    const decIndex = cellVal.indexOf('.') + 1;
                    prevVal = null;
                    if (options.args.cell.formula.includes('RANDBETWEEN')) {
                        options.fResult = cellVal = decIndex < 7 ? cellVal : (parseFloat(cellVal)).toFixed(0);
                    }
                }
                options.cellVal = cellVal;
                options.prevVal = prevVal;
                this.parseDecimalNumber(options);
                if (isNullOrUndefined(options.fResult) && !isNullOrUndefined(options.cellVal)) {
                    options.fResult = options.cellVal;
                }
            }
            options.isRightAlign = true;
        }
        if (options.fResult) {
            this.updateAutoDetectNumberFormat(options);
        }
        if (addressFormula) {
            options.isRightAlign = false;
            options.fResult = val;
        }
    }
    parseDecimalNumber(options) {
        const cellValArr = options.cellVal.split('.');
        if (cellValArr[0].length > 11) {
            options.cellVal = (Math.abs(Number(cellValArr[0])).toString()).substring(0, 6).replace(/0+$/, '');
            const digitLen = options.cellVal.length - 1;
            if (digitLen > -1) {
                options.fResult = this.scientificFormat(options.args, digitLen > 5 ? 5 : digitLen);
            }
        }
        else if (cellValArr[1]) {
            if (options.cellVal.length > 11) {
                // Subtract with 10 to neglect the decimal point.
                const rightDigitLen = 10 - (cellValArr[0].length - (Math.sign(Number(options.cellVal)) < 0 ? 1 : 0));
                options.fResult = Number(Number(options.cellVal).toFixed(rightDigitLen > 0 ? rightDigitLen : 0)).toString();
            }
            else if (options.cellVal.includes('e-')) {
                const expVal = options.cellVal.split('e-');
                const digitLen = Number(expVal[1]) + (expVal[0].includes('.') ? expVal[0].split('.')[1].length : 0);
                expVal[0] = expVal[0].replace('.', this.localeObj.decimal);
                if (expVal[1].length === 1) {
                    expVal[1] = '0' + expVal[1];
                }
                if (!options.args.updateValue) {
                    setCell(options.rowIdx, options.colIdx, options.sheet, { value: Number(options.cellVal).toFixed(digitLen) }, true);
                }
                options.fResult = expVal.join('E-');
            }
            else if (options.prevVal) {
                options.fResult = options.prevVal;
            }
            else if (options.args.updateValue && this.localeObj.decimal !== '.') {
                options.fResult = options.cellVal.replace('.', this.localeObj.decimal);
            }
        }
    }
    updateAutoDetectNumberFormat(options) {
        let res = options.fResult.toString();
        const cell = options.args.cell || options.cell;
        if (this.isPercentageValue(res, options.args, cell)) {
            cell.format = res.includes(this.localeObj.decimal) ? getFormatFromType('Percentage') : '0%';
            if (!options.args.updateValue) {
                options.args.format = cell.format;
                options.fResult = this.percentageFormat(options.args, options.intl);
                options.isRightAlign = true;
            }
        }
        else {
            const fractionArr = res ? res.toString().split('/') : [];
            const isFraction = (this.parent.isEdit && getTypeFromFormat(cell.format) === 'Scientific' && fractionArr.length === 2 && isNumber(fractionArr[0]) && isNumber(fractionArr[1]));
            if (res.includes(' ') || isFraction) {
                const valArr = isFraction ? fractionArr : res.split(' ');
                if (isFraction || valArr[1].includes('/') && isNumber(valArr[0]) && Number(valArr[0]) % 1 === 0) {
                    const fracArr = isFraction ? fractionArr : valArr[1].split('/');
                    if (isNumber(fracArr[0]) && Number(fracArr[0]) % 1 === 0 && isNumber(fracArr[1]) && Number(fracArr[1]) % 1 === 0) {
                        cell.format = `# ${fracArr[0].length > 1 || fracArr[1].length > 1 ? '??/??' : '?/?'}`;
                        cell.value = isFraction ? (Number(fracArr[0]) / Number(fracArr[1])).toString() :
                            (Number(valArr[0]) + (Number(fracArr[0]) / Number(fracArr[1]))).toString();
                        if (!options.args.updateValue) {
                            options.args.value = cell.value;
                            options.args.format = cell.format;
                            options.fResult = this.fractionFormat(options.args);
                            options.isRightAlign = true;
                        }
                        return;
                    }
                }
            }
            let format = '';
            if (res.includes(options.args.curSymbol)) { // Auto detect 1000 separator format with currency symbol
                format = res.includes(this.localeObj.decimal) ? numberFormatsCode.currency[0] : numberFormatsCode.currency[1];
                res = res.replace(options.args.curSymbol, '');
            }
            const isEdit = this.localeObj.decimal === '.' || (options.args.isEdit && !cell.formula);
            if (isEdit && res.includes(this.localeObj.group) &&
                parseThousandSeparator(res, this.parent.locale, this.localeObj.group, this.localeObj.decimal)) {
                res = res.split(this.localeObj.group).join('');
                if (!format) { // Auto detect 1000 separator format
                    format = (res.includes(this.localeObj.decimal) ? '#,##0.00' : '#,##0');
                }
            }
            if (format) {
                res = res.replace(this.localeObj.decimal, '.');
                if (isNumber(res)) {
                    options.args.value = Number(res).toString();
                    if (options.args.updateValue) {
                        options.args.cell.value = options.args.value;
                        options.args.cell.format = format;
                    }
                    else {
                        options.args.format = format;
                        setCell(options.rowIdx, options.colIdx, options.sheet, { value: options.args.value, format: format }, true);
                        if (format.includes('"')) {
                            format = this.processText(format);
                        }
                        options.fResult = this.getFormattedNumber(format, Number(options.args.value));
                        options.isRightAlign = true;
                    }
                }
            }
            else if (this.localeObj.decimal !== '.' && options.args.format === 'General' && isNumber(res) && res.includes('.')) {
                options.fResult = Number(res).toString().replace('.', this.localeObj.decimal);
            }
        }
    }
    isPercentageValue(value, args, cell) {
        if (value.includes('%')) {
            const valArr = value.split('%');
            if (valArr[0] !== '' && valArr[1].trim() === '') {
                const numArgs = checkIsNumberAndGetNumber({ value: valArr[0] }, this.parent.locale, this.localeObj.group, this.localeObj.decimal);
                if (numArgs.isNumber) {
                    args.value = Number(numArgs.value) / 100;
                    cell.value = args.value.toString();
                    return true;
                }
            }
        }
        return false;
    }
    findSuffix(zeros, resultSuffix) {
        const len = zeros.length;
        const suffixLen = len - resultSuffix.length;
        return zeros.substr(0, suffixLen < 0 ? 0 : suffixLen) + resultSuffix;
    }
    applyNumberFormat(args, intl) {
        args.format = this.isCustomFormat(args.format);
        const formatArr = args.format.split(';');
        if (Number(args.value) > 0) {
            args.format = formatArr[0];
        }
        else if (Number(args.value) === 0) {
            args.format = formatArr[2] ? formatArr[2] : formatArr[0];
            if (args.format.indexOf('"') > -1 && args.format.indexOf('#') === -1) {
                args.format = args.format.split('_').join(' ').split('*').join(' ').split('?').join(' ').split('"').join('');
                return args.format;
            }
        }
        else if (Number(args.value) < 0) {
            args.format = !isNullOrUndefined(formatArr[1]) ? formatArr[1].split('*').join(' ') : formatArr[0];
            if (args.format.indexOf('-') > -1) {
                args.value = args.value.toString().split('-').join('');
            }
        }
        else {
            args.format = formatArr[3] ? formatArr[3] : formatArr[0];
            args.format = args.format.split('_').join(' ').split('*').join(' ').split('?').join(' ');
            if (args.format.indexOf('@') > -1) {
                return args.format.split('@').join(args.value.toString());
            }
        }
        args.format = args.format.split('_').join(' ').split('*').join(' ').split('"').join('');
        if (args.format.indexOf('?') > -1 && args.format.indexOf(this.localeObj.decimal) > -1) {
            const formatDecimalLen = args.format.split(this.localeObj.decimal)[1].length;
            let replaceString = '';
            if (Number(args.value) % 1) {
                const valueDecimalLen = args.value.toString().split('.')[1].length;
                if (formatDecimalLen > valueDecimalLen) {
                    replaceString = ' ';
                }
                else {
                    replaceString = '0';
                }
            }
            args.format = args.format.split('?').join(replaceString);
        }
        else {
            args.format = args.format.split('?').join(' ');
        }
        if (Number(args.value) < 0 && args.cell && args.cell.format) {
            args.format = args.cell.format;
        }
        return intl.formatNumber(Number(args.value), { format: args.format });
    }
    isCustomFormat(format) {
        if (format === '_-* #,##0.00_-;-* #,##0.00_-;_-* "-"_-;_-@_-' || format === '_-* #,##0_-;-* #,##0_-;_-* "-"_-;_-@_-') {
            format = '';
        }
        format = format === '' ? getFormatFromType('Number') : format;
        format = format.toString().split('_)').join(' ').split('_(').join(' ').split('[Red]').join('');
        return format;
    }
    currencyFormat(args, intl, cell) {
        args.format = args.format || getFormatFromType('Currency');
        args.format = args.format.split('_(').join(' ').split('_)').join(' ');
        const formatArr = args.format.split(';');
        const colorCode = getColorCode(args.format);
        let cellVal = Number(args.value);
        if (cellVal >= 0 || isNullOrUndefined(formatArr[1])) {
            if (colorCode) {
                args.color = cell.style && cell.style.color ? cell.style.color : '';
                this.applyColor(args);
            }
            args.format = formatArr[0];
        }
        else {
            cellVal = Math.abs(cellVal);
            args.format = formatArr[1].split(`[${colorCode}]`).join('').split('*').join(' ');
            if (colorCode) {
                args.color = colorCode.toLowerCase();
                this.applyColor(args);
            }
        }
        args.format = this.getFormatForOtherCurrency(args.format);
        if (args.format.includes('"')) {
            args.format = this.processText(args.format);
        }
        return intl.formatNumber(cellVal, { format: args.format, currency: defaultCurrencyCode });
    }
    applyColor(args) {
        if (args.refresh) {
            this.setCell(args);
            if (args.td && args.td.style.color !== args.color) {
                this.parent.notify(applyCellFormat, { style: { color: args.color }, rowIdx: args.rowIndex, colIdx: args.colIndex,
                    td: args.td });
            }
        }
    }
    setCell(args) {
        if (!args.td) {
            const mergeArgs = {
                sheet: getSheet(this.parent, args.sheetIndex),
                cell: args.cell, rowIdx: args.rowIndex, colIdx: args.colIndex
            };
            if (args.cell.rowSpan > 1 || args.cell.colSpan > 1) {
                setVisibleMergeIndex(mergeArgs);
            }
            args.td = this.parent.getCell(mergeArgs.rowIdx, mergeArgs.colIdx);
        }
    }
    percentageFormat(args, intl) {
        args.format = args.format === '' ? getFormatFromType('Percentage') : args.format;
        return intl.formatNumber(Number(args.value), {
            format: args.format
        });
    }
    accountingFormat(args, fResult, intl, cell) {
        args.format = args.format || getFormatFromType('Accounting');
        args.format = args.format.split('_(').join(' ').split('_)').join(' ').split('[Red]').join('').split('_').join('');
        const formatArr = args.format.split(';');
        const numArgs = checkIsNumberAndGetNumber({ value: fResult }, this.parent.locale, this.localeObj.group, this.localeObj.decimal, args.curSymbol, false, true);
        if (numArgs.isNumber) {
            cell.value = args.value = numArgs.value;
            let cellVal = Number(args.value);
            if (cellVal >= 0) {
                args.format = cellVal === 0 && formatArr[2] ? formatArr[2] : formatArr[0];
            }
            else {
                args.format = formatArr[1].split('*').join(' ');
                cellVal = Math.abs(cellVal);
            }
            if (args.format.includes(args.curSymbol)) {
                if (args.format.includes('"')) {
                    args.format = this.processText(args.format);
                }
            }
            args.format = this.getFormatForOtherCurrency(args.format);
            args.formatApplied = true;
            if (cellVal === 0) {
                args.format = this.processText(args.format.split('*').join(' ').split('?').join(' '));
                if (!args.format.includes('#') && !args.format.includes('0')) {
                    args.format += '#';
                    let formattedText = intl.formatNumber(cellVal, { format: args.format, currency: defaultCurrencyCode });
                    if (formattedText.includes('0')) {
                        formattedText = formattedText.replace('0', '');
                    }
                    return args.dataUpdate ? formattedText.split(' ').join('') : formattedText;
                }
                const result = intl.formatNumber(cellVal, { format: args.format, currency: defaultCurrencyCode });
                return args.dataUpdate ? result.split(' ').join('') : result;
            }
            else {
                const result = intl.formatNumber(cellVal, { format: args.format, currency: defaultCurrencyCode });
                return args.dataUpdate ? result.split(' ').join('') : result;
            }
        }
        else if (formatArr[3]) {
            return this.processCustomText(cell, args, formatArr);
        }
        return fResult;
    }
    getFormatForOtherCurrency(format) {
        if (format.indexOf('[$') > -1) {
            const symbol = format.split(']')[0].split('[$')[1].split('-')[0];
            if (format.indexOf('0') > format.indexOf('[$')) {
                format = symbol + format.slice(format.indexOf(']') + 1, format.length);
            }
            else {
                format = format.slice(0, format.indexOf('[$')) + symbol;
            }
        }
        return format;
    }
    checkAndProcessNegativeValue(args, cellValue) {
        if (cellValue && isNumber(cellValue) && Number(cellValue) < 0) {
            if (args.rowIndex === undefined || args.dataUpdate) {
                args.formattedText = '#'.repeat(args.dataUpdate ? 7 : 10);
                return true;
            }
            args.isRowFill = true;
            this.setCell(args);
            const eventArgs = { cell: args.cell, cellEle: args.td, rowIdx: args.rowIndex, colIdx: args.colIndex,
                repeatChar: '#' };
            this.parent.notify(rowFillHandler, eventArgs);
            args.formattedText = eventArgs.formattedText;
            return true;
        }
        return false;
    }
    shortDateFormat(args, intl, cell) {
        let dateObj;
        if (defaultFormats && isImported(this.parent) && cell && cell.format === 'm/d/yyyy' && defaultFormats.has(14)) {
            cell.format = args.format = defaultFormats.get(14);
        }
        let format;
        if (args.format === '' || args.format === 'General' || args.format === 'mm-dd-yyyy' || args.format === 'm/d/yyyy') {
            format = 'MM-dd-yyyy';
            dateObj = { type: 'date', skeleton: 'yMd' };
        }
        else {
            format = args.format;
            if (args.format === getFormatFromType('ShortDate')) {
                dateObj = { type: 'date', skeleton: 'yMd' };
            }
            else {
                dateObj = { type: 'date', format: args.format };
            }
        }
        let shortDate;
        args.value = args.value.toString();
        const checkForDateFormat = this.checkForDateFormat(args, cell);
        if (args.value && cell && (!isNumber(args.value) || checkForDateFormat)) {
            const dateArgs = {
                value: args.value, updatedVal: args.value, cell, isEdit: args.isEdit, intl: intl,
                skipCellFormat: true, format: format
            };
            this.checkDateFormat(dateArgs);
            if (dateArgs.isDate || dateArgs.isTime) {
                cell.value = args.value = dateArgs.updatedVal;
                shortDate = dateArgs.dateObj;
            }
            else if (checkForDateFormat) {
                shortDate = intToDate(args.value);
            }
            else {
                return '';
            }
        }
        else {
            shortDate = intToDate(args.value);
        }
        if (!shortDate || shortDate.toString() === 'Invalid Date') {
            return '';
        }
        else if (shortDate.getFullYear() < 1900 || shortDate.getFullYear() > 9999) {
            return isNumber(args.value) ? args.value.toString() : '';
        }
        if (args.checkDate) {
            args.dateObj = shortDate;
        }
        return intl.formatDate(shortDate, dateObj);
    }
    longDateFormat(args, intl) {
        args.value = args.value.toString();
        let longDate;
        const checkForDateFormat = this.checkForDateFormat(args, args.cell);
        if ((args.value.includes(this.localeObj.dateSeparator) || args.value.indexOf('-') > 0) && (!isNumber(args.value)
            || checkForDateFormat)) {
            if (checkForDateFormat) {
                const dateEventArgs = {
                    value: args.value, updatedVal: args.value, cell: args.cell, isEdit: args.isEdit,
                    intl: intl
                };
                this.checkDateFormat(dateEventArgs);
                if (dateEventArgs.isDate || dateEventArgs.isTime) {
                    longDate = dateEventArgs.dateObj;
                    args.cell.value = args.value = dateToInt(longDate).toString();
                }
                else {
                    longDate = intToDate(args.value);
                }
            }
            else {
                longDate = toDate(args.value, intl, this.parent.locale, '', args.cell).dateObj;
                if (longDate && longDate.toString() !== 'Invalid Date' && longDate.getFullYear() >= 1900) {
                    args.cell.value = args.value = dateToInt(longDate).toString();
                }
                else {
                    return isNumber(args.value) ? args.value : '';
                }
            }
        }
        else {
            longDate = intToDate(args.value);
        }
        if (!longDate || longDate.toString() === 'Invalid Date') {
            return '';
        }
        else if (longDate.getFullYear() < 1900 || longDate.getFullYear() > 9999) {
            return isNumber(args.value) ? args.value.toString() : '';
        }
        if (args.checkDate) {
            args.dateObj = longDate;
        }
        return intl.formatDate(longDate, { type: 'date', skeleton: 'full' });
    }
    checkForDateFormat(args, cell) {
        let checkForDateFormat;
        let value = args.value;
        if (this.localeObj.decimal === '.' || (args.isEdit && !cell.formula)) {
            if (value.includes(this.localeObj.group) &&
                parseThousandSeparator(value, this.parent.locale, this.localeObj.group, this.localeObj.decimal)) {
                value = value.replace(this.localeObj.group, '');
                if (this.localeObj.decimal !== '.' && value.includes(this.localeObj.decimal)) {
                    value = value.replace(this.localeObj.decimal, '.');
                }
                if (isNumber(value) && cell) {
                    cell.value = args.value = value;
                }
                return false;
            }
            else {
                checkForDateFormat = this.localeObj.dateSeparator === '.' && value.includes('.');
            }
            if (this.localeObj.decimal !== '.' && !isNumber(value) && value.includes(this.localeObj.decimal)) {
                value = value.replace(this.localeObj.decimal, '.');
                if (isNumber(value) && cell) {
                    cell.value = args.value = value;
                }
            }
        }
        return checkForDateFormat;
    }
    timeFormat(args, intl, cell) {
        if (isNullOrUndefined(args.value)) {
            return '';
        }
        const defaultCode = getFormatFromType('Time');
        let code;
        if (args.format === '' || args.format === 'General') {
            code = defaultCode;
        }
        if (args.format === 'h:mm:ss AM/PM') {
            code = 'h:mm:ss a';
        }
        else {
            code = args.format;
        }
        let cellVal = args.value.toString();
        if (!isNumber(cellVal) && cell) {
            const timeArgs = { value: cellVal, updatedVal: cellVal, cell, isEdit: args.isEdit, intl: intl,
                skipCellFormat: true };
            this.checkDateFormat(timeArgs);
            if (timeArgs.isDate || timeArgs.isTime) {
                cell.value = cellVal = timeArgs.updatedVal;
            }
            else {
                return '';
            }
        }
        const value = cellVal.split('.');
        if (!isNullOrUndefined(value[1])) {
            cellVal = parseFloat((value[0] + 1) + '.' + value[1]) || cellVal;
        }
        return intl.formatDate(intToDate(cellVal), { type: 'time', skeleton: 'medium', format: code });
    }
    scientificHashFormat(args, fArr) {
        const fractionCount = this.findDecimalPlaces(args.format);
        const wholeCount = (fArr[0].split('0').length - 1) + (fArr[0].split('#').length - 1);
        const formattedVal = Number(args.value).toExponential(fractionCount + wholeCount);
        let expoSeparator;
        if (formattedVal.includes('e+')) {
            expoSeparator = 'e+';
        }
        else if (formattedVal.includes('e-')) {
            expoSeparator = 'e-';
        }
        else {
            return formattedVal;
        }
        const exponentArr = formattedVal.split(expoSeparator);
        const decimalArr = exponentArr[0].split('.');
        const exponent = Number(exponentArr[1]);
        let fractionDiff;
        if (expoSeparator === 'e-') {
            const expoVal = exponent + Math.abs(exponent - (wholeCount * (exponent > wholeCount ? 2 : 1)));
            fractionDiff = expoVal - exponent;
            exponentArr[1] = expoVal.toString();
        }
        else {
            fractionDiff = exponent % wholeCount;
            exponentArr[1] = (exponent - fractionDiff).toString();
        }
        if (fractionDiff > 0) {
            decimalArr[0] += decimalArr[1].substring(0, fractionDiff);
            decimalArr[1] = decimalArr[1].slice(fractionDiff);
            exponentArr[0] = decimalArr.join('.');
        }
        const base = Number('1' + '0'.repeat(fractionCount));
        return this.getFormattedNumber(fArr.join('.'), Number((Math.round(Number(exponentArr[0]) * base) / base).toFixed(fractionCount))) +
            expoSeparator.toUpperCase() + this.findSuffix(args.format.split('+')[1], exponentArr[1]);
    }
    scientificFormat(args, prefix) {
        if (!args.format) {
            args.format = getFormatFromType('Scientific');
        }
        const zeros = args.format.split('+')[1] || '00';
        if (prefix === undefined) {
            prefix = this.findDecimalPlaces(args.format);
        }
        let fResult = Number(args.value).toExponential(prefix);
        if (fResult.indexOf('e+') > -1) {
            fResult = fResult.split('e+')[0] + 'E+' + this.findSuffix(zeros, fResult.split('e+')[1]);
        }
        else if (fResult.indexOf('e-') > -1) {
            fResult = fResult.split('e-')[0] + 'E-' + this.findSuffix(zeros, fResult.split('e-')[1]);
        }
        return fResult.replace('.', this.localeObj.decimal);
    }
    fractionFormat(args) {
        let fractionResult;
        args.format = args.format || getFormatFromType('Fraction');
        this.checkAndSetColor(args);
        const valueArr = args.value.toString().split('.');
        const fractionDigit = args.format.split('?').length / 2;
        const formatArr = args.format.split(' ');
        const fractionArr = formatArr[1] ? formatArr[1].split('/') : [];
        if (/^\?{1,3}\/\?{1,3}$|^\?\/[248]$|^\?\?\/16$/.test(formatArr[1])) {
            if (valueArr.length === 2 && !valueArr[1].startsWith('0'.repeat(fractionArr[1].trim().length || 0))) {
                let [numerator, denominator, minError] = [0, 1, Number.MAX_VALUE];
                const denominatorLimit = fractionArr[1].includes('?') ?
                    Number('9'.repeat(fractionArr[1].split('?').length - 1)) : Number(fractionArr[1]);
                const decimalPart = parseFloat(`0.${valueArr[1]}`);
                for (let tempDenom = 1; tempDenom <= denominatorLimit; tempDenom++) {
                    const tempNumer = Math.round(decimalPart * tempDenom);
                    const error = Math.abs(decimalPart - tempNumer / tempDenom);
                    if (error < minError) {
                        [numerator, denominator, minError] = [tempNumer, tempDenom, error];
                    }
                }
                const gcd = getGcd(numerator, denominator);
                [numerator, denominator] = [numerator / gcd, denominator / gcd];
                if (numerator === denominator) {
                    valueArr[0] = `${parseInt(valueArr[0], 10) + 1}`;
                }
                else if (numerator !== 0) {
                    fractionResult = `${numerator}/${denominator}`;
                }
            }
        }
        else if (valueArr.length === 2 && !valueArr[1].startsWith('0'.repeat(fractionDigit))) {
            fractionResult = toFraction(Number(args.value));
        }
        let suffixVal = this.getFormattedNumber(formatArr[0], Math.abs(Number(valueArr[0])));
        if (fractionResult) {
            suffixVal = suffixVal === '0' ? '' : suffixVal;
            return `${(Number(args.value) < 0 ? '-' : '') + suffixVal} ${fractionResult}`;
        }
        else {
            return `${(Number(args.value) < 0 ? '-' : '') + suffixVal} ${'  '.repeat(fractionDigit * 2)}`;
        }
    }
    checkAndSetColor(args) {
        const colorCode = getColorCode(args.format);
        if (colorCode) {
            args.format = args.format.split(`[${colorCode}]`).join('');
            args.color = colorCode.toLowerCase();
            this.applyColor(args);
        }
    }
    findDecimalPlaces(code) {
        const eIndex = code.toUpperCase().indexOf('E');
        if (eIndex > -1) {
            let decIndex = code.indexOf(this.localeObj.decimal);
            if (decIndex === -1 && this.localeObj.decimal !== '.') {
                decIndex = code.indexOf('.');
            }
            return decIndex > 0 ? code.substring(decIndex + 1, eIndex).length : 0;
        }
        return 2;
    }
    checkDateFormat(args) {
        if (isNullOrUndefined(args.value)) {
            return;
        }
        const cell = args.cell || getCell(args.rowIndex, args.colIndex, getSheet(this.parent, isNullOrUndefined(args.sheetIndex) ? this.parent.activeSheetIndex : args.sheetIndex), false, true);
        const cellFormat = cell.format;
        if (this.parent.isEdit && getTypeFromFormat(cell.format) === 'Scientific') {
            cell.format = '';
        }
        const props = this.checkCustomDateFormat(args.value.toString(), cell, args.isEdit);
        if (props.val !== 'Invalid') {
            let noOfDays;
            if (props.format.startsWith('[h]')) {
                const timeArr = props.val.split(':');
                if (timeArr.length > 1 && Number(timeArr[0]) >= 24) {
                    noOfDays = Number(timeArr[0]) / 24;
                    timeArr[0] = '24';
                    props.val = timeArr.join(':');
                }
            }
            const dateObj = toDate(props.val, args.intl || new Internationalization(this.parent.locale), this.parent.locale, props.format || args.format, args.skipCellFormat && cell, props.isDateTime);
            if (dateObj.dateObj && dateObj.dateObj.toString() !== 'Invalid Date') {
                const year = dateObj.dateObj.getFullYear();
                if (year >= 1900 && year <= 9999) {
                    args.isTime = dateObj.type === 'time';
                    let dateIntVal = dateToInt(dateObj.dateObj, props.val.includes(':'), args.isTime);
                    if (noOfDays >= 1) {
                        dateIntVal += noOfDays;
                        dateObj.dateObj = intToDate(dateIntVal);
                    }
                    props.val = dateIntVal.toString();
                    if (!cell.format || cell.format === 'General') {
                        if (args.isTime) {
                            cell.format = getFormatFromType('Time');
                        }
                        else {
                            cell.format = getFormatFromType('ShortDate');
                        }
                        if (args.updateValue) {
                            cell.value = props.val;
                            return;
                        }
                    }
                    args.isDate = dateObj.type === 'date' || dateObj.type === 'datetime';
                    args.dateObj = dateObj.dateObj;
                }
                args.updatedVal = props.val;
            }
        }
        else if (cellFormat) {
            cell.format = cellFormat;
        }
    }
    checkCustomTimeFormat(val, cell) {
        let format = [];
        const am = ` ${this.localeObj.am}`;
        const pm = ` ${this.localeObj.pm}`;
        let isTewlveHr = val.includes(am) || val.includes(pm);
        if (!isTewlveHr) {
            if (val.includes(am.toLowerCase()) || val.includes(pm.toLowerCase())) {
                val = val.replace(am.toLowerCase(), am).replace(pm.toLowerCase(), pm);
                isTewlveHr = true;
            }
        }
        const timeArr = val.split(this.localeObj.timeSeparator);
        const isDefaultTime = timeArr.length === 3 && isTewlveHr;
        let twelveHrRep;
        if (timeArr.length <= 3) {
            let timeProp;
            let valArr;
            const maxHour = isTewlveHr ? 12 : 23;
            timeArr.forEach((timeVal, index) => {
                timeVal = timeVal.trim();
                timeArr[index] = timeVal;
                if (timeVal.includes(am) || timeVal.includes(pm)) {
                    twelveHrRep = ' AM/PM';
                    timeVal = timeVal.replace(am, '').replace(pm, '');
                }
                else {
                    twelveHrRep = '';
                }
                timeProp = Number(timeVal);
                if (isNumber(timeProp) && timeProp >= 0) {
                    if (timeProp >= 24 && index === 0 && timeArr.length > 1) {
                        format.push('[h]');
                    }
                    else if (timeProp <= maxHour && index === 0) {
                        format.push('h' + twelveHrRep);
                        if (timeArr.length === 1) {
                            if (twelveHrRep) {
                                valArr = val.split(' ');
                                valArr[0] += `${this.localeObj.timeSeparator}00`;
                                timeArr[0] = valArr.join(' ');
                            }
                            else {
                                format = [];
                                val = 'Invalid';
                            }
                        }
                    }
                    else if (timeProp <= 60 && (format.length === 1 || format.length === 2)) {
                        if (format.length === 1) {
                            format.push('mm' + twelveHrRep);
                            if (timeArr.length === 2 && format[0] === '[h]') {
                                format.push('ss');
                            }
                        }
                        else {
                            format.push('ss');
                        }
                        if (timeVal.length === 1) {
                            timeArr[index] = `0${timeArr[index]}`;
                        }
                    }
                    else {
                        format = [];
                        val = 'Invalid';
                    }
                }
                else {
                    format = [];
                    val = 'Invalid';
                }
            });
        }
        else {
            val = 'Invalid';
        }
        if (format.length) {
            val = timeArr.join(this.localeObj.timeSeparator);
            let formatCode;
            if (isDefaultTime) {
                formatCode = this.customFormats[24];
            }
            else {
                formatCode = format.join(':');
                if (defaultFormats) {
                    formatCode = this.getMatchingCustomFormat(formatCode);
                }
            }
            if (!cell.format || cell.format === 'General') {
                cell.format = formatCode;
                return { val: val, format: formatCode };
            }
        }
        return { val: val, format: '' };
    }
    checkCustomDateFormat(val, cell, isEdit) {
        let separator;
        const cellFormat = cell.format;
        let timeArgs;
        if (val.includes(this.localeObj.dateSeparator) && ((!val.includes(` ${this.localeObj.am}`) &&
            !val.includes(` ${this.localeObj.pm}`)) ||
            val.replace(` ${this.localeObj.am}`, '').replace(` ${this.localeObj.pm}`, '').includes(this.localeObj.dateSeparator))) {
            separator = this.localeObj.dateSeparator;
        }
        else if (val.indexOf('-') > 0) {
            separator = '-';
        }
        else if (val.indexOf(',') > 0) {
            const intl = new Internationalization(this.parent.locale);
            const parsedDate = intl.parseDate(val, { skeleton: 'full' });
            if (parsedDate && !isNaN(parsedDate.getTime())) {
                return { val: val, format: '', isDateTime: false };
            }
            return { val: 'Invalid', format: '' };
        }
        else {
            if (val.includes(this.localeObj.timeSeparator) || val.includes(` ${this.localeObj.am}`) ||
                val.includes(` ${this.localeObj.pm}`)) {
                return this.checkCustomTimeFormat(val, cell);
            }
            return { val: 'Invalid', format: '' };
        }
        if (val.includes(this.localeObj.timeSeparator) && val.includes(' ')) {
            const valArr = val.split(' ');
            val = valArr.shift();
            timeArgs = this.checkCustomTimeFormat(valArr.join(' '), cell);
            if (timeArgs.val === 'Invalid') {
                return { val: 'Invalid', format: '' };
            }
        }
        const dateArr = val.split(separator);
        let format = '';
        const formatArr = [];
        const updateFormat = (defaultCode) => {
            format = formatArr.join(separator);
            if (!cellFormat || cellFormat === 'General') {
                cell.format = defaultCode;
            }
        };
        let firstVal;
        const formats = IntlBase.getDependables(cldrData, this.parent.locale, null).dateObject;
        const months = formats.months['stand-alone'] ? formats.months['stand-alone'].wide : {};
        const abbreviatedMonth = formats.months['stand-alone'] ? formats.months['stand-alone'].abbreviated : { '1': '' };
        const enUSMonth = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const isMonth = (monthValue, monthKey, dateVal, dateLength) => {
            if (abbreviatedMonth[`${monthKey}`] && abbreviatedMonth[`${monthKey}`].toLowerCase() === dateVal) {
                firstVal = enUSMonth[Number(monthKey) - 1];
                return;
            }
            const shortMonthValue = monthValue.substring(0, dateLength);
            if (shortMonthValue === dateVal) {
                firstVal = enUSMonth[Number(monthKey) - 1];
            }
        };
        if (dateArr.length === 2) {
            const updateSecValue = (secVal) => {
                val = firstVal;
                formatArr[0] = 'MMM';
                if (Number(secVal) <= 31 && Number(secVal) > 0) {
                    val = secVal + separator + val;
                    if (this.localeObj.dateSeparator !== '/' && separator !== '-') {
                        val += separator + new Date().getFullYear();
                    }
                    formatArr.splice(0, 0, 'dd');
                    updateFormat(this.customFormats[21]);
                }
                else {
                    if (secVal.length === 2 && isNumber(secVal) && Number(secVal) > -1) {
                        secVal = (Number(secVal) < 30 ? new Date().getFullYear().toString().slice(0, 2) : '19') + secVal;
                    }
                    if (Number(secVal) >= 1900 && Number(secVal) <= 9999) {
                        val = '1' + separator + val + separator + secVal;
                        formatArr[1] = 'yyyy';
                        updateFormat(this.customFormats[22]);
                    }
                    else {
                        val = 'Invalid'; //Set as Invalid for invalid data like May-June.
                    }
                }
            };
            dateArr[0] = dateArr[0].toLowerCase().trim();
            dateArr[1] = dateArr[1].toLowerCase().trim();
            if (!Number(dateArr[0]) && dateArr[0].length >= abbreviatedMonth['1'].length) {
                Object.keys(months).find((key) => isMonth(months[`${key}`].toLowerCase(), key, dateArr[0], dateArr[0].length));
                if (!isNullOrUndefined(firstVal) && !dateArr[0].includes(',')) { // Added ',' checking to skip updating for the MMM d, yyyy ddd format.
                    updateSecValue(dateArr[1]);
                }
            }
            else if (!Number(dateArr[1]) && dateArr[1].length >= abbreviatedMonth['1'].length) {
                Object.keys(months).find((key) => isMonth(months[`${key}`].toLowerCase(), key, dateArr[1], dateArr[1].length));
                if (!isNullOrUndefined(firstVal)) {
                    updateSecValue(dateArr[0]);
                }
            }
            else if (Number(dateArr[0]) && Number(dateArr[0]) <= 12 && Number(dateArr[1]) && (this.localeObj.dateSeparator === '/' ||
                separator === '-' || (isEdit && !cell.formula))) {
                firstVal = enUSMonth[Number(dateArr[0]) - 1];
                updateSecValue(dateArr[1]);
            }
            if (!formatArr.length) {
                val = 'Invalid';
            }
        }
        else if (dateArr.length > 2) {
            for (let i = 0; i < dateArr.length; i++) {
                if (isNumber(dateArr[i])) {
                    if (dateArr[i].length !== 4 && dateArr[i].length !== 2 && dateArr[i].length !== 1) {
                        val = 'Invalid';
                    }
                }
                else {
                    dateArr[i] = dateArr[i].trim();
                    Object.keys(months).find((key) => isMonth(months[`${key}`].toLowerCase(), key, dateArr[i].trim().toLowerCase(), dateArr[i].length));
                    if (!isNullOrUndefined(firstVal)) {
                        if (i === 1) {
                            formatArr[1] = 'MMM';
                            dateArr[2] = dateArr[2].trim();
                            if (dateArr[2].length === 2 && isNumber(dateArr[2]) && Number(dateArr[2]) > -1) {
                                dateArr[2] = (Number(dateArr[2]) < 30 ? new Date().getFullYear().toString().slice(0, 2) : '19') + dateArr[2];
                            }
                            if (Number(dateArr[0]) <= 31 && Number(dateArr[2]) >= 1900 && Number(dateArr[2]) <= 9999) {
                                val = dateArr[0] + separator + firstVal;
                                val += (separator + dateArr[2]);
                                formatArr[0] = 'd';
                                formatArr[2] = 'yy';
                                updateFormat(this.customFormats[20]);
                                // Changed year format alone when given year value with 4 digits like 20-May-2022
                                formatArr[2] = 'yyyy';
                                format = formatArr.join(separator);
                            }
                        }
                    }
                    else {
                        val = 'Invalid';
                    }
                }
            }
        }
        let isDateTime;
        if (timeArgs && val !== 'Invalid') {
            if (!cellFormat || cellFormat === 'General') {
                cell.format = this.customFormats[27];
            }
            if (format && timeArgs.format) {
                format += ` ${timeArgs.format}`;
            }
            val += ` ${timeArgs.val}`;
            isDateTime = true;
        }
        return { val: val, format: format, isDateTime: isDateTime };
    }
    formattedBarText(args) {
        if (args.value === '' || isNullOrUndefined(args.value)) {
            return;
        }
        const option = {};
        const format = (args.cell && args.cell.format) || '';
        let type = args.type || (format && isCustomDateTime(format, true, option, true) ? option.type : '');
        const intl = new Internationalization();
        const beforeText = args.value;
        const date = args.showFormattedText && (format === 'dd-MM-yyyy' || format === 'dd/MM/yyyy') ? format :
            getFormatFromType('ShortDate');
        let time = getFormatFromType('Time');
        if (time === 'h:mm:ss AM/PM') {
            time = 'h:mm:ss a';
        }
        const timeFormat = format.toLowerCase();
        const parseOtherCultureNumber = () => {
            if (this.localeObj.decimal !== '.' && args.value) {
                args.value = args.value.toString();
                if (isNumber(args.value) && args.value.includes('.')) {
                    args.value = args.value.replace('.', this.localeObj.decimal);
                }
            }
        };
        if (type === 'time' && timeFormat.includes('m') && !timeFormat.includes(':m') && !timeFormat.includes('m:') &&
            !timeFormat.includes('[m') && !timeFormat.includes('am')) {
            type = 'date';
        }
        if (type === 'date') {
            const val = args.value.toString();
            args.value = this.shortDateFormat({ type: type, value: args.value, format: date }, intl, args.cell);
            if (args.value && val.includes('.')) {
                args.value += ` ${this.timeFormat({ type: type, value: val, format: time }, intl)}`;
            }
        }
        else if (type.includes('time')) {
            if (beforeText && Number(beforeText) >= 1 || type === 'datetime') {
                args.value = this.shortDateFormat({ type: type, value: args.value, format: date }, intl) + ' ' +
                    this.timeFormat({ type: type, value: args.value, format: time }, intl);
            }
            else {
                args.value = this.timeFormat({ type: type, value: args.value, format: time }, intl);
            }
        }
        else if (args.cell.format && args.cell.format.includes('%') && isNumber(args.cell.value)) {
            args.value = this.parent.getDisplayText(args.cell);
            if (!args.value.includes('%')) {
                args.value = beforeText;
                parseOtherCultureNumber();
            }
        }
        else {
            parseOtherCultureNumber();
        }
        if (!args.value || (args.value && args.value.toString().indexOf('null') > -1)) {
            args.value = beforeText;
        }
    }
    getFormattedNumber(format, value) {
        return new Internationalization().formatNumber(Number(value), { format: format }) || '';
    }
    getMatchingCustomFormat(format) {
        if (format === '#,##0_);(#,##0)' && defaultFormats.has(37)) {
            return defaultFormats.get(37);
        }
        else if (format === '#,##0_);[Red](#,##0)' && defaultFormats.has(38)) {
            return defaultFormats.get(38);
        }
        else if (format === '#,##0.00_);(#,##0.00)' && defaultFormats.has(39)) {
            return defaultFormats.get(39);
        }
        else if (format === '#,##0.00_);[Red](#,##0.00)' && defaultFormats.has(40)) {
            return defaultFormats.get(40);
        }
        else if (format === 'd-mmm-yy' && defaultFormats.has(15)) {
            return defaultFormats.get(15);
        }
        else if (format === 'd-mmm' && defaultFormats.has(16)) {
            return defaultFormats.get(16);
        }
        else if (format === 'mmm-yy' && defaultFormats.has(17)) {
            return defaultFormats.get(17);
        }
        else if (format === 'h:mm AM/PM' && defaultFormats.has(18)) {
            return defaultFormats.get(18);
        }
        else if (format === 'h:mm:ss AM/PM' && defaultFormats.has(19)) {
            return defaultFormats.get(19);
        }
        else if (format === 'h:mm' && defaultFormats.has(20)) {
            return defaultFormats.get(20);
        }
        else if (format === 'h:mm:ss' && defaultFormats.has(21)) {
            return defaultFormats.get(21);
        }
        else if (format === 'm/d/yyyy h:mm' && defaultFormats.has(22)) {
            return defaultFormats.get(22);
        }
        else if (format === 'mm:ss' && defaultFormats.has(45)) {
            return defaultFormats.get(45);
        }
        else {
            return format;
        }
    }
    /**
     * Adding event listener for number format.
     *
     * @returns {void} - Adding event listener for number format.
     */
    addEventListener() {
        this.parent.on(applyNumberFormatting, this.numberFormatting, this);
        this.parent.on(getFormattedCellObject, this.getFormattedCell, this);
        this.parent.on(checkDateFormat, this.checkDateFormat, this);
        this.parent.on(getFormattedBarText, this.formattedBarText, this);
        this.parent.on(checkNumberFormat, this.updateAutoDetectNumberFormat, this);
        this.parent.on(parseDecimalNumber, this.parseDecimalNumber, this);
        this.parent.on(localizedFormatAction, this.localizedFormatAction, this);
    }
    /**
     * Removing event listener for number format.
     *
     * @returns {void} -  Removing event listener for number format.
     */
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(applyNumberFormatting, this.numberFormatting);
            this.parent.off(getFormattedCellObject, this.getFormattedCell);
            this.parent.off(checkDateFormat, this.checkDateFormat);
            this.parent.off(getFormattedBarText, this.formattedBarText);
            this.parent.off(checkNumberFormat, this.updateAutoDetectNumberFormat);
            this.parent.off(parseDecimalNumber, this.parseDecimalNumber);
            this.parent.off(localizedFormatAction, this.localizedFormatAction);
        }
    }
    /**
     * To Remove the event listeners.
     *
     * @returns {void} - To Remove the event listeners.
     */
    destroy() {
        this.removeEventListener();
        if (defaultFormats && !this.parent.refreshing) {
            defaultFormats.clear();
            defaultFormats = null;
        }
        numberFormatsCode = this.parent = this.localeObj = this.customFormats = this.localizedFormats = null;
    }
    /**
     * Get the workbook number format module name.
     *
     * @returns {string} - Get the module name.
     */
    getModuleName() {
        return 'workbookNumberFormat';
    }
}
let defaultFormats;
let numberFormatsCode;
/**
 * Retrieves the built-in format code based on the specified number format type in either localized or non-localized format.
 *
 * @param {string} type - Specifies the type of number formatting.
 * @returns {string} - The built-in format code for the specified number format type.
 */
function getFormatFromType(type) {
    const formatType = type.split(' ').join('');
    if (!numberFormatsCode) {
        switch (formatType) {
            case 'Currency':
                return '$#,##0.00';
            case 'Accounting':
                return '_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)';
            case 'Time':
                return 'h:mm:ss AM/PM';
            default:
                return 'General';
        }
    }
    const getDefaultFormat = (format, id) => {
        return defaultFormats && defaultFormats.has(id) ? defaultFormats.get(id) : format;
    };
    let code = 'General';
    switch (formatType) {
        case 'Number':
            code = getDefaultFormat('0.00', 2);
            break;
        case 'Currency':
            code = numberFormatsCode.currency[0];
            break;
        case 'Accounting':
            code = numberFormatsCode.accounting[2];
            break;
        case 'ShortDate':
            code = getDefaultFormat('m/d/yyyy', 14);
            break;
        case 'LongDate':
            code = 'dddd, mmmm dd, yyyy';
            break;
        case 'Time':
            code = numberFormatsCode.time;
            break;
        case 'Percentage':
            code = getDefaultFormat('0.00%', 10);
            break;
        case 'Fraction':
            code = getDefaultFormat('# ?/?', 12);
            break;
        case 'Scientific':
            code = getDefaultFormat('0.00E+00', 11);
            break;
        case 'Text':
            code = getDefaultFormat('@', 49);
            break;
        case 'CurrencyWithColorCode':
            code = numberFormatsCode.currency[5];
            break;
    }
    return code;
}
/**
 * @hidden
 * @param {string} format -  Specidfies the format.
 * @param {boolean} isRibbonUpdate - Specifies where we are updating the type in the number format button.
 * @returns {string} - To get type from format.
 */
function getTypeFromFormat(format, isRibbonUpdate) {
    let code = 'General';
    switch (format) {
        case '0':
        case '0.00':
        case '#,##0':
        case '#,##0.00':
            code = 'Number';
            break;
        case '$#,##0.00':
        case '$#,##0':
        case '$#,##0_);[Red]($#,##0)':
        case '$#,##0.00_);($#,##0.00)':
        case '$#,##0_);($#,##0)':
        case '$#,##0.00_);[Red]($#,##0.00)':
            code = 'Currency';
            break;
        case '_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)':
        case '_ $ * #,##0.00_ ;_ $ * -#,##0.00_ ;_ $ * "-"??_ ;_ @_ ':
        case '_($* #,##0_);_($* (#,##0);_($* "-"_);_(@_)':
            code = 'Accounting';
            break;
        case 'mm-dd-yyyy':
        case 'm/d/yyyy':
        case 'dd/MM/yyyy':
            code = 'ShortDate';
            break;
        case 'dddd, mmmm dd, yyyy':
            code = 'LongDate';
            break;
        case 'h:mm:ss AM/PM':
            code = 'Time';
            break;
        case '0.00%':
        case '0%':
            code = 'Percentage';
            break;
        case '0.00E+00':
            code = 'Scientific';
            break;
        case '@':
            code = 'Text';
            break;
        default:
            if (format) {
                if (!numberFormatsCode) {
                    break;
                }
                if (format === numberFormatsCode.time) {
                    code = 'Time';
                }
                else if (numberFormatsCode.currency.indexOf(format) > -1) {
                    code = 'Currency';
                }
                else if (numberFormatsCode.accounting.indexOf(format) > -1) {
                    if (isRibbonUpdate) {
                        code = 'Accounting';
                    }
                }
                else if (format.includes('?/?') || ['2', '4', '8', '16'].indexOf(format.split('?/')[1]) > -1) {
                    code = 'Fraction';
                }
                if (defaultFormats && code === 'General' && isRibbonUpdate) {
                    const isDefaultFormat = (ids) => {
                        return ids.some((id) => defaultFormats.has(id) && defaultFormats.get(id) === format);
                    };
                    if (isDefaultFormat([1, 2, 3, 4])) {
                        code = 'Number';
                    }
                    else if (isDefaultFormat([14])) {
                        code = 'ShortDate';
                    }
                    else if (isDefaultFormat([9, 10])) {
                        code = 'Percentage';
                    }
                    else if (isDefaultFormat([11])) {
                        code = 'Scientific';
                    }
                    else if (isDefaultFormat([49])) {
                        code = 'Text';
                    }
                }
                isRibbonUpdate = false;
            }
            break;
    }
    if (isRibbonUpdate && numberFormatsCode && ((code === 'Currency' && numberFormatsCode.currency[0] !== '$#,##0.00') ||
        (code === 'Accounting' && numberFormatsCode.accounting[2] !== '_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)'))) {
        code = 'General';
    }
    return code;
}
/**
 * This method converts a culture-specific format code, which may include localized decimal separators, group separators, and
 * currency symbols, to a default culture (en-US) format code. The default format uses a default decimal separator (.),
 * group separators (,), and a currency symbol.
 *
 * @param {Workbook} context - Specifies the workbook instance containing the format code to be converted.
 * @param {string} format - The culture-specific format code, with localized decimal separators, group separators, and currency symbols,
 * that needs to be converted to the default format.
 * @returns {string} - Returns the default culture (en-US) format code, using the default decimal separator (.), group separators (,), and
 * currency symbol.
 */
function convertToDefaultFormat(context, format) {
    const eventArgs = { action: 'parseToDefaultFormat', format: format };
    context.notify(localizedFormatAction, eventArgs);
    return eventArgs.format;
}
/**
 * Populates culture-based number formats in the custom format dialog. By default, the decimal separator, group separator, and
 * currency symbol are updated based on the current culture. Currency and date formats can vary across cultures.
 * Excel maintains a default number format ID for each format code in the custom format dialog. This method maps these culture-based
 * format codes to their corresponding number format IDs, and the mapped formats will be populated in the custom format dialog.
 *
 * @param {Workbook} context - Specifies the workbook instance. If the component is not initialized, pass null for this parameter.
 * @param {FormatOption[]} formatOptions - Specifies the collection of number format IDs and their corresponding format codes.
 * @param {boolean} [clearMappedFormats] - Specifies whether to clear existing mapped formats or not. By default, this is set to true.
 * @returns {void}
 */
function configureLocalizedFormat(context, formatOptions, clearMappedFormats = true) {
    if (clearMappedFormats && defaultFormats) {
        defaultFormats.clear();
        defaultFormats = null;
    }
    if (formatOptions && formatOptions.length) {
        if (!defaultFormats) {
            defaultFormats = new Map();
        }
        formatOptions.forEach((format) => {
            defaultFormats.set(format.id, format.code);
        });
    }
    if (context) {
        context.notify(localizedFormatAction, { action: 'mapNumberFormatId' });
    }
}

/**
 * The `WorkbookSort` module is used to handle sort action in Spreadsheet.
 */
class WorkbookSort {
    /**
     * Constructor for WorkbookSort module.
     *
     * @param {Workbook} parent - Specifies the workbook.
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * To destroy the sort module.
     *
     * @returns {void} - To destroy the sort module.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(initiateSort, this.initiateSortHandler, this);
        this.parent.on(updateSortedDataOnCell, this.updateSortedDataOnCell, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(initiateSort, this.initiateSortHandler);
            this.parent.off(updateSortedDataOnCell, this.updateSortedDataOnCell);
        }
    }
    /**
     * Sorts range of cells in the sheet.
     *
     * @param {{ args: BeforeSortEventArgs, promise: Promise<SortEventArgs> }} eventArgs - Specify the arguments.
     * @param {BeforeSortEventArgs} eventArgs.args - arguments for sorting.
     * @param {Promise<SortEventArgs>} eventArgs.promise - Specify the promise.
     * @param {SortCollectionModel} eventArgs.previousSort - Specify the previous sort model.
     * @returns {void} - Sorts range of cells in the sheet.
     */
    initiateSortHandler(eventArgs) {
        const args = eventArgs.args;
        const deferred = new Deferred();
        const addressInfo = this.parent.getAddressInfo(args.range);
        const sheet = getSheet(this.parent, addressInfo.sheetIndex);
        let range = getSwapRange(addressInfo.indices);
        const sortOptions = args.sortOptions || { sortDescriptors: {}, containsHeader: true };
        let isSingleCell = false;
        eventArgs.promise = deferred.promise;
        if (range[0] > sheet.usedRange.rowIndex || range[1] > sheet.usedRange.colIndex) {
            deferred.reject(this.parent.serviceLocator.getService(workbookLocale).getConstant('SortOutOfRangeError'));
            return;
        }
        let containsHeader = sortOptions.containsHeader;
        const checkForHeader = args.checkForHeader;
        if (range[0] === range[2] || checkForHeader) { //if selected range is a single cell
            if (!checkForHeader) {
                range = getDataRange(range[0], range[1], sheet);
            }
            isSingleCell = true;
            if (isNullOrUndefined(sortOptions.containsHeader)) {
                if (typeof getCell(range[0], range[1], sheet, null, true).value ===
                    typeof getCell(range[0] + 1, range[1], sheet, null, true).value) {
                    containsHeader = this.isSameStyle(getCell(range[0], range[1], sheet, null, true).style, getCell(range[0] + 1, range[1], sheet, null, true).style) ? this.isHeaderRow(sheet, range) : true;
                }
                else {
                    containsHeader = true;
                }
            }
        }
        if ((isNullOrUndefined(args.sortOptions) || isNullOrUndefined(args.sortOptions.containsHeader)) && !isSingleCell) {
            const firstCell = getCell(range[0], range[1], sheet);
            const secondCell = getCell(range[0] + 1, range[1], sheet);
            if (firstCell && secondCell) {
                if (typeof firstCell.value === typeof secondCell.value) {
                    containsHeader = !this.isSameStyle(firstCell.style, secondCell.style) || this.isHeaderRow(sheet, range);
                }
                else {
                    containsHeader = true;
                }
            }
        }
        range[0] = containsHeader ? range[0] + 1 : range[0];
        const cell = getCellIndexes(sheet.activeCell);
        let header = getColumnHeaderText(cell[1] + 1);
        delete sortOptions.containsHeader;
        let sortDescriptors = sortOptions.sortDescriptors;
        const query = new Query();
        if (Array.isArray(sortDescriptors)) { //multi-column sorting.
            if (!sortDescriptors || sortDescriptors.length === 0) {
                sortDescriptors = [{ field: header }];
            }
            for (let length = sortDescriptors.length, i = length - 1; i > -1; i--) {
                if (!sortDescriptors[length - 1].field) {
                    sortDescriptors[length - 1].field = header;
                }
                if (!sortDescriptors[i].field) {
                    continue;
                }
                const comparerFn = sortDescriptors[i].sortComparer
                    || this.sortComparer.bind(this, sortDescriptors[i], sortOptions.caseSensitive);
                query.sortBy(sortDescriptors[i].field, comparerFn);
                header = sortDescriptors[i].field;
            }
        }
        else { //single column sorting.
            if (!sortDescriptors) {
                sortDescriptors = { field: header };
            }
            if (!sortDescriptors.field) {
                sortDescriptors.field = header;
            }
            const comparerFn = sortDescriptors.sortComparer
                || this.sortComparer.bind(this, sortDescriptors, sortOptions.caseSensitive);
            query.sortBy(sortDescriptors.field, comparerFn);
            header = sortDescriptors.field;
        }
        const address = getRangeAddress(range);
        getData(this.parent, `${sheet.name}!${address}`, true, null, null, null, null, null, undefined, null, getColIndex(header)).then((jsonData) => {
            const dataManager = new DataManager(jsonData);
            if (jsonData.length === 1 && (jsonData[0].throwMergeAlert)) {
                const sortModel = this.parent.sortCollection &&
                    this.parent.sortCollection[this.parent.sortCollection.length - 1];
                if (sortModel) {
                    let prevSortModel;
                    if (eventArgs.previousSort && eventArgs.previousSort.length) {
                        for (let i = 0; i < eventArgs.previousSort.length; i++) {
                            const sort = eventArgs.previousSort[i];
                            if (sortModel.sheetIndex === sort.sheetIndex) {
                                prevSortModel = sort;
                            }
                        }
                    }
                    if (prevSortModel) {
                        sortModel.columnIndex = prevSortModel.columnIndex;
                        sortModel.order = prevSortModel.order;
                        sortModel.sortRange = prevSortModel.sortRange;
                    }
                    else {
                        this.parent.sortCollection.pop();
                    }
                    this.parent.notify(refreshFilterRange, null);
                }
                deferred.reject(this.parent.serviceLocator.getService(workbookLocale).getConstant('AutoFillMergeAlertMsg'));
                return;
            }
            dataManager.executeQuery(query).then((e) => {
                this.parent.notify('setActionData', { args: { action: 'beforeSort', eventArgs: { range: address, cellDetails: jsonData, sortedCellDetails: e.result } } });
                this.updateSortedDataOnCell({ result: e.result, range: range, sheet: sheet, jsonData: jsonData });
                const sortArgs = { range: `${sheet.name}!${address}`, sortOptions: args.sortOptions };
                if (eventArgs.previousSort) {
                    sortArgs.previousSort = eventArgs.previousSort;
                }
                deferred.resolve(sortArgs);
            });
        });
    }
    isHeaderRow(sheet, range) {
        if (!sheet.ranges || !sheet.ranges.length) {
            return false;
        }
        return sheet.ranges.some((rangeItem) => {
            if (!rangeItem.dataSource || !rangeItem.showFieldAsHeader) {
                return false;
            }
            const startCellIndexes = getCellIndexes(rangeItem.startCell);
            return startCellIndexes[0] === range[0] && startCellIndexes[1] >= range[1] && startCellIndexes[1] <= range[3];
        });
    }
    updateSortedDataOnCell(args) {
        const fields = [];
        let cell;
        const updateCell = (rowIdx, data) => {
            for (let j = args.range[1], k = 0; j <= args.range[3]; j++, k++) {
                if (!fields[k]) {
                    fields[k] = getColumnHeaderText(j + 1);
                }
                if (data[fields[k]]) {
                    cell = extend({}, data[fields[k]], null, true);
                }
                else {
                    if (!getCell(rowIdx, j, args.sheet)) {
                        continue;
                    }
                    cell = null;
                }
                cell = this.skipBorderOnSorting(rowIdx, j, args.sheet, cell);
                if (cell && cell.validation) {
                    delete cell.validation;
                }
                const existingCell = getCell(rowIdx, j, args.sheet);
                if (existingCell) {
                    if (existingCell.validation) {
                        cell = Object.assign({}, cell, { validation: existingCell.validation }); // To preserve validation settings
                    }
                    if (existingCell.wrap) {
                        wrap(getCellAddress(rowIdx, j), false, this.parent);
                    }
                }
                if (cell && cell.formula) {
                    cell.formula = getUpdatedFormula([rowIdx, j], [parseInt(data['__rowIndex'], 10) - 1, j], args.sheet, this.parent, cell, true);
                }
                setCell(rowIdx, j, args.sheet, cell);
            }
        };
        const updatedCellDetails = args.isUndo && {};
        let rIdx;
        let result;
        for (let i = args.range[0], idx = 0; i <= args.range[2]; i++, idx++) {
            if (isHiddenRow(args.sheet, i)) {
                idx--;
                continue;
            }
            result = args.result[idx];
            if (args.isUndo) {
                if (result) {
                    rIdx = parseInt(result['__rowIndex'], 10) - 1;
                    updatedCellDetails[rIdx] = true;
                    updateCell(rIdx, result);
                    if (i === rIdx) {
                        continue;
                    }
                }
                if (!updatedCellDetails[i] && args.sheet.rows[i]) {
                    updateCell(i, {});
                }
            }
            else {
                updateCell(i, result || {});
            }
        }
    }
    skipBorderOnSorting(rowIndex, colIndex, sheet, cell) {
        const prevCell = getCell(rowIndex, colIndex, sheet);
        const borders = ['borderBottom', 'borderTop', 'borderRight', 'borderLeft', 'border'];
        if (cell && cell.style) {
            for (const border of borders) {
                delete cell.style[`${border}`];
            }
        }
        if (prevCell && prevCell.style) {
            for (const border of borders) {
                if (prevCell.style[`${border}`]) {
                    if (!cell) {
                        cell = {};
                    }
                    if (!cell.style) {
                        cell.style = {};
                    }
                    cell.style[`${border}`] = prevCell.style[`${border}`];
                }
            }
        }
        return cell;
    }
    isSameStyle(firstCellStyle, secondCellStyle) {
        if (!firstCellStyle) {
            firstCellStyle = {};
        }
        if (!secondCellStyle) {
            secondCellStyle = {};
        }
        let sameStyle = true;
        const keys = Object.keys(firstCellStyle);
        for (let i = 0; i < keys.length; i++) {
            if (firstCellStyle[keys[i]] === secondCellStyle[keys[i]] || this.parent.cellStyle[keys[i]] ===
                firstCellStyle[keys[i]]) {
                sameStyle = true;
            }
            else {
                sameStyle = false;
                break;
            }
        }
        return sameStyle;
    }
    /**
     * Compares the two cells for sorting.
     *
     * @param {SortDescriptor} sortDescriptor - protocol for sorting.
     * @param {boolean} caseSensitive - value for case sensitive.
     * @param {CellModel} x - first cell
     * @param {CellModel} y - second cell
     * @returns {number} - Compares the two cells for sorting.
     */
    sortComparer(sortDescriptor, caseSensitive, x, y) {
        const direction = sortDescriptor.order || '';
        const comparer = DataUtil.fnSort(direction);
        let xVal = x ? x.value : x;
        let yVal = y ? y.value : y;
        if (x && y && (typeof xVal === 'string' || typeof yVal === 'string') && xVal !== '' && yVal !== '') {
            let isXStringVal;
            let isYStringVal;
            if (isNumber(x.value)) { // Imported number values are of string type, need to handle this case in server side
                xVal = parseIntValue(x.value);
                if (x.format !== '@') {
                    x.value = xVal;
                }
                isXStringVal = true;
            }
            if (isNumber(y.value)) {
                yVal = parseIntValue(y.value);
                if (y.format !== '@') {
                    y.value = yVal;
                }
                isYStringVal = true;
            }
            if (!isXStringVal && !isYStringVal) {
                const caseOptions = { sensitivity: caseSensitive ? 'case' : 'base' };
                const collator = new Intl.Collator(this.parent.locale, caseOptions);
                if (!direction || direction.toLowerCase() === 'ascending') {
                    return collator.compare(xVal, yVal);
                }
                else {
                    return collator.compare(xVal, yVal) * -1;
                }
            }
        }
        if (isNullOrUndefined(yVal) || yVal === '') {
            return -1;
        }
        if (isNullOrUndefined(xVal) || xVal === '') {
            return 1;
        }
        return comparer(xVal, yVal);
    }
    /**
     * Gets the module name.
     *
     * @returns {string} - Get the module name.
     */
    getModuleName() {
        return 'workbookSort';
    }
}

/**
 * The `WorkbookFilter` module is used to handle filter action in Spreadsheet.
 */
class WorkbookFilter {
    /**
     * Constructor for WorkbookFilter module.
     *
     * @param {Workbook} parent - Constructor for WorkbookFilter module.
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * To destroy the filter module.
     *
     * @returns {void} - To destroy the filter module.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(initiateFilter, this.initiateFilterHandler, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(initiateFilter, this.initiateFilterHandler);
        }
    }
    /**
     * Filters a range of cells in the sheet.
     *
     * @param { {args: BeforeFilterEventArgs, promise: Promise<FilterEventArgs>}} eventArgs - Specify the event args.
     * @param {BeforeFilterEventArgs} eventArgs.args - arguments for filtering..
     * @param {Promise<FilterEventArgs>} eventArgs.promise - Specify the promise.
     * @param {boolean} eventArgs.refresh - Specify the refresh.
     * @returns {void} - Filters a range of cells in the sheet.
     */
    initiateFilterHandler(eventArgs) {
        const args = eventArgs.args;
        const deferred = new Deferred();
        const sheet = getSheet(this.parent, getSheetIndexFromAddress(this.parent, args.range));
        const filterOptions = args.filterOptions || {};
        eventArgs.promise = deferred.promise;
        if (filterOptions.datasource) {
            this.setFilter(filterOptions.datasource, filterOptions.predicates, args.range, eventArgs.refresh, filterOptions.equalOrPredicates);
            const filterEventArgs = { range: args.range, filterOptions: filterOptions };
            deferred.resolve(filterEventArgs);
        }
        else {
            const range = getSwapRange(getIndexesFromAddress(args.range));
            if (range[0] > sheet.usedRange.rowIndex || range[1] > sheet.usedRange.colIndex) {
                deferred.reject('Select a cell or range inside the used range and try again.');
                return;
            }
            if (range[0] === range[2] && (range[2] - range[0]) === 0) { //if selected range is a single cell
                range[0] = 0;
                range[1] = 0;
                range[3] = sheet.usedRange.colIndex;
            }
            range[2] = sheet.usedRange.rowIndex; //filter range should be till used range.
            range[0] = range[0] + 1; //ignore first row
            const address = getRangeAddress(range);
            getData(this.parent, `${sheet.name}!${address}`, true, true, null, null, null, null, false).then((jsonData) => {
                const dataManager = new DataManager(jsonData);
                this.setFilter(dataManager, filterOptions.predicates, args.range, eventArgs.refresh);
                const filterEventArgs = { range: address, filterOptions: filterOptions };
                deferred.resolve(filterEventArgs);
            });
        }
    }
    /**
     * Hides or unhides the rows based on the filter predicates.
     *
     * @param {DataManager} dataManager - Specify the dataManager.
     * @param {Predicate[]} predicates - Specify the predicates.
     * @param {string} range - Specify the range.
     * @param {boolean} refresh - Specify the refresh.
     * @param {Predicate[]} equalOrPredicates - Specify the equal condition or predicates.
     * @returns {void} - Hides or unhides the rows based on the filter predicates.
     */
    setFilter(dataManager, predicates, range, refresh, equalOrPredicates) {
        if (dataManager && predicates) {
            const jsonData = dataManager.dataSource.json;
            const result = applyPredicates(dataManager, predicates, equalOrPredicates);
            const rowKey = '__rowIndex';
            let sheet;
            let sheetIdx;
            if (range.indexOf('!') > -1) {
                sheetIdx = getSheetIndex(this.parent, range.substring(0, range.lastIndexOf('!')));
                sheet = getSheet(this.parent, sheetIdx);
            }
            else {
                sheet = this.parent.getActiveSheet();
                sheetIdx = getSheetIndex(this.parent, sheet.name);
            }
            if (this.parent.getModuleName() === 'spreadsheet') {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                const parent = this.parent;
                let hide;
                let refreshUI;
                if ((parent.scrollSettings.enableVirtualization && ((sheet.rows || jsonData).length > (parent.viewport.rowCount +
                    (parent.getThreshold('row') * 2))) || sheet.frozenRows || sheet.frozenColumns) || refresh) {
                    jsonData.forEach((data) => {
                        hide = result.indexOf(data) < 0;
                        setRow(sheet, Number(data[`${rowKey}`]) - 1, { hidden: hide, isFiltered: hide });
                    });
                    refreshUI = sheetIdx === parent.activeSheetIndex;
                    const paneIndexes = getRangeIndexes(sheet.paneTopLeftCell);
                    this.parent.updateTopLeftCell(skipHiddenIdx(sheet, paneIndexes[0], true) - this.parent.frozenRowCount(sheet), null, 'col');
                }
                else {
                    jsonData.forEach((data) => {
                        hide = result.indexOf(data) < 0;
                        if (refreshUI) {
                            setRow(sheet, Number(data[`${rowKey}`]) - 1, { hidden: hide, isFiltered: hide });
                        }
                        else {
                            const eventArgs = { startIndex: Number(data[`${rowKey}`]) - 1, hide: hide,
                                isFiltering: true, sheetIndex: sheetIdx };
                            eventArgs.endIndex = eventArgs.startIndex;
                            this.parent.notify(hideShow, eventArgs);
                            refreshUI = eventArgs.refreshUI;
                        }
                    });
                }
                if (refreshUI) {
                    parent.renderModule.refreshSheet(false, false, document.activeElement.id !== `${this.parent.element.id}_SearchBox`);
                }
            }
            else {
                let hide;
                jsonData.forEach((data) => {
                    hide = result.indexOf(data) < 0;
                    setRow(sheet, Number(data[`${rowKey}`]) - 1, { hidden: hide, isFiltered: hide });
                });
            }
        }
    }
    /**
     * Gets the module name.
     *
     * @returns {string} - Get the module name.
     */
    getModuleName() {
        return 'workbookFilter';
    }
}

/**
 * Specifies image.
 */
class WorkbookImage {
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    setImage(args) {
        const lastIndex = args.range ? args.range.lastIndexOf('!') : -1;
        const imgRange = args.range ? (lastIndex > -1) ? args.range.substring(lastIndex + 1) : args.range
            : this.parent.getActiveSheet().selectedRange;
        const sheetIdx = (args.range && lastIndex > -1) ?
            getSheetIndex(this.parent, args.range.substring(0, lastIndex)) : this.parent.activeSheetIndex;
        const indexes = getRangeIndexes(imgRange);
        const sheet = isUndefined$1(sheetIdx) ? this.parent.getActiveSheet() : getSheet(this.parent, sheetIdx);
        const cell = getCell(indexes[0], indexes[1], sheet);
        let oldImgData;
        const imgData = args.options;
        if (cell && cell.image) {
            oldImgData = cell.image;
            if (args.isPositionChanged) {
                for (let i = 0; i < oldImgData.length; i++) {
                    for (let j = 0; j < imgData.length; j++) {
                        if (oldImgData[i].id === imgData[j].id) {
                            oldImgData[i] = imgData[j];
                            if (document.getElementById(imgData[j].id)) {
                                args.isElementRemoved = true;
                                document.getElementById(imgData[j].id).remove();
                            }
                        }
                    }
                }
            }
            else {
                oldImgData = cell.image;
                for (let i = 0; i < imgData.length; i++) {
                    oldImgData.push(imgData[i]);
                }
            }
        }
        setCell(indexes[0], indexes[1], sheet, { image: (cell && cell.image) ? oldImgData : imgData }, true, true);
        return args.isElementRemoved;
    }
    /**
     * Adding event listener for number format.
     *
     * @returns {void} - Adding event listener for number format.
     */
    addEventListener() {
        this.parent.on(setImage, this.setImage, this);
    }
    /**
     * Removing event listener for number format.
     *
     * @returns {void}
     */
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(setImage, this.setImage);
        }
    }
    /**
     * To Remove the event listeners.
     *
     * @returns {void} - To Remove the event listeners.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    /**
     * Get the workbook number format module name.
     *
     * @returns {string} - Get the module name.
     */
    getModuleName() {
        return 'workbookImage';
    }
}

/**
 * The `WorkbookChart` module is used to handle chart action in Spreadsheet.
 */
class WorkbookChart {
    /**
     * Constructor for WorkbookChart module.
     *
     * @param {Workbook} parent - Constructor for WorkbookChart module.
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    addEventListener() {
        this.parent.on(setChart, this.setChartHandler, this);
        this.parent.on(deleteChartColl, this.deleteChartColl, this);
        this.parent.on(refreshChartSize, this.refreshChartSize, this);
        this.parent.on(focusChartBorder, this.focusChartBorder, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(setChart, this.setChartHandler);
            this.parent.off(deleteChartColl, this.deleteChartColl);
            this.parent.off(refreshChartSize, this.refreshChartSize);
            this.parent.off(focusChartBorder, this.focusChartBorder);
        }
    }
    setChartHandler(args) {
        let i = 0;
        let rangeIdx = [];
        args.isInitCell = isNullOrUndefined(args.isInitCell) ? false : args.isInitCell;
        args.isUndoRedo = isNullOrUndefined(args.isUndoRedo) ? true : args.isUndoRedo;
        args.isPaste = isNullOrUndefined(args.isPaste) ? false : args.isPaste;
        const chart = args.chart;
        let chartModel;
        let chartLength;
        if (chart.length > 0) {
            while (i < chart.length) {
                if (args.isCut === false) {
                    if (document.getElementById(args.chart[i].id)) {
                        chart[i] = {
                            range: chart[i].range, id: getUniqueID('e_spreadsheet_chart'), theme: chart[i].theme,
                            isSeriesInRows: chart[i].isSeriesInRows, type: chart[i].type,
                            markerSettings: chart[i].markerSettings,
                            title: chart[i].title, legendSettings: chart[i].legendSettings,
                            primaryXAxis: chart[i].primaryXAxis, primaryYAxis: chart[i].primaryYAxis,
                            dataLabelSettings: chart[i].dataLabelSettings
                        };
                    }
                }
                if (document.getElementById(args.chart[i].id)) {
                    return;
                }
                chartModel = chart[i];
                chartModel.theme = chartModel.theme || 'Material';
                chartModel.type = chartModel.type || 'Line';
                chartModel.isSeriesInRows = chartModel.isSeriesInRows || false;
                if (isNullOrUndefined(chartModel.range)) {
                    const sheet = this.parent.getActiveSheet();
                    chartModel.range = sheet.selectedRange;
                    rangeIdx = getSwapRange(getRangeIndexes(chartModel.range));
                    if (rangeIdx[0] === 0 && rangeIdx[2] === sheet.rowCount - 1 && rangeIdx[2] > sheet.usedRange.rowIndex) {
                        rangeIdx[2] = sheet.usedRange.rowIndex;
                    }
                    if (rangeIdx[1] === 0 && rangeIdx[3] === sheet.colCount - 1 && rangeIdx[3] > sheet.usedRange.colIndex) {
                        rangeIdx[3] = sheet.usedRange.colIndex;
                    }
                }
                else {
                    rangeIdx = getSwapRange(getRangeIndexes(chartModel.range));
                }
                const rangeAddress = getRangeAddress(rangeIdx);
                if (chartModel.range.indexOf('!') > 0) {
                    chartModel.range = chartModel.range.substring(0, chartModel.range.lastIndexOf('!')) + '!' + rangeAddress;
                }
                else {
                    chartModel.range = this.parent.getActiveSheet().name + '!' + rangeAddress;
                }
                if (isNullOrUndefined(chartModel.id)) {
                    chartModel.id = getUniqueID('e_spreadsheet_chart');
                }
                if (chartModel.markerSettings && chartModel.markerSettings.visible) {
                    if (chartModel.markerSettings.isFilled === undefined) {
                        chartModel.markerSettings.isFilled = true;
                    }
                    if (chartModel.markerSettings.shape === undefined) {
                        chartModel.markerSettings.shape = 'Circle';
                    }
                }
                chartModel.height = chartModel.height || 290;
                chartModel.width = chartModel.width || 480;
                this.parent.notify(initiateChart, {
                    option: chartModel, isInitCell: args.isInitCell, triggerEvent: args.isUndoRedo,
                    dataSheetIdx: args.dataSheetIdx, range: args.range, isPaste: args.isPaste
                });
                this.parent.chartColl.push(chartModel);
                if (!args.isInitCell || args.isPaste || args.isUndo || args.isRedo) {
                    let sheetIdx;
                    let rowIdx;
                    let colIdx;
                    if (args.range && (args.isUndo || args.isRedo)) {
                        sheetIdx = getSheetIndex(this.parent, args.range.substring(0, args.range.lastIndexOf('!')));
                        const range = getSwapRange(getRangeIndexes(args.range));
                        rowIdx = range[0];
                        colIdx = range[1];
                    }
                    else {
                        sheetIdx = args.sheetId === undefined
                            ? ((chartModel.range && chartModel.range.lastIndexOf('!') > 0)
                                ? getSheetIndex(this.parent, chartModel.range.substring(0, chartModel.range.lastIndexOf('!')))
                                : this.parent.activeSheetIndex) : getSheetIndexFromId(this.parent, args.sheetId);
                        const chartRowIdx = { clientY: chartModel.top, isImage: true };
                        const chartColIdx = { clientX: chartModel.left, isImage: true };
                        this.parent.notify(getChartRowIdxFromClientY, chartRowIdx);
                        this.parent.notify(getChartColIdxFromClientX, chartColIdx);
                        rowIdx = chartRowIdx.clientY;
                        colIdx = chartColIdx.clientX;
                    }
                    const sheet = isUndefined$1(sheetIdx) ? this.parent.getActiveSheet()
                        : this.parent.sheets[sheetIdx];
                    const cell = getCell(rowIdx, colIdx, sheet);
                    if (!this.parent.isPrintingProcessing) {
                        if (cell && cell.chart) {
                            cell.chart.push(chartModel);
                        }
                        else {
                            setCell(rowIdx, colIdx, sheet, { chart: [chartModel] }, true);
                        }
                    }
                }
                else {
                    const indexes = getRangeIndexes(args.range);
                    const chartRowIdx = { clientY: chartModel.top, isImage: true };
                    const chartColIdx = { clientX: chartModel.left, isImage: true };
                    this.parent.notify(getChartRowIdxFromClientY, chartRowIdx);
                    this.parent.notify(getChartColIdxFromClientX, chartColIdx);
                    const eventArgs = {
                        prevTop: chartModel.top, prevLeft: chartModel.left, prevRowIdx: indexes[0], prevColIdx: indexes[1],
                        prevHeight: chartModel.height, prevWidth: chartModel.width, currentTop: chartModel.top,
                        currentLeft: chartModel.left, currentRowIdx: chartRowIdx.clientY, currentColIdx: chartColIdx.clientX,
                        currentHeight: chartModel.height, currentWidth: chartModel.width, id: chartModel.id, requestType: 'chartRefreshOnInit'
                    };
                    if (indexes[0] !== chartRowIdx.clientY || indexes[1] !== chartColIdx.clientX) {
                        chartLength = chart.length;
                        this.parent.notify(refreshChartCellOnInit, eventArgs);
                        i -= chartLength - chart.length;
                    }
                }
                i++;
            }
        }
    }
    refreshChartSize(args) {
        let chartCnt;
        let j = 1;
        const sheetCnt = this.parent.sheets.length + 1;
        while (j < sheetCnt) {
            const charts = this.parent.chartColl;
            chartCnt = charts ? charts.length : 0;
            if (chartCnt) {
                while (chartCnt--) {
                    const chart = this.parent.chartColl[chartCnt];
                    if (!isNullOrUndefined(args.overlayEle.querySelector('#' + chart.id))) {
                        const chartObj = this.parent.element.querySelector('.' + chart.id);
                        const excelFilter = getComponent(chartObj, 'chart') || getComponent(chartObj, 'accumulationchart');
                        if (excelFilter) {
                            excelFilter.height = args.height;
                            excelFilter.width = args.width;
                        }
                    }
                }
            }
            j++;
        }
    }
    focusChartBorder(args) {
        for (let idx = 0; idx < this.parent.chartColl.length; idx++) {
            const overlayEle = document.getElementById(args.id);
            const chartEle = document.getElementById(this.parent.chartColl[idx].id);
            if (overlayEle && chartEle && closest(chartEle, '.' + overlayEle.classList[1]) === overlayEle) {
                this.parent.notify(initiateChart, {
                    option: this.parent.chartColl[idx], isRefresh: true
                });
            }
        }
    }
    deleteChartColl(args) {
        for (let idx = 0; idx < this.parent.chartColl.length; idx++) {
            if (this.parent.chartColl[idx].id + '_overlay' === args.id) {
                this.parent.chartColl.splice(idx, 1);
            }
        }
    }
    /**
     * To Remove the event listeners.
     *
     * @returns {void} - To Remove the event listeners.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    /**
     * Get the workbook chart module name.
     *
     * @returns {string} - Get the workbook chart module name.
     */
    getModuleName() {
        return 'workbookChart';
    }
}

/**
 * Workbook Cell format.
 */
class WorkbookCellFormat {
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    format(args) {
        let sheet;
        let rng = args.range;
        if (rng && typeof rng === 'string' && rng.indexOf('!') > -1) {
            const lastIndex = rng.lastIndexOf('!');
            rng = rng.substring(lastIndex + 1);
            sheet = this.parent.sheets[getSheetIndex(this.parent, args.range.substring(0, lastIndex))];
        }
        else {
            sheet = this.parent.getActiveSheet();
        }
        if (rng === undefined) {
            rng = sheet.selectedRange;
        }
        const triggerEvt = typeof (rng) !== 'object' && args.onActionUpdate && !args.isUndoRedo;
        const eventArgs = {
            range: rng, style: Object.assign({}, args.style), requestType: 'CellFormat'
        };
        if (args.borderType) {
            eventArgs.borderType = args.borderType;
        }
        const style = {};
        const indexes = typeof (eventArgs.range) === 'object' ? eventArgs.range :
            getSwapRange(getRangeIndexes(eventArgs.range));
        const mergeBorderRows = [];
        const hasReadOnlyCells = isReadOnlyCells(this.parent, indexes);
        if (hasReadOnlyCells) {
            if (args.onActionUpdate) {
                this.parent.notify(workbookReadonlyAlert, null);
            }
            return;
        }
        Object.assign(style, eventArgs.style, null, true);
        if (triggerEvt) {
            this.parent.trigger('beforeCellFormat', eventArgs);
            this.parent.notify('actionBegin', { eventArgs: eventArgs, action: 'format' });
            if (eventArgs.cancel) {
                args.cancel = true;
                return;
            }
        }
        if (args.borderType) {
            this.setTypedBorder(sheet, args.style.border, indexes, args.borderType, args.onActionUpdate, mergeBorderRows);
            delete args.style.border;
            delete eventArgs.style.border;
        }
        let i;
        let j;
        const props = { cell: null, rowIdx: 0, colIdx: 0, eventOnly: true, preventEvt: !triggerEvt };
        const triggerBeforeEvent = (cellStyle) => {
            props.cell = { style: cellStyle };
            props.rowIdx = i;
            props.colIdx = j;
            return updateCell(this.parent, sheet, props);
        };
        if (eventArgs.style.borderTop !== undefined) {
            for (j = indexes[1]; j <= indexes[3]; j++) {
                i = indexes[0];
                if (!triggerBeforeEvent({ borderTop: eventArgs.style.borderTop })) {
                    if (!args.isUndoRedo) {
                        this.checkAdjacentBorder(sheet, 'borderBottom', i - 1, j);
                        this.checkFullBorder(sheet, 'borderBottom', i - 1, j);
                    }
                    this.checkFullBorder(sheet, 'borderTop', i, j);
                    this.setCellBorder(sheet, props.cell.style, i, j, args.onActionUpdate, j === indexes[3], null, null, args.isUndoRedo, mergeBorderRows);
                }
            }
            delete eventArgs.style.borderTop;
        }
        if (eventArgs.style.borderBottom !== undefined) {
            let firstCell;
            let lastCell;
            for (j = indexes[1]; j <= indexes[3]; j++) {
                i = indexes[0];
                firstCell = getCell(i, j, sheet, false, true);
                if (firstCell.rowSpan > 0) {
                    lastCell = getCell(indexes[2], indexes[1], sheet, false, true);
                }
                else {
                    lastCell = getCell(indexes[2], indexes[3], sheet, false, true);
                }
                if (!(firstCell.rowSpan > 1 && lastCell.rowSpan < 0)) {
                    i = indexes[2];
                }
                const mergeArgs = { range: [i, j, i, j] };
                this.parent.notify(activeCellMergedRange, mergeArgs);
                i = mergeArgs.range[0];
                if (!triggerBeforeEvent({ borderBottom: eventArgs.style.borderBottom })) {
                    if (!args.isUndoRedo) {
                        this.checkAdjacentBorder(sheet, 'borderTop', indexes[2] + 1, j);
                        this.checkFullBorder(sheet, 'borderTop', indexes[2] + 1, j);
                    }
                    this.checkFullBorder(sheet, 'borderBottom', indexes[2], j);
                    this.setCellBorder(sheet, props.cell.style, i, j, args.onActionUpdate, j === indexes[3], null, null, args.isUndoRedo);
                    this.setBottomBorderPriority(sheet, indexes[2], j);
                }
            }
            delete eventArgs.style.borderBottom;
        }
        if (eventArgs.style.borderLeft !== undefined) {
            for (let i = indexes[0]; i <= indexes[2]; i++) {
                j = indexes[1];
                if (!triggerBeforeEvent({ borderLeft: eventArgs.style.borderLeft })) {
                    if (!args.isUndoRedo) {
                        this.checkAdjacentBorder(sheet, 'borderRight', i, j - 1);
                        this.checkFullBorder(sheet, 'borderRight', i, j - 1);
                    }
                    this.checkFullBorder(sheet, 'borderLeft', i, j);
                    this.setCellBorder(sheet, props.cell.style, i, j, args.onActionUpdate, null, null, null, args.isUndoRedo);
                }
            }
            delete eventArgs.style.borderLeft;
        }
        if (eventArgs.style.borderRight !== undefined) {
            for (let i = indexes[0]; i <= indexes[2]; i++) {
                j = indexes[3];
                const mergeArgs = { range: [i, j, i, j] };
                this.parent.notify(activeCellMergedRange, mergeArgs);
                j = mergeArgs.range[1];
                if (!triggerBeforeEvent({ borderRight: eventArgs.style.borderRight })) {
                    if (!args.isUndoRedo) {
                        this.checkAdjacentBorder(sheet, 'borderLeft', i, j + 1);
                        this.checkFullBorder(sheet, 'borderLeft', i, j + 1);
                    }
                    this.checkFullBorder(sheet, 'borderRight', i, j);
                    this.setCellBorder(sheet, props.cell.style, i, j, args.onActionUpdate, null, null, null, args.isUndoRedo);
                }
            }
            delete eventArgs.style.borderRight;
        }
        let border;
        let isFullBorder;
        const styleKeys = Object.keys(eventArgs.style);
        if (styleKeys.length) {
            let cell;
            let validation;
            let col;
            const parent = this.parent;
            const activeSheet = parent.viewport && this.parent.getActiveSheet().id === sheet.id;
            const frozenRow = this.parent.frozenRowCount(sheet);
            const frozenCol = this.parent.frozenColCount(sheet);
            const viewport = [frozenRow + parent.viewport.topIndex, frozenCol + parent.viewport.leftIndex,
                parent.viewport.bottomIndex, parent.viewport.rightIndex];
            let uiRefresh;
            let row;
            let checkHeight;
            let formatColor;
            const isFontColorApplied = styleKeys.indexOf('color') > -1;
            const isColorApplied = isFontColorApplied || styleKeys.indexOf('backgroundColor') > -1;
            for (i = indexes[0]; i <= indexes[2]; i++) {
                row = getRow(sheet, i) || {};
                if (row.isFiltered) {
                    continue;
                }
                uiRefresh = (i >= viewport[0] && i <= viewport[2]) || i < frozenRow;
                checkHeight = false;
                for (j = indexes[1]; j <= indexes[3]; j++) {
                    if (triggerBeforeEvent(eventArgs.style)) {
                        continue;
                    }
                    if (isFullBorder === undefined) {
                        if (eventArgs.style.border !== undefined) {
                            border = eventArgs.style.border;
                            delete eventArgs.style.border;
                            isFullBorder = true;
                        }
                        else {
                            isFullBorder = false;
                        }
                    }
                    cell = getCell(i, j, sheet, false, true);
                    col = sheet.columns[j];
                    if (cell.rowSpan > 1 || cell.colSpan > 1) {
                        for (let k = i, rowSpanLen = cell.rowSpan > 1 ? i + (cell.rowSpan - 1) : i; k <= rowSpanLen; k++) {
                            for (let l = j, colSpanLen = cell.colSpan > 1 ? j + (cell.colSpan - 1) : j; l <= colSpanLen; l++) {
                                if (isFullBorder) {
                                    this.setFullBorder(sheet, border, indexes, k, l, args.onActionUpdate, true);
                                }
                                this.setCellStyle(sheet, k, l, eventArgs.style);
                            }
                        }
                    }
                    if (isFullBorder) {
                        this.setFullBorder(sheet, border, indexes, i, j, args.onActionUpdate, undefined, mergeBorderRows);
                    }
                    this.setCellStyle(sheet, i, j, eventArgs.style);
                    if (!activeSheet) {
                        continue;
                    }
                    if (uiRefresh && ((j >= viewport[1] && j <= viewport[3]) || j < frozenCol)) {
                        formatColor = null;
                        if (isFontColorApplied && cell.format && cell.format.includes('[')) {
                            const colorCode = getColorCode(cell.format);
                            if (colorCode) {
                                formatColor = colorCode.toLowerCase();
                            }
                        }
                        this.parent.notify(applyCellFormat, { style: eventArgs.style, rowIdx: i, colIdx: j,
                            lastCell: j === indexes[3], isHeightCheckNeeded: true, manualUpdate: true, onActionUpdate: args.onActionUpdate,
                            formatColor: formatColor });
                        if (isColorApplied) {
                            validation = cell.validation || (checkColumnValidation(col, i, j) && col.validation);
                            if (validation && validation.isHighlighted) {
                                this.parent.notify(updateHighlight, {
                                    rowIdx: i, colIdx: j, cell: cell, validation: validation, col: cell.validation && col
                                });
                            }
                        }
                    }
                    else if (!row.customHeight) {
                        checkHeight = checkHeight || isHeightCheckNeeded(eventArgs.style, args.onActionUpdate);
                        if (checkHeight) {
                            this.parent.notify(applyCellFormat, { rowIdx: i, colIdx: j, lastCell: j === indexes[3], checkHeight: true,
                                outsideViewport: !uiRefresh, onActionUpdate: args.onActionUpdate });
                        }
                    }
                }
            }
        }
        if (isFullBorder) {
            eventArgs.style.border = border;
        }
        updateMergeBorder(this.parent, mergeBorderRows, [indexes[1], indexes[3]]);
        this.parent.setUsedRange(indexes[2], indexes[3]);
        if (args.refreshRibbon) {
            this.parent.notify(activeCellChanged, null);
        }
        if (sheet.conditionalFormats && sheet.conditionalFormats.length) {
            this.parent.notify(applyCF, { indexes: indexes });
        }
        if (triggerEvt) {
            eventArgs.style = style;
            eventArgs.range = `${sheet.name}!${rng}`;
            this.parent.notify('actionComplete', { eventArgs: eventArgs, action: 'format' });
        }
    }
    setBottomBorderPriority(sheet, rowIdx, colIdx) {
        if (isHiddenRow(sheet, rowIdx + 1)) {
            const pIdx = this.skipHiddenRows(sheet, rowIdx + 1);
            const pCellStyle = this.parent.getCellStyleValue(['borderTop'], [pIdx, colIdx]).borderTop;
            if (pCellStyle !== '') {
                sheet.rows[rowIdx].cells[colIdx].style.bottomPriority = true;
            }
        }
    }
    setFullBorder(sheet, border, indexes, i, j, actionUpdate, modelUpdate, mergeBorderRows) {
        const style = {};
        if (i === indexes[0]) {
            this.checkAdjacentBorder(sheet, 'borderBottom', i - 1, j);
            this.checkFullBorder(sheet, 'borderBottom', i - 1, j);
        }
        if (j === indexes[1]) {
            this.checkAdjacentBorder(sheet, 'borderRight', i, j - 1);
            this.checkFullBorder(sheet, 'borderRight', i, j - 1);
        }
        if (j === indexes[3]) {
            this.checkAdjacentBorder(sheet, 'borderLeft', i, j + 1);
            this.checkFullBorder(sheet, 'borderLeft', i, j + 1);
        }
        else {
            this.checkAdjacentBorder(sheet, 'border', i, j + 1);
        }
        style.borderRight = border;
        style.borderTop = border;
        style.borderLeft = border;
        style.borderBottom = border;
        this.setCellBorder(sheet, style, i, j, actionUpdate, j === indexes[3], null, modelUpdate, undefined, mergeBorderRows);
        if (i === indexes[2]) {
            this.checkAdjacentBorder(sheet, 'borderTop', i + 1, j);
            this.checkFullBorder(sheet, 'borderTop', i + 1, j);
            this.setBottomBorderPriority(sheet, i, j);
        }
        else {
            this.checkAdjacentBorder(sheet, 'border', i + 1, j);
        }
    }
    checkAdjacentBorder(sheet, prop, rowIdx, colIdx) {
        const style = {};
        if (this.parent.getCellStyleValue([prop], [rowIdx, colIdx])[`${prop}`] !== '') {
            style[`${prop}`] = undefined;
            this.setCellStyle(sheet, rowIdx, colIdx, style);
        }
    }
    checkFullBorder(sheet, prop, rowIdx, colIdx) {
        const border = this.parent.getCellStyleValue(['border'], [rowIdx, colIdx]).border;
        if (border !== '') {
            const style = { border: undefined };
            ['borderBottom', 'borderTop', 'borderLeft', 'borderRight'].forEach((value) => {
                if (value !== prop) {
                    style[`${value}`] = border;
                }
            });
            this.setCellStyle(sheet, rowIdx, colIdx, style);
        }
    }
    textDecorationActionUpdate(args) {
        const sheet = this.parent.getActiveSheet();
        const eventArgs = { range: sheet.selectedRange, style: args.style, requestType: 'CellFormat' };
        const indexes = getSwapRange(getRangeIndexes(sheet.selectedRange));
        const hasReadOnlyCells = isReadOnlyCells(this.parent, indexes);
        if (hasReadOnlyCells) {
            this.parent.notify(workbookReadonlyAlert, null);
            return;
        }
        this.parent.trigger('beforeCellFormat', eventArgs);
        this.parent.notify('actionBegin', { eventArgs: eventArgs, action: 'format' });
        if (eventArgs.cancel) {
            args.cancel = true;
            return;
        }
        const value = args.style.textDecoration.toLowerCase();
        let changedValue = value;
        const activeCellIndexes = getRangeIndexes(sheet.activeCell);
        let cellValue = this.parent.getCellStyleValue(['textDecoration'], activeCellIndexes).textDecoration.toLowerCase();
        let removeProp = false;
        if (cellValue === 'underline') {
            changedValue = value === 'underline' ? 'none' : 'underline line-through';
        }
        else if (cellValue === 'line-through') {
            changedValue = value === 'line-through' ? 'none' : 'underline line-through';
        }
        else if (cellValue === 'underline line-through') {
            changedValue = value === 'underline' ? 'line-through' : 'underline';
            removeProp = true;
        }
        if (changedValue === 'none') {
            removeProp = true;
        }
        let changedStyle = { textDecoration: changedValue };
        this.format({ style: changedStyle, range: activeCellIndexes, refreshRibbon: args.refreshRibbon, onActionUpdate: true });
        for (let i = indexes[0]; i <= indexes[2]; i++) {
            for (let j = indexes[1]; j <= indexes[3]; j++) {
                if (i === activeCellIndexes[0] && j === activeCellIndexes[1]) {
                    continue;
                }
                changedStyle = {};
                cellValue = this.parent.getCellStyleValue(['textDecoration'], [i, j]).textDecoration.toLowerCase();
                if (cellValue === 'none') {
                    if (removeProp) {
                        continue;
                    }
                    changedStyle.textDecoration = value;
                }
                else if (cellValue === 'underline' || cellValue === 'line-through') {
                    if (removeProp) {
                        if (value === cellValue) {
                            changedStyle.textDecoration = 'none';
                        }
                        else {
                            continue;
                        }
                    }
                    else {
                        changedStyle.textDecoration = value !== cellValue ? 'underline line-through' : value;
                    }
                }
                else if (cellValue === 'underline line-through') {
                    if (removeProp) {
                        changedStyle.textDecoration = value === 'underline' ? 'line-through' : 'underline';
                    }
                    else {
                        continue;
                    }
                }
                this.format({ style: changedStyle, range: [i, j, i, j], refreshRibbon: args.refreshRibbon, onActionUpdate: true });
            }
        }
        eventArgs.range = sheet.name + '!' + eventArgs.range;
        eventArgs.style.textDecoration = changedValue;
        this.parent.notify('actionComplete', { eventArgs: eventArgs, action: 'format' });
    }
    setTypedBorder(sheet, border, range, type, actionUpdate, mergeBorderRows) {
        let prevBorder;
        if (type === 'Outer') {
            for (let colIdx = range[1]; colIdx <= range[3]; colIdx++) {
                this.checkAdjacentBorder(sheet, 'borderBottom', range[0] - 1, colIdx);
                this.checkFullBorder(sheet, 'borderBottom', range[0] - 1, colIdx);
                this.setCellBorder(sheet, { borderTop: border }, range[0], colIdx, actionUpdate, colIdx === range[3], undefined, undefined, undefined, mergeBorderRows);
                this.checkAdjacentBorder(sheet, 'borderTop', range[2] + 1, colIdx);
                this.checkFullBorder(sheet, 'borderTop', range[2] + 1, colIdx);
                this.setCellBorder(sheet, { borderBottom: border }, range[2], colIdx, actionUpdate, colIdx === range[3], type);
                this.setBottomBorderPriority(sheet, range[2], colIdx);
            }
            for (let rowIdx = range[0]; rowIdx <= range[2]; rowIdx++) {
                this.checkAdjacentBorder(sheet, 'borderRight', rowIdx, range[1] - 1);
                this.checkFullBorder(sheet, 'borderRight', rowIdx, range[1] - 1);
                this.setCellBorder(sheet, { borderLeft: border }, rowIdx, range[1], actionUpdate);
                this.checkAdjacentBorder(sheet, 'borderLeft', rowIdx, range[3] + 1);
                this.checkFullBorder(sheet, 'borderLeft', rowIdx, range[3] + 1);
                this.setCellBorder(sheet, { borderRight: border }, rowIdx, range[3], actionUpdate, null, type);
            }
        }
        else if (type === 'Inner') {
            const mergeArgs = { range: [range[0], range[1], range[0], range[1]] };
            this.parent.notify(mergedRange, mergeArgs);
            if (mergeArgs.range[0] === range[0] && mergeArgs.range[1] === range[1] &&
                mergeArgs.range[2] === range[2] && mergeArgs.range[3] === range[3]) {
                return;
            }
            for (let i = range[0]; i <= range[2]; i++) {
                for (let j = range[1]; j <= range[3]; j++) {
                    const style = {};
                    prevBorder = this.parent.getCellStyleValue(['border'], [i, j]).border;
                    if (prevBorder !== '') {
                        style.border = undefined;
                        if (j === range[3] || j === range[1] || i === range[0] || i === range[2]) {
                            if (i === range[0]) {
                                style.borderTop = prevBorder;
                            }
                            if (i === range[2]) {
                                style.borderBottom = prevBorder;
                            }
                            if (j === range[3]) {
                                style.borderRight = prevBorder;
                            }
                            if (j === range[1]) {
                                style.borderLeft = prevBorder;
                            }
                        }
                    }
                    if (j !== range[3]) {
                        style.borderRight = border;
                    }
                    if (i !== range[0]) {
                        style.borderTop = border;
                    }
                    if (i !== range[2]) {
                        style.borderBottom = border;
                    }
                    if (j !== range[1]) {
                        style.borderLeft = border;
                    }
                    this.setCellBorder(sheet, style, i, j, actionUpdate, j === range[3], undefined, undefined, undefined, mergeBorderRows);
                }
            }
        }
        else if (type === 'Vertical') {
            for (let i = range[0]; i <= range[2]; i++) {
                for (let j = range[1]; j <= range[3]; j++) {
                    const style = { borderRight: border, borderLeft: border };
                    if (j === range[1]) {
                        this.checkAdjacentBorder(sheet, 'borderRight', i, j - 1);
                        this.checkFullBorder(sheet, 'borderRight', i, j - 1);
                    }
                    if (j === range[3]) {
                        this.checkAdjacentBorder(sheet, 'borderLeft', i, j + 1);
                        this.checkFullBorder(sheet, 'borderLeft', i, j + 1);
                    }
                    this.setCellBorder(sheet, style, i, j, actionUpdate);
                }
            }
        }
        else {
            for (let i = range[0]; i <= range[2]; i++) {
                for (let j = range[1]; j <= range[3]; j++) {
                    const style = { borderTop: border, borderBottom: border };
                    if (i === range[0]) {
                        this.checkAdjacentBorder(sheet, 'borderBottom', i - 1, j);
                        this.checkFullBorder(sheet, 'borderBottom', i - 1, j);
                    }
                    this.setCellBorder(sheet, style, i, j, actionUpdate, j === range[3]);
                    if (i === range[2]) {
                        this.checkAdjacentBorder(sheet, 'borderTop', i + 1, j);
                        this.checkFullBorder(sheet, 'borderTop', i + 1, j);
                        this.setBottomBorderPriority(sheet, i, j);
                    }
                }
            }
        }
    }
    setCellBorder(sheet, style, rowIdx, colIdx, actionUpdate, lastCell, type, modelUpdate, isUndoRedo, mergeBorderRows) {
        const cell = getCell(rowIdx, colIdx, sheet);
        const column = getColumn(sheet, colIdx);
        const row = getRow(sheet, rowIdx);
        if ((cell && cell.isReadOnly) || (column && column.isReadOnly) || (row && row.isReadOnly)) {
            return;
        }
        this.setCellStyle(sheet, rowIdx, colIdx, style);
        if (!modelUpdate && this.parent.getActiveSheet().id === sheet.id) {
            if (type === 'Outer' && (style.borderBottom || style.borderRight)) {
                const mergeArgs = { range: [rowIdx, colIdx, rowIdx, colIdx] };
                this.parent.notify(activeCellMergedRange, mergeArgs);
                rowIdx = mergeArgs.range[0];
                colIdx = mergeArgs.range[1];
            }
            if (isUndoRedo) {
                if (style.borderTop === '' && this.parent.getCellStyleValue(['borderBottom'], [rowIdx - 1, colIdx]).borderBottom !== '') {
                    style.borderTop = this.parent.getCellStyleValue(['borderBottom'], [rowIdx - 1, colIdx]).borderBottom;
                }
                if (style.borderLeft === '' && this.parent.getCellStyleValue(['borderRight'], [rowIdx, colIdx - 1]).borderRight !== '') {
                    style.borderLeft = this.parent.getCellStyleValue(['borderRight'], [rowIdx, colIdx - 1]).borderRight;
                }
                if (style.borderRight === '' && this.parent.getCellStyleValue(['borderLeft'], [rowIdx, colIdx + 1]).borderLeft !== '') {
                    style.borderRight = this.parent.getCellStyleValue(['borderLeft'], [rowIdx, colIdx + 1]).borderLeft;
                }
            }
            this.parent.notify(applyCellFormat, {
                style: style, rowIdx: rowIdx, colIdx: colIdx, onActionUpdate: actionUpdate, first: '', lastCell: lastCell,
                isHeightCheckNeeded: true, manualUpdate: true, mergeBorderRows: mergeBorderRows
            });
        }
    }
    setCellStyle(sheet, rowIdx, colIdx, style) {
        if (!sheet.rows[rowIdx]) {
            sheet.rows[rowIdx] = { cells: [] };
        }
        else if (!sheet.rows[rowIdx].cells) {
            sheet.rows[rowIdx].cells = [];
        }
        if (!sheet.rows[rowIdx].cells[colIdx]) {
            sheet.rows[rowIdx].cells[colIdx] = {};
        }
        if (!sheet.rows[rowIdx].cells[colIdx].style) {
            sheet.rows[rowIdx].cells[colIdx].style = {};
        }
        Object.assign(sheet.rows[rowIdx].cells[colIdx].style, style, null, true);
    }
    skipHiddenRows(sheet, startIdx) {
        startIdx++;
        if (isHiddenRow(sheet, startIdx)) {
            startIdx = this.skipHiddenRows(sheet, startIdx);
        }
        return startIdx;
    }
    addEventListener() {
        this.parent.on(setCellFormat, this.format, this);
        this.parent.on(textDecorationUpdate, this.textDecorationActionUpdate, this);
        this.parent.on(clear, this.clearCellObj, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(setCellFormat, this.format);
            this.parent.off(textDecorationUpdate, this.textDecorationActionUpdate);
            this.parent.off(clear, this.clearCellObj);
        }
    }
    clearCellObj(options) {
        const lastIndex = options.range ? options.range.lastIndexOf('!') : 0;
        const clrRange = options.range ? (lastIndex > 0) ? options.range.substring(lastIndex + 1) : options.range
            : this.parent.getActiveSheet().selectedRange;
        const sheetIdx = (options.range && lastIndex > 0) ?
            getSheetIndex(this.parent, options.range.substring(0, lastIndex)) : this.parent.activeSheetIndex;
        const sheet = getSheet(this.parent, sheetIdx);
        const range = getSwapRange(getIndexesFromAddress(clrRange));
        let sRowIdx = range[0];
        const eRowIdx = range[2];
        const cf = sheet.conditionalFormats && sheet.conditionalFormats.length &&
            [].slice.call(sheet.conditionalFormats);
        const cfRule = [];
        let cfRefreshAll;
        let evtArgs;
        let sColIdx;
        let eColIdx;
        let isValExist;
        for (sRowIdx; sRowIdx <= eRowIdx; sRowIdx++) {
            sColIdx = range[1];
            eColIdx = range[3];
            for (sColIdx; sColIdx <= eColIdx; sColIdx++) {
                const cell = getCell(sRowIdx, sColIdx, sheet);
                const isReadonlyCell = isReadOnly(cell, getColumn(sheet, sColIdx), getRow(sheet, sRowIdx));
                if (cell && (options.type === 'Clear All' || options.type === 'Clear Formats')) {
                    if (cell.rowSpan > 1 || cell.colSpan > 1) {
                        const mergeArgs = { range: [sRowIdx, sColIdx, sRowIdx, sColIdx] };
                        this.parent.notify(mergedRange, mergeArgs);
                        const mergedRanges = mergeArgs.range;
                        if (range[0] <= mergedRanges[0] && range[1] <= mergedRanges[1] && range[2] >= mergedRanges[2] &&
                            range[3] >= mergedRanges[3]) {
                            this.parent.notify(setMerge, { merge: false, range: mergedRanges, type: 'All', sheetIndex: sheetIdx,
                                preventRefresh: sheetIdx !== this.parent.activeSheetIndex });
                        }
                    }
                    if (!!cell.rowSpan && cell.rowSpan !== 1 || !!cell.colSpan && cell.colSpan !== 1) {
                        continue;
                    }
                }
                if (cell && !isReadonlyCell) {
                    switch (options.type) {
                        case 'Clear Formats':
                            delete cell.format;
                            delete cell.rowSpan;
                            delete cell.style;
                            delete cell.wrap;
                            delete cell.colSpan;
                            delete cell.formattedText;
                            if (cell.hyperlink) {
                                cell.style = { textDecoration: 'none', color: 'inherit' };
                            }
                            break;
                        case 'Clear Contents':
                            if (cell.hyperlink) {
                                this.parent.notify(deleteHyperlink, { sheet: sheet, rowIdx: sRowIdx, colIdx: sColIdx, preventRefresh: true });
                                cell.style = { textDecoration: 'underline', color: '#00e' };
                            }
                            isValExist = !!(cell.value || cell.formula);
                            delete cell.value;
                            delete cell.formula;
                            delete cell.formattedText;
                            if (isValExist) {
                                evtArgs = { action: 'refreshCalculate', rowIndex: sRowIdx, colIndex: sColIdx, sheetIndex: sheetIdx };
                                this.parent.notify(workbookFormulaOperation, evtArgs);
                                if (cf && !cfRefreshAll) {
                                    cfRefreshAll = evtArgs.isFormulaDependent;
                                    if (!cfRefreshAll) {
                                        updateCFModel(cf, cfRule, sRowIdx, sColIdx);
                                    }
                                }
                            }
                            break;
                        case 'Clear Hyperlinks':
                            delete cell.hyperlink;
                            break;
                        case 'Clear All':
                            isValExist = !!(cell.value || cell.formula);
                            setCell(sRowIdx, sColIdx, sheet, {}, false);
                            if (isValExist) {
                                evtArgs = { action: 'refreshCalculate', rowIndex: sRowIdx, colIndex: sColIdx, sheetIndex: sheetIdx };
                                this.parent.notify(workbookFormulaOperation, evtArgs);
                                if (cf && !cfRefreshAll) {
                                    cfRefreshAll = evtArgs.isFormulaDependent;
                                }
                            }
                            break;
                    }
                }
            }
        }
        if ((cfRule.length || cfRefreshAll) && sheetIdx === this.parent.activeSheetIndex) {
            this.parent.notify(applyCF, { cfModel: !cfRefreshAll && cfRule, refreshAll: cfRefreshAll, isAction: true });
        }
    }
    /**
     * To destroy workbook cell format.
     *
     * @returns {void} - To destroy workbook cell format.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    /**
     * Get the workbook cell format module name.
     *
     *  @returns {void}
     */
    getModuleName() {
        return 'workbookcellformat';
    }
}

/**
 * The `WorkbookEdit` module is used to handle the editing functionalities in Workbook.
 */
class WorkbookEdit {
    /**
     * Constructor for edit module in Workbook.
     *
     * @private
     * @param {Workbook} workbook - Specifies the workbook.
     */
    constructor(workbook) {
        this.parent = workbook;
        this.addEventListener();
    }
    /**
     * To destroy the edit module.
     *
     * @returns {void} - destroy the edit module
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(workbookEditOperation, this.performEditOperation, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(workbookEditOperation, this.performEditOperation);
        }
    }
    /**
     * Get the module name.
     *
     * @returns {string} - string
     * @private
     */
    getModuleName() {
        return 'workbookEdit';
    }
    performEditOperation(args) {
        const action = args.action;
        switch (action) {
            case 'updateCellValue':
                args.isFormulaDependent = this.updateCellValue(args.address, args.value, args.sheetIndex, args.isValueOnly, args.skipFormatCheck, args.isRandomFormula, args.skipCellFormat, args.isDelete, args.deletedRange, args.fillType, args.cellInformation, args.isRedo, args.isDependentUpdate, args.actionName, args.isPaste);
                break;
        }
    }
    updateCellValue(address, value, sheetIdx, isValueOnly, skipFormatCheck, isRandomFormula, skipCellFormat, isDelete, deletedRange, fillType, cellInformation, isRedo, isDependentUpdate, actionName, isPaste) {
        if (sheetIdx === undefined) {
            sheetIdx = this.parent.activeSheetIndex;
        }
        let range;
        let isFormulaDependent;
        if (typeof address === 'string') {
            range = getRangeIndexes(address);
        }
        else {
            range = address;
        }
        const sheet = getSheet(this.parent, sheetIdx);
        let cell = getCell(range[0], range[1], sheet, true);
        if (!cell) {
            cell = sheet.rows[range[0]].cells[range[1]] = {};
        }
        if (!isValueOnly) {
            let isFormula = checkIsFormula(value);
            isFormula = value === '#SPILL!' ? true : isFormula;
            let skipFormula = false; // for unique formula
            if (cell.formula && cell.formula.indexOf('UNIQUE') > -1 && value === '') {
                skipFormula = true;
            }
            const isNotTextFormat = getTypeFromFormat(cell.format) !== 'Text' && (!isFormula ||
                !value.toLowerCase().startsWith('=text('));
            isFormula = getTypeFromFormat(cell.format) === 'Text' ? false : isFormula;
            if (!isFormula && !skipFormula) {
                if (cell.formula) {
                    cell.formula = '';
                }
                cell.value = isNotTextFormat ? parseIntValue(value, isPaste) : value;
            }
            const eventArgs = {
                action: 'refreshCalculate',
                value: value,
                rowIndex: range[0],
                colIndex: range[1],
                sheetIndex: sheetIdx,
                isFormula: isFormula,
                isRandomFormula: isRandomFormula,
                isDelete: isDelete,
                deletedRange: deletedRange,
                fillType: fillType,
                isDependentRefresh: isDependentUpdate
            };
            if (isNotTextFormat && !skipFormatCheck) {
                const dateEventArgs = {
                    value: value,
                    rowIndex: range[0],
                    colIndex: range[1],
                    sheetIndex: sheetIdx,
                    updatedVal: '',
                    skipCellFormat: skipCellFormat
                };
                if (!isFormula) {
                    const cellType = getTypeFromFormat(cell.format);
                    const valArr = value ? value.toString().split('/') : [];
                    if ((cellType !== 'Number' && cellType !== 'Percentage' && cellType !== 'Fraction' && !(cellType === 'Scientific' && valArr.length === 2)) ||
                        (cellType === 'Fraction' && valArr.length !== 2)) {
                        this.parent.notify(checkDateFormat, dateEventArgs);
                    }
                    if (!isNullOrUndefined(dateEventArgs.updatedVal) && dateEventArgs.updatedVal.length > 0) {
                        cell.value = dateEventArgs.updatedVal;
                    }
                    else if (this.parent.isEdit && value && !isNumber(value)) {
                        const curSymbol = getNumberDependable(this.parent.locale, defaultCurrencyCode);
                        if (cell.format) {
                            if ((value.includes('%') || value.includes(curSymbol)) && isCustomDateTime(cell.format)) {
                                const formatArgs = {
                                    formattedText: value, value: value, format: 'General',
                                    cell: { value: value, format: 'General' }, isEdit: true
                                };
                                this.parent.notify(getFormattedCellObject, formatArgs);
                                if (formatArgs.format !== 'General' && ['Currency', 'Percentage'].indexOf(getTypeFromFormat(formatArgs.format)) > -1) {
                                    cell.format = formatArgs.format;
                                    cell.value = formatArgs.value;
                                }
                            }
                            else {
                                const evtArgs = {
                                    value: cell.value, format: cell.format, formattedText: cell.value,
                                    type: 'General', cell: cell, rowIndex: range[0], colIndex: range[1]
                                };
                                this.parent.notify(getFormattedCellObject, evtArgs);
                            }
                        }
                        else {
                            if (value.includes(curSymbol) || value.includes('%') ||
                                value.includes(getNumericObject(this.parent.locale).group)) {
                                const intl = new Internationalization();
                                const eventArgs = {
                                    intl: intl, updateValue: true, value: '', curSymbol: curSymbol,
                                    cell: cell
                                };
                                this.parent.notify(checkNumberFormat, {
                                    args: eventArgs, intl: intl, fResult: value,
                                    cell: cell
                                });
                            }
                        }
                    }
                }
                else if (!isNullOrUndefined(value) && value.toLowerCase().includes('unique(') && value.length > 0) {
                    cell.value = value;
                }
            }
            if (value === '#SPILL!') {
                cell.value = value;
            }
            else {
                const args = { cellIdx: range, isUnique: false };
                this.parent.notify(checkUniqueRange, args);
                if (this.parent.calculationMode === 'Manual' && isFormula && isNullOrUndefined(isDependentUpdate) &&
                    (actionName !== 'autofill' || cell.formula !== '') && !this.parent.isEdit &&
                    isNullOrUndefined(this.parent.element.querySelector('.e-text-replaceInp'))) {
                    skipFormula = true;
                    if (!isRedo && cell.value === undefined) {
                        skipFormula = false;
                    }
                }
                if (!skipFormula && !isDelete) {
                    this.parent.notify(workbookFormulaOperation, eventArgs);
                    isFormulaDependent = eventArgs.isFormulaDependent;
                }
                else {
                    value = cell.value;
                }
                if (isFormula) {
                    cell.formula = eventArgs.value;
                    if (this.parent.calculationMode === 'Manual' && skipFormula && isRedo && !this.parent.isEdit && cellInformation &&
                        cellInformation.cellDetails && cellInformation.cellDetails.length > 0 &&
                        cellInformation.cutCellDetails.length === 0 &&
                        (!isNullOrUndefined(cellInformation.cellDetails[0].autoFillText) ||
                            !isNullOrUndefined(cellInformation.cellDetails[0].copyCellValue))) {
                        for (let i = 0; i < cellInformation.cellDetails.length; i++) {
                            if (cellInformation.cellDetails[i].rowIndex === address[0] &&
                                cellInformation.cellDetails[i].colIndex === address[1]) {
                                if (cellInformation.cellDetails[i].copyCellValue) {
                                    value = cell.value = cellInformation.cellDetails[i].copyCellValue;
                                }
                                else {
                                    value = cell.value = cellInformation.cellDetails[i].autoFillText;
                                }
                                break;
                            }
                        }
                    }
                    else {
                        value = cell.value;
                        if (this.parent.calculationMode === 'Manual' && cellInformation && isRedo && cellInformation.displayText) {
                            value = cell.value = cellInformation.displayText;
                        }
                    }
                    const formula = cell.formula.toLowerCase();
                    const isNeedFormatUpdate = getTypeFromFormat(cell.format) === 'Scientific' && !skipFormatCheck && this.parent.isEdit;
                    if (formula === '=now()' && (!cell.format || cell.format === 'General' || isNeedFormatUpdate)) {
                        cell.format = `${getFormatFromType('ShortDate')} h:mm`;
                    }
                    else if (formula.includes('=time(') && (!cell.format || isNeedFormatUpdate)) {
                        cell.format = 'h:mm AM/PM';
                    }
                    else if (formula.includes('=date(') && isNeedFormatUpdate) {
                        cell.format = getFormatFromType('ShortDate');
                    }
                }
                else if (cell.value && typeof cell.value === 'string' && (cell.value.indexOf('www.') === 0 ||
                    cell.value.indexOf('https://') === 0 || cell.value.indexOf('http://') === 0 || cell.value.indexOf('ftp://') === 0)) {
                    this.parent.notify(setLinkModel, { hyperlink: cell.value, cell: `${sheet.name}!${getCellAddress(range[0], range[1])}` });
                }
            }
        }
        else {
            cell.value = value;
            if (cell.formattedText) {
                delete cell.formattedText;
            }
        }
        this.parent.setUsedRange(range[0], range[1], sheet);
        if (this.parent.chartColl.length && !this.parent.isEdit && !isRandomFormula) {
            this.parent.notify(refreshChart, { cell: cell, rIdx: range[0], cIdx: range[1], sheetIdx: sheetIdx, isRefreshChart: true });
        }
        return isFormulaDependent;
    }
}

/**
 * The `WorkbookHyperlink` module is used to handle Hyperlink action in Spreadsheet.
 */
class WorkbookHyperlink {
    /**
     * Constructor for WorkbookSort module.
     *
     * @param {Workbook} parent - Specifies the workbook.
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * To destroy the sort module.
     *
     * @returns {void} - To destroy the sort module.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(setLinkModel, this.setLinkHandler, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(setLinkModel, this.setLinkHandler);
        }
    }
    setLinkHandler(args) {
        let hyperlink = args.hyperlink;
        let cellAddr = args.cell;
        let sheet;
        if (cellAddr && cellAddr.indexOf('!') !== -1) {
            const lastIndex = cellAddr.lastIndexOf('!');
            sheet = getSheet(this.parent, getSheetIndex(this.parent, cellAddr.substring(0, lastIndex)));
            cellAddr = cellAddr.substring(lastIndex + 1);
            if (!sheet) {
                return;
            }
        }
        else {
            sheet = this.parent.getActiveSheet();
            cellAddr = cellAddr || sheet.selectedRange;
        }
        const isProtected = !args.triggerEvt && sheet.isProtected;
        if (isProtected && !sheet.protectSettings.insertLink) {
            return;
        }
        const cellIdx = getSwapRange(getRangeIndexes(cellAddr));
        if (typeof (hyperlink) === 'string') {
            if (hyperlink.toLowerCase().indexOf('www.') === 0) {
                hyperlink = 'http://' + hyperlink;
            }
        }
        else {
            if (hyperlink.address.toLowerCase().indexOf('www.') === 0) {
                hyperlink.address = 'http://' + hyperlink.address;
            }
        }
        let cellModel;
        const activeCell = getRangeIndexes(sheet.activeCell);
        for (let rIdx = cellIdx[0]; rIdx <= cellIdx[2]; rIdx++) {
            for (let cIdx = cellIdx[1]; cIdx <= cellIdx[3]; cIdx++) {
                if (isProtected && isLocked(getCell(rIdx, cIdx, sheet), getColumn(sheet, cIdx))) {
                    continue;
                }
                cellModel = { hyperlink: hyperlink };
                if (!isNullOrUndefined(args.displayText)) {
                    if (args.triggerEvt || args.isUndoRedo) {
                        if (rIdx === activeCell[0] && cIdx === activeCell[1]) {
                            cellModel.value = args.displayText;
                            delete cellModel.formattedText;
                        }
                    }
                    else {
                        cellModel.value = args.displayText;
                        delete cellModel.formattedText;
                    }
                }
                cellModel.style = { textDecoration: 'underline', color: '#00e' };
                updateCell(this.parent, sheet, { cell: cellModel, rowIdx: rIdx, colIdx: cIdx, preventEvt: !args.triggerEvt });
            }
        }
    }
    /**
     * Gets the module name.
     *
     *@returns {string} - returns the module name.
     */
    getModuleName() {
        return 'workbookHyperlink';
    }
}

/**
 * The `WorkbookInsert` module is used to insert cells, rows, columns and sheets in to workbook.
 */
class WorkbookInsert {
    /**
     * Constructor for the workbook insert module.
     *
     * @param {Workbook} parent - Specifies the workbook.
     * @private
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    // tslint:disable-next-line
    insertModel(args) {
        if (!args.model) {
            return;
        }
        let index;
        let model = [];
        let mergeCollection;
        let isModel;
        let maxHgtObj;
        if (typeof (args.start) === 'number') {
            index = args.start;
            args.end = args.end || index;
            if (index > args.end) {
                index = args.end;
                args.end = args.start;
            }
            if (args.modelType === 'Row' && index < args.model.maxHgts.length) {
                maxHgtObj = [];
            }
            for (let i = index; i <= args.end; i++) {
                model.push({});
                if (maxHgtObj) {
                    maxHgtObj.push(null);
                }
            }
        }
        else {
            if (args.start) {
                index = args.start[0].index || 0;
                model = args.start;
                isModel = true;
            }
            else {
                index = 0;
                model.push({});
            }
            if (args.modelType === 'Row' && index < args.model.maxHgts.length) {
                maxHgtObj = [];
                model.forEach(() => {
                    maxHgtObj.push(null);
                });
            }
        }
        const eventArgs = { model: model, index: index, modelType: args.modelType, insertType: args.insertType,
            cancel: false, isUndoRedo: args.isUndoRedo };
        const actionArgs = { eventArgs: eventArgs, action: 'insert' };
        if (args.isAction) {
            this.parent.notify(beginAction, actionArgs);
            if (eventArgs.cancel) {
                return;
            }
            delete eventArgs.cancel;
            eventArgs.isAction = args.isAction;
        }
        const insertArgs = { startIndex: index, endIndex: index + model.length - 1, modelType: args.modelType, sheet: args.model, isInsert: true };
        if (args.modelType === 'Row') {
            if (args.checkCount !== undefined && args.model.rows && args.checkCount === args.model.rows.length) {
                return;
            }
            this.parent.notify(refreshInsertDelete, insertArgs);
            args.model = args.model;
            if (!args.model.rows) {
                args.model.rows = [];
            }
            if (isModel && args.model.usedRange.rowIndex > -1 && index > args.model.usedRange.rowIndex) {
                for (let i = args.model.usedRange.rowIndex; i < index - 1; i++) {
                    model.splice(0, 0, {});
                }
            }
            const frozenRow = this.parent.frozenRowCount(args.model);
            if (index < frozenRow || (index <= frozenRow && args.freezePane)) {
                const newFrozenRows = args.model.frozenRows + model.length - ((index === frozenRow && frozenRow > 0) ? 1 : 0);
                this.parent.setSheetPropertyOnMute(args.model, 'frozenRows', newFrozenRows);
                eventArgs.freezePane = true;
            }
            args.model.rows.splice(index, 0, ...model);
            if (maxHgtObj) {
                args.model.maxHgts.splice(index, 0, ...maxHgtObj);
            }
            //this.setInsertInfo(args.model, index, model.length, 'count');
            this.setRowColCount(insertArgs.startIndex, insertArgs.endIndex, args.model, 'row');
            if (index > args.model.usedRange.rowIndex) {
                this.parent.setUsedRange(index + (model.length - 1), args.model.usedRange.colIndex, args.model, true);
            }
            else {
                this.parent.setUsedRange(args.model.usedRange.rowIndex + model.length, args.model.usedRange.colIndex, args.model, true);
            }
            const curIdx = index + model.length;
            let style;
            let cell;
            let newStyle;
            let parentCell;
            let mergeArgs;
            for (let i = 0; i <= args.model.usedRange.colIndex; i++) {
                if (args.model.rows[curIdx] && args.model.rows[curIdx].cells &&
                    args.model.rows[curIdx].cells[i]) {
                    cell = args.model.rows[curIdx].cells[i];
                    if (cell.rowSpan !== undefined && cell.rowSpan < 0 && cell.colSpan === undefined) {
                        mergeArgs = { range: [curIdx, i, curIdx, i], insertCount: model.length, insertModel: 'Row' };
                        this.parent.notify(insertMerge, mergeArgs);
                        if (!eventArgs.freezePane && mergeArgs.range[0] < frozenRow && mergeArgs.range[2] > frozenRow) {
                            eventArgs.freezePane = true;
                        }
                    }
                }
                parentCell = getCell(index - 1, i, args.model, false, true);
                style = parentCell.style;
                cell = getCell(index + 1, i, args.model, false, true);
                if (style || parentCell.wrap) {
                    if (style) {
                        newStyle = {};
                        Object.keys(style).forEach((key) => {
                            if (!(key === 'borderLeft' || key === 'borderRight' || key === 'borderTop' || key === 'borderBottom')) {
                                newStyle[key] = style[key];
                            }
                        });
                        if (cell.style) {
                            this.checkBorder(cell.style, args.model.rows[index - 1].cells[i].style, newStyle);
                        }
                    }
                    if (!args.isUndoRedo || args.isRedo) {
                        model.forEach((row) => {
                            if (!row.cells) {
                                row.cells = [];
                            }
                            if (!row.cells[i]) {
                                row.cells[i] = {};
                            }
                            if (style) {
                                if (!row.cells[i].style) {
                                    row.cells[i].style = {};
                                }
                                Object.assign(row.cells[i].style, newStyle);
                            }
                            if (parentCell.wrap) {
                                row.cells[i].wrap = true;
                            }
                        });
                    }
                }
            }
            eventArgs.sheetCount = args.model.rows.length;
        }
        else if (args.modelType === 'Column') {
            if (args.checkCount !== undefined && args.model.columns && args.checkCount === args.model.columns.length) {
                return;
            }
            this.parent.notify(refreshInsertDelete, insertArgs);
            args.model = args.model;
            if (!args.model.columns) {
                args.model.columns = [];
            }
            if (index && !args.model.columns[index - 1]) {
                args.model.columns[index - 1] = {};
            }
            args.model.columns.splice(index, 0, ...model);
            const frozenCol = this.parent.frozenColCount(args.model);
            if (index < frozenCol || (index <= frozenCol && args.freezePane)) {
                const newFrozenCols = args.model.frozenColumns + model.length - ((index === frozenCol && frozenCol > 0) ? 1 : 0);
                this.parent.setSheetPropertyOnMute(args.model, 'frozenColumns', newFrozenCols);
                eventArgs.freezePane = true;
            }
            //this.setInsertInfo(args.model, index, model.length, 'fldLen', 'Column');
            this.setRowColCount(insertArgs.startIndex, insertArgs.endIndex, args.model, 'col');
            if (index > args.model.usedRange.colIndex) {
                this.parent.setUsedRange(args.model.usedRange.rowIndex, index + (model.length - 1), args.model, true);
            }
            else {
                this.parent.setUsedRange(args.model.usedRange.rowIndex, args.model.usedRange.colIndex + model.length, args.model, true);
            }
            if (!args.model.rows) {
                args.model.rows = [];
            }
            const cellModel = [];
            if (!args.columnCellsModel) {
                args.columnCellsModel = [];
            }
            for (let i = 0; i < model.length; i++) {
                cellModel.push(null);
            }
            mergeCollection = [];
            let cell;
            let style;
            let newStyle;
            let parentCell;
            for (let i = 0; i <= args.model.usedRange.rowIndex; i++) {
                if (!args.model.rows[i]) {
                    args.model.rows[i] = { cells: [] };
                }
                else if (!args.model.rows[i].cells) {
                    args.model.rows[i].cells = [];
                }
                if (index && !args.model.rows[i].cells[index - 1]) {
                    args.model.rows[i].cells[index - 1] = {};
                }
                args.model.rows[i].cells.splice(index, 0, ...(args.columnCellsModel[i] &&
                    args.columnCellsModel[i].cells ? args.columnCellsModel[i].cells : cellModel));
                const curIdx = index + model.length;
                if (args.model.rows[i].cells[curIdx]) {
                    cell = args.model.rows[i].cells[curIdx];
                    if (cell.colSpan !== undefined && cell.colSpan < 0 && cell.rowSpan === undefined) {
                        mergeCollection.push({
                            range: [i, curIdx, i, curIdx], insertCount: cellModel.length, insertModel: 'Column'
                        });
                    }
                }
                parentCell = getCell(i, index - 1, args.model, false, true);
                style = parentCell.style;
                cell = getCell(i, index + 1, args.model, false, true);
                if (style || parentCell.wrap) {
                    if (style) {
                        newStyle = {};
                        Object.keys(style).forEach((key) => {
                            if (!(key === 'borderLeft' || key === 'borderRight' || key === 'borderTop' || key === 'borderBottom')) {
                                newStyle[key] = style[key];
                            }
                        });
                        if (cell.style) {
                            this.checkBorder(cell.style, args.model.rows[i].cells[index - 1].style, newStyle);
                        }
                    }
                    if (!args.isUndoRedo || args.isRedo) {
                        for (let j = index; j < curIdx; j++) {
                            if (!args.model.rows[i].cells[j]) {
                                args.model.rows[i].cells[j] = {};
                            }
                            if (style) {
                                if (!args.model.rows[i].cells[j].style) {
                                    args.model.rows[i].cells[j].style = {};
                                }
                                Object.assign(args.model.rows[i].cells[j].style, newStyle);
                            }
                            if (parentCell.wrap) {
                                args.model.rows[i].cells[j].wrap = true;
                            }
                        }
                    }
                }
            }
            mergeCollection.forEach((mergeArgs) => {
                this.parent.notify(insertMerge, mergeArgs);
                if (!eventArgs.freezePane && mergeArgs.range[1] < frozenCol && mergeArgs.range[3] > frozenCol) {
                    eventArgs.freezePane = true;
                }
            });
            eventArgs.sheetCount = args.model.columns.length;
        }
        else {
            if (args.checkCount !== undefined && args.checkCount === this.parent.sheets.length) {
                return;
            }
            const sheetModel = model;
            const sheetName = getSheetName(this.parent);
            const isFromUpdateAction = args.isFromUpdateAction;
            for (let i = 0; i < sheetModel.length; i++) {
                if (sheetModel[i].name) {
                    for (let j = 0; j < this.parent.sheets.length; j++) {
                        if (sheetModel[i].name === this.parent.sheets[j].name) {
                            sheetModel.splice(i, 1);
                            i--;
                            break;
                        }
                    }
                }
            }
            if (!sheetModel.length) {
                return;
            }
            delete model[0].index;
            this.parent.createSheet(index, model);
            let id;
            if (args.activeSheetIndex) {
                eventArgs.activeSheetIndex = args.activeSheetIndex;
                this.parent.setProperties({ activeSheetIndex: args.activeSheetIndex }, true);
            }
            else if (!args.isAction && args.start < this.parent.activeSheetIndex) {
                this.parent.setProperties({ activeSheetIndex: this.parent.skipHiddenSheets(this.parent.activeSheetIndex) }, true);
            }
            if (isFromUpdateAction) {
                this.parent.setProperties({ activeSheetIndex: getSheetIndex(this.parent, sheetName) }, true);
            }
            model.forEach((sheet) => {
                if (isModel) {
                    this.updateRangeModel(sheet.ranges);
                }
                const viewport = this.parent.viewport;
                const refreshRange = [viewport.topIndex, viewport.leftIndex, viewport.bottomIndex, viewport.rightIndex];
                const args = {
                    sheet: sheet, resolveAfterFullDataLoaded: true,
                    indexes: refreshRange, promise: new Promise((resolve) => { resolve((() => { })()); })
                };
                this.parent.notify(updateSheetFromDataSource, args);
                id = sheet.id;
                this.parent.notify(workbookFormulaOperation, {
                    action: 'addSheet', visibleName: sheet.name, sheetName: 'Sheet' + id, sheetId: id
                });
            });
            eventArgs.activeSheetIndex = args.activeSheetIndex;
            eventArgs.sheetCount = this.parent.sheets.length;
        }
        if (args.modelType !== 'Sheet') {
            this.insertConditionalFormats(args);
            this.parent.notify(refreshClipboard, { start: index, end: index + model.length - 1, modelType: args.modelType, model: args.model, isInsert: true });
            eventArgs.activeSheetIndex = getSheetIndex(this.parent, args.model.name);
        }
        this.parent.notify(insert, actionArgs);
    }
    setRowColCount(startIdx, endIdx, sheet, layout) {
        const prop = layout + 'Count';
        this.parent.setSheetPropertyOnMute(sheet, prop, sheet[`${prop}`] + ((endIdx - startIdx) + 1));
        if (sheet.id === this.parent.getActiveSheet().id) {
            this.parent.notify(updateRowColCount, { index: sheet[`${prop}`] - 1, update: layout, isInsert: true, start: startIdx, end: endIdx });
        }
    }
    updateRangeModel(ranges) {
        ranges.forEach((range) => {
            if (range.dataSource) {
                range.startCell = range.startCell || 'A1';
                range.showFieldAsHeader = range.showFieldAsHeader === undefined || range.showFieldAsHeader;
                range.template = range.template || '';
                range.address = range.address || 'A1';
            }
        });
    }
    checkBorder(style, adjStyle, newStyle) {
        if (style.borderLeft && style.borderLeft === adjStyle.borderLeft) {
            newStyle.borderLeft = style.borderLeft;
        }
        if (style.borderRight && style.borderRight === adjStyle.borderRight) {
            newStyle.borderRight = style.borderRight;
        }
        if (style.borderTop && style.borderTop === adjStyle.borderTop) {
            newStyle.borderTop = style.borderTop;
        }
        if (style.borderBottom && style.borderBottom === adjStyle.borderBottom) {
            newStyle.borderBottom = style.borderBottom;
        }
    }
    setInsertInfo(sheet, startIndex, count, totalKey, modelType = 'Row') {
        const endIndex = count = startIndex + (count - 1);
        sheet.ranges.forEach((range) => {
            if (range.info && startIndex < range.info[`${totalKey}`]) {
                if (!range.info[`insert${modelType}Range`]) {
                    range.info[`insert${modelType}Range`] = [[startIndex, endIndex]];
                }
                else {
                    range.info[`insert${modelType}Range`].push([startIndex, endIndex]);
                }
                range.info[`${totalKey}`] += ((endIndex - startIndex) + 1);
            }
        });
    }
    insertConditionalFormats(args) {
        const cfCollection = args.model.conditionalFormats;
        if (args.prevAction === 'delete') {
            this.parent.setSheetPropertyOnMute(args.model, 'conditionalFormats', args.conditionalFormats);
        }
        else if (cfCollection) {
            for (let i = 0, cfLength = cfCollection.length; i < cfLength; i++) {
                cfCollection[i].range = getRangeAddress(insertFormatRange(args, getRangeIndexes(cfCollection[i].range), !args.isAction && !args.isUndoRedo));
            }
        }
    }
    addEventListener() {
        this.parent.on(insertModel, this.insertModel, this);
    }
    /**
     * Destroy workbook insert module.
     *
     * @returns {void} - destroy the workbook insert module.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(insertModel, this.insertModel);
        }
    }
    /**
     * Get the workbook insert module name.
     *
     * @returns {string} - Return the string.
     */
    getModuleName() {
        return 'workbookinsert';
    }
}

/**
 * The `WorkbookDelete` module is used to delete cells, rows, columns and sheets from workbook.
 */
class WorkbookDelete {
    /**
     * Constructor for the workbook delete module.
     *
     * @param {Workbook} parent - Specify the workbook
     * @private
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    // tslint:disable-next-line
    deleteModel(args) {
        const sheetLength = this.parent.sheets.length;
        if (args.modelType === 'Sheet' && sheetLength === 1) {
            return;
        }
        const modelName = `${args.modelType.toLowerCase()}s`;
        args.start = args.start;
        if (args.start > args.end) {
            const startIdx = args.start;
            args.start = args.end;
            args.end = startIdx;
        }
        const eventArgs = { startIndex: args.start, endIndex: args.end, modelType: args.modelType,
            cancel: false, isUndoRedo: args.isUndoRedo };
        const actionArgs = { eventArgs: eventArgs, action: 'delete' };
        if (args.isAction) {
            this.parent.notify(beginAction, actionArgs);
            if (eventArgs.cancel) {
                return;
            }
        }
        let deletedCells;
        let prevCell;
        const mergeArgsCollection = [];
        const count = (args.end - args.start) + 1;
        const insertArgs = { startIndex: args.start, endIndex: args.end, modelType: args.modelType, sheet: args.model, isDelete: true };
        const isFinite = this.parent.scrollSettings.isFinite;
        if (args.modelType === 'Row') {
            if (args.checkCount !== undefined && args.checkCount === args.model.usedRange.rowIndex) {
                return;
            }
            this.parent.notify(refreshInsertDelete, insertArgs);
            args.model = args.model;
            if (isFinite) {
                if (args.start >= args.model.rowCount) {
                    return;
                }
                if (args.end >= args.model.rowCount) {
                    args.end = args.model.rowCount - 1;
                }
            }
            else {
                if (args.start > args.model.usedRange.rowIndex) {
                    return;
                }
                if (args.end > args.model.usedRange.rowIndex) {
                    args.end -= (args.end - args.model.usedRange.rowIndex);
                }
            }
            this.setRowColCount(args.start, args.end, args.model, 'row');
            if (args.start <= args.model.usedRange.rowIndex) {
                this.parent.setSheetPropertyOnMute(args.model, 'usedRange', { rowIndex: args.model.usedRange.rowIndex - ((args.end - args.start) + 1),
                    colIndex: args.model.usedRange.colIndex });
                if (args.model.usedRange.rowIndex < 0) {
                    this.parent.setSheetPropertyOnMute(args.model, 'usedRange', { rowIndex: 0, colIndex: args.model.usedRange.colIndex });
                }
            }
            let frozenRow = this.parent.frozenRowCount(args.model);
            if (args.start < frozenRow) {
                frozenRow = args.end < frozenRow ? (args.end - args.start) + 1 : frozenRow - args.start;
                frozenRow = args.model.frozenRows - frozenRow;
                this.parent.setSheetPropertyOnMute(args.model, 'frozenRows', frozenRow);
                eventArgs.freezePane = true;
            }
            const curIdx = args.end + 1;
            let cell;
            let mergeArgs;
            if (args.model.rows[args.start] && args.model.rows[args.start].cells) {
                for (let i = 0; i <= args.model.usedRange.colIndex; i++) {
                    if (args.model.rows[args.start].cells[i] &&
                        args.model.rows[args.start].cells[i].rowSpan !== undefined &&
                        args.model.rows[args.start].cells[i].rowSpan < 0 &&
                        args.model.rows[args.start].cells[i].colSpan === undefined) {
                        mergeArgs = { range: [args.start, i, args.start, i] };
                        this.parent.notify(activeCellMergedRange, mergeArgs);
                        mergeArgs.range = mergeArgs.range;
                        if (mergeArgs.range[2] <= args.end) {
                            prevCell = getCell(mergeArgs.range[0], i, args.model);
                            if (prevCell && prevCell.rowSpan > 1) {
                                if (prevCell.rowSpan - ((mergeArgs.range[2] - args.start) + 1) > 1) {
                                    setCell(mergeArgs.range[0], i, args.model, { colSpan: prevCell.rowSpan - ((mergeArgs.range[2] - args.start) + 1) }, true);
                                }
                                else {
                                    delete args.model.rows[mergeArgs.range[0]].cells[i].rowSpan;
                                }
                            }
                            mergeArgs = null;
                        }
                    }
                    if (args.model.rows[curIdx] && args.model.rows[curIdx].cells &&
                        args.model.rows[curIdx].cells[i] && args.model.rows[curIdx].cells[i].rowSpan
                        !== undefined && args.model.rows[curIdx].cells[i].rowSpan < 0 &&
                        args.model.rows[curIdx].cells[i].colSpan === undefined) {
                        if (!mergeArgs) {
                            mergeArgs = { range: [curIdx, i, curIdx, i] };
                            this.parent.notify(activeCellMergedRange, mergeArgs);
                        }
                        cell = new Object();
                        mergeArgs.range = mergeArgs.range;
                        Object.assign(cell, getCell(mergeArgs.range[0], mergeArgs.range[1], args.model));
                        if (cell && cell.rowSpan && (cell.rowSpan > 1 || cell.colSpan > 1)) {
                            const indexes = [];
                            indexes[1] = i;
                            indexes[3] = cell.colSpan > 1 ? i + (cell.colSpan - 1) : i;
                            mergeArgs.range = mergeArgs.range;
                            if (mergeArgs.range[0] < args.start) {
                                indexes[0] = indexes[2] = mergeArgs.range[0];
                                if (cell.rowSpan - count > 1) {
                                    indexes[2] += (cell.rowSpan - count - 1);
                                }
                            }
                            else {
                                indexes[0] = indexes[2] = args.start;
                                if (cell.rowSpan - ((args.end - mergeArgs.range[0]) + 1) > 1) {
                                    indexes[2] += ((cell.rowSpan - ((args.end - mergeArgs.range[0]) + 1)) - 1);
                                }
                            }
                            mergeArgsCollection.push({
                                range: indexes, isAction: false, preventRefresh: true, merge: true,
                                type: 'All', skipChecking: true
                            });
                        }
                    }
                    mergeArgs = null;
                }
            }
            eventArgs.sheetCount = args.model.usedRange.rowIndex;
        }
        else if (args.modelType === 'Column') {
            if (args.checkCount !== undefined && args.checkCount === args.model.usedRange.colIndex) {
                return;
            }
            this.parent.notify(refreshInsertDelete, insertArgs);
            args.model = args.model;
            if (isFinite) {
                if (args.start >= args.model.colCount) {
                    return;
                }
                if (args.end >= args.model.colCount) {
                    args.end = args.model.colCount - 1;
                }
            }
            else {
                if (args.start > args.model.usedRange.colIndex) {
                    return;
                }
                if (args.end > args.model.usedRange.colIndex) {
                    args.end -= (args.end - args.model.usedRange.colIndex);
                }
            }
            this.setRowColCount(args.start, args.end, args.model, 'col');
            if (args.start <= args.model.usedRange.colIndex) {
                this.parent.setSheetPropertyOnMute(args.model, 'usedRange', { rowIndex: args.model.usedRange.rowIndex, colIndex: args.model.usedRange.colIndex - count });
                if (args.model.usedRange.colIndex < 0) {
                    this.parent.setSheetPropertyOnMute(args.model, 'usedRange', { rowIndex: args.model.usedRange.rowIndex, colIndex: 0 });
                }
            }
            //this.setDeleteInfo(args.start, args.end, 'fldLen', 'Column');
            let frozenCol = this.parent.frozenColCount(args.model);
            if (args.start < frozenCol) {
                frozenCol = args.end < frozenCol ? (args.end - args.start) + 1 : frozenCol - args.start;
                frozenCol = args.model.frozenColumns - frozenCol;
                this.parent.setSheetPropertyOnMute(args.model, 'frozenColumns', frozenCol);
                this.parent.updateTopLeftCell();
                eventArgs.freezePane = true;
            }
            deletedCells = [];
            const curIdx = args.end + 1;
            let cell;
            let mergeArgs;
            for (let i = 0; i <= args.model.usedRange.rowIndex; i++) {
                deletedCells.push({});
                if (args.model.rows[i] && args.model.rows[i].cells) {
                    if (args.model.rows[i].cells[args.start] && args.model.rows[i].cells[args.start].colSpan !==
                        undefined && args.model.rows[i].cells[args.start].colSpan < 0 &&
                        args.model.rows[i].cells[args.start].rowSpan === undefined) {
                        mergeArgs = { range: [i, args.start, i, args.start] };
                        this.parent.notify(activeCellMergedRange, mergeArgs);
                        mergeArgs.range = mergeArgs.range;
                        if (mergeArgs.range[3] <= args.end) {
                            const prevCell = getCell(i, mergeArgs.range[1], args.model);
                            if (prevCell && prevCell.colSpan > 1) {
                                if (prevCell.colSpan - ((mergeArgs.range[3] - args.start) + 1) > 1) {
                                    setCell(i, mergeArgs.range[1], args.model, { colSpan: prevCell.colSpan - ((mergeArgs.range[3] - args.start) + 1) }, true);
                                }
                                else {
                                    delete args.model.rows[i].cells[mergeArgs.range[1]].colSpan;
                                }
                            }
                            mergeArgs = null;
                        }
                    }
                    if (args.model.rows[i].cells[curIdx] && args.model.rows[i].cells[curIdx].colSpan
                        !== undefined && args.model.rows[i].cells[curIdx].colSpan < 0 &&
                        args.model.rows[i].cells[curIdx].rowSpan === undefined) {
                        if (!mergeArgs) {
                            mergeArgs = { range: [i, curIdx, i, curIdx] };
                            this.parent.notify(activeCellMergedRange, mergeArgs);
                        }
                        cell = new Object();
                        mergeArgs.range = mergeArgs.range;
                        Object.assign(cell, getCell(mergeArgs.range[0], mergeArgs.range[1], args.model));
                        if (cell && cell.colSpan && (cell.colSpan > 1 || cell.rowSpan > 1)) {
                            const indexes = [];
                            indexes[0] = i;
                            indexes[2] = cell.rowSpan > 1 ? i + (cell.rowSpan - 1) : i;
                            mergeArgs.range = mergeArgs.range;
                            if (mergeArgs.range[1] < args.start) {
                                indexes[1] = indexes[3] = mergeArgs.range[1];
                                if (cell.colSpan - count > 1) {
                                    indexes[3] += (cell.colSpan - count - 1);
                                }
                            }
                            else {
                                indexes[1] = indexes[3] = args.start;
                                if (cell.colSpan - ((args.end - mergeArgs.range[1]) + 1) > 1) {
                                    indexes[3] += ((cell.colSpan - ((args.end - mergeArgs.range[1]) + 1)) - 1);
                                }
                            }
                            mergeArgsCollection.push({
                                range: indexes, isAction: false, preventRefresh: true, merge: true,
                                type: 'All', skipChecking: true
                            });
                        }
                    }
                    deletedCells[i].cells = args.model.rows[i].cells.splice(args.start, count);
                    mergeArgs = null;
                }
            }
            eventArgs.sheetCount = args.model.usedRange.colIndex;
            eventArgs.deletedCellsModel = deletedCells;
        }
        else {
            if ((args.end - args.start === this.parent.sheets.length - 1) || (args.checkCount !== undefined && args.checkCount ===
                this.parent.sheets.length)) {
                return;
            }
            this.parent.notify(refreshInsertDelete, insertArgs);
            eventArgs.sheetCount = this.parent.sheets.length;
            eventArgs.activeSheetIndex = this.parent.activeSheetIndex;
        }
        const deletedModel = [];
        const deleteMaxHgt = args.modelType === 'Row' && args.start < args.model.maxHgts.length;
        const sheetsModel = args.model[`${modelName}`];
        for (let i = args.start; i <= args.end; i++) {
            if (args.modelType === 'Sheet' && sheetsModel[i]) {
                this.parent.notify(workbookFormulaOperation, { action: 'deleteSheetTab', sheetId: sheetsModel[i].id });
            }
            if (sheetsModel[args.start] || args.start < sheetsModel.length) {
                deletedModel.push(sheetsModel[args.start] || {});
                sheetsModel.splice(args.start, 1);
            }
            else {
                deletedModel.push({});
            }
            if (i === args.start) {
                deletedModel[0].index = args.start;
            }
            if (deleteMaxHgt) {
                args.model.maxHgts.splice(args.start, 1);
            }
        }
        mergeArgsCollection.forEach((merge) => this.parent.notify(setMerge, merge));
        this.parent.notify(beforeDelete, args);
        if (args.modelType !== 'Sheet') {
            this.parent.notify(refreshClipboard, args);
            eventArgs.refreshSheet = args.refreshSheet;
            eventArgs.activeSheetIndex = getSheetIndex(this.parent, args.model.name);
            eventArgs['conditionalFormats'] = [];
            this.deleteConditionalFormats(args, eventArgs);
        }
        eventArgs.definedNames = insertArgs.definedNames;
        eventArgs.isAction = args.isAction;
        eventArgs.deletedModel = deletedModel;
        delete eventArgs.cancel;
        this.parent.notify(deleteAction, actionArgs);
    }
    setRowColCount(startIdx, endIdx, sheet, layout) {
        const prop = layout + 'Count';
        const curCount = sheet[`${prop}`];
        if (endIdx >= curCount) {
            endIdx = curCount - 1;
        }
        if (endIdx < startIdx) {
            return;
        }
        this.parent.setSheetPropertyOnMute(sheet, prop, curCount - ((endIdx - startIdx) + 1));
        if (sheet.id === this.parent.getActiveSheet().id) {
            this.parent.notify(updateRowColCount, { index: curCount - 1, update: layout, isDelete: true, start: startIdx, end: endIdx });
        }
    }
    deleteConditionalFormats(args, eventArgs) {
        const cfCollection = args.model.conditionalFormats;
        if (cfCollection) {
            for (let i = 0; i < cfCollection.length; i++) {
                eventArgs['conditionalFormats'].push(extend({}, cfCollection[i], null, true));
                const cfRange = getRangeIndexes(cfCollection[i].range);
                const sltRangeIndex = getRangeIndexes(args.model.selectedRange);
                if ((args.modelType === 'Column' && sltRangeIndex[1] <= cfRange[1] && sltRangeIndex[3] >= cfRange[3]) || (args.modelType === 'Row' && sltRangeIndex[0] <= cfRange[0] && sltRangeIndex[2] >= cfRange[2])) {
                    cfCollection.splice(cfCollection.indexOf(cfCollection[i]), 1);
                    i--;
                }
                else {
                    cfCollection[i].range = getRangeAddress(deleteFormatRange(args, cfRange));
                }
            }
        }
    }
    addEventListener() {
        this.parent.on(deleteModel, this.deleteModel, this);
    }
    /**
     * Destroy workbook delete module.
     *
     * @returns {void}
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(deleteModel, this.deleteModel);
        }
    }
    /**
     * Get the workbook delete module name.
     *
     * @returns {string} - returns the module name.
     */
    getModuleName() {
        return 'workbookdelete';
    }
}

/**
 * The `WorkbookHyperlink` module is used to handle Hyperlink action in Spreadsheet.
 */
class WorkbookDataValidation {
    /**
     * Constructor for WorkbookSort module.
     *
     * @param {Workbook} parent - Specifies the parent element.
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * To destroy the sort module.
     *
     * @returns {void}
     */
    destroy() {
        this.removeEventListener();
        this.highlightInvalidData = null;
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(cellValidation, this.updateValidationHandler, this);
        this.parent.on(addHighlight, this.addHighlightHandler, this);
        this.parent.on(removeHighlight, this.removeHighlightHandler, this);
        this.parent.on(beforeInsert, this.beforeInsertDeleteHandler, this);
        this.parent.on(beforeDelete, this.beforeInsertDeleteHandler, this);
        this.parent.on(refreshInsertDelete, this.beforeInsertDeleteHandler, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(cellValidation, this.updateValidationHandler);
            this.parent.off(addHighlight, this.addHighlightHandler);
            this.parent.off(removeHighlight, this.removeHighlightHandler);
            this.parent.off(beforeInsert, this.beforeInsertDeleteHandler);
            this.parent.off(beforeDelete, this.beforeInsertDeleteHandler);
            this.parent.off(refreshInsertDelete, this.beforeInsertDeleteHandler);
        }
    }
    updateValidationHandler(args) {
        let sheetName;
        const lastIndex = args.range.lastIndexOf('!');
        let sheet;
        let isActiveSheet;
        if (lastIndex > -1) {
            sheetName = args.range.substring(0, lastIndex);
            args.range = args.range.substring(lastIndex + 1);
            const sheetIdx = getSheetIndex(this.parent, sheetName);
            sheet = getSheet(this.parent, sheetIdx);
            isActiveSheet = sheetIdx === this.parent.activeSheetIndex;
        }
        else {
            sheet = this.parent.getActiveSheet();
            isActiveSheet = true;
        }
        const rangeInfo = this.getRangeWhenColumnSelected(args.range, sheet);
        if (sheetName) {
            args.range = sheetName + '!' + rangeInfo.range;
        }
        const indexes = getSwapRange(getRangeIndexes(rangeInfo.range));
        let column;
        let cell;
        let frozenRow;
        let uiRefresh;
        let viewport;
        let updateCellHighlightOnUI;
        let updateColHighlightOnUI;
        const options = { colIdx: indexes[1] };
        if (isActiveSheet) {
            frozenRow = this.parent.frozenRowCount(sheet);
            const frozenCol = this.parent.frozenColCount(sheet);
            const parent = this.parent;
            const viewOffset = parent.viewport || {};
            viewport = parent.scrollSettings && parent.scrollSettings.enableVirtualization ? [frozenRow + viewOffset.topIndex, frozenCol +
                    viewOffset.leftIndex, viewOffset.bottomIndex, viewOffset.rightIndex] : [0, 0, sheet.rowCount - 1, sheet.colCount - 1];
            if (rangeInfo.isFullCol) {
                const viewportRowIndexes = [[viewport[0], viewport[2]]];
                if (frozenRow) {
                    viewportRowIndexes.push([getRangeIndexes(sheet.topLeftCell)[0], frozenRow - 1]);
                }
                updateColHighlightOnUI = (validation) => {
                    if (validation.isHighlighted && ((options.colIdx >= viewport[1] && options.colIdx <= viewport[3]) ||
                        options.colIdx < frozenCol) && !isHiddenCol(sheet, options.colIdx)) {
                        viewportRowIndexes.forEach((indexes) => {
                            for (options.rowIdx = indexes[0]; options.rowIdx <= indexes[1]; options.rowIdx++) {
                                if (!isHiddenRow(sheet, options.rowIdx)) {
                                    options.cell = getCell(options.rowIdx, options.colIdx, sheet, false, true);
                                    options.validation = options.cell.validation ? options.cell.validation : validation;
                                    this.parent.notify(updateHighlight, options);
                                }
                            }
                        });
                    }
                };
            }
            updateCellHighlightOnUI = (validation) => {
                if (validation.isHighlighted && uiRefresh && ((options.colIdx >= viewport[1] && options.colIdx <= viewport[3]) ||
                    options.colIdx < frozenCol) && !isHiddenCol(sheet, options.colIdx)) {
                    this.parent.notify(updateHighlight, options);
                }
            };
        }
        let highlightObj;
        let isListType;
        let activeIdx;
        let updateFormula;
        if (args.isRemoveValidation) {
            if (isActiveSheet) {
                activeIdx = getRangeIndexes(sheet.activeCell);
                if (activeIdx[0] >= indexes[0] && activeIdx[1] >= indexes[1] && activeIdx[0] <= indexes[2] && activeIdx[1] <= indexes[3]) {
                    const validation = getCell(activeIdx[0], activeIdx[1], sheet, false, true).validation ||
                        (checkColumnValidation(sheet.columns[indexes[1]], activeIdx[0], activeIdx[1]) &&
                            sheet.columns[activeIdx[1]].validation);
                    isListType = validation && validation.type === 'List';
                }
                options.isRemoveValidation = true;
                options.isRemoveHighlightedData = true;
            }
        }
        else {
            if (args.isAction && this.highlightInvalidData) {
                highlightObj = { isHighlighted: this.highlightInvalidData };
            }
            if (args.rules.type === 'List') {
                activeIdx = getRangeIndexes(sheet.activeCell);
                isListType = isActiveSheet && activeIdx[0] >= indexes[0] && activeIdx[1] >= indexes[1] && activeIdx[0] <= indexes[2] &&
                    activeIdx[1] <= indexes[3];
                if (args.rules.value1) {
                    args.rules.value1 = args.rules.value1.trim();
                    if (args.rules.value1[args.rules.value1.length - 1] === this.parent.listSeparator) {
                        args.rules.value1 = args.rules.value1.substring(0, args.rules.value1.length - 1);
                    }
                }
            }
            else if (args.rules.type === 'Custom' && !isNullOrUndefined(args.rules.value2)) {
                delete args.rules.value2;
            }
            if (isActiveSheet) {
                options.removeOnValidData = true;
            }
            const isFormulaVal1 = checkIsFormula(args.rules.value1);
            const isFormulaVal2 = checkIsFormula(args.rules.value2);
            updateFormula = (rowIdx) => {
                // Calculate previous indexes based on the original starting point of the formula
                if (isFormulaVal1) {
                    options.validation.value1 = getUpdatedFormula([rowIdx, options.colIdx, rowIdx, options.colIdx], indexes, sheet, this.parent, { formula: args.rules.value1 });
                }
                if (isFormulaVal2) {
                    options.validation.value2 = getUpdatedFormula([rowIdx, options.colIdx, rowIdx, options.colIdx], indexes, sheet, this.parent, { formula: args.rules.value2 });
                }
            };
        }
        for (options.colIdx; options.colIdx <= indexes[3]; options.colIdx++) {
            if (rangeInfo.isFullCol) {
                if (args.isRemoveValidation) {
                    column = sheet.columns[options.colIdx];
                    if (column && column.validation) {
                        if (isActiveSheet) {
                            updateColHighlightOnUI(column.validation);
                        }
                        delete column.validation;
                    }
                }
                else {
                    options.validation = Object.assign({}, args.rules, highlightObj);
                    updateFormula(0);
                    if (!sheet.columns[options.colIdx]) {
                        sheet.columns[options.colIdx] = {};
                    }
                    sheet.columns[options.colIdx].validation = options.validation;
                    if (isActiveSheet) {
                        updateColHighlightOnUI(options.validation);
                    }
                    continue;
                }
            }
            for (options.rowIdx = indexes[0]; options.rowIdx <= indexes[2]; options.rowIdx++) {
                uiRefresh = isActiveSheet && ((options.rowIdx >= viewport[0] && options.rowIdx <= viewport[2]) ||
                    options.rowIdx < frozenRow) && !isHiddenRow(sheet, options.rowIdx);
                if (args.isRemoveValidation) {
                    column = sheet.columns[options.colIdx];
                    if (column && column.validation) {
                        if (options.rowIdx === indexes[2]) {
                            column.validation.address = getSplittedAddressForColumn(column.validation.address, [indexes[0], options.colIdx, indexes[2], options.colIdx], options.colIdx);
                        }
                        if (isActiveSheet) {
                            updateCellHighlightOnUI(column.validation);
                        }
                    }
                    cell = getCell(options.rowIdx, options.colIdx, sheet);
                    if (cell && cell.validation && !updateCell(this.parent, sheet, { cell: { validation: {} }, rowIdx: options.rowIdx, colIdx: options.colIdx })) {
                        if (isActiveSheet) {
                            updateCellHighlightOnUI(cell.validation);
                        }
                        delete cell.validation;
                    }
                }
                else {
                    options.validation = Object.assign({}, args.rules, highlightObj);
                    updateFormula(options.rowIdx);
                    if (!updateCell(this.parent, sheet, { cell: { validation: options.validation }, rowIdx: options.rowIdx, colIdx: options.colIdx })) {
                        if (isActiveSheet) {
                            options.cell = getCell(options.rowIdx, options.colIdx, sheet);
                            updateCellHighlightOnUI(options.validation);
                        }
                    }
                }
            }
        }
        if (isListType) {
            cell = getCell(activeIdx[0], activeIdx[1], sheet, false, true);
            let validation = cell.validation;
            if (!validation) {
                validation = checkColumnValidation(sheet.columns[activeIdx[1]], activeIdx[0], activeIdx[1]) ?
                    sheet.columns[activeIdx[1]].validation : {};
            }
            this.parent.notify(addListValidationDropdown, { validation, cell, rowIdx: activeIdx[0], colIdx: activeIdx[1], isRefresh: true });
        }
    }
    addHighlightHandler(args) {
        if (args.isAction) {
            this.highlightInvalidData = true;
        }
        this.invalidDataHandler(args.range);
    }
    removeHighlightHandler(args) {
        if (args.isAction) {
            this.highlightInvalidData = null;
        }
        this.invalidDataHandler(args.range, true);
    }
    invalidDataHandler(range, isRemoveHighlightedData) {
        let cell;
        let col;
        let rowIdx;
        let colIdx;
        let indexes;
        let uiRefresh;
        let isActiveSheet;
        let isFullRange;
        let lastColIdx;
        let row;
        const parent = this.parent;
        let sheet = this.parent.getActiveSheet();
        const frozenRow = this.parent.frozenRowCount(sheet);
        const frozenCol = this.parent.frozenColCount(sheet);
        const viewport = parent.scrollSettings && parent.scrollSettings.enableVirtualization ? (parent.viewport ?
            [frozenRow + parent.viewport.topIndex, frozenCol + parent.viewport.leftIndex, parent.viewport.bottomIndex,
                parent.viewport.rightIndex] : []) : [0, 0, sheet.rowCount - 1, sheet.colCount - 1];
        const updateHighlightOnUI = (validation, col) => {
            if (uiRefresh && ((colIdx >= viewport[1] && colIdx <= viewport[3]) || colIdx < frozenCol) && !isHiddenCol(sheet, colIdx)) {
                this.parent.notify(updateHighlight, {
                    isRemoveHighlightedData: isRemoveHighlightedData, rowIdx: rowIdx, colIdx: colIdx, cell: cell,
                    validation: validation, removeOnValidData: true, col: col
                });
            }
        };
        let updateHighlightProp;
        if (isRemoveHighlightedData) {
            updateHighlightProp = (validation, updateHighlight) => {
                if (validation.isHighlighted) {
                    if (updateHighlight) {
                        delete validation.isHighlighted;
                    }
                    updateHighlightOnUI(validation);
                }
            };
        }
        else {
            updateHighlightProp = (validation, updateHighlight, col) => {
                if (updateHighlight) {
                    validation.isHighlighted = true;
                }
                updateHighlightOnUI(validation, col);
            };
        }
        const updateValidationHighlight = () => {
            for (rowIdx = indexes[0]; rowIdx <= indexes[2]; rowIdx++) {
                uiRefresh = isActiveSheet && ((rowIdx >= viewport[0] && rowIdx <= viewport[2]) || rowIdx < frozenRow) &&
                    !isHiddenRow(sheet, rowIdx);
                if (isFullRange) {
                    row = getRow(sheet, rowIdx);
                    lastColIdx = Math.max(row && row.cells ? row.cells.length - 1 : null, sheet.columns.length - 1, indexes[3]);
                }
                for (colIdx = indexes[1]; colIdx <= lastColIdx; colIdx++) {
                    cell = getCell(rowIdx, colIdx, sheet, false, true);
                    col = sheet.columns[colIdx];
                    if (cell.validation) {
                        updateHighlightProp(cell.validation, true, col);
                    }
                    else {
                        if (checkColumnValidation(col, rowIdx, colIdx)) {
                            updateHighlightProp(col.validation, rowIdx === indexes[2]);
                        }
                    }
                }
            }
        };
        if (range) {
            if (range.includes('!')) {
                const sheetIdx = getSheetIndexFromAddress(this.parent, range);
                sheet = getSheet(this.parent, sheetIdx);
                range = getRangeFromAddress(range);
                isActiveSheet = sheetIdx === this.parent.activeSheetIndex;
            }
            else {
                isActiveSheet = true;
            }
            indexes = getSwapRange(getRangeIndexes(this.getRangeWhenColumnSelected(getUpdatedRange(sheet, range), sheet).range));
            lastColIdx = indexes[3];
            updateValidationHighlight();
        }
        else {
            isFullRange = true;
            this.parent.sheets.forEach((model, sheetIdx) => {
                sheet = model;
                indexes = [0, 0, Math.max(sheet.rows.length - 1, viewport[2]), Math.max(sheet.usedRange.colIndex, viewport[3])];
                isActiveSheet = sheetIdx === this.parent.activeSheetIndex;
                updateValidationHighlight();
            });
        }
    }
    beforeInsertDeleteHandler(args) {
        let isSheetAction;
        if (args.modelType === 'Sheet') {
            if (args.name !== refreshInsertDelete) {
                return;
            }
            isSheetAction = true;
        }
        else if (args.name === refreshInsertDelete) {
            return;
        }
        const isInsert = args.name === beforeInsert;
        let eventArgs;
        let endIdx;
        let curSheet;
        let prevIdx;
        if (isInsert) {
            curSheet = getSheet(this.parent, args.activeSheetIndex);
            endIdx = args.index + (args.model.length - 1);
            eventArgs = { insertDeleteArgs: { startIndex: args.index, endIndex: endIdx, modelType: args.modelType, isInsert: true,
                    sheet: curSheet }, sheetIdx: args.activeSheetIndex };
            prevIdx = args.index - 1;
        }
        else if (isSheetAction) {
            const sheetNames = [];
            let sheetId;
            const formulaArgs = {
                action: 'getSheetInfo', sheetInfo: []
            };
            this.parent.notify(workbookFormulaOperation, formulaArgs);
            for (let idx = args.startIndex; idx <= args.endIndex; idx++) {
                sheetId = this.parent.sheets[idx].id;
                for (let i = 0; i < formulaArgs.sheetInfo.length; i++) {
                    if (formulaArgs.sheetInfo[i].index === sheetId) {
                        sheetNames.push(formulaArgs.sheetInfo[i].sheet);
                        break;
                    }
                }
            }
            eventArgs = { sheetNames: sheetNames };
        }
        else {
            curSheet = args.model;
            eventArgs = { insertDeleteArgs: { startIndex: args.start, modelType: args.modelType,
                    endIndex: args.end, sheet: curSheet }, sheetIdx: getSheetIndexFromId(this.parent, curSheet.id) };
        }
        const updateFormula = (validation) => {
            if (checkIsFormula(validation.value1) && (!eventArgs.otherSheet || validation.value1.includes(curSheet.name))) {
                eventArgs.cell = { formula: validation.value1 };
                this.parent.notify(getUpdatedFormulaOnInsertDelete, eventArgs);
                validation.value1 = eventArgs.cell.formula;
            }
            if (checkIsFormula(validation.value2) && (!eventArgs.otherSheet || validation.value2.includes(curSheet.name))) {
                eventArgs.cell = { formula: validation.value2 };
                this.parent.notify(getUpdatedFormulaOnInsertDelete, eventArgs);
                validation.value2 = eventArgs.cell.formula;
            }
        };
        const isColAction = args.modelType === 'Column';
        const updateValidationToInsertedModel = (validation, isColUpdate) => {
            if (validation) {
                eventArgs.insertDeleteArgs.forceUpdate = true;
                for (let insertIdx = args.index; insertIdx <= endIdx; insertIdx++) {
                    validation = extend({}, validation);
                    updateFormula(validation);
                    if (isColUpdate) {
                        setColumn(curSheet, insertIdx, { validation: validation });
                    }
                    else if (isColAction) {
                        setCell(rowIdx, insertIdx, curSheet, { validation: validation }, true);
                    }
                    else {
                        setCell(insertIdx, colIdx, curSheet, { validation: validation }, true);
                    }
                }
                delete eventArgs.insertDeleteArgs.forceUpdate;
            }
        };
        let cell;
        let column;
        let endRowCount;
        let endColCount;
        let rowIdx;
        let colIdx;
        let isInsertOnCurSheet;
        this.parent.sheets.forEach((sheet, sheetIdx) => {
            if (isSheetAction) {
                if (sheetIdx >= args.startIndex && sheetIdx <= args.endIndex) {
                    return;
                }
            }
            else {
                if (sheetIdx === eventArgs.sheetIdx) {
                    isInsertOnCurSheet = isInsert;
                    delete eventArgs.otherSheet;
                    delete eventArgs.formulaSheet;
                }
                else {
                    eventArgs.otherSheet = true;
                    eventArgs.formulaSheet = sheet;
                    isInsertOnCurSheet = false;
                }
            }
            endRowCount = sheet.usedRange.rowIndex + 1;
            for (colIdx = 0, endColCount = sheet.usedRange.colIndex + 1; colIdx < endColCount; colIdx++) {
                if (isInsertOnCurSheet && isColAction && colIdx >= args.index && colIdx <= endIdx) {
                    continue;
                }
                column = sheet.columns && sheet.columns[colIdx];
                if (column && column.validation) {
                    updateFormula(column.validation);
                    if (isInsertOnCurSheet && isColAction && prevIdx === colIdx) {
                        updateValidationToInsertedModel(column.validation, true);
                    }
                }
                for (rowIdx = 0; rowIdx < endRowCount; rowIdx++) {
                    cell = getCell(rowIdx, colIdx, sheet, false, true);
                    if (cell.validation && (!isInsertOnCurSheet || isColAction || rowIdx < args.index || rowIdx > endIdx)) {
                        updateFormula(cell.validation);
                        if (isInsertOnCurSheet && prevIdx === (isColAction ? colIdx : rowIdx)) {
                            updateValidationToInsertedModel(cell.validation);
                        }
                    }
                }
            }
        });
    }
    getRangeWhenColumnSelected(range, sheet) {
        let isFullCol;
        const colNames = range.split(':');
        if (range.match(/\D/g) && !range.match(/[0-9]/g)) {
            colNames[0] += 1;
            colNames[1] += sheet.rowCount;
            range = colNames[0] + ':' + colNames[1];
            isFullCol = true;
        }
        else if (!range.match(/\D/g) && range.match(/[0-9]/g)) {
            colNames[0] = 'A' + colNames[0];
            colNames[1] = getCellAddress(0, sheet.colCount - 1).replace(/[0-9]/g, '') + colNames[1];
            range = colNames[0] + ':' + colNames[1];
        }
        return { range: range, isFullCol: isFullCol };
    }
    /**
     * Gets the module name.
     *
     * @returns {string} string
     */
    getModuleName() {
        return 'workbookDataValidation';
    }
}

/**
 * `WorkbookFindAndReplace` module is used to handle the search action in Spreadsheet.
 */
class WorkbookFindAndReplace {
    /**
     * Constructor for WorkbookFindAndReplace module.
     *
     * @param {Workbook} parent - Specifies the workbook.
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * To destroy the FindAndReplace module.
     *
     * @returns {void} - To destroy the FindAndReplace module.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(find, this.find, this);
        this.parent.on(replace, this.replace, this);
        this.parent.on(replaceAll, this.replaceAll, this);
        this.parent.on(count, this.totalCount, this);
        this.parent.on(findAllValues, this.findAllValues, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(find, this.find);
            this.parent.off(replace, this.replace);
            this.parent.off(replaceAll, this.replaceAll);
            this.parent.off(count, this.totalCount);
            this.parent.off(findAllValues, this.findAllValues);
        }
    }
    find(args) {
        args.sheetIndex = isUndefined$1(args.sheetIndex) ? this.parent.activeSheetIndex : args.sheetIndex;
        const sheet = this.parent.sheets[args.sheetIndex];
        const activeCell = getRangeIndexes(sheet.activeCell);
        const findArgs = { startRow: activeCell[0], startCol: activeCell[1],
            findVal: args.isCSen ? args.value : args.value.toLowerCase(), activeCell: activeCell };
        if (args.searchBy === 'By Row' ? findArgs.startRow > sheet.usedRange.rowIndex : findArgs.startCol > sheet.usedRange.colIndex) {
            if (args.findOpt === 'next') {
                findArgs.startRow = findArgs.startCol = 0;
            }
            else {
                findArgs.startRow = sheet.usedRange.rowIndex;
                findArgs.startCol = sheet.usedRange.colIndex;
            }
        }
        else {
            if (args.searchBy === 'By Row') {
                if (findArgs.startCol > sheet.usedRange.colIndex) {
                    if (args.findOpt === 'next') {
                        findArgs.startRow++;
                        if (findArgs.startRow > sheet.usedRange.rowIndex) {
                            findArgs.startRow = 0;
                        }
                        findArgs.startCol = 0;
                    }
                    else {
                        findArgs.startRow--;
                        if (findArgs.startRow < 0) {
                            findArgs.startRow = sheet.usedRange.rowIndex;
                        }
                        findArgs.startCol = sheet.usedRange.colIndex;
                    }
                }
            }
            else {
                if (findArgs.startRow > sheet.usedRange.rowIndex) {
                    if (args.findOpt === 'next') {
                        findArgs.startCol++;
                        if (findArgs.startCol > sheet.usedRange.colIndex) {
                            findArgs.startRow = 0;
                        }
                        findArgs.startRow = 0;
                    }
                    else {
                        findArgs.startCol--;
                        if (findArgs.startCol < 0) {
                            findArgs.startCol = sheet.usedRange.colIndex;
                        }
                        findArgs.startRow = sheet.usedRange.colIndex;
                    }
                }
            }
        }
        if (args.mode === 'Workbook') {
            findArgs.sheets = this.parent.sheets;
            findArgs.sheetIdx = args.sheetIndex;
        }
        else {
            findArgs.sheets = [sheet];
            findArgs.sheetIdx = 0;
        }
        let headerHgt;
        const hdrPanel = args.showDialog && this.parent.element && this.parent.element.querySelector('.e-header-panel');
        if (hdrPanel) {
            headerHgt = (hdrPanel.offsetHeight || (sheet.showHeaders ? 30 : 0)) + 1;
        }
        args.localeObj = getNumericObject(this.parent.locale);
        if (args.findOpt === 'next') {
            this.findNext(args, findArgs);
        }
        else {
            this.findPrevious(args, findArgs);
        }
        if (args.showDialog) {
            this.parent.notify(findToolDlg, { findValue: args.value, isPublic: true, headerHgt: headerHgt });
        }
    }
    findNext(args, findArgs) {
        const findOnSheet = (startIdx, endIdx, initIteration) => {
            let sheet;
            let cellAddr;
            for (let sheetIdx = startIdx; sheetIdx <= endIdx; sheetIdx++) {
                sheet = findArgs.sheets[sheetIdx];
                if (sheetIdx === findArgs.sheetIdx) {
                    if (initIteration) {
                        cellAddr = this.findNextOnSheet(args, findArgs.startRow, findArgs.startCol, findArgs.findVal, sheet, undefined, findArgs.activeCell);
                    }
                    else {
                        cellAddr = this.findNextOnSheet(args, 0, 0, findArgs.findVal, sheet, args.searchBy === 'By Row' ? findArgs.startRow : findArgs.startCol);
                    }
                }
                else {
                    cellAddr = this.findNextOnSheet(args, 0, 0, findArgs.findVal, sheet);
                }
                if (cellAddr) {
                    break;
                }
            }
            return cellAddr;
        };
        let cellAddr = findOnSheet(findArgs.sheetIdx, findArgs.sheets.length - 1, true);
        if (!cellAddr) {
            cellAddr = findOnSheet(0, findArgs.sheetIdx);
        }
        if (cellAddr) {
            this.parent.notify(goto, { address: cellAddr });
        }
        else {
            this.parent.notify(showFindAlert, null);
        }
    }
    findNextOnSheet(args, startRow, startCol, findVal, sheet, endIdx, activeCell) {
        let cellAddr;
        let rowIdx;
        let colIdx;
        if (args.searchBy === 'By Row') {
            if (endIdx === undefined) {
                endIdx = sheet.rows.length - 1;
            }
            let colLen;
            for (rowIdx = startRow; rowIdx <= endIdx; rowIdx++) {
                if (isHiddenRow(sheet, rowIdx)) {
                    continue;
                }
                colIdx = activeCell && rowIdx === startRow ? startCol : 0;
                colLen = sheet.rows[rowIdx] && sheet.rows[rowIdx].cells && sheet.rows[rowIdx].cells.length;
                for (colIdx; colIdx < colLen; colIdx++) {
                    if (!isHiddenCol(sheet, colIdx)) {
                        cellAddr = this.checkMatch(args, findVal, rowIdx, colIdx, sheet, activeCell);
                        if (cellAddr) {
                            return cellAddr;
                        }
                    }
                }
            }
        }
        else {
            if (endIdx === undefined) {
                endIdx = sheet.usedRange.colIndex;
            }
            const endRow = sheet.rows && sheet.rows.length - 1;
            for (colIdx = startCol; colIdx <= endIdx; colIdx++) {
                if (isHiddenCol(sheet, colIdx)) {
                    continue;
                }
                rowIdx = activeCell && colIdx === startCol ? startRow : 0;
                for (rowIdx; rowIdx <= endRow; rowIdx++) {
                    if (!isHiddenRow(sheet, rowIdx)) {
                        cellAddr = this.checkMatch(args, findVal, rowIdx, colIdx, sheet, activeCell);
                        if (cellAddr) {
                            return cellAddr;
                        }
                    }
                }
            }
        }
        return cellAddr;
    }
    findPrevious(args, findArgs) {
        const findOnSheet = (startIdx, endIdx, initIteration) => {
            let sheet;
            let cellAddr;
            for (let sheetIdx = startIdx; sheetIdx >= endIdx; sheetIdx--) {
                sheet = findArgs.sheets[sheetIdx];
                if (sheetIdx === findArgs.sheetIdx) {
                    if (initIteration) {
                        cellAddr = this.findPrevOnSheet(args, findArgs.startRow, findArgs.startCol, 0, 0, findArgs.findVal, sheet, findArgs.activeCell);
                    }
                    else {
                        if (args.searchBy === 'By Row') {
                            cellAddr = this.findPrevOnSheet(args, sheet.usedRange.rowIndex, sheet.usedRange.colIndex, findArgs.startRow, 0, findArgs.findVal, sheet);
                        }
                        else {
                            cellAddr = this.findPrevOnSheet(args, sheet.usedRange.rowIndex, sheet.usedRange.colIndex, 0, findArgs.startCol, findArgs.findVal, sheet);
                        }
                    }
                }
                else {
                    cellAddr = this.findPrevOnSheet(args, sheet.usedRange.rowIndex, sheet.usedRange.colIndex, 0, 0, findArgs.findVal, sheet);
                }
                if (cellAddr) {
                    break;
                }
            }
            return cellAddr;
        };
        let cellAddr;
        cellAddr = findOnSheet(findArgs.sheetIdx, 0, true);
        if (!cellAddr) {
            cellAddr = findOnSheet(findArgs.sheets.length - 1, findArgs.sheetIdx);
        }
        if (cellAddr) {
            this.parent.notify(goto, { address: cellAddr });
        }
        else {
            this.parent.notify(showFindAlert, null);
        }
    }
    findPrevOnSheet(args, startRow, startCol, endRow, endCol, findVal, sheet, activeCell) {
        let cellAddr;
        let colIdx;
        let rowIdx;
        if (args.searchBy === 'By Row') {
            for (rowIdx = startRow; rowIdx >= endRow; rowIdx--) {
                if (isHiddenRow(sheet, rowIdx)) {
                    continue;
                }
                colIdx = activeCell && rowIdx === startRow ? startCol : sheet.rows[rowIdx] &&
                    sheet.rows[rowIdx].cells && sheet.rows[rowIdx].cells.length - 1;
                for (colIdx; colIdx >= endCol; colIdx--) {
                    if (!isHiddenCol(sheet, colIdx)) {
                        cellAddr = this.checkMatch(args, findVal, rowIdx, colIdx, sheet, activeCell);
                        if (cellAddr) {
                            return cellAddr;
                        }
                    }
                }
            }
        }
        else {
            for (colIdx = startCol; colIdx >= endCol; colIdx--) {
                if (isHiddenCol(sheet, colIdx)) {
                    continue;
                }
                rowIdx = activeCell && colIdx === startCol ? startRow : sheet.rows && sheet.rows.length - 1;
                for (rowIdx; rowIdx >= endRow; rowIdx--) {
                    if (!isHiddenRow(sheet, rowIdx)) {
                        cellAddr = this.checkMatch(args, findVal, rowIdx, colIdx, sheet, activeCell);
                        if (cellAddr) {
                            return cellAddr;
                        }
                    }
                }
            }
        }
        return cellAddr;
    }
    checkMatch(args, findVal, rowIdx, colIdx, sheet, curCell) {
        if (curCell && rowIdx === curCell[0] && colIdx === curCell[1]) {
            return null;
        }
        let cell = getCell(rowIdx, colIdx, sheet, false, true);
        if (sheet.isProtected && !sheet.protectSettings.selectCells && sheet.protectSettings.selectUnLockedCells &&
            isLocked(cell, getColumn(sheet, colIdx))) {
            return null;
        }
        const checkValues = (cellVal) => {
            if (cellVal) {
                if (!args.isCSen) {
                    cellVal = cellVal.toLowerCase();
                }
                if (args.isEMatch) {
                    if (cellVal === findVal) {
                        return `${sheet.name}!${getCellAddress(rowIdx, colIdx)}`;
                    }
                }
                else if (cellVal.includes(findVal)) {
                    return `${sheet.name}!${getCellAddress(rowIdx, colIdx)}`;
                }
            }
            return null;
        };
        const displayText = this.getDisplayText(cell, rowIdx, colIdx, args.localeObj);
        let cellAddr = checkValues(displayText);
        if (!cellAddr) {
            cell = getCell(rowIdx, colIdx, sheet, false, true);
            if (cell.format && !isCustomDateTime(cell.format, true) && !displayText.includes('%')) {
                cellAddr = checkValues(this.getCellVal(cell, args.localeObj));
            }
        }
        return cellAddr;
    }
    replace(args) {
        const sheetIndex = isUndefined$1(args.sheetIndex) ? this.parent.activeSheetIndex : args.sheetIndex;
        const sheet = getSheet(this.parent, args.sheetIndex);
        if (sheet.isProtected) {
            this.parent.notify(workBookeditAlert, null);
            return;
        }
        const address = args.address;
        let activeCell = getRangeIndexes(address || sheet.activeCell);
        let activeCellModel = getCell(activeCell[0], activeCell[1], sheet, false, true);
        let compareVal = this.parent.getDisplayText(activeCellModel).toString();
        let checkValue;
        args.value = args.value.toString();
        if (!args.isCSen) {
            checkValue = args.value.toLowerCase();
        }
        const localeObj = getNumericObject(this.parent.locale);
        const getReplaceValue = (isRecursive) => {
            let replaceVal;
            if (args.isCSen) {
                if (args.isEMatch) {
                    replaceVal = compareVal === args.value && args.replaceValue;
                }
                else {
                    replaceVal = compareVal.indexOf(args.value) > -1 && compareVal.replace(args.value, args.replaceValue);
                }
            }
            else {
                if (args.isEMatch) {
                    replaceVal = compareVal.toLowerCase() === checkValue && args.replaceValue;
                }
                else {
                    const regExp = RegExp;
                    replaceVal = (compareVal.toLowerCase().includes(checkValue)) &&
                        compareVal.replace(new regExp(args.value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'ig'), args.replaceValue);
                }
            }
            if (!isRecursive && !replacedValue && activeCellModel.format && !isCustomDateTime(activeCellModel.format, true) &&
                !compareVal.includes('%')) {
                compareVal = this.getCellVal(activeCellModel, localeObj);
                if (compareVal) {
                    replaceVal = getReplaceValue(true);
                }
            }
            return replaceVal;
        };
        let replacedValue = getReplaceValue();
        if (!replacedValue) {
            args.findOpt = 'next';
            this.find(args);
            activeCell = getCellIndexes(sheet.activeCell);
            activeCellModel = getCell(activeCell[0], activeCell[1], sheet, false, true);
            compareVal = this.parent.getDisplayText(activeCellModel).toString();
            replacedValue = getReplaceValue();
            if (!replacedValue) {
                return;
            }
        }
        if (isReadOnly(getCell(activeCell[0], activeCell[1], sheet), getColumn(sheet, activeCell[1]), getRow(sheet, activeCell[0]))) {
            this.parent.notify(workbookReadonlyAlert, null);
            return;
        }
        const eventArgs = { address: `${sheet.name}!${getCellAddress(activeCell[0], activeCell[1])}`, cancel: false,
            compareValue: args.value, replaceValue: args.replaceValue, sheetIndex: sheetIndex };
        if (args.isAction) {
            this.parent.notify(beginAction, { action: 'beforeReplace', eventArgs: eventArgs });
            if (eventArgs.cancel) {
                return;
            }
            delete eventArgs.cancel;
        }
        updateCell(this.parent, sheet, { cell: { value: replacedValue }, rowIdx: activeCell[0], colIdx: activeCell[1], uiRefresh: true,
            checkCF: true, valChange: true });
        if (args.isAction) {
            this.parent.notify('actionComplete', { action: 'replace', eventArgs: eventArgs });
        }
    }
    replaceAll(args) {
        let startSheet = args.mode === 'Sheet' ? args.sheetIndex : 0;
        let sheet = this.parent.sheets[startSheet];
        let endRow = sheet.usedRange.rowIndex;
        let startRow = 0;
        let endColumn = sheet.usedRange.colIndex;
        let startColumn = 0;
        const addressCollection = [];
        const triggerEvent = args.isAction;
        const activeCellIdx = getCellIndexes(sheet.activeCell);
        const eventArgs = Object.assign({ addressCollection: addressCollection, cancel: false }, args);
        let replaceCount = 0;
        const updateAsync = (val, index, cell) => {
            if (requestAnimationFrame) {
                requestAnimationFrame(() => {
                    if (!eventArgs.cancel && eventArgs.addressCollection[index]) {
                        const indexes = getCellIndexes(eventArgs.addressCollection[index].substring(eventArgs.addressCollection[index].lastIndexOf('!') + 1));
                        const sheetIndex = getSheetIndexFromAddress(this.parent, eventArgs.addressCollection[index]);
                        updateCell(this.parent, this.parent.sheets[sheetIndex], { cell: { value: val }, rowIdx: indexes[0],
                            uiRefresh: true, checkCF: true, colIdx: indexes[1], valChange: true,
                            skipFormatCheck: args.skipFormatCheck });
                        if (activeCellIdx[0] === indexes[0] && activeCellIdx[1] === indexes[1]) {
                            this.parent.notify('formulaBarOperation', { action: 'refreshFormulabar',
                                cell: getCell(indexes[0], indexes[1], this.parent.sheets[sheetIndex], false, true) });
                        }
                        if (index === eventArgs.addressCollection.length - 1 && triggerEvent) {
                            this.parent.notify('actionComplete', { action: 'replaceAll', eventArgs: eventArgs });
                        }
                    }
                });
            }
            else {
                this.parent.updateCellDetails({ value: val }, eventArgs.addressCollection[index], undefined, undefined, true);
            }
            if (!cell.formula) {
                replaceCount++;
            }
        };
        const checkMatch = (cellval, cell) => {
            let matchFound;
            if (cellval) {
                if (args.isCSen) {
                    if (args.isEMatch) {
                        if (cellval === args.value) {
                            updateAsync(args.replaceValue, addressCollection.length, cell);
                            addressCollection.push(sheet.name + '!' + getCellAddress(startRow, startColumn));
                            matchFound = true;
                        }
                    }
                    else {
                        if (cellval.indexOf(args.value) > -1) {
                            updateAsync(cellval.replace(args.value, args.replaceValue), addressCollection.length, cell);
                            addressCollection.push(sheet.name + '!' + getCellAddress(startRow, startColumn));
                            matchFound = true;
                        }
                    }
                }
                else {
                    if (args.isEMatch) {
                        if (cellval.toLowerCase() === args.value) {
                            updateAsync(args.replaceValue, addressCollection.length, cell);
                            addressCollection.push(sheet.name + '!' + getCellAddress(startRow, startColumn));
                            matchFound = true;
                        }
                    }
                    else {
                        const val = cellval.toLowerCase();
                        if ((cellval === args.value || val.indexOf(args.value.toString().toLowerCase()) > -1) || val ===
                            args.value || cellval === args.value || val.indexOf(args.value) > -1) {
                            const regExp = RegExp;
                            regX = new regExp(args.value.toString().replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'ig');
                            updateAsync(cellval.replace(regX, args.replaceValue), addressCollection.length, cell);
                            addressCollection.push(sheet.name + '!' + getCellAddress(startRow, startColumn));
                            matchFound = true;
                        }
                    }
                }
            }
            return matchFound;
        };
        let displayText;
        let row;
        let regX;
        const localeObj = getNumericObject(this.parent.locale);
        let cell;
        for (startRow; startRow <= endRow + 1; startRow++) {
            if (startColumn > endColumn && startRow > endRow) {
                if (args.mode === 'Workbook') {
                    startSheet++;
                    sheet = this.parent.sheets[startSheet];
                    if (sheet) {
                        startColumn = 0;
                        startRow = 0;
                        endColumn = sheet.usedRange.colIndex;
                        endRow = sheet.usedRange.rowIndex;
                    }
                    else {
                        break;
                    }
                }
            }
            row = sheet.rows[startRow];
            if (row) {
                if (startColumn === endColumn + 1) {
                    startColumn = 0;
                }
                for (startColumn; startColumn <= endColumn; startColumn++) {
                    if (row) {
                        cell = row.cells && row.cells[startColumn];
                        if (cell) {
                            if (isReadOnly(cell, getColumn(sheet, startColumn), row)) {
                                continue;
                            }
                            displayText = this.getDisplayText(cell, startRow, startColumn, localeObj).toString();
                            if (!checkMatch(displayText, cell) && cell.format && !isCustomDateTime(cell.format, true) &&
                                !displayText.includes('%')) {
                                checkMatch(this.getCellVal(row.cells[startColumn], localeObj), cell);
                            }
                        }
                    }
                }
            }
        }
        if (addressCollection.length && triggerEvent) {
            this.parent.notify('actionBegin', { action: 'beforeReplaceAll', eventArgs: eventArgs });
            if (!eventArgs.cancel) {
                this.parent.notify(replaceAllDialog, { count: replaceCount, replaceValue: eventArgs.replaceValue });
            }
        }
        else {
            this.parent.notify(replaceAllDialog, { count: replaceCount, replaceValue: eventArgs.replaceValue });
        }
    }
    getDisplayText(cell, rowIdx, colIdx, localeObj) {
        if (!cell) {
            return '';
        }
        if (!cell.value && cell.value !== 0) {
            if (cell.hyperlink) {
                return typeof cell.hyperlink === 'string' ? cell.hyperlink : cell.hyperlink.address || '';
            }
            return '';
        }
        const cellValue = cell.value.toString();
        if (cell.format || cellValue.includes(localeObj.dateSeparator)) {
            const eventArgs = { value: cell.value, format: cell.format, formattedText: cell.value, cell: cell,
                rowIndex: rowIdx, colIndex: colIdx };
            this.parent.notify(getFormattedCellObject, eventArgs);
            return eventArgs.formattedText;
        }
        else {
            return cellValue;
        }
    }
    getCellVal(cell, localeObj) {
        if (isNumber(cell.value)) {
            if (localeObj.decimal !== '.') {
                return cell.value.toString().split('.').join(localeObj.decimal);
            }
            return cell.value.toString();
        }
        return cell.value ? cell.value.toString().toLowerCase() : '';
    }
    totalCount(args) {
        const sheet = this.parent.sheets[args.sheetIndex];
        const activeCell = getCellIndexes(sheet.activeCell);
        let count = 0;
        let requiredCount = 0;
        const findValue = args.value.toLowerCase();
        const localeObj = getNumericObject(this.parent.locale);
        let displayText;
        sheet.rows.filter((row, rowIdx) => row && row.cells && (!row.isFiltered && !row.hidden) &&
            row.cells.filter((cell, colIdx) => {
                if (cell && (cell.value || cell.value === 0) && !isHiddenCol(sheet, colIdx) && (!sheet.isProtected ||
                    sheet.protectSettings.selectCells || !isLocked(cell, getColumn(sheet, colIdx)))) {
                    displayText = this.getDisplayText(cell, rowIdx, colIdx, localeObj).toLowerCase();
                    if (displayText.includes(findValue) || (cell.format && !isCustomDateTime(cell.format, true) &&
                        !displayText.includes('%') && this.getCellVal(cell, localeObj).includes(findValue))) {
                        count++;
                        if ((rowIdx === activeCell[0] && colIdx >= activeCell[1]) || rowIdx > activeCell[0]) {
                            requiredCount++;
                        }
                    }
                }
            }));
        requiredCount -= 1;
        const totalCount = count;
        count = totalCount - requiredCount;
        if (count > totalCount) {
            count = totalCount;
        }
        if (count !== 0 && !this.parent.getDisplayText(getCell(activeCell[0], activeCell[1], sheet)).toLowerCase().includes(findValue)) {
            count -= 1;
        }
        args.findCount = `${count} of ${totalCount}`;
    }
    findAllValues(findAllArguments) {
        let startSheet = findAllArguments.sheetIndex;
        let sheet = this.parent.sheets[startSheet];
        let endRow = sheet.usedRange.rowIndex;
        let rowIndex = 0;
        let count = 0;
        let address;
        let endColumn = sheet.usedRange.colIndex;
        let columnIndex = 0;
        const sheetLength = this.parent.sheets.length;
        const initialSheet = findAllArguments.sheetIndex;
        for (rowIndex; rowIndex <= endRow + 1; rowIndex++) {
            if ((initialSheet !== 1) && (findAllArguments.sheetIndex === sheetLength)) {
                startSheet = 1;
            }
            if (rowIndex > endRow && columnIndex > endColumn) {
                if (findAllArguments.mode === 'Workbook') {
                    startSheet++;
                    if (startSheet > sheetLength - 1) {
                        startSheet = 0;
                    }
                    if (initialSheet === startSheet) {
                        if (count === 0) {
                            return;
                        }
                        return;
                    }
                    sheet = this.parent.sheets[startSheet];
                    if (sheet) {
                        rowIndex = 0;
                        columnIndex = 0;
                        endColumn = sheet.usedRange.colIndex;
                        endRow = sheet.usedRange.rowIndex;
                    }
                }
            }
            if (!isNullOrUndefined(sheet)) {
                if (sheet.rows[rowIndex]) {
                    const row = sheet.rows[rowIndex];
                    if (columnIndex === endColumn + 2) {
                        columnIndex = 0;
                    }
                    for (columnIndex; columnIndex <= endColumn + 1; columnIndex++) {
                        if (row) {
                            if (row.cells && row.cells[columnIndex]) {
                                const cell = sheet.rows[rowIndex].cells[columnIndex];
                                if (cell && !isNullOrUndefined(cell.value) && cell.value !== '' && (!sheet.isProtected ||
                                    sheet.protectSettings.selectCells || (sheet.protectSettings.selectUnLockedCells &&
                                    !isLocked(cell, getColumn(sheet, columnIndex))))) {
                                    const cellFormat = cell.format;
                                    let cellvalue;
                                    if (cellFormat) {
                                        const displayTxt = this.parent.getDisplayText(sheet.rows[rowIndex].cells[columnIndex]);
                                        cellvalue = displayTxt.toString();
                                    }
                                    else {
                                        cellvalue = cell.value.toString();
                                    }
                                    if (findAllArguments.isCSen && findAllArguments.isEMatch) {
                                        if (cellvalue === findAllArguments.value) {
                                            address = sheet.name + '!' + getCellAddress(rowIndex, columnIndex);
                                            findAllArguments.findCollection.push(address);
                                            count++;
                                        }
                                    }
                                    else if (findAllArguments.isCSen && !findAllArguments.isEMatch) {
                                        const index = cellvalue.indexOf(findAllArguments.value) > -1;
                                        if ((cellvalue === findAllArguments.value) || (index)) {
                                            address = sheet.name + '!' + getCellAddress(rowIndex, columnIndex);
                                            findAllArguments.findCollection.push(address);
                                            count++;
                                        }
                                    }
                                    else if (!findAllArguments.isCSen && findAllArguments.isEMatch) {
                                        const val = cellvalue.toString().toLowerCase();
                                        if (val === findAllArguments.value.toLowerCase()) {
                                            address = sheet.name + '!' + getCellAddress(rowIndex, columnIndex);
                                            findAllArguments.findCollection.push(address);
                                            count++;
                                        }
                                    }
                                    else if (!findAllArguments.isCSen && !findAllArguments.isEMatch) {
                                        const val = cellvalue.toString().toLowerCase();
                                        const index = val.indexOf(findAllArguments.value.toLowerCase()) > -1;
                                        if ((val === findAllArguments.value) || ((cellvalue === findAllArguments.value) || (index)) ||
                                            ((cellvalue === findAllArguments.value))) {
                                            address = sheet.name + '!' + getCellAddress(rowIndex, columnIndex);
                                            findAllArguments.findCollection.push(address);
                                            count++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (count === 0) {
            return;
        }
        return;
    }
    /**
     * Gets the module name.
     *
     * @returns {string} - Return the string
     */
    getModuleName() {
        return 'workbookfindAndReplace';
    }
}

/**
 * The `WorkbookSpreadSheet` module is used to handle the Protecting functionalities in Workbook.
 */
class WorkbookProtectSheet {
    /**
     * Constructor for edit module in Workbook.
     *
     * @param {Workbook} workbook - Specifies the workbook.
     * @private
     */
    constructor(workbook) {
        this.parent = workbook;
        this.addEventListener();
    }
    protectsheetHandler(args) {
        const sheetIndex = isNullOrUndefined(args.sheetIndex) ? this.parent.activeSheetIndex : args.sheetIndex;
        const sheet = getSheet(this.parent, sheetIndex);
        this.parent.setSheetPropertyOnMute(sheet, 'isProtected', true);
        this.parent.setSheetPropertyOnMute(sheet, 'protectSettings', {
            selectCells: args.protectSettings.selectCells, formatCells: args.protectSettings.formatCells,
            formatColumns: args.protectSettings.formatColumns, formatRows: args.protectSettings.formatRows,
            insertLink: args.protectSettings.insertLink, selectUnLockedCells: args.protectSettings.selectUnLockedCells
        });
        this.parent.notify(protectSheetWorkBook, { sheetIndex: sheetIndex, triggerEvent: args.triggerEvent });
        this.parent.notify(updateToggle, { props: 'Protect' });
        sheet.password = args.password ? args.password : '';
        sheet.columns.forEach((column) => {
            if (column && isUndefined$1(column.isLocked)) {
                column.isLocked = true;
            }
        });
    }
    unprotectsheetHandler(args) {
        let sheet = this.parent.getActiveSheet();
        if (!isNullOrUndefined(args.sheet)) {
            sheet = this.parent.sheets[args.sheet];
        }
        if (sheet.isImportProtected) {
            sheet.isImportProtected = false;
        }
        sheet.protectSettings.formatCells = sheet.protectSettings.formatColumns = false;
        sheet.protectSettings.formatRows = sheet.protectSettings.selectCells = false;
        this.parent.setSheetPropertyOnMute(sheet, 'isProtected', false);
        this.parent.notify(protectSheetWorkBook, sheet.protectSettings);
        this.parent.notify(updateToggle, { props: 'Protect' });
    }
    /**
     * To destroy the edit module.
     *
     * @returns {void} - To destroy the edit module.
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(protectsheetHandler, this.protectsheetHandler, this);
        this.parent.on(unprotectsheetHandler, this.unprotectsheetHandler, this);
        this.parent.on(setLockCells, this.lockCells, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(protectsheetHandler, this.protectsheetHandler);
            this.parent.off(setLockCells, this.lockCells);
            this.parent.off(protectsheetHandler, this.unprotectsheetHandler);
        }
    }
    lockCells(args) {
        const addressInfo = this.parent.getAddressInfo(args.range);
        const indexes = getSwapRange(addressInfo.indices);
        const sheet = getSheet(this.parent, addressInfo.sheetIndex);
        const isLocked = args.isLocked ? args.isLocked : false;
        if (indexes[0] === 0 && indexes[2] === sheet.rowCount - 1) {
            for (let i = indexes[1]; i <= indexes[3]; i++) {
                setColumn(sheet, i, { isLocked: args.isLocked });
            }
        }
        for (let i = indexes[0]; i <= indexes[2]; i++) {
            for (let j = indexes[1]; j <= indexes[3]; j++) {
                setCell(i, j, sheet, { isLocked: isLocked }, true);
            }
        }
        if (args.triggerEvent) {
            this.parent.notify('actionComplete', { action: 'lockCells', eventArgs: args });
        }
    }
    /**
     * Get the module name.
     *
     * @returns {string} - Return the string.
     * @private
     */
    getModuleName() {
        return 'workbookProtectSheet';
    }
}

/**
 * The `WorkbookMerge` module is used to merge the range of cells.
 */
class WorkbookMerge {
    /**
     * Constructor for the workbook merge module.
     *
     * @param {Workbook} parent - Specifies the workbook.
     * @private
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    merge(args) {
        args.sheetIndex = isUndefined$1(args.sheetIndex) ? this.parent.activeSheetIndex : args.sheetIndex;
        if (args.isAction) {
            this.parent.notify('actionBegin', { eventArgs: args, action: 'merge' });
            if (!args.model) {
                args.model = [];
            }
        }
        if (typeof args.range === 'string') {
            args.range = getRangeIndexes(args.range);
        }
        const range = args.range = getSwapRange(args.range);
        if (!args.skipChecking) {
            this.mergedRange(args);
        }
        if (!args.merge || args.type === 'All') {
            this.mergeAll(args);
            if (args.refreshRibbon) {
                this.parent.notify(activeCellChanged, null);
            }
        }
        else if (args.type === 'Horizontally') {
            for (let rowIdx = args.range[0], endIdx = args.range[2]; rowIdx <= endIdx; rowIdx++) {
                args.range = [rowIdx, range[1], rowIdx, range[3]];
                this.mergeAll(args, rowIdx - range[0]);
            }
        }
        else if (args.type === 'Vertically') {
            for (let colIdx = args.range[1], endIdx = args.range[3]; colIdx <= endIdx; colIdx++) {
                args.range = [range[0], colIdx, range[2], colIdx];
                this.mergeAll(args, 0, colIdx - range[1]);
            }
        }
        args.range = range;
        this.parent.setUsedRange(args.range[2], args.range[3]);
        if (args.isAction) {
            this.parent.notify('actionComplete', { eventArgs: args, action: 'merge' });
        }
        if (args.sheetIndex === this.parent.activeSheetIndex) {
            this.parent.notify('selectRange', { address: getSheet(this.parent, args.sheetIndex).selectedRange, skipChecking: true });
            if (this.parent.chartColl && this.parent.chartColl.length) {
                this.parent.notify(refreshChart, { range: args.range });
            }
        }
    }
    mergeAll(args, startRow = 0, startCol = 0) {
        let rowSpan = 0;
        let cell;
        args.range = args.range;
        let colSpan;
        let cellValue;
        let refreshAllCF;
        let format;
        let modelCell;
        const sheet = isUndefined$1(args.sheetIndex) ? this.parent.getActiveSheet() : getSheet(this.parent, args.sheetIndex);
        const updateObj = { cell: new Object(), rowIdx: args.range[0], colIdx: args.range[1], valChange: !args.merge,
            preventEvt: true, uiRefresh: !args.preventRefresh, skipFormatCheck: true };
        for (let rowIdx = args.range[0], rIdx = startRow; rowIdx <= args.range[2]; rowIdx++, rIdx++) {
            colSpan = 0;
            if (args.isAction && !args.model[rIdx]) {
                args.model.push({ cells: [] });
            }
            for (let colIdx = args.range[1], cIdx = startCol; colIdx <= args.range[3]; colIdx++, cIdx++) {
                cell = getCell(rowIdx, colIdx, sheet);
                if (cell && (cell.value || cell.value === 0 || cell.formula) && !cellValue) {
                    cellValue = cell.formula || cell.value;
                    format = cell.format;
                }
                if (args.isAction && args.merge) {
                    modelCell = args.model[rIdx].cells[cIdx] = {};
                    extend(modelCell, cell, null, true);
                }
                if (cell) {
                    delete cell.rowSpan;
                    delete cell.colSpan;
                    modelCell = !args.merge && !args.isAction && args.model && args.model[rIdx] &&
                        args.model[rIdx].cells[cIdx];
                    const isManualCalcMode = this.parent.calculationMode === 'Manual' &&
                        this.parent.getActiveSheet().isSheetCalculated &&
                        !isNullOrUndefined(cell.value) && cell.value !== '';
                    if (modelCell) {
                        if (isManualCalcMode) {
                            modelCell.value = cell.value;
                        }
                        setCell(rowIdx, colIdx, sheet, modelCell);
                    }
                    else if (args.model && args.model[rIdx].cells[cIdx] && isManualCalcMode) {
                        args.model[rIdx].cells[cIdx].value = cell.value;
                    }
                }
                if (rowIdx === args.range[0] && colIdx === args.range[1]) {
                    if (args.merge) {
                        if (args.range[3] - args.range[1] > 0) {
                            updateObj.cell.colSpan = (args.range[3] - args.range[1]) + 1;
                        }
                        if (args.range[2] - args.range[0] > 0) {
                            updateObj.cell.rowSpan = (args.range[2] - args.range[0]) + 1;
                        }
                        updateCell(this.parent, sheet, updateObj);
                        updateObj.valChange = updateObj.mergedCells = true;
                        continue;
                    }
                }
                else {
                    updateObj.rowIdx = rowIdx;
                    updateObj.colIdx = colIdx;
                    updateObj.cell = {};
                    if (args.merge) {
                        if (rowIdx !== args.range[0]) {
                            updateObj.cell.rowSpan = -rowSpan;
                        }
                        if (colIdx !== args.range[1]) {
                            colSpan++;
                            updateObj.cell.colSpan = -colSpan;
                        }
                    }
                }
                updateCell(this.parent, sheet, updateObj);
                if (!refreshAllCF) {
                    refreshAllCF = updateObj.isFormulaDependent;
                }
            }
            rowSpan++;
        }
        if (args.merge) {
            if (cellValue || cellValue === 0) {
                delete updateObj.mergedCells;
                updateObj.cell = {};
                const curCell = getCell(args.range[0], args.range[1], sheet);
                if (!curCell || (!curCell.value && !curCell.formula)) {
                    if (checkIsFormula(cellValue)) {
                        updateObj.cell.formula = cellValue;
                    }
                    else {
                        updateObj.cell.value = cellValue;
                    }
                    if (format) {
                        updateObj.cell.format = format;
                    }
                }
                updateObj.rowIdx = args.range[0];
                updateObj.colIdx = args.range[1];
                updateCell(this.parent, sheet, updateObj);
            }
            else if (!args.preventRefresh) {
                this.parent.notify(applyMerge, { rowIdx: args.range[0], colIdx: args.range[1] });
            }
        }
        if (!args.preventRefresh) {
            this.refreshCF(sheet, [...args.range], refreshAllCF, args.merge);
        }
    }
    refreshCF(sheet, range, refreshAll, isMerge) {
        if (sheet.conditionalFormats && sheet.conditionalFormats.length) {
            if (isMerge) {
                this.parent.notify(applyCF, { indexes: [range[0], range[1]], refreshAll: refreshAll, isAction: true });
            }
            else {
                this.parent.notify(applyCF, { indexes: range, refreshAll: refreshAll, isAction: true });
            }
        }
    }
    activeCellRange(args) {
        args.range = args.range;
        const sheet = this.parent.getActiveSheet();
        let cell = getCell(args.range[0], args.range[1], sheet);
        if (cell) {
            if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                args.range[0] += cell.rowSpan;
                if (args.insertCount) {
                    args.range[0] -= args.insertCount;
                }
            }
            if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                args.range[1] += cell.colSpan;
                if (args.insertCount) {
                    args.range[1] -= args.insertCount;
                }
            }
            cell = getCell(args.range[0], args.range[1], sheet);
            if (cell) {
                if (cell.rowSpan > 1 && (args.range[0] + (cell.rowSpan - 1) >= args.range[2] || args.insertCount)) {
                    args.range[2] = args.range[0] + (cell.rowSpan - 1);
                }
                if (cell.colSpan > 1 && (args.range[1] + (cell.colSpan - 1) >= args.range[3] || args.insertCount)) {
                    args.range[3] = args.range[1] + (cell.colSpan - 1);
                }
            }
        }
    }
    mergedRange(args) {
        if (typeof (args.range) === 'string') {
            args.range = getRangeIndexes(args.range);
        }
        if (args.range[0] <= args.range[2] && args.range[1] <= args.range[3]) {
            this.forward(args);
        }
        else if (args.range[0] >= args.range[2] && args.range[1] >= args.range[3]) {
            this.reverse(args);
        }
        else if (args.range[0] < args.range[2] && args.range[1] > args.range[3]) {
            this.forwardReverse(args);
        }
        else if (args.range[0] > args.range[2] && args.range[1] < args.range[3]) {
            this.reverseForward(args);
        }
    }
    forward(args) {
        args.range = args.range;
        const sheet = isUndefined$1(args.sheetIndex) ? this.parent.getActiveSheet() : getSheet(this.parent, args.sheetIndex);
        let cell = getCell(args.range[0], args.range[1], sheet);
        let endRowIdx;
        let endColIdx;
        let rowIdx = endRowIdx = args.range[0];
        let colIdx = endColIdx = args.range[1];
        if (cell) {
            if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                rowIdx = endRowIdx = args.range[0] + cell.rowSpan;
            }
            if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                colIdx = endColIdx = args.range[1] + cell.colSpan;
            }
            cell = getCell(rowIdx, colIdx, sheet);
            if (cell) {
                if (cell.rowSpan > 1) {
                    endRowIdx += (cell.rowSpan - 1);
                    if (rowIdx + (cell.rowSpan - 1) >= args.range[2]) {
                        args.range[2] = args.range[0];
                        args.range[2] = rowIdx + (cell.rowSpan - 1);
                    }
                }
                if (cell.colSpan > 1) {
                    endColIdx += (cell.colSpan - 1);
                    if (colIdx + (cell.colSpan - 1) >= args.range[3]) {
                        args.range[3] = args.range[1];
                        args.range[3] = colIdx + (cell.colSpan - 1);
                    }
                }
            }
        }
        args.range[0] = rowIdx;
        args.range[1] = colIdx;
        if (args.range[0] === rowIdx && args.range[1] === colIdx && args.range[2] === endRowIdx && args.range[3] === endColIdx) {
            args.isActiveCell = true;
        }
        if (args.skipChecking) {
            return;
        }
        for (let i = args.range[1]; i <= args.range[3]; i++) {
            cell = getCell(args.range[2], i, sheet);
            if (cell) {
                rowIdx = args.range[2];
                colIdx = i;
                if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                    colIdx += cell.colSpan;
                    if (colIdx < args.range[1]) {
                        args.range[1] = colIdx;
                    }
                }
                if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                    rowIdx += cell.rowSpan;
                    if (rowIdx < args.range[0]) {
                        args.range[0] = rowIdx;
                    }
                }
                cell = getCell(rowIdx, colIdx, sheet);
                if (cell) {
                    if (cell.colSpan > 1 && colIdx + (cell.colSpan - 1) > args.range[3]) {
                        args.range[3] = colIdx;
                        args.range[3] = colIdx + (cell.colSpan - 1);
                    }
                    if (cell.rowSpan > 1 && rowIdx + (cell.rowSpan - 1) > args.range[2]) {
                        args.range[2] = rowIdx;
                        args.range[2] = rowIdx + (cell.rowSpan - 1);
                    }
                }
            }
        }
        let startRowIdx;
        let startColIdx;
        for (let i = args.range[1]; i <= args.range[3]; i++) {
            cell = getCell(args.range[0], i, sheet);
            if (cell) {
                startColIdx = i;
                startRowIdx = args.range[0];
                if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                    startColIdx += cell.colSpan;
                    if (startColIdx < args.range[1]) {
                        args.range[1] = startColIdx;
                    }
                }
                if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                    startRowIdx += cell.rowSpan;
                    if (startRowIdx < args.range[0]) {
                        args.range[0] = startRowIdx;
                    }
                }
            }
        }
        for (let i = args.range[0]; i <= args.range[2]; i++) {
            cell = getCell(i, args.range[3], sheet);
            if (cell) {
                rowIdx = i;
                colIdx = args.range[3];
                if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                    rowIdx += cell.rowSpan;
                    if (rowIdx < args.range[0]) {
                        args.range[0] = rowIdx;
                    }
                }
                if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                    colIdx += cell.colSpan;
                    if (colIdx < args.range[1]) {
                        args.range[1] = colIdx;
                    }
                }
                cell = getCell(rowIdx, colIdx, sheet);
                if (cell) {
                    if (cell.rowSpan > 1 && rowIdx + (cell.rowSpan - 1) > args.range[2]) {
                        args.range[2] = rowIdx;
                        args.range[2] = rowIdx + (cell.rowSpan - 1);
                    }
                    if (cell.colSpan > 1 && colIdx + (cell.colSpan - 1) > args.range[3]) {
                        args.range[3] = colIdx;
                        args.range[3] = colIdx + (cell.colSpan - 1);
                    }
                }
            }
        }
    }
    forwardReverse(args) {
        const sheet = this.parent.getActiveSheet();
        args.range = args.range;
        let colIndex = args.range[1];
        let cell = getCell(args.range[0], args.range[1], sheet);
        let rowIndex = args.range[0];
        if (cell) {
            if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                colIndex += cell.colSpan;
                if (args.range[3] >= colIndex) {
                    args.range[3] = colIndex;
                }
            }
            if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                rowIndex += cell.rowSpan;
                if (rowIndex < args.range[0]) {
                    args.range[0] = rowIndex;
                }
            }
            cell = getCell(rowIndex, colIndex, sheet);
            if (cell) {
                if (cell.rowSpan > 1 && rowIndex + (cell.rowSpan - 1) >= args.range[2]) {
                    args.range[2] = rowIndex + (cell.rowSpan - 1);
                }
                if (cell.colSpan > 1 && colIndex + (cell.colSpan - 1) >= args.range[1]) {
                    args.range[1] = colIndex + (cell.colSpan - 1);
                }
            }
        }
        args.range[0] = rowIndex;
        if (args.skipChecking) {
            return;
        }
        let rowIdx;
        let cellIdx;
        for (let i = args.range[3]; i <= args.range[1]; i++) {
            cell = getCell(args.range[2], i, sheet);
            if (cell) {
                cellIdx = i;
                rowIdx = args.range[2];
                if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                    rowIdx += cell.rowSpan;
                    if (rowIdx < args.range[0]) {
                        args.range[0] = rowIdx;
                    }
                }
                if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                    cellIdx += cell.colSpan;
                    if (cellIdx < args.range[3]) {
                        args.range[3] = cellIdx;
                    }
                }
                cell = getCell(rowIdx, cellIdx, sheet);
                if (cell) {
                    if (cell.rowSpan > 1 && rowIdx + (cell.rowSpan - 1) > args.range[2]) {
                        args.range[2] = rowIdx + (cell.rowSpan - 1);
                    }
                    if (cell.colSpan > 1 && cellIdx + (cell.colSpan - 1) > args.range[1]) {
                        args.range[1] = cellIdx + (cell.colSpan - 1);
                    }
                }
            }
        }
        let startRowIndex;
        for (let i = args.range[3]; i <= args.range[1]; i++) {
            cell = getCell(args.range[0], i, sheet);
            if (cell) {
                cellIdx = i;
                startRowIndex = args.range[0];
                if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                    startRowIndex += cell.rowSpan;
                    if (startRowIndex < args.range[0]) {
                        args.range[0] = startRowIndex;
                    }
                }
                if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                    cellIdx += cell.colSpan;
                }
                cell = getCell(startRowIndex, cellIdx, sheet);
                if (cell) {
                    if (cell.rowSpan > 1 && startRowIndex + (cell.rowSpan - 1) > args.range[2]) {
                        args.range[2] = startRowIndex + (cell.rowSpan - 1);
                    }
                    if (cell.colSpan > 1 && cellIdx + (cell.colSpan - 1) > args.range[1]) {
                        args.range[1] = cellIdx;
                        args.range[1] = cellIdx + (cell.colSpan - 1);
                    }
                }
            }
        }
        let colIdx;
        for (let i = args.range[0]; i <= args.range[2]; i++) {
            cell = getCell(i, args.range[3], sheet);
            if (cell) {
                startRowIndex = i;
                colIdx = args.range[3];
                if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                    startRowIndex += cell.rowSpan;
                    if (startRowIndex < args.range[0]) {
                        args.range[0] = startRowIndex;
                    }
                }
                if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                    colIdx += cell.colSpan;
                    if (colIdx < args.range[3]) {
                        args.range[3] = colIdx;
                    }
                }
                cell = getCell(startRowIndex, colIdx, sheet);
                if (cell) {
                    if (cell.rowSpan > 1 && startRowIndex + (cell.rowSpan - 1) > args.range[2]) {
                        args.range[2] = startRowIndex;
                        args.range[2] = startRowIndex + (cell.rowSpan - 1);
                    }
                    if (cell.colSpan > 1 && colIdx + (cell.colSpan - 1) > args.range[1]) {
                        args.range[1] = colIdx;
                        args.range[1] = colIdx + (cell.colSpan - 1);
                    }
                }
            }
        }
    }
    reverse(args) {
        args.range = args.range;
        let colnIdx = args.range[1];
        const sheet = isUndefined$1(args.sheetIndex) ? this.parent.getActiveSheet() : getSheet(this.parent, args.sheetIndex);
        let cell = getCell(args.range[0], args.range[1], sheet);
        let rowIdx = args.range[0];
        if (cell) {
            if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                colnIdx += cell.colSpan;
            }
            if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                rowIdx += cell.rowSpan;
            }
            if (args.range[2] >= rowIdx) {
                args.range[2] = rowIdx;
                args.isActiveCell = true;
            }
            if (args.range[3] >= colnIdx) {
                args.range[3] = colnIdx;
                if (args.range[2] === rowIdx) {
                    args.isActiveCell = true;
                }
            }
            else if (args.isActiveCell) {
                args.isActiveCell = false;
            }
            cell = getCell(rowIdx, colnIdx, sheet);
            if (cell) {
                if (cell.rowSpan > 1 && rowIdx + (cell.rowSpan - 1) >= args.range[0]) {
                    args.range[0] = rowIdx;
                    args.range[0] = rowIdx + (cell.rowSpan - 1);
                }
                if (cell.colSpan > 1 && colnIdx + (cell.colSpan - 1) >= args.range[1]) {
                    args.range[1] = colnIdx;
                    args.range[1] = colnIdx + (cell.colSpan - 1);
                }
            }
        }
        let colIdx = args.range[3];
        if (args.skipChecking) {
            return;
        }
        for (let i = args.range[3]; i <= args.range[1]; i++) {
            cell = getCell(args.range[2], i, sheet);
            if (cell) {
                colIdx = i;
                rowIdx = args.range[2];
                if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                    rowIdx += cell.rowSpan;
                    if (rowIdx < args.range[2]) {
                        args.range[2] = rowIdx;
                    }
                }
                if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                    colIdx += cell.colSpan;
                    if (colIdx < args.range[3]) {
                        args.range[3] = colIdx;
                    }
                }
                cell = getCell(rowIdx, colIdx, sheet);
                if (cell) {
                    if (cell.rowSpan > 1 && rowIdx + (cell.rowSpan - 1) > args.range[0]) {
                        args.range[0] = rowIdx;
                        args.range[0] = rowIdx + (cell.rowSpan - 1);
                    }
                    if (cell.colSpan > 1 && colIdx + (cell.colSpan - 1) > args.range[1]) {
                        args.range[1] = colIdx;
                        args.range[1] = colIdx + (cell.colSpan - 1);
                    }
                }
            }
        }
        colIdx = args.range[3];
        for (let i = args.range[3]; i <= args.range[1]; i++) {
            cell = getCell(args.range[0], i, sheet);
            if (cell) {
                colIdx = i;
                rowIdx = args.range[0];
                if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                    colIdx += cell.colSpan;
                }
                if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                    rowIdx += cell.rowSpan;
                }
                cell = getCell(rowIdx, colIdx, sheet);
                if (cell) {
                    if (cell.colSpan > 1 && colIdx + (cell.colSpan - 1) > args.range[1]) {
                        args.range[1] = colIdx;
                        args.range[1] = colIdx + (cell.colSpan - 1);
                    }
                    if (cell.rowSpan > 1 && rowIdx + (cell.rowSpan - 1) > args.range[0]) {
                        args.range[0] = rowIdx;
                        args.range[0] = rowIdx + (cell.rowSpan - 1);
                    }
                }
            }
        }
        let cellIndex;
        let rIdx;
        for (let i = args.range[2]; i <= args.range[0]; i++) {
            cell = getCell(i, args.range[3], sheet);
            if (cell) {
                rIdx = i;
                cellIndex = args.range[3];
                if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                    rIdx += cell.rowSpan;
                    if (rIdx < args.range[2]) {
                        args.range[2] = rIdx;
                    }
                }
                if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                    cellIndex += cell.colSpan;
                    if (cellIndex < args.range[3]) {
                        args.range[3] = cellIndex;
                    }
                }
                cell = getCell(rIdx, cellIndex, sheet);
                if (cell) {
                    if (cell.rowSpan > 1 && rIdx + (cell.rowSpan - 1) > args.range[0]) {
                        args.range[0] = rIdx;
                        args.range[0] = rIdx + (cell.rowSpan - 1);
                    }
                    if (cell.colSpan > 1 && cellIndex + (cell.colSpan - 1) > args.range[1]) {
                        args.range[1] = cellIndex;
                        args.range[1] = cellIndex + (cell.colSpan - 1);
                    }
                }
            }
        }
    }
    reverseForward(args) {
        args.range = args.range;
        const sheet = isUndefined$1(args.sheetIndex) ? this.parent.getActiveSheet() : getSheet(this.parent, args.sheetIndex);
        let rIdx = args.range[0];
        let cIdx = args.range[1];
        let cell = getCell(args.range[0], args.range[1], sheet);
        if (cell) {
            if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                rIdx += cell.rowSpan;
                if (args.range[2] >= rIdx) {
                    args.range[2] = rIdx;
                }
            }
            if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                cIdx += cell.colSpan;
            }
            cell = getCell(rIdx, cIdx, sheet);
            if (cell) {
                if (cell.rowSpan > 1 && rIdx + (cell.rowSpan - 1) >= args.range[0]) {
                    args.range[0] = rIdx;
                    args.range[0] = rIdx + (cell.rowSpan - 1);
                }
                if (cell.colSpan > 1 && cIdx + (cell.colSpan - 1) >= args.range[3]) {
                    args.range[3] = args.range[1];
                    args.range[3] = cIdx + (cell.colSpan - 1);
                }
            }
        }
        if (args.skipChecking) {
            return;
        }
        let cIndex = args.range[3];
        let rIndex;
        for (let i = args.range[1]; i <= args.range[3]; i++) {
            cell = getCell(args.range[2], i, sheet);
            if (cell) {
                rIndex = args.range[2];
                cIndex = i;
                if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                    rIndex += cell.rowSpan;
                    if (rIndex < args.range[2]) {
                        args.range[2] = rIndex;
                    }
                }
                if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                    cIndex += cell.colSpan;
                    if (cIndex < args.range[1]) {
                        args.range[1] = cIndex;
                    }
                }
                cell = getCell(rIndex, cIndex, sheet);
                if (cell) {
                    if (cell.colSpan > 1 && cIndex + (cell.colSpan - 1) > args.range[3]) {
                        args.range[3] = cIndex + (cell.colSpan - 1);
                    }
                    if (cell.rowSpan > 1 && (cell.rowSpan - 1) + rIndex > args.range[0]) {
                        args.range[0] = (cell.rowSpan - 1) + rIndex;
                    }
                }
            }
        }
        let sRowIdx;
        let sColIdx;
        for (let i = args.range[1]; i <= args.range[3]; i++) {
            cell = getCell(args.range[0], i, sheet);
            if (cell) {
                sColIdx = i;
                sRowIdx = args.range[0];
                if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                    sColIdx += cell.colSpan;
                    if (sColIdx < args.range[1]) {
                        args.range[1] = sColIdx;
                    }
                }
                if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                    sRowIdx += cell.rowSpan;
                }
                cell = getCell(sRowIdx, sColIdx, sheet);
                if (cell) {
                    if (cell.rowSpan > 1 && sRowIdx + (cell.rowSpan - 1) > args.range[0]) {
                        args.range[0] = sRowIdx + (cell.rowSpan - 1);
                    }
                }
            }
        }
        let cellIndex;
        for (let i = args.range[2]; i <= args.range[0]; i++) {
            cell = getCell(i, args.range[3], sheet);
            if (cell) {
                rIndex = i;
                cellIndex = args.range[3];
                if (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan < 0) {
                    rIndex += cell.rowSpan;
                    if (rIndex < args.range[2]) {
                        args.range[2] = rIndex;
                    }
                }
                if (!isNullOrUndefined(cell.colSpan) && cell.colSpan < 0) {
                    cellIndex += cell.colSpan;
                    if (cellIndex < args.range[1]) {
                        args.range[1] = cellIndex;
                    }
                }
                cell = getCell(rIndex, cellIndex, sheet);
                if (cell) {
                    if (cell.rowSpan > 1 && (cell.rowSpan - 1) + rIndex > args.range[0]) {
                        args.range[0] = (cell.rowSpan - 1) + rIndex;
                    }
                    if (cell.colSpan > 1 && (cell.colSpan - 1) + cellIndex > args.range[3]) {
                        args.range[3] = cellIndex;
                        args.range[3] = (cell.colSpan - 1) + cellIndex;
                    }
                }
            }
        }
    }
    insertHandler(args) {
        this.activeCellRange(args);
        args.range = args.range;
        if (args.insertModel === 'Row') {
            args.range[2] += args.insertCount;
        }
        else {
            args.range[3] += args.insertCount;
        }
        args.preventRefresh = true;
        args.merge = true;
        this.mergeAll(args);
    }
    addEventListener() {
        this.parent.on(setMerge, this.merge, this);
        this.parent.on(mergedRange, this.mergedRange, this);
        this.parent.on(activeCellMergedRange, this.activeCellRange, this);
        this.parent.on(insertMerge, this.insertHandler, this);
    }
    /**
     * Destroy workbook merge module.
     *
     * @returns {void} - destroy the workbook merge module.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(setMerge, this.merge);
            this.parent.off(mergedRange, this.mergedRange);
            this.parent.off(activeCellMergedRange, this.activeCellRange);
            this.parent.off(insertMerge, this.insertHandler);
        }
    }
    /**
     * Get the workbook merge module name.
     *
     * @returns {string} - Return the string.
     */
    getModuleName() {
        return 'workbookmerge';
    }
}

/**
 * The `WorkbookConditionalFormat` module is used to handle conditional formatting action in Spreadsheet.
 */
class WorkbookConditionalFormat {
    /**
     * Constructor for WorkbookConditionalFormat module.
     *
     * @param {Workbook} parent - Specifies the parent element.
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * To destroy the conditional format module.
     *
     * @returns {void}
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(setCFRule, this.setCFRule, this);
        this.parent.on(clearCFRule, this.clearCFRule, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(setCFRule, this.setCFRule);
            this.parent.off(clearCFRule, this.clearCFRule);
        }
    }
    setCFRule(e) {
        const cf = e.cfModel;
        const sheetIndex = e.sheetIdx === undefined ? getSheetIndexFromAddress(this.parent, cf.range) : e.sheetIdx;
        const sheet = getSheet(this.parent, sheetIndex);
        let indexes = getSwapRange(getRangeIndexes(cf.range || sheet.selectedRange));
        cf.range = getRangeAddress(indexes);
        if (e.isAction) {
            const eventArgs = { range: cf.range, type: cf.type, cancel: false, cFColor: cf.cFColor, value: cf.value,
                sheetIdx: sheetIndex };
            this.parent.notify(beginAction, { eventArgs: eventArgs, action: 'conditionalFormat' });
            if (eventArgs.cancel) {
                return;
            }
            cf.type = eventArgs.type;
            cf.cFColor = eventArgs.cFColor;
            cf.value = eventArgs.value;
            if (eventArgs.range !== cf.range) {
                cf.range = eventArgs.range;
                indexes = getSwapRange(getRangeIndexes(eventArgs.range));
            }
            delete eventArgs.cancel;
        }
        if (!sheet.conditionalFormats) {
            this.parent.setSheetPropertyOnMute(sheet, 'conditionalFormats', []);
        }
        sheet.conditionalFormats.push(cf);
        if (sheetIndex !== this.parent.activeSheetIndex) {
            if (e.isUndoRedo && !e.isFromUpdateAction) {
                this.parent.notify(goto, { address: sheet.name + '!' + cf.range });
            }
        }
        else {
            this.parent.notify(applyCF, { cfModel: [cf], isAction: true });
        }
        this.parent.setUsedRange(indexes[2], indexes[3]);
        if (e.isAction) {
            this.parent.notify('actionComplete', { eventArgs: { range: cf.range, type: cf.type, cFColor: cf.cFColor, value: cf.value, sheetIdx: sheetIndex },
                action: 'conditionalFormat' });
        }
    }
    clearCFRule(args) {
        if (args.sheetIdx === undefined) {
            args.sheetIdx = this.parent.activeSheetIndex;
        }
        const sheet = getSheet(this.parent, args.sheetIdx);
        const cfRule = sheet.conditionalFormats;
        const allowActionComplete = cfRule && cfRule[cfRule.length - 1] && cfRule[cfRule.length - 1].action !== 'autofillWithCF';
        if (args.isUndo) {
            if (args.updatedCFModel) {
                args.updatedCFModel.forEach((cf) => {
                    for (let i = 0; i < cfRule.length; i++) {
                        if (cfRule[i].type === cf.type && cfRule[i].cFColor === cf.cFColor &&
                            cfRule[i].range === cf.range && cfRule[i].value === cf.value) {
                            cfRule.splice(i, 1);
                            break;
                        }
                    }
                });
            }
            cfRule.push(...args.oldCFModel.map((item) => Object.assign({}, item)));
            this.parent.notify(applyCF, { cfModel: args.oldCFModel, isAction: true });
            if (args.sheetIdx !== this.parent.activeSheetIndex) {
                this.parent.notify(goto, { address: sheet.name + '!' + args.range });
            }
            return;
        }
        if (!cfRule || !cfRule.length) {
            return;
        }
        let cf;
        let cfRange;
        let cfIdx;
        let newRange;
        let left;
        let right;
        let top;
        let bottom;
        let range;
        let idx = args.range && (typeof args.range === 'string' ? getRangeIndexes(args.range) : args.range);
        idx = idx ? getSwapRange(idx) : idx;
        args.oldCFModel = [];
        args.updatedCFModel = [];
        const updatedCFModel = [];
        const oldRange = [];
        const refreshCF = [];
        for (let i = 0; i < cfRule.length; i++) {
            cf = cfRule[i];
            cfRange = cf.range.split(',');
            for (let j = 0; j < cfRange.length; j++) {
                cfIdx = getRangeIndexes(cfRange[j]);
                if (args.range) {
                    if (idx[0] <= cfIdx[0] && idx[1] <= cfIdx[1] && idx[2] >= cfIdx[2] && idx[3] >= cfIdx[3]) {
                        cfRange.splice(j, 1);
                        j--;
                    }
                    else {
                        top = idx[0] >= cfIdx[0] && idx[0] <= cfIdx[2];
                        bottom = idx[2] >= cfIdx[0] && idx[2] <= cfIdx[2];
                        left = idx[1] >= cfIdx[1] && idx[1] <= cfIdx[3];
                        right = idx[3] >= cfIdx[1] && idx[3] <= cfIdx[3];
                        newRange = [];
                        if (top && bottom) {
                            if (left || right || (idx[1] < cfIdx[1] && idx[3] > cfIdx[3])) {
                                if (idx[0] - cfIdx[0] > 0) {
                                    newRange.push(getRangeAddress([cfIdx[0], cfIdx[1], idx[0] - 1, cfIdx[3]]));
                                }
                                if (cfIdx[2] - idx[2] > 0) {
                                    newRange.push(getRangeAddress([idx[2] + 1, cfIdx[1], cfIdx[2], cfIdx[3]]));
                                }
                            }
                            if (left && idx[1] !== cfIdx[1]) {
                                newRange.push(getRangeAddress([idx[0], cfIdx[1], idx[2], idx[1] - 1]));
                            }
                            if (right && idx[3] !== cfIdx[3]) {
                                newRange.push(getRangeAddress([idx[0], idx[3] + 1, idx[2], cfIdx[3]]));
                            }
                        }
                        else if (left && right) {
                            if (top || bottom || (idx[0] < cfIdx[0] && idx[2] > cfIdx[2])) {
                                if (idx[1] - cfIdx[1] > 0) {
                                    newRange.push(getRangeAddress([cfIdx[0], cfIdx[1], cfIdx[2], idx[1] - 1]));
                                }
                                if (cfIdx[3] - idx[3] > 0) {
                                    newRange.push(getRangeAddress([cfIdx[0], idx[3] + 1, cfIdx[2], cfIdx[3]]));
                                }
                            }
                            if (top) {
                                if (idx[0] !== cfIdx[0]) {
                                    newRange.push(getRangeAddress([cfIdx[0], idx[1], idx[0] - 1, idx[3]]));
                                }
                            }
                            else if (bottom && idx[2] !== cfIdx[2]) {
                                newRange.push(getRangeAddress([idx[2] + 1, idx[1], cfIdx[2], idx[3]]));
                            }
                        }
                        else if (top || bottom) {
                            if (left) {
                                if (idx[1] !== cfIdx[1]) {
                                    newRange.push(getRangeAddress([cfIdx[0], cfIdx[1], cfIdx[2], idx[1] - 1]));
                                }
                                if (idx[0] - cfIdx[0] > 0) {
                                    newRange.push(getRangeAddress([cfIdx[0], idx[1], idx[0] - 1, cfIdx[3]]));
                                }
                                else if (cfIdx[2] - idx[2] > 0) {
                                    newRange.push(getRangeAddress([idx[2] + 1, idx[1], cfIdx[2], cfIdx[3]]));
                                }
                            }
                            else if (right) {
                                if (idx[3] !== cfIdx[3]) {
                                    newRange.push(getRangeAddress([cfIdx[0], idx[3] + 1, cfIdx[2], cfIdx[3]]));
                                }
                                if (idx[0] - cfIdx[0] > 0) {
                                    newRange.push(getRangeAddress([cfIdx[0], cfIdx[1], idx[0] - 1, idx[3]]));
                                }
                                else if (cfIdx[2] - idx[2] > 0) {
                                    newRange.push(getRangeAddress([idx[2] + 1, cfIdx[1], cfIdx[2], idx[3]]));
                                }
                            }
                        }
                        if (newRange.length) {
                            cfRange[j] = newRange.join(',');
                        }
                        else {
                            continue;
                        }
                    }
                }
                else {
                    idx = cfIdx;
                    cfRange.splice(j, 1);
                    j--;
                }
                if (args.sheetIdx === this.parent.activeSheetIndex) {
                    this.parent.notify(clearCF, { indexes: [...idx] });
                }
            }
            range = cfRange.join(',');
            if (range !== cf.range) {
                if (args.cfModel && (args.cfModel.cFColor !== cf.cFColor || args.cfModel.type !== cf.type ||
                    args.cfModel.value !== cf.value)) {
                    refreshCF.push(cf);
                    continue;
                }
                oldRange.push(cf.range);
                if (!range) {
                    args.oldCFModel.push(cf);
                    updatedCFModel.concat(cfRule.splice(i, 1));
                    i--;
                }
                else {
                    args.oldCFModel.push({ type: cf.type, cFColor: cf.cFColor, format: cf.format, range: cf.range, value: cf.value });
                    cf.range = range;
                    if (cf.result) {
                        delete cf.result;
                        this.parent.notify(applyCF, { cfModel: [cf], isAction: true });
                    }
                    args.updatedCFModel.push(cf);
                    updatedCFModel.push(cf);
                }
            }
        }
        if (args.sheetIdx !== this.parent.activeSheetIndex) {
            if (args.isUndoRedo && !args.isFromUpdateAction) {
                this.parent.notify(goto, { address: sheet.name + '!' + args.range });
            }
        }
        else if (refreshCF.length) {
            this.parent.notify(applyCF, { cfModel: refreshCF, isAction: true });
        }
        if ((args.isAction || args.isClear) && args.oldCFModel.length) {
            const eventArgs = { cFormats: updatedCFModel, oldRange: oldRange,
                previousConditionalFormats: args.oldCFModel, sheetIdx: args.sheetIdx, selectedRange: args.range };
            if (args.updatedCFModel.length) {
                eventArgs.conditionalFormats = args.updatedCFModel;
            }
            if (args.isClear) {
                args.cfClearActionArgs = eventArgs;
            }
            else {
                if (allowActionComplete) {
                    this.parent.notify('actionComplete', { eventArgs: eventArgs, action: 'clearCF' });
                }
            }
        }
    }
    /**
     * Gets the module name.
     *
     * @returns {void} string
     */
    getModuleName() {
        return 'workbookConditionalFormatting';
    }
}

/**
 * WorkbookAutoFill module allows to perform auto fill functionalities.
 */
class WorkbookAutoFill {
    /**
     * Constructor for the workbook AutoFill module.
     *
     * @param {Workbook} parent - Specifies the workbook.
     * @private
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    getFillInfo(options) {
        const l10n = this.parent.serviceLocator.getService(workbookLocale);
        let val = '';
        let isStringType = true;
        let fillType = 'CopyCells';
        const disableItems = [];
        const isVFill = ['Down', 'Up'].indexOf(options.direction) > -1;
        const data = this.getRangeData({ range: options.dataRange, sheetIdx: this.parent.activeSheetIndex });
        const len = data.join().replace(/,/g, '').length;
        let i = this.isRange(options.dataRange) && len ? data.length : 1;
        while (i--) {
            val = data[i] && !isNullOrUndefined(data[i].value) ? data[i].value : '';
            if (isNumber(val) || checkIsFormula(val) || isNumber(val[val.length - 1])) {
                isStringType = false;
                fillType = this.parent.autoFillSettings.fillType;
                break;
            }
        }
        if (!len || isStringType) {
            disableItems.push(l10n.getConstant('FillSeries'));
            fillType = (options.fillType === 'FillSeries') ? fillType : options.fillType;
        }
        if (!isVFill || (isVFill && options.dataRange[1] !== options.dataRange[3])) {
            disableItems.push('Flash Fill'); // for flash fill option
        }
        return { fillType: fillType, disableItems: disableItems };
    }
    isRange(range) {
        return range && (range[0] !== range[2] || range[1] !== range[3]);
    }
    autoFill(options) {
        if (!options.dataRange || !options.fillRange || !options.direction || !this.parent.allowEditing ||
            (this.parent.getActiveSheet().isProtected && options.isLockedCell)) {
            return;
        }
        const dataRangeIndices = getSwapRange(getRangeIndexes(options.dataRange));
        const fillRangeIndices = getSwapRange(getRangeIndexes(options.fillRange));
        const autoFillOptions = {
            dataRange: dataRangeIndices, fillRange: fillRangeIndices, direction: options.direction, fillType: options.fillType || this.fillInfo.fillType, dataSheetIndex: getSheetIndexFromAddress(this.parent, options.dataRange),
            fillSheetIndex: getSheetIndexFromAddress(this.parent, options.fillRange), cells: options.cells
        };
        this.fillInfo = this.getFillInfo({ dataRange: dataRangeIndices, fillRange: fillRangeIndices, fillType: options.fillType,
            direction: options.direction });
        this.fillInfo.fillType = options.isFillOptClick ? options.fillType : this.fillInfo.fillType;
        switch (options.fillType) {
            case 'FillSeries':
            case 'FillWithoutFormatting':
                this.fillSeries(autoFillOptions);
                break;
            case 'CopyCells':
            case 'FillFormattingOnly':
                this.copyCells(autoFillOptions);
                break;
        }
    }
    fillSeries(options) {
        let val;
        let plen;
        let patterns;
        let patrn;
        let pRanges;
        let patrnRange;
        let fillRange;
        let data;
        let nextStringValue;
        let match;
        let temp;
        let dlen;
        let j;
        let k;
        let l;
        let tlen;
        let tot;
        let hasRef;
        let cells;
        let clen;
        let cellIdx;
        let cellProps = {};
        let i = 0;
        let prevCellData;
        let dateVal;
        let dateObj;
        const dataSheetIndex = isUndefined$1(options.dataSheetIndex) ? this.parent.activeSheetIndex : options.dataSheetIndex;
        const dataSheet = getSheet(this.parent, dataSheetIndex);
        let fillSheetIndex;
        let activeSheet;
        if (isUndefined$1(options.fillSheetIndex)) {
            fillSheetIndex = this.parent.activeSheetIndex;
            activeSheet = true;
        }
        else {
            fillSheetIndex = options.fillSheetIndex;
            activeSheet = fillSheetIndex === this.parent.activeSheetIndex;
        }
        const fillSheet = getSheet(this.parent, fillSheetIndex);
        const dminr = options.dataRange[0];
        const dminc = options.dataRange[1];
        const dmaxr = options.dataRange[2];
        const dmaxc = options.dataRange[3];
        const fminr = options.fillRange[0];
        const fminc = options.fillRange[1];
        const fmaxr = options.fillRange[2];
        const fmaxc = options.fillRange[3];
        const isVFill = ['Down', 'Up'].indexOf(options.direction) > -1;
        const isReverseFill = ['Up', 'Left'].indexOf(options.direction) > -1;
        const len = isVFill ? dmaxc - dminc : dmaxr - dminr;
        const fillWithFrmt = options.fillType === 'FillSeries';
        let prop;
        let cfRefreshAll;
        let cancel;
        const cf = dataSheet.conditionalFormats && dataSheet.conditionalFormats.length &&
            [].slice.call(dataSheet.conditionalFormats);
        const cfRule = [];
        const applyWrapToOuterCells = activeSheet && this.applyWrapToOuterCells(fillSheet);
        const isRowHeightCheck = options.fillType !== 'FillWithoutFormatting' && activeSheet && isVFill;
        while (i <= len) {
            pRanges = this.updateFillValues(isVFill, dminr, dminc, dmaxr, dmaxc, fminr, fminc, fmaxr, fmaxc, i);
            patrnRange = pRanges.patternRange;
            fillRange = pRanges.fillRange;
            patterns = this.getPattern(patrnRange, { isReverseFill: isReverseFill, isVFill: isVFill }, dataSheetIndex);
            data = this.getRangeData({ range: patrnRange, sheetIdx: dataSheetIndex });
            if (!isVFill) {
                data = this.getRangeData({ range: patrnRange, sheetIdx: dataSheetIndex }, true);
            }
            let isRefFormula = false;
            if (data[0] && data[0].formula && data[0].formula.match(/=[A-Za-z]+\(([^:]+):([^:]+)\)/)) {
                isRefFormula = true;
            }
            dlen = data.length;
            for (let l = 0; l < dlen; l++) {
                if (data[l] && data[l].isReadOnly) {
                    this.parent.notify(workbookReadonlyAlert, null);
                    return;
                }
            }
            if (!patterns || !patterns.length) {
                return;
            }
            plen = patterns.length;
            cells = this.getSelectedRange(fillSheet, { rowIndex: fillRange[0], colIndex: fillRange[1] }, { rowIndex: fillRange[2],
                colIndex: fillRange[3] });
            clen = cells.length;
            if (isReverseFill) {
                cells = cells.reverse();
                patterns = patterns.reverse();
                patterns = this.ensurePattern(patterns);
                data = data.reverse();
            }
            j = 0;
            while (j < clen) {
                cellIdx = cells[j];
                patrn = patterns[j % plen];
                if (isNumber(patrn)) {
                    patrn = patterns[patrn];
                }
                l = j % dlen;
                switch (patrn['type']) {
                    case 'number':
                    case 'date':
                        patrn = patrn;
                        if (patrn.isStartWithMonth && dlen === 1) {
                            dateVal = intToDate(patrn.regVal.a);
                            dateObj = new Date(dateVal);
                            dateVal.setMonth(dateVal.getMonth() + (patrn.regVal.b * patrn.i));
                            if (dateObj.getDate() > 28 && dateObj.getDate() !== dateVal.getDate()) {
                                dateObj.setDate(1);
                                dateObj.setMonth(dateObj.getMonth() + (patrn.regVal.b * patrn.i));
                                dateObj.setDate(new Date(dateObj.getFullYear(), dateObj.getMonth() + 1, 0).getDate());
                                dateVal = dateObj;
                            }
                            val = dateToInt(dateVal).toString();
                        }
                        else {
                            val = (this.round(patrn['regVal'].a + (patrn['regVal'].b * patrn['i']), 5)).toString();
                            if (patrn.val) {
                                match = (typeof (patrn.val[0]) === 'string') && patrn.val[0].match(/^0+/);
                                if (match) {
                                    nextStringValue = this.getNextFormattedValue(patrn.val[0], Number(val));
                                }
                            }
                        }
                        if (patrn.dataVal) {
                            if (patrn.copy === undefined && !match) {
                                patrn.copy = patrn.val.length > 2;
                                if (patrn.copy) {
                                    for (let m = 2; m < patrn.val.length; m++) {
                                        patrn.copy = Math.abs(this.round(patrn['regVal'].a + (patrn['regVal'].b * m), 5)) !==
                                            patrn.val[m];
                                        if (patrn.copy) {
                                            break;
                                        }
                                    }
                                }
                            }
                            val = patrn.copy ? (data[l] && !isNullOrUndefined(data[l].value) ? data[l].value : '') :
                                (patrn.start ? Math.abs(Number(val)) + patrn.dataVal :
                                    (match ? patrn.dataVal + nextStringValue : patrn.dataVal + Math.abs(Number(val))));
                        }
                        if (isReverseFill) {
                            patrn['i']--;
                        }
                        else {
                            patrn['i']++;
                        }
                        break;
                    case 'string':
                        // eslint-disable-next-line no-case-declarations
                        const newVal = patrn['i'] % patrn['val'].length;
                        val = patrn['val'][newVal];
                        patrn['i']++;
                        break;
                    case 'formula':
                        hasRef = false;
                        val = '=';
                        k = 0;
                        tlen = patrn['val'].length;
                        while (k < tlen) {
                            temp = patrn['val'][k];
                            if (typeof temp === 'object') {
                                hasRef = true;
                                tot = this.round(temp['a'] + (temp['b'] * patrn['i']), 5);
                                if (tot < 1) {
                                    val += '#REF!';
                                    if (isRefFormula) {
                                        k = tlen - 1;
                                        val += patrn['val'][k];
                                    }
                                }
                                else {
                                    val += isVFill ? temp['c'] + (temp['b'] ? tot : '$' + tot) : (temp['b'] ? getColumnHeaderText(tot) : temp['c'].substring(0, temp['c'].search(/\d/)) + '$' + getColumnHeaderText(tot)) + temp['c'].trim();
                                }
                            }
                            else {
                                val += temp;
                            }
                            k++;
                        }
                        if (hasRef && isReverseFill) {
                            patrn['i']--;
                        }
                        else {
                            patrn['i']++;
                        }
                        break;
                    case 'time':
                        val = (patrn['regVal'].a + (patrn['regVal'].b * patrn['i'])).toString();
                        if (Number(val) < 0 && isReverseFill) {
                            val = ((patrn['regVal'].a + Math.ceil(Math.abs(patrn['i'] / 24))) + (patrn['regVal'].b * patrn['i'])).toString();
                        }
                        if (isReverseFill) {
                            patrn['i']--;
                        }
                        else {
                            patrn['i']++;
                        }
                        break;
                }
                prevCellData = getCell(cellIdx.rowIndex, cellIdx.colIndex, fillSheet, false, true);
                if (prevCellData && prevCellData.isReadOnly) {
                    this.parent.notify(workbookReadonlyAlert, null);
                    return;
                }
                if (fillWithFrmt) {
                    Object.assign(cellProps, data[l], null, true);
                }
                else {
                    if (options.fillType === 'FillWithoutFormatting' && data[l] && data[l].hyperlink) {
                        cellProps.hyperlink = data[l].hyperlink;
                        cellProps.style = { textDecoration: 'none', color: 'inherit' };
                    }
                    else {
                        cellProps.style = prevCellData.style;
                    }
                    cellProps.format = prevCellData.format;
                    cellProps.wrap = prevCellData.wrap;
                    cellProps.rowSpan = prevCellData.rowSpan;
                    cellProps.colSpan = prevCellData.colSpan;
                }
                if (data[l] && data[l].validation) {
                    cellProps.validation = Object.assign({}, data[l].validation);
                    const currIdx = [cellIdx.rowIndex, cellIdx.colIndex, cellIdx.rowIndex, cellIdx.colIndex];
                    const prevIdx = [options.dataRange[0], options.dataRange[1], options.dataRange[2], options.dataRange[3]];
                    const sheet = this.parent.sheets[this.parent.activeSheetIndex];
                    let updatedValue = getUpdatedFormula(currIdx, prevIdx, sheet, this.parent, { formula: cellProps.validation.value1 });
                    cellProps.validation.value1 = updatedValue;
                    if (cellProps.validation.value2 !== '') {
                        updatedValue = getUpdatedFormula(currIdx, prevIdx, sheet, this.parent, { formula: cellProps.validation.value2 });
                        cellProps.validation.value2 = updatedValue;
                    }
                }
                const isFormula = checkIsFormula(val);
                if (isFormula) {
                    cellProps.formula = val;
                }
                if (val !== '0' || (val === '0' && options.fillType !== 'FillWithoutFormatting')) {
                    cellProps.value = isFormula && this.parent.calculationMode === 'Manual' ?
                        (data[l] ? data[l].value : '0') : val;
                }
                if (!isNullOrUndefined(cellProps.notes)) {
                    delete cellProps.notes;
                }
                prop = { cell: cellProps, rowIdx: cellIdx.rowIndex, colIdx: cellIdx.colIndex, valChange: true, uiRefresh: activeSheet,
                    pvtExtend: true, skipFormatCheck: true, fillType: options.fillType };
                if (activeSheet && !isHiddenRow(fillSheet, cellIdx.rowIndex) && !isHiddenCol(fillSheet, cellIdx.colIndex)) {
                    prop.td = this.parent.getCell(cellIdx.rowIndex, cellIdx.colIndex);
                    if (prop.td) {
                        prop.uiRefresh = true;
                    }
                }
                cancel = updateCell(this.parent, fillSheet, prop, options.cells);
                if (!cancel) {
                    if (activeSheet) {
                        applyWrapToOuterCells(prop);
                    }
                    if (cf && !cfRefreshAll) {
                        cfRefreshAll = prop.isFormulaDependent;
                        if (!cfRefreshAll) {
                            updateCFModel(cf, cfRule, cellIdx.rowIndex, cellIdx.colIndex, options.dataRange, options.fillRange, dataSheet);
                        }
                    }
                    if (isRowHeightCheck && cellProps.style && isHeightCheckNeeded(cellProps.style)) {
                        this.parent.notify(applyCellFormat, {
                            rowIdx: cellIdx.rowIndex, colIdx: cellIdx.colIndex, style: cellProps.style,
                            lastCell: true, isHeightCheckNeeded: true, onActionUpdate: true, manualUpdate: true
                        });
                    }
                }
                cellProps = {};
                j++;
            }
            i++;
        }
        if (cfRule.length || cfRefreshAll) {
            this.parent.notify(applyCF, { cfModel: !cfRefreshAll && cfRule, refreshAll: cfRefreshAll, isAction: true, isEdit: true });
        }
    }
    copyCells(options) {
        let i = 0;
        let j;
        let k;
        let patrnRange;
        let fillRange;
        let pRanges;
        let data;
        let dlen;
        let cells;
        let clen;
        let cellProperty = {};
        let cellIdx;
        const dMinR = options.dataRange[0];
        const dMinC = options.dataRange[1];
        const dMaxR = options.dataRange[2];
        const dMaxC = options.dataRange[3];
        const fMinR = options.fillRange[0];
        const fMinC = options.fillRange[1];
        const fMaxR = options.fillRange[2];
        const fMaxC = options.fillRange[3];
        const isVFill = ['Down', 'Up'].indexOf(options.direction) > -1;
        const isReverseFill = ['Up', 'Left'].indexOf(options.direction) > -1;
        const len = isVFill ? dMaxC - dMinC : dMaxR - dMinR;
        const dataSheetIndex = isUndefined$1(options.dataSheetIndex) ? this.parent.activeSheetIndex : options.dataSheetIndex;
        const dataSheet = getSheet(this.parent, dataSheetIndex);
        let fillSheetIndex;
        let activeSheet;
        if (isUndefined$1(options.fillSheetIndex)) {
            activeSheet = true;
            fillSheetIndex = this.parent.activeSheetIndex;
        }
        else {
            activeSheet = options.fillSheetIndex === this.parent.activeSheetIndex;
            fillSheetIndex = options.fillSheetIndex;
        }
        const fillSheet = getSheet(this.parent, fillSheetIndex);
        const formatOnly = options.fillType === 'FillFormattingOnly';
        let prevCellData;
        let cfRefreshAll;
        let prop;
        const cf = dataSheet.conditionalFormats && dataSheet.conditionalFormats.length &&
            [].slice.call(dataSheet.conditionalFormats);
        let cancel;
        const applyWrapToOuterCells = activeSheet && this.applyWrapToOuterCells(fillSheet);
        const cfRule = [];
        const isRowHeightCheck = activeSheet && isVFill;
        while (i <= len) {
            pRanges = this.updateFillValues(isVFill, dMinR, dMinC, dMaxR, dMaxC, fMinR, fMinC, fMaxR, fMaxC, i);
            patrnRange = pRanges.patternRange;
            fillRange = pRanges.fillRange;
            data = this.getRangeData({ range: patrnRange, sheetIdx: dataSheetIndex });
            dlen = data.length;
            for (let m = 0; m < dlen; m++) {
                if (data[m] && data[m].isReadOnly) {
                    this.parent.notify(workbookReadonlyAlert, null);
                    return;
                }
            }
            cells = this.getSelectedRange(fillSheet, { rowIndex: fillRange[0], colIndex: fillRange[1] }, { rowIndex: fillRange[2], colIndex: fillRange[3] });
            clen = cells.length;
            j = 0;
            if (isReverseFill) {
                cells = cells.reverse();
            }
            while (j < clen) {
                k = j % dlen;
                cellIdx = cells[j];
                if (formatOnly) {
                    prevCellData = getCell(cellIdx.rowIndex, cellIdx.colIndex, fillSheet);
                }
                Object.assign(cellProperty, data[k], null, true);
                if (formatOnly) {
                    cellProperty.value = prevCellData.value;
                    cellProperty.formula = prevCellData.formula;
                    if (!isNullOrUndefined(cellProperty.notes)) {
                        delete cellProperty.notes;
                    }
                    if (cellProperty.validation) {
                        delete cellProperty.validation;
                    }
                }
                if (cellProperty && cellProperty.isReadOnly) {
                    this.parent.notify(workbookReadonlyAlert, null);
                    return;
                }
                if (!isNullOrUndefined(cellProperty.notes) && !isNullOrUndefined(cellProperty.isNoteEditable)) {
                    delete cellProperty.notes;
                    delete cellProperty.isNoteEditable;
                }
                prop = { cell: cellProperty, rowIdx: cellIdx.rowIndex, colIdx: cellIdx.colIndex, valChange: true,
                    pvtExtend: true, fillType: options.fillType };
                if (activeSheet && !isHiddenRow(fillSheet, cellIdx.rowIndex) && !isHiddenCol(fillSheet, cellIdx.colIndex)) {
                    prop.td = this.parent.getCell(cellIdx.rowIndex, cellIdx.colIndex);
                    prop.uiRefresh = !!prop.td;
                }
                cancel = updateCell(this.parent, fillSheet, prop, options.cells);
                if (!cancel) {
                    if (activeSheet) {
                        applyWrapToOuterCells(prop);
                    }
                    if (cf && !cfRefreshAll) {
                        cfRefreshAll = prop.isFormulaDependent;
                        if (!cfRefreshAll) {
                            updateCFModel(cf, cfRule, cellIdx.rowIndex, cellIdx.colIndex, options.dataRange, options.fillRange, dataSheet);
                        }
                    }
                    if (isRowHeightCheck && cellProperty.style && isHeightCheckNeeded(cellProperty.style)) {
                        this.parent.notify(applyCellFormat, {
                            rowIdx: cellIdx.rowIndex, colIdx: cellIdx.colIndex, style: cellProperty.style,
                            lastCell: true, isHeightCheckNeeded: true, onActionUpdate: true, manualUpdate: true
                        });
                    }
                }
                cellProperty = {};
                j++;
            }
            i++;
        }
        if (cfRule.length || cfRefreshAll) {
            this.parent.notify(applyCF, { cfModel: !cfRefreshAll && cfRule, refreshAll: cfRefreshAll, isAction: true, isEdit: true });
        }
    }
    applyWrapToOuterCells(sheet) {
        let viewTopIdx;
        let viewLeftIdx;
        const frozenRow = this.parent.frozenRowCount(sheet);
        const frozenCol = this.parent.frozenColCount(sheet);
        const viewport = this.parent.viewport;
        if (viewport) {
            viewTopIdx = viewport.topIndex + frozenRow;
            viewLeftIdx = viewport.leftIndex + frozenCol;
        }
        let wrapArgs;
        return (options) => {
            if (!options.td && getCell(options.rowIdx, options.colIdx, sheet, false, true).wrap && ((options.rowIdx >= frozenRow &&
                options.rowIdx < viewTopIdx) || (options.colIdx >= frozenCol && options.colIdx < viewLeftIdx))) {
                if (!wrapArgs) {
                    wrapArgs = { range: null, wrap: true, sheet: sheet, initial: true, outsideViewport: true };
                }
                wrapArgs.range = [options.rowIdx, options.colIdx, options.rowIdx, options.colIdx];
                this.parent.notify(wrapEvent, wrapArgs);
            }
        };
    }
    updateFillValues(isVFill, dminr, dminc, dmaxr, dmaxc, fminr, fminc, fmaxr, fmaxc, i) {
        let pStart;
        let pEnd;
        let fStart;
        let fEnd;
        if (isVFill) {
            pStart = { rowIndex: dminr, colIndex: dminc + i };
            pEnd = { rowIndex: dmaxr, colIndex: dminc + i };
            fStart = { rowIndex: fminr, colIndex: fminc + i };
            fEnd = { rowIndex: fmaxr, colIndex: fminc + i };
        }
        else {
            pStart = { rowIndex: dminr + i, colIndex: dminc };
            pEnd = { rowIndex: dminr + i, colIndex: dmaxc };
            fStart = { rowIndex: fminr + i, colIndex: fminc };
            fEnd = { rowIndex: fminr + i, colIndex: fmaxc };
        }
        const patternRange = [pStart.rowIndex, pStart.colIndex, pEnd.rowIndex, pEnd.colIndex];
        const fillRange = [fStart.rowIndex, fStart.colIndex, fEnd.rowIndex, fEnd.colIndex];
        return { patternRange: patternRange, fillRange: fillRange };
    }
    getDataPattern(range, sheetIdx) {
        let val;
        let numValue;
        let type;
        let i = 0;
        let obj = { val: null,
            type: null };
        const patrn = [];
        const data = this.getRangeData({
            range: range, sheetIdx: isUndefined$1(sheetIdx) ? this.parent.activeSheetIndex
                : sheetIdx
        });
        const dlen = data.length;
        let isStartNum;
        let isDateStartsWithMonth;
        if (dlen) {
            let count;
            let dataVal;
            let format;
            let isNumVal;
            const minusOperator = (data) => {
                return !isStartNum && data && data[data.length - 1] === '-' ? data.slice(0, data.length - 1) : data;
            };
            while (i < dlen) {
                isDateStartsWithMonth = false;
                if (data[i]) {
                    if (data[i].formula && checkIsFormula(data[i].formula)) {
                        val = data[i].formula;
                        type = 'formula';
                    }
                    else {
                        val = isNullOrUndefined(data[i].value) ? '' : data[i].value;
                        const option = {};
                        format = data[i].format;
                        isNumVal = isNumber(val);
                        if (format && isCustomDateTime(format, true, option)) {
                            type = option.type;
                            if (val && !isNumVal) {
                                const dateEventArgs = { value: val, updatedVal: val, cell: data[i] };
                                this.parent.notify(checkDateFormat, dateEventArgs);
                                if (dateEventArgs.isDate || dateEventArgs.isTime) {
                                    data[i].value = val = dateEventArgs.updatedVal;
                                }
                                else {
                                    type = 'string';
                                }
                            }
                            isDateStartsWithMonth = type === 'date' && format.toLowerCase().startsWith('mmm');
                        }
                        else {
                            type = isNumVal ? 'number' : 'string';
                        }
                    }
                }
                else {
                    val = '';
                    type = 'string';
                }
                dataVal = '';
                if (type === 'string') {
                    isStartNum = false;
                    if (isNumber(val[0])) {
                        count = 0;
                        do {
                            count++;
                        } while (isNumber(val[count]));
                        if (val[count] === ' ') {
                            isStartNum = true;
                            type = 'number';
                            dataVal = val.slice(count, val.length);
                            val = Number(val.slice(0, count));
                        }
                    }
                    val = val;
                    if (!isStartNum && isNumber(val[val.length - 1])) {
                        count = 1;
                        do {
                            count++;
                        } while (isNumber(val[val.length - count]));
                        type = 'number';
                        count -= 1;
                        dataVal = val.slice(0, val.length - count);
                        numValue = val.slice(val.length - count, val.length);
                        val = numValue.match(/^0+/) ? numValue : Number(numValue);
                        if (obj.dataVal && obj.dataVal !== dataVal && obj.dataVal === minusOperator(dataVal)) {
                            dataVal = obj.dataVal;
                        }
                    }
                }
                if (i === 0) {
                    obj = { val: [val], type: type, isStartWithMonth: isDateStartsWithMonth };
                    if (dataVal) {
                        obj.dataVal = dataVal;
                        obj.start = isStartNum;
                    }
                }
                else if (type === obj.type && (!obj.dataVal || minusOperator(obj.dataVal) === minusOperator(dataVal))) {
                    obj.val.push(val);
                }
                else {
                    patrn.push(obj);
                    obj = { val: [val], type: type };
                    if (dataVal) {
                        obj.dataVal = dataVal;
                        obj.start = isStartNum;
                    }
                }
                i++;
            }
            patrn.push(obj);
            return patrn;
        }
        else {
            return [{ val: null, type: null }];
        }
    }
    getPredictionValue(args, isTime) {
        let i = 0;
        let sumx = 0;
        let sumy = 0;
        let sumxy = 0;
        let sumxx = 0;
        let a = 0;
        let b = 0;
        const n = args.length;
        while (i < n) {
            sumx = sumx + i;
            sumy = sumy + Number(args[i]);
            sumxy = sumxy + (i * Number(args[i]));
            sumxx = sumxx + (i * i);
            i++;
        }
        if (!isTime) {
            a = this.round(((sumy * sumxx) - (sumx * sumxy)) / ((n * sumxx) - (sumx * sumx)), 5);
            b = this.round(((n * sumxy) - (sumx * sumy)) / ((n * sumxx) - (sumx * sumx)), 5);
        }
        else {
            a = ((sumy * sumxx) - (sumx * sumxy)) / ((n * sumxx) - (sumx * sumx));
            b = ((n * sumxy) - (sumx * sumy)) / ((n * sumxx) - (sumx * sumx));
        }
        return { a: a, b: b };
    }
    getPattern(range, options, sheetIdx) {
        let j;
        let idx;
        let temp;
        let regVal;
        let diff;
        let len;
        let i = 0;
        const pattern = [];
        const patrns = this.getDataPattern(range, sheetIdx);
        const plen = patrns.length;
        let patrn;
        if (patrns) {
            while (i < plen) {
                patrn = patrns[i];
                switch (patrn.type) {
                    case 'number':
                    case 'date':
                        idx = pattern.length;
                        len = patrn.val.length;
                        diff = options.isReverseFill ? -1 : len;
                        if (len === 1) {
                            const newVal = parseFloat(patrn.val[0]) + 1;
                            if (typeof (patrn.val[0]) === 'string' && patrn.val[0].match(/^0+/)) {
                                patrn.val.push(this.getNextFormattedValue(patrn.val[0], newVal));
                            }
                            else {
                                patrn.val.push(newVal);
                            }
                        }
                        regVal = this.getPredictionValue(patrn.dataVal ? patrn.val.slice(0, 2) : patrn.val);
                        temp = { regVal: regVal, type: patrn.type, i: diff, isStartWithMonth: patrn.isStartWithMonth };
                        if (patrn.dataVal) {
                            temp.dataVal = patrn.dataVal;
                            temp.val = patrn.val;
                            temp.start = patrn.start;
                        }
                        pattern.push(temp);
                        j = 1;
                        while (j < len) {
                            pattern.push(idx);
                            j++;
                        }
                        break;
                    case 'string':
                        idx = pattern.length;
                        temp = { val: patrn.val, type: patrn.type, i: 0 };
                        pattern.push(temp);
                        j = 1;
                        len = patrn.val.length;
                        while (j < len) {
                            pattern.push(idx);
                            j++;
                        }
                        break;
                    case 'formula':
                        len = patrn.val.length;
                        patrn = this.getFormulaPattern(patrn.val, options);
                        diff = options.isReverseFill ? -1 : len;
                        if (patrn.isInPattern) {
                            idx = pattern.length;
                            temp = { val: patrn.val, type: 'formula', i: diff };
                            pattern.push(temp);
                            j = 1;
                            while (j < len) {
                                pattern.push(idx);
                                j++;
                            }
                        }
                        else {
                            j = 0;
                            diff = options.isReverseFill ? -1 : 1;
                            while (j < len) {
                                pattern.push({ val: patrn.val[j], type: 'formula', i: diff });
                                j++;
                            }
                        }
                        break;
                    case 'time':
                        idx = pattern.length;
                        len = patrn.val.length;
                        diff = options.isReverseFill ? -1 : len;
                        if (len === 1) {
                            const oldTimeVal = intToDate(patrn.val[0]);
                            const patrnVal = Number(patrn.val[0]);
                            const isTimeOnly = patrnVal >= 0 && patrnVal < 1;
                            const newTimeVal = dateToInt(new Date(oldTimeVal.getTime() + 60 * 60000), true, isTimeOnly);
                            patrn.val.push(newTimeVal);
                        }
                        regVal = this.getPredictionValue(patrn.val, true);
                        temp = { regVal: regVal, type: patrn.type, i: diff };
                        pattern.push(temp);
                        j = 1;
                        while (j < len) {
                            pattern.push(idx);
                            j++;
                        }
                        break;
                }
                i++;
            }
            return pattern;
        }
        else {
            return [{ regVal: null }];
        }
    }
    getNextFormattedValue(value, numValue) {
        const val = new Internationalization().formatNumber(Math.abs(numValue), { minimumIntegerDigits: value.length, useGrouping: false });
        const numeArgs = checkIsNumberAndGetNumber({ value: val }, this.parent.locale);
        return numeArgs.isNumber ? numeArgs.value : val;
    }
    isCellReference(text) {
        return /^[a-z]{1,3}\d{1,7}$/gi.test(text) ? 'relative' : (/^\$[a-z]{1,3}\$\d{1,7}$/gi.test(text) ? 'absolute' : (/^((\$[a-z]{1,3})\d{1,7}|[a-z]{1,3}(\$\d{1,7}))$/gi.test(text) ? 'mixed' : false));
    }
    round(value, round) {
        return Number(Math.round(parseFloat(value + 'e' + round)) + 'e-' + round) || Number(value);
    }
    getRangeData(options, isVFill) {
        const arr = [];
        const sheet = isUndefined$1(options.sheetIdx) ? this.parent.getActiveSheet() : getSheet(this.parent, options.sheetIdx);
        let minR = options.range[0];
        let minC = options.range[1];
        const maxR = options.range[2];
        const maxC = options.range[3];
        const minCol = minC;
        let cell;
        let column;
        while (minR <= maxR) {
            if (isHiddenRow(sheet, minR)) {
                minR++;
                continue;
            }
            minC = minCol;
            while (minC <= maxC) {
                if (isHiddenCol(sheet, minC)) {
                    minC++;
                    continue;
                }
                cell = getCell(minR, minC, sheet);
                if (isVFill) {
                    cell = Object.assign({}, getCell(minR, minC, sheet));
                    column = Object.assign({}, getColumn(sheet, minC));
                    if (cell && !cell.validation) {
                        if (column && column.validation) {
                            cell.validation = Object.assign({}, getColumn(sheet, minC).validation);
                            const currIdx = [minR, minC, minR, minC];
                            const prevIdx = [0, minC, 0, minC];
                            let updateVal = getUpdatedFormula(currIdx, prevIdx, sheet, this.parent, { formula: column.validation.value1 });
                            cell.validation.value1 = updateVal;
                            if (cell.validation.value2 !== '') {
                                updateVal = getUpdatedFormula(currIdx, prevIdx, sheet, this.parent, { formula: column.validation.value2 });
                                cell.validation.value2 = updateVal;
                            }
                        }
                    }
                }
                arr.push(cell);
                minC++;
            }
            minR++;
        }
        return arr;
    }
    getFormulaPattern(data, options) {
        let j;
        let temp;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let patrn;
        const patrns = [];
        let i = 0;
        const len = data.length;
        let cRfrType;
        const eventArgs = {};
        while (i < len) {
            eventArgs.formula = data[i];
            this.parent.notify(parseFormulaArgument, eventArgs);
            patrns.push(eventArgs.formulaArr);
            i++;
        }
        const isInPatrn = this.isInPattern(patrns, options.isVFill);
        if (isInPatrn) {
            patrn = patrns[0];
            i = patrn.length;
            while (i--) {
                temp = patrn[i];
                cRfrType = this.isCellReference(temp);
                if (cRfrType && (cRfrType !== 'absolute')) {
                    patrn[i] = this.getCellRefPrediction(temp, options, null, cRfrType);
                }
            }
            return { isInPattern: isInPatrn, val: patrn };
        }
        else {
            i = 0;
            while (i < len) {
                patrn = patrns[i];
                j = patrn.length;
                while (j--) {
                    temp = patrn[j];
                    cRfrType = this.isCellReference(temp.trim());
                    if (cRfrType && (cRfrType !== 'absolute')) {
                        patrns[i][j] = this.getCellRefPrediction(temp, options, len, cRfrType);
                    }
                }
                i++;
            }
            return { isInPattern: isInPatrn, val: patrns };
        }
    }
    generateColCount(text) {
        let colCount = 0;
        for (let i = 0; i < text.length; i++) {
            const charValue = text.charCodeAt(i) - 64;
            colCount = colCount * 26 + charValue;
        }
        return colCount;
    }
    getCellRefPrediction(text, options, length, rfrType) {
        text = text.toUpperCase();
        const eStr = '';
        const aRegx = new RegExp('[a-z$]', 'gi');
        const nRegx = new RegExp('[0-9$]', 'g');
        let str = options.isVFill ? text.replace(nRegx, eStr) : text.replace(aRegx, eStr);
        let temp = options.isVFill ? Number(text.replace(aRegx, eStr)) :
            this.generateColCount(text.replace(nRegx, eStr).trim());
        let dollarPosition = null;
        const arr = [temp];
        let isColAbslt = text[0] === '$';
        if (!isColAbslt && text.includes('$') && text.trim()[0] === '$') {
            for (let idx = 1; idx < text.length; idx++) {
                if (text[idx] === '$') {
                    dollarPosition = idx;
                    isColAbslt = true;
                    break;
                }
            }
        }
        if (length && length !== 1) {
            arr.push(temp + length);
        }
        else {
            arr.push(temp + 1);
        }
        temp = this.getPredictionValue(arr);
        if (rfrType && (rfrType === 'mixed')) {
            if (isColAbslt === options.isVFill) {
                if (dollarPosition) {
                    str = str.substring(0, dollarPosition) + '$' + str.substring(dollarPosition);
                }
                else {
                    str = '$' + str;
                }
            }
            else {
                temp['b'] = 0;
            }
        }
        temp['c'] = str;
        return temp;
    }
    isInPattern(patrn, isVFill) {
        let oldPatrn;
        let olen;
        let newPatrn;
        let nlen;
        let oldStr;
        let newStr;
        let oldInt;
        let newInt;
        const eStr = '';
        let i = 0;
        let j = 1;
        const plen = patrn.length;
        const nregx = new RegExp('[0-9$]', 'g');
        const aregx = new RegExp('[a-z$]', 'gi');
        if (plen === 1) {
            return false;
        }
        while (j < plen) {
            oldPatrn = patrn[i];
            newPatrn = patrn[j];
            olen = oldPatrn.length;
            nlen = newPatrn.length;
            if (olen !== nlen) {
                return false;
            }
            else {
                while (olen--) {
                    oldStr = oldPatrn[olen];
                    newStr = newPatrn[olen];
                    if (this.isCellReference(oldStr) === this.isCellReference(newStr)) {
                        if (isVFill) {
                            oldInt = Number(oldStr.replace(aregx, eStr));
                            newInt = Number(newStr.replace(aregx, eStr));
                        }
                        else {
                            oldInt = this.generateColCount(oldStr.replace(nregx, eStr));
                            newInt = this.generateColCount(newStr.replace(nregx, eStr));
                        }
                        if (oldInt !== newInt - 1) {
                            return false;
                        }
                    }
                    else if (oldStr !== newStr) {
                        return false;
                    }
                }
            }
            i++;
            j++;
        }
        return true;
    }
    ensurePattern(patterns) {
        let patrn;
        let idx = -1;
        let i = patterns.length;
        while (i--) {
            patrn = patterns[i];
            if (typeof (patrn) === 'object') {
                idx = i;
                if (patrn.type === 'string') {
                    patrn.val = patrn.val.reverse();
                }
            }
            else {
                patterns[i] = idx;
            }
        }
        return patterns;
    }
    getSelectedRange(sheet, startcell, endcell) {
        let i;
        let k;
        let l;
        const arr = [];
        const range = getSwapRange([startcell.rowIndex, startcell.colIndex, endcell.rowIndex, endcell.colIndex]);
        i = range[0];
        const j = range[2];
        while (i <= j) {
            if (isFilterHidden(sheet, i)) {
                i++;
                continue;
            }
            k = range[1];
            l = range[3];
            while (k <= l) {
                arr.push({ rowIndex: i, colIndex: k });
                k++;
            }
            i++;
        }
        return arr;
    }
    getFillType(args) {
        args.fillType = this.fillInfo.fillType;
        args.disableItems = this.fillInfo.disableItems;
        return args;
    }
    addEventListener() {
        this.parent.on(setAutoFill, this.autoFill, this);
        this.parent.on(getFillInfo, this.getFillType, this);
    }
    /**
     * Destroy workbook AutoFill module.
     *
     * @returns {void} - destroy the workbook AutoFill module.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(setAutoFill, this.autoFill);
            this.parent.off(getFillInfo, this.getFillType);
        }
    }
    /**
     * Get the workbook AutoFill module name.
     *
     * @returns {string} - Return the string.
     */
    getModuleName() {
        return 'workbookautofill';
    }
}

/**
 * ServiceLocator
 *
 * @hidden
 */
class ServiceLocator {
    constructor() {
        this.services = {};
    }
    getService(name) {
        if (isNullOrUndefined(this.services[`${name}`])) {
            // eslint-disable-next-line no-throw-literal
            throw `The service ${name} is not registered`;
        }
        return this.services[`${name}`];
    }
    register(name, type) {
        if (isNullOrUndefined(this.services[`${name}`])) {
            this.services[`${name}`] = type;
        }
    }
}

var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Workbook_1;
/**
 * Represents the Workbook.
 */
let Workbook = Workbook_1 = class Workbook extends Component {
    /**
     * Constructor for initializing the library.
     *
     * @param {WorkbookModel} options - Configures Workbook model.
     */
    constructor(options) {
        super(options);
        /** @hidden */
        this.isEdit = false;
        /**
         * To generate sheet name based on sheet count.
         *
         * @hidden
         */
        this.sheetNameCount = 1;
        /**
         * @hidden
         */
        this.dataValidationRange = '';
        /**
         * @hidden
         */
        this.isOpen = false;
        /**
         * @hidden
         */
        this.chartColl = [];
        /**
         * @hidden
         */
        this.isPrintingProcessing = false;
        /**
         * @hidden
         */
        this.currentPrintSheetIndex = 0;
        /** @hidden */
        this.customFormulaCollection = new Map();
        Workbook_1.Inject(DataBind, WorkbookSave, WorkbookOpen, WorkbookNumberFormat, WorkbookCellFormat, WorkbookEdit, WorkbookFormula, WorkbookSort, WorkbookHyperlink, WorkbookFilter, WorkbookInsert, WorkbookFindAndReplace, WorkbookDataValidation, WorkbookProtectSheet, WorkbookMerge, WorkbookConditionalFormat, WorkbookImage, WorkbookChart, WorkbookAutoFill);
        this.commonCellStyle = {};
        if (options && options.cellStyle) {
            this.commonCellStyle = options.cellStyle;
        }
        if (this.getModuleName() === 'workbook') {
            this.serviceLocator = new ServiceLocator;
            this.initWorkbookServices();
            this.dataBind();
            this.initEmptySheet();
        }
    }
    /**
     * For internal use only.
     *
     * @returns {void} - For internal use only.
     * @hidden
     */
    preRender() {
        if (!Object.keys(this.commonCellStyle).length) {
            this.commonCellStyle = skipDefaultValue(this.cellStyle, true);
        }
        if (this.getModuleName() === 'spreadsheet' && !this.refreshing) {
            this.initEmptySheet();
        }
    }
    initWorkbookServices() {
        this.serviceLocator.register(workbookLocale, new L10n(this.getModuleName(), localeData, this.locale));
    }
    /**
     * For internal use only.
     *
     * @returns {void} - For internal use only.
     * @hidden
     */
    render() {
        /** code snippets */
    }
    /**
     * To provide the array of modules needed for workbook.
     *
     * @returns {ModuleDeclaration[]} - To provide the array of modules needed for workbook.
     * @hidden
     */
    requiredModules() {
        return getWorkbookRequiredModules(this);
    }
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @returns {string} - Get the properties to be maintained in the persisted state.
     * @hidden
     */
    getPersistData() {
        return this.addOnPersist([]);
    }
    /**
     * Applies the style (font family, font weight, background color, etc...) to the specified range of cells.
     *
     * {% codeBlock src='spreadsheet/cellFormat/index.md' %}{% endcodeBlock %}
     *
     * @param {CellStyleModel} style - Specifies the cell style.
     * @param {string} range - Specifies the address for the range of cells.
     * @returns {void} - Applies the style (font family, font weight, background color, etc...) to the specified range of cells.
     */
    cellFormat(style, range) {
        const sheet = this.getActiveSheet();
        if (sheet && (!sheet.isProtected || sheet.protectSettings.formatCells)) {
            range = range || sheet.selectedRange;
            this.notify(setCellFormat, { style: style, range: range, refreshRibbon: range.indexOf(sheet.activeCell) > -1 ? true : false });
        }
    }
    /**
     * Applies cell lock to the specified range of cells.
     *
     * {% codeBlock src='spreadsheet/lockCells/index.md' %}{% endcodeBlock %}
     *
     * @param {string} range - Specifies the address for the range of cells.
     * @param {boolean} isLocked -Specifies the cell is locked or not.
     * @returns {void} - To Applies cell lock to the specified range of cells.
     */
    lockCells(range, isLocked) {
        const sheet = this.getActiveSheet();
        range = range || sheet.selectedRange;
        this.notify(setLockCells, { range: range, isLocked: isLocked, triggerEvent: true });
    }
    /**
     * @hidden
     * @param {Workbook} cssProps - Specifies the cssProps.
     * @param {number[]} indexes - Specifies the indexes.
     * @returns {CellStyleModel} - To get Cell Style Value.
     */
    getCellStyleValue(cssProps, indexes) {
        const cell = getCell(indexes[0], indexes[1], this.getActiveSheet());
        const style = {};
        cssProps.forEach((cssProp) => {
            style[`${cssProp}`] = this.cellStyle[`${cssProp}`];
            if (cell && cell.style && cell.style[`${cssProp}`]) {
                style[`${cssProp}`] = cell.style[`${cssProp}`];
            }
        });
        return style;
    }
    /**
     * Applies the number format (number, currency, percentage, short date, etc...) to the specified range of cells.
     *
     * {% codeBlock src='spreadsheet/numberFormat/index.md' %}{% endcodeBlock %}
     *
     * @param {string} format - Specifies the number format code.
     * @param {string} range - Specifies the address of the range of cells.
     * @returns {void} - Applies the number format (number, currency, percentage, short date, etc...) to the specified range of cells.
     */
    numberFormat(format, range) {
        this.notify(applyNumberFormatting, { format: format, range: range });
        this.notify(localizedFormatAction, { action: 'addToCustomFormats', format: format });
    }
    /**
     * Used to create new sheet.
     *
     * @hidden
     * @param {number} index - Specifies the index.
     * @param {SheetModel[]} sheets - Specifies the sheets.
     * @returns {void} - To create new sheet.
     */
    createSheet(index = this.sheets.length, sheets = [{}]) {
        this.sheets.splice(index, 0, ...sheets);
        initSheet(this, sheets);
        this.notify(sheetCreated, { sheetIndex: index || 0, sheets: sheets });
        this.notify(workbookFormulaOperation, {
            action: 'registerSheet', sheetIndex: index || 0, sheetCount: index + sheets.length
        });
    }
    /**
     * Used to remove sheet.
     *
     * @hidden
     * @param  {number} idx - Specifies the index.
     * @returns {void} - To remove sheet
     */
    removeSheet(idx) {
        this.sheets.splice(idx, 1);
    }
    /**
     * Destroys the Workbook library.
     *
     * @returns {void} - To destroy sheet
     */
    destroy() {
        this.notify(workbookDestroyed, null);
        super.destroy();
    }
    /**
     * Called internally if any of the property value changed.
     *
     * @param {WorkbookModel} newProp - To set the properties
     * @param {WorkbookModel} oldProp - To get the properties
     * @returns {void} - property value changed
     * @hidden
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onPropertyChanged(newProp, oldProp) {
        for (const prop of Object.keys(newProp)) {
            switch (prop) {
                case 'cellStyle':
                    merge(this.commonCellStyle, newProp.cellStyle);
                    break;
                case 'sheets':
                    if (newProp.sheets === this.sheets) {
                        this.notify(workbookFormulaOperation, { action: 'unRegisterSheet', propertyChange: true });
                        this.sheetNameCount = 1;
                        this.notify(sheetsDestroyed, {});
                        initSheet(this);
                        this.notify(sheetCreated, null);
                        this.notify(workbookFormulaOperation, { action: 'registerSheet' });
                    }
                    else {
                        initSheet(this);
                    }
                    break;
                case 'listSeparator':
                    this.notify(workbookFormulaOperation, { action: 'setArgumentSeparator' });
                    break;
            }
        }
    }
    /**
     * Not applicable for workbook.
     *
     * @hidden
     * @param {string | HTMLElement} selector - Specifies the selector.
     * @returns {void} - To append the element.
     */
    appendTo(selector) {
        super.appendTo(selector);
    }
    /**
     * Used to hide/show the rows in spreadsheet.
     *
     * @param {number} startIndex - Specifies the start row index.
     * @param {number} endIndex - Specifies the end row index.
     * @param {boolean} hide - To hide/show the rows in specified range.
     * @returns {void} - To hide/show the rows in spreadsheet.
     */
    hideRow(startIndex, endIndex = startIndex, hide = true) {
        const sheet = this.getActiveSheet();
        for (let i = startIndex; i <= endIndex; i++) {
            setRow(sheet, i, { hidden: hide });
        }
    }
    /**
     * Used to hide/show the columns in spreadsheet.
     *
     * @param {number} startIndex - Specifies the start column index.
     * @param {number} endIndex - Specifies the end column index.
     * @param {boolean} hide - Set `true` / `false` to hide / show the columns.
     * @returns {void} - To hide/show the columns in spreadsheet.
     */
    hideColumn(startIndex, endIndex = startIndex, hide = true) {
        const sheet = this.getActiveSheet();
        for (let i = startIndex; i <= endIndex; i++) {
            setColumn(sheet, i, { hidden: hide });
        }
    }
    /**
     * Sets the border to specified range of cells.
     *
     * {% codeBlock src='spreadsheet/setBorder/index.md' %}{% endcodeBlock %}
     *
     * @param {CellStyleModel} style - Specifies the style property which contains border value.
     * @param {string} range - Specifies the range of cell reference. If not specified, it will considered the active cell reference.
     * @param {BorderType} type - Specifies the range of cell reference. If not specified, it will considered the active cell reference.
     * @param {boolean} isUndoRedo - Specifies is undo redo or not.
     * @returns {void} - To Sets the border to specified range of cells.
     */
    setBorder(style, range, type, isUndoRedo) {
        this.notify(setCellFormat, {
            style: style, borderType: type, range: range || this.getActiveSheet().selectedRange, isUndoRedo: isUndoRedo
        });
    }
    /**
     * Used to insert rows in to the spreadsheet.
     *
     * {% codeBlock src='spreadsheet/insertRow/index.md' %}{% endcodeBlock %}
     *
     * @param {number | RowModel[]} startRow - Specifies the start row index / row model which needs to be inserted.
     * @param {number} endRow - Specifies the end row index.
     * @param {number | string} sheet - Specifies the sheet name or index in which the insert operation will perform. By default,
     * active sheet will be considered.
     * @returns {void} - To insert rows in to the spreadsheet.
     */
    insertRow(startRow, endRow, sheet) {
        this.notify(insertModel, { model: this.getSheetModel(sheet), start: startRow, end: endRow,
            modelType: 'Row', insertType: 'below' });
    }
    /**
     * Used to insert columns in to the spreadsheet.
     *
     * {% codeBlock src='spreadsheet/insertColumn/index.md' %}{% endcodeBlock %}
     *
     * @param {number | ColumnModel[]} startColumn - Specifies the start column index / column model which needs to be inserted.
     * @param {number} endColumn - Specifies the end column index.
     * @param {number | string} sheet - Specifies the sheet name or index in which the insert operation will perform. By default,
     * active sheet will be considered.
     * @returns {void} - To insert columns in to the spreadsheet.
     */
    insertColumn(startColumn, endColumn, sheet) {
        this.notify(insertModel, { model: this.getSheetModel(sheet), start: startColumn, end: endColumn,
            modelType: 'Column', insertType: 'after' });
    }
    /**
     * Used to insert sheets in to the spreadsheet.
     *
     * {% codeBlock src='spreadsheet/insertSheet/index.md' %}{% endcodeBlock %}
     *
     * @param {number | SheetModel[]} startSheet - Specifies the start sheet index / sheet model which needs to be inserted.
     * @param {number} endSheet - Specifies the end sheet index.
     * @returns {void} - To insert sheets in to the spreadsheet.
     */
    insertSheet(startSheet, endSheet) {
        if (this.isProtected) {
            return;
        }
        this.notify(insertModel, { model: this, start: startSheet, end: endSheet, modelType: 'Sheet' });
    }
    /**
     * Used to delete rows, columns and sheets from the spreadsheet.
     *
     * {% codeBlock src='spreadsheet/delete/index.md' %}{% endcodeBlock %}
     *
     * @param {number} startIndex - Specifies the start sheet / row / column index.
     * @param {number} endIndex - Specifies the end sheet / row / column index.
     * @param {ModelType} model - Specifies the delete model type. By default, the model is considered as `Sheet`. The possible values are,
     * - Row: To delete rows.
     * - Column: To delete columns.
     * - Sheet: To delete sheets.
     * @param {number | string} sheet - Specifies the sheet name or index in which the delete operation will perform. By default,
     * active sheet will be considered. It is applicable only for model type Row and Column.
     * @returns {void} - To delete rows, columns and sheets from the spreadsheet.
     */
    delete(startIndex, endIndex, model, sheet) {
        if (this.isProtected) {
            return;
        }
        startIndex = startIndex || 0;
        let sheetModel;
        endIndex = isNullOrUndefined(endIndex) ? startIndex : endIndex;
        if (!model || model === 'Sheet') {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            sheetModel = this;
            if (Math.abs(endIndex - startIndex) >= this.sheets.length) {
                return;
            }
        }
        else {
            sheetModel = this.getSheetModel(sheet);
            if (!sheetModel) {
                return;
            }
        }
        this.notify(deleteModel, {
            model: sheetModel, start: startIndex, end: endIndex, modelType: model || 'Sheet'
        });
    }
    /**
     * Used to move the sheets to the specified position in the list of sheets.
     *
     * {% codeBlock src='spreadsheet/moveSheet/index.md' %}{% endcodeBlock %}
     *
     * @param {number} position - Specifies the position to move a sheet in the list of sheets.
     * @param {number[]} sheetIndexes - Specifies the indexes of the sheet to be moved. By default, the active sheet will be moved.
     * @returns {void} - Used to move the sheets to the specified position in the list of sheets.
     */
    moveSheet(position, sheetIndexes) {
        if (this.isProtected) {
            return;
        }
        moveSheet(this, position, sheetIndexes);
    }
    /**
     * Used to make a duplicate/copy of the sheet in the spreadsheet.
     *
     * {% codeBlock src='spreadsheet/duplicateSheet/index.md' %}{% endcodeBlock %}
     *
     * @param {number} sheetIndex - Specifies the index of the sheet to be duplicated. By default, the active sheet will be duplicated.
     * @returns {void} - Used to make a duplicate/copy of the sheet in the spreadsheet.
     */
    duplicateSheet(sheetIndex) {
        if (this.isProtected) {
            return;
        }
        duplicateSheet(this, sheetIndex);
    }
    getSheetModel(sheet) {
        if (isNullOrUndefined(sheet)) {
            return this.getActiveSheet();
        }
        else {
            const index = typeof sheet === 'string' ? getSheetIndex(this, sheet) : sheet;
            if (isNullOrUndefined(index) || index >= this.sheets.length) {
                return null;
            }
            return this.sheets[index];
        }
    }
    /**
     * Used to merge the range of cells.
     *
     * {% codeBlock src='spreadsheet/merge/index.md' %}{% endcodeBlock %}
     *
     * @param {string} range - Specifies the range of cells as address.
     * @param {MergeType} type - Specifies the merge type. The possible values are,
     * - All: Merge all the cells between provided range.
     * - Horizontally: Merge the cells row-wise.
     * - Vertically: Merge the cells column-wise.
     * @returns {void} - To merge the range of cells.
     */
    merge(range, type) {
        let sheetIdx;
        let sheet;
        if (range) {
            sheetIdx = this.isPrintingProcessing ? this.currentPrintSheetIndex : getSheetIndexFromAddress(this, range);
            sheet = getSheet(this, sheetIdx);
        }
        else {
            sheet = this.getActiveSheet();
            range = sheet.selectedRange;
            sheetIdx = this.activeSheetIndex;
        }
        this.notify(setMerge, { merge: true, range: range, type: type || 'All', sheetIndex: sheetIdx, refreshRibbon: range.indexOf(sheet.activeCell) > -1 ? true : false, preventRefresh: this.activeSheetIndex !== sheetIdx });
    }
    /**
     * Used to split the merged cell into multiple cells.
     *
     * {% codeBlock src='spreadsheet/unMerge/index.md' %}{% endcodeBlock %}
     *
     * @param {string} range - Specifies the range of cells as address.
     * @returns {void} - To split the merged cell into multiple cells.
     */
    unMerge(range) {
        let sheetIdx;
        let sheet;
        if (range) {
            sheetIdx = getSheetIndexFromAddress(this, range);
            sheet = getSheet(this, sheetIdx);
        }
        else {
            sheet = this.getActiveSheet();
            range = sheet.selectedRange;
            sheetIdx = this.activeSheetIndex;
        }
        this.notify(setMerge, {
            merge: false, range: range, sheetIndex: sheetIdx, type: 'All',
            refreshRibbon: range.indexOf(sheet.activeCell) > -1 ? true : false, preventRefresh: this.activeSheetIndex !== sheetIdx
        });
    }
    /** Used to compute the specified expression/formula.
     *
     * {% codeBlock src='spreadsheet/computeExpression/index.md' %}{% endcodeBlock %}
     *
     * @param {string} formula - Specifies the formula(=SUM(A1:A3)) or expression(2+3).
     * @returns {string | number} - to compute the specified expression/formula.
     */
    computeExpression(formula) {
        const args = {
            action: 'computeExpression', formula: formula, isFromComputeExpression: true
        };
        this.notify(workbookFormulaOperation, args);
        return args.calcValue;
    }
    initEmptySheet() {
        if (!this.sheets.length) {
            this.createSheet();
        }
        else {
            initSheet(this);
        }
    }
    /**
     * @hidden
     * @returns {SheetModel} - To get Active Sheet.
     */
    getActiveSheet() {
        return this.sheets[this.activeSheetIndex];
    }
    /** @hidden
     * @param {number} index - Specifies the index.
     * @param {number} initIdx - Specifies the initIdx.
     * @param {number} hiddenCount - Specifies the initIdx.
     * @returns {number} - To skip Hidden Sheets.
     */
    skipHiddenSheets(index, initIdx, hiddenCount = 0) {
        if (this.sheets[index] && this.sheets[index].state !== 'Visible') {
            if (initIdx === undefined) {
                initIdx = index;
            }
            if (index && index + 1 === this.sheets.length) {
                index = initIdx - 1;
            }
            else {
                index = index < initIdx ? --index : ++index;
            }
            index = this.skipHiddenSheets(index, initIdx, ++hiddenCount);
        }
        if (hiddenCount === this.sheets.length) {
            this.setSheetPropertyOnMute(this.sheets[0], 'state', 'Visible');
            return 0;
        }
        return index;
    }
    /**
     * Used for setting the used range row and column index.
     *
     * @hidden
     * @param {number} rowIdx - Specifies the rowIndex.
     * @param {number} colIdx - Specifies the colIndex.
     * @param {SheetModel} sheet - Specifies the active sheet.
     * @param {boolean} preventRowColUpdate - To prevent updating row and column count.
     * @param {boolean} forceUpdate - To force updating row and column count.
     * @returns {void} - To setting the used range row and column index.
     */
    setUsedRange(rowIdx, colIdx, sheet = this.getActiveSheet(), preventRowColUpdate, forceUpdate) {
        if (forceUpdate) {
            this.setSheetPropertyOnMute(sheet, 'usedRange', { rowIndex: rowIdx, colIndex: colIdx });
            return;
        }
        if (rowIdx > sheet.usedRange.rowIndex) {
            this.setSheetPropertyOnMute(sheet, 'usedRange', { rowIndex: rowIdx, colIndex: sheet.usedRange.colIndex });
            if (sheet === this.getActiveSheet() && !preventRowColUpdate) {
                this.notify(updateRowColCount, { index: rowIdx, update: 'row' });
            }
        }
        if (colIdx > sheet.usedRange.colIndex) {
            this.setSheetPropertyOnMute(sheet, 'usedRange', { rowIndex: sheet.usedRange.rowIndex, colIndex: colIdx });
            if (sheet === this.getActiveSheet() && !preventRowColUpdate) {
                this.notify(updateRowColCount, { index: colIdx, update: 'col' });
            }
        }
    }
    /**
     * Gets the range of data as JSON from the specified address.
     *
     * {% codeBlock src='spreadsheet/getData/index.md' %}{% endcodeBlock %}
     *
     * @param {string} address - Specifies the address for range of cells.
     * @returns {Promise<Map<string, CellModel>>} - Gets the range of data as JSON from the specified address.
     */
    getData(address) {
        return getData(this, address);
    }
    /**
     * Get component name.
     *
     * @returns {string} - Gets the module name.
     * @hidden
     */
    getModuleName() {
        return 'workbook';
    }
    /** @hidden
     * @param {string} address - Specifies the sheet id.
     * @returns {void} - To set the value for row and col.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    goTo(address) {
        /** */
    }
    /** @hidden
     * @param {number} sheetId - Specifies the sheet id.
     * @param {number} rowIndex - Specifies the rowIndex.
     * @param {number} colIndex - Specifies the colIndex.
     * @param {string} formulaCellReference - Specifies the formulaCellReference.
     * @param {boolean} refresh - Specifies the refresh.
     * @param {boolean} isUnique - Specifies is unique formula or not.
     * @param {boolean} isSubtotal - Specifies is from Subtotal formula or not.
     * @returns {string | number} - To set the value for row and col.
     */
    getValueRowCol(sheetId, rowIndex, colIndex, formulaCellReference, refresh, isUnique, isSubtotal) {
        let sheetIndex = getSheetIndexFromId(this, sheetId);
        const sheet = getSheet(this, sheetIndex);
        let cell = getCell(rowIndex - 1, colIndex - 1, sheet);
        if (formulaCellReference && formulaCellReference.includes('!') && !cell && sheet.ranges && sheet.ranges.length) {
            let isNotLoaded;
            if (this.formulaRefCell && this.formulaRefCell === formulaCellReference) {
                return cell && cell.value;
            }
            sheet.ranges.forEach((range) => {
                if (!range.info || !range.info.loadedRange || !range.info.loadedRange.length) {
                    isNotLoaded = true;
                    return;
                }
            });
            if (isNotLoaded) {
                this.formulaRefCell = formulaCellReference;
                sheetIndex = getSheetIndexFromId(this, Number(formulaCellReference.substring(formulaCellReference.lastIndexOf(',') + 1, formulaCellReference.length)));
                if (isNullOrUndefined(sheetIndex)) {
                    return cell && cell.value;
                }
                formulaCellReference = formulaCellReference.substring(formulaCellReference.lastIndexOf('!') + 1, formulaCellReference.lastIndexOf(','));
                getData(this, `${sheet.name}!A1:${getCellAddress(rowIndex - 1, colIndex - 1)}`, null, null, null, null, formulaCellReference, sheetIndex);
            }
        }
        else if (cell && cell.formula && (refresh || isNullOrUndefined(cell.value)) &&
            !isUnique && this.calculationMode === 'Automatic') {
            this.notify(calculateFormula, {
                cell: cell, rowIdx: rowIndex - 1, colIdx: colIndex - 1, sheetIndex: sheetIndex,
                formulaRefresh: true
            });
        }
        if (cell && !isNumber(cell.value) && !this.isEdit) {
            const eventArgs = { formattedText: cell.value, value: cell.value, format: cell.format, cell: cell,
                skipFormatCheck: false };
            this.notify(getFormattedCellObject, eventArgs);
            cell = eventArgs.cell;
        }
        if (isSubtotal && cell && cell.formula && cell.formula.includes('SUBTOTAL(')) {
            return cell.formula; // To ignore subtotal result in the subtotal formula.
        }
        return cell && cell.value;
    }
    /** @hidden
     * @param {number} sheetId - Specifies the sheet id.
     * @param {string | number} value - Specifies the value.
     * @param {number} rowIndex - Specifies the rowIndex.
     * @param {number} colIndex - Specifies the colIndex.
     * @param {string} formula - Specifies the colIndex.
     * @param {boolean} isRandomFormula - Specifies is random formula or not.
     * @returns {void} - To set the value for row and col.
     */
    setValueRowCol(sheetId, value, rowIndex, colIndex, formula, isRandomFormula) {
        this.notify(workbookEditOperation, {
            action: 'updateCellValue', address: [rowIndex - 1, colIndex - 1], value: value,
            sheetIndex: getSheetIndexFromId(this, sheetId), isValueOnly: true, formula: formula, isRandomFormula: isRandomFormula
        });
    }
    /**
     * Opens the specified excel file or stream.
     *
     * @param {OpenOptions} options - Options for opening the excel file.
     * @returns {void} - Opens the specified excel file or stream.
     */
    open(options) {
        this.notify(workbookOpen, options);
    }
    /**
     * Opens the specified JSON object.
     *
     * {% codeBlock src='spreadsheet/openFromJson/index.md' %}{% endcodeBlock %}
     *
     * The available arguments in options are:
     * * file: Specifies the spreadsheet model as object or string. And the object contains the jsonObject,
     * which is saved from spreadsheet using saveAsJson method.
     * * triggerEvent: Specifies whether to trigger the `openComplete` event or not.
     *
     * @param {Object} options - Options for opening the JSON object.
     * @param {string | object} options.file - Options for opening the JSON object.
     * @param {boolean} options.triggerEvent - Specifies whether to trigger the `openComplete` event or not.
     * @param {SerializationOptions} jsonConfig - Specify the serialization options to customize the loading of the JSON data.
     * @param {boolean} jsonConfig.onlyValues - If true, only the cell values will be loaded, excluding styles, formulas, etc.
     * @param {boolean} jsonConfig.ignoreStyle - If true, styles will be excluded when loading the JSON data.
     * @param {boolean} jsonConfig.ignoreFormula - If true, formulas will be excluded when loading the JSON data.
     * @param {boolean} jsonConfig.ignoreFormat - If true, number formats will be excluded when loading the JSON data.
     * @param {boolean} jsonConfig.ignoreConditionalFormat - If true, conditional formatting will be excluded when loading the JSON data.
     * @param {boolean} jsonConfig.ignoreValidation - If true, data validation rules will be excluded when loading the JSON data.
     * @param {boolean} jsonConfig.ignoreFreezePane - If true, freeze panes will be excluded when loading the JSON data.
     * @param {boolean} jsonConfig.ignoreWrap - If true, text wrapping settings will be excluded when loading the JSON data.
     * @param {boolean} jsonConfig.ignoreChart - If true, charts will be excluded when loading the JSON data.
     * @param {boolean} jsonConfig.ignoreImage - If true, images will be excluded when loading the JSON data.
     * @param {boolean} jsonConfig.ignoreNote -  If true, notes will be excluded when loading the JSON data.
     * @returns {void} - Opens the specified JSON object.
     */
    openFromJson(options, jsonConfig) {
        this.isOpen = true;
        let jsonObject = typeof options.file === 'object' ? JSON.stringify(options.file) : options.file;
        if (jsonObject !== '' && jsonConfig) {
            const skipProps = [];
            if (jsonConfig.onlyValues) {
                skipProps.push(...['style', 'formula', 'format', 'conditionalFormats', 'validation',
                    'hyperlink', 'wrap', 'chart', 'image', 'notes']);
            }
            else {
                const ignoreProps = {
                    style: jsonConfig.ignoreStyle,
                    formula: jsonConfig.ignoreFormula,
                    format: jsonConfig.ignoreFormat,
                    conditionalFormats: jsonConfig.ignoreConditionalFormat,
                    validation: jsonConfig.ignoreValidation,
                    wrap: jsonConfig.ignoreWrap,
                    chart: jsonConfig.ignoreChart,
                    image: jsonConfig.ignoreImage,
                    notes: jsonConfig.ignoreNote
                };
                if (jsonConfig.ignoreFreezePane) {
                    skipProps.push(...['frozenColumns', 'frozenRows']);
                }
                for (const prop in ignoreProps) {
                    if (ignoreProps[prop]) {
                        skipProps.push(prop);
                    }
                }
            }
            jsonObject = JSON.stringify(JSON.parse(jsonObject), (key, value) => {
                if (skipProps.indexOf(key) > -1) {
                    return undefined;
                }
                return value;
            });
        }
        this.notify(workbookOpen, { jsonObject: jsonObject, triggerEvent: options.triggerEvent });
    }
    /**
     * Saves the Spreadsheet data to Excel file.
     *
     * {% codeBlock src='spreadsheet/save/index.md' %}{% endcodeBlock %}
     *
     * The available arguments in saveOptions are:
     * * url: Specifies the save URL.
     * * fileName: Specifies the file name.
     * * saveType: Specifies the file type need to be saved.
     *
     * @param {SaveOptions} saveOptions - Options for saving the excel file.
     * @param {SerializationOptions} jsonConfig - Specify the serialization options to customize the JSON output.
     * @param {boolean} jsonConfig.onlyValues - If true, only the cell values will be included, excluding styles, formulas, etc.
     * @param {boolean} jsonConfig.ignoreStyle - If true, styles will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreFormula - If true, formulas will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreFormat - If true, number formats will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreConditionalFormat - If true, conditional formatting will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreValidation - If true, data validation rules will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreFreezePane - If true, freeze panes will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreWrap - If true, text wrapping settings will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreChart - If true, charts will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreImage - If true, images will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreNote -  If true, notes will be excluded from the JSON output.
     * @returns {void} - To Saves the Spreadsheet data to Excel file.
     */
    save(saveOptions = {}, jsonConfig) {
        if (this.allowSave) {
            const defaultProps = {
                url: this.saveUrl,
                fileName: saveOptions.fileName || 'Sample',
                saveType: 'Xlsx'
                //passWord: args.passWord
            };
            const eventArgs = Object.assign({}, defaultProps, saveOptions, { customParams: {}, isFullPost: true, needBlobData: false, cancel: false, autoDetectFormat: false, pdfLayoutSettings: { fitSheetOnOnePage: false, orientation: 'Portrait' } });
            this.trigger('beforeSave', eventArgs);
            this.notify(beginAction, { eventArgs: eventArgs, action: 'beforeSave' });
            if (!eventArgs.cancel) {
                this.notify(beginSave, {
                    saveSettings: eventArgs, isFullPost: eventArgs.isFullPost, needBlobData: eventArgs.needBlobData,
                    customParams: eventArgs.customParams, pdfLayoutSettings: eventArgs.pdfLayoutSettings,
                    jsonConfig: jsonConfig
                });
            }
        }
    }
    /**
     * Saves the Spreadsheet data as JSON object.
     *
     * {% codeBlock src='spreadsheet/saveAsJson/index.md' %}{% endcodeBlock %}
     *
     * @param {SerializationOptions} jsonConfig - Specify the serialization options to customize the JSON output.
     * @param {boolean} jsonConfig.onlyValues - If true, only the cell values will be included, excluding styles, formulas, etc.
     * @param {boolean} jsonConfig.ignoreStyle - If true, styles will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreFormula - If true, formulas will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreFormat - If true, number formats will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreConditionalFormat - If true, conditional formatting will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreValidation - If true, data validation rules will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreFreezePane - If true, freeze panes will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreWrap - If true, text wrapping settings will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreChart - If true, charts will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreImage - If true, images will be excluded from the JSON output.
     * @param {boolean} jsonConfig.ignoreNote -  If true, notes will be excluded from the JSON output.
     * @returns {Promise<object>} - To Saves the Spreadsheet data as JSON object.
     */
    saveAsJson(jsonConfig) {
        return new Promise((resolve) => {
            this.on(onSave, (args) => {
                args.cancel = true;
                this.off(onSave);
                resolve({ jsonObject: { Workbook: args.jsonObject } });
                this.notify(saveCompleted, args);
            });
            this.save({}, jsonConfig);
        });
    }
    addHyperlink(hyperlink, cellAddress) {
        const args = { hyperlink: hyperlink, cell: cellAddress };
        this.notify(setLinkModel, args);
    }
    /**
     * To find the specified cell value.
     *
     * @hidden
     * @param {FindOptions} args - options for find.
     * {% codeBlock src='spreadsheet/findHandler/index.md' %}{% endcodeBlock %}
     * @returns {void} - To find the specified cell value.
     */
    findHandler(args) {
        this.notify(find, args);
    }
    /**
     * @hidden
     * @param {FindOptions} args - Specifies the FindOptions.
     * @returns {void} - To replace the value.
     */
    replaceHandler(args) {
        if (args.replaceBy === 'replace') {
            this.notify(replace, args);
        }
        else {
            this.notify(replaceAll, args);
        }
    }
    /**
     * Protect the active sheet based on the protect sheetings.
     *
     * @param {number} sheet - Specifies the sheet to protect.
     * @param {ProtectSettingsModel} protectSettings - Specifies the protect settings of the sheet.
     * @param {string} password - Specifies the password to protect
     * @returns {void} - protect the active sheet.
     */
    protectSheet(sheet, protectSettings, password) {
        if (isNullOrUndefined(sheet)) {
            sheet = this.activeSheetIndex;
        }
        else if (typeof (sheet) === 'string') {
            sheet = getSheetIndex(this, sheet);
        }
        const sheetModel = this.sheets[sheet];
        if (!sheetModel) {
            return;
        }
        this.setSheetPropertyOnMute(sheetModel, 'isProtected', true);
        this.setSheetPropertyOnMute(sheetModel, 'password', password ? password : '');
        this.setSheetPropertyOnMute(sheetModel, 'protectSettings', protectSettings ? protectSettings : {});
        this.notify(protectsheetHandler, {
            protectSettings: sheetModel.protectSettings, password: sheetModel.password, sheetIndex: sheet
        });
    }
    /**
     * Unprotect the active sheet.
     *
     * @param {number} sheet - Specifies the sheet to Unprotect.
     * @returns {void} - Unprotect the active sheet.
     */
    unprotectSheet(sheet) {
        if (isNullOrUndefined(sheet)) {
            sheet = this.activeSheetIndex;
        }
        else if (typeof (sheet) === 'string') {
            sheet = getSheetIndex(this, sheet);
        }
        if (!this.sheets[sheet]) {
            return;
        }
        const args = { sheet: sheet };
        this.notify(unprotectsheetHandler, args);
    }
    /**
     * Sorts the range of cells in the active Spreadsheet.
     *
     * @param {SortOptions} sortOptions - options for sorting.
     * @param {string} range - address of the data range.
     * @param {SortCollectionModel[]} previousSort - specifies previous sort collection.
     * @returns {Promise<SortEventArgs>} - Sorts the range of cells in the active Spreadsheet.
     */
    sort(sortOptions, range, previousSort) {
        if (!this.allowSorting) {
            return Promise.reject();
        }
        const eventArgs = {
            range: range || this.getActiveSheet().selectedRange,
            sortOptions: sortOptions || { sortDescriptors: {} },
            cancel: false
        };
        const promise = new Promise((resolve) => { resolve((() => { })()); });
        const sortArgs = { args: eventArgs, promise: promise, previousSort: previousSort };
        this.notify(initiateSort, sortArgs);
        return sortArgs.promise;
    }
    addDataValidation(rules, range) {
        if (isNullOrUndefined(rules.value1)) {
            return;
        }
        if (rules.type === 'List') {
            if (rules.value1.length > 256) {
                rules.value1 = rules.value1.substring(0, 255);
            }
        }
        else {
            rules.value1 = parseLocaleNumber([rules.value1], this)[0];
            if (rules.value2) {
                rules.value2 = parseLocaleNumber([rules.value2], this)[0];
            }
        }
        this.notify(cellValidation, { rules: rules, range: range || getUpdatedRange(this.getActiveSheet()) });
    }
    removeDataValidation(range) {
        this.notify(cellValidation, {
            range: range || getUpdatedRange(this.getActiveSheet()),
            isRemoveValidation: true
        });
    }
    addInvalidHighlight(range) {
        this.notify(addHighlight, { range: range });
    }
    removeInvalidHighlight(range) {
        this.notify(removeHighlight, { range: range });
    }
    /**
     * To determine whether the cell value in a data validation applied cell is valid or not.
     *
     * @param {string} cellAddress - Address of the cell.
     * @returns {boolean} - It return true if the cell value is valid; otherwise, false.
     */
    isValidCell(cellAddress) {
        let sheet;
        let sheetIdx;
        let range;
        if (cellAddress) {
            const addressInfo = getAddressInfo(this, cellAddress);
            sheetIdx = addressInfo.sheetIndex;
            range = addressInfo.indices;
            sheet = getSheet(this, sheetIdx);
        }
        else {
            sheet = this.getActiveSheet();
            range = getCellIndexes(sheet.activeCell);
            sheetIdx = this.activeSheetIndex;
        }
        const cell = getCell(range[0], range[1], sheet, false, true);
        if (cell.validation || checkColumnValidation(sheet.columns[range[1]], range[0], range[1])) {
            const value = cell.value ? cell.value : '';
            const validEventArgs = { value, range, sheetIdx, td: null, isValid: true };
            this.notify(isValidation, validEventArgs);
            return validEventArgs.isValid;
        }
        else {
            return true;
        }
    }
    conditionalFormat(conditionalFormat) {
        if (conditionalFormat.range) {
            if (this.listSeparator !== ',' && conditionalFormat.range.includes(this.listSeparator)) {
                conditionalFormat.range = conditionalFormat.range.split(this.listSeparator).join(',');
            }
        }
        else {
            conditionalFormat.range = this.getActiveSheet().selectedRange;
        }
        if (conditionalFormat.value) {
            let cfValues;
            if (conditionalFormat.type === 'Between') {
                if (this.listSeparator !== ',' && conditionalFormat.value.includes(this.listSeparator)) {
                    const dateValues = conditionalFormat.value.split('"').filter((date) => date.trim() && date.trim() !== this.listSeparator);
                    cfValues = dateValues.length > 1 ? dateValues : conditionalFormat.value.split(this.listSeparator);
                }
                else {
                    const dateValues = conditionalFormat.value.split('"').filter((date) => date.trim() && date.trim() !== ',');
                    cfValues = dateValues.length > 1 ? dateValues : conditionalFormat.value.split(',');
                }
            }
            else {
                cfValues = [conditionalFormat.value];
            }
            parseLocaleNumber(cfValues, this);
            conditionalFormat.value = cfValues.join(',');
        }
        this.notify(setCFRule, { cfModel: conditionalFormat });
    }
    clearConditionalFormat(range) {
        const clearCFArgs = {};
        if (!range || !range.includes('!')) {
            clearCFArgs.range = range || this.getActiveSheet().selectedRange;
            clearCFArgs.sheetIdx = this.activeSheetIndex;
        }
        else {
            const lastIndex = range.lastIndexOf('!');
            clearCFArgs.range = range.substring(lastIndex + 1);
            clearCFArgs.sheetIdx = getSheetIndex(this, range.substring(0, lastIndex));
        }
        this.notify(clearCFRule, clearCFArgs);
    }
    /**
     * Updates the properties of a specified cell.
     *
     * {% codeBlock src='spreadsheet/updateCell/index.md' %}{% endcodeBlock %}
     *
     * @param {CellModel} cell - The properties to update for the specified cell.
     * @param {string} address - The address of the cell to update. If not provided, the active cell's address will be used.
     * @param {boolean} enableDependentCellUpdate - Specifies whether dependent cells should also be updated. Default value is <c>true</c>.
     * @returns {void} - This method does not return a value.
     */
    updateCell(cell, address, enableDependentCellUpdate) {
        if (isNullOrUndefined(enableDependentCellUpdate)) {
            enableDependentCellUpdate = true;
        }
        this.updateCellDetails(cell, address, undefined, undefined, enableDependentCellUpdate);
    }
    /**
     * Updates the properties of a specified cell.
     *
     * @param {CellModel} cell - The properties to update for the specified cell.
     * @param {string} address - The address of the cell to update. If not provided, the active cell's address will be used.
     * @param {UndoRedoEventArgs} cellInformation - It holds the undoRedoCollections.
     * @param {boolean} isRedo - It holds the undo redo information.
     * @param {boolean} isDependentUpdate - Specifies whether dependent cells should also be updated.
     * @param {boolean} isFinite - Specifies scroll settings of the sheet is finite or not.
     * @param {boolean} isPublic - It holds whether updateCell public method is used.
     * @returns {void} - This method does not return a value.
     *
     * @hidden
     */
    updateCellDetails(cell, address, cellInformation, isRedo, isDependentUpdate, isFinite, isPublic) {
        let range;
        let sheetIdx;
        if (!address) {
            address = this.getActiveSheet().activeCell;
        }
        if (address.includes('!')) {
            range = getIndexesFromAddress(address);
            sheetIdx = getSheetIndex(this, address.substring(0, address.lastIndexOf('!')));
            if (sheetIdx === undefined) {
                return;
            }
        }
        else {
            range = getRangeIndexes(address);
            sheetIdx = this.activeSheetIndex;
        }
        const sheet = getSheet(this, sheetIdx);
        if (isFinite && !(sheet.rowCount > range[0] && sheet.rowCount > range[2] &&
            sheet.colCount > range[1] && sheet.colCount > range[3])) {
            this.notify(finiteAlert, null);
            return;
        }
        updateCell(this, sheet, { cell: cell, rowIdx: range[0], colIdx: range[1], preventEvt: true });
        const val = isPublic ? cell.formula || (isNullOrUndefined(cell.value) ? null : cell.value) :
            isNullOrUndefined(cell.value) ? (cell.formula || null) : cell.value;
        const valChange = val !== null;
        const cellModel = getCell(range[0], range[1], sheet, false, true);
        if (cellInformation && cellInformation.format && isRedo) {
            cellModel.format = cellInformation.format;
        }
        if (valChange) {
            delete cellModel.formattedText;
            this.notify(workbookEditOperation, {
                action: 'updateCellValue', address: range, value: val, sheetIndex: sheetIdx,
                cellInformation: cellInformation, isRedo: isRedo, isDependentUpdate: isDependentUpdate
            });
            if (this.isEdit && cellModel.value === '#CIRCULARREF!') {
                cellModel.value = '0';
            }
        }
        else if (!isNullOrUndefined(cell.format) && cellModel.formattedText) {
            delete cellModel.formattedText;
        }
        if (sheetIdx === this.activeSheetIndex) {
            const eventArgs = { sheet: sheet, cell: cellModel, rowIdx: range[0], colIdx: range[1] };
            if (cellModel.rowSpan > 1 || cellModel.colSpan > 1) {
                setVisibleMergeIndex(eventArgs);
            }
            const cellEle = !isHiddenRow(sheet, eventArgs.rowIdx) && !isHiddenCol(sheet, eventArgs.colIdx) &&
                this.getCell(eventArgs.rowIdx, eventArgs.colIdx);
            if (cellEle) {
                this.serviceLocator.getService('cell').refresh(eventArgs.rowIdx, eventArgs.colIdx, true, cellEle, valChange, valChange);
            }
            const activeCellIdx = getCellIndexes(sheet.activeCell);
            if (range[0] === activeCellIdx[0] && range[1] === activeCellIdx[1]) {
                this.notify(refreshRibbonIcons, null);
                this.notify(formulaBarOperation, { action: 'refreshFormulabar', cell: cellModel });
                if (cellEle && cell.validation) {
                    eventArgs.validation = cellModel.validation;
                    eventArgs.td = cellEle;
                    eventArgs.isRefresh = true;
                    this.notify(addListValidationDropdown, eventArgs);
                }
            }
        }
    }
    /**
     * Used to get a row data from the data source with updated cell value.
     *
     * {% codeBlock src='spreadsheet/getRowData/index.md' %}{% endcodeBlock %}
     *
     * @param {number} index - Specifies the row index.
     * @param {number} sheetIndex - Specifies the sheet index. By default, it consider the active sheet index.
     * @returns {Object[]} - Return row data.
     */
    getRowData(index, sheetIndex) {
        if (isNullOrUndefined(index)) {
            index = 0;
        }
        if (isNullOrUndefined(sheetIndex)) {
            sheetIndex = this.activeSheetIndex;
        }
        const eventArgs = { sheetIdx: sheetIndex, startIndex: index, modelType: 'Row', isDataRequest: true };
        this.notify(dataChanged, eventArgs);
        return eventArgs.data;
    }
    /**
     * This method is used to update the Range property in specified sheet index.
     *
     * @param {RangeModel} range - Specifies the range properties to update.
     * @param {number} [sheetIndex] - Specifies the sheet index to update the range. By default, it consider the active sheet index.
     * @returns {void} - To update a range properties.
     */
    updateRange(range, sheetIndex = this.activeSheetIndex) {
        const sheet = getSheet(this, sheetIndex);
        if (!sheet) {
            return;
        }
        if (!range.startCell) {
            range.startCell = 'A1';
        }
        if (range.showFieldAsHeader === undefined) {
            range.showFieldAsHeader = true;
        }
        if (range.template && !range.address) {
            range.address = range.startCell;
        }
        sheet.ranges.push(range);
        this.setSheetPropertyOnMute(sheet, 'ranges', sheet.ranges);
        if (range.dataSource) {
            this.notify(dataSourceChanged, { sheetIdx: sheetIndex, rangeIdx: sheet.ranges.length - 1, changedData: range.dataSource });
        }
    }
    /**
     * This method is used to wrap/unwrap the text content of the cell.
     *
     * {% codeBlock src='spreadsheet/wrap/index.md' %}{% endcodeBlock %}
     *
     * @param {string} address - Address of the cell to be wrapped.
     * @param {boolean} wrap - Set `false` if the text content of the cell to be unwrapped.
     * @returns {void} - To wrap/unwrap the text content of the cell.
     * {% codeBlock src='spreadsheet/wrap/index.md' %}{% endcodeBlock %}
     */
    wrap(address, wrap$1 = true) {
        wrap(address, wrap$1, this, null, true);
    }
    /**
     * Adds the defined name to the Spreadsheet.
     *
     * @param {DefineNameModel} definedName - Specifies the name.
     * @returns {boolean} - Return the added status of the defined name.
     * {% codeBlock src='spreadsheet/addDefinedName/index.md' %}{% endcodeBlock %}
     */
    addDefinedName(definedName) {
        const eventArgs = {
            action: 'addDefinedName',
            isAdded: false,
            definedName: definedName
        };
        this.notify(workbookFormulaOperation, eventArgs);
        return eventArgs.isAdded;
    }
    /**
     * Removes the defined name from the Spreadsheet.
     *
     * @param {string} definedName - Specifies the name.
     * @param {string} scope - Specifies the scope of the defined name.
     * @returns {boolean} - Return the removed status of the defined name.
     * {% codeBlock src='spreadsheet/removeDefinedName/index.md' %}{% endcodeBlock %}
     */
    removeDefinedName(definedName, scope = '') {
        const eventArgs = {
            action: 'removeDefinedName',
            isRemoved: false,
            definedName: definedName,
            scope: scope
        };
        this.notify(workbookFormulaOperation, eventArgs);
        return eventArgs.isRemoved;
    }
    /**
     * Used to set the image in spreadsheet.
     *
     * @param {ImageModel} images - Specifies the options to insert image in spreadsheet.
     * @param {string} range - Specifies the range in spreadsheet.
     * @returns {void} - To set the image in spreadsheet.
     */
    insertImage(images, range) {
        this.notify(setImage, { options: images, range: range ? range : this.getActiveSheet().selectedRange });
    }
    /**
     * Used to perform autofill action based on the specified range in spreadsheet.
     *
     * @param {string} fillRange - Specifies the fill range.
     * @param {string} dataRange - Specifies the data range.
     * @param {AutoFillDirection} direction - Specifies the direction("Down","Right","Up","Left") to be filled.
     * @param {AutoFillType} fillType - Specifies the fill type("FillSeries","CopyCells","FillFormattingOnly","FillWithoutFormatting") for autofill action.
     * @returns {void} - To perform autofill action based on the specified range in spreadsheet.
     */
    autoFill(fillRange, dataRange, direction, fillType) {
        const options = {
            dataRange: dataRange ? dataRange : this.getActiveSheet().selectedRange,
            fillRange: fillRange,
            direction: direction ? direction : 'Down',
            fillType: fillType ? fillType : 'FillSeries'
        };
        this.notify(setAutoFill, options);
    }
    /**
     * Used to set the chart in spreadsheet.
     *
     * {% codeBlock src='spreadsheet/insertChart/index.md' %}{% endcodeBlock %}
     *
     * @param {ChartModel} chart - Specifies the options to insert chart in spreadsheet
     * @returns {void} - To set the chart in spreadsheet.
     */
    insertChart(chart) {
        this.notify(setChart, { chart: chart });
    }
    /**
     * Used to delete the chart from spreadsheet.
     *
     * {% codeBlock src='spreadsheet/deleteChart/index.md' %}{% endcodeBlock %}
     *
     * @param {string} id - Specifies the chart element id.
     * @returns {void} - To delete the chart from spreadsheet.
     */
    deleteChart(id) {
        this.notify(deleteChart, { id: id });
    }
    /**
     * Filters the range of cells in the sheet.
     *
     * @param {FilterOptions} filterOptions - Specifies the filterOptions
     * @param {string} range - Specifies the range
     * @returns {Promise<FilterEventArgs>} - To Filters the range of cells in the sheet.
     */
    filter(filterOptions, range) {
        if (!this.allowFiltering) {
            return Promise.reject();
        }
        const eventArgs = {
            range: range || this.getActiveSheet().selectedRange,
            filterOptions: filterOptions,
            cancel: false
        };
        const promise = new Promise((resolve) => { resolve((() => { })()); });
        const filterArgs = { args: eventArgs, promise: promise };
        this.notify(initiateFilter, filterArgs);
        return filterArgs.promise;
    }
    /**
     * To add custom library function.
     *
     * @param {string} functionHandler - Custom function handler name
     * @param {string} functionName - Custom function name
     * @param {string} formulaDescription - Specifies formula description.
     * {% codeBlock src='spreadsheet/addCustomFunction/index.md' %}{% endcodeBlock %}
     * @returns {void} - To add custom library function.
     */
    addCustomFunction(functionHandler, functionName, formulaDescription) {
        functionName = functionName ? functionName : typeof functionHandler === 'string' ? functionHandler :
            functionHandler.name.replace('bound ', '');
        const eventArgs = {
            action: 'addCustomFunction',
            functionHandler: functionHandler,
            functionName: functionName,
            formulaDescription: formulaDescription
        };
        this.notify(workbookFormulaOperation, eventArgs);
    }
    /**
     * This method is used to Clear contents, formats and hyperlinks in spreadsheet.
     *
     * @param {ClearOptions} options - Options for clearing the content, formats and hyperlinks in spreadsheet.
     * @returns {void} - To Clear contents, formats and hyperlinks.
     */
    clear(options) {
        this.notify(clear, options);
    }
    /**
     * Gets the formatted text of the cell.
     *
     * {% codeBlock src='spreadsheet/getDisplayText/index.md' %}{% endcodeBlock %}
     *
     * @param {CellModel} cell - Specifies the cell.
     * @returns {string} - To get Display Text.
     */
    getDisplayText(cell) {
        if (!cell) {
            return '';
        }
        if (cell.format && !isNullOrUndefined(cell.value)) {
            const eventArgs = { formattedText: cell.value, value: cell.value, format: cell.format, cell: cell,
                skipFormatCheck: true };
            this.notify(getFormattedCellObject, eventArgs);
            return eventArgs.formattedText;
        }
        else if (!cell.value && cell.hyperlink) {
            return typeof cell.hyperlink === 'string' ? cell.hyperlink : cell.hyperlink.address;
        }
        else {
            return cell.value || typeof cell.value === 'number' ? cell.value.toString() : '';
        }
    }
    /**
     * This method is used to freeze rows and columns after the specified cell in the Spreadsheet.
     *
     * @param {number} row - Specifies the freezed row count.
     * @param {number} column - Specifies the freezed column count.
     * @param {number | string} sheet - Specifies the sheet name or index in which the freeze operation will perform. By default,
     * active sheet will be considered.
     * {% codeBlock src='spreadsheet/freezePanes/index.md' %}{% endcodeBlock %}
     * @returns {void}
     */
    freezePanes(row = 1, column = 1, sheet) {
        const model = this.getSheetModel(sheet);
        if (!this.allowFreezePane || (model.frozenRows === row && model.frozenColumns === column)) {
            return;
        }
        this.setSheetPropertyOnMute(model, 'frozenRows', row);
        this.setSheetPropertyOnMute(model, 'frozenColumns', column);
        this.updateTopLeftCell();
        if (model.id === this.getActiveSheet().id && this.getModuleName() === 'spreadsheet') {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            this.renderModule.refreshSheet();
        }
    }
    /**
     * This method is used to unfreeze the frozen rows and columns from the active sheet.
     *
     * @param {number | string} sheet - Specifies the sheet name or index in which the unfreeze operation will perform. By default,
     * active sheet will be considered.
     * {% codeBlock src='spreadsheet/unfreezePanes/index.md' %}{% endcodeBlock %}
     * @returns {void}
     * @deprecated This method is deprecated, use `unfreezePanes` method to unfreeze the frozen rows and columns.
     */
    Unfreeze(sheet) {
        this.freezePanes(0, 0, sheet);
    }
    /**
     * This method is used to unfreeze the frozen rows and columns from spreadsheet.
     *
     * @param {number | string} sheet - Specifies the sheet name or index in which the unfreeze operation will perform. By default,
     * active sheet will be considered.
     * {% codeBlock src='spreadsheet/unfreezePanes/index.md' %}{% endcodeBlock %}
     * @returns {void}
     */
    unfreezePanes(sheet) {
        this.freezePanes(0, 0, sheet);
    }
    /**
     * The `calculateNow` method is used to calculate any uncalculated formulas in a spreadsheet.
     * This method accepts an option to specify whether the calculation should be performed for the entire workbook or a specific sheet.
     *
     * @param {string} [scope] - Specifies the scope of the calculation. Acceptable values are `Sheet` or `Workbook`.
     * If not provided, the default scope is `Sheet`.
     * * `Sheet`: Calculates formulas only on the current sheet or a specified sheet.
     * * `Workbook`: Calculates formulas across the entire workbook.
     * @param {number | string} [sheet] - The index or name of the sheet to calculate if the scope is set to `Sheet`.
     * If not provided and the scope is `Sheet`, the current active sheet will be used.
     * @returns {Promise<void>} - A promise that resolves when the calculation is complete.
     * The promise does not return a specific value, but it can be used to perform actions after the calculation has finished.
     */
    calculateNow(scope, sheet) {
        let sheets;
        if (scope === 'Workbook' && this.calculationMode === 'Manual') {
            scope = 'CalculateWorkbook';
            this.setProperties({ calculationMode: 'Automatic' }, true);
        }
        if (scope === 'Workbook' || scope === 'CalculateWorkbook') {
            sheets = this.sheets;
        }
        else {
            if (typeof sheet === 'string') {
                sheet = getSheetIndex(this, sheet);
            }
            else {
                sheet = isNullOrUndefined(sheet) ? this.activeSheetIndex : sheet;
            }
            sheets = [getSheet(this, sheet)];
        }
        const calcArgs = { action: 'calculateNow',
            scope: scope, sheets: sheets, promise: new Promise((resolve) => { resolve((() => { })()); }) };
        this.notify(workbookFormulaOperation, calcArgs);
        return calcArgs.promise;
    }
    /**
     * @param {number} top - Specifies the top.
     * @param {number} left - Specifies the fleft.
     * @param {string} model - Specifies the model.
     * @param {SheetModel} sheet - Specifies the sheet.
     * @returns {void}
     * @hidden
     */
    updateTopLeftCell(top, left, model, sheet) {
        if (!sheet) {
            sheet = this.getActiveSheet();
        }
        const indexes = getCellIndexes(sheet.topLeftCell);
        if (sheet.frozenRows || sheet.frozenColumns) {
            if (isNullOrUndefined(top) || top < 0) {
                top = sheet.frozenRows ? 0 : indexes[0];
            }
            if (isNullOrUndefined(left) || left < 0) {
                left = sheet.frozenColumns ? 0 : indexes[1];
            }
            top += this.frozenRowCount(sheet);
            left += this.frozenColCount(sheet);
            if (model) {
                if (model === 'row') {
                    top = getCellIndexes(sheet.paneTopLeftCell)[0];
                }
                else {
                    left = getCellIndexes(sheet.paneTopLeftCell)[1];
                }
            }
            this.setSheetPropertyOnMute(sheet, 'paneTopLeftCell', getCellAddress(top, left));
            if (sheet.frozenRows) {
                top = indexes[0];
            }
            if (sheet.frozenColumns) {
                left = indexes[1];
            }
        }
        else {
            if (isNullOrUndefined(top)) {
                top = indexes[0];
            }
            if (isNullOrUndefined(left)) {
                left = indexes[1];
            }
            this.setSheetPropertyOnMute(sheet, 'paneTopLeftCell', getCellAddress(top, left));
        }
        this.setSheetPropertyOnMute(sheet, 'topLeftCell', getCellAddress(top, left));
    }
    /**
     * @hidden
     * @param {string} address - Specifies the address.
     * @returns {number | number[]} - To get address info.
     */
    getAddressInfo(address) {
        return getAddressInfo(this, address);
    }
    /**
     * @hidden
     * @param {SheetModel} sheet - Specifies the sheet.
     * @param {string} prop - Specifies the prop.
     * @param {Object} value - Specifies the value.
     * @returns {void} - To set sheet properties.
     */
    setSheetPropertyOnMute(sheet, prop, value) {
        this.isProtectedOnChange = true;
        sheet[`${prop}`] = value;
        this.isProtectedOnChange = false;
    }
    /**
     * To get frozen row count from top index.
     *
     * @hidden
     * @param {SheetModel} sheet - Specifies the sheet.
     * @returns {number} - to get the frozen count.
     */
    frozenRowCount(sheet) {
        return sheet.frozenRows ? (sheet.topLeftCell === 'A1' ? sheet.frozenRows : getCellIndexes(sheet.topLeftCell)[0] + sheet.frozenRows)
            : 0;
    }
    /**
     * To get frozen column count from left index.
     *
     * @hidden
     * @param {SheetModel} sheet - Specifies the sheet.
     * @returns {number} - to get the frozen count.
     */
    frozenColCount(sheet) {
        return sheet.frozenColumns ? (sheet.topLeftCell === 'A1' ? sheet.frozenColumns : getCellIndexes(sheet.topLeftCell)[1] +
            sheet.frozenColumns) : 0;
    }
    /**
     * To update the provided range while inserting or deleting rows and columns.
     *
     * @param {InsertDeleteEventArgs} args - Insert / Detele event arguments.
     * @param {number[]} index - Existing range.
     * @param {boolean} isRangeFormula - Specifies is range formula or not.
     * @param {number} rowIndex - Specifies the row index of the cell that contains the formula which is going to be refreshed.
     * @param {number} colIndex - Specifies the column index of the cell that contains the formula which is going to be refreshed.
     * @param {boolean} isAbsoluteRef - Specifies is the range used in the formula is Absolute reference or not.
     * @param {boolean} isSingleRangeRef - Specifies whether the formula as single range reference or not.
     * @returns {boolean} - It return `true`, if the insert / delete action happens between the provided range, otherwise `false`.
     * @hidden
     */
    updateRangeOnInsertDelete(args, index, isRangeFormula, rowIndex, colIndex, isAbsoluteRef, isSingleRangeRef) {
        let diff;
        let updated = false;
        if (args.isInsert) {
            diff = (args.endIndex - args.startIndex) + 1;
            if (args.modelType === 'Row') {
                if (args.forceUpdate) {
                    index[0] += 1;
                    index[2] += 1;
                    updated = true;
                }
                else {
                    const isRangeRefresh = !isAbsoluteRef && isSingleRangeRef
                        && index[2] === args.startIndex - 1 && rowIndex === args.startIndex && index[1] === index[3];
                    if (args.startIndex <= index[0]) {
                        index[0] += diff;
                        updated = true;
                    }
                    if (args.startIndex <= index[2] || (isRangeFormula && args.startIndex === index[2] + 1 && isRangeRefresh)) {
                        index[2] += diff;
                        updated = true;
                    }
                }
            }
            else {
                if (args.forceUpdate) {
                    index[1] += 1;
                    index[3] += 1;
                    updated = true;
                }
                else {
                    const isRangeRefresh = !isAbsoluteRef && isSingleRangeRef
                        && index[3] === args.startIndex - 1 && colIndex === args.startIndex && index[0] === index[2];
                    if (args.startIndex <= index[1]) {
                        index[1] += diff;
                        updated = true;
                    }
                    if (args.startIndex <= index[3] || (isRangeFormula && args.startIndex === index[3] + 1 && isRangeRefresh)) {
                        index[3] += diff;
                        updated = true;
                    }
                }
            }
        }
        else {
            if (args.modelType === 'Row') {
                diff = index[0] - args.startIndex;
                if (diff > 0) {
                    if (index[0] > args.endIndex) {
                        diff = (args.endIndex - args.startIndex) + 1;
                        if (diff > 0) {
                            index[0] -= diff;
                            updated = true;
                        }
                    }
                    else {
                        index[0] -= diff;
                        updated = true;
                    }
                }
                if (args.startIndex <= index[2]) {
                    if (args.endIndex <= index[2]) {
                        index[2] -= (args.endIndex - args.startIndex) + 1;
                    }
                    else {
                        index[2] -= (index[2] - args.startIndex) + 1;
                    }
                    updated = true;
                }
            }
            else {
                diff = index[1] - args.startIndex;
                if (diff > 0) {
                    if (index[1] > args.endIndex) {
                        diff = (args.endIndex - args.startIndex) + 1;
                        if (diff > 0) {
                            index[1] -= diff;
                            updated = true;
                        }
                    }
                    else {
                        index[1] -= diff;
                        updated = true;
                    }
                }
                if (args.startIndex <= index[3]) {
                    if (args.endIndex <= index[3]) {
                        index[3] -= (args.endIndex - args.startIndex) + 1;
                    }
                    else {
                        index[3] -= (index[3] - args.startIndex) + 1;
                    }
                    updated = true;
                }
            }
        }
        return updated;
    }
    /**
     * @param {number} rowIndex - Specifies the row index.
     * @param {number} colIndex - Specifies the column index.
     * @param {HTMLTableRowElement} row - Specifies the row.
     * @returns {HTMLElement} - returns cell element.
     * @hidden
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getCell(rowIndex, colIndex, row) {
        return null;
    }
    /**
     * Used in calculate to compute integer value of date
     *
     * @param {Date} date - Specifies the date value.
     * @param {boolean} isTime -Specifies is Time or not.
     * @returns {number} - Returns integer value of date.
     */
    dateToInt(date, isTime) {
        return dateToInt(date, isTime);
    }
    /**
     * Used to update format from calculate.
     *
     * @param {number} sheetId - Specifies the sheetId.
     * @param {number} rowIndex - Specifies the row index.
     * @param {number} colIndex - Specifies the col index.
     * @returns {void} - Update format from calculate.
     */
    setDateFormat(sheetId, rowIndex, colIndex) {
        const sheet = getSheet(this, getSheetIndexFromId(this, sheetId));
        const formatType = getCell(rowIndex, colIndex, sheet, null, true).format;
        if (!formatType || formatType === 'General') {
            setCell(rowIndex, colIndex, sheet, { format: getFormatFromType('ShortDate') }, true);
        }
    }
};
__decorate$4([
    Collection([], Sheet)
], Workbook.prototype, "sheets", void 0);
__decorate$4([
    Property(0)
], Workbook.prototype, "activeSheetIndex", void 0);
__decorate$4([
    Property('100%')
], Workbook.prototype, "height", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowFindAndReplace", void 0);
__decorate$4([
    Property()
], Workbook.prototype, "filterCollection", void 0);
__decorate$4([
    Property()
], Workbook.prototype, "sortCollection", void 0);
__decorate$4([
    Property('100%')
], Workbook.prototype, "width", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "showRibbon", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "showFormulaBar", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "showSheetTabs", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowEditing", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowOpen", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowSave", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowSorting", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowFiltering", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowNumberFormatting", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowCellFormatting", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowHyperlink", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "enableNotes", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowInsert", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowDelete", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowMerge", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowDataValidation", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowImage", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowChart", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowAutoFill", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowPrint", void 0);
__decorate$4([
    Property('Automatic')
], Workbook.prototype, "calculationMode", void 0);
__decorate$4([
    Complex({}, AutoFillSettings)
], Workbook.prototype, "autoFillSettings", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowConditionalFormat", void 0);
__decorate$4([
    Complex({}, CellStyle)
], Workbook.prototype, "cellStyle", void 0);
__decorate$4([
    Property('')
], Workbook.prototype, "openUrl", void 0);
__decorate$4([
    Complex({}, OpenSettings)
], Workbook.prototype, "openSettings", void 0);
__decorate$4([
    Property('')
], Workbook.prototype, "saveUrl", void 0);
__decorate$4([
    Property('')
], Workbook.prototype, "password", void 0);
__decorate$4([
    Property(false)
], Workbook.prototype, "isProtected", void 0);
__decorate$4([
    Collection([], DefineName)
], Workbook.prototype, "definedNames", void 0);
__decorate$4([
    Event$1()
], Workbook.prototype, "beforeOpen", void 0);
__decorate$4([
    Event$1()
], Workbook.prototype, "openFailure", void 0);
__decorate$4([
    Event$1()
], Workbook.prototype, "beforeSave", void 0);
__decorate$4([
    Event$1()
], Workbook.prototype, "saveComplete", void 0);
__decorate$4([
    Event$1()
], Workbook.prototype, "beforeCellFormat", void 0);
__decorate$4([
    Event$1()
], Workbook.prototype, "queryCellInfo", void 0);
__decorate$4([
    Event$1()
], Workbook.prototype, "beforeCellUpdate", void 0);
__decorate$4([
    Property(true)
], Workbook.prototype, "allowFreezePane", void 0);
__decorate$4([
    Property(',')
], Workbook.prototype, "listSeparator", void 0);
Workbook = Workbook_1 = __decorate$4([
    NotifyPropertyChanges
], Workbook);

var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Configures the Row behavior for the spreadsheet.
 *  ```html
 * <div id='Spreadsheet'></div>
 * ```
 * ```typescript
 * let spreadsheet: Spreadsheet = new Spreadsheet({
 *      sheets: [{
 *                rows: [{
 *                        index: 30,
 *                        cells: [{ index: 4, value: 'Total Amount:' },
 *                               { formula: '=SUM(F2:F30)', style: { fontWeight: 'bold' } }]
 *                }]
 * ...
 * });
 * spreadsheet.appendTo('#Spreadsheet');
 * ```
 */
class Row extends ChildProperty {
}
__decorate$5([
    Collection([], Cell)
], Row.prototype, "cells", void 0);
__decorate$5([
    Property(0)
], Row.prototype, "index", void 0);
__decorate$5([
    Property(20)
], Row.prototype, "height", void 0);
__decorate$5([
    Property(false)
], Row.prototype, "customHeight", void 0);
__decorate$5([
    Property(false)
], Row.prototype, "hidden", void 0);
__decorate$5([
    Complex({}, Format)
], Row.prototype, "format", void 0);
__decorate$5([
    Property(false)
], Row.prototype, "isReadOnly", void 0);
/**
 * @hidden
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {number} rowIndex - Specifies the rowIndex.
 * @returns {RowModel} - To get the row.
 */
function getRow(sheet, rowIndex) {
    return sheet.rows[rowIndex];
}
/**
 * @hidden
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {number} rowIndex - Specifies the rowIndex.
 * @param {RowModel} row - Specifies the row.
 * @returns {void} - To set the row.
 */
function setRow(sheet, rowIndex, row) {
    if (!sheet.rows[rowIndex]) {
        sheet.rows[rowIndex] = {};
    }
    Object.keys(row).forEach((key) => {
        sheet.rows[rowIndex][`${key}`] = row[`${key}`];
    });
}
/**
 * @hidden
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {number} index - Specifies the index.
 * @returns {boolean} - To return the bool value.
 */
function isHiddenRow(sheet, index) {
    return sheet.rows[index] && sheet.rows[index].hidden;
}
/**
 * @hidden
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {number} index - Specifies the index.
 * @returns {boolean} - To return the bool value.
 */
function isFilterHidden(sheet, index) {
    return sheet.rows[index] && sheet.rows[index].isFiltered;
}
/**
 * @hidden
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {number} rowIndex - Specifies the rowIndex.
 * @param {boolean} checkDPR - Specifies the bool value.
 * @param {boolean} addHidden - By default hidden rows are considered as 0, set `true` if you want to add the hidden rows height.
 * @returns {number} - To get the row height.
 */
function getRowHeight(sheet, rowIndex, checkDPR, addHidden) {
    let hgt;
    let stdHeight;
    if (sheet && sheet.standardHeight) {
        stdHeight = sheet.standardHeight;
    }
    if (sheet && sheet.rows && sheet.rows[rowIndex]) {
        if (!addHidden && sheet.rows[rowIndex].hidden) {
            return 0;
        }
        hgt = sheet.rows[rowIndex].height === undefined ?
            (stdHeight === undefined ? 20 : stdHeight) : sheet.rows[rowIndex].height;
    }
    else {
        hgt = stdHeight === undefined ? 20 : stdHeight;
    }
    if (checkDPR && window.devicePixelRatio % 1 > 0) {
        const pointValue = (hgt * window.devicePixelRatio) % 1;
        return hgt + (pointValue ? ((pointValue > 0.5 ? (1 - pointValue) : -1 * pointValue) / window.devicePixelRatio) : 0);
    }
    else {
        return hgt;
    }
}
/**
 * @hidden
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {number} rowIndex - Specifies the rowIndex.
 * @param {number} height - Specifies the height.
 * @returns {void} - To set the row height.
 */
function setRowHeight(sheet, rowIndex, height) {
    if (sheet && sheet.rows) {
        if (!sheet.rows[rowIndex]) {
            sheet.rows[rowIndex] = {};
        }
        sheet.rows[rowIndex].height = height;
    }
}
/**
 * @hidden
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {number} startRow - Specifies the startRow.
 * @param {number} endRow - Specifies the endRow.
 * @param {boolean} checkDPR - Specifies the boolean value.
 * @param {boolean} addHidden - By default hidden rows are considered as 0, set `true` if you want to add the hidden rows height.
 * @returns {number} - To get the rows height.
 */
function getRowsHeight(sheet, startRow, endRow = startRow, checkDPR, addHidden) {
    let height = 0;
    let swap;
    if (startRow > endRow) {
        swap = startRow;
        startRow = endRow;
        endRow = swap;
    }
    for (let i = startRow; i <= endRow; i++) {
        height += getRowHeight(sheet, i, checkDPR, addHidden);
    }
    return height;
}

var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Configures the Column behavior for the spreadsheet.
 */
class Column extends ChildProperty {
}
__decorate$6([
    Property(0)
], Column.prototype, "index", void 0);
__decorate$6([
    Property(64)
], Column.prototype, "width", void 0);
__decorate$6([
    Property(false)
], Column.prototype, "customWidth", void 0);
__decorate$6([
    Property(false)
], Column.prototype, "hidden", void 0);
__decorate$6([
    Complex({}, Format)
], Column.prototype, "format", void 0);
__decorate$6([
    Property(true)
], Column.prototype, "isLocked", void 0);
__decorate$6([
    Property('')
], Column.prototype, "validation", void 0);
__decorate$6([
    Property(false)
], Column.prototype, "isReadOnly", void 0);
/**
 * @hidden
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {number} colIndex - Specifies the colIndex.
 * @returns {ColumnModel} - To get Column.
 */
function getColumn(sheet, colIndex) {
    if (sheet.columns) {
        if (!sheet.columns[colIndex]) {
            sheet.columns[colIndex] = {};
        }
    }
    else {
        sheet.columns = [];
        sheet.columns[colIndex] = {};
    }
    return sheet.columns[colIndex];
}
/** @hidden
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {number} colIndex - Specifies the colIndex.
 * @param {ColumnModel} column - Specifies the column.
 * @returns {void} - To set Column.
 */
function setColumn(sheet, colIndex, column) {
    const curColumn = getColumn(sheet, colIndex);
    Object.keys(column).forEach((key) => {
        curColumn[`${key}`] = column[`${key}`];
    });
}
/**
 * @hidden
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {number} index - Specifies the index.
 * @param {boolean} skipHidden - Specifies the bool.
 * @param {boolean} checkDPR - Specifies the bool.
 * @returns {number} - To get Column width.
 */
function getColumnWidth(sheet, index, skipHidden, checkDPR) {
    let width;
    if (sheet && sheet.columns && sheet.columns[index]) {
        if (!skipHidden && sheet.columns[index].hidden) {
            return 0;
        }
        width = (sheet.columns[index].width || sheet.columns[index].customWidth) ?
            sheet.columns[index].width : 64;
    }
    else {
        width = 64;
    }
    if (checkDPR && window.devicePixelRatio % 1 > 0) {
        const pointValue = (width * window.devicePixelRatio) % 1;
        return width + (pointValue ? ((pointValue > 0.5 ? (1 - pointValue) : -1 * pointValue) / window.devicePixelRatio) : 0);
    }
    else {
        return width;
    }
}
/**
 * @hidden
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {number} startCol - Specifies the startCol.
 * @param {number} endCol - Specifies the endCol.
 * @param {boolean} checkDPR - Specifies the boolean value.
 * @returns {number} - returns the column width.
 */
function getColumnsWidth(sheet, startCol, endCol = startCol, checkDPR) {
    let width = 0;
    if (startCol > endCol) {
        const swap = startCol;
        startCol = endCol;
        endCol = swap;
    }
    for (let i = startCol; i <= endCol; i++) {
        width += getColumnWidth(sheet, i, null, checkDPR);
    }
    return width;
}
/**
 * @hidden
 * @param {SheetModel} sheet - Specifies the sheet.
 * @param {number} index - Specifies the index.
 * @returns {boolean} - returns the boolean value.
 */
function isHiddenCol(sheet, index) {
    return sheet.columns[index] && sheet.columns[index].hidden;
}
/**
 * @hidden
 * @param {ColumnModel} column - Specifies the column.
 * @param {number} rowIndex - Specifies the row index.
 * @param {number} colIndex - Specifies the column index.
 * @returns {boolean} - Specifies boolean values by checking column validation or not.
 */
function checkColumnValidation(column, rowIndex, colIndex) {
    return column && column.validation && (!column.validation.address || isInMultipleRange(column.validation.address, rowIndex, colIndex));
}

/**
 * To get Spreadsheet required modules.
 *
 * @hidden
 * @param {Spreadsheet} context - To get Spreadsheet required modules.
 * @returns {ModuleDeclaration[]} - To get Spreadsheet required modules.
 */
function getRequiredModules(context) {
    const modules = [];
    pushBasicModules(context, modules);
    getWorkbookRequiredModules(context, modules);
    return modules;
}
/**
 * To push basic modules to the spreadsheet.
 *
 * @param {Spreadsheet} context - Specifies the Spreadsheet instances.
 * @param {ModuleDeclaration[]} modules - Specifies the modules declaration.
 * @returns {void} - To push basic modules to the spreadsheet.
 */
function pushBasicModules(context, modules) {
    if (context.showRibbon) {
        modules.push({
            member: 'ribbon',
            args: [context]
        });
    }
    if (context.showFormulaBar) {
        modules.push({
            member: 'formulaBar',
            args: [context]
        });
    }
    if (context.showSheetTabs) {
        modules.push({
            member: 'sheetTabs',
            args: [context]
        });
    }
    if (context.allowEditing) {
        modules.push({
            member: 'edit',
            args: [context]
        });
        modules.push({
            member: 'formula',
            args: [context]
        });
    }
    if (context.allowOpen) {
        modules.push({
            member: 'open',
            args: [context]
        });
    }
    if (context.allowSave) {
        modules.push({
            member: 'save',
            args: [context]
        });
    }
    if (context.enableContextMenu) {
        modules.push({
            member: 'contextMenu',
            args: [context]
        });
    }
    if (context.allowAutoFill) {
        modules.push({ member: 'autofill', args: [context] });
    }
    if (context.selectionSettings.mode !== 'None') {
        modules.push({
            member: 'selection',
            args: [context]
        });
    }
    if (context.enableKeyboardNavigation) {
        modules.push({
            member: 'keyboardNavigation',
            args: [context]
        });
    }
    if (context.allowNumberFormatting) {
        modules.push({
            member: 'numberFormat',
            args: [context]
        });
    }
    if (context.enableKeyboardShortcut) {
        modules.push({
            member: 'keyboardShortcut',
            args: [context]
        });
    }
    if (context.enableClipboard) {
        modules.push({
            member: 'clipboard',
            args: [context]
        });
    }
    if (context.allowCellFormatting) {
        modules.push({
            member: 'cellformat',
            args: [context]
        });
    }
    if (context.allowSorting) {
        modules.push({ member: 'sort', args: [context] });
    }
    if (context.allowResizing) {
        modules.push({
            member: 'resize',
            args: [context]
        });
    }
    modules.push({
        member: 'protectSheet',
        args: [context]
    });
    modules.push({
        member: 'workbookFormula',
        args: [context]
    });
    modules.push({
        member: 'workbookEdit',
        args: [context]
    });
    if (context.allowHyperlink) {
        modules.push({
            member: 'spreadsheetHyperlink',
            args: [context]
        });
    }
    if (context.enableNotes) {
        modules.push({
            member: 'spreadsheetNote',
            args: [context]
        });
    }
    if (context.allowUndoRedo) {
        modules.push({
            member: 'undoredo',
            args: [context]
        });
    }
    if (context.allowFiltering) {
        modules.push({ member: 'filter', args: [context] });
    }
    if (context.allowWrap) {
        modules.push({ member: 'wrapText', args: [context] });
    }
    if (context.allowInsert) {
        modules.push({ member: 'insert', args: [context] });
    }
    if (context.allowDelete) {
        modules.push({ member: 'delete', args: [context] });
    }
    if (context.allowDataValidation) {
        modules.push({ member: 'dataValidation', args: [context] });
    }
    if (context.allowFindAndReplace) {
        modules.push({ member: 'findAndReplace', args: [context] });
    }
    if (context.allowMerge) {
        modules.push({ member: 'merge', args: [context] });
    }
    if (context.allowConditionalFormat) {
        modules.push({ member: 'conditionalFormatting', args: [context] });
    }
    if (context.allowImage) {
        modules.push({ member: 'spreadsheetImage', args: [context] });
    }
    if (context.allowChart) {
        modules.push({ member: 'spreadsheetChart', args: [context] });
    }
}

/** @hidden */
const DISABLED = 'e-disabled';
/** @hidden */
const WRAPTEXT = 'e-wraptext';
/** @hidden */
const locale = 'spreadsheetLocale';
/** @hidden */
const dialog = 'dialog';
/** @hidden */
const actionEvents = 'actionEvents';
/** @hidden */
const overlay = 'shape';
/** @hidden */
const fontColor = {
    'Custom': [
        '#ffffff', '#000000', '#e7e6e6', '#44546a', '#4472c4', '#ed7d31', '#a5a5a5', '#ffc000', '#70ad47', '#ff0000',
        '#f2f2f2', '#808080', '#cfcdcd', '#d5dce4', '#d9e2f3', '#fbe4d5', '#ededed', '#fff2cc', '#e2efd9', '#ffcccc',
        '#d9d9d9', '#595959', '#aeaaaa', '#acb9ca', '#b4c6e7', '#f7caac', '#dbdbdb', '#ffe599', '#c5e0b3', '#ff8080',
        '#bfbfbf', '#404040', '#747070', '#8496b0', '#8eaadb', '#f4b083', '#c9c9c9', '#ffd966', '#a8d08d', '#ff3333',
        '#a6a6a6', '#262626', '#3b3838', '#323e4f', '#2f5496', '#c45911', '#7b7b7b', '#bf8f00', '#538135', '#b30000',
        '#7f7f7f', '#0d0d0d', '#161616', '#212934', '#1f3763', '#823b0b', '#525252', '#7f5f00', '#375623', '#660000'
    ]
};
/** @hidden */
const fillColor = {
    'Custom': [
        '#ffffff', '#000000', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#ff0000', '#000080', '#800080', '#996633',
        '#f2f2f2', '#808080', '#ffffcc', '#b3ffb3', '#ccffff', '#ccccff', '#ffcccc', '#ccccff', '#ff80ff', '#f2e6d9',
        '#d9d9d9', '#595959', '#ffff80', '#80ff80', '#b3ffff', '#8080ff', '#ff8080', '#8080ff', '#ff00ff', '#dfbf9f',
        '#bfbfbf', '#404040', '#ffff33', '#33ff33', '#33ffff', '#3333ff', '#ff3333', '#0000b3', '#b300b3', '#c68c53',
        '#a6a6a6', '#262626', '#e6e600', '#00b300', '#009999', '#000099', '#b30000', '#000066', '#660066', '#86592d',
        '#7f7f7f', '#0d0d0d', '#999900', '#006600', '#006666', '#000066', '#660000', '#00004d', '#4d004d', '#734d26'
    ]
};
/** @hidden */
const keyCodes = {
    UP: 38,
    DOWN: 40,
    LEFT: 37,
    RIGHT: 39,
    FIRSTALPHABET: 65,
    LASTALPHABET: 90,
    SPACE: 32,
    BACKSPACE: 8,
    TAB: 9,
    DELETE: 46,
    ENTER: 13,
    ESC: 27
};
/**
 * Default locale text
 *
 * @hidden
 */
const defaultLocale = {
    FindValue: 'Find value',
    ReplaceValue: 'Replace value',
    FindReplaceTooltip: 'Find & Replace',
    InsertingEmptyValue: 'Reference value is not valid.',
    ReplaceAllEnd: ' matches replaced with ',
    ByRow: 'By Rows',
    ByColumn: 'By Columns',
    MatchCase: 'Match case',
    MatchExactCellElements: 'Match entire cell contents',
    EnterCellAddress: 'Enter cell address',
    FindAndReplace: 'Find and Replace',
    FindNextBtn: 'Find Next',
    FindPreviousBtn: 'Find Previous',
    ReplaceBtn: 'Replace',
    ReplaceAllBtn: 'Replace All',
    GotoHeader: 'Go To',
    Sheet: 'Sheet',
    Workbook: 'Workbook',
    NoElements: 'We couldn\'t find what you were looking for.',
    FindWhat: 'Find what',
    ReplaceWith: 'Replace with',
    Cut: 'Cut',
    Copy: 'Copy',
    Paste: 'Paste',
    PasteSpecial: 'Paste Special',
    Link: 'Link',
    Spreadsheet: 'Spreadsheet',
    AddNote: 'Add Note',
    EditNote: 'Edit Note',
    DeleteNote: 'Delete Note',
    Hyperlink: 'Hyperlink',
    EditHyperlink: 'Edit Hyperlink',
    OpenHyperlink: 'Open Hyperlink',
    RemoveHyperlink: 'Remove Hyperlink',
    InvalidHyperlinkAlert: 'The address of this site is not valid. Check the address and try again.',
    InsertLink: 'Insert Link',
    EditLink: 'Edit Link',
    All: 'All',
    Values: 'Values',
    Formats: 'Formats',
    Bold: 'Bold',
    Font: 'Font',
    FontSize: 'Font Size',
    Italic: 'Italic',
    Underline: 'Underline',
    Strikethrough: 'Strikethrough',
    TextColor: 'Text Color',
    FillColor: 'Fill Color',
    HorizontalAlignment: 'Horizontal Alignment',
    AlignLeft: 'Align Left',
    AlignCenter: 'Center',
    AlignRight: 'Align Right',
    VerticalAlignment: 'Vertical Alignment',
    AlignTop: 'Align Top',
    AlignMiddle: 'Align Middle',
    AlignBottom: 'Align Bottom',
    WrapText: 'Wrap Text',
    MergeCells: 'Merge Cells',
    MergeAll: 'Merge All',
    MergeHorizontally: 'Merge Horizontally',
    MergeVertically: 'Merge Vertically',
    Unmerge: 'Unmerge',
    UnmergeCells: 'Unmerge Cells',
    SelectMergeType: 'Select Merge Type',
    MergeCellsAlert: 'Merging cells will only preserve the top-leftmost(Uppermost) value. Merge anyway?',
    Borders: 'Borders',
    TopBorders: 'Top Borders',
    LeftBorders: 'Left Borders',
    RightBorders: 'Right Borders',
    BottomBorders: 'Bottom Borders',
    AllBorders: 'All Borders',
    HorizontalBorders: 'Horizontal Borders',
    VerticalBorders: 'Vertical Borders',
    OutsideBorders: 'Outside Borders',
    InsideBorders: 'Inside Borders',
    NoBorders: 'No Borders',
    BorderColor: 'Border Color',
    BorderStyle: 'Border Style',
    InsertFunction: 'Insert Function',
    CalcOptions: 'Calculation Options',
    CalcOptionsTip: 'Choose to calculate formulas either automatically or manually',
    CalcActiveSheet: 'Calculate Sheet',
    CalcWorkbook: 'Calculate Workbook',
    Automatic: 'Automatic',
    Manual: 'Manual',
    CalcSheetTip: 'Calculate the active sheet',
    CalcWorkbookTip: 'Calculate the entire workbook',
    Insert: 'Insert',
    Delete: 'Delete',
    DuplicateSheet: 'Duplicate',
    MoveRight: 'Move Right',
    MoveLeft: 'Move Left',
    Rename: 'Rename',
    Hide: 'Hide',
    FileName: 'File Name',
    PROPER: 'Converts a text to proper case; first letter to uppercase and other letters to lowercase.',
    NameBox: 'Name Box',
    ShowHeaders: 'Show Headers',
    HideHeaders: 'Hide Headers',
    ShowGridLines: 'Show Gridlines',
    ExtendValidation: 'The selection contains some cells without data validation. Do you want to extend validation to these cells?',
    Yes: 'Yes',
    No: 'No',
    HideGridLines: 'Hide Gridlines',
    FreezePanes: 'Freeze Panes',
    FreezeRows: 'Freeze Rows',
    FreezeColumns: 'Freeze Columns',
    UnfreezePanes: 'Unfreeze Panes',
    UnfreezeRows: 'Unfreeze Rows',
    UnfreezeColumns: 'Unfreeze Columns',
    AddSheet: 'Add Sheet',
    ListAllSheets: 'List All Sheets',
    CollapseToolbar: 'Collapse Toolbar',
    ExpandToolbar: 'Expand Toolbar',
    CollapseFormulaBar: 'Collapse Formula Bar',
    ExpandFormulaBar: 'Expand Formula Bar',
    File: 'File',
    Home: 'Home',
    Formulas: 'Formulas',
    View: 'View',
    New: 'New',
    Open: 'Open',
    SaveAs: 'Save As',
    Print: 'Print',
    Update: 'Update',
    ExcelXlsx: 'Microsoft Excel',
    ExcelXls: 'Microsoft Excel 97-2003',
    CSV: 'Comma-separated values',
    FormulaBar: 'Formula Bar',
    Sort: 'Sort',
    SortAscending: 'Ascending',
    SortDescending: 'Descending',
    CustomSort: 'Custom Sort',
    AddColumn: 'Add Column',
    ContainsHeader: 'Data contains header',
    CaseSensitive: 'Case sensitive',
    SortBy: 'Sort by',
    ThenBy: 'Then by',
    SelectAColumn: 'Select a column',
    SortEmptyFieldError: 'All sort criteria must have a column specified. Check the selected sort criteria and try again.',
    SortDuplicateFieldError: '  is being sorted by values more than once. Delete the duplicate sort criteria and try again.',
    SortOutOfRangeError: 'Select a cell or range inside the used range and try again.',
    MultiRangeSortError: 'This can\'t be done on a multiple range selection. Select a single range and try again.',
    SortAndFilter: 'Sort & Filter',
    Filter: 'Filter',
    ClearAllFilter: 'Clear',
    ClearFilterFrom: 'Clear Filter From ',
    ReapplyFilter: 'Reapply',
    FilterCellValue: 'Filter by Value of Selected Cell',
    FilterOutOfRangeError: 'Select a cell or range inside the used range and try again.',
    HideRow: 'Hide Row',
    HideRows: 'Hide Rows',
    UnhideRows: 'Unhide Rows',
    HideColumn: 'Hide Column',
    HideColumns: 'Hide Columns',
    UnhideColumns: 'Unhide Columns',
    InsertRow: 'Insert Row',
    InsertRows: 'Insert Rows',
    Above: 'Above',
    Below: 'Below',
    InsertColumn: 'Insert Column',
    InsertColumns: 'Insert Columns',
    Before: 'Before',
    After: 'After',
    DeleteRow: 'Delete Row',
    DeleteRows: 'Delete Rows',
    DeleteColumn: 'Delete Column',
    DeleteColumns: 'Delete Columns',
    Ok: 'OK',
    Close: 'Close',
    MoreOptions: 'More Options',
    Cancel: 'Cancel',
    Apply: 'Apply',
    MoreColors: 'More Colors',
    StandardColors: 'Standard Colors',
    General: 'General',
    Number: 'Number',
    Currency: 'Currency',
    Accounting: 'Accounting',
    ShortDate: 'Short Date',
    LongDate: 'Long Date',
    Time: 'Time',
    Percentage: 'Percentage',
    Fraction: 'Fraction',
    Scientific: 'Scientific',
    Text: 'Text',
    Custom: 'Custom',
    MobileFormulaBarPlaceHolder: 'Enter value or Formula',
    NumberFormat: 'Number Format',
    PasteAlert: 'You can\'t paste this here, because the copy area and paste area aren\'t in the same size. ' +
        'Please try pasting in a different range.',
    DestroyAlert: 'Are you sure you want to destroy the current workbook without saving and create a new workbook?',
    SheetRenameInvalidAlert: 'Sheet name contains invalid character.',
    SheetRenameEmptyAlert: 'Sheet name cannot be empty.',
    SheetRenameAlreadyExistsAlert: 'Sheet name already exists. Please enter another name.',
    DeleteSheetAlert: 'You can\'t undo deleting sheets, and you might be removing some data. If you don\'t need it, click OK to delete.',
    DeleteSingleLastSheetAlert: 'A Workbook must contain at least one visible worksheet.',
    PickACategory: 'Pick a category',
    Description: 'Description',
    UnsupportedFile: 'Unsupported File',
    DataLimitExceeded: 'File data is too large and it takes more time to process, do you want to continue?',
    FileSizeLimitExceeded: 'File size is too large and it takes more time to process, do you want to continue?',
    InvalidUrl: 'Invalid URL',
    SUM: 'Adds a series of numbers and/or cells.',
    SUMIF: 'Adds the cells based on specified condition.',
    SUMIFS: 'Adds the cells based on specified conditions.',
    ABS: 'Returns the value of a number without its sign.',
    RAND: 'Returns a random number between 0 and 1.',
    RANDBETWEEN: 'Returns a random integer based on specified values.',
    FLOOR: 'Rounds a number down to the nearest multiple of a given factor.',
    CEILING: 'Rounds a number up to the nearest multiple of a given factor.',
    PRODUCT: 'Multiplies a series of numbers and/or cells.',
    INT: 'Returns a number to the nearest integer.',
    ROUNDUP: 'Rounds a number away from zero.',
    SUMPRODUCT: 'Returns sum of the product of given ranges of arrays.',
    SORT: 'Sorts a range of an array',
    T: 'Checks whether a value is text or not and returns the text.',
    EXACT: 'Checks whether a two text strings are exactly same and returns TRUE or FALSE.',
    LEN: 'Returns a number of characters in a given string.',
    MOD: 'Returns a remainder after a number is divided by divisor.',
    ODD: 'Rounds a positive number up and negative number down to the nearest odd integer.',
    PI: 'Returns the value of pi.',
    COUNTBLANK: 'Returns the number of empty cells in a specified range of cells.',
    EVEN: 'Rounds a positive number up and negative number down to the nearest even integer.',
    DECIMAL: 'Converts a text representation of a number in a given base into a decimal number.',
    DEGREES: 'Converts radians to degrees.',
    ADDRESS: 'Returns a cell reference as text, given specified row and column numbers.',
    TIME: 'Converts hours, minutes, seconds to the time formatted text.',
    CHAR: 'Returns the character from the specified number.',
    CODE: 'Returns the numeric code for the first character in a given string.',
    DOLLAR: 'Converts the number to currency formatted text.',
    SMALL: 'Returns the k-th smallest value in a given array.',
    LARGE: 'Returns the k-th largest value in a given array.',
    FACT: 'Returns the factorial of a number.',
    MEDIAN: 'Returns the median of the given set of numbers.',
    EDATE: 'Returns a date with given number of months before or after the specified date.',
    DATEVALUE: 'Converts a date string into date value.',
    HOUR: 'Returns the number of hours in a specified time string.',
    SECOND: 'Returns the number of seconds in a specified time string.',
    MINUTE: 'Returns the number of minutes in a specified time string.',
    NOW: 'Returns the current date and time.',
    MONTH: 'Returns the number of months in a specified date string.',
    TODAY: 'Returns the current date as date value.',
    WEEKDAY: 'Returns the day of the week corresponding to a date.',
    AVERAGE: 'Calculates average for the series of numbers and/or cells excluding text.',
    AVERAGEIF: 'Calculates average for the cells based on specified criterion.',
    AVERAGEIFS: 'Calculates average for the cells based on specified conditions.',
    AVERAGEA: 'Calculates the average for the cells evaluating TRUE as 1, text and FALSE as 0.',
    COUNT: 'Counts the cells that contain numeric values in a range.',
    COUNTIF: 'Counts the cells based on specified condition.',
    COUNTIFS: 'Counts the cells based on specified conditions.',
    COUNTA: 'Counts the cells that contains values in a range.',
    MIN: 'Returns the smallest number of the given arguments.',
    MAX: 'Returns the largest number of the given arguments.',
    DATE: 'Returns the date based on given year, month, and day.',
    DAY: 'Returns the day from the given date.',
    DAYS: 'Returns the number of days between two dates.',
    IF: 'Returns value based on the given expression.',
    IFS: 'Returns value based on the given multiple expressions.',
    CalculateAND: 'Returns TRUE if all the arguments are TRUE, otherwise returns FALSE.',
    CalculateOR: 'Returns TRUE if any of the arguments are TRUE, otherwise returns FALSE.',
    IFERROR: 'Returns value if no error found else it will return specified value.',
    CHOOSE: 'Returns a value from list of values, based on index number.',
    INDEX: 'Returns a value of the cell in a given range based on row and column number.',
    FIND: 'Returns the position of a string within another string, which is case sensitive.',
    TEXT: 'Converts a value to text in specified number format.',
    CONCATENATE: 'Combines two or more strings together.',
    CONCAT: 'Concatenates a list or a range of text strings.',
    SUBTOTAL: 'Returns subtotal for a range using the given function number.',
    RADIANS: 'Converts degrees into radians.',
    MATCH: 'Returns the relative position of a specified value in given range.',
    LN: 'Returns the natural logarithm of a number.',
    INTERCEPT: 'Calculates the point of the Y-intercept line via linear regression.',
    UNIQUE: 'Returns a unique values from a range or array',
    SLOPE: 'Returns the slope of the line from linear regression of the data points.',
    LOOKUP: 'Looks for a value in a one-row or one-column range, then returns a value from the same position in a second one-row or one-column range.',
    HLOOKUP: 'Looks for a value in the top row of the array of values and then returns a value in the same column from a row in the array that you specify.',
    VLOOKUP: 'Looks for a specific value in the first column of a lookup range and returns a corresponding value from a different column within the same row.',
    NOT: 'Returns the inverse of a given logical expression.',
    EOMONTH: 'Returns the last day of the month that is a specified number of months before or after an initially supplied start date.',
    SQRT: 'Returns the square root of a positive number.',
    ROUNDDOWN: 'Rounds a number down, toward zero.',
    RSQ: 'Returns the square of the Pearson product moment correlation coefficient based on data points in known_y\'s and known_x\'s.',
    DefineNameExists: 'This name already exists, try different name.',
    DefineNameInValid: 'The name that you entered is not valid.',
    CircularReference: 'When a formula refers to one or more circular references, this may result in an incorrect calculation.',
    OR: 'OR',
    AND: 'AND',
    CustomFilterDatePlaceHolder: 'Choose a date',
    CustomFilterPlaceHolder: 'Enter the value',
    CustomFilter: 'Custom Filter',
    Between: 'Between',
    DateTimeFilter: 'DateTime Filters',
    Undo: 'Undo',
    Redo: 'Redo',
    DateFilter: 'Date Filters',
    TextFilter: 'Text Filters',
    NumberFilter: 'Number Filters',
    ClearFilter: 'Clear Filter',
    NoResult: 'No Matches Found',
    FilterFalse: 'False',
    FilterTrue: 'True',
    Blanks: 'Blanks',
    SelectAll: 'Select All',
    GreaterThanOrEqual: 'Greater Than Or Equal',
    GreaterThan: 'Greater Than',
    LessThanOrEqual: 'Less Than Or Equal',
    LessThan: 'Less Than',
    NotEqual: 'Not Equal',
    Equal: 'Equal',
    Contains: 'Contains',
    NotContains: 'Does Not Contains',
    EndsWith: 'Ends With',
    NotEndsWith: 'Does Not End With',
    StartsWith: 'Starts With',
    NotStartsWith: 'Does Not Start With',
    IsEmpty: 'Empty',
    IsNotEmpty: 'Not Empty',
    ClearButton: 'Clear',
    FilterButton: 'Filter',
    CancelButton: 'Cancel',
    OKButton: 'OK',
    Search: 'Search',
    ProtectSheet: 'Protect Sheet',
    UnprotectSheet: 'Unprotect Sheet',
    SelectCells: 'Select locked cells',
    SelectUnlockedCells: 'Select unlocked cells',
    FormatCells: 'Format cells',
    FormatRows: 'Format rows',
    FormatColumns: 'Format columns',
    InsertLinks: 'Insert links',
    ProtectContent: 'Protect the contents of locked cells',
    ProtectAllowUser: ' Allow all users of this worksheet to:',
    EditAlert: 'The cell you\'re trying to change is protected. To make change, unprotect the sheet.',
    ReadonlyAlert: 'You are trying to modify a cell that is in read-only mode. To make changes, please disable the read-only status.',
    FiniteAlert: 'Finite mode is active: Cannot access the specified cell range outside the defined limits.',
    Alert: 'Alert',
    SearchWithin: 'Search within',
    SearchBy: 'Search by',
    Reference: 'Reference',
    DataValidation: 'Data Validation',
    CellRange: 'Cell Range',
    Allow: 'Allow',
    Data: 'Data',
    Minimum: 'Minimum',
    Maximum: 'Maximum',
    IgnoreBlank: 'Ignore blank',
    WholeNumber: 'Whole Number',
    Decimal: 'Decimal',
    Date: 'Date',
    TextLength: 'Text Length',
    List: 'List',
    NotBetween: 'Not Between',
    EqualTo: 'Equal To',
    NotEqualTo: 'Not Equal To',
    GreaterThanOrEqualTo: 'Greater Than Or Equal To',
    LessThanOrEqualTo: 'Less Than Or Equal To',
    InCellDropDown: 'In-cell-dropdown',
    Sources: 'Sources',
    Value: 'Value',
    Formula: 'Formula',
    Retry: 'Retry',
    DialogError: 'The list source must be a reference to single row or column.',
    NamedRangeError: 'A named range you specified cannot be found.',
    MinMaxError: 'The Maximum must be greater than or equal to the Minimum.',
    InvalidNumberError: 'Please enter a valid number.',
    InvalidFormula: 'Please enter a valid formula.',
    MoreValidation: 'This selection contains more than one validation. \n Erase current settings and continue?',
    FileNameError: 'A file name can\'t contain characters like \\ / : * ? " < > [ ] |',
    ListLengthError: 'The list values allows only upto 256 characters',
    ValidationError: 'This value doesn' + '\'' + 't match the data validation restrictions defined for the cell.',
    EmptyError: 'You must enter a value',
    ClearHighlight: 'Clear Highlight',
    HighlightInvalidData: 'Highlight Invalid Data',
    ClearValidation: 'Clear Validation',
    HighlightCellsRules: 'Highlight Cells Rules',
    CFEqualTo: 'Equal To',
    TextThatContains: 'Text that Contains',
    Save: 'Save',
    EmptyFileName: 'File name cannot be empty.',
    LargeName: 'The name is too long.',
    ADateOccuring: 'A Date Occuring',
    DuplicateValues: 'Duplicate Values',
    TopBottomRules: 'Top/Bottom Rules',
    Directional: 'Directional',
    Shapes: 'Shapes',
    Indicators: 'Indicators',
    Ratings: 'Ratings',
    Top10Items: 'Top 10 Items',
    Top10: 'Top 10',
    Bottom10Items: 'Bottom 10 Items',
    Bottom10: 'Bottom 10',
    AboveAverage: 'Above Average',
    BelowAverage: 'Below Average',
    FormatCellsGreaterThan: 'Format cells that are GREATER THAN:',
    FormatCellsLessThan: 'Format cells that are LESS THAN:',
    FormatCellsBetween: 'Format cells that are BETWEEN:',
    FormatCellsEqualTo: 'Format cells that are EQUAL TO:',
    FormatCellsThatContainTheText: 'Format cells that contain the text:',
    FormatCellsThatContainADateOccurring: 'Format cells that contain a date occurring:',
    FormatCellsDuplicate: 'Format cells that contain:',
    FormatCellsTop: 'Format cells that rank in the TOP:',
    FormatCellsBottom: 'Format cells that rank in the BOTTOM:',
    FormatCellsAbove: 'Format cells that are ABOVE AVERAGE:',
    FormatCellsBelow: 'Format cells that are BELOW AVERAGE:',
    With: 'with',
    DataBars: 'Data Bars',
    ColorScales: 'Color Scales',
    IconSets: 'Icon Sets',
    ClearRules: 'Clear Rules',
    SelectedCells: 'Clear Rules from Selected Cells',
    EntireSheet: 'Clear Rules from Entire Sheet',
    ISNUMBER: 'Returns true when the value parses as a numeric value.',
    ROUND: 'Rounds a number to a specified number of digits.',
    GEOMEAN: 'Returns the geometric mean of an array or range of positive data.',
    POWER: 'Returns the result of a number raised to power',
    LOG: 'Returns the logarithm of a number to the base that you specify.',
    TRUNC: 'Returns the truncated value of a number to a specified number of decimal places.',
    EXP: 'Returns e raised to the power of the given number.',
    Clear: 'Clear',
    ClearContents: 'Clear Contents',
    ClearAll: 'Clear All',
    ClearFormats: 'Clear Formats',
    ClearHyperlinks: 'Clear Hyperlinks',
    LightRedFillWithDarkRedText: 'Light Red Fill with Dark Red Text',
    YellowFillWithDarkYellowText: 'Yellow Fill with Dark Yellow Text',
    GreenFillWithDarkGreenText: 'Green Fill with Dark Green Text',
    RedFill: 'Red Fill',
    RedText: 'Red Text',
    Duplicate: 'Duplicate',
    Unique: 'Unique',
    And: 'and',
    WebPage: 'Web Page',
    ThisDocument: 'This Document',
    DisplayText: 'Display Text',
    Url: 'URL',
    CellReference: 'Cell Reference',
    DefinedNames: 'Defined Names',
    EnterTheTextToDisplay: 'Enter the text to display',
    EnterTheUrl: 'Enter the URL',
    Image: 'Image',
    ConditionalFormatting: 'Conditional Formatting',
    BlueDataBar: 'Blue Data Bar',
    GreenDataBar: 'Green Data Bar',
    RedDataBar: 'Red Data Bar',
    OrangeDataBar: 'Orange Data Bar',
    LightBlueDataBar: 'Light blue Data Bar',
    PurpleDataBar: 'Purple Data Bar',
    GYRColorScale: 'Green - Yellow - Red Color Scale',
    RYGColorScale: 'Red - Yellow - Green Color Scale',
    GWRColorScale: 'Green - White - Red Color Scale',
    RWGColorScale: 'Red - White - Green Color Scale',
    BWRColorScale: 'Blue - White - Red Color Scale',
    RWBColorScale: 'Red - White - Blue Color Scale',
    WRColorScale: 'White - Red Color Scale',
    RWColorScale: 'Red - White Color Scale',
    GWColorScale: 'Green - White Color Scale',
    WGColorScale: 'White - Green Color Scale',
    GYColorScale: 'Green - Yellow Color Scale',
    YGColorScale: 'Yellow - Green Color Scale',
    ThreeArrowsColor: '3 Arrows (Colored)',
    ThreeArrowsGray: '3 Arrows (Gray)',
    ThreeTriangles: '3 Triangles',
    FourArrowsColor: '4 Arrows (Gray)',
    FourArrowsGray: '4 Arrows (Colored)',
    FiveArrowsColor: '5 Arrows (Gray)',
    FiveArrowsGray: '5 Arrows (Colored)',
    ThreeTrafficLights1: '3 Traffic Lights (Unrimmed)',
    ThreeTrafficLights2: '3 Traffic Lights (Rimmed)',
    ThreeSigns: '3 Signs',
    FourTrafficLights: '4 Traffic Lights',
    RedToBlack: 'Red To Black',
    ThreeSymbols1: '3 Symbols (Circled)',
    ThreeSymbols2: '3 Symbols (Uncircled)',
    ThreeFlags: '3 Flags',
    ThreeStars: '3 Stars',
    FourRatings: '4 Ratings',
    FiveQuarters: '5 Quarters',
    FiveRatings: '5 Ratings',
    FiveBoxes: '5 Boxes',
    Chart: 'Chart',
    Column: 'Column',
    Bar: 'Bar',
    Area: 'Area',
    Pie: 'Pie',
    Doughnut: 'Doughnut',
    PieAndDoughnut: 'Pie/Doughnut',
    Line: 'Line',
    LineMarker: 'Line with Markers',
    Radar: 'Radar',
    Scatter: 'Scatter',
    ChartDesign: 'Chart Design',
    ClusteredColumn: 'Clustered Column',
    StackedColumn: 'Stacked Column',
    StackedColumn100: '100% Stacked Column',
    ClusteredBar: 'Clustered Bar',
    StackedBar: 'Stacked Bar',
    StackedBar100: '100% Stacked Bar',
    StackedArea: 'Stacked Area',
    StackedArea100: '100% Stacked Area',
    StackedLine: 'Stacked Line',
    StackedLineMarker: 'Stacked Line with Markers',
    StackedLine100: '100% Stacked Line',
    StackedLine100Marker: '100% Stacked Line with Markers',
    AddChartElement: 'Add Chart Element',
    Axes: 'Axes',
    AxisTitle: 'Axis Title',
    ChartTitle: 'Chart Title',
    DataLabels: 'Data Labels',
    Gridlines: 'Gridlines',
    Legends: 'Legends',
    PrimaryHorizontal: 'Primary Horizontal',
    PrimaryVertical: 'Primary Vertical',
    None: 'None',
    AboveChart: 'Above Chart',
    Center: 'Center',
    InsideEnd: 'Inside End',
    InsideBase: 'Inside Base',
    OutsideEnd: 'OutSide End',
    PrimaryMajorHorizontal: 'Primary Major Horizontal',
    PrimaryMajorVertical: 'Primary Major Vertical',
    PrimaryMinorHorizontal: 'Primary Minor Horizontal',
    PrimaryMinorVertical: 'Primary Minor Vertical',
    Right: 'Right',
    Left: 'Left',
    Bottom: 'Bottom',
    Top: 'Top',
    SwitchRowColumn: 'Switch Row/Column',
    ChartTheme: 'Chart Theme',
    ChartType: 'Chart Type',
    Material: 'Material',
    Fabric: 'Fabric',
    Bootstrap: 'Bootstrap',
    HighContrastLight: 'HighContrast Light',
    MaterialDark: 'Material Dark',
    FabricDark: 'Fabric Dark',
    HighContrast: 'HighContrast',
    BootstrapDark: 'Bootstrap Dark',
    Bootstrap4: 'Bootstrap4',
    Bootstrap5Dark: 'Bootstrap5 Dark',
    Bootstrap5: 'Bootstrap5',
    Tailwind: 'Tailwind',
    TailwindDark: 'Tailwind Dark',
    Tailwind3: 'Tailwind 3',
    Tailwind3Dark: 'Tailwind 3 Dark',
    VerticalAxisTitle: 'Vertical Axis Title',
    HorizontalAxisTitle: 'Horizontal Axis Title',
    EnterTitle: 'Enter Title',
    ProtectWorkbook: 'Protect Workbook',
    Password: 'Password (optional):',
    EnterThePassword: 'Enter the password',
    ConfirmPassword: 'Confirm Password',
    EnterTheConfirmPassword: 'Re-enter your password',
    PasswordAlert: 'Confirmation password is not identical',
    UnprotectWorkbook: 'Unprotect Workbook',
    UnprotectPasswordAlert: 'The password you supplied is not correct.',
    IncorrectPassword: 'Unable to open the file or worksheet with the given password',
    PasswordAlertMsg: 'Please enter the password',
    ConfirmPasswordAlertMsg: 'Please enter the confirm password',
    IsProtected: 'is protected',
    PDF: 'PDF Document',
    AutoFillMergeAlertMsg: 'To do this, all the merged cells need to be the same size.',
    FillSeries: 'Fill Series',
    CopyCells: 'Copy Cells',
    FillFormattingOnly: 'Fill Formatting Only',
    FillWithoutFormatting: 'Fill Without Formatting',
    CustomFormat: 'Custom Number Formats',
    CustomFormatPlaceholder: 'Type or Select a custom format',
    CustomFormatTypeList: 'Type',
    UnprotectWorksheet: 'Unprotect Sheet',
    ReEnterPassword: 'Re-enter password to proceed',
    SheetPassword: 'Password to unprotect sheet:',
    Fluent: 'Fluent',
    FluentDark: 'Fluent Dark',
    Fluent2: 'Fluent 2',
    Fluent2Dark: 'Fluent 2 Dark',
    Fluent2HighContrast: 'Fluent 2 HighContrast',
    Material3: 'Material 3',
    Material3Dark: 'Material 3 Dark',
    CellReferenceTypoError: 'We found a typo in your cell reference. Do you want to correct this reference as follows?',
    InvalidFormulaError: 'We found that you typed a formula which is invalid.',
    InvalidArguments: 'We found that you typed a formula with an invalid arguments.',
    EmptyExpression: 'We found that you typed a formula with an empty expression.',
    MismatchedParenthesis: 'We found that you typed a formula with one or more missing opening or closing parenthesis.',
    ImproperFormula: 'We found that you typed a formula which is improper.',
    WrongNumberOfArguments: 'We found that you typed a formula with a wrong number of arguments.',
    Requires3Arguments: 'We found that you typed a formula which requires 3 arguments.',
    MismatchedStringQuotes: 'We found that you typed a formula with a mismatched quotes.',
    FormulaCircularRef: 'We found that you typed a formula with a circular reference.',
    AddCurrentSelection: 'Add current selection to filter',
    ExternalWorkbook: 'An imported excel file contains an external workbook reference. Do you want to import that file?'
};

/**
 * The function used to update Dom using requestAnimationFrame.
 *
 * @param  {Function} fn - Function that contains the actual action
 * @returns {void}
 * @hidden
 */
function getUpdateUsingRaf(fn) {
    requestAnimationFrame(() => {
        fn();
    });
}
/**
 * The function used to remove the dom element children.
 *
 * @param  {Element} parent - Specify the parent
 * @returns {void} - The function used to get colgroup width based on the row index.
 * @hidden
 */
function removeAllChildren(parent) {
    while (parent.firstChild) {
        parent.removeChild(parent.firstChild);
    }
}
/**
 * The function used to get colgroup width based on the row index.
 *
 * @param  {number} index - Specify the index
 * @returns {number} - The function used to get colgroup width based on the row index.
 * @hidden
 */
function getColGroupWidth(index) {
    let width = 30;
    if (index.toString().length > 3) {
        width = index.toString().length * 10;
    }
    return width;
}
let scrollAreaWidth = null;
let textLineHeight = 1.24;
/**
 * @hidden
 * @returns {number} - To get scrollbar width
 */
function getScrollBarWidth() {
    if (scrollAreaWidth !== null) {
        return scrollAreaWidth;
    }
    const htmlDivNode = document.createElement('div');
    let result = 0;
    htmlDivNode.style.cssText = 'width:100px;height: 100px;overflow: scroll;position: absolute;top: -9999px;';
    document.body.appendChild(htmlDivNode);
    result = (htmlDivNode.offsetWidth - htmlDivNode.clientWidth) | 0;
    document.body.removeChild(htmlDivNode);
    return scrollAreaWidth = result;
}
/**
 * @hidden
 * @param {HTMLElement} element - Specify the element.
 * @param {string[]} classList - Specify the classList
 * @param {number} scaleY - Specify the scaleY value.
 * @returns {number} - get Siblings Height
 */
function getSiblingsHeight(element, classList, scaleY = 1) {
    classList = classList || ['e-ribbon', 'e-formula-bar-panel', 'e-sheet-tab-panel', 'e-header-toolbar'];
    const previous = getHeightFromDirection(element, 'previous', classList, scaleY);
    const next = getHeightFromDirection(element, 'next', classList, scaleY);
    return previous + next;
}
/**
 * @param {HTMLElement} element - Specify the element.
 * @param {string} direction - Specify the direction.
 * @param {string[]} classList - Specify the classList.
 * @param {number} scaleY - Specify the scaleY value.
 * @returns {number} - get Height FromDirection
 */
function getHeightFromDirection(element, direction, classList, scaleY) {
    let sibling = (element)[direction + 'ElementSibling'];
    let result = 0;
    while (sibling) {
        if (classList.some((value) => sibling.classList.contains(value))) {
            result += (sibling.getBoundingClientRect().height * scaleY);
        }
        sibling = (sibling)[direction + 'ElementSibling'];
    }
    return result;
}
/**
 * @hidden
 * @param {Spreadsheet} context - Specify the spreadsheet.
 * @param {number[]} range - Specify the range.
 * @param {boolean} isModify - Specify the boolean value.
 * @returns {boolean} - Returns boolean value.
 */
function inView(context, range, isModify) {
    if (context.scrollSettings.enableVirtualization) {
        const sheet = context.getActiveSheet();
        const frozenRow = context.frozenRowCount(sheet);
        const frozenCol = context.frozenColCount(sheet);
        const topIdx = context.viewport.topIndex + frozenRow;
        const leftIdx = context.viewport.leftIndex + frozenCol;
        const bottomIdx = context.viewport.bottomIndex;
        const rightIdx = context.viewport.rightIndex;
        if (sheet.frozenRows || sheet.frozenColumns) {
            if (context.insideViewport(range[0], range[1]) || context.insideViewport(range[2], range[3])) {
                return true;
            }
        }
        else if (topIdx <= range[0] && bottomIdx >= range[2] && leftIdx <= range[1] && rightIdx >= range[3]) {
            return true;
        }
        let inView = false;
        if (isModify) {
            if (range[0] < topIdx && range[2] < topIdx || range[0] > bottomIdx && range[2] > bottomIdx) {
                return false;
            }
            else {
                if (range[0] < topIdx && range[2] > topIdx && range[0] >= frozenRow) {
                    range[0] = topIdx;
                    inView = true;
                }
                if (range[2] > bottomIdx) {
                    range[2] = bottomIdx;
                    inView = true;
                }
            }
            if (range[1] < leftIdx && range[3] < leftIdx || range[1] > rightIdx && range[3] > rightIdx) {
                return false;
            }
            else {
                if (range[1] < leftIdx && range[3] > leftIdx && range[1] >= frozenCol) {
                    range[1] = leftIdx;
                    inView = true;
                }
                if (range[3] > rightIdx) {
                    range[3] = rightIdx;
                    inView = true;
                }
            }
        }
        return inView;
    }
    else {
        return true;
    }
}
/**
 * To get the top left cell position in viewport.
 *
 * @hidden
 * @param {SheetModel} sheet - Specify the sheet.
 * @param {number[]} indexes - Specify the indexes.
 * @param {number} frozenRow - Specify the frozen row.
 * @param {number} frozenColumn - Specify the frozen column
 * @param {number} freezeScrollHeight - Specify the freeze scroll height
 * @param {number} freezeScrollWidth - Specify the freeze scroll width
 * @param {number} rowHdrWidth - Specify the row header width
 * @param {boolean} isOverlay - Specify the overlay.
 * @returns {number} - To get the top left cell position in viewport.
 */
function getCellPosition(sheet, indexes, frozenRow, frozenColumn, freezeScrollHeight, freezeScrollWidth, rowHdrWidth, isOverlay) {
    let i;
    const offset = { left: { idx: 0, size: 0 }, top: { idx: 0, size: 0 } };
    let top = offset.top.size;
    let left = offset.left.size;
    for (i = offset.top.idx; i < indexes[0]; i++) {
        if (frozenRow) {
            if (frozenRow - 1 < indexes[0] && i < frozenRow) {
                continue;
            }
        }
        top += getRowHeight(sheet, i, !isOverlay);
    }
    for (i = offset.left.idx; i < indexes[1]; i++) {
        if (frozenColumn && frozenColumn - 1 < indexes[1] && i < frozenColumn) {
            continue;
        }
        left += getColumnWidth(sheet, i, null, !isOverlay);
    }
    if (frozenRow && indexes[0] < frozenRow) {
        if (sheet.showHeaders) {
            top += 30;
        }
        if (freezeScrollHeight) {
            top -= freezeScrollHeight;
        }
    }
    if (frozenColumn && indexes[1] < frozenColumn) {
        if (sheet.showHeaders) {
            left += rowHdrWidth ? rowHdrWidth : 30;
        }
        if (freezeScrollWidth) {
            left -= freezeScrollWidth;
        }
    }
    return { top: top, left: left };
}
/**
 * @param {Spreadsheet} parent - Specify the parent
 * @param {HTMLElement} ele - Specify the element
 * @param {number[]} range - Specify the range
 * @param {string} cls - Specify the class name
 * @param {boolean} preventAnimation - Specify the preventAnimation.
 * @param {boolean} isMultiRange - Specify the multi range selection.
 * @param {boolean} removeCls - Specify to remove the class from selection.
 * @returns {void} - To set the position
 * @hidden
 */
function setPosition(parent, ele, range, cls = 'e-selection', preventAnimation, isMultiRange, removeCls) {
    const sheet = parent.getActiveSheet();
    if (sheet.frozenRows || sheet.frozenColumns) {
        let content;
        const frozenRow = parent.frozenRowCount(sheet);
        const frozenCol = parent.frozenColCount(sheet);
        if (cls === 'e-active-cell') {
            if (range[0] < frozenRow || range[1] < frozenCol) {
                ele.style.display = 'none';
                content = range[0] < frozenRow && range[1] < frozenCol ? parent.getSelectAllContent() :
                    (range[0] < frozenRow ? parent.getColumnHeaderContent() : parent.getRowHeaderContent());
                let rangeEle = content.querySelector('.' + cls);
                if (!rangeEle) {
                    rangeEle = ele.cloneNode(true);
                    content.appendChild(rangeEle);
                }
                ele = rangeEle;
                locateElem(parent, ele, range, sheet, parent.enableRtl, frozenRow, frozenCol, preventAnimation, true, parent.viewport.beforeFreezeHeight, parent.viewport.beforeFreezeWidth, parent.sheetModule.colGroupWidth);
            }
            else {
                locateElem(parent, ele, range, sheet, parent.enableRtl, frozenRow, frozenCol, preventAnimation);
            }
            if (ele.style.display) {
                ele.style.display = '';
            }
            removeRangeEle(parent.getSelectAllContent(), content, 'e-active-cell');
            removeRangeEle(parent.getColumnHeaderContent(), content, 'e-active-cell');
            removeRangeEle(parent.getRowHeaderContent(), content, 'e-active-cell');
        }
        else if (cls === 'e-autofill') {
            let contentElem;
            const freezeRow = parent.frozenRowCount(sheet);
            const freezeCol = parent.frozenColCount(sheet);
            if (range[0] < freezeRow || range[1] < freezeCol) {
                ele.style.display = 'none';
                contentElem = range[0] < freezeRow && range[1] < freezeCol ? parent.getSelectAllContent() :
                    (range[0] < freezeRow ? parent.getColumnHeaderContent() : parent.getRowHeaderContent());
                let rangeEle = contentElem.querySelector('.' + cls);
                if (!rangeEle) {
                    rangeEle = ele.cloneNode(true);
                    contentElem.appendChild(rangeEle);
                }
                ele = rangeEle;
                locateElem(parent, ele, range, sheet, parent.enableRtl, freezeRow, freezeCol, preventAnimation, true, parent.viewport.beforeFreezeHeight, parent.viewport.beforeFreezeWidth, parent.sheetModule.colGroupWidth, 'e-autofill');
            }
            else {
                locateElem(parent, ele, range, sheet, parent.enableRtl, freezeRow, freezeCol, preventAnimation, false, 0, 0, 0, 'e-autofill');
            }
            if (ele.style.display) {
                ele.style.display = '';
            }
            removeRangeEle(parent.getSelectAllContent(), contentElem, 'e-autofill');
            removeRangeEle(parent.getColumnHeaderContent(), contentElem, 'e-autofill');
            removeRangeEle(parent.getRowHeaderContent(), contentElem, 'e-autofill');
        }
        else if (cls === 'e-filloption') {
            let contentElem;
            const freezeRow = parent.frozenRowCount(sheet);
            const freezeCol = parent.frozenColCount(sheet);
            if ((range[0] < freezeRow || range[1] < freezeCol)) {
                if (range[3] + 1 === freezeCol && range[2] + 1 > freezeRow) {
                    locateElem(parent, parent.getMainContent().querySelector('.e-filloption'), range, sheet, parent.enableRtl, freezeRow, freezeCol, preventAnimation, false, 0, 0, 0, 'e-filloption', true, { left: -4 });
                }
                else if (range[2] + 1 === freezeRow && range[3] + 1 > freezeCol) {
                    locateElem(parent, parent.getMainContent().querySelector('.e-filloption'), range, sheet, parent.enableRtl, freezeRow, freezeCol, preventAnimation, false, 0, 0, 0, 'e-filloption', true, { top: -4 });
                }
                else if (range[3] + 1 === freezeCol && range[2] + 1 < freezeRow) { // for upper side
                    contentElem = parent.getColumnHeaderContent();
                    const rangeElem = contentElem.querySelector('.' + cls);
                    if (!rangeElem) {
                        parent.notify(getautofillDDB, { id: parent.element.id + '_autofilloptionbtn', appendElem: contentElem });
                    }
                    ele = parent.autofillModule.autoFillDropDown.element;
                    locateElem(parent, ele, range, sheet, parent.enableRtl, freezeRow, freezeCol, preventAnimation, false, 0, 0, 0, 'e-filloption', true, { left: -4 });
                }
                else if (range[2] + 1 === freezeRow && range[3] + 1 === freezeCol) { // corner cell
                    locateElem(parent, parent.getMainContent().querySelector('.e-filloption'), range, sheet, parent.enableRtl, freezeRow, freezeCol, preventAnimation, false, 0, 0, 0, 'e-filloption', true, { top: -4, left: -4 });
                }
                else {
                    contentElem = range[0] < freezeRow && range[1] < freezeCol ? parent.getSelectAllContent() :
                        (range[0] < freezeRow ? parent.getColumnHeaderContent() : parent.getRowHeaderContent());
                    const rangeEle = contentElem.querySelector('.' + cls);
                    if (!rangeEle) {
                        parent.notify(getautofillDDB, { id: parent.element.id + '_autofilloptionbtn', appendElem: contentElem });
                    }
                    ele = parent.autofillModule.autoFillDropDown.element;
                    locateElem(parent, ele, range, sheet, parent.enableRtl, freezeRow, freezeCol, preventAnimation, true, parent.viewport.
                        beforeFreezeHeight, parent.viewport.beforeFreezeWidth, parent.sheetModule.colGroupWidth, 'e-filloption', true);
                }
            }
            else {
                locateElem(parent, parent.getMainContent().querySelector('.e-filloption'), range, sheet, parent.enableRtl, freezeRow, freezeCol, preventAnimation, false, 0, 0, 0, 'e-filloption', true);
            }
            if (ele.style.display) {
                ele.style.display = '';
            }
            removeRangeEle(parent.getSelectAllContent(), contentElem, 'e-filloption');
            removeRangeEle(parent.getColumnHeaderContent(), contentElem, 'e-filloption');
            removeRangeEle(parent.getRowHeaderContent(), contentElem, 'e-filloption');
        }
        else {
            const swapRange = getSwapRange(range);
            if (swapRange[0] < frozenRow || swapRange[1] < frozenCol) {
                if (ele && !ele.classList.contains('e-multi-range')) {
                    ele.classList.add('e-hide');
                }
                const ranges = [];
                if (swapRange[0] < frozenRow && swapRange[1] < frozenCol) {
                    if (swapRange[2] < frozenRow && swapRange[3] < frozenCol) {
                        ranges.push(range);
                        if (!isMultiRange) {
                            removeRangeEle(parent.getColumnHeaderContent(), content, cls, true);
                            removeRangeEle(parent.getRowHeaderContent(), content, cls, true);
                        }
                    }
                    else if (swapRange[2] > frozenRow - 1) {
                        if (swapRange[3] < frozenCol) {
                            if (!isMultiRange) {
                                removeRangeEle(parent.getColumnHeaderContent(), content, cls, true);
                            }
                            ranges.push([swapRange[0], swapRange[1], frozenRow - 1, swapRange[3]]);
                            ranges.push([frozenRow, swapRange[1], swapRange[2], swapRange[3]]);
                        }
                        else {
                            ranges.push([swapRange[0], swapRange[1], frozenRow - 1, frozenCol - 1]);
                            ranges.push([frozenRow, swapRange[1], swapRange[2], frozenCol - 1]);
                            ranges.push([swapRange[0], frozenCol, frozenRow - 1, swapRange[3]]);
                            ranges.push([frozenRow, frozenCol, swapRange[2], swapRange[3]]);
                        }
                    }
                    else {
                        if (swapRange[2] < frozenRow) {
                            ranges.push([swapRange[0], swapRange[1], swapRange[2], frozenCol - 1]);
                            ranges.push([swapRange[0], frozenCol, swapRange[2], swapRange[3]]);
                            if (!isMultiRange) {
                                removeRangeEle(parent.getRowHeaderContent(), content, cls, true);
                            }
                        }
                        else {
                            ranges.push([frozenRow, swapRange[1], swapRange[2], frozenCol - 1]);
                            ranges.push([swapRange[0], swapRange[1], frozenRow - 1, frozenCol - 1]);
                            ranges.push([frozenRow, frozenCol, swapRange[2], swapRange[3]]);
                            ranges.push([swapRange[0], frozenCol, frozenRow - 1, swapRange[3]]);
                        }
                    }
                }
                else if (swapRange[0] < frozenRow) {
                    if (swapRange[2] < frozenRow) {
                        ranges.push(range);
                        if (!isMultiRange) {
                            removeRangeEle(parent.getRowHeaderContent(), content, cls, true);
                        }
                    }
                    else {
                        ranges.push([swapRange[0], swapRange[1], frozenRow - 1, swapRange[3]]);
                        ranges.push([frozenRow, swapRange[1], swapRange[2], swapRange[3]]);
                        if (!isMultiRange) {
                            removeRangeEle(parent.getSelectAllContent(), content, cls, true);
                            removeRangeEle(parent.getRowHeaderContent(), content, cls, true);
                        }
                    }
                }
                else {
                    if (swapRange[3] < frozenCol) {
                        ranges.push(range);
                        if (!isMultiRange) {
                            removeRangeEle(parent.getSelectAllContent(), content, cls, true);
                        }
                    }
                    else {
                        ranges.push([swapRange[0], swapRange[1], swapRange[2], frozenCol - 1]);
                        ranges.push([swapRange[0], frozenCol, swapRange[2], swapRange[3]]);
                        if (!isMultiRange) {
                            removeRangeEle(parent.getSelectAllContent(), content, cls, true);
                            removeRangeEle(parent.getColumnHeaderContent(), content, cls, true);
                        }
                    }
                }
                let removeEle;
                ranges.forEach((rng) => {
                    let zIndex;
                    if (rng[2] < frozenRow && rng[3] < frozenCol) {
                        content = parent.getSelectAllContent();
                    }
                    else {
                        if (frozenRow || frozenCol) {
                            const selectAllEle = parent.getSelectAllContent();
                            if (selectAllEle) {
                                zIndex = selectAllEle.style.zIndex;
                            }
                        }
                        if (rng[2] < frozenRow) {
                            content = parent.getColumnHeaderContent();
                        }
                        else if (rng[3] < frozenCol) {
                            content = parent.getRowHeaderContent();
                        }
                        else {
                            content = parent.getMainContent();
                            if (frozenRow && !zIndex) {
                                const colHdrEle = parent.getColumnHeaderContent();
                                if (colHdrEle) {
                                    zIndex = colHdrEle.style.zIndex;
                                }
                            }
                            if (frozenCol && !zIndex) {
                                const rowHdrEle = parent.getRowHeaderContent();
                                if (rowHdrEle) {
                                    zIndex = rowHdrEle.style.zIndex;
                                }
                            }
                        }
                    }
                    let rangeEle;
                    if (cls === 'e-copy-indicator' || cls === 'e-range-indicator') {
                        rangeEle = ele.cloneNode(true);
                        content.appendChild(rangeEle);
                        if (frozenRow) {
                            if (rng[2] + 1 === frozenRow) {
                                ranges.forEach((subRng) => {
                                    if (subRng !== rng) {
                                        removeEle = rangeEle.getElementsByClassName('e-bottom')[0];
                                        if (removeEle && subRng[0] === frozenRow) {
                                            detach(removeEle);
                                        }
                                    }
                                });
                            }
                            if (rng[0] === frozenRow && content.parentElement.classList.contains('e-main-panel')) {
                                ranges.forEach((subRng) => {
                                    if (subRng !== rng) {
                                        removeEle = rangeEle.getElementsByClassName('e-top')[0];
                                        if (removeEle && subRng[2] + 1 === frozenRow) {
                                            detach(removeEle);
                                        }
                                    }
                                });
                            }
                        }
                        if (frozenCol) {
                            if (rng[3] + 1 === frozenCol) {
                                ranges.forEach((subRng) => {
                                    if (subRng !== rng) {
                                        removeEle = rangeEle.getElementsByClassName('e-right')[0];
                                        if (removeEle && subRng[1] === frozenCol) {
                                            detach(removeEle);
                                        }
                                    }
                                });
                            }
                            if (rng[1] === frozenCol && (content.classList.contains('e-sheet-content') || content.classList.contains('e-column-header'))) {
                                ranges.forEach((subRng) => {
                                    if (subRng !== rng) {
                                        removeEle = rangeEle.getElementsByClassName('e-left')[0];
                                        if (removeEle && subRng[3] + 1 === frozenCol) {
                                            detach(removeEle);
                                        }
                                    }
                                });
                            }
                        }
                    }
                    else {
                        rangeEle = content.querySelector('.' + cls);
                        if (!rangeEle) {
                            rangeEle = ele.cloneNode(true);
                            if (isMultiRange && !rangeEle.classList.contains('e-multi-range')) {
                                rangeEle.classList.add('e-multi-range');
                            }
                            content.appendChild(rangeEle);
                        }
                        if (removeCls) {
                            rangeEle.classList.remove(cls);
                        }
                    }
                    if (frozenRow || frozenCol) {
                        if (zIndex) {
                            rangeEle.style.zIndex = zIndex;
                        }
                        else if (rangeEle.style.zIndex) {
                            rangeEle.style.zIndex = '';
                        }
                    }
                    locateElem(parent, rangeEle, rng, sheet, parent.enableRtl, frozenRow, frozenCol, preventAnimation, false, parent.viewport.beforeFreezeHeight, parent.viewport.beforeFreezeWidth, parent.sheetModule.colGroupWidth);
                    if (rangeEle.classList.contains('e-hide')) {
                        rangeEle.classList.remove('e-hide');
                    }
                });
            }
            else {
                if (!isMultiRange) {
                    removeRangeEle(parent.getSelectAllContent(), null, cls, true);
                    removeRangeEle(parent.getColumnHeaderContent(), null, cls, true);
                    removeRangeEle(parent.getRowHeaderContent(), null, cls, true);
                }
                locateElem(parent, ele, range, sheet, parent.enableRtl, frozenRow, frozenCol, preventAnimation);
                if (cls === 'e-range-indicator' || !parent.getMainContent().querySelector('.' + cls)) {
                    parent.getMainContent().appendChild(ele);
                }
                if (ele.classList.contains('e-hide')) {
                    ele.classList.remove('e-hide');
                }
                if (removeCls) {
                    ele.classList.remove(cls);
                }
            }
        }
    }
    else {
        const promise = locateElem(parent, ele, range, sheet, parent.enableRtl, 0, 0, preventAnimation);
        if (ele && !parent.getMainContent().querySelector('.' + cls)) {
            parent.getMainContent().appendChild(ele);
        }
        return promise;
    }
}
/**
 * @param {Element} content - Specify the content element.
 * @param {HTMLElement} checkEle - Specify the element.
 * @param {string} cls - Specify the class name.
 * @param {string} isSelection - Specify the selection element.
 * @param {string} removeCls - Specify to remove class from element.
 * @returns {void} - remove element with given range
 */
function removeRangeEle(content, checkEle, cls, isSelection, removeCls) {
    if (isSelection || content !== checkEle) {
        if (removeCls) {
            const collection = content.querySelectorAll('.' + cls);
            let i = 0;
            while (i < collection.length) {
                collection[i].classList.remove(cls);
                i++;
            }
        }
        else {
            const ele = content.querySelector('.' + cls);
            if (ele && !ele.classList.contains('e-multi-range')) {
                detach(ele);
            }
        }
    }
}
/**
 * Position element with given range
 *
 * @hidden
 * @param {Spreadsheet} parent - Specify the parent.
 * @param {HTMLElement} ele - Specify the element.
 * @param {number[]} range - specify the range.
 * @param {SheetModel} sheet - Specify the sheet.
 * @param {boolean} isRtl - Specify the boolean value.
 * @param {number} frozenRow - Specidy the frozen row.
 * @param {number} frozenColumn - Specify the frozen column
 * @param {boolean} preventAnimation - Specify the preventAnimation.
 * @param {boolean} isActiveCell - Specidy the boolean value.
 * @param {number} freezeScrollHeight - Specify the freeze scroll height
 * @param {number} freezeScrollWidth - Specify the freeze scroll width
 * @param {number} rowHdrWidth - Specify the row header width
 * @param {number} cls - Specify the class
 * @param {number} isFillOptShow - Specify the fill option
 * @param {number} freezeFillOpt - Specifies the fill option
 * @param {number} freezeFillOpt.top - Specifies the fill option
 * @param {number} freezeFillOpt.left - Specifies the fill option
 * @returns {void} - Position element with given range
 */
function locateElem(parent, ele, range, sheet, isRtl, frozenRow, frozenColumn, preventAnimation, isActiveCell, freezeScrollHeight, freezeScrollWidth, rowHdrWidth, cls, isFillOptShow, freezeFillOpt) {
    const swapRange = getSwapRange(range);
    const cellPosition = getCellPosition(sheet, swapRange, frozenRow, frozenColumn, freezeScrollHeight, freezeScrollWidth, rowHdrWidth);
    const startIndex = [skipHiddenIdx(sheet, 0, true), skipHiddenIdx(sheet, 0, true, 'columns')];
    let height;
    let width;
    if (parent.scrollSettings.isFinite) {
        height = swapRange[0] >= sheet.rowCount ? 0 : getRowsHeight(sheet, swapRange[0], swapRange[2] < sheet.rowCount ? swapRange[2] : sheet.rowCount - 1, true);
        width = swapRange[1] >= sheet.colCount ? 0 : getColumnsWidth(sheet, swapRange[1], swapRange[3] < sheet.colCount ? swapRange[3] : sheet.colCount - 1, true);
    }
    else {
        height = getRowsHeight(sheet, swapRange[0], swapRange[2], true);
        width = getColumnsWidth(sheet, swapRange[1], swapRange[3], true);
    }
    const isRowSelected = (swapRange[1] === 0 && swapRange[3] === sheet.colCount - 1);
    const isColSelected = (swapRange[0] === 0 && swapRange[2] === sheet.rowCount - 1);
    let top = 0;
    let tdiff = -5;
    let ldiff = -5;
    let left = 0;
    let otdiff = 6;
    let oldiff = 6;
    if (isNullOrUndefined(cls)) {
        const attrs = {
            'top': (swapRange[0] === startIndex[0] ? cellPosition.top : cellPosition.top - getDPRValue(1)) + 'px',
            'height': height && height + (swapRange[0] === startIndex[0] ? 0 : getDPRValue(1)) + 'px',
            'width': width && width + (swapRange[1] === startIndex[1] ? 0 : getDPRValue(1)) + (isActiveCell
                && frozenColumn && swapRange[1] < frozenColumn && swapRange[3] >= frozenColumn ? 1 : 0) + 'px'
        };
        attrs[isRtl ? 'right' : 'left'] = (swapRange[1] === startIndex[1] ? cellPosition.left : cellPosition.left - 1) + 'px';
        if (ele) {
            const promise = setStyleAttribute([{ element: ele, attrs: attrs }], preventAnimation);
            return promise;
        }
    }
    else {
        if (isRowSelected) {
            tdiff = -5;
            ldiff = -2;
            otdiff = 6;
            oldiff = 3;
        }
        if (isColSelected) {
            ldiff = -5;
            tdiff = 0;
            otdiff = 1;
            oldiff = 6;
        }
        if (!isColSelected) {
            top += height;
        }
        if (!isRowSelected) {
            left += width;
        }
        top += Math.round(cellPosition.top) + tdiff;
        left += Math.round(cellPosition.left) + ldiff;
        let attrs = {};
        if (isFillOptShow) {
            removeClass([ele], 'e-hide');
            top = freezeFillOpt && freezeFillOpt.top ? freezeFillOpt.top : top;
            left = freezeFillOpt && freezeFillOpt.left ? freezeFillOpt.left : left;
            attrs = {
                'top': top + otdiff + 'px'
            };
            attrs[isRtl ? 'right' : 'left'] = left + oldiff + 'px';
            if (ele) {
                setStyleAttribute([{ element: ele, attrs: attrs }], preventAnimation);
            }
        }
        else {
            attrs = {
                'top': top + 'px'
            };
            attrs[isRtl ? 'right' : 'left'] = left + 'px';
            if (ele) {
                setStyleAttribute([{ element: ele, attrs: attrs }], preventAnimation);
            }
        }
    }
}
/**
 * To update element styles using request animation frame
 *
 * @hidden
 * @param {StyleType[]} styles - Specify the styles
 * @param {boolean} preventAnimation - Specify the preventAnimation.
 * @returns {void} - To update element styles using request animation frame
 */
function setStyleAttribute(styles, preventAnimation) {
    const promise = new Promise((resolve) => {
        const setStyleFn = () => {
            styles.forEach((style) => {
                setStyleAttribute$1(style.element, style.attrs);
                resolve();
            });
        };
        if (preventAnimation) {
            setStyleFn();
        }
        else {
            requestAnimationFrame(() => setStyleFn());
        }
    });
    return promise;
}
/**
 * @hidden
 * @returns {string} - to get Start Event
 */
function getStartEvent() {
    return (Browser.isPointer ? 'pointerdown' : 'mousedown touchstart');
}
/**
 * @hidden
 * @returns {string} - to get Move Event
 */
function getMoveEvent() {
    return (Browser.isPointer ? 'pointermove' : 'mousemove touchmove');
}
/**
 * @hidden
 * @returns {string} - Returns string value.
 */
function getEndEvent() {
    return (Browser.isPointer ? 'pointerup' : 'mouseup touchend');
}
/**
 * @hidden
 * @param {Event} e - To specify the event.
 * @returns {boolean} - Returns boolean value.
 */
function isTouchStart(e) {
    return e.type === 'touchstart' || (e.type === 'pointerdown' && e.pointerType === 'touch');
}
/**
 * @hidden
 * @param {Event} e - To specify the event.
 * @returns {boolean} - Returns boolean value.
 */
function isTouchMove(e) {
    return e.type === 'touchmove' || (e.type === 'pointermove' && e.pointerType === 'touch');
}
/**
 * @hidden
 * @param {Event} e - To specify the event.
 * @returns {boolean} - Returns boolean value.
 */
function isTouchEnd(e) {
    return e.type === 'touchend' || (e.type === 'pointerup' && e.pointerType === 'touch');
}
/**
 * @hidden
 * @param {TouchEvent | MouseEvent} e - To specify the mouse and touch event.
 * @returns {number} - To get client value
 */
function isMouseDown(e) {
    return e && (e.type === 'mousedown' || e.type === 'pointerdown');
}
/**
 * @param {MouseEvent} e - Specify the event.
 * @returns {boolean} - To get boolean value.
 * @hidden
 */
function isMouseMove(e) {
    return e && (e.type === 'mousemove' || e.type === 'pointermove');
}
/**
 * @param {MouseEvent} e - Specify the event.
 * @returns {boolean} - To get boolean value
 * @hidden
 */
function isMouseUp(e) {
    return e && (e.type === 'mouseup' || e.type === 'pointerup');
}
/**
 * @param {number} keyCode - Specify  the keycode.
 * @returns {boolean} - to get boolean value.
 * @hidden
 */
function isNavigationKey(keyCode) {
    return (keyCode === keyCodes.UP) || (keyCode === keyCodes.DOWN) || (keyCode === keyCodes.LEFT)
        || (keyCode === keyCodes.RIGHT);
}
/**
 * @param {MouseEvent | TouchEvent} e - To specify the mouse or touch event.
 * @returns {number} - To get client X value.
 * @hidden
 */
function getClientX(e) {
    return e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
}
/**
 * @hidden
 * @param {MouseEvent | TouchEvent} e - To specify the mouse and touch event.
 * @returns {number} - To get client value
 */
function getClientY(e) {
    return e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
}
/**
 * To get the `pageX` value from the mouse or touch event.
 *
 * @param {MouseEvent | TouchEvent} e - Specifies the mouse or touch event.
 * @returns {number} - Return the `pageX` value.
 * @hidden
 */
function getPageX(e) {
    return e.changedTouches ? e.changedTouches[0].pageX : e.pageX;
}
/**
 * To get the `pageY` value from the mouse or touch event.
 *
 * @param {MouseEvent | TouchEvent} e - Specifies the mouse or touch event.
 * @returns {number} - Return the `pageY` value.
 * @hidden
 */
function getPageY(e) {
    return e.changedTouches ? e.changedTouches[0].pageY : e.pageY;
}
/**
 * Get even number based on device pixel ratio
 *
 * @param {number} value - Specify the number
 * @param {boolean} preventDecrease - Specify the boolean value
 * @returns {number} - To get DPR value
 * @hidden
 */
function getDPRValue(value, preventDecrease) {
    if (window.devicePixelRatio % 1 > 0) {
        const pointValue = (value * window.devicePixelRatio) % 1;
        return value + (pointValue ? (((pointValue > 0.5 || preventDecrease) ? (1 - pointValue) : -1 * pointValue)
            / window.devicePixelRatio) : 0);
    }
    else {
        return value;
    }
}
const config = {
    role: 'role',
    selected: 'aria-selected',
    multiselectable: 'aria-multiselectable',
    busy: 'aria-busy',
    colcount: 'aria-colcount'
};
/**
 * @hidden
 * @param {HTMLElement} target - specify the target.
 * @param {IAriaOptions<boolean>} options - Specify the options.
 * @returns {void} -  to set Aria Options
 */
function setAriaOptions(target, options) {
    const props = Object.keys(options);
    props.forEach((name) => {
        if (target) {
            target.setAttribute(config[`${name}`], options[`${name}`]);
        }
    });
}
/**
 * @hidden
 * @param {HTMLElement} element - specify the element.
 * @param {Object} component - Specify the component.
 * @returns {void} -  to destroy the component.
 */
function destroyComponent(element, component) {
    if (element) {
        const compObj = getComponent(element, component);
        if (compObj) {
            compObj.destroy();
        }
    }
}
/**
 * @hidden
 * @param {number} idx - Specify the index
 * @param {number} index - Specify the index
 * @param {string} value - Specify the value.
 * @param {boolean} isCol - Specify the boolean value.
 * @param {Spreadsheet} parent - Specify the parent.
 * @returns {void} - To set resize.
 */
function setResize(idx, index, value, isCol, parent) {
    let curEle;
    let curEleH;
    let curEleC;
    let preEle;
    let preEleH;
    let preEleC;
    let nxtEle;
    let nxtEleH;
    let nxtEleC;
    const sheet = parent.getActiveSheet();
    const frozenRow = parent.frozenRowCount(sheet);
    const frozenCol = parent.frozenColCount(sheet);
    if (isCol) {
        const header = idx < frozenCol ? parent.getSelectAllContent() : parent.getColumnHeaderContent();
        curEle = header.getElementsByTagName('th')[index];
        curEleH = header.getElementsByTagName('col')[index];
        curEleC = (idx < frozenCol ? parent.getRowHeaderContent() : parent.getMainContent()).getElementsByTagName('col')[index];
    }
    else {
        curEle = curEleH = frozenRow || frozenCol ? parent.getRow(idx, null, frozenCol - 1) :
            parent.getRow(idx, parent.getRowHeaderTable());
        curEleH.style.height = parseInt(value, 10) > 0 ? getDPRValue(parseInt(value, 10)) + 'px' : '2px';
        curEleC = parent.getRow(idx, null, frozenCol);
        curEleC.style.height = parseInt(value, 10) > 0 ? getDPRValue(parseInt(value, 10)) + 'px' : '0px';
        let hdrFntSize;
        if (sheet.showHeaders) {
            const hdrRow = parent.getRowHeaderContent().getElementsByClassName('e-row');
            const hdrClone = [];
            hdrClone[0] = hdrRow[index].getElementsByTagName('td')[0].cloneNode(true);
            hdrFntSize = findMaxValue(parent.getRowHeaderTable(), hdrClone, false, parent) + 1;
        }
        const contentRow = parent.getMainContent().getElementsByClassName('e-row');
        const contentClone = [];
        let eleTextHeight = 0;
        let eleMaxHeight = 0;
        const rIdx = idx;
        for (let idx = 0; idx < contentRow[index].getElementsByTagName('td').length; idx++) {
            const td = contentRow[index].getElementsByTagName('td')[idx];
            contentClone[idx] = td.cloneNode(true);
            const cell = getCell(rIdx, idx, sheet, false, true);
            eleTextHeight = cell.value ? getTextHeight(parent, cell.style) : eleTextHeight;
            eleMaxHeight = eleMaxHeight < eleTextHeight ? eleTextHeight : eleMaxHeight;
            if (td.getElementsByClassName('e-cf-databar')[0]) {
                const rHeight = Number((curEleC.style.height).split('px')[0]);
                parent.notify(applyCF, { indexes: [rIdx, idx], cell: cell, ele: td, isRender: true,
                    resizedRowHeight: rHeight });
            }
        }
        const cntFntSize = eleMaxHeight + 1;
        const fntSize = hdrFntSize >= cntFntSize ? hdrFntSize : cntFntSize;
        if (parseInt(curEleC.style.height, 10) < fntSize ||
            (curEle && curEle.classList.contains('e-reach-fntsize') && parseInt(curEleC.style.height, 10) === fntSize)) {
            if (sheet.showHeaders) {
                curEle.classList.add('e-reach-fntsize');
                curEleH.style.lineHeight = parseInt(value, 10) >= 4 ? ((parseInt(value, 10)) - 4) + 'px' :
                    parseInt(value, 10) > 0 ? ((parseInt(value, 10)) - 1) + 'px' : '0px';
            }
            curEleC.style.lineHeight = parseInt(value, 10) > 0 ? ((parseInt(value, 10)) - 1) + 'px' : '0px';
        }
        else {
            if (curEleH) {
                curEleH.style.removeProperty('line-height');
            }
            curEleC.style.removeProperty('line-height');
            if (curEle && curEle.classList.contains('e-reach-fntsize')) {
                curEle.classList.remove('e-reach-fntsize');
            }
        }
    }
    preEleC = curEleC.previousElementSibling;
    nxtEleC = curEleC.nextElementSibling;
    if (preEleC) {
        if (sheet.showHeaders) {
            preEle = curEle.previousElementSibling;
            preEleH = curEleH.previousElementSibling;
        }
        preEleC = curEleC.previousElementSibling;
    }
    if (nxtEleC) {
        if (sheet.showHeaders) {
            nxtEle = curEle.nextElementSibling;
            nxtEleH = curEleH.nextElementSibling;
        }
        nxtEleC = curEleC.nextElementSibling;
    }
    if (parseInt(value, 10) <= 0 && !(curEleC.classList.contains('e-zero') || curEleC.classList.contains('e-zero-start'))) {
        if (preEleC && nxtEleC) {
            if (isCol) {
                if (sheet.showHeaders) {
                    curEleH.style.width = '2px';
                }
                curEleC.style.width = '0px';
            }
            else {
                if (sheet.showHeaders) {
                    curEleH.style.height = '2px';
                }
                curEleC.style.height = '0px';
            }
            if (preEleC.classList.contains('e-zero-start')) {
                if (sheet.showHeaders) {
                    curEle.classList.add('e-zero-start');
                }
                curEleC.classList.add('e-zero-start');
            }
            else {
                if (sheet.showHeaders) {
                    curEle.classList.add('e-zero');
                }
                curEleC.classList.add('e-zero');
            }
            if (nxtEle && !nxtEle.classList.contains('e-zero') && !nxtEle.classList.contains('e-zero-last')) {
                if (sheet.showHeaders) {
                    curEle.classList.add('e-zero-last');
                }
                curEleC.classList.add('e-zero-last');
            }
            if (preEleC.classList.contains('e-zero-last')) {
                if (sheet.showHeaders) {
                    preEle.classList.remove('e-zero-last');
                }
                preEleC.classList.remove('e-zero-last');
            }
            if (sheet.showHeaders && preEle.classList.contains('e-zero')) {
                if (curEle.classList.contains('e-zero-end')) {
                    setWidthAndHeight(preEleH, -2, isCol);
                }
                else {
                    setWidthAndHeight(preEleH, -2, isCol);
                }
            }
            else if (sheet.showHeaders) {
                setWidthAndHeight(preEleH, -1, isCol);
            }
            if (sheet.showHeaders && preEle.classList.contains('e-zero-start')) {
                setWidthAndHeight(curEleH, -1, isCol);
            }
            if (sheet.showHeaders && nxtEle.classList.contains('e-zero')) {
                if (curEle.classList.contains('e-zero-start')) {
                    while (nxtEle) {
                        if (nxtEle.classList.contains('e-zero') && (parseInt(nxtEleH.style.height, 10) !== 0 && !isCol) ||
                            (parseInt(nxtEleH.style.width, 10) !== 0 && isCol)) {
                            if (isCol) {
                                curEleH.style.width = parseInt(curEleH.style.width, 10) - 1 + 'px';
                                nxtEleH.style.width = parseInt(nxtEleH.style.width, 10) - 1 + 'px';
                            }
                            else {
                                curEleH.style.height = parseInt(curEleH.style.height, 10) - 1 + 'px';
                                nxtEleH.style.height = parseInt(nxtEleH.style.height, 10) - 1 + 'px';
                            }
                            nxtEle.classList.remove('e-zero');
                            nxtEle.classList.add('e-zero-start');
                            break;
                        }
                        else {
                            let nxtIndex;
                            nxtEle.classList.remove('e-zero');
                            nxtEle.classList.add('e-zero-start');
                            if (isCol) {
                                nxtIndex = parseInt(nxtEle.getAttribute('aria-colindex'), 10) - 1;
                                nxtEle = parent.getColHeaderTable().getElementsByTagName('th')[nxtIndex + 1];
                                nxtEleH = parent.getColHeaderTable().getElementsByTagName('col')[nxtIndex + 1];
                            }
                            else {
                                nxtIndex = parseInt(nxtEle.getAttribute('aria-rowindex'), 10) - 1;
                                nxtEle = parent.getRowHeaderTable().getElementsByTagName('tr')[nxtIndex + 1];
                                nxtEleH = parent.getRowHeaderTable().getElementsByTagName('tr')[nxtIndex + 1];
                            }
                        }
                    }
                }
                else {
                    setWidthAndHeight(curEleH, -2, isCol);
                }
            }
            else if (sheet.showHeaders) {
                if (nxtEle.classList.contains('e-zero-end')) {
                    if (isCol) {
                        curEleH.style.width = '0px';
                    }
                    else {
                        curEleH.style.height = '0px';
                    }
                }
                else {
                    setWidthAndHeight(nxtEleH, -1, isCol);
                }
            }
        }
        else if (preEleC) {
            if (isCol) {
                if (sheet.showHeaders) {
                    curEleH.style.width = '1px';
                }
                curEleC.style.width = '0px';
            }
            else {
                if (sheet.showHeaders) {
                    curEleH.style.height = '1px';
                }
                curEleC.style.height = '0px';
            }
            if (sheet.showHeaders) {
                curEle.classList.add('e-zero-end');
            }
            curEleC.classList.add('e-zero-end');
            if (sheet.showHeaders) {
                curEle.classList.add('e-zero-last');
            }
            curEleC.classList.add('e-zero-last');
            if (sheet.showHeaders && preEle.classList.contains('e-zero')) {
                setWidthAndHeight(preEleH, -2, isCol);
            }
            else {
                setWidthAndHeight(preEleH, -1, isCol);
            }
        }
        else if (nxtEle) {
            curEle.classList.add('e-zero-start');
            curEleC.classList.add('e-zero-start');
            if (!nxtEle.classList.contains('e-zero')) {
                curEle.classList.add('e-zero-last');
                curEleC.classList.add('e-zero-last');
            }
            if (isCol) {
                curEleH.style.width = '1px';
                curEleC.style.width = '0px';
            }
            else {
                curEleH.style.height = '1px';
                curEleC.style.height = '0px';
            }
            if (sheet.showHeaders && nxtEle.classList.contains('e-zero')) {
                while (nxtEle) {
                    if (nxtEle.classList.contains('e-zero') && (parseInt(nxtEleH.style.width, 10) !== 0
                        && isCol) || (parseInt(nxtEleH.style.height, 10) !== 0 && !isCol)) {
                        if (isCol) {
                            nxtEleH.style.width = parseInt(nxtEleH.style.width, 10) - 1 + 'px';
                            curEleH.style.width = parseInt(curEleH.style.width, 10) - 1 + 'px';
                        }
                        else {
                            nxtEleH.style.height = parseInt(nxtEleH.style.height, 10) - 1 + 'px';
                            curEleH.style.height = parseInt(curEleH.style.height, 10) - 1 + 'px';
                        }
                        nxtEle.classList.add('e-zero-start');
                        nxtEle.classList.remove('e-zero');
                        break;
                    }
                    else {
                        let nxtIndex;
                        nxtEle.classList.add('e-zero-start');
                        nxtEle.classList.remove('e-zero');
                        if (isCol) {
                            nxtIndex = parseInt(nxtEle.getAttribute('aria-colindex'), 10) - 1;
                            nxtEleH = parent.getColHeaderTable().getElementsByTagName('col')[nxtIndex + 1];
                            nxtEle = parent.getColHeaderTable().getElementsByTagName('th')[nxtIndex + 1];
                        }
                        else {
                            nxtIndex = parseInt(nxtEle.getAttribute('aria-rowindex'), 10) - 1;
                            nxtEleH = parent.getRowHeaderTable().getElementsByTagName('tr')[nxtIndex + 1];
                            nxtEle = parent.getRowHeaderTable().getElementsByTagName('tr')[nxtIndex + 1];
                        }
                    }
                }
            }
            else if (sheet.showHeaders) {
                setWidthAndHeight(nxtEleH, -1, isCol);
            }
        }
    }
    else if (parseInt(value, 10) > 0) {
        const DPRValue = getDPRValue(parseInt(value, 10)) + 'px';
        if (isCol) {
            curEleH.style.width = DPRValue;
            curEleC.style.width = DPRValue;
        }
        else {
            curEleH.style.height = DPRValue;
            curEleC.style.height = DPRValue;
        }
        if (sheet.showHeaders && preEle && nxtEle) {
            if (preEle.classList.contains('e-zero')) {
                if (curEle.classList.contains('e-zero')) {
                    if (isCol) {
                        preEleH.style.width = parseInt(preEleH.style.width, 10) + 2 + 'px';
                        curEleH.style.width = parseInt(curEleH.style.width, 10) - 1 + 'px';
                    }
                    else {
                        preEleH.style.height = parseInt(preEleH.style.height, 10) + 2 + 'px';
                        curEleH.style.height = parseInt(curEleH.style.height, 10) - 1 + 'px';
                    }
                }
                else {
                    setWidthAndHeight(curEleH, -1, isCol);
                }
            }
            else {
                if (curEle.classList.contains('e-zero')) {
                    setWidthAndHeight(preEleH, 1, isCol);
                }
                else {
                    if (curEle.classList.contains('e-zero-start')) {
                        if (isCol) {
                            preEleH.style.width = parseInt(preEleH.style.width, 10) + 1 + 'px';
                            curEleH.style.width = parseInt(curEleH.style.width, 10) - 1 + 'px';
                        }
                        else {
                            preEleH.style.height = parseInt(preEleH.style.height, 10) + 1 + 'px';
                            curEleH.style.height = parseInt(curEleH.style.height, 10) - 1 + 'px';
                        }
                    }
                }
            }
            if (nxtEle.classList.contains('e-zero')) {
                setWidthAndHeight(curEleH, -1, isCol);
            }
            else {
                if (curEle.classList.contains('e-zero') || curEle.classList.contains('e-zero-start')) {
                    setWidthAndHeight(nxtEleH, 1, isCol);
                }
            }
            if (curEle.classList.contains('e-zero')) {
                curEle.classList.remove('e-zero');
            }
            if (curEle.classList.contains('e-zero-start')) {
                curEle.classList.remove('e-zero-start');
            }
            if (curEleC.classList.contains('e-zero')) {
                curEleC.classList.remove('e-zero');
            }
            if (curEleC.classList.contains('e-zero-start')) {
                curEleC.classList.remove('e-zero-start');
            }
            if (curEle.classList.contains('e-zero-last')) {
                curEle.classList.remove('e-zero-last');
            }
            if (curEleC.classList.contains('e-zero-last')) {
                curEleC.classList.remove('e-zero-last');
            }
            if (preEle.classList.contains('e-zero') || preEle.classList.contains('e-zero-start')) {
                preEle.classList.add('e-zero-last');
                preEleC.classList.add('e-zero-last');
            }
        }
        else if (sheet.showHeaders && preEle) {
            if (preEle.classList.contains('e-zero')) {
                if (curEle.classList.contains('e-zero')) {
                    if (isCol) {
                        curEleH.style.width = parseInt(curEleH.style.width, 10) - 1 + 'px';
                        preEleH.style.width = parseInt(preEleH.style.width, 10) + 2 + 'px';
                    }
                    else {
                        curEleH.style.height = parseInt(curEleH.style.height, 10) - 1 + 'px';
                        preEleH.style.height = parseInt(preEleH.style.height, 10) + 2 + 'px';
                    }
                }
                else {
                    setWidthAndHeight(curEleH, -1, isCol);
                }
            }
            else {
                if (curEle.classList.contains('e-zero')) {
                    setWidthAndHeight(preEleH, 1, isCol);
                }
                else {
                    setWidthAndHeight(curEleH, -1, isCol);
                }
            }
            if (curEle.classList.contains('e-zero')) {
                curEle.classList.remove('e-zero');
            }
            if (curEle.classList.contains('e-zero-end')) {
                curEle.classList.remove('e-zero-end');
            }
            if (curEleC.classList.contains('e-zero')) {
                curEleC.classList.remove('e-zero');
            }
            if (curEleC.classList.contains('e-zero-end')) {
                curEleC.classList.remove('e-zero-end');
            }
        }
        else if (sheet.showHeaders && nxtEle) {
            if (nxtEle.classList.contains('e-zero')) {
                setWidthAndHeight(curEleH, -1, isCol);
            }
            else if (curEle.classList.contains('e-zero-start')) {
                setWidthAndHeight(nxtEleH, 1, isCol);
                curEle.classList.remove('e-zero-start');
            }
            if (curEle.classList.contains('e-zero')) {
                curEle.classList.remove('e-zero');
            }
            if (curEleC.classList.contains('e-zero')) {
                curEleC.classList.remove('e-zero');
            }
            if (curEle.classList.contains('e-zero-start')) {
                curEle.classList.remove('e-zero-start');
            }
            if (curEleC.classList.contains('e-zero-start')) {
                curEleC.classList.remove('e-zero-start');
            }
        }
    }
}
/**
 * @hidden
 * @param {HTMLElement} trgt - Specify the target element.
 * @param {number} value - specify the number.
 * @param {boolean} isCol - Specify the boolean vlaue.
 * @returns {void} -  to set width and height.
 */
function setWidthAndHeight(trgt, value, isCol) {
    if (isCol) {
        trgt.style.width = parseInt(trgt.style.width, 10) + value + 'px';
    }
    else {
        trgt.style.height = parseInt(trgt.style.height, 10) + value + 'px';
    }
}
/**
 * @hidden
 * @param {number} lineHeight - Specify the line height for other culture text.
 * @returns {void} -  to set the line height for other culture text.
 */
function setTextLineHeight(lineHeight) {
    textLineHeight = lineHeight;
}
/**
 * @hidden
 * @param {HTMLElement} table - Specify the table.
 * @param {HTMLElement[]} text - specify the text.
 * @param {boolean} isCol - Specifyt boolean value
 * @param {Spreadsheet} parent - Specify the parent.
 * @param {string} prevData - specify the prevData.
 * @param {boolean} isWrap - Specifyt boolean value
 * @returns {number} - To find maximum value.
 */
function findMaxValue(table, text, isCol, parent, prevData, isWrap) {
    const myTableDiv = parent.createElement('div', { className: parent.element.className, styles: 'display: block' });
    const myTable = parent.createElement('table', {
        className: table.className + 'e-resizetable',
        styles: 'width: auto;height: auto'
    });
    const myTr = parent.createElement('tr');
    if (isCol) {
        text.forEach((element) => {
            const tr = myTr.cloneNode();
            tr.appendChild(element);
            myTable.appendChild(tr);
        });
    }
    else {
        text.forEach((element) => {
            myTr.appendChild(element.cloneNode(true));
        });
        myTable.appendChild(myTr);
    }
    myTableDiv.appendChild(myTable);
    document.body.appendChild(myTableDiv);
    let offsetWidthValue;
    let offsetHeightValue;
    const tableMaxWidth = myTable.getBoundingClientRect().width;
    const tableMaxHeight = myTable.getBoundingClientRect().height;
    if (!isWrap) {
        offsetHeightValue = tableMaxHeight;
        offsetWidthValue = tableMaxWidth;
    }
    else {
        if (isCol && parseInt(prevData, 10) > tableMaxWidth) {
            offsetWidthValue = tableMaxWidth;
        }
        else {
            offsetWidthValue = parseInt(prevData, 10);
        }
        if (!isCol && parseInt(prevData, 10) > tableMaxHeight) {
            offsetHeightValue = tableMaxHeight;
        }
        else {
            offsetHeightValue = parseInt(prevData, 10);
        }
    }
    document.body.removeChild(myTableDiv);
    if (isCol) {
        return Math.ceil(offsetWidthValue);
    }
    else {
        return Math.ceil(offsetHeightValue);
    }
}
/**
 * @hidden
 * @param {CollaborativeEditArgs} options - Specify the collaborative edit arguments.
 * @param {Spreadsheet} spreadsheet - specify the spreadsheet.
 * @param {boolean} isRedo - Specifyt the boolean value.
 * @param {CollaborativeEditArgs[]} undoCollections - Specify the undo collections.
 * @param {object} actionEventArgs - Specify the actionEventArgs.
 * @param {ActionEventArgs} actionEventArgs.eventArgs - Specify the eventArgs.
 * @param {boolean} isRecursive - Specify the recursive.
 * @returns {void} - To update the Action.
 */
function updateAction(options, spreadsheet, isRedo, undoCollections, actionEventArgs, isRecursive) {
    /* eslint-disable-next-line  @typescript-eslint/no-explicit-any */
    const eventArgs = options.eventArgs;
    let chartElement;
    let element;
    let args;
    let promise;
    let sortArgs;
    let cellEvtArgs;
    let cellValue;
    let clipboardPromise;
    let model;
    let sheet;
    let column;
    let row;
    let addressInfo;
    let isFromUpdateAction = options.isFromUpdateAction || isUndefined$1(isRedo);
    if (options.isUndoRedo) {
        isFromUpdateAction = options.isFromUpdateAction = true;
        delete options.isUndoRedo;
        spreadsheet.notify(performUndoRedo, options);
        return;
    }
    if (isFromUpdateAction && !isRecursive) {
        const address = eventArgs.address || eventArgs.range || eventArgs.pastedRange
            || (eventArgs.addressCollection && eventArgs.addressCollection[0]) || eventArgs.dataRange;
        const sheetIndex = isUndefined$1(eventArgs.sheetIndex) ? isUndefined$1(eventArgs.sheetIdx)
            ? isUndefined$1(eventArgs.activeSheetIndex) ? address ? getSheetIndexFromAddress(spreadsheet, address)
                : spreadsheet.activeSheetIndex : eventArgs.activeSheetIndex : eventArgs.sheetIdx : eventArgs.sheetIndex;
        if (sheetIndex !== spreadsheet.activeSheetIndex) {
            const args = {
                sheet: getSheet(spreadsheet, sheetIndex), resolveAfterFullDataLoaded: true,
                indexes: [0, 0, 0, 0], promise: new Promise((resolve) => { resolve((() => { })()); })
            };
            spreadsheet.notify(updateSheetFromDataSource, args);
            args.promise.then(() => {
                updateAction(options, spreadsheet, isRedo, undoCollections, actionEventArgs, true);
            });
            return;
        }
    }
    let cellSaveArgs;
    let addrInfo;
    let clearArgs;
    const sheetIndex = getSheetIndexFromId(spreadsheet, eventArgs.index);
    let cellIndexes;
    switch (options.action) {
        case 'sorting':
            args = {
                range: options.eventArgs.range,
                sortOptions: options.eventArgs.sortOptions,
                cancel: false
            };
            promise = new Promise((resolve) => { resolve((() => { })()); });
            sortArgs = { args: args, promise: promise };
            spreadsheet.notify(initiateSort, sortArgs);
            sortArgs.promise.then((args) => {
                spreadsheet.serviceLocator.getService('cell').refreshRange(getIndexesFromAddress(args.range));
            });
            break;
        case 'cellSave':
            cellEvtArgs = options.eventArgs;
            cellSaveArgs = { element: cellEvtArgs.element, value: cellEvtArgs.value,
                oldValue: cellEvtArgs.oldValue, address: cellEvtArgs.address, displayText: cellEvtArgs.displayText,
                formula: cellEvtArgs.formula, originalEvent: cellEvtArgs.originalEvent, format: cellEvtArgs.format };
            cellValue = cellSaveArgs.formula ? { formula: cellSaveArgs.formula } : { value: cellSaveArgs.value };
            spreadsheet.updateCellInfo(cellValue, cellSaveArgs.address, false, options.eventArgs, isRedo);
            if (isRedo === true) {
                spreadsheet.trigger('cellSave', cellSaveArgs);
            }
            break;
        case 'addNote':
        case 'editNote':
        case 'deleteNote':
            cellIndexes = getIndexesFromAddress(options.eventArgs.address);
            if (isRedo) {
                updateCell(spreadsheet, spreadsheet.getActiveSheet(), { rowIdx: cellIndexes[0], colIdx: cellIndexes[1], preventEvt: true,
                    cell: { notes: options.eventArgs.notes } });
                spreadsheet.serviceLocator.getService('cell').refreshRange(getIndexesFromAddress(eventArgs.address), false, false, true, true, isImported(spreadsheet));
            }
            break;
        case 'cellDelete':
            addrInfo = getAddressInfo(spreadsheet, options.eventArgs.address);
            clearRange(spreadsheet, addrInfo.indices, addrInfo.sheetIndex);
            break;
        case 'format':
            if (eventArgs.requestType === 'CellFormat') {
                if (eventArgs.style && eventArgs.style.border && !isNullOrUndefined(eventArgs.borderType)) {
                    const style = {};
                    Object.assign(style, eventArgs.style, null, true);
                    eventArgs.style.border = undefined;
                    spreadsheet.notify(setCellFormat, { style: eventArgs.style, refreshRibbon: true, range: eventArgs.range,
                        onActionUpdate: true, isUndoRedo: true });
                    eventArgs.style.border = style.border;
                    spreadsheet.setBorder(eventArgs.style, eventArgs.range, eventArgs.borderType);
                    eventArgs.style = style;
                }
                else {
                    spreadsheet.notify(setCellFormat, { style: eventArgs.style, refreshRibbon: true, range: eventArgs.range,
                        onActionUpdate: true, isUndoRedo: true });
                }
                getUpdateUsingRaf(() => spreadsheet.selectRange(spreadsheet.getActiveSheet().selectedRange));
            }
            else {
                spreadsheet.numberFormat(eventArgs.format, eventArgs.range);
            }
            break;
        case 'clipboard':
            clipboardPromise = new Promise((resolve) => { resolve((() => { })()); });
            addressInfo = spreadsheet.getAddressInfo(eventArgs.copiedRange);
            spreadsheet.notify(eventArgs.copiedInfo.isCut ? cut : copy, {
                range: addressInfo.indices, sId: getSheet(spreadsheet, addressInfo.sheetIndex).id,
                promise: promise, invokeCopy: true, isPublic: true, isFromUpdateAction: true
            });
            clipboardPromise.then(() => spreadsheet.notify(paste, {
                range: getIndexesFromAddress(eventArgs.pastedRange),
                sIdx: getSheetIndex(spreadsheet, getSheetNameFromAddress(eventArgs.pastedRange)),
                type: eventArgs.type, isAction: false, isInternal: true, isFromUpdateAction: true
            }));
            break;
        case 'gridLines':
            spreadsheet.setSheetPropertyOnMute(spreadsheet.sheets[eventArgs.sheetIdx], 'showGridLines', eventArgs.isShow);
            spreadsheet.serviceLocator.getService('sheet').toggleGridlines();
            spreadsheet.notify(refreshRibbonIcons, null);
            break;
        case 'headers':
            spreadsheet.setSheetPropertyOnMute(spreadsheet.sheets[eventArgs.sheetIdx], 'showHeaders', eventArgs.isShow);
            spreadsheet.serviceLocator.getService('sheet').showHideHeaders();
            spreadsheet.notify(refreshRibbonIcons, null);
            break;
        case 'resize':
        case 'resizeToFit':
            if (isFromUpdateAction) {
                sheet = spreadsheet.sheets[eventArgs.sheetIndex];
                column = getColumn(sheet, eventArgs.index);
                row = getRow(sheet, eventArgs.index);
                if ((eventArgs.isCol && column && column.hidden) || (row && row.hidden)) {
                    spreadsheet.notify(hideShow, { startIndex: eventArgs.index, endIndex: eventArgs.index, hide: false, isCol: eventArgs.isCol,
                        sheetIndex: eventArgs.sheetIndex });
                }
            }
            if (eventArgs.isCol) {
                if (eventArgs.hide === undefined) {
                    spreadsheet.setColWidth(isFromUpdateAction && !isUndefined$1(isRedo) ? eventArgs.oldWidth :
                        eventArgs.width, eventArgs.index, eventArgs.sheetIndex);
                }
                else {
                    spreadsheet.hideColumn(eventArgs.index, eventArgs.index, eventArgs.hide);
                }
            }
            else {
                if (eventArgs.hide === undefined) {
                    spreadsheet.setRowHeight(isFromUpdateAction && !isUndefined$1(isRedo) ? eventArgs.oldHeight :
                        eventArgs.height, eventArgs.index, eventArgs.sheetIndex);
                }
                else {
                    spreadsheet.hideRow(eventArgs.index, eventArgs.index, eventArgs.hide);
                }
                spreadsheet.notify(refreshFilterCellsOnResize, { rowIndex: eventArgs.index });
            }
            break;
        case 'renameSheet':
            spreadsheet.setSheetPropertyOnMute(spreadsheet.sheets[sheetIndex], 'name', eventArgs.value);
            spreadsheet.notify(sheetNameUpdate, {
                items: spreadsheet.element.querySelector('.e-sheet-tabs-items'),
                value: eventArgs.value,
                idx: sheetIndex
            });
            break;
        case 'hideSheet':
            spreadsheet.notify(hideSheet, { sheetIndex: eventArgs.sheetIndex });
            break;
        case 'showSheet':
            spreadsheet.notify(showSheet, eventArgs);
            break;
        case 'removeSheet':
            spreadsheet.notify(removeSheetTab, { index: eventArgs.index, isAction: true, count: eventArgs.sheetCount, clicked: true });
            break;
        case 'gotoSheet':
            spreadsheet.notify(goToSheet, { selectedIndex: eventArgs.currentSheetIndex, previousIndex: eventArgs.previousSheetIndex });
            break;
        case 'moveSheet':
            moveSheet(spreadsheet, eventArgs.position, eventArgs.sheetIndexes, null, isFromUpdateAction);
            break;
        case 'wrap':
            wrap(options.eventArgs.address, options.eventArgs.wrap, spreadsheet);
            break;
        case 'hideShow':
            if (eventArgs.isCol) {
                spreadsheet.notify(hideShow, { startIndex: eventArgs.startIndex, endIndex: eventArgs.endIndex, isCol: true,
                    hide: isRedo === false ? !eventArgs.hide : eventArgs.hide, sheetIndex: eventArgs.sheetIndex,
                    hiddenIndexes: eventArgs.hiddenIndexes });
            }
            else {
                spreadsheet.notify(hideShow, { startIndex: eventArgs.startIndex, endIndex: eventArgs.endIndex,
                    hide: isRedo === false ? !eventArgs.hide : eventArgs.hide, sheetIndex: eventArgs.sheetIndex });
            }
            break;
        case 'replace':
            spreadsheet.notify(replace, { value: eventArgs.compareValue, replaceValue: eventArgs.replaceValue,
                sheetIndex: eventArgs.sheetIndex, address: eventArgs.address });
            break;
        case 'replaceAll':
            spreadsheet.notify(replaceAll, eventArgs);
            break;
        case 'filter':
            promise = new Promise((resolve) => { resolve((() => { })()); });
            if (isRedo === false) {
                spreadsheet.notify(initiateFilterUI, { predicates: eventArgs.previousPredicates, range: eventArgs.range, sIdx: eventArgs.sheetIndex, promise: promise, isInternal: true });
            }
            else {
                spreadsheet.notify(initiateFilterUI, { predicates: eventArgs.predicates, range: eventArgs.range, sIdx: eventArgs.sheetIndex, promise: promise,
                    isInternal: true, useFilterRange: eventArgs.useFilterRange, allowHeaderFilter: eventArgs.allowHeaderFilter });
            }
            if (actionEventArgs && !isFromUpdateAction) {
                promise.then(() => {
                    spreadsheet.notify(completeAction, extend({ isUndo: !isRedo, isUndoRedo: !isFromUpdateAction }, actionEventArgs));
                });
            }
            break;
        case 'insert':
            if (options.eventArgs.modelType === 'Sheet') {
                sheet = spreadsheet;
            }
            else {
                sheet = getSheet(spreadsheet, options.eventArgs.activeSheetIndex);
                if (!sheet) {
                    break;
                }
            }
            if (isRedo === false) {
                spreadsheet.notify(deleteModel, { model: sheet, start: options.eventArgs.index, isUndoRedo: true, end: options.eventArgs.index + (options.eventArgs.model.length - 1), modelType: options.eventArgs.modelType });
            }
            else {
                spreadsheet.notify(insertModel, { model: sheet, start: options.eventArgs.index, end: options.eventArgs.index +
                        (options.eventArgs.model.length - 1), modelType: options.eventArgs.modelType, checkCount: isRedo === undefined ?
                        options.eventArgs.sheetCount : null, activeSheetIndex: options.eventArgs.activeSheetIndex, isUndoRedo: true,
                    insertType: options.eventArgs.insertType, isFromUpdateAction: isFromUpdateAction, isRedo: isRedo });
            }
            break;
        case 'delete':
            if (options.eventArgs.modelType === 'Sheet') {
                sheet = spreadsheet;
            }
            else {
                sheet = getSheet(spreadsheet, options.eventArgs.activeSheetIndex);
                if (!sheet) {
                    break;
                }
            }
            if (isRedo === false) {
                spreadsheet.notify(insertModel, { model: sheet, start: options.eventArgs.deletedModel, modelType: options.eventArgs.modelType, columnCellsModel: options.eventArgs.deletedCellsModel, definedNames: options.eventArgs.definedNames, activeSheetIndex: options.eventArgs.activeSheetIndex, isUndoRedo: true,
                    insertType: options.eventArgs.modelType === 'Row' ? 'above' : 'before',
                    conditionalFormats: options.eventArgs.conditionalFormats, prevAction: options.action, freezePane: eventArgs.freezePane });
            }
            else {
                spreadsheet.notify(deleteModel, { model: sheet, start: options.eventArgs.startIndex,
                    checkCount: options.eventArgs.sheetCount, end: options.eventArgs.endIndex, modelType: options.eventArgs.modelType,
                    isUndoRedo: true, insertType: options.eventArgs.modelType === 'Row' ? 'above' : 'before' });
            }
            break;
        case 'validation':
            if (isRedo === false) {
                spreadsheet.notify(removeDataValidation, { range: eventArgs.range });
            }
            else {
                spreadsheet.notify(cellValidation, { rules: { type: eventArgs.type, operator: eventArgs.operator, value1: eventArgs.value1, value2: eventArgs.value2, ignoreBlank: eventArgs.ignoreBlank, inCellDropDown: eventArgs.inCellDropDown },
                    range: eventArgs.range, isAction: true });
            }
            break;
        case 'removeHighlight':
        case 'addHighlight':
            spreadsheet.notify(invalidData, { isRemoveHighlight: options.action === 'removeHighlight', isPublic: true });
            break;
        case 'merge':
            options.eventArgs.isAction = false;
            model = [];
            for (let rIdx = 0, rCnt = eventArgs.model.length; rIdx < rCnt; rIdx++) {
                model.push({ cells: [] });
                for (let cIdx = 0, cCnt = eventArgs.model[rIdx].cells.length; cIdx < cCnt; cIdx++) {
                    model[rIdx].cells[cIdx] = {};
                    Object.assign(model[rIdx].cells[cIdx], eventArgs.model[rIdx].cells[cIdx]);
                }
            }
            if (isRedo === false && eventArgs.mergeCollection) {
                let mergeItem;
                for (let i = 0; i < eventArgs.mergeCollection.length; i++) {
                    mergeItem = { range: null };
                    Object.assign(mergeItem, eventArgs);
                    mergeItem.range = eventArgs.mergeCollection[i];
                    spreadsheet.notify(setMerge, mergeItem);
                }
            }
            else {
                spreadsheet.notify(setMerge, options.eventArgs);
            }
            if (spreadsheet.calculationMode === 'Manual' && isRedo &&
                spreadsheet.getActiveSheet().isSheetCalculated) {
                for (let i = 0; i < eventArgs.model.length; i++) {
                    const cells = eventArgs.model[i].cells;
                    for (let j = 0; j < cells.length; j++) {
                        const value = eventArgs.model[i].cells[j].value;
                        model[i].cells[j].value =
                            (!isNullOrUndefined(value) && value !== '' ? value : model[i].cells[j].value);
                    }
                }
            }
            eventArgs.model = model;
            break;
        case 'clear':
            clearArgs = { options: options.eventArgs, isFromUpdateAction: isFromUpdateAction };
            spreadsheet.notify(clearViewer, clearArgs);
            if (!isFromUpdateAction && clearArgs.cfClearActionArgs) {
                eventArgs.cfClearActionArgs.previousConditionalFormats = clearArgs.cfClearActionArgs.previousConditionalFormats;
                eventArgs.cfClearActionArgs.conditionalFormats = clearArgs.cfClearActionArgs.conditionalFormats;
            }
            break;
        case 'conditionalFormat':
            if (isRedo === false) {
                spreadsheet.notify(clearCFRule, { range: eventArgs.range, cfModel: { type: eventArgs.type, cFColor: eventArgs.cFColor,
                        value: eventArgs.value }, sheetIdx: eventArgs.sheetIdx, isUndoRedo: !eventArgs.cancel,
                    isFromUpdateAction: isFromUpdateAction });
            }
            else {
                spreadsheet.notify(setCFRule, { cfModel: { type: eventArgs.type, cFColor: eventArgs.cFColor, value: eventArgs.value,
                        range: eventArgs.range }, sheetIdx: eventArgs.sheetIdx, isUndoRedo: true, isFromUpdateAction: isFromUpdateAction });
            }
            break;
        case 'clearCF':
            if (isRedo === false) {
                spreadsheet.notify(clearCFRule, { oldCFModel: eventArgs.previousConditionalFormats, updatedCFModel: eventArgs.conditionalFormats,
                    range: eventArgs.selectedRange, isUndo: true, sheetIdx: eventArgs.sheetIdx });
            }
            else {
                const clearArgs = { range: eventArgs.selectedRange, sheetIdx: eventArgs.sheetIdx,
                    isUndoRedo: true, isFromUpdateAction: isFromUpdateAction };
                spreadsheet.notify(clearCFRule, clearArgs);
                if (!isFromUpdateAction) {
                    eventArgs.previousConditionalFormats = clearArgs.oldCFModel;
                    if (clearArgs.updatedCFModel.length) {
                        eventArgs.conditionalFormats = clearArgs.updatedCFModel;
                    }
                    else {
                        delete eventArgs.conditionalFormats;
                    }
                }
            }
            break;
        case 'insertImage':
            if (isRedo === false) {
                spreadsheet.notify(deleteImage, { id: options.eventArgs.id, sheetIdx: options.eventArgs.sheetIndex + 1, range: options.eventArgs.range,
                    preventEventTrigger: true });
            }
            else {
                spreadsheet.notify(createImageElement, { options: { src: options.eventArgs.imageData, height: options.eventArgs.imageHeight, width: options.eventArgs.imageWidth, id: options.eventArgs.id }, range: options.eventArgs.range, isPublic: false,
                    isUndoRedo: true });
            }
            break;
        case 'deleteImage':
            if (isRedo === false) {
                spreadsheet.notify(createImageElement, { options: { src: options.eventArgs.imageData, height: options.eventArgs.imageHeight, width: options.eventArgs.imageWidth, id: options.eventArgs.id }, range: options.eventArgs.address, isPublic: false,
                    isUndoRedo: true });
            }
            else {
                spreadsheet.notify(deleteImage, { id: options.eventArgs.id, range: options.eventArgs.address, preventEventTrigger: true });
            }
            break;
        case 'imageRefresh':
            element = document.getElementById(options.eventArgs.id);
            if (isRedo === false) {
                spreadsheet.notify(refreshImgCellObj, { prevTop: options.eventArgs.currentTop, prevLeft: options.eventArgs.currentLeft, currentTop: options.eventArgs.prevTop, currentLeft: options.eventArgs.prevLeft, id: options.eventArgs.id, currentHeight: options.eventArgs.prevHeight, currentWidth: options.eventArgs.prevWidth, requestType: 'imageRefresh',
                    prevHeight: options.eventArgs.currentHeight, prevWidth: options.eventArgs.currentWidth, isUndoRedo: true });
            }
            else {
                options.eventArgs.isUndoRedo = true;
                spreadsheet.notify(refreshImgCellObj, options.eventArgs);
            }
            if (element) {
                element.style.height = isRedo === false ? options.eventArgs.prevHeight + 'px' : options.eventArgs.currentHeight + 'px';
                element.style.width = isRedo === false ? options.eventArgs.prevWidth + 'px' : options.eventArgs.currentWidth + 'px';
                element.style.top = isRedo === false ? options.eventArgs.prevTop + 'px' : options.eventArgs.currentTop + 'px';
                element.style.left = isRedo === false ? options.eventArgs.prevLeft + 'px' : options.eventArgs.currentLeft + 'px';
            }
            break;
        case 'insertChart':
            if (isRedo === false) {
                spreadsheet.notify(deleteChart, { id: eventArgs.id, range: eventArgs.posRange || eventArgs.range, isUndoRedo: true });
            }
            else {
                const chartOptions = [{
                        type: eventArgs.type, theme: eventArgs.theme,
                        markerSettings: eventArgs.markerSettings, isSeriesInRows: eventArgs.isSeriesInRows,
                        range: eventArgs.range, id: eventArgs.id, height: eventArgs.height, width: eventArgs.width, top: eventArgs.top,
                        left: eventArgs.left
                    }];
                spreadsheet.notify(setChart, {
                    chart: chartOptions, isUndoRedo: false, range: eventArgs.posRange || eventArgs.range, isInitCell: true, isRedo: true
                });
            }
            break;
        case 'deleteChart':
            if (isRedo === false) {
                const chartOpts = [{
                        type: eventArgs.type, theme: eventArgs.theme, markerSettings: eventArgs.markerSettings,
                        dataLabelSettings: eventArgs.dataLabelSettings, title: eventArgs.title,
                        legendSettings: eventArgs.legendSettings, primaryXAxis: eventArgs.primaryXAxis,
                        primaryYAxis: eventArgs.primaryYAxis, isSeriesInRows: eventArgs.isSeriesInRows,
                        range: eventArgs.range, id: eventArgs.id, height: eventArgs.height,
                        width: eventArgs.width, top: eventArgs.top, left: eventArgs.left
                    }];
                spreadsheet.notify(setChart, { chart: chartOpts, isUndoRedo: false, range: eventArgs.posRange, isInitCell: true, isUndo: true });
            }
            else {
                spreadsheet.notify(deleteChart, { id: eventArgs.id, range: eventArgs.range, isUndoRedo: true });
            }
            break;
        case 'chartRefresh':
            chartElement = document.getElementById(options.eventArgs.id);
            if (chartElement) {
                chartElement.style.height = isRedo === false ? options.eventArgs.prevHeight + 'px' : options.eventArgs.currentHeight + 'px';
                chartElement.style.width = isRedo === false ? options.eventArgs.prevWidth + 'px' : options.eventArgs.currentWidth + 'px';
                chartElement.style.top = isRedo === false ? options.eventArgs.prevTop + 'px' : options.eventArgs.currentTop + 'px';
                chartElement.style.left = isRedo === false ? options.eventArgs.prevLeft + 'px' : options.eventArgs.currentLeft + 'px';
            }
            if (isRedo === false) {
                spreadsheet.notify(refreshChartCellObj, extend({}, options.eventArgs, {
                    currentColIdx: options.eventArgs.prevColIdx, currentHeight: options.eventArgs.prevHeight,
                    currentLeft: options.eventArgs.prevLeft, currentRowIdx: options.eventArgs.prevRowIdx,
                    currentTop: options.eventArgs.prevTop, currentWidth: options.eventArgs.prevWidth,
                    prevColIdx: options.eventArgs.currentColIdx, prevHeight: options.eventArgs.currentHeight,
                    prevLeft: options.eventArgs.currentLeft, prevRowIdx: options.eventArgs.currentRowIdx,
                    prevTop: options.eventArgs.currentTop, prevWidth: options.eventArgs.currentWidth, isUndoRedo: true
                }));
                spreadsheet.notify(refreshChartSize, {
                    height: options.eventArgs.prevHeight.toString(),
                    width: options.eventArgs.prevWidth.toString(), overlayEle: chartElement
                });
            }
            else {
                options.eventArgs.isUndoRedo = true;
                spreadsheet.notify(refreshChartCellObj, options.eventArgs);
                spreadsheet.notify(refreshChartSize, {
                    height: options.eventArgs.currentHeight.toString(),
                    width: options.eventArgs.currentWidth.toString(), overlayEle: chartElement
                });
            }
            break;
        case 'chartDesign':
            spreadsheet.notify(chartDesignTab, options.eventArgs);
            break;
        case 'autofill':
            if (isFromUpdateAction && eventArgs.undoArgs) {
                eventArgs.undoArgs.isFromUpdateAction = eventArgs.undoArgs.isUndo = eventArgs.undoArgs.preventEvt = true;
                eventArgs.undoArgs.isPublic = true;
                spreadsheet.notify(performUndoRedo, eventArgs.undoArgs);
            }
            spreadsheet.notify(setAutoFill, { fillRange: options.eventArgs.fillRange, dataRange: options.eventArgs.dataRange,
                fillType: options.eventArgs.fillType, direction: options.eventArgs.direction, cells: options.eventArgs.beforeActionData });
            break;
        case 'removeValidation':
            if (isRedo !== false) {
                spreadsheet.notify(removeDataValidation, { range: eventArgs.range, isCol: eventArgs.isColSelected });
            }
            break;
        case 'addDefinedName':
            if (isRedo === false) {
                spreadsheet.notify(workbookFormulaOperation, { action: 'removeDefinedName', isRemoved: false, definedName: eventArgs.name, scope: eventArgs.scope, isEventTrigger: true });
            }
            else {
                const definedName = { name: eventArgs.name, refersTo: eventArgs.refersTo, scope: eventArgs.scope, comment: eventArgs.comment };
                spreadsheet.notify(workbookFormulaOperation, { action: 'addDefinedName', isAdded: false, definedName: definedName, isEventTrigger: true });
            }
            break;
        case 'hyperlink':
            spreadsheet.notify(setLinkModel, { hyperlink: eventArgs.hyperlink, cell: eventArgs.address, displayText: eventArgs.displayText,
                isUndoRedo: true });
            spreadsheet.serviceLocator.getService('cell').refreshRange(getIndexesFromAddress(eventArgs.address), false, false, false, true, isImported(spreadsheet));
            break;
        case 'removeHyperlink':
            spreadsheet.notify(removeHyperlink, { range: eventArgs.address, preventEventTrigger: true });
            break;
        case 'freezePanes':
            spreadsheet.freezePanes(eventArgs.row, eventArgs.column, eventArgs.sheetIndex);
            break;
        case 'duplicateSheet':
            duplicateSheet(spreadsheet, eventArgs.sheetIndex, null, isFromUpdateAction);
            break;
        case 'protectSheet':
            if (eventArgs.isProtected) {
                spreadsheet.notify(protectsheetHandler, eventArgs);
            }
            else {
                spreadsheet.setSheetPropertyOnMute(getSheet(spreadsheet, eventArgs.sheetIndex), 'password', '');
                spreadsheet.notify(applyProtect, { isActive: true, sheetIndex: eventArgs.sheetIndex });
            }
            break;
        case 'protectWorkbook':
            if (eventArgs.isProtected) {
                spreadsheet.notify(setProtectWorkbook, eventArgs);
            }
            else {
                spreadsheet.notify(removeWorkbookProtection, null);
            }
            break;
        case 'lockCells':
            spreadsheet.notify(setLockCells, eventArgs);
    }
}
/**
 * @hidden
 * @param {Workbook} workbook - Specify the workbook
 * @param {number} rowIdx - specify the roe index
 * @param {number} colIdx - specify the column Index.
 * @param {number} sheetIdx - specify the sheet index.
 * @returns {boolean} - Returns the boolean value.
 */
function hasTemplate(workbook, rowIdx, colIdx, sheetIdx) {
    const sheet = workbook.sheets[sheetIdx];
    const ranges = sheet.ranges;
    let range;
    for (let i = 0, len = ranges.length; i < len; i++) {
        if (ranges[i].template) {
            range = getRangeIndexes(ranges[i].address.length ? ranges[i].address : ranges[i].startCell);
            if (range[0] <= rowIdx && range[1] <= colIdx && range[2] >= rowIdx && range[3] >= colIdx) {
                return true;
            }
        }
    }
    return false;
}
/**
 * Setting row height in view an model.
 *
 * @hidden
 * @param {Spreadsheet} parent - Specify the parent
 * @param {SheetModel} sheet - specify the column width
 * @param {number} height - specify the style.
 * @param {number} rowIdx - specify the rowIdx
 * @param {HTMLElement} row - specify the row
 * @param {HTMLElement} hRow - specify the hRow.
 * @param {boolean} notifyRowHgtChange - specify boolean value.
 * @param {boolean} outsideViewport - Specify whether the row is outside the viewport.
 * @returns {void} - Setting row height in view an model.
 */
function setRowEleHeight(parent, sheet, height, rowIdx, row, hRow, notifyRowHgtChange = true, outsideViewport) {
    const prevHgt = getRowHeight(sheet, rowIdx, true);
    const dprHgt = getDPRValue(height);
    if (!outsideViewport) {
        const frozenCol = parent.frozenColCount(sheet);
        row = row || (sheet.frozenRows ? parent.getRow(rowIdx, null, frozenCol) : parent.getRow(rowIdx));
        if (row) {
            row.style.height = `${dprHgt}px`;
        }
        if (sheet.frozenColumns) {
            hRow = hRow || parent.getRow(rowIdx, null, frozenCol - 1);
        }
        else {
            const frozenRow = parent.frozenRowCount(sheet);
            hRow = hRow || parent.getRow(rowIdx, rowIdx < frozenRow ? parent.sheetModule.getSelectAllTable() : parent.getRowHeaderTable());
        }
        if (hRow) {
            hRow.style.height = `${dprHgt}px`;
        }
    }
    setRowHeight(sheet, rowIdx, height);
    parent.setProperties({ sheets: parent.sheets }, true);
    if (notifyRowHgtChange) {
        parent.notify(rowHeightChanged, { rowIdx: rowIdx, threshold: dprHgt - prevHgt });
    }
}
/**
 * @hidden
 * @param {Workbook} context - Specify the context
 * @param {CellStyleModel} style - specify the style.
 * @param {number} lines - specify the lines
 * @param {number} lineHeight - Specify the line height.
 * @returns {number} - get Text Height
 */
function getTextHeight(context, style, lines = 1, lineHeight) {
    const fontSize = (style && style.fontSize) || context.cellStyle.fontSize;
    const fontSizePx = fontSize.indexOf('pt') > -1 ? parseInt(fontSize, 10) / 0.75 : parseInt(fontSize, 10);
    const hgt = fontSizePx * (lineHeight || getLineHeight(style && style.fontFamily ? style : context.cellStyle)) * lines;
    return Math.ceil(hgt % 1 > 0.9 ? hgt + 1 : hgt); // 0.9 -> if it is nearest value adding extra 1 pixel
}
/**
 * @hidden
 * @param {CellStyleModel} style - cell style
 * @returns {number} - returns line height
 */
function getLineHeight(style) {
    let lineHeight = textLineHeight;
    if (style) {
        if (style.fontFamily === 'Arial Black' || style.fontFamily === 'Comic Sans MS') {
            lineHeight = 1.44;
        }
        else if (style.fontFamily === '"Segoe UI", sans-serif') {
            lineHeight = 1.36;
        }
    }
    return lineHeight;
}
/**
 * @hidden
 * @param {string} text - Specify the text
 * @param {CellStyleModel} style - specify the style.
 * @param {CellStyleModel} parentStyle - specify the parentStyle
 * @param  {boolean} preventDpr - specify the preventDpr.
 * @returns {number} - get Text Width
 */
function getTextWidth(text, style, parentStyle, preventDpr) {
    if (!style) {
        style = parentStyle;
    }
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    context.font = (style.fontStyle || parentStyle.fontStyle) + ' ' + (style.fontWeight || parentStyle.fontWeight) + ' '
        + (style.fontSize || parentStyle.fontSize) + ' ' + (style.fontFamily || parentStyle.fontFamily);
    return preventDpr ? context.measureText(text).width : getDPRValue(context.measureText(text).width, true);
}
/**
 * @hidden
 * @param {string} text - Specify the text
 * @param {number} colwidth - specify the column width
 * @param {CellStyleModel} style - specify the style.
 * @param {CellStyleModel} parentStyle - specify the parentStyle
 * @returns {number} - Setting maximum height while doing formats and wraptext
 */
function getLines(text, colwidth, style, parentStyle) {
    let width;
    let splitTextArr;
    let lWidth;
    let cWidth;
    let prevWidth = 0;
    const textArr = text.toString().split(' ');
    const spaceWidth = getTextWidth(' ', style, parentStyle);
    let hypenWidth;
    let lines;
    let cnt = 0;
    let lineCnt = 0;
    let maxCnt = 0;
    const calculateCount = (txt, isHypenSplit) => {
        if (prevWidth) {
            cnt++;
        }
        if (width / colwidth >= 1) {
            txt.split('').forEach((val) => {
                cWidth = getTextWidth(val, style, parentStyle, true);
                lWidth += cWidth;
                if (lWidth > colwidth) {
                    cnt++;
                    lWidth = cWidth;
                }
            });
            width = getDPRValue(lWidth, true);
        }
        if (!isHypenSplit) {
            addSpace(width);
        }
        prevWidth = width;
    };
    const addSpace = (size) => {
        width += ((size + spaceWidth) / colwidth >= 1 ? 0 : spaceWidth);
    };
    textArr.forEach((txt) => {
        lWidth = 0;
        cWidth = 0;
        width = getTextWidth(txt, style, parentStyle);
        lines = (prevWidth + width) / colwidth;
        if (lines > 1) {
            splitTextArr = txt.split('-');
            if (splitTextArr.length > 1) {
                const lastIdx = splitTextArr.length - 1;
                splitTextArr.forEach((splitText, index) => {
                    lWidth = 0;
                    cWidth = 0;
                    if (!hypenWidth) {
                        hypenWidth = getTextWidth('-', style, parentStyle);
                    }
                    width = getTextWidth(splitText, style, parentStyle);
                    if (index < lastIdx) {
                        width += hypenWidth;
                    }
                    lines = (prevWidth + width) / colwidth;
                    if (lines >= 1) {
                        calculateCount(splitText, index !== lastIdx);
                    }
                    else {
                        if (index === lastIdx && textArr[textArr.length - 1] !== txt) {
                            addSpace(prevWidth + width);
                        }
                        prevWidth += width;
                    }
                });
            }
            else {
                calculateCount(txt, false);
            }
        }
        else {
            addSpace(prevWidth + width);
            prevWidth += width;
        }
    });
    if (prevWidth) {
        lineCnt = (prevWidth - spaceWidth) / colwidth;
        maxCnt = parseFloat((lineCnt).toString().split('.')[0]);
        cnt += (lineCnt + 0.05 >= maxCnt + 1 ? Math.ceil(lineCnt) + 1 : Math.ceil(lineCnt));
    }
    return cnt;
}
/**
 * calculation for width taken by border inside a cell
 *
 * @param {number} rowIdx - Specify the row index.
 * @param {number} colIdx - Specify the column index.
 * @param {SheetModel} sheet - Specify the sheet.
 * @returns {number} - get border width.
 * @hidden
 */
function getBorderWidth(rowIdx, colIdx, sheet) {
    let width = 0;
    const cell = getCell(rowIdx, colIdx, sheet, null, true);
    const rightSideCell = getCell(rowIdx, colIdx + 1, sheet, null, true);
    if (cell.style) {
        if (cell.style.border) {
            width = (colIdx === 0 ? 2 : 1) * parseFloat(cell.style.border.split('px')[0]);
        }
        else {
            if (colIdx === 0 && cell.style.borderLeft) {
                width = parseFloat(cell.style.borderLeft.split('px')[0]);
            }
            if (cell.style.borderRight) {
                width += parseFloat(cell.style.borderRight.split('px')[0]);
            }
        }
    }
    if (!(cell.style && (cell.style.border || cell.style.borderRight)) && rightSideCell.style && rightSideCell.style.borderLeft) {
        width += parseFloat(rightSideCell.style.borderLeft.split('px')[0]);
    }
    return width > 0 && width < 1 ? 1 : width;
}
/**
 * calculation for height taken by border inside a cell
 *
 * @param {number} rowIdx - Specify the row index.
 * @param {number} colIdx - Specify the column index.
 * @param {SheetModel} sheet - Specify the sheet.
 * @returns {number} - get border height.
 * @hidden
 */
function getBorderHeight(rowIdx, colIdx, sheet) {
    let height = 0;
    const cell = getCell(rowIdx, colIdx, sheet, null, true);
    if (cell.style) {
        if (cell.style.border) {
            height = (rowIdx === 0 ? 2 : 1) * parseFloat(cell.style.border.split('px')[0]);
        }
        else {
            if (rowIdx === 0 && cell.style.borderTop) {
                height = parseFloat(cell.style.borderTop.split('px')[0]);
            }
            if (cell.style.borderBottom) {
                height += parseFloat(cell.style.borderBottom.split('px')[0]);
            }
        }
    }
    const bottomSideCell = getCell(rowIdx + 1, colIdx, sheet, null, true);
    if (!(cell.style && (cell.style.border || cell.style.borderBottom)) && bottomSideCell.style && bottomSideCell.style.borderTop) {
        height += parseFloat(bottomSideCell.style.borderTop.split('px')[0]);
    }
    return Math.ceil(height) || 1; // 1 -> For default bottom border
}
/**
 * Calculating column width by excluding cell padding and border width
 *
 * @param {SheetModel} sheet - Specify the sheet
 * @param {number} rowIdx - Specify the row index.
 * @param {number} startColIdx - Specify the start column index.
 * @param {number} endColIdx - Specify the end column index.
 * @returns {number} - get excluded column width.
 * @hidden
 */
function getExcludedColumnWidth(sheet, rowIdx, startColIdx, endColIdx = startColIdx) {
    return getColumnsWidth(sheet, startColIdx, endColIdx, true) - getDPRValue((4 + (getBorderWidth(rowIdx, startColIdx, sheet) || 1))); // 4 -> For cell padding
}
/**
 * @param {Workbook} context - Specify the Workbook.
 * @param {number} rowIdx - Specify the row index.
 * @param {number} colIdx - Specify the column index.
 * @param {SheetModel} sheet - Specify the sheet.
 * @param {CellStyleModel} style - Specify the style.
 * @param {number} lines - Specify the lines.
 * @param {number} lineHeight - Specify the line height.
 * @returns {number} - get text height with border.
 * @hidden
 */
function getTextHeightWithBorder(context, rowIdx, colIdx, sheet, style, lines, lineHeight) {
    return getTextHeight(context, style, lines, lineHeight) + getBorderHeight(rowIdx, colIdx, sheet);
}
/**
 * Setting maximum height while doing formats and wraptext
 *
 * @hidden
 * @param {SheetModel} sheet - Specify the sheet
 * @param {number} rIdx - specify the row Index
 * @param {number} cIdx - specify the column Index.
 * @param {number} hgt - specify the hgt
 * @returns {void} - Setting maximum height while doing formats and wraptext
 */
function setMaxHgt(sheet, rIdx, cIdx, hgt) {
    if (!sheet.maxHgts[rIdx]) {
        sheet.maxHgts[rIdx] = {};
    }
    sheet.maxHgts[rIdx][cIdx] = hgt;
}
/**
 * Getting maximum height by comparing each cell's modified height.
 *
 * @hidden
 * @param {SheetModel} sheet - Specify the sheet.
 * @param {number} rIdx - Specify the row index.
 * @returns {number} - Getting maximum height by comparing each cell's modified height.
 */
function getMaxHgt(sheet, rIdx) {
    let maxHgt = 0;
    const rowHgt = sheet.maxHgts[rIdx];
    if (rowHgt) {
        Object.keys(rowHgt).forEach((key) => {
            if (rowHgt[`${key}`] > maxHgt) {
                maxHgt = rowHgt[`${key}`];
            }
        });
    }
    return maxHgt;
}
/**
 * @hidden
 * @param {HTMLElement} ele - Specify the element.
 * @returns {void} - Specify the focus.
 */
function focus(ele) {
    if (!document.activeElement.classList.contains('e-text-findNext-short')) {
        if (Browser.isIE) {
            const scrollX = window.scrollX;
            const scrollY = window.scrollY;
            ele.focus();
            window.scrollTo(scrollX, scrollY);
        }
        else {
            if (ele.classList.contains('e-input')) {
                const inputEle = ele;
                const position = inputEle.value.length;
                inputEle.setSelectionRange(position, position);
            }
            ele.focus({ preventScroll: true });
        }
    }
}
/**
 * Checks whether a specific range of cells is locked or not.
 *
 * @param {Spreadsheet} parent - Specify the spreadsheet.
 * @param {number[]} rangeIndexes - Specify the range indexes.
 * @returns {boolean} - Returns true if any of the cells is locked and returns false if none of the cells is locked.
 * @hidden
 */
function isLockedCells(parent, rangeIndexes) {
    const sheet = parent.getActiveSheet();
    let hasLockCell;
    const address = !isNullOrUndefined(rangeIndexes) ? rangeIndexes : getSwapRange(getRangeIndexes(sheet.selectedRange));
    for (let row = address[0]; row <= address[2]; row++) {
        for (let col = address[1]; col <= address[3]; col++) {
            const cell = getCell(row, col, sheet);
            if (isLocked(cell, getColumn(sheet, col))) {
                hasLockCell = true;
                break;
            }
        }
    }
    return hasLockCell;
}
/**
 * Checks whether the range is discontinuous or not.
 *
 * @param {string} range - Specify the sheet
 * @returns {boolean} - Returns true if the range is discontinuous range.
 * @hidden
 */
function isDiscontinuousRange(range) {
    return range.includes(' ');
}
/**
 * @hidden
 * @param {Spreadsheet} context - Specifies the context.
 * @param {number[]} range - Specifies the address range.
 * @param {number} sheetIdx - Specifies the sheetIdx.
 * @returns {void} - To clear the range.
 */
function clearRange(context, range, sheetIdx) {
    const sheet = getSheet(context, sheetIdx);
    let skip;
    let cell;
    let newCell;
    let td;
    let prop;
    const uiRefresh = sheetIdx === context.activeSheetIndex;
    let cfRefreshAll;
    const cf = sheet.conditionalFormats && sheet.conditionalFormats.length && [].slice.call(sheet.conditionalFormats);
    const cfRule = [];
    let isCellUpdated = false;
    for (let sRIdx = range[0], eRIdx = range[2]; sRIdx <= eRIdx; sRIdx++) {
        if (isFilterHidden(sheet, sRIdx)) {
            continue;
        }
        for (let sCIdx = range[1], eCIdx = range[3]; sCIdx <= eCIdx; sCIdx++) {
            const args = { cellIdx: [sRIdx, sCIdx], isUnique: false,
                uniqueRange: '' };
            context.notify(checkUniqueRange, args);
            skip = false;
            if (args.uniqueRange !== '') {
                const rangeIndex = getIndexesFromAddress(args.uniqueRange);
                skip = getCell(rangeIndex[0], rangeIndex[1], sheet).value === '#SPILL!';
            }
            // Determine if it's the last iteration of the given range.
            const isLastIteration = (sRIdx === eRIdx) && (sCIdx === eCIdx);
            if (!args.isUnique || skip) {
                cell = getCell(sRIdx, sCIdx, sheet);
                if ((cell && cell.value === 0) || cell && cell.value && (isNullOrUndefined(cell.value) || cell.value !== '')) {
                    isCellUpdated = false;
                    newCell = {};
                    if (cell.formula) {
                        newCell.formula = '';
                    }
                    if (cell.value || cell.value === 0) {
                        newCell.value = '';
                    }
                    if (cell.hyperlink) {
                        newCell.hyperlink = '';
                    }
                    const mergeArgs = { sheet: sheet, cell: cell, rowIdx: sRIdx, colIdx: sCIdx };
                    if (cell.colSpan > 1 || cell.rowSpan > 1) {
                        setVisibleMergeIndex(mergeArgs);
                    }
                    td = context.getCell(mergeArgs.rowIdx, mergeArgs.colIdx);
                    prop = { cell: newCell, rowIdx: sRIdx, colIdx: sCIdx, valChange: true, uiRefresh: uiRefresh, td: td,
                        cellDelete: true, isDelete: !isLastIteration, deletedRange: range };
                    if (!Object.keys(newCell).length || updateCell(context, sheet, prop)) {
                        continue;
                    }
                    if (cf && !cfRefreshAll) {
                        cfRefreshAll = prop.isFormulaDependent;
                        if (!cfRefreshAll) {
                            updateCFModel(cf, cfRule, sRIdx, sCIdx);
                        }
                    }
                    if (td) {
                        if (td.querySelector('.e-cf-databar')) {
                            td.removeChild(td.querySelector('.e-cf-databar'));
                        }
                        if (td.querySelector('.e-iconsetspan')) {
                            td.removeChild(td.querySelector('.e-iconsetspan'));
                        }
                    }
                }
                else {
                    if (!isCellUpdated && prop) {
                        isCellUpdated = isLastIteration;
                        prop.isDelete = !isLastIteration;
                        if (!Object.keys(newCell).length || updateCell(context, sheet, prop)) {
                            continue;
                        }
                    }
                }
            }
        }
    }
    if ((cfRule.length || cfRefreshAll) && uiRefresh) {
        context.notify(applyCF, { cfModel: !cfRefreshAll && cfRule, refreshAll: cfRefreshAll, isAction: true, isEdit: true });
    }
}
/**
 * @param {Spreadsheet} parent - Specifies the spreadsheet instance.
 * @param {number} top - Specifies the top.
 * @returns {number} - It returns bottom offset.
 * @hidden
 */
function getBottomOffset(parent, top) {
    let hgt = 0;
    const sheet = parent.getActiveSheet();
    const viewPortHeight = (sheet.frozenRows ? parent.viewport.height - parent.sheetModule.getColHeaderHeight(sheet, true) :
        parent.viewport.height) - 17 || 20;
    for (let rowIdx = top;; rowIdx++) {
        hgt += getRowHeight(sheet, rowIdx, true);
        if (hgt >= viewPortHeight) {
            return { index: rowIdx, height: hgt };
        }
    }
}
/**
 * @param {Spreadsheet} parent - Specifies the spreadsheet instance.
 * @param {number} left - Specifies the left.
 * @returns {number} -It returns right index using given left value.
 * @hidden
 */
function getRightIdx(parent, left) {
    let width = 0;
    const sheet = parent.getActiveSheet();
    const contWidth = parent.getMainContent().parentElement.offsetWidth -
        parent.sheetModule.getRowHeaderWidth(sheet) - parent.sheetModule.getScrollSize();
    for (let i = left;; i++) {
        width += getColumnWidth(sheet, i, null, true);
        if (width >= contWidth) {
            return i;
        }
    }
}
/**
 * @param {Spreadsheet} spreadsheet - Specifies the spreadsheet instance.
 * @param {number} minWidth - Specifies the minimum width.
 * @returns {void}
 * @hidden
 */
function setColMinWidth(spreadsheet, minWidth) {
    spreadsheet.renderModule.setSheetPanelSize(minWidth);
}
/**
 * Calculating resolution based windows value
 *
 * @param {number} size - Specify the end column index.
 * @returns {number} - get excluded column width.
 * @hidden
 */
function addDPRValue(size) {
    if (window.devicePixelRatio % 1 > 0) {
        const pointValue = (size * window.devicePixelRatio) % 1;
        return size + (pointValue ? ((pointValue > 0.5 ? (1 - pointValue) : -1 * pointValue) / window.devicePixelRatio) : 0);
    }
    return size;
}
/**
 * @param {Spreadsheet} context - Specifies the spreadsheet instance.
 * @param {string[]} keys - Specifies key array.
 * @returns {string} - It returns sheet property of the given key and context.
 * @hidden
 */
function getSheetProperties(context, keys) {
    const skipProps = [];
    if (keys) {
        /* eslint-disable */
        let propList = Object.getPrototypeOf(new Cell(context, 'cells', {}, true)).constructor.prototype.propList;
        const cellProps = propList.colPropNames.concat(propList.complexPropNames).concat(propList.propNames);
        cellProps.push('formattedText');
        propList = Object.getPrototypeOf(new Row(context, 'rows', {}, true)).constructor.prototype.propList;
        const rowProps = propList.colPropNames.concat(propList.complexPropNames).concat(propList.propNames);
        propList = Object.getPrototypeOf(new Column(context, 'columns', {}, true)).constructor.prototype.propList;
        const colProps = propList.colPropNames.concat(propList.complexPropNames).concat(propList.propNames);
        propList = Object.getPrototypeOf(new Sheet(context, 'sheets', {}, true)).constructor.prototype.propList;
        /* eslint-enable */
        const sheetProps = propList.colPropNames.concat(propList.complexPropNames).concat(propList.propNames);
        sheetProps.splice(sheetProps.indexOf('rows'), 1);
        sheetProps.splice(sheetProps.indexOf('columns'), 1);
        sheetProps.splice(sheetProps.indexOf('cells'), 1);
        rowProps.splice(rowProps.indexOf('cells'), 1);
        skipProps.push(...sheetProps);
        if (keys.indexOf('rows') === -1) {
            skipProps.push(...rowProps);
        }
        if (keys.indexOf('columns') === -1) {
            skipProps.push(...colProps);
        }
        if (keys.indexOf('cells') === -1) {
            skipProps.push(...cellProps);
        }
        let idx;
        keys.forEach((key) => {
            idx = skipProps.indexOf(key);
            if (skipProps.indexOf(key) > -1) {
                skipProps.splice(idx, 1);
            }
        });
    }
    else {
        skipProps.push('ranges');
    }
    const eventArgs = { skipProps: skipProps };
    context.notify('getStringifyObject', eventArgs);
    return eventArgs.model;
}
/**
 * Returns the row indexes and column indexes of the charts in the active sheet
 *
 * @param {Spreadsheet} context - Specifies the Spreadsheet instance.
 * @returns { {chart: ChartModel, chartRowIdx: number, chartColIdx: number}[] } - Returns the row indexes and column indexes of the charts in the active sheet
 * @hidden
 */
function getChartsIndexes(context) {
    let chart;
    const chartIndexes = [];
    const sheetName = context.getActiveSheet().name;
    for (let i = 0, len = context.chartColl.length; i < len; i++) {
        chart = context.chartColl[i];
        if (sheetName === getSheetNameFromAddress(chart.range)) {
            const prevTop = { clientY: chart.top, isImage: true };
            const prevLeft = { clientX: chart.left, isImage: true };
            context.notify(getRowIdxFromClientY, prevTop);
            context.notify(getColIdxFromClientX, prevLeft);
            chartIndexes.push({ chart: chart, chartRowIdx: prevTop.clientY, chartColIdx: prevLeft.clientX });
        }
    }
    return chartIndexes;
}
/**
 * Checks if the given range string represents a valid column range.
 *
 * @param {string} range - The range string to validate.
 * @returns {boolean} - Returns `true` if the range is a valid column range, otherwise `false`.
 * @hidden
 */
function isColumnRange(range) {
    return /^[A-Za-z]+:[A-Za-z]+$/.test(range);
}
/**
 * Checks if the given range string represents a valid row range.
 *
 * @param {string} range - The range string to validate.
 * @returns {boolean} - Returns `true` if the range is a valid row range, otherwise `false`.
 * @hidden
 */
function isRowRange(range) {
    return /^[0-9]+:[0-9]+$/.test(range);
}
/**
 * Sets the standard height for a specified sheet in a spreadsheet.
 *
 * @param {Spreadsheet} context - The spreadsheet instance.
 * @param {number} sheetIndex - The index of the sheet to set the standard height.
 * @param {number} standardHeight - The standard height to set for the sheet.
 * @returns {void}
 * @hidden
 */
function setStandardHeight(context, sheetIndex, standardHeight) {
    const sheet = context.sheets[sheetIndex];
    if (sheet) {
        sheet.standardHeight = standardHeight;
        context.dataBind();
    }
}
/**
 * Retrieves the standard height of a specific sheet in the spreadsheet.
 *
 * @param {Spreadsheet} context - The spreadsheet instance.
 * @param {number} sheetIndex - The index of the sheet to retrieve the standard height.
 * @returns {number} - The standard height of the specified sheet.
 * @hidden
 */
function getStandardHeight(context, sheetIndex) {
    return context.sheets[sheetIndex].standardHeight;
}
/**
 * Removes the specified elements from the DOM.
 *
 * @param {HTMLElement[]} elements - An array of HTML elements that need to be removed from the DOM.
 * @returns {void}
 * @hidden
 */
function removeElements(elements) {
    elements.forEach((element) => {
        if (element && element.parentNode) {
            element.parentNode.removeChild(element);
        }
    });
}

var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Represents the scroll settings.
 */
class ScrollSettings extends ChildProperty {
}
__decorate$7([
    Property(false)
], ScrollSettings.prototype, "isFinite", void 0);
__decorate$7([
    Property(true)
], ScrollSettings.prototype, "enableVirtualization", void 0);
/**
 * Represents the selection settings.
 */
class SelectionSettings extends ChildProperty {
}
__decorate$7([
    Property('Multiple')
], SelectionSettings.prototype, "mode", void 0);

/**
 * Sheet module is used to render Sheet
 *
 * @hidden
 */
class SheetRender {
    constructor(parent) {
        this.colGroupWidth = 30; //Row header and selectall table colgroup width
        this.parent = parent;
        this.col = parent.createElement('col');
        this.rowRenderer = parent.serviceLocator.getService('row');
        this.cellRenderer = parent.serviceLocator.getService('cell');
        this.addEventListener();
    }
    refreshSelectALLContent() {
        let cell;
        const sheet = this.parent.getActiveSheet();
        if (sheet.frozenColumns || sheet.frozenRows) {
            const tHead = this.getSelectAllTable().querySelector('thead');
            const row = this.rowRenderer.render();
            tHead.appendChild(row);
            cell = this.parent.createElement('th', { className: 'e-select-all-cell' });
            row.appendChild(cell);
        }
        else {
            cell = this.headerPanel.firstElementChild;
            cell.classList.add('e-select-all-cell');
        }
        cell.appendChild(this.parent.createElement('button', {
            className: 'e-selectall', id: `${this.parent.element.id}_select_all`,
            attrs: { 'aria-label': this.parent.serviceLocator.getService(locale).getConstant('SelectAll'), 'type': 'button' }
        }));
    }
    updateLeftColGroup(width, rowHdr) {
        if (width) {
            this.colGroupWidth = width;
        }
        if (!rowHdr) {
            rowHdr = this.getRowHeaderPanel();
        }
        let table = rowHdr.querySelector('table');
        const sheet = this.parent.getActiveSheet();
        const frag = document.createDocumentFragment(); // Using a fragment for batch updates
        let colGrp;
        if (width) {
            table.querySelector('colgroup').firstElementChild.style.width = `${this.colGroupWidth}px`;
        }
        else {
            colGrp = this.parent.createElement('colgroup');
            const col = this.col.cloneNode();
            col.style.width = `${this.colGroupWidth}px`;
            frag.appendChild(col);
            colGrp.appendChild(frag);
            table.insertBefore(colGrp, table.querySelector('tbody'));
        }
        if (sheet.frozenRows || sheet.frozenColumns) {
            table = this.getSelectAllTable();
            if (width) {
                table.querySelector('colgroup').firstElementChild.style.width = `${this.colGroupWidth}px`;
            }
            else {
                table.insertBefore(colGrp.cloneNode(true), table.querySelector('thead'));
            }
        }
        this.setPanelWidth(sheet, rowHdr);
        this.setPanelHeight(sheet);
    }
    setPanelWidth(sheet, rowHdr, isRtlChange) {
        const scrollSize = this.getScrollSize(true);
        const width = this.getRowHeaderWidth(sheet);
        const isRtl = this.parent.enableRtl;
        const offset = isRtl ? 'right' : 'left';
        let rtlOffset;
        const colHeaderPanel = this.getColHeaderPanel();
        const contentPanel = this.getContentPanel();
        if (isRtlChange) {
            rtlOffset = isRtl ? 'left' : 'right';
            contentPanel.style[`${rtlOffset}`] = colHeaderPanel.style[`${rtlOffset}`] = '';
        }
        if (sheet.frozenColumns) {
            const frozenCol = document.getElementById(this.parent.element.id + '_sheet').getElementsByClassName('e-frozen-column')[0];
            frozenCol.style.height = `calc(100% - ${scrollSize}px)`;
            if (isRtlChange) {
                frozenCol.style[`${rtlOffset}`] = '';
            }
            frozenCol.style[`${offset}`] = width - getDPRValue(1) + 'Px';
            frozenCol.style.display = '';
        }
        const widthCalc = `calc(100% - ${width}px)`;
        this.setHeaderPanelWidth(this.getSelectAllContent(), width);
        colHeaderPanel.style.width = widthCalc;
        colHeaderPanel.style[`${offset}`] = width + 'px';
        this.setHeaderPanelWidth(rowHdr, width);
        contentPanel.style.width = widthCalc;
        contentPanel.style[`${offset}`] = width + 'px';
        let scroll = (this.contentPanel.nextElementSibling ? this.contentPanel.nextElementSibling : null);
        if (scroll) {
            if (scrollSize) {
                scroll.style.height = scrollSize + 1 + 'px';
            }
            else {
                scroll.style.height = '1px';
                scroll.style.borderTopWidth = '0px';
            }
            scroll = scroll.firstElementChild;
            if (isRtlChange) {
                scroll.style[`${rtlOffset}`] = '';
            }
            scroll.style[`${offset}`] = width + 'px';
            scroll.style.width = widthCalc;
            if (Browser.userAgent.indexOf('Mac OS') > -1 && Browser.info.name === 'safari') {
                scroll.style.height = '7px';
                scroll.style.top = '-7px';
            }
        }
    }
    getScrollSize(addOffset) {
        const scrollSize = parseInt(this.headerPanel.style[this.parent.enableRtl ? 'margin-left' : 'margin-right'], 10);
        return scrollSize ? scrollSize + (addOffset ? 1 : 0) : 0;
    }
    setHeaderPanelWidth(content, width) {
        const emptyCol = [].slice.call(content.querySelectorAll('col.e-empty'));
        emptyCol.forEach((col) => {
            width += parseInt(col.style.width, 10);
        });
        content.style.width = width + 'px';
    }
    setPanelHeight(sheet) {
        const scrollSize = this.getScrollSize(true);
        const contentPanel = this.contentPanel;
        const headerPanel = this.headerPanel;
        if (sheet.frozenRows) {
            const frozenHeight = this.getColHeaderHeight(sheet);
            if (!sheet.showHeaders && !sheet.frozenColumns) {
                headerPanel.style.height = frozenHeight + 'px';
            }
            else {
                headerPanel.style.height = '';
            }
            contentPanel.style.height = `calc(100% - ${frozenHeight + scrollSize}px)`;
            const frozenRow = document.getElementById(this.parent.element.id + '_sheet').getElementsByClassName('e-frozen-row')[0];
            frozenRow.style.width = Browser.isDevice ? '100%' : `calc(100% - ${scrollSize}px)`;
            frozenRow.style.top = frozenHeight - 1 - (sheet.showHeaders ? 1 : 0) + 'px';
            frozenRow.style.display = '';
        }
        else {
            contentPanel.style.height = `calc(100% - ${(sheet.showHeaders ? getDPRValue(31) : 0) + scrollSize}px)`;
        }
    }
    renderPanel() {
        this.contentPanel = this.parent.createElement('div', { className: 'e-main-panel', attrs: { 'tabindex': '0' } });
        const sheet = this.parent.getActiveSheet();
        const id = this.parent.element.id;
        const frag = document.createDocumentFragment();
        const rowHeader = this.parent.createElement('div', { className: 'e-row-header', id: `${id}_row_header` });
        frag.appendChild(rowHeader);
        this.initHeaderPanel();
        if (this.parent.allowScrolling) {
            this.parent.scrollModule.setPadding();
        }
        const sheetEle = document.getElementById(this.parent.element.id + '_sheet');
        if (sheet.frozenColumns) {
            sheetEle.classList.add('e-frozen-columns');
        }
        if (sheet.frozenRows) {
            sheetEle.classList.add('e-frozen-rows');
        }
        this.updateHideHeaders(sheet, sheetEle);
        if (!sheet.showGridLines) {
            sheetEle.classList.add('e-hide-gridlines');
        }
        const content = this.parent.createElement('div', { className: 'e-sheet-content', id: `${id}_main_content` });
        frag.appendChild(content);
        if (!this.parent.allowScrolling) {
            content.style.overflow = 'hidden';
        }
        if (sheet.frozenRows) {
            sheetEle.appendChild(this.parent.createElement('div', { className: 'e-frozen-row', styles: 'display: none' }));
        }
        if (sheet.frozenColumns) {
            sheetEle.appendChild(this.parent.createElement('div', { className: 'e-frozen-column', styles: 'display: none' }));
        }
        if (Browser.userAgent.indexOf('Mac OS') > -1 && Browser.info.name === 'safari') {
            sheetEle.classList.add('e-mac-safari');
        }
        this.contentPanel.appendChild(frag); // Append all created elements to the content panel in a single operation using fragment.
    }
    initHeaderPanel() {
        const id = this.parent.element.id;
        const frag = document.createDocumentFragment();
        this.headerPanel = this.parent.createElement('div', { className: 'e-header-panel' });
        const selectAllContainer = this.parent.createElement('div', { className: 'e-selectall-container', id: `${id}_selectall` });
        frag.appendChild(selectAllContainer);
        const columnHeader = this.parent.createElement('div', { className: 'e-column-header', id: `${id}_col_header` });
        frag.appendChild(columnHeader);
        this.headerPanel.appendChild(frag);
    }
    createHeaderTable() {
        const rowHdrEle = this.contentPanel.querySelector('.e-row-header');
        const sheet = this.parent.getActiveSheet();
        if (sheet.frozenRows || sheet.frozenColumns) {
            this.updateTable(sheet.frozenRows ? ['thead', 'tbody'] : ['thead'], 'selectall', this.headerPanel.querySelector('.e-selectall-container'));
        }
        this.updateTable(sheet.frozenRows ? ['thead', 'tbody'] : ['thead'], 'colhdr', this.headerPanel.querySelector('.e-column-header'));
        this.updateTable(['tbody'], 'rowhdr', rowHdrEle);
        this.updateLeftColGroup(null, rowHdrEle);
    }
    updateTable(tagName, name, appendTo) {
        const frag = document.createDocumentFragment();
        const table = this.parent.createElement('table', {
            className: `e-table e-${name}-table`, attrs: { 'role': 'grid' }
        });
        tagName.forEach((tag) => { frag.appendChild(this.parent.createElement(tag)); });
        table.appendChild(frag);
        appendTo.appendChild(table);
    }
    /**
     * It is used to refresh the select all, row header, column header and content of the spreadsheet.
     *
     * @param {SheetRenderArgs} args - Specifies the cells, indexes, direction, skipUpdateOnFirst, top, left, initload properties.
     * @returns {void}
     */
    renderTable(args) {
        let indexes;
        let row;
        let hRow;
        const sheet = this.parent.getActiveSheet();
        let cell;
        let cellArgs;
        const mergeBorderRows = [];
        const frag = document.createDocumentFragment();
        frag.appendChild(this.headerPanel);
        frag.appendChild(this.contentPanel);
        if (this.parent.allowScrolling) {
            const scrollPanel = this.parent.createElement('div', { className: 'e-scrollbar' });
            scrollPanel.appendChild(this.parent.createElement('div', { className: 'e-scroller' }));
            frag.appendChild(scrollPanel);
        }
        this.createHeaderTable();
        this.updateTable(['tbody'], 'content', this.contentPanel.lastElementChild);
        const colGrp = this.parent.createElement('colgroup');
        let col;
        const cTBody = this.contentPanel.querySelector('.e-sheet-content tbody');
        this.refreshSelectALLContent();
        const selectAllColGrp = this.getSelectAllContent().querySelector('colgroup');
        const rowHdrColGrp = this.getRowHeaderPanel().querySelector('colgroup');
        const selectAllHdrRow = this.getSelectAllContent().querySelector('thead .e-header-row');
        const rHdrTBody = this.contentPanel.querySelector('.e-row-header tbody');
        const selectAllTBody = this.getSelectAllContent().querySelector('tbody');
        const cHdrTHead = this.headerPanel.querySelector('.e-column-header thead');
        const cHdrTBody = this.headerPanel.querySelector('.e-column-header tbody');
        const cHdrRow = this.rowRenderer.render();
        cHdrTHead.appendChild(cHdrRow);
        this.getColHeaderTable().insertBefore(colGrp, cHdrTHead);
        const frozenRow = this.parent.frozenRowCount(sheet);
        const frozenCol = this.parent.frozenColCount(sheet);
        const lastFrozenCol = skipHiddenIdx(sheet, frozenCol - 1, false, 'columns');
        this.parent.notify(beforeContentLoaded, { top: args.top, left: args.left });
        const colCount = sheet.colCount.toString();
        const rowCount = sheet.colCount.toString();
        const layout = args.top && args.left ? 'RowColumn' : (args.top ? 'Row' : (args.left ? 'Column' : ''));
        this.parent.getColHeaderTable().setAttribute('aria-colcount', colCount);
        this.parent.getRowHeaderTable().setAttribute('aria-rowcount', rowCount);
        let emptyRow;
        attributes(this.parent.getContentTable(), { 'aria-rowcount': rowCount, 'aria-colcount': colCount });
        args.cells.forEach((value, key) => {
            indexes = getRangeIndexes(key);
            if (indexes[1] === args.indexes[1] || !row) {
                if (indexes[1] === args.indexes[1]) {
                    hRow = this.rowRenderer.render(indexes[0], true);
                }
                if (frozenCol && frozenRow && indexes[1] < frozenCol && indexes[0] < frozenRow) {
                    emptyRow = selectAllTBody.querySelector('.e-empty');
                    if (emptyRow) {
                        selectAllTBody.insertBefore(hRow, emptyRow);
                    }
                    else {
                        selectAllTBody.appendChild(hRow);
                    }
                    row = hRow;
                }
                else if (frozenCol && indexes[1] < frozenCol) {
                    rHdrTBody.appendChild(hRow);
                    row = hRow;
                }
                else {
                    row = this.rowRenderer.render(indexes[0]);
                    if (frozenRow && indexes[0] < frozenRow) {
                        emptyRow = cHdrTBody.querySelector('.e-empty');
                        if (emptyRow) {
                            cHdrTBody.insertBefore(row, emptyRow);
                        }
                        else {
                            cHdrTBody.appendChild(row);
                        }
                    }
                    else {
                        cTBody.appendChild(row);
                    }
                    if (indexes[1] === args.indexes[1]) {
                        if (frozenRow && indexes[0] < frozenRow) {
                            selectAllTBody.appendChild(hRow);
                        }
                        else {
                            rHdrTBody.appendChild(hRow);
                        }
                    }
                }
                if (indexes[1] === args.indexes[1]) {
                    this.cellRenderer.renderRowHeader(indexes[0], hRow);
                }
            }
            cellArgs = { colIdx: indexes[1], rowIdx: indexes[0], cell: value, mergeBorderRows: mergeBorderRows,
                address: key, lastCell: indexes[1] === args.indexes[3], isHeightCheckNeeded: true, row: row, hRow: hRow,
                pRow: row.previousSibling, pHRow: hRow.previousSibling, isRefreshing: args.isRefreshing,
                first: layout ? (layout.includes('Row') ? (indexes[0] === args.indexes[0] ? 'Row' : (layout.includes('Column') ? (indexes[1] === args.indexes[1] ? 'Column' : '') : '')) : (indexes[1] === args.indexes[1] ? 'Column' : '')) : '' };
            cell = this.cellRenderer.render(cellArgs);
            const notFirstRow = this.parent.scrollSettings.enableVirtualization && this.parent.viewport.topIndex !==
                skipHiddenIdx(sheet, 0, true);
            const notFirstCol = this.parent.scrollSettings.enableVirtualization && this.parent.viewport.leftIndex !==
                skipHiddenIdx(sheet, 0, true, 'columns');
            if (notFirstRow) {
                this.checkRowMerge(indexes, args.indexes, cell, value, sheet);
            }
            if (notFirstCol) {
                this.checkColMerge(indexes, args.indexes, cell, value, sheet);
            }
            if (frozenCol && indexes[1] === lastFrozenCol) {
                row = null;
            }
            if (indexes[0] === args.indexes[0]) {
                if (frozenCol && indexes[1] < frozenCol) {
                    col = this.updateCol(sheet, indexes[1], selectAllColGrp);
                    const empty = rowHdrColGrp.querySelector('.e-empty');
                    if (empty) {
                        rowHdrColGrp.insertBefore(col.cloneNode(true), empty);
                    }
                    else {
                        rowHdrColGrp.appendChild(col.cloneNode(true));
                    }
                    this.cellRenderer.renderColHeader(indexes[1], selectAllHdrRow);
                }
                else {
                    this.updateCol(sheet, indexes[1], colGrp);
                    this.cellRenderer.renderColHeader(indexes[1], cHdrRow);
                }
            }
        });
        if (this.parent.isReact) {
            this.parent['renderReactTemplates']();
        }
        updateMergeBorder(this.parent, mergeBorderRows);
        cTBody.parentElement.insertBefore(colGrp.cloneNode(true), cTBody);
        getUpdateUsingRaf(() => {
            if (!this.parent) {
                return;
            }
            const content = this.parent.getMainContent();
            const sheetContent = document.getElementById(this.parent.element.id + '_sheet');
            if (sheetContent.childElementCount && sheetContent.querySelector('.e-header-panel') !== this.headerPanel) {
                const sheetChild = sheetContent.children;
                for (let i = 0; i < sheetChild.length; i++) {
                    if (!sheetChild[i].classList.contains('e-frozen-row') &&
                        !sheetChild[i].classList.contains('e-frozen-column') &&
                        !sheetChild[i].classList.contains('e-ss-overlay')) {
                        sheetContent.removeChild(sheetChild[i]);
                    }
                }
            }
            sheetContent.appendChild(frag);
            sheetContent.style.backgroundColor = '';
            if (sheet.conditionalFormats && sheet.conditionalFormats.length) {
                this.parent.notify(applyCF, { indexes: args.indexes });
            }
            this.checkRowHeightChanged(args, sheet);
            if (args.top) {
                content.parentElement.scrollTop = args.top;
            }
            if (args.left) {
                content.scrollLeft = args.left;
                this.parent.getColumnHeaderContent().scrollLeft = args.left;
            }
            this.parent.notify(contentLoaded, args);
            this.checkTableWidth(sheet);
            this.parent.notify(editOperation, { action: 'renderEditor', initLoad: args.initLoad && !this.parent.isOpen });
            if (!args.initLoad && !this.parent.isOpen) {
                this.parent.hideSpinner();
            }
            setAriaOptions(content, { busy: false });
            this.parent.trigger(dataBound, {});
            if (this.parent.isEdit) {
                this.parent.notify(initiateEdit, null);
            }
            if (args.openOptions && args.openOptions.eventArgs && args.openOptions.eventArgs.triggerEvent) {
                this.parent.trigger('openComplete', { response: args.openOptions });
            }
            if (args.initLoad) {
                let triggerEvent = true;
                if (this.parent.scrollSettings.enableVirtualization) {
                    for (let i = 0; i < sheet.ranges.length; i++) {
                        if (sheet.ranges[i].info.count - 1 > this.parent.viewport.bottomIndex) {
                            triggerEvent = false;
                            break;
                        }
                    }
                }
                if (triggerEvent) {
                    if (this.parent.isReact) {
                        setTimeout(() => {
                            if (!this.parent) {
                                return;
                            }
                            this.triggerCreatedEvent();
                        });
                    }
                    else {
                        this.triggerCreatedEvent();
                    }
                }
                else if (!this.parent.isOpen) {
                    this.parent.hideSpinner();
                }
            }
        });
    }
    triggerCreatedEvent() {
        if (!this.parent.isOpen) {
            this.parent.hideSpinner();
        }
        if (this.parent.createdHandler) {
            if (this.parent.createdHandler.observers) {
                this.parent['created'].observers =
                    this.parent.createdHandler.observers;
                if (this.parent.isAngular &&
                    this.parent.createdHandler.currentObservers) {
                    this.parent['created'].currentObservers =
                        this.parent.createdHandler.currentObservers;
                }
            }
            else {
                this.parent.setProperties({ created: this.parent.createdHandler }, true);
            }
            this.parent.createdHandler = undefined;
            this.parent.trigger(created, null);
            if (this.parent) {
                this.parent.notify(clearUndoRedoCollection, null);
            }
        }
        if (this.parent) {
            this.parent.notify(spreadsheetCreated, null);
        }
    }
    /**
     * This method is used to check whether row height increased above the viewport after import
     *
     * @param {Object} args - Specify the args.
     * @param {number} args.top - Specify the top value.
     * @param {number} args.left - Specify the left value.
     * @param {SheetModel} sheet - Specify the sheet.
     * @returns {void} - This method is used to check whether row height increased above the viewport after import
     */
    checkRowHeightChanged(args, sheet) {
        const eventArgs = { top: args.top, left: args.left, sheet: sheet };
        this.parent.notify(getUpdatedScrollPosition, eventArgs);
        if (args.top !== eventArgs.top) {
            if (this.parent.scrollModule && this.parent.scrollModule.offset.top.idx && (eventArgs.top - args.top) <
                getRowHeight(sheet, this.parent.scrollModule.offset.top.idx)) {
                this.parent.scrollModule.offset.top.size = eventArgs.top;
            }
            args.top = eventArgs.top;
        }
        if (args.left !== eventArgs.left) {
            if (this.parent.scrollModule && this.parent.scrollModule.offset.left.idx && (eventArgs.left - args.left) <
                getColumnWidth(sheet, this.parent.scrollModule.offset.left.idx)) {
                this.parent.scrollModule.offset.left.size = eventArgs.left;
            }
            args.left = eventArgs.left;
        }
    }
    checkTableWidth(sheet) {
        if (this.parent.scrollSettings.isFinite && !this.parent.scrollSettings.enableVirtualization && sheet.colCount - 1 ===
            this.parent.viewport.rightIndex) {
            const cellsWidth = getColumnsWidth(sheet, this.parent.viewport.leftIndex + this.parent.frozenColCount(sheet), this.parent.viewport.rightIndex);
            const rowHdrWidth = this.getRowHeaderWidth(sheet);
            const scrollSize = this.getScrollSize();
            if (cellsWidth < this.contentPanel.getBoundingClientRect().width - rowHdrWidth - scrollSize) {
                this.getContentPanel().style.width = cellsWidth + 'px';
                this.getColHeaderPanel().style.width = cellsWidth + 'px';
            }
            else if (!this.getContentPanel().style.width.includes('calc')) {
                this.getContentPanel().style.width = `calc(100% - ${rowHdrWidth}px)`;
                this.getColHeaderPanel().style.width = `calc(100% - ${rowHdrWidth}px)`;
            }
        }
    }
    clearCFResult(sheet) {
        if (sheet.conditionalFormats && sheet.conditionalFormats.length) {
            sheet.conditionalFormats.forEach((cfRule) => {
                delete cfRule.result;
            });
        }
    }
    refreshColumnContent(args) {
        let row;
        let count = 0;
        const sheet = this.parent.getActiveSheet();
        let cellArgs;
        const mergeBorderRows = [];
        const frag = document.createDocumentFragment();
        const hFrag = document.createDocumentFragment();
        let tBody = this.parent.element.querySelector('.e-sheet-content tbody');
        let hTBody = this.parent.element.querySelector('.e-column-header tbody');
        let colGrp = this.parent.element.querySelector('.e-sheet-content colgroup');
        colGrp = colGrp.cloneNode();
        frag.appendChild(colGrp);
        tBody = frag.appendChild(tBody.cloneNode(true));
        const hColGrp = colGrp.cloneNode();
        hFrag.appendChild(hColGrp);
        let tHead = this.parent.element.querySelector('.e-column-header thead');
        tHead = hFrag.appendChild(tHead.cloneNode(true));
        const hRow = tHead.querySelector('tr');
        hRow.innerText = '';
        const frozenRow = this.parent.frozenRowCount(sheet);
        const frozenCol = this.parent.frozenColCount(sheet);
        if (frozenRow) {
            hTBody = hFrag.appendChild(hTBody.cloneNode(true));
        }
        const lastFrozenRow = skipHiddenIdx(sheet, frozenRow - 1, false);
        const notFirstRow = this.parent.scrollSettings.enableVirtualization && this.parent.viewport.topIndex !==
            skipHiddenIdx(sheet, 0, true);
        this.clearCFResult(sheet);
        args.cells.forEach((value, key) => {
            const indexes = getRangeIndexes(key);
            if (indexes[0] === args.indexes[0]) {
                const col = this.updateCol(sheet, indexes[1], hColGrp);
                colGrp.appendChild(col.cloneNode());
                this.cellRenderer.renderColHeader(indexes[1], hRow);
            }
            if (indexes[1] - frozenCol === args.indexes[1]) {
                row = (indexes[0] < frozenRow) ? hTBody.children[count] : tBody.children[count];
                if (row) {
                    row.innerText = '';
                    count++;
                }
                else {
                    return;
                }
            }
            if (!row) {
                return;
            }
            cellArgs = {
                colIdx: indexes[1], rowIdx: indexes[0], cell: value, address: key, row: row, pRow: row.previousSibling,
                first: !args.skipUpdateOnFirst && indexes[1] === args.indexes[1] ? 'Column' :
                    (notFirstRow && indexes[0] === args.indexes[0] ? 'Row' : ''), isRefreshing: true, mergeBorderRows: mergeBorderRows
            };
            const cell = this.cellRenderer.render(cellArgs);
            this.checkColMerge(indexes, args.indexes, cell, value, sheet);
            if (frozenRow && indexes[0] === lastFrozenRow) {
                count = 0;
            } // Reset count for frozen row
        });
        const appendColumns = () => {
            let table = this.getColHeaderTable();
            removeAllChildren(table);
            table.appendChild(hFrag);
            table = this.getContentTable();
            removeAllChildren(table);
            table.appendChild(frag);
            this.parent.notify(virtualContentLoaded, { refresh: 'Column', prevRowColCnt: args.prevRowColCnt });
            updateMergeBorder(this.parent, mergeBorderRows);
            if (sheet.conditionalFormats && sheet.conditionalFormats.length) {
                this.parent.notify(applyCF, { indexes: args.indexes, isRender: true });
            }
            if (this.parent.isEdit) {
                this.parent.notify(forRefSelRender, {});
            }
            if (this.parent.allowChart) {
                this.parent.notify(chartRangeSelection, null);
            }
            if (!this.parent.isOpen) {
                this.parent.hideSpinner();
            }
            setAriaOptions(this.parent.getMainContent(), { busy: false });
        };
        if (args.insertDelete) {
            appendColumns();
        }
        else {
            getUpdateUsingRaf(() => appendColumns());
        }
    }
    refreshRowContent(args) {
        let row;
        let hdrRow;
        let colGroupWidth = this.colGroupWidth;
        const sheet = this.parent.getActiveSheet();
        let cell;
        let cellArgs;
        const mergeBorderRows = [];
        const frag = document.createDocumentFragment();
        const hFrag = document.createDocumentFragment();
        const tBody = this.parent.createElement('tbody');
        const hTBody = tBody.cloneNode();
        hFrag.appendChild(hTBody);
        frag.appendChild(tBody);
        const frozenCol = this.parent.frozenColCount(sheet);
        const lastFrozenCol = skipHiddenIdx(sheet, frozenCol - 1, false, 'columns');
        const notFirstCol = this.parent.scrollSettings.enableVirtualization && this.parent.viewport.leftIndex !==
            skipHiddenIdx(sheet, 0, true, 'columns');
        this.clearCFResult(sheet);
        args.cells.forEach((value, key) => {
            const indexes = getRangeIndexes(key);
            if (indexes[1] === args.indexes[1] || !row) {
                if (indexes[1] === args.indexes[1]) {
                    hdrRow = this.rowRenderer.render(indexes[0], true);
                }
                if (frozenCol && indexes[1] < frozenCol) {
                    hTBody.appendChild(hdrRow);
                    row = hdrRow;
                }
                else {
                    if (indexes[1] === args.indexes[1]) {
                        hTBody.appendChild(hdrRow);
                    }
                    row = this.rowRenderer.render(indexes[0]);
                    tBody.appendChild(row);
                }
                if (indexes[1] === args.indexes[1]) {
                    this.cellRenderer.renderRowHeader(indexes[0], hdrRow);
                    colGroupWidth = getColGroupWidth(indexes[0] + 1);
                }
            }
            if (frozenCol) {
                hdrRow = hTBody.lastElementChild || hdrRow;
            }
            cellArgs = {
                rowIdx: indexes[0], colIdx: indexes[1], cell: value, address: key, lastCell: indexes[1] === args.indexes[3], row: row, hRow: hdrRow, pRow: row.previousSibling,
                pHRow: hdrRow.previousSibling, isHeightCheckNeeded: true, first: !args.skipUpdateOnFirst && indexes[0] === args.indexes[0] ?
                    'Row' : (notFirstCol && indexes[1] === args.indexes[1] ? 'Column' : ''), isRefreshing: true, mergeBorderRows: mergeBorderRows
            };
            cell = this.cellRenderer.render(cellArgs);
            this.checkRowMerge(indexes, args.indexes, cell, value, sheet);
            if (frozenCol && indexes[1] === lastFrozenCol) {
                row = null;
            }
        });
        if (this.colGroupWidth !== colGroupWidth) {
            this.updateLeftColGroup(colGroupWidth);
        }
        const rowHeaderTbody = this.contentPanel.querySelector('.e-row-header tbody');
        if (rowHeaderTbody) {
            detach(rowHeaderTbody);
            this.getRowHeaderTable().appendChild(hFrag);
        }
        const sheetContentTbody = this.contentPanel.querySelector('.e-sheet-content tbody');
        if (sheetContentTbody) {
            detach(sheetContentTbody);
            this.getContentTable().appendChild(frag);
        }
        this.parent.notify(virtualContentLoaded, { refresh: 'Row', prevRowColCnt: args.prevRowColCnt });
        updateMergeBorder(this.parent, mergeBorderRows);
        if (sheet.conditionalFormats && sheet.conditionalFormats.length) {
            this.parent.notify(applyCF, { indexes: args.indexes, isRender: true });
        }
        if (this.parent.allowChart) {
            this.parent.notify(chartRangeSelection, {});
        }
        if (this.parent.isEdit) {
            this.parent.notify(forRefSelRender, null);
        }
        if (!this.parent.isOpen) {
            this.parent.hideSpinner();
        }
        setAriaOptions(this.parent.getMainContent(), { busy: false });
    }
    updateCol(sheet, idx, appendTo) {
        const col = this.col.cloneNode();
        col.style.width = formatUnit(getColumnWidth(sheet, idx, null, true));
        if (appendTo) {
            const empty = appendTo.querySelector('.e-empty');
            return empty ? appendTo.insertBefore(col, empty) : appendTo.appendChild(col);
        }
        else {
            return col;
        }
    }
    updateColContent(args) {
        getUpdateUsingRaf(() => {
            let row;
            let refChild;
            let rowCount = 0;
            let cell;
            let col;
            let skipRender;
            let cellArgs;
            const sheet = this.parent.getActiveSheet();
            const mergeBorderRows = [];
            const hRow = this.parent.element.querySelector('.e-column-header .e-header-row');
            const colGrp = this.parent.element.querySelector('.e-sheet-content colgroup');
            const hColGrp = this.parent.element.querySelector('.e-column-header colgroup');
            const hRefChild = hRow.firstElementChild;
            const colRefChild = colGrp.firstElementChild;
            const hColRefChild = hColGrp.firstElementChild;
            const tBody = this.parent.element.querySelector('.e-sheet-content tbody');
            const hTBody = this.parent.element.querySelector('.e-column-header tbody');
            const frozenRow = this.parent.frozenRowCount(sheet);
            const frozenCol = this.parent.frozenColCount(sheet);
            const lastFrozenRow = skipHiddenIdx(sheet, frozenRow - 1, false);
            const firstRow = skipHiddenIdx(sheet, args.indexes[0], true);
            this.clearCFResult(sheet);
            args.cells.forEach((value, key) => {
                if (skipRender) {
                    return;
                }
                const indexes = getRangeIndexes(key);
                if (args.direction === 'first' && indexes[1] === args.indexes[1]) {
                    this.checkColMerge([indexes[0], this.parent.viewport.leftIndex + frozenCol], args.indexes, ((indexes[0] < frozenRow ? hTBody : tBody).rows[rowCount] ||
                        { cells: [] }).cells[(args.indexes[3] - args.indexes[1]) + 1], getCell(indexes[0], this.parent.viewport.leftIndex + frozenCol, sheet) || {}, sheet);
                }
                if (indexes[0] === firstRow) {
                    if (args.direction === 'last') {
                        col = this.col.cloneNode();
                        col.style.width = formatUnit(getColumnWidth(sheet, indexes[1], null, true));
                        colGrp.insertBefore(col, colRefChild);
                        hColGrp.insertBefore(col.cloneNode(), hColRefChild);
                        this.cellRenderer.renderColHeader(indexes[1], hRow, hRefChild);
                    }
                    else {
                        col = this.updateCol(sheet, indexes[1], colGrp);
                        hColGrp.appendChild(col.cloneNode());
                        this.cellRenderer.renderColHeader(indexes[1], hRow);
                    }
                    if (this.parent.scrollSettings.enableVirtualization && args.direction) {
                        /* eslint-disable */
                        detach(colGrp[args.direction + 'ElementChild']);
                        detach(hColGrp[args.direction + 'ElementChild']);
                        detach(hRow[args.direction + 'ElementChild']);
                        /* eslint-enable */
                    }
                }
                if (indexes[1] === args.indexes[1]) {
                    if (indexes[0] < frozenRow) {
                        row = hTBody.children[rowCount];
                    }
                    else {
                        row = tBody.children[rowCount];
                        if (!row) {
                            skipRender = true;
                            return;
                        }
                    }
                    rowCount++;
                    refChild = row.firstElementChild;
                }
                cellArgs = {
                    colIdx: indexes[1], rowIdx: indexes[0], cell: value, address: key, row: row, pRow: row.previousSibling,
                    lastCell: indexes[1] === args.indexes[3], isHeightCheckNeeded: args.direction === 'first', first: args.direction ===
                        'last' && !args.skipUpdateOnFirst && indexes[1] === args.indexes[1] ? 'Column' : '', checkNextBorder: args.direction
                        === 'last' && indexes[3] === args.indexes[3] ? 'Column' : '', isRefreshing: args.direction === 'first',
                    mergeBorderRows: mergeBorderRows
                };
                if (args.direction === 'last') {
                    cellArgs.refChild = refChild;
                    cell = this.cellRenderer.render(cellArgs);
                    this.checkColMerge(indexes, args.indexes, cell, value, sheet, ((indexes[0] < frozenRow ? hTBody : tBody).rows[rowCount - 1] ||
                        { cells: [] }).cells[1]);
                }
                else {
                    cell = this.cellRenderer.render(cellArgs);
                }
                if (this.parent.scrollSettings.enableVirtualization && args.direction) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    detach(row[args.direction + 'ElementChild']);
                }
                if (frozenRow && indexes[0] === lastFrozenRow) {
                    rowCount = 0;
                }
            });
            this.parent.notify(virtualContentLoaded, { refresh: 'Column', prevRowColCnt: args.prevRowColCnt });
            updateMergeBorder(this.parent, mergeBorderRows);
            if (sheet.conditionalFormats && sheet.conditionalFormats.length) {
                this.parent.notify(applyCF, { indexes: args.indexes, isRender: true });
            }
            if (this.parent.allowChart) {
                this.parent.notify(chartRangeSelection, null);
            }
            if (this.parent.isEdit) {
                this.parent.notify(forRefSelRender, {});
            }
            if (!this.parent.isOpen) {
                this.parent.hideSpinner();
            }
            setAriaOptions(this.parent.getMainContent(), { busy: false });
        });
    }
    updateRowContent(args) {
        const mainContent = this.parent.getMainContent();
        if (args.direction === '' && !mainContent.children.length) {
            return;
        }
        let row;
        let hRow;
        let cell;
        let firstRow;
        let cellArgs;
        const mergeBorderRows = [];
        let count = 0;
        let colGroupWidth = this.colGroupWidth;
        const sheet = this.parent.getActiveSheet();
        const tBody = mainContent.querySelector('tbody');
        const rTBody = this.parent.getRowHeaderContent().querySelector('tbody');
        const rFrag = document.createDocumentFragment();
        const frag = document.createDocumentFragment();
        this.parent.showSpinner();
        const frozenCol = this.parent.frozenColCount(sheet);
        const frozenRow = this.parent.frozenRowCount(sheet);
        const firstCol = skipHiddenIdx(sheet, args.indexes[1], true, 'columns');
        const lastFrozenCol = skipHiddenIdx(sheet, frozenCol - 1, false, 'columns');
        this.clearCFResult(sheet);
        args.cells.forEach((value, cKey) => {
            const indexes = getRangeIndexes(cKey);
            let pHRow;
            let pRow;
            if (args.direction === 'first' && indexes[0] === args.indexes[0]) {
                pHRow = rTBody.rows[rTBody.rows.length - 1];
                pRow = tBody.rows[tBody.rows.length - 1];
                if (firstRow === undefined) {
                    firstRow = (indexes[1] < frozenCol ? rTBody : tBody).rows[(args.indexes[2] - args.indexes[0]) + 1] || null;
                }
                this.checkRowMerge([this.parent.viewport.topIndex + frozenRow, indexes[1]], args.indexes, (firstRow || { cells: [] }).cells[indexes[1] < frozenCol ? count + 1 : count], getCell(this.parent.viewport.topIndex + frozenRow, indexes[1], sheet) || {}, sheet);
            }
            if (indexes[1] === firstCol || !row) {
                if (indexes[1] === firstCol) {
                    hRow = this.rowRenderer.render(indexes[0], true);
                }
                if (frozenCol && indexes[1] < frozenCol) {
                    rFrag.appendChild(hRow);
                    row = hRow;
                }
                else {
                    row = this.rowRenderer.render(indexes[0]);
                    frag.appendChild(row);
                    if (indexes[1] === firstCol) {
                        rFrag.appendChild(hRow);
                    }
                    if (this.parent.scrollSettings.enableVirtualization && args.direction) {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        detach(tBody[args.direction + 'ElementChild']);
                    }
                }
                if (indexes[1] === firstCol) {
                    this.cellRenderer.renderRowHeader(indexes[0], hRow);
                    colGroupWidth = getColGroupWidth(indexes[0] + 1);
                    if (this.parent.scrollSettings.enableVirtualization && args.direction) {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        detach(rTBody[args.direction + 'ElementChild']);
                    }
                }
            }
            if (frozenCol) {
                hRow = rFrag.lastElementChild || hRow;
            }
            cellArgs = {
                colIdx: indexes[1], rowIdx: indexes[2], cell: value, address: cKey, row: row,
                lastCell: indexes[1] === args.indexes[3], pHRow: hRow.previousSibling || pHRow, checkNextBorder: args.direction === 'last' &&
                    indexes[2] === args.indexes[2] ? 'Row' : '', pRow: row.previousSibling || pRow, isHeightCheckNeeded: args.direction === 'first'
                    || args.direction === '', hRow: hRow, first: args.direction === 'last' && !args.skipUpdateOnFirst && indexes[0] ===
                    args.indexes[0] ? 'Row' : '', isRefreshing: args.direction === 'first', mergeBorderRows: mergeBorderRows
            };
            cell = this.cellRenderer.render(cellArgs);
            if (args.direction === 'last' && tBody.rows.length) {
                this.checkRowMerge(indexes, args.indexes, cell, value, sheet, (indexes[1] < frozenCol ? rTBody : tBody).rows[0].cells[indexes[1] < frozenCol ? count + 1 : count]);
            }
            count++;
            if (frozenCol && indexes[1] === lastFrozenCol) {
                row = null;
                firstRow = undefined;
                count = 0;
            }
        });
        if (this.colGroupWidth !== colGroupWidth) {
            this.updateLeftColGroup(colGroupWidth);
        }
        if (args.direction === 'last') {
            rTBody.insertBefore(rFrag, rTBody.firstElementChild);
            tBody.insertBefore(frag, tBody.firstElementChild);
        }
        else {
            rTBody.appendChild(rFrag);
            tBody.appendChild(frag);
        }
        if (this.parent.scrollSettings.enableVirtualization) {
            this.parent.notify(virtualContentLoaded, { refresh: 'Row', prevRowColCnt: args.prevRowColCnt });
        }
        updateMergeBorder(this.parent, mergeBorderRows);
        if (sheet.conditionalFormats && sheet.conditionalFormats.length) {
            this.parent.notify(applyCF, { indexes: args.indexes, isRender: true });
        }
        if (this.parent.isEdit) {
            this.parent.notify(forRefSelRender, null);
        }
        if (this.parent.allowChart) {
            this.parent.notify(chartRangeSelection, {});
        }
        if (!this.parent.isOpen) {
            this.parent.hideSpinner();
        }
        setAriaOptions(this.parent.getMainContent(), { busy: false });
    }
    checkRowMerge(indexes, range, cell, model, sheet, firstcell) {
        if (this.parent.scrollSettings.enableVirtualization && cell &&
            (!isNullOrUndefined(model.rowSpan) || !isNullOrUndefined(model.colSpan))) {
            const frozenRow = this.parent.frozenRowCount(sheet);
            const viewportTopIdx = this.parent.viewport.topIndex + frozenRow;
            if (indexes[0] === viewportTopIdx) {
                if (model.rowSpan < 0) {
                    const args = { td: cell, rowIdx: indexes[0], colIdx: indexes[1], isRow: true,
                        isFreezePane: true
                    };
                    this.parent.notify(checkMerge, args);
                    if (args.insideFreezePane) {
                        return;
                    }
                    if (viewportTopIdx >= range[2]) {
                        this.refreshPrevMerge(range[2] + 1, indexes[1]);
                    }
                }
                if (firstcell) {
                    this.refreshFirstCell(indexes[0] + (range[2] - range[0]) + 1, indexes[1], sheet, firstcell);
                }
            }
            else if (model.rowSpan > 1) {
                const prevTopIdx = range[2] + 1;
                if (indexes[0] + model.rowSpan - 1 >= prevTopIdx && indexes[0] < prevTopIdx) {
                    this.refreshPrevMerge(prevTopIdx, indexes[1], viewportTopIdx);
                }
            }
        }
    }
    refreshPrevMerge(prevTopIdx, colIndex, currTopIdx) {
        const td = this.parent.getCell(prevTopIdx, colIndex, this.parent.getRow(currTopIdx ?
            currTopIdx : 0, null, colIndex));
        if (td) {
            this.cellRenderer.refresh(prevTopIdx, colIndex, null, td);
        }
    }
    refreshFirstCell(rowIdx, colIdex, sheet, firstcell) {
        const cell = getCell(rowIdx, colIdex, sheet, false, true);
        if (cell.rowSpan < 0 || cell.colSpan < 0) {
            this.cellRenderer.refresh(rowIdx, colIdex, null, firstcell);
        }
    }
    checkColMerge(indexes, range, cell, model, sheet, firstcell) {
        if (this.parent.scrollSettings.enableVirtualization && cell && (!isNullOrUndefined(model.rowSpan) ||
            !isNullOrUndefined(model.colSpan))) {
            const frozenCol = this.parent.frozenColCount(sheet);
            const viewportLeftIdx = this.parent.viewport.leftIndex + frozenCol;
            if (indexes[1] === viewportLeftIdx) {
                if (model.colSpan < 0) {
                    const e = {
                        td: cell,
                        colIdx: indexes[1], rowIdx: indexes[0], isFreezePane: true
                    };
                    this.parent.notify(checkMerge, e);
                    if (e.insideFreezePane) {
                        return;
                    }
                    if (viewportLeftIdx >= range[3]) {
                        const td = this.parent.getCell(indexes[0], indexes[3] + 1, this.parent.getRow(indexes[0], null, indexes[3] + 1));
                        if (td) {
                            this.cellRenderer.refresh(indexes[0], range[3] + 1, null, td);
                        }
                    }
                }
                if (firstcell) {
                    this.refreshFirstCell(indexes[0], indexes[1] + (range[3] - range[1]) + 1, sheet, firstcell);
                }
            }
            else if (model.colSpan > 1) {
                if (indexes[1] + model.colSpan - 1 >= range[3] + 1 && indexes[1] < range[3] + 1) {
                    const td = this.parent.getCell(indexes[0], indexes[3] + 1, this.parent.getRow(indexes[0], null, indexes[3] + 1));
                    if (td) {
                        this.cellRenderer.refresh(indexes[0], range[3] + 1, null, td);
                    }
                }
            }
        }
    }
    toggleGridlines() {
        const sheetElem = document.getElementById(this.parent.element.id + '_sheet');
        if (this.parent.getActiveSheet().showGridLines) {
            sheetElem.classList.remove('e-hide-gridlines');
        }
        else {
            sheetElem.classList.add('e-hide-gridlines');
        }
    }
    /**
     * Used to toggle row and column headers.
     *
     * @returns {void}
     */
    showHideHeaders() {
        const sheet = this.parent.getActiveSheet();
        getUpdateUsingRaf(() => {
            if (sheet.showHeaders) {
                const content = this.getContentPanel();
                this.setPanelWidth(sheet, this.getRowHeaderPanel());
                this.setPanelHeight(sheet);
                document.getElementById(this.parent.element.id + '_sheet').classList.remove('e-hide-headers');
                this.getColHeaderPanel().scrollLeft = content.scrollLeft;
                this.parent.selectRange(sheet.selectedRange);
            }
            else {
                this.updateHideHeaders(sheet, document.getElementById(this.parent.element.id + '_sheet'));
                this.setPanelHeight(sheet);
                if (this.parent.frozenColCount(sheet) || this.parent.frozenRowCount(sheet)) {
                    this.setPanelWidth(sheet, this.getRowHeaderPanel());
                    this.parent.selectRange(sheet.selectedRange);
                }
                else {
                    this.getContentPanel().style.width = '';
                    this.getContentPanel().style[this.parent.enableRtl ? 'right' : 'left'] = '';
                }
                this.getScrollElement().style.left = this.getRowHeaderWidth(sheet) + 'px';
            }
        });
    }
    updateHideHeaders(sheet, ele) {
        if (!sheet.showHeaders) {
            ele.classList.add('e-hide-headers');
        }
    }
    rowHeightChanged(args) {
        if (args.threshold || args.isHideShow) {
            const sheet = this.parent.getActiveSheet();
            if (args.rowIdx < this.parent.frozenRowCount(sheet)) {
                this.setPanelHeight(sheet);
            }
        }
    }
    colWidthChanged(args) {
        if (args.threshold || args.isHideShow) {
            const sheet = this.parent.getActiveSheet();
            if (args.colIdx < this.parent.frozenColCount(sheet)) {
                this.setPanelWidth(sheet, this.getRowHeaderPanel());
            }
            this.checkTableWidth(sheet);
        }
    }
    getRowHeaderWidth(sheet, skipFreezeCheck, addScaling) {
        let width = 0;
        const scaleX = addScaling ? this.parent.viewport.scaleX : 1;
        if (!skipFreezeCheck && sheet.frozenColumns) {
            const leftIdx = getCellIndexes(sheet.topLeftCell)[1];
            width = getColumnsWidth(sheet, leftIdx, leftIdx + sheet.frozenColumns - 1, true) / scaleX;
        }
        width += (sheet.showHeaders ? getDPRValue(this.colGroupWidth) / scaleX : 0);
        return width;
    }
    getColHeaderHeight(sheet, skipHeader) {
        const topIndex = getCellIndexes(sheet.topLeftCell)[0];
        return (sheet.showHeaders && !skipHeader ? getDPRValue(31) : 0) +
            getRowsHeight(sheet, topIndex, topIndex + sheet.frozenRows - 1, true);
    }
    /**
     * Get the select all table element of spreadsheet
     *
     * @returns {HTMLElement} - Select all content element.
     */
    getSelectAllContent() {
        return this.headerPanel.getElementsByClassName('e-selectall-container')[0];
    }
    /**
     * Get the horizontal scroll element of spreadsheet
     *
     * @returns {HTMLElement} - Select all content element.
     */
    getScrollElement() {
        let elem;
        if (this.contentPanel) {
            elem = (this.contentPanel.parentElement || this.contentPanel.nextElementSibling);
        }
        return elem && elem.querySelector('.e-scroller');
    }
    /**
     * Get the select all table element of spreadsheet
     *
     * @returns {HTMLTableElement} - Select all table element.
     */
    getSelectAllTable() {
        return this.headerPanel.getElementsByClassName('e-selectall-table')[0];
    }
    /**
     * Get the column header element of spreadsheet
     *
     * @returns {HTMLTableElement} - Column header table element.
     */
    getColHeaderTable() {
        return this.headerPanel.getElementsByClassName('e-colhdr-table')[0];
    }
    /**
     * Get the row header table element of spreadsheet
     *
     * @returns {HTMLTableElement} - Row header table element.
     */
    getRowHeaderTable() {
        return this.contentPanel.getElementsByClassName('e-rowhdr-table')[0];
    }
    /**
     * Get the main content table element of spreadsheet
     *
     * @returns {Element} - Content table element.
     */
    getContentTable() {
        return this.contentPanel.getElementsByClassName('e-content-table')[0];
    }
    /**
     * Get the row header div element of spreadsheet
     *
     * @returns {HTMLElement} - Row header panel element.
     */
    getRowHeaderPanel() {
        return this.contentPanel.getElementsByClassName('e-row-header')[0];
    }
    /**
     * Get the column header div element of spreadsheet
     *
     * @returns {HTMLElement} - Column header panel element.
     */
    getColHeaderPanel() {
        return this.headerPanel.getElementsByClassName('e-column-header')[0];
    }
    /**
     * Get the main content div element of spreadsheet
     *
     * @returns {HTMLElement} - Content panel element.
     */
    getContentPanel() {
        return this.contentPanel.getElementsByClassName('e-sheet-content')[0];
    }
    addEventListener() {
        this.parent.on(created, this.triggerCreatedEvent, this);
        this.parent.on(rowHeightChanged, this.rowHeightChanged, this);
        this.parent.on(colWidthChanged, this.colWidthChanged, this);
        this.parent.on(spreadsheetDestroyed, this.removeEventListener, this);
    }
    /**
     * Clears the internal properties of Sheet module.
     *
     * @returns {void}
     */
    destroy() {
        if (this.headerPanel) {
            removeAllChildren(this.headerPanel);
            this.headerPanel.remove();
        }
        this.headerPanel = null;
        if (this.contentPanel) {
            removeAllChildren(this.contentPanel);
            this.contentPanel.remove();
        }
        this.contentPanel = null;
        if (this.col) {
            removeAllChildren(this.col);
            this.col.remove();
        }
        this.col = null;
        this.rowRenderer = null;
        this.cellRenderer = null;
        this.colGroupWidth = null;
        this.parent = null;
    }
    removeEventListener() {
        this.parent.off(created, this.triggerCreatedEvent);
        this.parent.off(rowHeightChanged, this.rowHeightChanged);
        this.parent.off(colWidthChanged, this.colWidthChanged);
        this.parent.off(spreadsheetDestroyed, this.removeEventListener);
    }
}

/**
 * RowRenderer module is used for creating row element
 *
 * @hidden
 */
class RowRenderer {
    constructor(parent) {
        this.parent = parent;
        this.element = this.parent.createElement('tr');
        this.cellRenderer = parent.serviceLocator.getService('cell');
        this.parent.on(deInitProperties, this.initProps, this);
    }
    render(index, isRowHeader, preventHiddenCls) {
        const row = this.element.cloneNode();
        const sheet = this.parent.getActiveSheet();
        if (index === undefined) {
            row.classList.add('e-header-row');
            return row;
        }
        row.classList.add('e-row');
        if (!this.bottomBorderWidth) {
            let width = 1;
            if (window.devicePixelRatio % 1 > 0) {
                const pointValue = (1 * window.devicePixelRatio) % 1;
                width = 1 + (pointValue ? ((pointValue > 0.5 ? (1 - pointValue) : -1 * pointValue) / window.devicePixelRatio) : 0);
            }
            this.bottomBorderWidth = width;
        }
        const rowHeight = getRowHeight(sheet, index, true);
        const actualRowHgt = getRowHeight(sheet, index);
        const rowStyles = {
            height: `${rowHeight}px`,
            lineHeight: (actualRowHgt < 20) ?
                (rowHeight > this.bottomBorderWidth ? `${rowHeight - this.bottomBorderWidth}px` : '0px') : ''
        };
        Object.assign(row.style, rowStyles);
        attributes(row, { 'aria-rowindex': (index + 1).toString() });
        if (isRowHeader && !preventHiddenCls) {
            if (actualRowHgt < 20) {
                const width = 4 + (this.bottomBorderWidth - 1);
                row.style.lineHeight = rowHeight >= width ? `${rowHeight - width}px` :
                    (rowHeight > this.bottomBorderWidth ? `${rowHeight - this.bottomBorderWidth}px` : '0px');
                if (!row.classList.contains('e-reach-fntsize')) {
                    row.classList.add('e-reach-fntsize');
                }
            }
            if (isHiddenRow(sheet, index + 1) && !isHiddenRow(sheet, index - 1)) {
                row.classList.add('e-hide-start');
            }
            if (index !== 0 && isHiddenRow(sheet, index - 1) && !isHiddenRow(sheet, index + 1)) {
                row.classList.add('e-hide-end');
            }
        }
        return row;
    }
    refresh(index, pRow, hRow, header, preventHiddenCls) {
        const sheet = this.parent.getActiveSheet();
        let row;
        if (header) {
            row = this.render(index, header, preventHiddenCls);
            this.cellRenderer.renderRowHeader(index, row);
        }
        else {
            let i;
            let len;
            const updateCells = () => {
                while (i <= len) {
                    if (!isHiddenCol(sheet, i)) {
                        this.cellRenderer.render({ colIdx: i, rowIdx: index, cell: getCell(index, i, sheet), address: getCellAddress(index, i),
                            lastCell: i === len, row: row, hRow: hRow, isHeightCheckNeeded: true, pRow: pRow, first: index === this.parent.viewport.topIndex && skipHiddenIdx(sheet, index, true) !==
                                skipHiddenIdx(sheet, 0, true) ? 'Row' : '', skipFormatCheck: isImported(this.parent), checkCF: true });
                    }
                    i++;
                }
            };
            const frozenCol = this.parent.frozenColCount(sheet);
            if (frozenCol) {
                row = hRow;
                i = getCellIndexes(sheet.topLeftCell)[0];
                len = frozenCol - 1;
                updateCells();
            }
            row = this.render(index, header, preventHiddenCls);
            i = this.parent.viewport.leftIndex + frozenCol;
            len = this.parent.viewport.rightIndex;
            updateCells();
        }
        return row;
    }
    initProps() {
        this.bottomBorderWidth = null;
    }
    /**
     * Clears the internal properties of RowRenderer module.
     *
     * @returns {void}
     */
    destroy() {
        this.parent.off(deInitProperties, this.initProps);
        if (this.element) {
            this.element.remove();
        }
        if (this.bottomBorderWidth) {
            this.bottomBorderWidth = null;
        }
        this.parent = null;
        this.element = null;
    }
}

/**
 * CellRenderer class which responsible for building cell content.
 *
 * @hidden
 */
class CellRenderer {
    constructor(parent) {
        this.parent = parent;
        this.element = this.parent.createElement('td');
        this.th = this.parent.createElement('th', { className: 'e-header-cell' });
        this.tableRow = parent.createElement('tr', { className: 'e-row' });
        this.parent.on(updateView, this.updateView, this);
        this.parent.on(calculateFormula, this.calculateFormula, this);
    }
    renderColHeader(index, row, refChild) {
        const headerCell = this.th.cloneNode();
        const headerText = getColumnHeaderText(index + 1);
        headerCell.innerText = headerText;
        const sheet = this.parent.getActiveSheet();
        if (isHiddenCol(sheet, index + 1)) {
            headerCell.classList.add('e-hide-start');
        }
        if (index !== 0 && isHiddenCol(sheet, index - 1)) {
            headerCell.classList.add('e-hide-end');
        }
        if (refChild) {
            row.insertBefore(headerCell, refChild);
        }
        else {
            row.appendChild(headerCell);
        }
        this.parent.trigger('beforeCellRender', { cell: null, element: headerCell, address: headerText, colIndex: index });
        this.parent.notify(renderFilterCell, { td: headerCell, rowIndex: 0, colIndex: index });
        attributes(headerCell, { 'aria-colindex': (index + 1).toString(), 'tabindex': '-1' });
    }
    renderRowHeader(index, row, refChild) {
        const headerCell = this.element.cloneNode();
        addClass([headerCell], 'e-header-cell');
        attributes(headerCell, { 'role': 'rowheader', 'tabindex': '-1' });
        headerCell.innerText = (index + 1).toString();
        if (refChild) {
            row.insertBefore(headerCell, refChild);
        }
        else {
            row.appendChild(headerCell);
        }
        this.parent.trigger('beforeCellRender', { cell: null, element: headerCell, address: `${index + 1}`, rowIndex: index });
    }
    render(args) {
        const sheet = this.parent.getActiveSheet();
        args.td = this.element.cloneNode();
        args.td.className = 'e-cell';
        attributes(args.td, { 'aria-colindex': (args.colIdx + 1).toString(), 'tabindex': '-1' });
        if (this.checkMerged(args)) {
            this.createImageAndChart(args);
            if (args.refChild) {
                args.row.insertBefore(args.td, args.refChild);
            }
            else {
                args.row.appendChild(args.td);
            }
            return args.td;
        }
        args.isRefresh = false;
        args.skipFormatCheck = isImported(this.parent);
        const isTemplateCell = this.update(args);
        if (args.checkCF && args.cell && sheet.conditionalFormats && sheet.conditionalFormats.length) {
            this.parent.notify(applyCF, { indexes: [args.rowIdx, args.colIdx], cell: args.cell, ele: args.td, isRender: true });
        }
        if (!args.td.classList.contains('e-cell-template')) {
            this.parent.notify(renderFilterCell, { td: args.td, rowIndex: args.rowIdx, colIndex: args.colIdx });
        }
        if (args.refChild) {
            args.row.insertBefore(args.td, args.refChild);
        }
        else {
            args.row.appendChild(args.td);
        }
        const evtArgs = { cell: args.cell, element: args.td, address: args.address, rowIndex: args.rowIdx, colIndex: args.colIdx, needHeightCheck: false, row: args.row };
        this.parent.trigger('beforeCellRender', evtArgs);
        if (!sheet.rows[args.rowIdx] || !sheet.rows[args.rowIdx].customHeight) {
            if (evtArgs.needHeightCheck || (isTemplateCell && evtArgs.element && evtArgs.element.children.length)) {
                const clonedCell = evtArgs.element.cloneNode(true);
                clonedCell.style.width = getColumnWidth(sheet, args.colIdx, true) + 'px';
                this.tableRow.appendChild(clonedCell);
            }
            if (args.lastCell && this.tableRow.childElementCount) {
                const rowHeight = this.getRowHeightOnInit();
                if (rowHeight > getRowHeight(sheet, args.rowIdx)) {
                    setRowEleHeight(this.parent, sheet, rowHeight, args.rowIdx, args.row, args.hRow);
                }
                this.tableRow.innerText = '';
            }
        }
        this.setWrapByValue(sheet, args);
        return evtArgs.element;
    }
    setWrapByValue(sheet, args) {
        if (args.cell && isNullOrUndefined(args.cell.wrap) && args.cell.value && args.cell.value.toString().includes('\n')) {
            setCell(args.rowIdx, args.colIdx, sheet, { wrap: true }, true);
            this.parent.notify(wrapEvent, { range: [args.rowIdx, args.colIdx, args.rowIdx, args.colIdx], wrap: true, initial: true, sheet: sheet,
                td: args.td, row: args.row, hRow: args.hRow });
        }
    }
    update(args) {
        const sheet = this.parent.getActiveSheet();
        let isTemplateCell;
        // In SF-425413 ticket, we suggested to add the template property in the cell model to render the template using updateCell method.
        if (!args.isRefresh || (args.cell && args.cell.template)) {
            const compiledTemplate = this.processTemplates(args.cell, args.rowIdx, args.colIdx);
            if (compiledTemplate) {
                if (typeof compiledTemplate === 'string') {
                    args.td.innerHTML = compiledTemplate;
                }
                else {
                    removeAllChildren(args.td);
                    append(compiledTemplate, args.td);
                }
                args.td.classList.add('e-cell-template');
                isTemplateCell = true;
            }
        }
        if (args.isRefresh) {
            if (args.td.rowSpan) {
                this.mergeFreezeRow(sheet, args.rowIdx, args.colIdx, args.td.rowSpan, args.row, true);
                args.td.removeAttribute('rowSpan');
            }
            if (args.td.colSpan) {
                this.mergeFreezeCol(sheet, args.rowIdx, args.colIdx, args.td.colSpan, true);
                args.td.removeAttribute('colSpan');
            }
            if (this.checkMerged(args)) {
                return false;
            }
            if (args.cell && !args.cell.hyperlink) {
                const hyperlink = args.td.querySelector('.e-hyperlink');
                if (hyperlink) {
                    detach(hyperlink);
                }
            }
            if (args.cell && args.td.children.length > 0 &&
                args.td.children[args.td.childElementCount - 1].className.indexOf('e-addNoteIndicator') > -1) {
                const noteIndicator = args.td.querySelector('.e-addNoteIndicator');
                if (noteIndicator) {
                    detach(noteIndicator);
                }
            }
            if ((!args.cell || !this.parent.allowWrap) && args.td.classList.contains('e-wraptext')) {
                args.td.classList.remove('e-wraptext');
            }
        }
        if (args.cell && args.cell.formula && !args.isRandomFormula && this.parent.calculationMode === 'Automatic') {
            this.calculateFormula(args);
            if (args.fillType && args.fillType === 'FillWithoutFormatting') {
                delete args.cell.format;
            }
        }
        const formatArgs = { value: args.cell && args.cell.value,
            type: args.cell && getTypeFromFormat(args.cell.format), format: args.cell && args.cell.format,
            formattedText: args.cell && args.cell.value, isRightAlign: false, cell: args.cell, rowIndex: args.rowIdx, colIndex: args.colIdx,
            td: args.td, skipFormatCheck: args.skipFormatCheck, refresh: true };
        if (this.parent.calculationMode === 'Manual' && args.cell && !args.cell.value && args.cell.value !== '' && args.cell.formula) {
            formatArgs.value = 0;
            args.cell.value = '0';
        }
        if (args.cell) {
            this.parent.notify(getFormattedCellObject, formatArgs);
        }
        this.parent.refreshNode(args.td, formatArgs);
        let style = {};
        if (args.cell) {
            if (args.cell.style) {
                if (args.cell.style.properties) {
                    style = skipDefaultValue(args.cell.style, true);
                }
                else {
                    style = args.cell.style;
                }
            }
            if (formatArgs.color !== undefined) {
                style = Object.assign({}, style);
                style.color = formatArgs.color;
            }
            this.createImageAndChart(args);
            if (args.cell.hyperlink) {
                if (args.fillType === 'FillFormattingOnly') {
                    args.td.style.textDecoration = 'underline';
                    args.td.style.color = '#00e';
                }
                else {
                    this.parent.notify(createHyperlinkElement, {
                        cell: args.cell, style: style, td: args.td, rowIdx: args.rowIdx,
                        colIdx: args.colIdx, fillType: args.fillType, action: args.action
                    });
                }
            }
            if (args.cell.rowSpan > 1) {
                const rowSpan = args.rowSpan || (args.cell.rowSpan -
                    this.parent.hiddenCount(args.rowIdx, args.rowIdx + (args.cell.rowSpan - 1)));
                if (rowSpan > 1) {
                    args.td.rowSpan = rowSpan;
                    this.mergeFreezeRow(sheet, args.rowIdx, args.colIdx, rowSpan, args.row);
                }
            }
            if (args.cell.colSpan > 1) {
                const colSpan = args.colSpan || (args.cell.colSpan -
                    this.parent.hiddenCount(args.colIdx, args.colIdx + (args.cell.colSpan - 1), 'columns'));
                if (colSpan > 1) {
                    args.td.colSpan = colSpan;
                    this.mergeFreezeCol(sheet, args.rowIdx, args.colIdx, colSpan);
                }
            }
            if (!isNullOrUndefined(args.cell.notes) && !args.fillType) {
                this.parent.notify(createNoteIndicator, { targetElement: args.td, rowIndex: args.rowIdx, columnIndex: args.colIdx });
            }
            else if (!isNullOrUndefined(args.td) && args.td.children.length > 0 && args.td.children[args.td.childElementCount - 1].className.indexOf('e-addNoteIndicator') > -1) {
                this.parent.notify(deleteNote, { rowIndex: args.rowIdx, columnIndex: args.colIdx });
            }
            if (args.cell.isNoteEditable) {
                this.parent.notify(showNote, { rowIndex: args.rowIdx, columnIndex: args.colIdx, isNoteEditable: true,
                    isScrollWithNote: true, cellElement: args.td });
            }
        }
        if (args.isRefresh && isNullOrUndefined(args.cell) && !isNullOrUndefined(args.td) && args.td.children.length > 0 && args.td.children[args.td.childElementCount - 1].className.indexOf('e-addNoteIndicator') > -1) {
            this.parent.notify(deleteNote, { rowIndex: args.rowIdx, columnIndex: args.colIdx });
        }
        if (args.isRefresh) {
            this.removeStyle(args.td, args.rowIdx, args.colIdx);
        }
        if (args.lastCell && this.parent.chartColl && this.parent.chartColl.length) {
            this.parent.notify(refreshChart, {
                cell: args.cell, rIdx: args.rowIdx, cIdx: args.colIdx, sheetIdx: this.parent.activeSheetIndex, isSelectAll: args.isSelectAll
            });
        }
        this.applyStyle(args, style);
        if (args.checkNextBorder === 'Row') {
            const borderTop = this.parent.getCellStyleValue(['borderTop'], [Number(this.parent.getContentTable().rows[0].getAttribute('aria-rowindex')) - 1, args.colIdx]).borderTop;
            if (borderTop !== '' && (!args.cell || !args.cell.style || !args.cell.style.bottomPriority)) {
                args.style = { borderBottom: borderTop };
                this.parent.notify(applyCellFormat, args);
            }
        }
        if (args.checkNextBorder === 'Column') {
            const borderLeft = this.parent.getCellStyleValue(['borderLeft'], [args.rowIdx, args.colIdx + 1]).borderLeft;
            if (borderLeft !== '' && (!args.cell || !args.cell.style || (!args.cell.style.borderRight && !args.cell.style.border))) {
                args.style = { borderRight: borderLeft };
                this.parent.notify(applyCellFormat, args);
            }
        }
        if (args.cell && !isNullOrUndefined(args.cell.wrap)) {
            this.parent.notify(wrapEvent, {
                range: [args.rowIdx, args.colIdx, args.rowIdx, args.colIdx], wrap: args.cell.wrap, sheet: sheet, initial: true, td: args.td,
                row: args.row, hRow: args.hRow, isCustomHgt: !args.isRefresh &&
                    getRowHeight(sheet, args.rowIdx) > (sheet && sheet.standardHeight ? sheet.standardHeight : 20)
            });
        }
        let validation;
        let col;
        if (args.cell && args.cell.validation) {
            validation = args.cell.validation;
            col = sheet.columns && sheet.columns[args.colIdx];
        }
        else {
            validation = checkColumnValidation(sheet.columns && sheet.columns[args.colIdx], args.rowIdx, args.colIdx) &&
                sheet.columns[args.colIdx].validation;
        }
        if (validation) {
            if (validation.isHighlighted) {
                args.validation = validation;
                args.col = col;
                this.parent.notify(updateHighlight, args);
            }
            if (validation.type === 'List' && !args.isRefresh && args.address === sheet.activeCell) {
                args.validation = validation;
                this.parent.notify(addListValidationDropdown, args);
            }
        }
        return isTemplateCell;
    }
    applyStyle(args, style) {
        if (Object.keys(style).length || Object.keys(this.parent.commonCellStyle).length || args.lastCell) {
            args.style = extend({}, this.parent.commonCellStyle, style);
            this.parent.notify(applyCellFormat, args);
        }
    }
    createImageAndChart(args) {
        if (args.cell.chart && args.cell.chart.length > 0) {
            this.parent.notify(setChart, { chart: args.cell.chart, isInitCell: true, range: getCellAddress(args.rowIdx, args.colIdx),
                isUndoRedo: false });
        }
        if (args.cell.image && args.cell.image.length > 0) {
            for (let i = 0; i < args.cell.image.length; i++) {
                if (args.cell.image[i]) {
                    this.parent.notify(createImageElement, {
                        options: {
                            src: args.cell.image[i].src, id: args.cell.image[i].id,
                            height: args.cell.image[i].height, width: args.cell.image[i].width,
                            top: args.cell.image[i].top, left: args.cell.image[i].left
                        },
                        range: getRangeAddress([args.rowIdx, args.colIdx, args.rowIdx, args.colIdx]), isPublic: false
                    });
                }
            }
        }
    }
    calculateFormula(args) {
        if (args.cell.value !== undefined && args.cell.value !== null) {
            const eventArgs = { action: 'checkFormulaAdded', added: true, address: args.address, sheetId: (args.sheetIndex === undefined ? this.parent.getActiveSheet() :
                    getSheet(this.parent, args.sheetIndex)).id.toString() };
            this.parent.notify(workbookFormulaOperation, eventArgs);
            if (eventArgs.added) {
                return;
            }
        }
        else if (args.formulaRefresh) {
            args.cell.value = '';
        }
        const isFormula = checkIsFormula(args.cell.formula);
        const eventArgs = {
            action: 'refreshCalculate', value: args.cell.formula, rowIndex: args.rowIdx, colIndex: args.colIdx,
            isFormula: isFormula, sheetIndex: args.sheetIndex, isRefreshing: args.isRefreshing,
            isDependentRefresh: args.isDependentRefresh, isRandomFormula: args.isRandomFormula, fillType: args.fillType
        };
        if (this.parent.calculationMode === 'Automatic' || args.isSortAction || args.action === 'calculate' || args.isDependentRefresh) {
            this.parent.notify(workbookFormulaOperation, eventArgs);
        }
        if ((args.cell.value === undefined && this.parent.calculationMode === 'Manual' && !this.parent.getActiveSheet().isSheetCalculated)
            || (this.parent.isEdit && args.cell.value === '#CIRCULARREF!')) {
            args.cell.value = '0';
        }
        args.cell.value = getCell(args.rowIdx, args.colIdx, isNullOrUndefined(args.sheetIndex) ? this.parent.getActiveSheet() :
            getSheet(this.parent, args.sheetIndex)).value;
        if (isFormula && (args.cell.formula.indexOf('^+') > -1 || args.cell.formula.indexOf('&+') > -1)) {
            args.cell.formula = eventArgs.value; // for correcting the formulas 5^+3=>5^3 and 5&+3=>5&3 while rendering like Excel.
        }
    }
    checkMerged(args) {
        if (args.cell && (args.cell.colSpan < 0 || args.cell.rowSpan < 0)) {
            const sheet = this.parent.getActiveSheet();
            if (sheet.frozenRows || sheet.frozenColumns) {
                const mergeArgs = { range: [args.rowIdx, args.colIdx, args.rowIdx, args.colIdx] };
                this.parent.notify(activeCellMergedRange, mergeArgs);
                const frozenRow = this.parent.frozenRowCount(sheet);
                const frozenCol = this.parent.frozenColCount(sheet);
                let setDisplay;
                mergeArgs.range = mergeArgs.range;
                if (sheet.frozenRows && sheet.frozenColumns) {
                    if (mergeArgs.range[0] < frozenRow && mergeArgs.range[1] < frozenCol) {
                        setDisplay = args.rowIdx < frozenRow && args.colIdx < frozenCol;
                    }
                    else if (mergeArgs.range[0] < frozenRow) {
                        setDisplay = args.rowIdx < frozenRow;
                    }
                    else if (mergeArgs.range[1] < frozenCol) {
                        setDisplay = args.colIdx < frozenCol;
                    }
                    else {
                        setDisplay = true;
                    }
                }
                else {
                    setDisplay = frozenRow ? (mergeArgs.range[0] >= frozenRow || args.rowIdx < frozenRow) : (mergeArgs.range[1] >= frozenCol
                        || args.colIdx < frozenCol);
                }
                if (setDisplay) {
                    args.td.style.display = 'none';
                }
            }
            else {
                args.td.style.display = 'none';
            }
            args.isMerged = true;
            const rowSpan = args.cell.rowSpan;
            const colSpan = args.cell.colSpan;
            if (colSpan < 0 || rowSpan < 0) {
                this.parent.notify(checkPrevMerge, args);
                if (colSpan < 0 && args.cell.style && args.cell.style.borderTop) {
                    this.applyStyle(args, { borderTop: args.cell.style.borderTop });
                }
                if (rowSpan < 0 && args.cell.style && args.cell.style.borderLeft) {
                    this.applyStyle(args, { borderLeft: args.cell.style.borderLeft });
                }
            }
            return args.isMerged;
        }
        return false;
    }
    mergeFreezeRow(sheet, rowIdx, colIdx, rowSpan, tr, unMerge) {
        const frozenRow = this.parent.frozenRowCount(sheet);
        if (frozenRow && rowIdx < frozenRow && rowIdx + (rowSpan - 1) >= frozenRow) {
            let rowEle;
            let spanRowTop = 0;
            let height;
            const frozenCol = this.parent.frozenColCount(sheet);
            const row = tr || this.parent.getRow(rowIdx, null, colIdx);
            const emptyRows = [].slice.call(row.parentElement.querySelectorAll('.e-empty'));
            if (unMerge) {
                const curEmptyLength = rowIdx + rowSpan - frozenRow;
                if (curEmptyLength < emptyRows.length) {
                    return;
                }
                else {
                    let curSpan = 0;
                    if (curEmptyLength === emptyRows.length) {
                        let curCell;
                        let i;
                        let len;
                        if (frozenCol && colIdx < frozenCol) {
                            i = getCellIndexes(sheet.topLeftCell)[1];
                            len = frozenCol;
                        }
                        else {
                            i = this.parent.viewport.leftIndex + frozenCol;
                            len = this.parent.viewport.rightIndex;
                        }
                        for (i; i < len; i++) {
                            if (i === colIdx) {
                                continue;
                            }
                            curCell = getCell(rowIdx, i, sheet, false, true);
                            if (curCell.rowSpan && rowIdx + curCell.rowSpan - frozenRow > curSpan) {
                                curSpan = rowIdx + curCell.rowSpan - frozenRow;
                            }
                        }
                        if (curSpan === curEmptyLength) {
                            return;
                        }
                    }
                    else {
                        curSpan = curEmptyLength;
                    }
                    let lastRowIdx = rowIdx + (rowSpan - 1);
                    for (let i = curSpan, len = emptyRows.length; i < len; i++) {
                        spanRowTop += getRowHeight(sheet, lastRowIdx);
                        lastRowIdx--;
                        detach(emptyRows.pop());
                    }
                    this.updateSpanTop(colIdx, frozenCol, spanRowTop, true);
                    if (!emptyRows.length) {
                        this.updateColZIndex(colIdx, frozenCol, true);
                    }
                    return;
                }
            }
            this.updateColZIndex(colIdx, frozenCol);
            for (let i = frozenRow, len = rowIdx + (rowSpan - 1); i <= len; i++) {
                height = getRowHeight(sheet, skipHiddenIdx(sheet, i, true), true);
                spanRowTop += -height;
                if (frozenRow + emptyRows.length > i) {
                    continue;
                }
                rowEle = row.cloneNode();
                rowEle.classList.add('e-empty');
                rowEle.style.visibility = 'hidden';
                rowEle.style.height = height + 'px';
                row.parentElement.appendChild(rowEle);
            }
            this.updateSpanTop(colIdx, frozenCol, spanRowTop);
        }
    }
    updateSpanTop(colIdx, frozenCol, top, update) {
        const mainPanel = this.parent.serviceLocator.getService('sheet').contentPanel;
        if (update) {
            if (!parseInt(mainPanel.style.top, 10)) {
                return;
            }
            top = parseInt(mainPanel.style.top, 10) + top;
        }
        if (frozenCol && colIdx < frozenCol && (update || !parseInt(mainPanel.style.top, 10) || top <
            parseInt(mainPanel.style.top, 10))) {
            mainPanel.style.top = top + 'px';
            const scroll = mainPanel.nextElementSibling;
            if (scroll) {
                scroll.style.top = top + 'px';
            }
        }
    }
    mergeFreezeCol(sheet, rowIdx, colIdx, colSpan, unMerge) {
        const frozenCol = this.parent.frozenColCount(sheet);
        if (frozenCol && colIdx < frozenCol && colIdx + (colSpan - 1) >= frozenCol) {
            let col;
            let width;
            const frozenRow = this.parent.frozenRowCount(sheet);
            const colGrp = (rowIdx < frozenRow ? this.parent.getSelectAllContent() : this.parent.getRowHeaderContent()).querySelector('colgroup');
            const emptyCols = [].slice.call(colGrp.querySelectorAll('.e-empty'));
            if (unMerge) {
                const curEmptyLength = colIdx + colSpan - frozenCol;
                if (curEmptyLength < emptyCols.length) {
                    return;
                }
                else {
                    let curSpan = 0;
                    if (curEmptyLength === emptyCols.length) {
                        let curCell;
                        let len;
                        let i;
                        if (frozenRow && rowIdx < frozenRow) {
                            len = frozenRow;
                            i = getCellIndexes(sheet.topLeftCell)[0];
                        }
                        else {
                            len = this.parent.viewport.bottomIndex;
                            i = this.parent.viewport.topIndex + frozenRow;
                        }
                        for (i; i < len; i++) {
                            if (i === rowIdx) {
                                continue;
                            }
                            curCell = getCell(i, colIdx, sheet, false, true);
                            if (curCell.colSpan && colIdx + curCell.colSpan - frozenCol > curSpan) {
                                curSpan = colIdx + curCell.colSpan - frozenCol;
                            }
                        }
                        if (curSpan === curEmptyLength) {
                            return;
                        }
                    }
                    else {
                        curSpan = curEmptyLength;
                    }
                    for (let i = curSpan, len = emptyCols.length; i < len; i++) {
                        detach(emptyCols.pop());
                    }
                    this.parent.serviceLocator.getService('sheet').setPanelWidth(sheet, this.parent.getRowHeaderContent());
                    if (!emptyCols.length) {
                        this.updateRowZIndex(rowIdx, frozenRow, true);
                    }
                    return;
                }
            }
            this.updateRowZIndex(rowIdx, frozenRow);
            for (let i = frozenCol, len = colIdx + (colSpan - 1); i <= len; i++) {
                if (frozenCol + emptyCols.length > i) {
                    continue;
                }
                col = colGrp.childNodes[0].cloneNode();
                col.classList.add('e-empty');
                col.style.visibility = 'hidden';
                width = getColumnWidth(sheet, skipHiddenIdx(sheet, i, true, 'columns'), null, true);
                col.style.width = width + 'px';
                colGrp.appendChild(col);
                if (i === len) {
                    this.parent.serviceLocator.getService('sheet').setPanelWidth(sheet, this.parent.getRowHeaderContent());
                }
            }
        }
    }
    updateColZIndex(colIdx, frozenCol, remove) {
        if (colIdx < frozenCol) {
            this.updateSelectAllZIndex(remove);
        }
        else {
            this.parent.getColumnHeaderContent().style.zIndex = remove ? '' : '2';
            this.updatedHeaderZIndex(remove);
        }
    }
    updateSelectAllZIndex(remove) {
        const frozenRowEle = this.parent.element.querySelector('.e-frozen-row');
        const frozenColEle = this.parent.element.querySelector('.e-frozen-column');
        if (remove) {
            this.parent.getSelectAllContent().style.zIndex = '';
            if (frozenRowEle) {
                frozenRowEle.style.zIndex = '';
            }
            if (frozenColEle) {
                frozenColEle.style.zIndex = '';
            }
        }
        else {
            const rowHeader = this.parent.getRowHeaderContent();
            const colHeader = this.parent.getColumnHeaderContent();
            if (rowHeader.style.zIndex || colHeader.style.zIndex) {
                this.parent.getSelectAllContent().style.zIndex = '3';
                if (frozenRowEle) {
                    frozenRowEle.style.zIndex = '4';
                }
                if (frozenColEle) {
                    frozenColEle.style.zIndex = '4';
                }
                const rowHdrSelection = rowHeader.querySelector('.e-selection');
                if (rowHdrSelection) {
                    rowHdrSelection.style.zIndex = '3';
                }
                const colHdrSelection = colHeader.querySelector('.e-selection');
                if (colHdrSelection) {
                    colHdrSelection.style.zIndex = '3';
                }
            }
            else {
                this.parent.getSelectAllContent().style.zIndex = '2';
            }
        }
    }
    updatedHeaderZIndex(remove) {
        if (!remove && this.parent.getSelectAllContent().style.zIndex === '2') {
            this.parent.getSelectAllContent().style.zIndex = '3';
            const frozenRowEle = this.parent.element.querySelector('.e-frozen-row');
            const frozenColEle = this.parent.element.querySelector('.e-frozen-column');
            if (frozenColEle) {
                frozenColEle.style.zIndex = '4';
            }
            if (frozenRowEle) {
                frozenRowEle.style.zIndex = '4';
            }
            const rowHdrSelection = this.parent.getRowHeaderContent().querySelector('.e-selection');
            if (rowHdrSelection) {
                rowHdrSelection.style.zIndex = '3';
            }
            const colHdrSelection = this.parent.getColumnHeaderContent().querySelector('.e-selection');
            if (colHdrSelection) {
                colHdrSelection.style.zIndex = '3';
            }
        }
    }
    updateRowZIndex(rowIdx, frozenRow, remove) {
        if (rowIdx < frozenRow) {
            this.updateSelectAllZIndex(remove);
        }
        else {
            this.parent.getRowHeaderContent().style.zIndex = remove ? '' : '2';
            this.updatedHeaderZIndex(remove);
        }
    }
    processTemplates(cell, rowIdx, colIdx) {
        const sheet = this.parent.getActiveSheet();
        const ranges = sheet.ranges;
        let range;
        for (let j = 0, len = ranges.length; j < len; j++) {
            if (ranges[j].template) {
                range = getRangeIndexes(ranges[j].address.length ? ranges[j].address : ranges[j].startCell);
                if (range[0] <= rowIdx && range[1] <= colIdx && range[2] >= rowIdx && range[3] >= colIdx) {
                    if (cell) {
                        return this.compileCellTemplate(ranges[j].template, Object.assign({ rowIndex: rowIdx, colIndex: colIdx }, cell));
                    }
                    else {
                        if (!getCell(rowIdx, colIdx, sheet, true)) {
                            return this.compileCellTemplate(ranges[j].template, Object.assign({ rowIndex: rowIdx, colIndex: colIdx }, getCell(rowIdx, colIdx, sheet, null, true)));
                        }
                    }
                }
            }
        }
        return '';
    }
    compileCellTemplate(template, cell) {
        let compiledStr;
        if (typeof template === 'string') {
            let templateString;
            if (template.trim().indexOf('#') === 0) {
                templateString = document.querySelector(template).innerHTML.trim();
            }
            else {
                templateString = template;
            }
            compiledStr = compile(templateString);
            if (!(this.parent).isVue || this.isSelector(template)) {
                return compiledStr(cell, this.parent, 'ranges', '', true)[0].outerHTML;
            }
            else {
                return compiledStr(cell, this.parent, 'ranges', '');
            }
        }
        else {
            compiledStr = compile(template);
            const compiledTemplate = compiledStr(cell, this.parent, 'ranges', '');
            return compiledTemplate[0] ? compiledTemplate : [compiledTemplate];
        }
    }
    isSelector(template) {
        try {
            return !!document.querySelector(template);
        }
        catch (err) {
            return false;
        }
    }
    getRowHeightOnInit() {
        const tTable = this.parent.createElement('table', { className: 'e-table e-test-table' });
        const tBody = tTable.appendChild(this.parent.createElement('tbody'));
        tBody.appendChild(this.tableRow);
        this.parent.element.appendChild(tTable);
        const height = this.tableRow.getBoundingClientRect().height;
        this.parent.element.removeChild(tTable);
        return height < 20 ? 20 : height;
    }
    removeStyle(element, rowIdx, colIdx) {
        let cellStyle;
        if (element.style.length) {
            cellStyle = this.parent.getCellStyleValue(['borderLeft', 'border'], [rowIdx, colIdx + 1]);
            const rightBorder = cellStyle.borderLeft || cellStyle.border;
            cellStyle = this.parent.getCellStyleValue(['borderTop', 'border'], [rowIdx + 1, colIdx]);
            const bottomBorder = cellStyle.borderTop || cellStyle.border;
            if (rightBorder || bottomBorder) {
                [].slice.call(element.style).forEach((style) => {
                    if (rightBorder && bottomBorder) {
                        if (!style.includes('border-right') && !style.includes('border-bottom')) {
                            element.style.removeProperty(style);
                        }
                    }
                    else if ((rightBorder && !(style.indexOf('border-right') > -1) && (!bottomBorder || bottomBorder === 'none')) ||
                        (bottomBorder && !(style.indexOf('border-bottom') > -1) && (!rightBorder || rightBorder === 'none'))) {
                        element.style.removeProperty(style);
                    }
                });
            }
            else {
                element.removeAttribute('style');
            }
        }
        const prevRowCell = this.parent.getCell(rowIdx - 1, colIdx);
        if (prevRowCell && prevRowCell.style.borderBottom) {
            const prevRowIdx = Number(prevRowCell.parentElement.getAttribute('aria-rowindex')) - 1;
            cellStyle = this.parent.getCellStyleValue(['borderBottom', 'border'], [prevRowIdx, colIdx]);
            if (!(cellStyle.borderBottom || cellStyle.border)) {
                prevRowCell.style.borderBottom = '';
            }
        }
        const prevColCell = element.previousElementSibling;
        if (prevColCell && prevColCell.style.borderRight) {
            colIdx = Number(prevColCell.getAttribute('aria-colindex')) - 1;
            cellStyle = this.parent.getCellStyleValue(['borderRight', 'border'], [rowIdx, colIdx]);
            if (!(cellStyle.borderRight || cellStyle.border)) {
                prevColCell.style.borderRight = '';
            }
        }
    }
    /**
     * @hidden
     * @param {number[]} range - Specifies the range.
     * @param {boolean} refreshing - Specifies the refresh.
     * @param {boolean} checkWrap - Specifies the range.
     * @param {boolean} checkHeight - Specifies the checkHeight.
     * @param {boolean} checkCF - Specifies the check for conditional format.
     * @param {boolean} skipFormatCheck - Specifies whether to skip the format checking while applying the number format.
     * @param {boolean} checkFormulaAdded - Specifies whether to check the formula added or not.
     * @param {boolean} isFromAutoFillOption - Specifies whether the value is from auto fill option or not.
     * @param {boolean} isHeightCheckNeeded - Specifies whether the refreshing is from undo-redo with format action.
     * @param {boolean} isSortAction - Specifies whether to check the sort action performed or not.
     * @param {boolean} isSelectAll - Specifies the all sheet cells selected or not.
     * @param {PreviousCellDetails[]} cells - Specifies the undo redo cell collections.
     * @returns {void}
     */
    refreshRange(range, refreshing, checkWrap, checkHeight, checkCF, skipFormatCheck, checkFormulaAdded, isFromAutoFillOption, isHeightCheckNeeded = true, isSortAction, isSelectAll, cells) {
        const sheet = this.parent.getActiveSheet();
        const cRange = range.slice();
        let args;
        let cell;
        if (inView(this.parent, cRange, true)) {
            let cellIdx = 0;
            for (let i = cRange[0]; i <= cRange[2]; i++) {
                if (isHiddenRow(sheet, i)) {
                    continue;
                }
                for (let j = cRange[1]; j <= cRange[3]; j++) {
                    if (isHiddenCol(sheet, j)) {
                        continue;
                    }
                    cell = this.parent.getCell(i, j);
                    if (cell) {
                        args = { rowIdx: i, colIdx: j, td: cell, cell: getCell(i, j, sheet), isRefreshing: refreshing, lastCell: j ===
                                cRange[3], isRefresh: true, isHeightCheckNeeded: isHeightCheckNeeded, manualUpdate: true, first: '', onActionUpdate: checkHeight, skipFormatCheck: skipFormatCheck, isFromAutoFillOption: isFromAutoFillOption,
                            isSelectAll: isSelectAll, rowHeight: cells && cells[cellIdx] && cells[cellIdx].rowHeight };
                        cellIdx++;
                        if (checkFormulaAdded) {
                            args.address = getCellAddress(i, j);
                        }
                        this.update(args);
                        if (checkCF && sheet.conditionalFormats && sheet.conditionalFormats.length) {
                            this.parent.notify(applyCF, { indexes: [i, j], isAction: true });
                        }
                        this.parent.notify(renderFilterCell, { td: cell, rowIndex: i, colIndex: j });
                        if (checkWrap) {
                            this.setWrapByValue(sheet, args);
                        }
                    }
                    if (this.parent.calculationMode === 'Manual' && isSortAction) {
                        if (!cell) {
                            args = {
                                rowIdx: i, colIdx: j, td: cell, cell: getCell(i, j, sheet), isRefreshing: refreshing, lastCell: j ===
                                    cRange[3], isRefresh: true, isHeightCheckNeeded: isHeightCheckNeeded, manualUpdate: true, first: '',
                                onActionUpdate: checkHeight, skipFormatCheck: skipFormatCheck, isFromAutoFillOption: isFromAutoFillOption,
                                isSortAction: isSortAction
                            };
                        }
                        else {
                            args.isSortAction = isSortAction;
                        }
                        if (args.cell && args.cell.formula && sheet.isSheetCalculated) {
                            this.calculateFormula(args);
                        }
                    }
                }
            }
        }
    }
    refresh(rowIdx, colIdx, lastCell, element, checkCF, checkWrap, skipFormatCheck, isRandomFormula, fillType) {
        const sheet = this.parent.getActiveSheet();
        if (!element && (isHiddenRow(sheet, rowIdx) || isHiddenCol(sheet, colIdx))) {
            return;
        }
        if (element || !this.parent.scrollSettings.enableVirtualization || this.parent.insideViewport(rowIdx, colIdx)) {
            const cell = (element || this.parent.getCell(rowIdx, colIdx));
            if (!cell) {
                return;
            }
            const args = { rowIdx: rowIdx, colIdx: colIdx, td: cell, cell: getCell(rowIdx, colIdx, sheet), isRefresh: true,
                lastCell: lastCell, isHeightCheckNeeded: true, manualUpdate: true, first: '', skipFormatCheck: skipFormatCheck,
                isRandomFormula: isRandomFormula, fillType: fillType };
            this.update(args);
            if (checkCF && sheet.conditionalFormats && sheet.conditionalFormats.length) {
                this.parent.notify(applyCF, { indexes: [rowIdx, colIdx], isAction: true });
            }
            this.parent.notify(renderFilterCell, { td: cell, rowIndex: rowIdx, colIndex: colIdx });
            if (checkWrap) {
                this.setWrapByValue(sheet, args);
            }
        }
    }
    updateView(args) {
        if (isNullOrUndefined(args.sheetIndex) || (args.sheetIndex === this.parent.activeSheetIndex)) {
            if (!args.indexes) {
                const sheet = this.parent.getActiveSheet();
                const frozenRow = this.parent.frozenRowCount(sheet);
                const frozenCol = this.parent.frozenColCount(sheet);
                const topLeftCell = getRangeIndexes(sheet.topLeftCell);
                if (frozenRow && frozenCol) {
                    this.refreshRange([topLeftCell[0], topLeftCell[1], frozenRow - 1, frozenCol - 1], args.refreshing, args.checkWrap, false, args.checkCF);
                }
                if (frozenRow) {
                    this.refreshRange([topLeftCell[0], this.parent.viewport.leftIndex + frozenCol, frozenRow - 1, this.parent.viewport.rightIndex], args.refreshing, args.checkWrap, false, args.checkCF);
                }
                if (frozenCol) {
                    this.refreshRange([this.parent.viewport.topIndex + frozenRow, topLeftCell[1], this.parent.viewport.bottomIndex, frozenCol - 1], args.refreshing, args.checkWrap, false, args.checkCF);
                }
                args.indexes = [this.parent.viewport.topIndex + frozenRow, this.parent.viewport.leftIndex + frozenCol,
                    this.parent.viewport.bottomIndex, this.parent.viewport.rightIndex];
            }
            this.refreshRange(args.indexes, args.refreshing, args.checkWrap, false, args.checkCF);
        }
        else if (args.refreshing) {
            this.calculateFormula({ cell: getCell(args.indexes[0], args.indexes[1], getSheet(this.parent, args.sheetIndex), true, true),
                rowIdx: args.indexes[0], colIdx: args.indexes[1], sheetIndex: args.sheetIndex });
        }
    }
    /**
     * Removes the added event handlers and clears the internal properties of CellRenderer module.
     *
     * @returns {void}
     */
    destroy() {
        this.parent.off(updateView, this.updateView);
        this.parent.off(calculateFormula, this.calculateFormula);
        if (this.element) {
            this.element.remove();
        }
        this.element = null;
        if (this.th) {
            this.th.remove();
        }
        this.th = null;
        if (this.tableRow) {
            this.tableRow.remove();
        }
        this.tableRow = null;
        this.parent = null;
    }
}

/**
 * Render module is used to render the spreadsheet
 *
 * @hidden
 */
class Render {
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
        this.instantiateRenderer();
    }
    render() {
        this.parent.setProperties({ activeSheetIndex: this.parent.skipHiddenSheets(this.parent.activeSheetIndex) }, true);
        if (!this.parent.isMobileView()) {
            this.parent.notify(ribbon, null);
            this.parent.notify(formulaBar, null);
        }
        const sheetPanel = this.parent.createElement('div', {
            id: this.parent.element.id + '_sheet_panel', className: 'e-sheet-panel'
        });
        if (this.parent.enableRtl) {
            sheetPanel.classList.add('e-rtl');
        }
        this.parent.element.appendChild(sheetPanel);
        if (this.parent.showSheetTabs) {
            this.parent.notify(sheetTabs, null);
        }
        else { // for formula calculation
            this.parent.notify(workbookFormulaOperation, { action: 'initSheetInfo' });
            this.parent.notify(workbookFormulaOperation, { action: 'initiateDefinedNames' });
        }
        if (this.parent.isMobileView()) {
            this.parent.notify(formulaBar, null);
            this.parent.notify(ribbon, null);
        }
        if (this.parent.password && (this.parent.password.length > 0 || this.parent.isProtected)) {
            this.parent.isProtected = true;
            if (this.parent.showSheetTabs) {
                this.parent.element.querySelector('.e-add-sheet-tab').setAttribute('disabled', 'true');
                this.parent.element.querySelector('.e-add-sheet-tab').classList.add('e-disabled');
            }
        }
        if (this.parent.selectionSettings.mode === 'None') {
            this.parent.allowAutoFill = false;
        }
        this.setSheetPanelSize();
        this.renderSheet(sheetPanel);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.checkTopLeftCell(!this.parent.refreshing);
    }
    checkTopLeftCell(initLoad, isRefreshing, scrollTop, scrollLeft, preventModelCheck, openOptions) {
        const sheet = this.parent.getActiveSheet();
        this.parent.showSpinner();
        let isTopLeftCell = sheet.topLeftCell === 'A1';
        const indexes = getCellIndexes(sheet.topLeftCell);
        let isFreezeScrolled;
        if (sheet.topLeftCell !== sheet.paneTopLeftCell && (sheet.frozenRows || sheet.frozenColumns)) {
            const paneIndexes = getCellIndexes(sheet.paneTopLeftCell);
            isFreezeScrolled = this.parent.scrollSettings.enableVirtualization;
            isTopLeftCell = sheet.frozenRows && sheet.frozenColumns ? indexes[0] + sheet.frozenRows === paneIndexes[0] &&
                indexes[1] + sheet.frozenColumns === paneIndexes[1] : (sheet.frozenRows ? indexes[0] + sheet.frozenRows === paneIndexes[0]
                && indexes[1] === 0 : indexes[1] + sheet.frozenColumns === paneIndexes[1] && indexes[0] === 0);
            if (indexes[0] && paneIndexes[0] > indexes[0]) {
                this.parent.viewport.beforeFreezeHeight = getRowsHeight(sheet, 0, indexes[0] - 1, true);
            }
            else {
                this.parent.viewport.beforeFreezeHeight = 0;
            }
            if (indexes[1] && paneIndexes[1] > indexes[1]) {
                this.parent.viewport.beforeFreezeWidth = getColumnsWidth(sheet, 0, indexes[1] - 1, true);
            }
            else {
                this.parent.viewport.beforeFreezeWidth = 0;
            }
        }
        else {
            this.parent.viewport.beforeFreezeHeight = this.parent.viewport.beforeFreezeWidth = 0;
        }
        const frozenRow = this.parent.frozenRowCount(sheet);
        const frozenCol = this.parent.frozenColCount(sheet);
        if (!this.parent.scrollSettings.enableVirtualization || isTopLeftCell) {
            this.refreshUI({ rowIndex: indexes[0], colIndex: indexes[1], refresh: 'All' }, null, initLoad, isRefreshing, preventModelCheck, openOptions);
            if (isFreezeScrolled) {
                this.parent.viewport.topIndex = skipHiddenIdx(sheet, frozenRow, true) - frozenRow;
                this.parent.viewport.leftIndex = skipHiddenIdx(sheet, frozenCol, true, 'columns') - frozenCol;
            }
        }
        else {
            const pIndexes = sheet.paneTopLeftCell === sheet.topLeftCell ? indexes : getCellIndexes(sheet.paneTopLeftCell);
            const eventArgs = { preventScroll: true };
            eventArgs.scrollTop = scrollTop || (pIndexes[0] > frozenRow ? getRowsHeight(sheet, frozenRow, pIndexes[0] - 1, true) : 0);
            eventArgs.scrollLeft = scrollLeft || (pIndexes[1] > frozenCol ? getColumnsWidth(sheet, frozenCol, pIndexes[1] - 1, true) : 0);
            this.parent.notify(onContentScroll, eventArgs);
            let threshold = this.parent.getThreshold('row');
            const rowIndex = sheet.frozenRows ? indexes[0] : (indexes[0] > threshold ?
                skipHiddenIdx(sheet, indexes[0] - threshold, true) : 0);
            const frozenIndexes = [];
            if (sheet.frozenRows) {
                frozenIndexes.push(pIndexes[0] - threshold > frozenRow ? pIndexes[0] - threshold : frozenRow);
            }
            threshold = this.parent.getThreshold('col');
            const colIndex = sheet.frozenColumns ? indexes[1] :
                (indexes[1] > threshold ? skipHiddenIdx(sheet, indexes[1] - threshold, true, 'columns') : 0);
            if (sheet.frozenColumns) {
                if (!frozenIndexes.length) {
                    frozenIndexes.push(frozenRow);
                }
                frozenIndexes.push(pIndexes[1] - threshold > frozenCol ? pIndexes[1] - threshold : frozenCol);
            }
            else if (frozenIndexes.length) {
                frozenIndexes.push(frozenCol);
            }
            this.refreshUI({ rowIndex: rowIndex, colIndex: colIndex, refresh: 'All', top: eventArgs.scrollTop, left: eventArgs.scrollLeft,
                frozenIndexes: frozenIndexes }, null, initLoad, isRefreshing, preventModelCheck, openOptions);
            if (isFreezeScrolled) {
                if (frozenRow && frozenIndexes[0] >= frozenRow) {
                    this.parent.viewport.topIndex = skipHiddenIdx(sheet, frozenIndexes[0], true) - frozenRow;
                }
                if (frozenCol && frozenIndexes[1] >= frozenCol) {
                    this.parent.viewport.leftIndex = skipHiddenIdx(sheet, frozenIndexes[1], true, 'columns') - frozenCol;
                }
            }
        }
    }
    renderSheet(panel = document.getElementById(this.parent.element.id + '_sheet_panel')) {
        panel.appendChild(this.parent.createElement('div', { className: 'e-sheet', id: this.parent.element.id + '_sheet', styles: 'background-color: #fff' }));
        this.parent.serviceLocator.getService('sheet').renderPanel();
    }
    /**
     * @hidden
     * @param {RefreshArgs} args - Specifies the RefreshArgs.
     * @param {string} address - Specifies the address.
     * @param {boolean} initLoad - Specifies the initLoad.
     * @param {boolean} isRefreshing - Specifies the isRefreshing.
     * @param {boolean} preventModelCheck - Specifies the preventModelCheck.
     * @param {boolean} openOptions - Specifies the open response options.
     * @returns {void}
     */
    // tslint:disable-next-line:max-func-body-length
    refreshUI(args, address, initLoad, isRefreshing, preventModelCheck, openOptions) {
        if (args.refresh !== 'All') {
            this.parent.showSpinner();
        }
        const sheetModule = this.parent.serviceLocator.getService('sheet');
        const sheet = this.parent.getActiveSheet();
        const sheetName = getSheetName(this.parent);
        const prevRowColCnt = { rowCount: sheet.rowCount, colCount: sheet.colCount };
        args.frozenIndexes = args.frozenIndexes ? args.frozenIndexes : [];
        if (!address) {
            if (this.parent.scrollSettings.enableVirtualization) {
                let lastRow = args.rowIndex + this.parent.viewport.rowCount + (this.parent.getThreshold('row') * 2);
                let lastCol = args.colIndex + this.parent.viewport.colCount + (this.parent.getThreshold('col') * 2);
                const frozenRow = this.parent.frozenRowCount(sheet);
                const frozenCol = this.parent.frozenColCount(sheet);
                if (args.frozenIndexes.length) {
                    lastRow += (args.frozenIndexes[0] - frozenRow);
                    lastCol += (args.frozenIndexes[1] - frozenCol);
                }
                if (args.refresh === 'Row') {
                    lastRow += frozenRow;
                }
                else {
                    lastRow += sheet.frozenRows;
                }
                if (args.refresh === 'Column') {
                    lastCol += frozenCol;
                }
                else {
                    lastCol += sheet.frozenColumns;
                }
                const rowIdx = args.frozenIndexes[0] > frozenRow ? args.frozenIndexes[0] : args.rowIndex + (args.refresh === 'Row' ?
                    frozenRow : sheet.frozenRows);
                let indexes = this.parent.skipHidden(rowIdx, lastRow, 'rows', false);
                lastRow = indexes[1];
                if (rowIdx !== indexes[0]) {
                    const topLeftCell = getCellIndexes(sheet.paneTopLeftCell);
                    if (topLeftCell[0] === rowIdx) {
                        this.parent.updateTopLeftCell(indexes[0] - frozenRow, topLeftCell[1], 'col');
                    }
                }
                indexes[0] -= frozenRow;
                let count = sheet.rowCount - 1;
                let diff = 0;
                let startRow = args.rowIndex;
                if (this.parent.scrollSettings.isFinite && lastRow > count) {
                    diff = lastRow - count;
                    lastRow = skipHiddenIdx(sheet, count, false);
                    if (indexes[0] + frozenRow > skipHiddenIdx(sheet, frozenRow, true)) {
                        let startIdx = args.rowIndex - diff;
                        startIdx = startIdx < 0 ? 0 : startIdx;
                        startIdx = this.decreaseHidden(startIdx, args.rowIndex - 1, frozenRow);
                        if (args.top && startIdx < args.rowIndex) {
                            this.parent.notify(updateTranslate, { height: getRowsHeight(sheet, startIdx + frozenRow, args.rowIndex - 1 + frozenRow, true),
                                isRender: true });
                        }
                        this.parent.viewport.topIndex = indexes[0] = startIdx;
                        startRow = args.refresh === 'Row' ? startIdx : startRow;
                    }
                }
                if (args.refresh === 'Row') {
                    args.rowIndex = skipHiddenIdx(sheet, startRow + frozenRow, true) - frozenRow;
                }
                else {
                    startRow = args.rowIndex = frozenRow ? skipHiddenIdx(sheet, startRow, true) : indexes[0];
                }
                const colIdx = args.frozenIndexes[1] > frozenCol ? args.frozenIndexes[1] : args.colIndex + (args.refresh ===
                    'Column' ? frozenCol : sheet.frozenColumns);
                indexes = this.parent.skipHidden(colIdx, lastCol, 'columns', false);
                lastCol = indexes[1];
                if (colIdx !== indexes[0]) {
                    const topLeftCell = getCellIndexes(sheet.paneTopLeftCell);
                    if (topLeftCell[1] === colIdx) {
                        this.parent.updateTopLeftCell(topLeftCell[0], indexes[0] - frozenCol, 'row');
                    }
                }
                indexes[0] -= frozenCol;
                count = sheet.colCount - 1;
                diff = 0;
                let startCol = args.colIndex;
                if (this.parent.scrollSettings.isFinite && lastCol > count) {
                    diff = lastCol - count;
                    lastCol = skipHiddenIdx(sheet, count, false, 'columns');
                    if (indexes[0] + frozenCol > skipHiddenIdx(sheet, frozenCol, true, 'columns')) {
                        let startIdx = args.colIndex - diff;
                        startIdx = startIdx > -1 ? startIdx : 0;
                        startIdx = this.decreaseHidden(startIdx, args.colIndex - 1, frozenCol, 'columns');
                        if (args.left && startIdx < args.colIndex) {
                            this.parent.notify(updateTranslate, { width: getColumnsWidth(sheet, startIdx + frozenCol, args.colIndex - 1 + frozenCol, true),
                                isRender: true });
                        }
                        this.parent.viewport.leftIndex = indexes[0] = startIdx;
                        startCol = args.refresh === 'Column' ? startIdx : startCol;
                    }
                }
                if (args.refresh === 'Column') {
                    args.colIndex = skipHiddenIdx(sheet, startCol + frozenCol, true, 'columns') - frozenCol;
                }
                else {
                    startCol = args.colIndex = frozenCol ? skipHiddenIdx(sheet, startCol, true, 'columns') : indexes[0];
                }
                if (args.refresh === 'Row') {
                    startRow += frozenRow;
                    if (frozenRow) {
                        lastRow += getCellIndexes(sheet.topLeftCell)[0];
                    }
                    lastCol = this.parent.viewport.rightIndex;
                }
                if (args.refresh === 'Column') {
                    startCol += frozenCol;
                    if (frozenCol) {
                        lastCol += getCellIndexes(sheet.topLeftCell)[1];
                    }
                    lastRow = this.parent.viewport.bottomIndex;
                }
                this.parent.viewport.topIndex = args.rowIndex;
                this.parent.viewport.bottomIndex = lastRow;
                this.parent.viewport.leftIndex = args.colIndex;
                this.parent.viewport.rightIndex = lastCol;
                address = `${getCellAddress(startRow, startCol)}:${getCellAddress(lastRow, lastCol)}`;
            }
            else {
                if (args.refresh === 'All') {
                    this.updateTopLeftScrollPosition(extend(args, { sheet: sheet }));
                }
                this.parent.viewport.bottomIndex = sheet.rowCount - 1;
                this.parent.viewport.rightIndex = sheet.colCount - 1;
                address = `${getCellAddress(args.rowIndex, args.colIndex)}:${getCellAddress(this.parent.viewport.bottomIndex, this.parent.viewport.rightIndex)}`;
            }
        }
        if (args.refresh === 'All') {
            this.parent.trigger(beforeDataBound, {});
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const isOpen = this.parent.isOpen || this.parent.refreshing;
        setAriaOptions(this.parent.getMainContent(), { busy: true });
        const sheetsLen = this.parent.sheets.length;
        getData(this.parent, `${sheetName}!${address}`, null, null, args.frozenIndexes).then((values) => {
            if (!this.parent || sheetsLen < this.parent.sheets.length) {
                return;
            }
            const sheetIdx = getSheetIndexFromId(this.parent, sheet.id);
            if (!preventModelCheck && (sheetIdx === undefined || sheetIdx !== this.parent.activeSheetIndex)) {
                if (sheetIdx > -1) {
                    this.checkTopLeftCell();
                }
                return;
            }
            const indexes = [args.rowIndex, args.colIndex, ...getCellIndexes(address.split(':')[1])];
            let isEdit;
            let arg;
            switch (args.refresh) {
                case 'All':
                    sheetModule.renderTable({ cells: values, indexes: indexes, top: args.top, left: args.left, initLoad: initLoad, isRefreshing: isRefreshing, isOpen: isOpen, openOptions: openOptions });
                    break;
                case 'Row':
                    sheetModule.refreshRowContent({ cells: values, indexes: indexes, skipUpdateOnFirst: args.skipUpdateOnFirst, prevRowColCnt: prevRowColCnt });
                    isEdit = false;
                    arg = { isEdit: isEdit };
                    this.parent.notify(isFormulaBarEdit, arg);
                    if (arg.isEdit) {
                        this.parent.notify(editOperation, { action: 'startEdit', refreshCurPos: false });
                    }
                    break;
                case 'Column':
                    sheetModule.refreshColumnContent({
                        cells: values, indexes: indexes, skipUpdateOnFirst: args.skipUpdateOnFirst,
                        prevRowColCnt: prevRowColCnt, insertDelete: args.insertDelete
                    });
                    break;
                case 'RowPart':
                    sheetModule.updateRowContent({
                        cells: values, indexes: indexes, direction: args.direction, skipUpdateOnFirst: args.skipUpdateOnFirst,
                        prevRowColCnt: prevRowColCnt
                    });
                    break;
                case 'ColumnPart':
                    sheetModule.updateColContent({
                        cells: values, indexes: indexes, direction: args.direction, skipUpdateOnFirst: args.skipUpdateOnFirst,
                        prevRowColCnt: prevRowColCnt
                    });
                    break;
            }
            if (this.parent && this.parent.isReact) {
                this.parent['renderReactTemplates']();
            }
        });
        this.parent.notify(beforeVirtualContentLoaded, { refresh: args.refresh, skipTranslate: args.skipTranslate });
    }
    updateTopLeftScrollPosition(args) {
        const topLeftCell = getCellIndexes(args.sheet.topLeftCell);
        const paneTopLeftCell = getCellIndexes(args.sheet.paneTopLeftCell);
        if (args.sheet.frozenRows) {
            const frozenRow = this.parent.frozenRowCount(args.sheet);
            if (paneTopLeftCell[0] > frozenRow) {
                args.top = getRowsHeight(args.sheet, frozenRow, paneTopLeftCell[0] - 1, true);
            }
        }
        else {
            if (args.rowIndex) {
                args.rowIndex = 0;
            }
            if (topLeftCell[0] !== 0) {
                args.top = getRowsHeight(args.sheet, 0, topLeftCell[0] - 1, true);
            }
        }
        if (args.sheet.frozenColumns) {
            const frozenCol = this.parent.frozenColCount(args.sheet);
            if (paneTopLeftCell[1] > frozenCol) {
                args.left = getColumnsWidth(args.sheet, frozenCol, paneTopLeftCell[1] - 1, true);
            }
        }
        else {
            if (args.colIndex) {
                args.colIndex = 0;
            }
            if (topLeftCell[1] !== 0) {
                args.left = getColumnsWidth(args.sheet, 0, topLeftCell[1] - 1, true);
            }
        }
    }
    removeSheet() {
        if (document.getElementById(this.parent.element.id + '_sheet')) {
            remove(document.getElementById(this.parent.element.id + '_sheet'));
        }
    }
    /**
     * Refresh the active sheet.
     *
     * @param {boolean} isOpen - Specifies the isOpen.
     * @param {boolean} resize - Set `true` to refresh the sheet with exiting scroll top and left.
     * @param {boolean} focusEle - Specify the focusEle.
     * @param {boolean} preventModelCheck - Specifies the preventModelCheck.
     * @param {boolean} openOptions - Specifies the open response options.
     * @returns {void}
     */
    refreshSheet(isOpen, resize, focusEle, preventModelCheck, openOptions) {
        let scrollTop = 0;
        let scrollLeft = 0;
        if (resize) {
            const mainPanel = this.parent.element.getElementsByClassName('e-main-panel')[0];
            if (mainPanel) {
                scrollTop = mainPanel.scrollTop;
            }
            const sheetContent = this.parent.getMainContent();
            if (sheetContent) {
                scrollLeft = sheetContent.scrollLeft;
            }
        }
        this.removeSheet();
        this.renderSheet();
        this.parent.notify(deInitProperties, {});
        this.checkTopLeftCell(false, isOpen, scrollTop, scrollLeft, preventModelCheck, openOptions);
        if (focusEle) {
            focus(this.parent.element);
        }
    }
    /**
     * Used to set sheet panel size.
     *
     * @param {number} colMinWidth - Specifies column minimum width value.
     * @returns {void}
     */
    setSheetPanelSize(colMinWidth) {
        const panel = document.getElementById(this.parent.element.id + '_sheet_panel');
        const offset = this.parent.element.getBoundingClientRect();
        let height;
        this.parent.viewport.scaleY = this.parent.viewport.scaleX = 1;
        if (this.parent.enableScaling) {
            const offsetHeight = this.parent.element.offsetHeight;
            const scaleY = offsetHeight / offset.height;
            if (scaleY !== 1 && Math.abs(offsetHeight - offset.height) >= offsetHeight * 0.1) {
                this.parent.viewport.scaleY = scaleY;
            }
            const offsetWidth = this.parent.element.offsetWidth;
            const scaleX = offsetWidth / offset.width;
            if (scaleX !== 1 && Math.abs(offsetWidth - offset.width) >= offsetWidth * 0.1) {
                this.parent.viewport.scaleX = scaleX;
            }
        }
        if (this.parent.height === 'auto') {
            panel.style.height = '260px';
            height = 230;
        }
        else {
            height = (offset.height * this.parent.viewport.scaleY) - getSiblingsHeight(panel, null, this.parent.viewport.scaleY);
            panel.style.height = `${height}px`;
            height -= (32 / this.parent.viewport.scaleY);
        }
        if (colMinWidth !== undefined) {
            this.colMinWidth = colMinWidth;
        }
        this.parent.viewport.height = height;
        const width = offset.width * this.parent.viewport.scaleX;
        this.parent.viewport.width = width - (32 / this.parent.viewport.scaleX);
        this.parent.viewport.rowCount = this.roundValue(height, 20);
        this.parent.viewport.colCount = this.roundValue(width, this.colMinWidth || 64);
    }
    roundValue(size, threshold) {
        const value = size / threshold;
        const roundedValue = Math.round(value);
        return Math.abs(value - roundedValue) < 0.5 ? roundedValue : roundedValue - 1;
    }
    moveOrDuplicateSheetHandler(args) {
        this.parent.notify(refreshSheetTabs, null);
        if (args.refresh) {
            this.refreshSheet(args.isDuplicate);
        }
    }
    decreaseHidden(startIdx, endIdx, freezeCount, layout = 'rows') {
        startIdx += freezeCount;
        endIdx += freezeCount;
        const sheet = this.parent.getActiveSheet();
        for (let i = endIdx; i >= startIdx; i--) {
            if ((sheet[`${layout}`])[i] && (sheet[`${layout}`])[i].hidden) {
                startIdx--;
                if (startIdx < freezeCount) {
                    startIdx = skipHiddenIdx(sheet, freezeCount, true, layout);
                    break;
                }
            }
        }
        return startIdx - freezeCount;
    }
    /**
     * Registing the renderer related services.
     *
     * @returns {void}
     */
    instantiateRenderer() {
        this.parent.serviceLocator.register('cell', new CellRenderer(this.parent));
        this.parent.serviceLocator.register('row', new RowRenderer(this.parent));
        this.parent.serviceLocator.register('sheet', new SheetRender(this.parent));
    }
    /**
     * Destroy the Render module.
     *
     * @returns {void}
     */
    destroy() {
        this.removeEventListener();
        this.parent.serviceLocator.getService('row').destroy();
        this.parent.serviceLocator.getService('cell').destroy();
        if (this.colMinWidth) {
            this.colMinWidth = null;
        }
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(spreadsheetDestroyed, this.destroy, this);
        this.parent.on(moveOrDuplicateSheet, this.moveOrDuplicateSheetHandler, this);
        this.parent.on(getUpdatedScrollPosition, this.updateTopLeftScrollPosition, this);
    }
    removeEventListener() {
        this.parent.off(spreadsheetDestroyed, this.destroy);
        this.parent.off(moveOrDuplicateSheet, this.moveOrDuplicateSheetHandler);
        this.parent.off(getUpdatedScrollPosition, this.updateTopLeftScrollPosition);
    }
}

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Represents clipboard support for Spreadsheet.
 */
class Clipboard {
    constructor(parent) {
        this.parent = parent;
        this.init();
        this.addEventListener();
    }
    init() {
        this.parent.element.appendChild(this.parent.createElement('input', { className: 'e-clipboard', attrs: { 'contenteditable': 'true', 'tabindex': '-1', 'aria-hidden': 'true' } }));
    }
    addEventListener() {
        const ele = this.getClipboardEle();
        this.parent.on(cut, this.cut, this);
        this.parent.on(copy, this.copy, this);
        this.parent.on(paste, this.paste, this);
        this.parent.on(clearCopy, this.clearCopiedInfo, this);
        this.parent.on(tabSwitch, this.tabSwitchHandler, this);
        this.parent.on(cMenuBeforeOpen, this.cMenuBeforeOpenHandler, this);
        this.parent.on(ribbonClick, this.ribbonClickHandler, this);
        this.parent.on(contentLoaded, this.initCopyIndicator, this);
        this.parent.on(rowHeightChanged, this.rowHeightChanged, this);
        this.parent.on(colWidthChanged, this.colWidthChanged, this);
        this.parent.on(refreshClipboard, this.refreshOnInsertDelete, this);
        EventHandler.add(ele, 'cut', this.cut, this);
        EventHandler.add(ele, 'copy', this.copy, this);
        EventHandler.add(ele, 'paste', this.paste, this);
    }
    removeEventListener() {
        const ele = this.getClipboardEle();
        if (!this.parent.isDestroyed) {
            this.parent.off(cut, this.cut);
            this.parent.off(copy, this.copy);
            this.parent.off(paste, this.paste);
            this.parent.off(clearCopy, this.clearCopiedInfo);
            this.parent.off(tabSwitch, this.tabSwitchHandler);
            this.parent.off(cMenuBeforeOpen, this.cMenuBeforeOpenHandler);
            this.parent.off(ribbonClick, this.ribbonClickHandler);
            this.parent.off(contentLoaded, this.initCopyIndicator);
            this.parent.off(rowHeightChanged, this.rowHeightChanged);
            this.parent.off(colWidthChanged, this.colWidthChanged);
            this.parent.off(refreshClipboard, this.refreshOnInsertDelete);
        }
        EventHandler.remove(ele, 'cut', this.cut);
        EventHandler.remove(ele, 'copy', this.copy);
        EventHandler.remove(ele, 'paste', this.paste);
    }
    ribbonClickHandler(args) {
        const parentId = this.parent.element.id;
        switch (args.item.id) {
            case parentId + '_cut':
                this.cut({ invokeCopy: true });
                break;
            case parentId + '_copy':
                this.copy({ invokeCopy: true });
                break;
        }
    }
    tabSwitchHandler(args) {
        if (args.activeTab === 0 && !this.copiedInfo && !this.copiedShapeInfo) {
            this.hidePaste();
        }
    }
    cMenuBeforeOpenHandler(e) {
        const sheet = this.parent.getActiveSheet();
        const l10n = this.parent.serviceLocator.getService(locale);
        let delRowItems = [];
        let hideRowItems = [];
        let delColItems = [];
        let hideColItems = [];
        const actCell = sheet.activeCell;
        const actCellIndex = getCellIndexes(actCell);
        const cellObj = getCell(actCellIndex[0], actCellIndex[1], sheet);
        const isLocked$1 = sheet.isProtected && isLocked(cellObj, getColumn(sheet, actCellIndex[1]));
        const isReadonlyCell = isReadOnly(cellObj, getColumn(sheet, actCellIndex[1]), getRow(sheet, actCellIndex[0]));
        if (e.target === 'Content' || e.target === 'RowHeader' || e.target === 'ColumnHeader' || e.target === 'SelectAll') {
            this.parent.enableContextMenuItems([l10n.getConstant('Paste'), l10n.getConstant('PasteSpecial')], (this.copiedInfo ||
                this.copiedShapeInfo && !isLocked$1) ? true : false);
            this.parent.enableContextMenuItems([l10n.getConstant('Cut')], !isLocked$1);
        }
        if (e.target === 'Content') {
            if (sheet.isProtected) {
                this.parent.enableContextMenuItems([l10n.getConstant('Filter'), l10n.getConstant('Sort'),
                    l10n.getConstant('AddNote')], false);
            }
            if (isLocked$1) {
                this.parent.enableContextMenuItems([l10n.getConstant('Cut'), l10n.getConstant('Hyperlink'),
                    l10n.getConstant('EditNote'), l10n.getConstant('DeleteNote')], false);
            }
            else if (isReadonlyCell) {
                this.parent.enableContextMenuItems([l10n.getConstant('Cut'), l10n.getConstant('Paste'), l10n.getConstant('PasteSpecial'),
                    l10n.getConstant('Filter'), l10n.getConstant('Sort'), l10n.getConstant('Hyperlink'), l10n.getConstant('EditHyperlink'),
                    l10n.getConstant('OpenHyperlink'), l10n.getConstant('RemoveHyperlink'), l10n.getConstant('AddNote')], false);
            }
            else if (sheet.isProtected && !sheet.protectSettings.insertLink) {
                this.parent.enableContextMenuItems([l10n.getConstant('Hyperlink')], false);
            }
        }
        if (sheet.isProtected) {
            if (e.target === 'ColumnHeader') {
                delColItems = [l10n.getConstant('DeleteColumn'), l10n.getConstant('DeleteColumns'),
                    l10n.getConstant('InsertColumn'), l10n.getConstant('InsertColumns')];
                hideColItems = [l10n.getConstant('HideColumn'), l10n.getConstant('HideColumns'), l10n.getConstant('UnhideColumns')];
                this.parent.enableContextMenuItems(delColItems, false);
                this.parent.enableContextMenuItems(hideColItems, sheet.protectSettings.formatColumns);
            }
            if (e.target === 'RowHeader') {
                delRowItems = [l10n.getConstant('DeleteRow'), l10n.getConstant('DeleteRows'),
                    l10n.getConstant('InsertRow'), l10n.getConstant('InsertRows')];
                hideRowItems = [l10n.getConstant('HideRow'), l10n.getConstant('HideRows'), l10n.getConstant('UnhideRows')];
                this.parent.enableContextMenuItems(delRowItems, false);
                this.parent.enableContextMenuItems(hideRowItems, sheet.protectSettings.formatRows);
            }
        }
    }
    rowHeightChanged(args) {
        if (this.copiedInfo) {
            const ele = this.getCopyIndicator();
            if (ele) {
                if (this.copiedInfo.range[0] > args.rowIdx) {
                    ele.style.top = `${parseFloat(ele.style.top) + args.threshold}px`;
                }
                else if (inRange(this.copiedInfo.range, args.rowIdx, this.copiedInfo.range[1])) {
                    ele.style.height = `${parseFloat(ele.style.height) + args.threshold}px`;
                }
            }
        }
    }
    colWidthChanged(args) {
        if (this.copiedInfo) {
            const ele = this.getCopyIndicator();
            if (ele) {
                if (this.copiedInfo.range[1] > args.colIdx) {
                    ele.style.left = `${parseFloat(ele.style.left) + args.threshold}px`;
                }
                else if (inRange(this.copiedInfo.range, this.copiedInfo.range[0], args.colIdx)) {
                    ele.style.width = `${parseFloat(ele.style.width) + args.threshold}px`;
                }
            }
        }
    }
    cut(args) {
        this.setCopiedInfo(args, true);
    }
    copy(args) {
        this.setCopiedInfo(args, false);
    }
    paste(args) {
        if (this.parent.isEdit || this.parent.element.getElementsByClassName('e-dlg-overlay').length > 0) {
            const editEle = this.parent.element.getElementsByClassName('e-spreadsheet-edit')[0];
            editEle.style.height = 'auto';
            return;
        }
        let rfshRange;
        let isExternal = ((args && args.clipboardData) || window['clipboardData']);
        if (isExternal && args.clipboardData && args.clipboardData.getData('isInternalCut').length && !this.copiedInfo) {
            return; // to prevent multiple cut paste action
        }
        if (isExternal || this.copiedShapeInfo || (args.isInternal && this.copiedInfo)) {
            args.isInternal = !isExternal;
            let isCut;
            const copiedIdx = this.getCopiedIdx();
            args.isAction = !!isExternal || args.isAction;
            const cSIdx = args && args.sIdx > -1 ? args.sIdx : this.parent.activeSheetIndex;
            const curSheet = getSheet(this.parent, cSIdx);
            let selIdx = getSwapRange(args && args.range || getRangeIndexes(curSheet.selectedRange));
            let pasteModelArgs;
            let rows;
            if (isExternal) {
                pasteModelArgs = this.getExternalCells(args);
                rows = pasteModelArgs.model;
                if (!args.isInternal && pasteModelArgs.internal) {
                    isExternal = false;
                    if (!this.copiedInfo) {
                        return;
                    }
                }
                if (!rows || !rows.length) { // If image pasted
                    if (pasteModelArgs.file) {
                        this.parent.notify(insertImage, { file: pasteModelArgs.file });
                        return;
                    }
                    else if (this.copiedInfo) {
                        isExternal = false;
                    }
                    else {
                        return;
                    }
                }
            }
            pasteModelArgs = pasteModelArgs;
            const copyInfo = Object.assign({ isExternal: isExternal }, this.copiedInfo);
            let cIdx;
            let pSheetIdx;
            let column;
            let notRemoveMerge;
            let isRepeative;
            let cSheetSel;
            let prevSheet;
            let isRowSelected;
            let isColSelected;
            if (isExternal) {
                pSheetIdx = cSIdx;
                prevSheet = getSheet(this.parent, pSheetIdx);
                column = {};
                cSheetSel = pasteModelArgs.selection;
                isRepeative = cSheetSel !== 'Sheet' && (selIdx[2] - selIdx[0] + 1) % pasteModelArgs.rowCount === 0 &&
                    (selIdx[3] - selIdx[1] + 1) % pasteModelArgs.colCount === 0;
                cIdx = [0, 0, pasteModelArgs.usedRowIndex, pasteModelArgs.usedColIndex];
            }
            else {
                cIdx = getSwapRange(this.copiedShapeInfo ? getRangeIndexes(curSheet.selectedRange) : this.copiedInfo.range);
                pSheetIdx = copiedIdx;
                column = getColumn(curSheet, cIdx[1]);
                notRemoveMerge = isSingleCell(cIdx) && this.isRangeMerged(selIdx, curSheet);
                prevSheet = getSheet(this.parent, pSheetIdx);
                isRepeative = !notRemoveMerge && (selIdx[2] - selIdx[0] + 1) % (cIdx[2] - cIdx[0] + 1) === 0 &&
                    (selIdx[3] - selIdx[1] + 1) % (cIdx[3] - cIdx[1] + 1) === 0;
                if (prevSheet) {
                    isRowSelected = cIdx[1] === 0 && cIdx[3] === prevSheet.colCount - 1;
                    isColSelected = cIdx[0] === 0 && cIdx[2] === prevSheet.rowCount - 1;
                    if (isRowSelected) {
                        if (isColSelected) {
                            cSheetSel = 'Sheet';
                            cIdx[2] = prevSheet.usedRange.rowIndex;
                            cIdx[3] = prevSheet.usedRange.colIndex;
                        }
                        else {
                            cSheetSel = 'Row';
                            cIdx[3] = prevSheet.usedRange.colIndex;
                        }
                    }
                    else if (isColSelected) {
                        cSheetSel = 'Column';
                        cIdx[2] = prevSheet.usedRange.rowIndex;
                    }
                }
            }
            rfshRange = isRepeative ? selIdx : [selIdx[0], selIdx[1]]
                .concat([selIdx[0] + cIdx[2] - cIdx[0], selIdx[1] + cIdx[3] - cIdx[1] || selIdx[1]]);
            if (cSheetSel) {
                if ((cSheetSel === 'Sheet' || cSheetSel === 'Column') && rfshRange[2] < curSheet.usedRange.rowIndex) {
                    rfshRange[2] = curSheet.usedRange.rowIndex;
                }
                if ((cSheetSel === 'Sheet' || cSheetSel === 'Row') && rfshRange[3] < curSheet.usedRange.colIndex) {
                    rfshRange[3] = curSheet.usedRange.colIndex;
                }
            }
            let pasteType = (args && args.type) || 'All';
            if (isReadOnlyCells(this.parent, rfshRange)) {
                this.parent.notify(readonlyAlert, null);
                return;
            }
            else if (curSheet.isProtected && isLockedCells(this.parent, rfshRange)) {
                this.parent.notify(editAlert, null);
                return;
            }
            if (args.isAction && !this.copiedShapeInfo) {
                const beginEventArgs = { requestType: 'paste', copiedInfo: this.copiedInfo,
                    copiedRange: getRangeAddress(cIdx), pastedRange: getRangeAddress(rfshRange), type: pasteType, cancel: false };
                this.parent.notify(beginAction, { eventArgs: beginEventArgs, action: 'clipboard' });
                if (beginEventArgs.cancel) {
                    return;
                }
                selIdx = getRangeIndexes(beginEventArgs.pastedRange);
                if (isExternal) {
                    isRepeative = pasteModelArgs.selection !== 'Sheet' && (selIdx[2] - selIdx[0] + 1) % pasteModelArgs.rowCount === 0 &&
                        (selIdx[3] - selIdx[1] + 1) % pasteModelArgs.colCount === 0;
                }
                else {
                    isRepeative = !notRemoveMerge && !isRowSelected && (selIdx[2] - selIdx[0] + 1) % (cIdx[2] - cIdx[0] + 1) === 0
                        && !isColSelected && (selIdx[3] - selIdx[1] + 1) % (cIdx[3] - cIdx[1] + 1) === 0;
                }
                rfshRange = isRepeative ? selIdx : [selIdx[0], selIdx[1]].concat([selIdx[0] + cIdx[2] - cIdx[0], selIdx[1] + cIdx[3] - cIdx[1] || selIdx[1]]);
                pasteType = beginEventArgs.type;
            }
            let selectionRange;
            if (cSheetSel) {
                selectionRange = [].concat(rfshRange);
                if (cSheetSel === 'Sheet' || cSheetSel === 'Column') {
                    if (rfshRange[2] < curSheet.usedRange.rowIndex) {
                        rfshRange[2] = curSheet.usedRange.rowIndex;
                    }
                    if (cIdx[2] < curSheet.usedRange.rowIndex) {
                        cIdx[2] += curSheet.usedRange.rowIndex - cIdx[2];
                    }
                    if (selectionRange[2] < curSheet.rowCount) {
                        selectionRange[2] = curSheet.rowCount - 1;
                    }
                }
                if (cSheetSel === 'Sheet' || cSheetSel === 'Row') {
                    if (rfshRange[3] < curSheet.usedRange.colIndex) {
                        cIdx[3] += curSheet.usedRange.colIndex - rfshRange[3];
                        rfshRange[3] = curSheet.usedRange.colIndex;
                    }
                    if (cIdx[3] < curSheet.usedRange.colIndex) {
                        cIdx[3] += curSheet.usedRange.colIndex - cIdx[3];
                    }
                    if (selectionRange[3] < curSheet.colCount) {
                        selectionRange[3] = curSheet.colCount - 1;
                    }
                }
            }
            else {
                selectionRange = rfshRange;
            }
            let cell;
            let isExtend;
            let prevCell;
            let rowIdx = selIdx[0];
            const mergeCollection = [];
            if (curSheet.isProtected && isLockedCells(this.parent, rfshRange)) {
                this.parent.notify(editAlert, null);
                return;
            }
            if (this.copiedShapeInfo && !this.copiedInfo) {
                const pictureElem = this.copiedShapeInfo.pictureElem;
                if (pictureElem.classList.contains('e-datavisualization-chart')) {
                    this.copiedShapeInfo.chartInfo.top = null;
                    this.copiedShapeInfo.chartInfo.left = null;
                    this.parent.notify(setChart, {
                        chart: [this.copiedShapeInfo.chartInfo], isInitCell: true, isUndoRedo: true, isPaste: true,
                        dataSheetIdx: this.copiedShapeInfo.sheetIdx, isCut: this.copiedShapeInfo.isCut, sheetId: curSheet.id,
                        range: args.range || `${curSheet.name}!${curSheet.selectedRange}`
                    });
                }
                else {
                    this.parent.notify(createImageElement, {
                        options: {
                            src: pictureElem.style.backgroundImage.replace(/url\((['"])?(.*?)\1\)/gi, '$2'),
                            height: this.copiedShapeInfo.height, width: this.copiedShapeInfo.width,
                            id: this.copiedShapeInfo.isCut ? pictureElem.id : ''
                        },
                        range: getRangeAddress([rowIdx, selIdx[1], rowIdx, selIdx[1]]), isPublic: false, isUndoRedo: true
                    });
                }
                const pastedCell = getCell(rowIdx, selIdx[1], curSheet);
                if (pastedCell && !isNullOrUndefined(pastedCell.image) && pastedCell.image.length > 0) {
                    const eventArgs = {
                        requestType: 'imagePaste',
                        copiedShapeInfo: this.copiedShapeInfo,
                        pasteSheetIndex: this.parent.activeSheetIndex,
                        pastedRange: getSheetName(this.parent) + '!' + getRangeAddress([rowIdx, selIdx[1], rowIdx, selIdx[1]]),
                        pastedPictureElement: document.getElementById(pastedCell.image[pastedCell.image.length - 1].id)
                    };
                    this.parent.notify(completeAction, { eventArgs: eventArgs, action: 'clipboard' });
                }
            }
            else {
                const cRows = [];
                const isInRange = this.isInRange(cIdx, selIdx, copiedIdx);
                let isFullRowMerge = false;
                let isFullColMerge = false;
                let hiddenCount = 0;
                const cf = [];
                let cfRule;
                let cancel;
                if (!isRepeative && pasteType !== 'Values') {
                    cfRule = this.setCF(cIdx, rfshRange, prevSheet, curSheet, cf, cfRule);
                }
                let isUniqueCell = false;
                const uniqueCellColl = [];
                const copyCellArgs = {
                    sheet: curSheet, isExternal: !!isExternal
                };
                const pasteSetCell = this.setCell(copyCellArgs);
                const cutSetCell = !isExternal && this.copiedInfo.isCut && this.setCell({ sheet: prevSheet });
                const prevSheetMergeCollection = [];
                const colValidationCollection = [];
                for (let i = cIdx[0], l = 0; i <= cIdx[2]; i++, l++) {
                    if (!isExternal && !copyInfo.isCut && isFilterHidden(prevSheet, i)) {
                        l--;
                        hiddenCount++;
                        continue;
                    }
                    if (isInRange) {
                        cRows[selIdx[0] + l] = { cells: [] };
                    }
                    for (let j = cIdx[1], k = 0; j <= cIdx[3]; j++, k++) {
                        if (isInRange) {
                            cRows[selIdx[0] + l].cells[selIdx[1] + k] = getCell(selIdx[0] + l, selIdx[1] + k, prevSheet, false, true);
                        }
                        cell = isExternal ? (rows[i] && rows[i].cells[j]) || {} :
                            extend({}, (isInRange && cRows[i] && cRows[i].cells[j]) ?
                                cRows[i].cells[j] : getCell(i, j, prevSheet), null, true);
                        column = getColumn(prevSheet, j);
                        if (!cell.validation && checkColumnValidation(column, i, j)) {
                            const validation = Object.assign({}, column.validation);
                            const prevIdx = [0, cIdx[1], 0, cIdx[3]];
                            const value1 = validation.value1;
                            const value2 = validation.value2;
                            if (checkIsFormula(value1)) {
                                validation.value1 = getUpdatedFormula([i, j], prevIdx, prevSheet, this.parent, { formula: value1 });
                            }
                            if (checkIsFormula(value2)) {
                                validation.value2 = getUpdatedFormula([i, j], prevIdx, prevSheet, this.parent, { formula: value2 });
                            }
                            cell.validation = validation;
                        }
                        if (cell && cell.isReadOnly) {
                            delete cell.isReadOnly;
                        }
                        if (isRowSelected || isColSelected) {
                            if (cell && cell.rowSpan) {
                                if (cell.rowSpan > 0) {
                                    if ((cell.rowSpan + i) - 1 <= cIdx[2]) {
                                        isFullRowMerge = true;
                                    }
                                    else {
                                        cell = {};
                                    }
                                }
                                else if (!isFullRowMerge) {
                                    cell = {};
                                }
                                else if (cell.rowSpan < 0) {
                                    const rowSpan = cell.rowSpan;
                                    const colSpan = cell.colSpan ? cell.colSpan : 0;
                                    const spanCell = getCell(rowIdx + rowSpan, (selIdx[1] + k) + colSpan, curSheet);
                                    if (spanCell && !spanCell.rowSpan) {
                                        cell = {};
                                    }
                                }
                            }
                            if (cell && cell.colSpan) {
                                if (cell.colSpan > 0) {
                                    if ((cell.colSpan + j) - 1 <= cIdx[3]) {
                                        isFullColMerge = true;
                                    }
                                    else {
                                        cell = {};
                                    }
                                }
                                else if (!isFullColMerge) {
                                    cell = {};
                                }
                            }
                        }
                        if (cell && pasteType) {
                            let model;
                            switch (pasteType) {
                                case 'Formats':
                                    model = { format: cell.format, style: cell.style };
                                    if (this.copiedInfo && !this.copiedInfo.isCut) {
                                        if (cell.rowSpan) {
                                            model.rowSpan = cell.rowSpan;
                                        }
                                        if (cell.colSpan) {
                                            model.colSpan = cell.colSpan;
                                        }
                                    }
                                    cell = model;
                                    break;
                                case 'Values':
                                    cell = { value: cell.value };
                                    if (cell.value && cell.value.toString().indexOf('\n') > -1) {
                                        const ele = this.parent.getCell(selIdx[0], selIdx[1]);
                                        ele.classList.add('e-alt-unwrap');
                                    }
                                    break;
                            }
                            isExtend = ['Formats', 'Values'].indexOf(pasteType) > -1;
                        }
                        if ((!this.parent.scrollSettings.isFinite && (cIdx[2] - cIdx[0] > (1048575 - selIdx[0])
                            || cIdx[3] - cIdx[1] > (16383 - selIdx[1])))
                            || (this.parent.scrollSettings.isFinite && (cIdx[2] - cIdx[0] > (curSheet.rowCount - 1 - selIdx[0])
                                || cIdx[3] - cIdx[1] > (curSheet.colCount - 1 - selIdx[1])))) {
                            this.showDialog();
                            return;
                        }
                        if (isRepeative) {
                            for (let x = selIdx[0]; x <= selIdx[2]; x += (cIdx[2] - cIdx[0]) + 1) {
                                if (!copyInfo.isCut && !hiddenCount && isFilterHidden(curSheet, x + l)) {
                                    continue;
                                }
                                for (let y = selIdx[1]; y <= selIdx[3]; y += (cIdx[3] - cIdx[1] + 1)) {
                                    if (i === cIdx[0] && j === cIdx[1] && (cfRule === undefined || cfRule.length) &&
                                        pasteType !== 'Values') {
                                        cfRule = this.setCF(cIdx, [x, y, x + (cIdx[2] - cIdx[0]), y + (cIdx[3] - cIdx[1])], prevSheet, curSheet, cf, cfRule);
                                    }
                                    prevCell = getCell(x + l, y + k, curSheet, false, true);
                                    if (!isExternal && (!isNullOrUndefined(prevCell.colSpan) || !isNullOrUndefined(prevCell.rowSpan))) {
                                        if (isRowSelected || isColSelected) {
                                            continue;
                                        }
                                        const merge = { range: [x + l, y + k, x + l, y + k], merge: false, isAction: false, type: 'All',
                                            sheetIndex: cSIdx, preventRefresh: cSIdx !== this.parent.activeSheetIndex };
                                        mergeCollection.push(merge);
                                        this.parent.notify(setMerge, merge);
                                    }
                                    const colInd = y + k;
                                    cell = extend({}, cell ? cell : {}, null, true);
                                    if (!isExtend && this.copiedInfo && !this.copiedInfo.isCut && cell.formula) {
                                        const newFormula = getUpdatedFormula([x + l, colInd], [i, j], prevSheet, this.parent, isInRange ? cell : null);
                                        if (!isNullOrUndefined(newFormula)) {
                                            cell.formula = newFormula;
                                        }
                                    }
                                    if (this.copiedInfo && !this.copiedInfo.isCut && cell.validation) {
                                        const currIdx = selIdx;
                                        const prevIdx = cIdx;
                                        let updatedVal = getUpdatedFormula(currIdx, prevIdx, prevSheet, this.parent, { formula: cell.validation.value1 });
                                        cell.validation.value1 = updatedVal;
                                        if (cell.validation.value2 !== '') {
                                            updatedVal = getUpdatedFormula(currIdx, prevIdx, prevSheet, this.parent, { formula: cell.validation.value2 });
                                            cell.validation.value2 = updatedVal;
                                        }
                                    }
                                    if (curSheet.isProtected && cell && cell.isLocked !== false) {
                                        cell.isLocked = prevCell.isLocked;
                                    }
                                    if (prevCell && prevCell.formula && prevCell.formula.indexOf('=UNIQUE(') > -1) {
                                        this.parent.notify(removeUniquecol, null);
                                    }
                                    const uniqueFormulaArgs = {
                                        cellIdx: [i, j], isUnique: false, uniqueRange: '', sheetName: prevSheet.name
                                    };
                                    this.parent.notify(checkUniqueRange, uniqueFormulaArgs);
                                    if (uniqueFormulaArgs.isUnique) {
                                        cell.value = null;
                                    }
                                    isUniqueCell = false;
                                    if (cell && cell.formula && cell.formula.indexOf('=UNIQUE(') > -1) {
                                        isUniqueCell = true;
                                        uniqueCellColl.push([x, colInd]);
                                        cell.value = null;
                                    }
                                    cancel = pasteSetCell(x + l, colInd, cell, colInd === selIdx[3], isExtend, isUniqueCell, args.beforeActionData, args.isUndo);
                                    if (cancel) {
                                        continue;
                                    }
                                    if (cell.formula && this.copiedInfo && this.copiedInfo.isCut) {
                                        this.parent.notify(clearFormulaDependentCells, { cellRef: getRangeAddress([i, j, i, j]) });
                                    }
                                }
                            }
                        }
                        else {
                            if (isExternal || !hasTemplate(this.parent, i, j, copiedIdx)) {
                                if (notRemoveMerge) {
                                    pasteSetCell(rowIdx, selIdx[1] + k, { value: cell.value }, j === cIdx[3], true);
                                }
                                else {
                                    pasteSetCell(rowIdx, selIdx[1] + k, cell, j === cIdx[3], isExtend);
                                }
                            }
                        }
                        if (!isExternal && this.copiedInfo.isCut && !(inRange(selIdx, i, j) &&
                            copiedIdx === this.parent.activeSheetIndex)) {
                            let cell = getCell(i, j, prevSheet);
                            if (cell) {
                                if (cell.isReadOnly) {
                                    continue;
                                }
                                if (cell.isLocked || isNullOrUndefined(cell.isLocked)) {
                                    if ((isRowSelected || isColSelected) && (cell.rowSpan !== undefined || cell.colSpan !== undefined)) {
                                        if (cell.rowSpan > 1 || cell.colSpan > 1) {
                                            prevSheetMergeCollection.push({ range: [i, j, i, j], rowSpan: cell.rowSpan, colSpan: cell.colSpan });
                                            cell = null;
                                        }
                                        else {
                                            continue;
                                        }
                                    }
                                    else {
                                        if (!cell.validation && prevSheet.columns[j] && prevSheet.columns[j].validation
                                            && colValidationCollection.indexOf(j) === -1) {
                                            colValidationCollection.push(j);
                                        }
                                        cell = null;
                                    }
                                }
                                else if (cell.isLocked === false) {
                                    if (prevSheet.isProtected) {
                                        cell = { isLocked: false };
                                    }
                                    else {
                                        cell = null;
                                    }
                                }
                            }
                            cutSetCell(i, j, cell, j === cIdx[3]);
                        }
                    }
                    rowIdx++;
                }
                if (prevSheetMergeCollection.length) {
                    prevSheetMergeCollection.forEach((mergeInfo) => {
                        setCell(mergeInfo.range[0], mergeInfo.range[1], prevSheet, {
                            rowSpan: mergeInfo.rowSpan, colSpan: mergeInfo.colSpan
                        });
                        const mergeArgs = { range: mergeInfo.range };
                        this.parent.notify(mergedRange, mergeArgs);
                        this.parent.notify(setMerge, {
                            merge: false, range: mergeArgs.range, type: 'All',
                            sheetIndex: pSheetIdx, preventRefresh: pSheetIdx !== this.parent.activeSheetIndex
                        });
                        mergeArgs.range = mergeArgs.range;
                        for (let sRowIdx = mergeArgs.range[0]; sRowIdx <= mergeArgs.range[2]; sRowIdx++) {
                            for (let sColIdx = mergeArgs.range[1]; sColIdx <= mergeArgs.range[3]; sColIdx++) {
                                cutSetCell(sRowIdx, sColIdx, null);
                            }
                        }
                    });
                }
                if (colValidationCollection.length) {
                    colValidationCollection.forEach((colIdx) => {
                        this.parent.notify(cellValidation, { range: prevSheet.name + '!' + getRangeAddress([cIdx[0], colIdx, cIdx[2], colIdx]), isRemoveValidation: true });
                    });
                }
                if (uniqueCellColl.length) {
                    for (let i = 0; i < uniqueCellColl.length; i++) {
                        this.parent.serviceLocator.getService('cell').refresh(uniqueCellColl[i][0], uniqueCellColl[i][1]);
                    }
                }
                if (copyCellArgs.isRandFormula && this.parent.calculationMode === 'Automatic') {
                    this.parent.notify(workbookFormulaOperation, { action: 'refreshRandomFormula' });
                }
                this.parent.notify(refreshRibbonIcons, null);
                const hiddenDiff = rfshRange[2] - hiddenCount;
                const selHiddenDiff = selectionRange[2] - hiddenCount;
                rfshRange[2] = hiddenDiff;
                selectionRange[2] = selHiddenDiff;
                this.parent.setUsedRange(rfshRange[2], rfshRange[3]);
                const selRange = getRangeAddress(selectionRange);
                if (cSIdx === this.parent.activeSheetIndex && !args.isFromUpdateAction) {
                    this.parent.notify(selectRange, { address: selRange });
                }
                if (!isExternal && this.copiedInfo.isCut) {
                    isCut = this.copiedInfo.isCut;
                    if (copiedIdx === this.parent.activeSheetIndex) {
                        this.parent.serviceLocator.getService('cell').refreshRange(cIdx);
                    }
                    this.clearCopiedInfo();
                }
                if ((isExternal || isInRange) && this.copiedInfo) {
                    this.clearCopiedInfo();
                }
                let clearCFArgs;
                if (isCut) {
                    if (cfRule && cfRule.length && pasteType !== 'Values') {
                        clearCFArgs = { range: cIdx, sheetIdx: pSheetIdx, isClear: true };
                        this.parent.notify(clearCFRule, clearCFArgs);
                    }
                    //this.updateFilter(copyInfo, rfshRange);
                    setMaxHgt(prevSheet, cIdx[0], cIdx[1], (this.parent.getRow(cIdx[0], null, this.parent.frozenColCount(prevSheet)) || { offsetHeight: 20 }).offsetHeight);
                    const hgt = getMaxHgt(prevSheet, cIdx[0]);
                    setRowEleHeight(this.parent, prevSheet, hgt, cIdx[0]);
                }
                if (cf.length && cSIdx === this.parent.activeSheetIndex) {
                    this.parent.notify(applyCF, { cfModel: cf, isAction: true });
                }
                const copySheet = getSheet(this.parent, copiedIdx);
                if (!isExternal && cIdx[0] === cIdx[2] && cSheetSel === 'Row') {
                    const hgt = copySheet.rows[cIdx[0]].height;
                    for (let i = selIdx[0]; i <= selIdx[2]; i++) {
                        setRowEleHeight(this.parent, this.parent.getActiveSheet(), hgt, i);
                    }
                    if (isCut) {
                        const defaultHeight = copySheet && copySheet.standardHeight ? copySheet.standardHeight : 20;
                        setRowEleHeight(this.parent, copySheet, defaultHeight, cIdx[0]);
                    }
                }
                if (args.isAction) {
                    const eventArgs = {
                        requestType: 'paste',
                        copiedInfo: copyInfo,
                        mergeCollection: mergeCollection,
                        pasteSheetIndex: this.parent.activeSheetIndex,
                        copiedRange: prevSheet.name + '!' + (copyInfo.range ? getRangeAddress(copyInfo.range) : prevSheet.selectedRange),
                        pastedRange: curSheet.name + '!' + getRangeAddress(rfshRange),
                        type: pasteType || 'All',
                        selectedRange: selRange
                    };
                    if (hiddenCount) {
                        eventArgs['skipFilterCheck'] = true;
                    }
                    if (clearCFArgs && clearCFArgs.cfClearActionArgs) {
                        eventArgs['cfClearActionArgs'] = clearCFArgs.cfClearActionArgs;
                    }
                    if (cf.length) {
                        eventArgs['cfActionArgs'] = { cfModel: cf, sheetIdx: cSIdx };
                    }
                    this.parent.notify(completeAction, { eventArgs: eventArgs, action: 'clipboard' });
                }
                if (args.focus) {
                    focus(this.parent.element);
                }
            }
        }
        else {
            this.getClipboardEle().select();
        }
    }
    setCF(cRange, pRange, cSheet, pSheet, cf, conditionalFormats) {
        let cfRange;
        let indexes;
        const assignCF = (conditionalFormat) => {
            cfRange = [pRange[0] + (indexes[0] <= cRange[0] ? 0 : indexes[0] - cRange[0]),
                pRange[1] + (indexes[1] <= cRange[1] ? 0 : indexes[1] - cRange[1]),
                pRange[2] - (indexes[2] >= cRange[2] ? 0 : cRange[2] - indexes[2]),
                pRange[3] - (indexes[3] >= cRange[3] ? 0 : cRange[3] - indexes[3])];
            if (!pSheet.conditionalFormats) {
                this.parent.setSheetPropertyOnMute(pSheet, 'conditionalFormats', []);
            }
            const cfRule = {
                range: getRangeAddress(cfRange), type: conditionalFormat.type,
                cFColor: conditionalFormat.cFColor, value: conditionalFormat.value, format: conditionalFormat.format
            };
            pSheet.conditionalFormats.push(cfRule);
            cf.push(cfRule);
        };
        if (conditionalFormats) {
            for (let i = 0, len = conditionalFormats.length; i < len; i++) {
                indexes = getRangeIndexes(conditionalFormats[i].range);
                assignCF(conditionalFormats[i]);
            }
        }
        else {
            conditionalFormats = [];
            if (cSheet.conditionalFormats) {
                for (let i = 0, len = cSheet.conditionalFormats.length; i < len; i++) {
                    indexes = getRangeIndexes(cSheet.conditionalFormats[i].range);
                    if (checkRange([cRange], cSheet.conditionalFormats[i].range)) {
                        conditionalFormats.push(cSheet.conditionalFormats[i]);
                        assignCF(cSheet.conditionalFormats[i]);
                    }
                }
            }
        }
        return conditionalFormats;
    }
    isRangeMerged(range, sheet) {
        const cell = getCell(range[0], range[1], sheet);
        if (cell && (cell.colSpan > 1 || cell.rowSpan > 1)) {
            const args = { range: range.slice(2, 4).concat(range.slice(2, 4)) };
            this.parent.notify(activeCellMergedRange, args);
            return args.range[0] === range[0] && args.range[1] === range[1] && args.range[2] === range[2] && args.range[3] === range[3];
        }
        return false;
    }
    updateFilter(copyInfo, pastedRange) {
        let isFilterCut;
        let diff;
        this.parent.notify(setFilteredCollection, null);
        for (let i = 0; i < this.parent.sheets.length; i++) {
            if (this.parent.filterCollection && this.parent.filterCollection[i] &&
                this.parent.filterCollection[i].sheetIndex === getSheetIndexFromId(this.parent, copyInfo.sId)) {
                let range = copyInfo.range;
                const fRange = getRangeIndexes(this.parent.filterCollection[i].filterRange);
                range = getSwapRange(range);
                if (fRange[0] === range[0] && fRange[2] === range[2] && fRange[1] === range[1] && fRange[3] === range[3]) {
                    isFilterCut = true;
                    diff = [Math.abs(range[0] - fRange[0]), Math.abs(range[1] - fRange[1]),
                        Math.abs(range[2] - fRange[2]), Math.abs(range[3] - fRange[3])];
                }
            }
        }
        let cell = this.parent.getCell(copyInfo.range[0], copyInfo.range[1]);
        cell = cell ? (cell.querySelector('.e-filter-icon') ? cell : this.parent.getCell(copyInfo.range[2], copyInfo.range[3])) : cell;
        const asc = cell ? cell.querySelector('.e-sortasc-filter') : cell;
        const desc = cell ? cell.querySelector('.e-sortdesc-filter') : cell;
        if (isFilterCut) {
            for (let n = 0; n < this.parent.filterCollection.length; n++) {
                const filterCol = this.parent.filterCollection[n];
                const sheetIndex = copyInfo && copyInfo.sId ? getSheetIndexFromId(this.parent, copyInfo.sId) :
                    this.parent.activeSheetIndex;
                if (filterCol.sheetIndex === sheetIndex) {
                    this.parent.notify(initiateFilterUI, { predicates: null, range: filterCol.filterRange, sIdx: sheetIndex, isCut: true });
                }
                if (filterCol.sheetIndex === sheetIndex && sheetIndex === this.parent.activeSheetIndex) {
                    diff = [pastedRange[0] + diff[0], pastedRange[1] + diff[1],
                        Math.abs(pastedRange[2] - diff[2]), Math.abs(pastedRange[3] - diff[3])];
                    this.parent.notify(initiateFilterUI, { predicates: null, range: getRangeAddress(diff), sIdx: null, isCut: true });
                    if (copyInfo.range[3] === copyInfo.range[1]) { // To update sorted icon after pasting.
                        const filteredCell = this.parent.getCell(pastedRange[0], pastedRange[1]);
                        if (asc && filteredCell) {
                            filteredCell.querySelector('.e-filter-icon').classList.add('e-sortasc-filter');
                        }
                        if (desc && filteredCell) {
                            filteredCell.querySelector('.e-filter-icon').classList.add('e-sortdesc-filter');
                        }
                    }
                }
            }
        }
    }
    isInRange(cRng, pRng, sIdx) {
        const activeSheetIndex = this.parent.activeSheetIndex;
        return (inRange(cRng, pRng[0], pRng[1]) && sIdx === activeSheetIndex) ||
            (inRange(cRng, pRng[2], pRng[3]) && sIdx === activeSheetIndex);
    }
    setCell(args) {
        const sheet = args.sheet;
        const uiRefresh = sheet.name === this.parent.getActiveSheet().name;
        return (rIdx, cIdx, cell, lastCell, isExtend, isUniqueCell, actionData, isUndo) => {
            if (cell && cell.formula && (cell.formula.indexOf('RANDBETWEEN(') > -1 || cell.formula.indexOf('RAND(') > -1 ||
                cell.formula.indexOf('NOW(') > -1)) {
                args.isRandFormula = true;
            }
            const cancel = updateCell(this.parent, sheet, {
                cell: cell, rowIdx: rIdx, colIdx: cIdx, pvtExtend: !isExtend, valChange: !isUniqueCell, lastCell: lastCell,
                uiRefresh: uiRefresh, requestType: 'paste', skipFormatCheck: !args.isExternal, isRandomFormula: args.isRandFormula
            }, actionData, isUndo);
            if (!cancel && cell && cell.style && args.isExternal) {
                let hgt = getTextHeightWithBorder(this.parent, rIdx, cIdx, sheet, cell.style || this.parent.cellStyle, cell.wrap ? getLines(this.parent.getDisplayText(cell), getExcludedColumnWidth(sheet, rIdx, cIdx, cell.colSpan > 1 ? cIdx + cell.colSpan - 1 : cIdx), cell.style, this.parent.cellStyle) : 1);
                hgt = Math.round(hgt);
                if (hgt < 20) {
                    hgt = 20; // default height
                }
                setMaxHgt(sheet, rIdx, cIdx, hgt);
                const prevHeight = getRowsHeight(sheet, rIdx);
                const maxHgt = getMaxHgt(sheet, rIdx);
                const heightChanged = maxHgt > prevHeight;
                if (heightChanged) {
                    setRowEleHeight(this.parent, sheet, maxHgt, rIdx);
                }
            }
            return cancel;
        };
    }
    getCopiedIdx() {
        if (this.copiedInfo) {
            for (let i = 0; i < this.parent.sheets.length; i++) {
                if (this.parent.sheets[i].id === this.copiedInfo.sId) {
                    return i;
                }
            }
            this.clearCopiedInfo();
        }
        return -1;
    }
    setCopiedInfo(args, isCut) {
        if (this.parent.isEdit) {
            return;
        }
        const deferred = new Deferred();
        args.promise = deferred.promise;
        const sheet = this.parent.getActiveSheet();
        let range;
        if (args && args.range) {
            const isRowSelected = (args.range[1] === 0 && args.range[3] === sheet.colCount - 1);
            const isColSelected = (args.range[0] === 0 && args.range[2] === sheet.rowCount - 1);
            const mergeArgs = { range: args.range };
            if (!(isRowSelected || isColSelected)) {
                this.parent.notify(mergedRange, mergeArgs);
            }
            range = mergeArgs.range;
        }
        else {
            range = getRangeIndexes(sheet.selectedRange);
        }
        if (isCut && isReadOnlyCells(this.parent, range)) {
            this.parent.notify(readonlyAlert, null);
            return;
        }
        if (args && !args.isPublic && !args.clipboardData) {
            const eventArgs = { copiedRange: `${sheet.name}!${getRangeAddress(range)}`, cancel: false, action: isCut ? 'cut' : 'copy' };
            this.parent.notify(beginAction, eventArgs);
            if (eventArgs.cancel) {
                return;
            }
        }
        const option = {
            sheet: sheet, indexes: [0, 0, sheet.rowCount - 1, sheet.colCount - 1], isFinite: this.parent.scrollSettings.isFinite,
            promise: new Promise((resolve) => { resolve((() => { })()); })
        };
        const pictureElements = document.getElementsByClassName('e-ss-overlay-active');
        const pictureLen = pictureElements.length;
        if (sheet.isLocalData && !(args && args.clipboardData) && range[0] === 0 && range[2] === (sheet.rowCount - 1) && !pictureLen) {
            this.parent.showSpinner();
            this.parent.notify('updateSheetFromDataSource', option);
        }
        this.checkForUncalculatedFormula(range, (args && args.sId) ? args.sId : sheet.id);
        option.promise.then(() => {
            if (pictureLen > 0) {
                const imgRowIdx = {
                    clientY: pictureElements[0].offsetTop,
                    isImage: true
                };
                this.parent.notify(getRowIdxFromClientY, imgRowIdx);
                const imgColIdx = {
                    clientX: pictureElements[0].offsetLeft,
                    isImage: true
                };
                this.parent.notify(getColIdxFromClientX, imgColIdx);
                this.copiedShapeInfo = {
                    sId: (args && args.sId) ? args.sId : sheet.id, sheetIdx: sheet.index, isCut: isCut, pictureElem: pictureElements[0], copiedRange: getRangeAddress([imgRowIdx.clientY, imgColIdx.clientX,
                        imgRowIdx.clientY, imgColIdx.clientX]), height: pictureElements[0].offsetHeight,
                    width: pictureElements[0].offsetWidth,
                    chartInfo: this.getChartElemInfo(pictureElements[0])
                };
                if (!pictureElements[0].classList.contains('e-datavisualization-chart')) {
                    const imgURL = window.getComputedStyle(pictureElements[0]).backgroundImage.slice(5, -2);
                    this.addImgToClipboard(imgURL, this.copiedShapeInfo.height, this.copiedShapeInfo.width);
                }
                this.hidePaste(true);
                if (isCut) {
                    if (pictureElements[0].classList.contains('e-datavisualization-chart')) {
                        this.parent.deleteChart(this.copiedShapeInfo.chartInfo.id);
                    }
                    else {
                        this.parent.notify(deleteImage, {
                            id: this.copiedShapeInfo.pictureElem.id, sheetIdx: this.copiedShapeInfo.sId,
                            range: this.copiedShapeInfo.copiedRange
                        });
                    }
                }
            }
            else if (!(args && args.clipboardData)) {
                if (this.copiedInfo) {
                    this.clearCopiedInfo();
                }
                this.copiedInfo = {
                    range: range, sId: (args && args.sId) ? args.sId : sheet.id, isCut: isCut
                };
                this.hidePaste(true);
                if (!args.isFromUpdateAction) {
                    this.initCopyIndicator();
                }
                if (!Browser.isIE) {
                    this.getClipboardEle().select();
                }
                if (args && args.invokeCopy) {
                    document.execCommand(isCut ? 'cut' : 'copy');
                }
                this.parent.hideSpinner();
            }
            if (Browser.isIE) {
                this.setExternalCells(args, isCut);
            }
            deferred.resolve();
        });
        if (args && args.clipboardData) {
            this.setExternalCells(args, isCut);
            this.getClipboardEle().setAttribute('aria-label', `${sheet.selectedRange} ${this.parent.serviceLocator.getService(locale).getConstant(isCut ? 'Cut' : 'Copy')}`);
        }
    }
    imageToCanvas(src, height, width) {
        return new Promise((res) => {
            const canvas = document.createElement('canvas');
            const canvasCtx = canvas.getContext('2d');
            const img = new Image();
            img.src = src;
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                canvas.width = width;
                canvas.height = height;
                canvasCtx.drawImage(img, 0, 0, width, height);
                canvas.toBlob((blob) => {
                    res(blob);
                }, 'image/png');
            };
        });
    }
    addImgToClipboard(src, height, width) {
        return __awaiter(this, void 0, void 0, function* () {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            const navigator = window.navigator;
            const imageBlob = yield this.imageToCanvas(src, height, width);
            yield navigator.clipboard.write([new ClipboardItem({ [imageBlob.type]: imageBlob })]);
        });
    }
    checkForUncalculatedFormula(range, sheetId) {
        let cell;
        const sheetIdx = getSheetIndexFromId(this.parent, sheetId);
        const sheet = getSheet(this.parent, sheetIdx);
        for (let i = range[0]; i <= range[2]; i++) {
            for (let j = range[1]; j <= range[3]; j++) {
                cell = getCell(i, j, sheet, null, true);
                if (cell.formula && isUndefined$1(cell.value)) {
                    this.parent.notify(workbookFormulaOperation, {
                        action: 'refreshCalculate', value: cell.formula, rowIndex: i, colIndex: j, isFormula: checkIsFormula(cell.formula), sheetIndex: sheetIdx
                    });
                }
            }
        }
    }
    getChartElemInfo(overlayEle) {
        const chartColl = this.parent.chartColl;
        if (overlayEle.classList.contains('e-datavisualization-chart')) {
            const chartId = overlayEle.getElementsByClassName('e-control')[0].id;
            for (let idx = 0; idx < chartColl.length; idx++) {
                if (chartColl[idx].id === chartId) {
                    const chart = chartColl[idx];
                    return chart;
                }
            }
        }
        return null;
    }
    clearCopiedInfo() {
        if (this.copiedInfo) {
            if (this.parent.getActiveSheet().id === this.copiedInfo.sId) {
                this.removeIndicator(this.parent.getSelectAllContent());
                this.removeIndicator(this.parent.getColumnHeaderContent());
                this.removeIndicator(this.parent.getRowHeaderContent());
                this.removeIndicator(this.parent.getMainContent());
            }
            this.copiedInfo = null;
            this.hidePaste();
        }
        if (this.copiedShapeInfo) {
            this.copiedShapeInfo = null;
            this.hidePaste();
        }
    }
    removeIndicator(ele) {
        if (ele) {
            const indicator = ele.getElementsByClassName('e-copy-indicator')[0];
            if (indicator) {
                detach(indicator);
            }
        }
    }
    initCopyIndicator() {
        if (this.copiedInfo && this.parent.getActiveSheet().id === this.copiedInfo.sId) {
            const copyIndicator = this.parent.createElement('div', { className: 'e-copy-indicator' });
            copyIndicator.appendChild(this.parent.createElement('div', { className: 'e-top' }));
            copyIndicator.appendChild(this.parent.createElement('div', { className: 'e-bottom' }));
            copyIndicator.appendChild(this.parent.createElement('div', { className: 'e-left' }));
            copyIndicator.appendChild(this.parent.createElement('div', { className: 'e-right' }));
            setPosition(this.parent, copyIndicator, this.copiedInfo.range, 'e-copy-indicator');
        }
    }
    showDialog() {
        this.parent.serviceLocator.getService(dialog).show({
            header: 'Spreadsheet',
            height: 205, width: 340, isModal: true, showCloseIcon: true,
            content: this.parent.serviceLocator.getService(locale).getConstant('PasteAlert'),
            beforeOpen: (args) => {
                const dlgArgs = {
                    dialogName: 'PasteDialog',
                    element: args.element, target: args.target, cancel: args.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    args.cancel = true;
                }
            }
        });
    }
    hidePaste(isShow) {
        if (this.parent.getActiveSheet().isProtected) {
            isShow = false;
        }
        this.parent.notify(enableToolbarItems, [{ items: [this.parent.element.id + '_paste'], enable: isShow || false }]);
    }
    setExternalCells(args, isCut) {
        let cell;
        let val;
        let text = '';
        let cellStyle;
        const sheet = this.parent.getActiveSheet();
        const range = getSwapRange(this.copiedInfo.range);
        const isRowSelected = range[1] === 0 && range[3] === sheet.colCount - 1;
        const isColSelected = range[0] === 0 && range[2] === sheet.rowCount - 1;
        let data = '<html><body><table class="e-spreadsheet" xmlns="http://www.w3.org/1999/xhtml" style="border-collapse:collapse;"';
        if (isRowSelected || isColSelected) {
            data += ` aria-rowcount="${sheet.usedRange.rowIndex}" aria-colcount="${sheet.usedRange.colIndex}"`;
            data += ` aria-label="${isRowSelected && isColSelected ? 'Sheet' : isRowSelected ? 'Row' : 'Column'}"`;
        }
        data += '><tbody>';
        for (let i = range[0]; i <= range[2]; i++) {
            if (!isCut && isFilterHidden(sheet, i)) {
                continue;
            }
            data += '<tr>';
            for (let j = range[1]; j <= range[3]; j++) {
                cell = getCell(i, j, sheet, false, true);
                if (cell.colSpan < 0 || cell.rowSpan < 0) {
                    continue;
                }
                data += '<td';
                if (cell.colSpan) {
                    data += ' colspan="' + cell.colSpan + '"';
                }
                if (cell.rowSpan) {
                    data += ' rowspan="' + cell.rowSpan + '"';
                }
                if (cell.style) {
                    cellStyle = '';
                    if (!cell.style['whiteSpace']) {
                        cellStyle += 'white-space:' + (cell.wrap ? 'normal' : 'nowrap') + ';';
                    }
                    if (!cell.style.verticalAlign) {
                        cellStyle += 'vertical-align:bottom;';
                    }
                    Object.keys(cell.style).forEach((style) => {
                        let cellStyleValue = cell.style[`${style}`];
                        if (style.includes('border') && cellStyleValue.includes('dashed') && cellStyleValue.includes('1px')) {
                            cellStyleValue = cellStyleValue.replace('1px', 'thin');
                        }
                        const regex = style.match(/[A-Z]/);
                        cellStyle += (style === 'backgroundColor' ? 'background' : (regex ? style.replace(regex[0], '-'
                            + regex[0].toLowerCase()) : style)) + ':' + ((style === 'backgroundColor' || style === 'color')
                            ? cell.style[`${style}`].slice(0, 7) : cellStyleValue) + ';';
                    });
                    data += cellStyle.includes('"') ? ` style='${cellStyle}'` : ` style="${cellStyle}"`;
                }
                else {
                    data += ' style="white-space:' + (cell.wrap ? 'normal' : 'nowrap') + ';vertical-align:bottom;"';
                }
                if (!isNullOrUndefined(cell.value)) {
                    val = cell.value;
                    if (cell.format && cell.format !== 'General') {
                        data += cell.value.toString().includes('"') ? ' cell-value=\'' + val + '\'' : ' cell-value="' + cell.value + '"';
                        data += cell.format.includes('"') ? ' num-format=\'' + cell.format + '\'' : ' num-format="' + cell.format + '"';
                        const eventArgs = { formattedText: val, value: val, format: cell.format, cell: cell, rowIndex: i,
                            colIndex: j, dataUpdate: true };
                        this.parent.notify(getFormattedCellObject, eventArgs);
                        val = eventArgs.formattedText;
                    }
                    data += '>';
                    if (typeof val === 'string' && val.includes('\n')) {
                        data += val.split('\n').join('<br>');
                    }
                    else {
                        data += val;
                    }
                    text += val;
                    data += '</td>';
                }
                else {
                    data += '></td>';
                }
                text += j === range[3] ? '' : '\t';
            }
            data += '</tr>';
            text += i === range[2] ? '' : '\n';
        }
        data += '</tbody></table></body></html>';
        if (Browser.isIE) {
            window['clipboardData'].setData('text', text);
            if (isCut) {
                window['clipboardData'].setData('isInternalCut', text);
            }
        }
        else {
            args.clipboardData.setData('text/html', data);
            args.clipboardData.setData('text/plain', text);
            if (isCut) {
                args.clipboardData.setData('isInternalCut', text);
            }
            args.preventDefault();
        }
    }
    getExternalCells(args) {
        let html;
        let text;
        const rows = [];
        const pasteModelArgs = { model: rows };
        const ele = this.parent.createElement('span');
        const clearClipboard = () => setTimeout(() => { this.getClipboardEle().innerHTML = ''; }, 0);
        if (Browser.isIE) {
            text = window['clipboardData'].getData('text');
        }
        else {
            html = args.clipboardData.getData('text/html');
            text = args.clipboardData.getData('text/plain');
            if (this.copiedInfo && html.includes('<table class="e-spreadsheet"')) {
                let isFilteredRange = false;
                if (!this.copiedInfo.isCut) {
                    const filterArgs = { sheetIdx: getSheetIndexFromId(this.parent, this.copiedInfo.sId) };
                    this.parent.notify(getFilterRange, filterArgs);
                    if (filterArgs.isFiltered) {
                        const indexes = filterArgs.filterRange;
                        const copyIndexes = this.copiedInfo.range;
                        isFilteredRange = indexes[0] === copyIndexes[0] && indexes[1] === copyIndexes[1] && indexes[2] === copyIndexes[2] &&
                            indexes[3] === copyIndexes[3];
                    }
                }
                if (!isFilteredRange) {
                    clearClipboard();
                    return { internal: true };
                }
            }
            ele.innerHTML = html;
        }
        if (ele.querySelector('table')) {
            this.generateCells(ele, pasteModelArgs);
        }
        else if (ele.querySelector('img')) {
            const img = ele.querySelector('img');
            this.parent.notify(createImageElement, { options: { src: img.src, height: img.height, width: img.width }, isPublic: true });
        }
        else if (text) {
            let cells = [];
            let cellStyle;
            let childArr;
            let filteredChild;
            if (html) {
                childArr = [].slice.call(ele.children);
            }
            const getStyle = this.cellStyle(ele);
            pasteModelArgs.colCount = 1;
            text.split('\n').forEach((row) => {
                cellStyle = null;
                if (html) {
                    filteredChild = childArr.filter((elem) => elem.textContent && elem.textContent.replace(/(\r\n|\n|\r|\s)/gm, ' ').trim() === row.trim())[0];
                    if (filteredChild) {
                        cellStyle = getStyle(filteredChild);
                        childArr.splice(childArr.indexOf(filteredChild), 1);
                    }
                }
                row.split('\t').forEach((col, j) => {
                    if (col || cellStyle) {
                        cells[j] = {};
                        if (cellStyle) {
                            if (cellStyle.whiteSpace &&
                                cellStyle.whiteSpace !== 'nowrap') {
                                cells[j].wrap = true;
                                delete cellStyle['whiteSpace'];
                                if (Object.keys(cellStyle).length) {
                                    cells[j].style = cellStyle;
                                }
                            }
                            else {
                                cells[j].style = cellStyle;
                            }
                        }
                        if (col) {
                            if (checkIsFormula(col)) {
                                cells[j].formula = col;
                            }
                            else {
                                cells[j].value = parseIntValue(col.trim(), true, true);
                            }
                        }
                    }
                });
                rows.push({ cells: cells });
                pasteModelArgs.colCount = Math.max(pasteModelArgs.colCount, cells.length);
                cells = [];
            });
            pasteModelArgs.rowCount = rows.length;
            pasteModelArgs.usedRowIndex = rows.length - 1;
            pasteModelArgs.usedColIndex = pasteModelArgs.colCount - 1;
        }
        else if (args.clipboardData.files && args.clipboardData.files[0] && args.clipboardData.files[0].type.includes('image')) {
            clearClipboard();
            return { file: args.clipboardData.files[0] };
        }
        clearClipboard();
        return pasteModelArgs;
    }
    generateCells(ele, pasteModelArgs) {
        const rows = pasteModelArgs.model;
        const table = ele.querySelector('table');
        const isSpreadsheet = table.classList.contains('e-spreadsheet');
        const tableStyleObj = {};
        const rowStyleObj = {};
        pasteModelArgs.usedRowIndex = table.rows.length - 1;
        pasteModelArgs.rowCount = table.rows.length;
        if (isSpreadsheet) {
            pasteModelArgs.selection = table.getAttribute('aria-label');
            if (pasteModelArgs.selection) {
                if (pasteModelArgs.selection === 'Sheet') {
                    pasteModelArgs.usedRowIndex = Number(table.getAttribute('aria-rowcount'));
                    pasteModelArgs.usedColIndex = Number(table.getAttribute('aria-colcount'));
                }
                else if (pasteModelArgs.selection === 'Row') {
                    pasteModelArgs.usedColIndex = Number(table.getAttribute('aria-colcount'));
                }
                else {
                    pasteModelArgs.usedRowIndex = Number(table.getAttribute('aria-rowcount'));
                }
            }
        }
        const tableStyles = [];
        if (!isNullOrUndefined(table)) {
            if (!isNullOrUndefined(table.getAttribute('style'))) {
                tableStyles.push(table.getAttribute('style'));
                this.generateStyles(tableStyles, tableStyleObj);
            }
        }
        const getStyle = this.cellStyle(ele, isSpreadsheet);
        let tr;
        let cells;
        let cellStyle;
        let td;
        let cellCount = 1;
        let colLen;
        let formatStr;
        let curColIdx;
        pasteModelArgs.colCount = 1;
        const rowStyles = [];
        for (let rowIdx = 0, rowLen = pasteModelArgs.usedRowIndex; rowIdx <= rowLen; rowIdx++) {
            tr = table.rows[rowIdx];
            if (!isNullOrUndefined(tr.getAttribute('style'))) {
                rowStyles.push(tr.getAttribute('style'));
                this.generateStyles(rowStyles, rowStyleObj);
            }
            if (!rows[rowIdx]) {
                rows[rowIdx] = { cells: [] };
            }
            cells = rows[rowIdx].cells;
            pasteModelArgs.colCount = Math.max(pasteModelArgs.colCount, tr.cells.length);
            colLen = pasteModelArgs.usedColIndex < tr.cells.length ? pasteModelArgs.usedColIndex : tr.cells.length - 1;
            for (let colIdx = 0; colIdx <= colLen; colIdx++) {
                td = tr.cells[colIdx];
                curColIdx = colIdx;
                if (cells[colIdx]) {
                    colIdx = this.getNewIndex(cells, colIdx);
                }
                cells[colIdx] = {};
                cellStyle = getStyle(td, rowStyleObj, tableStyleObj);
                td.textContent = td.textContent.replace(/(\r\n|\n|\r)/gm, '');
                td.textContent = td.textContent.replace(/\s+/g, ' ');
                if (cellStyle.whiteSpace &&
                    cellStyle.whiteSpace !== 'nowrap') {
                    cells[colIdx].wrap = true;
                    delete cellStyle['whiteSpace'];
                }
                if (Object.keys(cellStyle).length) {
                    if (cellStyle.border) {
                        ['borderBottom', 'borderTop', 'borderLeft', 'borderRight'].forEach((prop) => {
                            cellStyle[`${prop}`] = cellStyle.border;
                        });
                        delete cellStyle.border;
                    }
                    cells[colIdx].style = cellStyle;
                }
                if (td.textContent) {
                    cells[colIdx].value = parseIntValue(td.textContent.trim(), true, true);
                }
                formatStr = isSpreadsheet ? 'num-format' : 'number-format';
                if (td.getAttribute(formatStr)) {
                    cells[colIdx].format = td.getAttribute(formatStr);
                    if (cells[colIdx].value && td.getAttribute('cell-value')) {
                        cells[colIdx].value = parseIntValue(td.getAttribute('cell-value').trim(), true, true);
                    }
                }
                if (td.getAttribute('colspan') && parseInt(td.getAttribute('colspan'), 10) > 1) {
                    cells[colIdx].colSpan = parseInt(td.getAttribute('colspan'), 10);
                }
                if (td.getAttribute('rowspan') && parseInt(td.getAttribute('rowspan'), 10) > 1) {
                    cells[colIdx].rowSpan = parseInt(td.getAttribute('rowspan'), 10);
                }
                if (cells[colIdx].colSpan > 1 && cells[colIdx].rowSpan > 1) {
                    let cell;
                    for (let k = rowIdx, len = rowIdx + cells[colIdx].rowSpan; k < len; k++) {
                        for (let l = colIdx, len = colIdx + cells[colIdx].colSpan; l < len; l++) {
                            if (k === rowIdx && l === colIdx) {
                                continue;
                            }
                            cell = cells[colIdx].style ? { style: extend({}, cells[colIdx].style) } : {};
                            if (k !== rowIdx) {
                                cell.rowSpan = rowIdx - k;
                            }
                            if (l !== colIdx) {
                                cell.colSpan = colIdx - l;
                            }
                            if (!rows[k]) {
                                rows[k] = { cells: [] };
                            }
                            rows[k].cells[l] = cell;
                        }
                    }
                }
                else if (cells[colIdx].colSpan > 1) {
                    for (let k = colIdx + 1, len = colIdx + cells[colIdx].colSpan; k < len; k++) {
                        cells[k] = { colSpan: colIdx - k, style: extend({}, cellStyle) };
                    }
                }
                else if (cells[colIdx].rowSpan > 1) {
                    for (let k = rowIdx + 1, len = rowIdx + cells[colIdx].rowSpan; k < len; k++) {
                        if (!rows[k]) {
                            rows[k] = { cells: [] };
                        }
                        rows[k].cells[colIdx] = { rowSpan: rowIdx - k, style: extend({}, cellStyle) };
                    }
                }
                colIdx = curColIdx;
            }
            cellCount = Math.max(cellCount, cells.length);
        }
        pasteModelArgs.usedColIndex = cellCount - 1;
    }
    getNewIndex(cells, index) {
        if (cells[index]) {
            index++;
            index = this.getNewIndex(cells, index);
        }
        return index;
    }
    cellStyle(ele, isSpreadsheet) {
        let eleStyle;
        let commonStyle;
        if (!isSpreadsheet) {
            eleStyle = ele.querySelector('style') && ele.querySelector('style').innerHTML;
            const keys = Object.keys(this.parent.commonCellStyle);
            if (keys && keys.length && eleStyle) {
                let tdStyle = eleStyle.includes('td') ? eleStyle.split('td')[1] : eleStyle;
                tdStyle = tdStyle.includes('{') ? tdStyle.split('{')[1].split('}')[0] : tdStyle.split('}')[0];
                commonStyle = {};
                for (let i = 0; i < keys.length; i++) {
                    let key = keys[i];
                    const regex = key.match(/[A-Z]/);
                    if (regex) {
                        key = key.replace(regex[0], '-' + regex[0].toLowerCase());
                    }
                    if (tdStyle.indexOf(key) > -1) {
                        commonStyle[keys[i]] = tdStyle.split(key + ':')[1].split(';')[0].trim();
                    }
                }
            }
        }
        return (td, rowStyleObj, tableStyleObj) => {
            const cellStyle = {};
            let styles;
            if (isSpreadsheet) {
                if (td.getAttribute('style')) {
                    styles = td.getAttribute('style').split(';');
                }
                else {
                    return cellStyle;
                }
            }
            else {
                styles = [];
                if (eleStyle && td.className && eleStyle.includes(td.classList[0])) {
                    const styleTagCSS = eleStyle.split(td.classList[0]);
                    styles.push(styleTagCSS[styleTagCSS.length - 1].split('{')[1].split('}')[0]);
                }
                const nodeList = [].slice.call(td.querySelectorAll('*'));
                nodeList.unshift(td);
                nodeList.forEach((node) => {
                    if (node.getAttribute('style')) {
                        styles.push(node.getAttribute('style'));
                    }
                    if (node.tagName === 'B') {
                        styles.push('font-weight:bold');
                    }
                    if (node.tagName === 'I') {
                        styles.push('font-style:italic');
                    }
                    if (node.tagName === 'U') {
                        styles.push('text-decoration:underline');
                    }
                });
                Object.assign(cellStyle, tableStyleObj, rowStyleObj, commonStyle);
            }
            if (styles.length) {
                this.generateStyles(styles, cellStyle);
            }
            if (td.querySelector('S')) {
                cellStyle.textDecoration = cellStyle.textDecoration ? 'underline line-through' : 'line-through';
            }
            if (cellStyle.textDecoration &&
                ['underline', 'line-through', 'underline line-through', 'none'].indexOf(cellStyle.textDecoration) === -1) {
                cellStyle.textDecoration = 'none';
            }
            if (cellStyle.textAlign && ['left', 'center', 'right'].indexOf(cellStyle.textAlign) === -1) {
                cellStyle.textAlign = 'left';
            }
            if (cellStyle.verticalAlign && ['bottom', 'middle', 'top'].indexOf(cellStyle.verticalAlign) === -1) {
                cellStyle.verticalAlign = 'bottom';
            }
            if (cellStyle.fontSize) {
                cellStyle.fontSize = Math.round(parseFloat((cellStyle.fontSize.indexOf('px') > -1) ? (parseFloat(cellStyle.fontSize) * 0.75).toString() :
                    ((cellStyle.fontSize.indexOf('em') > -1) ? (parseFloat(cellStyle.fontSize) * 16 / 1.3333).toString() : cellStyle.fontSize))) + 'pt';
            }
            if (cellStyle.fontWeight && ['bold', 'normal'].indexOf(cellStyle.fontWeight) === -1) {
                cellStyle.fontWeight = cellStyle.fontWeight > '599' ? 'bold' : 'normal';
            }
            return cellStyle;
        };
    }
    generateStyles(styles, styleObj) {
        let index;
        let value;
        let splitValue;
        let splitBorder;
        let borderSize;
        // `styleAttr` holds the `CSS` property and `styleValue` holds its corresponding `JS` property in same order, common for border.
        const styleAttr = ['font-family', 'vertical-align', 'text-align', 'text-indent', 'color', 'white-space',
            'font-weight', 'font-style', 'font-size', 'text-decoration', 'background', 'background-color'];
        const styleValue = ['fontFamily', 'verticalAlign', 'textAlign', 'textIndent', 'color', 'whiteSpace', 'fontWeight',
            'fontStyle', 'fontSize', 'textDecoration', 'backgroundColor', 'backgroundColor'];
        const borderAttr = ['border-bottom', 'border-top', 'border-right', 'border-left', 'border'];
        const borderValue = ['borderBottom', 'borderTop', 'borderRight', 'borderLeft', 'border'];
        if (styles && styles.length) {
            styles.forEach((styles) => {
                styles.split(';').forEach((style) => {
                    value = style.split(':')[0].trim();
                    index = styleAttr.indexOf(value);
                    if (index > -1) {
                        value = style.split(':')[1].trim();
                        styleObj[styleValue[index]] = value;
                    }
                    else {
                        index = borderAttr.indexOf(value);
                        if (index > -1) {
                            value = style.split(':')[1].trim();
                            if (value === 'none') {
                                value = undefined;
                            }
                            else if (value.includes('pt')) {
                                splitValue = value.split('pt');
                                splitBorder = splitValue[0].split(' ');
                                for (let i = 0; i < splitBorder.length; i++) {
                                    borderSize = parseFloat(splitBorder[i]);
                                    if (borderSize) {
                                        splitBorder.splice(i, 1);
                                        splitBorder.unshift((borderSize / 0.75).toFixed(2) + 'px');
                                        splitValue[0] = splitBorder.join(' ');
                                        break;
                                    }
                                }
                                value = splitValue.join('');
                            }
                            styleObj[borderValue[index]] = value;
                        }
                    }
                });
            });
        }
    }
    refreshOnInsertDelete(args) {
        if (this.copiedInfo) {
            if (args.model.id !== this.copiedInfo.sId) {
                return;
            }
            const range = this.copiedInfo.range;
            if (args.isInsert) {
                if (args.modelType === 'Column') {
                    if (args.start <= range[3]) {
                        if (args.start <= range[1]) {
                            const len = args.end - args.start + 1;
                            range[1] += len;
                            range[3] += len;
                        }
                        else {
                            range[3] = range[1] + (args.start - range[1] - 1);
                        }
                        this.performAction();
                    }
                }
                else {
                    if (args.start <= range[2]) {
                        if (args.start <= range[0]) {
                            const len = args.end - args.start + 1;
                            range[0] += len;
                            range[2] += len;
                        }
                        else {
                            range[2] = range[1] + (args.start - range[1] - 1);
                        }
                        this.performAction();
                    }
                }
            }
            else {
                this.clearCopiedInfo();
            }
        }
    }
    performAction() {
        const copyIndicator = this.getCopyIndicator();
        if (copyIndicator) {
            setPosition(this.parent, copyIndicator, this.copiedInfo.range, 'e-copy-indicator');
        }
    }
    getClipboardEle() {
        return this.parent.element.getElementsByClassName('e-clipboard')[0];
    }
    getCopyIndicator() {
        return this.parent.element.getElementsByClassName('e-copy-indicator')[0];
    }
    getModuleName() {
        return 'clipboard';
    }
    destroy() {
        this.removeEventListener();
        const ele = this.getClipboardEle();
        detach(ele);
        this.parent = null;
    }
}

/**
 * The `Protect-Sheet` module is used to handle the Protecting functionalities in Spreadsheet.
 */
class Edit {
    /**
     * Constructor for edit module in Spreadsheet.
     *
     * @param {Spreadsheet} parent - Constructor for edit module in Spreadsheet.
     * @private
     */
    constructor(parent) {
        this.editorElem = null;
        this.editCellData = {};
        this.isEdit = false;
        this.isCellEdit = true;
        this.isNewValueEdit = true;
        this.isAltEnter = false;
        this.curEndPos = null;
        this.curStartPos = null;
        this.uniqueColl = '';
        this.uniqueActCell = '';
        this.isSpill = false;
        this.keyCodes = {
            BACKSPACE: 8,
            SPACE: 32,
            TAB: 9,
            DELETE: 46,
            ESC: 27,
            ENTER: 13,
            FIRSTALPHABET: 65,
            LASTALPHABET: 90,
            FIRSTNUMBER: 48,
            LASTNUMBER: 59,
            FIRSTNUMPAD: 96,
            LASTNUMPAD: 111,
            SYMBOLSETONESTART: 186,
            SYMBOLSETONEEND: 192,
            SYMBOLSETTWOSTART: 219,
            SYMBOLSETTWOEND: 222,
            FIREFOXEQUALPLUS: 61,
            FIREFOXMINUS: 173,
            F2: 113
        };
        this.formulaErrorStrings = [
            'mismatched parentheses',
            'requires 3 arguments',
            'improper formula',
            'empty expression',
            'mismatched string quotes',
            'wrong number of arguments',
            'invalid arguments'
        ];
        this.parent = parent;
        this.addEventListener();
        //Spreadsheet.Inject(WorkbookEdit);
    }
    /**
     * To destroy the edit module.
     *
     * @returns {void} - To destroy the edit module.
     * @hidden
     */
    destroy() {
        if (this.isEdit) {
            this.cancelEdit(true, false);
        }
        this.removeEventListener();
        this.editorElem = null;
        if (this.formulaErrorStrings) {
            this.formulaErrorStrings = [];
        }
        if (this.editCellData) {
            this.editCellData = {};
        }
        if (this.keyCodes) {
            this.keyCodes = {};
        }
        this.parent = null;
    }
    addEventListener() {
        if (Browser.isDevice && Browser.info.name === 'safari' && (Browser.isIos || Browser.isIos7)) {
            EventHandler.add(this.parent.element, 'touchend', this.tapHandler, this);
        }
        else {
            EventHandler.add(this.parent.element, 'dblclick', this.dblClickHandler, this);
        }
        this.parent.on(mouseDown, this.mouseDownHandler, this);
        this.parent.on(keyUp, this.keyUpHandler, this);
        this.parent.on(keyDown, this.keyDownHandler, this);
        this.parent.on(editOperation, this.performEditOperation, this);
        this.parent.on(initiateCur, this.initiateCurPosition, this);
        this.parent.on(editValue, this.updateFormulaBarValue, this);
        this.parent.on(addressHandle, this.addressHandler, this);
        this.parent.on(initiateEdit, this.initiateRefSelection, this);
        this.parent.on(forRefSelRender, this.refSelectionRender, this);
        this.parent.on(checkUniqueRange, this.checkUniqueRange, this);
        this.parent.on(reApplyFormula, this.reApplyFormula, this);
        this.parent.on(activeSheetChanged, this.sheetChangeHandler, this);
        this.parent.on(readonlyAlert, this.readOnlyAlertHandler, this);
        this.parent.on(finiteAlert, this.finiteAlertHandler, this);
    }
    removeEventListener() {
        if (Browser.isDevice && Browser.info.name === 'safari' && (Browser.isIos || Browser.isIos7)) {
            EventHandler.remove(this.parent.element, 'touchend', this.tapHandler);
        }
        else {
            EventHandler.remove(this.parent.element, 'dblclick', this.dblClickHandler);
        }
        if (!this.parent.isDestroyed) {
            this.parent.off(mouseDown, this.mouseDownHandler);
            this.parent.off(keyUp, this.keyUpHandler);
            this.parent.off(keyDown, this.keyDownHandler);
            this.parent.off(editOperation, this.performEditOperation);
            this.parent.off(initiateCur, this.initiateCurPosition);
            this.parent.off(editValue, this.updateFormulaBarValue);
            this.parent.off(addressHandle, this.addressHandler);
            this.parent.off(initiateEdit, this.initiateRefSelection);
            this.parent.off(forRefSelRender, this.refSelectionRender);
            this.parent.off(checkUniqueRange, this.checkUniqueRange);
            this.parent.off(reApplyFormula, this.reApplyFormula);
            this.parent.off(activeSheetChanged, this.sheetChangeHandler);
            this.parent.off(readonlyAlert, this.readOnlyAlertHandler);
            this.parent.off(finiteAlert, this.finiteAlertHandler);
        }
    }
    /**
     * Get the module name.
     *
     * @returns {string} - Get the module name.
     * @private
     */
    getModuleName() {
        return 'edit';
    }
    performEditOperation(args) {
        const action = args.action;
        switch (action) {
            case 'renderEditor':
                this.renderEditor();
                if (args.initLoad && Browser.isDevice && Browser.info.name === 'safari' && (Browser.isIos || Browser.isIos7)) {
                    const focusEditEle = this.parent.createElement('div', { className: 'e-ss-focus-edit', attrs: { 'contentEditable': 'true', 'inputmode': 'none', 'tabindex': '-1' } });
                    const sheetPanel = this.parent.element.querySelector('.e-sheet-panel');
                    if (sheetPanel) {
                        sheetPanel.style.position = 'relative';
                        sheetPanel.appendChild(focusEditEle);
                    }
                    this.parent.element.onfocus = () => {
                        focus(focusEditEle);
                    };
                }
                break;
            case 'refreshEditor':
                this.refreshEditor(args.value, args.refreshFormulaBar, args.refreshEditorElem, args.isAppend, args.trigEvent);
                if (args.refreshCurPos) {
                    this.setCursorPosition();
                }
                break;
            case 'startEdit':
                if (!this.isEdit) {
                    this.isNewValueEdit = args.isNewValueEdit;
                    this.startEdit(args.address, args.value, args.refreshCurPos);
                }
                else {
                    const isEdit = false;
                    const arg = { isEdit: isEdit };
                    this.parent.notify(isFormulaBarEdit, arg);
                    if (arg.isEdit) {
                        this.isNewValueEdit = args.isNewValueEdit;
                        this.startEdit(args.address, args.value, args.refreshCurPos);
                    }
                }
                break;
            case 'endEdit':
                if (this.isEdit) {
                    this.endEdit(args.refreshFormulaBar, null, args.isPublic);
                }
                break;
            case 'cancelEdit':
                if (this.isEdit) {
                    this.cancelEdit(args.refreshFormulaBar);
                }
                break;
            case 'getCurrentEditValue':
                args.editedValue = this.editCellData.value;
                if (args.endFormulaRef !== undefined) {
                    args.endFormulaRef = this.endFormulaRef;
                }
                break;
            case 'refreshDependentCellValue':
                this.refreshDependentCellValue(args.rowIdx, args.colIdx, args.sheetIdx);
                break;
            case 'getElement':
                args.element = this.getEditElement(this.parent.getActiveSheet());
                break;
            case 'focusEditorElem':
                this.editorElem.focus();
                break;
            case 'getCurrentEditSheetIdx':
                args.sheetIndex = this.editCellData.sheetIndex;
                break;
        }
    }
    keyUpHandler(e) {
        if (this.isEdit) {
            const editElement = this.getEditElement(this.parent.getActiveSheet());
            if (e.altKey && e.keyCode === 13) {
                editElement.focus();
                this.altEnter();
                this.isAltEnter = true;
            }
            else if (this.isCellEdit && this.editCellData.value !== editElement.textContent && e.keyCode !== 16 && (!e.shiftKey ||
                (e.shiftKey && !isNavigationKey(e.keyCode)))) {
                this.refreshEditor(editElement.textContent, this.isCellEdit);
            }
            const isFormulaEdit = checkIsFormula(this.editCellData.value, true);
            if (isFormulaEdit && (!e || (e.keyCode !== 16 && e.keyCode !== 17 && (!e.shiftKey || !isNavigationKey(e.keyCode))))) {
                this.updateFormulaReference(editElement);
                if (this.endFormulaRef) {
                    const curOffset = this.getCurPosition();
                    const validCharacters = ['+', '-', '*', '/', this.parent.listSeparator, '(', '=', '&', ':'];
                    if (curOffset.end && validCharacters.indexOf(this.editCellData.value[curOffset.end - 1]) > -1) {
                        this.endFormulaRef = false;
                    }
                }
            }
        }
    }
    updateFormulaReference(editElement) {
        const formulaRefIndicator = this.parent.element.querySelector('.e-formularef-indicator');
        if (formulaRefIndicator) {
            formulaRefIndicator.parentElement.removeChild(formulaRefIndicator);
        }
        if (this.editCellData.value !== editElement.textContent) {
            this.refreshEditor(editElement.textContent, true);
        }
        const sheetIdx = this.editCellData.sheetIndex;
        const editValue = this.editCellData.value;
        this.parent.notify(initiateFormulaReference, { range: editValue, formulaSheetIdx: sheetIdx });
    }
    keyDownHandler(e) {
        const trgtElem = e.target;
        const keyCode = e.keyCode;
        const sheet = this.parent.getActiveSheet();
        const actCell = getCellIndexes(sheet.activeCell);
        const cell = getCell(actCell[0], actCell[1], sheet, false, true);
        const isKeyboardShortcut = this.parent.enableKeyboardShortcut;
        if (!isKeyboardShortcut && keyCode === this.keyCodes.SPACE && !e.ctrlKey && !e.altKey && !e.metaKey) {
            e.preventDefault();
            return;
        }
        if (!closest(trgtElem, '.e-spreadsheet .e-dialog')) {
            if (!sheet.isProtected || trgtElem.classList.contains('e-sheet-rename') || !isLocked(cell, getColumn(sheet, actCell[1])) || ((trgtElem.classList.contains('e-formula-bar') || trgtElem.classList.contains('e-combobox')) && !trgtElem.disabled)) {
                if (this.isEdit) {
                    const editorElem = this.getEditElement(sheet);
                    const isFormulaEdit = checkIsFormula(this.editCellData.value, true);
                    if (this.isCellEdit || (isFormulaEdit && this.editCellData.value !== editorElem.textContent && e.keyCode !== 16 &&
                        e.keyCode !== 17)) {
                        if (actCell[1] < this.parent.frozenColCount(sheet) && (!sheet.frozenRows || actCell[0] >=
                            this.parent.frozenRowCount(sheet)) && editorElem && editorElem.style.height !== 'auto') {
                            if (getTextWidth(editorElem.textContent, cell.style, this.parent.cellStyle) > parseInt(editorElem.style.maxWidth, 10)) {
                                editorElem.style.height = 'auto';
                            }
                        }
                        if (getTextWidth(editorElem.textContent, cell.style, this.parent.cellStyle) > parseInt(editorElem.style.maxWidth, 10) - 5) { // 5 decreased for padding.
                            editorElem.style.height = 'auto';
                        }
                        if (actCell[0] < this.parent.frozenRowCount(sheet) && editorElem && !editorElem.style.overflow && getTextWidth(editorElem.textContent, cell.style, this.parent.cellStyle) > parseInt(editorElem.style.maxWidth, 10)) {
                            editorElem.style.overflow = 'auto';
                        }
                        if (!e.shiftKey || (e.shiftKey && !isNavigationKey(e.keyCode))) {
                            this.refreshEditor(editorElem.textContent, this.isCellEdit, false, false, false);
                        }
                    }
                    if (!e.altKey) {
                        switch (keyCode) {
                            case this.keyCodes.ENTER:
                                if (Browser.isWindows) {
                                    e.preventDefault();
                                }
                                if (!isFormulaEdit) {
                                    this.endEdit(false, e);
                                }
                                else {
                                    const formulaRefIndicator = this.parent.element.querySelector('.e-formularef-indicator');
                                    if (formulaRefIndicator) {
                                        formulaRefIndicator.parentElement.removeChild(formulaRefIndicator);
                                    }
                                    if (getSheet(this.parent, this.editCellData.sheetIndex).id === sheet.id) {
                                        this.endEdit(false, e);
                                    }
                                    else {
                                        this.parent.goTo(this.editCellData.fullAddr);
                                        this.endEdit(false, e);
                                    }
                                }
                                break;
                            case this.keyCodes.TAB:
                                if (!this.hasFormulaSuggSelected()) {
                                    this.endEdit(false, e);
                                }
                                break;
                            case this.keyCodes.ESC:
                                if (isKeyboardShortcut) {
                                    this.cancelEdit(true, true, e);
                                }
                                break;
                        }
                    }
                }
                else if (trgtElem.classList.contains('e-spreadsheet') || closest(trgtElem, '.e-sheet-panel')) {
                    if (keyCode === 13 && trgtElem.contentEditable === 'true') {
                        e.preventDefault();
                    }
                    const key = String.fromCharCode(keyCode);
                    const isAlphabet = (keyCode >= this.keyCodes.FIRSTALPHABET && keyCode <= this.keyCodes.LASTALPHABET) ||
                        (key.toLowerCase() !== key.toUpperCase() && !(keyCode >= 112 && keyCode <= 123));
                    const isNumeric = (keyCode >= this.keyCodes.FIRSTNUMBER && keyCode <= this.keyCodes.LASTNUMBER);
                    const isNumpadKeys = (keyCode >= this.keyCodes.FIRSTNUMPAD && keyCode <= this.keyCodes.LASTNUMPAD);
                    let isSymbolkeys = (keyCode >= this.keyCodes.SYMBOLSETONESTART &&
                        keyCode <= this.keyCodes.SYMBOLSETONEEND);
                    if (!isSymbolkeys) {
                        isSymbolkeys = (keyCode >= this.keyCodes.SYMBOLSETTWOSTART && keyCode <= this.keyCodes.SYMBOLSETTWOEND);
                    }
                    const isFirefoxExceptionkeys = (keyCode === this.keyCodes.FIREFOXEQUALPLUS) ||
                        (keyCode === this.keyCodes.FIREFOXMINUS);
                    const isF2Edit = (!e.shiftKey && !e.ctrlKey && !e.metaKey && keyCode === this.keyCodes.F2) &&
                        isKeyboardShortcut;
                    const isBackSpace = keyCode === this.keyCodes.BACKSPACE && isKeyboardShortcut;
                    const isMacDelete = /(Macintosh|MacIntel|MacPPC|Mac68K|Mac|Mac OS|iPod|iPad)/i.test(navigator.userAgent) && isBackSpace;
                    const readonlyDialog = this.parent.element.querySelector('.e-readonly-alert-dlg');
                    const overlayElements = this.parent.element.getElementsByClassName('e-ss-overlay-active');
                    if ((!e.ctrlKey && !e.metaKey && !e.altKey && ((!e.shiftKey && keyCode === this.keyCodes.SPACE) || isAlphabet || isNumeric ||
                        isNumpadKeys || isSymbolkeys || (Browser.info.name === 'mozilla' && isFirefoxExceptionkeys))) || isF2Edit || isBackSpace) {
                        if (isF2Edit) {
                            this.isNewValueEdit = false;
                        }
                        if (!readonlyDialog) {
                            if (isReadOnlyCells(this.parent) && overlayElements.length === 0) {
                                this.parent.notify(readonlyAlert, null);
                            }
                            else if (overlayElements.length) {
                                if (isBackSpace && !isMacDelete) {
                                    this.editingHandler('delete');
                                }
                            }
                            else {
                                this.startEdit(null, null, true, true);
                                focus(this.getEditElement(sheet));
                            }
                        }
                    }
                    if ((keyCode === this.keyCodes.DELETE || isMacDelete) && isKeyboardShortcut) {
                        const islockcell = sheet.isProtected && isLockedCells(this.parent);
                        if (!readonlyDialog) {
                            if (islockcell) {
                                this.parent.notify(editAlert, null);
                            }
                            else if (isReadOnlyCells(this.parent) && overlayElements.length === 0) {
                                this.parent.notify(readonlyAlert, null);
                            }
                            else {
                                this.editingHandler('delete');
                                this.parent.notify(activeCellChanged, null);
                            }
                        }
                    }
                }
            }
            else if (((keyCode >= this.keyCodes.FIRSTALPHABET && keyCode <= this.keyCodes.LASTALPHABET) ||
                (keyCode >= this.keyCodes.FIRSTNUMBER && keyCode <= this.keyCodes.LASTNUMBER)
                || (keyCode === this.keyCodes.DELETE) || (keyCode === this.keyCodes.BACKSPACE) || (keyCode === this.keyCodes.SPACE)
                || (keyCode >= this.keyCodes.FIRSTNUMPAD && keyCode <= this.keyCodes.LASTNUMPAD) ||
                (keyCode >= this.keyCodes.SYMBOLSETONESTART && keyCode <= this.keyCodes.SYMBOLSETONEEND)
                || (keyCode >= 219 && keyCode <= 222) || (!e.shiftKey && !e.ctrlKey && !e.metaKey && keyCode === this.keyCodes.F2))
                && (keyCode !== 67) && (keyCode !== 89) && (keyCode !== 90)) {
                if (sheet.protectSettings.insertLink && keyCode === 75) {
                    return;
                }
                if (e.altKey && (keyCode === 65 || keyCode === 70 || keyCode === 72 || keyCode === 77
                    || keyCode === 78 || keyCode === 87)) {
                    return;
                }
                if (!e.ctrlKey && e.keyCode !== 70 && !this.parent.element.querySelector('.e-editAlert-dlg') &&
                    !trgtElem.parentElement.classList.contains('e-unprotectpwd-content') &&
                    !trgtElem.parentElement.classList.contains('e-password-content') &&
                    !trgtElem.parentElement.classList.contains('e-sheet-password-content') &&
                    !trgtElem.parentElement.classList.contains('e-unprotectsheetpwd-content') &&
                    !trgtElem.parentElement.classList.contains('e-reenterpwd-content')) {
                    this.parent.notify(editAlert, null);
                }
            }
        }
    }
    renderEditor() {
        if (!this.editorElem || !select('#' + this.parent.element.id + '_edit', this.parent.element)) {
            const editor = this.parent.createElement('div', { id: this.parent.element.id + '_edit', className: 'e-spreadsheet-edit', attrs: { 'contentEditable': 'true',
                    'role': 'textbox', 'spellcheck': 'false', 'aria-multiline': 'true' } });
            if (this.parent.element.getElementsByClassName('e-spreadsheet-edit')[0]) {
                this.parent.element.getElementsByClassName('e-spreadsheet-edit')[0].remove();
            }
            const sheetContentElem = this.parent.element.querySelector('.e-sheet-content');
            if (!sheetContentElem) {
                return;
            }
            sheetContentElem.appendChild(editor);
            this.editorElem = editor;
        }
        this.parent.notify(formulaOperation, { action: 'renderAutoComplete' });
    }
    refreshEditor(value, refreshFormulaBar, refreshEditorElem, isAppend, trigEvent = true, prevCellValue) {
        if (isAppend) {
            value = this.editCellData.value = this.editCellData.value + value;
        }
        else {
            this.editCellData.value = prevCellValue ? prevCellValue : value;
        }
        const editorElem = this.getEditElement(this.parent.getActiveSheet());
        if (refreshEditorElem && editorElem) {
            editorElem.textContent = value;
        }
        if (refreshFormulaBar) {
            this.parent.notify(formulaBarOperation, { action: 'refreshFormulabar', value: value });
        }
        if (this.parent.isEdit && editorElem && trigEvent && this.editCellData.value === editorElem.textContent) {
            if (this.triggerEvent('cellEditing').cancel) {
                this.cancelEdit(false, false, null, true);
            }
        }
        // if (this.editorElem.scrollHeight + 2 <= this.editCellData.element.offsetHeight) {
        //     this.editorElem.style.height = (this.editCellData.element.offsetHeight + 1) + 'px';
        // } else {
        //     this.editorElem.style.removeProperty('height');
        // }
    }
    startEdit(address, value, refreshCurPos = true, preventFormulaReference) {
        if (this.parent.showSheetTabs) {
            this.parent.element.querySelector('.e-add-sheet-tab').setAttribute('disabled', 'true');
        }
        const sheet = this.parent.getActiveSheet();
        const range = getCellIndexes(sheet.activeCell);
        const cell = getCell(range[0], range[1], sheet, false, true);
        if (this.parent.calculationMode === 'Manual' && checkIsFormula(cell.formula)) {
            this.editCellData.prevFormulaValue = cell.value;
        }
        if (hasTemplate(this.parent, range[0], range[1], this.parent.activeSheetIndex)) {
            const cellEle = this.parent.getCell(range[0], range[1]);
            let isDelTemplate = false;
            const value = cellEle.innerHTML;
            if (cellEle) {
                if (value.indexOf('<') > -1 && value.indexOf('>') > -1 && value.indexOf('input') > -1) {
                    isDelTemplate = true;
                }
            }
            if (isDelTemplate) {
                return;
            }
        }
        const isMergedHiddenCell = this.updateEditCellDetail(address, value);
        this.initiateEditor(refreshCurPos, isMergedHiddenCell);
        this.positionEditor();
        this.parent.isEdit = this.isEdit = true;
        this.parent.notify(clearCopy, null);
        this.parent.notify(enableToolbarItems, [{ enable: false }]);
        if (cell.formula && !preventFormulaReference) {
            this.parent.notify(initiateFormulaReference, { range: cell.formula, formulaSheetIdx: this.editCellData.sheetIndex });
        }
    }
    setCursorPosition() {
        const elem = this.getEditElement(this.parent.getActiveSheet());
        const textLen = elem.textContent.length;
        if (textLen) {
            const selection = document.getSelection();
            const range = document.createRange();
            range.setStart(elem.firstChild, textLen);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
        }
        elem.focus();
    }
    hasFormulaSuggSelected() {
        const suggDdlElem = document.getElementById(this.parent.element.id + '_ac_popup');
        return suggDdlElem && suggDdlElem.style.visibility === 'visible' &&
            suggDdlElem.querySelectorAll('.e-item-focus').length > 0;
    }
    editingHandler(action) {
        const pictureElements = document.getElementsByClassName('e-ss-overlay-active');
        const pictureLen = pictureElements.length;
        let isSpill;
        switch (action) {
            case 'delete':
                if (pictureLen > 0) {
                    if (pictureElements[0].classList.contains('e-datavisualization-chart')) {
                        this.parent.notify(deleteChart, {
                            id: pictureElements[0].id, sheetIdx: this.parent.activeSheetIndex + 1
                        });
                    }
                    else {
                        this.parent.notify(deleteImage, {
                            id: pictureElements[0].id, sheetIdx: this.parent.activeSheetIndex + 1
                        });
                    }
                }
                else {
                    const sheet = this.parent.getActiveSheet();
                    let address = sheet.selectedRange;
                    let range = getIndexesFromAddress(address);
                    range = range[0] > range[2] || range[1] > range[3] ? getSwapRange(range) : range;
                    address = getRangeAddress(range);
                    const cellDeleteArgs = { address: sheet.name + '!' + address, cancel: false };
                    this.parent.notify(beginAction, { action: 'cellDelete', eventArgs: cellDeleteArgs });
                    if (cellDeleteArgs.cancel) {
                        return;
                    }
                    address = getRangeFromAddress(cellDeleteArgs.address);
                    range = getRangeIndexes(address);
                    clearRange(this.parent, range, this.parent.activeSheetIndex);
                    this.parent.notify(selectionComplete, {});
                    if (range[0] === 0 && range[1] === 0 && range[2] >= sheet.usedRange.rowIndex && range[3] >= sheet.usedRange.colIndex) {
                        this.parent.setUsedRange(0, 0, sheet, false, true);
                    }
                    const args = { cellIdx: range, isUnique: false };
                    this.checkUniqueRange(args);
                    if (args.isUnique) {
                        const indexes = getRangeIndexes(this.uniqueColl);
                        const cell = getCell(indexes[0], indexes[1], this.parent.getActiveSheet());
                        if (cell && cell.value) {
                            isSpill = cell.value.toString().indexOf('#SPILL!') > -1;
                        }
                    }
                    if (args.isUnique && this.uniqueColl.split(':')[0] === address.split(':')[0]) {
                        const index = getRangeIndexes(this.uniqueColl);
                        for (let i = index[0]; i <= index[2]; i++) {
                            for (let j = index[1]; j <= index[3]; j++) {
                                this.parent.updateCellInfo({ value: '', formula: '' }, getRangeAddress([i, j]), true);
                            }
                        }
                        this.parent.notify(removeUniquecol, null);
                        this.uniqueColl = '';
                    }
                    else if (args.isUnique) {
                        const uniqueRange = getRangeIndexes(this.uniqueColl);
                        if (getCell(uniqueRange[0], uniqueRange[1], sheet).value === '#SPILL!') {
                            let skip = false;
                            for (let j = uniqueRange[0]; j <= uniqueRange[2]; j++) {
                                for (let k = uniqueRange[1]; k <= uniqueRange[3]; k++) {
                                    const cell = getCell(j, k, sheet);
                                    if (j === uniqueRange[0] && k === uniqueRange[1]) {
                                        skip = false;
                                    }
                                    else if (cell && !isNullOrUndefined(cell.value) && cell.value !== '') {
                                        skip = true;
                                    }
                                }
                            }
                            if (!skip) {
                                this.reApplyFormula();
                            }
                        }
                    }
                    if (args.isUnique) {
                        this.parent.notify(completeAction, { action: 'cellDelete',
                            eventArgs: { address: sheet.name + '!' + address, isSpill: isSpill } });
                    }
                    else {
                        this.parent.notify(completeAction, { action: 'cellDelete', eventArgs: { address: sheet.name + '!' + address } });
                    }
                }
                break;
        }
    }
    getCurPosition() {
        const cursorOffset = {};
        const selection = window.getSelection();
        if (selection && selection.focusNode && selection.focusNode.classList &&
            selection.focusNode.classList.contains('e-formula-bar-panel')) {
            const formulaBar = selection.focusNode.getElementsByClassName('e-formula-bar e-css')[0];
            if (formulaBar.value === this.editCellData.value) {
                cursorOffset.start = formulaBar.selectionStart;
                cursorOffset.end = formulaBar.selectionEnd;
            }
        }
        else if (this.getEditElement(this.parent.getActiveSheet()).textContent === this.editCellData.value) {
            cursorOffset.start = selection.anchorOffset;
            cursorOffset.end = selection.focusOffset;
            if (cursorOffset.start > cursorOffset.end) {
                const x = cursorOffset.start;
                cursorOffset.start = cursorOffset.end;
                cursorOffset.end = x;
            }
        }
        return cursorOffset;
    }
    mouseDownHandler(e) {
        if (!closest(e.target, '.e-findtool-dlg') && !closest(e.target, '.e-validation-error-dlg')) {
            if (this.isEdit) {
                const curOffset = this.getCurPosition();
                let selectionStart;
                let selectionEnd;
                if (curOffset.start) {
                    this.curStartPos = selectionStart = curOffset.start;
                }
                if (curOffset.end) {
                    this.curEndPos = selectionEnd = curOffset.end;
                }
                const trgtElem = e.target;
                const sheet = this.parent.getActiveSheet();
                const formulaRefIndicator = this.parent.element.querySelector('.e-formularef-indicator');
                this.isCellEdit = trgtElem.classList.contains('e-spreadsheet-edit');
                let isFormula = checkIsFormula(this.editCellData.value, true);
                const editorElem = this.getEditElement(sheet);
                const validCharacters = ['+', '-', '*', '/', this.parent.listSeparator, '(', '=', '&', ':'];
                if (trgtElem.classList.contains('e-cell') || trgtElem.classList.contains('e-header-cell') ||
                    trgtElem.classList.contains('e-selectall') || closest(trgtElem, '.e-toolbar-item.e-active') || closest(trgtElem, '.e-table')) {
                    if (!isFormula || this.endFormulaRef) {
                        this.endFormulaRef = false;
                        this.endEdit(false, e);
                    }
                    else {
                        const actCellIdx = getCellIndexes(sheet.activeCell);
                        const cell = getCell(actCellIdx[0], actCellIdx[1], sheet);
                        const editorValue = document.activeElement.classList.contains('e-formula-bar') ?
                            document.activeElement.value : editorElem.textContent;
                        if (this.editCellData.value === editorValue) {
                            if (selectionStart === selectionEnd) {
                                if (this.editCellData.sheetIndex !== getSheetIndex(this.parent, sheet.name)) {
                                    if (validCharacters.indexOf(editorValue.substring(selectionStart - 1, selectionStart)) === -1) {
                                        if (formulaRefIndicator) {
                                            formulaRefIndicator.parentElement.removeChild(formulaRefIndicator);
                                        }
                                        this.parent.goTo(this.editCellData.fullAddr);
                                        this.endEdit(false, e);
                                        return;
                                    }
                                }
                                else if (validCharacters.indexOf(editorElem.textContent.substring(selectionStart - 1, selectionStart)) === -1) {
                                    if (formulaRefIndicator) {
                                        formulaRefIndicator.parentElement.removeChild(formulaRefIndicator);
                                    }
                                    this.endEdit(false, e);
                                    return;
                                }
                            }
                            else if (validCharacters.indexOf(editorValue.substring(selectionStart - 1, selectionStart)) !== -1 &&
                                isCellReference(editorValue.substring(selectionStart, selectionEnd)) &&
                                editorValue.indexOf(':') !== selectionEnd) {
                                this.editCellData.value = editorValue.substring(0, selectionStart) +
                                    editorValue.substring(selectionEnd, editorValue.length);
                            }
                        }
                        if (!cell) {
                            return;
                        }
                        isFormula = cell.formula && (checkIsFormula(cell.formula) || (this.editCellData.value &&
                            this.editCellData.value.toString().indexOf('=') === 0));
                        if (isFormula && this.parent.isEdit) {
                            const curPos = selectionEnd;
                            if (this.editCellData.value.length === curPos) {
                                if (this.editCellData.value.substring(this.editCellData.value.length - 1) === ')' ||
                                    isNumber(this.editCellData.value.substring(this.editCellData.value.length - 1))) {
                                    if (formulaRefIndicator) {
                                        formulaRefIndicator.parentElement.removeChild(formulaRefIndicator);
                                    }
                                    this.endEdit(false, e);
                                }
                            }
                            else if (this.editCellData.value === editorValue &&
                                validCharacters.indexOf(editorValue.substring(curPos - 1, curPos)) === -1) {
                                if (formulaRefIndicator) {
                                    formulaRefIndicator.parentElement.removeChild(formulaRefIndicator);
                                }
                                this.endEdit(false, e);
                            }
                        }
                    }
                }
                else {
                    if (isFormula && this.editCellData.value === editorElem.textContent && editorElem.textContent.indexOf('(') !==
                        editorElem.textContent.length - 1 && !this.isCellEdit && !trgtElem.classList.contains('e-formula-bar') &&
                        validCharacters.indexOf(this.editCellData.value.substring(selectionStart - 1, selectionStart)) === -1) {
                        if (getSheet(this.parent, this.editCellData.sheetIndex).id === sheet.id) {
                            const curPos = window.getSelection().focusOffset;
                            if (validCharacters.indexOf(editorElem.textContent.substring(curPos - 1, curPos)) === -1) {
                                if (formulaRefIndicator) {
                                    formulaRefIndicator.parentElement.removeChild(formulaRefIndicator);
                                }
                                this.parent.goTo(this.editCellData.fullAddr);
                                if (this.isEdit) {
                                    this.endEdit(false, e);
                                }
                                return;
                            }
                        }
                    }
                }
            }
        }
    }
    tapHandler(e) {
        if (!this.tapedTwice) {
            this.tapedTwice = true;
            setTimeout(() => {
                this.tapedTwice = false;
                if (!this.parent.isEdit && e.target.classList.contains('e-cell')) {
                    const focusEditEle = this.parent.element.querySelector('.e-ss-focus-edit');
                    if (focusEditEle) {
                        focus(focusEditEle);
                    }
                }
            }, 300);
            return;
        }
        e.preventDefault();
        this.dblClickHandler(e);
    }
    dblClickHandler(e) {
        const trgt = e.target;
        if (!closest(trgt, '.e-datavisualization-chart') && !trgt.classList.contains('e-ss-overlay') &&
            (trgt.classList.contains('e-active-cell') || trgt.classList.contains('e-cell') || trgt.classList.contains('e-wrap-content') ||
                closest(trgt, '.e-sheet-content') || trgt.classList.contains('e-table'))) {
            const sheet = this.parent.getActiveSheet();
            const actCell = getCellIndexes(sheet.activeCell);
            const cell = getCell(actCell[0], actCell[1], sheet, false, true);
            if (isReadOnly(cell, getColumn(sheet, actCell[1]), getRow(sheet, actCell[0]))) {
                this.parent.notify(readonlyAlert, null);
            }
            else if (!sheet.isProtected || !isLocked(cell, getColumn(sheet, actCell[1]))) {
                if (this.isEdit) {
                    if (!trgt.classList.contains('e-spreadsheet-edit')) {
                        if (checkIsFormula(this.editCellData.value)) {
                            const sheetName = this.editCellData.fullAddr.substring(0, this.editCellData.fullAddr.lastIndexOf('!'));
                            if (this.parent.getActiveSheet().name === sheetName) {
                                this.endEdit();
                            }
                        }
                        else {
                            this.endEdit();
                        }
                    }
                }
                else {
                    this.isNewValueEdit = false;
                    this.startEdit();
                    focus(this.getEditElement(sheet));
                }
            }
            else {
                this.parent.notify(editAlert, null);
            }
        }
    }
    updateEditCellDetail(addr, value) {
        let sheetIdx;
        let sheet;
        let isMergedHiddenCell;
        if (isNullOrUndefined(this.editCellData.sheetIndex)) {
            if (addr && addr.lastIndexOf('!') > -1) {
                sheetIdx = getSheetIndex(this.parent, getSheetNameFromAddress(addr));
            }
            else {
                sheetIdx = this.parent.activeSheetIndex;
            }
        }
        else {
            sheetIdx = this.editCellData.sheetIndex;
        }
        if (!this.editCellData.addr) {
            sheet = getSheet(this.parent, sheetIdx);
            if (addr) {
                addr = getRangeFromAddress(addr);
            }
            else {
                addr = sheet.activeCell;
            }
        }
        else if (checkIsFormula(this.editCellData.value, true)) {
            sheet = getSheet(this.parent, sheetIdx);
            this.isNewValueEdit = false;
        }
        if (addr) {
            const range = getRangeIndexes(addr);
            let rowIdx = range[0];
            let colIdx = range[1];
            const model = getCell(rowIdx, colIdx, sheet, false, true);
            if (model.colSpan > 1 || model.rowSpan > 1) {
                const mergeArgs = { sheet: sheet, cell: model, rowIdx: rowIdx, colIdx: colIdx };
                setVisibleMergeIndex(mergeArgs);
                rowIdx = mergeArgs.rowIdx;
                colIdx = mergeArgs.colIdx;
                isMergedHiddenCell = mergeArgs.isMergedHiddenCell;
            }
            const cellElem = this.parent.getCell(rowIdx, colIdx);
            const cellPosition = getCellPosition(sheet, range, this.parent.frozenRowCount(sheet), this.parent.frozenColCount(sheet), this.parent.viewport.beforeFreezeHeight, this.parent.viewport.beforeFreezeWidth, this.parent.sheetModule.colGroupWidth);
            this.editCellData = {
                addr: addr,
                fullAddr: getSheetName(this.parent, sheetIdx) + '!' + addr,
                rowIndex: rowIdx,
                colIndex: colIdx,
                sheetIndex: sheetIdx,
                element: cellElem,
                value: value || '',
                position: cellPosition,
                prevFormulaValue: this.editCellData.prevFormulaValue
            };
        }
        return isMergedHiddenCell;
    }
    initiateEditor(refreshCurPos, isMergedHiddenCell) {
        getData(this.parent, this.editCellData.fullAddr, false, isMergedHiddenCell).then((values) => {
            if (!this.parent) {
                return;
            }
            values.forEach((cell) => {
                let value;
                const updateEditValue = () => {
                    const args = { cell: cell, value: cell ? cell.value : '',
                        showFormattedText: this.editCellData.showFormattedText };
                    this.parent.notify(getFormattedBarText, args);
                    value = cell ? (cell.formula || args.value) : '';
                    this.editCellData.oldValue = value;
                };
                updateEditValue();
                const evtArgs = this.triggerEvent('cellEdit', null, value);
                if (evtArgs.cancel) {
                    this.cancelEdit(true, false, null, true);
                    return;
                }
                if (evtArgs.showFormattedText) {
                    // For SF-354174 ticket we have provided 'dd/MM/yyyy' support and diplayed the formatted value in the editor which is
                    // not a default behavior. To handle this, we have added this property and it applies only for the 'dd/MM/yyyy' format.
                    this.editCellData.showFormattedText = true;
                    updateEditValue();
                }
                if (this.editCellData.value) {
                    value = this.editCellData.value;
                }
                else {
                    this.editCellData.value = value;
                }
                let prevCellValue;
                if (this.isNewValueEdit) {
                    prevCellValue = value;
                    value = '';
                }
                else {
                    this.isNewValueEdit = true;
                }
                if (isUndefined$1(value)) {
                    value = '';
                }
                this.refreshEditor(value, false, true, false, false, prevCellValue);
                if (refreshCurPos) {
                    this.setCursorPosition();
                }
            });
        });
    }
    positionEditor(isWrap) {
        let tdElem = this.editCellData.element;
        const isEdit = false;
        let cellEle;
        const arg = { isEdit: isEdit };
        this.parent.notify(isFormulaBarEdit, arg);
        if (arg.isEdit && isNullOrUndefined(tdElem)) {
            cellEle = this.parent.getCell(this.editCellData.rowIndex, this.editCellData.colIndex);
            tdElem = cellEle;
            this.editCellData.element = cellEle;
        }
        if (tdElem) {
            tdElem.classList.add('e-ss-edited');
            const sheet = this.parent.getActiveSheet();
            const cell = getCell(this.editCellData.rowIndex, this.editCellData.colIndex, sheet, false, true);
            const left = this.editCellData.position.left + 1;
            const top = this.editCellData.position.top + 1;
            const args = { range: [this.editCellData.rowIndex, this.editCellData.colIndex, this.editCellData.rowIndex,
                    this.editCellData.colIndex] };
            this.parent.notify(activeCellMergedRange, args);
            const minHeight = getRowsHeight(sheet, args.range[0], args.range[2]) - 3;
            const minWidth = getColumnsWidth(sheet, args.range[1], args.range[3]) - 3;
            const cont = this.parent.getMainContent();
            const mainContElement = cont.parentElement;
            let editWidth;
            const frozenCol = this.parent.frozenColCount(sheet);
            let zIndex;
            let preventWrap;
            const frozenRow = this.parent.frozenRowCount(sheet);
            let addWrap;
            if (this.editCellData.colIndex < frozenCol) {
                editWidth = Math.abs(this.parent.getRowHeaderContent().getBoundingClientRect()[this.parent.enableRtl ? 'left' : 'right'] -
                    tdElem.getBoundingClientRect()[this.parent.enableRtl ? 'right' : 'left']) - 1;
                if (this.editCellData.rowIndex < frozenRow) {
                    if (this.parent.getRowHeaderContent().style.zIndex === '2') {
                        zIndex = '3';
                    }
                }
                else {
                    if (getTextWidth(cell.value, cell.style, this.parent.cellStyle) > editWidth) {
                        addWrap = true;
                    }
                }
            }
            else {
                editWidth = (mainContElement.offsetWidth - (left - cont.scrollLeft) - 28) -
                    this.parent.sheetModule.getRowHeaderWidth(sheet);
                const tdEleInf = tdElem.getBoundingClientRect();
                const mainContEleInf = mainContElement.getBoundingClientRect();
                const getCellRight = this.parent.enableRtl ? tdEleInf.left : tdEleInf.right;
                const getMainConEleRight = this.parent.enableRtl ? mainContEleInf.left : mainContEleInf.right;
                const horizontalScrollBar = this.parent.getScrollElement();
                const verticalScrollBarWidth = this.parent.sheetModule.getScrollSize();
                if (this.parent.enableRtl) {
                    if ((getMainConEleRight + verticalScrollBarWidth) > getCellRight) {
                        horizontalScrollBar.scrollLeft -= tdEleInf.width;
                    }
                }
                else {
                    if ((getMainConEleRight - verticalScrollBarWidth) < getCellRight) {
                        horizontalScrollBar.scrollLeft += tdEleInf.width;
                    }
                }
            }
            if (this.editCellData.rowIndex < frozenRow) {
                preventWrap = true;
            }
            const height = !preventWrap && ((cell && cell.wrap) || (tdElem && isWrap) || addWrap) ? 'auto;' : minHeight + 'px;';
            // let editHeight: number = mainContElement.offsetHeight - top - 28;
            let inlineStyles = 'display:block;top:' + top + 'px;' + (this.parent.enableRtl ? 'right:' : 'left:') + left + 'px;' +
                'min-width:' + minWidth + 'px;max-width:' + (cell && cell.wrap ? minWidth : editWidth) + 'px;' +
                'height:' + height + (cell && cell.wrap ? ('width:' + minWidth + 'px;') : '') + 'min-height:' + minHeight + 'px;' +
                (zIndex ? 'z-index: ' + zIndex + ';' : '') + (preventWrap && ((cell && !cell.wrap) || (tdElem && isWrap)) && (getTextWidth(cell.value, cell.style, this.parent.cellStyle) > editWidth || (tdElem && isWrap)) ? 'overflow: auto;' : '');
            const styles = tdElem.style.cssText.split(';');
            styles.forEach((style) => {
                if (!style.includes('border')) {
                    inlineStyles += style + ';';
                }
            });
            const editorElem = this.getEditElement(sheet, true);
            editorElem.style.cssText = inlineStyles;
            if (getTextWidth(editorElem.textContent, cell.style, this.parent.cellStyle) > editWidth) {
                editorElem.style.height = 'auto';
            }
            // we using edit div height as auto , while editing div enlarges and hide active cell bottom border for that
            // we increasing 1px height to active cell.
            const actCell = this.parent.element.querySelector('.e-active-cell');
            if (actCell) {
                actCell.style.height = (minHeight + 4) + 'px';
            }
            if (tdElem.classList.contains('e-right-align')) {
                editorElem.classList.add('e-right-align');
            }
            else if (tdElem.classList.contains('e-center-align')) {
                editorElem.classList.add('e-center-align');
            }
        }
    }
    updateEditedValue(tdRefresh, value, e, isPublic) {
        const oldCellValue = this.editCellData.oldValue;
        if (value) {
            this.editCellData.value = value;
        }
        const newVal = this.editCellData.value;
        /* To set the before cell details for undo redo. */
        this.parent.notify(setActionData, { args: { action: 'beforeCellSave', eventArgs: { address: this.editCellData.addr } } });
        let isValidCellValue = true;
        if (this.parent.allowDataValidation) {
            const sheet = this.parent.getActiveSheet();
            const cellIndex = getRangeIndexes(sheet.activeCell);
            const cell = getCell(cellIndex[0], cellIndex[1], sheet, false, true);
            const column = getColumn(sheet, cellIndex[1]);
            if (cell.validation || checkColumnValidation(column, cellIndex[0], cellIndex[1])) {
                const editedValue = this.editCellData.value || this.getEditElement(sheet).innerText;
                const sheetIdx = this.parent.activeSheetIndex;
                const range = typeof this.editCellData.addr === 'string' ? getRangeIndexes(this.editCellData.addr) :
                    this.editCellData.addr;
                const validEventArgs = { value: editedValue, range, sheetIdx, isEdit: true, td: null, isValid: true };
                const currEditedCell = Object.assign({}, cell, { value: editedValue }); // Update edited value for validation purpose.
                setCell(cellIndex[0], cellIndex[1], sheet, currEditedCell);
                this.parent.notify(isValidation, validEventArgs);
                setCell(cellIndex[0], cellIndex[1], sheet, cell);
                isValidCellValue = validEventArgs.isValid;
                if (isValidCellValue) {
                    if (checkIsFormula(editedValue) || !cell.format) {
                        if (!this.editCellData.value) {
                            this.editCellData.value = editedValue;
                        }
                    }
                    else if (editedValue !== validEventArgs.value || (!this.editCellData.value && validEventArgs.value)) {
                        this.editCellData.value = validEventArgs.value;
                    }
                }
                else {
                    this.isCellEdit = true;
                }
            }
        }
        if (!isPublic && checkIsFormula(this.editCellData.value)) {
            const eventArgs = { formula: this.editCellData.value };
            this.parent.notify(checkFormulaRef, eventArgs);
            if (eventArgs.isInvalid) {
                let isYesBtnClick;
                this.isCellEdit = true;
                isValidCellValue = false;
                const l10n = this.parent.serviceLocator.getService(locale);
                const erroDialogInst = this.parent.serviceLocator.getService(dialog);
                erroDialogInst.show({
                    width: 400, isModal: true, showCloseIcon: true, target: this.parent.element, cssClass: 'e-validation-error-dlg',
                    content: `${l10n.getConstant('CellReferenceTypoError')}<br>${eventArgs.formula}`,
                    beforeOpen: () => this.editCellData.element.focus(),
                    buttons: [{
                            buttonModel: { content: l10n.getConstant('Yes'), isPrimary: true },
                            click: () => {
                                isYesBtnClick = true;
                                erroDialogInst.hide();
                            }
                        },
                        {
                            buttonModel: { content: l10n.getConstant('No') },
                            click: () => erroDialogInst.hide()
                        }],
                    close: () => {
                        if (isYesBtnClick) {
                            value = this.editCellData.value = eventArgs.formula;
                            this.updateCell(oldCellValue, tdRefresh, value, newVal, e);
                            this.parent.notify(formulaBarOperation, { action: 'refreshFormulabar', value: eventArgs.formula });
                        }
                        else {
                            const editorElem = this.getEditElement(this.parent.getActiveSheet());
                            if (editorElem.innerText) {
                                window.getSelection().selectAllChildren(editorElem);
                            }
                        }
                    }
                }, false);
            }
        }
        if (isValidCellValue) {
            this.updateCell(oldCellValue, tdRefresh, value, newVal, e);
        }
        else if (e) {
            e.preventDefault();
        }
    }
    updateCell(oldCellValue, tdRefresh, value, newVal, e) {
        const oldValue = oldCellValue ? oldCellValue.toString().toUpperCase() : '';
        const sheet = this.parent.getActiveSheet();
        if (oldCellValue || oldCellValue === 0) {
            oldCellValue = oldCellValue.toString();
        }
        let curCellValue = this.editCellData.value;
        if (curCellValue) {
            curCellValue = curCellValue.toString();
        }
        const isCellValChanged = oldCellValue !== curCellValue || checkIsFormula(oldValue);
        if (isCellValChanged) {
            if (this.isAltEnter && curCellValue && curCellValue.includes('\n')) {
                wrap(sheet.activeCell, true, this.parent, true);
                this.refreshEditor(curCellValue, this.isCellEdit, false, false, false);
            }
            const cellIndex = getRangeIndexes(sheet.activeCell);
            if (oldCellValue && oldCellValue.indexOf('=UNIQUE(') > -1 && this.editCellData.value === '') {
                this.parent.notify(removeUniquecol, null);
            }
            const args = { cellIdx: cellIndex, isUnique: false };
            this.checkUniqueRange(args);
            const isUniqueRange = args.isUnique;
            if (isUniqueRange && oldCellValue !== '' && this.editCellData.value === '') {
                const rangeIdx = getRangeIndexes(this.uniqueColl);
                if (getCell(rangeIdx[0], rangeIdx[1], sheet).value.toString().indexOf('#SPILL!') === -1) {
                    return;
                }
            }
            if (oldCellValue && oldCellValue.indexOf('UNIQUE') > -1 &&
                this.editCellData.value && this.editCellData.value.toString().indexOf('UNIQUE') > -1 && isUniqueRange) {
                this.updateUniqueRange('');
            }
            const evtArgs = {
                action: 'updateCellValue',
                address: this.editCellData.addr, value: this.editCellData.value, skipCellFormat: this.editCellData.showFormattedText
            };
            this.parent.notify(workbookEditOperation, evtArgs);
            const updatedCell = getCell(cellIndex[0], cellIndex[1], sheet, true);
            let cellValue;
            if (!isNullOrUndefined(updatedCell)) {
                cellValue = updatedCell.value.toString();
            }
            const isCircularRefError = cellValue === '#CIRCULARREF!';
            const isInvalidFormula = this.formulaErrorStrings.indexOf(cellValue) > -1;
            if (isInvalidFormula || isCircularRefError) {
                let isDlgOpenCancel;
                if (e) {
                    const target = e.target;
                    const ribbonCls = ['e-toolbar-item', 'e-tab-wrap', 'e-text-wrap', 'e-tab-text', 'e-caret'];
                    const skipAlertCls = ['e-scroller', 'e-main-panel', 'e-autofill'];
                    if ((!ribbonCls.some((cls) => target.classList.contains(cls)) || !closest(target, '.e-ribbon')) &&
                        !skipAlertCls.some((cls) => target.classList.contains(cls))) {
                        isDlgOpenCancel = this.showFormulaAlertDlg(cellValue, isCircularRefError);
                    }
                    if (!isDlgOpenCancel) {
                        e.preventDefault();
                    }
                }
                if (!isDlgOpenCancel) {
                    delete updatedCell.value;
                    delete updatedCell.formula;
                    this.parent.notify(clearFormulaDependentCells, { cellRef: sheet.activeCell, clearFormulaInfo: true });
                    if (checkIsFormula(oldValue)) {
                        this.parent.updateCellInfo({ formula: oldValue }, sheet.activeCell);
                    }
                    else if (oldCellValue) {
                        this.parent.updateCellInfo({ value: oldCellValue }, sheet.activeCell);
                    }
                    return;
                }
                else {
                    updatedCell.value = '0';
                }
            }
            let indexes;
            if (evtArgs.isFormulaDependent) {
                indexes = getViewportIndexes(this.parent, this.parent.viewport);
            }
            const cell = getCell(cellIndex[0], cellIndex[1], sheet, true);
            const eventArgs = this.getRefreshNodeArgs(cell, this.editCellData.element, this.editCellData.rowIndex, this.editCellData.colIndex);
            this.editCellData.value = eventArgs.value;
            this.parent.notify(refreshChart, { cell: null, rIdx: this.editCellData.rowIndex, cIdx: this.editCellData.colIndex, viewportIndexes: indexes });
            if (cell && cell.formula) {
                this.editCellData.formula = cell.formula;
            }
            if (tdRefresh) {
                this.parent.refreshNode(this.editCellData.element, eventArgs);
            }
            if (cell && cell.hyperlink) {
                this.parent.serviceLocator.getService('cell').refreshRange(cellIndex);
            }
            if (sheet.conditionalFormats && sheet.conditionalFormats.length) {
                this.parent.notify(applyCF, {
                    indexes: [this.editCellData.rowIndex, this.editCellData.colIndex], isAction: true,
                    refreshAll: evtArgs.isFormulaDependent, isEdit: true
                });
            }
            if (cell && cell.wrap) {
                this.parent.notify(wrapEvent, { range: cellIndex, wrap: true, sheet: sheet });
            }
            if (isUniqueRange) {
                const rangeIdx = getRangeIndexes(this.uniqueColl);
                if (getCell(rangeIdx[0], rangeIdx[1], sheet).value.toString().indexOf('#SPILL!') > -1) {
                    this.isSpill = true;
                }
                if ((oldCellValue !== '' && this.editCellData.value === '') ||
                    (this.editCellData.formula && this.editCellData.formula.length > 1 &&
                        oldCellValue !== this.editCellData.formula)) {
                    let skip = false;
                    for (let j = rangeIdx[0]; j <= rangeIdx[2]; j++) {
                        for (let k = rangeIdx[1]; k <= rangeIdx[3]; k++) {
                            const cell = getCell(j, k, sheet);
                            if (j === rangeIdx[0] && k === rangeIdx[1]) {
                                skip = false;
                            }
                            else if (cell && !isNullOrUndefined(cell.value) && cell.value !== '') {
                                skip = true;
                            }
                        }
                    }
                    if (!skip) {
                        this.reApplyFormula();
                    }
                }
                else {
                    this.updateUniqueRange(newVal);
                }
            }
        }
        this.triggerEvent('cellSave', e, value);
        this.resetEditState();
        this.focusElement(e);
    }
    checkUniqueRange(uniquArgs) {
        const args = { range: [] };
        this.parent.notify(getUniqueRange, args);
        const collection = args.range;
        if (!uniquArgs.sheetName) {
            uniquArgs.sheetName = this.parent.getActiveSheet().name;
        }
        for (let i = 0; i < collection.length; i++) {
            if (collection[i].substring(0, collection[i].lastIndexOf('!')) === uniquArgs.sheetName) {
                const rangeIdx = getRangeIndexes(collection[i]);
                for (let j = rangeIdx[0]; j <= rangeIdx[2]; j++) {
                    for (let k = rangeIdx[1]; k <= rangeIdx[3]; k++) {
                        if (uniquArgs.cellIdx[0] === j && uniquArgs.cellIdx[1] === k) {
                            uniquArgs.isUnique = true;
                            this.uniqueCell = true;
                            const uniqueIndex = this.uniqueColl !== '' ? getRangeIndexes(this.uniqueColl) : [0, 0, 0, 0];
                            const collectionIndex = getRangeIndexes(collection[i]);
                            if (uniqueIndex[0] === collectionIndex[0] && uniqueIndex[1] === collectionIndex[1]) {
                                const index = [uniqueIndex[0], collectionIndex[1], uniqueIndex[0], collectionIndex[1]];
                                index[2] = uniqueIndex[2] > collectionIndex[2] ? uniqueIndex[2] : collectionIndex[2];
                                index[3] = uniqueIndex[3] > collectionIndex[3] ? uniqueIndex[3] : collectionIndex[3];
                                this.uniqueColl = getRangeAddress(index);
                                uniquArgs.uniqueRange = getRangeAddress(index);
                            }
                            else {
                                this.uniqueColl = collection[i];
                                uniquArgs.uniqueRange = collection[i];
                            }
                        }
                    }
                }
            }
        }
    }
    updateUniqueRange(value) {
        const rangeIdx = getRangeIndexes(this.uniqueColl);
        let skip = false;
        if (getCell(rangeIdx[0], rangeIdx[1], this.parent.getActiveSheet()).value !== '#SPILL!') {
            skip = true;
        }
        for (let j = rangeIdx[0]; j <= rangeIdx[2]; j++) {
            for (let k = rangeIdx[1]; k <= rangeIdx[3]; k++) {
                if (skip) {
                    if (j === rangeIdx[0] && k === rangeIdx[1]) {
                        this.parent.updateCellInfo({ value: '#SPILL!' }, getRangeAddress([j, k]), true);
                    }
                    else {
                        if (getRangeAddress([j, k]).split(':')[0] === this.editCellData.addr) {
                            this.parent.updateCellInfo({ value: value }, getRangeAddress([j, k]), true);
                        }
                        else {
                            this.parent.updateCellInfo({ value: '' }, getRangeAddress([j, k]), true);
                        }
                    }
                }
            }
        }
    }
    reApplyFormula() {
        const cellIdx = getRangeIndexes(this.uniqueColl);
        const cell = getCell(cellIdx[0], cellIdx[1], this.parent.getActiveSheet());
        this.parent.updateCellInfo({ value: '' }, getRangeAddress([cellIdx[0], cellIdx[1]]), true);
        const sheets = this.parent.sheets;
        let formula = cell.formula;
        for (let i = 0; i < sheets.length; i++) {
            if (formula.indexOf(sheets[i].name) > -1) {
                formula = formula.replace(sheets[i].name, '!' + i);
            }
        }
        this.parent.notify(workbookFormulaOperation, { action: 'computeExpression', formula: formula });
        this.uniqueCell = false;
        if (this.uniqueActCell !== '') {
            this.editCellData.value = this.uniqueActCell;
            this.uniqueActCell = '';
        }
    }
    refreshDependentCellValue(rowIdx, colIdx, sheetIdx) {
        if (rowIdx && colIdx) {
            rowIdx--;
            colIdx--;
            if (((this.editCellData.rowIndex !== rowIdx || this.editCellData.colIndex !== colIdx)
                && this.parent.activeSheetIndex === sheetIdx) || (this.uniqueCell && this.parent.activeSheetIndex === sheetIdx)) {
                const sheet = getSheet(this.parent, sheetIdx);
                let td;
                if (!isHiddenRow(sheet, rowIdx) && !isHiddenCol(sheet, colIdx)) {
                    td = this.parent.getCell(rowIdx, colIdx);
                }
                if (td) {
                    if (td.parentElement) {
                        const curRowIdx = td.parentElement.getAttribute('aria-rowindex');
                        if (curRowIdx && Number(curRowIdx) - 1 !== rowIdx) {
                            return;
                        }
                    }
                    const cell = getCell(rowIdx, colIdx, sheet);
                    const actCell = getRangeIndexes(sheet.activeCell);
                    if (actCell[0] === rowIdx && actCell[1] === colIdx) {
                        this.uniqueActCell = cell.value;
                    }
                    const eventArgs = this.getRefreshNodeArgs(cell, td, rowIdx, colIdx);
                    this.parent.refreshNode(td, eventArgs);
                }
            }
        }
    }
    getRefreshNodeArgs(cell, tdEle, rowIdx, colIdx) {
        cell = cell || {};
        const eventArgs = {
            value: cell.value, format: cell.format,
            formattedText: cell.formattedText && cell.formattedText !== '' ? cell.formattedText : cell.value, isRightAlign: false,
            type: 'General', cell: cell, rowIndex: rowIdx, td: tdEle, colIndex: colIdx, refresh: true, isEdit: true
        };
        this.parent.notify(getFormattedCellObject, eventArgs);
        return eventArgs;
    }
    endEdit(refreshFormulaBar = false, event, isPublic) {
        if (refreshFormulaBar) {
            this.refreshEditor(this.editCellData.oldValue, false, true, false, false);
        }
        const triggerEventArgs = this.triggerEvent('beforeCellSave');
        if (triggerEventArgs.cancel) {
            if (this.parent.isEdit && event) {
                event.preventDefault();
            }
            return;
        }
        if (!this.isAltEnter && triggerEventArgs.value && triggerEventArgs.value.toString().indexOf('\n') > -1) {
            const cell = getCell(this.editCellData.rowIndex, this.editCellData.colIndex, this.parent.getActiveSheet());
            wrap(this.parent.getActiveSheet().activeCell, cell ? (cell.wrap === false ? false : true) :
                true, this.parent);
            this.refreshEditor(triggerEventArgs.value, this.isCellEdit, false, false, false);
        }
        this.updateEditedValue(true, triggerEventArgs.value, event, isPublic);
    }
    cancelEdit(refreshFormulaBar = true, trigEvent = true, event, isInternal) {
        this.refreshEditor(this.editCellData.oldValue, refreshFormulaBar, false, false, false);
        if (!isInternal) {
            if (trigEvent) {
                this.triggerEvent('cellSave', event, undefined, true);
            }
            else {
                this.triggerEvent('cellEdited');
            }
        }
        this.resetEditState();
        this.focusElement();
    }
    focusElement(e) {
        if (e && e.keyCode === 9 && document.activeElement.classList.contains('e-formula-bar')) {
            const focusEle = this.parent.element.querySelector(`.e-formula-bar-panel ${e.shiftKey ? '.e-insert-function' : '.e-combobox'}`);
            if (focusEle) {
                focus(focusEle);
            }
        }
        else {
            focus(this.parent.element);
        }
        this.parent.notify(enableToolbarItems, [{ enable: true }]);
    }
    triggerEvent(eventName, event, value, pvtManualCalc) {
        const sheet = this.parent.getActiveSheet();
        let cell = getCell(this.editCellData.rowIndex, this.editCellData.colIndex, sheet);
        const eventArgs = {
            element: this.editCellData.element,
            value: value ? value : this.editCellData.value,
            oldValue: this.editCellData.oldValue,
            address: this.editCellData.fullAddr,
            displayText: this.parent.getDisplayText(cell),
            previousFormulaValue: this.editCellData.prevFormulaValue
        };
        if (eventArgs.address) {
            const indexes = getRangeIndexes(eventArgs.address);
            const args = { cellIdx: indexes, isUnique: false };
            this.checkUniqueRange(args);
            if (args.isUnique) {
                eventArgs.isSpill = this.isSpill;
            }
        }
        const isValueChanged = (eventArgs.value ? eventArgs.value.toString() : eventArgs.value) !==
            (eventArgs.oldValue || eventArgs.oldValue === 0 ? eventArgs.oldValue.toString() : eventArgs.oldValue);
        if (isValueChanged || (!pvtManualCalc && checkIsFormula(eventArgs.value) && (!cell || !cell.format ||
            getTypeFromFormat(cell.format) !== 'Text'))) {
            if (eventName !== 'cellSave') {
                eventArgs.cancel = false;
            }
            if (eventName === 'beforeCellSave') {
                this.parent.notify(beginAction, { eventArgs: eventArgs, action: 'cellSave', preventAction: true });
                cell = checkIsFormula(eventArgs.value) ? { formula: eventArgs.value } : { value: eventArgs.value };
                const cancel = updateCell(this.parent, sheet, { cell: cell, rowIdx: this.editCellData.rowIndex, colIdx: this.editCellData.colIndex,
                    eventOnly: true });
                if (cancel) {
                    this.cancelEdit(false, false, null, true);
                    eventArgs.cancel = true;
                    return eventArgs;
                }
            }
            this.parent.trigger(eventName, eventArgs);
            if (eventName === 'cellSave') {
                this.parent.trigger('cellEdited', eventArgs);
                if (this.editCellData.formula) {
                    eventArgs.formula = this.editCellData.formula;
                }
                else if (!isValueChanged) {
                    eventArgs.formula = eventArgs.value;
                }
                if (cell.format) {
                    eventArgs.format = cell.format;
                }
                eventArgs.originalEvent = event;
                this.parent.notify(completeAction, { eventArgs: eventArgs, action: 'cellSave' });
            }
        }
        else if (eventName !== 'beforeCellSave') {
            if (eventName === 'cellSave') {
                this.parent.trigger('cellEdited', eventArgs);
            }
            else {
                this.parent.trigger(eventName, eventArgs);
            }
        }
        return eventArgs;
    }
    altEnter() {
        this.positionEditor(true);
        const selection = window.getSelection();
        const node = selection.anchorNode;
        let offset;
        let range = document.createRange();
        offset = (node.nodeType === 3) ? selection.anchorOffset : node.textContent.length;
        if (offset === 0 && node.textContent.length > 0) {
            offset = node.textContent.length;
        }
        const text = node.textContent;
        const textBefore = text.slice(0, offset);
        const textAfter = text.slice(offset) || ' ';
        node.textContent = textBefore + '\n' + textAfter;
        range = document.createRange();
        if (node.nodeType === 3) {
            range.setStart(node, offset + 1);
            range.setEnd(node, offset + 1);
        }
        else if (node.nodeType === 1) {
            range.setStart(node.firstChild, offset + 1);
            range.setEnd(node.firstChild, offset + 1);
        }
        selection.removeAllRanges();
        selection.addRange(range);
    }
    resetEditState(elemRefresh = true) {
        if (elemRefresh) {
            const editorElem = this.getEditElement(this.parent.getActiveSheet());
            if (checkIsFormula(editorElem.textContent) || editorElem.textContent === '') {
                this.parent.notify(clearCellRef, null);
            }
            if (this.editCellData.element) {
                this.editCellData.element.classList.remove('e-ss-edited');
                this.editorElem.textContent = '';
                if (editorElem === this.editorElem) {
                    this.editorElem.removeAttribute('style');
                    this.editorElem.classList.remove('e-right-align');
                }
                else {
                    detach(editorElem);
                }
            }
        }
        this.editCellData = {};
        this.parent.isEdit = this.isEdit = false;
        this.isCellEdit = true;
        this.isAltEnter = false;
        this.parent.notify(formulaOperation, { action: 'endEdit' });
        if (this.parent.showSheetTabs && !this.parent.isProtected) {
            const addSheetBtn = this.parent.element.querySelector('.e-add-sheet-tab');
            if (addSheetBtn) {
                addSheetBtn.removeAttribute('disabled');
            }
        }
    }
    refSelectionRender() {
        const editorElem = this.getEditElement(this.parent.getActiveSheet());
        if (editorElem) {
            if (checkIsFormula(editorElem.textContent)) {
                this.parent.notify(initiateFormulaReference, {
                    range: editorElem.textContent, formulaSheetIdx: this.editCellData.sheetIndex
                });
            }
        }
    }
    // Start edit the formula cell and set cursor position
    initiateRefSelection() {
        const sheetName = this.editCellData.fullAddr.substring(0, this.editCellData.fullAddr.lastIndexOf('!'));
        const value = this.editCellData.value;
        if (this.parent.getActiveSheet().name === sheetName && checkIsFormula(this.editCellData.value, true)) {
            this.startEdit(this.editCellData.addr, value, false);
            this.parent.notify(initiateFormulaReference, {
                range: this.editCellData.value, formulaSheetIdx: this.editCellData.sheetIndex
            });
            this.getEditElement(this.parent.getActiveSheet()).textContent = value;
            this.initiateCurPosition();
        }
        else {
            this.initiateCurPosition();
        }
    }
    addressHandler(args) {
        const dlgInst = this.parent.serviceLocator.getService(dialog).dialogInstance;
        if (dlgInst && dlgInst.element && dlgInst.element.classList.contains('e-validation-error-dlg')) {
            args.isAlertDlgOpen = true;
            return;
        }
        if (!this.curStartPos) {
            const curOffset = this.getCurPosition();
            if (curOffset.start) {
                this.curStartPos = curOffset.start;
            }
            if (curOffset.end) {
                this.curEndPos = curOffset.end;
            }
        }
        let address = args.range;
        let sheetIdx = this.editCellData.sheetIndex;
        const editorEle = this.getEditElement(this.parent.getActiveSheet());
        if (this.parent.activeSheetIndex !== sheetIdx) {
            address = '\'' + this.parent.getActiveSheet().name + '\'' + '!' + address;
            if (args.isNameBoxSelect) {
                sheetIdx = this.parent.activeSheetIndex;
            }
        }
        const editedValue = this.editCellData.value;
        if (args.isSelect) {
            this.parent.notify(initiateFormulaReference, { range: editedValue + address, formulaSheetIdx: sheetIdx });
        }
        else if (this.parent.activeSheetIndex === sheetIdx) {
            const editorContent = document.activeElement.classList.contains('e-formula-bar') ?
                document.activeElement.value : editorEle.textContent;
            if (args.isNameBoxSelect) {
                this.parent.notify(initiateFormulaReference, { range: editedValue + address, formulaSheetIdx: sheetIdx });
                this.curStartPos = editedValue.length;
            }
            let startVal;
            let endVal;
            if (args.isMouseDown && editorContent !== editedValue) {
                startVal = editorContent.substring(0, this.curEndPos) + this.parent.listSeparator;
                endVal = editorContent.substring(this.curEndPos);
                this.refreshEditor(startVal + endVal, false, true);
                this.parent.notify(initiateFormulaReference, { range: editorEle.textContent, formulaSheetIdx: sheetIdx });
                this.curEndPos += this.parent.listSeparator.length;
                this.curStartPos = this.curEndPos;
                startVal += address;
            }
            else {
                startVal = editedValue.substring(0, this.curStartPos) + address;
                endVal = editedValue.substring(this.curStartPos);
                if (args.isNameBoxSelect) {
                    this.refreshEditor(startVal + endVal, true, true);
                }
            }
            editorEle.textContent = startVal + endVal;
            this.curEndPos = startVal.length;
        }
    }
    updateFormulaBarValue(args) {
        const value = this.editCellData.value;
        const lastRange = this.parent.getActiveSheet().selectedRange.split(' ');
        let address = lastRange[lastRange.length - 1];
        address = isSingleCell(getIndexesFromAddress(address)) ? address.split(':')[0] : address;
        const formulaBar = this.parent.element.querySelector('.e-formula-bar');
        if (value && checkIsFormula(value, true)) {
            const sheetName = this.editCellData.fullAddr.substring(0, this.editCellData.fullAddr.lastIndexOf('!'));
            const otherSheet = this.parent.getActiveSheet().name !== sheetName;
            if (otherSheet) {
                address = '\'' + this.parent.getActiveSheet().name + '\'' + '!' + address;
            }
            let startVal;
            let endVal;
            if (otherSheet && args.isMouseDown && lastRange.length > 1 && args.formulaBarVal && args.formulaBarVal !== value) {
                startVal = args.formulaBarVal.substring(0, this.curEndPos) + this.parent.listSeparator;
                endVal = args.formulaBarVal.substring(this.curEndPos);
                this.refreshEditor(startVal + endVal, true);
                this.curEndPos += this.parent.listSeparator.length;
                this.curStartPos = this.curEndPos;
                startVal += address;
            }
            else {
                startVal = value.substring(0, this.curStartPos) + address;
                endVal = value.substring(this.curStartPos);
            }
            formulaBar.value = startVal + endVal;
            this.curEndPos = startVal.length;
        }
    }
    setFormulaBarCurPosition(input, selectionStart, selectionEnd) {
        if (input.setSelectionRange) {
            input.focus();
            input.selectionStart = selectionStart;
            input.selectionEnd = selectionStart;
            input.setSelectionRange(selectionStart, selectionEnd);
        }
    }
    initiateCurPosition(args = { isCellEdit: false }) {
        const el = this.getEditElement(this.parent.getActiveSheet(), true);
        if (args.isCellEdit) {
            const curOffset = this.getCurPosition();
            if (!this.endFormulaRef && curOffset.start === curOffset.end) {
                this.updateFormulaReference(el);
                const validCharacters = ['+', '-', '*', '/', this.parent.listSeparator, '(', '=', '&', ':'];
                if (curOffset.end && validCharacters.indexOf(this.editCellData.value[curOffset.end - 1]) === -1) {
                    this.endFormulaRef = true;
                }
            }
            return;
        }
        const value = el.innerText;
        const selection = window.getSelection();
        if ((selection && selection.focusNode && selection.focusNode.classList &&
            selection.focusNode.classList.contains('e-formula-bar-panel'))) {
            const formulaBar = this.parent.element.querySelector('.e-formula-bar');
            this.setFormulaBarCurPosition(formulaBar, this.curEndPos, this.curEndPos);
            return;
        }
        if (value) {
            const range = document.createRange();
            if (value.indexOf(')') === value.length - 1) {
                range.setStart(el.childNodes[0], this.curEndPos);
                range.setEnd(el.childNodes[0], this.curEndPos);
            }
            else {
                range.setStart(el.childNodes[0], this.curEndPos);
                range.setEnd(el.childNodes[0], this.curEndPos);
            }
            selection.removeAllRanges();
            selection.addRange(range);
        }
        const sheetIdx = this.editCellData.sheetIndex;
        if (sheetIdx !== this.parent.activeSheetIndex) {
            const elem = this.parent.element.querySelector('.e-formula-bar');
            if (elem.value) {
                if (elem.value.indexOf(')') === this.curEndPos - 1) {
                    this.setFormulaBarCurPosition(elem, this.curEndPos - 1, this.curEndPos - 1);
                }
                else {
                    this.setFormulaBarCurPosition(elem, this.curEndPos, this.curEndPos);
                }
            }
        }
    }
    getEditElement(sheet, isEdit) {
        if ((this.isEdit || isEdit) && (sheet.frozenRows || sheet.frozenColumns)) {
            const frozenRow = this.parent.frozenRowCount(sheet);
            const frozenCol = this.parent.frozenColCount(sheet);
            const range = getCellIndexes(sheet.activeCell);
            let content;
            if (range[0] < frozenRow && range[1] < frozenCol) {
                content = this.parent.getSelectAllContent();
            }
            else if (range[0] < frozenRow) {
                content = this.parent.getColumnHeaderContent();
            }
            else if (range[1] < frozenCol) {
                content = this.parent.getRowHeaderContent();
            }
            else {
                return this.editorElem;
            }
            let editEle = content.getElementsByClassName('e-spreadsheet-edit')[0];
            if (!editEle && isEdit) {
                editEle = content.appendChild(this.editorElem.cloneNode());
            }
            return editEle;
        }
        return this.editorElem;
    }
    sheetChangeHandler() {
        if (!this.isEdit) {
            this.editCellData.value = null;
        }
    }
    showFormulaAlertDlg(errorString, triggerBeforeOpenEvt) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const alertDialog = this.parent.serviceLocator.getService('dialog');
        let cursorPosition;
        const errorKey = this.getFormulaErrorKey(errorString);
        let cancel;
        const content = l10n.getConstant(errorKey);
        const dlgInst = alertDialog.dialogInstance;
        if (dlgInst && dlgInst.visible && dlgInst.element.classList.contains('e-circularref-dlg')) {
            return cancel;
        }
        alertDialog.show({
            width: 400, isModal: true, showCloseIcon: true, target: this.parent.element, cssClass: 'e-validation-error-dlg e-circularref-dlg',
            content: content,
            beforeOpen: (args) => {
                if (triggerBeforeOpenEvt) {
                    const sheet = this.parent.getActiveSheet();
                    const dlgArgs = { dialogName: 'CircularReferenceDialog', element: args.element,
                        target: args.target, cancel: args.cancel, cellAddress: `${sheet.name}!${sheet.activeCell}`, content: content };
                    this.parent.trigger('dialogBeforeOpen', dlgArgs);
                    if (dlgArgs.cancel) {
                        args.cancel = cancel = true;
                        return;
                    }
                    else if (dlgArgs.content !== content) {
                        alertDialog.dialogInstance.content = dlgArgs.content;
                        alertDialog.dialogInstance.dataBind();
                    }
                }
                if (window.getSelection().rangeCount > 0) {
                    const range = window.getSelection().getRangeAt(0);
                    cursorPosition = range.endOffset;
                }
            },
            buttons: [{
                    buttonModel: { content: l10n.getConstant('Ok'), isPrimary: true },
                    click: () => alertDialog.hide()
                }],
            close: () => {
                if (!cancel) {
                    const elem = this.getEditElement(this.parent.getActiveSheet());
                    if (elem.childElementCount) {
                        const textContent = elem.textContent;
                        cursorPosition = textContent.length;
                        elem.textContent = textContent;
                    }
                    const selection = document.getSelection();
                    const range = document.createRange();
                    range.setStart(elem.firstChild, cursorPosition);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    elem.focus();
                }
            }
        }, false);
        return cancel;
    }
    getFormulaErrorKey(errorString) {
        let errorKey;
        switch (errorString) {
            case 'invalid arguments':
                errorKey = 'InvalidArguments';
                break;
            case 'improper formula':
                errorKey = 'ImproperFormula';
                break;
            case 'empty expression':
                errorKey = 'EmptyExpression';
                break;
            case 'mismatched parentheses':
                errorKey = 'MismatchedParenthesis';
                break;
            case 'mismatched string quotes':
                errorKey = 'MismatchedStringQuotes';
                break;
            case 'wrong number of arguments':
                errorKey = 'WrongNumberOfArguments';
                break;
            case 'requires 3 arguments':
                errorKey = 'Requires3Arguments';
                break;
            case '#CIRCULARREF!':
                errorKey = 'FormulaCircularRef';
                break;
            default:
                errorKey = 'InvalidFormulaError';
        }
        return errorKey;
    }
    readOnlyAlertHandler() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialog = this.parent.serviceLocator.getService('dialog');
        const findDialog = this.parent.element.querySelector('.e-find-dlg');
        let findDlgInst;
        if (!isNullOrUndefined(findDialog)) {
            findDlgInst = getComponent(findDialog, 'dialog');
        }
        dialog.show({
            content: l10n.getConstant('ReadonlyAlert'),
            isModal: true,
            closeOnEscape: true,
            showCloseIcon: true,
            width: '400px',
            cssClass: 'e-readonly-alert-dlg',
            beforeOpen: (args) => {
                const dlgArgs = {
                    dialogName: 'ReadOnlyAlertDialog',
                    content: l10n.getConstant('ReadonlyAlert'),
                    element: args.element, target: args.target, cancel: args.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    args.cancel = true;
                }
                else {
                    dialog.dialogInstance.content = dlgArgs.content;
                    focus(this.parent.element);
                }
            },
            close: () => {
                if (!isNullOrUndefined(findDialog)) {
                    dialog.dialogInstance = findDlgInst;
                }
                focus(this.parent.element);
            }
        });
    }
    finiteAlertHandler() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialog = this.parent.serviceLocator.getService('dialog');
        dialog.show({
            header: l10n.getConstant('Alert'),
            content: l10n.getConstant('FiniteAlert'),
            isModal: true,
            closeOnEscape: true,
            showCloseIcon: true,
            width: '400px',
            cssClass: 'e-finite-alert-dlg'
        });
    }
}

/**
 * Represents selection support for Spreadsheet.
 */
class Selection {
    /**
     * Constructor for the Spreadsheet selection module.
     *
     * @param {Spreadsheet} parent - Constructor for the Spreadsheet selection module.
     * @private
     */
    constructor(parent) {
        this.invalidOperators = ['%'];
        this.formulaRange = [];
        /** @hidden */
        this.isNoteActiveElement = false;
        this.isNoteTouch = false;
        this.parent = parent;
        this.addEventListener();
        this.mouseMoveEvt = this.mouseMoveHandler.bind(this);
    }
    addEventListener() {
        this.parent.on(contentLoaded, this.init, this);
        this.parent.on(mouseDown, this.mouseDownHandler, this);
        this.parent.on(virtualContentLoaded, this.virtualContentLoadedHandler, this);
        this.parent.on(cellNavigate, this.cellNavigateHandler, this);
        this.parent.on(selectRange, this.selectRange, this);
        this.parent.on(rowHeightChanged, this.rowHeightChanged, this);
        this.parent.on(colWidthChanged, this.colWidthChanged, this);
        this.parent.on(protectSelection, this.protectHandler, this);
        this.parent.on(initiateFormulaReference, this.initiateFormulaSelection, this);
        this.parent.on(clearCellRef, this.clearBorder, this);
        this.parent.on(getRowIdxFromClientY, this.getRowIdxFromClientY, this);
        this.parent.on(getColIdxFromClientX, this.getColIdxFromClientX, this);
        this.parent.on(getChartRowIdxFromClientY, this.getRowIdxFromClientY, this);
        this.parent.on(getChartColIdxFromClientX, this.getColIdxFromClientX, this);
        this.parent.on(focusBorder, this.chartBorderHandler, this);
        this.parent.on(selectionStatus, this.isTouchSelectionStarted, this);
        this.parent.on(rangeSelectionByKeydown, this.selectionByKeydown, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(contentLoaded, this.init);
            this.parent.off(mouseDown, this.mouseDownHandler);
            this.parent.off(virtualContentLoaded, this.virtualContentLoadedHandler);
            this.parent.off(cellNavigate, this.cellNavigateHandler);
            this.parent.off(selectRange, this.selectRange);
            this.parent.off(rowHeightChanged, this.rowHeightChanged);
            this.parent.off(colWidthChanged, this.colWidthChanged);
            this.parent.off(protectSelection, this.protectHandler);
            this.parent.off(initiateFormulaReference, this.initiateFormulaSelection);
            this.parent.off(clearCellRef, this.clearBorder);
            this.parent.off(getRowIdxFromClientY, this.getRowIdxFromClientY);
            this.parent.off(getColIdxFromClientX, this.getColIdxFromClientX);
            this.parent.off(getChartRowIdxFromClientY, this.getRowIdxFromClientY);
            this.parent.off(getChartColIdxFromClientX, this.getColIdxFromClientX);
            this.parent.off(focusBorder, this.chartBorderHandler);
            this.parent.off(selectionStatus, this.isTouchSelectionStarted);
            this.parent.off(rangeSelectionByKeydown, this.selectionByKeydown);
        }
    }
    isTouchSelectionStarted(args) {
        args.touchSelectionStarted = this.touchSelectionStarted;
    }
    selectionByKeydown(args) {
        this.selectRangeByIdx(args.range, args.e, false, false, false, false, undefined, false);
    }
    rowHeightChanged(args) {
        if (!args.threshold) {
            return;
        }
        getUpdateUsingRaf(() => {
            if (!this.parent) {
                return;
            }
            const sheet = this.parent.getActiveSheet();
            let ele = this.getActiveCell();
            if (ele && (sheet.frozenRows || sheet.frozenColumns || sheet.selectedRange.includes(' '))) {
                this.selectRange({ address: sheet.selectedRange, isRowHeightChanged: true });
                return;
            }
            const sRange = getSwapRange(getRangeIndexes(sheet.selectedRange));
            const mergeArgs = { range: sRange, isActiveCell: false, skipChecking: true };
            let isActiveCell;
            if (ele) {
                const rowIdx = getCellIndexes(sheet.activeCell)[0];
                this.parent.notify(mergedRange, mergeArgs);
                if (mergeArgs.isActiveCell) {
                    const cell = getCell(sRange[0], sRange[1], sheet, false, true);
                    isActiveCell = cell.rowSpan > 1 && sRange[0] <= args.rowIdx && sRange[2] >= args.rowIdx;
                }
                if (rowIdx === args.rowIdx || isActiveCell) {
                    ele.style.height = `${parseFloat(ele.style.height) + args.threshold}px`;
                }
                else if (rowIdx > args.rowIdx) {
                    ele.style.top = `${parseFloat(ele.style.top) + args.threshold}px`;
                }
            }
            ele = this.getSelectionElement();
            if (ele) {
                if (isActiveCell || (sRange[0] === sRange[2] && sRange[1] === sRange[3])) {
                    return;
                }
                const rowStart = sRange[0];
                const rowEnd = sRange[2];
                if (rowStart <= args.rowIdx && rowEnd >= args.rowIdx && ele) {
                    ele.style.height = `${parseFloat(ele.style.height) + args.threshold}px`;
                }
                else if (rowStart > args.rowIdx && ele) {
                    ele.style.top = `${parseFloat(ele.style.top) + args.threshold}px`;
                }
            }
        });
    }
    colWidthChanged(args) {
        if (!args.threshold) {
            return;
        }
        getUpdateUsingRaf(() => {
            if (!this.parent) {
                return;
            }
            const sheet = this.parent.getActiveSheet();
            let ele = this.getActiveCell();
            const isRtl = this.parent.enableRtl;
            if (ele && (sheet.frozenRows || sheet.frozenColumns || sheet.selectedRange.includes(' '))) {
                this.selectRange({ address: sheet.selectedRange });
                return;
            }
            const sRange = getSwapRange(getRangeIndexes(sheet.selectedRange));
            const e = { range: sRange, isActiveCell: false, skipChecking: true };
            let isActiveCell;
            if (ele) {
                this.parent.notify(mergedRange, e);
                const colIdx = getCellIndexes(sheet.activeCell)[1];
                if (e.isActiveCell) {
                    const cell = getCell(sRange[0], sRange[1], sheet, false, true);
                    isActiveCell = cell.rowSpan > 1 || cell.colSpan > 1;
                }
                if (colIdx === args.colIdx || isActiveCell) {
                    ele.style.width = `${parseFloat(ele.style.width) + args.threshold}px`;
                }
                else if (colIdx > args.colIdx) {
                    if (isRtl) {
                        ele.style.right = `${parseFloat(ele.style.right) + args.threshold}px`;
                    }
                    else {
                        ele.style.left = `${parseFloat(ele.style.left) + args.threshold}px`;
                    }
                }
            }
            ele = this.getSelectionElement();
            if (!ele || isActiveCell || (sRange[0] === sRange[2] && sRange[1] === sRange[3])) {
                return;
            }
            const colStart = sRange[1];
            const colEnd = sRange[3];
            if (colStart <= args.colIdx && colEnd >= args.colIdx && ele) {
                ele.style.width = `${parseFloat(ele.style.width) + args.threshold}px`;
            }
            else if (colStart > args.colIdx && ele) {
                if (isRtl) {
                    ele.style.right = `${parseFloat(ele.style.right) + args.threshold}px`;
                }
                else {
                    ele.style.left = `${parseFloat(ele.style.left) + args.threshold}px`;
                }
            }
        });
    }
    selectRange(args) {
        args.address = this.parent.selectionSettings.mode === 'Single' ? getRangeAddress(getCellIndexes(args.address)) : args.address;
        this.selectMultiRange(args.address, null, null, args.skipChecking, args.isRowHeightChanged);
    }
    init() {
        this.createSelectionElement();
        const sheet = this.parent.getActiveSheet();
        const sRange = getSwapRange(getRangeIndexes(sheet.selectedRange));
        const actRange = getCellIndexes(sheet.activeCell);
        const inRange = sRange[0] <= actRange[0] && sRange[2] >= actRange[0] && sRange[1] <= actRange[1]
            && sRange[3] >= actRange[1];
        this.selectMultiRange(sheet.selectedRange, true, inRange);
    }
    selectMultiRange(address, isInit, inRange, skipChecking, isisRowHeightChanged) {
        let sheetIdx = this.parent.activeSheetIndex;
        if (address.indexOf('!') > -1) {
            sheetIdx = getSheetIndex(this.parent, getSheetNameFromAddress(address));
            address = address.substring(address.lastIndexOf('!') + 1);
        }
        if (this.parent.activeSheetIndex === sheetIdx) {
            address.split(' ').forEach((rng, idx) => {
                this.selectRangeByIdx(getRangeIndexes(rng), { type: 'mousedown', ctrlKey: idx !== 0 }, null, inRange, isInit, skipChecking, undefined, false, isisRowHeightChanged);
            });
        }
        else {
            updateSelectedRange(this.parent, address, this.parent.sheets[sheetIdx]);
        }
    }
    createSelectionElement() {
        const content = this.parent.getMainContent();
        let ele = this.parent.createElement('div', { className: 'e-selection' });
        content.appendChild(ele);
        ele = this.parent.createElement('div', { className: 'e-active-cell' });
        content.appendChild(ele);
    }
    isMergeActiveCell(sheet, activeIdx, rowIdx, colIdx) {
        const cell = getCell(rowIdx, colIdx, sheet, false, true);
        if ((!!cell.rowSpan && cell.rowSpan !== 1) || (!!cell.colSpan && cell.colSpan !== 1)) {
            const mergeArgs = { range: [rowIdx, colIdx, rowIdx, colIdx] };
            this.parent.notify(activeCellMergedRange, mergeArgs);
            const mergeRange = mergeArgs.range;
            return mergeRange[0] === activeIdx[0] && mergeRange[1] === activeIdx[1];
        }
        return false;
    }
    mouseDownHandler(e) {
        this.isNoteActiveElement = !isNullOrUndefined(document) && !isNullOrUndefined(document.activeElement) &&
            typeof document.activeElement.className === 'string' && document.activeElement.className.indexOf('e-addNoteContainer') > -1;
        if (closest(e.target, '.e-scrollbar') || e.target.classList.contains('e-main-panel') ||
            e.target.classList.contains('e-sheet')) {
            return;
        }
        const eventArgs = { action: 'getCurrentEditValue', editedValue: '' };
        const sheet = this.parent.getActiveSheet();
        this.parent.notify(editOperation, eventArgs);
        const isFormulaEdit = checkIsFormula(eventArgs.editedValue, true);
        const isNoteCellIndex = this.parent.enableNotes && !isNullOrUndefined(this.parent.spreadsheetNoteModule.noteCellIndexes);
        const cellIndexes = isNoteCellIndex ? this.parent.spreadsheetNoteModule.noteCellIndexes :
            getCellIndexes(this.parent.getActiveSheet().activeCell);
        const targetElement = this.parent.getCell(cellIndexes[0], cellIndexes[1]);
        if (!isNullOrUndefined(targetElement) && targetElement.children !== null && targetElement.children.length > 0
            && this.isNoteActiveElement && targetElement.children[targetElement.children.length - 1].classList.contains('e-addNoteIndicator')) {
            const cell = getCell(cellIndexes[0], cellIndexes[1], sheet);
            const eventAction = !isNullOrUndefined(cell) && cell.notes ? 'editNote' : 'addNote';
            const noteContainer = document.getElementsByClassName('e-addNoteContainer')[0];
            const address = getSheetName(this.parent, this.parent.activeSheetIndex) + '!' + getRangeAddress(cellIndexes);
            if (!isNullOrUndefined(noteContainer) && !isNullOrUndefined(noteContainer.value) && e.target.className !== 'e-addNoteContainer'
                && ((isNullOrUndefined(cell) || isNullOrUndefined(cell.notes)) || (cell.notes !== noteContainer.value))) {
                this.parent.notify(setActionData, { args: { action: 'beforeCellSave', eventArgs: { address: address } } });
                updateCell(this.parent, this.parent.getActiveSheet(), { rowIdx: cellIndexes[0], colIdx: cellIndexes[1], preventEvt: true,
                    cell: { notes: noteContainer.value, isNoteEditable: false } });
                const eventArgs = { notes: noteContainer.value, address: address };
                this.parent.notify(completeAction, { eventArgs: eventArgs, action: eventAction });
            }
            else if (e.target.className !== 'e-addNoteContainer') {
                updateCell(this.parent, this.parent.getActiveSheet(), { rowIdx: cellIndexes[0], colIdx: cellIndexes[1], preventEvt: true,
                    cell: { isNoteEditable: false } });
            }
            this.parent.spreadsheetNoteModule.isShowNote = null;
        }
        if (!this.isNoteTouch && e.target.className !== 'e-addNoteContainer' && document.getElementsByClassName('e-addNoteContainer') && document.getElementsByClassName('e-addNoteContainer').length > 0) {
            this.parent.notify(removeNoteContainer, '');
        }
        if (this.isNoteTouch && e.type.indexOf('mouse') > -1) {
            this.isNoteTouch = false;
        }
        if (!this.parent.isEdit || isFormulaEdit) {
            const overlayElem = document.getElementById(this.parent.element.id + '_overlay');
            if (typeof (e.target.className) === 'string') {
                if (e.target.className.indexOf('e-ss-overlay') > -1) {
                    return;
                }
            }
            else if (overlayElem) {
                overlayElem.classList.remove('e-ss-overlay-active');
            }
            if (closest(e.target, '.e-datavisualization-chart')) {
                return;
            }
            if (sheet.isProtected && !sheet.protectSettings.selectCells && !sheet.protectSettings.selectUnLockedCells) {
                return;
            }
            if (!(closest(e.target, '.e-findtool-dlg') || closest(e.target, '.e-dragfill-ddb'))) {
                if (this.getSheetElement().contains(e.target) && !e.target.classList.contains('e-colresize')
                    && !e.target.classList.contains('e-rowresize')) {
                    const sheet = this.parent.getActiveSheet();
                    const mode = this.parent.selectionSettings.mode;
                    const mouseClientX = getClientX(e);
                    const mouseClientY = getClientY(e);
                    let rowIdx = this.getRowIdxFromClientY({ clientY: mouseClientY, target: e.target });
                    let colIdx = this.getColIdxFromClientX({ clientX: mouseClientX, target: e.target });
                    const activeIdx = getCellIndexes(sheet.activeCell);
                    let isRowSelected;
                    let isColSelected;
                    if (sheet.showHeaders) {
                        const trgt = e.target;
                        if (sheet.frozenColumns || sheet.frozenRows) {
                            let headerEle = this.parent.getSelectAllContent().querySelector('thead');
                            if (headerEle) {
                                isColSelected = (this.parent.getColumnHeaderContent().contains(trgt) || headerEle.contains(trgt)) &&
                                    trgt.classList.contains('e-header-cell') || (trgt.classList.contains('e-selectall-table') &&
                                    rowIdx < 0 && colIdx >= this.parent.frozenColCount(sheet));
                            }
                            else {
                                isColSelected = this.parent.getColumnHeaderContent().contains(trgt) &&
                                    trgt.classList.contains('e-header-cell');
                            }
                            headerEle = this.parent.getSelectAllContent().querySelector('tbody');
                            if (headerEle) {
                                isRowSelected = (this.parent.getRowHeaderContent().contains(trgt) || headerEle.contains(trgt)) &&
                                    trgt.classList.contains('e-header-cell') || (trgt.classList.contains('e-selectall-table') &&
                                    colIdx < 0 && rowIdx >= this.parent.frozenRowCount(sheet));
                            }
                            else {
                                isRowSelected = this.parent.getRowHeaderContent().contains(trgt) &&
                                    trgt.classList.contains('e-header-cell');
                            }
                            if (rowIdx === -1) {
                                rowIdx = 0;
                            }
                            if (colIdx === -1) {
                                colIdx = 0;
                            }
                        }
                        else {
                            isRowSelected = this.parent.getRowHeaderContent().contains(e.target);
                            isColSelected = this.parent.getColumnHeaderContent().contains(e.target);
                        }
                    }
                    if ((sheet.frozenRows || sheet.frozenColumns) && !isColSelected && !isRowSelected) {
                        const trgt = e.target;
                        const idx = ['e-rowhdr-table', 'e-selectall-table', 'e-colhdr-table'].findIndex((cls) => trgt.classList.contains(cls));
                        if (idx > -1) {
                            const selector = ['.e-row-header', '.e-selectall-container', '.e-column-header'][idx];
                            const closestEle = closest(trgt, selector);
                            if (closestEle && closestEle.style.zIndex) {
                                const cell = getCell(rowIdx, colIdx, sheet);
                                if ((cell && cell.validation && cell.validation.type === 'List') ||
                                    (checkColumnValidation(sheet.columns[colIdx], rowIdx, colIdx) &&
                                        sheet.columns[colIdx].validation.type === 'List')) {
                                    const td = this.parent.getCell(rowIdx, colIdx);
                                    if (td) {
                                        const listEle = td.querySelector('.e-validation-list');
                                        if (listEle) {
                                            const listEleRect = listEle.getBoundingClientRect();
                                            const dropdownClicked = mouseClientX >= listEleRect.left &&
                                                mouseClientX <= listEleRect.right && mouseClientY >= listEleRect.top &&
                                                mouseClientY <= listEleRect.bottom;
                                            if (dropdownClicked) {
                                                const ddlEle = listEle.querySelector('.e-dropdownlist');
                                                if (ddlEle) {
                                                    const ddlInst = getComponent(ddlEle, 'dropdownlist');
                                                    if (ddlInst) {
                                                        ddlInst.showPopup();
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (e.which === 3 && this.isSelected(rowIdx, colIdx)) {
                        return;
                    }
                    if (e.target.classList.contains('e-autofill')) {
                        this.isautoFillClicked = true;
                        const autoFillDdb = e.target.parentElement.querySelector('.e-dragfill-ddb');
                        if (!autoFillDdb || autoFillDdb.classList.contains('e-hide')) {
                            this.dAutoFillCell = sheet.selectedRange;
                        }
                    }
                    const topLeftIdx = getRangeIndexes(sheet.topLeftCell);
                    let range;
                    if (isRowSelected) {
                        this.isRowSelected = true;
                        if (!e.shiftKey || mode === 'Single') {
                            this.startCell = [rowIdx, 0];
                        }
                        else if (!this.startCell) {
                            this.startCell = [topLeftIdx[0], 0];
                        }
                        range = [this.startCell[0], sheet.frozenColumns ? topLeftIdx[1] : 0, rowIdx, sheet.colCount - 1];
                    }
                    else if (isColSelected) {
                        this.isColSelected = true;
                        if (!e.shiftKey || mode === 'Single') {
                            this.startCell = [0, colIdx];
                        }
                        else if (!this.startCell) {
                            this.startCell = [0, topLeftIdx[1]];
                        }
                        range = [sheet.frozenRows ? topLeftIdx[0] : 0, this.startCell[1], sheet.rowCount - 1, colIdx];
                    }
                    else if (closest(e.target, '.e-select-all-cell')) {
                        this.startCell = [sheet.frozenRows ? topLeftIdx[0] : 0, sheet.frozenColumns ? topLeftIdx[1] : 0];
                        range = [].concat(this.startCell, [sheet.rowCount - 1, sheet.colCount - 1]);
                    }
                    else if (!e.target.classList.contains('e-sheet-content')) {
                        if (!e.shiftKey || mode === 'Single') {
                            this.startCell = [rowIdx, colIdx];
                        }
                        if (!this.isautoFillClicked && !closest(e.target, '.e-filloption')) {
                            range = [].concat(this.startCell ? this.startCell : getCellIndexes(sheet.activeCell), [rowIdx, colIdx]);
                        }
                    }
                    if (isTouchStart(e) && !(isRowSelected || isColSelected) && range) {
                        const colRowSelectArgs = this.isRowColSelected(range);
                        this.isRowSelected = colRowSelectArgs.isRowSelected;
                        this.isColSelected = colRowSelectArgs.isColSelected;
                    }
                    const preventEvt = e.ctrlKey && range && sheet.selectedRange.includes(getRangeAddress(range));
                    if (!preventEvt && mode === 'Multiple' && (!isTouchEnd(e) && (!isTouchStart(e) ||
                        (isTouchStart(e) && ((activeIdx[0] === rowIdx && activeIdx[1] === colIdx) ||
                            this.isMergeActiveCell(sheet, activeIdx, rowIdx, colIdx)))) || isColSelected || isRowSelected)) {
                        document.addEventListener(getMoveEvent().split(' ')[0], this.mouseMoveEvt);
                        if (!Browser.isPointer) {
                            if (Browser.isIos && isTouchStart(e) && e.target && e.target.classList.contains('e-cell')) {
                                e.preventDefault();
                            }
                            document.addEventListener(getMoveEvent().split(' ')[1], this.mouseMoveEvt, { passive: false });
                        }
                        this.touchSelectionStarted = true;
                    }
                    else {
                        this.touchSelectionStarted = false;
                    }
                    if (!isTouchEnd(e)) {
                        if (preventEvt) {
                            if (this.parent.isEdit) {
                                const updateFormulaCurPos = (e) => {
                                    EventHandler.remove(document, getEndEvent(), updateFormulaCurPos);
                                    this.updateFormulaCursorPosition(e);
                                };
                                EventHandler.add(document, getEndEvent(), updateFormulaCurPos, this);
                            }
                        }
                        else {
                            EventHandler.add(document, getEndEvent(), this.mouseUpHandler, this);
                        }
                    }
                    const isNoteAvailable = (e.target.className === 'e-addNoteIndicator' ||
                        (e.target.children.length > 0 && e.target.children[e.target.childElementCount - 1].className.indexOf('e-addNoteIndicator') > -1));
                    if (isTouchStart(e) && isNoteAvailable) {
                        const cellIndexes = getCellIndexes(getRangeAddress(range).split(':')[0]);
                        this.parent.notify(showNote, { rowIndex: cellIndexes[0], columnIndex: cellIndexes[1], isNoteEditable: false });
                        this.isNoteTouch = true;
                        this.parent.spreadsheetNoteModule.isNoteVisibleOnTouch = true;
                    }
                    if (isTouchStart(e) && !(isColSelected || isRowSelected)) {
                        this.touchEvt = e;
                        return;
                    }
                    if (range) {
                        this.selectRangeByIdx(range, e);
                    }
                    if (!this.isNoteTouch && e.type.indexOf('mouse') > -1 && isNoteAvailable) {
                        const cellIndexes = getCellIndexes(getRangeAddress(range).split(':')[0]);
                        this.parent.notify(showNote, { rowIndex: cellIndexes[0], columnIndex: cellIndexes[1], isNoteEditable: false });
                        this.parent.spreadsheetNoteModule.isNoteVisible = true;
                    }
                    if (this.parent.isMobileView()) {
                        this.parent.element.classList.add('e-mobile-focused');
                        this.parent.renderModule.setSheetPanelSize();
                    }
                }
            }
        }
        if (isFormulaEdit && (e.target.classList.contains('e-cell') || e.target.classList.contains('e-wrap-content') ||
            e.target.classList.contains('e-header-cell')) && this.parent.isEdit) {
            let range = this.parent.getActiveSheet().selectedRange;
            const lastRange = range.split(' ');
            range = isSingleCell(getIndexesFromAddress(lastRange[lastRange.length - 1])) ? lastRange[lastRange.length - 1].split(':')[0] : lastRange[lastRange.length - 1];
            this.parent.notify(addressHandle, { range: range, isSelect: false, isMouseDown: e.ctrlKey });
        }
    }
    mouseMoveHandler(e) {
        const sheet = this.parent.getActiveSheet();
        if (isTouchMove(e)) {
            e.preventDefault();
        }
        const eventArgs = { action: 'getCurrentEditValue', editedValue: '' };
        this.parent.notify(editOperation, eventArgs);
        const isFormulaEdit = checkIsFormula(eventArgs.editedValue, true);
        const verticalContent = this.parent.getMainContent().parentElement;
        const horizontalContent = this.parent.element.getElementsByClassName('e-scroller')[0];
        const clientRect = verticalContent.getBoundingClientRect();
        const frozenCol = this.parent.frozenColCount(sheet);
        let left = clientRect.left + this.parent.sheetModule.getRowHeaderWidth(sheet, false, true);
        let right = clientRect.right - getScrollBarWidth();
        const top = clientRect.top;
        const bottom = clientRect.bottom;
        const clientX = getClientX(e);
        const clientY = getClientY(e);
        // remove math.min or handle top and left auto scroll
        let colIdx = this.isRowSelected ? sheet.colCount - 1 :
            this.getColIdxFromClientX({ clientX: clientX, target: e.target });
        let rowIdx = this.isColSelected ? sheet.rowCount - 1 :
            this.getRowIdxFromClientY({ clientY: clientY, target: e.target });
        let prevIndex;
        let rangeIndex;
        if (e.ctrlKey) {
            const selRanges = sheet.selectedRange.split(' ');
            prevIndex = getRangeIndexes(selRanges[selRanges.length - 1]);
        }
        else {
            prevIndex = getRangeIndexes(sheet.selectedRange);
        }
        if (Browser.isDevice) {
            const screenWidth = screen.availWidth;
            if (right >= screenWidth - 40) {
                right -= (40 - (screenWidth - right));
            }
            if (!sheet.showHeaders && left < 40) {
                left += (40 - left);
            }
        }
        const mergeArgs = { range: [rowIdx, colIdx, rowIdx, colIdx] };
        this.parent.notify(activeCellMergedRange, mergeArgs);
        if (mergeArgs.range[2] === prevIndex[2] && mergeArgs.range[3] === prevIndex[3] && clientY <= bottom && clientY >= top &&
            clientX <= right && clientX >= left) {
            return;
        }
        const frozenRow = this.parent.frozenRowCount(sheet);
        if (!isFormulaEdit && !this.isColSelected && !this.isRowSelected) {
            prevIndex = getCellIndexes(sheet.activeCell);
        }
        const isScrollDown = clientY > bottom && !this.isColSelected && rowIdx < sheet.rowCount;
        const isScrollUp = clientY < top && rowIdx >= 0 && !this.isColSelected &&
            !!verticalContent.scrollTop && (!frozenRow || prevIndex[0] >= frozenRow);
        const isScrollRight = clientX > right && !this.isRowSelected && colIdx < sheet.colCount;
        const isScrollLeft = clientX < left && colIdx >= 0 && !this.isRowSelected &&
            !!horizontalContent.scrollLeft && (!frozenCol || prevIndex[1] >= frozenCol);
        this.clearInterval();
        let scrollUpRowIdx;
        let scrollUpColIdx;
        if (isScrollDown || isScrollUp || isScrollRight || isScrollLeft) {
            if (isScrollUp || isScrollLeft) {
                scrollUpRowIdx = rowIdx;
                scrollUpColIdx = colIdx;
            }
            const scrollSelection = () => {
                if (isScrollDown || isScrollUp) {
                    rowIdx = this.getRowIdxFromClientY({ clientY: isScrollDown ? bottom : top });
                    if (rowIdx >= sheet.rowCount) { // clear interval when scroll up
                        this.clearInterval();
                        return;
                    }
                    verticalContent.scrollTop += (isScrollDown ? 1 : -1) * getRowHeight(sheet, rowIdx);
                }
                if (isScrollRight || isScrollLeft) {
                    colIdx = this.getColIdxFromClientX({ clientX: isScrollRight ? right : left, isFScroll: true });
                    if (colIdx >= sheet.colCount) { // clear interval when scroll left
                        this.clearInterval();
                        return;
                    }
                    horizontalContent.scrollLeft += (isScrollRight ? 1 : -1) * getColumnWidth(sheet, colIdx);
                }
                if ((isScrollUp && sheet.frozenRows && !verticalContent.scrollTop) ||
                    (isScrollLeft && sheet.frozenColumns && !horizontalContent.scrollLeft)) {
                    this.selectRangeByIdx([].concat(prevIndex[0], prevIndex[1], [scrollUpRowIdx, scrollUpColIdx]), e);
                    this.clearInterval();
                    return;
                }
                this.selectRangeByIdx([].concat(prevIndex[0], prevIndex[1], [rowIdx, colIdx]), e);
            };
            scrollSelection();
            this.scrollInterval = setInterval(() => {
                scrollSelection();
                this.clearInterval();
                this.scrollInterval = setInterval(scrollSelection, 100);
            });
        }
        else {
            let indexes = [].concat(prevIndex[0], prevIndex[1], [rowIdx, colIdx]);
            if (frozenRow && indexes[0] < frozenRow && indexes[2] >= frozenRow && verticalContent.scrollTop) {
                verticalContent.scrollTop = 0;
                indexes[2] = frozenRow;
            }
            if (frozenCol && indexes[1] < frozenCol && indexes[3] >= frozenCol && horizontalContent.scrollLeft) {
                horizontalContent.scrollLeft = 0;
                indexes[3] = frozenCol;
            }
            if (this.isautoFillClicked) {
                if (e.target.classList.contains('e-autofill')) {
                    this.dAutoFillCell = sheet.selectedRange;
                }
                const args = { e: e, indexes: null };
                this.parent.notify(selectAutoFillRange, args);
                indexes = args.indexes;
                rangeIndex = indexes;
            }
            this.selectRangeByIdx(indexes, e);
        }
        if (isFormulaEdit && this.parent.isEdit && !closest(e.target, '#' + this.parent.element.id + '_edit')) {
            let range;
            if (this.isautoFillClicked) {
                range = getRangeAddress(rangeIndex);
            }
            else {
                range = this.parent.getActiveSheet().selectedRange;
            }
            const lastRange = range.split(' ');
            this.parent.notify(addressHandle, { range: lastRange[lastRange.length - 1], isSelect: false });
        }
    }
    mouseUpHandler(e) {
        const rowIdx = this.getRowIdxFromClientY({ clientY: getClientY(e), target: e.target });
        const colIdx = this.getColIdxFromClientX({ clientX: getClientX(e), target: e.target });
        this.clearInterval();
        if (isTouchEnd(e) && !(this.isColSelected || this.isRowSelected) &&
            (this.getRowIdxFromClientY({ clientY: getClientY(this.touchEvt), target: e.target }) === rowIdx &&
                this.getColIdxFromClientX({ clientX: getClientX(this.touchEvt), target: e.target }) === colIdx)) {
            this.mouseDownHandler(e);
        }
        document.removeEventListener(getMoveEvent().split(' ')[0], this.mouseMoveEvt);
        if (!Browser.isPointer) {
            document.removeEventListener(getMoveEvent().split(' ')[1], this.mouseMoveEvt);
        }
        EventHandler.remove(document, getEndEvent(), this.mouseUpHandler);
        const sheet = this.parent.getActiveSheet();
        if (sheet.frozenRows || sheet.frozenColumns) {
            removeRangeEle(this.parent.element, null, 'e-cur-selection', true, true);
        }
        this.parent.notify(mouseUpAfterSelection, e);
        if (this.isautoFillClicked) {
            const sheet = this.parent.getActiveSheet();
            const indexes = getRangeIndexes(sheet.selectedRange);
            if (!(this.isColSelected && indexes[1] === colIdx) && !(this.isRowSelected && indexes[0] === rowIdx)) {
                const autoFillDdb = e.target.parentElement.querySelector('.e-dragfill-ddb');
                if (!autoFillDdb || autoFillDdb.classList.contains('e-hide')) {
                    this.dAutoFillCell = sheet.selectedRange;
                }
                this.parent.notify(performAutoFill, { event: e, dAutoFillCell: this.dAutoFillCell });
            }
            this.isautoFillClicked = false;
        }
        else if (!e.ctrlKey && !isDiscontinuousRange(getSelectedRange(this.parent.getActiveSheet()))) {
            this.parent.notify(positionAutoFillElement, null);
        }
        else {
            this.parent.notify(hideAutoFillElement, null);
        }
        this.updateFormulaCursorPosition(e);
    }
    updateFormulaCursorPosition(e) {
        if (this.parent.isEdit) {
            const eventArgs = { action: 'getCurrentEditValue', editedValue: '' };
            this.parent.notify(editOperation, eventArgs);
            const isFormulaEdit = checkIsFormula(eventArgs.editedValue, true);
            if (isFormulaEdit) {
                this.parent.notify(initiateCur, { isCellEdit: e.target.classList.contains('e-spreadsheet-edit') });
            }
        }
    }
    isSelected(rowIdx, colIdx) {
        let isSelected = false;
        let indexes;
        const ranges = this.parent.getActiveSheet().selectedRange.split(' ');
        for (let i = 0; i < ranges.length; i++) {
            indexes = getSwapRange(getRangeIndexes(ranges[i]));
            if (indexes[0] <= rowIdx && rowIdx <= indexes[2] && indexes[1] <= colIdx && colIdx <= indexes[3]) {
                isSelected = true;
                break;
            }
        }
        return isSelected;
    }
    virtualContentLoadedHandler(args) {
        const sheet = this.parent.getActiveSheet();
        let indexes;
        let isColSelected;
        let isRowSelected;
        sheet.selectedRange.split(' ').forEach((rng, idx) => {
            indexes = getRangeIndexes(rng);
            isRowSelected = (indexes[1] === 0 && indexes[3] === args.prevRowColCnt.colCount - 1);
            isColSelected = (indexes[0] === 0 && indexes[2] === args.prevRowColCnt.rowCount - 1);
            if (isRowSelected || isColSelected) {
                if (isColSelected && isRowSelected) {
                    indexes = [0, 0, sheet.rowCount - 1, sheet.colCount - 1];
                }
                else if (isColSelected) {
                    indexes = [0, indexes[1], sheet.rowCount - 1, indexes[3]];
                }
                else {
                    indexes = [indexes[0], 0, indexes[2], sheet.colCount - 1];
                }
                if (sheet.frozenRows || sheet.frozenColumns) {
                    this.selectRangeByIdx(indexes, { type: 'mousedown', ctrlKey: idx !== 0 }, false, false, false, false, undefined, true);
                }
                else {
                    this.selectRangeByIdx(indexes, null, true, null, null, null, idx);
                }
            }
            else {
                indexes = getRangeIndexes(rng);
                const topIdx = this.parent.viewport.topIndex + this.parent.frozenRowCount(sheet);
                const leftIdx = this.parent.viewport.leftIndex + this.parent.frozenColCount(sheet);
                this.highlightHdr(indexes, idx === 0 ? false : true, indexes[0] >= topIdx || indexes[2] >= topIdx, indexes[1] >= leftIdx || indexes[3] >= leftIdx);
            }
        });
    }
    clearInterval() {
        if (this.scrollInterval) {
            clearInterval(this.scrollInterval);
            this.scrollInterval = null;
        }
    }
    getScrollLeft() {
        return this.parent.scrollModule ? this.parent.scrollModule.prevScroll.scrollLeft : 0;
    }
    cellNavigateHandler(args) {
        const sheet = this.parent.getActiveSheet();
        if (sheet.isProtected && !sheet.protectSettings.selectCells && !sheet.protectSettings.selectUnLockedCells) {
            return;
        }
        args.type = 'mousedown';
        this.selectRangeByIdx(args.range, args, false, false, false, false, undefined, args.preventAnimation);
    }
    getColIdxFromClientX(e) {
        let width = 0;
        const sheet = this.parent.getActiveSheet();
        let left = 0;
        if (e.isImage) {
            left = e.clientX;
        }
        else {
            const cliRect = document.getElementById(this.parent.element.id + '_sheet').getBoundingClientRect();
            if (this.parent.enableRtl) {
                left = (cliRect.right - this.parent.sheetModule.getRowHeaderWidth(sheet, true, true) - 1) - e.clientX;
            }
            else {
                left = e.clientX - (cliRect.left + this.parent.sheetModule.getRowHeaderWidth(sheet, true, true) + 1);
            }
            left += this.parent.viewport.beforeFreezeWidth;
            const frozenColPosition = () => {
                const frozenCol = this.parent.element.querySelector('.e-frozen-column');
                return parseInt(frozenCol.style[this.parent.enableRtl ? 'right' : 'left'], 10) / this.parent.viewport.scaleX;
            };
            if ((!e.target || (!closest(e.target, '.e-row-header') && !closest(e.target, '.e-selectall-container')) ||
                this.isScrollableArea(e.clientX, e.target, true)) && (!this.parent.frozenColCount(sheet) ||
                left > frozenColPosition() || e.isFScroll)) {
                left += (this.getScrollLeft() / this.parent.viewport.scaleX);
            }
            if (sheet.frozenRows && left < 0 && sheet.showHeaders) {
                return -1;
            }
        }
        let size;
        for (let i = 0;; i++) {
            size = width += getColumnWidth(sheet, i, null, !e.isImage) / this.parent.viewport.scaleX;
            if (left < (e.isImage ? Number(addDPRValue(size).toFixed(2)) : size) ||
                (this.parent.scrollSettings.isFinite && i === sheet.colCount - 1)) {
                if (!e.isImage) {
                    e.size = left;
                }
                e.clientX = i;
                return i;
            }
        }
    }
    isScrollableArea(offset, target, isclientX) {
        if (!target.classList.contains('e-table')) {
            return false;
        }
        if (isclientX) {
            return offset > this.parent.getMainContent().getBoundingClientRect().left;
        }
        else {
            return offset > this.parent.getMainContent().parentElement.getBoundingClientRect().top;
        }
    }
    getRowIdxFromClientY(args) {
        let height = 0;
        const sheet = this.parent.getActiveSheet();
        let top = 0;
        if (args.isImage) {
            top = args.clientY;
        }
        else {
            const sheetEle = document.getElementById(this.parent.element.id + '_sheet');
            top = args.clientY + this.parent.viewport.beforeFreezeHeight -
                (sheetEle.getBoundingClientRect().top + (sheet.showHeaders ? 31 / this.parent.viewport.scaleY : 0));
            if (!args.target || !closest(args.target, '.e-header-panel') || this.isScrollableArea(args.clientY, args.target)) {
                top += (this.parent.getMainContent().parentElement.scrollTop / this.parent.viewport.scaleY);
            }
            if (sheet.frozenColumns && top < 0 && sheet.showHeaders) {
                return -1;
            }
        }
        let size;
        for (let i = 0;; i++) {
            size = height += getRowHeight(sheet, i, !args.isImage) / this.parent.viewport.scaleY;
            if (top < (args.isImage ? Number(addDPRValue(size).toFixed(2)) : size) ||
                (this.parent.scrollSettings.isFinite && i === sheet.rowCount - 1)) {
                if (!args.isImage) {
                    args.size = top;
                }
                args.clientY = i;
                return i;
            }
        }
    }
    initFormulaReferenceIndicator(range) {
        if (this.parent.isEdit) {
            const forRefIndicator = this.parent.createElement('div', { className: 'e-formularef-indicator' });
            forRefIndicator.appendChild(this.parent.createElement('div', { className: 'e-top' }));
            forRefIndicator.appendChild(this.parent.createElement('div', { className: 'e-bottom' }));
            forRefIndicator.appendChild(this.parent.createElement('div', { className: 'e-left' }));
            forRefIndicator.appendChild(this.parent.createElement('div', { className: 'e-right' }));
            this.parent.getMainContent().appendChild(forRefIndicator);
            setPosition(this.parent, forRefIndicator, range, 'e-formularef-indicator');
        }
    }
    isMouseEvent(e) {
        return isMouseDown(e) || isMouseUp(e) || isMouseMove(e);
    }
    selectRangeByIdx(range, e, isScrollRefresh, isActCellChanged, isInit, skipChecking, selectedRowColIdx, preventAnimation, isisRowHeightChanged) {
        const isMouseEvent = e && this.isMouseEvent(e);
        if (e && e.target && isMouseEvent && closest(e.target, '#' + this.parent.element.id + '_edit')) {
            return;
        }
        const eventArgs = { action: 'getCurrentEditValue', editedValue: '',
            endFormulaRef: false };
        this.parent.notify(editOperation, eventArgs);
        const isFormulaEdit = (this.parent.isEdit ? checkIsFormula(eventArgs.editedValue, true) : false) &&
            !eventArgs.endFormulaRef;
        const isMultiRange = e && e.ctrlKey && isMouseDown(e);
        let ele;
        if (!isMultiRange) {
            ele = this.getSelectionElement(e, selectedRowColIdx);
        }
        const sheet = this.parent.getActiveSheet();
        const topLeftIdx = getRangeIndexes(sheet.topLeftCell);
        const formulaRefIndicator = this.parent.element.querySelector('.e-formularef-indicator');
        const mergeArgs = { range: [].slice.call(range), isActiveCell: false, skipChecking: skipChecking };
        let isMergeRange;
        let rowColSelectArgs = this.isRowColSelected(range);
        if (!rowColSelectArgs.isColSelected && !rowColSelectArgs.isRowSelected) {
            this.parent.notify(mergedRange, mergeArgs);
        }
        if (range !== mergeArgs.range) {
            isMergeRange = true;
        }
        range = mergeArgs.range;
        let promise = new Promise((resolve) => { resolve((() => { })()); });
        const args = { range: getRangeAddress(range), cancel: false };
        if (sheet.isProtected) {
            const protectCell = getCell(range[2], range[3], sheet);
            if (sheet.protectSettings.selectUnLockedCells && !sheet.protectSettings.selectCells) {
                if (!isNullOrUndefined(protectCell)) {
                    if ((protectCell.isLocked === true || isNullOrUndefined(protectCell.isLocked))) {
                        return;
                    }
                    else {
                        const sheetEle = this.parent.element.getElementsByClassName('e-sheet-panel')[0];
                        if (sheetEle && sheetEle.classList.contains('e-protected')) {
                            sheetEle.classList.remove('e-protected');
                        }
                    }
                }
                else if (!sheet.protectSettings.selectCells) {
                    return;
                }
            }
        }
        this.parent.trigger('beforeSelect', args);
        if (args.cancel) {
            return;
        }
        if (isFormulaEdit && formulaRefIndicator) {
            formulaRefIndicator.parentElement.removeChild(formulaRefIndicator);
        }
        if (!isisRowHeightChanged) {
            this.parent.notify(hideAutoFillOptions, null);
        }
        if ((isSingleCell(range) || mergeArgs.isActiveCell) && !isMultiRange) {
            if (ele) {
                if (!ele.classList.contains('e-multi-range')) {
                    ele.classList.add('e-hide');
                }
                if (sheet.frozenRows || sheet.frozenColumns) {
                    const clsName = isMouseMove(e) ? 'e-cur-selection' : 'e-selection';
                    removeRangeEle(this.parent.getSelectAllContent(), null, clsName, true);
                    removeRangeEle(this.parent.getColumnHeaderContent(), null, clsName, true);
                    removeRangeEle(this.parent.getRowHeaderContent(), null, clsName, true);
                }
            }
            if (!sheet.frozenColumns && !sheet.frozenRows && ele) {
                setPosition(this.parent, ele, range);
            }
            if (isFormulaEdit && e && e.target && (!isMouseEvent || !e.target.classList.contains('e-spreadsheet-edit'))
                && this.parent.isEdit) {
                const addRefArgs = {
                    range: getRangeAddress(range).split(':')[0], isSelect: true
                };
                this.parent.notify(addressHandle, addRefArgs);
                if (addRefArgs.isAlertDlgOpen) {
                    return;
                }
                this.initFormulaReferenceIndicator(range);
            }
        }
        else {
            if (isMultiRange) {
                if (selectedRowColIdx === undefined) {
                    let selRange = getRangeAddress(range);
                    if (sheet.selectedRange.includes(selRange) && !isFormulaEdit) {
                        const selRanges = sheet.selectedRange.split(' ');
                        if (selRanges.length > 1) {
                            selRanges.splice(selRanges.indexOf(selRange), 1);
                            selRange = selRanges.join(' ');
                        }
                        else {
                            selRange = sheet.activeCell + ':' + sheet.activeCell;
                        }
                        this.selectRange({ address: selRange });
                        return;
                    }
                    else {
                        ele = this.getSelectionElement(e, selectedRowColIdx);
                    }
                }
                else {
                    ele = this.getSelectionElement(e, selectedRowColIdx);
                }
            }
            if (isFormulaEdit && this.parent.isEdit) {
                if (e && e.target && (!isMouseEvent || !e.target.classList.contains('e-spreadsheet-edit')) && this.parent.isEdit) {
                    const addRefArgs = {
                        range: getRangeAddress(range), isSelect: true
                    };
                    this.parent.notify(addressHandle, addRefArgs);
                    if (addRefArgs.isAlertDlgOpen) {
                        return;
                    }
                    this.initFormulaReferenceIndicator(range);
                }
            }
            else {
                let clsName;
                if (ele) {
                    ele.classList.remove('e-hide');
                    if (sheet.frozenRows || sheet.frozenColumns) {
                        if (e && e.target || isMultiRange) {
                            clsName = 'e-cur-selection';
                            if (isMouseMove(e) && ele.classList.contains('e-cur-selection')) {
                                ele.classList.add('e-hide');
                            }
                            else {
                                ele.classList.add(clsName);
                            }
                        }
                        if (!isMultiRange && (this.isColSelected || this.isRowSelected) && isMouseDown(e)) {
                            removeRangeEle(this.parent.getSelectAllContent(), null, 'e-selection');
                            removeRangeEle(this.parent.getColumnHeaderContent(), null, 'e-selection');
                            removeRangeEle(this.parent.getRowHeaderContent(), null, 'e-selection');
                        }
                    }
                }
                const offset = (this.isColSelected && this.isRowSelected) ? undefined
                    : this.getOffset(range[2], range[3]);
                if (isMergeRange && offset) { // Need to handle half hidden merge cell in better way
                    offset.left = { idx: 0, size: 0 };
                }
                promise = setPosition(this.parent, ele, range, clsName, preventAnimation, isMultiRange, isMultiRange && !e.target) ||
                    promise;
            }
        }
        const eArgs = { action: 'getCurrentEditSheetIdx', sheetIndex: null };
        this.parent.notify(editOperation, eArgs);
        if (sheet.frozenColumns && range[1] > 0 && range[1] === topLeftIdx[1] && range[3] === sheet.colCount - 1) {
            range[1] = 0;
        }
        if (sheet.frozenRows && range[0] > 0 && range[0] === topLeftIdx[0] && range[2] === sheet.rowCount - 1) {
            range[0] = 0;
        }
        let selRange = getRangeAddress(range);
        if (e && e.ctrlKey && (isMouseMove(e) || isMouseUp(e)) && !isFormulaEdit) {
            selRange = sheet.selectedRange.slice(0, sheet.selectedRange.lastIndexOf(' ')) + ' ' + selRange;
        }
        else if (selectedRowColIdx > -1) {
            const selRanges = sheet.selectedRange.split(' ');
            selRanges[selectedRowColIdx] = selRange;
            selRange = selRanges.join(' ');
        }
        if (!isFormulaEdit && !this.isautoFillClicked) {
            let isSelectRangeChange = false;
            if (sheet.selectedRange !== selRange) {
                isSelectRangeChange = true;
            }
            updateSelectedRange(this.parent, selRange, sheet, isMultiRange);
            if (isSelectRangeChange) {
                promise.then(() => {
                    if (this.parent) {
                        this.parent.trigger('select', { range: this.parent.getActiveSheet().selectedRange });
                    }
                });
            }
        }
        else if (!isInit && !this.isautoFillClicked) {
            updateSelectedRange(this.parent, selRange, sheet, isMultiRange);
        }
        rowColSelectArgs = this.isRowColSelected(range);
        this.isRowSelected = rowColSelectArgs.isRowSelected;
        this.isColSelected = rowColSelectArgs.isColSelected;
        this.highlightHdr(range, e && e.ctrlKey);
        if (!isScrollRefresh && !(e && (e.type === 'mousemove' || isTouchMove(e)))) {
            if (!isFormulaEdit) {
                this.updateActiveCell(isActCellChanged ? getRangeIndexes(sheet.activeCell) : range, isInit, preventAnimation);
            }
            else if (eArgs.sheetIndex === this.parent.getActiveSheet().id - 1 && isInit) {
                isActCellChanged = true;
                this.updateActiveCell(isActCellChanged ? getRangeIndexes(sheet.activeCell) : range, isInit, preventAnimation);
            }
            else if (!this.parent.isEdit) {
                this.updateActiveCell(isActCellChanged ? getRangeIndexes(sheet.activeCell) : range, isInit, preventAnimation);
            }
        }
        if (isNullOrUndefined(e)) {
            e = { type: 'mousedown' };
        }
        if (!isFormulaEdit) {
            this.parent.notify(selectionComplete, e);
        }
        else if (!isInit) {
            this.parent.notify(selectionComplete, e);
        }
        if (!isMultiRange && !isDiscontinuousRange(getSelectedRange(this.parent.getActiveSheet()))) {
            this.parent.notify(positionAutoFillElement, { preventAnimation: preventAnimation });
        }
        else {
            this.parent.notify(hideAutoFillElement, null);
        }
        if (this.parent.showAggregate) {
            this.parent.notify(showAggregate, {});
        }
        this.parent.notify(refreshOverlayElem, null);
    }
    isRowColSelected(indexes) {
        const sheet = this.parent.getActiveSheet();
        return { isRowSelected: indexes[1] === 0 && indexes[3] === sheet.colCount - 1,
            isColSelected: indexes[0] === 0 && indexes[2] === sheet.rowCount - 1 };
    }
    updateActiveCell(range, isInit, preventAnimation) {
        const sheet = this.parent.getActiveSheet();
        const topLeftIdx = getRangeIndexes(sheet.topLeftCell);
        let rowIdx;
        let colIdx;
        let isMergeRange;
        if (this.isColSelected) {
            rowIdx = topLeftIdx[0];
            colIdx = range[1];
            if (this.isRowSelected) {
                colIdx = topLeftIdx[1];
            }
        }
        else {
            rowIdx = range[0];
            colIdx = range[1];
            if (this.isRowSelected) {
                colIdx = topLeftIdx[1];
            }
        }
        const mergeArgs = { range: [rowIdx, colIdx, ...[rowIdx, colIdx]] };
        this.parent.notify(activeCellMergedRange, mergeArgs);
        if (range !== mergeArgs.range) {
            isMergeRange = true;
        }
        range = mergeArgs.range;
        if (sheet.activeCell !== getCellAddress(range[0], range[1]) || isInit) {
            this.previousActiveCell = sheet.activeCell.indexOf(':') > -1 ? this.previousActiveCell : sheet.activeCell;
            this.parent.setSheetPropertyOnMute(sheet, 'activeCell', getCellAddress(range[0], range[1]));
            if (sheet.isProtected) {
                const element = this.parent.element.querySelector('.e-formula-bar');
                const cell = getCell(range[0], range[1], sheet);
                const isCellLocked = isLocked(cell, getColumn(sheet, range[1]));
                if (isCellLocked && element && !element.disabled) {
                    element.disabled = true;
                }
                else if (!isCellLocked && element && element.disabled) {
                    element.disabled = false;
                }
            }
            if (this.getActiveCell()) {
                const offset = this.getOffset(range[2], range[3]);
                if (isMergeRange) {
                    offset.left = { idx: 0, size: 0 };
                }
                setPosition(this.parent, this.getActiveCell(), range, 'e-active-cell', preventAnimation);
            }
            this.parent.notify(activeCellChanged, null);
        }
        else {
            setPosition(this.parent, this.getActiveCell(), range, 'e-active-cell', preventAnimation);
        }
    }
    getOffset(rowIdx, colIdx) {
        const offset = { left: { idx: 0, size: 0 }, top: { idx: 0, size: 0 } };
        if (this.parent.scrollModule) {
            if (colIdx >= this.parent.scrollModule.offset.left.idx) {
                offset.left = this.parent.scrollModule.offset.left;
            }
            if (rowIdx >= this.parent.scrollModule.offset.top.idx) {
                offset.top = this.parent.scrollModule.offset.top;
            }
        }
        return offset;
    }
    getSelectionElement(e, selectedRowColIdx) {
        const sheet = this.parent.getActiveSheet();
        if (e && e.ctrlKey && !this.parent.isEdit) {
            if (isMouseUp(e) || isMouseMove(e)) {
                if (sheet.frozenColumns || sheet.frozenRows) {
                    let ele = this.parent.getMainContent().querySelector('.e-cur-selection');
                    if (ele) {
                        return ele;
                    }
                    else {
                        ele = this.parent.element.querySelector('.e-multi-range');
                        return ele && ele.cloneNode();
                    }
                }
                else {
                    return this.parent.getMainContent().querySelector('.e-selection:last-child');
                }
            }
            else {
                const selElem = this.parent.getMainContent().getElementsByClassName('e-selection')[0];
                const ele = selElem.cloneNode();
                ele.classList.add('e-multi-range');
                if (sheet.frozenColumns || sheet.frozenRows) {
                    if (!sheet.selectedRange.includes(' ')) {
                        selElem.classList.remove('e-hide');
                        setPosition(this.parent, selElem, getSwapRange(getRangeIndexes(sheet.selectedRange)), undefined, false, true);
                    }
                    if (!this.parent.getMainContent().querySelector('.e-multi-range') && selElem.classList.contains('e-hide')) {
                        return selElem;
                    }
                    return ele;
                }
                else {
                    selElem.classList.remove('e-hide');
                    return this.parent.getMainContent().appendChild(ele);
                }
            }
        }
        else if (selectedRowColIdx > -1) {
            return ((sheet.frozenRows || sheet.frozenColumns) ?
                this.parent.element.querySelector('.e-sheet').getElementsByClassName('e-selection')[selectedRowColIdx] :
                this.parent.getMainContent().getElementsByClassName('e-selection')[selectedRowColIdx]);
        }
        else {
            const elems = [].slice.call(this.parent.element.getElementsByClassName('e-multi-range'));
            elems.forEach((ele) => {
                remove(ele);
            });
            return this.parent.getMainContent().getElementsByClassName('e-selection')[0];
        }
    }
    getActiveCell() {
        return this.parent.getMainContent().getElementsByClassName('e-active-cell')[0];
    }
    getSheetElement() {
        return document.getElementById(this.parent.element.id + '_sheet');
    }
    highlightHdr(range, isMultiRange, isRowRefresh = true, isColRefresh = true) {
        const sheet = this.parent.getActiveSheet();
        if (sheet.showHeaders) {
            if (!isMultiRange) {
                removeClass(this.getSheetElement().querySelectorAll('.e-highlight'), 'e-highlight');
                removeClass(this.getSheetElement().querySelectorAll('.e-prev-highlight'), 'e-prev-highlight');
            }
            const selectAllEle = this.parent.element.getElementsByClassName('e-select-all-cell')[0];
            if (selectAllEle) {
                removeClass([selectAllEle], ['e-prev-highlight-right', 'e-prev-highlight-bottom']);
            }
            const rowHdr = [];
            const colHdr = [];
            const swapRange = getSwapRange(range);
            if (this.isRowSelected) {
                swapRange[1] = skipHiddenIdx(sheet, swapRange[1], true, 'columns');
            }
            if (this.isColSelected) {
                swapRange[0] = skipHiddenIdx(sheet, swapRange[0], true);
            }
            const frozenIdx = [0, 0, 0, 0];
            const indexes = [0, 0, 0, 0];
            const topLeftIndex = getCellIndexes(sheet.topLeftCell);
            let i;
            let j;
            const updateIndex = (freezePane, layout, offset) => {
                let idx;
                let hiddenCount;
                if (freezePane && swapRange[i] < freezePane) {
                    topLeftIndex[i] = skipHiddenIdx(sheet, topLeftIndex[i], true, layout);
                    const startIdx = skipHiddenIdx(sheet, swapRange[i], true, layout);
                    if (startIdx === topLeftIndex[i]) {
                        swapRange[i] = startIdx;
                    }
                    hiddenCount = this.parent.hiddenCount(topLeftIndex[i], swapRange[i] - 1, layout, sheet);
                    frozenIdx[i] = swapRange[i] - hiddenCount - topLeftIndex[i];
                    idx = swapRange[j] < freezePane ? swapRange[j] : freezePane - 1;
                    frozenIdx[j] = idx - this.parent.hiddenCount(swapRange[i], idx, layout, sheet) - hiddenCount -
                        topLeftIndex[i] + 1;
                    idx = this.parent.viewport[`${offset}`] + freezePane;
                    if (swapRange[j] >= idx) {
                        indexes[i] = 0;
                        indexes[i] -= this.parent.hiddenCount(idx, idx, layout, sheet);
                        indexes[j] = swapRange[j] - this.parent.hiddenCount(idx, swapRange[j], layout, sheet) - idx + 1;
                    }
                }
                else {
                    idx = skipHiddenIdx(sheet, this.parent.viewport[`${offset}`] + freezePane, true, layout);
                    const startIdx = skipHiddenIdx(sheet, swapRange[i], true, layout);
                    if (idx === startIdx) {
                        swapRange[i] = idx;
                    }
                    hiddenCount = this.parent.hiddenCount(idx, swapRange[i] - 1, layout, sheet);
                    indexes[i] = swapRange[i] - hiddenCount - idx;
                    indexes[j] = swapRange[j] - this.parent.hiddenCount(swapRange[i], swapRange[j], layout, sheet) - hiddenCount - idx + 1;
                }
            };
            const updateCell = (idx, parent, hdrArr) => {
                const header = [].slice.call(parent.getElementsByClassName('e-header-cell'));
                for (let k = idx[i]; k < idx[j]; k++) {
                    if (header[k]) {
                        hdrArr.push(header[k]);
                    }
                }
            };
            if (isRowRefresh) {
                i = 0;
                j = 2;
                updateIndex(this.parent.frozenRowCount(sheet), 'rows', 'topIndex');
                if (sheet.frozenRows) {
                    const selectAllBody = this.parent.getSelectAllContent().querySelector('tbody');
                    if (selectAllBody) {
                        updateCell(frozenIdx, selectAllBody, rowHdr);
                    }
                }
                updateCell(indexes, this.parent.getRowHeaderContent(), rowHdr);
            }
            if (isColRefresh) {
                i = 1;
                j = 3;
                updateIndex(this.parent.frozenColCount(sheet), 'columns', 'leftIndex');
                if (sheet.frozenColumns) {
                    const selectAllHdr = this.parent.getSelectAllContent().querySelector('thead');
                    if (selectAllHdr) {
                        updateCell(frozenIdx, selectAllHdr, colHdr);
                    }
                }
                updateCell(indexes, this.parent.getColumnHeaderContent(), colHdr);
            }
            if (sheet.isProtected && !sheet.protectSettings.selectCells) {
                removeClass([].concat(rowHdr, colHdr), 'e-highlight');
            }
            else {
                addClass([].concat(rowHdr, colHdr), 'e-highlight');
            }
            if (rowHdr.length && rowHdr[0].parentElement.previousElementSibling) {
                rowHdr[0].parentElement.previousElementSibling.classList.add('e-prev-highlight');
            }
            if (colHdr.length && colHdr[0].previousElementSibling) {
                colHdr[0].previousElementSibling.classList.add('e-prev-highlight');
            }
            if (this.isRowSelected && this.isColSelected) {
                if (sheet.isProtected && !sheet.protectSettings.selectCells) {
                    document.getElementById(`${this.parent.element.id}_select_all`).classList.remove('e-highlight');
                }
                else {
                    document.getElementById(`${this.parent.element.id}_select_all`).classList.add('e-highlight');
                }
            }
            if (selectAllEle) {
                if (skipHiddenIdx(sheet, swapRange[0], true) === skipHiddenIdx(sheet, 0, true)) {
                    selectAllEle.classList.add('e-prev-highlight-bottom');
                }
                if (skipHiddenIdx(sheet, swapRange[1], true, 'columns') === skipHiddenIdx(sheet, 0, true, 'columns')) {
                    selectAllEle.classList.add('e-prev-highlight-right');
                }
            }
        }
    }
    protectHandler() {
        const range = getRangeIndexes(this.parent.getActiveSheet().selectedRange);
        const swapRange = getSwapRange(range);
        const actRange = getCellIndexes(this.parent.getActiveSheet().activeCell);
        const inRange = swapRange[0] <= actRange[0] && swapRange[2] >= actRange[0] && swapRange[1] <= actRange[1]
            && swapRange[3] >= actRange[1];
        this.selectRangeByIdx(range, null, null, inRange);
    }
    initiateFormulaSelection(args) {
        this.processFormulaEditRange(args.range, args.formulaSheetIdx);
    }
    processFormulaEditRange(val, formulaStartSheetIdx) {
        let str;
        let formulaSheetIdx = formulaStartSheetIdx;
        let i = 0;
        const eventArgs = { formula: val };
        this.parent.notify(parseFormulaArgument, eventArgs);
        const parsedVal = eventArgs.formulaArr;
        const len = parsedVal.length;
        let ctrlKeyCount = 0;
        const formulaBorder = [['e-vborderright', 'e-vborderbottom'], ['e-pborderright', 'e-pborderbottom'],
            ['e-cborderright', 'e-cborderbottom'], ['e-gborderright', 'e-gborderbottom'], ['e-oborderright', 'e-oborderbottom'],
            ['e-bborderright', 'e-bborderbottom']];
        this.clearBorder();
        const actSheetIdx = this.parent.getActiveSheet().id - 1;
        while (i < len) {
            str = parsedVal[i];
            if (this.invalidOperators.indexOf(str) > -1) {
                break;
            }
            if (isCellReference(str.toUpperCase())) {
                str = str.replace(/\$/g, '');
                if (i > 0) {
                    if (parsedVal[i - 1].lastIndexOf('!') === parsedVal[i - 1].length - 1) {
                        const sheetName = parsedVal[i - 1].substring(1, parsedVal[i - 1].lastIndexOf('!') - 1);
                        formulaSheetIdx = sheetName ? getSheetIndex(this.parent, sheetName) : formulaSheetIdx;
                    }
                }
                if (parsedVal[i + 1] === ':') {
                    i++;
                    if (parsedVal[i + 1] && isCellReference(parsedVal[i + 1].toUpperCase())) {
                        str = str + ':' + parsedVal[i + 1];
                        i++;
                    }
                }
                if (actSheetIdx === formulaSheetIdx) {
                    this.updateFormulaEditRange(str, ctrlKeyCount, formulaBorder);
                }
                formulaSheetIdx = formulaStartSheetIdx;
                ctrlKeyCount++;
            }
            i++;
        }
    }
    updateFormulaEditRange(str, i, formulaBorder) {
        const indices = getRangeIndexes(str);
        this.formulaRange[i] = str;
        this.dStartCell = { rowIndex: indices[0], colIndex: indices[1] };
        this.dEndCell = { rowIndex: indices[2], colIndex: indices[3] };
        this.focusBorder(this.dStartCell, this.dEndCell, formulaBorder[i % 6]);
    }
    chartBorderHandler(args) {
        this.focusBorder(args.startcell, args.endcell, args.classes, true);
    }
    focusBorder(startcell, endcell, classes, isChart) {
        isChart = isNullOrUndefined(isChart) ? false : isChart;
        const sheet = this.parent.getActiveSheet();
        const range = getSwapRange([startcell.rowIndex, startcell.colIndex, endcell.rowIndex, endcell.colIndex]);
        const topLeftIdx = getRangeIndexes(sheet.topLeftCell);
        const hiddenCol = this.parent.hiddenCount(topLeftIdx[1], range[3] - 1, 'columns', sheet);
        if (isChart && hiddenCol > 0) {
            range[1] -= hiddenCol;
            range[3] -= hiddenCol;
        }
        if (sheet.frozenRows || sheet.frozenColumns) {
            const rangeReference = this.parent.createElement('div', {
                className: isChart ? 'e-range-indicator e-chart-range' : 'e-range-indicator e-formuala-range'
            });
            rangeReference.appendChild(this.parent.createElement('div', { className: 'e-top' }));
            rangeReference.appendChild(this.parent.createElement('div', { className: 'e-bottom' }));
            rangeReference.appendChild(this.parent.createElement('div', { className: 'e-left' }));
            rangeReference.appendChild(this.parent.createElement('div', { className: 'e-right' }));
            setPosition(this.parent, rangeReference, range, 'e-range-indicator');
            return;
        }
        const minr = range[0];
        const minc = range[1];
        const maxr = range[2];
        const maxc = range[3];
        if (minr) {
            (this.getEleFromRange([minr - 1, minc, minr - 1, maxc])).forEach((td) => {
                if (td) {
                    td.classList.add(classes[1]);
                    if (!isChart) {
                        td.classList.add('e-formularef-selection');
                    }
                }
            }); // top
        }
        (this.getEleFromRange([minr, maxc, maxr, maxc])).forEach((td) => {
            if (td) {
                td.classList.add(classes[0]);
                if (!isChart) {
                    td.classList.add('e-formularef-selection');
                }
            }
        }); // right
        this.getEleFromRange([maxr, minc, maxr, maxc]).forEach((td) => {
            if (td) {
                td.classList.add(classes[1]);
                if (!isChart) {
                    td.classList.add('e-formularef-selection');
                }
            }
        }); // bottom
        if (minc) {
            (this.getEleFromRange([minr, minc - 1, maxr, minc - 1])).forEach((td) => {
                if (td) {
                    td.classList.add(classes[0]);
                    if (!isChart) {
                        td.classList.add('e-formularef-selection');
                    }
                }
            }); // left
        }
    }
    getEleFromRange(range) {
        let startRIndex = range[0];
        let startCIndex = range[1];
        let endRIndex = range[2];
        let endCIndex = range[3];
        let i;
        let rowIdx;
        let temp;
        let tempCells = [];
        let rowCells;
        const cells = [];
        if (startRIndex > endRIndex) {
            temp = startRIndex;
            startRIndex = endRIndex;
            endRIndex = temp;
        }
        if (startCIndex > endCIndex) {
            temp = startCIndex;
            startCIndex = endCIndex;
            endCIndex = temp;
        }
        if (this.parent.scrollSettings.enableVirtualization) {
            for (i = startRIndex; i <= endRIndex; i++) {
                rowIdx = i;
                if (rowIdx > -1) {
                    const row = this.parent.getRow(rowIdx, null);
                    if (row) {
                        rowCells = row.getElementsByClassName('e-cell');
                        tempCells = (endCIndex === startCIndex) ?
                            [rowCells[endCIndex]] : this.getRowCells(rowCells, startCIndex, endCIndex + 1);
                        this.merge(cells, tempCells);
                    }
                }
            }
        }
        return cells;
    }
    getRowCells(rowCells, startCIndex, endCIndex) {
        const tdCol = [];
        for (startCIndex; startCIndex < endCIndex; startCIndex++) {
            if (rowCells[startCIndex]) {
                tdCol.push(rowCells[startCIndex]);
            }
        }
        return tdCol;
    }
    merge(first, second) {
        if (!first || !second) {
            return;
        }
        Array.prototype.push.apply(first, second);
    }
    clearBorder() {
        const sheet = this.parent.getActiveSheet();
        if (sheet.frozenColumns || sheet.frozenRows) {
            const formualIndicator = [].slice.call(this.parent.element.getElementsByClassName('e-formuala-range'));
            formualIndicator.forEach((indicator) => { detach(indicator); });
            return;
        }
        const borderEleColl = this.parent.element.getElementsByClassName('e-formularef-selection');
        for (let idx = borderEleColl.length - 1; idx >= 0; idx--) {
            const td = borderEleColl[idx];
            const classArr = ['e-vborderright', 'e-vborderbottom', 'e-pborderright', 'e-pborderbottom',
                'e-cborderright', 'e-cborderbottom', 'e-gborderright', 'e-gborderbottom', 'e-oborderright',
                'e-oborderbottom', 'e-bborderright', 'e-bborderbottom', 'e-formularef-selection'];
            for (let idx = 0; idx < classArr.length; idx++) {
                td.classList.remove(classArr[idx]);
            }
        }
        // for (let idx: number = 0; idx < borderEleColl.length; idx++) {
        //     const td: HTMLElement = borderEleColl[idx] as HTMLElement;
        // }
    }
    /**
     * For internal use only - Get the module name.
     *
     * @private
     * @returns {string} - Get the module name.
     */
    getModuleName() {
        return 'selection';
    }
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
}

/**
 * The `Scroll` module is used to handle scrolling behavior.
 *
 * @hidden
 */
class Scroll {
    /**
     * Constructor for the Spreadsheet scroll module.
     *
     * @param {Spreadsheet} parent - Constructor for the Spreadsheet scroll module.
     * @private
     */
    constructor(parent) {
        this.clientX = 0;
        /** @hidden */
        this.isKeyScroll = true;
        this.parent = parent;
        this.addEventListener();
        this.initProps();
    }
    onContentScroll(e) {
        if (!this.parent) {
            return;
        }
        const target = this.parent.getMainContent().parentElement;
        const scrollLeft = e.scrollLeft;
        const top = e.scrollTop || target.scrollTop;
        const left = scrollLeft && this.parent.enableRtl ? this.initScrollValue - scrollLeft : scrollLeft;
        let scrollArgs;
        let prevSize;
        if (this.parent.allowAutoFill) {
            const elem = document.querySelector('#' + this.parent.element.id + '_autofilloptionbtn-popup');
            const DDBElem = document.querySelector('#' + this.parent.element.id + '_autofilloptionbtn');
            if (elem) {
                const DDBObj = getComponent(DDBElem, 'dropdown-btn');
                DDBObj.toggle();
            }
        }
        if (!isNullOrUndefined(scrollLeft) && this.prevScroll.scrollLeft !== left) {
            const scrollRight = left > this.prevScroll.scrollLeft;
            prevSize = this.offset.left.size;
            this.offset.left = this.getColOffset(left, scrollRight, e.skipHidden);
            if (!e.preventScroll) {
                this.parent.getColumnHeaderContent().scrollLeft = scrollLeft;
                this.parent.getMainContent().scrollLeft = scrollLeft;
                e.scrollLeft = scrollLeft;
            }
            scrollArgs = {
                cur: this.offset.left, prev: { idx: this.leftIndex, size: prevSize }, increase: scrollRight, preventScroll: e.preventScroll
            };
            this.updateTopLeftCell(scrollRight, true);
            this.parent.notify(focusRenameInput, null);
            this.parent.notify(onHorizontalScroll, scrollArgs);
            this.updateNoteContainer();
            if (!this.parent.scrollSettings.enableVirtualization && scrollRight && !this.parent.scrollSettings.isFinite) {
                this.updateNonVirtualCols();
            }
            this.leftIndex = scrollArgs.prev.idx;
            this.prevScroll.scrollLeft = left;
        }
        if (Math.round(this.prevScroll.scrollTop) !== Math.round(top)) {
            if (e.skipRowVirualScroll) {
                this.prevScroll.scrollTop = 0;
                this.offset.top = { idx: 0, size: 0 };
            }
            const scrollDown = top > this.prevScroll.scrollTop;
            prevSize = this.offset.top.size;
            this.offset.top = this.getRowOffset(top, scrollDown);
            scrollArgs = {
                cur: this.offset.top, prev: { idx: this.topIndex, size: prevSize }, increase: scrollDown, preventScroll: e.preventScroll
            };
            this.updateTopLeftCell(scrollDown);
            if (e.preventScroll && this.offset.top.idx <= this.parent.getThreshold('row')) {
                this.offset.top = { idx: 0, size: 0 };
            }
            else if (!e.skipRowVirualScroll) {
                this.parent.notify(focusRenameInput, null);
                this.parent.notify(onVerticalScroll, scrollArgs);
                this.updateNoteContainer();
            }
            else {
                scrollArgs.prev.idx = scrollArgs.cur.idx;
            }
            if (!this.parent.scrollSettings.enableVirtualization && scrollDown && !this.parent.scrollSettings.isFinite) {
                this.updateNonVirtualRows();
            }
            this.topIndex = scrollArgs.prev.idx;
            this.prevScroll.scrollTop = top;
        }
        const isEdit = false;
        const args = { isEdit: isEdit };
        this.parent.notify(isFormulaBarEdit, args);
        if (args.isEdit) {
            const textArea = this.parent.element.querySelector('.e-formula-bar');
            textArea.focus();
        }
        this.isKeyScroll = true;
    }
    updateNoteContainer() {
        if (document.getElementsByClassName('e-addNoteContainer') && document.getElementsByClassName('e-addNoteContainer').length > 0) {
            this.parent.notify(updateNoteContainer, null);
        }
    }
    updateScrollValue(args) {
        if (args.scrollLeft !== undefined) {
            this.prevScroll.scrollLeft = args.scrollLeft + (this.prevScroll.scrollLeft - this.offset.left.size);
            this.offset.left.size = args.scrollLeft;
        }
        if (args.scrollTop !== undefined) {
            this.prevScroll.scrollTop = args.scrollTop + (this.prevScroll.scrollTop - this.offset.top.size);
            this.offset.top.size = args.scrollTop;
        }
    }
    updateNonVirtualRows() {
        const sheet = this.parent.getActiveSheet();
        const threshold = this.parent.getThreshold('row');
        if (this.offset.top.idx > sheet.rowCount - (this.parent.viewport.rowCount + threshold)) {
            this.parent.renderModule.refreshUI({ rowIndex: sheet.rowCount, colIndex: 0, direction: 'first', refresh: 'RowPart' }, `${getCellAddress(sheet.rowCount, 0)}:${getCellAddress(sheet.rowCount + threshold - 1, sheet.colCount - 1)}`);
            this.parent.setSheetPropertyOnMute(sheet, 'rowCount', sheet.rowCount + threshold);
            this.parent.viewport.bottomIndex = sheet.rowCount - 1;
        }
    }
    updateNonVirtualCols() {
        const sheet = this.parent.getActiveSheet();
        const threshold = this.parent.getThreshold('col');
        if (this.offset.left.idx > sheet.colCount - (this.parent.viewport.colCount + threshold)) {
            this.parent.renderModule.refreshUI({ rowIndex: 0, colIndex: sheet.colCount, direction: 'first', refresh: 'ColumnPart' }, `${getCellAddress(0, sheet.colCount)}:${getCellAddress(sheet.rowCount - 1, sheet.colCount + threshold - 1)}`);
            this.parent.setSheetPropertyOnMute(sheet, 'colCount', sheet.colCount + threshold);
            this.parent.viewport.rightIndex = sheet.colCount - 1;
        }
    }
    updateTopLeftCell(increase, isLeft) {
        const sheet = this.parent.getActiveSheet();
        let top = this.offset.top.idx;
        let left = this.offset.left.idx;
        if (!increase) {
            const frozenRow = this.parent.frozenRowCount(sheet);
            top = skipHiddenIdx(sheet, top + frozenRow, true) - frozenRow;
            const frozenCol = this.parent.frozenColCount(sheet);
            left = skipHiddenIdx(sheet, left + frozenCol, true, 'columns') - frozenCol;
        }
        if (isLeft) {
            this.parent.updateTopLeftCell(null, left, 'row');
        }
        else {
            this.parent.updateTopLeftCell(top, null, 'col');
        }
    }
    getRowOffset(scrollTop, scrollDown) {
        let temp = this.offset.top.size;
        const sheet = this.parent.getActiveSheet();
        let i = scrollDown ? this.offset.top.idx + 1 : (this.offset.top.idx ? this.offset.top.idx - 1 : 0);
        const frozenRow = this.parent.frozenRowCount(sheet);
        const count = this.parent.scrollSettings.isFinite ? sheet.rowCount : Infinity;
        scrollTop = Math.round(scrollTop);
        while (i < count) {
            if (scrollDown) {
                const rowHeight = getRowHeight(sheet, i - 1 + frozenRow, true);
                temp += rowHeight;
                if (Math.abs(Math.round(temp) - scrollTop) <= 1) { // <=1 -> For other resolution scrollTop value slightly various with row height
                    return { idx: skipHiddenIdx(sheet, i + frozenRow, true) - frozenRow, size: temp };
                }
                if (Math.round(temp) > scrollTop) {
                    return { idx: i - 1, size: temp - rowHeight };
                }
                i++;
            }
            else {
                const rowHeight = getRowHeight(sheet, i + frozenRow, true);
                temp -= rowHeight;
                if (temp <= 0) {
                    return { idx: 0, size: 0 };
                }
                if (Math.abs(Math.round(temp) - scrollTop) <= 1) {
                    return { idx: i, size: temp };
                }
                if (Math.round(temp) < scrollTop) {
                    temp += rowHeight;
                    if (Math.round(temp) > scrollTop) {
                        return { idx: i, size: temp - rowHeight < 0 ? 0 : temp - rowHeight };
                    }
                    else {
                        return { idx: skipHiddenIdx(sheet, i + 1 + frozenRow, true) - frozenRow, size: temp };
                    }
                }
                i--;
            }
        }
        return { idx: this.offset.top.idx, size: this.offset.top.size };
    }
    getColOffset(scrollLeft, increase, skipHidden) {
        let temp = this.offset.left.size;
        const sheet = this.parent.getActiveSheet();
        let i = increase ? this.offset.left.idx + 1 : (this.offset.left.idx ? this.offset.left.idx - 1 : 0);
        const frozenCol = this.parent.frozenColCount(sheet);
        const count = this.parent.scrollSettings.isFinite ? sheet.colCount : Infinity;
        while (i < count) {
            if (increase) {
                const colWidth = getColumnWidth(sheet, i - 1 + frozenCol, skipHidden, true);
                temp += colWidth;
                if (Math.abs(Math.round(temp) - scrollLeft) <= 1) {
                    return { idx: skipHiddenIdx(sheet, i + frozenCol, true, 'columns') - frozenCol, size: temp };
                }
                if (Math.round(temp) > scrollLeft) {
                    return { idx: i - 1, size: temp - colWidth };
                }
                i++;
            }
            else {
                const colWidth = getColumnWidth(sheet, i + frozenCol, skipHidden, true);
                temp -= colWidth;
                if (temp <= 0) {
                    return { idx: 0, size: 0 };
                }
                if (Math.abs(Math.round(temp) - scrollLeft) <= 1) {
                    return { idx: i, size: temp };
                }
                if (Math.round(temp) < scrollLeft) {
                    temp += colWidth;
                    if (Math.round(temp) > scrollLeft) {
                        temp = temp - colWidth;
                        return { idx: i, size: temp < 0 ? 0 : temp };
                    }
                    else {
                        return { idx: skipHiddenIdx(sheet, i + 1 + frozenCol, true, 'columns') - frozenCol, size: temp };
                    }
                }
                i--;
            }
        }
        return { idx: this.offset.left.idx, size: this.offset.left.size };
    }
    contentLoaded(args) {
        if (!this.parent.scrollSettings.enableVirtualization) {
            const scrollTrack = this.parent.createElement('div', { className: 'e-virtualtrack' });
            this.updateNonVirualScrollWidth({ scrollTrack: scrollTrack });
            this.parent.getScrollElement().appendChild(scrollTrack);
        }
        if (args.left) {
            this.parent.getScrollElement().scrollLeft = args.left;
        }
        this.setScrollEvent();
        if (this.parent.enableRtl) {
            this.initScrollValue = this.parent.getScrollElement().scrollLeft;
        }
    }
    updateNonVirualScrollWidth(args) {
        if (!args.scrollTrack) {
            args.scrollTrack = this.parent.getScrollElement().getElementsByClassName('e-virtualtrack')[0];
        }
        args.scrollTrack.style.width = `${Math.abs(this.parent.getContentTable().getBoundingClientRect().width +
            (this.parent.scrollSettings.isFinite ? this.parent.sheetModule.getScrollSize() : 0))}px`;
    }
    onHeaderWheel(e) {
        e.preventDefault();
        this.parent.getMainContent().parentElement.scrollTop += e.deltaY;
        this.parent.getScrollElement().scrollLeft += e.deltaX;
    }
    onContentWheel(e) {
        if (e.deltaX !== 0) {
            e.preventDefault();
            this.parent.getScrollElement().scrollLeft += e.deltaX;
        }
    }
    scrollHandler(e) {
        this.onContentScroll({ scrollLeft: e.target.scrollLeft });
    }
    updateScroll(args) {
        if (isNullOrUndefined(args.left)) {
            this.parent.sheetModule.contentPanel.scrollTop = args.top;
        }
        else {
            this.parent.getScrollElement().scrollLeft = args.left;
        }
    }
    setScrollEvent() {
        EventHandler.add(this.parent.sheetModule.contentPanel, 'scroll', this.onContentScroll, this);
        EventHandler.add(this.parent.getColumnHeaderContent(), 'wheel', this.onHeaderWheel, this);
        EventHandler.add(this.parent.getSelectAllContent(), 'wheel', this.onHeaderWheel, this);
        EventHandler.add(this.parent.getMainContent(), 'wheel', this.onContentWheel, this);
        EventHandler.add(this.parent.getRowHeaderContent(), 'wheel', this.onContentWheel, this);
        EventHandler.add(this.parent.getScrollElement(), 'scroll', this.scrollHandler, this);
    }
    initProps() {
        this.topIndex = 0;
        this.leftIndex = 0;
        this.prevScroll = { scrollLeft: 0, scrollTop: 0 };
        this.offset = { left: { idx: 0, size: 0 }, top: { idx: 0, size: 0 } };
    }
    /**
     * @hidden
     *
     * @param {boolean} isRtlChange - Specifies RtlChange or not.
     * @returns {void} - To Set padding
     */
    setPadding(isRtlChange) {
        this.parent.sheetModule.contentPanel.style.overflowY = 'scroll';
        const scrollWidth = getScrollBarWidth();
        if (scrollWidth > 0) {
            const colHeader = this.parent.getColumnHeaderContent();
            const cssProps = this.parent.enableRtl ? { margin: 'marginLeft', border: 'borderLeftWidth' }
                : { margin: 'marginRight', border: 'borderRightWidth' };
            colHeader.parentElement.style[cssProps.margin] = scrollWidth + 'px';
            colHeader.style[cssProps.border] = '1px';
        }
        if (isRtlChange) {
            this.initScrollValue = 0;
        }
    }
    setClientX(e) {
        if (e.type === 'mousedown' || e.pointerType === 'mouse') {
            return;
        }
        const args = { touchSelectionStarted: false };
        this.parent.notify(selectionStatus, args);
        if (args.touchSelectionStarted || args.isOverlayClicked) {
            return;
        }
        this.clientX = this.getPointX(e);
        const sheetContent = document.getElementById(this.parent.element.id + '_sheet');
        EventHandler.add(sheetContent, Browser.isPointer ? 'pointermove' : 'touchmove', this.onTouchScroll, this);
        EventHandler.add(sheetContent, Browser.isPointer ? 'pointerup' : 'touchend', this.pointerUpHandler, this);
    }
    getPointX(e) {
        let clientX = 0;
        if (e.touches && e.touches.length) {
            clientX = e.touches[0].clientX;
        }
        else {
            clientX = e.clientX;
        }
        return clientX;
    }
    onTouchScroll(e) {
        if (e.pointerType === 'mouse') {
            return;
        }
        const clientX = this.getPointX(e);
        const diff = this.clientX - clientX;
        const scroller = this.parent.element.getElementsByClassName('e-scroller')[0];
        if ((diff > 10 || diff < -10) && scroller.scrollLeft + diff >= 0) {
            e.preventDefault();
            this.clientX = clientX;
            getUpdateUsingRaf(() => { scroller.scrollLeft += diff; });
        }
    }
    pointerUpHandler() {
        const sheetContent = document.getElementById(this.parent.element.id + '_sheet');
        EventHandler.remove(sheetContent, Browser.isPointer ? 'pointermove' : 'touchmove', this.onTouchScroll);
        EventHandler.remove(sheetContent, Browser.isPointer ? 'pointerup' : 'touchend', this.pointerUpHandler);
    }
    addEventListener() {
        this.parent.on(contentLoaded, this.contentLoaded, this);
        this.parent.on(onContentScroll, this.onContentScroll, this);
        this.parent.on(updateScroll, this.updateScroll, this);
        this.parent.on(deInitProperties, this.initProps, this);
        this.parent.on(spreadsheetDestroyed, this.destroy, this);
        this.parent.on(mouseDown, this.setClientX, this);
        this.parent.on(updateScrollValue, this.updateScrollValue, this);
        if (!this.parent.scrollSettings.enableVirtualization) {
            this.parent.on(virtualContentLoaded, this.updateNonVirualScrollWidth, this);
            this.parent.on(colWidthChanged, this.updateNonVirualScrollWidth, this);
        }
    }
    destroy() {
        this.removeEventListener();
        const ddbEle = document.querySelector('#' + this.parent.element.id + '_autofilloptionbtn');
        if (ddbEle) {
            const ddbObj = getComponent(ddbEle, 'dropdown-btn');
            if (ddbObj) {
                ddbObj.destroy();
            }
        }
        this.parent = null;
    }
    removeEventListener() {
        this.parent.off(contentLoaded, this.contentLoaded);
        this.parent.off(onContentScroll, this.onContentScroll);
        this.parent.off(updateScroll, this.updateScroll);
        this.parent.off(deInitProperties, this.initProps);
        this.parent.off(spreadsheetDestroyed, this.destroy);
        this.parent.off(mouseDown, this.setClientX);
        this.parent.off(updateScrollValue, this.updateScrollValue);
        if (!this.parent.scrollSettings.enableVirtualization) {
            this.parent.off(virtualContentLoaded, this.updateNonVirualScrollWidth);
            this.parent.off(colWidthChanged, this.updateNonVirualScrollWidth);
        }
    }
}

/**
 * VirtualScroll module
 *
 * @hidden
 */
class VirtualScroll {
    constructor(parent) {
        this.scroll = [];
        this.parent = parent;
        this.addEventListener();
    }
    createVirtualElement(args) {
        const sheet = this.parent.getActiveSheet();
        let container = this.parent.getMainContent();
        this.content = this.parent.createElement('div', { className: 'e-virtualable' });
        this.content.appendChild(container.querySelector('.e-table'));
        container.appendChild(this.content);
        const vTrack = container.appendChild(this.parent.createElement('div', { className: 'e-virtualtrack' }));
        let height = 0;
        let width;
        if (this.parent.sheets.length > this.scroll.length) {
            this.initScroll();
        }
        let endIndex = this.parent.viewport.bottomIndex;
        if (sheet.rowCount > endIndex + 1 || sheet.usedRange.rowIndex > endIndex) {
            if (!this.parent.scrollSettings.isFinite && sheet.rowCount <= sheet.usedRange.rowIndex) {
                this.parent.setSheetPropertyOnMute(sheet, 'rowCount', sheet.usedRange.rowIndex + 1);
            }
            this.setScrollCount(sheet.rowCount, 'row');
        }
        else {
            if (!this.parent.scrollSettings.isFinite) {
                this.parent.setSheetPropertyOnMute(sheet, 'rowCount', endIndex + 1);
            }
            this.scroll[this.parent.activeSheetIndex].rowCount = sheet.rowCount;
        }
        let startIndex = this.parent.frozenRowCount(sheet);
        const indexes = getCellIndexes(sheet.topLeftCell);
        if (args.top) {
            height = args.top;
            if (sheet.frozenRows) {
                height += getRowsHeight(sheet, indexes[0], startIndex - 1, true);
            }
            startIndex = getCellIndexes(sheet.paneTopLeftCell)[0];
        }
        height += getRowsHeight(sheet, startIndex, this.scroll[this.parent.activeSheetIndex].rowCount - 1, true);
        endIndex = this.parent.viewport.rightIndex;
        let size = 0;
        const frozenCol = this.parent.frozenColCount(sheet);
        if (args.left) {
            size = args.left;
            if (frozenCol) {
                size += getColumnsWidth(sheet, indexes[1], frozenCol - 1, true);
            }
            startIndex = getCellIndexes(sheet.paneTopLeftCell)[1];
        }
        else {
            startIndex = frozenCol;
        }
        if (sheet.colCount > endIndex + 1 || sheet.usedRange.colIndex > endIndex) {
            if (!this.parent.scrollSettings.isFinite && sheet.colCount <= sheet.usedRange.colIndex) {
                this.parent.setSheetPropertyOnMute(sheet, 'colCount', sheet.usedRange.colIndex + 1);
            }
            size += getColumnsWidth(sheet, startIndex, endIndex, true);
            this.setScrollCount(sheet.colCount, 'col');
            width = size + getColumnsWidth(sheet, endIndex + 1, this.scroll[this.parent.activeSheetIndex].colCount - 1, true);
        }
        else {
            if (!this.parent.scrollSettings.isFinite) {
                this.parent.setSheetPropertyOnMute(sheet, 'colCount', endIndex + 1);
            }
            size += getColumnsWidth(sheet, startIndex, sheet.colCount - 1, true);
            this.scroll[this.parent.activeSheetIndex].colCount = sheet.colCount;
            width = size;
        }
        if (isNullOrUndefined(this.parent.viewport.leftIndex)) {
            this.parent.viewport.leftIndex = 0;
        }
        if (isNullOrUndefined(this.parent.viewport.topIndex)) {
            this.parent.viewport.topIndex = 0;
        }
        if (args.left) {
            size = getColumnsWidth(sheet, this.parent.viewport.leftIndex + frozenCol, endIndex, true);
        }
        if (isNullOrUndefined(this.translateX)) {
            this.translateX = 0;
        }
        if (isNullOrUndefined(this.translateY)) {
            this.translateY = 0;
        }
        container = this.parent.getRowHeaderContent();
        this.rowHeader = this.content.cloneNode();
        this.rowHeader.appendChild(container.querySelector('.e-table'));
        container.appendChild(this.rowHeader);
        const rowVTrack = container.appendChild(vTrack.cloneNode());
        this.rowHeader.style.transform = `translate(0px, ${this.translateY}px)`;
        container = this.parent.getColumnHeaderContent();
        this.colHeader = this.content.cloneNode();
        this.colHeader.appendChild(container.querySelector('.e-table'));
        container.appendChild(this.colHeader);
        const colVTrack = container.appendChild(vTrack.cloneNode());
        this.colHeader.style.width = `${size}px`;
        rowVTrack.style.height = `${height}px`;
        colVTrack.style.width = `${width}px`;
        this.colHeader.style.transform = `translate(${this.translateX}px, 0px)`;
        this.content.style.transform = `translate(${this.translateX}px, ${this.translateY}px)`;
        this.content.style.width = `${size}px`;
        vTrack.style.height = `${height}px`;
        vTrack.style.width = `${width}px`;
        if (this.parent.allowScrolling) {
            const scrollVTrack = colVTrack.cloneNode(true);
            scrollVTrack.style.width = `${width + (this.parent.scrollSettings.isFinite ? this.parent.sheetModule.getScrollSize() : 0)}px`;
            this.parent.getScrollElement().appendChild(scrollVTrack);
        }
    }
    initScroll() {
        let i = 0;
        while (i < this.parent.sheets.length) {
            if (!this.scroll[i]) {
                this.scroll.push({ rowCount: 0, colCount: 0 });
            }
            i++;
        }
    }
    setScrollCount(count, layout) {
        const activeSheetIdx = this.parent.activeSheetIndex;
        if (!this.scroll[activeSheetIdx][layout + 'Count'] || this.scroll[activeSheetIdx][layout + 'Count'] !== count) {
            this.scroll[activeSheetIdx][layout + 'Count'] = count;
        }
    }
    getRowAddress(indexes) {
        const sheet = this.parent.getActiveSheet();
        return getRangeAddress([indexes[0], sheet.frozenColumns ? getCellIndexes(sheet.topLeftCell)[1] : this.parent.viewport.leftIndex,
            indexes[1], this.parent.viewport.rightIndex]);
    }
    getColAddress(indexes) {
        const sheet = this.parent.getActiveSheet();
        return getRangeAddress([sheet.frozenRows ? getCellIndexes(sheet.topLeftCell)[0] : this.parent.viewport.topIndex, indexes[0],
            this.parent.viewport.bottomIndex, indexes[1]]);
    }
    updateScrollCount(idx, layout, threshold = idx) {
        const sheet = this.parent.getActiveSheet();
        let rowCount = idx + this.parent.viewport[layout + 'Count'] + 1 + threshold;
        const usedRangeCount = this.scroll[this.parent.activeSheetIndex][layout + 'Count'];
        if (rowCount < usedRangeCount) {
            if (sheet[layout + 'Count'] === usedRangeCount) {
                return;
            }
            rowCount = usedRangeCount;
        }
        if (!this.parent.scrollSettings.isFinite) {
            this.parent.setSheetPropertyOnMute(sheet, layout + 'Count', rowCount);
        }
    }
    onVerticalScroll(args) {
        let idx = args.cur.idx;
        const height = args.cur.size;
        const prevIdx = args.prev.idx;
        let idxDiff = Math.abs(idx - prevIdx);
        const threshold = this.parent.getThreshold('row');
        if (idxDiff > Math.round(threshold / 2)) {
            let startIdx;
            let lastIdx;
            let prevTopIdx;
            const sheet = this.parent.getActiveSheet();
            if (idx <= threshold) {
                if (!args.increase) {
                    if (this.translateY && prevIdx > threshold) {
                        this.translateY = 0;
                        const frozenCol = this.parent.frozenColCount(sheet);
                        const frozenRow = this.parent.frozenRowCount(sheet);
                        if (!args.preventScroll) {
                            const colIndex = frozenCol ? getCellIndexes(sheet.topLeftCell)[1] : this.parent.viewport.leftIndex;
                            const fIndexes = frozenCol ? [frozenRow, this.parent.viewport.leftIndex + frozenCol] : [];
                            if (idxDiff < this.parent.viewport.rowCount + threshold) {
                                startIdx = skipHiddenIdx(sheet, frozenRow, true);
                                lastIdx = skipHiddenIdx(sheet, (this.parent.viewport.topIndex + frozenRow) - 1, false);
                                this.parent.viewport.topIndex = startIdx - frozenRow;
                                const btmIdx = this.skipHiddenLastIdx(this.parent.viewport.bottomIndex - (((lastIdx - startIdx) + 1) - this.hiddenCount(startIdx, lastIdx)), this.parent.viewport.bottomIndex);
                                this.parent.viewport.bottomIndex = skipHiddenIdx(sheet, btmIdx, false);
                                this.parent.renderModule.refreshUI({
                                    colIndex: colIndex, rowIndex: startIdx, direction: 'last', refresh: 'RowPart',
                                    skipUpdateOnFirst: true, frozenIndexes: fIndexes
                                }, this.getRowAddress([startIdx, skipHiddenIdx(sheet, lastIdx, false)]));
                            }
                            else {
                                const prevColIndex = this.parent.viewport.leftIndex;
                                this.parent.renderModule.refreshUI({ rowIndex: 0, colIndex: colIndex, refresh: 'Row', skipUpdateOnFirst: true,
                                    frozenIndexes: fIndexes, skipTranslate: true });
                                if (frozenCol) {
                                    this.parent.viewport.leftIndex = prevColIndex;
                                }
                                this.translate({ refresh: 'Row' });
                            }
                            focus(this.parent.element);
                            idx = 0;
                        }
                        else {
                            this.parent.viewport.topIndex = prevIdx - (threshold - frozenRow);
                        }
                    }
                    this.updateScrollCount(threshold, 'row');
                }
            }
            if (prevIdx < threshold) {
                idxDiff = Math.abs(idx - threshold);
            }
            if (!args.increase && this.parent.scrollSettings.isFinite && this.parent.viewport.bottomIndex ===
                skipHiddenIdx(sheet, sheet.rowCount - 1, false)) {
                const frozenRow = this.parent.frozenRowCount(sheet);
                const thresholdIdx = this.parent.viewport.topIndex + frozenRow + getRangeIndexes(sheet.paneTopLeftCell)[0] - 1;
                if (idx + frozenRow > thresholdIdx) {
                    args.prev.idx = idx;
                    return;
                }
                idxDiff = thresholdIdx - (idx + frozenRow);
            }
            if (idx > threshold) {
                prevTopIdx = this.parent.viewport.topIndex;
                this.parent.viewport.topIndex = idx - threshold;
                if (args.increase && prevTopIdx > this.parent.viewport.topIndex) {
                    this.parent.viewport.topIndex = prevTopIdx;
                    return;
                }
                const frozenRow = this.parent.frozenRowCount(sheet);
                if (!args.preventScroll) {
                    const frozenCol = this.parent.frozenColCount(sheet);
                    let colIndex;
                    const frozenIndexes = [];
                    if (frozenCol) {
                        colIndex = getCellIndexes(sheet.topLeftCell)[1];
                        frozenIndexes.push(frozenRow);
                        frozenIndexes.push(this.parent.viewport.leftIndex + frozenCol);
                    }
                    else {
                        colIndex = this.parent.viewport.leftIndex;
                    }
                    if (idxDiff < this.parent.viewport.rowCount + threshold) {
                        if (args.increase) {
                            startIdx = this.parent.viewport.bottomIndex + 1;
                            lastIdx = this.parent.viewport.bottomIndex + (this.parent.viewport.topIndex - prevTopIdx);
                            lastIdx -= this.hiddenCount(prevTopIdx + frozenRow, this.parent.viewport.topIndex - 1 + frozenRow);
                            if (lastIdx <= this.parent.viewport.bottomIndex || (this.parent.scrollSettings.isFinite &&
                                startIdx > skipHiddenIdx(sheet, sheet.rowCount - 1, false, 'rows'))) {
                                this.parent.viewport.topIndex = prevTopIdx;
                                return;
                            }
                            const indexes = this.parent.skipHidden(startIdx, lastIdx, 'rows', false);
                            const finiteProps = this.checkLastIdx(indexes[1], 'row');
                            startIdx = indexes[0];
                            lastIdx = finiteProps.index;
                            let topIdx = this.parent.viewport.topIndex + frozenRow;
                            if (finiteProps.diff) {
                                const diffCount = ((lastIdx - startIdx) + 1) - this.hiddenCount(startIdx, lastIdx);
                                topIdx = skipHiddenIdx(sheet, prevTopIdx, true, 'rows', diffCount) + frozenRow;
                            }
                            this.parent.viewport.topIndex = skipHiddenIdx(sheet, topIdx, !finiteProps.diff) - frozenRow;
                            this.setThresholdHeight(height, idx - this.parent.viewport.topIndex, frozenRow, !!finiteProps.diff, prevTopIdx === skipHiddenIdx(sheet, frozenRow, true));
                            this.parent.viewport.bottomIndex = lastIdx;
                            this.parent.renderModule.refreshUI({ colIndex: colIndex, rowIndex: startIdx, direction: 'first', refresh: 'RowPart',
                                frozenIndexes: frozenIndexes }, this.getRowAddress([startIdx, lastIdx]));
                        }
                        else {
                            startIdx = skipHiddenIdx(sheet, this.parent.viewport.topIndex + frozenRow, false);
                            if (startIdx < frozenRow) {
                                startIdx = frozenRow;
                                startIdx = skipHiddenIdx(sheet, startIdx, true);
                            }
                            this.parent.viewport.topIndex = startIdx - frozenRow;
                            lastIdx = skipHiddenIdx(sheet, (prevTopIdx + frozenRow) - 1, false);
                            if (lastIdx < frozenRow || lastIdx < startIdx) {
                                this.parent.viewport.topIndex = prevTopIdx;
                                return;
                            }
                            const btmIdx = this.skipHiddenLastIdx(this.parent.viewport.bottomIndex - (((lastIdx - startIdx) + 1) - this.hiddenCount(startIdx, lastIdx)), this.parent.viewport.bottomIndex);
                            this.parent.viewport.bottomIndex = skipHiddenIdx(sheet, btmIdx, false);
                            this.setThresholdHeight(height, idx - this.parent.viewport.topIndex, frozenRow);
                            this.parent.renderModule.refreshUI({ colIndex: colIndex, rowIndex: startIdx, direction: 'last', refresh: 'RowPart',
                                frozenIndexes: frozenIndexes }, this.getRowAddress([startIdx, lastIdx]));
                        }
                    }
                    else {
                        prevTopIdx = this.parent.viewport.leftIndex;
                        this.parent.viewport.topIndex = skipHiddenIdx(sheet, this.parent.viewport.topIndex + frozenRow, false) - frozenRow;
                        if (this.parent.viewport.topIndex < 0) {
                            this.parent.viewport.topIndex = skipHiddenIdx(sheet, frozenRow, true) - frozenRow;
                        }
                        this.parent.renderModule.refreshUI({
                            rowIndex: this.parent.viewport.topIndex, colIndex: colIndex, refresh: 'Row',
                            frozenIndexes: frozenIndexes, skipTranslate: true
                        });
                        if (frozenCol) {
                            this.parent.viewport.leftIndex = prevTopIdx;
                        }
                        this.setThresholdHeight(height, idx - this.parent.viewport.topIndex, frozenRow, this.parent.scrollSettings.isFinite && this.parent.viewport.bottomIndex ===
                            skipHiddenIdx(sheet, sheet.rowCount - 1, false));
                        this.translate({ refresh: 'Row' });
                    }
                    this.updateScrollCount(idx, 'row', threshold);
                    this.focusSheet();
                }
                else {
                    this.setThresholdHeight(height, threshold, frozenRow);
                    this.translate({ refresh: 'Row' });
                }
            }
            args.prev.idx = idx;
        }
    }
    skipHiddenLastIdx(idx, prevIdx, layout = 'rows') {
        const sheet = this.parent.getActiveSheet();
        let count = 0;
        for (let i = idx; i <= prevIdx; i++) {
            if ((sheet[`${layout}`])[i] && (sheet[`${layout}`])[i].hidden) {
                count++;
            }
        }
        if (count) {
            idx = this.skipHiddenLastIdx(idx - count, idx - 1, layout);
        }
        return idx;
    }
    hiddenCount(startIdx, endIdx, layout = 'rows') {
        let index = 0;
        const sheet = this.parent.getActiveSheet();
        for (let i = startIdx; i <= endIdx; i++) {
            if ((sheet[`${layout}`])[i] && (sheet[`${layout}`])[i].hidden) {
                index++;
            }
        }
        return index;
    }
    checkLastIdx(idx, layout) {
        let diff = 0;
        if (this.parent.scrollSettings.isFinite) {
            const sheet = this.parent.getActiveSheet();
            const count = skipHiddenIdx(sheet, (sheet[layout + 'Count'] - 1), false, layout === 'col' ? 'columns' : 'rows');
            if (idx > count) {
                diff = idx - count;
                idx = count;
            }
        }
        return { index: idx, diff: diff };
    }
    onHorizontalScroll(args) {
        let idx = args.cur.idx;
        const width = args.cur.size;
        const prevIdx = args.prev.idx;
        let idxDiff = Math.abs(idx - prevIdx);
        const threshold = this.parent.getThreshold('col');
        if (idxDiff > Math.round(threshold / 2)) {
            let startIdx;
            let endIdx;
            let prevLeftIdx;
            const sheet = this.parent.getActiveSheet();
            if (idx <= threshold) {
                if (!args.increase) {
                    if (this.translateX && prevIdx > threshold) {
                        this.translateX = 0;
                        const frozenCol = this.parent.frozenColCount(sheet);
                        const frozenRow = this.parent.frozenRowCount(sheet);
                        if (!args.preventScroll) {
                            const rowIndex = frozenRow ? getCellIndexes(sheet.topLeftCell)[0] : this.parent.viewport.topIndex;
                            const fIndexes = frozenRow ? [this.parent.viewport.topIndex + frozenRow, frozenCol] : [];
                            if (idxDiff < this.parent.viewport.colCount + threshold) {
                                startIdx = skipHiddenIdx(sheet, frozenCol, true, 'columns');
                                endIdx = skipHiddenIdx(sheet, (this.parent.viewport.leftIndex + frozenCol) - 1, false, 'columns');
                                this.parent.viewport.leftIndex = startIdx - frozenCol;
                                const rightIdx = this.skipHiddenLastIdx(this.parent.viewport.rightIndex - (((endIdx - startIdx) + 1) -
                                    this.hiddenCount(startIdx, endIdx, 'columns')), this.parent.viewport.rightIndex, 'columns');
                                this.parent.viewport.rightIndex = skipHiddenIdx(sheet, rightIdx, false, 'columns');
                                this.parent.renderModule.refreshUI({ rowIndex: rowIndex, colIndex: startIdx, direction: 'last', refresh: 'ColumnPart',
                                    skipUpdateOnFirst: true, frozenIndexes: fIndexes }, this.getColAddress([startIdx, skipHiddenIdx(sheet, endIdx, false, 'columns')]));
                            }
                            else {
                                const prevRowIndex = this.parent.viewport.topIndex;
                                this.parent.renderModule.refreshUI({ rowIndex: rowIndex, colIndex: 0, refresh: 'Column', skipUpdateOnFirst: true,
                                    frozenIndexes: fIndexes, skipTranslate: true });
                                if (frozenRow) {
                                    this.parent.viewport.topIndex = prevRowIndex;
                                }
                                this.translate({ refresh: 'Column' });
                            }
                            focus(this.parent.element);
                            idx = 0;
                        }
                        else {
                            this.parent.viewport.leftIndex = prevIdx - (threshold - frozenCol);
                        }
                    }
                    this.updateScrollCount(threshold, 'col');
                }
            }
            if (prevIdx < threshold) {
                idxDiff = Math.abs(idx - threshold);
            }
            if (!args.increase && this.parent.scrollSettings.isFinite && this.parent.viewport.rightIndex ===
                skipHiddenIdx(sheet, sheet.colCount - 1, false, 'columns')) {
                const frozenCol = this.parent.frozenColCount(sheet);
                let thresholdIdx = this.parent.viewport.leftIndex + frozenCol + getRangeIndexes(sheet.paneTopLeftCell)[1] - 1;
                thresholdIdx += this.hiddenCount(this.parent.viewport.leftIndex + frozenCol, thresholdIdx);
                if (idx + frozenCol > thresholdIdx) {
                    args.prev.idx = idx;
                    return;
                }
                idxDiff = thresholdIdx - (idx + frozenCol);
            }
            if (idx > threshold) {
                prevLeftIdx = this.parent.viewport.leftIndex;
                this.parent.viewport.leftIndex = idx - threshold;
                if (args.increase && prevLeftIdx > this.parent.viewport.leftIndex) {
                    this.parent.viewport.leftIndex = prevLeftIdx;
                    return;
                }
                const frozenCol = this.parent.frozenColCount(sheet);
                if (!args.preventScroll) {
                    const frozenRow = this.parent.frozenRowCount(sheet);
                    const rowIndex = frozenRow ? getCellIndexes(sheet.topLeftCell)[0] : this.parent.viewport.topIndex;
                    let frozenIndexes = [];
                    if (frozenRow) {
                        frozenIndexes = [frozenRow + this.parent.viewport.topIndex, frozenCol];
                    }
                    if (idxDiff < this.parent.viewport.colCount + threshold) {
                        if (args.increase) {
                            startIdx = this.parent.viewport.rightIndex + 1;
                            endIdx = this.parent.viewport.rightIndex + (this.parent.viewport.leftIndex - prevLeftIdx);
                            endIdx -= this.hiddenCount(prevLeftIdx + frozenCol, this.parent.viewport.leftIndex - 1 + frozenCol, 'columns');
                            if (endIdx <= this.parent.viewport.rightIndex || (this.parent.scrollSettings.isFinite &&
                                startIdx > skipHiddenIdx(sheet, sheet.colCount - 1, false, 'columns'))) {
                                this.parent.viewport.leftIndex = prevLeftIdx;
                                return;
                            }
                            const indexes = this.parent.skipHidden(startIdx, endIdx, 'columns', false);
                            const finiteOffset = this.checkLastIdx(indexes[1], 'col');
                            startIdx = indexes[0];
                            endIdx = finiteOffset.index;
                            this.parent.viewport.leftIndex = skipHiddenIdx(sheet, (this.parent.viewport.leftIndex - finiteOffset.diff) + frozenCol, !finiteOffset.diff, 'columns') - frozenCol;
                            this.setThresholdWidth(width, idx - this.parent.viewport.leftIndex, frozenCol, !!finiteOffset.diff, prevLeftIdx === skipHiddenIdx(sheet, frozenCol, true, 'columns'));
                            this.parent.viewport.rightIndex = endIdx;
                            this.parent.renderModule.refreshUI({ rowIndex: rowIndex, colIndex: startIdx, direction: 'first', refresh: 'ColumnPart',
                                frozenIndexes: frozenIndexes }, this.getColAddress([startIdx, endIdx]));
                        }
                        else {
                            startIdx = skipHiddenIdx(sheet, this.parent.viewport.leftIndex + frozenCol, false, 'columns');
                            if (startIdx < frozenCol) {
                                startIdx = frozenCol;
                                startIdx = skipHiddenIdx(sheet, startIdx, true, 'columns');
                            }
                            this.parent.viewport.leftIndex = startIdx - frozenCol;
                            endIdx = skipHiddenIdx(sheet, (prevLeftIdx + frozenCol) - 1, false, 'columns');
                            if (endIdx < frozenCol || endIdx < startIdx) {
                                this.parent.viewport.leftIndex = prevLeftIdx;
                                return;
                            }
                            const rightIdx = this.skipHiddenLastIdx(this.parent.viewport.rightIndex - (((endIdx - startIdx) + 1) -
                                this.hiddenCount(startIdx, endIdx, 'columns')), this.parent.viewport.rightIndex, 'columns');
                            this.parent.viewport.rightIndex = skipHiddenIdx(sheet, rightIdx, false, 'columns');
                            this.setThresholdWidth(width, idx - this.parent.viewport.leftIndex, frozenCol);
                            this.parent.renderModule.refreshUI({ rowIndex: rowIndex, colIndex: startIdx, direction: 'last', refresh: 'ColumnPart',
                                frozenIndexes: frozenIndexes }, this.getColAddress([startIdx, endIdx]));
                        }
                    }
                    else {
                        prevLeftIdx = this.parent.viewport.topIndex;
                        this.parent.viewport.leftIndex = skipHiddenIdx(sheet, this.parent.viewport.leftIndex + frozenCol, false, 'columns')
                            - frozenCol;
                        if (this.parent.viewport.leftIndex < 0) {
                            this.parent.viewport.leftIndex = skipHiddenIdx(sheet, frozenCol, true, 'columns') - frozenCol;
                        }
                        this.parent.renderModule.refreshUI({
                            rowIndex: rowIndex, colIndex: this.parent.viewport.leftIndex, refresh: 'Column', frozenIndexes: frozenIndexes,
                            skipTranslate: true
                        });
                        if (frozenRow) {
                            this.parent.viewport.topIndex = prevLeftIdx;
                        }
                        this.setThresholdWidth(width, idx - this.parent.viewport.leftIndex, frozenCol, this.parent.scrollSettings.isFinite && this.parent.viewport.rightIndex ===
                            skipHiddenIdx(sheet, sheet.colCount - 1, false, 'columns'));
                        this.translate({ refresh: 'Column' });
                    }
                    this.updateScrollCount(idx, 'col', threshold);
                    this.focusSheet();
                }
                else {
                    this.setThresholdWidth(width, threshold, frozenCol);
                    this.translate({ refresh: 'Column' });
                }
            }
            args.prev.idx = idx;
        }
    }
    focusSheet() {
        if (!document.activeElement.classList.contains('e-text-findNext-short') || !closest(document.activeElement, '#' + this.parent.element.id)) {
            focus(this.parent.element);
        }
    }
    setThresholdHeight(scrollHeight, threshold, frozenRow, endReached, isInit) {
        const sheet = this.parent.getActiveSheet();
        const start = this.parent.viewport.topIndex + frozenRow;
        const end = (start + threshold) - 1;
        if (endReached || isInit || end < start) {
            this.translateY = start <= frozenRow ? 0 : getRowsHeight(sheet, frozenRow, start - 1, true);
        }
        else {
            this.translateY = scrollHeight - getRowsHeight(sheet, start, end, true);
        }
    }
    setThresholdWidth(scrollWidth, threshold, frozenCol, endReached, isInit) {
        const sheet = this.parent.getActiveSheet();
        const start = this.parent.viewport.leftIndex + frozenCol;
        const end = (start + threshold) - 1;
        if (endReached || isInit || end < start) {
            this.translateX = start <= frozenCol ? 0 : getColumnsWidth(sheet, frozenCol, start - 1, true);
        }
        else {
            this.translateX = scrollWidth - getColumnsWidth(sheet, start, end, true);
        }
    }
    translate(args) {
        if (args.skipTranslate || !this.content) {
            return;
        }
        let translateX = this.translateX || 0;
        translateX = this.parent.enableRtl ? -translateX : translateX;
        if (args.refresh === 'Row' || args.refresh === 'RowPart') {
            this.content.style.transform = `translate(${translateX}px, ${this.translateY}px)`;
            this.rowHeader.style.transform = `translate(0px, ${this.translateY}px)`;
        }
        if (args.refresh === 'Column' || args.refresh === 'ColumnPart') {
            this.content.style.transform = `translate(${translateX}px, ${this.translateY}px)`;
            this.colHeader.style.transform = `translate(${translateX}px, 0px)`;
        }
    }
    updateColumnWidth(args) {
        if (args.refresh === 'Column') {
            this.content.style.width = '';
            const sheet = this.parent.getActiveSheet();
            const width = getColumnsWidth(sheet, this.parent.viewport.leftIndex + this.parent.frozenColCount(sheet), this.parent.viewport.rightIndex, true);
            this.colHeader.style.width = width + 'px';
            this.content.style.width = width + 'px';
            if (!this.parent.scrollSettings.isFinite || args.isUpdate) {
                const scroll = this.parent.element.querySelector('.e-scroller .e-virtualtrack');
                if (!scroll) {
                    return;
                }
                const scrollWidth = parseInt(scroll.style.width, 10);
                const newWidth = width + this.translateX + this.parent.viewport.beforeFreezeWidth;
                if (newWidth > scrollWidth) {
                    const diff = newWidth - scrollWidth;
                    scroll.style.width = scrollWidth + diff + 'px';
                }
                else {
                    const diff = scrollWidth - newWidth;
                    const vTrack = this.parent.getMainContent().getElementsByClassName('e-virtualtrack')[0];
                    if (scrollWidth - diff < parseInt(vTrack.style.width, 10)) {
                        scroll.style.width = vTrack.style.width;
                    }
                }
            }
        }
        else if (!this.parent.scrollSettings.isFinite) {
            const vTrack = this.parent.getMainContent().getElementsByClassName('e-virtualtrack')[0];
            const vTrackHeight = parseInt(vTrack.style.height, 10);
            const height = this.content.getBoundingClientRect().height;
            const newHeight = height + this.translateY + this.parent.viewport.beforeFreezeHeight;
            if (newHeight > vTrackHeight) {
                const diff = newHeight - vTrackHeight;
                vTrack.style.height = vTrackHeight + diff + 'px';
            }
            else {
                const diff = vTrackHeight - newHeight;
                const hVTrack = this.parent.getRowHeaderContent().getElementsByClassName('e-virtualtrack')[0];
                if (vTrackHeight - diff < parseInt(hVTrack.style.height, 10)) {
                    vTrack.style.height = hVTrack.style.height;
                }
            }
        }
    }
    updateRowColCount(args) {
        if (!this.scroll.length) {
            return;
        }
        const sheet = this.parent.getActiveSheet();
        if (args.update === 'row') {
            if (args.index !== this.scroll[this.parent.activeSheetIndex].rowCount - 1) {
                const height = this.getVTrackHeight('height');
                let newHeight = height;
                if (args.index >= this.scroll[this.parent.activeSheetIndex].rowCount) {
                    if (args.start === undefined) {
                        newHeight += getRowsHeight(sheet, this.scroll[this.parent.activeSheetIndex].rowCount, args.index, true);
                    }
                    else {
                        newHeight += getRowsHeight(sheet, args.start, args.end, true);
                    }
                }
                else {
                    if (args.start === undefined) {
                        newHeight -= getRowsHeight(sheet, args.index + 1, this.scroll[this.parent.activeSheetIndex].rowCount - 1, true);
                    }
                    else {
                        newHeight -= getRowsHeight(sheet, args.start, args.end, true);
                    }
                }
                if (!args.isDelete && newHeight < height) {
                    return;
                }
                this.scroll[this.parent.activeSheetIndex].rowCount = args.index + 1;
                this.updateVTrack(this.rowHeader, newHeight, 'height');
                if (this.scroll[this.parent.activeSheetIndex].rowCount > sheet.rowCount) {
                    this.parent.setSheetPropertyOnMute(sheet, 'rowCount', this.scroll[this.parent.activeSheetIndex].rowCount);
                }
            }
        }
        else {
            if (args.index !== this.scroll[this.parent.activeSheetIndex].colCount - 1) {
                const width = this.getVTrackHeight('width');
                let newWidth = width;
                if (args.index >= this.scroll[this.parent.activeSheetIndex].colCount) {
                    if (args.start === undefined) {
                        newWidth += getColumnsWidth(sheet, this.scroll[this.parent.activeSheetIndex].colCount, args.index, true);
                    }
                    else {
                        newWidth += getColumnsWidth(sheet, args.start, args.end, true);
                    }
                }
                else {
                    if (args.start === undefined) {
                        newWidth -= getColumnsWidth(sheet, args.index + 1, this.scroll[this.parent.activeSheetIndex].colCount - 1, true);
                    }
                    else {
                        newWidth -= getColumnsWidth(sheet, args.start, args.end, true);
                    }
                }
                if (!args.isDelete && newWidth < width) {
                    return;
                }
                this.scroll[this.parent.activeSheetIndex].colCount = args.index + 1;
                this.updateVTrack(this.colHeader, newWidth, 'width');
                if (this.scroll[this.parent.activeSheetIndex].colCount > sheet.colCount) {
                    this.parent.setSheetPropertyOnMute(sheet, 'colCount', this.scroll[this.parent.activeSheetIndex].colCount);
                }
            }
        }
    }
    getVTrackHeight(str) {
        let height = this.content.nextElementSibling.style[`${str}`];
        if (height.includes('e+')) {
            height = height.split('px')[0];
            const heightArr = height.split('e+');
            return Number(heightArr[0]) * Math.pow(10, Number(heightArr[1]));
        }
        else {
            return parseFloat(height);
        }
    }
    updateVTrackHeight(args) {
        const frozenRow = this.parent.frozenRowCount(this.parent.getActiveSheet());
        if (args.rowIdx < this.scroll[this.parent.activeSheetIndex].rowCount) {
            this.updateVTrack(this.rowHeader, this.getVTrackHeight('height') + args.threshold, 'height');
        }
        if (args.rowIdx >= frozenRow && args.rowIdx < this.parent.scrollModule.offset.top.idx + frozenRow) {
            const mainPanel = this.parent.element.getElementsByClassName('e-main-panel')[0];
            if (mainPanel) {
                this.parent.scrollModule.prevScroll.scrollTop = mainPanel.scrollTop + args.threshold;
                mainPanel.scrollTop += args.threshold;
            }
            this.parent.scrollModule.offset.top.size += args.threshold;
            if (args.rowIdx < this.parent.viewport.topIndex + frozenRow) {
                this.translateY += args.threshold;
                this.translate({ refresh: 'Row' });
            }
        }
    }
    updateVTrackWidth(args) {
        if (isHiddenCol(this.parent.getActiveSheet(), args.colIdx)) {
            return;
        }
        const frozenCol = this.parent.frozenColCount(this.parent.getActiveSheet());
        if (args.colIdx >= this.parent.viewport.leftIndex + frozenCol && args.colIdx <= this.parent.viewport.rightIndex) {
            const hdrVTrack = this.parent.getColumnHeaderContent().getElementsByClassName('e-virtualtrack')[0];
            hdrVTrack.style.width = parseFloat(hdrVTrack.style.width) + args.threshold + 'px';
            const cntVTrack = this.parent.getMainContent().getElementsByClassName('e-virtualtrack')[0];
            cntVTrack.style.width = parseFloat(cntVTrack.style.width) + args.threshold + 'px';
            const scrollVTrack = this.parent.getScrollElement().getElementsByClassName('e-virtualtrack')[0];
            scrollVTrack.style.width = parseFloat(scrollVTrack.style.width) + args.threshold + 'px';
            const hdrColumn = this.parent.getColumnHeaderContent().getElementsByClassName('e-virtualable')[0];
            hdrColumn.style.width = parseFloat(hdrColumn.style.width) + args.threshold + 'px';
            const cntColumn = this.parent.getMainContent().getElementsByClassName('e-virtualable')[0];
            cntColumn.style.width = parseFloat(cntColumn.style.width) + args.threshold + 'px';
        }
        else if (args.colIdx >= frozenCol && args.colIdx < this.parent.viewport.leftIndex + frozenCol) {
            this.parent.scrollModule.offset.left.size += args.threshold;
            this.translateX += args.threshold;
            this.translate({ refresh: 'Column' });
        }
    }
    updateVTrack(header, size, sizeStr) {
        header.nextElementSibling.style[`${sizeStr}`] = `${size}px`;
        this.content.nextElementSibling.style[`${sizeStr}`] = `${size}px`;
        if (sizeStr === 'width' && this.parent.allowScrolling) {
            this.parent.getScrollElement().firstElementChild.style.width = `${size}px`;
        }
    }
    deInitProps() {
        this.parent.viewport.leftIndex = null;
        this.parent.viewport.topIndex = null;
        this.parent.viewport.bottomIndex = null;
        this.translateX = null;
        this.translateY = null;
    }
    updateScrollProps(args = { sheetIndex: 0, sheets: this.parent.sheets }) {
        if (this.scroll.length === 0) {
            this.initScroll();
        }
        else {
            args.sheets.forEach(() => { this.scroll.splice(args.sheetIndex, 0, { rowCount: 0, colCount: 0 }); });
        }
    }
    sliceScrollProps(args) {
        if (isNullOrUndefined(args.sheetIndex)) {
            this.scroll.length = 0;
        }
        else {
            this.scroll.splice(args.sheetIndex, 1);
        }
    }
    updateTranslate(args) {
        if (args.height) {
            if (args.isRender) {
                this.translateY -= args.height;
            }
            else {
                const height = parseInt(this.parent.getMainContent().getElementsByClassName('e-virtualtrack')[0].style.height, 10);
                if (args.isHide) {
                    this.updateVTrack(this.rowHeader, height - args.height, 'height');
                    this.setThresholdHeight(this.translateY, ((args.prevSize - 1) - this.parent.viewport.topIndex) + 1, this.parent.frozenRowCount(this.parent.getActiveSheet()));
                }
                else {
                    this.updateVTrack(this.rowHeader, height + args.height, 'height');
                    this.translateY = this.translateY + args.size;
                }
            }
            this.translate({ refresh: 'Row' });
        }
        if (args.width) {
            this.translateX -= args.width;
            this.translate({ refresh: 'Column' });
        }
    }
    addEventListener() {
        this.parent.on(beforeContentLoaded, this.createVirtualElement, this);
        this.parent.on(beforeVirtualContentLoaded, this.translate, this);
        this.parent.on(virtualContentLoaded, this.updateColumnWidth, this);
        this.parent.on(updateTableWidth, this.updateColumnWidth, this);
        this.parent.on(onVerticalScroll, this.onVerticalScroll, this);
        this.parent.on(onHorizontalScroll, this.onHorizontalScroll, this);
        this.parent.on(updateRowColCount, this.updateRowColCount, this);
        this.parent.on(rowHeightChanged, this.updateVTrackHeight, this);
        this.parent.on(colWidthChanged, this.updateVTrackWidth, this);
        this.parent.on(deInitProperties, this.deInitProps, this);
        this.parent.on(sheetsDestroyed, this.sliceScrollProps, this);
        this.parent.on(sheetCreated, this.updateScrollProps, this);
        this.parent.on(updateTranslate, this.updateTranslate, this);
        this.parent.on(spreadsheetDestroyed, this.destroy, this);
    }
    destroy() {
        this.removeEventListener();
        const noteIndicatorElement = document.querySelectorAll('.e-addNoteIndicator');
        if (noteIndicatorElement) {
            noteIndicatorElement.forEach((element) => {
                element.remove();
            });
        }
        if (this.rowHeader) {
            removeAllChildren(this.rowHeader);
            this.rowHeader.remove();
        }
        if (this.colHeader) {
            removeAllChildren(this.colHeader);
            this.colHeader.remove();
        }
        if (this.content) {
            removeAllChildren(this.content);
            this.content.remove();
        }
        this.rowHeader = null;
        this.colHeader = null;
        this.content = null;
        this.parent = null;
        this.scroll.length = 0;
        this.translateX = null;
        this.translateY = null;
    }
    removeEventListener() {
        this.parent.off(beforeContentLoaded, this.createVirtualElement);
        this.parent.off(beforeVirtualContentLoaded, this.translate);
        this.parent.off(virtualContentLoaded, this.updateColumnWidth);
        this.parent.off(updateTableWidth, this.updateColumnWidth);
        this.parent.off(onVerticalScroll, this.onVerticalScroll);
        this.parent.off(onHorizontalScroll, this.onHorizontalScroll);
        this.parent.off(updateRowColCount, this.updateRowColCount);
        this.parent.off(rowHeightChanged, this.updateVTrackHeight);
        this.parent.off(colWidthChanged, this.updateVTrackWidth);
        this.parent.off(sheetsDestroyed, this.sliceScrollProps);
        this.parent.off(sheetCreated, this.updateScrollProps);
        this.parent.off(updateTranslate, this.updateTranslate);
        this.parent.off(spreadsheetDestroyed, this.destroy);
    }
}

/**
 * Represents keyboard navigation support for Spreadsheet.
 */
class KeyboardNavigation {
    /**
     * Constructor for the Spreadsheet Keyboard Navigation module.
     *
     * @private
     * @param {Spreadsheet} parent - Specify the spreadsheet
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
        /* code snippet */
    }
    addEventListener() {
        this.parent.on(keyDown, this.keyDownHandler, this);
        /* code snippet */
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(keyDown, this.keyDownHandler);
        }
        /* code snippet */
    }
    keyDownHandler(e) {
        const target = e.target;
        const isRtl = this.parent.enableRtl;
        const isKeyboardShortcut = this.parent.enableKeyboardShortcut;
        if (e.altKey && (e.keyCode === 38 || e.keyCode === 40) && !isKeyboardShortcut) {
            e.preventDefault();
            return;
        }
        /*alt + up to close filter popup*/
        if (e.altKey && e.keyCode === 38 && this.parent.element.lastElementChild.classList.contains('e-filter-popup')) {
            this.parent.notify(filterCellKeyDown, { closePopup: true });
            return;
        }
        if (this.parent.allowPrint && e.ctrlKey && e.keyCode === 80 && isKeyboardShortcut) {
            e.preventDefault();
            this.parent.print();
            return;
        }
        const textarea = e.target;
        if (!isNullOrUndefined(textarea) && textarea.classList.contains('e-addNoteContainer')) {
            if (e.key === 'Escape' || e.keyCode === 27) {
                const isNoteCellIndex = !isNullOrUndefined(this.parent.spreadsheetNoteModule.noteCellIndexes);
                const cellIndexes = isNoteCellIndex ? this.parent.spreadsheetNoteModule.noteCellIndexes :
                    getCellIndexes(this.parent.getActiveSheet().activeCell);
                const cell = getCell(cellIndexes[0], cellIndexes[1], this.parent.getActiveSheet());
                const targetElement = this.parent.getCell(cellIndexes[0], cellIndexes[1]);
                const address = getSheetName(this.parent, this.parent.activeSheetIndex) + '!' + getRangeAddress(cellIndexes);
                if (!isNullOrUndefined(textarea) && !isNullOrUndefined(textarea.value)
                    && ((isNullOrUndefined(cell) || isNullOrUndefined(cell.notes)) || (cell.notes !== textarea.value))
                    && document.activeElement.className.indexOf('e-addNoteContainer') > -1) {
                    const eventAction = !isNullOrUndefined(cell) && cell.notes ? 'editNote' : 'addNote';
                    this.parent.notify(setActionData, { args: { action: 'beforeCellSave', eventArgs: { address: address } } });
                    updateCell(this.parent, this.parent.getActiveSheet(), { rowIdx: cellIndexes[0], colIdx: cellIndexes[1], preventEvt: true,
                        cell: { notes: textarea.value, isNoteEditable: false } });
                    const eventArgs = { notes: textarea.value, address: address };
                    this.parent.notify(completeAction, { eventArgs: eventArgs, action: eventAction });
                }
                this.parent.spreadsheetNoteModule.isShowNote = null;
                this.parent.notify(removeNoteContainer, '');
                focus(targetElement);
            }
            return;
        }
        const dlgInst = this.parent.serviceLocator.getService(dialog).dialogInstance;
        const isNameBox = target.id === `${this.parent.element.id}_name_box`;
        if (this.parent.selectionSettings.mode === 'None' || dlgInst || this.parent.isEdit || (target.classList.contains('e-ss-ddb') &&
            e.keyCode !== 117 && e.keyCode !== 9) || (isNameBox && e.keyCode !== 117) || target.classList.contains('e-sheet-rename') ||
            target.id === `${this.parent.element.id}_SearchBox` || target.classList.contains('e-chk-hidden') || (target.classList.contains('e-ddl') &&
            target.classList.contains('e-input-focus'))) {
            if (dlgInst) {
                if (e.keyCode === 13) {
                    if (dlgInst.element.classList.contains('e-spreadsheet-function-dlg') &&
                        (target.classList.contains('e-formula-list') || target.classList.contains('e-list-item'))) {
                        focus(dlgInst.element.querySelector('.e-footer-content .e-primary'));
                    }
                }
                else if (e.keyCode === 9) { // To maintain the focus inside the dialogs on the tab or shift + tab key
                    if (dlgInst.element.classList.contains('e-find-dlg')) {
                        const footerBtns = dlgInst.element.querySelectorAll('.e-footer-content .e-btn:not(:disabled)');
                        const cls = footerBtns.length ? footerBtns[footerBtns.length - 1].className :
                            'e-findnreplace-checkmatch';
                        if (e.shiftKey) {
                            if (document.activeElement.classList.contains('e-dlg-closeicon-btn')) {
                                e.preventDefault();
                                if (footerBtns.length) {
                                    focus(footerBtns[footerBtns.length - 1]);
                                }
                                else {
                                    const cBoxWrapper = dlgInst.element.querySelector('.e-findnreplace-exactmatchcheckbox');
                                    if (cBoxWrapper) {
                                        focus(cBoxWrapper.querySelector('.e-findnreplace-checkmatch'));
                                        cBoxWrapper.classList.add('e-focus');
                                    }
                                }
                            }
                        }
                        else if (document.activeElement.className.includes(cls)) {
                            focus(dlgInst.element);
                        }
                    }
                    else if (dlgInst.element.classList.contains('e-protect-dlg')) {
                        if (e.shiftKey ? document.activeElement.classList.contains('e-primary') :
                            document.activeElement.id === `${this.parent.element.id}_protect_check`) {
                            const listWrapper = dlgInst.element.querySelector('.e-protect-option-list');
                            if (listWrapper && !listWrapper.querySelector('.e-list-item.e-focused')) {
                                const listEle = listWrapper.querySelector('.e-list-item');
                                if (listEle) {
                                    listEle.classList.add('e-focused');
                                }
                            }
                        }
                    }
                    else if (dlgInst.element.classList.contains('e-custom-format-dlg')) {
                        if (!e.shiftKey) {
                            if (document.activeElement.classList.contains('e-btn') &&
                                document.activeElement.parentElement.classList.contains('e-custom-dialog')) {
                                const listWrapper = dlgInst.element.querySelector('.e-custom-listview');
                                const listObj = getComponent(listWrapper, 'listview');
                                if (listWrapper) {
                                    let listEle = listWrapper.querySelector('.e-list-item.e-active');
                                    if (!listEle) {
                                        listEle = listWrapper.querySelector('.e-list-item');
                                        if (listEle) {
                                            listObj.selectItem(listEle);
                                        }
                                        else {
                                            return;
                                        }
                                    }
                                    e.preventDefault();
                                    listEle.focus();
                                }
                            }
                            else if (document.activeElement.classList.contains('e-list-item')) {
                                focus(dlgInst.element);
                            }
                        }
                        else if (document.activeElement.className.includes('e-list-item e-active')) {
                            const listWrapper = closest(document.activeElement, '.e-custom-listview');
                            if (listWrapper) {
                                focus(listWrapper);
                            }
                        }
                    }
                    else if (dlgInst.element.classList.contains('e-spreadsheet-function-dlg')) {
                        if (e.shiftKey && document.activeElement.className.includes('e-list-item e-active')) {
                            const listWrapper = closest(document.activeElement, '.e-formula-list');
                            if (listWrapper) {
                                focus(listWrapper);
                            }
                        }
                    }
                    else if (dlgInst.element.classList.contains('e-goto-dlg') && !dlgInst.element.classList.contains('e-dlg-modal')) {
                        if (e.shiftKey) {
                            if (document.activeElement.className.includes('e-dlg-closeicon-btn')) {
                                const footerOkBtn = dlgInst.element.querySelector('.e-footer-content .e-btn');
                                if (footerOkBtn) {
                                    e.preventDefault();
                                    focus(footerOkBtn);
                                }
                            }
                        }
                        else if (document.activeElement.className.includes('e-btn-goto-ok')) {
                            focus(dlgInst.element);
                        }
                    }
                }
            }
            else if (isNameBox && e.keyCode === 9 && e.shiftKey) {
                this.focusEle(e, '.e-formula-bar', false, true);
            }
            const eventArgs = { action: 'getCurrentEditValue', editedValue: '' };
            this.parent.notify(editOperation, eventArgs);
            const isFormulaEdit = checkIsFormula(eventArgs.editedValue, true);
            if (this.parent.isEdit && isFormulaEdit && e.shiftKey && !e.ctrlKey && isNavigationKey(e.keyCode)) {
                this.shiftSelection(e);
            }
            return;
        }
        const sheet = this.parent.getActiveSheet();
        const actIdxes = getCellIndexes(sheet.activeCell);
        if (e.altKey) {
            if (e.keyCode === 40) {
                if (target.classList.contains('e-dropdown-btn') || target.classList.contains('e-split-btn')) {
                    return;
                }
                const filterArgs = { e: e, isFilterCell: false };
                this.parent.notify(filterCellKeyDown, filterArgs);
                if (filterArgs.isFilterCell) { /*alt + down to open filter popup*/
                    return;
                }
            }
            if (e.keyCode === 40 && !document.getElementById(this.parent.element.id + 'listValid_popup')) {
                const cell = this.parent.getCell(actIdxes[0], actIdxes[1]);
                if (cell) {
                    const listValidation = cell.querySelector('.e-validation-list .e-ddl');
                    if (listValidation) {
                        focus(listValidation);
                        const ddlEle = listValidation.querySelector('.e-dropdownlist') || listValidation;
                        const listObj = getComponent(ddlEle, 'dropdownlist');
                        if (listObj) {
                            listObj.showPopup();
                        }
                        return;
                    }
                }
            }
        }
        if (target.id === `${this.parent.element.id}_File`) {
            focus(this.parent.element);
        }
        const isSheetTabFocus = target.classList.contains('e-add-sheet-tab') || target.classList.contains('e-sheets-list') ||
            (target.classList.contains('e-tab-wrap') && !!closest(target, '.e-sheet-tabs-items')) ||
            target.classList.contains('e-aggregate-list') || target.classList.contains('e-scroll-nav');
        if ([9, 37, 38, 39, 40, 33, 34, 35, 36].indexOf(e.keyCode) > -1 && !isSheetTabFocus) {
            e.preventDefault();
        }
        let isNavigate;
        const selectIdx = getRangeIndexes(sheet.selectedRange);
        if (e.keyCode === 36) { /* home key */
            const frozenCol = this.parent.frozenColCount(sheet);
            let selectIdxes;
            if (e.ctrlKey || e.metaKey) {
                const frozenRow = skipHiddenIdx(sheet, this.parent.frozenRowCount(sheet), true);
                if (e.shiftKey) { /* ctrl+shift+home */
                    selectIdxes = [actIdxes[0], actIdxes[1], frozenRow, skipHiddenIdx(sheet, frozenCol, true, 'columns')];
                }
                else { /* ctrl+home */
                    selectIdxes = [frozenRow, skipHiddenIdx(sheet, frozenCol, true, 'columns'), frozenRow];
                    selectIdxes[3] = selectIdxes[1];
                }
                const mainPanel = this.parent.element.querySelector('.e-main-panel');
                if (mainPanel.scrollTop) {
                    mainPanel.scrollTop = 0;
                }
                const hCont = this.parent.getScrollElement();
                if (hCont.scrollLeft) {
                    hCont.scrollLeft = 0;
                }
            }
            else if (e.shiftKey) { /* shift+home */
                const startCol = skipHiddenIdx(sheet, frozenCol, true, 'columns');
                if (sheet.frozenColumns && skipHiddenIdx(sheet, actIdxes[1], true, 'columns') === startCol) {
                    selectIdxes = [selectIdx[0], actIdxes[1], selectIdx[2], skipHiddenIdx(sheet, 0, true, 'columns')];
                }
                else {
                    selectIdxes = [selectIdx[0], actIdxes[1], selectIdx[2], startCol];
                }
                this.scrollNavigation([selectIdxes[2], selectIdxes[3]], true);
            }
            else {
                let startCol = skipHiddenIdx(sheet, frozenCol, true, 'columns');
                if (sheet.frozenColumns && (startCol === actIdxes[1] || frozenCol === actIdxes[1])) {
                    startCol = skipHiddenIdx(sheet, 0, true, 'columns');
                }
                selectIdxes = [actIdxes[0], startCol, actIdxes[0], startCol];
                this.scrollNavigation([selectIdxes[0], selectIdxes[1]], true);
            }
            this.updateSelection(sheet, selectIdxes, e);
        }
        else if (e.ctrlKey || e.metaKey) {
            if (e.keyCode === 35) { /*ctrl + end*/
                e.preventDefault();
                let lastRow = skipHiddenIdx(sheet, sheet.usedRange.rowIndex, false);
                lastRow = lastRow > -1 ? lastRow : sheet.usedRange.rowIndex;
                let lastCol = skipHiddenIdx(sheet, sheet.usedRange.colIndex, false, 'columns');
                lastCol = lastCol > -1 ? lastCol : sheet.usedRange.colIndex;
                if (!e.shiftKey) {
                    actIdxes[0] = lastRow;
                    actIdxes[1] = lastCol;
                }
                actIdxes[2] = lastRow;
                actIdxes[3] = lastCol;
                this.updateSelection(sheet, actIdxes.concat(actIdxes), e);
                this.scrollNavigation([lastRow, lastCol], true);
            }
            else if (e.keyCode === 32 && !e.shiftKey && isKeyboardShortcut) { /*ctrl + space*/
                selectIdx[0] = 0;
                selectIdx[2] = sheet.rowCount - 1;
                this.updateSelection(sheet, selectIdx, { shiftKey: true });
            }
            if (e.keyCode === 40 || e.keyCode === 39 || e.keyCode === 38 || e.keyCode === 37) {
                if (e.shiftKey) {
                    if (e.keyCode === 40) { /* ctrl+shift+down */
                        selectIdx[2] = this.getNextNonEmptyCell(selectIdx[2], actIdxes[1], 'down');
                    }
                    else if ((e.keyCode === 39 && !isRtl) || (e.keyCode === 37 && isRtl)) { /* ctrl+shift+right */
                        selectIdx[3] = this.getNextNonEmptyCell(actIdxes[0], selectIdx[3], 'right');
                    }
                    else if (e.keyCode === 38) { /* ctrl+shift+up */
                        selectIdx[2] = this.getNextNonEmptyCell(selectIdx[2], actIdxes[1], 'top');
                    }
                    else { /* ctrl+shift+left */
                        selectIdx[3] = this.getNextNonEmptyCell(actIdxes[0], selectIdx[3], 'left');
                    }
                    this.updateSelection(sheet, selectIdx, e);
                    this.scrollNavigation([selectIdx[2], selectIdx[3]], true);
                }
                else {
                    if ((e.keyCode === 37 && !isRtl) || (e.keyCode === 39 && isRtl)) { /*ctrl + left*/
                        actIdxes[1] = this.getNextNonEmptyCell(actIdxes[0], actIdxes[1], 'left');
                    }
                    else if (e.keyCode === 38) { /*ctrl + up*/
                        actIdxes[0] = this.getNextNonEmptyCell(actIdxes[0], actIdxes[1], 'top');
                    }
                    else if ((e.keyCode === 39 && !isRtl) || (e.keyCode === 37 && isRtl)) { /*ctrl+ right*/
                        actIdxes[1] = this.getNextNonEmptyCell(actIdxes[0], actIdxes[1], 'right');
                    }
                    else { /*ctrl+ down*/
                        actIdxes[0] = this.getNextNonEmptyCell(actIdxes[0], actIdxes[1], 'down');
                    }
                    this.parent.selectRange(getRangeAddress(actIdxes));
                    this.scrollNavigation([actIdxes[0], actIdxes[1]], true);
                }
            }
            else if (e.keyCode === 117) {
                const activeEle = document.activeElement;
                if (activeEle.classList.contains('e-spreadsheet') || closest(activeEle, '.e-sheet')) {
                    this.setFocus('Sheet', e, true);
                }
                else if (isSheetTabFocus) {
                    this.setFocus('SheetTabs', e);
                }
                else if (closest(activeEle, '.e-ribbon')) {
                    this.setFocus('Ribbon', e);
                }
                else if (isNameBox || activeEle.classList.contains('e-insert-function')) {
                    this.setFocus('FormulaBar', e);
                }
            }
        }
        else {
            if (e.shiftKey) {
                if (e.keyCode === 32 && isKeyboardShortcut) { /*shift + space*/
                    e.preventDefault();
                    selectIdx[1] = 0;
                    selectIdx[3] = sheet.colCount - 1;
                    this.updateSelection(sheet, selectIdx, e);
                }
                this.shiftSelection(e);
                if ((e.keyCode === 34 || e.keyCode === 33) && (this.parent.scrollModule &&
                    this.parent.scrollModule.isKeyScroll)) { /* shift Page Up and Page Down*/
                    let scrollTop = 0;
                    const mainPanel = this.parent.element.querySelector('.e-main-panel');
                    const topRow = skipHiddenIdx(sheet, getCellIndexes(sheet.paneTopLeftCell)[0], true);
                    const viewportHgt = getBottomOffset(this.parent, topRow).height;
                    if (e.keyCode === 34) { /* Page Down*/
                        scrollTop = viewportHgt + this.parent.scrollModule.offset.top.size;
                        if (!this.parent.scrollSettings.isFinite) {
                            const vTrack = this.parent.getMainContent().querySelector('.e-virtualtrack');
                            if (vTrack && parseFloat(vTrack.style.height) < scrollTop + viewportHgt) {
                                vTrack.style.height = `${scrollTop + viewportHgt}px`;
                            }
                        }
                    }
                    else { /* Page up*/
                        scrollTop = this.parent.scrollModule.offset.top.size - viewportHgt;
                        if (Math.round(scrollTop) < 0) {
                            if (mainPanel.scrollTop) {
                                scrollTop = 0;
                            }
                            else {
                                this.parent.selectRange(getRangeAddress([selectIdx[0], selectIdx[1], topRow, selectIdx[3]]));
                                return;
                            }
                        }
                    }
                    const aRowIdx = skipHiddenIdx(sheet, getRangeIndexes(sheet.selectedRange)[2], true);
                    const selectDiff = topRow > aRowIdx ? 0 : aRowIdx - topRow;
                    if (this.parent.scrollModule && mainPanel.scrollTop) {
                        this.parent.scrollModule.isKeyScroll = false;
                    }
                    mainPanel.scrollTop = scrollTop;
                    getUpdateUsingRaf(() => {
                        if (e.keyCode === 34) {
                            selectIdx[2] = skipHiddenIdx(sheet, getCellIndexes(sheet.paneTopLeftCell)[0] + selectDiff, true);
                            if (this.parent.scrollSettings.isFinite && selectIdx[2] > sheet.rowCount - 1) {
                                selectIdx[2] = skipHiddenIdx(sheet, sheet.rowCount - 1, false);
                                selectIdx[2] = selectIdx[2] < 0 ? 0 : selectIdx[2];
                            }
                        }
                        else {
                            selectIdx[2] = skipHiddenIdx(sheet, getCellIndexes(sheet.paneTopLeftCell)[0] + selectDiff, false);
                            selectIdx[2] = selectIdx[2] < 0 ? 0 : selectIdx[2];
                        }
                        this.updateSelection(sheet, selectIdx, e);
                    });
                }
            }
            else {
                if (e.keyCode === 9 || (this.parent.enableRtl ? e.keyCode === 37 : e.keyCode === 39)) { /*Right or Tab key*/
                    const cell = getCell(actIdxes[0], actIdxes[1], sheet);
                    if (cell && cell.colSpan > 1) {
                        actIdxes[1] += (cell.colSpan - 1);
                    }
                    if (actIdxes[1] < sheet.colCount - 1 && (!sheet.isProtected || sheet.protectSettings.selectCells)) {
                        actIdxes[1] += 1;
                        isNavigate = true;
                    }
                    else if (sheet.protectSettings.selectUnLockedCells) {
                        const idx = this.getNextUnlockedCell('right', actIdxes);
                        isNavigate = actIdxes[1] !== idx[1] || actIdxes[0] !== idx[0];
                        actIdxes[1] = idx[1];
                        actIdxes[0] = idx[0];
                    }
                }
                else if (e.keyCode === 13 || e.keyCode === 40) { /*Down or Enter Key*/
                    const cell = getCell(actIdxes[0], actIdxes[1], sheet);
                    if (cell && cell.rowSpan > 1) {
                        actIdxes[0] += (cell.rowSpan - 1);
                    }
                    if (actIdxes[0] < sheet.rowCount - 1 && (!sheet.isProtected || sheet.protectSettings.selectCells)) {
                        isNavigate = true;
                        actIdxes[0] += 1;
                    }
                    else if (sheet.protectSettings.selectUnLockedCells) {
                        const idx = this.getNextUnlockedCell('down', actIdxes);
                        isNavigate = actIdxes[0] !== idx[0] || actIdxes[1] !== idx[1];
                        actIdxes[1] = idx[1];
                        actIdxes[0] = idx[0];
                    }
                }
                else if ((e.keyCode === 34 || e.keyCode === 33) && (this.parent.scrollModule &&
                    this.parent.scrollModule.isKeyScroll)) { /*Page Up and Page Down*/
                    const mainPanel = this.parent.element.querySelector('.e-main-panel');
                    let scrollTop = 0;
                    const topRow = skipHiddenIdx(sheet, getCellIndexes(sheet.paneTopLeftCell)[0], true);
                    const aRowIdx = skipHiddenIdx(sheet, getCellIndexes(sheet.activeCell)[0], true);
                    const viewportHgt = getBottomOffset(this.parent, topRow).height;
                    if (e.keyCode === 34) { /*Page Down*/
                        scrollTop = this.parent.scrollModule.offset.top.size + viewportHgt;
                        if (!this.parent.scrollSettings.isFinite) {
                            const vTrack = this.parent.getMainContent().querySelector('.e-virtualtrack');
                            if (vTrack && parseFloat(vTrack.style.height) < scrollTop + viewportHgt) {
                                vTrack.style.height = `${scrollTop + viewportHgt}px`;
                            }
                        }
                    }
                    else { /*Page Up*/
                        scrollTop = this.parent.scrollModule.offset.top.size - viewportHgt;
                        if (sheet.frozenRows && actIdxes[0] < this.parent.frozenRowCount(sheet)) {
                            this.parent.selectRange(getRangeAddress([topRow, selectIdx[1], topRow, selectIdx[1]]));
                            return;
                        }
                        if (Math.round(scrollTop) < 0) {
                            if (mainPanel.scrollTop) {
                                scrollTop = 0;
                            }
                            else {
                                return;
                            }
                        }
                    }
                    const selectDiff = topRow > aRowIdx ? 0 : aRowIdx - topRow;
                    if (this.parent.scrollModule && mainPanel.scrollTop) {
                        this.parent.scrollModule.isKeyScroll = false;
                    }
                    mainPanel.scrollTop = scrollTop;
                    getUpdateUsingRaf(() => {
                        let activeRow;
                        if (e.keyCode === 34) {
                            activeRow = skipHiddenIdx(sheet, getCellIndexes(sheet.paneTopLeftCell)[0] + selectDiff, true);
                            if (this.parent.scrollSettings.isFinite) {
                                if (activeRow > sheet.rowCount - 1) {
                                    activeRow = skipHiddenIdx(sheet, sheet.rowCount - 1, false);
                                    activeRow = activeRow < 0 ? 0 : activeRow;
                                }
                            }
                        }
                        else {
                            activeRow = getCellIndexes(sheet.paneTopLeftCell)[0] + selectDiff;
                            activeRow -= this.parent.hiddenCount(topRow, aRowIdx);
                            activeRow = skipHiddenIdx(sheet, activeRow, false);
                            activeRow = activeRow < 0 ? 0 : activeRow;
                        }
                        this.parent.notify(cellNavigate, { range: [activeRow, actIdxes[1], activeRow, actIdxes[1]], preventAnimation: true });
                    });
                }
            }
            if (e.shiftKey ? e.keyCode === 9 : (this.parent.enableRtl ? e.keyCode === 39 : e.keyCode === 37)) { /*left or shift+tab key*/
                if (actIdxes[1] > 0 && (!sheet.isProtected || sheet.protectSettings.selectCells)) {
                    actIdxes[1] -= 1;
                    isNavigate = true;
                }
                else if (sheet.protectSettings.selectUnLockedCells) {
                    const idx = this.getNextUnlockedCell('left', actIdxes);
                    isNavigate = actIdxes[1] !== idx[1] || actIdxes[0] !== idx[0];
                    actIdxes[1] = idx[1];
                    actIdxes[0] = idx[0];
                }
                if (actIdxes[1] <= 0) {
                    const content = this.parent.getMainContent();
                    if (actIdxes[1] === 0 && content.scrollLeft && !this.parent.enableRtl) {
                        content.scrollLeft = 0;
                    }
                }
            }
            else if (e.shiftKey ? e.keyCode === 13 : e.keyCode === 38) { /*up or shift+enter key */
                if (!this.parent.element.querySelector('.e-find-toolbar')) {
                    if (actIdxes[0] > 0 && (!sheet.isProtected || sheet.protectSettings.selectCells)) {
                        actIdxes[0] -= 1;
                        isNavigate = true;
                    }
                    else if (sheet.protectSettings.selectUnLockedCells) {
                        const cellIdx = this.getNextUnlockedCell('up', actIdxes);
                        isNavigate = actIdxes[0] !== cellIdx[0] || actIdxes[1] !== cellIdx[1];
                        actIdxes[1] = cellIdx[1];
                        actIdxes[0] = cellIdx[0];
                    }
                    if (actIdxes[0] <= 0) {
                        const contentEle = this.parent.getMainContent().parentElement;
                        if (actIdxes[0] === 0 && contentEle.scrollTop) {
                            contentEle.scrollTop = 0;
                        }
                    }
                }
            }
        }
        if (isNavigate && (!this.parent.scrollModule || this.parent.scrollModule.isKeyScroll) && !isSheetTabFocus &&
            !closest(document.activeElement, '.e-ribbon') && !target.classList.contains('e-insert-function')
            && (!target.classList.contains('e-formula-bar') || (target.classList.contains('e-formula-bar') && target.nodeName === 'TEXTAREA' && e.keyCode === 13))) {
            if (e.keyCode === 40 || e.keyCode === 38 || e.keyCode === 13) { /* down || up */
                while (isHiddenRow(sheet, actIdxes[0])) {
                    if (e.keyCode === 40 || (!e.shiftKey && e.keyCode === 13)) {
                        actIdxes[0] = actIdxes[0] + 1;
                    }
                    if (e.keyCode === 38 || (e.shiftKey && e.keyCode === 13)) {
                        actIdxes[0] = actIdxes[0] - 1;
                        if (actIdxes[0] < 0) {
                            return;
                        }
                    }
                }
            }
            if (e.keyCode === 37 || e.keyCode === 39 || e.keyCode === 9) { /* left || right || tab */
                while (isHiddenCol(sheet, actIdxes[1])) {
                    if (e.keyCode === 39 || (!e.shiftKey && e.keyCode === 9)) {
                        actIdxes[1] = actIdxes[1] + 1;
                    }
                    if (e.keyCode === 37 || (e.shiftKey && e.keyCode === 9)) {
                        actIdxes[1] = actIdxes[1] - 1;
                        if (actIdxes[1] < 0) {
                            return;
                        }
                    }
                }
            }
            const topLeftIdx = getRangeIndexes(sheet.topLeftCell);
            if (sheet.frozenRows && actIdxes[0] < topLeftIdx[0]) {
                actIdxes[0] = skipHiddenIdx(sheet, topLeftIdx[0], true);
            }
            if (sheet.frozenColumns && actIdxes[1] < topLeftIdx[1]) {
                actIdxes[1] = skipHiddenIdx(sheet, topLeftIdx[1], true, 'columns');
            }
            this.scrollNavigation(actIdxes);
            const range = getRangeAddress(actIdxes);
            const navigateFn = (preventAnimation) => {
                if (range === sheet.selectedRange) {
                    return;
                }
                this.parent.selectionModule.previousActiveCell = sheet.activeCell;
                if (document.getElementsByClassName('e-addNoteContainer') && document.getElementsByClassName('e-addNoteContainer').length > 0) {
                    this.parent.notify(removeNoteContainer, '');
                }
                this.parent.setSheetPropertyOnMute(sheet, 'activeCell', range);
                this.parent.notify(cellNavigate, { range: actIdxes.concat(actIdxes), preventAnimation: preventAnimation });
                let ele;
                if (Browser.isDevice && Browser.info.name === 'safari' && (Browser.isIos || Browser.isIos7)) {
                    ele = this.parent.element.querySelector('.e-ss-focus-edit');
                }
                ele = ele || this.parent.getCell(actIdxes[0], actIdxes[1]);
                if (ele) {
                    focus(ele);
                }
            };
            if (this.parent.scrollModule && this.parent.scrollModule.isKeyScroll) {
                if (range === sheet.selectedRange) {
                    return;
                }
                getUpdateUsingRaf(navigateFn.bind(this, true));
            }
            else {
                navigateFn();
            }
        }
        else if (e.keyCode === 9) {
            const ribbon = this.parent.showRibbon && closest(document.activeElement, '.e-ribbon');
            if (ribbon) {
                if (closest(document.activeElement, '.e-tab-header')) {
                    if (e.shiftKey || ribbon.classList.contains('e-collapsed')) {
                        this.focusEle(e, '.e-ribbon .e-drop-icon');
                    }
                    else {
                        this.focusEle(e, '.e-ribbon .e-content .e-toolbar-item:not(.e-separator):not(.e-overlay):not(.e-hide) .e-btn');
                    }
                }
                else if (closest(document.activeElement, '.e-content')) {
                    if (e.shiftKey) {
                        this.focusEle(e, '.e-ribbon .e-toolbar-items .e-toolbar-item.e-active .e-tab-wrap', true);
                    }
                    else {
                        this.focusEle(e, '.e-ribbon .e-drop-icon');
                    }
                }
                else if (document.activeElement.classList.contains('e-drop-icon')) {
                    if (e.shiftKey && !ribbon.classList.contains('e-collapsed')) {
                        this.focusEle(e, '.e-ribbon .e-content .e-toolbar-item:not(.e-separator):not(.e-overlay):not(.e-hide) .e-btn');
                    }
                    else {
                        this.focusEle(e, '.e-ribbon .e-toolbar-items .e-toolbar-item.e-active .e-tab-wrap', true);
                    }
                }
            }
            else if (target.classList.contains('e-insert-function')) {
                if (e.shiftKey) {
                    this.focusEle(e, '.e-formula-bar-panel .e-combobox');
                }
                else {
                    this.focusEle(e, '.e-formula-bar', false, true);
                }
            }
            else if (isSheetTabFocus) {
                if (e.shiftKey) {
                    const isNavOrAggregate = target.classList.contains('e-aggregate-list') || target.classList.contains('e-scroll-left-nav');
                    if (target.classList.contains('e-add-sheet-tab') || isNavOrAggregate || (target.classList.contains('e-sheets-list') &&
                        target.previousElementSibling && target.previousElementSibling.disabled)) {
                        const focusEle = !isNavOrAggregate && this.parent.element.querySelector('.e-aggregate-list');
                        if (focusEle) {
                            this.focusEle(e, null, false, false, focusEle);
                        }
                        else if (!target.classList.contains('e-scroll-left-nav') && this.parent.element.querySelector('.e-sheet-tab-panel .e-scroll-nav')) {
                            this.focusEle(e, '.e-sheet-tab-panel .e-scroll-right-nav', true);
                        }
                        else {
                            const items = [].slice.call(this.parent.element.querySelectorAll('.e-sheet-tab-panel .e-toolbar-item'));
                            if (items[items.length - 1]) {
                                this.focusEle(e, null, true, false, items[items.length - 1].querySelector('.e-tab-wrap'));
                            }
                        }
                    }
                    else if (target.classList.contains('e-scroll-right-nav')) {
                        this.focusEle(e, '.e-sheet-tab-panel .e-scroll-left-nav', true);
                    }
                    else if (target.classList.contains('e-tab-wrap')) {
                        const items = [].slice.call(this.parent.element.querySelectorAll('.e-sheet-tab-panel .e-toolbar-item'));
                        const idx = items.indexOf(target.parentElement);
                        if (idx === 0) {
                            this.focusEle(e, '.e-sheet-tab-panel .e-sheets-list');
                        }
                        else {
                            this.focusEle(e, null, true, false, items[idx - 1].querySelector('.e-tab-wrap'));
                        }
                    }
                }
                else {
                    const isAggAvail = !!this.parent.element.querySelector('.e-aggregate-list');
                    if (target.classList.contains('e-aggregate-list') || (!isAggAvail && target.classList.contains('e-scroll-right-nav'))) {
                        this.focusEle(e, '.e-sheet-tab-panel .e-icon-btn:not(:disabled)');
                    }
                    else if (target.classList.contains('e-sheets-list')) {
                        this.focusEle(e, '.e-sheet-tab-panel .e-toolbar-item .e-tab-wrap', true);
                    }
                    else if (target.classList.contains('e-scroll-left-nav')) {
                        this.focusEle(e, '.e-sheet-tab-panel .e-scroll-right-nav', true);
                    }
                    else if (target.classList.contains('e-tab-wrap')) {
                        const items = [].slice.call(this.parent.element.querySelectorAll('.e-sheet-tab-panel .e-toolbar-item'));
                        const index = items.indexOf(target.parentElement);
                        if (index === items.length - 1) {
                            const isNav = !!this.parent.element.querySelector('.e-sheet-tab-panel .e-scroll-nav');
                            if (isNav || !isAggAvail) {
                                this.focusEle(e, `.e-sheet-tab-panel .${isNav ? 'e-scroll-nav' : 'e-icon-btn:not(:disabled)'}`, isNav);
                            }
                        }
                        else {
                            this.focusEle(e, null, true, false, items[index + 1].querySelector('.e-tab-wrap'));
                        }
                    }
                }
            }
        }
        if (e.keyCode === 121 && e.shiftKey && !this.parent.enableKeyboardShortcut) { /*Shift + F10*/
            e.preventDefault();
        }
    }
    setFocus(layout, e, isSheetArea) {
        if (layout === 'Sheet') {
            if (e.shiftKey) {
                if (this.parent.showFormulaBar) {
                    this.focusEle(e, '.e-formula-bar-panel .e-combobox');
                }
                else {
                    this.setFocus('FormulaBar', e, isSheetArea);
                }
            }
            else {
                if (this.parent.showSheetTabs) {
                    this.focusEle(e, '.e-sheet-tab-panel .e-icon-btn:not(:disabled)');
                }
                else {
                    this.setFocus('SheetTabs', e, isSheetArea);
                }
            }
        }
        else if (layout === 'SheetTabs') {
            if (e.shiftKey) {
                if (!isSheetArea) {
                    this.focusEle(e, '.e-selectall');
                }
            }
            else {
                if (this.parent.showRibbon) {
                    this.focusEle(e, '.e-ribbon .e-toolbar-items .e-toolbar-item.e-active .e-tab-wrap', true);
                }
                else {
                    this.setFocus('Ribbon', e, isSheetArea);
                }
            }
        }
        else if (layout === 'Ribbon') {
            if (e.shiftKey) {
                if (this.parent.showSheetTabs) {
                    this.focusEle(e, '.e-sheet-tab-panel .e-icon-btn:not(:disabled)');
                }
                else if (!isSheetArea) {
                    this.focusEle(e, '.e-selectall');
                }
            }
            else {
                if (this.parent.showFormulaBar) {
                    this.focusEle(e, '.e-formula-bar-panel .e-combobox');
                }
                else {
                    this.setFocus('FormulaBar', e, isSheetArea);
                }
            }
        }
        else if (layout === 'FormulaBar') {
            if (e.shiftKey) {
                if (this.parent.showRibbon) {
                    this.focusEle(e, '.e-ribbon .e-toolbar-items .e-toolbar-item.e-active .e-tab-wrap', true);
                }
                else {
                    this.setFocus('Ribbon', e, isSheetArea);
                }
            }
            else if (!isSheetArea) {
                this.focusEle(e, '.e-selectall');
            }
        }
    }
    focusEle(e, selector, setTabIndex, startEdit, focusEle) {
        focusEle = focusEle || this.parent.element.querySelector(selector);
        if (setTabIndex && !focusEle) {
            const tabEle = this.parent.element.querySelector('.e-ribbon .e-tab');
            const selectedTab = (tabEle && getComponent(tabEle, 'tab').selectedItem) || 0;
            focusEle = this.parent.element.querySelector('.e-tab-header').getElementsByClassName('e-toolbar-item')[selectedTab];
            focusEle = focusEle && focusEle.querySelector('.e-tab-wrap');
        }
        if (focusEle) {
            e.preventDefault();
            if (startEdit) {
                focusEle.click();
                focus(focusEle);
                focusEle.setSelectionRange(focusEle.value.length, focusEle.value.length);
            }
            else if (setTabIndex) {
                focusEle.setAttribute('tabindex', '0');
                if (focusEle.parentElement.classList.contains('e-active') && focusEle.parentElement.classList.contains('e-toolbar-item')) {
                    const tabEle = this.parent.element.querySelector('.e-sheet-tab-panel .e-sheet-tab');
                    if (!tabEle && tabEle.classList.contains('e-focused')) {
                        tabEle.classList.add('e-focused');
                    }
                }
                focusEle.focus();
            }
            else {
                focus(focusEle);
            }
        }
    }
    updateSelection(sheet, range, e) {
        if (sheet.isProtected && !sheet.protectSettings.selectCells && sheet.protectSettings.selectUnLockedCells) {
            if (!isLockedCells(this.parent, getSwapRange(range))) {
                this.parent.notify(cellNavigate, { range: range, shiftKey: e.shiftKey });
            }
        }
        else {
            this.parent.notify(cellNavigate, { range: range, shiftKey: e.shiftKey });
        }
    }
    getNextNonEmptyCell(rowIdx, colIdx, position) {
        const sheet = this.parent.getActiveSheet();
        const isNonEmptyCell = (rowIdx, colIdx) => {
            const cellVal = getCell(rowIdx, colIdx, sheet, null, true).value;
            return !isNullOrUndefined(cellVal) && cellVal !== '';
        };
        let checkForEmptyCell;
        let visibleIdx;
        if (position === 'down') {
            const startRow = skipHiddenIdx(sheet, rowIdx + 1, true);
            checkForEmptyCell = isNonEmptyCell(startRow, colIdx);
            const lastRow = skipHiddenIdx(sheet, sheet.rowCount - 1, false);
            for (let rowIdx = startRow; rowIdx < sheet.rowCount; rowIdx++) {
                if (rowIdx === lastRow) {
                    return rowIdx;
                }
                if (checkForEmptyCell) {
                    if (!isNonEmptyCell(skipHiddenIdx(sheet, rowIdx, true), colIdx)) {
                        return skipHiddenIdx(sheet, rowIdx - 1, false);
                    }
                }
                else {
                    visibleIdx = skipHiddenIdx(sheet, rowIdx + 1, true);
                    if (isNonEmptyCell(visibleIdx, colIdx)) {
                        return visibleIdx;
                    }
                }
            }
            return rowIdx;
        }
        else if (position === 'top') {
            const startRow = skipHiddenIdx(sheet, rowIdx - 1, false);
            checkForEmptyCell = isNonEmptyCell(startRow, colIdx);
            const startIdx = this.parent.frozenRowCount(sheet) ? getRangeIndexes(sheet.topLeftCell)[0] : 0;
            const endIdx = skipHiddenIdx(sheet, startIdx, true);
            for (let rowIdx = startRow; rowIdx >= 0; rowIdx--) {
                if (rowIdx === endIdx) {
                    return rowIdx;
                }
                if (checkForEmptyCell) {
                    if (!isNonEmptyCell(skipHiddenIdx(sheet, rowIdx, false), colIdx)) {
                        return skipHiddenIdx(sheet, rowIdx + 1, true);
                    }
                }
                else {
                    visibleIdx = skipHiddenIdx(sheet, rowIdx - 1, false);
                    if (isNonEmptyCell(visibleIdx, colIdx)) {
                        return visibleIdx;
                    }
                }
            }
            return rowIdx;
        }
        else if (position === 'right') {
            const startCol = skipHiddenIdx(sheet, colIdx + 1, true, 'columns');
            checkForEmptyCell = isNonEmptyCell(rowIdx, startCol);
            const lastCol = skipHiddenIdx(sheet, sheet.colCount - 1, false, 'columns');
            for (let colIdx = startCol; colIdx < sheet.colCount; colIdx++) {
                if (colIdx === lastCol) {
                    return colIdx;
                }
                if (checkForEmptyCell) {
                    if (!isNonEmptyCell(rowIdx, skipHiddenIdx(sheet, colIdx, true, 'columns'))) {
                        return skipHiddenIdx(sheet, colIdx - 1, false, 'columns');
                    }
                }
                else {
                    visibleIdx = skipHiddenIdx(sheet, colIdx + 1, true, 'columns');
                    if (isNonEmptyCell(rowIdx, visibleIdx)) {
                        return visibleIdx;
                    }
                }
            }
            return colIdx;
        }
        else {
            const startCol = skipHiddenIdx(sheet, colIdx - 1, false, 'columns');
            checkForEmptyCell = isNonEmptyCell(rowIdx, startCol);
            const startIdx = this.parent.frozenColCount(sheet) ? getRangeIndexes(sheet.topLeftCell)[1] : 0;
            const endIdx = skipHiddenIdx(sheet, startIdx, true, 'columns');
            for (let colIdx = startCol; colIdx >= 0; colIdx--) {
                if (colIdx === endIdx) {
                    return colIdx;
                }
                if (checkForEmptyCell) {
                    if (!isNonEmptyCell(rowIdx, skipHiddenIdx(sheet, colIdx, false, 'columns'))) {
                        return skipHiddenIdx(sheet, colIdx + 1, true, 'columns');
                    }
                }
                else {
                    visibleIdx = skipHiddenIdx(sheet, colIdx - 1, false, 'columns');
                    if (isNonEmptyCell(rowIdx, visibleIdx)) {
                        return visibleIdx;
                    }
                }
            }
            return colIdx;
        }
    }
    getNextUnlockedCell(position, actCellIdx) {
        const sheet = this.parent.getActiveSheet();
        let cell;
        let col;
        if (position === 'right') {
            let rowIdx = actCellIdx[0];
            let colIdx;
            let secIteration;
            let rowLen = sheet.usedRange.rowIndex;
            let colLen = sheet.usedRange.colIndex;
            while (rowIdx <= rowLen) {
                colIdx = colIdx === undefined ? actCellIdx[1] + 1 : 0;
                if (secIteration && rowIdx === actCellIdx[0]) {
                    colLen = actCellIdx[1] - 1;
                }
                for (colIdx; colIdx <= colLen; colIdx++) {
                    cell = getCell(rowIdx, colIdx, sheet);
                    col = getColumn(sheet, colIdx) || {};
                    if (!isLocked(cell, col) && !col.hidden && !isHiddenRow(sheet, rowIdx)) {
                        return [rowIdx, colIdx];
                    }
                }
                if (rowIdx === sheet.usedRange.rowIndex && !secIteration) {
                    rowIdx = 0;
                    rowLen = actCellIdx[0];
                    secIteration = true;
                }
                else {
                    rowIdx++;
                }
            }
        }
        else if (position === 'left') {
            let rowIdx = actCellIdx[0];
            let colIdx;
            let secIteration;
            let rowLen = 0;
            let colLen = 0;
            while (rowIdx >= rowLen) {
                colIdx = colIdx === undefined ? actCellIdx[1] - 1 : sheet.usedRange.colIndex;
                if (secIteration && rowIdx === actCellIdx[0]) {
                    colLen = actCellIdx[1] + 1;
                }
                for (colIdx; colIdx >= colLen; colIdx--) {
                    cell = getCell(rowIdx, colIdx, sheet);
                    col = getColumn(sheet, colIdx) || {};
                    if (!isLocked(cell, col) && !col.hidden && !isHiddenRow(sheet, rowIdx)) {
                        return [rowIdx, colIdx];
                    }
                }
                if (rowIdx === 0 && !secIteration) {
                    rowIdx = sheet.usedRange.rowIndex;
                    rowLen = actCellIdx[0];
                    secIteration = true;
                }
                else {
                    rowIdx--;
                }
            }
        }
        else if (position === 'down') {
            let colIdx = actCellIdx[1];
            let rowIdx;
            let secIteration;
            let colLen = sheet.usedRange.colIndex;
            let rowLen = sheet.usedRange.rowIndex;
            while (colIdx <= colLen) {
                rowIdx = rowIdx === undefined ? actCellIdx[0] + 1 : 0;
                if (secIteration && colIdx === actCellIdx[1]) {
                    rowLen = actCellIdx[0] - 1;
                }
                for (rowIdx; rowIdx <= rowLen; rowIdx++) {
                    cell = getCell(rowIdx, colIdx, sheet);
                    col = getColumn(sheet, colIdx) || {};
                    if (!isLocked(cell, col) && !col.hidden && !isHiddenRow(sheet, rowIdx)) {
                        return [rowIdx, colIdx];
                    }
                }
                if (colIdx === sheet.usedRange.colIndex && !secIteration) {
                    colIdx = 0;
                    colLen = actCellIdx[1];
                    secIteration = true;
                }
                else {
                    colIdx++;
                }
            }
        }
        else {
            let colIdx = actCellIdx[1];
            let rowIdx;
            let secIteration;
            let colLen = 0;
            let rowLen = 0;
            while (colIdx >= colLen) {
                rowIdx = rowIdx === undefined ? actCellIdx[0] - 1 : sheet.usedRange.rowIndex;
                if (secIteration && colIdx === actCellIdx[1]) {
                    rowLen = actCellIdx[0] + 1;
                }
                for (rowIdx; rowIdx >= rowLen; rowIdx--) {
                    cell = getCell(rowIdx, colIdx, sheet);
                    col = getColumn(sheet, colIdx) || {};
                    if (!isLocked(cell, col) && !col.hidden && !isHiddenRow(sheet, rowIdx)) {
                        return [rowIdx, colIdx];
                    }
                }
                if (colIdx === 0 && !secIteration) {
                    colIdx = sheet.usedRange.colIndex;
                    colLen = actCellIdx[1];
                    secIteration = true;
                }
                else {
                    colIdx--;
                }
            }
        }
        return actCellIdx;
    }
    shiftSelection(e) {
        const sheet = this.parent.getActiveSheet();
        const selectedRange = getRangeIndexes(sheet.selectedRange);
        const swapRange = getSwapRange(selectedRange);
        let noHidden = true;
        const isRtl = this.parent.enableRtl;
        if (e.keyCode === 38) { /*shift + up arrow*/
            for (let i = swapRange[1]; i <= swapRange[3]; i++) {
                const cell = getCell(selectedRange[2], i, sheet);
                if (!isNullOrUndefined(cell) && cell.rowSpan && cell.rowSpan < 0) {
                    selectedRange[2] = skipHiddenIdx(sheet, selectedRange[2] - (Math.abs(cell.rowSpan) + 1), false);
                    noHidden = false;
                    break;
                }
            }
            if (noHidden) {
                selectedRange[2] = skipHiddenIdx(sheet, selectedRange[2] - 1, false);
            }
            const startIdx = this.parent.frozenRowCount(sheet) ? getRangeIndexes(sheet.topLeftCell)[0] : 0;
            if (selectedRange[2] < startIdx) {
                return;
            }
        }
        if (e.keyCode === 40) { /*shift + down arrow*/
            for (let i = swapRange[1]; i <= swapRange[3]; i++) {
                const cell = getCell(selectedRange[2], i, sheet);
                if (!isNullOrUndefined(cell) && cell.rowSpan && cell.rowSpan > 0) {
                    selectedRange[2] = skipHiddenIdx(sheet, selectedRange[2] + Math.abs(cell.rowSpan), true);
                    noHidden = false;
                    break;
                }
            }
            if (noHidden) {
                selectedRange[2] = skipHiddenIdx(sheet, selectedRange[2] + 1, true);
            }
            if (selectedRange[2] >= sheet.rowCount) {
                selectedRange[2] = skipHiddenIdx(sheet, sheet.rowCount - 1, false);
                if (selectedRange[2] < 0) {
                    return;
                }
            }
        }
        if ((e.keyCode === 39 && !isRtl) || (e.keyCode === 37 && isRtl)) { /*shift + right arrow*/
            for (let i = swapRange[0]; i <= swapRange[2]; i++) {
                const cell = getCell(i, selectedRange[3], sheet);
                if (!isNullOrUndefined(cell) && cell.colSpan && cell.colSpan > 0) {
                    selectedRange[3] = skipHiddenIdx(sheet, selectedRange[3] + Math.abs(cell.colSpan), true, 'columns');
                    noHidden = false;
                    break;
                }
            }
            if (noHidden) {
                selectedRange[3] = skipHiddenIdx(sheet, selectedRange[3] + 1, true, 'columns');
            }
            if (selectedRange[3] >= sheet.colCount) {
                selectedRange[3] = skipHiddenIdx(sheet, sheet.colCount - 1, false, 'columns');
                if (selectedRange[3] < 0) {
                    return;
                }
            }
        }
        if ((e.keyCode === 37 && !isRtl) || (e.keyCode === 39 && isRtl)) { /*shift + left arrow*/
            for (let i = swapRange[0]; i <= swapRange[2]; i++) {
                const cell = getCell(i, selectedRange[3], sheet);
                if (!isNullOrUndefined(cell) && cell.colSpan && cell.colSpan < 0) {
                    selectedRange[3] = skipHiddenIdx(sheet, selectedRange[3] - (Math.abs(cell.colSpan) + 1), false, 'columns');
                    noHidden = false;
                    break;
                }
            }
            if (noHidden) {
                selectedRange[3] = skipHiddenIdx(sheet, selectedRange[3] - 1, false, 'columns');
            }
            const startIdx = this.parent.frozenColCount(sheet) ? getRangeIndexes(sheet.topLeftCell)[1] : 0;
            if (selectedRange[3] < startIdx) {
                return;
            }
        }
        if (!this.parent.scrollSettings.enableVirtualization && e.shiftKey && e.ctrlKey) { /*ctrl + shift selection*/
            const usedRange = [sheet.usedRange.rowIndex, sheet.usedRange.colIndex];
            if (e.keyCode === 37) {
                if (selectedRange[3] <= usedRange[1]) {
                    selectedRange[3] = skipHiddenIdx(sheet, 0, true, 'columns');
                }
                else {
                    selectedRange[3] = skipHiddenIdx(sheet, usedRange[1], true, 'columns');
                }
            }
            if (e.keyCode === 38) {
                if (selectedRange[2] <= usedRange[0]) {
                    selectedRange[2] = skipHiddenIdx(sheet, 0, true);
                }
                else {
                    selectedRange[2] = skipHiddenIdx(sheet, usedRange[0], true);
                }
            }
            if (e.keyCode === 39) {
                if (selectedRange[3] <= usedRange[1]) {
                    selectedRange[3] = skipHiddenIdx(sheet, usedRange[1], false, 'columns');
                }
                else {
                    selectedRange[3] = skipHiddenIdx(sheet, sheet.colCount, false, 'columns');
                }
                if (selectedRange[3] < 0) {
                    return;
                }
            }
            if (e.keyCode === 40) {
                if (selectedRange[2] <= usedRange[0]) {
                    selectedRange[2] = skipHiddenIdx(sheet, usedRange[0], false);
                }
                else {
                    selectedRange[2] = skipHiddenIdx(sheet, sheet.rowCount, false);
                }
                if (selectedRange[2] < 0) {
                    return;
                }
            }
        }
        if (e.keyCode === 37 || e.keyCode === 39 || e.keyCode === 38 || e.keyCode === 40) { /*left,right,up,down*/
            const activeIdxes = getCellIndexes(sheet.activeCell);
            if (this.parent.isEdit && e.shiftKey) {
                e.preventDefault();
                this.parent.notify(rangeSelectionByKeydown, { range: selectedRange, e });
                this.parent.notify(addressHandle, { range: getRangeAddress(getSwapRange(selectedRange)), isSelect: false });
                this.parent.notify(initiateCur, {});
            }
            else {
                this.parent.notify(cellNavigate, { range: selectedRange, shiftKey: e.shiftKey });
            }
            this.scrollNavigation([isColumnSelected(sheet, selectedRange) ? activeIdxes[0] : selectedRange[2],
                isRowSelected(sheet, selectedRange) ? activeIdxes[1] : selectedRange[3]]);
        }
    }
    scrollNavigation(actIdxes, scrollToCell) {
        if (!this.parent.allowScrolling) {
            return;
        }
        const x = this.parent.enableRtl ? -1 : 1;
        const cont = this.parent.getMainContent().parentElement;
        const hCont = this.parent.getScrollElement();
        const sheet = this.parent.getActiveSheet();
        const selectedRange = getSwapRange(getRangeIndexes(sheet.selectedRange));
        const topLeftIdxes = getCellIndexes(sheet.topLeftCell);
        const frozenRow = this.parent.frozenRowCount(sheet);
        const frozenCol = this.parent.frozenColCount(sheet);
        const paneTopLeftIdxes = getCellIndexes(sheet.paneTopLeftCell);
        const topIdx = skipHiddenIdx(sheet, actIdxes[0] < frozenRow ? topLeftIdxes[0] : paneTopLeftIdxes[0], true);
        const offsetTopSize = this.parent.scrollModule.offset.top.size;
        if (cont.scrollTop) {
            if (frozenRow && actIdxes[0] !== selectedRange[2]) {
                if (actIdxes[0] === frozenRow) {
                    cont.scrollTop = 0;
                    return;
                }
                if (actIdxes[0] === frozenRow - 1) {
                    cont.scrollTop = 0;
                }
            }
            else if (actIdxes[0] === skipHiddenIdx(sheet, 0, true)) {
                cont.scrollTop = 0;
                return;
            }
        }
        if (hCont && hCont.scrollLeft) {
            if (frozenCol && actIdxes[1] !== selectedRange[3]) {
                if (actIdxes[1] === frozenCol) {
                    hCont.scrollLeft = 0;
                    return;
                }
                if (actIdxes[1] === frozenCol - 1) {
                    hCont.scrollLeft = 0;
                }
            }
            else if (actIdxes[1] === skipHiddenIdx(sheet, 0, true, 'columns')) {
                hCont.scrollLeft = 0;
                return;
            }
        }
        const viewportBtmIdx = getBottomOffset(this.parent, topIdx).index;
        if (viewportBtmIdx <= actIdxes[0]) {
            if (actIdxes[0] >= frozenRow) {
                if (scrollToCell) {
                    const viewPortHeight = cont.getBoundingClientRect().height;
                    const rowsHeight = getRowsHeight(sheet, paneTopLeftIdxes[0], actIdxes[0], true);
                    if (rowsHeight > viewPortHeight * 2) {
                        cont.scrollTop = offsetTopSize + rowsHeight - viewPortHeight;
                    }
                    else {
                        cont.scrollTop = offsetTopSize + rowsHeight - getRowHeight(sheet, actIdxes[0], true);
                    }
                    focus(this.parent.element);
                }
                else {
                    cont.scrollTop = offsetTopSize + getRowsHeight(sheet, viewportBtmIdx, actIdxes[0], true);
                }
            }
        }
        else if (topIdx > actIdxes[0]) {
            if (cont.scrollTop) {
                this.parent.scrollModule.isKeyScroll = false;
            }
            cont.scrollTop = offsetTopSize - Math.ceil(getRowsHeight(sheet, actIdxes[0], topIdx - 1, true));
            if (scrollToCell) {
                focus(this.parent.element);
            }
        }
        const scrollLeftIdx = getRightIdx(this.parent, paneTopLeftIdxes[1]);
        if (scrollLeftIdx <= actIdxes[1] && hCont) {
            if (actIdxes[1] >= frozenCol) {
                if (scrollToCell) {
                    const contWidth = hCont.getBoundingClientRect().width;
                    const scrollWidth = getColumnsWidth(sheet, paneTopLeftIdxes[1], actIdxes[1], true);
                    if (scrollWidth > contWidth * 2) {
                        hCont.scrollLeft = (this.parent.scrollModule.offset.left.size + scrollWidth - contWidth) * x;
                    }
                    else {
                        hCont.scrollLeft = (this.parent.scrollModule.offset.left.size +
                            (scrollWidth - getColumnWidth(sheet, actIdxes[0], null, true))) * x;
                    }
                    focus(this.parent.element);
                }
                else {
                    hCont.scrollLeft = (this.parent.scrollModule.offset.left.size + getColumnsWidth(sheet, scrollLeftIdx, actIdxes[1], true)) * x;
                }
            }
        }
        else if (paneTopLeftIdxes[1] > actIdxes[1] && hCont) {
            if (hCont.scrollLeft) {
                this.parent.scrollModule.isKeyScroll = false;
            }
            hCont.scrollLeft = (this.parent.scrollModule.offset.left.size -
                getColumnsWidth(sheet, actIdxes[1], paneTopLeftIdxes[1] - 1, true)) * x;
            if (scrollToCell) {
                focus(this.parent.element);
            }
        }
    }
    /**
     * For internal use only - Get the module name.
     *
     * @private
     * @returns {string} - Get the module name.
     */
    getModuleName() {
        return 'keyboardNavigation';
    }
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
}

/**
 * Represents keyboard shortcut support for Spreadsheet.
 */
class KeyboardShortcut {
    /**
     * Constructor for the Spreadsheet Keyboard Shortcut module.
     *
     * @param {Spreadsheet} parent - Specify the spreadsheet.
     * @private
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    addEventListener() {
        this.parent.on(keyDown, this.keyDownHandler, this);
        this.parent.on(keyUp, this.keyUpHandler, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(keyDown, this.keyDownHandler);
            this.parent.off(keyUp, this.keyUpHandler);
        }
    }
    isTrgtNotInput(e) {
        const trgt = e.target;
        return (!closest(trgt, '.e-filter-popup')
            && !closest(trgt, '.e-find-dlg') && !closest(trgt, '.e-hyperlink-dlg') &&
            !closest(trgt, '.e-sheet-tab') && !closest(trgt, '.e-name-box') && !closest(trgt, '.e-link-dialog'));
    }
    ribbonShortCuts(e) {
        if (this.parent.showRibbon && e.altKey && !e.ctrlKey && !e.shiftKey) {
            const tabObj = getComponent(this.parent.element.querySelector('.e-ribbon .e-tab'), 'tab');
            let tabIdx;
            if (e.keyCode === 72) { /*alt + H =home*/
                tabIdx = 1;
            }
            else if (e.keyCode === 78) { /*alt + N =insert */
                tabIdx = 2;
            }
            else if (e.keyCode === 65) { /*alt + A =data */
                tabIdx = 4;
            }
            else if (e.keyCode === 87) { /*alt + W =view*/
                tabIdx = 5;
            }
            else if (e.keyCode === 77) { /*alt + M =formula */
                tabIdx = 3;
            }
            else if (e.keyCode === 70) { /*alt + F =file */
                e.preventDefault();
                select('#' + this.parent.element.id + '_File', this.parent.element).click();
            }
            else if (e.keyCode === 18) { /** alt = active tab focus */
                e.preventDefault();
                const activeCell = getCellIndexes(this.parent.getActiveSheet().activeCell);
                const args = { sheetIdx: this.parent.activeSheetIndex };
                this.parent.notify(getFilterRange, args);
                if (!(args.hasFilter && args.filterRange && args.filterRange[0] === activeCell[0] && args.filterRange[1] <= activeCell[1] &&
                    args.filterRange[3] >= activeCell[1])) {
                    const actEle = document.activeElement;
                    if (!actEle.classList.contains('e-spreadsheet-edit') && !actEle.classList.contains('e-sheet-rename') &&
                        actEle.id !== `${this.parent.element.id}_name_box` && !closest(actEle, '.e-dropdown-btn') &&
                        !closest(actEle, '.e-split-btn') && !closest(actEle, '.e-popup-open')) {
                        const cell = this.parent.getCell(activeCell[0], activeCell[1]);
                        if (cell && cell.querySelector('.e-validation-list')) {
                            return;
                        }
                        if (closest(actEle, '.e-ribbon')) {
                            focus(this.parent.element);
                            return;
                        }
                        for (let i = 0; i <= this.parent.ribbonModule.ribbon.items.length; i++) {
                            if (i === this.parent.ribbonModule.ribbon.selectedTab) {
                                const focusEle = this.parent.element.querySelector('.e-toolbar-items').children[i + 2].children[0];
                                focusEle.setAttribute('tabindex', '0');
                                focus(focusEle);
                                return;
                            }
                        }
                    }
                }
            }
            if (tabIdx) {
                if (!tabObj.items[tabIdx].disabled && !tabObj.items[tabIdx].cssClass.includes('e-hide')) {
                    e.preventDefault();
                    tabObj.select(tabIdx, Object.assign(e, { isShortcut: true }));
                }
                else {
                    focus(this.parent.element);
                }
            }
        }
    }
    keyUpHandler(e) {
        if (e.keyCode === 37 || e.keyCode === 39) {
            const activeEle = document.activeElement;
            if (activeEle.classList.contains('e-colorpicker-wrapper') || activeEle.classList.contains('e-split-btn-wrapper')) {
                const colorPickerBtn = activeEle.querySelector('.e-split-btn');
                if (colorPickerBtn) {
                    focus(colorPickerBtn);
                }
            }
        }
        else if (e.keyCode === 13) {
            const target = e.target;
            if (target.classList.contains('e-scroll-nav')) {
                const focusScroll = () => {
                    if (!target.getAttribute('tabindex')) {
                        target.setAttribute('tabindex', '0');
                        focus(target);
                    }
                    EventHandler.remove(target, 'blur', focusScroll);
                };
                EventHandler.add(target, 'blur', focusScroll, this);
            }
        }
    }
    keyDownHandler(e) {
        const isSelectionNone = this.parent.selectionSettings.mode === 'None';
        this.ribbonShortCuts(e);
        const sheet = this.parent.getActiveSheet();
        const target = e.target;
        const textarea = e.target;
        if (!isNullOrUndefined(textarea) && textarea.classList.contains('e-addNoteContainer')) {
            return;
        }
        if ((e.ctrlKey || e.metaKey) && this.isTrgtNotInput(e)) {
            if (!closest(target, '.e-find-dlg') && !isSelectionNone) {
                if ([79, 83].indexOf(e.keyCode) > -1) {
                    e.preventDefault();
                }
                else if (e.keyCode === 65 && !this.parent.isEdit) {
                    e.preventDefault();
                }
            }
            const indexes = getCellIndexes(sheet.activeCell);
            if (e.keyCode === 79) { /*Ctrl + O*/
                if (this.parent.allowOpen && this.parent.openUrl) {
                    select('#' + this.parent.element.id + '_fileUpload', this.parent.element).click();
                }
            }
            else if (e.keyCode === 83) { /*Ctrl + S*/
                if (this.parent.saveUrl && this.parent.allowSave) {
                    this.parent.notify(exportDialog, null);
                }
            }
            else if (e.keyCode === 67 && !isSelectionNone) { /*Ctrl + C*/
                this.parent.notify(copy, { promise: Promise });
            }
            else if (e.keyCode === 75 && !isSelectionNone) { /*Ctrl + K*/
                const row = sheet.rows[indexes[0]];
                let cell;
                e.preventDefault();
                if (!isNullOrUndefined(row)) {
                    cell = row.cells[indexes[1]];
                }
                if (isNullOrUndefined(cell)) {
                    setCell(indexes[0], indexes[1], sheet, cell, false);
                }
                if (cell && cell.hyperlink) {
                    this.parent.notify(editHyperlink, null);
                }
                else {
                    this.parent.notify(initiateHyperlink, null);
                }
            }
            else if (e.keyCode === 90 && !isSelectionNone) { /* Ctrl + Z */
                if (!this.parent.isEdit) {
                    e.preventDefault();
                    this.parent.notify(performUndoRedo, { isUndo: true });
                }
            }
            else if (e.keyCode === 89 && !isSelectionNone) { /* Ctrl + Y */
                if (!this.parent.isEdit) {
                    e.preventDefault();
                    this.parent.notify(performUndoRedo, { isUndo: false });
                }
            }
            else if ((e.keyCode === 82 || e.keyCode === 68) && !isSelectionNone) { /* Ctrl + R */ /* Ctrl + D */
                e.preventDefault();
                const selectRange = getSwapRange(getRangeIndexes(sheet.selectedRange));
                const startCell = { colIndex: selectRange[1], rowIndex: selectRange[0] };
                let direction;
                let dataRange;
                if (e.keyCode === 68) {
                    if (selectRange[0] === selectRange[2]) {
                        startCell.rowIndex = selectRange[0] - 1;
                    }
                    else {
                        selectRange[0] += 1;
                    }
                    dataRange = getRangeAddress([startCell.rowIndex, startCell.colIndex, startCell.rowIndex, selectRange[3]]);
                    direction = 'Down';
                }
                else {
                    if (selectRange[1] === selectRange[3]) {
                        startCell.colIndex = selectRange[1] - 1;
                    }
                    else {
                        selectRange[1] += 1;
                    }
                    direction = 'Right';
                    dataRange = getRangeAddress([startCell.rowIndex, startCell.colIndex, selectRange[2], startCell.colIndex]);
                }
                if (startCell.rowIndex < 0 || startCell.colIndex < 0) {
                    return;
                }
                this.parent.notify(performAutoFill, {
                    fillType: getCell(startCell.rowIndex, startCell.colIndex, sheet, false, true).formula ? 'FillSeries' : 'CopyCells',
                    dAutoFillCell: dataRange, rangeInfo: {
                        direction: direction, startCell: startCell,
                        endCell: { rowIndex: selectRange[2], colIndex: selectRange[3] }, fillRange: selectRange
                    }
                });
                this.parent.notify(selectionComplete, { type: 'mousedown' });
                this.parent.notify(refreshRibbonIcons, null);
            }
            const isLocked$1 = sheet.isProtected && isLocked(getCell(indexes[0], indexes[1], sheet), getColumn(sheet, indexes[1]));
            if (e.keyCode === 70 && !isSelectionNone && this.parent.allowFindAndReplace) { /* Ctrl + F */
                e.preventDefault();
                this.parent.notify(findToolDlg, {});
            }
            if ((!isLocked$1 || !sheet.isProtected || e.keyCode === 86) && e.keyCode !== 70 && !isSelectionNone) {
                if (e.keyCode === 71) { /* Ctrl + G */
                    e.preventDefault();
                    this.parent.notify(gotoDlg, null);
                }
                else if (e.keyCode === 72) { /* Ctrl + H */
                    e.preventDefault();
                    this.parent.notify(findDlg, null);
                }
                else if (e.keyCode === 88) { /* Ctrl + X */
                    this.parent.notify(cut, { promise: Promise });
                }
                else if (e.keyCode === 86) { /* Ctrl + v */
                    this.parent.notify(paste, { isAction: true });
                }
                if (e.shiftKey && e.keyCode === 76 && !this.parent.isEdit && !sheet.isProtected) { /* Ctrl + Shift + L */
                    e.preventDefault();
                    this.parent.notify(initiateFilterUI, {});
                }
            }
            if (!isSelectionNone && (!sheet.isProtected || sheet.protectSettings.formatCells)) {
                if (e.keyCode === 66) { /* Ctrl + B */
                    e.preventDefault();
                    let value = this.parent.getCellStyleValue(['fontWeight'], indexes).fontWeight;
                    value = value === 'bold' ? 'normal' : 'bold';
                    this.parent.notify(setCellFormat, { style: { fontWeight: value }, onActionUpdate: true, refreshRibbon: true });
                }
                else if (e.keyCode === 73) { /* Ctrl + I */
                    e.preventDefault();
                    let value = this.parent.getCellStyleValue(['fontStyle'], indexes).fontStyle;
                    value = value === 'italic' ? 'normal' : 'italic';
                    this.parent.notify(setCellFormat, { style: { fontStyle: value }, onActionUpdate: true, refreshRibbon: true });
                }
                else if (e.ctrlKey && e.keyCode === 85 && !e.shiftKey) { /* Ctrl + U */
                    e.preventDefault();
                    this.parent.notify(textDecorationUpdate, { style: { textDecoration: 'underline' }, refreshRibbon: true });
                }
                else if (e.ctrlKey && e.keyCode === 53 && !e.shiftKey) { /* Ctrl + 5 */
                    e.preventDefault();
                    this.parent.notify(textDecorationUpdate, { style: { textDecoration: 'line-through' }, refreshRibbon: true });
                }
            }
        }
        if (e.keyCode === 27) { /*ESC*/
            this.parent.notify(clearCopy, null);
        }
        if ((((e.ctrlKey || e.metaKey) && e.keyCode === 119) || (e.keyCode === 13 && target.classList.contains('e-drop-icon')))
            && this.parent.showRibbon) { /*ctrl + f8 or Enter*/
            e.preventDefault();
            const expandCollapseIcon = this.parent.element.querySelector('.e-drop-icon');
            if (expandCollapseIcon) {
                expandCollapseIcon.click();
            }
        }
        //general key actions
        if ((e.ctrlKey || e.metaKey) && !isSelectionNone) {
            if (e.keyCode === 57) { /*ctrl + 9(row-hide)*/
                if (!sheet.isProtected || sheet.protectSettings.formatRows) {
                    e.preventDefault();
                    const indexes = getRangeIndexes(sheet.selectedRange);
                    this.parent.notify(hideShow, { startIndex: indexes[0], endIndex: indexes[2], hide: !e.shiftKey, isCol: false,
                        actionUpdate: true });
                }
            }
            else if (e.keyCode === 48) { /*ctrl + 0(col-hide)*/
                if (!sheet.isProtected || sheet.protectSettings.formatColumns) {
                    const indexes = getRangeIndexes(sheet.selectedRange);
                    this.parent.notify(hideShow, { startIndex: indexes[1], endIndex: indexes[3], hide: !e.shiftKey, isCol: true,
                        actionUpdate: true });
                }
            }
        }
        if (e.shiftKey && !isSelectionNone) {
            if (e.keyCode === 113 && !sheet.isProtected) { /*shift + F2(Add note)*/
                e.preventDefault();
                if (e.target.children.length > 0 && typeof e.target.children[e.target.children.length - 1].className === 'string' &&
                    e.target.children[e.target.children.length - 1].className.indexOf('e-addNoteIndicator') > -1) {
                    this.parent.notify(editNote, null);
                }
                else {
                    this.parent.notify(addNote, null);
                }
            }
            else if (e.keyCode === 114) { /*shift + F3(insert-function dialog)*/
                e.preventDefault();
                this.parent.notify(renderInsertDlg, null);
            }
            else if (e.keyCode === 116 && this.parent.allowFindAndReplace) { /* shift + F5 */
                e.preventDefault();
                this.parent.notify(findToolDlg, {});
            }
            else if (e.keyCode === 121) { /* Context menu open Shift+F10 */
                const className = document.activeElement.className;
                if (['e-spreadsheet', 'e-cell', 'e-header-cell', 'e-clipboard', 'e-rowhdr-table', 'e-selectall-table', 'e-main-panel'].some((cls) => className.includes(cls))) {
                    this.focusTarget(sheet);
                }
            }
        }
        if (e.altKey && !isSelectionNone) {
            if ((e.ctrlKey || e.metaKey) && e.keyCode === 78) { /*ctrl+alt+N*/
                e.preventDefault();
                this.parent.refresh(true);
            }
            else if (e.keyCode === 113 && this.parent.saveUrl) { /*alt + F2*/
                e.preventDefault();
                this.parent.notify(exportDialog, null);
            }
        }
        //number-formatting
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && !isSelectionNone) {
            if (!sheet.isProtected || sheet.protectSettings.formatCells) {
                const range = sheet.selectedRange;
                let format;
                if (e.keyCode === 192) { /*ctrl + shift + ~(General)*/
                    format = 'General';
                }
                else if (e.keyCode === 52) { /*ctrl + shift + $(currency)*/
                    format = getFormatFromType('CurrencyWithColorCode');
                }
                else if (e.keyCode === 53) { /*ctrl + shift + %(percent)*/
                    format = '0%';
                }
                else if (e.keyCode === 54) { /*ctrl + shift + ^(scentific)*/
                    format = getFormatFromType('Scientific');
                }
                else if (e.keyCode === 51) { /*ctrl + shift + #(Date)*/
                    format = 'dd-mmm-yy';
                }
                else if (e.keyCode === 50) { /*ctrl + shift + @(Time)*/
                    format = 'h:mm AM/PM';
                }
                else if (e.keyCode === 49) { /*ctrl + shift + !(Number)*/
                    format = getFormatFromType('Number');
                }
                else if (e.keyCode === 55) { /*ctrl + shift + 7*/
                    e.preventDefault();
                    const border = '1px solid #000000';
                    this.parent.notify(setCellFormat, { style: { border: border }, onActionUpdate: true, borderType: 'Outer' });
                }
                if (format) {
                    const isReadonly = isReadOnlyCells(this.parent, getSwapRange(getRangeIndexes(range)));
                    if (!isReadonly) {
                        const eventArgs = {
                            format: format, range: range, cancel: false, requestType: 'NumberFormat'
                        };
                        const actionArgs = {
                            range: sheet.name + '!' + eventArgs.range, format: eventArgs.format, requestType: 'NumberFormat'
                        };
                        this.parent.trigger('beforeCellFormat', eventArgs);
                        this.parent.notify(beginAction, { eventArgs: eventArgs, action: 'format' });
                        if (!eventArgs.cancel) {
                            this.parent.notify(applyNumberFormatting, eventArgs);
                            this.parent.notify(selectionComplete, { type: 'mousedown' });
                            this.parent.notify(completeAction, { eventArgs: actionArgs, action: 'format' });
                            this.parent.notify(refreshRibbonIcons, null);
                        }
                    }
                }
            }
            if (e.keyCode === 85) { /*ctrl + shift + U*/
                e.preventDefault();
                const formulaExpand = this.parent.element.querySelector('.e-formula-bar-panel .e-drop-icon');
                if (formulaExpand) {
                    formulaExpand.click();
                }
            }
        }
        if (e.keyCode === 122 && e.shiftKey && !e.ctrlKey && !this.parent.isProtected) { // shift+f11
            this.parent.notify(insertModel, {
                model: this.parent, start: this.parent.activeSheetIndex + 1, end: this.parent.activeSheetIndex + 1, modelType: 'Sheet', isAction: true, activeSheetIndex: this.parent.activeSheetIndex + 1
            });
        }
        if (e.shiftKey && e.altKey && e.keyCode === 75 && this.parent.showSheetTabs) { /* Shift + Alt + K*/
            this.parent.element.querySelector('.e-sheets-list').click();
        }
    }
    focusTarget(sheet) {
        const indexes = getSwapRange(getRangeIndexes(sheet.selectedRange));
        const isRowSelected = (indexes[1] === 0 && indexes[3] === sheet.colCount - 1);
        const isColSelected = (indexes[0] === 0 && indexes[2] === sheet.rowCount - 1);
        let target;
        if (isRowSelected && isColSelected) {
            target = this.parent.element.querySelector('.e-selectall');
        }
        else if (isRowSelected) {
            const frozenRow = this.parent.frozenRowCount(sheet);
            if (indexes[0] < frozenRow) {
                const freezeHdrRow = this.parent.getRow(indexes[0], this.parent.sheetModule.getSelectAllTable());
                target = freezeHdrRow && freezeHdrRow.cells[0];
            }
            else {
                indexes[0] = skipHiddenIdx(sheet, indexes[0], true);
                const topIdx = skipHiddenIdx(sheet, getRangeIndexes(sheet.paneTopLeftCell)[0], true);
                const bottomIdx = getBottomOffset(this.parent, topIdx).index;
                let hdrRow;
                if (indexes[0] > topIdx && indexes[0] < bottomIdx) {
                    hdrRow = this.parent.getRow(indexes[0], this.parent.getRowHeaderTable());
                }
                else if (indexes[0] >= bottomIdx) {
                    hdrRow = this.parent.getRow(bottomIdx - 1, this.parent.getRowHeaderTable());
                }
                else {
                    hdrRow = this.parent.getRow(topIdx + 1, this.parent.getRowHeaderTable());
                }
                target = hdrRow && hdrRow.cells[0];
            }
        }
        else if (isColSelected) {
            const frozenCol = this.parent.frozenColCount(sheet);
            if (indexes[1] < frozenCol) {
                const freezeHdrRow = this.parent.element.querySelector('.e-selectall-container .e-header-row');
                target = freezeHdrRow && this.parent.getCell(0, indexes[1], freezeHdrRow);
            }
            else {
                indexes[1] = skipHiddenIdx(sheet, indexes[1], true, 'columns');
                const leftIdx = skipHiddenIdx(sheet, getRangeIndexes(sheet.paneTopLeftCell)[1], true, 'columns');
                const rightIdx = getRightIdx(this.parent, leftIdx);
                const hdrRow = this.parent.element.querySelector('.e-column-header .e-header-row');
                if (indexes[1] > leftIdx && indexes[1] < rightIdx) {
                    target = hdrRow && this.parent.getCell(0, indexes[1], hdrRow);
                }
                else if (indexes[1] >= rightIdx) {
                    target = hdrRow && this.parent.getCell(0, rightIdx - 1, hdrRow);
                }
                else {
                    target = hdrRow && this.parent.getCell(0, leftIdx + 1, hdrRow);
                }
            }
        }
        else {
            const topLeftIdx = getRangeIndexes(sheet.paneTopLeftCell);
            target = this.parent.getCell(indexes[0], indexes[1]);
            const frozenRow = this.parent.frozenRowCount(sheet);
            const frozenCol = this.parent.frozenColCount(sheet);
            if (indexes[0] < frozenRow && indexes[1] < frozenCol) {
                target = this.parent.getCell(indexes[0], indexes[1]);
            }
            else if (indexes[0] < frozenRow) {
                const leftIdx = getRangeIndexes(sheet.paneTopLeftCell)[1];
                const rightIdx = getRightIdx(this.parent, leftIdx);
                if (indexes[1] > leftIdx && indexes[1] < rightIdx) {
                    target = this.parent.getCell(indexes[0], indexes[1]);
                }
                else if (indexes[1] >= rightIdx) {
                    target = this.parent.getCell(indexes[0], rightIdx - 1);
                }
                else {
                    target = this.parent.getCell(indexes[0], leftIdx + 1);
                }
            }
            else if (indexes[1] < frozenCol) {
                const topIdx = getRangeIndexes(sheet.paneTopLeftCell)[0];
                const bottomIdx = getBottomOffset(this.parent, topIdx).index;
                if (indexes[0] > topIdx && indexes[0] < bottomIdx) {
                    target = this.parent.getCell(indexes[0], indexes[1]);
                }
                else if (indexes[0] >= bottomIdx) {
                    target = this.parent.getCell(bottomIdx - 1, indexes[1]);
                }
                else {
                    target = this.parent.getCell(topIdx + 1, indexes[1]);
                }
            }
            else {
                const topIdx = getRangeIndexes(sheet.paneTopLeftCell)[0];
                const bottomIdx = getBottomOffset(this.parent, topIdx).index;
                const leftIdx = getRangeIndexes(sheet.paneTopLeftCell)[1];
                const rightIdx = getRightIdx(this.parent, leftIdx);
                if (indexes[0] > topIdx && indexes[0] < bottomIdx) {
                    if (indexes[1] > leftIdx && indexes[1] < rightIdx) {
                        target = this.parent.getCell(indexes[0], indexes[1]);
                    }
                    else if (indexes[1] >= rightIdx) {
                        target = this.parent.getCell(indexes[0], rightIdx - 1);
                    }
                    else {
                        target = this.parent.getCell(indexes[0], leftIdx + 1);
                    }
                }
                else if (indexes[0] >= bottomIdx) {
                    if (indexes[1] > leftIdx && indexes[1] < rightIdx) {
                        target = this.parent.getCell(bottomIdx - 1, indexes[1]);
                    }
                    else if (indexes[1] >= rightIdx) {
                        target = this.parent.getCell(bottomIdx - 1, rightIdx - 1);
                    }
                    else {
                        target = this.parent.getCell(bottomIdx - 1, leftIdx + 1);
                    }
                }
                else {
                    if (indexes[1] > leftIdx && indexes[1] < rightIdx) {
                        target = this.parent.getCell(topIdx + 1, indexes[1]);
                    }
                    else if (indexes[1] >= rightIdx) {
                        target = this.parent.getCell(topIdx + 1, rightIdx - 1);
                    }
                    else {
                        target = this.parent.getCell(topIdx + 1, leftIdx + 1);
                    }
                }
            }
            if (!target) {
                target = this.parent.getCell(topLeftIdx[0] + 1, topLeftIdx[1] + 1);
            }
        }
        if (target) {
            focus(target);
        }
    }
    getModuleName() {
        return 'keyboardShortcut';
    }
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
}

/**
 * CellFormat module allows to format the cell styles.
 */
class CellFormat {
    constructor(parent) {
        this.checkHeight = false;
        this.parent = parent;
        this.addEventListener();
    }
    applyCellFormat(args) {
        if (args.checkHeight) {
            if (!this.checkHeight) {
                this.checkHeight = true;
            }
            this.updateRowHeight(args.rowIdx, args.colIdx, args.lastCell, args.onActionUpdate, args.outsideViewport, args.rowHeight);
            return;
        }
        const keys = Object.keys(args.style);
        const sheet = this.parent.getActiveSheet();
        if (args.lastCell && !keys.length && (getMaxHgt(sheet, args.rowIdx) <= (sheet.standardHeight || 20))) {
            return;
        }
        const cell = args.td || this.parent.getCell(args.rowIdx, args.colIdx);
        if (cell) {
            this.updateMergeBorder(args, sheet);
            let cellStyleColor;
            if (args.formatColor && cell.style.color === args.formatColor) {
                cellStyleColor = args.style.color;
                delete args.style.color;
            }
            if (args.style.border !== undefined || args.style.borderTop !== undefined || args.style.borderLeft !== undefined) {
                const curStyle = {};
                Object.keys(args.style).forEach((key) => { curStyle[`${key}`] = args.style[`${key}`]; });
                if (curStyle.border !== undefined) {
                    Object.assign(cell.style, { borderRight: args.style.border, borderBottom: args.style.border });
                    this.setLeftBorder(args.style.border, cell, args.rowIdx, args.colIdx, args.colIdx === this.parent.frozenColCount(sheet) ? args.hRow : args.row, args.onActionUpdate, args.first, sheet);
                    this.setTopBorder(args.style.border, cell, args.rowIdx, args.colIdx, args.pRow, args.pHRow, args.onActionUpdate, args.first, args.lastCell, args.manualUpdate, sheet, args);
                    delete curStyle.border;
                }
                if (curStyle.borderTop !== undefined) {
                    this.setTopBorder(args.style.borderTop, cell, args.rowIdx, args.colIdx, args.pRow, args.pHRow, args.onActionUpdate, args.first, args.lastCell, args.manualUpdate, sheet, args);
                    delete curStyle.borderTop;
                }
                if (curStyle.borderLeft !== undefined) {
                    this.setLeftBorder(args.style.borderLeft, cell, args.rowIdx, args.colIdx, args.colIdx === this.parent.frozenColCount(sheet) ? args.hRow : args.row, args.onActionUpdate, args.first, sheet);
                    delete curStyle.borderLeft;
                }
                if (Object.keys(curStyle).length) {
                    if (curStyle.borderBottom !== undefined) {
                        this.setThickBorderHeight(curStyle.borderBottom, args.rowIdx, args.colIdx, cell, args.row, args.hRow, args.onActionUpdate, args.lastCell, args.manualUpdate);
                    }
                    Object.assign(cell.style, curStyle);
                }
            }
            else {
                if (args.style.borderBottom !== undefined) {
                    this.setThickBorderHeight(args.style.borderBottom, args.rowIdx, args.colIdx, cell, args.row, args.hRow, args.onActionUpdate, args.lastCell, args.manualUpdate);
                }
                Object.assign(cell.style, args.style);
                if (cell) {
                    const dataBar = cell.querySelector('.e-cf-databar');
                    if (dataBar) {
                        const dataBarValue = dataBar.querySelector('.e-databar-value');
                        if (dataBarValue) {
                            dataBarValue.style.textDecoration = args.style.textDecoration;
                            if (args.style.verticalAlign) {
                                dataBarValue.style.alignItems = args.style.verticalAlign === 'top' ? 'start' :
                                    args.style.verticalAlign === 'middle' ? 'center' : 'end';
                            }
                        }
                    }
                }
                const CellElem = getCell(args.rowIdx, args.colIdx, sheet); // Need to remove after adding span support to merge
                if (CellElem && (CellElem.rowSpan || CellElem.colSpan) && cell.offsetHeight > 0) {
                    const height = getTextHeight(this.parent, CellElem.style || this.parent.cellStyle);
                    if (height > cell.offsetHeight) {
                        setRowEleHeight(this.parent, sheet, cell.offsetHeight, args.rowIdx);
                    }
                }
                if (args.style.fontSize && cell) {
                    const ddlCont = cell.querySelector('.e-validation-list');
                    if (ddlCont) {
                        this.parent.notify(addListValidationDropdown, {
                            ddlCont: ddlCont,
                            rowIdx: args.rowIdx, colIdx: args.colIdx, updatePosition: true
                        });
                    }
                }
            }
            const cellModel = getCell(args.rowIdx, args.colIdx, sheet, null, true);
            if (!sheet.rows[args.rowIdx] || !sheet.rows[args.rowIdx].customHeight) {
                if (args.isHeightCheckNeeded) {
                    if (!args.manualUpdate) {
                        if (!cellModel.wrap && isHeightCheckNeeded(args.style)) {
                            setMaxHgt(sheet, args.rowIdx, args.colIdx, getTextHeightWithBorder(this.parent, args.rowIdx, args.colIdx, sheet, args.style));
                        }
                        if (args.lastCell) {
                            const height = getMaxHgt(sheet, args.rowIdx);
                            const defaultHeight = sheet.standardHeight || 20;
                            if (height > defaultHeight && height > getRowHeight(sheet, args.rowIdx)) {
                                setRowEleHeight(this.parent, sheet, height, args.rowIdx, args.row, args.hRow);
                            }
                        }
                    }
                    else {
                        if (!this.checkHeight) {
                            this.checkHeight = isHeightCheckNeeded(args.style, args.onActionUpdate);
                        }
                        if (cell && cell.children[0] && cell.children[0].className === 'e-cf-databar' && args.style.fontSize) {
                            cell.children[0].querySelector('.e-databar-value').style.fontSize = args.style.fontSize;
                        }
                        if (!args.isFromAutoFillOption) {
                            this.updateRowHeight(args.rowIdx, args.colIdx, args.lastCell, args.onActionUpdate, null, args.rowHeight);
                        }
                        if (cellModel.wrap && (args.style.fontSize || args.style.fontFamily)) {
                            cell.style.lineHeight = (parseFloat((cellModel.style && cellModel.style.fontSize) || this.parent.cellStyle.fontSize) * getLineHeight(cellModel.style && cellModel.style.fontFamily ? cellModel.style : this.parent.cellStyle)) + 'pt';
                        }
                    }
                }
            }
            else if (!cellModel.wrap && (args.style.fontSize || args.style.fontFamily)) {
                const hgt = getRowHeight(sheet, args.rowIdx, true) - getBorderHeight(args.rowIdx, args.colIdx, sheet);
                if (hgt < getTextHeight(this.parent, cellModel.style)) {
                    cell.style.lineHeight = `${hgt}px`;
                }
                else if (cell.style.lineHeight) {
                    cell.style.lineHeight = '';
                }
            }
            if (cellStyleColor !== undefined) {
                args.style.color = cellStyleColor;
            }
        }
        else {
            this.updateRowHeight(args.rowIdx, args.colIdx, true, args.onActionUpdate, null, args.rowHeight);
        }
    }
    updateRowHeight(rowIdx, colIdx, isLastCell, onActionUpdate, outsideViewport, rHeight) {
        if (this.checkHeight) {
            const sheet = this.parent.getActiveSheet();
            const cell = getCell(rowIdx, colIdx, sheet, null, true);
            if (!cell.rowSpan) {
                let hgt = 0;
                hgt = getTextHeightWithBorder(this.parent, rowIdx, colIdx, sheet, cell.style || this.parent.cellStyle, cell.wrap && !cell.colSpan ? getLines(this.parent.getDisplayText(cell), getExcludedColumnWidth(sheet, rowIdx, colIdx), cell.style, this.parent.cellStyle)
                    : 1);
                const val = cell.value && cell.value.toString();
                if (val && val.indexOf('\n') > -1) {
                    let i;
                    const splitVal = val.split('\n');
                    let n = 0;
                    const valLength = splitVal.length;
                    for (i = 0; i < valLength; i++) {
                        let lines = getLines(splitVal[i], getExcludedColumnWidth(sheet, rowIdx, colIdx), cell.style, this.parent.cellStyle);
                        if (lines === 0) {
                            lines = 1; // for empty new line
                        }
                        n = n + lines;
                    }
                    hgt = getTextHeightWithBorder(this.parent, rowIdx, colIdx, sheet, cell.style || this.parent.cellStyle, n);
                }
                const defaultHeight = sheet && sheet.standardHeight ? sheet.standardHeight : 20;
                if (hgt < defaultHeight) {
                    hgt = defaultHeight; // default height
                }
                setMaxHgt(sheet, rowIdx, colIdx, hgt);
                if (!outsideViewport) {
                    const td = this.parent.getCell(rowIdx, colIdx);
                    if (td && td.children[0] && td.children[0].className === 'e-cf-databar') {
                        td.children[0].style.height = '100%';
                        td.children[0].firstElementChild.nextElementSibling.style.height = '100%';
                    }
                }
                if (isLastCell) {
                    this.checkHeight = false;
                    const maxHgt = rHeight ? rHeight : getMaxHgt(sheet, rowIdx);
                    const prevHgt = getRowHeight(sheet, rowIdx);
                    if (onActionUpdate ? maxHgt !== prevHgt : maxHgt > prevHgt) {
                        setRowEleHeight(this.parent, sheet, maxHgt, rowIdx, null, null, true, outsideViewport);
                    }
                }
            }
        }
    }
    updateMergeBorder(args, sheet) {
        const cellModel = getCell(args.rowIdx, args.colIdx, sheet, null, true);
        const mergeArgs = { range: [args.rowIdx, args.colIdx, args.rowIdx, args.colIdx] };
        this.parent.notify(activeCellMergedRange, mergeArgs);
        if (cellModel.rowSpan > 1 && !args.style.borderBottom) {
            const bottomCell = getCell(mergeArgs.range[2], mergeArgs.range[1], sheet, null, true);
            if (bottomCell.style && bottomCell.style.borderBottom) {
                args.style.borderBottom = bottomCell.style.borderBottom;
            }
        }
        if (cellModel.colSpan > 1 && !args.style.borderRight) {
            const rightCell = getCell(mergeArgs.range[0], mergeArgs.range[3], sheet, null, true);
            if (rightCell.style && rightCell.style.borderRight) {
                args.style.borderRight = rightCell.style.borderRight;
            }
        }
    }
    setLeftBorder(border, cell, rowIdx, colIdx, row, actionUpdate, first, sheet) {
        if (first && first.includes('Column')) {
            return;
        }
        const isRtl = this.parent.enableRtl;
        const prevCell = isRtl ? this.parent.getCell(rowIdx, colIdx + 1, row) :
            this.parent.getCell(rowIdx, colIdx - 1, row);
        if (prevCell) {
            let model = getCell(rowIdx, colIdx - 1, sheet, false, true);
            if ((!!model.rowSpan && model.rowSpan !== 1) || (!!model.colSpan && model.colSpan !== 1)) {
                const mergeArgs = { range: [rowIdx, colIdx - 1, rowIdx, colIdx - 1] };
                this.parent.notify(activeCellMergedRange, mergeArgs);
                model = getCell(mergeArgs.range[0], mergeArgs.range[1], sheet, false, true);
                if (model.style && model.style.borderRight && model.style.borderRight !== 'none') {
                    return;
                }
                else {
                    model = getCell(mergeArgs.range[0], mergeArgs.range[3], sheet, null, true);
                    if (model.style && model.style.borderRight && model.style.borderRight !== 'none') {
                        return;
                    }
                    cell.style.borderLeft = border;
                }
            }
            else {
                if (actionUpdate && border !== '' && colIdx === this.parent.viewport.leftIndex) {
                    this.parent.getMainContent().scrollLeft -= this.getBorderSize(border);
                }
                prevCell.style.borderRight = (border === 'none') ? prevCell.style.borderRight : border;
            }
        }
        else {
            cell.style.borderLeft = border;
        }
    }
    setTopBorder(border, cell, rowIdx, colIdx, pRow, pHRow, actionUpdate, first, lastCell, manualUpdate, sheet, args) {
        if (first && first.includes('Row')) {
            return;
        }
        let col = colIdx;
        let model = getCell(rowIdx, colIdx, sheet, false, true);
        if (model.colSpan > 1 && isHiddenCol(sheet, colIdx)) {
            col = skipHiddenIdx(sheet, colIdx, true, 'columns');
            if (col > colIdx + model.colSpan - 1) {
                col = colIdx;
            }
        }
        const prevCell = this.parent.getCell(rowIdx - 1, col, pRow);
        if (prevCell) {
            model = getCell(rowIdx - 1, colIdx, sheet, false, true);
            if ((!!model.rowSpan && model.rowSpan !== 1) || (!!model.colSpan && model.colSpan !== 1)) {
                const mergeArgs = { range: [rowIdx - 1, colIdx, rowIdx - 1, colIdx] };
                this.parent.notify(activeCellMergedRange, mergeArgs);
                model = getCell(mergeArgs.range[0], mergeArgs.range[1], sheet, false, true);
                if (model.style && model.style.borderBottom && model.style.borderBottom !== 'none') {
                    return;
                }
                else {
                    model = getCell(mergeArgs.range[2], mergeArgs.range[1], sheet, null, true);
                    if (model.style && model.style.borderBottom && model.style.borderBottom !== 'none') {
                        return;
                    }
                    cell.style.borderTop = border;
                    if (args.mergeBorderRows !== undefined && args.mergeBorderRows.indexOf(rowIdx) === -1) {
                        args.mergeBorderRows.push(rowIdx);
                    }
                }
            }
            else {
                if (isHiddenRow(sheet, rowIdx - 1)) {
                    const index = [Number(prevCell.parentElement.getAttribute('aria-rowindex')) - 1, colIdx];
                    if (this.parent.getCellStyleValue(['bottomPriority'], index).bottomPriority) {
                        return;
                    }
                }
                if (actionUpdate && border !== '' && sheet.topLeftCell.includes(`${rowIdx + 1}`)) {
                    this.parent.getMainContent().parentElement.scrollTop -= this.getBorderSize(border);
                }
                this.setThickBorderHeight(border, rowIdx - 1, colIdx, prevCell, pRow, pHRow, actionUpdate, lastCell, manualUpdate);
                prevCell.style.borderBottom = (border === 'none') ? prevCell.style.borderBottom : border;
            }
        }
        else {
            cell.style.borderTop = border;
        }
    }
    setThickBorderHeight(border, rowIdx, colIdx, cell, row, hRow, actionUpdate, lastCell, manualUpdate) {
        const size = border ? this.getBorderSize(border) : 1;
        const sheet = this.parent.getActiveSheet();
        if (size > 2 && (!sheet.rows[rowIdx] || !sheet.rows[rowIdx].customHeight)) {
            if (manualUpdate) {
                if (!this.checkHeight) {
                    this.checkHeight = true;
                }
                this.updateRowHeight(rowIdx, colIdx, lastCell, actionUpdate);
            }
            else {
                const prevHeight = getRowHeight(sheet, rowIdx);
                const height = Math.ceil(this.parent.calculateHeight(this.parent.getCellStyleValue(['fontFamily', 'fontSize'], [rowIdx, colIdx]), 1, 3));
                if (height > prevHeight) {
                    setRowEleHeight(this.parent, sheet, height, rowIdx, row, hRow);
                }
            }
        }
        if (actionUpdate && (lastCell || !this.checkHeight) && size < 3 && (!sheet.rows[rowIdx] ||
            !sheet.rows[rowIdx].customHeight)) {
            if (!this.checkHeight) {
                this.checkHeight = true;
            }
            this.updateRowHeight(rowIdx, colIdx, lastCell, actionUpdate);
        }
    }
    getBorderSize(border) {
        const size = border.split(' ')[0];
        return size === 'thin' ? 1 : (size === 'medium' ? 2 : (size === 'thick' ? 3 : (parseInt(size, 10) || 1)));
    }
    clearObj(args) {
        const options = args.options;
        const range = options.range ? (options.range.indexOf('!') > 0) ?
            options.range.substring(options.range.lastIndexOf('!') + 1) : options.range : this.parent.getActiveSheet().selectedRange;
        const sheetIndex = (options.range && options.range.indexOf('!') > 0) ?
            getSheetIndex(this.parent, options.range.substring(0, options.range.lastIndexOf('!'))) :
            this.parent.activeSheetIndex;
        const rangeIdx = getSwapRange(getRangeIndexes(range));
        const isRangeReadOnly = isReadOnlyCells(this.parent, rangeIdx);
        if (isRangeReadOnly) {
            if (args.isAction) {
                this.parent.notify(readonlyAlert, null);
            }
            return;
        }
        const sheet = this.parent.sheets[sheetIndex];
        let sRIdx = rangeIdx[0];
        const eRIdx = rangeIdx[2];
        let sCIdx;
        let eCIdx;
        const overlayElements = this.parent.element.getElementsByClassName('e-ss-overlay-active');
        const isOverlay = overlayElements.length > 0;
        let clearCFArgs;
        const isSelectAll = this.parent.element.getElementsByClassName('e-prev-highlight-bottom').length > 0;
        let eventArgs = { range: range, type: options.type, requestType: 'clear',
            sheetIndex: sheetIndex };
        const actionBegin = () => {
            if (args.isAction) {
                this.parent.notify(beginAction, { action: 'beforeClear', eventArgs: eventArgs });
            }
        };
        const actionComplete = () => {
            if (args.isAction) {
                eventArgs = { range: sheet.name + '!' + range, type: options.type, sheetIndex: sheetIndex };
                if (clearCFArgs) {
                    eventArgs.cfClearActionArgs = clearCFArgs.cfClearActionArgs;
                }
                this.parent.notify(completeAction, { eventArgs: eventArgs, action: 'clear', isSelectAll: isSelectAll });
            }
        };
        const isClearAll = options.type === 'Clear All';
        if (isOverlay) {
            if (options.type === 'Clear Contents' || isClearAll) {
                actionBegin();
                if (overlayElements[0].classList.contains('e-datavisualization-chart')) {
                    this.parent.notify(deleteChart, {
                        id: overlayElements[0].id, sheetIdx: this.parent.activeSheetIndex + 1, clearAction: true
                    });
                }
                else {
                    this.parent.notify(deleteImage, {
                        id: overlayElements[0].id, sheetIdx: this.parent.activeSheetIndex + 1, clearAction: true
                    });
                }
                actionComplete();
            }
        }
        else {
            actionBegin();
            if (options.type === 'Clear Formats' || isClearAll) {
                clearCFArgs = { range: range, sheetIdx: sheetIndex, isClear: true };
                this.parent.notify(clearCFRule, clearCFArgs);
                args.cfClearActionArgs = clearCFArgs.cfClearActionArgs;
                if (isClearAll) {
                    this.parent.notify(cellValidation, { range: range, isRemoveValidation: true });
                    if (sRIdx === 0 && rangeIdx[1] === 0 && eRIdx >= sheet.usedRange.rowIndex && rangeIdx[3] >= sheet.usedRange.colIndex) {
                        this.parent.setUsedRange(sRIdx, rangeIdx[1], sheet, false, true);
                    }
                }
                for (sRIdx; sRIdx <= eRIdx; sRIdx++) {
                    sCIdx = rangeIdx[1];
                    eCIdx = rangeIdx[3];
                    for (sCIdx; sCIdx <= eCIdx; sCIdx++) {
                        const cell = getCell(sRIdx, sCIdx, sheet);
                        const cellElem = this.parent.getCell(sRIdx, sCIdx);
                        if (cell) {
                            if (isClearAll && cell.formula) {
                                this.parent.notify(clearFormulaDependentCells, { cellRef: getRangeAddress([sRIdx, sCIdx, sRIdx, sCIdx]) });
                            }
                            if (cell.wrap) {
                                this.parent.notify(wrapEvent, { range: [sRIdx, sCIdx, sRIdx, sCIdx], wrap: false, sheet: sheet });
                            }
                            if (cell.hyperlink) {
                                if (cellElem) {
                                    removeClass(cellElem.querySelectorAll('.e-hyperlink'), 'e-hyperlink-style');
                                }
                                if (isClearAll) {
                                    this.parent.removeHyperlink(sheet.name + '!' + getRangeAddress([sRIdx, sCIdx, sRIdx, sCIdx]));
                                }
                            }
                        }
                    }
                }
            }
            if (options.type === 'Clear Hyperlinks') {
                this.parent.removeHyperlink(sheet.name + '!' + range);
            }
            this.parent.notify(clear, { range: sheet.name + '!' + range, type: options.type });
            this.parent.serviceLocator.getService('cell').refreshRange(getSwapRange(getRangeIndexes(range)), false, false, false, options.type === 'Clear Hyperlinks' ? true : false, isImported(this.parent), !isClearAll, null, null, null, isSelectAll);
            if (!args.isFromUpdateAction) {
                this.parent.notify(selectRange, { address: range });
            }
            this.parent.notify(activeCellChanged, null);
            actionComplete();
        }
    }
    addEventListener() {
        this.parent.on(applyCellFormat, this.applyCellFormat, this);
        this.parent.on(clearViewer, this.clearObj, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(applyCellFormat, this.applyCellFormat);
            this.parent.off(clearViewer, this.clearObj);
        }
    }
    /**
     * Destroy cell format module.
     *
     * @returns {void} - Destroy cell format module.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
        this.checkHeight = null;
    }
    /**
     * Get the cell format module name.
     *
     * @returns {string} - Get the cell format module name.
     */
    getModuleName() {
        return 'cellformat';
    }
}

/**
 * The `Resize` module is used to handle the resizing functionalities in Spreadsheet.
 */
class Resize {
    /**
     * Constructor for resize module in Spreadsheet.
     *
     * @param {Spreadsheet} parent - Constructor for resize module in Spreadsheet.
     * @private
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    addEventListener() {
        this.parent.on(contentLoaded, this.wireEvents, this);
        this.parent.on(autoFit, this.autoFit, this);
        this.parent.on(setAutoFit, this.setAutoFitHandler, this);
        this.parent.on(propertyChange, this.propertyChange, this);
    }
    autoFit(args) {
        const element = args.isRow ? this.parent.getRowHeaderTable() : this.parent.getColHeaderTable().rows[0];
        for (let i = args.startIndex; i <= args.endIndex; i++) {
            this.trgtEle = args.isRow ? this.parent.getRow(i, element) :
                this.parent.getCell(null, i, element);
            this.setAutofit(i, !args.isRow);
        }
    }
    wireEvents() {
        const rowHeader = this.parent.getRowHeaderContent();
        const colHeader = this.parent.element.getElementsByClassName('e-header-panel')[0];
        if (!colHeader) {
            return;
        }
        EventHandler.add(colHeader, 'dblclick', this.dblClickHandler, this);
        EventHandler.add(rowHeader, 'dblclick', this.dblClickHandler, this);
        EventHandler.add(colHeader, 'mousedown', this.mouseDownHandler, this);
        EventHandler.add(rowHeader, 'mousedown', this.mouseDownHandler, this);
        this.wireResizeCursorEvent(rowHeader, colHeader);
    }
    wireResizeCursorEvent(rowHeader, colHeader) {
        EventHandler.add(rowHeader, 'mousemove', this.setTarget, this);
        EventHandler.add(colHeader, 'mousemove', this.setTarget, this);
    }
    unWireResizeCursorEvent() {
        EventHandler.remove(this.parent.getRowHeaderContent(), 'mousemove', this.setTarget);
        const headerPanel = this.parent.element.getElementsByClassName('e-header-panel')[0];
        if (headerPanel) {
            EventHandler.remove(headerPanel, 'mousemove', this.setTarget);
        }
    }
    unwireEvents() {
        const rowHeader = this.parent.getRowHeaderContent();
        const colHeader = this.parent.element.getElementsByClassName('e-header-panel')[0];
        if (!colHeader) {
            return;
        }
        EventHandler.remove(colHeader, 'dblclick', this.dblClickHandler);
        EventHandler.remove(rowHeader, 'dblclick', this.dblClickHandler);
        EventHandler.remove(colHeader, 'mousedown', this.mouseDownHandler);
        EventHandler.remove(rowHeader, 'mousedown', this.mouseDownHandler);
        this.unWireResizeCursorEvent();
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(contentLoaded, this.wireEvents);
            this.parent.off(autoFit, this.autoFit);
            this.parent.off(setAutoFit, this.setAutoFitHandler);
            this.parent.off(propertyChange, this.propertyChange);
        }
    }
    mouseMoveHandler(e) {
        const colResizeHandler = this.parent.element.getElementsByClassName('e-colresize-handler')[0];
        const rowResizeHandler = this.parent.element.getElementsByClassName('e-rowresize-handler')[0];
        this.resizeTooltip(null, true, e);
        if (colResizeHandler || rowResizeHandler) {
            this.isMouseMoved = true;
            const isRtl = this.parent.enableRtl;
            if (colResizeHandler) {
                if (isRtl ? (e.x < this.trgtEle.parentElement.firstChild.getBoundingClientRect().right) :
                    (e.x > this.trgtEle.parentElement.firstChild.getBoundingClientRect().left)) {
                    colResizeHandler.style.left = e.clientX -
                        document.getElementById(this.parent.element.id + '_sheet').getBoundingClientRect().left + 'px';
                }
            }
            else if (rowResizeHandler) {
                if (e.y >= this.trgtEle.parentElement.parentElement.firstChild.getBoundingClientRect().top) {
                    rowResizeHandler.style.top = e.clientY -
                        document.getElementById(this.parent.element.id + '_sheet').getBoundingClientRect().top + 'px';
                }
            }
        }
    }
    mouseDownHandler(e) {
        if (!closest(e.target, '.e-header-cell') || e.target.className.includes('e-filter-icon')) {
            return;
        }
        this.event = e;
        this.trgtEle = e.target;
        if (this.trgtEle.parentElement.classList.contains('e-hide-end') || this.trgtEle.classList.contains('e-hide-end')) {
            const offsetSize = this.trgtEle.offsetHeight;
            const offset = e.offsetY;
            if ((offsetSize >= 10 && offset < 5) || (offsetSize - 2 < 8 && offset < Math.ceil((offset - 2) / 2))) {
                this.trgtEle.classList.add('e-skip-resize');
            }
        }
        this.updateTarget(e, this.trgtEle);
        const trgt = this.trgtEle;
        const className = trgt.classList.contains('e-colresize') ? 'e-colresize-handler' :
            trgt.classList.contains('e-rowresize') ? 'e-rowresize-handler' : '';
        this.createResizeHandler(trgt, className);
        this.unWireResizeCursorEvent();
        EventHandler.add(this.parent.element, 'mousemove', this.mouseMoveHandler, this);
        EventHandler.add(document, 'mouseup', this.mouseUpHandler, this);
    }
    mouseUpHandler(e) {
        const resizeHandler = this.parent.element.getElementsByClassName('e-resize-handle')[0];
        this.resizeOn(e);
        this.isMouseMoved = null;
        const HeaderTooltip = document.querySelector('.e-header-tooltip');
        if (resizeHandler) {
            detach(resizeHandler);
            this.updateCursor();
        }
        if (HeaderTooltip) {
            HeaderTooltip.remove();
        }
        EventHandler.remove(document, 'mouseup', this.mouseUpHandler);
        EventHandler.remove(this.parent.element, 'mousemove', this.mouseMoveHandler);
        const colHeader = this.parent.element.getElementsByClassName('e-header-panel')[0];
        if (colHeader) {
            this.wireResizeCursorEvent(this.parent.getRowHeaderContent(), colHeader);
        }
        this.parent.notify(positionAutoFillElement, null);
        this.parent.notify(hideAutoFillOptions, null);
    }
    dblClickHandler(e) {
        if (!closest(e.target, '.e-header-cell') || e.target.className.includes('e-filter-icon')) {
            return;
        }
        this.trgtEle = e.target;
        const skipUnhideRowCol = this.updateTarget(e, this.trgtEle);
        if (skipUnhideRowCol) {
            this.parent.notify(readonlyAlert, null);
            return;
        }
        if (this.trgtEle.classList.contains('e-colresize')) {
            const colIndx = parseInt(this.trgtEle.getAttribute('aria-colindex'), 10) - 1;
            const prevWidth = `${getColumnWidth(this.parent.getActiveSheet(), colIndx)}px`;
            if (this.trgtEle.classList.contains('e-unhide-column')) {
                this.showHiddenColumns(colIndx - 1);
            }
            else {
                this.setAutofit(colIndx, true, prevWidth, this.trgtEle);
            }
        }
        else if (this.trgtEle.classList.contains('e-rowresize')) {
            const rowIndx = parseInt(this.trgtEle.parentElement.getAttribute('aria-rowindex'), 10) - 1;
            const prevHeight = `${getRowHeight(this.parent.getActiveSheet(), rowIndx)}px`;
            this.setAutofit(rowIndx, false, prevHeight);
        }
        this.parent.notify(positionAutoFillElement, null);
    }
    setTarget(e) {
        if (this.parent.isEdit || !closest(e.target, '.e-header-cell') || e.target.className.includes('e-filter-icon')) {
            return;
        }
        const trgt = e.target;
        const sheet = this.parent.getActiveSheet();
        if (sheet.isProtected && (!sheet.protectSettings.formatColumns || !sheet.protectSettings.formatRows)) {
            if (!sheet.protectSettings.formatRows && !sheet.protectSettings.formatColumns) {
                return;
            }
            if (sheet.protectSettings.formatRows) {
                if (closest(trgt, '.e-colhdr-table')) {
                    return;
                }
            }
            if (sheet.protectSettings.formatColumns) {
                if (closest(trgt, '.e-rowhdr-table')) {
                    return;
                }
            }
        }
        let newTrgt;
        let tOffsetV;
        let eOffsetV;
        let tClass;
        if (closest(trgt, '.e-header-row')) {
            tOffsetV = trgt.offsetWidth;
            tClass = 'e-colresize';
            eOffsetV = this.parent.enableRtl ? (tOffsetV - e.offsetX) : e.offsetX;
            const prevSibling = this.getColPrevSibling(trgt);
            if (prevSibling && !prevSibling.classList.contains('e-select-all-cell')) {
                newTrgt = prevSibling;
            }
            else {
                if (Number(trgt.getAttribute('aria-colindex')) > 1) {
                    newTrgt = trgt;
                }
            }
        }
        else if (closest(trgt, '.e-row')) {
            eOffsetV = e.offsetY;
            tOffsetV = trgt.offsetHeight;
            tClass = 'e-rowresize';
            const prevSibling = this.getRowPrevSibling(trgt);
            if (prevSibling) {
                newTrgt = prevSibling.firstElementChild;
            }
            else {
                if (Number(trgt.parentElement.getAttribute('aria-rowindex')) > 1) {
                    newTrgt = trgt;
                }
            }
        }
        if (tOffsetV - 2 < 8 && eOffsetV !== Math.ceil((tOffsetV - 2) / 2)) {
            if (eOffsetV < Math.ceil((tOffsetV - 2) / 2)) {
                trgt.classList.add(tClass);
                if (newTrgt) {
                    newTrgt.classList.add(tClass);
                }
            }
            else if (eOffsetV > Math.ceil((tOffsetV - 2) / 2)) {
                trgt.classList.add(tClass);
            }
        }
        else if (tOffsetV - 5 < eOffsetV && eOffsetV <= tOffsetV && tOffsetV >= 10) {
            trgt.classList.add(tClass);
        }
        else if (eOffsetV < 5 && newTrgt && tOffsetV >= 10) {
            trgt.classList.add(tClass);
            newTrgt.classList.add(tClass);
        }
        else {
            const resEle = this.parent.element.getElementsByClassName(tClass);
            for (let index = 0; index < resEle.length; index++) {
                resEle[index].classList.remove(tClass);
            }
        }
    }
    getColPrevSibling(trgt) {
        const frozenCol = this.parent.frozenColCount(this.parent.getActiveSheet());
        return trgt.previousElementSibling || (frozenCol && closest(trgt, '.e-column-header') ?
            this.parent.getSelectAllContent().querySelector('.e-header-row').lastElementChild : null);
    }
    getRowPrevSibling(trgt) {
        const frozenRow = this.parent.frozenRowCount(this.parent.getActiveSheet());
        return trgt.parentElement.previousElementSibling || (frozenRow && closest(trgt, '.e-row-header') ?
            this.parent.getSelectAllContent().querySelector('tbody').lastElementChild : null);
    }
    updateTarget(e, trgt) {
        if (closest(trgt, '.e-header-row')) {
            const offsetX = this.parent.enableRtl ? (trgt.offsetWidth - e.offsetX) : e.offsetX;
            if ((trgt.offsetWidth < 10 && offsetX < Math.ceil((trgt.offsetWidth - 2) / 2)) || (offsetX < 5 &&
                trgt.offsetWidth >= 10) && trgt.classList.contains('e-colresize')) {
                const sheet = this.parent.getActiveSheet();
                const prevIdx = Number(this.trgtEle.getAttribute('aria-colindex')) - 2;
                const prevSibling = this.getColPrevSibling(trgt);
                if (prevSibling && !isHiddenCol(sheet, prevIdx)) {
                    this.trgtEle = prevSibling;
                }
                else {
                    if (prevIdx > -1) {
                        const colModel = getColumn(sheet, prevIdx);
                        if (colModel.isReadOnly || isReadOnlyCells(this.parent, [0, prevIdx, sheet.rowCount - 1, prevIdx])) {
                            return true;
                        }
                        this.trgtEle.classList.add('e-unhide-column');
                    }
                }
            }
        }
        else {
            if ((trgt.offsetHeight < 10 && e.offsetY < Math.ceil((trgt.offsetHeight - 2) / 2)) || (e.offsetY < 5 &&
                trgt.offsetHeight >= 10) && trgt.classList.contains('e-rowresize')) {
                const sheet = this.parent.getActiveSheet();
                const prevIdx = Number(trgt.parentElement.getAttribute('aria-rowindex')) - 2;
                const prevSibling = this.getRowPrevSibling(trgt);
                if (prevSibling || isHiddenRow(sheet, prevIdx)) {
                    if (e.type === 'dblclick' && isHiddenRow(sheet, prevIdx)) {
                        const rowModel = getRow(sheet, prevIdx);
                        if (rowModel.isReadOnly || isReadOnlyCells(this.parent, [prevIdx, 0, prevIdx, sheet.colCount - 1])) {
                            return true;
                        }
                        const selectRange = getSwapRange(getRangeIndexes(sheet.selectedRange));
                        let eventArgs;
                        if (prevIdx <= selectRange[2] && prevIdx > selectRange[0] && isRowSelected(sheet, selectRange)) {
                            eventArgs = { startIndex: selectRange[0], endIndex: selectRange[2], hide: false, autoFit: true };
                        }
                        else {
                            eventArgs = { startIndex: prevIdx, endIndex: prevIdx, hide: false, autoFit: true };
                        }
                        this.parent.notify(hideShow, eventArgs);
                    }
                    else {
                        if (!isHiddenRow(sheet, prevIdx)) {
                            this.trgtEle = prevSibling.getElementsByClassName('e-header-cell')[0];
                        }
                    }
                }
            }
        }
        return false;
    }
    setAutoFitHandler(args) {
        if (args.isCol && isHiddenCol(this.parent.getActiveSheet(), args.idx)) {
            this.showHiddenColumns(args.idx);
        }
        else {
            this.setAutofit(args.idx, args.isCol, null, null, args.sheetIdx);
        }
    }
    getWrapText(text, colwidth, style) {
        const textArr = text.toString().split(' ');
        const spaceWidth = getTextWidth(' ', style, this.parent.cellStyle);
        let width;
        let textWidth = 0;
        let prevWidth = 0;
        let displayText = text;
        let val = '';
        const setDisplayText = () => {
            const curWidth = parseInt(prevWidth.toString(), 10);
            if (curWidth > textWidth || (curWidth === textWidth && getTextWidth(val.trim(), style, this.parent.cellStyle) >
                getTextWidth(displayText, style, this.parent.cellStyle))) {
                displayText = val.trim();
                textWidth = curWidth;
            }
        };
        textArr.forEach((txt, index) => {
            width = getTextWidth(txt, style, this.parent.cellStyle);
            if ((prevWidth + width) / colwidth > 1) {
                setDisplayText();
                val = '';
                prevWidth = width;
            }
            else {
                width += ((prevWidth + width + spaceWidth) / colwidth >= 1 ? 0 : spaceWidth);
                prevWidth += width;
            }
            val += txt + ' ';
            if (index === textArr.length - 1) {
                setDisplayText();
            }
        });
        return displayText;
    }
    setAutofit(idx, isCol, prevData, hdrCell, sheetIdx) {
        const sheet = !isNullOrUndefined(sheetIdx) ? getSheet(this.parent, sheetIdx) : this.parent.getActiveSheet();
        let autoFitWithHeader;
        const isActiveSheet = !isNullOrUndefined(sheetIdx) ? sheetIdx === this.parent.activeSheetIndex : true;
        if (hdrCell) {
            const eventArgs = { cancel: false, index: idx, isCol: isCol,
                sheetIndex: this.parent.activeSheetIndex };
            if (isCol) {
                eventArgs.oldWidth = prevData;
                eventArgs.autoFitWithHeader = false;
            }
            else {
                eventArgs.oldHeight = prevData;
            }
            this.parent.notify(beginAction, { eventArgs: eventArgs, action: 'resizeToFit' });
            if (eventArgs.cancel) {
                return;
            }
            autoFitWithHeader = eventArgs.autoFitWithHeader;
        }
        let oldValue;
        let cell = {};
        let cellEle;
        let colGrp;
        let wrapCell;
        const table = this.parent.createElement('table', { className: this.parent.getContentTable().className + ' e-resizetable', styles: 'height: auto' });
        const tBody = this.parent.createElement('tbody');
        const rowEle = this.parent.createElement('tr', { className: 'e-row' });
        const tdEle = this.parent.createElement('td', { className: 'e-cell' });
        let tableWidth = 0;
        let colWidth = 0;
        if (isCol) {
            let row;
            table.style.width = 'auto';
            const appendRow = (content) => {
                cellEle = tdEle.cloneNode();
                cellEle.textContent = content;
                cellEle.style.fontFamily = (cell.style && cell.style.fontFamily) || this.parent.cellStyle.fontFamily;
                cellEle.style.fontSize = (cell.style && cell.style.fontSize) || this.parent.cellStyle.fontSize;
                cellEle.style.fontWeight = (cell.style && cell.style.fontWeight) || this.parent.cellStyle.fontWeight;
                row = rowEle.cloneNode();
                row.appendChild(cellEle);
                tBody.appendChild(row);
            };
            if (autoFitWithHeader) {
                appendRow(hdrCell.textContent);
            }
            for (let rowIdx = 0, len = sheet.rows.length; rowIdx < len; rowIdx++) {
                cell = getCell(rowIdx, idx, sheet);
                if (cell && cell.value) {
                    if (cell.wrap) {
                        wrapCell = true;
                        appendRow(this.getWrapText(this.parent.getDisplayText(cell), getExcludedColumnWidth(sheet, idx, idx, cell.colSpan > 1 ? idx + cell.colSpan - 1 : idx), cell.style));
                    }
                    else {
                        appendRow(this.parent.getDisplayText(cell));
                    }
                }
            }
            oldValue = getColumnWidth(sheet, idx);
        }
        else {
            const colLength = sheet.rows[idx] && sheet.rows[idx].cells ?
                sheet.rows[idx].cells.length : 0;
            colGrp = this.parent.createElement('colgroup');
            for (let colIdx = 0; colIdx < colLength; colIdx++) {
                cell = getCell(idx, colIdx, sheet);
                if (cell) {
                    cellEle = tdEle.cloneNode();
                    if (cell.wrap) {
                        cellEle.classList.add('e-wraptext');
                    }
                    cellEle.textContent = this.parent.getDisplayText(cell);
                    cellEle.style.fontFamily = (cell.style && cell.style.fontFamily) || this.parent.cellStyle.fontFamily;
                    cellEle.style.fontSize = (cell.style && cell.style.fontSize) || this.parent.cellStyle.fontSize;
                    rowEle.appendChild(cellEle);
                    colWidth = (cell.colSpan && cell.colSpan >= 1) ? this.getMergedColumnsWidth(cell.colSpan, colIdx, sheet) :
                        (cell.colSpan && cell.colSpan < 1) ? 0 : getColumnWidth(sheet, colIdx, false, true);
                    tableWidth += colWidth;
                    colGrp.appendChild(this.parent.createElement('col', { styles: `width:${colWidth}px` }));
                }
            }
            table.appendChild(colGrp);
            tBody.appendChild(rowEle);
            oldValue = getRowHeight(sheet, idx);
        }
        table.appendChild(tBody);
        if (tableWidth) {
            table.style.width = tableWidth + 'px';
        }
        const wrapper = this.parent.createElement('div', { className: this.parent.element.className, styles: 'display: block' });
        wrapper.appendChild(table);
        document.body.appendChild(wrapper);
        const offset = table.getBoundingClientRect();
        document.body.removeChild(wrapper);
        const fitSize = Math.ceil(isCol ? offset.width : offset.height);
        let autofitValue = (isCol ? this.getFloatingElementWidth(fitSize + (wrapCell ? 1 : 0), idx) : fitSize) || oldValue;
        let threshold;
        if (isCol) {
            if (autofitValue > 0) {
                threshold = -(oldValue - autofitValue);
            }
            else {
                threshold = -oldValue;
            }
            const frozenCol = this.parent.frozenColCount(sheet);
            if ((frozenCol && idx >= getRangeIndexes(sheet.topLeftCell)[1] && idx < frozenCol) ||
                (idx >= this.parent.viewport.leftIndex + frozenCol && idx <= this.parent.viewport.rightIndex)) {
                getColumn(sheet, idx).width = autofitValue > 0 ? autofitValue : 0;
                if (isActiveSheet) {
                    this.resizeStart(idx, this.parent.getViewportIndex(idx, true), autofitValue + 'px', isCol, true, prevData);
                    this.parent.notify(colWidthChanged, { threshold: threshold, colIdx: idx });
                }
            }
            else {
                if (isActiveSheet) {
                    this.parent.notify(colWidthChanged, { threshold: threshold, colIdx: idx });
                }
                getColumn(sheet, idx).width = autofitValue > 0 ? autofitValue : 0;
            }
        }
        else {
            const frozenRow = this.parent.frozenRowCount(sheet);
            autofitValue = autofitValue > 20 ? autofitValue : 20;
            threshold = -(oldValue - autofitValue);
            if ((frozenRow && idx >= getRangeIndexes(sheet.topLeftCell)[0] && idx < frozenRow) ||
                (idx >= this.parent.viewport.topIndex + frozenRow && idx <= this.parent.viewport.bottomIndex)) {
                setRowHeight(sheet, idx, autofitValue);
                setRow(sheet, idx, { customHeight: false });
                if (isActiveSheet) {
                    this.resizeStart(idx, this.parent.getViewportIndex(idx), autofitValue + 'px', isCol, true, prevData);
                    this.parent.notify(rowHeightChanged, { threshold: threshold, rowIdx: idx });
                }
            }
            else {
                if (isActiveSheet) {
                    this.parent.notify(rowHeightChanged, { threshold: threshold, rowIdx: idx });
                }
                setRowHeight(sheet, idx, autofitValue);
            }
        }
        if (isActiveSheet) {
            this.parent.selectRange(sheet.selectedRange);
        }
    }
    getMergedColumnsWidth(colSpan, colIndex, sheet) {
        let columnWidth = 0;
        for (let i = 0; i < colSpan; i++) {
            columnWidth += getColumnWidth(sheet, colIndex, false, true);
            colIndex++;
        }
        return columnWidth;
    }
    createResizeHandler(trgt, className) {
        const editor = this.parent.createElement('div', { className: className });
        editor.classList.add('e-resize-handle');
        const sheet = document.getElementById(this.parent.element.id + '_sheet');
        if (trgt.classList.contains('e-colresize')) {
            editor.style.height = this.parent.getMainContent().parentElement.clientHeight + this.parent.getColumnHeaderContent().offsetHeight + 'px';
            editor.style.left = this.event.clientX - sheet.getBoundingClientRect().left + 'px';
            editor.style.top = '0px';
        }
        else if (trgt.classList.contains('e-rowresize')) {
            editor.style.width = this.parent.getMainContent().parentElement.clientWidth + 'px';
            editor.style.left = '0px';
            editor.style.top = this.event.clientY - sheet.getBoundingClientRect().top + 'px';
        }
        sheet.appendChild(editor);
        this.resizeTooltip(trgt, false);
        this.updateCursor();
    }
    resizeTooltip(trgt, isResize, e) {
        if (isResize) {
            const isRtl = this.parent.enableRtl;
            const HeaderTolltip = document.querySelector('.e-header-tooltip');
            const colResizeHandler = this.parent.element.getElementsByClassName('e-colresize-handler')[0];
            const rowResizeHandler = this.parent.element.getElementsByClassName('e-rowresize-handler')[0];
            if (colResizeHandler) {
                const trgtWidth = isRtl ? (Math.round(this.trgtEle.getBoundingClientRect().right) - (e.clientX)) :
                    ((e.clientX) - Math.round(this.trgtEle.getBoundingClientRect().left));
                if (HeaderTolltip) {
                    HeaderTolltip.firstChild.textContent = trgtWidth > 0 ? ('Width:(' + trgtWidth.toString() + ' pixels)') : ('Width: 0.00');
                }
            }
            else if (rowResizeHandler) {
                const trgtHeight = (e.clientY) - Math.round(this.trgtEle.getBoundingClientRect().top);
                if (HeaderTolltip) {
                    HeaderTolltip.firstChild.textContent = trgtHeight > 0 ? ('Height:(' + trgtHeight.toString() + ' pixels)') : ('Height: 0.00');
                }
            }
        }
        else {
            const isColResize = trgt.classList.contains('e-colresize');
            const isRowResize = trgt.classList.contains('e-rowresize');
            if (isColResize || isRowResize) {
                const className = isColResize ? 'e-colresize-handler' : 'e-rowresize-handler';
                const tooltip = new Tooltip({
                    cssClass: 'e-header-tooltip',
                    showTipPointer: false
                });
                if (isColResize) {
                    tooltip.content = initializeCSPTemplate(() => {
                        return 'Width:(' + Math.round(trgt.getBoundingClientRect().width).toString() + ' pixels)';
                    });
                }
                else if (isRowResize) {
                    tooltip.content = initializeCSPTemplate(() => {
                        return 'Height:(' + Math.round(trgt.getBoundingClientRect().height).toString() + ' pixels)';
                    });
                    tooltip.offsetX = -((this.parent.getMainContent().parentElement.clientWidth / 2) -
                        Math.round(trgt.getBoundingClientRect().width));
                }
                tooltip.appendTo('.' + className);
                tooltip.open();
                tooltip.refresh();
            }
        }
    }
    setColWidth(index, viewportIdx, width, curWidth) {
        const sheet = this.parent.getActiveSheet();
        let threshold = getDPRValue(width) - curWidth;
        if (threshold < 0 && curWidth < -(threshold)) {
            threshold = -curWidth;
        }
        if (width > 0) {
            if (this.isMouseMoved && this.trgtEle.classList.contains('e-unhide-column')) {
                this.showHiddenColumns(index, width);
                this.parent.notify(completeAction, {
                    eventArgs: {
                        index: index, width: `${0}px`, isCol: true, sheetIndex: this.parent.activeSheetIndex, oldWidth: `${curWidth}px`,
                        hide: false
                    }, action: 'resize'
                });
                return;
            }
            this.resizeStart(index, viewportIdx, `${width}px`, true, false, `${curWidth}px`);
            setColumn(sheet, index, { width: width, customWidth: true });
            this.parent.notify(colWidthChanged, { threshold, colIdx: index, checkWrapCell: true });
        }
        else {
            if (this.isMouseMoved) {
                this.parent.hideColumn(index);
                this.showHideCopyIndicator();
                this.parent.notify(completeAction, {
                    eventArgs: {
                        index: index, width: `${0}px`, isCol: true, sheetIndex: this.parent.activeSheetIndex, oldWidth: `${curWidth}px`,
                        hide: true
                    }, action: 'resize'
                });
            }
        }
    }
    showHideCopyIndicator() {
        const copyIndicator = this.parent.element.getElementsByClassName('e-copy-indicator')[0];
        let isIndicator = false;
        if (copyIndicator) {
            detach(copyIndicator);
            this.parent.notify(hideAutoFillElement, null);
            isIndicator = true;
        }
        if (isIndicator) {
            this.parent.notify(contentLoaded, {});
        }
    }
    showHiddenColumns(index, width) {
        const sheet = this.parent.getActiveSheet();
        const selectedRange = getRangeIndexes(sheet.selectedRange);
        let startIdx;
        let endIdx;
        let colgroup;
        if (index >= selectedRange[1] && index <= selectedRange[3] && selectedRange[2] === sheet.rowCount - 1 &&
            getCellIndexes(sheet.activeCell)[0] === getCellIndexes(sheet.topLeftCell)[0]) {
            startIdx = selectedRange[1];
            endIdx = selectedRange[3];
            colgroup = this.parent.getMainContent().querySelector('colgroup');
        }
        else {
            startIdx = endIdx = index;
        }
        if (width !== undefined) {
            for (let i = startIdx; i <= endIdx; i++) {
                setColumn(sheet, i, { width: width, customWidth: true });
                if (i >= this.parent.viewport.leftIndex && i <= this.parent.viewport.rightIndex && !isHiddenCol(sheet, i)) {
                    colgroup.children[this.parent.getViewportIndex(i, true)].style.width = `${width}px`;
                }
            }
        }
        if (this.trgtEle) {
            this.trgtEle.classList.remove('e-unhide-column');
        }
        const hideEvtArgs = { startIndex: startIdx, endIndex: endIdx, hide: false, isCol: true, autoFit: true };
        this.parent.notify(hideShow, hideEvtArgs);
        this.showHideCopyIndicator();
        if (width === undefined) {
            if (hideEvtArgs.autoFit) {
                this.autoFit({ isRow: false, startIndex: startIdx, endIndex: endIdx });
            }
            else {
                const performAutoFit = () => {
                    this.parent.off(contentLoaded, performAutoFit);
                    this.autoFit({ isRow: false, startIndex: startIdx, endIndex: endIdx });
                };
                this.parent.on(contentLoaded, performAutoFit, this);
            }
        }
    }
    setRowHeight(rowIdx, viewportIdx, height, prevData) {
        const sheet = this.parent.getActiveSheet();
        const frozenCol = this.parent.frozenColCount(sheet);
        const eleHeight = parseInt(this.parent.getRow(rowIdx, null, frozenCol).style.height, 10);
        const rowHeight = height;
        let threshold = getDPRValue(parseInt(rowHeight, 10)) - eleHeight;
        if (threshold < 0 && eleHeight < -(threshold)) {
            threshold = -eleHeight;
        }
        let customHeight;
        if (sheet.rows[rowIdx] && sheet.rows[rowIdx].customHeight) {
            customHeight = true;
        }
        this.resizeStart(rowIdx, viewportIdx, rowHeight, false, false, prevData, customHeight);
        setRow(sheet, rowIdx, { height: parseInt(rowHeight, 10) > 0 ? parseInt(rowHeight, 10) : 0, customHeight: true });
        this.parent.notify(rowHeightChanged, { threshold, rowIdx: rowIdx, isCustomHgt: true });
    }
    resizeOn(e) {
        let idx;
        let actualIdx;
        const sheet = this.parent.getActiveSheet();
        const activeCell = getRangeIndexes(sheet.activeCell);
        const cell = getCell(activeCell[0], activeCell[1], sheet);
        if (this.trgtEle.classList.contains('e-rowresize')) {
            const prevIdx = Number(this.trgtEle.parentElement.getAttribute('aria-rowindex')) - 2;
            if (this.isMouseMoved && isHiddenRow(sheet, prevIdx) && this.trgtEle.classList.contains('e-skip-resize') &&
                e.clientY > this.trgtEle.getBoundingClientRect().top) {
                this.trgtEle.classList.remove('e-skip-resize');
                const eventArgs = { startIndex: prevIdx, endIndex: prevIdx, hide: false, skipAppend: true };
                this.parent.notify(hideShow, eventArgs);
                const rTbody = this.parent.getRowHeaderTable().tBodies[0];
                const tbody = this.parent.getContentTable().tBodies[0];
                eventArgs.hdrRow.style.display = 'none';
                eventArgs.row.style.display = 'none';
                rTbody.insertBefore(eventArgs.hdrRow, rTbody.children[eventArgs.insertIdx]);
                tbody.insertBefore(eventArgs.row, tbody.children[eventArgs.insertIdx]);
                this.trgtEle = eventArgs.hdrRow.firstElementChild;
                eventArgs.hdrRow.nextElementSibling.classList.remove('e-hide-end');
                eventArgs.mergeCollection.forEach((mergeArgs) => { this.parent.notify(setMerge, mergeArgs); });
            }
            else {
                if (this.trgtEle.classList.contains('e-skip-resize')) {
                    this.trgtEle.classList.remove('e-skip-resize');
                    if ((!this.isMouseMoved && isHiddenRow(sheet, prevIdx)) || !this.trgtEle.parentElement.previousElementSibling) {
                        return;
                    }
                    this.trgtEle = this.trgtEle.parentElement.previousElementSibling.getElementsByClassName('e-header-cell')[0];
                }
            }
            actualIdx = idx = parseInt(this.trgtEle.parentElement.getAttribute('aria-rowindex'), 10) - 1;
            idx = this.parent.getViewportIndex(actualIdx);
            const frozenCol = this.parent.frozenColCount(sheet);
            let prevData = this.parent.getRow(actualIdx, null, frozenCol).style.height;
            let rowHeight = e.clientY - this.event.clientY + parseInt(prevData, 10);
            if (rowHeight <= 0) {
                this.parent.hideRow(actualIdx);
                this.showHideCopyIndicator();
                setRow(sheet, actualIdx, { height: 0, customHeight: true });
                this.parent.notify(completeAction, {
                    eventArgs: { index: actualIdx, height: '0px', isCol: false, sheetIndex: this.parent.activeSheetIndex, oldHeight: prevData },
                    action: 'resize'
                });
                return;
            }
            this.setRowHeight(actualIdx, idx, `${rowHeight}px`, prevData);
            this.parent.notify(refreshFilterCellsOnResize, { rowIndex: actualIdx });
            if (this.trgtEle.parentElement.style.display === 'none') {
                const sheet = this.parent.getActiveSheet();
                const selectedRange = getSwapRange(getRangeIndexes(sheet.selectedRange));
                if (actualIdx <= selectedRange[2] && actualIdx > selectedRange[0]) {
                    rowHeight = getRowHeight(sheet, actualIdx);
                    let count;
                    for (let i = selectedRange[0]; i <= selectedRange[2]; i++) {
                        if (i === actualIdx) {
                            continue;
                        }
                        prevData = `${getRowHeight(sheet, i)}px`;
                        setRow(sheet, i, { customHeight: true, height: rowHeight });
                        if (isHiddenRow(sheet, i)) {
                            if (!count) {
                                count = i;
                            }
                        }
                        else {
                            this.parent.getRow(i).style.height = `${rowHeight}px`;
                            if (sheet.showHeaders) {
                                this.parent.getRow(i, this.parent.getRowHeaderTable()).style.height = `${rowHeight}px`;
                            }
                        }
                        this.parent.notify(completeAction, {
                            eventArgs: {
                                index: i, height: `${rowHeight}px`, isCol: false,
                                sheetIndex: this.parent.activeSheetIndex, oldHeight: prevData
                            },
                            action: 'resize'
                        });
                    }
                    this.parent.hideRow(selectedRange[0], actualIdx - 1, false);
                    this.showHideCopyIndicator();
                    idx += Math.abs(actualIdx - count);
                }
                else {
                    if (idx !== 0 && !isHiddenRow(sheet, actualIdx - 1)) {
                        this.trgtEle.parentElement.previousElementSibling.classList.remove('e-hide-start');
                    }
                    else {
                        if (idx !== 0) {
                            this.trgtEle.parentElement.classList.add('e-hide-end');
                        }
                    }
                    this.parent.selectRange(sheet.selectedRange);
                }
                this.trgtEle.parentElement.style.display = '';
                this.parent.getContentTable().rows[idx].style.display = '';
            }
        }
        else if (this.trgtEle.classList.contains('e-colresize')) {
            if (this.isMouseMoved && this.trgtEle.classList.contains('e-unhide-column') &&
                e.clientX < this.trgtEle.getBoundingClientRect().left) {
                this.trgtEle.classList.remove('e-unhide-column');
                if (this.trgtEle.previousElementSibling) {
                    this.trgtEle = this.trgtEle.previousElementSibling;
                }
            }
            idx = parseInt(this.trgtEle.getAttribute('aria-colindex'), 10) - 1;
            let curWidth;
            if (this.trgtEle.classList.contains('e-unhide-column')) {
                idx -= 1;
                curWidth = 0;
            }
            else {
                curWidth = getColumnWidth(this.parent.getActiveSheet(), idx);
            }
            this.setColWidth(idx, this.parent.getViewportIndex(idx, true), (this.parent.enableRtl ?
                (this.event.clientX - e.clientX) : (e.clientX - this.event.clientX)) + curWidth, curWidth);
        }
        if (cell && cell.format && cell.format.includes('*')) {
            this.parent.notify(getFormattedCellObject, { value: cell.value, format: cell.format, cell: cell,
                formattedText: cell.value, rowIndex: activeCell[0], colIndex: activeCell[1] });
        }
    }
    resizeStart(idx, viewportIdx, value, isCol, isFit, prevData, isCustomHeight) {
        setResize(idx, viewportIdx, value, isCol, this.parent);
        const action = isFit ? 'resizeToFit' : 'resize';
        let eventArgs;
        let isAction;
        if (isCol) {
            eventArgs = { index: idx, width: value, isCol: isCol, sheetIndex: this.parent.activeSheetIndex, oldWidth: prevData };
            isAction = prevData !== value;
        }
        else {
            eventArgs = { index: idx, height: value, isCol: isCol, sheetIndex: this.parent.activeSheetIndex, oldHeight: prevData,
                isPrevCustomHeight: isCustomHeight };
            isAction = prevData !== value;
        }
        if (isAction) {
            this.parent.notify(completeAction, { eventArgs: eventArgs, action: action });
        }
    }
    updateCursor() {
        if (this.parent.element.getElementsByClassName('e-colresize-handler')[0]) {
            this.parent.element.classList.add('e-col-resizing');
        }
        else if (this.parent.element.classList.contains('e-col-resizing')) {
            this.parent.element.classList.remove('e-col-resizing');
        }
        if (this.parent.element.getElementsByClassName('e-rowresize-handler')[0]) {
            this.parent.element.classList.add('e-row-resizing');
        }
        else if (this.parent.element.classList.contains('e-row-resizing')) {
            this.parent.element.classList.remove('e-row-resizing');
        }
    }
    // To get the floating element width like filter
    getFloatingElementWidth(oldWidth, colIdx) {
        let floatingWidth = oldWidth;
        const eventArgs = { filterRange: [], hasFilter: false };
        this.parent.notify(getFilterRange, eventArgs);
        if (eventArgs.hasFilter && eventArgs.filterRange) {
            if (eventArgs.filterRange[1] <= colIdx && eventArgs.filterRange[3] >= colIdx) {
                floatingWidth = oldWidth + 22; // default width and padding for button
            }
        }
        return floatingWidth;
    }
    /**
     * To destroy the resize module.
     *
     * @returns {void} - To destroy the resize module.
     */
    destroy() {
        this.unwireEvents();
        this.removeEventListener();
        if (this.trgtEle) {
            this.trgtEle.remove();
        }
        this.trgtEle = null;
        this.event = null;
        this.parent = null;
    }
    /**
     * Get the module name.
     *
     * @returns {string} - Get the module name.
     */
    getModuleName() {
        return 'resize';
    }
    propertyChange(args) {
        if (args.propertyName === 'allowResizing') {
            this.wireEvents();
        }
    }
}

/**
 * The `ShowHide` module is used to perform hide/show the rows and columns.
 *
 * @hidden
 */
class ShowHide {
    /**
     * Constructor for the Spreadsheet show hide module.
     *
     * @param {Spreadsheet} parent - Specify the spreadsheet instance.
     * @private
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    hideShow(args) {
        const sheetIndex = isUndefined$1(args.sheetIndex) ? this.parent.activeSheetIndex : args.sheetIndex;
        const sheet = getSheet(this.parent, sheetIndex);
        if (args.startIndex > args.endIndex) {
            const temp = args.startIndex;
            args.startIndex = args.endIndex;
            args.endIndex = temp;
        }
        if (args.actionUpdate !== undefined) {
            const range = args.isCol ? [0, args.startIndex, sheet.rowCount - 1, args.endIndex] :
                [args.startIndex, 0, args.endIndex, sheet.colCount - 1];
            if (isReadOnlyCells(this.parent, range)) {
                if (args.actionUpdate) {
                    this.parent.notify(readonlyAlert, null);
                }
                return;
            }
        }
        let actionArgs;
        if (args.actionUpdate) {
            args.sheetIndex = sheetIndex;
            actionArgs = { eventArgs: args, action: 'hideShow' };
            this.parent.notify(beginAction, actionArgs);
            if (args.cancel) {
                return;
            }
            delete args.cancel;
        }
        if (args.hide) {
            args.hiddenIndexes = [];
        }
        const performHideShow = (updateViewport) => {
            if (args.isCol) {
                this.hideCol(args);
                if (updateViewport) {
                    this.parent.sheetModule.colWidthChanged({ colIdx: args.startIndex, isHideShow: true });
                }
            }
            else {
                this.hideRow(args);
                if (updateViewport) {
                    this.parent.sheetModule.rowHeightChanged({ rowIdx: args.startIndex, isHideShow: true });
                }
            }
        };
        const freezePane = args.isCol ? this.parent.frozenColCount(sheet) : this.parent.frozenRowCount(sheet);
        if (freezePane && args.startIndex < freezePane) {
            let endIndex;
            args.freezePane = true;
            if (args.endIndex >= freezePane) {
                endIndex = args.endIndex;
                args.endIndex = freezePane - 1;
            }
            performHideShow(true);
            delete args.freezePane;
            if (endIndex !== undefined) {
                const startIndex = args.startIndex;
                args.endIndex = endIndex;
                args.startIndex = freezePane;
                performHideShow(!this.parent.scrollSettings.enableVirtualization);
                args.startIndex = startIndex;
            }
        }
        else {
            performHideShow(!this.parent.scrollSettings.enableVirtualization);
        }
        if (args.actionUpdate) {
            this.updateIndexOnlyForHiddenColumnsAndRows(args, sheet);
            this.parent.notify(completeAction, actionArgs);
            focus(this.parent.element);
        }
    }
    updateIndexOnlyForHiddenColumnsAndRows(args, sheet) {
        const startIndex = args.startIndex;
        const endIndex = args.endIndex;
        let model;
        for (let sIdx = args.startIndex; sIdx <= endIndex; sIdx++) {
            model = args.isCol ? getColumn(sheet, sIdx) : getRow(sheet, sIdx) || {};
            if (model.hidden === false) {
                args.startIndex = sIdx;
                break;
            }
        }
        for (let eIdx = args.endIndex; eIdx >= startIndex; eIdx--) {
            model = args.isCol ? getColumn(sheet, eIdx) : getRow(sheet, eIdx) || {};
            if (model.hidden === false) {
                args.endIndex = eIdx;
                break;
            }
        }
    }
    hideRow(eventArgs) {
        const sheetIndex = isUndefined$1(eventArgs.sheetIndex) ? this.parent.activeSheetIndex : eventArgs.sheetIndex;
        const sheet = getSheet(this.parent, sheetIndex);
        let cell;
        let count = 0;
        let idx;
        let nextIdx;
        let merge;
        let model;
        const args = Object.assign({}, eventArgs);
        const isFinite = this.parent.scrollSettings.isFinite && !args.freezePane;
        let height;
        if (isFinite) {
            if (args.startIndex >= sheet.rowCount) {
                return;
            }
            if (args.endIndex >= sheet.rowCount) {
                args.endIndex = sheet.rowCount - 1;
            }
            height = 0;
        }
        const frozenRow = this.parent.frozenRowCount(sheet);
        if (args.hide) {
            let content;
            let rowHdr;
            let row;
            let prevChartIndexes = [];
            let currentChartIndexes = [];
            const updateBtmIdx = isFinite && args.endIndex === skipHiddenIdx(sheet, sheet.rowCount - 1, false);
            for (let i = args.startIndex; i <= args.endIndex; i++) {
                if (isHiddenRow(sheet, i)) {
                    if (args.isFiltering && !isFilterHidden(sheet, i)) {
                        setRow(sheet, i, { isFiltered: true });
                    }
                    continue;
                }
                if (idx === undefined) {
                    if (args.freezePane) {
                        rowHdr = this.parent.sheetModule.getSelectAllTable();
                        content = this.parent.getColHeaderTable();
                    }
                    else {
                        rowHdr = this.parent.getRowHeaderTable();
                        content = this.parent.getContentTable();
                    }
                    idx = this.parent.getViewportIndex(i);
                    count = 0;
                }
                model = { hidden: true };
                if (args.isFiltering) {
                    model.isFiltered = true;
                }
                if (!args.isFiltering) {
                    prevChartIndexes = getChartsIndexes(this.parent);
                }
                setRow(sheet, i, model);
                if (!args.isFiltering) {
                    currentChartIndexes = getChartsIndexes(this.parent);
                }
                if (sheetIndex !== this.parent.activeSheetIndex) {
                    continue;
                }
                if (isFinite) {
                    height += getRowHeight(sheet, i, true, true);
                }
                this.refreshChart(i, 'rows');
                if (!args.isFiltering) {
                    this.refreshChartCellModel(prevChartIndexes, currentChartIndexes);
                }
                row = content && content.rows[idx];
                if (row) {
                    if (!merge) {
                        for (let j = 0; j <= sheet.usedRange.colIndex; j++) {
                            cell = getCell(i, j, sheet) || {};
                            if ((cell.colSpan || cell.rowSpan) && (args.startIndex >= this.parent.viewport.topIndex ||
                                this.parent.scrollSettings.enableVirtualization)) {
                                merge = true;
                                break;
                            }
                        }
                    }
                    if (merge) {
                        continue;
                    }
                    if (rowHdr.rows[idx]) {
                        detach(rowHdr.rows[idx]);
                    }
                    detach(row);
                    count++;
                    row = content.rows[idx];
                    if (row && i === args.endIndex) {
                        let cell;
                        nextIdx = skipHiddenIdx(sheet, i + 1, true);
                        const first = nextIdx !== skipHiddenIdx(sheet, 0, true) && nextIdx ===
                            (this.parent.viewport.topIndex >= args.startIndex ? args.endIndex + 1 : this.parent.viewport.topIndex) ? 'Row' : '';
                        for (let j = this.parent.viewport.leftIndex; j <= this.parent.viewport.rightIndex; j++) {
                            const borderTop = this.parent.getCellStyleValue(['borderTop'], [nextIdx, j]).borderTop;
                            if (borderTop !== '') {
                                cell = row.cells[j];
                                this.parent.notify(applyCellFormat, {
                                    onActionUpdate: false, rowIdx: nextIdx, colIdx: j,
                                    style: { borderTop: borderTop }, row: row, pRow: row.previousElementSibling,
                                    first: first, td: cell
                                });
                            }
                        }
                    }
                }
                else {
                    if (i <= this.parent.viewport.bottomIndex) {
                        count++;
                    }
                    else {
                        count--;
                    }
                }
            }
            if (args.refreshUI) {
                return;
            }
            if (merge && (args.startIndex >= this.parent.viewport.topIndex || !this.parent.scrollSettings.enableVirtualization)) {
                if (args.isFiltering) {
                    eventArgs.refreshUI = true;
                }
                else {
                    this.parent.selectRange(sheet.selectedRange);
                    if (sheet.frozenRows || sheet.frozenColumns) {
                        this.parent.renderModule.refreshSheet(false, false, true);
                        eventArgs.refreshUI = true;
                    }
                    else {
                        this.parent.renderModule.refreshUI({ rowIndex: this.parent.viewport.topIndex, colIndex: this.parent.viewport.leftIndex, refresh: 'Row' });
                    }
                }
                return;
            }
            if (!count) {
                return;
            }
            this.parent.selectRange(sheet.selectedRange);
            const updateHideClass = () => {
                if (sheet.showHeaders) {
                    const firstIdx = args.freezePane ? 1 : 0;
                    if (idx === firstIdx) {
                        if (rowHdr.rows[firstIdx]) {
                            rowHdr.rows[firstIdx].classList.add('e-hide-end');
                        }
                    }
                    else {
                        if (rowHdr && rowHdr.rows[idx - 1]) {
                            rowHdr.rows[idx - 1].classList.add('e-hide-start');
                        }
                        if (rowHdr && rowHdr.rows[idx]) {
                            rowHdr.rows[idx].classList.add('e-hide-end');
                        }
                    }
                }
            };
            if (!args.freezePane && this.parent.scrollSettings.enableVirtualization) {
                let startIndex = args.startIndex;
                let endIndex = args.startIndex;
                if (args.startIndex < getCellIndexes(sheet.paneTopLeftCell)[0] || count > this.parent.viewport.rowCount) {
                    if (args.isFiltering) {
                        eventArgs.refreshUI = true;
                        return;
                    }
                    this.parent.updateTopLeftCell(skipHiddenIdx(sheet, args.startIndex - 1 < frozenRow ? frozenRow : args.startIndex - 1, true) - frozenRow, null, 'col');
                    this.parent.renderModule.refreshSheet(false, false, true);
                }
                else {
                    startIndex = this.parent.viewport.bottomIndex + 1;
                    endIndex = startIndex + count - 1;
                    const indexes = this.parent.skipHidden(startIndex, endIndex, 'rows', false);
                    startIndex = indexes[0];
                    endIndex = indexes[1];
                    if (isFinite) {
                        if (startIndex >= sheet.rowCount) {
                            if (this.parent.viewport.topIndex + frozenRow === skipHiddenIdx(sheet, frozenRow, true)) {
                                updateHideClass();
                                this.parent.notify(updateTranslate, { isHide: true, height: height });
                                if (updateBtmIdx) {
                                    this.parent.viewport.bottomIndex = skipHiddenIdx(sheet, sheet.rowCount - 1, false);
                                }
                            }
                            else {
                                this.parent.renderModule.refreshSheet(false, false, true);
                            }
                            return;
                        }
                        else if (endIndex >= sheet.rowCount) {
                            this.parent.renderModule.refreshSheet(false, false, true);
                            return;
                        }
                        else {
                            this.parent.notify(updateTranslate, { isHide: true, height: height });
                        }
                    }
                    this.parent.viewport.bottomIndex = endIndex;
                    let colIndex;
                    const frozenCol = this.parent.frozenColCount(sheet);
                    const frozenIdxes = [];
                    if (frozenCol) {
                        frozenIdxes.push(frozenRow);
                        frozenIdxes.push(this.parent.viewport.leftIndex + frozenCol);
                        colIndex = getCellIndexes(sheet.topLeftCell)[1];
                    }
                    else {
                        colIndex = this.parent.viewport.leftIndex;
                    }
                    this.parent.renderModule.refreshUI({ colIndex: colIndex, rowIndex: startIndex, direction: '', refresh: 'RowPart', frozenIndexes: frozenIdxes }, `${getCellAddress(startIndex, colIndex)}:${getCellAddress(endIndex, this.parent.viewport.rightIndex)}`);
                }
            }
            updateHideClass();
        }
        else {
            let hFrag;
            let frag;
            let hRow;
            let row;
            let newStartRow;
            let rowRenderer;
            let content;
            let rowHdr;
            let startRow;
            let endRow = args.startIndex - 1;
            const mergeCollection = [];
            let skipDetach = args.freezePane;
            let direction = 'lastElementChild';
            let detachedHeight = 0;
            const viewportTopIdx = this.parent.viewport.topIndex + frozenRow;
            if (isFinite) {
                const lastIdx = skipHiddenIdx(sheet, sheet.rowCount - 1, false);
                if (this.parent.viewport.bottomIndex === lastIdx) {
                    if (viewportTopIdx === skipHiddenIdx(sheet, frozenRow, true)) {
                        skipDetach = true;
                    }
                    else {
                        const topLeftCell = getRangeIndexes(sheet.paneTopLeftCell)[0];
                        const count = (((sheet.rowCount - 1) - topLeftCell) + 1) -
                            this.parent.hiddenCount(topLeftCell, sheet.rowCount - 1);
                        if (count < this.parent.viewport.rowCount + Math.round(this.parent.getThreshold('row') / 2)) {
                            direction = 'firstElementChild';
                        }
                    }
                }
            }
            const prevChartIndexes = getChartsIndexes(this.parent);
            for (let i = args.startIndex, len = args.endIndex; i <= len; i++) {
                if (!(args.isFiltering ? isHiddenRow(sheet, i) : isHiddenRow(sheet, i) && !isFilterHidden(sheet, i))) {
                    if (args.startIndex === args.endIndex) {
                        return;
                    }
                    if (idx === undefined) {
                        endRow++;
                    }
                    else {
                        newStartRow = i;
                    }
                    continue;
                }
                if (newStartRow !== undefined) {
                    len = i;
                    continue;
                }
                model = { hidden: false };
                if (args.isFiltering) {
                    model.isFiltered = false;
                }
                if (!skipDetach && i > this.parent.viewport.bottomIndex) {
                    setRow(sheet, i, model);
                    if (startRow === undefined) {
                        return;
                    }
                    continue;
                }
                if (startRow === undefined) {
                    startRow = i;
                }
                setRow(sheet, i, model);
                if (sheetIndex !== this.parent.activeSheetIndex) {
                    continue;
                }
                if (isFinite) {
                    height += getRowHeight(sheet, i, true, true);
                }
                this.refreshChart(i, 'rows');
                if (idx === undefined) {
                    hFrag = document.createDocumentFragment();
                    frag = document.createDocumentFragment();
                    rowRenderer = this.parent.serviceLocator.getService('row');
                    if (args.freezePane) {
                        rowHdr = this.parent.sheetModule.getSelectAllTable();
                        content = this.parent.getColHeaderTable();
                    }
                    else {
                        rowHdr = this.parent.getRowHeaderTable();
                        content = this.parent.getContentTable();
                        if (i < this.parent.viewport.topIndex + frozenRow) {
                            this.parent.viewport.topIndex = i - frozenRow;
                        }
                    }
                    idx = this.parent.getViewportIndex(i);
                }
                endRow++;
                hRow = rowRenderer.refresh(i, null, null, true, true);
                hFrag.appendChild(hRow);
                if (rowHdr && rowHdr.rows.length && !skipDetach) {
                    detach(rowHdr.tBodies[0][`${direction}`]);
                }
                row = frag.appendChild(rowRenderer.refresh(i, row, hRow));
                if (content && content.rows.length && !skipDetach) {
                    detach(content.tBodies[0][`${direction}`]);
                    if (direction === 'firstElementChild') {
                        if (idx !== undefined && idx - 1 > -1) {
                            idx -= 1;
                        }
                        detachedHeight += getRowHeight(sheet, this.parent.viewport.topIndex, true);
                        this.parent.viewport.topIndex = skipHiddenIdx(sheet, this.parent.viewport.topIndex + 1, true);
                    }
                }
                for (let j = this.parent.viewport.leftIndex; j <= this.parent.viewport.rightIndex; j++) {
                    cell = getCell(i, j, sheet) || {};
                    if (cell.rowSpan !== undefined || cell.colSpan !== undefined) {
                        const mergeArgs = {
                            range: [i, j, i, j], isAction: false, merge: true,
                            type: 'All', skipChecking: true
                        };
                        this.parent.notify(activeCellMergedRange, mergeArgs);
                        if (!mergeCollection.length || mergeArgs.range[1] !== mergeCollection[mergeCollection.length - 1].range[1] ||
                            mergeArgs.range[0] !== mergeCollection[mergeCollection.length - 1].range[0]) {
                            mergeCollection.push(mergeArgs);
                        }
                    }
                }
            }
            const currentChartIndexes = getChartsIndexes(this.parent);
            this.refreshChartCellModel(prevChartIndexes, currentChartIndexes);
            if (idx === undefined) {
                return;
            }
            let refreshUI;
            if (!args.freezePane) {
                if (args.isFiltering && args.startIndex < getCellIndexes(sheet.paneTopLeftCell)[0]) {
                    eventArgs.refreshUI = true;
                    if (newStartRow === undefined || newStartRow === args.endIndex) {
                        return;
                    }
                }
                const prevBottomIdx = this.parent.viewport.bottomIndex;
                this.parent.viewport.bottomIndex = this.parent.viewport.topIndex + frozenRow + this.parent.viewport.rowCount +
                    (this.parent.getThreshold('row') * 2);
                const endHiddenCount = this.parent.hiddenCount(args.endIndex + 1, this.parent.viewport.bottomIndex);
                count = this.parent.hiddenCount(this.parent.viewport.topIndex + frozenRow, args.startIndex) + endHiddenCount;
                this.parent.viewport.bottomIndex += count;
                if (isFinite && this.parent.viewport.bottomIndex >= sheet.rowCount) {
                    this.parent.viewport.bottomIndex = skipHiddenIdx(sheet, sheet.rowCount - 1, false);
                }
                if (!args.isFiltering && startRow >= viewportTopIdx && startRow <= prevBottomIdx && startRow >
                    (this.parent.viewport.bottomIndex - endHiddenCount - Math.abs(endRow - startRow))) {
                    refreshUI = true;
                }
            }
            args.insertIdx = eventArgs.insertIdx = idx;
            args.row = eventArgs.row = frag.querySelector('.e-row');
            args.mergeCollection = eventArgs.mergeCollection = mergeCollection;
            if (sheet.showHeaders) {
                eventArgs.hdrRow = args.hdrRow = hFrag.querySelector('.e-row');
                if (idx !== 0 && !isHiddenRow(sheet, endRow - 1) && rowHdr.rows[idx - 1]) {
                    rowHdr.rows[idx - 1].classList.remove('e-hide-start');
                }
                if (args.startIndex !== 0 && isHiddenRow(sheet, args.startIndex - 1)) {
                    args.hdrRow.classList.add('e-hide-end');
                }
                if (isHiddenRow(sheet, endRow + 1)) {
                    hFrag.lastElementChild.classList.add('e-hide-start');
                }
                else {
                    if (rowHdr.rows[idx]) {
                        rowHdr.rows[idx].classList.remove('e-hide-end');
                    }
                }
            }
            if (row && content && content.rows[idx]) {
                nextIdx = skipHiddenIdx(sheet, endRow + 1, true);
                for (let i = this.parent.viewport.leftIndex; i <= this.parent.viewport.rightIndex; i++) {
                    const borderTop = this.parent.getCellStyleValue(['borderTop'], [nextIdx, i]).borderTop;
                    if (borderTop !== '') {
                        this.parent.notify(applyCellFormat, {
                            onActionUpdate: false, rowIdx: nextIdx, colIdx: i, style: { borderTop: borderTop }, pRow: row,
                            td: content.rows[idx].cells[i], first: ''
                        });
                        const prevIdx = skipHiddenIdx(sheet, startRow - 1, false);
                        if (prevIdx > -1) {
                            if (content.rows[idx - 1] && !this.parent.getCellStyleValue(['borderBottom'], [prevIdx, i]).borderBottom &&
                                !this.parent.getCellStyleValue(['borderTop'], [startRow, i]).borderTop) {
                                content.rows[idx - 1].cells[i].style.borderBottom = '';
                            }
                        }
                        else {
                            content.rows[idx].cells[i].style.borderTop = '';
                        }
                    }
                }
            }
            if (args.skipAppend) {
                return;
            }
            if (isFinite) {
                this.parent.notify(updateTranslate, { height: height, size: detachedHeight });
            }
            if (refreshUI || (Math.abs(endRow - startRow) > this.parent.viewport.rowCount + (this.parent.getThreshold('row') * 2))) {
                this.parent.renderModule.refreshSheet(false, false, true);
            }
            else {
                if (rowHdr) {
                    if (rowHdr.tBodies[0].rows.length) {
                        rowHdr.tBodies[0].insertBefore(hFrag, rowHdr.rows[idx]);
                    }
                    else {
                        rowHdr.tBodies[0].appendChild(hFrag);
                    }
                }
                if (content && content.tBodies[0]) {
                    if (content.tBodies[0].rows.length) {
                        content.tBodies[0].insertBefore(frag, content.rows[idx]);
                    }
                    else {
                        content.tBodies[0].appendChild(frag);
                    }
                }
                this.parent.selectRange(sheet.selectedRange);
                if (args.autoFit && sheet.showHeaders) {
                    this.parent.notify(autoFit, { startIndex: args.startIndex, endIndex: args.endIndex, isRow: true });
                }
                mergeCollection.forEach((mergeArgs) => { this.parent.notify(setMerge, mergeArgs); });
                if (newStartRow !== undefined && newStartRow !== args.endIndex) {
                    args.startIndex = newStartRow;
                    this.hideRow(args);
                }
            }
        }
    }
    hideCol(args) {
        const sheetIndex = isUndefined$1(args.sheetIndex) ? this.parent.activeSheetIndex : args.sheetIndex;
        const sheet = getSheet(this.parent, sheetIndex);
        const hiddenIndex = [];
        const beforeViewportIdx = [];
        const paneTopLeftIdx = getCellIndexes(sheet.paneTopLeftCell);
        const frozenCol = this.parent.frozenColCount(sheet);
        const frozenRow = this.parent.frozenRowCount(sheet);
        const viewportLeftIdx = this.parent.viewport.leftIndex + frozenCol;
        let scrollable;
        const skipColCount = skipHiddenIdx(sheet, sheet.colCount - 1, false, 'columns');
        for (let i = args.startIndex; i <= args.endIndex; i++) {
            if (args.hide) {
                if (isHiddenCol(sheet, i)) {
                    continue;
                }
            }
            else {
                if (!isHiddenCol(sheet, i) || (args.hiddenIndexes && args.hiddenIndexes.indexOf(i) === -1)) {
                    continue;
                }
            }
            const prevChartIndexes = getChartsIndexes(this.parent);
            setColumn(sheet, i, { hidden: args.hide });
            const currentChartIndexes = getChartsIndexes(this.parent);
            this.refreshChart(i, 'columns');
            this.refreshChartCellModel(prevChartIndexes, currentChartIndexes);
            if (this.parent.scrollSettings.enableVirtualization && !args.freezePane && (i < viewportLeftIdx ||
                (i > this.parent.viewport.rightIndex && (!this.parent.scrollSettings.isFinite ||
                    !(skipColCount === this.parent.viewport.rightIndex && i >= skipColCount && i < sheet.colCount))))) {
                if (i < viewportLeftIdx) {
                    beforeViewportIdx.push(i);
                }
                continue;
            }
            hiddenIndex.push(i);
            if (args.hide) {
                args.hiddenIndexes.push(i);
                if (i <= paneTopLeftIdx[1]) {
                    scrollable = true;
                }
            }
        }
        if (!beforeViewportIdx.length && !hiddenIndex.length) {
            return;
        }
        if (sheetIndex !== this.parent.activeSheetIndex) {
            return;
        }
        const topLeftIdx = getCellIndexes(sheet.topLeftCell);
        let table;
        let hTable;
        const getRowIndexes = () => {
            let idx;
            if (this.parent.scrollSettings.enableVirtualization) {
                idx = [frozenRow ? topLeftIdx[0] : this.parent.viewport.topIndex, this.parent.viewport.bottomIndex];
            }
            else {
                idx = [0, sheet.rowCount - 1];
            }
            if (args.freezePane) {
                table = this.parent.getRowHeaderTable();
                hTable = this.parent.sheetModule.getSelectAllTable();
            }
            else {
                table = this.parent.getContentTable();
                hTable = this.parent.getColHeaderTable();
            }
            return idx;
        };
        if (args.hide) {
            if (!hiddenIndex.length) {
                return;
            }
            if (hiddenIndex.length <= this.parent.getThreshold('col') || !this.parent.scrollSettings.enableVirtualization ||
                args.freezePane) {
                this.removeCell(sheet, hiddenIndex, getRowIndexes(), table, hTable);
            }
            if (!args.freezePane && this.parent.scrollSettings.enableVirtualization) {
                if (scrollable) {
                    this.parent.updateTopLeftCell(null, skipHiddenIdx(sheet, hiddenIndex[0] - 1 < frozenCol ? frozenCol : hiddenIndex[0] - 1, true, 'columns') -
                        frozenCol, 'row');
                    this.parent.renderModule.refreshSheet(false, false, true);
                    return;
                }
                let fIndexes = [];
                const viewportRowIdx = this.parent.viewport.topIndex;
                const rowIdx = frozenRow ? topLeftIdx[0] : viewportRowIdx;
                if (frozenRow) {
                    fIndexes = [frozenRow + viewportRowIdx, frozenCol];
                }
                if (this.parent.scrollSettings.isFinite) {
                    const colCount = skipHiddenIdx(sheet, sheet.colCount - 1, false, 'columns');
                    const startIdx = this.parent.viewport.leftIndex + frozenCol;
                    const endIndex = this.parent.viewport.rightIndex;
                    if (endIndex + hiddenIndex.length >= colCount) {
                        const index = skipHiddenIdx(sheet, startIdx - ((endIndex + hiddenIndex.length) - colCount), false, 'columns');
                        if (index >= frozenCol) {
                            this.parent.viewport.leftIndex = index;
                            this.parent.viewport.leftIndex -= this.parent.hiddenCount(endIndex, colCount);
                        }
                        this.parent.viewport.rightIndex = colCount;
                        if (startIdx !== (this.parent.viewport.leftIndex + frozenCol) || endIndex !== this.parent.viewport.rightIndex) {
                            this.parent.renderModule.refreshUI({ colIndex: this.parent.viewport.leftIndex, refresh: 'Column', frozenIndexes: fIndexes, rowIndex: rowIdx,
                                skipUpdateOnFirst: this.parent.viewport.leftIndex + frozenCol === skipHiddenIdx(sheet, frozenCol, true, 'columns') });
                            if (frozenRow) {
                                this.parent.viewport.topIndex = viewportRowIdx;
                            }
                        }
                        else {
                            this.parent.notify(updateTableWidth, { refresh: 'Column', isUpdate: true });
                        }
                        this.parent.selectRange(sheet.selectedRange);
                        return;
                    }
                }
                if (hiddenIndex.length <= this.parent.getThreshold('col')) {
                    const indexes = this.parent.skipHidden(this.parent.viewport.rightIndex + 1, this.parent.viewport.rightIndex + hiddenIndex.length, 'columns');
                    this.parent.viewport.rightIndex = indexes[1];
                    this.parent.renderModule.refreshUI({ rowIndex: rowIdx, colIndex: indexes[0], direction: '', refresh: 'ColumnPart', frozenIndexes: fIndexes }, `${getRangeAddress([rowIdx, indexes[0], this.parent.viewport.bottomIndex, indexes[1]])}`);
                }
                else {
                    this.parent.renderModule.refreshUI({
                        skipUpdateOnFirst: this.parent.viewport.leftIndex + frozenCol === skipHiddenIdx(sheet, frozenCol, true, 'columns'), rowIndex: rowIdx, colIndex: this.parent.viewport.leftIndex,
                        refresh: 'Column', frozenIndexes: fIndexes
                    });
                    if (frozenRow) {
                        this.parent.viewport.topIndex = viewportRowIdx;
                    }
                }
            }
            this.parent.selectRange(sheet.selectedRange);
        }
        else {
            if (beforeViewportIdx.length && this.parent.scrollSettings.enableVirtualization) {
                beforeViewportIdx.sort((i, j) => { return i - j; });
                const leftIdx = beforeViewportIdx[0] - 1 < frozenCol ? frozenCol : beforeViewportIdx[0] - 1;
                this.parent.updateTopLeftCell(null, skipHiddenIdx(sheet, leftIdx, true, 'columns') - frozenCol, 'row');
                this.parent.renderModule.refreshSheet(false, false, true);
                if (args.autoFit) {
                    args.autoFit = false;
                }
                return;
            }
            if ((!this.parent.scrollSettings.isFinite || this.parent.viewport.rightIndex < skipColCount) &&
                (hiddenIndex.length <= this.parent.getThreshold('col') || !this.parent.scrollSettings.enableVirtualization
                    || args.freezePane)) {
                this.appendCell(sheet, hiddenIndex, getRowIndexes(), table, hTable, args.freezePane);
                if (this.parent.scrollSettings.enableVirtualization && !args.freezePane) {
                    this.parent.notify(virtualContentLoaded, { refresh: 'Column', prevRowColCnt: { rowCount: sheet.rowCount, colCount: sheet.colCount } });
                }
                this.parent.selectRange(sheet.selectedRange);
            }
            else {
                this.parent.renderModule.refreshSheet(false, false, true);
            }
        }
    }
    removeCell(sheet, indexes, rowIdxs, table, hTable) {
        let startIdx = rowIdxs[0];
        const endIdx = rowIdxs[1];
        let rowIdx = 0;
        const len = indexes.length - 1;
        const frozenRow = this.parent.frozenRowCount(sheet);
        const colgrp = table.getElementsByTagName('colgroup')[0];
        const cellIdx = this.parent.getViewportIndex(indexes[0], true) + 1;
        const lastFreezeRow = skipHiddenIdx(sheet, frozenRow - 1, false);
        let hRow;
        let row;
        let hColgrp;
        let cell;
        let nextIdx;
        if (sheet.showHeaders) {
            hColgrp = hTable.getElementsByTagName('colgroup')[0];
            hRow = hTable.rows[0];
        }
        while (startIdx <= endIdx) {
            if (isHiddenRow(sheet, startIdx)) {
                startIdx++;
                continue;
            }
            row = frozenRow && startIdx < frozenRow ? hTable.rows[rowIdx + 1] : table.rows[rowIdx];
            indexes.forEach((idx, index) => {
                if (rowIdx === 0 && startIdx >= frozenRow) {
                    if (sheet.showHeaders) {
                        detach(hColgrp.children[cellIdx]);
                        detach(hRow.cells[cellIdx]);
                    }
                    detach(colgrp.children[cellIdx]);
                }
                detach(row.cells[cellIdx]);
                if (index === 0) {
                    cell = getCell(startIdx, idx, sheet, false, true);
                    if ((cell.colSpan !== undefined && (cell.rowSpan === undefined || cell.colSpan > 1)) || (cell.rowSpan < 0 &&
                        startIdx - 1 > -1 && isHiddenRow(sheet, startIdx - 1) && Math.abs(cell.rowSpan) ===
                        this.parent.hiddenCount(startIdx + cell.rowSpan, startIdx, 'rows', sheet))) {
                        this.parent.notify(hiddenMerge, { rowIdx: startIdx, colIdx: idx, model: 'col', start: indexes[0], end: indexes[len] });
                    }
                }
                if (index === len) {
                    nextIdx = skipHiddenIdx(sheet, idx + 1, true, 'columns');
                    const borderLeft = this.parent.getCellStyleValue(['borderLeft'], [rowIdx, nextIdx]).borderLeft;
                    if (borderLeft !== '') {
                        this.parent.notify(applyCellFormat, {
                            onActionUpdate: false, rowIdx: rowIdx, colIdx: nextIdx,
                            style: { borderLeft: borderLeft }, row: row, first: ''
                        });
                    }
                    cell = getCell(startIdx, idx, sheet) || {};
                    if ((cell.colSpan !== undefined && (cell.rowSpan === undefined || cell.colSpan > 1)) || (cell.rowSpan < 0 &&
                        startIdx - 1 > -1 && isHiddenRow(sheet, startIdx - 1) && Math.abs(cell.rowSpan) ===
                        this.parent.hiddenCount(startIdx + cell.rowSpan, startIdx, 'rows', sheet))) {
                        this.parent.notify(hiddenMerge, {
                            rowIdx: startIdx, colIdx: idx, model: 'col',
                            start: indexes[0], end: indexes[len], isEnd: true
                        });
                    }
                }
            });
            if (frozenRow && startIdx === lastFreezeRow) {
                rowIdx = 0;
                startIdx = this.parent.viewport.topIndex + frozenRow;
            }
            else {
                rowIdx++;
                startIdx++;
            }
        }
        if (cellIdx - 1 > -1 && sheet.showHeaders && hRow.cells[cellIdx - 1]) {
            hRow.cells[cellIdx - 1].classList.add('e-hide-start');
        }
        if (sheet.showHeaders && hRow.cells[cellIdx]) {
            hRow.cells[cellIdx].classList.add('e-hide-end');
        }
    }
    appendCell(sheet, indexes, rowIdxs, table, hTable, skip) {
        let startIdx = rowIdxs[0];
        const endIdx = rowIdxs[1];
        let rowIdx = 0;
        const len = indexes.length - 1;
        let hRow;
        let row;
        let hColgrp;
        let prevIdx;
        const frozenRow = this.parent.frozenRowCount(sheet);
        const colgrp = table.getElementsByTagName('colgroup')[0];
        if (sheet.showHeaders) {
            hColgrp = hTable.getElementsByTagName('colgroup')[0];
            hRow = hTable.rows[0];
        }
        const cellRenderer = this.parent.serviceLocator.getService('cell');
        indexes.sort((i, j) => { return i - j; });
        const mergeCollection = [];
        const cellIdx = [];
        let cell;
        let refCell;
        let cellModel;
        const firstFrozenRow = skipHiddenIdx(sheet, frozenRow - 1, false);
        let cellArgs;
        while (startIdx <= endIdx) {
            if (isHiddenRow(sheet, startIdx)) {
                startIdx++;
                continue;
            }
            row = frozenRow && startIdx < frozenRow ? hTable.rows[rowIdx + 1] : table.rows[rowIdx];
            indexes.forEach((idx, index) => {
                if (rowIdx === 0) {
                    cellIdx[index] = this.parent.getViewportIndex(idx, true);
                    if (sheet.showHeaders) {
                        refCell = hRow.cells[cellIdx[index]];
                        if (refCell) {
                            if (index === 0 && indexes[index] && !isHiddenCol(sheet, indexes[index] - 1) &&
                                refCell.previousSibling) {
                                refCell.previousElementSibling.classList.remove('e-hide-start');
                            }
                            if (index === len) {
                                refCell.classList.remove('e-hide-end');
                            }
                        }
                    }
                    if (startIdx >= frozenRow) {
                        if (colgrp.children[cellIdx[index]]) {
                            colgrp.insertBefore(this.parent.sheetModule.updateCol(sheet, idx), colgrp.children[cellIdx[index]]);
                            if (sheet.showHeaders) {
                                cellRenderer.renderColHeader(idx, hRow, refCell);
                            }
                        }
                        else {
                            colgrp.appendChild(this.parent.sheetModule.updateCol(sheet, idx));
                            if (sheet.showHeaders) {
                                cellRenderer.renderColHeader(idx, hRow);
                            }
                        }
                        if (!skip) {
                            detach(colgrp.lastChild);
                            if (sheet.showHeaders) {
                                detach(hRow.lastChild);
                            }
                        }
                        if (sheet.showHeaders && index === len) {
                            detach(hColgrp);
                            hTable.insertBefore(colgrp.cloneNode(true), hTable.tHead);
                        }
                    }
                }
                if (!skip) {
                    detach(row.lastChild);
                }
                refCell = row.cells[cellIdx[index]];
                cellArgs = {
                    rowIdx: startIdx, colIdx: idx, cell: getCell(startIdx, idx, sheet), row: row,
                    address: getCellAddress(startIdx, idx), lastCell: idx === len, isHeightCheckNeeded: true,
                    first: idx !== skipHiddenIdx(sheet, 0, true, 'columns') && idx === this.parent.viewport.leftIndex ? 'Column' : '',
                    checkNextBorder: index === len ? 'Column' : '', checkCF: true
                };
                if (refCell) {
                    cellArgs.refChild = refCell;
                }
                cell = cellRenderer.render(cellArgs);
                if (index === 0 && cell.previousSibling) {
                    const borderLeft = this.parent.getCellStyleValue(['borderLeft'], [rowIdx, skipHiddenIdx(sheet, indexes[indexes.length - 1] + 1, true, 'columns')]).borderLeft;
                    if (borderLeft !== '') {
                        prevIdx = skipHiddenIdx(sheet, indexes[0] - 1, false, 'columns');
                        if (prevIdx > -1 && !this.parent.getCellStyleValue(['borderRight'], [rowIdx, prevIdx]).borderRight &&
                            !this.parent.getCellStyleValue(['borderLeft'], [rowIdx, indexes[0]]).borderLeft) {
                            cell.previousSibling.style.borderRight = '';
                        }
                    }
                }
                cellModel = getCell(startIdx, idx, sheet) || {};
                if ((cellModel.colSpan !== undefined && (cellModel.rowSpan === undefined || cellModel.colSpan > 1)) ||
                    (cellModel.rowSpan < 0 && startIdx - 1 > -1 && isHiddenRow(sheet, startIdx - 1) &&
                        Math.abs(cellModel.rowSpan) === this.parent.hiddenCount(startIdx + cellModel.rowSpan, startIdx, 'rows', sheet))) {
                    const mergeArgs = {
                        range: [startIdx, idx, startIdx, idx], isAction: false, merge: true,
                        type: 'All', skipChecking: true
                    };
                    this.parent.notify(activeCellMergedRange, mergeArgs);
                    if (!mergeCollection.length || mergeArgs.range[1] !== mergeCollection[mergeCollection.length - 1].range[1] ||
                        mergeArgs.range[0] !== mergeCollection[mergeCollection.length - 1].range[0]) {
                        mergeCollection.push(mergeArgs);
                    }
                }
            });
            if (frozenRow && startIdx === firstFrozenRow) {
                startIdx = this.parent.viewport.topIndex + frozenRow;
                rowIdx = 0;
            }
            else {
                startIdx++;
                rowIdx++;
            }
        }
        mergeCollection.forEach((mergeArgs) => { this.parent.notify(setMerge, mergeArgs); });
        this.parent.viewport.rightIndex = skipHiddenIdx(sheet, this.parent.viewport.rightIndex - indexes.length, false, 'columns');
    }
    refreshChart(index, showHide) {
        this.parent.notify(refreshChart, { rIdx: index, showHide: showHide });
    }
    refreshChartCellModel(prevChartIndexes, currentChartIndexes) {
        this.parent.notify(refreshChartCellModel, { prevChartIndexes, currentChartIndexes });
    }
    addEventListener() {
        this.parent.on(hideShow, this.hideShow, this);
        this.parent.on(spreadsheetDestroyed, this.destroy, this);
    }
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    removeEventListener() {
        this.parent.off(hideShow, this.hideShow);
        this.parent.off(spreadsheetDestroyed, this.destroy);
    }
}

/**
 * `Hyperlink` module
 */
class SpreadsheetHyperlink {
    /**
     * Constructor for Hyperlink module.
     *
     * @param {Spreadsheet} parent - Constructor for Hyperlink module.
     */
    constructor(parent) {
        this.divElements = [];
        this.inputElements = [];
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * To destroy the Hyperlink module.
     *
     * @returns {void} - To destroy the Hyperlink module.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(initiateHyperlink, this.initiateHyperlinkHandler, this);
        this.parent.on(editHyperlink, this.editHyperlinkHandler, this);
        this.parent.on(openHyperlink, this.openHyperlinkHandler, this);
        this.parent.on(click, this.hyperlinkClickHandler, this);
        this.parent.on(createHyperlinkElement, this.createHyperlinkEle, this);
        this.parent.on(keyUp, this.keyUpHandler, this);
        this.parent.on(deleteHyperlink, this.removeHyperlink, this);
        this.parent.on(removeHyperlink, this.removeHyperlinkHandler, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(initiateHyperlink, this.initiateHyperlinkHandler);
            this.parent.off(editHyperlink, this.editHyperlinkHandler);
            this.parent.off(openHyperlink, this.openHyperlinkHandler);
            this.parent.off(click, this.hyperlinkClickHandler);
            this.parent.off(createHyperlinkElement, this.createHyperlinkEle);
            this.parent.off(keyUp, this.keyUpHandler);
            this.parent.off(deleteHyperlink, this.removeHyperlink);
            this.parent.off(removeHyperlink, this.removeHyperlinkHandler);
        }
    }
    /**
     * Gets the module name.
     *
     * @returns {string} - Gets the module name.
     */
    getModuleName() {
        return 'spreadsheetHyperlink';
    }
    keyUpHandler(e) {
        const trgt = e.target;
        if (closest(trgt, '.e-document')) {
            const hyperlinkText = document.querySelector('.e-hyp-text');
            const hyperlinkSpan = this.parent.element.querySelector('.e-hyperlink-alert-span');
            const dlgElement = closest(trgt, '.e-hyperlink-dlg') || closest(trgt, '.e-edithyperlink-dlg');
            const footerEle = dlgElement.getElementsByClassName('e-footer-content')[0];
            const insertBut = footerEle.firstChild;
            if (hyperlinkText && !isNullOrUndefined(hyperlinkText.value)) {
                if (!isCellReference(hyperlinkText.value.toUpperCase())) {
                    this.showDialog();
                    insertBut.setAttribute('disabled', 'true');
                }
                else if (hyperlinkSpan) {
                    hyperlinkSpan.remove();
                    insertBut.removeAttribute('disabled');
                }
            }
        }
        if (trgt.classList.contains('e-text') && closest(trgt, '.e-cont')) {
            if (closest(trgt, '.e-webpage') && closest(trgt, '.e-webpage').getElementsByClassName('e-cont')[1] === trgt.parentElement) {
                const dlgEle = closest(trgt, '.e-hyperlink-dlg') || closest(trgt, '.e-edithyperlink-dlg');
                const ftrEle = dlgEle.getElementsByClassName('e-footer-content')[0];
                const insertBut = ftrEle.firstChild;
                if (trgt.value !== '') {
                    insertBut.removeAttribute('disabled');
                }
                else {
                    const linkDialog = closest(trgt, '.e-link-dialog');
                    const webPage = linkDialog.querySelector('.e-webpage');
                    const isUrl = webPage.querySelectorAll('.e-cont')[1].querySelector('.e-text').value ? true : false;
                    if (!isUrl) {
                        insertBut.setAttribute('disabled', 'true');
                    }
                }
            }
        }
    }
    initiateHyperlinkHandler() {
        const sheet = this.parent.getActiveSheet();
        if (sheet.isProtected && (!sheet.protectSettings.insertLink || isLockedCells(this.parent))) {
            this.parent.notify(editAlert, null);
            return;
        }
        if (isReadOnlyCells(this.parent)) {
            this.parent.notify(readonlyAlert, null);
            return;
        }
        const l10n = this.parent.serviceLocator.getService(locale);
        if (!this.parent.element.querySelector('.e-hyperlink-dlg')) {
            const dialogInst = this.parent.serviceLocator.getService(dialog);
            let displayText;
            dialogInst.show({
                width: 323, isModal: true, showCloseIcon: true, cssClass: 'e-hyperlink-dlg',
                header: l10n.getConstant('InsertLink'),
                beforeOpen: (args) => {
                    const dlgArgs = {
                        dialogName: 'InsertLinkDialog',
                        element: args.element, target: args.target, cancel: args.cancel
                    };
                    this.parent.trigger('dialogBeforeOpen', dlgArgs);
                    if (dlgArgs.cancel) {
                        args.cancel = true;
                        return;
                    }
                    dialogInst.dialogInstance.content = this.hyperlinkContent();
                    displayText = dialogInst.dialogInstance.content.querySelector('.e-text').value;
                    dialogInst.dialogInstance.dataBind();
                    focus(this.parent.element);
                },
                open: () => {
                    setTimeout(() => {
                        focus(dialogInst.dialogInstance.element.querySelectorAll('.e-webpage input')[1]);
                    });
                },
                beforeClose: this.dialogBeforeClose.bind(this),
                buttons: [{
                        buttonModel: {
                            content: l10n.getConstant('Insert'), isPrimary: true, disabled: true
                        },
                        click: () => {
                            this.dlgClickHandler(displayText);
                            dialogInst.hide();
                        }
                    }]
            });
        }
    }
    dialogBeforeClose() {
        const headerTab = this.headerTabs;
        if (headerTab && headerTab.element) {
            headerTab.destroy();
            headerTab.element.remove();
        }
        this.headerTabs = null;
        removeElements(this.inputElements);
        this.inputElements = [];
        removeElements(this.divElements);
        this.divElements = [];
    }
    dlgClickHandler(displayText) {
        let value;
        let address;
        const sheet = this.parent.getActiveSheet();
        const cellAddress = sheet.name + '!' + sheet.selectedRange;
        const item = this.parent.element.querySelector('.e-link-dialog').
            getElementsByClassName('e-content')[0].querySelector('.e-item.e-active');
        if (item) {
            value = item.getElementsByClassName('e-cont')[0].querySelector('.e-text').value;
            if (value === displayText) {
                value = null;
            }
            if (item.querySelector('.e-webpage')) {
                address = item.getElementsByClassName('e-cont')[1].querySelector('.e-text').value;
                const args = { address: address };
                this.parent.insertHyperlink(args, cellAddress, value, false);
            }
            else {
                address = item.getElementsByClassName('e-cont')[1].querySelector('.e-text').value;
                const dlgContent = item.getElementsByClassName('e-cont')[2];
                if (dlgContent.getElementsByClassName('e-list-item')[0].querySelector('.e-active')) {
                    const sheetName = item.getElementsByClassName('e-cont')[2].querySelector('.e-active').textContent;
                    // const sheets: SheetModel[] = spreadsheetInst.sheets;
                    // for (let idx: number = 0; idx < sheets.length; idx++) {
                    //     if (sheets[idx].name === sheetName) {
                    //         const sheetIdx: number = idx + 1;
                    //     }
                    // }
                    address = sheetName + '!' + address.toUpperCase();
                    const args = { address: address };
                    this.parent.insertHyperlink(args, cellAddress, value, false);
                }
                else if (dlgContent.querySelector('.e-active')) {
                    const definedName = item.getElementsByClassName('e-cont')[2].querySelector('.e-active').textContent;
                    for (let idx = 0; idx < this.parent.definedNames.length; idx++) {
                        if (this.parent.definedNames[idx].name === definedName) {
                            const args = {
                                address: this.parent.definedNames[idx].name
                            };
                            this.parent.insertHyperlink(args, cellAddress, value, false);
                        }
                    }
                }
            }
        }
    }
    showDialog() {
        if (this.parent.element.querySelector('.e-hyperlink-alert-span')) {
            this.parent.element.querySelector('.e-hyperlink-alert-span').remove();
        }
        const l10n = this.parent.serviceLocator.getService(locale);
        const hyperlinkSpan = this.parent.createElement('span', { className: 'e-hyperlink-alert-span' });
        hyperlinkSpan.innerText = l10n.getConstant('HyperlinkAlert');
        const dlgEle = this.parent.element.querySelector('.e-hyperlink-dlg') || this.parent.element.querySelector('.e-edithyperlink-dlg');
        (dlgEle.querySelector('.e-dlg-content')).appendChild(hyperlinkSpan);
    }
    editHyperlinkHandler() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        let displayText;
        dialogInst.show({
            width: 323, isModal: true, showCloseIcon: true, cssClass: 'e-edithyperlink-dlg',
            header: l10n.getConstant('EditLink'),
            beforeOpen: (args) => {
                const dlgArgs = {
                    dialogName: 'EditLinkDialog',
                    element: args.element, target: args.target, cancel: args.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    args.cancel = true;
                    return;
                }
                dialogInst.dialogInstance.content = this.hyperEditContent();
                displayText = dialogInst.dialogInstance.content.querySelector('.e-text').value;
                dialogInst.dialogInstance.dataBind();
                focus(this.parent.element);
            },
            open: () => {
                setTimeout(() => {
                    if (dialogInst.dialogInstance.element.querySelector('.e-webpage')) {
                        focus(dialogInst.dialogInstance.element.querySelectorAll('.e-webpage input')[1]);
                    }
                    else {
                        focus(dialogInst.dialogInstance.element.querySelectorAll('.e-document input')[1]);
                    }
                });
            },
            buttons: [{
                    buttonModel: {
                        content: l10n.getConstant('Update'), isPrimary: true
                    },
                    click: () => {
                        this.dlgClickHandler(displayText);
                        dialogInst.hide();
                    }
                }]
        });
    }
    openHyperlinkHandler() {
        const cellIndexes = getCellIndexes(this.parent.getActiveSheet().activeCell);
        let trgt = this.parent.getCell(cellIndexes[0], cellIndexes[1]);
        if (trgt.getElementsByClassName('e-hyperlink')[0]) {
            trgt = trgt.querySelector('.e-hyperlink');
        }
        this.hlOpenHandler(trgt);
    }
    hlOpenHandler(trgt, isClick, event) {
        if (trgt.classList.contains('e-hyperlink')) {
            const cellEle = closest(trgt, '.e-cell');
            if (!cellEle) {
                return;
            }
            const range = ['', ''];
            let rangeIndexes;
            let isEmpty = true;
            let sheet = this.parent.getActiveSheet();
            const colIdx = parseInt(cellEle.getAttribute('aria-colindex'), 10) - 1;
            const rowIdx = parseInt(cellEle.parentElement.getAttribute('aria-rowindex'), 10) - 1;
            const cell = getCell(rowIdx, colIdx, sheet, false, true);
            if (cell.style && cell.style.color === '#00e') {
                updateCell(this.parent, sheet, { rowIdx: rowIdx, colIdx: colIdx, preventEvt: true, cell: { style: { color: '#551a8b' } } });
                cellEle.style.color = '#551a8b';
            }
            let rangeAddr = cell.hyperlink;
            let address;
            const befArgs = { hyperlink: rangeAddr, address: sheet.activeCell, target: '_blank', cancel: false };
            this.parent.trigger(beforeHyperlinkClick, befArgs);
            if (befArgs.cancel) {
                if (event) {
                    event.preventDefault();
                }
                return;
            }
            rangeAddr = befArgs.hyperlink;
            const aftArgs = { hyperlink: rangeAddr, address: sheet.activeCell };
            if (typeof (rangeAddr) === 'string') {
                address = rangeAddr;
            }
            if (typeof (rangeAddr) === 'object') {
                address = rangeAddr.address;
            }
            const definedNameCheck = address;
            if (address.indexOf('http://') === -1 && address.indexOf('https://') === -1 && address.indexOf('ftp://') === -1) {
                if (!isNullOrUndefined(address)) {
                    if (this.parent.definedNames) {
                        for (let idx = 0; idx < this.parent.definedNames.length; idx++) {
                            if (this.parent.definedNames[idx].name === address) {
                                address = this.parent.definedNames[idx].refersTo;
                                address = address.slice(1);
                                break;
                            }
                        }
                    }
                    if (address.lastIndexOf('!') !== -1) {
                        range[0] = address.substring(0, address.lastIndexOf('!'));
                        if (range[0].startsWith('\'') && range[0].endsWith('\'')) {
                            range[0] = range[0].slice(1, range[0].length - 1);
                        }
                        range[1] = address.substring(address.lastIndexOf('!') + 1);
                    }
                    else {
                        range[0] = this.parent.getActiveSheet().name;
                        range[1] = address;
                    }
                    // selRange = range[1];
                    let sheetIdx;
                    for (let idx = 0; idx < this.parent.sheets.length; idx++) {
                        if (this.parent.sheets[idx].name === range[0]) {
                            sheetIdx = idx;
                        }
                    }
                    sheet = this.parent.sheets[sheetIdx];
                    if (range[1].indexOf(':') !== -1) {
                        const colIndex = range[1].indexOf(':');
                        let left = range[1].substr(0, colIndex);
                        let right = range[1].substr(colIndex + 1, range[1].length);
                        left = left.replace('$', '');
                        right = right.replace('$', '');
                        if (right.match(/\D/g) && !right.match(/[0-9]/g) && left.match(/\D/g) && !left.match(/[0-9]/g)) {
                            // selRange = left + '1' + ':' + right + sheet.rowCount;
                            left = left + '1';
                            right = right + sheet.rowCount;
                            range[1] = left + ':' + right;
                        }
                        else if (!right.match(/\D/g) && right.match(/[0-9]/g) && !left.match(/\D/g) && left.match(/[0-9]/g)) {
                            // selRange = getCellAddress(parseInt(left, 10) - 1, 0) + ':' +
                            //     getCellAddress(parseInt(right, 10) - 1, sheet.colCount - 1);
                            rangeIndexes = [parseInt(left, 10) - 1, 0, parseInt(right, 10) - 1, sheet.colCount - 1];
                            isEmpty = false;
                        }
                    }
                    let isDefinedNamed;
                    const definedname = this.parent.definedNames;
                    if (!isNullOrUndefined(definedname)) {
                        for (let idx = 0; idx < definedname.length; idx++) {
                            if (definedname[idx].name === definedNameCheck) {
                                isDefinedNamed = true;
                                break;
                            }
                        }
                    }
                    if (isCellReference(range[1]) || isDefinedNamed) {
                        rangeIndexes = isEmpty ? getRangeIndexes(range[1]) : rangeIndexes;
                        if (!isNullOrUndefined(sheet)) {
                            let rangeAddr = getRangeAddress(rangeIndexes);
                            if (sheet === this.parent.getActiveSheet()) {
                                getUpdateUsingRaf(() => { this.parent.goTo(rangeAddr); });
                            }
                            else {
                                if (rangeAddr.indexOf(':') >= 0) {
                                    const addArr = rangeAddr.split(':');
                                    rangeAddr = addArr[0] === addArr[1] ? addArr[0] : rangeAddr;
                                }
                                getUpdateUsingRaf(() => { this.parent.goTo(this.parent.sheets[sheetIdx].name + '!' + rangeAddr); });
                            }
                        }
                    }
                    else {
                        this.showInvalidHyperlinkDialog();
                    }
                }
            }
            else if (!isClick) {
                if (this.isValidUrl(address)) {
                    window.open(address, befArgs.target);
                }
                else {
                    this.showInvalidHyperlinkDialog();
                }
            }
            this.parent.trigger(afterHyperlinkClick, aftArgs);
        }
    }
    isValidUrl(url) {
        // eslint-disable-next-line no-useless-escape, security/detect-unsafe-regex
        return /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/.test(url);
    }
    showInvalidHyperlinkDialog() {
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        const l10n = this.parent.serviceLocator.getService(locale);
        dialogInst.show({
            width: 323, isModal: true, showCloseIcon: true,
            header: l10n.getConstant('Hyperlink'),
            content: l10n.getConstant('InvalidHyperlinkAlert'),
            buttons: [{
                    buttonModel: {
                        content: l10n.getConstant('Ok'), isPrimary: true
                    },
                    click: () => {
                        dialogInst.hide();
                    }
                }]
        }, false);
    }
    hyperlinkClickHandler(e) {
        const trgt = e.target;
        if (closest(trgt, '.e-link-dialog') && closest(trgt, '.e-toolbar-item')) {
            const dlgEle = closest(trgt, '.e-hyperlink-dlg') || closest(trgt, '.e-edithyperlink-dlg');
            const ftrEle = dlgEle.getElementsByClassName('e-footer-content')[0];
            const insertBut = ftrEle.firstChild;
            const docEle = dlgEle.querySelector('.e-document');
            const webEle = dlgEle.querySelector('.e-webpage');
            const webEleText = webEle ? webEle.querySelectorAll('.e-cont')[0].querySelector('.e-text').value :
                docEle.querySelectorAll('.e-cont')[0].querySelector('.e-text').value;
            const docEleText = docEle ? docEle.querySelectorAll('.e-cont')[0].querySelector('.e-text').value :
                webEleText;
            const toolbarItems = closest(trgt, '.e-toolbar-items');
            if (toolbarItems.getElementsByClassName('e-toolbar-item')[1].classList.contains('e-active')) {
                const actEle = docEle.querySelectorAll('.e-cont')[2].querySelector('.e-active');
                docEle.querySelectorAll('.e-cont')[0].querySelector('.e-text').value = webEleText;
                if (closest(actEle, '.e-list-item').classList.contains('e-level-2') && insertBut.hasAttribute('disabled')) {
                    insertBut.removeAttribute('disabled');
                }
                else if (closest(actEle, '.e-list-item').classList.contains('e-level-1') && !insertBut.hasAttribute('disabled')) {
                    insertBut.setAttribute('disabled', 'true');
                }
            }
            else {
                const isEmpty = webEle.querySelectorAll('.e-cont')[1].querySelector('.e-text').value ? false : true;
                webEle.querySelectorAll('.e-cont')[0].querySelector('.e-text').value = docEleText;
                if (isEmpty && !insertBut.hasAttribute('disabled')) {
                    insertBut.setAttribute('disabled', 'true');
                }
                else if (!isEmpty && insertBut.hasAttribute('disabled')) {
                    insertBut.removeAttribute('disabled');
                }
            }
        }
        if (closest(trgt, '.e-list-item') && trgt.classList.contains('e-fullrow')) {
            let item = this.parent.element.getElementsByClassName('e-link-dialog')[0];
            if (item) {
                item = item.getElementsByClassName('e-content')[0].getElementsByClassName('e-active')[0];
            }
            else {
                return;
            }
            const cellRef = item.getElementsByClassName('e-cont')[1].getElementsByClassName('e-text')[0];
            const dlgEle = closest(trgt, '.e-hyperlink-dlg') || closest(trgt, '.e-edithyperlink-dlg');
            const ftrEle = dlgEle.getElementsByClassName('e-footer-content')[0];
            const insertBut = ftrEle.firstChild;
            if (closest(trgt, '.e-list-item').classList.contains('e-level-2')) {
                if (closest(trgt, '.e-list-item').getAttribute('data-uid') === 'defName') {
                    if (!cellRef.classList.contains('e-disabled') && !cellRef.hasAttribute('readonly')) {
                        cellRef.setAttribute('readonly', 'true');
                        cellRef.classList.add('e-disabled');
                        cellRef.setAttribute('disabled', 'true');
                    }
                    if (insertBut.hasAttribute('disabled')) {
                        insertBut.removeAttribute('disabled');
                    }
                }
                else if (closest(trgt, '.e-list-item').getAttribute('data-uid') === 'sheet') {
                    if (cellRef.classList.contains('e-disabled') && cellRef.hasAttribute('readonly')) {
                        cellRef.removeAttribute('readonly');
                        cellRef.classList.remove('e-disabled');
                        cellRef.removeAttribute('disabled');
                    }
                    if (isCellReference(cellRef.value.toUpperCase())) {
                        if (insertBut.hasAttribute('disabled')) {
                            insertBut.removeAttribute('disabled');
                        }
                    }
                }
            }
            else if (closest(trgt, '.e-list-item').classList.contains('e-level-1')) {
                insertBut.setAttribute('disabled', 'true');
            }
        }
        else {
            this.hlOpenHandler(trgt, true, e);
        }
    }
    createHyperlinkEle(args) {
        const cell = args.cell;
        if (!isNullOrUndefined(cell.hyperlink)) {
            const td = args.td;
            const hyperEle = this.parent.createElement('a', { className: 'e-hyperlink e-hyperlink-style' });
            let address;
            if (typeof cell.hyperlink === 'string') {
                if (cell.hyperlink.toLowerCase().indexOf('www.') === 0) {
                    cell.hyperlink = 'http://' + cell.hyperlink;
                }
                address = cell.hyperlink;
            }
            else {
                address = cell.hyperlink.address;
                if (address.toLowerCase().indexOf('www.') === 0) {
                    cell.hyperlink.address = address = 'http://' + address;
                }
            }
            if (address.indexOf('http://') === 0 || address.indexOf('https://') === 0 || address.indexOf('ftp://') === 0) {
                hyperEle.setAttribute('href', address);
                hyperEle.setAttribute('target', '_blank');
            }
            else if (address.includes('=') || address.includes('!')) {
                hyperEle.setAttribute('ref', address);
            }
            if (getTypeFromFormat(cell.format) === 'Accounting') {
                hyperEle.innerHTML = td.innerHTML;
            }
            else {
                hyperEle.innerText = td.innerText !== '' ? td.innerText : address;
            }
            td.textContent = '';
            td.innerText = '';
            if (this.parent.autoFillSettings.fillType === 'FillWithoutFormatting' || args.fillType === 'FillWithoutFormatting' ||
                args.action === 'Clear Formats') {
                hyperEle.style.textDecoration = 'none';
            }
            td.appendChild(hyperEle);
            if (!args.style.color || !args.style.textDecoration) {
                const style = {};
                if (!args.style.color) {
                    args.style.color = style.color = '#00e';
                }
                if (!args.style.textDecoration) {
                    args.style.textDecoration = style.textDecoration = 'underline';
                }
                updateCell(this.parent, this.parent.getActiveSheet(), { rowIdx: args.rowIdx, colIdx: args.colIdx, preventEvt: true,
                    cell: { style: style } });
            }
        }
    }
    hyperEditContent() {
        let isWeb = true;
        const dialog = this.hyperlinkContent();
        const indexes = getRangeIndexes(this.parent.getActiveSheet().activeCell);
        const cell = this.parent.sheets[this.parent.getActiveSheet().id - 1].rows[indexes[0]].cells[indexes[1]];
        if (this.parent.scrollSettings.enableVirtualization) {
            indexes[0] = indexes[0] - this.parent.viewport.topIndex;
            indexes[1] = indexes[1] - this.parent.viewport.leftIndex;
        }
        let value = this.parent.getDisplayText(cell);
        let address;
        const hyperlink = cell.hyperlink;
        if (typeof (hyperlink) === 'string') {
            address = hyperlink;
            value = value || address;
            if (address.indexOf('http://') === -1 && address.indexOf('https://') === -1 && address.indexOf('ftp://') === -1) {
                isWeb = false;
            }
        }
        else if (typeof (hyperlink) === 'object') {
            address = hyperlink.address;
            value = value || address;
            if (address.indexOf('http://') === -1 && address.indexOf('https://') === -1 && address.indexOf('ftp://') === -1) {
                isWeb = false;
            }
        }
        let definedNamesCount = 0;
        let rangeCount = 0;
        const definedNames = this.parent.definedNames;
        const sheets = this.parent.sheets;
        for (let idx = 0, len = definedNames.length; idx < len; idx++) {
            if (definedNames[idx].name === address) {
                definedNamesCount++;
            }
        }
        for (let idx = 0, len = sheets.length; idx < len; idx++) {
            if (address.includes(sheets[idx].name)) {
                rangeCount++;
            }
        }
        if (definedNamesCount === 0 && rangeCount === 0) {
            isWeb = true;
        }
        const item = dialog.querySelector('.e-content');
        if (isWeb) {
            const webContElem = item.querySelector('.e-webpage');
            webContElem.getElementsByClassName('e-cont')[0].getElementsByClassName('e-text')[0].setAttribute('value', value);
            if (typeof (hyperlink) === 'string') {
                webContElem.getElementsByClassName('e-cont')[1].querySelector('.e-text').setAttribute('value', hyperlink);
            }
            else {
                const address = webContElem.getElementsByClassName('e-cont')[1].querySelector('.e-text');
                address.setAttribute('value', hyperlink.address);
            }
        }
        else {
            let isDefinedNamed;
            const docContElem = item.querySelector('.e-document');
            docContElem.getElementsByClassName('e-cont')[0].getElementsByClassName('e-text')[0].setAttribute('value', value);
            let sheetName;
            let range;
            // let sheet: SheetModel = this.parent.getActiveSheet();
            // let sheetIdx: number;
            if (this.parent.definedNames) {
                for (let idx = 0; idx < this.parent.definedNames.length; idx++) {
                    if (this.parent.definedNames[idx].name === address) {
                        isDefinedNamed = true;
                        break;
                    }
                }
            }
            if (isDefinedNamed) {
                const cellRef = docContElem.getElementsByClassName('e-cont')[1].getElementsByClassName('e-text')[0];
                cellRef.setAttribute('readonly', 'true');
                cellRef.classList.add('e-disabled');
                cellRef.setAttribute('disabled', 'true');
                const treeCont = docContElem.getElementsByClassName('e-cont')[2];
                const listEle = treeCont.querySelectorAll('.e-list-item.e-level-1')[1];
                for (let idx = 0; idx < listEle.getElementsByTagName('li').length; idx++) {
                    if (listEle.getElementsByTagName('li')[idx].innerText === address) {
                        listEle.getElementsByTagName('li')[idx].classList.add('e-active');
                    }
                }
            }
            else {
                if (address && address.lastIndexOf('!') !== -1) {
                    const lastIndex = address.lastIndexOf('!');
                    sheetName = address.substring(0, lastIndex);
                    range = address.substring(lastIndex + 1);
                    // sheetIdx = parseInt(rangeArr[0].replace(/\D/g, ''), 10) - 1;
                    // sheet = this.parent.sheets[sheetIdx];
                }
                docContElem.getElementsByClassName('e-cont')[1].querySelector('.e-text').setAttribute('value', range);
                const treeCont = docContElem.getElementsByClassName('e-cont')[2];
                const listEle = treeCont.querySelectorAll('.e-list-item.e-level-1')[0];
                for (let idx = 0; idx < listEle.getElementsByTagName('li').length; idx++) {
                    if (listEle.getElementsByTagName('li')[idx].innerText === sheetName) {
                        if (listEle.getElementsByTagName('li')[idx].classList.contains('e-active')) {
                            break;
                        }
                        else {
                            listEle.getElementsByTagName('li')[idx].classList.add('e-active');
                        }
                    }
                    else {
                        if (listEle.getElementsByTagName('li')[idx].classList.contains('e-active')) {
                            listEle.getElementsByTagName('li')[idx].classList.remove('e-active');
                        }
                    }
                }
            }
        }
        return dialog;
    }
    hyperlinkContent() {
        const l10n = this.parent.serviceLocator.getService(locale);
        let idx = 0;
        let selIdx = 0;
        let isWeb = true;
        let isDefinedName;
        let isCellRef = true;
        let address;
        const indexes = getRangeIndexes(this.parent.getActiveSheet().activeCell);
        const sheet = this.parent.getActiveSheet();
        const cell = getCell(indexes[0], indexes[1], sheet);
        let isEnable = true;
        if (cell) {
            if ((cell.value && typeof (cell.value) === 'string' && cell.value.match('[A-Za-z]+') !== null) ||
                cell.value === '' || isNullOrUndefined(cell.value)) {
                isEnable = true;
            }
            else {
                isEnable = false;
            }
            const hyperlink = cell.hyperlink;
            if (typeof (hyperlink) === 'string') {
                const hl = hyperlink;
                if (hl.indexOf('http://') === -1 && hl.indexOf('https://') === -1 && hl.indexOf('ftp://') === -1) {
                    address = hyperlink;
                    isWeb = false;
                }
            }
            else if (typeof (hyperlink) === 'object') {
                const hl = hyperlink.address;
                if (hl.indexOf('http://') === -1 && hl.indexOf('https://') === -1 && hl.indexOf('ftp://') === -1) {
                    address = hyperlink.address;
                    isWeb = false;
                }
            }
            if (address) {
                let defNamesCnt = 0;
                let rangeCnt = 0;
                const definedNames = this.parent.definedNames;
                const sheets = this.parent.sheets;
                for (let idx = 0, len = sheets.length; idx < len; idx++) {
                    if (address.includes(sheets[idx].name)) {
                        rangeCnt++;
                    }
                }
                for (let idx = 0, len = definedNames.length; idx < len; idx++) {
                    if (definedNames[idx].name === address) {
                        defNamesCnt++;
                    }
                }
                if (defNamesCnt === 0 && rangeCnt === 0) {
                    isWeb = true;
                }
            }
            if (isWeb) {
                selIdx = 0;
            }
            else {
                selIdx = 1;
            }
            if (this.parent.definedNames) {
                for (let idx = 0; idx < this.parent.definedNames.length; idx++) {
                    if (this.parent.definedNames[idx].name === address) {
                        isDefinedName = true;
                        isCellRef = false;
                        break;
                    }
                }
            }
        }
        const dialogElem = this.parent.createElement('div', { className: 'e-link-dialog' });
        const webContElem = this.parent.createElement('div', { className: 'e-webpage' });
        const docContElem = this.parent.createElement('div', { className: 'e-document' });
        this.headerTabs = new Tab({
            selectedItem: selIdx,
            items: [
                {
                    header: { 'text': l10n.getConstant('WebPage') },
                    content: webContElem
                },
                {
                    header: { 'text': l10n.getConstant('ThisDocument') },
                    content: docContElem
                }
            ]
        });
        this.headerTabs.appendTo(dialogElem);
        const indicator = dialogElem.querySelector('.e-toolbar-items').querySelector('.e-indicator');
        if (isWeb) {
            indicator.style.cssText = 'left: 0; right: 136px';
        }
        else {
            indicator.style.cssText = 'left: 136px; right: 0';
        }
        const textCont = this.parent.createElement('div', { className: 'e-cont' });
        const urlCont = this.parent.createElement('div', { className: 'e-cont' });
        const textH = this.parent.createElement('div', { className: 'e-header' });
        textH.innerText = l10n.getConstant('DisplayText');
        const urlH = this.parent.createElement('div', { className: 'e-header' });
        urlH.innerText = l10n.getConstant('Url');
        const textInput = this.parent.createElement('input', { className: 'e-input e-text', attrs: { 'type': 'Text' } });
        this.inputElements.push(textInput);
        if (!isEnable) {
            textInput.classList.add('e-disabled');
            textInput.setAttribute('readonly', 'true');
            textInput.setAttribute('disabled', 'true');
        }
        if (cell && isNullOrUndefined(cell.hyperlink)) {
            textInput.setAttribute('value', this.parent.getDisplayText(cell));
        }
        const urlInput = this.parent.createElement('input', { className: 'e-input e-text', attrs: { 'type': 'Text' } });
        this.inputElements.push(urlInput);
        textInput.setAttribute('placeholder', l10n.getConstant('EnterTheTextToDisplay'));
        urlInput.setAttribute('placeholder', l10n.getConstant('EnterTheUrl'));
        textCont.appendChild(textInput);
        textCont.insertBefore(textH, textInput);
        urlCont.appendChild(urlInput);
        urlCont.insertBefore(urlH, urlInput);
        webContElem.appendChild(urlCont);
        webContElem.insertBefore(textCont, urlCont);
        const cellRef = [];
        const definedName = [];
        const sheets = this.parent.sheets;
        for (idx; idx < this.parent.sheets.length; idx++) {
            const sheetName = this.parent.sheets[idx].name;
            if (this.parent.sheets[idx].state === 'Visible') {
                if (sheets[idx] === this.parent.getActiveSheet()) {
                    cellRef.push({
                        nodeId: 'sheet',
                        nodeText: sheetName.indexOf(' ') !== -1 ? '\'' + sheetName + '\'' : sheetName,
                        selected: true
                    });
                }
                else {
                    cellRef.push({
                        nodeId: 'sheet',
                        nodeText: sheetName.indexOf(' ') !== -1 ? '\'' + sheetName + '\'' : sheetName
                    });
                }
            }
        }
        for (idx = 0; idx < this.parent.definedNames.length; idx++) {
            definedName.push({
                nodeId: 'defName',
                nodeText: this.parent.definedNames[idx].name
            });
        }
        const data = [
            {
                nodeId: '01', nodeText: l10n.getConstant('CellReference'), expanded: isCellRef,
                nodeChild: cellRef
            },
            {
                nodeId: '02', nodeText: l10n.getConstant('DefinedNames'), expanded: isDefinedName,
                nodeChild: definedName
            }
        ];
        const treeObj = new TreeView({
            fields: { dataSource: data, id: 'nodeId', text: 'nodeText', child: 'nodeChild' }
        });
        const cellrefCont = this.parent.createElement('div', { className: 'e-cont' });
        const cellrefH = this.parent.createElement('div', { className: 'e-header' });
        cellrefH.innerText = l10n.getConstant('CellReference');
        const cellrefInput = this.parent.createElement('input', { className: 'e-input e-text e-hyp-text', attrs: { 'type': 'Text' } });
        cellrefInput.setAttribute('value', 'A1');
        this.inputElements.push(cellrefInput);
        cellrefCont.appendChild(cellrefInput);
        cellrefCont.insertBefore(cellrefH, cellrefInput);
        const textCont1 = this.parent.createElement('div', { className: 'e-cont' });
        const textH1 = this.parent.createElement('div', { className: 'e-header' });
        textH1.innerText = l10n.getConstant('DisplayText');
        const textInput1 = this.parent.createElement('input', { className: 'e-input e-text', attrs: { 'type': 'Text' } });
        this.inputElements.push(textInput1);
        if (!isEnable) {
            textInput1.classList.add('e-disabled');
            textInput1.setAttribute('readonly', 'true');
            textInput1.setAttribute('disabled', 'true');
        }
        if (cell && isNullOrUndefined(cell.hyperlink)) {
            textInput1.setAttribute('value', this.parent.getDisplayText(cell));
        }
        textInput1.setAttribute('placeholder', l10n.getConstant('EnterTheTextToDisplay'));
        textCont1.appendChild(textInput1);
        textCont1.insertBefore(textH1, textInput1);
        const sheetCont = this.parent.createElement('div', { className: 'e-cont' });
        const sheetH = this.parent.createElement('div', { className: 'e-header' });
        sheetH.innerText = l10n.getConstant('Sheet');
        const refCont = this.parent.createElement('div', { className: 'e-refcont' });
        this.divElements.push(textCont);
        this.divElements.push(urlCont);
        this.divElements.push(textH);
        this.divElements.push(urlH);
        this.divElements.push(cellrefCont);
        this.divElements.push(cellrefH);
        this.divElements.push(textCont1);
        this.divElements.push(textH1);
        this.divElements.push(sheetCont);
        this.divElements.push(sheetH);
        this.divElements.push(refCont);
        this.divElements.push(docContElem);
        this.divElements.push(webContElem);
        this.divElements.push(dialogElem);
        sheetCont.appendChild(refCont);
        sheetCont.insertBefore(sheetH, refCont);
        docContElem.appendChild(cellrefCont);
        docContElem.insertBefore(textCont1, cellrefCont);
        treeObj.appendTo(refCont);
        docContElem.appendChild(sheetCont);
        return dialogElem;
    }
    removeHyperlink(args) {
        const cell = getCell(args.rowIdx, args.colIdx, args.sheet);
        if (cell && cell.hyperlink) {
            if (typeof (cell.hyperlink) === 'string') {
                cell.value = cell.value || cell.value === 0 ? cell.value : cell.hyperlink;
            }
            else {
                cell.value = cell.value || cell.value === 0 ? cell.value : cell.hyperlink.address;
            }
            delete (cell.hyperlink);
            if (cell.style) {
                delete cell.style.textDecoration;
                delete cell.style.color;
            }
            if (cell.validation) {
                if (cell.validation.isHighlighted) {
                    if (cell.style.backgroundColor) {
                        cell.style.color = '#ff0000';
                    }
                }
            }
            if (args.sheet === this.parent.getActiveSheet()) {
                if (cell.style) {
                    this.parent.notify(refreshRibbonIcons, null);
                }
                if (!args.preventRefresh) {
                    this.parent.serviceLocator.getService('cell').refresh(args.rowIdx, args.colIdx, false, null, true, false, isImported(this.parent));
                }
            }
        }
    }
    removeHyperlinkHandler(args) {
        let range = args.range;
        let sheetName;
        let sheet = this.parent.getActiveSheet();
        let sheetIdx;
        if (!args.preventEventTrigger) {
            const eventArgs = { address: range.indexOf('!') === -1 ? sheet.name + '!' + range : range, cancel: false };
            this.parent.notify(beginAction, { action: 'removeHyperlink', eventArgs: eventArgs });
            if (eventArgs.cancel) {
                return;
            }
        }
        if (range && range.indexOf('!') !== -1) {
            const lastIndex = range.lastIndexOf('!');
            sheetName = range.substring(0, lastIndex);
            const sheets = this.parent.sheets;
            for (let idx = 0; idx < sheets.length; idx++) {
                if (sheets[idx].name === sheetName) {
                    sheetIdx = idx;
                }
            }
            sheet = this.parent.sheets[sheetIdx];
            range = range.substring(lastIndex + 1);
        }
        const rangeIndexes = range ? getRangeIndexes(range) : getRangeIndexes(sheet.activeCell);
        let cellEle;
        let classList;
        for (let rowIdx = rangeIndexes[0]; rowIdx <= rangeIndexes[2]; rowIdx++) {
            for (let colIdx = rangeIndexes[1]; colIdx <= rangeIndexes[3]; colIdx++) {
                if (sheet && sheet.rows[rowIdx] && sheet.rows[rowIdx].cells[colIdx]) {
                    classList = [];
                    cellEle = this.parent.getCell(rowIdx, colIdx);
                    if (cellEle) {
                        for (let i = 0; i < cellEle.classList.length; i++) {
                            classList.push(cellEle.classList[i]);
                        }
                    }
                    this.parent.notify(deleteHyperlink, { sheet: sheet, rowIdx: rowIdx, colIdx: colIdx });
                    for (let i = 0; i < classList.length; i++) {
                        if (!cellEle.classList.contains(classList[i])) {
                            cellEle.classList.add(classList[i]);
                        }
                    }
                }
            }
        }
        if (!args.preventEventTrigger) {
            this.parent.notify(completeAction, { action: 'removeHyperlink', eventArgs: { address: range.indexOf('!') === -1 ? sheet.name + '!' + range : range } });
        }
    }
}

/**
 * UndoRedo module allows to perform undo redo functionalities.
 */
class UndoRedo {
    constructor(parent) {
        this.undoCollection = [];
        this.redoCollection = [];
        this.isUndo = false;
        this.undoRedoStep = 100;
        this.parent = parent;
        this.addEventListener();
    }
    setActionData(options) {
        const sheet = this.parent.getActiveSheet();
        let address;
        let cells = [];
        let cutCellDetails = [];
        const args = options.args;
        const eventArgs = args.eventArgs;
        let copiedInfo = {};
        switch (args.action) {
            case 'format':
                address = getRangeIndexes(args.eventArgs.range);
                break;
            case 'clipboard':
                copiedInfo = eventArgs.copiedInfo;
                address = getRangeIndexes(getRangeFromAddress(eventArgs.pastedRange));
                if (copiedInfo && copiedInfo.isCut) {
                    cutCellDetails = this.getCellDetails(copiedInfo.range, getSheet(this.parent, getSheetIndexFromId(this.parent, copiedInfo.sId)), 'clipboard');
                }
                break;
            case 'beforeSort':
                address = getRangeIndexes(args.eventArgs.range);
                if (address[0] === address[2] && (address[2] - address[0]) === 0) { //if selected range is a single cell
                    address[0] = 0;
                    address[1] = 0;
                    address[2] = sheet.usedRange.rowIndex;
                    address[3] = sheet.usedRange.colIndex;
                }
                break;
            case 'beforeCellSave':
            case 'cellDelete':
            case 'cellSave':
            case 'addNote':
            case 'editNote':
            case 'deleteNote':
                address = getRangeIndexes(eventArgs.address);
                break;
            case 'beforeWrap':
            case 'beforeReplace':
            case 'chartDesign':
                address = this.parent.getAddressInfo(eventArgs.address).indices;
                break;
            case 'beforeClear':
                address = getRangeIndexes(eventArgs.range);
                break;
            case 'beforeInsertImage':
                address = getRangeIndexes(eventArgs.range);
                break;
            case 'deleteImage':
                address = getRangeIndexes(eventArgs.address);
                break;
            case 'beforeInsertChart':
                address = getRangeIndexes(eventArgs.range);
                break;
            case 'filter':
                address = getRangeIndexes(eventArgs.range);
                break;
            case 'autofill':
                address = getRangeIndexes(eventArgs.fillRange);
                break;
            case 'validation':
                if (isColumnRange(eventArgs.range.substring(eventArgs.range.lastIndexOf('!') + 1))) {
                    address = getRangeIndexes(eventArgs.range);
                    address[2] = sheet.usedRange.rowIndex;
                }
                else {
                    address = getRangeIndexes(eventArgs.range);
                }
                break;
            case 'removeValidation':
                if (eventArgs.isColSelected) {
                    this.beforeActionData = { cellDetails: [] };
                    const rangeArr = eventArgs.range.substring(eventArgs.range.lastIndexOf('!') + 1).split(':');
                    for (let start = getColIndex(rangeArr[0]), end = getColIndex(rangeArr[1]); start <= end; start++) {
                        if (sheet.columns[start] && sheet.columns[start].validation) {
                            this.beforeActionData.cellDetails.push({ colIndex: start, validation: sheet.columns[start].validation });
                        }
                    }
                }
                else {
                    address = getRangeIndexes(eventArgs.range);
                }
                break;
            case 'hyperlink':
            case 'removeHyperlink':
                address = getRangeIndexes(eventArgs.address);
                break;
        }
        if (args.action === 'beforeSort') {
            this.beforeActionData = { cellDetails: eventArgs.cellDetails };
            this.beforeActionData.sortedCellDetails = eventArgs.sortedCellDetails;
        }
        else if (address) {
            if (args.isClearAction && this.beforeActionData.cellDetails.length > 0) {
                cells = this.beforeActionData.cellDetails;
            }
            else {
                cells = this.getCellDetails(address, sheet, args.action);
            }
            this.beforeActionData = { cellDetails: cells, cutCellDetails: cutCellDetails };
        }
    }
    getBeforeActionData(args) {
        args.beforeDetails = this.beforeActionData;
    }
    performUndoRedo(args) {
        let undoRedoArgs;
        if (args.isFromUpdateAction) {
            undoRedoArgs = args;
        }
        else {
            undoRedoArgs = args.isUndo ? this.undoCollection.pop() : this.redoCollection.pop();
            if (args.setCollection) {
                args.undoArgs = undoRedoArgs;
            }
        }
        this.isUndo = args.isUndo;
        let preventEvt;
        if (undoRedoArgs) {
            let actionArgs;
            const undoRedoAction = undoRedoArgs.action;
            const replaceArgs = {};
            let address = [];
            let sheet;
            if (undoRedoArgs.action === 'autofill' || undoRedoArgs.action === 'autofillWithCF') {
                address = undoRedoArgs.eventArgs.fillRange.split('!');
            }
            else if (undoRedoArgs.action === 'cellSave' || undoRedoArgs.action === 'cellDelete') {
                address = undoRedoArgs.eventArgs.address.split('!');
            }
            else if (undoRedoArgs.action === 'clipboard') {
                address = undoRedoArgs.eventArgs.pastedRange.split('!');
            }
            if (address.length > 0) {
                sheet = getSheet(this.parent, getSheetIndex(this.parent, address[0]));
            }
            else if (undoRedoArgs.action === 'clear') {
                sheet = getSheet(this.parent, undoRedoArgs.eventArgs.sheetIndex);
            }
            if (undoRedoArgs.action === 'autofillWithCF') {
                undoRedoArgs.action = 'autofill';
                const conditionalFormat = sheet.conditionalFormats;
                if (conditionalFormat[conditionalFormat.length - 1].action === 'autofillWithCF' && args.isUndo) {
                    if (!conditionalFormat[conditionalFormat.length - 1].value) {
                        this.parent.notify(clearCFRule, { range: conditionalFormat[conditionalFormat.length - 1].range, isAction: true });
                    }
                    else {
                        conditionalFormat.pop();
                    }
                }
            }
            if (!args.isPublic) {
                const actionData = undoRedoArgs.eventArgs.beforeActionData;
                delete undoRedoArgs.eventArgs.beforeActionData;
                actionArgs = { action: undoRedoArgs.action, eventArgs: {} };
                extend(actionArgs.eventArgs, undoRedoArgs.eventArgs, null, true);
                if (this.parent.calculationMode === 'Manual' && (undoRedoArgs.action === 'clipboard' ||
                    undoRedoArgs.action === 'cellDelete' || undoRedoArgs.action === 'autofill' || undoRedoArgs.action === 'clear')) {
                    if (!args.isUndo) {
                        if (sheet.isSheetCalculated) {
                            (actionData.cutCellDetails.length ? actionData.cutCellDetails :
                                actionData.cellDetails).forEach((prevCell) => {
                                const cellVal = getCell(prevCell.rowIndex, prevCell.colIndex, sheet, false, true).value;
                                if ((cellVal || cellVal === 0) && prevCell.value !== cellVal) {
                                    prevCell.value = cellVal;
                                }
                            });
                        }
                    }
                    else if ((undoRedoArgs.eventArgs.requestType === 'paste' && undoRedoArgs.action === 'clipboard') ||
                        undoRedoArgs.eventArgs.fillType) {
                        let undoActionName;
                        if (!actionData.cutCellDetails.length) {
                            undoActionName = undoRedoArgs.eventArgs.fillType ? 'autofill' : 'Copy';
                        }
                        else if (sheet.isSheetCalculated) {
                            undoActionName = 'Cut';
                        }
                        if (undoActionName) {
                            for (let i = 0, cellCol = actionData.cellDetails, cutCellCol = actionData.cutCellDetails; i < cellCol.length; i++) {
                                let cellValue = getCell(cellCol[i].rowIndex, cellCol[i].colIndex, sheet, false, true);
                                cellValue = cellValue ? cellValue.value : '';
                                if (undoActionName === 'Copy') {
                                    cellCol[i].copyCellValue = cellValue;
                                }
                                else if (undoActionName === 'autofill') {
                                    if (cellCol[i].value !== cellValue && cellCol[i].autoFillText !== cellValue) {
                                        cellCol[i].autoFillText = cellValue;
                                    }
                                }
                                else if (undoActionName === 'Cut') {
                                    if (cutCellCol[i].value !== cellValue) {
                                        cutCellCol[i].value = cellValue;
                                    }
                                }
                            }
                        }
                    }
                }
                undoRedoArgs.eventArgs.beforeActionData = actionData;
                actionArgs.eventArgs.cancel = false;
                undoRedoArgs.preventAction = actionArgs.preventAction = true;
                if (args.isUndo) {
                    actionArgs.isUndo = true;
                    if (undoRedoArgs.action === 'cellSave' && this.parent.calculationMode === 'Manual' &&
                        sheet.isSheetCalculated && actionData.cellDetails.length === 1) {
                        const cell = getCell(actionData.cellDetails[0].rowIndex, actionData.cellDetails[0].colIndex, sheet);
                        if (cell && undoRedoArgs.eventArgs.displayText !== cell.value) {
                            undoRedoArgs.eventArgs.displayText = cell.value;
                        }
                    }
                }
                else {
                    actionArgs.isRedo = true;
                }
                if (!args.isFromUpdateAction) {
                    this.parent.notify(beginAction, actionArgs);
                }
                if (actionArgs.eventArgs.cancel) {
                    this.updateUndoRedoIcons();
                    return;
                }
                delete actionArgs.eventArgs.cancel;
            }
            switch (undoRedoArgs.action) {
                case 'cellSave':
                case 'format':
                case 'wrap':
                case 'cellDelete':
                case 'autofill':
                case 'removeValidation':
                case 'hyperlink':
                case 'addNote':
                case 'editNote':
                case 'deleteNote':
                case 'removeHyperlink':
                    undoRedoArgs = this.performOperation(undoRedoArgs, args.preventEvt, args.preventReSelect, args.isFromAutoFillOption);
                    undoRedoArgs.action = undoRedoAction;
                    break;
                case 'sorting':
                    this.undoForSorting(undoRedoArgs, args.isUndo);
                    break;
                case 'clipboard':
                    undoRedoArgs = this.undoForClipboard(undoRedoArgs, args.isUndo, actionArgs);
                    preventEvt = true;
                    break;
                case 'resize':
                case 'resizeToFit':
                    undoRedoArgs = this.undoForResize(undoRedoArgs);
                    if (args.isUndo) {
                        const eventArgs = undoRedoArgs.eventArgs;
                        if (!eventArgs.isPrevCustomHeight) {
                            const sheet = this.parent.sheets[eventArgs.sheetIndex];
                            const row = sheet && getRow(sheet, eventArgs.index);
                            if (row && row.customHeight) {
                                delete row.customHeight;
                            }
                        }
                    }
                    break;
                case 'hideShow':
                    updateAction(undoRedoArgs, this.parent, !args.isUndo);
                    break;
                case 'replace':
                    undoRedoArgs = this.performOperation(undoRedoArgs);
                    break;
                case 'replaceAll':
                    undoRedoArgs.eventArgs.isAction = false;
                    if (args.isUndo) {
                        replaceArgs.value = undoRedoArgs.eventArgs.replaceValue;
                        replaceArgs.replaceValue = undoRedoArgs.eventArgs.value;
                        replaceArgs.skipFormatCheck = isImported(this.parent);
                    }
                    this.parent.notify(replaceAll, Object.assign({}, undoRedoArgs.eventArgs, replaceArgs));
                    break;
                case 'insert':
                case 'filter':
                    updateAction(undoRedoArgs, this.parent, !args.isUndo, null, actionArgs);
                    preventEvt = undoRedoArgs.action === 'filter';
                    break;
                case 'delete':
                    updateAction(undoRedoArgs, this.parent, !args.isUndo);
                    break;
                case 'validation':
                    updateAction(undoRedoArgs, this.parent, !args.isUndo);
                    undoRedoArgs = this.performOperation(undoRedoArgs);
                    break;
                case 'addHighlight':
                case 'removeHighlight':
                    updateAction(undoRedoArgs, this.parent, !args.isUndo);
                    break;
                case 'merge':
                    undoRedoArgs.eventArgs.merge = undoRedoArgs.isFromUpdateAction ?
                        undoRedoArgs.eventArgs.merge : !undoRedoArgs.eventArgs.merge;
                    updateAction(undoRedoArgs, this.parent, !args.isUndo);
                    break;
                case 'clear':
                    undoRedoArgs = this.performOperation(undoRedoArgs);
                    if (args.isUndo && undoRedoArgs.eventArgs.cfClearActionArgs) {
                        updateAction({ action: 'clearCF', eventArgs: undoRedoArgs.eventArgs.cfClearActionArgs }, this.parent, !args.isUndo);
                    }
                    for (let i = this.undoCollection.length; i > 0; i--) {
                        if (this.undoCollection[i - 1].isClearAction) {
                            this.performUndoRedo(args);
                        }
                        else {
                            break;
                        }
                    }
                    break;
                case 'conditionalFormat':
                    updateAction(undoRedoArgs, this.parent, !args.isUndo, this.undoCollection);
                    break;
                case 'clearCF':
                    updateAction(undoRedoArgs, this.parent, !args.isUndo);
                    break;
                case 'insertImage':
                case 'deleteImage':
                    updateAction(undoRedoArgs, this.parent, !args.isUndo);
                    break;
                case 'imageRefresh':
                    updateAction(undoRedoArgs, this.parent, !args.isUndo);
                    break;
                case 'insertChart':
                case 'deleteChart':
                    updateAction(undoRedoArgs, this.parent, !args.isUndo);
                    break;
                case 'chartRefresh':
                    updateAction(undoRedoArgs, this.parent, !args.isUndo);
                    break;
                case 'chartDesign':
                    undoRedoArgs.eventArgs.isUndo = args.isUndo;
                    this.parent.notify(undoRedoForChartDesign, undoRedoArgs.eventArgs);
                    break;
                case 'addDefinedName':
                    updateAction(undoRedoArgs, this.parent, !args.isUndo);
                    break;
            }
            if (!args.isFromUpdateAction) {
                if (args.isUndo) {
                    this.redoCollection.push(undoRedoArgs);
                }
                else {
                    this.undoCollection.push(undoRedoArgs);
                }
                if (this.undoCollection.length > this.undoRedoStep) {
                    this.undoCollection.splice(0, 1);
                }
                if (this.redoCollection.length > this.undoRedoStep) {
                    this.redoCollection.splice(0, 1);
                }
                this.updateUndoRedoIcons();
                if (!args.isPublic && !preventEvt) {
                    this.parent.notify(completeAction, extend({ isUndoRedo: true, isUndo: args.isUndo }, undoRedoArgs));
                }
            }
            this.parent.notify(refreshRibbonIcons, null);
        }
    }
    undoForSorting(args, isUndo) {
        const sheetIndex = getSheetIndexFromAddress(this.parent, args.eventArgs.range);
        const range = getRangeIndexes(args.eventArgs.range);
        const updateSortIcon = (idx, add) => {
            if (sheetIndex === this.parent.activeSheetIndex) {
                let td = this.parent.getCell(range[0] - 1, this.parent.sortCollection[idx].columnIndex);
                if (td) {
                    td = select('.e-filter-icon', td);
                    if (td) {
                        // Determine the class to add or remove
                        const sortClass = `e-sort${this.parent.sortCollection[idx].order === 'Ascending' ? 'asc' : 'desc'}-filter`;
                        if (add) {
                            td.classList.add(sortClass);
                        }
                        else {
                            td.classList.remove(sortClass);
                        }
                    }
                }
            }
        };
        if (isUndo) {
            this.parent.notify(updateSortedDataOnCell, { result: args.eventArgs.beforeActionData.cellDetails, range: range, sheet: getSheet(this.parent, sheetIndex), jsonData: args.eventArgs.beforeActionData.sortedCellDetails, isUndo: true });
            this.parent.notify(sortComplete, { range: args.eventArgs.range });
            if (this.parent.sortCollection && args.eventArgs.previousSort) {
                for (let i = this.parent.sortCollection.length - 1; i >= 0; i--) {
                    if (this.parent.sortCollection[i].sheetIndex === sheetIndex) {
                        updateSortIcon(i, false);
                        this.parent.sortCollection.splice(i, 1);
                        const prevSort = args.eventArgs.previousSort;
                        if (Array.isArray(prevSort)) {
                            for (let j = 0; j < prevSort.length; j++) {
                                this.parent.sortCollection.splice(j, 0, prevSort[j]);
                                updateSortIcon(j, true);
                            }
                        }
                        if (!this.parent.sortCollection.length) {
                            this.parent.sortCollection = undefined;
                        }
                        break;
                    }
                }
            }
        }
        else {
            updateAction(args, this.parent, true);
            if (args.eventArgs.previousSort) {
                let idx = 0;
                if (this.parent.sortCollection) {
                    for (let i = this.parent.sortCollection.length - 1; i >= 0; i--) {
                        if (this.parent.sortCollection[i].sheetIndex === sheetIndex) {
                            updateSortIcon(i, false);
                            idx = i;
                            this.parent.sortCollection.splice(i, 1);
                        }
                    }
                }
                else {
                    this.parent.sortCollection = [];
                }
                this.parent.sortCollection.splice(idx, 0, { sortRange: args.eventArgs.range.substring(args.eventArgs.range.lastIndexOf('!') + 1), sheetIndex: sheetIndex,
                    columnIndex: getColIndex(args.eventArgs.sortOptions.sortDescriptors.field), order: args.eventArgs.sortOptions.sortDescriptors.order });
                updateSortIcon(idx, true);
            }
        }
    }
    updateUndoRedoCollection(options) {
        const actionList = ['clipboard', 'format', 'sorting', 'cellSave', 'resize', 'resizeToFit', 'wrap', 'hideShow', 'replace',
            'validation', 'merge', 'clear', 'conditionalFormat', 'clearCF', 'insertImage', 'imageRefresh', 'insertChart', 'deleteChart',
            'chartRefresh', 'filter', 'cellDelete', 'autofill', 'autofillWithCF', 'addDefinedName', 'removeValidation', 'removeHighlight', 'addHighlight', 'hyperlink', 'removeHyperlink', 'deleteImage', 'chartDesign', 'replaceAll', 'addNote', 'editNote', 'deleteNote'];
        if ((options.args.action === 'insert' || options.args.action === 'delete') && options.args.eventArgs.modelType !== 'Sheet') {
            actionList.push(options.args.action);
        }
        const action = options.args.action;
        if (actionList.indexOf(action) === -1 && !options.isPublic) {
            return;
        }
        const eventArgs = options.args.eventArgs;
        if (action === 'clipboard' || action === 'sorting' || action === 'format' || action === 'cellSave' ||
            action === 'wrap' || action === 'replace' || action === 'validation' || action === 'clear' || action === 'conditionalFormat' ||
            action === 'clearCF' || action === 'insertImage' || action === 'imageRefresh' || action === 'insertChart' ||
            action === 'chartRefresh' || action === 'filter' || action === 'cellDelete' || action === 'autofill' || action === 'autofillWithCF' || action === 'removeValidation' ||
            action === 'addDefinedName' || action === 'hyperlink' || action === 'removeHyperlink' || action === 'deleteImage' || action === 'chartDesign' || action === 'addNote' || action === 'editNote' || action === 'deleteNote') {
            const beforeActionDetails = { beforeDetails: { cellDetails: [] } };
            this.parent.notify(getBeforeActionData, beforeActionDetails);
            eventArgs.beforeActionData = beforeActionDetails.beforeDetails;
        }
        if (action === 'clipboard' && eventArgs.copiedInfo && eventArgs.copiedInfo.isExternal) {
            const addressInfo = this.parent.getAddressInfo(eventArgs.pastedRange);
            eventArgs.copiedInfo.cellDetails = this.getCellDetails(addressInfo.indices, getSheet(this.parent, addressInfo.sheetIndex), action);
        }
        if (this.redoCollection.length > 0 && this.redoCollection[this.redoCollection.length - 1].action === 'autofillWithCF' && options.args.action === 'autofill') {
            options.args.action = 'autofillWithCF';
        }
        this.undoCollection.push(options.args);
        this.redoCollection = [];
        if (this.undoCollection.length > this.undoRedoStep) {
            this.undoCollection.splice(0, 1);
        }
        this.updateUndoRedoIcons();
    }
    clearUndoRedoCollection() {
        this.undoCollection = [];
        this.redoCollection = [];
        this.updateUndoRedoIcons();
    }
    updateUndoRedoIcons() {
        const l10n = this.parent.serviceLocator.getService(locale);
        this.parent.notify(enableToolbarItems, [{
                tab: l10n.getConstant('Home'), items: [this.parent.element.id + '_undo'],
                enable: this.undoCollection.length > 0
            }]);
        this.parent.notify(enableToolbarItems, [{
                tab: l10n.getConstant('Home'), items: [this.parent.element.id + '_redo'],
                enable: this.redoCollection.length > 0
            }]);
    }
    updateUndoRedoSheetReferences(args) {
        const updateReference = (collection) => {
            collection.forEach((editArgs) => {
                const eventArgs = editArgs.eventArgs;
                if (eventArgs) {
                    ['address', 'dataRange', 'fillRange'].forEach((property) => {
                        if (eventArgs[property] && eventArgs[property].includes(args.pName)) {
                            eventArgs[property] = eventArgs[property].replace(args.pName, args.value);
                        }
                    });
                }
            });
        };
        updateReference(this.undoCollection);
        updateReference(this.redoCollection);
    }
    undoForClipboard(args, isUndo, actionArgs) {
        const eventArgs = args.eventArgs;
        const address = [];
        address[0] = eventArgs.pastedRange.substring(0, eventArgs.pastedRange.lastIndexOf('!'));
        address[1] = eventArgs.pastedRange.substring(eventArgs.pastedRange.lastIndexOf('!') + 1);
        const range = getRangeIndexes(address[1]);
        const sheetIndex = getSheetIndex(this.parent, address[0]);
        const sheet = getSheet(this.parent, sheetIndex);
        const copiedInfo = eventArgs.copiedInfo;
        const actionData = eventArgs.beforeActionData;
        const isFromUpdateAction = args.isFromUpdateAction;
        const isRefresh = sheetIndex === this.parent.activeSheetIndex;
        let pictureElem;
        if (actionArgs) {
            actionArgs.isUndoRedo = true;
            actionArgs.eventArgs.beforeActionData = actionData;
        }
        if (args.eventArgs.requestType === 'imagePaste') {
            const copiedShapeInfo = eventArgs.copiedShapeInfo;
            if (isUndo) {
                pictureElem = copiedShapeInfo.pictureElem;
                if (copiedShapeInfo.isCut) {
                    this.parent.notify(deleteImage, {
                        id: pictureElem.id, sheetIdx: eventArgs.pasteSheetIndex + 1, isUndoRedo: true
                    });
                    this.parent.notify(createImageElement, {
                        options: {
                            src: pictureElem.style.backgroundImage.replace(/url\((['"])?(.*?)\1\)/gi, '$2'),
                            height: copiedShapeInfo.height, width: copiedShapeInfo.width, id: pictureElem.id
                        },
                        range: copiedShapeInfo.copiedRange, isPublic: false, isUndoRedo: true
                    });
                }
                else {
                    this.parent.notify(deleteImage, {
                        id: eventArgs.pastedPictureElement.id, sheetIdx: eventArgs.pasteSheetIndex + 1, isUndoRedo: true
                    });
                }
            }
            else {
                if (copiedShapeInfo.isCut) {
                    pictureElem = copiedShapeInfo.pictureElem;
                    this.parent.notify(deleteImage, {
                        id: pictureElem.id, sheetIdx: copiedShapeInfo.sId, isUndoRedo: true
                    });
                    this.parent.notify(createImageElement, {
                        options: {
                            src: pictureElem.style.backgroundImage.replace(/url\((['"])?(.*?)\1\)/gi, '$2'),
                            height: copiedShapeInfo.height, width: copiedShapeInfo.width, id: pictureElem.id
                        },
                        range: copiedShapeInfo.pastedRange, isPublic: false, isUndoRedo: true
                    });
                }
                else {
                    pictureElem = eventArgs.pastedPictureElement;
                    this.parent.notify(createImageElement, {
                        options: {
                            src: pictureElem.style.backgroundImage.replace(/url\((['"])?(.*?)\1\)/gi, '$2'),
                            height: pictureElem.offsetHeight, width: pictureElem.offsetWidth, id: pictureElem.id
                        },
                        range: copiedShapeInfo.pastedRange, isPublic: false, isUndoRedo: true
                    });
                }
            }
        }
        else {
            if (isUndo) {
                if (copiedInfo.isCut) {
                    const cells = actionData.cutCellDetails;
                    this.updateCellDetails(cells, getSheet(this.parent, getSheetIndexFromId(this.parent, copiedInfo.sId)), getSwapRange(copiedInfo.range), isRefresh, args);
                    if (eventArgs.cfClearActionArgs) {
                        updateAction({ action: 'clearCF', eventArgs: eventArgs.cfClearActionArgs }, this.parent, false);
                    }
                }
                if (actionData) {
                    this.updateCellDetails(actionData.cellDetails, sheet, range, isRefresh, args, null, null, actionArgs ?
                        actionArgs.isUndoRedo : null);
                }
                if (eventArgs.cfActionArgs) {
                    eventArgs.cfActionArgs.cfModel.forEach((cf) => {
                        updateAction({ eventArgs: { range: cf.range, type: cf.type, cFColor: cf.cFColor, value: cf.value,
                                sheetIdx: eventArgs.cfActionArgs.sheetIdx, cancel: true }, action: 'conditionalFormat' }, this.parent, false);
                    });
                }
                setMaxHgt(sheet, range[0], range[1], getRowHeight(sheet, range[0]));
                const hgt = getMaxHgt(sheet, range[0]);
                setRowEleHeight(this.parent, sheet, hgt, range[0]);
                eventArgs.mergeCollection.forEach((mergeArgs) => {
                    mergeArgs.merge = !mergeArgs.merge;
                    this.parent.notify(setMerge, mergeArgs);
                    mergeArgs.merge = !mergeArgs.merge;
                });
                if (actionArgs && !isFromUpdateAction) {
                    this.parent.notify(completeAction, actionArgs);
                }
            }
            else {
                if (copiedInfo.isExternal) {
                    const addressInfo = this.parent.getAddressInfo(eventArgs.pastedRange);
                    this.updateCellDetails(copiedInfo.cellDetails, getSheet(this.parent, addressInfo.sheetIndex), addressInfo.indices, true, args, null, null, actionArgs ?
                        actionArgs.isUndoRedo : null);
                    if (actionArgs && !isFromUpdateAction) {
                        this.parent.notify(completeAction, actionArgs);
                    }
                }
                else {
                    const clipboardPromise = new Promise((resolve) => { resolve((() => { })()); });
                    const addressInfo = this.parent.getAddressInfo(eventArgs.copiedRange);
                    this.parent.notify(eventArgs.copiedInfo.isCut ? cut : copy, {
                        range: addressInfo.indices, sId: getSheet(this.parent, addressInfo.sheetIndex).id,
                        promise: clipboardPromise, invokeCopy: true, isPublic: true, isFromUpdateAction: isFromUpdateAction
                    });
                    clipboardPromise.then(() => {
                        this.parent.notify(paste, {
                            range: address ? getIndexesFromAddress(eventArgs.pastedRange) : address,
                            sIdx: address ? getSheetIndex(this.parent, getSheetNameFromAddress(eventArgs.pastedRange)) : address,
                            type: eventArgs.type, isAction: false, isInternal: true, isFromUpdateAction: isFromUpdateAction,
                            beforeActionData: eventArgs.beforeActionData, isUndo: isUndo
                        });
                        if (actionArgs && !isFromUpdateAction) {
                            this.parent.notify(completeAction, actionArgs);
                        }
                    });
                }
            }
            if (isRefresh && !isFromUpdateAction) {
                this.parent.notify(selectRange, { address: eventArgs.selectedRange });
                this.parent.notify(positionAutoFillElement, {});
            }
            else {
                this.checkRefreshNeeded(sheetIndex, isFromUpdateAction);
            }
        }
        return args;
    }
    undoForResize(args) {
        const eventArgs = args.eventArgs;
        if (eventArgs.hide === undefined) {
            if (eventArgs.isCol) {
                const temp = eventArgs.oldWidth;
                eventArgs.oldWidth = eventArgs.width;
                eventArgs.width = temp;
            }
            else {
                const temp = eventArgs.oldHeight;
                eventArgs.oldHeight = eventArgs.height;
                eventArgs.height = temp;
            }
        }
        else {
            eventArgs.hide = !eventArgs.hide;
        }
        updateAction(args, this.parent, false);
        const sheet = this.parent.getActiveSheet();
        const activeCell = getRangeIndexes(sheet.activeCell);
        const CellElem = getCell(activeCell[0], activeCell[1], sheet);
        if (CellElem && CellElem.rowSpan) {
            const td = this.parent.getCell(activeCell[0], activeCell[1]);
            this.parent.element.querySelector('.e-active-cell').style.height = td.offsetHeight + 'px';
        }
        else if (CellElem && CellElem.colSpan) {
            const td = this.parent.getCell(activeCell[0], activeCell[1]);
            this.parent.element.querySelector('.e-active-cell').style.width = td.offsetWidth + 'px';
        }
        return args;
    }
    performOperation(args, preventEvt, preventReSelect, isFromAutoFillOption) {
        const eventArgs = args.eventArgs;
        const address = [];
        const undoRange = (args.action === 'cellSave' || args.action === 'wrap' || args.action === 'replace'
            || args.action === 'cellDelete' || args.action === 'hyperlink' || args.action === 'addNote' || args.action === 'editNote'
            || args.action === 'deleteNote' || args.action === 'removeHyperlink') ? eventArgs.address : eventArgs.range;
        if (args.action === 'autofill') {
            address[0] = eventArgs.fillRange.substring(0, eventArgs.fillRange.lastIndexOf('!'));
            address[1] = eventArgs.fillRange.substring(eventArgs.fillRange.lastIndexOf('!') + 1);
        }
        else {
            address[0] = undoRange.substring(0, undoRange.lastIndexOf('!'));
            address[1] = undoRange.substring(undoRange.lastIndexOf('!') + 1);
        }
        const sheetIndex = getSheetIndex(this.parent, address[0]);
        const sheet = getSheet(this.parent, sheetIndex);
        let range;
        if (eventArgs.isColSelected) {
            const rangeArr = address[1].split(':');
            range = [0, getColIndex(rangeArr[0]), sheet.rowCount - 1, getColIndex(rangeArr[1])];
        }
        else {
            range = getSwapRange(getRangeIndexes(address[1]));
        }
        const indexes = range;
        const actionData = eventArgs.beforeActionData;
        const isFromUpdateAction = args.isFromUpdateAction;
        const isRefresh = this.checkRefreshNeeded(sheetIndex, isFromUpdateAction);
        const uniqueArgs = { cellIdx: [range[0], range[1]], isUnique: false, uniqueRange: '' };
        if (!eventArgs.isColSelected) {
            this.parent.notify(checkUniqueRange, uniqueArgs);
        }
        if (this.isUndo) {
            if (uniqueArgs.isUnique && eventArgs.formula && eventArgs.formula.indexOf('UNIQUE') > -1) {
                const rangeIdx = getRangeIndexes(uniqueArgs.uniqueRange);
                if (getCell(rangeIdx[0], rangeIdx[1], this.parent.getActiveSheet()).value !== '#SPILL!') {
                    for (let j = rangeIdx[0]; j <= rangeIdx[2]; j++) {
                        for (let k = rangeIdx[1]; k <= rangeIdx[3]; k++) {
                            if (j === rangeIdx[0] && k === rangeIdx[1]) {
                                k = k + 1;
                            }
                            this.parent.updateCellInfo({ value: '' }, getRangeAddress([j, k]), true);
                        }
                    }
                }
            }
            this.updateCellDetails(actionData.cellDetails, sheet, range, isRefresh, args, preventEvt, eventArgs.isColSelected, true, isFromAutoFillOption);
            if (uniqueArgs.isUnique && args.action === 'cellDelete' && eventArgs.isSpill) {
                const rangeIdx = getRangeIndexes(uniqueArgs.uniqueRange);
                const cell = getCell(rangeIdx[0], rangeIdx[1], this.parent.getActiveSheet());
                for (let i = rangeIdx[0]; i <= rangeIdx[2]; i++) {
                    for (let j = rangeIdx[1]; j <= rangeIdx[3]; j++) {
                        for (let k = range[0]; k <= range[2]; k++) {
                            for (let l = range[1]; l <= range[3]; l++) {
                                if (i !== k || j !== l) {
                                    this.parent.updateCellInfo({ value: '' }, getCellAddress(i, j), true);
                                }
                            }
                        }
                    }
                }
                cell.value = '#SPILL!';
                this.parent.updateCellInfo(cell, getCellAddress(rangeIdx[0], rangeIdx[1]), true);
            }
            if (!eventArgs.isSpill && uniqueArgs.uniqueRange !== '') {
                const indexes = getRangeIndexes(uniqueArgs.uniqueRange);
                for (let j = indexes[0]; j <= indexes[2]; j++) {
                    for (let k = indexes[1]; k <= indexes[3]; k++) {
                        if (j === indexes[0] && k === indexes[1]) {
                            k = k + 1;
                        }
                        this.parent.updateCellInfo({ value: '' }, getRangeAddress([j, k]), true);
                    }
                }
                this.parent.notify(reApplyFormula, null);
            }
        }
        else {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            const argsEventArgs = args.eventArgs;
            let activeCellIndexes = getRangeIndexes(sheet.activeCell);
            const startRange = address[1] ? address[1].split(':') : [];
            if (indexes[0] !== activeCellIndexes[0] && indexes[1] !== activeCellIndexes[1] &&
                args.action === 'hyperlink' && startRange.length > 0) {
                sheet.activeCell = startRange[0];
                activeCellIndexes = getRangeIndexes(sheet.activeCell);
            }
            let cellValue = this.parent.getCellStyleValue(['textDecoration'], activeCellIndexes).textDecoration;
            if (argsEventArgs && argsEventArgs.style && argsEventArgs.style.textDecoration) {
                const value = argsEventArgs.style.textDecoration;
                let changedValue = value;
                let changedStyle;
                let removeProp = false;
                if (cellValue === 'underline') {
                    changedValue = value === 'underline' ? 'none' : 'underline line-through';
                }
                else if (cellValue === 'line-through') {
                    changedValue = value === 'line-through' ? 'none' : 'underline line-through';
                }
                else if (cellValue === 'underline line-through') {
                    changedValue = value === 'underline' ? 'line-through' : 'underline';
                    removeProp = true;
                }
                if (changedValue === 'none') {
                    removeProp = true;
                }
                argsEventArgs.style.textDecoration = changedValue;
                args.eventArgs = argsEventArgs;
                for (let i = indexes[0]; i <= indexes[2]; i++) {
                    for (let j = indexes[1]; j <= indexes[3]; j++) {
                        changedStyle = {};
                        cellValue = this.parent.getCellStyleValue(['textDecoration'], [i, j]).textDecoration;
                        if (cellValue === 'none') {
                            if (removeProp) {
                                continue;
                            }
                            changedStyle.textDecoration = value;
                        }
                        else if (cellValue === 'underline' || cellValue === 'line-through') {
                            if (removeProp) {
                                if (value === cellValue) {
                                    changedStyle.textDecoration = 'none';
                                }
                                else {
                                    continue;
                                }
                            }
                            else {
                                changedStyle.textDecoration = value !== cellValue ? 'underline line-through' : value;
                            }
                        }
                        else if (cellValue === 'underline line-through') {
                            if (removeProp) {
                                changedStyle.textDecoration = value === 'underline' ? 'line-through' : 'underline';
                            }
                            else {
                                continue;
                            }
                        }
                        this.parent.notify(setCellFormat, {
                            style: { textDecoration: changedStyle.textDecoration }, range: [i, j, i, j], refreshRibbon: true,
                            onActionUpdate: true
                        });
                    }
                }
                argsEventArgs.style.textDecoration = value;
                args.eventArgs = argsEventArgs;
            }
            else {
                if (!isNullOrUndefined(eventArgs.oldValue) && eventArgs.oldValue !== eventArgs.value && uniqueArgs.isUnique) {
                    const indexes = getRangeIndexes(uniqueArgs.uniqueRange);
                    if (getCell(indexes[0], indexes[1], this.parent.getActiveSheet()).value !== '#SPILL!') {
                        for (let j = indexes[0]; j <= indexes[2]; j++) {
                            for (let k = indexes[1]; k <= indexes[3]; k++) {
                                if (j === indexes[0] && k === indexes[1]) {
                                    this.parent.updateCellInfo({ value: '#SPILL!' }, getRangeAddress([indexes[0], indexes[1]]), true);
                                    k = k + 1;
                                }
                                this.parent.updateCellInfo({ value: '' }, getRangeAddress([j, k]), true);
                            }
                        }
                    }
                }
                updateAction(args, this.parent, true);
                if (uniqueArgs.isUnique && args.action === 'cellDelete' && eventArgs.isSpill) {
                    const indexes = getRangeIndexes(uniqueArgs.uniqueRange);
                    let Skip = false;
                    for (let i = indexes[0]; i <= indexes[1]; i++) {
                        for (let j = indexes[1]; j <= indexes[3]; j++) {
                            if (i === indexes[0] && j === indexes[1]) {
                                j++;
                            }
                            if (getCell(i, j, sheet) && !isNullOrUndefined(getCell(i, j, sheet).value)
                                && getCell(i, j, sheet).value !== '') {
                                Skip = true;
                            }
                        }
                    }
                    if (!Skip) {
                        const cell = getCell(indexes[0], indexes[1], this.parent.getActiveSheet());
                        cell.value = '';
                        this.parent.updateCellInfo(cell, getCellAddress(indexes[0], indexes[1]), true);
                        this.parent.notify(reApplyFormula, null);
                    }
                }
            }
        }
        if (args.action === 'autofill') {
            address[1] = this.isUndo ? args.eventArgs.dataRange : args.eventArgs.selectedRange;
        }
        if (isRefresh && !preventReSelect && !isFromUpdateAction) {
            if (eventArgs.isColSelected) {
                address[1] = sheet.selectedRange;
            }
            this.parent.notify(selectRange, { address: address[1] });
        }
        if (this.parent.showAggregate) {
            this.parent.notify(showAggregate, {});
        }
        return args;
    }
    getCellDetails(address, sheet, action) {
        const cells = [];
        let cell;
        const filterCheck = action === 'cellDelete';
        const processedColumns = {};
        address = getSwapRange(address);
        const updateCellProps = (rowIdx, colIdx) => {
            const currentCell = {
                rowIndex: rowIdx, colIndex: colIdx, value: cell ? cell.value : '',
                formula: cell ? cell.formula : ''
            };
            const rowHeight = getRowHeight(sheet, rowIdx);
            if (cell) {
                if (cell.format) {
                    currentCell.format = cell.format;
                }
                if (!isNullOrUndefined(cell.isLocked)) {
                    currentCell.isLocked = cell.isLocked;
                }
                if (cell.style) {
                    currentCell.style = Object.assign({}, cell.style);
                }
                if (cell.wrap) {
                    currentCell.wrap = cell.wrap;
                }
                if (cell.rowSpan) {
                    currentCell.rowSpan = cell.rowSpan;
                }
                if (cell.colSpan) {
                    currentCell.colSpan = cell.colSpan;
                }
                if (cell.image) {
                    currentCell.image = cell.image;
                }
                if (cell.chart) {
                    currentCell.chart = JSON.parse(JSON.stringify(cell.chart));
                }
                if (cell.validation) {
                    currentCell.validation = Object.assign({}, cell.validation);
                }
                if (cell.notes) {
                    currentCell.notes = cell.notes;
                }
                if (cell.isReadOnly) {
                    currentCell.isReadOnly = cell.isReadOnly;
                }
                if (cell.formattedText) {
                    currentCell.formattedText = cell.formattedText;
                }
                if (cell.hyperlink) {
                    currentCell.hyperlink = (isObject(cell.hyperlink) ? extend({}, cell.hyperlink) : cell.hyperlink);
                }
                if (sheet.standardHeight ? rowHeight !== sheet.standardHeight : rowHeight !== 20) {
                    cell.rowHeight = currentCell.rowHeight = rowHeight;
                }
                const editModule = this.parent.editModule;
                currentCell.value = cell && editModule && cell.formula === editModule.editCellData.value &&
                    (!isNullOrUndefined(editModule.editCellData.prevFormulaValue)) ?
                    editModule.editCellData.prevFormulaValue : currentCell.value;
            }
            cells.push(currentCell);
        };
        if (action === 'validation' || action === 'removeValidation') {
            for (let colIdx = address[1]; colIdx <= address[3]; colIdx++) {
                const column = getColumn(sheet, colIdx);
                for (let rowIdx = address[0]; rowIdx <= address[2]; rowIdx++) {
                    if (!processedColumns[colIdx] && checkColumnValidation(column, rowIdx, colIdx)) {
                        cells.push({ colIndex: colIdx, validation: Object.assign({}, column.validation) });
                        processedColumns[colIdx] = true;
                    }
                    cell = getCell(rowIdx, colIdx, sheet);
                    if (cell && !cell.validation) {
                        continue;
                    }
                    updateCellProps(rowIdx, colIdx);
                }
            }
        }
        else {
            for (let i = address[0]; i <= address[2]; i++) {
                if (filterCheck && isFilterHidden(sheet, i)) {
                    continue;
                }
                for (let j = address[1]; j <= address[3]; j++) {
                    cell = getCell(i, j, sheet);
                    updateCellProps(i, j);
                }
            }
        }
        return cells;
    }
    updateCellDetails(cells, sheet, range, isRefresh, args, preventEvt, isColSelected, isUndoRedo, isFromAutoFillOption) {
        const len = cells.length;
        const triggerEvt = args && !preventEvt && (args.action === 'cellSave' || args.action === 'cellDelete' ||
            args.action === 'autofill' || args.action === 'clipboard');
        let cellElem;
        let prevCell;
        let select;
        const cf = args && !args.eventArgs.cfClearActionArgs && sheet.conditionalFormats &&
            sheet.conditionalFormats.length && [].slice.call(sheet.conditionalFormats);
        const cfRule = [];
        let cfRefreshAll;
        let evtArgs;
        let isDelete;
        let deletedRange;
        if (args.action === 'cellDelete') {
            isDelete = false;
            deletedRange = range;
        }
        for (let i = 0; i < len; i++) {
            if (isColSelected || isUndefined$1(cells[i].rowIndex)) {
                setColumn(sheet, cells[i].colIndex, { validation: cells[i].validation });
                continue;
            }
            prevCell = getCell(cells[i].rowIndex, cells[i].colIndex, sheet, false, true);
            if (prevCell.style && args && (args.action === 'format' || args.action === 'clipboard')) {
                if (prevCell.style.borderTop && (!cells[i].style || !cells[i].style.borderTop)) {
                    this.parent.setBorder({ borderTop: '' }, sheet.name + '!' + getCellAddress(cells[i].rowIndex, cells[i].colIndex), null, isUndoRedo);
                }
                if (prevCell.style.borderLeft && (!cells[i].style || !cells[i].style.borderLeft)) {
                    this.parent.setBorder({ borderLeft: '' }, sheet.name + '!' + getCellAddress(cells[i].rowIndex, cells[i].colIndex), null, isUndoRedo);
                }
                if (prevCell.style.borderRight && (!cells[i].style ||
                    !cells[i].style.borderRight)) {
                    this.parent.setBorder({ borderRight: '' }, sheet.name + '!' + getCellAddress(cells[i].rowIndex, cells[i].colIndex), null, isUndoRedo);
                }
                if (prevCell.style.fontSize && (!cells[i].style || !cells[i].style.fontSize)) {
                    prevCell.style.fontSize = '11pt';
                    select = true;
                    this.parent.notify(applyCellFormat, { style: { fontSize: '11pt' }, rowIdx: cells[i].rowIndex, colIdx: cells[i].colIndex, lastCell: true, isHeightCheckNeeded: true, manualUpdate: true, onActionUpdate: true });
                }
                if (prevCell.style.fontFamily && (!cells[i].style || !cells[i].style.fontFamily)) {
                    select = true;
                    prevCell.style.fontFamily = 'Calibri';
                    this.parent.notify(applyCellFormat, { style: { fontFamily: 'Calibri' }, rowIdx: cells[i].rowIndex, colIdx: cells[i].colIndex, lastCell: true, isHeightCheckNeeded: true, manualUpdate: true, onActionUpdate: true });
                }
            }
            if (prevCell.image && args && args.action === 'clipboard') {
                prevCell.image.forEach((image) => {
                    this.parent.notify(deleteImage, { id: image.id, sheet: sheet, preventEventTrigger: true, rowIdx: cells[i].rowIndex,
                        colIdx: cells[i].colIndex });
                });
            }
            const currentCell = {
                value: (cells[i].formula && cells[i].formula.toUpperCase().includes('UNIQUE')) ? null : cells[i].value, formula: cells[i].formula
            };
            if (cells[i].format) {
                currentCell.format = cells[i].format;
            }
            if (!isNullOrUndefined(cells[i].isLocked)) {
                currentCell.isLocked = prevCell.isLocked ? prevCell.isLocked : cells[i].isLocked;
            }
            if (cells[i].style) {
                currentCell.style = Object.assign({}, cells[i].style);
            }
            if (cells[i].wrap) {
                currentCell.wrap = cells[i].wrap;
            }
            if (cells[i].rowSpan) {
                currentCell.rowSpan = cells[i].rowSpan;
            }
            if (cells[i].colSpan) {
                currentCell.colSpan = cells[i].colSpan;
            }
            if (cells[i].hyperlink) {
                currentCell.hyperlink = cells[i].hyperlink;
            }
            if (cells[i].image) {
                currentCell.image = cells[i].image;
            }
            if (cells[i].notes) {
                currentCell.notes = cells[i].notes;
            }
            if (cells[i].isReadOnly) {
                currentCell.isReadOnly = cells[i].isReadOnly;
            }
            if (cells[i].formattedText) {
                currentCell.formattedText = cells[i].formattedText;
            }
            setCell(cells[i].rowIndex, cells[i].colIndex, sheet, currentCell);
            evtArgs = {
                action: 'updateCellValue', address: [cells[i].rowIndex, cells[i].colIndex,
                    cells[i].rowIndex, cells[i].colIndex], notes: cells[i].notes,
                value: cells[i].formula ? cells[i].formula : cells[i].value,
                sheetIndex: getSheetIndex(this.parent, sheet.name), skipFormatCheck: isImported(this.parent),
                isDelete: isDelete, deletedRange: deletedRange, actionName: args.action
            };
            this.parent.notify(workbookEditOperation, evtArgs);
            if (cf && !cfRefreshAll) {
                cfRefreshAll = evtArgs.isFormulaDependent;
            }
            if (args && args.action === 'format' && args.eventArgs.requestType === 'NumberFormat' && currentCell.wrap &&
                currentCell.format !== prevCell.format && !getRow(sheet, cells[i].rowIndex).customHeight) {
                this.parent.notify(wrapEvent, {
                    range: [cells[i].rowIndex, cells[i].colIndex, cells[i].rowIndex,
                        cells[i].colIndex], wrap: true, sheet: sheet, initial: true, isOtherAction: true
                });
            }
            else if ((args && args.action === 'wrap' && args.eventArgs.wrap) || (prevCell.wrap && !cells[i].wrap)) {
                this.parent.notify(wrapEvent, {
                    range: [cells[i].rowIndex, cells[i].colIndex, cells[i].rowIndex,
                        cells[i].colIndex], wrap: false, sheet: sheet, initial: true
                });
            }
            if (args && cells[i].hyperlink && args.action === 'clear') {
                const hyperlinkRange = sheet.name + '!' + getRangeAddress([cells[i].rowIndex, cells[i].colIndex, cells[i].rowIndex, cells[i].colIndex]);
                cellElem = this.parent.getCell(cells[i].rowIndex, cells[i].colIndex);
                if (args.eventArgs.type === 'Clear All' || args.eventArgs.type === 'Clear Hyperlinks') {
                    this.parent.addHyperlink(cells[i].hyperlink, hyperlinkRange, cells[i].value);
                }
                else if (args.eventArgs.type === 'Clear Formats' && cellElem) {
                    addClass(cellElem.querySelectorAll('.e-hyperlink'), 'e-hyperlink-style');
                }
            }
            if (cells[i].validation) {
                this.parent.notify(cellValidation, { rules: cells[i].validation,
                    range: `${sheet.name}!${getCellAddress(cells[i].rowIndex, cells[i].colIndex)}` });
            }
            if (triggerEvt && cells[i].value !== prevCell.value) {
                this.parent.trigger('cellSave', { element: null, value: cells[i].value, oldValue: prevCell.value, formula: cells[i].formula, cancel: false,
                    address: `${sheet.name}!${getCellAddress(cells[i].rowIndex, cells[i].colIndex)}`,
                    displayText: this.parent.getDisplayText(cells[i]) });
            }
            if (cf && !cfRefreshAll) {
                updateCFModel(cf, cfRule, cells[i].rowIndex, cells[i].colIndex);
            }
        }
        if (isRefresh) {
            if (range[0] === range[2] && range[1] === range[3]) {
                const cell = getCell(range[0], range[1], sheet);
                if (cell.rowSpan > 1) {
                    range[2] = range[0] + cell.rowSpan - 1;
                }
                if (cell.colSpan > 1) {
                    range[3] = range[1] + cell.colSpan - 1;
                }
            }
            let isHeightCheckFromUndo = false;
            if (args.action === 'autofill' || args.action === 'clipboard' || args.action === 'wrap') {
                isHeightCheckFromUndo = true;
            }
            else if (args.action === 'format' && args.eventArgs.requestType === 'CellFormat') {
                isHeightCheckFromUndo = isHeightCheckNeeded(args.eventArgs.style, true);
            }
            this.parent.serviceLocator.getService('cell').refreshRange(range, false, false, true, false, isImported(this.parent), null, isFromAutoFillOption, isHeightCheckFromUndo, null, null, cells);
            if (cfRule.length || cfRefreshAll) {
                this.parent.notify(applyCF, { cfModel: !cfRefreshAll && cfRule, refreshAll: cfRefreshAll, isAction: true });
            }
            if (select) {
                getUpdateUsingRaf(() => this.parent.selectRange(sheet.selectedRange));
            }
        }
    }
    checkRefreshNeeded(sheetIndex, isFromUpdateAction) {
        let isRefresh = true;
        if (sheetIndex !== this.parent.activeSheetIndex) {
            if (!isFromUpdateAction) {
                this.parent.activeSheetIndex = sheetIndex;
                this.parent.dataBind();
            }
            isRefresh = false;
        }
        return isRefresh;
    }
    addEventListener() {
        this.parent.on(performUndoRedo, this.performUndoRedo, this);
        this.parent.on(updateUndoRedoCollection, this.updateUndoRedoCollection, this);
        this.parent.on(setActionData, this.setActionData, this);
        this.parent.on(getBeforeActionData, this.getBeforeActionData, this);
        this.parent.on(clearUndoRedoCollection, this.clearUndoRedoCollection, this);
        this.parent.on(setUndoRedo, this.updateUndoRedoIcons, this);
        this.parent.on(sheetRenameUpdate, this.updateUndoRedoSheetReferences, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(performUndoRedo, this.performUndoRedo);
            this.parent.off(updateUndoRedoCollection, this.updateUndoRedoCollection);
            this.parent.off(setActionData, this.setActionData);
            this.parent.off(getBeforeActionData, this.getBeforeActionData);
            this.parent.off(clearUndoRedoCollection, this.clearUndoRedoCollection);
            this.parent.off(setUndoRedo, this.updateUndoRedoIcons);
            this.parent.off(sheetRenameUpdate, this.updateUndoRedoSheetReferences);
        }
    }
    /**
     * Destroy undo redo module.
     *
     * @returns {void} - Destroy undo redo module.
     */
    destroy() {
        this.removeEventListener();
        if (this.undoCollection.length > 0) {
            this.undoCollection = [];
        }
        if (this.redoCollection.length > 0) {
            this.redoCollection = [];
        }
        if (this.beforeActionData && this.beforeActionData.cellDetails) {
            this.beforeActionData.cellDetails = [];
        }
        this.parent = null;
    }
    /**
     * Get the undo redo module name.
     *
     * @returns {string} - Get the undo redo module name.
     */
    getModuleName() {
        return 'undoredo';
    }
}

/**
 * Represents Wrap Text support for Spreadsheet.
 */
class WrapText {
    /**
     * Constructor for the Spreadsheet Wrap Text module.
     *
     * @param {Spreadsheet} parent - Specifies the Spreadsheet.
     * @private
     */
    constructor(parent) {
        this.parent = parent;
        this.wrapCell = this.parent.createElement('span', { className: 'e-wrap-content' });
        this.addEventListener();
    }
    addEventListener() {
        this.parent.on(ribbonClick, this.ribbonClickHandler, this);
        this.parent.on(wrapEvent, this.wrapTextHandler, this);
        this.parent.on(rowHeightChanged, this.rowHeightChangedHandler, this);
        this.parent.on(colWidthChanged, this.colWidthChanged, this);
        this.parent.on(updateWrapCell, this.updateWrapCell, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(ribbonClick, this.ribbonClickHandler);
            this.parent.off(wrapEvent, this.wrapTextHandler);
            this.parent.off(rowHeightChanged, this.rowHeightChangedHandler);
            this.parent.off(colWidthChanged, this.colWidthChanged);
            this.parent.off(updateWrapCell, this.updateWrapCell);
        }
    }
    wrapTextHandler(args) {
        if (args.initial || inView(this.parent, args.range, true)) {
            if (args.isPublic && isReadOnlyCells(this.parent, args.range)) {
                return;
            }
            if (args.initial && !args.td && !args.outsideViewport && inView(this.parent, args.range, true)) {
                args.initial = false;
            }
            let ele;
            let cell;
            let colwidth;
            let maxHgt;
            let hgt;
            let isCustomHgt;
            let rowCustomHeight;
            let lineHgt;
            let row;
            let visibleRow;
            const frozenRow = this.parent.frozenRowCount(args.sheet);
            let isLessStandardHgt;
            let filterRange;
            let hyperlinkEle;
            if (!isNullOrUndefined(args.sheet.standardHeight) && args.sheet.standardHeight < 20) {
                isLessStandardHgt = true;
            }
            else {
                filterRange = this.parent.allowFiltering &&
                    this.parent.filterModule.filterRange.has(this.parent.activeSheetIndex) &&
                    this.parent.filterModule.filterRange.get(this.parent.activeSheetIndex).range;
            }
            for (let i = args.range[0]; i <= args.range[2]; i++) {
                maxHgt = 0;
                row = getRow(args.sheet, i);
                rowCustomHeight = row.customHeight;
                isCustomHgt = rowCustomHeight || args.isCustomHgt;
                visibleRow = !isHiddenRow(args.sheet, i);
                for (let j = args.range[1]; j <= args.range[3]; j++) {
                    cell = getCell(i, j, args.sheet, null, true);
                    if (cell.rowSpan < 0 || cell.colSpan < 0) {
                        continue;
                    }
                    const isMerge = cell.rowSpan > 1 || cell.colSpan > 1;
                    ele = args.initial ? args.td : (visibleRow && !isHiddenCol(args.sheet, j) && this.parent.getCell(i, j));
                    if (ele) {
                        if (args.wrap) {
                            lineHgt = getLineHeight(cell.style && cell.style.fontFamily ? cell.style : this.parent.cellStyle);
                            ele.classList.add(WRAPTEXT);
                        }
                        else {
                            ele.classList.remove(WRAPTEXT);
                            lineHgt = null;
                        }
                        if (isCustomHgt || isMerge || row.height < 20 || isLessStandardHgt ||
                            (filterRange && i === filterRange[0] && j >= filterRange[1] && j <= filterRange[3])) {
                            this.updateWrapCell({ rowIdx: i, colIdx: j, sheet: args.sheet, ele: ele });
                        }
                        if (Browser.isIE) {
                            ele.classList.add('e-ie-wrap');
                        }
                    }
                    else {
                        lineHgt = null;
                    }
                    if (!(isCustomHgt || isMerge)) {
                        colwidth = getExcludedColumnWidth(args.sheet, i, j, cell.colSpan > 1 ? j + cell.colSpan - 1 : j);
                        let displayText = this.parent.getDisplayText(cell).toString();
                        if (this.parent.isEdit && ele && displayText.indexOf('\n') < 0) {
                            const editElem = this.parent.element.querySelector('.e-spreadsheet-edit');
                            if (editElem) {
                                if (editElem.textContent.indexOf('\n') > -1) {
                                    displayText = editElem.textContent;
                                }
                            }
                        }
                        if (displayText) {
                            if (args.wrap) {
                                if (ele && ele.classList.contains('e-alt-unwrap')) {
                                    ele.classList.remove('e-alt-unwrap');
                                    if (displayText.includes('\n')) {
                                        hyperlinkEle = ele.querySelector('.e-hyperlink');
                                        if (hyperlinkEle && !hyperlinkEle.innerText.includes('\n')) {
                                            hyperlinkEle.innerText = displayText;
                                        }
                                    }
                                }
                                let lines;
                                let n = 0;
                                let p;
                                if (displayText.indexOf('\n') > -1) {
                                    const splitVal = displayText.split('\n');
                                    const valLength = splitVal.length;
                                    for (p = 0; p < valLength; p++) {
                                        lines = getLines(splitVal[p], colwidth, cell.style, this.parent.cellStyle);
                                        if (lines === 0) {
                                            lines = 1; // for empty new line
                                        }
                                        n = n + lines;
                                    }
                                    lines = n;
                                }
                                else {
                                    lines = getLines(displayText, colwidth, cell.style, this.parent.cellStyle);
                                }
                                hgt = getTextHeightWithBorder(this.parent, i, j, args.sheet, cell.style || this.parent.cellStyle, lines, lineHgt);
                                maxHgt = Math.max(maxHgt, hgt);
                                if (cell.rowSpan > 1) {
                                    const prevHeight = getRowsHeight(args.sheet, i, i + (cell.rowSpan - 1));
                                    if (prevHeight >= maxHgt) {
                                        return;
                                    }
                                    hgt = maxHgt = getRowHeight(args.sheet, i) + (maxHgt - prevHeight);
                                }
                                setMaxHgt(args.sheet, i, j, hgt);
                            }
                            else {
                                if (ele) {
                                    if (displayText.indexOf('\n') > -1) {
                                        ele.classList.add('e-alt-unwrap');
                                    }
                                    hyperlinkEle = ele.querySelector('.e-hyperlink');
                                    if (hyperlinkEle) {
                                        const hyperlinkText = hyperlinkEle.innerText;
                                        if (hyperlinkText.includes('\n')) {
                                            hyperlinkEle.innerText = hyperlinkText.split('\n').join(' ');
                                        }
                                    }
                                }
                                hgt = getTextHeightWithBorder(this.parent, i, j, args.sheet, cell.style || this.parent.cellStyle, 1, lineHgt);
                                setMaxHgt(args.sheet, i, j, hgt);
                                maxHgt = Math.max(getMaxHgt(args.sheet, i), 20);
                            }
                        }
                        else if (!args.wrap || !displayText) {
                            setMaxHgt(args.sheet, i, j, 20);
                            maxHgt = Math.max(getMaxHgt(args.sheet, i), 20);
                        }
                        if (j === args.range[3]) {
                            const prevHgt = getRowHeight(args.sheet, i);
                            if ((args.wrap && (args.isOtherAction ? maxHgt >= 20 : maxHgt > 20) && getMaxHgt(args.sheet, i) <= maxHgt) ||
                                ((!args.wrap || !displayText) && getMaxHgt(args.sheet, i) < prevHgt && prevHgt > 20)) {
                                if (prevHgt !== maxHgt) {
                                    if (ele) {
                                        setRowEleHeight(this.parent, args.sheet, maxHgt, i, args.row, args.hRow, visibleRow);
                                        if (ele && args.sheet.conditionalFormats && args.sheet.conditionalFormats.length) {
                                            this.parent.notify(applyCF, { indexes: [i, j], isAction: true });
                                        }
                                    }
                                    else {
                                        setRowEleHeight(this.parent, args.sheet, maxHgt, i, null, null, visibleRow, !visibleRow || i > this.parent.viewport.bottomIndex ||
                                            (i >= frozenRow && i < this.parent.viewport.topIndex + frozenRow));
                                    }
                                }
                            }
                        }
                    }
                    if (ele) {
                        if (isCustomHgt && !isMerge) {
                            const displayText = this.parent.getDisplayText(cell);
                            if (args.wrap) {
                                if (ele.classList.contains('e-alt-unwrap')) {
                                    ele.classList.remove('e-alt-unwrap');
                                }
                            }
                            else if (displayText.indexOf('\n') > -1) {
                                ele.classList.add('e-alt-unwrap');
                            }
                        }
                        if (args.wrap) {
                            if (!rowCustomHeight) {
                                ele.style.lineHeight = (parseFloat((cell.style && cell.style.fontSize) || this.parent.cellStyle.fontSize) *
                                    lineHgt) + 'pt';
                            }
                            else if (ele.style.lineHeight) {
                                ele.style.lineHeight = '';
                            }
                        }
                        else {
                            ele.style.lineHeight = '';
                        }
                    }
                }
            }
            if (!args.initial) {
                this.parent.notify(positionAutoFillElement, null);
            }
        }
    }
    ribbonClickHandler(args) {
        const target = closest(args.originalEvent.target, '.e-btn');
        if (target && target.id === this.parent.element.id + '_wrap') {
            const wrap$1 = target.classList.contains('e-active');
            const address = getAddressFromSelectedRange(this.parent.getActiveSheet());
            const eventArgs = { address: address, wrap: wrap$1, cancel: false };
            if (isReadOnlyCells(this.parent)) {
                this.parent.notify(readonlyAlert, null);
                return;
            }
            this.parent.notify(beginAction, { action: 'beforeWrap', eventArgs: eventArgs });
            if (!eventArgs.cancel) {
                wrap(this.parent.getActiveSheet().selectedRange, wrap$1, this.parent);
                this.parent.notify(completeAction, { action: 'wrap', eventArgs: { address: address, wrap: wrap$1 } });
            }
        }
    }
    rowHeightChangedHandler(args) {
        if (args.isCustomHgt) {
            args.sheet = this.parent.getActiveSheet();
            for (let i = this.parent.viewport.leftIndex, len = this.parent.viewport.rightIndex; i <= len; i++) {
                if (getCell(args.rowIdx, i, args.sheet, false, true).wrap) {
                    args.colIdx = i;
                    args.ele = this.parent.getCell(args.rowIdx, i);
                    this.updateWrapCell(args);
                    if (args.ele.style.lineHeight) {
                        args.ele.style.lineHeight = '';
                    }
                }
            }
        }
    }
    colWidthChanged(args) {
        if (args.checkWrapCell) {
            args.sheet = this.parent.getActiveSheet();
            for (let i = this.parent.viewport.topIndex, len = this.parent.viewport.bottomIndex; i <= len; i++) {
                if (getCell(i, args.colIdx, args.sheet, false, true).wrap) {
                    args.rowIdx = i;
                    args.ele = this.parent.getCell(i, args.colIdx);
                    this.updateWrapCell(args);
                }
            }
        }
    }
    updateWrapCell(args) {
        if (args.ele && !args.ele.querySelector('.e-wrap-content')) {
            const wrapSpan = this.wrapCell.cloneNode();
            const filterBtn = args.ele.querySelector('.e-filter-btn');
            while (args.ele.childElementCount && !isNullOrUndefined(args.ele.firstElementChild) &&
                args.ele.firstElementChild.className.indexOf('e-addNoteIndicator') === -1) {
                wrapSpan.appendChild(args.ele.firstElementChild);
            }
            let nodeElement;
            if (!isNullOrUndefined(args.ele.firstElementChild) && args.ele.firstElementChild.className.indexOf('e-addNoteIndicator') > -1) {
                nodeElement = args.ele.firstElementChild;
            }
            if (filterBtn) {
                if (args.ele.firstChild) {
                    args.ele.insertBefore(filterBtn, args.ele.firstChild);
                }
                else {
                    args.ele.appendChild(filterBtn);
                }
            }
            if (!getCell(args.rowIdx, args.colIdx, args.sheet, false, true).hyperlink) {
                const node = args.ele.lastChild;
                if (node && node.nodeType === 3) {
                    wrapSpan.appendChild(document.createTextNode(node.textContent));
                    node.textContent = '';
                }
                else {
                    wrapSpan.appendChild(document.createTextNode(args.ele.textContent));
                    args.ele.textContent = '';
                }
            }
            args.ele.appendChild(wrapSpan);
            if (!isNullOrUndefined(nodeElement)) {
                args.ele.appendChild(nodeElement);
            }
        }
    }
    /**
     * For internal use only - Get the module name.
     *
     * @returns {string} - Get the module name.
     * @private
     */
    getModuleName() {
        return 'wrapText';
    }
    /**
     * Removes the added event handlers and clears the internal properties of WrapText module.
     *
     * @returns {void}
     */
    destroy() {
        this.removeEventListener();
        if (this.wrapCell) {
            this.wrapCell.remove();
            this.wrapCell = null;
        }
        this.parent = null;
    }
}

/**
 * The `Insert` module is used to insert cells, rows, columns and sheets in to the spreadsheet.
 */
class Insert {
    /**
     * Constructor for the Spreadsheet insert module.
     *
     * @param {Spreadsheet} parent - Specify the spreadsheet instance.
     * @private
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    insert(actionArgs) {
        const args = actionArgs.eventArgs;
        this.parent.notify(beforeInsert, args);
        const sheet = getSheet(this.parent, args.activeSheetIndex);
        switch (args.modelType) {
            case 'Sheet':
                this.parent.notify(insertSheetTab, { startIdx: args.index, endIdx: args.index + (args.model.length - 1), preventUpdate: !args.isAction });
                this.parent.renderModule.refreshSheet();
                break;
            case 'Row':
                if (args.activeSheetIndex === this.parent.activeSheetIndex) {
                    const frozenRow = this.parent.frozenRowCount(sheet);
                    if (!this.parent.scrollSettings.enableVirtualization ||
                        args.index <= this.parent.viewport.bottomIndex) {
                        if (args.freezePane) {
                            this.parent.renderModule.refreshSheet(false, false, true);
                        }
                        else if (this.parent.scrollSettings.enableVirtualization) {
                            const frozenCol = this.parent.frozenColCount(sheet);
                            if (args.index >= this.parent.viewport.topIndex + frozenRow) {
                                const frozenIndexes = [];
                                let colIndex;
                                if (frozenCol) {
                                    colIndex = getCellIndexes(sheet.topLeftCell)[1];
                                    frozenIndexes.push(frozenRow);
                                    frozenIndexes.push(this.parent.viewport.leftIndex + frozenCol);
                                }
                                else {
                                    colIndex = this.parent.viewport.leftIndex;
                                }
                                const prevColIdx = this.parent.viewport.leftIndex;
                                this.parent.renderModule.refreshUI({
                                    rowIndex: this.parent.viewport.topIndex, colIndex: colIndex, refresh: 'Row',
                                    frozenIndexes: frozenIndexes, skipUpdateOnFirst: this.parent.viewport.topIndex +
                                        frozenRow === skipHiddenIdx(sheet, frozenRow, true)
                                });
                                if (frozenCol) {
                                    this.parent.viewport.leftIndex = prevColIdx;
                                }
                            }
                            const topIdx = getCellIndexes(sheet.paneTopLeftCell)[0];
                            if (args.index < topIdx) {
                                this.parent.notify(updateScrollValue, { scrollTop: getRowsHeight(sheet, frozenRow, topIdx - 1, true) });
                                this.parent.goTo(getCellAddress(args.index, skipHiddenIdx(sheet, frozenCol, true, 'columns')));
                            }
                            this.parent.selectRange(sheet.selectedRange);
                        }
                        else {
                            this.parent.renderModule.refreshSheet(false, false, true);
                        }
                    }
                    else if (this.parent.scrollSettings.isFinite && (this.parent.viewport.topIndex + frozenRow ===
                        skipHiddenIdx(sheet, 0, true) || this.parent.viewport.bottomIndex === skipHiddenIdx(sheet, sheet.rowCount - args.model.length - 1, false))) {
                        this.parent.renderModule.refreshSheet(false, false, true);
                    }
                }
                break;
            case 'Column':
                if (args.activeSheetIndex === this.parent.activeSheetIndex) {
                    const frozenCol = this.parent.frozenColCount(sheet);
                    if (!this.parent.scrollSettings.enableVirtualization || args.index <= this.parent.viewport.rightIndex) {
                        if (args.freezePane) {
                            this.parent.renderModule.refreshSheet(false, false, true);
                        }
                        else if (this.parent.scrollSettings.enableVirtualization) {
                            const frozenRow = this.parent.frozenRowCount(sheet);
                            if (args.index >= this.parent.viewport.leftIndex + frozenCol) {
                                let frozenIndexes = [];
                                if (frozenRow) {
                                    frozenIndexes = [frozenRow + this.parent.viewport.topIndex, frozenCol];
                                }
                                const rowIndex = frozenRow ? getCellIndexes(sheet.topLeftCell)[0] : this.parent.viewport.topIndex;
                                const prevRowIdx = this.parent.viewport.topIndex;
                                this.parent.renderModule.refreshUI({ skipUpdateOnFirst: this.parent.viewport.leftIndex + frozenCol === skipHiddenIdx(sheet, frozenCol, true, 'columns'), rowIndex: rowIndex, colIndex: this.parent.viewport.leftIndex,
                                    refresh: 'Column', frozenIndexes: frozenIndexes });
                                if (frozenRow) {
                                    this.parent.viewport.topIndex = prevRowIdx;
                                }
                            }
                            const leftIdx = getCellIndexes(sheet.paneTopLeftCell)[1];
                            if (args.index < leftIdx) {
                                this.parent.notify(updateScrollValue, { scrollLeft: getColumnsWidth(sheet, 0, leftIdx - 1, true) });
                                this.parent.goTo(getCellAddress(skipHiddenIdx(sheet, frozenRow, true), args.index));
                            }
                            this.parent.selectRange(sheet.selectedRange);
                        }
                        else {
                            this.parent.renderModule.refreshSheet(false, false, true);
                        }
                    }
                    else if (this.parent.scrollSettings.isFinite && (this.parent.viewport.leftIndex + frozenCol ===
                        skipHiddenIdx(sheet, 0, true, 'columns') || this.parent.viewport.rightIndex === skipHiddenIdx(sheet, sheet.colCount - args.model.length - 1, false, 'columns'))) {
                        this.parent.renderModule.refreshSheet(false, false, true);
                    }
                }
                break;
        }
        this.refreshImgElement(args.model.length, this.parent.activeSheetIndex, args.modelType, args.index);
        if (args.isAction) {
            delete args.isAction;
            this.parent.notify(completeAction, actionArgs);
            focus(this.parent.element);
        }
        else if (!args.isUndoRedo) {
            args.isMethod = true;
            this.parent.notify(triggerDataChange, actionArgs);
        }
    }
    refreshImgElement(count, sheetIdx, modelType, index) {
        const sheet = this.parent.sheets[sheetIdx];
        let cellObj;
        const indexes = [0, 0, sheet.usedRange.rowIndex, sheet.usedRange.colIndex];
        for (let i = 0; i <= indexes[2]; i++) {
            for (let j = indexes[1]; j <= indexes[3]; j++) {
                cellObj = getCell(i, j, sheet);
                if (cellObj && cellObj.image && cellObj.image.length > 0) {
                    if ((modelType === 'Row' && i >= index) || (modelType === 'Column' && j >= index)) {
                        this.parent.notify(refreshImagePosition, {
                            rowIdx: i, colIdx: j, sheetIdx: sheetIdx, type: modelType, count: count, status: 'insert'
                        });
                    }
                }
            }
        }
    }
    addEventListener() {
        this.parent.on(insert, this.insert, this);
    }
    /**
     * Destroy insert module.
     *
     * @returns {void} - Destroy insert module.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(insert, this.insert);
        }
    }
    /**
     * Get the insert module name.
     *
     * @returns {string} - Get the insert module name.
     */
    getModuleName() {
        return 'insert';
    }
}

/**
 * The `Delete` module is used to delete cells, rows, columns and sheets from the spreadsheet.
 */
class Delete {
    /**
     * Constructor for the Spreadsheet insert module.
     *
     * @param {Spreadsheet} parent - Constructor for the Spreadsheet insert module.
     * @private
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    delete(actionArgs) {
        const args = actionArgs.eventArgs;
        if (args.modelType === 'Sheet') {
            const activeSheetDeleted = args.activeSheetIndex >= args.startIndex && args.activeSheetIndex <= args.endIndex;
            if (activeSheetDeleted) {
                this.parent.setProperties({ activeSheetIndex: this.parent.skipHiddenSheets(args.startIndex < this.parent.sheets.length ? args.startIndex :
                        (args.startIndex ? args.startIndex - 1 : 0)) }, true);
            }
            if (args.endIndex < args.activeSheetIndex) {
                this.parent.setProperties({ activeSheetIndex: args.activeSheetIndex - ((args.endIndex + 1) - args.startIndex) }, true);
            }
            this.parent.notify(refreshSheetTabs, null);
            if (activeSheetDeleted) {
                this.parent.renderModule.refreshSheet(false, false, true);
            }
        }
        else if (args.activeSheetIndex === this.parent.activeSheetIndex) {
            const sheet = this.parent.getActiveSheet();
            const frozenRow = this.parent.frozenRowCount(sheet);
            const frozenCol = this.parent.frozenColCount(sheet);
            if (args.modelType === 'Row') {
                if (!this.parent.scrollSettings.enableVirtualization || args.startIndex <= this.parent.viewport.bottomIndex) {
                    if (this.parent.scrollSettings.enableVirtualization) {
                        if (args.startIndex < getCellIndexes(sheet.paneTopLeftCell)[0]) {
                            this.parent.updateTopLeftCell(skipHiddenIdx(sheet, args.startIndex - 1 < frozenRow ? frozenRow : args.startIndex - 1, true) - frozenRow, null, 'col');
                            this.parent.renderModule.refreshSheet(false, false, true);
                        }
                        else {
                            if (args.freezePane || (this.parent.scrollSettings.isFinite &&
                                this.parent.viewport.bottomIndex >= skipHiddenIdx(sheet, sheet.rowCount - 1, false))) {
                                this.parent.renderModule.refreshSheet(false, false, true);
                            }
                            else {
                                const frozenIndexes = [];
                                const frozenCol = this.parent.frozenColCount(sheet);
                                let colIndex;
                                const viewportColIdx = this.parent.viewport.leftIndex;
                                if (frozenCol) {
                                    frozenIndexes.push(frozenRow);
                                    frozenIndexes.push(viewportColIdx + frozenCol);
                                    colIndex = getCellIndexes(sheet.topLeftCell)[1];
                                }
                                else {
                                    colIndex = viewportColIdx;
                                }
                                this.parent.renderModule.refreshUI({ rowIndex: this.parent.viewport.topIndex, refresh: 'Row', colIndex: colIndex, skipUpdateOnFirst: this.parent.viewport.topIndex + frozenRow === skipHiddenIdx(sheet, frozenRow, true),
                                    frozenIndexes: frozenIndexes });
                                if (frozenCol) {
                                    this.parent.viewport.leftIndex = viewportColIdx;
                                }
                                this.parent.selectRange(sheet.selectedRange);
                            }
                        }
                    }
                    else {
                        this.parent.renderModule.refreshSheet(false, false, true);
                    }
                }
            }
            else {
                if (args.refreshSheet !== false && (!this.parent.scrollSettings.enableVirtualization ||
                    args.startIndex <= this.parent.viewport.rightIndex)) {
                    if (this.parent.scrollSettings.enableVirtualization) {
                        if (args.startIndex < getCellIndexes(sheet.paneTopLeftCell)[1]) {
                            this.parent.updateTopLeftCell(null, skipHiddenIdx(sheet, args.startIndex - 1 < frozenCol ? frozenCol :
                                args.startIndex - 1, true, 'columns') - frozenCol, 'row');
                            this.parent.renderModule.refreshSheet(false, false, true);
                        }
                        else {
                            if (args.freezePane || args.refreshSheet === true) {
                                this.parent.renderModule.refreshSheet(false, false, true);
                            }
                            else {
                                const frozenRow = this.parent.frozenRowCount(sheet);
                                let frozenIndexes = [];
                                const viewportRowIdx = this.parent.viewport.topIndex;
                                const rowIndex = frozenRow ? getCellIndexes(sheet.topLeftCell)[0] : viewportRowIdx;
                                if (frozenRow) {
                                    frozenIndexes = [frozenRow + viewportRowIdx, frozenCol];
                                }
                                this.parent.renderModule.refreshUI({ rowIndex: rowIndex, refresh: 'Column', colIndex: this.parent.viewport.leftIndex, insertDelete: true,
                                    skipUpdateOnFirst: this.parent.viewport.leftIndex + frozenCol === skipHiddenIdx(sheet, frozenCol, true, 'columns'), frozenIndexes: frozenIndexes });
                                if (frozenRow) {
                                    this.parent.viewport.topIndex = viewportRowIdx;
                                }
                                this.parent.selectRange(sheet.selectedRange);
                            }
                        }
                    }
                    else {
                        this.parent.renderModule.refreshSheet(false, false, true);
                    }
                }
                delete args.refreshSheet;
            }
        }
        this.refreshImgElement(args.deletedModel.length, this.parent.activeSheetIndex, args.modelType, args.startIndex);
        if (args.isAction) {
            delete args.isAction;
            this.parent.notify(completeAction, actionArgs);
            focus(this.parent.element);
        }
        else if (!args.isUndoRedo) {
            args.isMethod = true;
            this.parent.notify(triggerDataChange, actionArgs);
        }
    }
    addEventListener() {
        this.parent.on(deleteAction, this.delete, this);
    }
    /**
     * Destroy delete module.
     *
     * @returns {void} - Destroy delete module.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(deleteAction, this.delete);
        }
    }
    /**
     * Get the delete module name.
     *
     * @returns {string} - Get the delete module name.
     */
    getModuleName() {
        return 'delete';
    }
    refreshImgElement(count, sheetIdx, modelType, index) {
        const sheet = this.parent.sheets[sheetIdx];
        let cell;
        const address = [0, 0, sheet.usedRange.rowIndex, sheet.usedRange.colIndex];
        for (let i = 0; i <= address[2]; i++) {
            for (let j = address[1]; j <= address[3]; j++) {
                cell = getCell(i, j, sheet);
                if (cell && cell.image && cell.image.length > 0) {
                    if ((modelType === 'Row' && i >= index) || (modelType === 'Column' && j >= index)) {
                        this.parent.notify(refreshImagePosition, {
                            rowIdx: i, colIdx: j, sheetIdx: sheetIdx, type: modelType, count: count, status: 'delete'
                        });
                    }
                }
            }
        }
    }
}

/**
 * Represents Data Validation support for Spreadsheet.
 */
class DataValidation {
    /**
     * Constructor for the Spreadsheet Data Validation module.
     *
     * @param {Spreadsheet} parent - Constructor for the Spreadsheet Data Validation module.
     */
    constructor(parent) {
        this.divElements = [];
        this.spanElements = [];
        this.inputElements = [];
        this.checkBoxElements = [];
        this.numericTextBoxElements = [];
        this.dropDownListElements = [];
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * To destroy the Data Validation module.
     *
     * @returns {void}
     */
    destroy() {
        this.removeEventListener();
        let validationArgs = {};
        if (!this.parent.isDestroyed && !this.parent.refreshing) {
            const activeCellIndex = getCellIndexes(this.parent.getActiveSheet().activeCell);
            const activeCell = this.parent.getCell(activeCellIndex[0], activeCellIndex[1]);
            if (activeCell) {
                validationArgs = { rowIdx: activeCellIndex[0], colIdx: activeCellIndex[1], td: activeCell, isRefresh: true };
            }
        }
        this.removeListDropdownHandler(this.parent.element.querySelector('.e-validation-list'), validationArgs);
        const dataValPopup = select('#' + this.parent.element.id + '_datavalidation-popup');
        if (dataValPopup) {
            dataValPopup.remove();
        }
        this.typeData = [];
        this.operatorData = [];
        if (this.dataList) {
            this.dataList = null;
        }
        if (this.formObj) {
            this.formObj.destroy();
            this.formObj = null;
        }
        this.parent = null;
    }
    addEventListener() {
        if (Browser.isDevice && Browser.info.name === 'safari' && (Browser.isIos || Browser.isIos7)) {
            EventHandler.add(this.parent.element, 'touchend', this.listOpen, this);
        }
        else {
            EventHandler.add(this.parent.element, 'dblclick', this.listOpen, this);
        }
        this.parent.on(initiateDataValidation, this.initiateDataValidationHandler, this);
        this.parent.on(invalidData, this.invalidDataHandler, this);
        this.parent.on(isValidation, this.isValidCellHandler, this);
        this.parent.on(activeCellChanged, this.listHandler, this);
        this.parent.on(keyUp, this.keyUpHandler, this);
        this.parent.on(removeDataValidation, this.removeValidationHandler, this);
        this.parent.on(updateHighlight, this.updateHighlightHandler, this);
        this.parent.on(rowHeightChanged, this.listValidationHeightHandler, this);
        this.parent.on(addListValidationDropdown, this.addListValidationDropdownHandler, this);
    }
    removeEventListener() {
        if (Browser.isDevice && Browser.info.name === 'safari' && (Browser.isIos || Browser.isIos7)) {
            EventHandler.remove(this.parent.element, 'touchend', this.listOpen);
        }
        else {
            EventHandler.remove(this.parent.element, 'dblclick', this.listOpen);
        }
        if (!this.parent.isDestroyed) {
            this.parent.off(initiateDataValidation, this.initiateDataValidationHandler);
            this.parent.off(invalidData, this.invalidDataHandler);
            this.parent.off(isValidation, this.isValidCellHandler);
            this.parent.off(activeCellChanged, this.listHandler);
            this.parent.off(keyUp, this.keyUpHandler);
            this.parent.off(removeDataValidation, this.removeValidationHandler);
            this.parent.off(updateHighlight, this.updateHighlightHandler);
            this.parent.off(rowHeightChanged, this.listValidationHeightHandler);
            this.parent.off(addListValidationDropdown, this.addListValidationDropdownHandler);
        }
    }
    removeValidationHandler(eventArgs) {
        let sheet;
        let range;
        const args = { cancel: false, isColSelected: eventArgs.isCol };
        if (eventArgs.range && eventArgs.range.includes('!')) {
            range = eventArgs.range;
            sheet = getSheet(this.parent, getSheetIndex(this.parent, range.substring(0, range.lastIndexOf('!'))));
            if (!sheet) {
                return;
            }
        }
        else {
            sheet = this.parent.getActiveSheet();
            range = sheet.name + '!';
            if (eventArgs.range) {
                range += eventArgs.range;
            }
            else {
                const rangeArgs = this.getRange(sheet.selectedRange);
                range += rangeArgs.range;
                args.isColSelected = rangeArgs.isColSelected;
            }
        }
        args.range = range;
        if (eventArgs.isAction) {
            this.parent.notify(beginAction, { eventArgs: args, action: 'removeValidation' });
        }
        if (!args.cancel) {
            this.parent.notify(cellValidation, { range: range, isRemoveValidation: true });
            if (eventArgs.isAction) {
                delete args.cancel;
                this.parent.notify(completeAction, { eventArgs: args, action: 'removeValidation' });
            }
        }
    }
    updateNoteIndicator(td, rowIndex, columnIndex) {
        const noteIndicator = td.querySelector('.e-addNoteIndicator');
        if (noteIndicator) {
            remove(noteIndicator);
            this.parent.notify(createNoteIndicator, { targetElement: td, rowIndex: rowIndex, columnIndex: columnIndex, skipEvent: true });
        }
    }
    keyUpHandler(e) {
        const target = e.target;
        const dlgEle = this.parent.element.querySelector('.e-datavalidation-dlg');
        if (closest(target, '.e-values') && dlgEle && e.keyCode !== 13) {
            const valuesCont = dlgEle.querySelector('.e-values');
            const errorEle = valuesCont.querySelector('.e-dlg-error');
            const footerCont = dlgEle.querySelector('.e-footer-content');
            const primaryBut = footerCont.querySelector('.e-primary');
            if (primaryBut.hasAttribute('disabled')) {
                primaryBut.removeAttribute('disabled');
            }
            if (errorEle) {
                valuesCont.removeChild(errorEle);
            }
        }
    }
    listOpen(e) {
        const target = e.target;
        if (this.listObj && target.classList.contains('e-cell') && target.querySelector('.e-validation-list') && this.parent.isEdit) {
            this.listObj.showPopup();
        }
    }
    invalidDataHandler(args) {
        const eventArgs = { range: '', cancel: false };
        let actionArgs;
        const action = args.isRemoveHighlight ? removeHighlight : addHighlight;
        if (!args.isPublic) {
            actionArgs = { eventArgs: eventArgs, action: action };
            this.parent.notify(beginAction, actionArgs);
            if (eventArgs.cancel) {
                return;
            }
        }
        this.parent.notify(action, { range: eventArgs.range, isAction: true });
        if (!args.isPublic) {
            actionArgs.preventAction = true;
            this.parent.notify(completeAction, actionArgs);
        }
    }
    listHandler() {
        const sheet = this.parent.getActiveSheet();
        const indexes = getCellIndexes(sheet.activeCell);
        const cell = getCell(indexes[0], indexes[1], sheet);
        const tdEle = this.parent.getCell(indexes[0], indexes[1]);
        if (!tdEle) {
            return;
        }
        this.removeListDropdownHandler(this.parent.element.getElementsByClassName('e-validation-list')[0]);
        const validation = (cell && cell.validation) || (sheet.columns && sheet.columns[indexes[1]] &&
            sheet.columns[indexes[1]].validation);
        if (validation && validation.type === 'List') {
            if (validation.address && !isInMultipleRange(validation.address, indexes[0], indexes[1])) {
                return;
            }
            this.addListValidationDropdownHandler({ cell, validation, td: tdEle, rowIdx: indexes[0], colIdx: indexes[1] });
        }
        if (cell && cell.validation) {
            cell.validation = validation;
        }
    }
    removeListDropdownHandler(listEle, validationArgs) {
        if (listEle) {
            if (this.listObj) {
                this.listObj.destroy();
            }
            remove(listEle);
            if (!validationArgs) {
                if (!isNullOrUndefined(this.parent.selectionModule.previousActiveCell)) {
                    const pervActiveCellIdx = getCellIndexes(this.parent.selectionModule.previousActiveCell);
                    const pervActiveCellEle = this.parent.getCell(pervActiveCellIdx[0], pervActiveCellIdx[1]);
                    if (pervActiveCellEle) {
                        this.updateNoteIndicator(pervActiveCellEle, pervActiveCellIdx[0], pervActiveCellIdx[1]);
                    }
                }
            }
            else if (validationArgs.isRefresh) {
                this.updateNoteIndicator(validationArgs.td, validationArgs.rowIdx, validationArgs.colIdx);
            }
        }
    }
    addListValidationDropdownHandler(args) {
        if (args.updatePosition) {
            this.updateTopPosition({ ddlCont: args.ddlCont, rowIdx: args.rowIdx, colIdx: args.colIdx });
            return;
        }
        let inCellDropDown = args.validation.inCellDropDown;
        if (args.isRefresh) {
            if (!args.td) {
                args.td = this.parent.getCell(args.rowIdx, args.colIdx);
                if (!args.td) {
                    return;
                }
            }
            this.removeListDropdownHandler(args.td.querySelector('.e-validation-list'), args);
            if (args.validation.type !== 'List') {
                return;
            }
            if (isNullOrUndefined(inCellDropDown)) {
                inCellDropDown = true;
            }
        }
        else {
            if (isNullOrUndefined(args.validation.ignoreBlank)) {
                args.validation.ignoreBlank = true;
            }
            if (isNullOrUndefined(inCellDropDown)) {
                inCellDropDown = args.validation.inCellDropDown = true;
            }
        }
        if (inCellDropDown) {
            const ddlCont = this.parent.createElement('div', { className: 'e-validation-list' });
            const ddlEle = this.parent.createElement('input', { id: this.parent.element.id + 'listValid' });
            ddlCont.appendChild(ddlEle);
            let isDevice;
            const tdEle = args.td;
            const parent = tdEle.getElementsByClassName('e-wrap-content')[0] || tdEle;
            this.updateTopPosition({ ddlCont: ddlCont, rowIdx: args.rowIdx, colIdx: args.colIdx });
            this.listValidationHeightHandler({ ddlCont: ddlCont });
            parent.insertBefore(ddlCont, parent.firstChild);
            let validationVal = args.validation.value1;
            if ((!args.cell || !args.cell.validation) && validationVal.startsWith('=')) {
                validationVal = getUpdatedFormula([args.rowIdx, args.colIdx, args.rowIdx, args.colIdx], [0, args.colIdx, 0, args.colIdx], this.parent.getActiveSheet(), this.parent, { formula: validationVal });
            }
            const dataSource = this.getListDataSource(validationVal);
            this.listObj = new DropDownList({
                index: this.setDropDownListIndex(dataSource, args.cell),
                dataSource: dataSource,
                fields: { text: 'text', value: 'id' },
                width: '0px',
                popupHeight: '200px',
                change: () => this.listValueChange(this.listObj.text),
                beforeOpen: () => {
                    isDevice = window.browserDetails.isDevice;
                    if (isDevice) {
                        window.browserDetails.isDevice = false;
                    }
                },
                open: (args) => {
                    args.popup.offsetX = this.listObj.enableRtl ? 3 : -tdEle.offsetWidth + (this.parent.enableRtl ? 4 : 24);
                    args.popup.offsetY = -(tdEle.querySelector('.e-control-wrapper.e-ddl').offsetHeight - 18);
                    args.popup.element.style.width = tdEle.offsetWidth - 1 + 'px';
                    if (isDevice) {
                        window.browserDetails.isDevice = true;
                    }
                },
                close: (args) => {
                    if (args.event && (args.event.keyCode === 13 ||
                        (args.event.altKey && args.event.keyCode === 38))) {
                        args.event.preventDefault();
                        args.event.stopPropagation();
                    }
                    focus(this.parent.element);
                }
            });
            this.listObj.appendTo(ddlEle);
            this.updateNoteIndicator(tdEle, args.rowIdx, args.colIdx);
        }
    }
    updateTopPosition(args) {
        const sheet = this.parent.getActiveSheet();
        const cell = getCell(args.rowIdx, args.colIdx, sheet);
        if (cell && cell.style && cell.style.fontSize && parseFloat(cell.style.fontSize) > 11) {
            args.ddlCont.style.top = `${parseFloat(cell.style.fontSize) - 11}pt`;
        }
        else if (args.ddlCont.style.top) {
            args.ddlCont.style.top = '';
        }
    }
    listValidationHeightHandler(args) {
        const sheet = this.parent.getActiveSheet();
        const indexes = getCellIndexes(sheet.activeCell);
        const cell = getCell(indexes[0], indexes[1], sheet);
        const validation = (cell && cell.validation) || (sheet.columns && sheet.columns[indexes[1]] &&
            sheet.columns[indexes[1]].validation);
        if (validation && validation.type === 'List') {
            if (validation.inCellDropDown) {
                const tdRowHeight = getRowHeight(sheet, indexes[0], true) - getBorderHeight(indexes[0], indexes[1], sheet);
                if (tdRowHeight <= 18) {
                    const ddlCont = args.ddlCont || this.parent.element.querySelector('.e-validation-list');
                    if (ddlCont) {
                        ddlCont.style.height = tdRowHeight + 'px';
                    }
                }
                else if (!args.ddlCont) {
                    const ddlCont = this.parent.element.querySelector('.e-validation-list');
                    if (ddlCont) {
                        ddlCont.style.removeProperty('height');
                    }
                }
            }
        }
    }
    setDropDownListIndex(dataSource, cell) {
        if (cell && !isNullOrUndefined(cell.value)) {
            const cellVal = cell.value.toString();
            const isNumVal = isNumber(cellVal);
            const numObj = isNumVal && getNumericObject(this.parent.locale);
            for (let idx = 0, len = dataSource.length; idx < len; idx++) {
                if (dataSource[idx].text === cellVal || (isNumVal &&
                    this.parseValidationValue(dataSource[idx].text, numObj).toString() === cellVal)) {
                    return idx;
                }
            }
        }
        return null;
    }
    getListDataSource(validationVal) {
        const data = [];
        let count = 0;
        const definedNames = this.parent.definedNames;
        let value = validationVal;
        const isRange = value.startsWith('=');
        if (definedNames.length > 0 && isRange) {
            const listValue = value.split('=')[1];
            for (let idx = 0, len = definedNames.length; idx < len; idx++) {
                if (definedNames[idx].name === listValue) {
                    let definedNameRange = definedNames[idx].refersTo;
                    while (definedNameRange.includes('\'')) {
                        definedNameRange = definedNameRange.replace('\'', '');
                    }
                    value = definedNameRange;
                }
            }
        }
        if (isRange) {
            let sheet;
            let address;
            let sheetName;
            const lastIndex = value.lastIndexOf('!');
            if (lastIndex > -1) {
                sheetName = value.substring(1, lastIndex);
                address = value.substring(lastIndex + 1);
                if (sheetName.startsWith('\'') && sheetName.endsWith('\'')) {
                    sheetName = sheetName.substring(1, sheetName.length - 1);
                }
                sheet = getSheet(this.parent, getSheetIndex(this.parent, sheetName));
            }
            else {
                sheet = this.parent.getActiveSheet();
                address = value.substring(1);
            }
            const activeSheet = this.parent.getActiveSheet();
            if (sheet) {
                if (sheet.name !== activeSheet.name) {
                    let isNotLoaded;
                    const selectedRange = getRangeIndexes(activeSheet.selectedRange);
                    sheet.ranges.forEach((range) => {
                        if (!range.info || !range.info.loadedRange || !range.info.loadedRange.length) {
                            isNotLoaded = true;
                            return;
                        }
                    });
                    if (isNotLoaded) {
                        this.parent.showSpinner();
                        getData(this.parent, `${sheet.name}!${address}`).then(() => {
                            this.parent.hideSpinner();
                            if (activeSheet.name === this.parent.getActiveSheet().name) {
                                const curRange = getRangeIndexes(this.parent.getActiveSheet().selectedRange);
                                if (curRange[0] === selectedRange[0] && curRange[1] === selectedRange[1]) {
                                    const dataSource = this.getListDataSource(validationVal);
                                    this.listObj.dataSource = dataSource;
                                    const cell = getCell(curRange[0], curRange[1], activeSheet);
                                    this.listObj.index = this.setDropDownListIndex(dataSource, cell);
                                    this.listObj.dataBind();
                                }
                            }
                        });
                    }
                }
                let indexes;
                const range = address.split(':');
                if (range[0] && range[1] && ((range[0].match(/[a-z]+$/ig) && range[1].match(/[a-z]+$/ig)) ||
                    (range[0].match(/^[0-9]/g) && range[1].match(/^[0-9]/g)))) {
                    const addressInfo = this.parent.getIndexes(address);
                    if (addressInfo.isCol) {
                        indexes = [0, addressInfo.startIdx, sheet.usedRange.rowIndex, addressInfo.startIdx];
                    }
                    else {
                        indexes = [addressInfo.startIdx, 0, addressInfo.startIdx, sheet.usedRange.colIndex];
                    }
                }
                else {
                    indexes = getRangeIndexes(address);
                }
                let cell;
                for (let rowIdx = indexes[0]; rowIdx <= indexes[2]; rowIdx++) {
                    if (!sheet.rows[rowIdx]) {
                        setRow(sheet, rowIdx, {});
                    }
                    for (let colIdx = indexes[1]; colIdx <= indexes[3]; colIdx++) {
                        if (!sheet.rows[rowIdx].cells) {
                            setCell(rowIdx, colIdx, sheet, {});
                        }
                        count += 1;
                        cell = sheet.rows[rowIdx].cells[colIdx];
                        const formattedText = this.parent.getDisplayText(cell) || '';
                        data.push({ text: formattedText, id: 'list-' + count });
                    }
                }
            }
        }
        else {
            const listValues = this.getListOfValues(value);
            for (let idx = 0; idx < listValues.length; idx++) {
                count += 1;
                data.push({ text: listValues[idx], id: 'list-' + count });
            }
        }
        return data;
    }
    listValueChange(value) {
        const sheet = this.parent.getActiveSheet();
        const cellIdx = getIndexesFromAddress(sheet.activeCell);
        const cellObj = Object.assign({}, getCell(cellIdx[0], cellIdx[1], sheet));
        if (sheet.isProtected && isLocked(cellObj, getColumn(sheet, cellIdx[1]))) {
            this.parent.notify(editAlert, null);
        }
        else if (isReadOnly(cellObj, getColumn(sheet, cellIdx[1]), getRow(sheet, cellIdx[0]))) {
            this.parent.notify(readonlyAlert, null);
        }
        else {
            if (this.parent.isEdit) {
                this.parent.closeEdit();
            }
            const args = { value: value, oldValue: cellObj.value,
                address: sheet.name + '!' + sheet.activeCell, cancel: false };
            this.parent.notify(beginAction, { action: 'cellSave', eventArgs: args });
            if (args.cancel) {
                return;
            }
            const cell = { value: value, formula: '' };
            if (cellObj.format && isCustomDateTime(cellObj.format) && !isNumber(value)) {
                const formatArgs = { formattedText: value, value: value, format: 'General',
                    cell: { value: value, format: 'General' }, isEdit: true };
                this.parent.notify(getFormattedCellObject, formatArgs);
                if (formatArgs.format !== 'General' && ['Currency', 'Percentage'].indexOf(getTypeFromFormat(formatArgs.format)) > -1) {
                    cell.format = formatArgs.format;
                    cell.value = formatArgs.value;
                }
            }
            const cancelled = updateCell(this.parent, sheet, { cell: cell, rowIdx: cellIdx[0], colIdx: cellIdx[1], valChange: true, lastCell: true, checkCF: true,
                uiRefresh: true });
            if (!cancelled) {
                const cell = getCell(cellIdx[0], cellIdx[1], sheet, false, true);
                delete cell.formula;
                this.parent.notify(formulaBarOperation, { action: 'refreshFormulabar', cell: cell });
                this.parent.notify(refreshRibbonIcons, null);
                this.parent.notify(completeAction, { action: 'cellSave', eventArgs: { value: value, oldValue: cellObj.value, address: sheet.name + '!' + sheet.activeCell } });
            }
        }
    }
    getRange(range) {
        const indexes = getRangeIndexes(range);
        const sheet = this.parent.getActiveSheet();
        const maxRowCount = sheet.rowCount;
        let isColSelected;
        if (indexes[2] === maxRowCount - 1 && indexes[0] === 0) {
            range = range.replace(/[0-9]/g, '');
            isColSelected = true;
        }
        return { range: range, isColSelected: isColSelected };
    }
    initiateDataValidationHandler() {
        const sheet = this.parent.getActiveSheet();
        const indexes = getRangeIndexes(sheet.selectedRange);
        let rowIdx = indexes[0];
        let colIdx = indexes[1];
        let rowIterateCondition;
        let updateRowIdx;
        if (indexes[2] >= indexes[0]) {
            rowIterateCondition = () => rowIdx <= indexes[2];
            updateRowIdx = () => { rowIdx++; };
        }
        else {
            rowIterateCondition = () => rowIdx >= indexes[2];
            updateRowIdx = () => { rowIdx--; };
        }
        let colIterateCondition;
        let updateColIdx;
        if (indexes[3] >= indexes[1]) {
            colIterateCondition = () => colIdx <= indexes[3];
            updateColIdx = () => { colIdx++; };
        }
        else {
            colIterateCondition = () => colIdx >= indexes[3];
            updateColIdx = () => { colIdx--; };
        }
        let cell;
        let moreValidation;
        let cellsWithoutValidation;
        let validation;
        let curValidation;
        let isVal1Formula;
        let isVal2Formula;
        const updateFormula = (curIdx, prevIdx) => {
            if (isVal1Formula) {
                const updatedFormula = getUpdatedFormula(curIdx, prevIdx, sheet, this.parent, { formula: validation.value1 });
                if (!updatedFormula.includes('#REF!')) {
                    validation.value1 = updatedFormula;
                }
            }
            if (isVal2Formula) {
                const updatedFormula = getUpdatedFormula(curIdx, prevIdx, sheet, this.parent, { formula: validation.value2 });
                if (!updatedFormula.includes('#REF!')) {
                    validation.value2 = updatedFormula;
                }
            }
        };
        for (rowIdx; rowIterateCondition(); updateRowIdx()) {
            for (colIdx; colIterateCondition(); updateColIdx()) {
                cell = getCell(rowIdx, colIdx, sheet, false, true);
                curValidation = cell.validation || (checkColumnValidation(sheet.columns[colIdx], rowIdx, colIdx) &&
                    sheet.columns[colIdx].validation);
                if (curValidation) {
                    if (validation) {
                        if (curValidation.type !== validation.type || curValidation.operator !== validation.operator ||
                            ((!isVal1Formula || !checkIsFormula(curValidation.value1)) && curValidation.value1 !== validation.value1) ||
                            ((!isVal2Formula || !checkIsFormula(curValidation.value2)) && curValidation.value2 !== validation.value2)) {
                            moreValidation = true;
                            break;
                        }
                    }
                    else {
                        validation = Object.assign({}, curValidation);
                        isVal1Formula = checkIsFormula(validation.value1);
                        isVal2Formula = checkIsFormula(validation.value2);
                        if (!cell.validation) {
                            updateFormula([rowIdx, colIdx, rowIdx, colIdx], [0, colIdx, 0, colIdx]);
                        }
                        const actIdxes = getRangeIndexes(sheet.activeCell);
                        if (rowIdx !== actIdxes[0] || colIdx !== actIdxes[1]) {
                            updateFormula(actIdxes, [rowIdx, colIdx, rowIdx, colIdx]);
                        }
                    }
                }
                else {
                    cellsWithoutValidation = true;
                }
            }
            colIdx = indexes[1];
        }
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        const validationDialogHandler = (validation) => {
            if (!this.parent.element.querySelector('.e-datavalidation-dlg')) {
                const range = this.getRange(sheet.selectedRange).range;
                dialogInst.show({
                    width: 375, showCloseIcon: true, isModal: true, cssClass: 'e-datavalidation-dlg',
                    header: l10n.getConstant('DataValidation'),
                    beforeOpen: (args) => {
                        const dlgArgs = { dialogName: 'ValidationDialog', element: args.element,
                            target: args.target, cancel: args.cancel };
                        this.parent.trigger('dialogBeforeOpen', dlgArgs);
                        if (dlgArgs.cancel) {
                            args.cancel = true;
                        }
                        else {
                            dialogInst.dialogInstance.content = this.dataValidationContent(l10n, range, validation);
                            dialogInst.dialogInstance.dataBind();
                            focus(this.parent.element);
                        }
                    },
                    beforeClose: this.dialogBeforeClose.bind(this),
                    buttons: [{
                            buttonModel: {
                                content: l10n.getConstant('ClearAll'),
                                cssClass: 'e-btn e-clearall-btn e-flat'
                            },
                            click: () => {
                                dialogInst.dialogInstance.content = this.dataValidationContent(l10n, range);
                                dialogInst.dialogInstance.dataBind();
                            }
                        },
                        {
                            buttonModel: { content: l10n.getConstant('Apply'), isPrimary: true },
                            click: () => {
                                this.dlgClickHandler(dialogInst);
                            }
                        }]
                });
            }
        };
        if (moreValidation || (validation && cellsWithoutValidation)) {
            let dialogName;
            const btns = [{
                    buttonModel: { isPrimary: true, cssClass: 'e-btn-goto-ok' },
                    click: () => {
                        dialogInst.hide(true);
                        validationDialogHandler();
                    }
                }];
            if (moreValidation) {
                dialogName = 'MoreValidation';
                btns[0].buttonModel.content = l10n.getConstant('Ok');
            }
            else {
                dialogName = 'ExtendValidation';
                btns[0].buttonModel.content = l10n.getConstant('No');
                btns.splice(0, 0, {
                    buttonModel: {
                        content: l10n.getConstant('Yes'), isPrimary: true, cssClass: 'e-btn-goto-ok'
                    },
                    click: () => {
                        dialogInst.hide(true);
                        validationDialogHandler(validation);
                    }
                });
            }
            const dialogContent = l10n.getConstant(dialogName);
            const dlg = {
                width: 350, isModal: true, showCloseIcon: true, cssClass: 'e-goto-dlg', header: l10n.getConstant('Spreadsheet'),
                content: dialogContent,
                beforeOpen: (args) => {
                    const dlgArgs = { dialogName: dialogName, element: args.element, target: args.target,
                        cancel: args.cancel, content: dialogContent };
                    this.parent.trigger('dialogBeforeOpen', dlgArgs);
                    if (dlgArgs.cancel) {
                        args.cancel = true;
                    }
                    else {
                        if (dlgArgs.content !== dialogContent) {
                            dialogInst.dialogInstance.content = dlgArgs.content;
                            dialogInst.dialogInstance.dataBind();
                        }
                        focus(this.parent.element);
                    }
                },
                buttons: btns
            };
            dialogInst.show(dlg);
        }
        else {
            validationDialogHandler(validation);
        }
    }
    dataValidationContent(l10n, range, validation) {
        let value1;
        let value2;
        let type;
        const isNew = !validation;
        let operator;
        let ignoreBlank;
        if (isNew) {
            value1 = value2 = '0';
            ignoreBlank = true;
        }
        else {
            const val1 = validation.value1;
            const val2 = validation.value2;
            type = validation.type;
            operator = validation.operator;
            ignoreBlank = validation.ignoreBlank === false ? false : true;
            if (type === 'Date' || type === 'Time') {
                const getFormattedDate = (val) => {
                    if (isNumber(val)) {
                        const args = { cell: { value: val }, type: type.toLowerCase(),
                            value: val };
                        this.parent.notify(getFormattedBarText, args);
                        return args.value;
                    }
                    return val;
                };
                value1 = getFormattedDate(val1);
                value2 = getFormattedDate(val2);
            }
            else {
                const getFormattedValue = (val) => {
                    if (isNumber(val)) {
                        val = val.toString();
                        const localeObj = getNumericObject(this.parent.locale);
                        if (localeObj.decimal !== '.' && val.includes('.')) {
                            val = val.replace('.', localeObj.decimal);
                        }
                    }
                    return val;
                };
                value1 = getFormattedValue(val1);
                value2 = getFormattedValue(val2);
            }
        }
        const dlgContent = this.parent.createElement('div', { className: 'e-validation-dlg' });
        const cellRangeCont = this.parent.createElement('div', { className: 'e-cellrange' });
        const allowDataCont = this.parent.createElement('div', { className: 'e-allowdata' });
        const valuesCont = this.parent.createElement('div', { className: 'e-values' });
        const ignoreBlankCont = this.parent.createElement('div', { className: 'e-ignoreblank' });
        this.divElements.push(dlgContent);
        this.divElements.push(cellRangeCont);
        this.divElements.push(allowDataCont);
        this.divElements.push(valuesCont);
        this.divElements.push(ignoreBlankCont);
        dlgContent.appendChild(cellRangeCont);
        dlgContent.appendChild(allowDataCont);
        dlgContent.appendChild(valuesCont);
        dlgContent.appendChild(ignoreBlankCont);
        const cellRangeText = this.parent.createElement('span', { className: 'e-header' });
        cellRangeText.innerText = l10n.getConstant('CellRange');
        const cellRangeEle = this.parent.createElement('input', {
            className: 'e-input',
            attrs: { value: range, 'aria-label': l10n.getConstant('CellRange') }
        });
        cellRangeCont.appendChild(cellRangeText);
        cellRangeCont.appendChild(cellRangeEle);
        const allowCont = this.parent.createElement('div', { className: 'e-allow' });
        const dataCont = this.parent.createElement('div', { className: 'e-data' });
        allowDataCont.appendChild(allowCont);
        allowDataCont.appendChild(dataCont);
        const allowText = this.parent.createElement('span', { className: 'e-header' });
        allowText.innerText = l10n.getConstant('Allow');
        this.typeData = [
            { text: l10n.getConstant('WholeNumber'), id: 'type-1' },
            { text: l10n.getConstant('Decimal'), id: 'type-2' },
            { text: l10n.getConstant('Date'), id: 'type-3' },
            { text: l10n.getConstant('Time'), id: 'type-4' },
            { text: l10n.getConstant('TextLength'), id: 'type-5' },
            { text: l10n.getConstant('List'), id: 'type-6' },
            { text: l10n.getConstant('Custom'), id: 'type-7' }
        ];
        this.operatorData = [
            { text: l10n.getConstant('Between'), id: 'operator-1' },
            { text: l10n.getConstant('NotBetween'), id: 'operator-2' },
            { text: l10n.getConstant('EqualTo'), id: 'operator-3' },
            { text: l10n.getConstant('NotEqualTo'), id: 'operator-4' },
            { text: l10n.getConstant('GreaterThan'), id: 'operator-5' },
            { text: l10n.getConstant('LessThan'), id: 'operator-6' },
            { text: l10n.getConstant('GreaterThanOrEqualTo'), id: 'operator-7' },
            { text: l10n.getConstant('LessThanOrEqualTo'), id: 'operator-8' }
        ];
        const allowSelectEle = this.parent.createElement('input', { className: 'e-select' });
        this.spanElements.push(cellRangeText);
        this.inputElements.push(cellRangeEle);
        this.divElements.push(allowCont);
        this.divElements.push(dataCont);
        this.spanElements.push(allowText);
        this.inputElements.push(allowSelectEle);
        let allowIdx = 0;
        if (!isNew) {
            if (type) {
                type = this.formattedType(type);
            }
            for (let idx = 0; idx < this.typeData.length; idx++) {
                if (type === this.formattedType(this.typeData[idx].text)) {
                    allowIdx = idx;
                    break;
                }
            }
        }
        if (isNew || (type !== 'List' && type !== 'Custom')) {
            let dataIdx = 0;
            const dataText = this.parent.createElement('span', { className: 'e-header' });
            dataText.innerText = l10n.getConstant('Data');
            const dataSelectEle = this.parent.createElement('input', { className: 'e-select' });
            if (!isNew) {
                for (let idx = 0; idx < this.operatorData.length; idx++) {
                    if (operator === this.formattedValue(this.operatorData[idx].text)) {
                        dataIdx = idx;
                        break;
                    }
                }
            }
            dataCont.appendChild(dataText);
            dataCont.appendChild(dataSelectEle);
            this.spanElements.push(dataText);
            this.inputElements.push(dataSelectEle);
            this.dataList = new DropDownList({
                dataSource: this.operatorData,
                index: dataIdx,
                popupHeight: '200px',
                change: this.userInput.bind(this)
            });
            this.dropDownListElements.push(this.dataList);
            this.dataList.appendTo(dataSelectEle);
        }
        else if (type !== 'Custom') {
            const ignoreBlankEle = this.parent.createElement('input', { className: 'e-checkbox' });
            dataCont.appendChild(ignoreBlankEle);
            const ignoreBlankObj = new CheckBox({ label: l10n.getConstant('InCellDropDown'), checked: validation.inCellDropDown === false ? false : true });
            this.checkBoxElements.push(ignoreBlankObj);
            ignoreBlankObj.appendTo(ignoreBlankEle);
            this.inputElements.push(ignoreBlankEle);
        }
        allowCont.appendChild(allowText);
        allowCont.appendChild(allowSelectEle);
        this.typeList = new DropDownList({
            dataSource: this.typeData,
            index: allowIdx,
            popupHeight: '200px',
            change: this.userInput.bind(this)
        });
        this.dropDownListElements.push(this.typeList);
        this.typeList.appendTo(allowSelectEle);
        const createContEle = (labelKey, value) => {
            const valueText = this.parent.createElement('span', { className: 'e-header' });
            valueText.innerText = labelKey;
            const valueEle = this.parent.createElement('input', { className: 'e-input', attrs: { value } });
            valuesCont.appendChild(valueText);
            valuesCont.appendChild(valueEle);
            this.spanElements.push(valueText);
            this.inputElements.push(valueEle);
        };
        if (isNew || ((this.typeList.value !== l10n.getConstant('List') && this.typeList.value !== l10n.getConstant('Custom')) &&
            (this.dataList.value === l10n.getConstant('Between') || this.dataList.value === l10n.getConstant('NotBetween')))) {
            const minimumCont = this.parent.createElement('div', { className: 'e-minimum' });
            const maximumCont = this.parent.createElement('div', { className: 'e-maximum' });
            valuesCont.appendChild(minimumCont);
            valuesCont.appendChild(maximumCont);
            const minimumText = this.parent.createElement('span', { className: 'e-header' });
            minimumText.innerText = l10n.getConstant('Minimum');
            const maximumText = this.parent.createElement('span', { className: 'e-header' });
            maximumText.innerText = l10n.getConstant('Maximum');
            const minimumInp = this.parent.createElement('input', {
                id: 'minvalue',
                className: 'e-input', attrs: { value: value1, 'aria-label': l10n.getConstant('Minimum') }
            });
            const maximumInp = this.parent.createElement('input', {
                id: 'maxvalue',
                className: 'e-input', attrs: { value: value2, 'aria-label': l10n.getConstant('Maximum') }
            });
            minimumCont.appendChild(minimumText);
            minimumCont.appendChild(minimumInp);
            maximumCont.appendChild(maximumText);
            maximumCont.appendChild(maximumInp);
            this.divElements.push(minimumCont);
            this.divElements.push(maximumCont);
            this.spanElements.push(minimumText);
            this.spanElements.push(maximumText);
            this.inputElements.push(minimumInp);
            this.inputElements.push(maximumInp);
            const numericMin = new NumericTextBox({
                value: 0
            });
            this.numericTextBoxElements.push(numericMin);
            numericMin.appendTo('#minvalue');
            const numericMax = new NumericTextBox({
                value: 0
            });
            this.numericTextBoxElements.push(numericMax);
            numericMax.appendTo('#maxvalue');
        }
        else if (!isNew && type === 'List') {
            createContEle(l10n.getConstant('Sources'), value1);
        }
        else if (!isNew && type === 'Custom') {
            createContEle(l10n.getConstant('Formula'), value1);
        }
        else {
            createContEle(l10n.getConstant('Value'), value1);
        }
        const ignoreBlankEle = this.parent.createElement('input', { className: 'e-checkbox' });
        ignoreBlankCont.appendChild(ignoreBlankEle);
        const ignoreBlankObj = new CheckBox({ label: l10n.getConstant('IgnoreBlank'), checked: ignoreBlank });
        this.checkBoxElements.push(ignoreBlankObj);
        ignoreBlankObj.appendTo(ignoreBlankEle);
        this.inputElements.push(ignoreBlankEle);
        return dlgContent;
    }
    dialogBeforeClose() {
        this.checkBoxElements.forEach((checkbox) => {
            if (checkbox && checkbox.element) {
                checkbox.destroy();
                checkbox.element.remove();
            }
        });
        this.checkBoxElements = [];
        this.numericTextBoxElements.forEach((numericTextBox) => {
            if (numericTextBox && numericTextBox.element) {
                numericTextBox.destroy();
                numericTextBox.element.remove();
            }
        });
        this.numericTextBoxElements = [];
        this.dropDownListElements.forEach((dropDownList) => {
            if (dropDownList && dropDownList.element) {
                dropDownList.destroy();
                dropDownList.element.remove();
            }
        });
        this.dropDownListElements = [];
        removeElements(this.spanElements);
        this.spanElements = [];
        removeElements(this.inputElements);
        this.inputElements = [];
        removeElements(this.divElements);
        this.divElements = [];
    }
    userInput() {
        const listObj = this.typeList;
        const listObj1 = this.dataList;
        const dlgEle = this.parent.element.querySelector('.e-datavalidation-dlg');
        const dlgCont = dlgEle.querySelector('.e-validation-dlg');
        const allowDataCont = dlgCont.querySelector('.e-allowdata');
        const valuesCont = dlgCont.querySelector('.e-values');
        const l10n = this.parent.serviceLocator.getService(locale);
        const dataCont = allowDataCont.querySelector('.e-data');
        const clearChildEle = (element) => {
            while (element.lastChild) {
                element.removeChild(element.lastChild);
            }
        };
        clearChildEle(valuesCont);
        if (listObj.value === l10n.getConstant('List')) {
            clearChildEle(dataCont);
            const cellDropDownEle = this.parent.createElement('input', { className: 'e-checkbox' });
            this.inputElements.push(cellDropDownEle);
            dataCont.appendChild(cellDropDownEle);
            const cellDropDownOhj = new CheckBox({ label: l10n.getConstant('InCellDropDown'), checked: true });
            this.checkBoxElements.push(cellDropDownOhj);
            cellDropDownOhj.appendTo(cellDropDownEle);
        }
        else if (listObj.value === l10n.getConstant('Custom')) {
            clearChildEle(dataCont);
        }
        else if (!dataCont.childElementCount || dataCont.getElementsByClassName('e-checkbox-wrapper')[0]) {
            clearChildEle(dataCont);
            const dataText = this.parent.createElement('span', { className: 'e-header' });
            dataText.innerText = l10n.getConstant('Data');
            const dataSelectEle = this.parent.createElement('input', { className: 'e-select' });
            this.spanElements.push(dataText);
            this.inputElements.push(dataSelectEle);
            dataCont.appendChild(dataText);
            dataCont.appendChild(dataSelectEle);
            listObj1.appendTo(dataSelectEle);
        }
        if ((listObj.value !== l10n.getConstant('List') && listObj.value !== l10n.getConstant('Custom')) && (listObj1.value === l10n.getConstant('Between') || listObj1.value === l10n.getConstant('NotBetween'))) {
            const minimumCont = this.parent.createElement('div', { className: 'e-minimum' });
            const maximumCont = this.parent.createElement('div', { className: 'e-maximum' });
            this.divElements.push(minimumCont);
            this.divElements.push(maximumCont);
            valuesCont.appendChild(minimumCont);
            valuesCont.appendChild(maximumCont);
            const minimumText = this.parent.createElement('span', { className: 'e-header' });
            minimumText.innerText = l10n.getConstant('Minimum');
            const maximumText = this.parent.createElement('span', { className: 'e-header' });
            maximumText.innerText = l10n.getConstant('Maximum');
            const minimumInp = this.parent.createElement('input', { id: 'min', className: 'e-input', attrs: { value: '0' } });
            const maximumInp = this.parent.createElement('input', { id: 'max', className: 'e-input', attrs: { value: '0' } });
            this.spanElements.push(minimumText);
            this.spanElements.push(maximumText);
            this.inputElements.push(minimumInp);
            this.inputElements.push(maximumInp);
            const numericMin = new NumericTextBox({
                value: 0
            });
            this.numericTextBoxElements.push(numericMin);
            numericMin.appendTo('min');
            const numericMax = new NumericTextBox({
                value: 0
            });
            this.numericTextBoxElements.push(numericMax);
            numericMax.appendTo('max');
            minimumCont.appendChild(minimumText);
            minimumCont.appendChild(minimumInp);
            maximumCont.appendChild(maximumText);
            maximumCont.appendChild(maximumInp);
        }
        else {
            const valueText = this.parent.createElement('span', { className: 'e-header' });
            valueText.innerText = listObj.value === l10n.getConstant('List') ? l10n.getConstant('Sources') :
                listObj.value === l10n.getConstant('Custom') ? l10n.getConstant('Formula') : l10n.getConstant('Value');
            const valueEle = listObj.value === l10n.getConstant('List') ? this.parent.createElement('input', {
                className: 'e-input',
                attrs: { placeholder: 'Enter value' }
            }) :
                this.parent.createElement('input', { className: 'e-input', attrs: { value: '0' } });
            this.spanElements.push(valueText);
            this.inputElements.push(valueEle);
            valuesCont.appendChild(valueText);
            valuesCont.appendChild(valueEle);
        }
    }
    dlgClickHandler(dialogInst) {
        const l10n = this.parent.serviceLocator.getService(locale);
        let errorMsg;
        const dlgEle = this.parent.element.querySelector('.e-datavalidation-dlg');
        const dlgFooter = dlgEle.querySelector('.e-footer-content');
        const dlgContEle = dlgEle.getElementsByClassName('e-dlg-content')[0].
            getElementsByClassName('e-validation-dlg')[0];
        const allowData = dlgContEle.getElementsByClassName('e-allowdata')[0];
        const allowEle = allowData.getElementsByClassName('e-allow')[0].getElementsByTagName('input')[0];
        const dataEle = allowData.getElementsByClassName('e-data')[0].getElementsByTagName('input')[0];
        const values = dlgContEle.getElementsByClassName('e-values')[0];
        const valueArr = [];
        valueArr[0] = values.getElementsByTagName('input')[0].value;
        valueArr[1] = values.getElementsByTagName('input')[1] ? values.getElementsByTagName('input')[1].value : '';
        const type = this.formattedType(allowEle.value);
        let isValid = true;
        const ignoreBlank = dlgContEle.querySelector('.e-ignoreblank .e-checkbox').checked;
        const inCellDropDown = allowData.querySelector('.e-data').querySelector('.e-checkbox-wrapper') ?
            allowData.querySelector('.e-data').querySelector('.e-checkbox-wrapper').querySelector('.e-check') ? true : false : null;
        const range = dlgContEle.querySelector('.e-cellrange').getElementsByTagName('input')[0].value;
        let operator;
        if (dataEle) {
            operator = this.formattedValue(dataEle.value);
        }
        const valArr = [];
        if (type === 'List') {
            if (valueArr[0] !== '') {
                valArr.push(valueArr[0]);
            }
            if (valueArr[0].startsWith('=')) {
                let address = valueArr[0].substring(1);
                const definedName = this.parent.definedNames.find((item) => item.name === address);
                if (definedName) {
                    address = definedName.refersTo.substring(1);
                }
                let isSheetNameValid;
                let sheetTokenIdx;
                if (address.includes('!')) {
                    sheetTokenIdx = address.lastIndexOf('!');
                    let sheetName = address.substring(0, sheetTokenIdx);
                    address = address.substring(sheetTokenIdx + 1);
                    if (sheetName.startsWith('\'') && sheetName.endsWith('\'')) {
                        sheetName = sheetName.substring(1, sheetName.length - 1);
                    }
                    isSheetNameValid = getSheetIndex(this.parent, sheetName) > -1;
                    if (!definedName) {
                        valArr[0] = '=' + sheetName + '!' + address;
                    }
                }
                else {
                    isSheetNameValid = true;
                }
                if (!address.includes(':') && isCellReference(address)) {
                    address = `${address}:${address}`;
                }
                let isSingleRowOrCol;
                if (isSheetNameValid) {
                    const cellRef = address.split(':');
                    if (cellRef.length === 2) {
                        isSingleRowOrCol = address.match(/[a-z]/gi) && cellRef[0].replace(/[0-9]/g, '') === cellRef[1].replace(/[0-9]/g, '')
                            || address.match(/\d/g) && cellRef[0].replace(/\D/g, '') === cellRef[1].replace(/\D/g, '');
                    }
                }
                isValid = isSingleRowOrCol;
                if (!isValid) {
                    errorMsg = !definedName && sheetTokenIdx === undefined && !address.includes(':') ?
                        l10n.getConstant('NamedRangeError') : l10n.getConstant('DialogError');
                }
            }
            else if (valueArr[0].length > 256) {
                isValid = false;
                errorMsg = l10n.getConstant('ListLengthError');
            }
        }
        else {
            const numObj = getNumericObject(this.parent.locale);
            if (type === 'Decimal' && numObj.decimal !== '.') {
                const isNotCulturedNumber = (val) => isNumber(val) && val.includes('.') &&
                    (numObj.group !== '.' || !parseThousandSeparator(val, this.parent.locale, numObj.group, numObj.decimal));
                if (isNotCulturedNumber(valueArr[0]) || isNotCulturedNumber(valueArr[1])) {
                    isValid = false;
                    errorMsg = l10n.getConstant('InvalidNumberError');
                }
            }
            parseLocaleNumber(valueArr, this.parent, numObj);
            if (valueArr[0] !== '') {
                valArr.push(valueArr[0]);
            }
            if (valueArr[1] !== '') {
                valArr.push(valueArr[1]);
            }
        }
        if (isValid) {
            const sheet = this.parent.getActiveSheet();
            const validDlg = this.isDialogValidator(valArr, type, operator);
            if (operator === 'Between' && validDlg.isValid && !isNaN(parseFloat(valArr[0])) && !isNaN(parseFloat(valArr[1])) &&
                parseFloat(valArr[0]) > parseFloat(valArr[1])) {
                validDlg.isValid = false;
                validDlg.errorMsg = l10n.getConstant('MinMaxError');
            }
            if (type === 'Custom') {
                if (checkIsFormula(valArr[0])) {
                    const errorStrings = ['#N/A', '#VALUE!', '#REF!', '#DIV/0!', '#NUM!', '#NAME?', '#NULL!', '#CALC!'];
                    const eventArgs = { value: valArr[0] };
                    this.parent.notify(commputeFormulaValue, eventArgs);
                    const customValue = eventArgs.value;
                    if (errorStrings.indexOf(customValue) > -1) {
                        validDlg.isValid = false;
                        validDlg.errorMsg = l10n.getConstant('InvalidFormula');
                    }
                }
            }
            errorMsg = validDlg.errorMsg;
            isValid = validDlg.isValid;
            if (isValid) {
                if (isReadOnlyCells(this.parent, getSwapRange(getRangeIndexes(range)))) {
                    dialogInst.hide(true);
                    this.parent.notify(readonlyAlert, null);
                    return;
                }
                const args = { range: sheet.name + '!' + range, value1: valArr[0], value2: valArr[1] || '',
                    ignoreBlank: ignoreBlank, type: type, operator: operator, inCellDropDown: inCellDropDown, cancel: false };
                this.parent.notify(beginAction, { eventArgs: args, action: 'validation' });
                if (!args.cancel) {
                    this.parent.notify(cellValidation, { rules: { type: args.type, operator: args.operator, value1: args.value1, value2: args.value2,
                            ignoreBlank: args.ignoreBlank, inCellDropDown: args.inCellDropDown }, range: args.range, isAction: true });
                    delete args.cancel;
                    if (!this.parent.element.getElementsByClassName('e-validation-error-dlg')[0]) {
                        if (dialogInst.dialogInstance) {
                            dialogInst.dialogInstance.hide();
                        }
                        else {
                            dialogInst.hide();
                        }
                    }
                    this.parent.notify(completeAction, { eventArgs: args, action: 'validation' });
                }
            }
        }
        if (!isValid) {
            const errorEle = this.parent.createElement('div', { className: 'e-dlg-error', id: 'e-invalid' });
            errorEle.innerText = errorMsg;
            values.appendChild(errorEle);
            dlgFooter.querySelector('.e-primary').setAttribute('disabled', 'true');
        }
    }
    formattedValue(value) {
        const l10n = this.parent.serviceLocator.getService(locale);
        switch (value) {
            case l10n.getConstant('Between'):
                value = 'Between';
                break;
            case l10n.getConstant('NotBetween'):
                value = 'NotBetween';
                break;
            case l10n.getConstant('EqualTo'):
                value = 'EqualTo';
                break;
            case l10n.getConstant('NotEqualTo'):
                value = 'NotEqualTo';
                break;
            case l10n.getConstant('GreaterThan'):
                value = 'GreaterThan';
                break;
            case l10n.getConstant('LessThan'):
                value = 'LessThan';
                break;
            case l10n.getConstant('GreaterThanOrEqualTo'):
                value = 'GreaterThanOrEqualTo';
                break;
            case l10n.getConstant('LessThanOrEqualTo'):
                value = 'LessThanOrEqualTo';
                break;
            default:
                value = 'Between';
                break;
        }
        return value;
    }
    formattedType(value) {
        const l10n = this.parent.serviceLocator.getService(locale);
        switch (value) {
            case l10n.getConstant('WholeNumber'):
                value = 'WholeNumber';
                break;
            case l10n.getConstant('Decimal'):
                value = 'Decimal';
                break;
            case l10n.getConstant('Date'):
                value = 'Date';
                break;
            case l10n.getConstant('TextLength'):
                value = 'TextLength';
                break;
            case l10n.getConstant('List'):
                value = 'List';
                break;
            case l10n.getConstant('Time'):
                value = 'Time';
                break;
            case l10n.getConstant('Custom'):
                value = 'Custom';
                break;
        }
        return value;
    }
    isDialogValidator(values, type, operator) {
        const l10n = this.parent.serviceLocator.getService(locale);
        let count = 0;
        let isEmpty = false;
        let formValidation;
        if (type === 'List') {
            isEmpty = values.length > 0 ? false : true;
        }
        else {
            if (operator === 'Between' || operator === 'NotBetween') {
                isEmpty = values.length === 2 ? false : true;
            }
            else {
                isEmpty = values.length > 0 ? false : true;
            }
        }
        if (!isEmpty) {
            let value;
            for (let idx = 0; idx < values.length; idx++) {
                if (checkIsFormula(values[idx])) {
                    const eventArgs = { value: values[idx] };
                    this.parent.notify(commputeFormulaValue, eventArgs);
                    value = eventArgs.value;
                }
                else if (type === 'Date' || type === 'Time') {
                    value = values[idx] = this.getDateAsNumber({ range: [], cell: { value: values[idx] } }, values[idx]);
                }
                else {
                    value = values[idx];
                }
                formValidation = this.formatValidation(value, type, true);
                if (formValidation.isValid) {
                    count = count + 1;
                }
                else {
                    break;
                }
            }
            formValidation.isValid = count === values.length;
            return formValidation;
        }
        else {
            return { isValid: false, errorMsg: l10n.getConstant('EmptyError') };
        }
    }
    getDateAsNumber(args, cellValue) {
        const dateEventArgs = { value: cellValue, rowIndex: args.range[0], cell: args.cell,
            colIndex: args.range[1], sheetIndex: args.sheetIdx, updatedVal: '' };
        this.parent.notify(checkDateFormat, dateEventArgs);
        return dateEventArgs.updatedVal || cellValue;
    }
    getListOfValues(listValue) {
        let listValArr;
        if (this.parent.listSeparator !== ',' && listValue.includes(this.parent.listSeparator)) {
            listValArr = listValue.split(this.parent.listSeparator);
        }
        else {
            listValArr = listValue.split(',');
        }
        return listValArr;
    }
    checkValidationHandler(args, validation) {
        const enterValue = args.value.toString();
        const sheet = this.parent.sheets[args.sheetIdx];
        const cell = getCell(args.range[0], args.range[1], sheet, null, true);
        let value1 = validation.value1;
        let value2 = validation.value2;
        if (!cell.validation) {
            const currIdx = args.range;
            const prevIdx = [0, args.range[1], 0, args.range[3]];
            if (checkIsFormula(value1)) {
                value1 = getUpdatedFormula(currIdx, prevIdx, sheet, this.parent, { formula: value1 });
            }
            if (checkIsFormula(value2)) {
                value2 = getUpdatedFormula(currIdx, prevIdx, sheet, this.parent, { formula: value2 });
            }
        }
        if (validation.type !== 'List') {
            if (checkIsFormula(value1)) {
                const eventArgs1 = { value: value1 };
                this.parent.notify(commputeFormulaValue, eventArgs1);
                value1 = eventArgs1.value;
            }
            if (checkIsFormula(value2)) {
                const eventArgs2 = { value: value2 };
                this.parent.notify(commputeFormulaValue, eventArgs2);
                value2 = eventArgs2.value;
            }
            if (checkIsFormula(args.value)) {
                const eventArgs = { value: args.value };
                this.parent.notify(commputeFormulaValue, eventArgs);
                args.value = eventArgs.value;
            }
        }
        let value = args.value;
        const opt = validation.operator || 'Between';
        const type = validation.type || 'WholeNumber';
        const ignoreBlank = isNullOrUndefined(validation.ignoreBlank) ? true : validation.ignoreBlank;
        if (ignoreBlank && enterValue === '') {
            return true;
        }
        else {
            const isDateTimeType = type === 'Date' || type === 'Time';
            if (args.value) {
                if (isDateTimeType || validation.type === 'TextLength') {
                    if (!isNumber(args.value)) {
                        value = args.value = this.getDateAsNumber(args, args.value);
                    }
                }
                else {
                    const numObj = args.isEdit && getNumericObject(this.parent.locale);
                    const numVal = this.parseValidationValue(args.value, numObj);
                    if (numVal !== args.value && isNumber(numVal)) {
                        value = args.value = numVal.toString();
                    }
                }
            }
            let isValid = this.formatValidation(args.value, type).isValid;
            if (isValid) {
                isValid = false;
                if (isDateTimeType) {
                    if (value1 && !isNumber(value1)) {
                        value1 = this.getDateAsNumber(args, value1);
                    }
                    if (value2 && !isNumber(value2)) {
                        value2 = this.getDateAsNumber(args, value2);
                    }
                }
                else if (validation.type === 'TextLength') {
                    value = args.value.toString().length.toString();
                }
                if (type === 'List') {
                    const val = args.value.toString();
                    const isNumVal = isNumber(val);
                    const numObj = isNumVal && getNumericObject(this.parent.locale);
                    if (value1.startsWith('=')) {
                        let listVal;
                        const data = this.getListDataSource(value1);
                        for (let idx = 0; idx < data.length; idx++) {
                            listVal = data[idx].text.toString();
                            if (enterValue === listVal || val === listVal || (isNumVal &&
                                val === this.parseValidationValue(listVal, numObj).toString())) {
                                isValid = true;
                                break;
                            }
                        }
                    }
                    else {
                        const listValues = this.getListOfValues(value1);
                        for (let idx = 0; idx < listValues.length; idx++) {
                            if (enterValue === listValues[idx] || val === listValues[idx] || (isNumVal &&
                                val === this.parseValidationValue(listValues[idx], numObj).toString())) {
                                isValid = true;
                                break;
                            }
                        }
                    }
                    if (!isValid && ignoreBlank && val === '') {
                        isValid = true;
                    }
                }
                else if (type === 'Custom') {
                    const numVal = parseFloat(value1.toString());
                    if (isNumber(numVal)) {
                        if (numVal === 0) {
                            const cellRefVal = { value: validation.value1 };
                            this.parent.notify(getCellRefValue, cellRefVal); // To consider empty cell references cases.
                            isValid = cellRefVal.value !== '' ? false : true;
                        }
                        else {
                            isValid = true;
                        }
                    }
                    else if (value1.toUpperCase() === 'TRUE') {
                        isValid = true;
                    }
                    else {
                        isValid = false;
                    }
                    if (!isValid && ignoreBlank && value1 === '') {
                        isValid = true;
                    }
                }
                else {
                    if (type === 'Decimal' || type === 'Time') {
                        value = parseFloat(value.toString());
                        value1 = parseFloat(value1.toString());
                        value2 = value2 ? parseFloat(value2.toString()) : null;
                    }
                    else {
                        value = parseInt(value.toString(), 10);
                        value1 = parseInt(value1.toString(), 10);
                        value2 = value2 ? parseInt(value2.toString(), 10) : null;
                    }
                    switch (opt) {
                        case 'EqualTo':
                            isValid = value === value1;
                            break;
                        case 'NotEqualTo':
                            isValid = value !== value1;
                            break;
                        case 'Between':
                            isValid = value >= value1 && value <= value2;
                            break;
                        case 'NotBetween':
                            isValid = !(value >= value1 && value <= value2);
                            break;
                        case 'GreaterThan':
                            isValid = value > value1;
                            break;
                        case 'LessThan':
                            isValid = value < value1;
                            break;
                        case 'GreaterThanOrEqualTo':
                            isValid = value >= value1;
                            break;
                        case 'LessThanOrEqualTo':
                            isValid = value <= value1;
                            break;
                    }
                }
            }
            return isValid;
        }
    }
    parseValidationValue(val, numObj) {
        if (isNumber(val)) {
            if (numObj && numObj.group === '.') {
                val = val.toString();
                if (val.indexOf('.') && parseThousandSeparator(val, this.parent.locale, numObj.group, numObj.decimal)) {
                    val = val.split(numObj.group).join('');
                }
            }
            return val;
        }
        const formatArgs = { formattedText: val, value: val, format: 'General', cell: { value: val, format: 'General' },
            isEdit: !!numObj };
        this.parent.notify(getFormattedCellObject, formatArgs);
        return formatArgs.value;
    }
    isValidCellHandler(args) {
        const sheet = this.parent.sheets[args.sheetIdx];
        const cell = getCell(args.range[0], args.range[1], sheet);
        const formulaArgs = { skip: false, value: '' };
        let validation = cell && cell.validation;
        if (validation) {
            if (checkIsFormula(validation.value1) && !isCellReference(validation.value1.substring(1, validation.value1.length)) &&
                validation.value1.indexOf('(') > -1) {
                let val = validation.value1;
                val = val.substring(val.indexOf('=') + 1, val.indexOf('('));
                formulaArgs.value = val.toUpperCase();
                this.parent.notify(formulaInValidation, formulaArgs);
            }
            if (!formulaArgs.skip && checkIsFormula(validation.value2) &&
                !isCellReference(validation.value2.substring(1, validation.value2.length)) && validation.value1.indexOf('(') > -1) {
                let val2 = validation.value2;
                val2 = val2.substring(val2.indexOf('=') + 1, val2.indexOf('('));
                formulaArgs.value = val2.toUpperCase();
                this.parent.notify(formulaInValidation, formulaArgs);
            }
        }
        if (!formulaArgs.skip) {
            args.value = isNullOrUndefined(args.value) ? '' : args.value;
            if (validation) {
                args.isValid = this.checkValidationHandler(args, validation);
                if (args.isValid && checkColumnValidation(sheet.columns[args.range[1]], args.range[0], args.range[1])) {
                    validation = sheet.columns[args.range[1]].validation;
                    args.isValid = this.checkValidationHandler(args, validation);
                }
            }
            else if (checkColumnValidation(sheet.columns[args.range[1]], args.range[0], args.range[1])) {
                validation = sheet.columns[args.range[1]].validation;
                args.isValid = this.checkValidationHandler(args, validation);
            }
            if (validation) {
                let addInvalidHighlight;
                if (args.isEdit && !args.isValid) {
                    args.isValid = addInvalidHighlight = this.validationErrorHandler(this.parent.serviceLocator.getService(locale).getConstant('ValidationError'));
                }
                if (args.isValid && validation.isHighlighted && !isHiddenRow(sheet, args.range[0]) && !isHiddenCol(sheet, args.range[1])) {
                    this.updateHighlightHandler({
                        rowIdx: args.range[0], colIdx: args.range[1],
                        isRemoveHighlightedData: !addInvalidHighlight, isRemoveValidation: true
                    });
                }
            }
        }
    }
    formatValidation(value, type, isDialogValidator) {
        const sheetPanel = this.parent.element.getElementsByClassName('e-sheet-panel')[0];
        let errorMsg;
        const formEle = this.parent.createElement('form', { id: 'formId', className: 'form-horizontal' });
        const inputEle = this.parent.createElement('input', { id: 'e-validation' });
        inputEle.setAttribute('name', 'validation');
        inputEle.setAttribute('type', 'text');
        if (type === 'Date' && isNumber(value)) {
            const valArr = value.toString().split('.');
            if (valArr.length === 2) {
                value = valArr[0];
            }
        }
        inputEle.setAttribute('value', value);
        formEle.appendChild(inputEle);
        sheetPanel.appendChild(formEle);
        let options;
        switch (type) {
            case 'Date':
                options = {
                    rules: {
                        'validation': { date: true }
                    },
                    customPlacement: (inputElement, error) => {
                        errorMsg = error.innerText;
                    }
                };
                break;
            case 'Decimal':
                options = {
                    rules: {
                        'validation': { number: true }
                    },
                    customPlacement: (inputElement, error) => {
                        errorMsg = error.innerText;
                    }
                };
                break;
            case 'WholeNumber':
                options = {
                    rules: {
                        'validation': { regex: /^-?\d*\.?[0]*$/ }
                    },
                    customPlacement: (inputElement, error) => {
                        errorMsg = error.innerText;
                    }
                };
                break;
            case 'TextLength':
                if (isDialogValidator) {
                    options = {
                        rules: {
                            'validation': { regex: /^\d*\.?[0]*$/ }
                        },
                        customPlacement: (inputElement, error) => {
                            errorMsg = error.innerText;
                        }
                    };
                }
                break;
        }
        this.formObj = new FormValidator('#formId', options);
        const isValid = this.formObj.validate();
        sheetPanel.removeChild(sheetPanel.getElementsByClassName('form-horizontal')[0]);
        return { isValid: isValid, errorMsg: errorMsg };
    }
    updateHighlightHandler(args) {
        let isValid;
        if (!args.isRemoveValidation) {
            const cellValue = args.cell.value || args.cell.value === 0 ? args.cell.value : args.cell.hyperlink ?
                (typeof args.cell.hyperlink === 'string' ? args.cell.hyperlink : (args.cell.hyperlink.address || '')) : '';
            const validEventArgs = {
                value: cellValue, range: [args.rowIdx, args.colIdx], sheetIdx: this.parent.activeSheetIndex
            };
            isValid = this.checkValidationHandler(validEventArgs, args.validation);
            if (isValid && args.col && checkColumnValidation(args.col, args.rowIdx, args.colIdx)) {
                validEventArgs.value = cellValue;
                isValid = this.checkValidationHandler(validEventArgs, args.col.validation);
            }
        }
        if (isValid) {
            if (args.removeOnValidData) {
                const cellEle = this.parent.getCell(args.rowIdx, args.colIdx);
                if (cellEle && cellEle.style.backgroundColor) {
                    args.td = cellEle;
                    args.style = this.parent.getCellStyleValue(['backgroundColor', 'color'], [args.rowIdx, args.colIdx]);
                    this.parent.notify(applyCellFormat, args);
                    args.td = null;
                }
            }
        }
        else {
            if (args.isRemoveHighlightedData) {
                args.style = this.parent.getCellStyleValue(['backgroundColor', 'color'], [args.rowIdx, args.colIdx]);
                this.parent.notify(applyCellFormat, args);
            }
            else {
                args.style = { backgroundColor: '#ffff00', color: '#ff0000' };
                this.parent.notify(applyCellFormat, args);
            }
        }
    }
    validationErrorHandler(error) {
        const el = this.parent.element.getElementsByClassName('e-spreadsheet-edit')[0];
        const l10n = this.parent.serviceLocator.getService(locale);
        let cancel = false;
        if (!this.parent.element.querySelector('.e-validation-error-dlg')) {
            const erroDialogInst = this.parent.serviceLocator.getService(dialog);
            const disableCancel = false;
            const dlgModel = {
                width: 400, height: 200, isModal: true, showCloseIcon: true, cssClass: 'e-validation-error-dlg',
                target: document.getElementById(this.parent.element.id) || this.parent.element,
                beforeOpen: (args) => {
                    const dlgArgs = {
                        dialogName: 'ValidationErrorDialog',
                        element: args.element, target: args.target, cancel: args.cancel, content: error
                    };
                    this.parent.trigger('dialogBeforeOpen', dlgArgs);
                    if (dlgArgs.cancel) {
                        args.cancel = true;
                        cancel = true;
                    }
                    el.focus();
                    erroDialogInst.dialogInstance.content = dlgArgs.content;
                    erroDialogInst.dialogInstance.dataBind();
                },
                buttons: [{
                        buttonModel: {
                            content: l10n.getConstant('Retry'), isPrimary: true
                        },
                        click: () => {
                            this.errorDlgHandler(erroDialogInst, 'Retry');
                        }
                    },
                    {
                        buttonModel: {
                            content: l10n.getConstant('Cancel')
                        },
                        click: () => {
                            this.errorDlgHandler(erroDialogInst, 'Cancel');
                        }
                    }]
            };
            erroDialogInst.show(dlgModel, disableCancel);
        }
        return cancel;
    }
    errorDlgHandler(errorDialogInst, buttonName) {
        if (buttonName === 'Retry') {
            const el = this.parent.element.getElementsByClassName('e-spreadsheet-edit')[0];
            errorDialogInst.hide();
            if (el.innerText) {
                window.getSelection().selectAllChildren(el);
                if (this.listObj && !this.listObj.isDestroyed) {
                    this.listObj.showPopup();
                }
            }
        }
        else {
            const indexes = getCellIndexes(this.parent.getActiveSheet().activeCell);
            const cell = getCell(indexes[0], indexes[1], this.parent.getActiveSheet());
            const value = cell ? this.parent.getDisplayText(cell) : '';
            this.parent.notify(editOperation, {
                action: 'cancelEdit', value: value, refreshFormulaBar: true,
                refreshEditorElem: true, isAppend: false, trigEvent: true
            });
            errorDialogInst.hide();
        }
    }
    /**
     * Gets the module name.
     *
     * @returns {string} - Gets the module name.
     */
    getModuleName() {
        return 'dataValidation';
    }
}

/**
 * The `Protect-sheet` module is used to handle the Protecting functionalities in Spreadsheet.
 */
class ProtectSheet {
    /**
     * Constructor for protectSheet module in Spreadsheet.
     *
     * @param {Spreadsheet} parent - Specify the spreadsheet.
     * @private
     */
    constructor(parent) {
        this.parent = parent;
        this.init();
    }
    init() {
        this.addEventListener();
    }
    /**
     * To destroy the protectSheet module.
     *
     * @returns {void} - To destroy the protectSheet module.
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(applyProtect, this.protect, this);
        this.parent.on(protectSheet, this.protectSheetHandler, this);
        this.parent.on(editAlert, this.editProtectedAlert, this);
        this.parent.on(protectWorkbook, this.protectWorkbook, this);
        this.parent.on(keyUp, this.KeyUpHandler, this);
        this.parent.on(unProtectWorkbook, this.unProtectWorkbook, this);
        this.parent.on(unProtectSheetPassword, this.unProtectSheetPassword, this);
        this.parent.on(importProtectWorkbook, this.importProtectWorkbook, this);
        this.parent.on(setProtectWorkbook, this.protectWorkbookHandler, this);
        this.parent.on(removeWorkbookProtection, this.removeWorkbookProtection, this);
        this.parent.on(toggleProtect, this.toggleProtect, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(applyProtect, this.protect);
            this.parent.off(protectSheet, this.protectSheetHandler);
            this.parent.off(editAlert, this.editProtectedAlert);
            this.parent.off(protectWorkbook, this.protectWorkbook);
            this.parent.off(keyUp, this.KeyUpHandler);
            this.parent.off(unProtectWorkbook, this.unProtectWorkbook);
            this.parent.off(unProtectSheetPassword, this.unProtectSheetPassword);
            this.parent.off(importProtectWorkbook, this.importProtectWorkbook);
            this.parent.off(setProtectWorkbook, this.protectWorkbookHandler);
            this.parent.off(removeWorkbookProtection, this.removeWorkbookProtection);
            this.parent.off(toggleProtect, this.toggleProtect);
        }
    }
    protect(args) {
        if (args.isActive) {
            const sheet = this.parent.getActiveSheet();
            if (sheet.isImportProtected) {
                sheet.isImportProtected = false;
            }
        }
        this.parent.notify(clearCopy, null);
        if (!args.isActive) {
            this.createDialogue();
        }
        else {
            this.parent.setSheetPropertyOnMute(getSheet(this.parent, args.sheetIndex), 'isProtected', false);
            this.parent.notify(updateToggleItem, { props: 'Protect' });
            this.parent.notify(protectSheet, args);
            this.parent.notify(protectSelection, null);
        }
    }
    createDialogue() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const listData = [
            { text: l10n.getConstant('SelectCells'), id: '1' },
            { text: l10n.getConstant('SelectUnlockedCells'), id: '6' },
            { text: l10n.getConstant('FormatCells'), id: '2' },
            { text: l10n.getConstant('FormatRows'), id: '3' },
            { text: l10n.getConstant('FormatColumns'), id: '4' },
            { text: l10n.getConstant('InsertLinks'), id: '5' }
        ];
        this.optionList = new ListView({
            dataSource: listData,
            showCheckBox: true,
            select: this.dialogOpen.bind(this)
        });
        const dialogElem = this.parent.createElement('div', { className: 'e-sheet-password-dialog' });
        const pwdCont = this.parent.createElement('div', { className: 'e-sheet-password-content' });
        const textH = this.parent.createElement('div', { className: 'e-header' });
        textH.innerText = l10n.getConstant('SheetPassword');
        const pwdInput = this.parent.createElement('input', { className: 'e-input e-text', attrs: { 'type': 'password' } });
        pwdInput.setAttribute('placeholder', l10n.getConstant('EnterThePassword'));
        pwdCont.appendChild(pwdInput);
        pwdCont.insertBefore(textH, pwdInput);
        dialogElem.appendChild(pwdCont);
        const protectHeaderCntent = this.parent.createElement('div', { className: 'e-protect-content' });
        protectHeaderCntent.innerText = l10n.getConstant('ProtectAllowUser');
        this.parent.setSheetPropertyOnMute(this.parent.getActiveSheet(), 'isProtected', false);
        const checkbox = new CheckBox({ checked: true, label: l10n.getConstant('ProtectContent'), cssClass: 'e-protect-checkbox' });
        const listViewElement = this.parent.createElement('div', {
            className: 'e-protect-option-list',
            id: this.parent.element.id + '_option_list'
        });
        const headerContent = this.parent.createElement('div', { className: 'e-header-content' });
        headerContent.innerText = l10n.getConstant('ProtectSheet');
        const checkBoxElement = this.parent.createElement('input', { id: this.parent.element.id + '_protect_check', attrs: { type: 'checkbox' } });
        const protectSheetDlg = this.parent.serviceLocator.getService('dialog');
        const checkBoxClickHandler = () => {
            const ch = getInstance(document.getElementById(this.parent.element.id + '_protect_check'), CheckBox);
            protectSheetDlg.dialogInstance.element.querySelector('.e-footer-content .e-btn.e-primary').disabled =
                !ch.checked;
        };
        let dlgCanceled;
        protectSheetDlg.show({
            header: headerContent.outerHTML,
            content: dialogElem.outerHTML + checkBoxElement.outerHTML + protectHeaderCntent.outerHTML + listViewElement.outerHTML,
            showCloseIcon: true, isModal: true,
            cssClass: 'e-protect-dlg',
            beforeOpen: (args) => {
                const dlgArgs = {
                    dialogName: 'ProtectSheetDialog',
                    element: args.element, target: args.target, cancel: args.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    dlgCanceled = args.cancel = true;
                }
                else {
                    focus(this.parent.element);
                }
            },
            beforeClose: () => {
                if (!dlgCanceled) {
                    EventHandler.remove(checkbox.element, 'click', checkBoxClickHandler);
                }
            },
            buttons: [{
                    click: this.selectOption.bind(this, protectSheetDlg),
                    buttonModel: { content: l10n.getConstant('Ok'), isPrimary: true }
                },
                {
                    click: () => protectSheetDlg.hide(),
                    buttonModel: { content: l10n.getConstant('Cancel') }
                }]
        }, false);
        if (!dlgCanceled) {
            checkbox.appendTo('#' + this.parent.element.id + '_protect_check');
            this.optionList.appendTo('#' + this.parent.element.id + '_option_list');
            this.optionList.selectMultipleItems([{ id: '1' }, { id: '6' }]);
            EventHandler.add(checkbox.element, 'click', checkBoxClickHandler, this);
        }
    }
    dialogOpen(args) {
        const l10n = this.parent.serviceLocator.getService(locale);
        if (args.text === l10n.getConstant('SelectCells') && args.isChecked && args.isInteracted) {
            this.optionList.checkItem({ id: '6' });
        }
        if (args.text === l10n.getConstant('SelectUnlockedCells') && !args.isChecked && args.isInteracted) {
            this.optionList.uncheckItem({ id: '1' });
        }
    }
    selectOption(protectSheetDlg) {
        const pwdInput = protectSheetDlg.dialogInstance.element.querySelector('.e-sheet-password-content .e-input');
        const pwd = pwdInput.value;
        if (pwd) {
            this.reEnterSheetPassword(pwd);
        }
        else {
            const sheet = this.parent.getActiveSheet();
            this.parent.setSheetPropertyOnMute(sheet, 'isProtected', true);
            this.parent.setSheetPropertyOnMute(sheet, 'password', pwd);
            this.updateProtectSheet(pwd);
            protectSheetDlg.hide();
            if (!sheet.protectSettings.selectCells && !sheet.protectSettings.selectUnLockedCells) {
                this.parent.notify(hideAutoFillElement, null);
            }
            else if (sheet.protectSettings.selectUnLockedCells && isLockedCells(this.parent, getRangeIndexes(sheet.selectedRange))) {
                this.parent.notify(hideAutoFillElement, null);
            }
        }
    }
    applySheetPwd(pwd) {
        const actSheet = this.parent.getActiveSheet();
        this.parent.setSheetPropertyOnMute(actSheet, 'isProtected', true);
        this.parent.setSheetPropertyOnMute(actSheet, 'password', pwd);
        this.updateProtectSheet(pwd);
        if (!actSheet.protectSettings.selectCells && !actSheet.protectSettings.selectUnLockedCells) {
            this.parent.notify(hideAutoFillElement, null);
        }
    }
    updateProtectSheet(password) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const selectedItems = this.optionList.getSelectedItems();
        const protectSettings = {
            selectCells: selectedItems.text.indexOf(l10n.getConstant('SelectCells')) > -1,
            formatCells: selectedItems.text.indexOf(l10n.getConstant('FormatCells')) > -1,
            formatRows: selectedItems.text.indexOf(l10n.getConstant('FormatRows')) > -1,
            formatColumns: selectedItems.text.indexOf(l10n.getConstant('FormatColumns')) > -1,
            insertLink: selectedItems.text.indexOf(l10n.getConstant('InsertLinks')) > -1,
            selectUnLockedCells: selectedItems.text.indexOf(l10n.getConstant('SelectUnlockedCells')) > -1
        };
        this.parent.notify(protectsheetHandler, { protectSettings: protectSettings, password: password, triggerEvent: true });
        this.parent.notify(protectSelection, null);
        this.parent.notify(clearUndoRedoCollection, null);
    }
    protectSheetHandler(args) {
        const sheetIndex = isNullOrUndefined(args && args.sheetIndex) ? this.parent.activeSheetIndex : args.sheetIndex;
        const sheet = getSheet(this.parent, sheetIndex);
        const id = this.parent.element.id;
        const disableHomeBtnId = [id + '_undo', id + '_redo', id + '_cut', id + '_copy', id + '_paste', id + '_number_format',
            id + '_font_name', id + '_font_size', id + '_bold', id + '_italic', id + '_line-through', id + '_underline',
            id + '_font_color_picker', id + '_fill_color_picker', id + '_borders', id + '_merge_cells', id + '_text_align',
            id + '_vertical_align', id + '_wrap', id + '_sorting', id + '_clear', id + '_conditionalformatting'];
        const enableHomeBtnId = [id + '_cut', id + '_copy', id + '_number_format', id + '_font_name', id + '_font_size',
            id + '_bold', id + '_italic', id + '_line-through', id + '_underline', id + '_font_color_picker', id + '_fill_color_picker',
            id + '_borders', id + '_text_align', id + '_vertical_align', id + '_wrap', id + '_sorting',
            id + '_clear', id + '_conditionalformatting'];
        const enableFrmlaBtnId = [id + '_insert_function'];
        const enableInsertBtnId = [id + '_hyperlink', id + '_', id + '_chart'];
        const imageBtnId = [id + '_image'];
        const findBtnId = [id + '_find'];
        const dataValidationBtnId = [id + '_datavalidation'];
        const chartBtnId = [id + '_chart'];
        const sheetElement = document.getElementById(this.parent.element.id + '_sheet_panel');
        if (sheetElement) {
            if (sheet.isProtected) {
                if (sheet.protectSettings.selectCells) {
                    sheetElement.classList.remove('e-protected');
                }
                else if (sheet.protectSettings.selectUnLockedCells && !isLockedCells(this.parent, getRangeIndexes(sheet.selectedRange))) {
                    sheetElement.classList.remove('e-protected');
                }
                else {
                    sheetElement.classList.add('e-protected');
                }
            }
            else {
                sheetElement.classList.add('e-protected');
            }
            if (!sheet.isProtected) {
                sheetElement.classList.remove('e-protected');
            }
        }
        this.parent.dataBind();
        this.parent.notify(protectCellFormat, {
            disableHomeBtnId: disableHomeBtnId,
            enableHomeBtnId: enableHomeBtnId, enableFrmlaBtnId: enableFrmlaBtnId, enableInsertBtnId: enableInsertBtnId,
            findBtnId: findBtnId, dataValidationBtnId: dataValidationBtnId, imageBtnId: imageBtnId, chartBtnId: chartBtnId
        });
        this.parent.notify(enableFormulaInput, null);
        if (sheet.isProtected) {
            this.parent.notify(updateToggleItem, { props: 'Protect' });
        }
        if (args && args.triggerEvent) {
            this.parent.notify(completeAction, { action: 'protectSheet', eventArgs: { sheetIndex: sheetIndex, isProtected: sheet.isProtected, password: sheet.password, protectSettings: sheet.protectSettings.properties || sheet.protectSettings } });
        }
    }
    editProtectedAlert() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const protectedAlertDlg = this.parent.serviceLocator.getService('dialog');
        protectedAlertDlg.show({
            content: l10n.getConstant('EditAlert'),
            isModal: true,
            closeOnEscape: true,
            showCloseIcon: true,
            width: '400px',
            cssClass: 'e-editAlert-dlg',
            beforeOpen: (args) => {
                const dlgArgs = {
                    dialogName: 'EditAlertDialog',
                    content: l10n.getConstant('EditAlert'),
                    element: args.element, target: args.target, cancel: args.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    args.cancel = true;
                }
                else {
                    protectedAlertDlg.dialogInstance.content = dlgArgs.content;
                    focus(this.parent.element);
                }
            },
            close: () => focus(this.parent.element)
        });
    }
    protectWorkbook() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        dialogInst.show({
            width: 323, isModal: true, showCloseIcon: true, cssClass: 'e-protectworkbook-dlg',
            header: l10n.getConstant('ProtectWorkbook'),
            beforeOpen: (args) => {
                const dlgArgs = {
                    dialogName: 'ProtectWorkbook',
                    element: args.element, target: args.target, cancel: args.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    args.cancel = true;
                }
                else {
                    dialogInst.dialogInstance.content = this.passwordProtectContent();
                    dialogInst.dialogInstance.dataBind();
                    focus(this.parent.element);
                }
            },
            buttons: [{
                    buttonModel: {
                        content: l10n.getConstant('Ok'), isPrimary: true
                    },
                    click: () => {
                        this.alertMessage();
                        this.dlgClickHandler(dialogInst);
                    }
                }]
        });
    }
    passwordProtectContent() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialogElem = this.parent.createElement('div', { className: 'e-password-dialog' });
        const pwdCont = this.parent.createElement('div', { className: 'e-password-content' });
        const cnfrmPwdCont = this.parent.createElement('div', { className: 'e-password-content' });
        const textH = this.parent.createElement('div', { className: 'e-header' });
        textH.innerText = l10n.getConstant('Password');
        const urlH = this.parent.createElement('div', { className: 'e-header' });
        urlH.innerText = l10n.getConstant('ConfirmPassword');
        const pwdInput = this.parent.createElement('input', { className: 'e-input e-text', attrs: { 'type': 'password' } });
        const cnfrmPwdInput = this.parent.createElement('input', { className: 'e-input e-text', attrs: { 'type': 'password' } });
        pwdInput.setAttribute('placeholder', l10n.getConstant('EnterThePassword'));
        cnfrmPwdInput.setAttribute('placeholder', l10n.getConstant('EnterTheConfirmPassword'));
        pwdCont.appendChild(pwdInput);
        pwdCont.insertBefore(textH, pwdInput);
        cnfrmPwdCont.appendChild(cnfrmPwdInput);
        cnfrmPwdCont.insertBefore(urlH, cnfrmPwdInput);
        dialogElem.appendChild(cnfrmPwdCont);
        dialogElem.insertBefore(pwdCont, cnfrmPwdCont);
        return dialogElem;
    }
    KeyUpHandler(e) {
        const trgt = e.target;
        if (trgt.classList.contains('e-text') && closest(trgt, '.e-password-content')) {
            if (closest(trgt, '.e-password-dialog') && closest(trgt, '.e-password-dialog').
                getElementsByClassName('e-password-content')[1] === trgt.parentElement) {
                const dlgEle = closest(trgt, '.e-protectworkbook-dlg');
                const ftrEle = dlgEle.getElementsByClassName('e-footer-content')[0];
                const okBtn = ftrEle.firstChild;
                if (trgt.value !== '') {
                    okBtn.removeAttribute('disabled');
                }
                else {
                    okBtn.setAttribute('disabled', 'true');
                }
            }
        }
        if (trgt.classList.contains('e-text') && closest(trgt, '.e-unprotectpwd-content')) {
            if (closest(trgt, '.e-unprotectpwd-dialog') && closest(trgt, '.e-unprotectpwd-dialog').
                getElementsByClassName('e-unprotectpwd-content')[0] === trgt.parentElement) {
                const dlgElement = closest(trgt, '.e-unprotectworkbook-dlg');
                const ftrElement = dlgElement.getElementsByClassName('e-footer-content')[0];
                const okButton = ftrElement.firstChild;
                if (trgt.value !== '') {
                    okButton.removeAttribute('disabled');
                }
                else {
                    okButton.setAttribute('disabled', 'true');
                }
            }
        }
        if (trgt.classList.contains('e-text') && closest(trgt, '.e-reenterpwd-content')) {
            if (closest(trgt, '.e-reenterpwd-dialog') && closest(trgt, '.e-reenterpwd-dialog').
                getElementsByClassName('e-reenterpwd-content')[0] === trgt.parentElement) {
                const dlgCnt = closest(trgt, '.e-reenterpwd-dlg');
                const ftrCnt = dlgCnt.getElementsByClassName('e-footer-content')[0];
                const okBtnElem = ftrCnt.firstChild;
                if (trgt.value !== '') {
                    okBtnElem.removeAttribute('disabled');
                }
                else {
                    okBtnElem.setAttribute('disabled', 'true');
                }
            }
        }
        if (trgt.classList.contains('e-text') && closest(trgt, '.e-unprotectsheetpwd-content')) {
            if (closest(trgt, '.e-unprotectsheetpwd-dialog') && closest(trgt, '.e-unprotectsheetpwd-dialog').
                getElementsByClassName('e-unprotectsheetpwd-content')[0] === trgt.parentElement) {
                const dlg = closest(trgt, '.e-unprotectworksheet-dlg');
                const ftr = dlg.getElementsByClassName('e-footer-content')[0];
                const btn = ftr.firstChild;
                if (trgt.value !== '') {
                    btn.removeAttribute('disabled');
                }
                else {
                    btn.setAttribute('disabled', 'true');
                }
            }
        }
        if (trgt.classList.contains('e-text') && closest(trgt, '.e-importprotectpwd-content')) {
            if (closest(trgt, '.e-importprotectpwd-dialog') && closest(trgt, '.e-importprotectpwd-dialog').
                getElementsByClassName('e-importprotectpwd-content')[0] === trgt.parentElement) {
                const dlgElem = closest(trgt, '.e-importprotectworkbook-dlg');
                const ftrElem = dlgElem.getElementsByClassName('e-footer-content')[0];
                const btn = ftrElem.firstChild;
                if (trgt.value !== '') {
                    btn.removeAttribute('disabled');
                }
                else {
                    btn.setAttribute('disabled', 'true');
                }
            }
        }
    }
    alertMessage() {
        const spanElem = this.parent.element.querySelector('.e-pwd-alert-span');
        const unpotectSpanElem = this.parent.element.querySelector('.e-unprotectpwd-alert-span');
        const importpotectSpanElem = this.parent.element.querySelector('.e-importprotectpwd-alert-span');
        const protectSheetSpanElem = this.parent.element.querySelector('.e-reenterpwd-alert-span');
        const unProtectSheetSpanElem = this.parent.element.querySelector('.e-unprotectsheetpwd-alert-span');
        if (spanElem) {
            spanElem.remove();
        }
        if (unpotectSpanElem) {
            unpotectSpanElem.remove();
        }
        if (importpotectSpanElem) {
            importpotectSpanElem.remove();
        }
        if (protectSheetSpanElem) {
            protectSheetSpanElem.remove();
        }
        if (unProtectSheetSpanElem) {
            unProtectSheetSpanElem.remove();
        }
    }
    dlgClickHandler(dialogInst) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const pwdVal = this.parent.element.querySelector('.e-password-dialog').
            getElementsByClassName('e-password-content')[0].querySelector('.e-input');
        const cnfrmPwd = this.parent.element.querySelector('.e-password-dialog').
            getElementsByClassName('e-password-content')[1].querySelector('.e-input');
        const pwdSpan = this.parent.createElement('span', {
            className: 'e-pwd-alert-span'
        });
        if (pwdVal.value === cnfrmPwd.value) {
            dialogInst.hide();
            this.parent.notify(updateToggleItem, { props: 'Protectworkbook' });
            this.protectWorkbookHandler({ password: pwdVal.value });
            this.parent.notify(completeAction, { action: 'protectWorkbook', eventArgs: { isProtected: true, password: pwdVal.value } });
        }
        else if (pwdVal.value === '') {
            pwdSpan.textContent = l10n.getConstant('PasswordAlertMsg');
        }
        else if (cnfrmPwd.value === '') {
            pwdSpan.textContent = l10n.getConstant('ConfirmPasswordAlertMsg');
        }
        else if (pwdVal.value !== cnfrmPwd.value) {
            pwdSpan.textContent = l10n.getConstant('PasswordAlert');
        }
        if (dialogInst.dialogInstance) {
            (this.parent.element.querySelector('.e-protectworkbook-dlg').querySelector('.e-dlg-content')).appendChild(pwdSpan);
        }
    }
    protectWorkbookHandler(args) {
        this.parent.password = args.password;
        this.parent.isProtected = true;
        if (this.parent.showSheetTabs) {
            this.parent.element.querySelector('.e-add-sheet-tab').setAttribute('disabled', 'true');
            this.parent.element.querySelector('.e-add-sheet-tab').classList.add('e-disabled');
        }
        this.parent.notify(updateToggleItem, { props: 'Protectworkbook' });
    }
    unProtectWorkbook() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        dialogInst.show({
            width: 323, isModal: true, showCloseIcon: true, cssClass: 'e-unprotectworkbook-dlg',
            header: l10n.getConstant('UnprotectWorkbook'),
            beforeOpen: (args) => {
                const dlgArgs = {
                    dialogName: 'UnprotectWorkbook',
                    element: args.element, target: args.target, cancel: args.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    args.cancel = true;
                }
                else {
                    dialogInst.dialogInstance.content = this.unProtectPasswordContent();
                    dialogInst.dialogInstance.dataBind();
                    focus(this.parent.element);
                }
            },
            buttons: [{
                    buttonModel: {
                        content: l10n.getConstant('Ok'), isPrimary: true, disabled: true
                    },
                    click: () => {
                        this.alertMessage();
                        this.unprotectdlgOkClick(dialogInst);
                    }
                }]
        });
    }
    unProtectsheet(isImportedSheet) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        dialogInst.show({
            width: 323, isModal: true, showCloseIcon: true, cssClass: 'e-unprotectworksheet-dlg',
            header: l10n.getConstant('UnprotectWorksheet'),
            beforeOpen: (args) => {
                const dlgArgs = {
                    dialogName: 'UnProtectSheet',
                    element: args.element, target: args.target, cancel: args.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    args.cancel = true;
                }
                else {
                    dialogInst.dialogInstance.content = this.unProtectSheetPasswordContent();
                    dialogInst.dialogInstance.dataBind();
                    focus(this.parent.element);
                }
            },
            buttons: [{
                    buttonModel: {
                        content: l10n.getConstant('Ok'), isPrimary: true, disabled: this.parent.allowOpen && this.parent.openModule.isImportedFile &&
                            (this.parent.openModule.unProtectSheetIdx.indexOf(this.parent.activeSheetIndex) === -1) ? false : true
                    },
                    click: () => {
                        this.alertMessage();
                        this.unprotectSheetdlgOkClick(dialogInst, isImportedSheet);
                    }
                }]
        });
    }
    reEnterSheetPassword(pwd) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        const protectSheetDlgInst = dialogInst.dialogInstance;
        let dlgCancel;
        let pwdApplied;
        dialogInst.show({
            width: 323, isModal: true, showCloseIcon: true, cssClass: 'e-reenterpwd-dlg',
            header: l10n.getConstant('ConfirmPassword'),
            beforeOpen: (args) => {
                const dlgArgs = {
                    dialogName: 'Re-enterPassword',
                    element: args.element, target: args.target, cancel: args.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    dlgCancel = args.cancel = true;
                }
                else {
                    const l10n = this.parent.serviceLocator.getService(locale);
                    const dialogCont = this.parent.createElement('div', { className: 'e-reenterpwd-dialog' });
                    const pwdCont = this.parent.createElement('div', { className: 'e-reenterpwd-content' });
                    const textH = this.parent.createElement('div', { className: 'e-header' });
                    textH.innerText = l10n.getConstant('ReEnterPassword');
                    const pwdInput = this.parent.createElement('input', { className: 'e-input e-text', attrs: { 'type': 'password' } });
                    pwdCont.appendChild(pwdInput);
                    pwdCont.insertBefore(textH, pwdInput);
                    dialogCont.appendChild(pwdCont);
                    dialogInst.dialogInstance.content = dialogCont;
                    dialogInst.dialogInstance.dataBind();
                    focus(this.parent.element.querySelector('.e-protect-dlg.e-dialog .e-footer-content .e-btn'));
                }
            },
            close: () => {
                dialogInst.dialogInstance = protectSheetDlgInst;
                if (dlgCancel) {
                    this.applySheetPwd(pwd);
                    dialogInst.hide(true);
                }
                else if (pwdApplied) {
                    dialogInst.hide(true);
                }
            },
            buttons: [{
                    buttonModel: {
                        content: l10n.getConstant('Ok'), isPrimary: true, disabled: true
                    },
                    click: () => {
                        this.alertMessage();
                        const l10n = this.parent.serviceLocator.getService(locale);
                        const cnfrmPwdInput = this.parent.element.querySelector('.e-reenterpwd-dialog .e-reenterpwd-content .e-input');
                        const cnfrmPwd = cnfrmPwdInput.value;
                        if (pwd === cnfrmPwd) {
                            this.applySheetPwd(pwd);
                            pwdApplied = true;
                            dialogInst.hide();
                        }
                        else {
                            const pwdSpan = this.parent.createElement('span', { className: 'e-reenterpwd-alert-span' });
                            if (!cnfrmPwd) {
                                pwdSpan.textContent = l10n.getConstant('ConfirmPasswordAlertMsg');
                            }
                            else {
                                pwdSpan.textContent = l10n.getConstant('PasswordAlert');
                            }
                            (this.parent.element.querySelector('.e-reenterpwd-dlg').querySelector('.e-reenterpwd-dialog')).appendChild(pwdSpan);
                        }
                    }
                }]
        });
    }
    unProtectPasswordContent() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dlgElem = this.parent.createElement('div', { className: 'e-unprotectpwd-dialog' });
        const pwdCont = this.parent.createElement('div', { className: 'e-unprotectpwd-content' });
        const textHeader = this.parent.createElement('div', { className: 'e-header' });
        textHeader.innerText = l10n.getConstant('EnterThePassword');
        const pwdInputElem = this.parent.createElement('input', { className: 'e-input e-text', attrs: { 'type': 'password' } });
        pwdCont.appendChild(pwdInputElem);
        pwdCont.insertBefore(textHeader, pwdInputElem);
        dlgElem.appendChild(pwdCont);
        return dlgElem;
    }
    unProtectSheetPasswordContent() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialogCnt = this.parent.createElement('div', { className: 'e-unprotectsheetpwd-dialog' });
        const pwdCnt = this.parent.createElement('div', { className: 'e-unprotectsheetpwd-content' });
        const textH = this.parent.createElement('div', { className: 'e-header' });
        textH.innerText = l10n.getConstant('EnterThePassword');
        const pwdInput = this.parent.createElement('input', { className: 'e-input e-text', attrs: { 'type': 'password' } });
        pwdCnt.appendChild(pwdInput);
        pwdCnt.insertBefore(textH, pwdInput);
        dialogCnt.appendChild(pwdCnt);
        return dialogCnt;
    }
    unprotectdlgOkClick(dialogInst) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const pwd = this.parent.element.querySelector('.e-unprotectpwd-dialog').
            getElementsByClassName('e-unprotectpwd-content')[0].querySelector('.e-input');
        if (this.parent.password === pwd.value) {
            dialogInst.hide();
            this.removeWorkbookProtection();
            this.parent.notify(completeAction, { action: 'protectWorkbook', eventArgs: { isProtected: false } });
        }
        else {
            const pwdSpan = this.parent.createElement('span', { className: 'e-unprotectpwd-alert-span' });
            pwdSpan.innerText = l10n.getConstant('UnprotectPasswordAlert');
            (this.parent.element.querySelector('.e-unprotectworkbook-dlg').querySelector('.e-dlg-content')).appendChild(pwdSpan);
        }
    }
    removeWorkbookProtection() {
        this.parent.password = '';
        this.parent.isProtected = false;
        if (this.parent.showSheetTabs) {
            this.parent.element.querySelector('.e-add-sheet-tab').removeAttribute('disabled');
            this.parent.element.querySelector('.e-add-sheet-tab').classList.remove('e-disabled');
        }
        const elem = document.getElementById(this.parent.element.id + '_protectworkbook');
        if (elem) {
            elem.classList.remove('e-active');
        }
        this.parent.notify(updateToggleItem, { props: 'Protectworkbook' });
    }
    unprotectSheetdlgOkClick(dialogInst, isImportedSheet) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const sheet = this.parent.getActiveSheet();
        const pwd = this.parent.element.querySelector('.e-unprotectsheetpwd-dialog').
            getElementsByClassName('e-unprotectsheetpwd-content')[0].querySelector('.e-input');
        if (isImportedSheet && sheet.password.length === 0) {
            const impArgs = {
                sheetPassword: pwd.value,
                sheetIndex: this.parent.activeSheetIndex
            };
            this.parent.open(impArgs);
        }
        else {
            if (sheet.password === pwd.value) {
                dialogInst.hide();
                this.unProtectSheetPassword();
            }
            else {
                const pwdSpan = this.parent.createElement('span', { className: 'e-unprotectsheetpwd-alert-span' });
                pwdSpan.innerText = l10n.getConstant('UnprotectPasswordAlert');
                (this.parent.element.querySelector('.e-unprotectworksheet-dlg').querySelector('.e-dlg-content')).appendChild(pwdSpan);
            }
        }
    }
    unProtectSheetPassword() {
        const sheet = this.parent.getActiveSheet();
        const sheetIdx = this.parent.activeSheetIndex;
        this.parent.setSheetPropertyOnMute(sheet, 'isProtected', !sheet.isProtected);
        this.parent.setSheetPropertyOnMute(sheet, 'password', '');
        const isActive = sheet.isProtected ? false : true;
        this.parent.notify(applyProtect, { isActive: isActive, id: this.parent.element.id + '_protect', sheetIndex: sheetIdx, triggerEvent: true });
        if (this.parent.allowOpen && this.parent.openModule.isImportedFile &&
            this.parent.openModule.unProtectSheetIdx.indexOf(sheetIdx) === -1) {
            this.parent.openModule.unProtectSheetIdx.push(sheetIdx);
        }
    }
    importProtectWorkbook(fileArgs) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        dialogInst.show({
            width: 323, isModal: true, showCloseIcon: true, cssClass: 'e-importprotectworkbook-dlg',
            header: l10n.getConstant('UnprotectWorkbook'),
            beforeOpen: (args) => {
                const dlgArgs = {
                    dialogName: 'ImportProtectWorkbook',
                    element: args.element, target: args.target, cancel: args.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    args.cancel = true;
                }
                else {
                    dialogInst.dialogInstance.content = this.importProtectPasswordContent(fileArgs);
                    dialogInst.dialogInstance.dataBind();
                    focus(this.parent.element);
                }
            },
            buttons: [{
                    buttonModel: {
                        content: l10n.getConstant('Ok'), isPrimary: true, disabled: true
                    },
                    click: () => {
                        this.alertMessage();
                        this.importOkClick(fileArgs);
                    }
                }]
        });
    }
    importProtectPasswordContent(args) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialogElem = this.parent.createElement('div', { className: 'e-importprotectpwd-dialog' });
        const pwdCont = this.parent.createElement('div', { className: 'e-importprotectpwd-content' });
        const textSpan = this.parent.createElement('span', { className: 'e-header' });
        textSpan.innerText = '"' + args.file.name + '"' + ' ' + l10n.getConstant('IsProtected');
        const pwdInput = this.parent.createElement('input', { className: 'e-input e-text', attrs: { 'type': 'password' } });
        pwdInput.setAttribute('placeholder', l10n.getConstant('EnterThePassword'));
        pwdCont.appendChild(textSpan);
        pwdCont.appendChild(pwdInput);
        dialogElem.appendChild(pwdCont);
        return dialogElem;
    }
    importOkClick(args) {
        const pwd = this.parent.element.querySelector('.e-importprotectpwd-dialog').
            getElementsByClassName('e-importprotectpwd-content')[0].querySelector('.e-input');
        this.parent.password = pwd.value;
        const impArgs = {
            file: args.file,
            password: pwd.value
        };
        this.parent.open(impArgs);
    }
    toggleProtect() {
        let isActive;
        const parentId = this.parent.element.id;
        const sheet = this.parent.getActiveSheet();
        if (sheet.isProtected && this.parent.allowOpen && sheet.isImportProtected && this.parent.openModule.isImportedFile &&
            this.parent.openModule.unProtectSheetIdx.indexOf(this.parent.activeSheetIndex) === -1) {
            this.unProtectsheet(true);
        }
        else if (sheet.password && sheet.password.length > 0) {
            this.unProtectsheet();
        }
        else {
            this.parent.setSheetPropertyOnMute(sheet, 'isProtected', !sheet.isProtected);
            isActive = sheet.isProtected ? false : true;
            this.parent.notify(applyProtect, { isActive: isActive, id: parentId + '_protect', sheetIndex: this.parent.activeSheetIndex, triggerEvent: true });
        }
    }
    /**
     * Get the module name.
     *
     * @returns {string} - Get the module name.
     *
     * @private
     */
    getModuleName() {
        return 'protectSheet';
    }
}

/**
 * `FindAndReplace` module is used to handle the search action in Spreadsheet.
 */
class FindAndReplace {
    /**
     * Constructor for FindAndReplace module.
     *
     * @param {Spreadsheet} parent - Constructor for FindAndReplace module.
     */
    constructor(parent) {
        this.shortValue = '';
        this.divElements = [];
        this.paraElements = [];
        this.inputElements = [];
        this.textBoxElements = [];
        this.dropDownListElements = [];
        this.parent = parent;
        this.addEventListener();
    }
    addEventListener() {
        this.parent.on(findDlg, this.renderFindDlg, this);
        this.parent.on(gotoDlg, this.renderGotoDlg, this);
        this.parent.on(goto, this.gotoHandler, this);
        this.parent.on(findHandler, this.findHandler, this);
        this.parent.on(showFindAlert, this.showFindAlert, this);
        this.parent.on(replaceAllDialog, this.replaceAllDialog, this);
        this.parent.on(findKeyUp, this.findKeyUp, this);
        this.parent.on(findToolDlg, this.findToolDlg, this);
        this.parent.on(activeSheetChanged, this.refreshFindDlg, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(findDlg, this.renderFindDlg);
            this.parent.off(gotoDlg, this.renderGotoDlg);
            this.parent.off(goto, this.gotoHandler);
            this.parent.off(findHandler, this.findHandler);
            this.parent.off(showFindAlert, this.showFindAlert);
            this.parent.off(replaceAllDialog, this.replaceAllDialog);
            this.parent.off(findKeyUp, this.findKeyUp);
            this.parent.off(findToolDlg, this.findToolDlg);
            this.parent.off(activeSheetChanged, this.refreshFindDlg);
        }
    }
    findToolDlg(args) {
        const updateDisableState = (disable) => {
            const ribbon = this.parent.showRibbon && this.parent.element.querySelector('.e-ribbon');
            if (ribbon) {
                const findBtn = (args.event && args.event.target ?
                    closest(args.event.target, `#${this.parent.element.id}_findbtn`) :
                    select(`#${this.parent.element.id}_findbtn`, ribbon));
                if (findBtn) {
                    if (disable) {
                        findBtn.classList.add('e-disabled');
                    }
                    else {
                        findBtn.classList.remove('e-disabled');
                    }
                    findBtn.disabled = disable;
                }
            }
        };
        let dialogDiv = args.dialogEle || this.parent.element.getElementsByClassName('e-findtool-dlg')[0];
        if (args.isPublic) {
            this.findValue = args.findValue;
        }
        const sheet = this.parent.getActiveSheet();
        let toolbarObj;
        let findTextInput;
        let findSpan;
        const findHandlerFn = (e) => {
            if (!findTextInput || (sheet.isProtected && !sheet.protectSettings.selectCells &&
                !sheet.protectSettings.selectUnLockedCells)) {
                return;
            }
            const inputValue = findTextInput.value;
            if (e && e.keyCode === 13) {
                if (findTextInput.value && findSpan.textContent !== '0 of 0') {
                    this.parent.notify(findHandler, { findOption: e.shiftKey ? 'prev' : 'next' });
                    this.updateCount(findSpan, e.shiftKey);
                }
            }
            else {
                let enable;
                if (inputValue === '') {
                    findSpan.textContent = '0 of 0';
                    enable = false;
                }
                else {
                    const countArgs = { value: inputValue, mode: 'Sheet',
                        isCSen: false, sheetIndex: this.parent.activeSheetIndex, isEMatch: false, searchBy: 'By Row' };
                    this.parent.notify(count, countArgs);
                    findSpan.textContent = countArgs.findCount;
                    enable = countArgs.findCount !== '0 of 0';
                }
                toolbarObj.enableItems(1, enable);
                toolbarObj.enableItems(2, enable);
            }
        };
        if (dialogDiv) {
            if (args.isPublic || args.refreshPosition) {
                if (args.isPublic) {
                    findTextInput = dialogDiv.querySelector('.e-text-findNext-short');
                    findTextInput.value = this.findValue;
                    findSpan = dialogDiv.querySelector('.e-input-group-icon');
                    toolbarObj = getComponent(dialogDiv.querySelector('.e-find-toolbar'), 'toolbar');
                    findHandlerFn();
                }
                if (args.refreshPosition) {
                    let headerHgt;
                    if (this.parent.getActiveSheet().showHeaders) {
                        const hdrPanel = this.parent.getColumnHeaderContent().parentElement;
                        headerHgt = ((hdrPanel && hdrPanel.offsetHeight) || 30) + 1;
                    }
                    else {
                        headerHgt = 1;
                    }
                    dialogDiv.style.top = `${headerHgt}px`;
                }
            }
            else {
                updateDisableState(true);
                this.findDialog.hide();
            }
        }
        else {
            const findTextElement = this.parent.createElement('div', { className: 'e-input-group' });
            findTextInput = this.parent.createElement('input', { className: 'e-input e-text-findNext-short', attrs: { 'type': 'Text' } });
            if (this.findValue) {
                findTextInput.value = this.findValue;
            }
            const l10n = this.parent.serviceLocator.getService(locale);
            findTextInput.setAttribute('placeholder', l10n.getConstant('FindValue'));
            findSpan = this.parent.createElement('span', { className: 'e-input-group-icon' });
            let timeoutHandler;
            const largeData = (sheet.usedRange.rowIndex * sheet.usedRange.colIndex) > 100;
            findTextInput.onkeyup = (e) => {
                if (largeData) {
                    if (timeoutHandler) {
                        clearTimeout(timeoutHandler);
                    }
                    timeoutHandler = setTimeout(findHandlerFn.bind(this, e), 500);
                }
                else {
                    findHandlerFn(e);
                }
            };
            findTextElement.appendChild(findTextInput);
            findTextElement.appendChild(findSpan);
            const toolItemModel = [
                { type: 'Input', template: findTextElement },
                {
                    prefixIcon: 'e-icons e-prev-icon', tooltipText: l10n.getConstant('FindPreviousBtn'), type: 'Button', cssClass: 'e-findRib-prev',
                    disabled: true
                },
                { prefixIcon: 'e-icons e-next-icon', tooltipText: l10n.getConstant('FindNextBtn'), type: 'Button', cssClass: 'e-findRib-next', disabled: true },
                { type: 'Separator' },
                { prefixIcon: 'e-icons e-option-icon', tooltipText: l10n.getConstant('MoreOptions'), type: 'Button', cssClass: 'e-findRib-more' },
                { prefixIcon: 'e-icons e-close', tooltipText: l10n.getConstant('Close'), type: 'Button', cssClass: 'e-findRib-close' }
            ];
            toolbarObj = new Toolbar({
                clicked: (args) => {
                    if (args.item.cssClass === 'e-findRib-next') {
                        this.parent.notify(findHandler, { findOption: 'next' });
                        this.updateCount(findSpan);
                    }
                    else if (args.item.cssClass === 'e-findRib-prev') {
                        this.parent.notify(findHandler, { findOption: 'prev' });
                        this.updateCount(findSpan, true);
                    }
                    else if (args.item.cssClass === 'e-findRib-more') {
                        this.findDialog.animationSettings.effect = 'None';
                        this.findDialog.setProperties({ animationSettings: this.findDialog.animationSettings }, true);
                        this.renderFindDlg();
                        this.findDialog.hide();
                    }
                }, width: 'auto', height: 'auto', items: toolItemModel, cssClass: 'e-find-toolObj',
                created: () => {
                    const tbarBtns = toolbarObj.element.querySelectorAll('.e-toolbar-item .e-tbar-btn');
                    tbarBtns.forEach((tbarBtn) => tbarBtn.removeAttribute('tabindex'));
                }
            });
            const tbarEle = this.parent.createElement('div', { className: 'e-find-toolbar', attrs: { 'tabindex': '-1' } });
            toolbarObj.createElement = this.parent.createElement;
            toolbarObj.appendTo(tbarEle);
            dialogDiv = this.parent.createElement('div', { className: 'e-dlg-div', attrs: { 'aria-label': l10n.getConstant('FindValue') } });
            const sheetPanel = this.parent.element.getElementsByClassName('e-sheet-panel')[0];
            const findDlgModel = {
                cssClass: 'e-findtool-dlg', visible: false, enableRtl: this.parent.enableRtl, target: sheetPanel,
                open: () => {
                    EventHandler.add(document, 'click', this.closeDialog, this);
                    if (this.findValue && (!sheet.isProtected || sheet.protectSettings.selectCells ||
                        sheet.protectSettings.selectUnLockedCells)) {
                        const countArgs = { value: this.findValue, mode: 'Sheet',
                            isCSen: false, sheetIndex: this.parent.activeSheetIndex, isEMatch: false, searchBy: 'By Row' };
                        this.parent.notify(count, countArgs);
                        findSpan.textContent = countArgs.findCount;
                        const enable = countArgs.findCount !== '0 of 0';
                        toolbarObj.enableItems(1, enable);
                        toolbarObj.enableItems(2, enable);
                    }
                    else {
                        findSpan.textContent = '0 of 0';
                    }
                    updateDisableState(false);
                    const inputContainer = toolbarObj.element.querySelector('.e-input-group');
                    if (inputContainer) {
                        inputContainer.addEventListener('focus', () => {
                            const textInput = toolbarObj.element.querySelector('.e-text-findNext-short');
                            focus(textInput);
                            textInput.classList.add('e-input-focus');
                            (textInput).setSelectionRange(0, textInput.value.length);
                        });
                    }
                    if (animationSettings) {
                        this.findDialog.setProperties({ animationSettings: animationSettings }, true);
                    }
                },
                beforeOpen: () => focus(this.parent.element),
                beforeClose: () => {
                    this.findValue = findTextInput.value || null;
                    toolbarObj.destroy();
                    EventHandler.remove(document, 'click', this.closeDialog);
                },
                close: () => {
                    this.findDialog.destroy();
                    this.findDialog = null;
                    detach(dialogDiv);
                    sheetPanel.style.position = '';
                    focus(this.parent.element);
                    updateDisableState(false);
                },
                created: () => {
                    sheetPanel.style.position = 'relative';
                    dialogDiv.style.width = this.parent.getMainContent().offsetWidth + 'px';
                    dialogDiv.style.visibility = 'hidden';
                    dialogDiv.style.display = 'block';
                    this.findDialog.width = (parseInt(getComputedStyle(dialogDiv).borderLeftWidth, 10) * 2) +
                        dialogDiv.querySelector('.e-toolbar-items').getBoundingClientRect().width + 'px';
                    dialogDiv.style.display = '';
                    dialogDiv.style.width = '';
                    dialogDiv.style.visibility = '';
                    dialogDiv.style.top =
                        `${(args && args.headerHgt) || (this.parent.getColumnHeaderContent().parentElement.offsetHeight + 1)}px`;
                    dialogDiv.style.left = '';
                    dialogDiv.style[this.parent.enableRtl ? 'left' : 'right'] = `${this.parent.sheetModule.getScrollSize()}px`;
                    this.findDialog.show();
                }
            };
            if (Browser.isDevice) {
                findDlgModel.header = tbarEle;
                findDlgModel.allowDragging = true;
            }
            else {
                findDlgModel.content = tbarEle;
            }
            this.findDialog = new Dialog$1(findDlgModel);
            this.findDialog.createElement = this.parent.createElement;
            let animationSettings;
            if (args && args.isPublic) {
                animationSettings = { effect: this.findDialog.animationSettings.effect };
                this.findDialog.setProperties({ animationSettings: { effect: 'None' } }, true);
            }
            this.findDialog.appendTo(dialogDiv);
        }
    }
    refreshFindDlg() {
        const findDialog = this.findDialog && this.parent.element.getElementsByClassName('e-findtool-dlg')[0];
        if (findDialog) {
            const findToolInput = findDialog.querySelector('.e-text-findNext-short');
            this.findToolDlg({ findValue: findToolInput.value, isPublic: true, refreshPosition: true, dialogEle: findDialog });
        }
    }
    updateCount(countEle, isPrev) {
        const values = countEle.textContent.split(' ');
        let newStart;
        if (isPrev) {
            newStart = Number(values[0]) - 1;
            if (newStart < 1) {
                newStart = Number(values[2]);
            }
        }
        else {
            newStart = Number(values[0]) + 1;
            if (newStart > Number(values[2])) {
                newStart = 1;
            }
        }
        values[0] = newStart.toString();
        countEle.textContent = values.join(' ');
    }
    closeDialog(e) {
        if ((closest(e.target, '.e-findRib-close') || !closest(e.target, '.e-spreadsheet')) && this.findDialog) {
            this.findToolDlg({});
        }
    }
    renderFindDlg() {
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        if (!this.parent.element.querySelector('.e-find-dlg')) {
            const l10n = this.parent.serviceLocator.getService(locale);
            const dlg = {
                isModal: false, showCloseIcon: true, cssClass: 'e-find-dlg',
                header: l10n.getConstant('FindAndReplace'),
                beforeOpen: (args) => {
                    const dlgArgs = { dialogName: 'FindAndReplaceDialog', element: args.element, target: args.target, cancel: args.cancel };
                    this.parent.trigger('dialogBeforeOpen', dlgArgs);
                    if (dlgArgs.cancel) {
                        args.cancel = true;
                    }
                    else {
                        dialogInst.dialogInstance.content = this.findandreplaceContent();
                        dialogInst.dialogInstance.dataBind();
                        focus(this.parent.element);
                    }
                },
                buttons: [{
                        buttonModel: { content: l10n.getConstant('FindPreviousBtn'), isPrimary: true, cssClass: 'e-btn-findPrevious',
                            disabled: true },
                        click: (e) => {
                            this.dialogMessage();
                            this.findHandler({ findOption: e && e.keyCode === 13 ? 'next' : 'prev' });
                        }
                    },
                    {
                        buttonModel: { content: l10n.getConstant('FindNextBtn'), isPrimary: true, cssClass: 'e-btn-findNext', disabled: true },
                        click: () => {
                            this.dialogMessage();
                            this.findHandler({ findOption: 'next' });
                        }
                    },
                    {
                        buttonModel: { content: l10n.getConstant('ReplaceBtn'), isPrimary: true, cssClass: 'e-btn-replace', disabled: true },
                        click: () => {
                            this.dialogMessage();
                            this.replaceHandler(replace);
                        }
                    },
                    {
                        buttonModel: { content: l10n.getConstant('ReplaceAllBtn'), isPrimary: true, cssClass: 'e-btn-replaceAll', disabled: true },
                        click: () => {
                            this.dialogMessage();
                            this.replaceHandler(replaceAll);
                        }
                    }],
                open: () => {
                    const findInput = this.parent.element.querySelector('.e-text-findNext');
                    if (findInput.value) {
                        const prevButton = this.parent.element.querySelector('.e-btn-findPrevious');
                        const prevButtonObj = getComponent(prevButton, 'btn');
                        prevButtonObj.disabled = false;
                        getComponent(this.parent.element.querySelector('.e-btn-findNext'), 'btn').disabled = false;
                    }
                    getUpdateUsingRaf(() => {
                        focus(findInput);
                    });
                },
                beforeClose: this.dialogBeforeClose.bind(this)
            };
            dialogInst.show(dlg);
        }
        else {
            dialogInst.hide();
        }
    }
    dialogBeforeClose() {
        const checkBox = this.checkBoxElements;
        if (checkBox && checkBox.element) {
            checkBox.destroy();
            checkBox.element.remove();
        }
        this.checkBoxElements = null;
        this.textBoxElements.forEach((textBox) => {
            if (textBox && textBox.element) {
                textBox.destroy();
                textBox.element.remove();
            }
        });
        this.textBoxElements = [];
        this.dropDownListElements.forEach((dropDownList) => {
            if (dropDownList && dropDownList.element) {
                dropDownList.destroy();
                dropDownList.element.remove();
            }
        });
        this.dropDownListElements = [];
        removeElements(this.paraElements);
        this.paraElements = [];
        removeElements(this.inputElements);
        this.inputElements = [];
        removeElements(this.divElements);
        this.divElements = [];
    }
    dialogMessage() {
        if (this.parent.element.querySelector('.e-replace-alert-span')) {
            this.parent.element.querySelector('.e-replace-alert-span').remove();
        }
        else if (this.parent.element.querySelector('.e-find-alert-span')) {
            this.parent.element.querySelector('.e-find-alert-span').remove();
        }
    }
    renderGotoDlg() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        const cancelBtn = false;
        if (isNullOrUndefined(this.parent.element.querySelector('.e-goto-dlg'))) {
            const dlg = {
                width: 300, isModal: false, showCloseIcon: true, cssClass: 'e-goto-dlg',
                header: l10n.getConstant('GotoHeader'),
                beforeOpen: (args) => {
                    const dlgArgs = {
                        dialogName: 'GoToDialog',
                        element: args.element, target: args.target, cancel: args.cancel
                    };
                    this.parent.trigger('dialogBeforeOpen', dlgArgs);
                    if (dlgArgs.cancel) {
                        args.cancel = true;
                    }
                    else {
                        dialogInst.dialogInstance.content = this.GotoContent();
                        dialogInst.dialogInstance.dataBind();
                        focus(this.parent.element);
                    }
                },
                buttons: [{
                        buttonModel: {
                            content: l10n.getConstant('Ok'), isPrimary: true, cssClass: 'e-btn-goto-ok'
                        },
                        click: () => {
                            if (this.gotoHandler()) {
                                dialogInst.hide();
                            }
                        }
                    }], open: () => {
                    this.textFocus();
                }
            };
            dialogInst.show(dlg, cancelBtn);
        }
        else {
            dialogInst.hide();
        }
    }
    textFocus() {
        const element = this.parent.element.querySelector('.e-text-goto');
        element.addEventListener('focus', () => {
            if (this.parent.element.querySelector('.e-goto-alert-span')) {
                this.parent.element.querySelector('.e-goto-alert-span').remove();
            }
        });
    }
    findHandler(findOpt) {
        let findInput = this.parent.element.querySelector('.e-text-findNext');
        if (!findInput) {
            findInput = this.parent.element.querySelector('.e-text-findNext-short');
            if (!findInput) {
                this.gotoAlert();
            }
        }
        const value = findInput.value;
        if (findInput.value !== '') {
            const sheet = this.parent.getActiveSheet();
            if (sheet.isProtected && !sheet.protectSettings.selectCells && !sheet.protectSettings.selectUnLockedCells) {
                return;
            }
            const sheetIndex = this.parent.activeSheetIndex;
            const checkCase = this.parent.element.querySelector('.e-findnreplace-checkcase');
            let isCSen;
            if (!checkCase) {
                isCSen = false;
            }
            else {
                const caseCheckbox = getComponent(checkCase, 'checkbox');
                isCSen = caseCheckbox.checked;
            }
            const checkmatch = this.parent.element.querySelector('.e-findnreplace-checkmatch');
            let isEMatch;
            if (!checkmatch) {
                isEMatch = false;
            }
            else {
                const entireMatchCheckbox = getComponent(checkmatch, 'checkbox');
                isEMatch = entireMatchCheckbox.checked;
            }
            const searchitem = this.parent.element.querySelector('.e-findnreplace-searchby');
            let searchBy;
            if (!searchitem) {
                searchBy = 'By Row';
            }
            else {
                const searchDDL = getComponent(searchitem, 'dropdownlist');
                searchBy = searchDDL.value.toString();
            }
            const modeitem = this.parent.element.querySelector('.e-findnreplace-searchwithin');
            let mode;
            if (!modeitem) {
                mode = 'Sheet';
            }
            else {
                const modeDDL = getComponent(modeitem, 'dropdownlist');
                mode = modeDDL.value.toString();
            }
            const args = {
                value: value, sheetIndex: sheetIndex, findOpt: findOpt.findOption, mode: mode, isCSen: isCSen,
                isEMatch: isEMatch, searchBy: searchBy, isAction: true
            };
            this.parent.find(args);
        }
    }
    replaceHandler(action) {
        const dlg = this.parent.element.querySelector('.e-find-dlg');
        const findValue = dlg.querySelector('.e-text-findNext').value;
        const replaceValue = this.parent.element.querySelector('.e-text-replaceInp').value;
        const checkCase = this.parent.element.querySelector('.e-findnreplace-checkcase').checked;
        const checkmatch = this.parent.element.querySelector('.e-findnreplace-checkmatch').checked;
        const searchInValue = this.parent.element.querySelector('.e-search-within .e-ddl-hidden').value;
        const searchByValue = this.parent.element.querySelector('.e-searchby .e-ddl-hidden').value;
        this.parent.notify(action, { value: findValue, mode: searchInValue, isCSen: checkCase, isEMatch: checkmatch, searchBy: searchByValue,
            findOpt: 'next', replaceValue: replaceValue, replaceBy: action, sheetIndex: this.parent.activeSheetIndex, isAction: true });
    }
    gotoHandler(address) {
        let isNotAlertShown = true;
        if (address) {
            this.parent.goTo(address.address);
        }
        else {
            let gotoAddress = this.parent.element.querySelector('.e-text-goto').value;
            for (let nameIdx = 0; nameIdx < this.parent.definedNames.length; nameIdx++) {
                if (this.parent.definedNames[nameIdx].name === gotoAddress) {
                    gotoAddress = this.parent.definedNames[nameIdx].refersTo.slice(1);
                    break;
                }
            }
            let addr = gotoAddress;
            if (gotoAddress.includes('!')) {
                addr = gotoAddress.substring(gotoAddress.lastIndexOf('!') + 1);
            }
            addr = addr.split('$').join('');
            if (addr.includes(':')) {
                addr = addr.split(':')[0];
            }
            const rowMatch = addr.match(/\d+/);
            const colMatch = addr.match(/[A-Z]+/i);
            if (!rowMatch || !colMatch || colMatch.index !== 0) {
                this.gotoAlert();
                isNotAlertShown = false;
            }
            else {
                const indexes = getSwapRange(getRangeIndexes(addr));
                const sheet = this.parent.getActiveSheet();
                if (indexes[2] >= 1048576 || indexes[3] >= 16384) {
                    this.gotoAlert();
                    isNotAlertShown = false;
                }
                else if (this.parent.scrollSettings.isFinite && (sheet.rowCount < indexes[2] + 1 || sheet.colCount < indexes[3] + 1)) {
                    this.parent.notify(finiteAlert, null);
                    isNotAlertShown = false;
                }
                else {
                    this.parent.goTo(gotoAddress);
                }
            }
        }
        return isNotAlertShown;
    }
    gotoAlert() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const gotoSpan = this.parent.createElement('span', { className: 'e-goto-alert-span' });
        gotoSpan.innerText = l10n.getConstant('InsertingEmptyValue');
        if (this.parent.element.querySelector('.e-goto-alert-span')) {
            this.parent.element.querySelector('.e-goto-alert-span').remove();
        }
        (this.parent.element.querySelector('.e-goto-dlg').querySelector('.e-dlg-content')).appendChild(gotoSpan);
    }
    showFindAlert() {
        if (this.parent.element.querySelector('.e-replace-alert-span')) {
            this.parent.element.querySelector('.e-replace-alert-span').remove();
        }
        const replaceDlgCont = this.parent.element.querySelector('.e-find-dlg .e-dlg-content');
        if (replaceDlgCont) {
            const findSpan = this.parent.createElement('span', { className: 'e-find-alert-span' });
            findSpan.innerText = this.parent.serviceLocator.getService(locale).getConstant('NoElements');
            replaceDlgCont.appendChild(findSpan);
        }
    }
    replaceAllDialog(options) {
        if (this.parent.element.querySelector('.e-find-alert-span')) {
            this.parent.element.querySelector('.e-find-alert-span').remove();
        }
        const replaceAlert = this.parent.element.querySelector('.e-replace-alert-span');
        if (replaceAlert) {
            replaceAlert.remove();
        }
        const l10n = (this.parent.serviceLocator.getService(locale));
        const replaceSpan = this.parent.createElement('span', { className: 'e-replace-alert-span' });
        replaceSpan.innerText = options.count + l10n.getConstant('ReplaceAllEnd') + options.replaceValue;
        if (this.parent.element.querySelector('.e-find-dlg')) {
            (this.parent.element.querySelector('.e-find-dlg').querySelector('.e-dlg-content')).appendChild(replaceSpan);
        }
    }
    findKeyUp(e) {
        if (e.target.classList.contains('e-text-findNext')) {
            const findValue = this.parent.element.querySelector('.e-text-findNext').value;
            if (!isNullOrUndefined(findValue) && findValue !== '') {
                const prevButton = this.parent.element.querySelector('.e-btn-findPrevious');
                const prevButtonObj = getComponent(prevButton, 'btn');
                prevButtonObj.disabled = false;
                getComponent(this.parent.element.querySelector('.e-btn-findNext'), 'btn').disabled = false;
            }
            else {
                getComponent(this.parent.element.querySelector('.e-btn-findPrevious'), 'btn').disabled = true;
                getComponent(this.parent.element.querySelector('.e-btn-findNext'), 'btn').disabled = true;
                this.dialogMessage();
            }
        }
        const findValue = this.parent.element.querySelector('.e-text-findNext').value;
        const replaceValue = this.parent.element.querySelector('.e-text-replaceInp').value;
        if (!isNullOrUndefined(findValue) && !isNullOrUndefined(replaceValue) && (findValue !== '') && (replaceValue !== '')) {
            if (!this.parent.getActiveSheet().isProtected) {
                getComponent(this.parent.element.querySelector('.e-btn-replace'), 'btn').disabled = false;
                getComponent(this.parent.element.querySelector('.e-btn-replaceAll'), 'btn').disabled = false;
            }
        }
        else {
            getComponent(this.parent.element.querySelector('.e-btn-replace'), 'btn').disabled = true;
            getComponent(this.parent.element.querySelector('.e-btn-replaceAll'), 'btn').disabled = true;
        }
    }
    findandreplaceContent() {
        if (this.parent.element.querySelector('.e-text-findNext-short')) {
            this.shortValue = this.parent.element.querySelector('.e-text-findNext-short').value;
        }
        const dialogElem = this.parent.createElement('div', { className: 'e-link-dialog' });
        const findElem = this.parent.createElement('div', { className: 'e-find' });
        const findCheck = this.parent.createElement('div', { className: 'e-findCheck' });
        this.divElements.push(dialogElem);
        this.divElements.push(findElem);
        this.divElements.push(findCheck);
        const l10n = this.parent.serviceLocator.getService(locale);
        dialogElem.appendChild(findElem);
        const findTextE = this.parent.createElement('div', { className: 'e-cont' });
        const findTextH = this.parent.createElement('p', { className: 'e-header' });
        findTextH.innerText = l10n.getConstant('FindWhat');
        const findTextIp = this.parent.createElement('input', {
            className: 'e-input e-text-findNext', attrs: {
                'type': 'Text', 'placeholder': l10n.getConstant('FindValue'),
                'value': this.shortValue
            }
        });
        this.divElements.push(findTextE);
        this.paraElements.push(findTextH);
        this.inputElements.push(findTextIp);
        findTextE.appendChild(findTextIp);
        findTextE.insertBefore(findTextH, findTextIp);
        findElem.appendChild(findTextE);
        const findTextBox = new TextBox({ width: '70%' });
        this.textBoxElements.push(findTextBox);
        findTextBox.createElement = this.parent.createElement;
        findTextBox.appendTo(findTextIp);
        const replaceTextE = this.parent.createElement('div', { className: 'e-cont' });
        const replaceTextH = this.parent.createElement('p', { className: 'e-header' });
        replaceTextH.innerText = l10n.getConstant('ReplaceWith');
        const replaceTextIp = this.parent.createElement('input', {
            className: 'e-input e-text-replaceInp', attrs: { 'type': 'Text', 'placeholder': l10n.getConstant('ReplaceValue') }
        });
        this.divElements.push(replaceTextE);
        this.paraElements.push(replaceTextH);
        this.inputElements.push(replaceTextIp);
        replaceTextE.appendChild(replaceTextIp);
        replaceTextE.insertBefore(replaceTextH, replaceTextIp);
        findElem.appendChild(replaceTextE);
        const replaceTextBox = new TextBox({ width: '70%' });
        this.textBoxElements.push(replaceTextBox);
        replaceTextBox.createElement = this.parent.createElement;
        replaceTextBox.appendTo(replaceTextIp);
        const withinData = [
            { Id: 'Sheet', Within: l10n.getConstant('Sheet') },
            { Id: 'Workbook', Within: l10n.getConstant('Workbook') }
        ];
        const withInDDL = new DropDownList({
            dataSource: withinData,
            cssClass: 'e-search-within',
            fields: { value: 'Id', text: 'Within' }, width: '50%', index: 0
        });
        this.dropDownListElements.push(withInDDL);
        let label = l10n.getConstant('SearchWithin');
        const withIn = this.parent.createElement('input', {
            className: 'e-findnreplace-searchwithin', attrs: { type: 'select', label: label }
        });
        const withinTextH = this.parent.createElement('p', { className: 'e-header' });
        withinTextH.innerText = label;
        this.inputElements.push(withIn);
        this.paraElements.push(withinTextH);
        findElem.appendChild(withinTextH);
        findElem.appendChild(withIn);
        withInDDL.createElement = this.parent.createElement;
        withInDDL.appendTo(withIn);
        const searchData = [
            { Id: 'By Row', Search: l10n.getConstant('ByRow') },
            { Id: 'By Column', Search: l10n.getConstant('ByColumn') }
        ];
        const searchDDL = new DropDownList({
            dataSource: searchData,
            cssClass: 'e-searchby',
            fields: { value: 'Id', text: 'Search' }, width: '50%', index: 0
        });
        this.dropDownListElements.push(searchDDL);
        label = l10n.getConstant('SearchBy');
        const searchIn = this.parent.createElement('input', {
            className: 'e-findnreplace-searchby', attrs: { type: 'select', label: label }
        });
        const searchTextH = this.parent.createElement('p', { className: 'e-header' });
        searchTextH.innerText = label;
        this.inputElements.push(searchIn);
        this.paraElements.push(searchTextH);
        findElem.appendChild(searchTextH);
        findElem.appendChild(searchIn);
        searchDDL.createElement = this.parent.createElement;
        searchDDL.appendTo(searchIn);
        const isCSen = new CheckBox({
            label: l10n.getConstant('MatchCase'), checked: false,
            cssClass: 'e-findnreplace-casecheckbox'
        });
        const caaseCheckbox = this.parent.createElement('input', {
            className: 'e-findnreplace-checkcase', attrs: { type: 'checkbox' }
        });
        this.inputElements.push(caaseCheckbox);
        findCheck.appendChild(caaseCheckbox);
        isCSen.createElement = this.parent.createElement;
        isCSen.appendTo(caaseCheckbox);
        const isEMatch = new CheckBox({
            label: l10n.getConstant('MatchExactCellElements'), checked: false,
            cssClass: 'e-findnreplace-exactmatchcheckbox'
        });
        this.checkBoxElements = isEMatch;
        const entirematchCheckbox = this.parent.createElement('input', {
            className: 'e-findnreplace-checkmatch', attrs: { type: 'checkbox' }
        });
        this.inputElements.push(entirematchCheckbox);
        findCheck.appendChild(entirematchCheckbox);
        isEMatch.createElement = this.parent.createElement;
        isEMatch.appendTo(entirematchCheckbox);
        findElem.appendChild(findCheck);
        return dialogElem;
    }
    GotoContent() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialogElem = this.parent.createElement('div', { className: 'e-link-dialog' });
        const gotoElem = this.parent.createElement('div', { className: 'e-goto' });
        dialogElem.appendChild(gotoElem);
        const gotoTextE = this.parent.createElement('div', { className: 'e-cont' });
        const gotoTextH = this.parent.createElement('p', { className: 'e-header' });
        gotoTextH.innerText = l10n.getConstant('Reference');
        const gotoTextBox = new TextBox({
            placeholder: l10n.getConstant('EnterCellAddress')
        });
        const gotoTextIp = this.parent.createElement('input', { className: 'e-text-goto', attrs: { 'type': 'Text' } });
        gotoTextE.appendChild(gotoTextIp);
        gotoTextE.insertBefore(gotoTextH, gotoTextIp);
        gotoElem.appendChild(gotoTextE);
        gotoTextBox.createElement = this.parent.createElement;
        gotoTextBox.appendTo(gotoTextIp);
        return dialogElem;
    }
    /**
     * To destroy the find-and-replace module.
     *
     * @returns {void} - To destroy the find-and-replace module.
     */
    destroy() {
        this.removeEventListener();
        if (this.findDialog) {
            this.findDialog.hide();
        }
        this.parent = null;
    }
    /**
     * Gets the module name.
     *
     * @returns {string} - Gets the module name.
     */
    getModuleName() {
        return 'findAndReplace';
    }
}

/**
 * The `Merge` module is used to to merge the range of cells.
 */
class Merge {
    /**
     * Constructor for the Spreadsheet merge module.
     *
     * @param {Spreadsheet} parent - Specify the spreadsheet.
     * @private
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    merge(args) {
        this.parent.serviceLocator.getService('cell').refresh(args.rowIdx, args.colIdx, args.lastCell, args.element, false, false, isImported(this.parent));
    }
    hideHandler(args) {
        const sheet = this.parent.getActiveSheet();
        const mergeArgs = { range: [args.rowIdx, args.colIdx, args.rowIdx, args.colIdx] };
        this.parent.notify(activeCellMergedRange, mergeArgs);
        mergeArgs.range = mergeArgs.range;
        const cell = getCell(mergeArgs.range[0], mergeArgs.range[1], sheet) || {};
        const startIdx = args.model === 'row' ? mergeArgs.range[0] : mergeArgs.range[1];
        const endIdx = startIdx + ((cell[`${args.model}Span`] || 1) - 1);
        if ((!args.isEnd && (args.start === startIdx || isHiddenCol(sheet, startIdx))) || (args.isEnd && (args.start > startIdx &&
            !isHiddenCol(sheet, startIdx)))) {
            return;
        }
        if (cell[`${args.model}Span`] > 1 && endIdx >= args.start) {
            if (args.model === 'row' ? isHiddenRow(sheet, startIdx) : isHiddenCol(sheet, startIdx)) {
                if (args.colIdx <= endIdx) {
                    const colIdx = skipHiddenIdx(sheet, mergeArgs.range[1], true, 'columns');
                    if (colIdx <= endIdx) {
                        let rowIdx = mergeArgs.range[0];
                        if (cell.rowSpan > 1) {
                            rowIdx = skipHiddenIdx(sheet, mergeArgs.range[0], true);
                            rowIdx = rowIdx <= mergeArgs.range[2] ? rowIdx : mergeArgs.range[0];
                        }
                        const cellEle = this.parent.getCell(rowIdx, colIdx);
                        if (cellEle) {
                            cellEle.style.display = '';
                            this.parent.serviceLocator.getService('cell').refresh(mergeArgs.range[0], mergeArgs.range[1], true, cellEle, true, true);
                        }
                    }
                }
            }
            else {
                const rowIdx = cell.rowSpan > 1 ? skipHiddenIdx(sheet, mergeArgs.range[0], true) : mergeArgs.range[0];
                this.merge({ rowIdx: mergeArgs.range[0], colIdx: mergeArgs.range[1], element: this.parent.getCell(rowIdx, mergeArgs.range[1]) });
            }
        }
    }
    checkPrevMerge(args) {
        let cell;
        let mergeArgs;
        let mergeCount;
        let isMergeApplied;
        let isRowMergeCell;
        const sheet = this.parent.getActiveSheet();
        const clearMerge = () => {
            const contTable = this.parent.getContentTable();
            const contRow = contTable && contTable.rows[0];
            if (!contRow) {
                return;
            }
            const firstRowIdx = parseInt(contRow.getAttribute('aria-rowindex'), 10) - 1;
            mergeArgs.range = mergeArgs.range;
            if (firstRowIdx > this.parent.viewport.topIndex + this.parent.frozenRowCount(sheet) && firstRowIdx > mergeArgs.range[0] &&
                firstRowIdx <= mergeArgs.range[2]) {
                let cellEle;
                const hdrTable = this.parent.getRowHeaderTable();
                const hdrRow = hdrTable && hdrTable.rows[0];
                const frozenCol = this.parent.frozenColCount(sheet);
                if (frozenCol && !hdrRow) {
                    return;
                }
                for (let colIdx = args.colIdx; colIdx <= mergeArgs.range[3]; colIdx++) {
                    cellEle = this.parent.getCell(firstRowIdx, colIdx, colIdx < frozenCol ? hdrRow : contRow);
                    if (cellEle && (cellEle.colSpan > 1 || cellEle.rowSpan > 1)) {
                        cellEle.style.display = 'none';
                        cellEle.removeAttribute('colSpan');
                        cellEle.removeAttribute('rowSpan');
                    }
                }
            }
        };
        const checkRowMerge = (isColMerge) => {
            mergeArgs.range = mergeArgs.range;
            if (isHiddenRow(sheet, mergeArgs.range[0]) && args.rowIdx >= mergeArgs.range[0] && args.rowIdx <= mergeArgs.range[2]) {
                isMergeApplied = false;
                for (let rowIdx = mergeArgs.range[0]; rowIdx < args.rowIdx; rowIdx++) {
                    if (!isHiddenRow(sheet, rowIdx)) {
                        isMergeApplied = true;
                        break;
                    }
                }
                if (cell.rowSpan > 1 && !isMergeApplied) {
                    const rowMergeCount = cell.rowSpan - this.parent.hiddenCount(mergeArgs.range[0], mergeArgs.range[2]);
                    if (rowMergeCount > 0) {
                        clearMerge();
                        args.td.style.display = '';
                        args.colSpan = mergeCount;
                        args.rowSpan = rowMergeCount;
                        args.cell = cell;
                        args.isMerged = false;
                    }
                }
            }
            else if (isColMerge) {
                for (let rowIdx = mergeArgs.range[0]; isRowMergeCell && rowIdx < args.rowIdx; rowIdx++) {
                    if (!isHiddenRow(sheet, rowIdx)) {
                        isMergeApplied = true;
                        break;
                    }
                }
                if (!isMergeApplied) {
                    clearMerge();
                    args.td.style.display = '';
                    args.colSpan = mergeCount;
                    args.cell = cell;
                    args.isMerged = false;
                }
            }
        };
        if (args.cell.colSpan < 0) {
            if (args.colIdx - 1 > -1 && isHiddenCol(sheet, args.colIdx - 1)) {
                cell = getCell(args.rowIdx, args.colIdx - 1, sheet, false, true);
                isRowMergeCell = args.rowIdx - 1 > -1 && isHiddenRow(sheet, args.rowIdx - 1);
                if ((cell.colSpan !== undefined || cell.rowSpan !== undefined) && (cell.rowSpan === undefined ||
                    cell.rowSpan > 1 || isRowMergeCell)) {
                    mergeArgs = { range: [args.rowIdx, args.colIdx - 1, args.rowIdx, args.colIdx - 1] };
                    this.parent.notify(activeCellMergedRange, mergeArgs);
                    mergeArgs.range = mergeArgs.range;
                    cell = getCell(mergeArgs.range[0], mergeArgs.range[1], sheet, false, true);
                    if (isHiddenCol(sheet, mergeArgs.range[1]) && args.colIdx >= mergeArgs.range[1] && args.colIdx <= mergeArgs.range[3]) {
                        for (let colIdx = mergeArgs.range[1]; colIdx < args.colIdx; colIdx++) {
                            if (!isHiddenCol(sheet, colIdx)) {
                                isMergeApplied = true;
                                break;
                            }
                        }
                        if (cell.colSpan > 1 && !isMergeApplied) {
                            mergeCount = cell.colSpan - this.parent.hiddenCount(mergeArgs.range[1], mergeArgs.range[3], 'columns');
                            if (mergeCount > 0) {
                                checkRowMerge(true);
                            }
                        }
                    }
                }
            }
        }
        else {
            if (args.rowIdx - 1 > -1 && isHiddenRow(sheet, args.rowIdx - 1)) {
                cell = getCell(args.rowIdx - 1, args.colIdx, sheet, false, true);
                if (cell.rowSpan !== undefined) {
                    mergeArgs = { range: [args.rowIdx - 1, args.colIdx, args.rowIdx - 1, args.colIdx] };
                    this.parent.notify(activeCellMergedRange, mergeArgs);
                    mergeArgs.range = mergeArgs.range;
                    cell = getCell(mergeArgs.range[0], mergeArgs.range[1], sheet, false, true);
                    checkRowMerge();
                }
            }
        }
    }
    checkMerge(args) {
        const sheet = this.parent.getActiveSheet();
        let mergeArgs;
        let cell = getCell(args.rowIdx, args.colIdx, sheet) || {};
        if (args.isRow) {
            if (cell.colSpan === undefined || isHiddenCol(sheet, args.colIdx - 1)) {
                mergeArgs = { range: [args.rowIdx, args.colIdx, args.rowIdx, args.colIdx] };
                mergeArgs.range = mergeArgs.range;
                this.parent.notify(activeCellMergedRange, mergeArgs);
                if ((isHiddenCol(sheet, args.colIdx - 1) && !isHiddenCol(sheet, mergeArgs.range[1])) || (args.isFreezePane &&
                    mergeArgs.range[0] < this.parent.frozenRowCount(sheet))) {
                    args.insideFreezePane = mergeArgs.range[0] < this.parent.frozenRowCount(sheet);
                    return;
                }
                if (args.colIdx !== this.parent.viewport.leftIndex + this.parent.frozenColCount(sheet) &&
                    isHiddenCol(sheet, args.colIdx - 1)) {
                    for (let colIdx = mergeArgs.range[1]; cell.colSpan !== undefined && colIdx < args.colIdx; colIdx++) {
                        if (!isHiddenCol(sheet, colIdx)) {
                            return;
                        }
                    }
                }
                cell = getCell(mergeArgs.range[0], mergeArgs.range[1], sheet);
                const mergeCount = (mergeArgs.range[2] - args.rowIdx) + 1 -
                    this.parent.hiddenCount(args.rowIdx, mergeArgs.range[2]);
                if (mergeCount >= 1) {
                    this.merge({ rowIdx: mergeArgs.range[0], colIdx: mergeArgs.range[1], element: args.td });
                    if (mergeCount === 1) {
                        args.td.removeAttribute('rowspan');
                    }
                    else {
                        args.td.rowSpan = mergeCount;
                    }
                    args.td.style.display = '';
                }
            }
        }
        else {
            if (cell.rowSpan === undefined || isHiddenRow(sheet, args.rowIdx - 1)) {
                mergeArgs = { range: [args.rowIdx, args.colIdx, args.rowIdx, args.colIdx] };
                mergeArgs.range = mergeArgs.range;
                this.parent.notify(activeCellMergedRange, mergeArgs);
                if ((isHiddenRow(sheet, args.rowIdx - 1) && !isHiddenRow(sheet, mergeArgs.range[0])) || (args.isFreezePane &&
                    mergeArgs.range[1] < this.parent.frozenColCount(sheet))) {
                    args.insideFreezePane = mergeArgs.range[1] < this.parent.frozenColCount(sheet);
                    return;
                }
                if (args.rowIdx !== this.parent.viewport.topIndex + this.parent.frozenRowCount(sheet) &&
                    isHiddenRow(sheet, args.rowIdx - 1)) {
                    for (let rowIdx = mergeArgs.range[0]; cell.rowSpan !== undefined && rowIdx < args.rowIdx; rowIdx++) {
                        if (!isHiddenRow(sheet, rowIdx)) {
                            return;
                        }
                    }
                }
                cell = getCell(mergeArgs.range[0], mergeArgs.range[1], sheet);
                const mergeCount = (mergeArgs.range[3] - args.colIdx) + 1 - this.parent.hiddenCount(args.colIdx, mergeArgs.range[3], 'columns');
                if (mergeCount >= 1) {
                    this.merge({ rowIdx: mergeArgs.range[0], colIdx: mergeArgs.range[1], element: args.td });
                    if (mergeCount === 1) {
                        args.td.removeAttribute('colspan');
                    }
                    else {
                        args.td.colSpan = mergeCount;
                    }
                    args.td.style.display = '';
                }
            }
        }
    }
    addEventListener() {
        this.parent.on(applyMerge, this.merge, this);
        this.parent.on(hiddenMerge, this.hideHandler, this);
        this.parent.on(checkPrevMerge, this.checkPrevMerge, this);
        this.parent.on(checkMerge, this.checkMerge, this);
    }
    /**
     * Destroy merge module.
     *
     * @returns {void} - Destroy merge module.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(applyMerge, this.merge);
            this.parent.off(hiddenMerge, this.hideHandler);
            this.parent.off(checkPrevMerge, this.checkPrevMerge);
            this.parent.off(checkMerge, this.checkMerge);
        }
    }
    /**
     * Get the merge module name.
     *
     * @returns {string} - Get the merge module name.
     */
    getModuleName() {
        return 'merge';
    }
}

/**
 * Represents Conditional Formatting support for Spreadsheet.
 */
class ConditionalFormatting {
    /**
     * Constructor for the Spreadsheet Conditional Formatting module.
     *
     * @param {Spreadsheet} parent - Constructor for the Spreadsheet Conditional Formatting module.
     */
    constructor(parent) {
        this.divElements = [];
        this.spanElements = [];
        this.inputElements = [];
        this.dropDownListElements = [];
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * To destroy the Conditional Formatting module.
     *
     * @returns {void} - To destroy the Conditional Formatting module.
     */
    destroy() {
        this.removeEventListener();
        if (this.dupData) {
            this.dupData = [];
        }
        if (this.colorData) {
            this.colorData = [];
        }
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(applyCF, this.applyCF, this);
        this.parent.on(renderCFDlg, this.renderCFDlg, this);
        this.parent.on(clearCF, this.clearCF, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(applyCF, this.applyCF);
            this.parent.off(renderCFDlg, this.renderCFDlg);
            this.parent.off(clearCF, this.clearCF);
        }
    }
    clearCF(args) {
        const sheet = this.parent.getActiveSheet();
        const clearFn = (rIdx, cIdx, cell, td) => {
            removeClass([td], ['e-redft', 'e-yellowft', 'e-greenft', 'e-redf', 'e-redt', 'e-iconset']);
            let styleVal;
            let style;
            ['backgroundColor', 'color'].forEach((styleProp) => {
                if (td.style[`${styleProp}`]) {
                    td.style[`${styleProp}`] = '';
                    styleVal = cell && cell.style && cell.style[`${styleProp}`] || this.parent.commonCellStyle[`${styleProp}`];
                    if (styleVal) {
                        style = {};
                        style[`${styleProp}`] = styleVal;
                        this.parent.notify(applyCellFormat, { style: style, rowIdx: rIdx, colIdx: cIdx, td: td });
                    }
                }
            });
            let cfEle;
            ['.e-cf-databar', '.e-iconsetspan'].forEach((clsSelector) => {
                cfEle = td.querySelector(clsSelector);
                const wrapElement = td.querySelector('.e-wrap-content');
                if (cfEle) {
                    if (wrapElement) {
                        wrapElement.removeChild(cfEle);
                    }
                    else {
                        td.removeChild(cfEle);
                    }
                    td.textContent = this.parent.getDisplayText(cell);
                }
            });
        };
        this.updateRange(sheet, args.indexes, this.parent.frozenRowCount(sheet), this.parent.frozenColCount(sheet), getCellIndexes(sheet.topLeftCell), clearFn);
    }
    renderCFDlg(args) {
        const l10n = this.parent.serviceLocator.getService(locale);
        let readonlyAlertThrow;
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        dialogInst.show({
            width: 375, showCloseIcon: true, isModal: true, cssClass: 'e-conditionalformatting-dlg',
            header: args.action.replace('...', ''),
            beforeOpen: (beforeOpenArgs) => {
                const dlgArgs = {
                    dialogName: 'ConditionalFormatDialog',
                    element: beforeOpenArgs.element, target: beforeOpenArgs.target, cancel: beforeOpenArgs.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    beforeOpenArgs.cancel = true;
                }
                else {
                    dialogInst.dialogInstance.content = this.cfDlgContent(args.action);
                    dialogInst.dialogInstance.dataBind();
                    focus(this.parent.element);
                }
            },
            beforeClose: this.dialogBeforeClose.bind(this),
            close: () => {
                if (readonlyAlertThrow) {
                    this.parent.notify(readonlyAlert, null);
                    readonlyAlertThrow = false;
                }
            },
            buttons: [{
                    buttonModel: { content: l10n.getConstant('Ok'), isPrimary: true },
                    click: () => {
                        const sheet = this.parent.getActiveSheet();
                        if (isReadOnlyCells(this.parent, getSwapRange(getRangeIndexes(sheet.selectedRange)))) {
                            readonlyAlertThrow = true;
                        }
                        else {
                            this.dlgClickHandler(args.action);
                        }
                        dialogInst.hide();
                    }
                }]
        });
    }
    dialogBeforeClose() {
        const numeric = this.numericTBElements;
        if (numeric && numeric.element) {
            numeric.destroy();
            numeric.element.remove();
        }
        this.numericTBElements = null;
        this.dropDownListElements.forEach((dropDownList) => {
            if (dropDownList && dropDownList.element) {
                dropDownList.destroy();
                dropDownList.element.remove();
            }
        });
        this.dropDownListElements = [];
        if (this.value1Inp) {
            this.value1Inp.removeEventListener('input', this.validateCFInput.bind(this));
            if (this.value1Inp.parentNode) {
                this.value1Inp.parentNode.removeChild(this.value1Inp);
            }
            this.value1Inp = null;
        }
        if (this.value2Inp) {
            this.value2Inp.removeEventListener('input', this.validateCFInput.bind(this));
            if (this.value2Inp.parentNode) {
                this.value2Inp.parentNode.removeChild(this.value2Inp);
            }
            this.value2Inp = null;
        }
        removeElements(this.spanElements);
        this.spanElements = [];
        removeElements(this.inputElements);
        this.inputElements = [];
        removeElements(this.divElements);
        this.divElements = [];
    }
    dlgClickHandler(action) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const cont = this.parent.element.querySelector('.e-conditionalformatting-dlg .e-dlg-content .e-cf-dlg');
        const cf = { cFColor: this.getCFColor(cont.querySelector('.e-cfsub .e-input').value),
            range: this.parent.getActiveSheet().selectedRange };
        const cfInputs = cont.querySelectorAll('.e-cfmain .e-input');
        if (action === l10n.getConstant('DuplicateValues') + '...') {
            cf.type = cfInputs[0].value === l10n.getConstant('Duplicate') ? 'Duplicate' : 'Unique';
        }
        else {
            cf.type = this.getType(action);
            const cfValues = [];
            if (cfInputs[0]) {
                cfValues.push(cfInputs[0].value);
            }
            if (cfInputs[1]) {
                cfValues.push(cfInputs[1].value);
            }
            parseLocaleNumber(cfValues, this.parent);
            cf.value = cfValues.join(',');
        }
        this.parent.notify(setCFRule, { cfModel: cf, isAction: true });
    }
    getType(action) {
        const l10n = this.parent.serviceLocator.getService(locale);
        let result;
        switch (action) {
            case l10n.getConstant('GreaterThan') + '...':
                result = 'GreaterThan';
                break;
            case l10n.getConstant('LessThan') + '...':
                result = 'LessThan';
                break;
            case l10n.getConstant('Between') + '...':
                result = 'Between';
                break;
            case l10n.getConstant('CFEqualTo') + '...':
                result = 'EqualTo';
                break;
            case l10n.getConstant('TextThatContains') + '...':
                result = 'ContainsText';
                break;
            case l10n.getConstant('ADateOccuring') + '...':
                result = 'DateOccur';
                break;
            case l10n.getConstant('Top10Items') + '...':
                result = 'Top10Items';
                break;
            case l10n.getConstant('Bottom10Items') + '...':
                result = 'Bottom10Items';
                break;
            case l10n.getConstant('Top10') + ' %...':
                result = 'Top10Percentage';
                break;
            case l10n.getConstant('Bottom10') + ' %...':
                result = 'Bottom10Percentage';
                break;
            case l10n.getConstant('AboveAverage') + '...':
                result = 'AboveAverage';
                break;
            case l10n.getConstant('BelowAverage') + '...':
                result = 'BelowAverage';
                break;
        }
        return result;
    }
    getCFColor(value) {
        const l10n = this.parent.serviceLocator.getService(locale);
        let result = 'RedFT';
        switch (value) {
            case l10n.getConstant('LightRedFillWithDarkRedText'):
                result = 'RedFT';
                break;
            case l10n.getConstant('YellowFillWithDarkYellowText'):
                result = 'YellowFT';
                break;
            case l10n.getConstant('GreenFillWithDarkGreenText'):
                result = 'GreenFT';
                break;
            case l10n.getConstant('RedFill'):
                result = 'RedF';
                break;
            case l10n.getConstant('RedText'):
                result = 'RedT';
                break;
        }
        return result;
    }
    cfDlgContent(action) {
        const dlgText = this.getDlgText(action);
        const l10n = this.parent.serviceLocator.getService(locale);
        const dlgContent = this.parent.createElement('div', { className: 'e-cf-dlg' });
        const mainDiv = this.parent.createElement('div', { className: 'e-cfmain' });
        const subDiv = this.parent.createElement('div', { className: 'e-cfsub' });
        this.divElements.push(dlgContent);
        this.divElements.push(mainDiv);
        this.divElements.push(subDiv);
        const value1Text = this.parent.createElement('span', { className: 'e-header e-top-header' });
        value1Text.innerText = dlgText;
        this.value1Inp =
            this.parent.createElement('input', { className: 'e-input', id: 'valueInput', attrs: { type: 'text',
                    'aria-label': dlgText } });
        const duplicateSelectEle = this.parent.createElement('input', { className: 'e-select' });
        const subDivText = this.parent.createElement('span', { className: 'e-header' });
        subDivText.innerText = l10n.getConstant('With');
        const colorSelectEle = this.parent.createElement('input', { className: 'e-select' });
        this.spanElements.push(value1Text);
        this.inputElements.push(duplicateSelectEle);
        this.spanElements.push(subDivText);
        this.inputElements.push(colorSelectEle);
        dlgContent.appendChild(mainDiv);
        dlgContent.appendChild(subDiv);
        mainDiv.appendChild(value1Text);
        let setValidation;
        if (action !== l10n.getConstant('DuplicateValues') + '...') {
            if (action !== l10n.getConstant('AboveAverage') + '...' && action !== l10n.getConstant('BelowAverage') + '...') {
                mainDiv.appendChild(this.value1Inp);
                setValidation = true;
                const percent = action === l10n.getConstant('Top10') + ' %...' || action === l10n.getConstant('Bottom10') + ' %...';
                if (action === l10n.getConstant('Top10Items') + '...' || action === l10n.getConstant('Bottom10Items') + '...' || percent) {
                    this.value1Inp.maxLength = percent ? 3 : 4;
                    const numeric = new NumericTextBox({ value: 10, min: 1, max: percent ? 100 : 1000, format: '###' });
                    this.numericTBElements = numeric;
                    numeric.appendTo(this.value1Inp);
                }
            }
        }
        else {
            mainDiv.appendChild(duplicateSelectEle);
            this.dupData = [
                { text: l10n.getConstant('Duplicate'), id: 'duplicate' },
                { text: l10n.getConstant('Unique'), id: 'unique' }
            ];
            const dupList = new DropDownList({
                dataSource: this.dupData,
                index: 0,
                popupHeight: '200px'
            });
            this.dropDownListElements.push(dupList);
            dupList.appendTo(duplicateSelectEle);
        }
        if (action === l10n.getConstant('Between') + '...') {
            const value2Text = this.parent.createElement('span', { className: 'e-header e-header-2' });
            value2Text.innerText = l10n.getConstant('And');
            this.value2Inp = this.parent.createElement('input', { className: 'e-input e-between' });
            this.spanElements.push(value2Text);
            mainDiv.appendChild(value2Text);
            mainDiv.appendChild(this.value2Inp);
            this.value2Inp.addEventListener('input', this.validateCFInput.bind(this));
        }
        if (setValidation) {
            this.validateCFInput({ target: this.value1Inp });
            this.value1Inp.addEventListener('input', this.validateCFInput.bind(this));
        }
        subDiv.appendChild(subDivText);
        subDiv.appendChild(colorSelectEle);
        this.colorData = [
            { text: l10n.getConstant('LightRedFillWithDarkRedText'), value: 'redft', id: 'redft' },
            { text: l10n.getConstant('YellowFillWithDarkYellowText'), id: 'yellowft' },
            { text: l10n.getConstant('GreenFillWithDarkGreenText'), id: 'greenft' },
            { text: l10n.getConstant('RedFill'), id: 'redf' },
            { text: l10n.getConstant('RedText'), id: 'redt' }
        ];
        const colorList = new DropDownList({
            dataSource: this.colorData,
            index: 0,
            popupHeight: '200px'
        });
        this.dropDownListElements.push(colorList);
        colorList.appendTo(colorSelectEle);
        return dlgContent;
    }
    validateCFInput(e) {
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        let text = e.target.value;
        const btn = dialogInst.dialogInstance.element.getElementsByClassName('e-primary')[0];
        if (text && (e.target.classList.contains('e-between') || e.target.parentElement.querySelector('.e-between'))) {
            text = e.target.parentElement.querySelector((e.target.classList.contains('e-between') ? '.e-input' : '.e-between')).value;
        }
        btn.disabled = !(text.trim());
    }
    checkCellHandler(rowIdx, colIdx, cf) {
        const ranges = cf.range.trim().split(',');
        return ranges.some((range) => {
            const indexes = getRangeIndexes(range.includes(':') ? range : `${range}:${range}`);
            return rowIdx >= indexes[0] && rowIdx <= indexes[2] && colIdx >= indexes[1] && colIdx <= indexes[3];
        });
    }
    getDlgText(action) {
        const l10n = this.parent.serviceLocator.getService(locale);
        let result = '';
        switch (action) {
            case l10n.getConstant('GreaterThan') + '...':
                result = l10n.getConstant('FormatCellsGreaterThan');
                break;
            case l10n.getConstant('LessThan') + '...':
                result = l10n.getConstant('FormatCellsLessThan');
                break;
            case l10n.getConstant('Between') + '...':
                result = l10n.getConstant('FormatCellsBetween');
                break;
            case l10n.getConstant('CFEqualTo') + '...':
                result = l10n.getConstant('FormatCellsEqualTo');
                break;
            case l10n.getConstant('TextThatContains') + '...':
                result = l10n.getConstant('FormatCellsThatContainTheText');
                break;
            case l10n.getConstant('ADateOccuring') + '...':
                result = l10n.getConstant('FormatCellsThatContainADateOccurring');
                break;
            case l10n.getConstant('DuplicateValues') + '...':
                result = l10n.getConstant('FormatCellsDuplicate');
                break;
            case l10n.getConstant('Top10Items') + '...':
                result = l10n.getConstant('FormatCellsTop');
                break;
            case l10n.getConstant('Top10') + ' %...':
                result = l10n.getConstant('FormatCellsTop');
                break;
            case l10n.getConstant('Bottom10Items') + '...':
                result = l10n.getConstant('FormatCellsBottom');
                break;
            case l10n.getConstant('Bottom10') + ' %...':
                result = l10n.getConstant('FormatCellsBottom');
                break;
            case l10n.getConstant('AboveAverage') + '...':
                result = l10n.getConstant('FormatCellsAbove');
                break;
            case l10n.getConstant('BelowAverage') + '...':
                result = l10n.getConstant('FormatCellsBelow');
                break;
        }
        return result;
    }
    updateResult(cf, sheet, isDataBar, isColorScale, isAverage, isTopBottom, isIconSets, input) {
        const valueObj = {};
        const dupValueObj = {};
        const rangeArr = cf.range.split(',');
        let result = [];
        let rangeIndexes;
        let val;
        let cell;
        let cellType;
        let updateFn;
        if (isDataBar) {
            updateFn = () => {
                if (isNumber(val) && cellType !== 'Text') {
                    const intVal = parseFloat(val);
                    if (intVal >= 0) {
                        if (result[0] === undefined || intVal > result[0]) {
                            result[0] = intVal;
                        }
                    }
                    else if (result[1] === undefined || intVal < result[1]) {
                        result[1] = intVal;
                    }
                }
            };
        }
        else if (isColorScale) {
            updateFn = () => {
                if (isNumber(val) && cellType !== 'Text') {
                    const intVal = parseFloat(val);
                    result.push(Number(intVal));
                }
            };
        }
        else if (isAverage) {
            result = [0, 0];
            updateFn = () => {
                if (isNumber(val) && cellType !== 'Text') {
                    result[0] += parseFloat(val);
                    result[1]++;
                }
            };
        }
        else if (isTopBottom) {
            updateFn = () => {
                if (isNumber(val) && cellType !== 'Text') {
                    result.push(parseFloat(val));
                }
            };
        }
        else if (isIconSets) {
            updateFn = () => {
                if (isNumber(val) && cellType !== 'Text') {
                    const intVal = parseFloat(val);
                    if (result[0] === undefined || intVal < result[0]) {
                        result[0] = intVal;
                    }
                    if (result[1] === undefined || intVal > result[1]) {
                        result[1] = intVal;
                    }
                }
            };
        }
        else {
            updateFn = () => {
                if (valueObj[`${val}`]) {
                    if (val !== '') {
                        if (!dupValueObj[`${val}`]) {
                            dupValueObj[`${val}`] = true;
                            result.push(val);
                        }
                    }
                }
                else {
                    valueObj[`${val}`] = true;
                }
            };
        }
        for (let rangeIdx = 0; rangeIdx < rangeArr.length; rangeIdx++) {
            rangeIndexes = getRangeIndexes(rangeArr[rangeIdx]);
            for (let i = rangeIndexes[0]; i <= rangeIndexes[2]; i++) {
                for (let j = rangeIndexes[1]; j <= rangeIndexes[3]; j++) {
                    cell = getCell(i, j, sheet, false, true);
                    cellType = '';
                    if (!isNullOrUndefined(cell.value)) {
                        val = cell.value.toString().toLowerCase();
                        cellType = getTypeFromFormat(cell.format);
                        updateFn();
                    }
                    else if (cell.formula) {
                        this.parent.notify(calculateFormula, {
                            cell: cell, rowIdx: i, colIdx: j, sheetIndex: this.parent.activeSheetIndex
                        });
                        val = cell.value.toString().toLowerCase();
                        cellType = getTypeFromFormat(cell.format);
                        updateFn();
                    }
                }
            }
        }
        if (isColorScale || isTopBottom) {
            result = result.sort((n1, n2) => n1 - n2);
            if (!cf.type.includes('Bottom')) {
                result = result.reverse();
            }
            if (isTopBottom) {
                let endIdx = parseFloat(input);
                if (cf.type.includes('Percentage')) {
                    endIdx = endIdx / (100 / result.length);
                    endIdx = (endIdx < 1) ? 1 : endIdx;
                }
                result = result.slice(0, endIdx);
            }
        }
        else if (isAverage) {
            result = [result[0] / result[1]];
            if (!result[0]) {
                result = [];
            }
        }
        cf.result = result;
    }
    applyCF(args) {
        const rangeCheck = !args.cfModel;
        const sheet = this.parent.getActiveSheet();
        const cfRule = args.cfModel || sheet.conditionalFormats;
        let indexes = [args.indexes];
        if (args.refreshAll) {
            indexes = getViewportIndexes(this.parent, this.parent.viewport);
        }
        const updatedCFCellRef = {};
        for (let i = cfRule.length - 1; i >= 0; i--) {
            if (rangeCheck && (indexes[0].length === 2 ? !this.checkCellHandler(args.indexes[0], args.indexes[1], cfRule[i]) :
                !checkRange(indexes, cfRule[i].range))) {
                continue;
            }
            this.updateCF(args, sheet, cfRule[i], updatedCFCellRef);
        }
    }
    updateCF(args, sheet, cf, updatedCFCellRef) {
        let value1;
        let value2 = '';
        let isLongDate = false;
        if (cf.value) {
            let dateValues = [];
            let valueArr = [];
            if (cf.type === 'Between') {
                dateValues = cf.value.split('"').filter((date) => date.trim() && date.trim() !== ',');
                if (dateValues.length > 1) {
                    valueArr = dateValues;
                    isLongDate = true;
                }
                else {
                    valueArr = cf.value.split(',').filter((value) => !!value.trim());
                }
            }
            else {
                valueArr = [cf.value];
            }
            if (valueArr.length > 1) {
                if (valueArr[0].split('(').length > 1) {
                    let valueStr = '';
                    for (let idx = 0; idx < valueArr.length; idx++) {
                        valueStr += valueArr[idx] + ',';
                        if (valueStr.split('(').length === valueStr.split(')').length && value1 === undefined) {
                            value1 = valueStr.substring(0, valueStr.length - 1);
                            valueStr = '';
                        }
                    }
                    value2 = valueStr.substring(0, valueStr.length - 1);
                }
                else {
                    value1 = valueArr[0];
                    for (let idx = 1; idx < valueArr.length; idx++) {
                        value2 += idx + 1 === valueArr.length ? valueArr[idx] : valueArr[idx] + ',';
                    }
                }
            }
            else {
                value1 = valueArr[0] || cf.value;
            }
        }
        if (!cf.type) {
            cf.type = 'GreaterThan';
        }
        let style;
        let cfColor;
        if (cf.format && cf.format.style) {
            style = skipDefaultValue(cf.format.style, true);
            if (!Object.keys(style).length) {
                cfColor = cf.cFColor;
                if (!cfColor) {
                    cfColor = cf.cFColor = 'RedFT';
                }
            }
        }
        else {
            style = {};
            cfColor = cf.cFColor;
            if (!cfColor) {
                cfColor = cf.cFColor = 'RedFT';
            }
        }
        const isAverage = cf.type.includes('Average');
        const isTopBottom = cf.type.includes('10') && isNumber(value1);
        const isIconSets = (cf.type.includes('Three') || cf.type.includes('Four') || cf.type.includes('Five'));
        const isDataBar = cf.type.includes('DataBar');
        const isColorScale = cf.type.includes('ColorScale');
        if ((!args.isRender || !cf.result) && (cf.type === 'Duplicate' || cf.type === 'Unique' || isDataBar
            || isColorScale || isAverage || isTopBottom || isIconSets)) {
            this.updateResult(cf, sheet, isDataBar, isColorScale, isAverage, isTopBottom, isIconSets, value1);
        }
        const updateCF = (rIdx, cIdx, cell, td, currentRowHeight, isLongDate) => {
            const cellVal = cell && !isNullOrUndefined(cell.value) ? cell.value.toString() : '';
            let isApply;
            let dateEventArgs;
            let isValueCFRule = true;
            const cellType = cell ? getTypeFromFormat(cell.format) : '';
            switch (cf.type) {
                case 'GreaterThan':
                case 'LessThan':
                    isApply = this.isGreaterThanLessThan(cf, cellVal, value1, cellType);
                    break;
                case 'Between':
                    isApply = isNumber(cellVal) && cellType !== 'Text' && this.isBetWeen(cf, cellVal, value1, value2, isLongDate);
                    break;
                case 'EqualTo':
                    isApply = this.isEqualTo(cf, cellVal, value1);
                    break;
                case 'ContainsText':
                    isApply = cellVal && value1 && this.isContainsText(cellVal, value1);
                    break;
                case 'DateOccur':
                    dateEventArgs = { value: value1, cell: {}, updatedVal: value1 };
                    if (!isNumber(value1)) {
                        this.parent.notify(checkDateFormat, dateEventArgs);
                    }
                    isApply = cellVal === dateEventArgs.updatedVal;
                    break;
                case 'Unique':
                    isApply = cellVal !== '' && cf.result.indexOf(cellVal.toLowerCase()) === -1;
                    break;
                case 'Duplicate':
                    isApply = cf.result.indexOf(cellVal.toLowerCase()) > -1;
                    break;
                case 'Top10Items':
                case 'Bottom10Items':
                case 'Top10Percentage':
                case 'Bottom10Percentage':
                    if (cf.result) {
                        let value = parseFloat(cellVal);
                        if (isDateTime(cellVal)) {
                            value = dateToInt(cellVal);
                        }
                        isApply = cf.result.indexOf(value) > -1;
                    }
                    break;
                case 'AboveAverage':
                    isApply = cf.result.length && isNumber(cellVal) && cellType !== 'Text' && parseFloat(cellVal) > cf.result[0];
                    break;
                case 'BelowAverage':
                    isApply = cf.result.length && isNumber(cellVal) && cellType !== 'Text' && parseFloat(cellVal) < cf.result[0];
                    break;
                default:
                    isValueCFRule = false;
                    if (isDataBar) {
                        if (!updatedCFCellRef[`${rIdx}_${cIdx}_bars`]) {
                            updatedCFCellRef[`${rIdx}_${cIdx}_bars`] = true;
                            this.applyDataBars(cellVal, cf, td, rIdx, cellType, currentRowHeight);
                        }
                    }
                    else if (isColorScale) {
                        if (!updatedCFCellRef[`${rIdx}_${cIdx}`]) {
                            const value = isNumber(cellVal) ? parseFloat(cellVal) : NaN;
                            if (isNaN(value)) {
                                if (td.style.backgroundColor && !td.classList.contains('e-yellowft') && !td.classList.contains('e-greenft') && !td.classList.value.includes('e-redf')) {
                                    td.style.backgroundColor = '';
                                    const style = extend({}, this.parent.commonCellStyle, cell && cell.style);
                                    if (style.backgroundColor) {
                                        this.parent.notify(applyCellFormat, {
                                            style: { backgroundColor: style.backgroundColor }, td: td, rowIdx: rIdx,
                                            colIdx: cIdx
                                        });
                                    }
                                }
                            }
                            else {
                                const valArr = cf.result;
                                const idx = valArr.indexOf(value);
                                if (idx === -1) {
                                    if (td.style.backgroundColor) {
                                        td.style.backgroundColor = '';
                                        const style = extend({}, this.parent.commonCellStyle, cell && cell.style);
                                        if (style.backgroundColor) {
                                            this.parent.notify(applyCellFormat, {
                                                style: { backgroundColor: style.backgroundColor }, td: td, rowIdx: rIdx,
                                                colIdx: cIdx
                                            });
                                        }
                                    }
                                }
                                else {
                                    const colors = this.getColor(cf.type);
                                    td.style.backgroundColor = idx === 0 ? colors[0] :
                                        (idx === valArr.length - 1 ? colors[colors.length - 1] : (valArr.length === 3 && idx === 1 ? colors[1] :
                                            this.getGradient(idx, colors[0], colors[1], colors[2], valArr.length)));
                                    updatedCFCellRef[`${rIdx}_${cIdx}`] = true;
                                }
                            }
                        }
                    }
                    else {
                        if (!updatedCFCellRef[`${rIdx}_${cIdx}_icons`]) {
                            updatedCFCellRef[`${rIdx}_${cIdx}_icons`] = true;
                            const cfIcon = this.parent.createElement('span', { className: 'e-icon e-iconsetspan' });
                            const iconSetUpdated = this.applyIconSet(cellVal, cf, td, cfIcon, cellType);
                            if (iconSetUpdated && cell && cell.format && cell.format.includes('*') &&
                                getTypeFromFormat(cell.format) !== 'Accounting') {
                                this.parent.notify(rowFillHandler, { cell: cell, cellEle: td, rowIdx: rIdx, colIdx: cIdx, updateFillSize: true,
                                    iconSetSpan: cfIcon });
                            }
                        }
                    }
                    break;
            }
            if (args.isAction && isValueCFRule) {
                this.parent.trigger('beforeConditionalFormat', { conditionalFormat: cf, cell: cell, element: td, apply: isApply,
                    address: getCellAddress(rIdx, cIdx) });
                if (!isApply && args.isEdit && !updatedCFCellRef[`${rIdx}_${cIdx}`]) {
                    let style;
                    if (cfColor) {
                        if (td.className.includes('e-' + cfColor.toLowerCase())) {
                            td.classList.remove('e-' + cfColor.toLowerCase());
                            td.style.backgroundColor = '';
                            td.style.color = '';
                            style = extend({}, this.parent.commonCellStyle, cell && cell.style);
                            if (style.backgroundColor || style.color) {
                                this.parent.notify(applyCellFormat, { rowIdx: rIdx, colIdx: cIdx, td: td,
                                    style: { backgroundColor: style.backgroundColor, color: style.color } });
                            }
                        }
                    }
                    else {
                        td.removeAttribute('style');
                        style = extend({}, this.parent.commonCellStyle, cell && cell.style);
                        if (Object.keys(style).length) {
                            this.parent.notify(applyCellFormat, { style: style, rowIdx: rIdx, colIdx: cIdx, td: td });
                        }
                    }
                }
            }
            if (isApply && !updatedCFCellRef[`${rIdx}_${cIdx}`]) {
                updatedCFCellRef[`${rIdx}_${cIdx}`] = true;
                removeClass([td], ['e-redft', 'e-yellowft', 'e-greenft', 'e-redf', 'e-redt']);
                if (cfColor) {
                    td.classList.add('e-' + cfColor.toLowerCase());
                    this.setCFStyle(style, cf);
                }
                Object.assign(td.style, style);
            }
        };
        if (args.ele) {
            updateCF(args.indexes[0], args.indexes[1], args.cell, args.ele, args.resizedRowHeight, isLongDate);
        }
        else {
            const rangeArr = cf.range.split(',');
            const frozenRow = this.parent.frozenRowCount(sheet);
            const frozenCol = this.parent.frozenColCount(sheet);
            const topLeftIdx = getCellIndexes(sheet.topLeftCell);
            for (let i = 0; i < rangeArr.length; i++) {
                this.updateRange(sheet, getRangeIndexes(rangeArr[i]), frozenRow, frozenCol, topLeftIdx, updateCF, isLongDate);
            }
        }
    }
    updateRange(sheet, rangeIdx, frozenRow, frozenCol, topLeftIdx, invokeFn, isLongDate) {
        rangeIdx[0] = rangeIdx[0] < frozenRow ? (rangeIdx[0] < topLeftIdx[0] ? topLeftIdx[0] : rangeIdx[0]) :
            (rangeIdx[0] < this.parent.viewport.topIndex + frozenRow ? this.parent.viewport.topIndex + frozenRow : rangeIdx[0]);
        rangeIdx[1] = rangeIdx[1] < frozenCol ? (rangeIdx[1] < topLeftIdx[1] ? topLeftIdx[1] : rangeIdx[1]) :
            (rangeIdx[1] < this.parent.viewport.leftIndex + frozenCol ? this.parent.viewport.leftIndex + frozenCol : rangeIdx[1]);
        rangeIdx[2] = rangeIdx[2] < frozenRow ? (rangeIdx[2] < topLeftIdx[0] ? topLeftIdx[0] - 1 :
            rangeIdx[2]) : (rangeIdx[2] > this.parent.viewport.bottomIndex ? this.parent.viewport.bottomIndex : rangeIdx[2]);
        rangeIdx[3] = rangeIdx[3] < frozenCol ? (rangeIdx[3] < topLeftIdx[1] ? topLeftIdx[1] - 1 : rangeIdx[3]) :
            (rangeIdx[3] > this.parent.viewport.rightIndex ? this.parent.viewport.rightIndex : rangeIdx[3]);
        let td;
        for (let rowIdx = rangeIdx[0]; rowIdx <= rangeIdx[2]; rowIdx++) {
            if (frozenRow && rowIdx === frozenRow) {
                rowIdx = this.parent.viewport.topIndex + frozenRow;
            }
            if (isHiddenRow(sheet, rowIdx)) {
                continue;
            }
            for (let colIdx = rangeIdx[1]; colIdx <= rangeIdx[3]; colIdx++) {
                if (frozenCol && colIdx === frozenCol) {
                    colIdx = this.parent.viewport.leftIndex + frozenCol;
                }
                if (isHiddenCol(sheet, colIdx)) {
                    continue;
                }
                td = this.parent.getCell(rowIdx, colIdx);
                if (td) {
                    invokeFn(rowIdx, colIdx, getCell(rowIdx, colIdx, sheet), td, undefined, isLongDate);
                }
            }
        }
    }
    applyIconSet(val, cf, cellEle, cfIcon, cellType) {
        const iconSetExist = cellEle.classList.contains('e-iconset');
        const wrapText = cellEle.querySelector('.e-wrap-content');
        if (iconSetExist) {
            cellEle.classList.remove('e-iconset');
            const iconSpan = cellEle.querySelector('.e-iconsetspan');
            if (iconSpan) {
                if (wrapText) {
                    wrapText.removeChild(iconSpan);
                }
                else {
                    cellEle.removeChild(iconSpan);
                }
            }
        }
        const value = isNumber(val) ? parseFloat(val) : NaN;
        const result = cf.result;
        if (isNaN(value) || (result[0] === undefined && result[1] === undefined) || (isNumber(val) && cellType === 'Text')) {
            return iconSetExist;
        }
        const min = result[0];
        const max = result[1];
        const iconList = this.getIconList(cf.type).split(',');
        let currentSymbol;
        if (iconList.length === 3) {
            const maxPercent = min + (0.67 * ((max) - (min)));
            const minPercent = min + (0.33 * ((max) - (min)));
            currentSymbol =
                'e-' + (value >= maxPercent ? iconList[0].trim() : value >= minPercent ? iconList[1].trim() : iconList[2].trim());
        }
        else if (iconList.length === 4) {
            const percent1 = min + (0.25 * ((max) - (min)));
            const percent2 = min + (0.50 * ((max) - (min)));
            const percent3 = min + (0.75 * ((max) - (min)));
            currentSymbol =
                'e-' + (value >= percent3 ? iconList[0].trim() : value >= percent2 ? iconList[1].trim() : value >= percent1 ?
                    iconList[2].trim() : iconList[3].trim());
        }
        else if (iconList.length === 5) {
            const percent1 = min + (0.20 * ((max) - (min)));
            const percent2 = min + (0.40 * ((max) - (min)));
            const percent3 = min + (0.60 * ((max) - (min)));
            const percent4 = min + (0.80 * ((max) - (min)));
            currentSymbol =
                'e-' + (value >= percent4 ? iconList[0].trim() : value >= percent3 ? iconList[1].trim() : value >= percent2 ?
                    iconList[2].trim() : value >= percent1 ? iconList[3].trim() : iconList[4].trim());
        }
        cfIcon.classList.add(currentSymbol);
        const dataBar = cellEle.querySelector('.e-cf-databar');
        if (dataBar) {
            cfIcon.style.height = dataBar.style.height;
            cfIcon.classList.add(cellEle.style.verticalAlign === 'top' ? 'e-cf-icon-top' : cellEle.style.verticalAlign === 'middle' ?
                'e-cf-icon-middle' : 'e-cf-icon-end');
        }
        if (wrapText) {
            wrapText.insertBefore(cfIcon, wrapText.firstChild);
        }
        else {
            cellEle.insertBefore(cfIcon, cellEle.childNodes[0]);
        }
        cellEle.classList.add('e-iconset');
        return true;
    }
    getIconList(iconName) {
        const result = '3arrows-1,3arrows-2,3arrows-3';
        switch (iconName) {
            case 'ThreeArrows':
                return '3arrows-1,3arrows-2,3arrows-3';
            case 'ThreeArrowsGray':
                return '3arrowsgray-1,3arrowsgray-2,3arrowsgray-3';
            case 'FourArrowsGray':
                return '4arrowsgray-1,4arrowsgray-2,4arrowsgray-3,4arrowsgray-4';
            case 'FourArrows':
                return '4arrows-1,4arrows-2,4arrows-3,4arrows-4';
            case 'FiveArrowsGray':
                return '5arrowsgray-1,5arrowsgray-2,5arrowsgray-3,5arrowsgray-4,5arrowsgray-5';
            case 'FiveArrows':
                return '5arrows-1,5arrows-2,5arrows-3,5arrows-4,5arrows-5';
            case 'ThreeTrafficLights1':
                return '3trafficlights-1,3trafficlights-2,3trafficlights-3';
            case 'ThreeTrafficLights2':
                return '3rafficlights2-1,3rafficlights2-2,3rafficlights2-3';
            case 'ThreeSigns':
                return '3signs-1,3signs-2,3signs-3';
            case 'FourTrafficLights':
                return '4trafficlights-1,4trafficlights-2,4trafficlights-3,4trafficlights-4';
            case 'FourRedToBlack':
                return '4redtoblack-1,4redtoblack-2,4redtoblack-3,4redtoblack-4';
            case 'ThreeSymbols':
                return '3symbols-1,3symbols-2,3symbols-3';
            case 'ThreeSymbols2':
                return '3symbols2-1,3symbols2-2,3symbols2-3';
            case 'ThreeFlags':
                return '3flags-1,3flags-2,3flags-3';
            case 'FourRating':
                return '4rating-4,4rating-3,4rating-2,4rating-1';
            case 'FiveQuarters':
                return '5quarters-1,5quarters-2,5quarters-3,5quarters-4,5quarters-5';
            case 'FiveRating':
                return '5rating-5,5rating-4,5rating-3,5rating-2,5rating-1';
            case 'ThreeTriangles':
                return '3triangles-1,3triangles-2,3triangles-3';
            case 'ThreeStars':
                return '3stars-1,3stars-2,3stars-3';
            case 'FiveBoxes':
                return '5boxes-1,5boxes-2,5boxes-3,5boxes-4,5boxes-5';
        }
        return result;
    }
    applyDataBars(val, cf, td, rIdx, cellType, currentRowHeight) {
        const sheet = this.parent.getActiveSheet();
        const result = cf.result;
        let leftStandardWidth = 0;
        let topVal;
        let value;
        if (isNumber(val)) {
            value = parseFloat(val);
        }
        if ((result[0] === undefined && result[1] === undefined) || isNaN(value) || (isNumber(val) && cellType === 'Text')) {
            const dataBar = td.getElementsByClassName('e-cf-databar')[0];
            if (dataBar) {
                const textContent = dataBar.getElementsByClassName('e-databar-value')[0].textContent;
                const hyperlink = td.querySelector('.e-hyperlink');
                const noteIndicator = td.querySelector('.e-addNoteIndicator');
                const wrapText = td.querySelector('.e-wrap-content');
                if (wrapText) {
                    wrapText.textContent = '';
                    if (hyperlink) {
                        wrapText.appendChild(hyperlink);
                    }
                    else {
                        wrapText.innerText = textContent;
                    }
                }
                else {
                    td.removeChild(dataBar);
                    if (hyperlink) {
                        td.appendChild(hyperlink);
                    }
                    else {
                        td.innerText = textContent;
                    }
                }
                if (noteIndicator) {
                    td.appendChild(noteIndicator);
                }
            }
            return;
        }
        if (result[0] !== undefined && result[1] !== undefined) {
            topVal = result[0] + Math.abs(result[1]);
            leftStandardWidth = Math.abs((result[1] / topVal) * 100);
        }
        else if (result[0] !== undefined) {
            topVal = result[0];
        }
        else {
            topVal = result[1];
        }
        const databar = this.parent.createElement('div', { id: 'spreadsheet-databar', className: 'e-cf-databar' });
        const leftSpan = this.parent.createElement('span', { id: 'spreadsheet-leftspan', className: 'e-databar' });
        const rightSpan = this.parent.createElement('span', { id: 'spreadsheet-rightspan', className: 'e-databar' });
        const dataSpan = this.parent.createElement('span', { id: 'spreadsheet-dataspan', className: 'e-databar-value' });
        const iconSetSpan = td.querySelector('.e-iconsetspan');
        const noteIndicator = td.querySelector('.e-addNoteIndicator');
        const wrapText = td.querySelector('.e-wrap-content');
        const rowHeight = currentRowHeight ? currentRowHeight : getRowHeight(sheet, rIdx, true);
        const currencySpan = td.querySelector('#' + this.parent.element.id + '_currency');
        databar.style.height = rowHeight - 1 + 'px';
        if (iconSetSpan) {
            iconSetSpan.style.height = rowHeight - 1 + 'px';
            iconSetSpan.classList.add(td.style.verticalAlign === 'top' ? 'e-cf-icon-top' : td.style.verticalAlign === 'middle' ?
                'e-cf-icon-middle' : 'e-cf-icon-end');
        }
        if (currencySpan) {
            currencySpan.style.alignItems = td.style.verticalAlign === 'top' ? 'start' : td.style.verticalAlign === 'middle' ?
                'center' : 'end';
            currencySpan.classList.add('e-cf-currency');
        }
        let cfColor = cf.type[0];
        if (cfColor === 'L') {
            cfColor += 'B';
        }
        if (result[1] === undefined) {
            rightSpan.style.width = '' + Math.ceil(Math.abs((value / topVal) * 100)) + '%';
            rightSpan.style.height = rowHeight - 3 + 'px';
            rightSpan.style.backgroundColor = this.getColor(cfColor)[0];
            rightSpan.style.left = '0px';
        }
        else if (result[0] === undefined) {
            rightSpan.style.width = '' + Math.ceil(Math.abs((value / topVal) * 100)) + '%';
            rightSpan.style.height = rowHeight - 3 + 'px';
            rightSpan.style.backgroundColor = this.getColor('R')[0];
            rightSpan.style.left = '0px';
        }
        else if (value >= 0) {
            leftSpan.style.width = leftStandardWidth + '%';
            leftSpan.style.height = rowHeight - 3 + 'px'; // -3 buffer of data bar.
            leftSpan.style.backgroundColor = 'transparent';
            leftSpan.style.left = '0px';
            rightSpan.style.width = '' + Math.ceil(Math.abs((value / topVal) * 100)) + '%';
            rightSpan.style.height = rowHeight - 3 + 'px';
            rightSpan.style.backgroundColor = this.getColor(cfColor)[0];
            rightSpan.style.left = leftStandardWidth + '%';
        }
        else {
            leftSpan.style.width = '' + Math.ceil(Math.abs((value / topVal) * 100)) + '%';
            leftSpan.style.height = rowHeight - 3 + 'px';
            leftSpan.style.backgroundColor = this.getColor('R')[0];
            if (leftSpan.style.width === leftStandardWidth + '%') {
                leftSpan.style.left = '0px';
            }
            else {
                leftSpan.style.right = (100 - leftStandardWidth) + '%';
            }
        }
        dataSpan.style.fontSize = td.style.fontSize || '11pt';
        dataSpan.style.alignItems = td.style.verticalAlign === 'top' ? 'start' : td.style.verticalAlign === 'middle' ?
            'center' : 'end';
        dataSpan.style.textDecoration = td.style.textDecoration;
        const curEle = td.querySelector(`#${this.parent.element.id}_currency`);
        if (curEle) {
            databar.appendChild(curEle);
        }
        const hyperlink = td.querySelector('.e-hyperlink');
        if (hyperlink) {
            dataSpan.appendChild(hyperlink);
        }
        else {
            const dataContent = td.querySelector('.e-validation-list') ? td.innerText : td.textContent;
            dataSpan.innerText = dataContent;
            if (dataContent === '') {
                dataSpan.appendChild(document.createTextNode(dataContent));
            }
        }
        databar.appendChild(leftSpan);
        databar.appendChild(rightSpan);
        databar.appendChild(dataSpan);
        td.textContent = '';
        if (wrapText) {
            wrapText.textContent = '';
            if (iconSetSpan) {
                wrapText.appendChild(iconSetSpan);
            }
            wrapText.appendChild(databar);
            td.appendChild(wrapText);
        }
        else {
            if (iconSetSpan) {
                td.insertBefore(iconSetSpan, td.firstElementChild);
            }
            td.appendChild(databar);
        }
        if (noteIndicator) {
            td.appendChild(noteIndicator);
        }
    }
    getColor(cfColor) {
        if (cfColor === 'LB') {
            return ['#008aef'];
        }
        const colorCodeArr = cfColor.split('');
        const colorArr = [];
        for (let i = 0; i < colorCodeArr.length; i++) {
            switch (colorCodeArr[i]) {
                case 'G':
                    colorArr.push('#63be7b');
                    break;
                case 'Y':
                    colorArr.push('#ffeb84');
                    break;
                case 'R':
                    colorArr.push('#f8696b');
                    break;
                case 'W':
                    colorArr.push('#ffffff');
                    break;
                case 'B':
                    colorArr.push('#5a8ac6');
                    break;
                case 'O':
                    colorArr.push('#ffb628');
                    break;
                case 'LB':
                    colorArr.push('#008aef');
                    break;
                case 'P':
                    colorArr.push('#d6007b');
                    break;
            }
        }
        return colorArr;
    }
    getGradient(t, start, middle, end, large) {
        if (isNullOrUndefined(end)) {
            return this.getLinear(start, middle, t / large);
        }
        else {
            const center = large / 2;
            return t >= center ? this.getLinear(middle, end, Math.abs((t - center) / center)) : this.getLinear(start, middle, t / center);
        }
    }
    getLinear(s, e, x) {
        const r = this.byteLinear(s[1] + s[2], e[1] + e[2], x);
        const g = this.byteLinear(s[3] + s[4], e[3] + e[4], x);
        const b = this.byteLinear(s[5] + s[6], e[5] + e[6], x);
        return '#' + r + g + b;
    }
    byteLinear(a, b, x) {
        const y = (parseInt(a, 16) * (1 - x) + parseInt(b, 16) * x) | 0;
        return Math.abs(y).toString(16);
    }
    isGreaterThanLessThan(cf, value, input, cellType) {
        if (isNumber(value) && cellType !== 'Text') {
            if (isNumber(input)) {
                const txtRegx = new RegExp(/[^.-a-zA-Z 0-9]+/g);
                return cf.type === 'GreaterThan' ? parseFloat(value) > parseFloat(input.replace(txtRegx, '')) : parseFloat(value) <
                    parseFloat(input.replace(txtRegx, ''));
            }
            else {
                const dateEventArgs = {
                    value: input, rowIndex: 0, colIndex: 0, sheetIndex: 0,
                    isDate: false, updatedVal: '', isTime: false
                };
                this.parent.notify(checkDateFormat, dateEventArgs);
                if (dateEventArgs.isDate || dateEventArgs.isTime) {
                    cf.value = dateEventArgs.updatedVal.toString();
                    return cf.type === 'GreaterThan' ? Number(value) > Number(dateEventArgs.updatedVal) :
                        Number(value) < Number(dateEventArgs.updatedVal);
                }
                else if (input) {
                    return cf.type === 'GreaterThan' ? value.toLowerCase() > input.toLowerCase() : value.toLowerCase() < input.toLowerCase();
                }
            }
        }
        else if (value === '' && Number(input) > 0 && cf.type === 'LessThan') {
            return true;
        }
        return false;
    }
    isBetWeen(cf, value, input1, input2, isLongDate) {
        if (!isLongDate) {
            const txtRegx = new RegExp(/[^.-a-zA-Z 0-9]+/g);
            input1 = input1.replace(txtRegx, '');
            input2 = input2.replace(txtRegx, '');
        }
        if (isNumber(input1)) {
            let firstVal = parseFloat(input1);
            let secondVal = parseFloat(input2);
            if (firstVal > secondVal) {
                [firstVal, secondVal] = [secondVal, firstVal];
            }
            return parseFloat(value) >= firstVal && parseFloat(value) <= secondVal;
        }
        else if (input1 && input2) {
            const dateEventArgs1 = { value: input1, cell: {}, updatedVal: '' };
            const dateEventArgs2 = { value: input2, cell: {}, updatedVal: '' };
            this.parent.notify(checkDateFormat, dateEventArgs1);
            this.parent.notify(checkDateFormat, dateEventArgs2);
            if ((dateEventArgs1.isDate || dateEventArgs1.isTime) && (dateEventArgs2.isDate || dateEventArgs2.isTime)) {
                cf.value = dateEventArgs1.updatedVal + ',' + dateEventArgs2.updatedVal;
                if (dateEventArgs1.updatedVal > dateEventArgs2.updatedVal) {
                    [dateEventArgs1.updatedVal, dateEventArgs2.updatedVal] = [dateEventArgs2.updatedVal, dateEventArgs1.updatedVal];
                }
                return value >= dateEventArgs1.updatedVal && value <= dateEventArgs2.updatedVal;
            }
            else {
                return value.toLowerCase() >= input1.toLowerCase() && value.toLowerCase() <= input2.toLowerCase();
            }
        }
        return false;
    }
    isEqualTo(cf, value, input) {
        if (isNumber(input)) {
            if (value === '') {
                return parseFloat(input) === 0;
            }
            const txtRegx = new RegExp(/[^.-a-zA-Z 0-9]+/g);
            return parseFloat(value) === parseFloat(input.replace(txtRegx, ''));
        }
        else if (!value || !input) {
            return false;
        }
        else {
            const dateTimeArgs = { value: input, cell: {}, updatedVal: '' };
            this.parent.notify(checkDateFormat, dateTimeArgs);
            if (dateTimeArgs.isTime || dateTimeArgs.isDate) {
                cf.value = dateTimeArgs.updatedVal;
                return value === dateTimeArgs.updatedVal;
            }
            else {
                return value.toLowerCase() === input.toLowerCase();
            }
        }
    }
    isContainsText(value, input) {
        const txtRegx = new RegExp(/[^.-a-zA-Z 0-9]+/g);
        if (isNumber(input.replace(txtRegx, ''))) {
            input = input.replace(txtRegx, '');
            if (isDateTime(value)) {
                value = dateToInt(value).toString();
            }
            return value.indexOf(input) > -1;
        }
        else if (isDateTime(input)) {
            if (isDateTime(value)) {
                value = dateToInt(value).toString();
            }
            return value.indexOf(dateToInt(input).toString()) > -1;
        }
        else {
            return value.toLowerCase().indexOf(input.toLowerCase()) > -1;
        }
    }
    setCFStyle(style, cf) {
        switch (cf.cFColor) {
            case 'RedFT':
                style.backgroundColor = '#ffc7ce';
                style.color = '#9c0055';
                break;
            case 'YellowFT':
                style.backgroundColor = '#ffeb9c';
                style.color = '#9c6500';
                break;
            case 'GreenFT':
                style.backgroundColor = '#c6efce';
                style.color = '#006100';
                break;
            case 'RedF':
                style.backgroundColor = '#ffc7ce';
                break;
            case 'RedT':
                style.color = '#9c0055';
                break;
        }
        return style;
    }
    /**
     * Gets the module name.
     *
     * @returns {string} - Gets the module name.
     */
    getModuleName() {
        return 'conditionalFormatting';
    }
}

/**
 * AutoFill module allows to perform auto fill functionalities.
 */
class AutoFill {
    constructor(parent) {
        this.fillOptionIndex = 0;
        this.parent = parent;
        this.addEventListener();
    }
    getfillItems() {
        const l10n = this.parent.serviceLocator.getService(locale);
        return [
            { text: l10n.getConstant('CopyCells') },
            { text: l10n.getConstant('FillSeries') },
            { text: l10n.getConstant('FillFormattingOnly') },
            { text: l10n.getConstant('FillWithoutFormatting') }
        ];
    }
    createAutoFillElement() {
        if (this.parent.allowAutoFill) {
            const element = this.parent.getMainContent();
            const ele = this.parent.createElement('div', { className: 'e-autofill' });
            if (element.lastElementChild && element.lastElementChild.classList.contains('e-ss-overlay')) {
                element.insertBefore(ele, element.getElementsByClassName('e-ss-overlay')[0]);
            }
            else {
                element.appendChild(ele);
            }
            this.autoFillElement = ele;
            if (this.autoFillDropDown) {
                this.autoFillDropDown.destroy();
                this.autoFillDropDown = null;
            }
            this.getautofillDDB({ id: this.parent.element.id + '_autofilloptionbtn', appendElem: element });
        }
    }
    getautofillDDB(args) {
        this.splitBtnElem = this.parent.createElement('button', { id: args.id, className: 'e-filloption', attrs: { 'type': 'button' } });
        this.splitBtnElem.appendChild(this.parent.createElement('span', { className: 'e-tbar-btn-text' }));
        this.autoFillDropDown = new DropDownButton({
            cssClass: 'e-dragfill-ddb',
            iconCss: 'e-icons e-dragfill-icon',
            items: this.getfillItems(),
            createPopupOnClick: true,
            enableRtl: this.parent.enableRtl,
            select: (args) => {
                this.autoFillOptionClick({ type: this.getFillType(args.item.text) });
            },
            beforeOpen: () => this.autoFillClick()
        });
        this.autoFillDropDown.createElement = this.parent.createElement;
        this.autoFillDropDown.appendTo(this.splitBtnElem);
        args.appendElem.appendChild(this.splitBtnElem);
        return this.autoFillDropDown;
    }
    getFillType(text) {
        const l10n = this.parent.serviceLocator.getService(locale);
        let type;
        if (text === l10n.getConstant('CopyCells')) {
            type = 'CopyCells';
        }
        else if (text === l10n.getConstant('FillSeries')) {
            type = 'FillSeries';
        }
        else if (text === l10n.getConstant('FillFormattingOnly')) {
            type = 'FillFormattingOnly';
        }
        else {
            type = 'FillWithoutFormatting';
        }
        return type;
    }
    autoFillClick() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const fillInfo = { fillType: 'FillSeries', disableItems: [''] };
        this.parent.notify(getFillInfo, fillInfo);
        this.autoFillDropDown.setProperties({ 'items': this.getfillItems() }, true);
        this.autoFillDropDown.removeItems(fillInfo.disableItems);
        this.refreshAutoFillOption(l10n.getConstant(fillInfo.fillType));
    }
    getFillRange(pStartCell, pEndCell, pFillCell, direction) {
        switch (direction) {
            case 'Up':
                return [pFillCell.rowIndex, pStartCell.colIndex, pStartCell.rowIndex - 1, pEndCell.colIndex];
            case 'Right':
                return [pStartCell.rowIndex, pEndCell.colIndex + 1, pEndCell.rowIndex, pFillCell.colIndex];
            case 'Down':
                return [pEndCell.rowIndex + 1, pStartCell.colIndex, pFillCell.rowIndex, pEndCell.colIndex];
            case 'Left':
                return [pStartCell.rowIndex, pFillCell.colIndex, pEndCell.rowIndex, pStartCell.colIndex - 1];
        }
    }
    autoFillOptionClick(args) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const sheet = this.parent.getActiveSheet();
        const range = getSwapRange(getRangeIndexes(this.parent.selectionModule.dAutoFillCell));
        const currcell = getRangeIndexes(sheet.selectedRange);
        const minr = range[0];
        const minc = range[1];
        const maxr = range[2];
        const maxc = range[3];
        const dir = this.getDirection({ rowIndex: maxr, colIndex: maxc }, { rowIndex: currcell[2],
            colIndex: currcell[3] });
        const dataRange = [minr, minc, maxr, maxc];
        const fillRange = this.getFillRange({ rowIndex: minr, colIndex: minc }, { rowIndex: maxr, colIndex: maxc }, { rowIndex: currcell[2], colIndex: currcell[3] }, dir);
        this.refreshAutoFillOption(l10n.getConstant(args.type));
        const evtArgs = { isUndo: true, isPublic: true, preventReSelect: true,
            preventEvt: args.type === 'FillWithoutFormatting',
            setCollection: args.type === 'FillFormattingOnly' || args.type === 'FillWithoutFormatting', isFromAutoFillOption: true };
        this.parent.notify(performUndoRedo, evtArgs);
        const eventArgs = { dataRange: sheet.name + '!' + getRangeAddress(dataRange), fillRange: sheet.name + '!' + getRangeAddress(fillRange), direction: dir, fillType: args.type, isFillOptClick: true };
        this.isVerticalFill = eventArgs.direction === 'Down' || eventArgs.direction === 'Up';
        this.parent.notify(setAutoFill, eventArgs);
        this.positionAutoFillElement({ isautofill: true });
        const autoFillArgs = { dataRange: eventArgs.dataRange, fillRange: eventArgs.fillRange,
            fillType: eventArgs.fillType, direction: eventArgs.direction, selectedRange: sheet.name + '!' + getRangeAddress(currcell),
            undoArgs: evtArgs.undoArgs };
        this.parent.notify(completeAction, { eventArgs: autoFillArgs, action: 'autofill' });
        if (this.parent.showAggregate) {
            this.parent.notify(showAggregate, {});
        }
        this.autoFillClick();
    }
    refreshAutoFillOption(type) {
        for (let i = 0; i < this.autoFillDropDown.items.length; i++) {
            this.autoFillDropDown.items[i].iconCss = '';
        }
        for (let i = 0; i < this.autoFillDropDown.items.length; i++) {
            if (this.autoFillDropDown.items[i].text === type) {
                this.autoFillDropDown.items[i].iconCss = 'e-icons e-selected-icon';
            }
        }
        if (['Copy Cells', 'Fill Series', 'Fill Formatting Only', 'Fill Without Formatting'].indexOf(type) < 0) {
            this.autoFillDropDown.items[this.fillOptionIndex].iconCss = '';
        }
        this.autoFillDropDown.dataBind();
    }
    positionAutoFillElement(args) {
        let top = 0;
        let left = 0;
        const sheet = this.parent.getActiveSheet();
        const indexes = getSwapRange(getRangeIndexes(sheet.selectedRange));
        let tdiff = -5;
        let ldiff = -5;
        let otdiff = 6;
        let oldiff = 6;
        const isRowSelected = (indexes[1] === 0 && indexes[3] === sheet.colCount - 1);
        const isColSelected = (indexes[0] === 0 && indexes[2] === sheet.rowCount - 1);
        let rowIdx = indexes[2];
        let colIdx = indexes[3];
        let height;
        let width;
        let pos;
        const isRtl = this.parent.enableRtl;
        const cell = this.parent.getCell(rowIdx, colIdx);
        if (isHiddenCol(sheet, indexes[3]) || isHiddenRow(sheet, indexes[2]) ||
            (cell && cell.classList.contains('e-formularef-selection')) || (sheet.isProtected && sheet.protectSettings.selectUnLockedCells
            && isLockedCells(this.parent, indexes))) {
            this.hideAutoFillElement();
            return;
        }
        if ((sheet.isProtected && (sheet.protectSettings.selectCells || sheet.protectSettings.selectUnLockedCells)) || !sheet.isProtected) {
            if (isRowSelected) {
                tdiff = -5;
                ldiff = -1;
                otdiff = 6;
                oldiff = 2;
                rowIdx = indexes[2];
                colIdx = indexes[1];
            }
            else if (isColSelected) {
                ldiff = -5;
                tdiff = 0;
                otdiff = 1;
                oldiff = 6;
                rowIdx = indexes[0];
                colIdx = indexes[3];
            }
            if (sheet.frozenColumns || sheet.frozenRows) {
                if (isColSelected || isRowSelected) {
                    setPosition(this.parent, this.autoFillElement, indexes, 'e-autofill', args && args.preventAnimation);
                    if (this.parent.autoFillSettings.showFillOptions && args && args.isautofill) {
                        setPosition(this.parent, this.autoFillDropDown.element, indexes, 'e-filloption');
                    }
                }
                else {
                    setPosition(this.parent, this.autoFillElement, [rowIdx, colIdx, rowIdx, colIdx], 'e-autofill', args && args.preventAnimation);
                    if (this.parent.autoFillSettings.showFillOptions && args && args.isautofill) {
                        setPosition(this.parent, this.autoFillDropDown.element, [rowIdx, colIdx, rowIdx, colIdx], 'e-filloption');
                    }
                }
                if (this.autoFillElement) {
                    this.autoFillCell = { rowIndex: rowIdx, colIndex: colIdx };
                    const autoFillHandles = this.parent.element.querySelectorAll('.e-autofill');
                    if (autoFillHandles.length) {
                        const clientRect = autoFillHandles[0].getBoundingClientRect();
                        this.autoFillElementPosition = {
                            left: clientRect.left, top: clientRect.top
                        };
                        [].slice.call(autoFillHandles).forEach((autoFillElem) => {
                            removeClass([autoFillElem], 'e-hide');
                        });
                    }
                }
            }
            else {
                pos = getCellPosition(sheet, [rowIdx, colIdx, rowIdx, colIdx], this.parent.frozenRowCount(sheet), this.parent.frozenColCount(sheet), this.parent.viewport.beforeFreezeHeight, this.parent.viewport.beforeFreezeWidth, this.parent.sheetModule.colGroupWidth);
                height = getRowsHeight(sheet, rowIdx, rowIdx, true);
                width = getColumnsWidth(sheet, colIdx, colIdx, true);
                if (!isColSelected) {
                    top += height;
                }
                if (!isRowSelected) {
                    left += width;
                }
                top += Math.round(pos.top) + tdiff;
                left += Math.round(pos.left) + ldiff;
                if (this.autoFillElement) {
                    removeClass([this.autoFillElement], 'e-hide');
                    this.autoFillElement.style.top = top + 'px';
                    if (isRtl) {
                        this.autoFillElement.style.right = left + 'px';
                    }
                    else {
                        this.autoFillElement.style.left = left + 'px';
                    }
                    this.autoFillCell = { rowIndex: rowIdx, colIndex: colIdx };
                    const clientRect = this.autoFillElement.getBoundingClientRect();
                    this.autoFillElementPosition = {
                        left: clientRect.left, top: clientRect.top
                    };
                    if (this.parent.autoFillSettings.showFillOptions && args && args.isautofill) {
                        removeClass([this.autoFillDropDown.element], 'e-hide');
                        const sheetPanel = this.parent.element.querySelector('.e-main-panel');
                        const virtualable = this.parent.element.querySelector('.e-main-panel .e-sheet-content .e-virtualable');
                        const scroller = this.parent.element.querySelector('.e-sheet-panel .e-scrollbar .e-scroller');
                        const rowOffset = virtualable && virtualable.clientHeight < sheetPanel.clientHeight ?
                            (sheetPanel.clientHeight - virtualable.clientHeight) : 0;
                        const columnsOffset = virtualable && virtualable.clientWidth < sheetPanel.clientWidth ?
                            (sheetPanel.clientWidth - virtualable.clientWidth) : 0;
                        const autoFillDropDownRect = this.autoFillDropDown.element.getBoundingClientRect();
                        if ((sheetPanel.scrollTop + sheetPanel.clientHeight - rowOffset) < (top + autoFillDropDownRect.height)) {
                            top -= autoFillDropDownRect.height;
                        }
                        if ((scroller.scrollLeft + scroller.clientWidth - columnsOffset) < (left + autoFillDropDownRect.width)) {
                            left -= autoFillDropDownRect.width;
                        }
                        this.autoFillDropDown.element.style.top = top + otdiff + 'px';
                        if (isRtl) {
                            this.autoFillDropDown.element.style.right = left + oldiff + 'px';
                        }
                        else {
                            this.autoFillDropDown.element.style.left = left + oldiff + 'px';
                        }
                    }
                }
            }
        }
    }
    hideAutoFillElement() {
        const elem = this.parent.element;
        [].slice.call(elem.querySelectorAll('.e-autofill')).forEach((optElem) => {
            if (elem) {
                addClass([optElem], 'e-hide');
            }
        });
    }
    hideAutoFillOptions() {
        const elem = this.parent.element;
        [].slice.call(elem.querySelectorAll('.e-filloption')).forEach((optElem) => {
            if (elem) {
                addClass([optElem], 'e-hide');
            }
        });
    }
    selectAutoFillRange(args) {
        const rowObj = { clientY: getClientY(args.e), target: args.e.target };
        const colObj = { clientX: getClientX(args.e), target: args.e.target };
        const sheet = this.parent.getActiveSheet();
        this.parent.notify(getRowIdxFromClientY, rowObj);
        this.parent.notify(getColIdxFromClientX, colObj);
        let rangeIndexes;
        const autofillRange = this.getAutoFillRange({ rowIndex: rowObj.clientY, colIndex: colObj.clientX });
        if (autofillRange && autofillRange.fillRange) {
            rangeIndexes = [autofillRange.startCell.rowIndex, autofillRange.startCell.colIndex, autofillRange.endCell.rowIndex,
                autofillRange.endCell.colIndex];
        }
        else {
            rangeIndexes = getRangeIndexes(sheet.selectedRange);
        }
        args.indexes = rangeIndexes;
        return rangeIndexes;
    }
    getAutoFillRange(idx) {
        const sheet = this.parent.getActiveSheet();
        const aCell = this.autoFillCell;
        const range = getSwapRange(getRangeIndexes(sheet.selectedRange));
        const minr = range[0];
        const minc = range[1];
        const maxr = range[2];
        const maxc = range[3];
        const inRange = isInRange(range, [idx.rowIndex, idx.colIndex, idx.rowIndex, idx.colIndex], true);
        const minIdx = { rowIndex: minr, colIndex: minc };
        const scell = { rowIndex: range[0], colIndex: range[1] };
        const ecell = { rowIndex: range[2], colIndex: range[3] };
        const maxIdx = { rowIndex: maxr, colIndex: maxc };
        const modifiedIdx = this.modifyRangeForMerge(idx.rowIndex, idx.colIndex, aCell.rowIndex, aCell.colIndex, range);
        if (idx.rowIndex < aCell.rowIndex) { // up
            if ((minr - idx.rowIndex > idx.colIndex - maxc) && (minr - idx.rowIndex > minc - idx.colIndex)) {
                return inRange ? { startCell: minIdx, endCell: { rowIndex: idx.rowIndex, colIndex: maxc } } : { startCell: maxIdx, endCell: { rowIndex: modifiedIdx.rowIndex, colIndex: minc }, fillRange: [modifiedIdx.rowIndex, minc, minr - 1, maxc], direction: 'Up' };
            }
            else if (idx.colIndex > aCell.colIndex) {
                return { startCell: minIdx, endCell: { rowIndex: maxr, colIndex: idx.colIndex },
                    fillRange: [minr, maxc + 1, maxr, idx.colIndex], direction: 'Right' };
            }
            else if (idx.colIndex < aCell.colIndex) {
                return inRange ? { startCell: minIdx, endCell: maxIdx } : { startCell: maxIdx, endCell: { rowIndex: minr, colIndex: idx.colIndex }, fillRange: [minr, idx.colIndex, maxr, minc - 1], direction: 'Left' };
            }
            else {
                return { startCell: scell, endCell: ecell };
            }
        }
        else if (idx.colIndex > aCell.colIndex) { // right
            if ((idx.rowIndex - maxr > idx.colIndex - maxc)) {
                return { startCell: minIdx, endCell: { rowIndex: idx.rowIndex, colIndex: maxc },
                    fillRange: [maxr + 1, minc, idx.rowIndex, maxc], direction: 'Down' };
            }
            else {
                return { startCell: minIdx, endCell: { rowIndex: maxr, colIndex: modifiedIdx.colIndex },
                    fillRange: [minr, maxc + 1, maxr, modifiedIdx.colIndex], direction: 'Right' };
            }
        }
        else if (idx.colIndex < aCell.colIndex) { // left
            if ((idx.rowIndex - maxr > maxc - idx.colIndex) || ((idx.rowIndex - minr > maxc - idx.colIndex) && idx.rowIndex !== maxr)) {
                return { startCell: minIdx, endCell: { rowIndex: idx.rowIndex, colIndex: maxc },
                    fillRange: [maxr + 1, minc, idx.rowIndex, maxc], direction: 'Down' };
            }
            else {
                return inRange ? { startCell: minIdx, endCell: maxIdx } : { startCell: maxIdx, endCell: { rowIndex: minr, colIndex: modifiedIdx.colIndex }, fillRange: [minr, modifiedIdx.colIndex, maxr, minc - 1], direction: 'Left' };
            }
        }
        else if (idx.rowIndex > aCell.rowIndex) { // down
            return { startCell: minIdx, endCell: { rowIndex: modifiedIdx.rowIndex, colIndex: maxc },
                fillRange: [maxr + 1, minc, modifiedIdx.rowIndex, maxc], direction: 'Down' };
        }
        else if (idx.rowIndex === aCell.rowIndex && idx.colIndex === aCell.colIndex) {
            return { startCell: scell, endCell: ecell };
        }
        else {
            return { startCell: scell, endCell: ecell };
        }
    }
    modifyRangeForMerge(rowIdx, colIdx, autoFillRowIdx, autoFillColIdx, selRange) {
        const modifiedIdx = { rowIndex: rowIdx, colIndex: colIdx };
        if (this.isMergedRange(selRange)) {
            const selRowCount = selRange[2] - selRange[0] + 1;
            const selColCount = selRange[3] - selRange[1] + 1;
            let remainder;
            if (rowIdx < autoFillRowIdx) { // up
                remainder = (selRange[2] - rowIdx + 1) % selRowCount;
                if (remainder && rowIdx - (selRowCount - remainder) >= 0) {
                    modifiedIdx.rowIndex = rowIdx - (selRowCount - remainder);
                }
            }
            else if (colIdx > autoFillColIdx) { // right
                remainder = (colIdx - selRange[1] + 1) % selColCount;
                if (remainder) {
                    modifiedIdx.colIndex = colIdx + (selColCount - remainder);
                }
            }
            else if (colIdx < autoFillColIdx) { // left
                remainder = (selRange[3] - colIdx + 1) % selColCount;
                if (remainder && colIdx - (selColCount - remainder) >= 0) {
                    modifiedIdx.colIndex = colIdx - (selColCount - remainder);
                }
            }
            else if (rowIdx > autoFillRowIdx) { // down
                remainder = (rowIdx - selRange[0] + 1) % selRowCount;
                if (remainder) {
                    modifiedIdx.rowIndex = rowIdx + (selRowCount - remainder);
                }
            }
        }
        return modifiedIdx;
    }
    performAutoFill(args) {
        if (args.rangeInfo || !(args.event.clientX > this.autoFillElementPosition.left &&
            args.event.clientX < this.autoFillElementPosition.left + 10) ||
            !(args.event.clientY > this.autoFillElementPosition.top && args.event.clientY < this.autoFillElementPosition.top + 10)) {
            let autofillRange;
            if (args.rangeInfo) {
                autofillRange = args.rangeInfo;
            }
            else {
                const rowObj = {
                    clientY: getClientY(args.event), target: args.event.target
                };
                const colObj = {
                    clientX: getClientX(args.event), target: args.event.target
                };
                this.parent.notify(getRowIdxFromClientY, rowObj);
                this.parent.notify(getColIdxFromClientX, colObj);
                autofillRange = this.getAutoFillRange({ rowIndex: rowObj.clientY, colIndex: colObj.clientX });
            }
            const sheet = this.parent.getActiveSheet();
            if (autofillRange && autofillRange.fillRange) {
                const eventArgs = {
                    dataRange: sheet.name + '!' + args.dAutoFillCell,
                    fillRange: sheet.name + '!' + getRangeAddress(autofillRange.fillRange), direction: autofillRange.direction,
                    fillType: args.fillType || this.parent.autoFillSettings.fillType, cancel: false
                };
                const isReadonlyCells = isReadOnlyCells(this.parent, getRangeIndexes(args.dAutoFillCell)) ||
                    isReadOnlyCells(this.parent, autofillRange.fillRange);
                if (isReadonlyCells) {
                    this.parent.notify(readonlyAlert, null);
                    return;
                }
                this.parent.notify(beginAction, { eventArgs: eventArgs, action: 'autofill' });
                if (eventArgs.cancel) {
                    return;
                }
                const isLockedCell = isLockedCells(this.parent, autofillRange.fillRange);
                if (sheet.isProtected && isLockedCell) {
                    this.parent.notify(editAlert, null);
                    return;
                }
                if (args.rangeInfo) {
                    this.performAutoFillAction(eventArgs, null, isLockedCell);
                }
                else {
                    this.performAutoFillAction(eventArgs, autofillRange, isLockedCell);
                    this.positionAutoFillElement({ isautofill: true });
                }
            }
        }
        else {
            this.positionAutoFillElement({ isautofill: false });
        }
    }
    refreshCell(options) {
        this.parent.serviceLocator.getService('cell').refreshRange([options.rowIndex, options.colIndex, options.rowIndex, options.colIndex]);
    }
    getDirection(endCell, currcell, isVerticalFill) {
        isVerticalFill = isNullOrUndefined(isVerticalFill) ? this.isVerticalFill : isVerticalFill;
        if (isVerticalFill) {
            if (currcell.rowIndex < endCell.rowIndex) { // up
                return 'Up';
            }
            else if (currcell.rowIndex > endCell.rowIndex) { // down
                return 'Down';
            }
            else if (currcell.colIndex > endCell.colIndex) { // right
                return 'Right';
            }
            else if (currcell.colIndex < endCell.colIndex) { // left
                return 'Left';
            }
        }
        else {
            if (currcell.colIndex > endCell.colIndex) { // right
                return 'Right';
            }
            else if (currcell.colIndex < endCell.colIndex) { // left
                return 'Left';
            }
            else if (currcell.rowIndex < endCell.rowIndex) { // up
                return 'Up';
            }
            else if (currcell.rowIndex > endCell.rowIndex) { // down
                return 'Down';
            }
        }
        return null;
    }
    performAutoFillAction(args, autoFillRange, isLockedCell) {
        const sheet = this.parent.getActiveSheet();
        const l10n = this.parent.serviceLocator.getService(locale);
        if (this.isMergedRange(getRangeIndexes(args.fillRange))) {
            const dialogInst = this.parent.serviceLocator.getService(dialog);
            dialogInst.show({
                isModal: true, showCloseIcon: true, height: 180, width: 400, content: l10n.getConstant('AutoFillMergeAlertMsg'),
                buttons: [{
                        buttonModel: { content: this.parent.serviceLocator.getService(locale).getConstant('Ok'), isPrimary: true },
                        click: () => { dialogInst.hide(); this.parent.selectRange(args.dataRange); }
                    }],
                close: () => { dialogInst.hide(); this.parent.selectRange(args.dataRange); }
            }, false);
            return;
        }
        this.isVerticalFill = args.direction === 'Down' || args.direction === 'Up';
        this.parent.notify(setAutoFill, {
            dataRange: args.dataRange,
            fillRange: args.fillRange, direction: args.direction, fillType: args.fillType, isLockedCell: isLockedCell
        });
        const selRange = autoFillRange ? getRangeAddress([autoFillRange.startCell.rowIndex, autoFillRange.startCell.colIndex,
            autoFillRange.endCell.rowIndex, autoFillRange.endCell.colIndex]) : sheet.selectedRange;
        updateSelectedRange(this.parent, selRange, sheet);
        const autoFillArgs = { dataRange: args.dataRange, fillRange: args.fillRange, fillType: args.fillType, direction: args.direction,
            selectedRange: selRange };
        this.parent.notify(completeAction, {
            eventArgs: autoFillArgs, action: sheet.conditionalFormats && sheet.conditionalFormats.length > 0 &&
                sheet.conditionalFormats[sheet.conditionalFormats.length - 1].action === 'autofillWithCF' ? 'autofillWithCF' :
                'autofill'
        });
        this.parent.trigger('select', { range: this.parent.getActiveSheet().selectedRange });
        if (this.parent.showAggregate) {
            this.parent.notify(showAggregate, {});
        }
        this.parent.notify(refreshRibbonIcons, null);
    }
    getRangeData(options) {
        const arr = [];
        const sheet = this.parent.getActiveSheet();
        let minr = options.range[0];
        let minc = options.range[1];
        const maxr = options.range[2];
        const maxc = options.range[3];
        const minCol = minc;
        let cell;
        while (minr <= maxr) {
            if (isHiddenRow(sheet, minr)) {
                minr++;
                continue;
            }
            minc = minCol;
            while (minc <= maxc) {
                if (isHiddenCol(sheet, minc)) {
                    minc++;
                    continue;
                }
                cell = getCell(minr, minc, sheet);
                arr.push(cell);
                minc++;
            }
            minr++;
        }
        return arr;
    }
    isMergedRange(range) {
        let i = 0;
        const data = this.getRangeData({ range: range, sheetIdx: this.parent.activeSheetIndex });
        for (i = 0; i < data.length; i++) {
            if (data[i] && (data[i].rowSpan || data[i].colSpan)) {
                return true;
            }
        }
        return false;
    }
    addEventListener() {
        this.parent.on(contentLoaded, this.createAutoFillElement, this);
        this.parent.on(positionAutoFillElement, this.positionAutoFillElement, this);
        this.parent.on(hideAutoFillOptions, this.hideAutoFillOptions, this);
        this.parent.on(hideAutoFillElement, this.hideAutoFillElement, this);
        this.parent.on(performAutoFill, this.performAutoFill, this);
        this.parent.on(selectAutoFillRange, this.selectAutoFillRange, this);
        this.parent.on(refreshCell, this.refreshCell, this);
        this.parent.on(getautofillDDB, this.getautofillDDB, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(contentLoaded, this.createAutoFillElement);
            this.parent.off(positionAutoFillElement, this.positionAutoFillElement);
            this.parent.off(hideAutoFillOptions, this.hideAutoFillOptions);
            this.parent.off(hideAutoFillElement, this.hideAutoFillElement);
            this.parent.off(performAutoFill, this.performAutoFill);
            this.parent.off(selectAutoFillRange, this.selectAutoFillRange);
            this.parent.off(refreshCell, this.refreshCell);
            this.parent.off(getautofillDDB, this.getautofillDDB);
        }
    }
    /**
     * Destroy AutoFill module.
     *
     * @returns {void} - Destroy auto fill module.
     */
    destroy() {
        this.removeEventListener();
        if (this.autoFillElement) {
            this.autoFillElement.remove();
        }
        this.autoFillElement = null;
        this.autoFillElementPosition = null;
        this.autoFillCell = null;
        if (this.autoFillDropDown) {
            this.autoFillDropDown.destroy();
        }
        this.autoFillDropDown = null;
        this.isVerticalFill = null;
        this.fillOptionIndex = null;
        if (this.splitBtnElem) {
            removeAllChildren(this.splitBtnElem);
            this.splitBtnElem.remove();
        }
        this.splitBtnElem = null;
        this.parent = null;
    }
    /**
     * Get the AutoFill module name.
     *
     * @returns {string} - Get the auto fill module name.
     */
    getModuleName() {
        return 'autofill';
    }
}

/**
 * `Note` module
 */
class SpreadsheetNote {
    /**
     * Constructor for Note module.
     *
     * @param {Spreadsheet} parent - Constructor for Note module.
     */
    constructor(parent) {
        /** @hidden */
        this.isNoteVisible = false;
        /** @hidden */
        this.isNoteVisibleOnTouch = false;
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * To destroy the Note module.
     *
     * @returns {void} - To destroy the Note module.
     */
    destroy() {
        this.removeEventListener();
        if (!this.parent.isDestroyed && !this.parent.refreshing) {
            const noteIndicators = this.parent.element.getElementsByClassName('e-addNoteIndicator');
            while (noteIndicators.length) {
                const cellEle = closest(noteIndicators[0], '.e-cell');
                if (cellEle) {
                    EventHandler.remove(cellEle, 'mouseover', this.mouseOver);
                    EventHandler.remove(cellEle, 'mouseout', this.mouseOut);
                }
                detach(noteIndicators[0]);
            }
        }
        this.parent = null;
        this.isNoteVisible = null;
    }
    addEventListener() {
        this.parent.on(addNote, this.addNote, this);
        this.parent.on(editNote, this.editNote, this);
        this.parent.on(deleteNote, this.deleteNote, this);
        this.parent.on(createNoteIndicator, this.createNoteIndicator, this);
        this.parent.on(showNote, this.showNote, this);
        this.parent.on(removeNoteContainer, this.removeNoteContainer, this);
        this.parent.on(updateNoteContainer, this.updateNoteContainer, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(addNote, this.addNote);
            this.parent.off(editNote, this.editNote);
            this.parent.off(showNote, this.showNote);
            this.parent.off(deleteNote, this.deleteNote);
            this.parent.off(createNoteIndicator, this.createNoteIndicator);
            this.parent.off(removeNoteContainer, this.removeNoteContainer);
            this.parent.off(updateNoteContainer, this.updateNoteContainer);
        }
    }
    /**
     * Gets the module name.
     *
     * @returns {string} - Gets the module name.
     */
    getModuleName() {
        return 'spreadsheetNote';
    }
    addNote() {
        const cellIndexes = !isNullOrUndefined(this.noteCellIndexes) ?
            this.noteCellIndexes : getCellIndexes(this.parent.getActiveSheet().activeCell);
        const targetElement = this.parent.getCell(cellIndexes[0], cellIndexes[1]);
        if (!isNullOrUndefined(targetElement) && ((targetElement.children.length === 0) || (targetElement.children.length > 0 && targetElement.children[targetElement.childElementCount - 1].className.indexOf('e-addNoteIndicator') === -1))) {
            this.createNoteIndicator({ targetElement: targetElement, rowIndex: cellIndexes[0], columnIndex: cellIndexes[1] });
            this.createNoteContainer(targetElement, cellIndexes[0], cellIndexes[1], false, true);
        }
    }
    deleteNote(args) {
        const cellIndexes = getCellIndexes(this.parent.getActiveSheet().activeCell);
        const rowIndex = !isNullOrUndefined(args) && !isNullOrUndefined(args.rowIndex) ? args.rowIndex : cellIndexes[0];
        const columnIndex = !isNullOrUndefined(args) && !isNullOrUndefined(args.columnIndex) ? args.columnIndex : cellIndexes[1];
        const targetElement = this.parent.getCell(rowIndex, columnIndex);
        if (targetElement.children.length > 0 && targetElement.children[targetElement.children.length - 1].className.indexOf('e-addNoteIndicator') > -1) {
            targetElement.removeChild(targetElement.children[targetElement.children.length - 1]);
            EventHandler.remove(targetElement, 'mouseover', this.mouseOver);
            EventHandler.remove(targetElement, 'mouseout', this.mouseOut);
            const address = getSheetName(this.parent, this.parent.activeSheetIndex) + '!' + this.parent.getActiveSheet().activeCell;
            const cell = getCell(rowIndex, columnIndex, this.parent.getActiveSheet());
            if (!isNullOrUndefined(args) && args.isDeleteFromMenu) {
                this.parent.notify(setActionData, { args: { action: 'beforeCellSave', eventArgs: { address: address } } });
            }
            if (!isNullOrUndefined(cell) && cell.notes) {
                delete cell.notes;
            }
            if (!isNullOrUndefined(args) && args.isDeleteFromMenu) {
                const eventArgs = { notes: cell.notes, address: address };
                this.parent.notify(completeAction, { eventArgs: eventArgs, action: 'deleteNote' });
                this.isShowNote = null;
            }
        }
    }
    editNote() {
        const cellIndexes = !isNullOrUndefined(this.noteCellIndexes) ?
            this.noteCellIndexes : getCellIndexes(this.parent.getActiveSheet().activeCell);
        this.showNote({ rowIndex: cellIndexes[0], columnIndex: cellIndexes[1], isNoteEditable: true });
        const noteContainerElement = document.getElementsByClassName('e-addNoteContainer')[0];
        updateCell(this.parent, this.parent.getActiveSheet(), { rowIdx: cellIndexes[0], colIdx: cellIndexes[1], preventEvt: true,
            cell: { isNoteEditable: true } });
        if (noteContainerElement) {
            this.getNoteFocus(noteContainerElement);
        }
    }
    createNoteIndicator(args) {
        const noteIndicator = this.parent.createElement('div', { className: 'e-addNoteIndicator', styles: 'position: absolute;top: 0;right: 0;width: 0;height: 0;border-left: 8px solid transparent;border-top: 8px solid red;cursor: pointer;' });
        if (args.targetElement.children.length > 0) {
            const rowHeight = getRowHeight(this.parent.getActiveSheet(), args.rowIndex);
            const defaultFilterButtonHeight = 20;
            for (let i = 0; i < args.targetElement.childElementCount; i++) {
                if (args.targetElement.children[i].className.indexOf('e-filter-btn') > -1) {
                    noteIndicator.style.right = (rowHeight < (defaultFilterButtonHeight + 10) ?
                        (args.targetElement.children[i].getBoundingClientRect().width <= 0 ? defaultFilterButtonHeight :
                            args.targetElement.children[i].getBoundingClientRect().width) : 0 + 2) + 'px';
                }
                if (args.targetElement.children[i].className.indexOf('e-validation-list') > -1) {
                    noteIndicator.style.right = `${(args.targetElement.children[i].getBoundingClientRect().width || 20) + 2}px`;
                }
            }
        }
        if (!isNullOrUndefined(args.targetElement) && (args.targetElement.children.length === 0) || (args.targetElement.children.length > 0 && args.targetElement.children[args.targetElement.childElementCount - 1].className.indexOf('e-addNoteIndicator') === -1)) {
            if (!args.skipEvent) {
                EventHandler.add(args.targetElement, 'mouseover', this.mouseOver, [this, args.rowIndex, args.columnIndex]);
                EventHandler.add(args.targetElement, 'mouseout', this.mouseOut, this);
            }
            args.targetElement.appendChild(noteIndicator);
        }
    }
    mouseOver() {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const args = this;
        const noteModule = args[0];
        if ((noteModule.isNoteVisibleOnTouch && !isNullOrUndefined(document.getElementsByClassName('e-addNoteContainer')[0])) ||
            isNullOrUndefined(document.getElementsByClassName('e-addNoteContainer')[0])) {
            if (!isNullOrUndefined(document.getElementsByClassName('e-addNoteContainer')[0])) {
                noteModule.removeNoteContainer();
            }
            noteModule.showNote({ rowIndex: args[1], columnIndex: args[2], isNoteEditable: false });
            noteModule.isNoteVisible = true;
        }
    }
    mouseOut(e) {
        if (this.isNoteVisible && (!this.isNoteVisibleOnTouch && !isNullOrUndefined(document.getElementsByClassName('e-addNoteContainer')[0]))) {
            if (document.activeElement.className.indexOf('e-addNoteContainer') === -1 && !isNullOrUndefined(e.relatedTarget) && e.relatedTarget.className.indexOf('e-connectorLine') === -1 && e.relatedTarget.className.indexOf('e-addNoteContainer') === -1) {
                this.removeNoteContainer();
                this.isNoteVisible = false;
            }
        }
    }
    createNoteContainer(targetElement, rowIndex, columnIndex, isShowNote, isNoteEditable) {
        const sheet = this.parent.getActiveSheet();
        const cell = getCell(rowIndex, columnIndex, sheet);
        const cellRect = targetElement.getBoundingClientRect();
        const noteContainer = this.parent.createElement('textarea', { className: 'e-addNoteContainer' });
        this.createContainer(noteContainer, cell, cellRect, isShowNote);
        this.createConnectorLine(noteContainer, cellRect);
        if (isNoteEditable) {
            this.getNoteFocus(noteContainer);
        }
        EventHandler.add(noteContainer, 'mouseout', this.mouseOut, this);
        EventHandler.add(document.getElementsByClassName('e-connectorLine')[0], 'mouseout', this.mouseOut, this);
    }
    getNoteFocus(noteContainerElement) {
        noteContainerElement.selectionStart = noteContainerElement.value.length;
        noteContainerElement.focus();
    }
    createContainer(noteContainer, cell, cellRect, isShowNote) {
        let containerTop = 5;
        if (!isNullOrUndefined(document.getElementsByClassName('e-select-all-cell')[0]) && !isNullOrUndefined(document.getElementsByClassName('e-scroller')[0]) &&
            cellRect.top >= document.getElementsByClassName('e-select-all-cell')[0].getBoundingClientRect().bottom && cellRect.right >= document.getElementsByClassName('e-select-all-cell')[0].getBoundingClientRect().right &&
            cellRect.bottom <= document.getElementsByClassName('e-scroller')[0].getBoundingClientRect().top && cellRect.right <= document.getElementsByClassName('e-scroller')[0].getBoundingClientRect().width) {
            noteContainer.style.display = 'block';
            containerTop = cellRect.top === document.getElementsByClassName('e-select-all-cell')[0].getBoundingClientRect().bottom ? 0 : containerTop;
        }
        else {
            noteContainer.style.display = 'none';
        }
        const elementClientRect = this.parent.element.getBoundingClientRect();
        const elementPosition = this.parent.element.style.getPropertyValue('position');
        noteContainer.style.position = 'absolute';
        noteContainer.style.top = (cellRect.top - (elementClientRect.top - (elementPosition === 'absolute' ? 0 :
            this.parent.element.offsetTop)) - containerTop) + 'px';
        noteContainer.style.left = (cellRect.left + cellRect.width - (elementClientRect.left - (elementPosition === 'absolute' ?
            0 : this.parent.element.offsetLeft)) + 10) + 'px';
        noteContainer.style.width = '120px';
        noteContainer.style.height = '120px';
        noteContainer.style.zIndex = '5';
        noteContainer.style.color = 'black';
        noteContainer.style.backgroundColor = 'lightyellow';
        if (isShowNote && !isNullOrUndefined(cell) && !isNullOrUndefined(cell.notes)) {
            noteContainer.innerHTML = cell.notes;
        }
        else {
            noteContainer.innerHTML = '';
        }
        this.parent.element.appendChild(noteContainer);
    }
    createConnectorLine(noteContainer, cellRect) {
        const connectorLine = this.parent.createElement('canvas', { className: 'e-connectorLine', styles: 'width: 100px; position: absolute;  z-index: 1;' });
        const context = connectorLine.getContext('2d');
        const elementClientRect = this.parent.element.getBoundingClientRect();
        const elementPosition = this.parent.element.style.getPropertyValue('position');
        connectorLine.style.left = cellRect.left + cellRect.width - (elementClientRect.left - (elementPosition === 'absolute' ?
            0 : this.parent.element.offsetLeft)) + 'px';
        connectorLine.style.top = (noteContainer.getBoundingClientRect().top - (elementClientRect.top - (elementPosition === 'absolute' ?
            0 : this.parent.element.offsetTop)) - 5) + 'px';
        context.clearRect(0, 0, connectorLine.width, connectorLine.height);
        context.beginPath();
        if (noteContainer.getBoundingClientRect().top === cellRect.top) {
            context.moveTo(0, 16);
            context.lineTo(30, 15);
        }
        else {
            context.moveTo(0, 30);
            context.lineTo(30, 15);
        }
        context.strokeStyle = 'black';
        context.lineWidth = 5;
        context.stroke();
        this.parent.element.appendChild(connectorLine);
        if (noteContainer.getBoundingClientRect().top > 0) {
            connectorLine.style.display = 'block';
            connectorLine.style.zIndex = '4';
        }
        else {
            connectorLine.style.display = 'none';
        }
    }
    showNote(args) {
        const targetElement = !isNullOrUndefined(this.parent.getCell(args.rowIndex, args.columnIndex)) ?
            this.parent.getCell(args.rowIndex, args.columnIndex) : args.cellElement;
        const contextMenuElement = document.getElementById(this.parent.element.id + '_contextmenu');
        const contextMenuDisplayStyle = !isNullOrUndefined(contextMenuElement) ? contextMenuElement.style.getPropertyValue('display') : 'none';
        const showNoteOverContextMenu = args.isNoteEditable ? true : contextMenuDisplayStyle !== 'block';
        if (!isNullOrUndefined(targetElement) && isNullOrUndefined(document.getElementsByClassName('e-addNoteContainer')[0]) && showNoteOverContextMenu
            && (args.isScrollWithNote || (targetElement.children !== null && targetElement.children.length > 0 && targetElement.children[targetElement.children.length - 1].classList.contains('e-addNoteIndicator')))) {
            this.createNoteContainer(targetElement, args.rowIndex, args.columnIndex, true, args.isNoteEditable);
            this.noteCellIndexes = [args.rowIndex, args.columnIndex];
        }
    }
    removeNoteContainer() {
        EventHandler.remove(document.getElementsByClassName('e-addNoteContainer')[0], 'mouseout', this.mouseOut);
        EventHandler.remove(document.getElementsByClassName('e-connectorLine')[0], 'mouseout', this.mouseOut);
        this.parent.element.removeChild(document.getElementsByClassName('e-addNoteContainer')[0]);
        this.parent.element.removeChild(document.getElementsByClassName('e-connectorLine')[0]);
        this.noteCellIndexes = null;
        this.isNoteVisible = false;
        this.isNoteVisibleOnTouch = false;
    }
    updateNoteContainer() {
        this.parent.selectionModule.isNoteActiveElement = document.activeElement.className.indexOf('e-addNoteContainer') > -1 ? true : this.parent.selectionModule.isNoteActiveElement;
        const cellIdxs = !isNullOrUndefined(this.noteCellIndexes) ?
            this.noteCellIndexes : getCellIndexes(this.parent.getActiveSheet().activeCell);
        const cell = getCell(cellIdxs[0], cellIdxs[1], this.parent.getActiveSheet());
        const noteContainer = document.getElementsByClassName('e-addNoteContainer')[0];
        if (((isNullOrUndefined(cell) || isNullOrUndefined(cell.notes)) || (cell.notes !== noteContainer.value))
            && this.parent.selectionModule.isNoteActiveElement) {
            const address = getSheetName(this.parent, this.parent.activeSheetIndex) + '!' + getRangeAddress(cellIdxs);
            this.parent.notify(setActionData, { args: { action: 'beforeCellSave', eventArgs: { address: address } } });
            const eventAction = !isNullOrUndefined(cell) && cell.notes ? 'editNote' : 'addNote';
            updateCell(this.parent, this.parent.getActiveSheet(), { rowIdx: cellIdxs[0], colIdx: cellIdxs[1], preventEvt: true,
                cell: { notes: noteContainer.value, isNoteEditable: true } });
            const eventArgs = { notes: noteContainer.value, address: address };
            this.parent.notify(completeAction, { eventArgs: eventArgs, action: eventAction });
            this.isShowNote = null;
        }
        this.isShowNote = isNullOrUndefined(this.isShowNote) ? this.parent.selectionModule.isNoteActiveElement : this.isShowNote;
        if (this.isShowNote) {
            const isScrollWithNote = !isNullOrUndefined(cell) && !isNullOrUndefined(cell.isNoteEditable) ?
                cell.isNoteEditable : false;
            this.parent.notify(removeNoteContainer, '');
            this.parent.notify(showNote, { rowIndex: cellIdxs[0], columnIndex: cellIdxs[1], isNoteEditable: true, isScrollWithNote: isScrollWithNote });
        }
        else {
            this.parent.notify(removeNoteContainer, '');
            this.isShowNote = null;
        }
    }
}

/**
 * Dialog Service.
 *
 * @hidden
 */
class Dialog {
    /**
     * Constructor for initializing dialog service.
     *
     * @param {Spreadsheet} parent - Specifies the Spreadsheet instance.
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * To show dialog.
     *
     * @param {DialogModel} dialogModel - Specifies the Dialog model.
     * @param {boolean} cancelBtn - Specifies the cancel button.
     * @returns {void}
     */
    show(dialogModel, cancelBtn) {
        let btnContent;
        cancelBtn = isNullOrUndefined(cancelBtn) ? true : false;
        const beforeOpenHandler = dialogModel.beforeOpen || null;
        const closeHandler = dialogModel.close || null;
        const model = {
            header: 'Spreadsheet',
            cssClass: this.parent.cssClass,
            target: this.parent.element,
            buttons: [],
            allowDragging: true
        };
        dialogModel.beforeOpen = (args) => {
            if (beforeOpenHandler) {
                beforeOpenHandler(args);
                if (args.cancel) {
                    this.hide(true);
                    if (!args.preventFocus) {
                        focus(this.parent.element);
                    }
                }
            }
        };
        dialogModel.close = () => {
            this.destroyDialog();
            if (closeHandler) {
                closeHandler();
            }
        };
        extend(model, dialogModel);
        if (cancelBtn) {
            btnContent = this.parent.serviceLocator.getService(locale).getConstant(model.buttons.length ? 'Cancel' : 'Ok');
            model.buttons.push({
                buttonModel: { content: btnContent, isPrimary: model.buttons.length === 0 },
                click: this.hide.bind(this)
            });
        }
        const div = this.parent.createElement('div');
        document.body.appendChild(div);
        this.dialogInstance = new Dialog$1(model);
        this.dialogInstance.createElement = this.parent.createElement;
        this.dialogInstance.appendTo(div);
        if (this.dialogInstance) {
            this.dialogInstance.refreshPosition();
        }
    }
    /**
     * To destroy the dialog if it open is prevented by user.
     *
     * @returns {void}
     */
    destroyDialog() {
        this.dialogInstance.destroy();
        remove(this.dialogInstance.element);
        this.dialogInstance = null;
    }
    /**
     * To hide dialog.
     *
     * @param {DialogModel} disableAnimation - To disable the animation while hiding the dialog.
     * @returns {void}
     */
    hide(disableAnimation) {
        if (this.dialogInstance) {
            if (disableAnimation) {
                this.dialogInstance.animationSettings.effect = 'None';
                this.dialogInstance.dataBind();
            }
            this.dialogInstance.hide();
        }
    }
    /**
     * To clear private variables.
     *
     * @returns {void}
     */
    destroy() {
        this.parent = null;
    }
}

/**
 *  Begin and complete events.
 *
 * @hidden
 */
class ActionEvents {
    /**
     * Constructor for initializing action begin and action complete services.
     *
     * @param {Spreadsheet} parent - Specifies the spreadsheet element.
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
        //this.initializeActionBegin();
        //this.initializeActionComplete();
    }
    initializeActionBegin() {
        const cellFormat = this.parent.beforeCellFormat;
        this.parent.beforeCellFormat = (args) => {
            this.actionEventHandler({ evtArgs: args, evtFunc: cellFormat, actionType: 'begin', eventType: 'format' });
        };
        const beforeOpen = this.parent.beforeOpen;
        this.parent.beforeOpen = (args) => {
            this.actionEventHandler({ evtArgs: args, evtFunc: beforeOpen, actionType: 'begin', eventType: 'beforeOpen' });
        };
        const beforeSave = this.parent.beforeSave;
        this.parent.beforeSave = (args) => {
            this.actionEventHandler({ evtArgs: args, evtFunc: beforeSave, actionType: 'begin', eventType: 'beforeSave' });
        };
        const beforeSort = this.parent.beforeSort;
        this.parent.beforeSort = (args) => {
            this.actionEventHandler({ evtArgs: args, evtFunc: beforeSort, actionType: 'begin', eventType: 'beforeSort' });
        };
    }
    initializeActionComplete() {
        const sortComplete = this.parent.sortComplete;
        this.parent.sortComplete = (args) => {
            this.actionEventHandler({ evtArgs: args, evtFunc: sortComplete, actionType: 'complete', eventType: 'sorting' });
        };
        const cellSave = this.parent.cellSave;
        this.parent.cellSave = (args) => {
            this.actionEventHandler({ evtArgs: args, evtFunc: cellSave, actionType: 'complete', eventType: 'cellSave' });
        };
    }
    actionEventHandler(args) {
        if (args.evtFunc) {
            args.evtFunc.apply(this, [args]);
        }
        if (args.actionType === 'begin') {
            this.actionBeginHandler({ eventArgs: args.evtArgs, action: args.eventType });
        }
        else {
            this.actionCompleteHandler({ eventArgs: args.evtArgs, action: args.eventType });
        }
    }
    actionBeginHandler(args) {
        const preventAction = args.preventAction;
        delete args.preventAction;
        const actionArgs = { action: args.action };
        if (args.isUndo) {
            actionArgs.isUndo = true;
            delete args.isUndo;
        }
        if (args.isRedo) {
            actionArgs.isUndo = false;
            delete args.isRedo;
        }
        actionArgs.args = args;
        this.parent.trigger('actionBegin', actionArgs);
        if (!preventAction && !this.parent.isPrintingProcessing && (args.action === 'clipboard' || args.action === 'format' ||
            args.action === 'cellSave' || args.action === 'addNote' || args.action === 'editNote' || args.action === 'deleteNote' ||
            args.action === 'beforeWrap' || args.action === 'beforeReplace' || args.action === 'filter' || args.action === 'beforeClear' ||
            args.action === 'beforeInsertImage' || args.action === 'beforeInsertChart' || args.action === 'chartDesign' ||
            args.action === 'cellDelete' || args.action === 'autofill' || args.action === 'validation' ||
            args.action === 'removeValidation' || args.action === 'hyperlink' || args.action === 'removeHyperlink' || args.action === 'deleteImage')) {
            this.parent.notify(setActionData, { args: args });
        }
        if (preventAction) {
            args.preventAction = true;
        }
        if (actionArgs.isUndo) {
            args.isUndo = true;
        }
        if (actionArgs.isUndo === false) {
            args.isRedo = true;
        }
    }
    actionCompleteHandler(args) {
        const preventAction = args.preventAction;
        delete args.preventAction;
        this.parent.notify(triggerDataChange, args);
        if (!args.preventEventTrigger) {
            this.parent.trigger('actionComplete', args);
        }
        if (!preventAction && args.action !== 'undoRedo' && args.action !== 'gotoSheet') {
            this.parent.notify(updateUndoRedoCollection, { args: args });
        }
        this.parent.notify(positionAutoFillElement, null);
    }
    addEventListener() {
        this.parent.on(completeAction, this.actionCompleteHandler, this);
        this.parent.on(beginAction, this.actionBeginHandler, this);
        this.parent.on(spreadsheetDestroyed, this.removeEventListener, this);
    }
    removeEventListener() {
        this.parent.off(completeAction, this.actionCompleteHandler);
        this.parent.off(beginAction, this.actionBeginHandler);
        this.parent.off(spreadsheetDestroyed, this.removeEventListener);
    }
}

/**
 * Specifes to create or modify overlay.
 *
 * @hidden
 */
class Overlay {
    /**
     * Constructor for initializing Overlay service.
     *
     *  @param {Spreadsheet} parent - Specifies the Spreadsheet instance.
     */
    constructor(parent) {
        this.minHeight = '300px';
        this.minWidth = '400px';
        this.isOverlayClicked = false;
        this.isResizerClicked = false;
        this.currentWidth = 400;
        this.currenHeight = 300;
        this.parent = parent;
        this.parent.on(selectionStatus, this.isOverlaySelected, this);
        this.parent.on(refreshOverlayElem, this.refreshOverlayElem, this);
        this.parent.on(spreadsheetDestroyed, this.destroy, this);
    }
    /**
     * To insert a shape.
     *
     * @param {string} id - Specifies the id.
     * @param {string} range - Specifies the range.
     * @param {number} sheetIndex - Specifies the sheet index.
     * @returns {HTMLElement} - Returns div element
     * @hidden
     */
    insertOverlayElement(id, range, sheetIndex) {
        const div = this.parent.createElement('div', {
            id: id,
            attrs: { 'class': 'e-ss-overlay' },
            styles: 'width: ' + this.minWidth + ';  height: ' + this.minHeight
        });
        if (this.parent.allowEditing) {
            const actOverlayElem = this.parent.element.getElementsByClassName('e-ss-overlay-active')[0];
            if (actOverlayElem) {
                removeClass([actOverlayElem], 'e-ss-overlay-active');
                this.parent.notify(removeDesignChart, {});
            }
            div.classList.add('e-ss-overlay-active');
        }
        const indexes = getRangeIndexes(range);
        const sheet = this.parent.sheets[sheetIndex];
        const frozenRow = this.parent.frozenRowCount(sheet);
        const frozenCol = this.parent.frozenColCount(sheet);
        const pos = getCellPosition(sheet, indexes, frozenRow, frozenCol, this.parent.viewport.beforeFreezeHeight, this.parent.viewport.beforeFreezeWidth, this.parent.sheetModule.colGroupWidth, true);
        if (indexes[0] >= frozenRow && indexes[1] < frozenCol) {
            const mainPanel = this.parent.sheetModule.contentPanel;
            if (mainPanel.scrollTop) {
                pos.top -= mainPanel.scrollTop;
                pos.top +=
                    this.parent.getColumnHeaderContent().parentElement.getBoundingClientRect().height;
            }
        }
        if (indexes[1] >= frozenCol && indexes[0] < frozenRow) {
            const scrollPanel = this.parent.getScrollElement();
            if (scrollPanel.scrollLeft) {
                pos.left -= scrollPanel.scrollLeft;
                pos.left += this.parent.sheetModule.getRowHeaderWidth(sheet);
            }
        }
        let parent;
        if (indexes[0] < frozenRow || indexes[1] < frozenCol) {
            parent = this.parent.element.querySelector('#' + this.parent.element.id + '_sheet');
            if (frozenRow) {
                if (indexes[0] >= frozenRow) {
                    pos.top += (sheet.showHeaders ? 31 : 0) + getRowsHeight(sheet, getCellIndexes(sheet.topLeftCell)[0], frozenRow - 1);
                }
                else if (!frozenCol) {
                    pos.left += this.parent.sheetModule.getRowHeaderWidth(sheet, true);
                }
            }
            if (frozenCol) {
                if (indexes[1] >= frozenCol) {
                    pos.left += this.parent.sheetModule.getRowHeaderWidth(sheet);
                }
                else if (!frozenRow) {
                    pos.left += (sheet.showHeaders ? 31 : 0);
                }
            }
        }
        else {
            parent = this.parent.getMainContent();
        }
        div.style.top = Number(addDPRValue(pos.top).toFixed(2)) + 'px';
        div.style.left = Number(addDPRValue(pos.left).toFixed(2)) + 'px';
        if (sheetIndex === this.parent.activeSheetIndex) {
            parent.appendChild(div);
            this.renderResizeHandler(div);
            this.addEventListener(div);
        }
        else if (this.parent.isPrintingProcessing) {
            div.style.visibility = 'hidden';
            document.body.append(div);
        }
        this.originalWidth = parseFloat(getComputedStyle(div, null).getPropertyValue('width').replace('px', ''));
        this.originalHeight = parseFloat(getComputedStyle(div, null).getPropertyValue('height').replace('px', ''));
        return { element: div, top: pos.top, left: pos.left };
    }
    /**
     * To adjust the layout inside freeze pane.
     *
     * @hidden
     * @param {ChartModel} model - Specifies the id.
     * @param {HTMLElement} element - Specifies the range.
     * @param {string} range - Specifies the sheet index.
     * @returns {void}
     */
    adjustFreezePaneSize(model, element, range) {
        const indexes = getRangeIndexes(range);
        const sheet = this.parent.getActiveSheet();
        const frozenRow = this.parent.frozenRowCount(sheet);
        const frozenCol = this.parent.frozenColCount(sheet);
        if (indexes[0] < frozenRow || indexes[1] < frozenCol) {
            if (!isNullOrUndefined(model.top)) {
                element.style.top = model.top + (sheet.showHeaders ? 31 : 0) - this.parent.viewport.beforeFreezeHeight + 'px';
            }
            if (!isNullOrUndefined(model.left)) {
                element.style.left = model.left + this.parent.sheetModule.getRowHeaderWidth(sheet, true) -
                    this.parent.viewport.beforeFreezeWidth + 'px';
            }
        }
        else {
            if (!isNullOrUndefined(model.top)) {
                element.style.top = model.top - this.parent.viewport.beforeFreezeHeight - (frozenRow ? getRowsHeight(sheet, getCellIndexes(sheet.topLeftCell)[0], frozenRow - 1) : 0) + 'px';
            }
            if (!isNullOrUndefined(model.left)) {
                element.style.left = model.left - this.parent.viewport.beforeFreezeWidth - (frozenCol ? getColumnsWidth(sheet, getCellIndexes(sheet.topLeftCell)[1], frozenCol - 1) : 0) + 'px';
            }
        }
        if (isNullOrUndefined(model.top)) {
            const startTop = getCellIndexes(sheet.topLeftCell)[0];
            model.top = this.parent.viewport.beforeFreezeHeight + (frozenRow && startTop === indexes[0] ? 0 : getRowsHeight(sheet, frozenRow ? startTop : 0, indexes[0] - 1));
        }
        if (isNullOrUndefined(model.left)) {
            const startLeft = getCellIndexes(sheet.topLeftCell)[1];
            model.left = this.parent.viewport.beforeFreezeWidth + (frozenCol && startLeft === indexes[1] ? 0 : getColumnsWidth(sheet, frozenCol ? startLeft : 0, indexes[1] - 1));
        }
    }
    addEventListener(div) {
        const overlayElem = div;
        EventHandler.add(overlayElem, getStartEvent(), this.overlayClickHandler, this);
        EventHandler.add(overlayElem, getMoveEvent(), this.overlayMouseMoveHandler, this);
        EventHandler.add(this.parent.element.querySelector('#' + this.parent.element.id + '_sheet'), getMoveEvent(), this.overlayMouseMoveHandler, this);
        EventHandler.add(document, getEndEvent(), this.overlayMouseUpHandler, this);
        this.parent.on(overlayEleSize, this.setOriginalSize, this);
    }
    setOriginalSize(args) {
        this.originalHeight = args.height;
        this.originalWidth = args.width;
    }
    overlayMouseMoveHandler(e) {
        const target = e.target;
        const overlayElem = document.getElementsByClassName('e-ss-overlay-active')[0];
        const sheet = this.parent.getActiveSheet();
        const checkOffset = sheet.frozenRows || sheet.frozenColumns ? [29, this.parent.sheetModule.getRowHeaderWidth(sheet, true)] : [-1, -1];
        let height1;
        let top;
        let width1;
        let height2;
        let width2;
        let left;
        if (this.isOverlayClicked && this.isResizerClicked) {
            if (isTouchMove(e)) {
                e.preventDefault();
            }
            switch (this.resizer) {
                case 'e-ss-overlay-t':
                    height1 = Math.max(this.originalMouseY - getClientY(e) + this.originalHeight, 20);
                    top = getClientY(e) - (this.originalMouseY - this.originalResizeTop);
                    if (height1 > 20 && top > checkOffset[0]) {
                        overlayElem.style.height = height1 + 'px';
                        overlayElem.style.top = top + 'px';
                        this.resizedReorderTop = top; // resized divTop
                        this.currenHeight = height1;
                        this.parent.notify(refreshChartSize, {
                            height: overlayElem.style.height, width: overlayElem.style.width, overlayEle: overlayElem
                        });
                    }
                    break;
                case 'e-ss-overlay-r':
                    width1 = this.originalWidth + (getPageX(e) - this.originalMouseX);
                    if (width1 > 20) {
                        overlayElem.style.width = width1 + 'px';
                        this.currentWidth = width1;
                        this.parent.notify(refreshChartSize, {
                            height: overlayElem.style.height, width: overlayElem.style.width, overlayEle: overlayElem
                        });
                    }
                    break;
                case 'e-ss-overlay-b':
                    height2 = this.originalHeight + (getPageY(e) - this.originalMouseY);
                    if (height2 > 20) {
                        overlayElem.style.height = height2 + 'px';
                        this.currenHeight = height2;
                        this.parent.notify(refreshChartSize, {
                            height: overlayElem.style.height, width: overlayElem.style.width, overlayEle: overlayElem
                        });
                    }
                    break;
                case 'e-ss-overlay-l':
                    width2 = Math.max(this.originalMouseX - getClientX(e) + this.originalWidth, 20);
                    left = getClientX(e) - (this.originalMouseX - this.originalResizeLeft);
                    if (width2 > 20 && left > checkOffset[1]) {
                        overlayElem.style.width = width2 + 'px';
                        overlayElem.style.left = left + 'px';
                        this.resizedReorderLeft = left; //resized divLeft
                        this.currentWidth = width2;
                        this.parent.notify(refreshChartSize, {
                            height: overlayElem.style.height, width: overlayElem.style.width, overlayEle: overlayElem
                        });
                    }
                    break;
            }
        }
        else if (this.isOverlayClicked) {
            if (isTouchMove(e)) {
                e.preventDefault();
            }
            if ((closest(target, '.e-sheet') && !target.classList.contains('e-sheet-content')) ||
                target.classList.contains('e-cell')) {
                if (!overlayElem) {
                    return;
                }
                const aX = getClientX(e) - this.diffX;
                const aY = getClientY(e) - this.diffY;
                if (aX > checkOffset[1]) {
                    overlayElem.style.left = aX + 'px';
                }
                if (aY > checkOffset[0]) {
                    overlayElem.style.top = aY + 'px';
                }
                this.resizedReorderLeft = aX < 0 ? 0 : aX; //resized divLeft
                this.resizedReorderTop = aY < 0 ? 0 : aY; // resized divTop
            }
            else {
                this.overlayMouseUpHandler(e, true);
            }
        }
    }
    overlayMouseUpHandler(e, isMouseUp) {
        if (!this.parent || this.parent.getActiveSheet().isProtected || !this.parent.allowEditing) {
            return;
        }
        this.isResizerClicked = false;
        let elem = e.target;
        const overlayElems = document.getElementsByClassName('e-datavisualization-chart e-ss-overlay-active');
        if (!elem.classList.contains('e-ss-overlay')) {
            elem = closest(e.target, '.e-datavisualization-chart') ?
                closest(e.target, '.e-datavisualization-chart') : elem;
        }
        const sheet = this.parent.getActiveSheet();
        const eventArgs = {
            prevTop: sheet.frozenRows || sheet.frozenColumns ? this.prevY : this.originalReorderTop,
            prevLeft: sheet.frozenRows || sheet.frozenColumns ? this.prevX : this.originalReorderLeft,
            currentTop: this.resizedReorderTop >= 0 ? parseInt(this.resizedReorderTop.toString(), 10) : this.originalReorderTop,
            currentLeft: this.resizedReorderLeft >= 0 ? parseInt(this.resizedReorderLeft.toString(), 10) : this.originalReorderLeft,
            id: elem.id, currentHeight: this.currenHeight, currentWidth: this.currentWidth,
            requestType: 'imageRefresh', prevHeight: this.originalHeight, prevWidth: this.originalWidth
        };
        if (this.isOverlayClicked || isMouseUp) {
            let currRowIdx;
            let currColIdx;
            const prevRowIdx = { clientY: eventArgs.prevTop, isImage: true };
            const prevColIdx = { clientX: eventArgs.prevLeft, isImage: true };
            const overlayEle = this.parent.element.getElementsByClassName('e-ss-overlay-active')[0];
            if (sheet.frozenRows || sheet.frozenColumns) {
                if (!overlayEle) {
                    return;
                }
                prevRowIdx.isImage = false;
                prevColIdx.isImage = false;
                prevRowIdx.target = overlayEle;
                prevColIdx.target = overlayEle;
                if (eventArgs.prevTop < this.parent.getColumnHeaderContent().getBoundingClientRect().bottom) {
                    prevRowIdx.target = this.parent.getColumnHeaderContent();
                }
                if (eventArgs.prevLeft < this.parent.getRowHeaderContent().getBoundingClientRect().right) {
                    prevColIdx.target = this.parent.getRowHeaderTable();
                }
                const clientRect = overlayEle.getBoundingClientRect();
                currRowIdx = { clientY: clientRect.top };
                currColIdx = { clientX: clientRect.left };
                if (clientRect.top < this.parent.getColumnHeaderContent().getBoundingClientRect().bottom) {
                    currRowIdx.target = this.parent.getColumnHeaderContent();
                }
                if (clientRect.left < this.parent.getRowHeaderContent().getBoundingClientRect().right) {
                    currColIdx.target = this.parent.getRowHeaderTable();
                }
            }
            else {
                currRowIdx = { clientY: eventArgs.currentTop, isImage: true };
                currColIdx = { clientX: eventArgs.currentLeft, isImage: true };
            }
            this.parent.notify(getRowIdxFromClientY, prevRowIdx);
            this.parent.notify(getRowIdxFromClientY, currRowIdx);
            this.parent.notify(getColIdxFromClientX, prevColIdx);
            this.parent.notify(getColIdxFromClientX, currColIdx);
            if (currRowIdx.size) {
                eventArgs.currentTop = currRowIdx.size;
            }
            if (currColIdx.size) {
                eventArgs.currentLeft = currColIdx.size;
            }
            eventArgs.prevRowIdx = prevRowIdx.clientY;
            eventArgs.prevColIdx = prevColIdx.clientX;
            eventArgs.currentRowIdx = currRowIdx.clientY;
            eventArgs.currentColIdx = currColIdx.clientX;
            if ((sheet.frozenColumns || sheet.frozenRows) && !closest(overlayEle, '.e-sheet-content')) {
                const frozenCol = this.parent.frozenColCount(sheet);
                const frozenRow = this.parent.frozenRowCount(sheet);
                if (eventArgs.currentRowIdx >= frozenRow && eventArgs.currentColIdx >= frozenCol) {
                    let top = parseInt(overlayEle.style.top, 10);
                    let left = parseInt(overlayEle.style.left, 10);
                    const mainPanel = this.parent.sheetModule.contentPanel;
                    top += mainPanel.scrollTop;
                    top -= this.parent.getColumnHeaderContent().parentElement.getBoundingClientRect().height;
                    const scrollPanel = this.parent.getScrollElement();
                    left += scrollPanel.scrollLeft;
                    left -= this.parent.sheetModule.getRowHeaderWidth(sheet);
                    overlayEle.style.top = top + 'px';
                    overlayEle.style.left = left + 'px';
                    this.parent.getMainContent().appendChild(overlayEle);
                }
            }
            if (overlayElems && overlayElems[0]) {
                if (overlayElems[0].querySelector('.e-control')) {
                    eventArgs.id = overlayElems[0].id;
                }
            }
            if (this.originalReorderTop !== this.resizedReorderTop || this.originalReorderLeft !== this.resizedReorderLeft) {
                eventArgs.id = overlayEle.id;
                if (overlayElems && overlayElems[0]) {
                    eventArgs.requestType = 'chartRefresh';
                    this.parent.notify(refreshChartCellObj, eventArgs);
                }
                else {
                    this.parent.notify(refreshImgCellObj, eventArgs);
                }
                this.resizedReorderTop = this.originalReorderTop;
                this.resizedReorderLeft = this.originalReorderLeft;
            }
            else if (this.currenHeight !== this.originalHeight || this.originalWidth !== this.currentWidth) {
                eventArgs.id = elem.id.indexOf('overlay') > 0 ? elem.id : elem.parentElement &&
                    elem.parentElement.classList.contains('e-ss-overlay') ? elem.parentElement.id : overlayEle.id;
                if (overlayElems && overlayElems[0]) {
                    eventArgs.requestType = 'chartRefresh';
                    this.parent.notify(refreshChartCellObj, eventArgs);
                }
                else {
                    this.parent.notify(refreshImgCellObj, eventArgs);
                }
                this.originalHeight = this.currenHeight;
                this.originalWidth = this.currentWidth;
            }
        }
        this.isOverlayClicked = false;
    }
    isOverlaySelected(args) {
        args.isOverlayClicked = this.isOverlayClicked;
    }
    refreshOverlayElem(args) {
        if (args) {
            const selector = '.e-ss-overlay-active' + ((args && args.selector) || '');
            const overlayElem = this.parent.element.querySelector(selector);
            if (overlayElem) {
                removeClass([overlayElem], 'e-ss-overlay-active');
                this.parent.notify(removeDesignChart, {});
            }
        }
        else {
            const selector = 'e-ss-overlay-active';
            const overlayElems = Array.from(this.parent.element.getElementsByClassName(selector));
            for (let i = 0; i < overlayElems.length; i++) {
                const element = overlayElems[i];
                if (element) {
                    removeClass([element], 'e-ss-overlay-active');
                    this.parent.notify(removeDesignChart, {});
                }
            }
        }
        this.parent.notify(clearChartBorder, null);
    }
    overlayClickHandler(e) {
        if (this.parent.getActiveSheet().isProtected || !this.parent.allowEditing) {
            return;
        }
        this.isOverlayClicked = true;
        const target = e.target;
        let overlayElem = e.target;
        if (!target.classList.contains('e-ss-overlay')) {
            overlayElem = target.parentElement;
            if (closest(e.target, '.e-datavisualization-chart')) {
                overlayElem = closest(e.target, '.e-datavisualization-chart');
            }
        }
        const sheet = this.parent.getActiveSheet();
        if ((sheet.frozenColumns || sheet.frozenRows) && closest(overlayElem, '.e-sheet-content')) {
            let top = parseInt(overlayElem.style.top, 10);
            let left = parseInt(overlayElem.style.left, 10);
            const mainPanel = this.parent.sheetModule.contentPanel;
            top -= mainPanel.scrollTop;
            top += this.parent.getColumnHeaderContent().parentElement.getBoundingClientRect().height;
            const scrollPanel = this.parent.getScrollElement();
            left -= scrollPanel.scrollLeft;
            left += this.parent.sheetModule.getRowHeaderWidth(sheet);
            overlayElem.style.top = top + 'px';
            overlayElem.style.left = left + 'px';
            this.parent.element.querySelector('#' + this.parent.element.id + '_sheet').appendChild(overlayElem);
        }
        this.originalWidth = this.currentWidth = parseFloat(overlayElem.style.width);
        this.originalHeight = this.currenHeight = parseFloat(overlayElem.style.height);
        this.originalReorderLeft = parseFloat(overlayElem.style.left); //divLeft
        this.originalReorderTop = parseFloat(overlayElem.style.top); // divTop
        this.resizedReorderLeft = parseFloat(overlayElem.style.left); //resized divLeft
        this.resizedReorderTop = parseFloat(overlayElem.style.top); // resized divTop
        this.originalResizeTop = this.originalReorderTop;
        this.originalResizeLeft = this.originalReorderLeft;
        this.originalMouseX = getClientX(e); // posX
        this.originalMouseY = getClientY(e); // posY
        this.diffX = this.originalMouseX - this.originalReorderLeft;
        this.diffY = this.originalMouseY - this.originalReorderTop;
        const actOverlayElem = document.getElementsByClassName('e-ss-overlay-active')[0];
        if (actOverlayElem) {
            removeClass([actOverlayElem], 'e-ss-overlay-active');
        }
        this.parent.element.querySelector('#' + overlayElem.id).classList.add('e-ss-overlay-active');
        if (target.classList.contains('e-ss-resizer')) {
            this.resizer = target.classList[0];
            this.isResizerClicked = true;
        }
        if (overlayElem.classList.contains('e-datavisualization-chart')) {
            this.parent.notify(focusChartBorder, { id: overlayElem.id });
            if (!actOverlayElem) {
                this.parent.notify(insertDesignChart, { id: overlayElem.id });
            }
        }
        const clientRect = overlayElem.getBoundingClientRect();
        this.prevX = clientRect.left;
        this.prevY = clientRect.top;
    }
    renderResizeHandler(overlay) {
        const handles = ['e-ss-overlay-t', 'e-ss-overlay-r', 'e-ss-overlay-b', 'e-ss-overlay-l'];
        let idx = 0;
        let handleElem;
        while (idx < handles.length) {
            handleElem = this.parent.createElement('div', { className: handles[idx] + ' ' + 'e-ss-resizer' + (Browser.isDevice ? ' e-ss-resizer-touch' : ''),
                styles: 'width: 8px; height: 8px; border-radius: 4px;' });
            overlay.appendChild(handleElem);
            idx++;
        }
    }
    removeEventListener() {
        const overlays = this.parent.element.querySelectorAll('.e-ss-overlay');
        if (overlays.length) { // Added this condition temporarly to handle chart destroy from spec file.
            for (let idx = 0; idx < overlays.length; idx++) {
                EventHandler.remove(overlays[idx], getStartEvent(), this.overlayClickHandler);
                EventHandler.remove(overlays[idx], getMoveEvent(), this.overlayMouseMoveHandler);
            }
        }
        const ele = this.parent.element.querySelector('#' + this.parent.element.id + '_sheet');
        if (ele) {
            EventHandler.remove(ele, getMoveEvent(), this.overlayMouseMoveHandler);
        }
        if (document) {
            EventHandler.remove(document, getEndEvent(), this.overlayMouseUpHandler);
        }
        if (!this.parent.isDestroyed) {
            this.parent.off(overlayEleSize, this.setOriginalSize);
            this.parent.off(selectionStatus, this.isOverlaySelected);
            this.parent.off(refreshOverlayElem, this.refreshOverlayElem);
            this.parent.off(spreadsheetDestroyed, this.destroy);
        }
    }
    /**
     * To clear private variables.
     *
     * @returns {void}
     */
    destroy() {
        this.removeEventListener();
        if (this.currentWidth) {
            this.currentWidth = null;
        }
        if (this.currenHeight) {
            this.currenHeight = null;
        }
        if (this.minHeight) {
            this.minHeight = null;
        }
        if (this.minWidth) {
            this.minWidth = null;
        }
        if (this.isOverlayClicked) {
            this.isOverlayClicked = null;
        }
        if (this.isResizerClicked) {
            this.isResizerClicked = null;
        }
        this.parent = null;
    }
}

var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Objects used for configuring the Ribbon tab header properties.
 */
class RibbonHeader extends ChildProperty {
}
__decorate$8([
    Property('')
], RibbonHeader.prototype, "text", void 0);
__decorate$8([
    Property('')
], RibbonHeader.prototype, "iconCss", void 0);
__decorate$8([
    Property('left')
], RibbonHeader.prototype, "iconPosition", void 0);
/**
 * An array of object that is used to configure the Tab.
 */
class RibbonItem extends ChildProperty {
}
__decorate$8([
    Complex({}, RibbonHeader)
], RibbonItem.prototype, "header", void 0);
__decorate$8([
    Collection([], Item)
], RibbonItem.prototype, "content", void 0);
__decorate$8([
    Property('')
], RibbonItem.prototype, "cssClass", void 0);
__decorate$8([
    Property(false)
], RibbonItem.prototype, "disabled", void 0);
/**
 * Represents Ribbon component.
 */
let Ribbon = class Ribbon extends Component {
    /**
     * Constructor for creating the widget.
     *
     * @param {RibbonModel} options - Specify the options
     * @param {string|HTMLDivElement} element -specify the element.
     */
    constructor(options, element) {
        super(options);
    }
    /**
     * For internal use only.
     *
     * @returns {void} - For internal use only.
     * @private
     */
    preRender() {
        /** */
    }
    /**
     * For internal use only.
     *
     * @returns {void} - For internal use only.
     * @private
     */
    render() {
        if (!this.element.id) {
            this.element.id = getUniqueID('ribbon');
        }
        this.renderRibbon();
    }
    /**
     * Destroys the component (detaches/removes all event handlers, attributes, classes, and empties the component element).
     *
     * {% codeBlock src='spreadsheet/destroy/index.md' %}{% endcodeBlock %}
     *
     * @function destroy
     * @returns {void} - Destroys the component
     */
    destroy() {
        const expandCollapseElem = this.element.querySelector('.e-drop-icon');
        if (expandCollapseElem) {
            expandCollapseElem.removeEventListener('click', this.ribbonExpandCollapse.bind(this));
        }
        if (this.menuItems.length) {
            const fileMenu = document.getElementById(`${this.element.id}_menu`);
            if (fileMenu) {
                getComponent(fileMenu, 'menu').destroy();
            }
        }
        if (this.toolbarObj) {
            this.toolbarObj.destroy();
        }
        if (this.tabObj) {
            this.tabObj.destroy();
        }
        this.element.innerHTML = '';
        this.toolbarObj = null;
        this.tabObj = null;
        super.destroy();
    }
    getTabItems() {
        const tabItems = [];
        if (this.menuItems.length) {
            tabItems.push({
                header: { text: this.initMenu(this.menuItems) },
                content: this.toolbarObj.element,
                cssClass: 'e-menu-tab'
            });
        }
        this.items.forEach((item) => {
            tabItems.push({
                header: item.header,
                content: this.toolbarObj.element
            });
        });
        return tabItems;
    }
    initMenu(menuItems) {
        const menu = this.createElement('ul', { id: `${this.element.id}_menu` });
        this.element.appendChild(menu);
        const menuObj = new Menu({
            cssClass: 'e-file-menu',
            items: menuItems,
            showItemOnClick: true,
            beforeOpen: (args) => {
                if (args.parentItem.text === menuItems[0].text) {
                    menuObj.showItemOnClick = false;
                }
                this.trigger('beforeOpen', args);
            },
            select: (args) => {
                this.trigger('fileMenuItemSelect', args);
            },
            beforeClose: (args) => {
                if (args.event.type === 'mouseover' && !closest(args.event.target, '.e-menu-popup')) {
                    args.cancel = true;
                    return;
                }
                this.trigger('beforeClose', args);
                if (!args.parentItem || args.parentItem.text === menuItems[0].text) {
                    menuObj.setProperties({ showItemOnClick: true }, true);
                }
            },
            beforeItemRender: (args) => {
                this.trigger('beforeFileMenuItemRender', args);
            },
            created: () => {
                menuObj.element.removeAttribute('tabindex');
                const fileItem = menuObj.element.querySelector('.e-menu-item');
                if (fileItem) {
                    fileItem.removeAttribute('tabindex');
                }
            }
        });
        menuObj.createElement = this.createElement;
        menuObj.appendTo(menu);
        return menu.parentElement;
    }
    renderRibbon() {
        const tabElement = this.createElement('div');
        const tBarElement = this.createElement('div');
        let isShortcut;
        this.toolbarObj = new Toolbar({
            items: this.items[this.selectedTab].content,
            clicked: (args) => this.trigger('clicked', args)
        });
        this.toolbarObj.createElement = this.createElement;
        this.toolbarObj.appendTo(tBarElement);
        this.tabObj = new Tab({
            selectedItem: this.getIndex(this.selectedTab),
            animation: { next: { duration: 0 }, previous: { duration: 0 } },
            items: this.getTabItems(),
            selecting: (args) => {
                if (args.isSwiped) {
                    args.cancel = true;
                    return;
                }
                isShortcut = args.event && args.event.isShortcut;
                if (this.menuItems.length && args.selectingIndex === 0) {
                    args.cancel = true;
                    if ((!args.event || isShortcut || args.event.type === 'keydown') && args.selectingItem) {
                        const fileMenu = args.selectingItem.querySelector('.e-file-menu .e-menu-item');
                        if (fileMenu) {
                            fileMenu.click();
                        }
                    }
                }
                else {
                    if (args.selectingIndex === this.getIndex(this.selectedTab)) {
                        return;
                    }
                    this.updateToolbar(this.getIndex(args.selectingIndex, true));
                    this.toolbarObj.dataBind();
                    this.refreshTemplateItems(this.toolbarObj); // To refresh template items in the toolbar.
                    if (this.element.classList.contains('e-collapsed')) {
                        EventHandler.remove(args.selectedItem, 'click', this.ribbonExpandCollapse);
                    }
                    let eventArgs;
                    if (this.menuItems.length) {
                        eventArgs = Object.assign({}, args);
                        eventArgs.selectingIndex -= 1;
                        eventArgs.selectedIndex -= 1;
                    }
                    else {
                        eventArgs = args;
                    }
                    this.trigger('selecting', eventArgs);
                }
            },
            selected: (args) => {
                if (!args.isInteracted && !isShortcut) {
                    args.preventFocus = true;
                }
                if (args.selectedIndex === this.getIndex(this.selectedTab)) {
                    return;
                }
                this.setProperties({ 'selectedTab': this.getIndex(args.selectedIndex, true) }, true);
                if (this.element.classList.contains('e-collapsed')) {
                    this.element.classList.remove('e-collapsed');
                    this.trigger('expandCollapse', { element: this.toolbarObj.element, expanded: true });
                }
            },
            created: () => {
                this.toolbarObj.refreshOverflow();
            }
        });
        this.element.appendChild(tabElement);
        this.tabObj.createElement = this.createElement;
        this.tabObj.appendTo(tabElement);
        const collapseBtn = this.createElement('span', { className: 'e-drop-icon e-icons' });
        collapseBtn.addEventListener('click', this.ribbonExpandCollapse.bind(this));
        this.element.appendChild(collapseBtn);
    }
    ribbonExpandCollapse(e) {
        const eventArgs = { element: this.toolbarObj.element, expanded: true };
        let activeTab;
        if (this.element.classList.contains('e-collapsed')) {
            activeTab = this.tabObj.element.querySelector('.e-tab-header').getElementsByClassName('e-toolbar-item')[this.tabObj.selectedItem];
            this.element.classList.remove('e-collapsed');
            activeTab.classList.add('e-active');
            EventHandler.remove(activeTab, 'click', this.ribbonExpandCollapse);
            this.trigger('expandCollapse', eventArgs);
        }
        else {
            activeTab = this.tabObj.element.querySelector('.e-tab-header .e-toolbar-item.e-active');
            this.element.classList.add('e-collapsed');
            eventArgs.expanded = false;
            activeTab.classList.remove('e-active');
            EventHandler.add(activeTab, 'click', this.ribbonExpandCollapse, this);
            this.trigger('expandCollapse', eventArgs);
        }
    }
    getIndex(index, decrement) {
        return this.menuItems.length ? (decrement ? index - 1 : index + 1) : index;
    }
    updateToolbar(index) {
        this.toolbarObj.items = this.items[index].content;
        this.toolbarObj.dataBind();
    }
    refreshTemplateItems(toolbarInstance) {
        if (this.spreadInstance && this.spreadInstance.isReact && this.spreadInstance.portals &&
            toolbarInstance && toolbarInstance.portals) {
            this.spreadInstance.portals = this.spreadInstance.portals.concat(toolbarInstance.portals);
            this.spreadInstance['renderReactTemplates']();
        }
    }
    /**
     * To enable / disable the ribbon menu items.
     *
     * @param {string[]} items - Items that needs to be enabled / disabled.
     * @param {boolean} enable - Set `true` / `false` to enable / disable the menu items.
     * @param {boolean} isUniqueId - Set `true` if the given menu items `text` is a unique id.
     * @returns {void} - To enable / disable the ribbon menu items.
     */
    enableMenuItems(items, enable = true, isUniqueId) {
        if (!this.menuItems.length) {
            return;
        }
        getComponent(document.getElementById(`${this.element.id}_menu`), 'menu').enableItems(items, enable, isUniqueId);
    }
    /**
     * To show/hide the menu items in Ribbon.
     *
     * @param {string[]} items - Specifies the menu items text which is to be show/hide.
     * @param {boolean} hide - Set `true` / `false` to hide / show the menu items.
     * @param {boolean} isUniqueId - Set `true` if the given menu items `text` is a unique id.
     * @returns {void} - To show/hide the menu items in Ribbon.
     */
    hideMenuItems(items, hide = true, isUniqueId) {
        if (!this.menuItems.length) {
            return;
        }
        const menuInstance = getComponent(document.getElementById(`${this.element.id}_menu`), 'menu');
        if (hide) {
            menuInstance.hideItems(items, isUniqueId);
        }
        else {
            menuInstance.showItems(items, isUniqueId);
        }
    }
    /**
     * To add custom menu items.
     *
     * @param {MenuItemModel[]} items - Specifies the Ribbon menu items to be inserted.
     * @param {string} text - Specifies the existing file menu item text before / after which the new file menu items to be inserted.
     * @param {boolean} insertAfter - Set `false` if the `items` need to be inserted before the `text`.
     * By default, `items` are added after the `text`.
     * @param {boolean} isUniqueId - Set `true` if the given menu items `text` is a unique id.
     * @returns {void} - To add custom menu items.
     */
    addMenuItems(items, text, insertAfter = true, isUniqueId) {
        if (!this.menuItems.length) {
            return;
        }
        const menuInstance = getComponent(document.getElementById(`${this.element.id}_menu`), 'menu');
        if (insertAfter) {
            menuInstance.insertAfter(items.reverse(), text, isUniqueId);
        }
        else {
            menuInstance.insertBefore(items, text, isUniqueId);
        }
    }
    /**
     * To show/hide the Ribbon tabs.
     *
     * @param {string[]} tabs - Specifies the tab header text which needs to be shown/hidden.
     * @param {boolean} hide - Set `true` / `false` to hide / show the ribbon tabs.
     * @returns {void} - To show/hide the Ribbon tabs.
     */
    hideTabs(tabs, hide = true) {
        let idx;
        let activeTab;
        let stateChanged;
        let isAllHidden;
        if (!hide) {
            isAllHidden = this.isAllHidden();
        }
        tabs.forEach((tab) => {
            idx = this.getTabIndex(tab, -1);
            if (idx > -1) {
                if (hide) {
                    if (!this.items[idx].cssClass.includes(' e-hide')) {
                        this.items[idx].cssClass = `${this.items[idx].cssClass} e-hide`;
                        this.tabObj.items[this.getIndex(idx)].cssClass = this.items[idx].cssClass;
                        if (activeTab === undefined && idx === this.selectedTab) {
                            activeTab = true;
                        }
                        stateChanged = true;
                    }
                }
                else {
                    if (this.items[idx].cssClass.includes(' e-hide')) {
                        this.items[idx].cssClass = this.items[idx].cssClass.replace(' e-hide', '');
                        this.tabObj.items[this.getIndex(idx)].cssClass = this.items[idx].cssClass;
                        if (activeTab === undefined && idx === this.selectedTab) {
                            activeTab = true;
                        }
                        stateChanged = true;
                    }
                }
            }
        });
        this.setProperties({ 'items': this.items }, true);
        // eslint-disable-next-line no-self-assign
        this.tabObj.items = this.tabObj.items;
        this.tabObj.dataBind();
        if (hide) {
            isAllHidden = this.isAllHidden();
            if (isAllHidden) {
                activeTab = false;
            }
        }
        if (!hide && isAllHidden) {
            activeTab = activeTab ? false : true;
        }
        if (stateChanged && isAllHidden) {
            if (this.element.classList.contains('e-collapsed')) {
                this.element.classList.remove('e-collapsed');
                this.element.querySelector('.e-drop-icon').classList.remove('e-hide');
            }
            else {
                this.element.classList.add('e-collapsed');
                this.element.querySelector('.e-drop-icon').classList.add('e-hide');
            }
        }
        if (activeTab) {
            for (let i = 0; i < this.items.length; i++) {
                if (!this.items[i].cssClass.includes(' e-hide')) {
                    this.tabObj.selectedItem = this.getIndex(i);
                    this.tabObj.dataBind();
                    break;
                }
            }
        }
    }
    isAllHidden() {
        let allHidden = true;
        for (let i = 0; i < this.items.length; i++) {
            if (!this.items[i].cssClass.includes(' e-hide')) {
                allHidden = false;
                break;
            }
        }
        return allHidden;
    }
    /**
     * To enable / disable the Ribbon tabs.
     *
     * @param {string[]} tabs - Specifies the tab header text which needs to be enabled / disabled.
     * @param {boolean} enable - Set `true` / `false` to enable / disable the ribbon tabs.
     * @returns {void} - To enable / disable the Ribbon tabs.
     */
    enableTabs(tabs, enable = true) {
        tabs.forEach((tab) => {
            let idx = (this.getTabIndex(tab, -1));
            if (idx > -1) {
                this.items[idx].disabled = !enable;
                idx = this.getIndex(idx);
                this.tabObj.enableTab(idx, enable);
            }
        });
        this.setProperties({ 'items': this.items }, true);
    }
    /**
     * To add custom tabs.
     *
     * @param {RibbonItemModel[]} items - Specifies the Ribbon tab items to be inserted.
     * @param {string} insertBefore - Specifies the existing Ribbon header text before which the new tabs will be inserted.
     * If not specified, the new tabs will be inserted at the end.
     * @returns {void} - To add custom tabs.
     */
    addTabs(items, insertBefore) {
        let idx = this.getTabIndex(insertBefore);
        items.forEach((item) => {
            item = new RibbonItem(this.items[0], 'items', item, true);
            this.items.splice(idx, 0, item);
            this.tabObj.addTab([{ header: item.header, content: this.toolbarObj.element }], this.getIndex(idx));
            idx++;
        });
        this.setProperties({ 'items': this.items }, true);
        this.setProperties({ 'selectedTab': this.getIndex(this.tabObj.selectedItem, true) }, true);
    }
    getTabIndex(headerText, idx = this.items.length) {
        if (headerText) {
            for (let i = 0; i < this.items.length; i++) {
                if (this.items[i].header.text === headerText) {
                    idx = i;
                    break;
                }
            }
        }
        return idx;
    }
    /**
     * To add the custom items in Ribbon toolbar.
     *
     * @param {string} tab - Specifies the ribbon tab header text under which the specified items will be inserted..
     * @param {ItemModel[]} items - Specifies the ribbon toolbar items that needs to be inserted.
     * @param {number} index - Specifies the index text before which the new items will be inserted.
     * @returns {void} - To add the custom items in Ribbon toolbar.
     * If not specified, the new items will be inserted at the end of the toolbar.
     */
    addToolbarItems(tab, items, index) {
        const tabIdx = this.getTabIndex(tab);
        if (isNullOrUndefined(index)) {
            index = this.items[tabIdx].content.length;
        }
        items.forEach((item) => {
            item = new Item(this.items[tabIdx].content[0], 'content', item, true);
            this.items[tabIdx].content.splice(index, 0, item);
            index++;
        });
        this.setProperties({ 'items': this.items }, true);
        if (tabIdx === this.selectedTab && items.length) {
            this.updateToolbar(tabIdx);
        }
    }
    /**
     * Enables or disables the specified Ribbon toolbar items or all ribbon items.
     *
     * @param {string} tab - Specifies the ribbon tab header text under which the toolbar items need to be enabled / disabled.
     * @param {number[]} items - Specifies the toolbar item indexes / unique id's which needs to be enabled / disabled.
     * If it is not specified the entire toolbar items will be enabled / disabled.
     * @param  {boolean} enable - Boolean value that determines whether the toolbar items should be enabled or disabled.
     * @returns {void} - Enables or disables the specified Ribbon toolbar items or all ribbon items.
     */
    enableItems(tab, items, enable) {
        if (enable === undefined) {
            enable = true;
        }
        if (items) {
            const tabIdx = this.getTabIndex(tab, -1);
            if (tabIdx < 0) {
                return;
            }
            for (let i = 0; i < items.length; i++) {
                if (typeof items[i] === 'string') {
                    for (let j = 0; j < this.items[tabIdx].content.length; j++) {
                        if (this.items[tabIdx].content[j].id === items[i]) {
                            items[i] = j;
                            break;
                        }
                    }
                }
                if (typeof items[i] === 'string') {
                    if (items.length - 1 > i) {
                        continue;
                    }
                    else {
                        return;
                    }
                }
                this.items[tabIdx].content[items[i]].disabled = !enable;
                this.setProperties({ 'items': this.items }, true);
                if (tabIdx === this.selectedTab) {
                    this.toolbarObj.enableItems(items[i], enable);
                }
            }
        }
        else {
            this.toolbarObj.disable(!enable);
        }
    }
    /**
     * To show/hide the existing Ribbon toolbar items.
     *
     * @param {string} tab - Specifies the ribbon tab header text under which the specified items need to be hidden / shown.
     * @param {number[]} indexes - Specifies the toolbar indexes which needs to be shown/hidden from UI.
     * @param {boolean} hide - Set `true` / `false` to hide / show the toolbar items.
     * @returns {void} - To show/hide the existing Ribbon toolbar items.
     */
    hideToolbarItems(tab, indexes, hide = true) {
        let tabIdx;
        let tabContent;
        for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].header.text === tab) {
                tabIdx = i;
                indexes.forEach((idx) => {
                    tabContent = this.items[tabIdx].content[idx];
                    if (tabContent) {
                        if (hide) {
                            if (!tabContent.cssClass.includes(' e-hide')) {
                                tabContent.cssClass = tabContent.cssClass + ' e-hide';
                            }
                        }
                        else {
                            if (tabContent.cssClass.includes(' e-hide')) {
                                tabContent.cssClass = tabContent.cssClass.replace(' e-hide', '');
                            }
                        }
                    }
                });
                break;
            }
        }
        this.setProperties({ 'items': this.items }, true);
        if (tabIdx !== undefined && tabIdx === this.selectedTab) {
            this.updateToolbar(tabIdx);
        }
    }
    /**
     * Get component name.
     *
     * @returns {string} - Get component name.
     * @private
     */
    getModuleName() {
        return 'ribbon';
    }
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @returns {string} - Get the properties to be maintained in the persisted state.
     * @private
     */
    getPersistData() {
        return this.addOnPersist([]);
    }
    /**
     * Called internally if any of the property value changed.
     *
     * @param {RibbonModel} newProp - Specify the new properties
     * @param {RibbonModel} oldProp - specify the old properties.
     * @returns {void} - if any of the property value changed.
     * @private
     */
    onPropertyChanged(newProp, oldProp) {
        for (const prop of Object.keys(newProp)) {
            switch (prop) {
                case 'selectedTab':
                    this.tabObj.selectedItem = this.getIndex(newProp.selectedTab);
                    this.tabObj.dataBind();
                    break;
            }
        }
    }
};
__decorate$8([
    Property('')
], Ribbon.prototype, "cssClass", void 0);
__decorate$8([
    Property(true)
], Ribbon.prototype, "menuType", void 0);
__decorate$8([
    Collection([], MenuItem)
], Ribbon.prototype, "menuItems", void 0);
__decorate$8([
    Property(0)
], Ribbon.prototype, "selectedTab", void 0);
__decorate$8([
    Collection([], RibbonItem)
], Ribbon.prototype, "items", void 0);
__decorate$8([
    Property(null)
], Ribbon.prototype, "spreadInstance", void 0);
__decorate$8([
    Event$1()
], Ribbon.prototype, "selecting", void 0);
__decorate$8([
    Event$1()
], Ribbon.prototype, "fileMenuItemSelect", void 0);
__decorate$8([
    Event$1()
], Ribbon.prototype, "beforeFileMenuItemRender", void 0);
__decorate$8([
    Event$1()
], Ribbon.prototype, "beforeOpen", void 0);
__decorate$8([
    Event$1()
], Ribbon.prototype, "beforeClose", void 0);
__decorate$8([
    Event$1()
], Ribbon.prototype, "selectFormat", void 0);
__decorate$8([
    Event$1()
], Ribbon.prototype, "clicked", void 0);
__decorate$8([
    Event$1()
], Ribbon.prototype, "created", void 0);
__decorate$8([
    Event$1()
], Ribbon.prototype, "expandCollapse", void 0);
Ribbon = __decorate$8([
    NotifyPropertyChanges
], Ribbon);

/**
 * `Color Picker` module is used to handle ColorPicker functionality.
 *
 * @hidden
 */
class ColorPicker {
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    render() {
        const id = this.parent.element.id;
        let input = this.parent.createElement('input', { attrs: { 'type': 'color' } });
        const tileRenderHandler = (args) => {
            args.element.tabIndex = -1;
        };
        this.fontColorPicker = new ColorPicker$1({
            value: '#000000ff',
            mode: 'Palette',
            showButtons: false,
            presetColors: fontColor,
            enableOpacity: false,
            cssClass: 'e-spreadsheet-color-popup',
            beforeTileRender: tileRenderHandler,
            beforeClose: () => this.beforeCloseHandler(this.fontColorPicker),
            open: this.openHandler.bind(this),
            beforeModeSwitch: (args) => this.beforeModeSwitch(this.fontColorPicker, args),
            change: (args) => {
                const color = this.fontColorPicker.getValue(args.currentValue.rgba);
                const eventArgs = { style: { color: color }, onActionUpdate: true };
                this.parent.notify(setCellFormat, eventArgs);
                if (eventArgs.cancel) {
                    this.fontColorPicker.setProperties({ 'value': this.fontColorPicker.getValue(args.previousValue.rgba, 'HEXA') }, true);
                }
                else {
                    this.updateSelectedColor(eventArgs.style.color, this.fontColorPicker.element, 'TextColor');
                }
            },
            created: () => this.updateSelectedColor('#000000', this.fontColorPicker.element, 'TextColor', true)
        });
        this.fontColorPicker.createElement = this.parent.createElement;
        this.parent.element.appendChild(input);
        this.fontColorPicker.appendTo(input);
        input.parentElement.id = `${id}_font_color_picker`;
        addClass([input.nextElementSibling.getElementsByClassName('e-selected-color')[0]], ['e-icons', 'e-font-color']);
        input = this.parent.createElement('input', { attrs: { 'type': 'color' } });
        this.filColorPicker = new ColorPicker$1({
            value: '#ffff00ff',
            mode: 'Palette',
            presetColors: fillColor,
            showButtons: false,
            enableOpacity: false,
            cssClass: 'e-spreadsheet-color-popup',
            open: this.openHandler.bind(this),
            beforeTileRender: tileRenderHandler,
            beforeClose: () => this.beforeCloseHandler(this.filColorPicker),
            beforeModeSwitch: (args) => this.beforeModeSwitch(this.filColorPicker, args),
            change: (args) => {
                const color = this.filColorPicker.getValue(args.currentValue.rgba);
                const eventArgs = { style: { backgroundColor: color }, onActionUpdate: true };
                this.parent.notify(setCellFormat, eventArgs);
                if (eventArgs.cancel) {
                    this.filColorPicker.setProperties({ 'value': this.filColorPicker.getValue(args.previousValue.rgba, 'HEXA') }, true);
                }
                else {
                    this.updateSelectedColor(eventArgs.style.backgroundColor, this.filColorPicker.element, 'FillColor');
                }
            },
            created: () => this.updateSelectedColor('#ffff00', this.filColorPicker.element, 'FillColor', true)
        });
        this.filColorPicker.createElement = this.parent.createElement;
        this.parent.element.appendChild(input);
        this.filColorPicker.appendTo(input);
        input.parentElement.id = `${id}_fill_color_picker`;
        addClass([input.nextElementSibling.getElementsByClassName('e-selected-color')[0]], ['e-icons', 'e-fill-color']);
    }
    updateSelectedColor(color, ele, name, isCreated) {
        const localeText = this.parent.serviceLocator.getService(locale).getConstant(name);
        if (isCreated) {
            ele.parentElement.querySelector('.e-dropdown-btn').setAttribute('aria-label', localeText);
        }
        const primaryBtn = ele.parentElement.querySelector('.e-split-colorpicker');
        primaryBtn.setAttribute('aria-label', `${localeText} ${color}`);
        primaryBtn.firstElementChild.style.borderBottomColor = color;
    }
    openHandler(args) {
        args.element.querySelector('.e-mode-switch-btn').title =
            this.parent.serviceLocator.getService(locale).getConstant('MoreColors');
    }
    beforeCloseHandler(inst) {
        if (!inst.modeSwitcher) {
            inst.setProperties({ modeSwitcher: true }, true);
        }
        if (inst.showButtons) {
            inst.setProperties({ showButtons: false }, true);
        }
        focus(inst.element.parentElement.querySelector('.e-split-colorpicker'));
    }
    beforeModeSwitch(inst, args) {
        const l10n = this.parent.serviceLocator.getService(locale);
        if (args.mode === 'Picker') {
            inst.showButtons = true;
            inst.dataBind();
            args.element.querySelector('.e-apply').title = l10n.getConstant('Apply');
            args.element.querySelector('.e-cancel').title = l10n.getConstant('Cancel');
            args.element.querySelector('.e-mode-switch-btn').title = l10n.getConstant('StandardColors');
        }
        else {
            inst.showButtons = false;
            inst.dataBind();
            args.element.querySelector('.e-mode-switch-btn').title = l10n.getConstant('MoreColors');
        }
    }
    destroy() {
        if (this.parent) {
            this.removeEventListener();
            if (this.fontColorPicker) {
                this.fontColorPicker.destroy();
            }
            this.fontColorPicker = null;
            if (this.filColorPicker) {
                this.filColorPicker.destroy();
            }
            this.filColorPicker = null;
            this.parent = null;
        }
    }
    addEventListener() {
        this.parent.on(beforeRibbonCreate, this.render, this);
        this.parent.on('destroyRibbonComponents', this.destroy, this);
        this.parent.on(spreadsheetDestroyed, this.destroy, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(beforeRibbonCreate, this.render);
            this.parent.off('destroyRibbonComponents', this.destroy);
            this.parent.off(spreadsheetDestroyed, this.destroy);
        }
    }
}

/**
 * Represents Ribbon for Spreadsheet.
 */
class Ribbon$1 {
    constructor(parent) {
        this.border = '1px solid #000000';
        this.fontNameIndex = 5;
        this.numPopupWidth = 0;
        this.preTabIdx = 1;
        this.spanElements = []; // To keep track of dynamically added elements in conditional formatting.
        this.iconSetGroupElement = [];
        this.iconSetElements = [];
        this.iconWrapElements = [];
        this.parent = parent;
        this.addEventListener();
        new ColorPicker(parent);
    }
    getModuleName() {
        return 'ribbon';
    }
    ribbonOperation(args) {
        if (args && args.onPropertyChange) {
            this.onPropertyChanged(args.prop);
        }
        else {
            this.initialize();
        }
    }
    initialize(onPropertyChange) {
        this.parent.notify(beforeRibbonCreate, {});
        if (this.parent.isMobileView()) {
            this.createMobileView();
        }
        else {
            const refEle = onPropertyChange && (this.parent.element.querySelector('.e-formula-bar-panel') ||
                document.getElementById(this.parent.element.id + '_sheet_panel'));
            this.createRibbon(refEle);
        }
    }
    getRibbonMenuItems() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const id = this.parent.element.id;
        const menuItems = [{
                text: this.parent.isMobileView() ? '' : l10n.getConstant('File'),
                iconCss: this.parent.isMobileView() ? 'e-icons e-file-menu-icon' : null, id: `${id}_File`,
                items: [
                    { text: l10n.getConstant('New'), id: `${id}_New`, iconCss: 'e-new e-icons' },
                    { text: l10n.getConstant('Open'), id: `${id}_Open`, iconCss: 'e-open e-icons' },
                    {
                        text: l10n.getConstant('SaveAs'), iconCss: 'e-save e-icons', id: `${id}_Save_As`,
                        items: [
                            { text: l10n.getConstant('ExcelXlsx'), id: `${id}_Xlsx`, iconCss: 'e-xlsx e-icons' },
                            { text: l10n.getConstant('ExcelXls'), id: `${id}_Xls`, iconCss: 'e-xls e-icons' },
                            { text: l10n.getConstant('CSV'), id: `${id}_Csv`, iconCss: 'e-csv e-icons' },
                            { text: l10n.getConstant('PDF'), id: `${id}_Pdf`, iconCss: 'e-pdf e-icons' }
                        ]
                    },
                    { text: l10n.getConstant('Print'), id: `${id}_Print`, iconCss: 'e-print e-icons' }
                ]
            }];
        return menuItems;
    }
    getRibbonItems() {
        const id = this.parent.element.id;
        const l10n = this.parent.serviceLocator.getService(locale);
        const items = [{
                header: { text: l10n.getConstant('Home') },
                content: [
                    { prefixIcon: 'e-undo-icon', tooltipText: `${l10n.getConstant('Undo')} (Ctrl+Z)`,
                        htmlAttributes: { 'aria-label': l10n.getConstant('Undo') }, id: id + '_undo', disabled: true },
                    { prefixIcon: 'e-redo-icon', tooltipText: `${l10n.getConstant('Redo')} (Ctrl+Y)`,
                        htmlAttributes: { 'aria-label': l10n.getConstant('Redo') }, id: id + '_redo', disabled: true },
                    { type: 'Separator', id: id + '_separator_1' },
                    { prefixIcon: 'e-cut-icon', tooltipText: `${l10n.getConstant('Cut')} (Ctrl+X)`,
                        htmlAttributes: { 'aria-label': l10n.getConstant('Cut') }, id: id + '_cut' },
                    { prefixIcon: 'e-copy-icon', tooltipText: `${l10n.getConstant('Copy')} (Ctrl+C)`,
                        htmlAttributes: { 'aria-label': l10n.getConstant('Copy') }, id: id + '_copy' },
                    { tooltipText: `${l10n.getConstant('Paste')} (Ctrl+V)`, template: this.getPasteBtn(id, l10n), id: id + '_paste',
                        disabled: true }, { type: 'Separator', id: id + '_separator_2' },
                    { template: this.getNumFormatDDB(id, l10n), tooltipText: l10n.getConstant('NumberFormat'), id: id + '_number_format' },
                    { type: 'Separator', id: id + '_separator_3' },
                    { template: this.getFontNameDDB(id), tooltipText: l10n.getConstant('Font'), id: id + '_font_name' },
                    { type: 'Separator', id: id + '_separator_4' },
                    { template: this.getFontSizeDDB(id), tooltipText: l10n.getConstant('FontSize'), id: id + '_font_size' },
                    { type: 'Separator', id: id + '_separator_5' },
                    { template: this.getBtn(id, 'bold', l10n.getConstant('Bold')), tooltipText: `${l10n.getConstant('Bold')} (Ctrl+B)`,
                        id: id + '_bold' },
                    { template: this.getBtn(id, 'italic', l10n.getConstant('Italic')), tooltipText: `${l10n.getConstant('Italic')} (Ctrl+I)`,
                        id: id + '_italic' },
                    { template: this.getBtn(id, 'line-through', l10n.getConstant('Strikethrough')),
                        tooltipText: `${l10n.getConstant('Strikethrough')} (Ctrl+5)`,
                        id: id + '_line-through' },
                    { template: this.getBtn(id, 'underline', l10n.getConstant('Underline')), tooltipText: `${l10n.getConstant('Underline')} (Ctrl+U)`,
                        id: id + '_underline' },
                    { template: document.getElementById(`${id}_font_color_picker`), tooltipText: l10n.getConstant('TextColor'),
                        id: id + '_font_color_picker' }, { type: 'Separator', id: id + '_separator_6' },
                    { template: document.getElementById(`${id}_fill_color_picker`), tooltipText: l10n.getConstant('FillColor'),
                        id: id + '_fill_color_picker' },
                    { template: this.getBordersDBB(id), tooltipText: l10n.getConstant('Borders'), id: id + '_borders' },
                    { template: this.getMergeSplitBtn(id), tooltipText: l10n.getConstant('MergeCells'), id: id + '_merge_cells',
                        disabled: true },
                    { type: 'Separator', id: id + '_separator_7' },
                    { template: this.getTextAlignDDB(id), tooltipText: l10n.getConstant('HorizontalAlignment'), id: id + '_text_align' },
                    { template: this.getVerticalAlignDDB(id), tooltipText: l10n.getConstant('VerticalAlignment'), id: id + '_vertical_align' },
                    { template: this.getBtn(id, 'wrap', l10n.getConstant('WrapText'), false), tooltipText: `${l10n.getConstant('WrapText')}`, id: id + '_wrap' }
                ]
            },
            {
                header: { text: l10n.getConstant('Insert') }, content: [
                    {
                        prefixIcon: 'e-hyperlink-icon', text: l10n.getConstant('Link'),
                        id: id + '_hyperlink', tooltipText: l10n.getConstant('Link'), click: () => { this.getHyperlinkDlg(); }
                    },
                    {
                        prefixIcon: 'e-image-icon', text: l10n.getConstant('Image'),
                        id: id + '_image', tooltipText: l10n.getConstant('Image'), click: () => { select('#' + id + '_imageUpload', this.parent.element).click(); }
                    }
                ]
            },
            {
                header: { text: l10n.getConstant('Formulas') }, content: [
                    {
                        prefixIcon: 'e-insert-function', tooltipText: l10n.getConstant('InsertFunction'), text: l10n.getConstant('InsertFunction'),
                        id: id + '_insert_function'
                    },
                    { type: 'Separator', id: id + '_separator_14' },
                    {
                        template: this.createCalcOptions(id, l10n), tooltipText: l10n.getConstant('CalcOptionsTip'), id: id + '_calc_types'
                    },
                    { type: 'Separator', id: id + '_separator_15' },
                    {
                        prefixIcon: 'e-calculate-sheet', tooltipText: l10n.getConstant('CalcSheetTip'), text: l10n.getConstant('CalcActiveSheet'),
                        id: id + '_calc_current_sheet', click: () => {
                            this.parent.notify(workbookFormulaOperation, { action: 'ClearDependentCellCollection' });
                            this.parent.calculateNow('Sheet');
                        },
                        disabled: this.parent.calculationMode === 'Automatic'
                    },
                    {
                        prefixIcon: 'e-calculation', tooltipText: l10n.getConstant('CalcWorkbookTip'), text: l10n.getConstant('CalcWorkbook'),
                        id: id + '_calc_entire_sheets', click: () => {
                            this.parent.notify(workbookFormulaOperation, { action: 'ClearDependentCellCollection' });
                            this.parent.calculateNow('Workbook');
                        },
                        disabled: this.parent.calculationMode === 'Automatic'
                    }
                ]
            },
            {
                header: { text: l10n.getConstant('Data') }, content: [
                    {
                        prefixIcon: 'e-protect-icon', text: l10n.getConstant('ProtectSheet'), id: id + '_protect',
                        tooltipText: l10n.getConstant('ProtectSheet')
                    },
                    {
                        prefixIcon: 'e-password-protect-icon', text: l10n.getConstant('ProtectWorkbook'), id: id + '_protectworkbook',
                        tooltipText: l10n.getConstant('ProtectWorkbook')
                    },
                    { type: 'Separator', id: id + '_separator_8' },
                    {
                        template: this.datavalidationDDB(id), tooltipText: l10n.getConstant('DataValidation'),
                        id: id + '_datavalidation'
                    }
                ]
            },
            {
                header: { text: l10n.getConstant('View') }, content: [
                    {
                        prefixIcon: 'e-hide-headers', text: this.getLocaleText('Headers'), id: id + '_headers',
                        tooltipText: this.getLocaleText('Headers')
                    }, { type: 'Separator', id: id + '_separator_9' },
                    {
                        prefixIcon: 'e-hide-gridlines', text: this.getLocaleText('GridLines'), id: id + '_gridlines',
                        tooltipText: this.getLocaleText('GridLines')
                    },
                    { type: 'Separator', id: id + '_separator_13' },
                    { prefixIcon: 'e-freeze-pane', text: l10n.getConstant('FreezePanes'), id: id + '_freezepanes', tooltipText: l10n.getConstant('FreezePanes'), disabled: !this.parent.allowFreezePane },
                    { prefixIcon: 'e-freeze-row', text: l10n.getConstant('FreezeRows'), id: id + '_freezerows', tooltipText: l10n.getConstant('FreezeRows'), disabled: !this.parent.allowFreezePane },
                    { prefixIcon: 'e-freeze-column', text: l10n.getConstant('FreezeColumns'), id: id + '_freezecolumns', tooltipText: l10n.getConstant('FreezeColumns'), disabled: !this.parent.allowFreezePane }
                ]
            }];
        if (this.parent.allowConditionalFormat) {
            items.find((x) => x.header && x.header.text === l10n.getConstant('Home')).content.push({ type: 'Separator', id: id + '_separator_10' }, { template: this.getCFDBB(id), tooltipText: l10n.getConstant('ConditionalFormatting'), id: id + '_conditionalformatting' });
        }
        if (this.parent.allowChart) {
            items.find((x) => x.header && x.header.text === l10n.getConstant('Insert')).content.push({ type: 'Separator', id: id + '_separator_11' }, {
                template: this.getChartDDB(id, true), text: l10n.getConstant('Chart'),
                tooltipText: l10n.getConstant('Chart'), id: id + '_chart'
            });
        }
        if (this.parent.allowCellFormatting) {
            items.find((x) => x.header && x.header.text === l10n.getConstant('Home')).content.push({ type: 'Separator', id: id + '_separator_12' }, { template: this.getClearDDB(id), tooltipText: l10n.getConstant('Clear'), id: id + '_clear' });
        }
        if (this.parent.allowSorting || this.parent.allowFiltering) {
            items.find((x) => x.header && x.header.text === l10n.getConstant('Home')).content.push({ template: this.getSortFilterDDB(id), tooltipText: l10n.getConstant('SortAndFilter'), id: id + '_sorting' });
        }
        if (this.parent.allowFindAndReplace) {
            items.find((x) => x.header && x.header.text === l10n.getConstant('Home')).content.push({
                template: this.getFindBtn(id), prefixIcon: 'e-tbar-search-icon tb-icons',
                tooltipText: l10n.getConstant('FindReplaceTooltip'), id: id + '_find'
            });
        }
        return items;
    }
    createCalcOptions(id, l10n) {
        const typeBtn = createElement('button', { id: id + '_calc_types', attrs: { 'type': 'button' }, className: 'e-calc-types' });
        const typeBtnText = createElement('span', { className: 'e-calc-types-text' });
        typeBtnText.innerText = l10n.getConstant('CalcOptions');
        typeBtn.appendChild(typeBtnText);
        this.calcTypeOptions = new DropDownButton({
            items: [
                { id: id + '_Automatic', text: l10n.getConstant('Automatic'), iconCss: this.parent.calculationMode === 'Automatic' ? 'e-icons e-selected-icon' : '' },
                { id: id + '_Manual', text: l10n.getConstant('Manual'), iconCss: this.parent.calculationMode === 'Manual' ? 'e-icons e-selected-icon' : '' }
            ],
            createPopupOnClick: true,
            iconCss: 'e-calculation e-icons',
            cssClass: 'e-flat e-calc-types'
        });
        this.calcTypeOptions.select = this.selectCalcOptions.bind(this);
        this.calcTypeOptions.appendTo(typeBtn);
        return typeBtn;
    }
    selectCalcOptions(args) {
        if (args.item.id === this.parent.element.id + '_Automatic') {
            this.calcTypeOptions.items[0].iconCss = 'e-icons e-selected-icon';
            this.calcTypeOptions.items[1].iconCss = '';
            if (this.parent.calculationMode === 'Manual') {
                this.parent.notify(workbookFormulaOperation, { action: 'ClearDependentCellCollection' });
            }
            this.parent.setProperties({ calculationMode: 'Automatic' }, true);
            this.updateFormulaButtons();
            this.parent.calculateNow('Workbook');
        }
        else {
            this.calcTypeOptions.items[0].iconCss = '';
            this.calcTypeOptions.items[1].iconCss = 'e-icons e-selected-icon';
            this.parent.setProperties({ calculationMode: 'Manual' }, true);
            this.updateFormulaButtons();
        }
    }
    updateFormulaButtons() {
        const l10n = this.parent.serviceLocator.getService(locale);
        this.parent.notify(enableToolbarItems, [{
                tab: l10n.getConstant('Formulas'), items: [this.parent.element.id + '_calc_current_sheet'],
                enable: this.parent.calculationMode === 'Manual'
            }]);
        this.parent.notify(enableToolbarItems, [{
                tab: l10n.getConstant('Formulas'), items: [this.parent.element.id + '_calc_entire_sheets'],
                enable: this.parent.calculationMode === 'Manual'
            }]);
    }
    getPasteBtn(id, l10n) {
        const btn = this.parent.element.appendChild(this.parent.createElement('button', { id: id + '_paste', attrs: { 'type': 'button' } }));
        this.pasteSplitBtn = new SplitButton({
            iconCss: 'e-icons e-paste-icon',
            items: [
                { text: l10n.getConstant('All'), id: 'All' },
                { text: l10n.getConstant('Values'), id: 'Values' },
                { text: l10n.getConstant('Formats'), id: 'Formats' }
            ],
            createPopupOnClick: true,
            select: (args) => {
                this.pasteSplitBtn.element.setAttribute('aria-label', l10n.getConstant('Paste') + ' ' + args.item.text);
                this.parent.notify(paste, { type: args.item.id, isAction: true, isInternal: true });
            },
            click: () => {
                btn.setAttribute('aria-label', l10n.getConstant('Paste'));
                this.parent.notify(paste, { isAction: true, isInternal: true });
            },
            beforeOpen: (args) => {
                args.element.setAttribute('aria-label', l10n.getConstant('Paste'));
            }
        });
        this.pasteSplitBtn.createElement = this.parent.createElement;
        this.pasteSplitBtn.appendTo(btn);
        return btn.parentElement;
    }
    getHyperlinkDlg() {
        const activeSheet = this.parent.getActiveSheet();
        const indexes = getRangeIndexes(activeSheet.activeCell);
        const cell = getCell(indexes[0], indexes[1], activeSheet);
        if (cell && cell.hyperlink) {
            this.parent.notify(editHyperlink, null);
        }
        else {
            this.parent.notify(initiateHyperlink, null);
        }
    }
    passwordProtectDlg() {
        if (this.parent.password.length > 0) {
            this.parent.notify(unProtectWorkbook, null);
        }
        else {
            if (document.getElementById(this.parent.element.id + '_protectworkbook').classList.contains('e-active')) {
                document.getElementById(this.parent.element.id + '_protectworkbook').classList.remove('e-active');
                if (this.parent.showSheetTabs) {
                    this.parent.element.querySelector('.e-add-sheet-tab').removeAttribute('disabled');
                }
            }
            else {
                this.parent.notify(protectWorkbook, null);
            }
        }
    }
    getLocaleText(str) {
        let text;
        const l10n = this.parent.serviceLocator.getService(locale);
        const sheet = this.parent.getActiveSheet();
        if (sheet['show' + str]) {
            text = l10n.getConstant('Hide' + str);
        }
        else {
            text = l10n.getConstant('Show' + str);
        }
        return text;
    }
    getLocaleProtectText(str, setClass) {
        let text;
        const l10n = this.parent.serviceLocator.getService(locale);
        const sheet = this.parent.getActiveSheet();
        if (sheet.isProtected) {
            if (setClass) {
                this.parent.getMainContent().classList.remove('e-hide-' + str.toLowerCase());
            }
            text = l10n.getConstant('Unprotect' + str);
        }
        else {
            if (setClass) {
                this.parent.getMainContent().classList.add('e-hide-' + str.toLowerCase());
            }
            text = l10n.getConstant('Protect' + str);
        }
        return text;
    }
    getLocaleProtectWorkbook(str, setClass) {
        let text;
        const l10n = this.parent.serviceLocator.getService(locale);
        if (this.parent.isProtected) {
            if (setClass) {
                this.parent.getMainContent().classList.remove('e-hide-' + str.toLowerCase());
            }
            text = l10n.getConstant(str);
        }
        else {
            if (setClass) {
                this.parent.getMainContent().classList.add('e-hide-' + str.toLowerCase());
            }
            text = l10n.getConstant(str);
        }
        return text;
    }
    insertDesignChart() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const tabIdx = this.ribbon.items.length - 1;
        const chartTabHeader = l10n.getConstant('ChartDesign');
        if (this.parent.allowChart && this.ribbon.items[tabIdx] && this.ribbon.items[tabIdx].header.text !==
            chartTabHeader) {
            this.preTabIdx = this.ribbon.selectedTab;
            const id = this.parent.element.id;
            const items = [{
                    header: { text: chartTabHeader },
                    content: [
                        {
                            template: this.getAddChartEleDBB(id),
                            tooltipText: l10n.getConstant('AddChartElement'), id: id + 'add_chart_ element_chart'
                        },
                        { type: 'Separator' },
                        {
                            prefixIcon: 'e-switch-row-column-icon', text: l10n.getConstant('SwitchRowColumn'),
                            tooltipText: l10n.getConstant('SwitchRowColumn'),
                            id: id + 'switch_row_column_chart', click: () => {
                                this.parent.notify(chartDesignTab, { switchRowColumn: true, triggerEvent: true });
                            }
                        },
                        { type: 'Separator' },
                        { template: this.getChartThemeDDB(id), tooltipText: l10n.getConstant('ChartTheme'), id: id + '_chart_theme' },
                        { type: 'Separator' },
                        { template: this.getChartDDB(id, false), tooltipText: l10n.getConstant('ChartType'), id: id + '_chart_type' }
                    ]
                }];
            this.addRibbonTabs({ items: items });
            this.ribbon.tabObj.select(this.ribbon.items.length);
        }
    }
    removeDesignChart() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const tabIdx = this.ribbon.items.length - 1;
        if (this.ribbon.items[tabIdx] && this.ribbon.items[tabIdx].header.text ===
            l10n.getConstant('ChartDesign')) {
            this.ribbon.tabObj.select(this.preTabIdx + 1);
            this.parent.hideRibbonTabs([l10n.getConstant('ChartDesign')], true);
            if (document.getElementsByClassName('e-addchart-ddb').length > 0) {
                document.getElementsByClassName('e-addchart-ddb')[0].remove();
            }
            if (document.getElementsByClassName('e-chart-type-ddb').length > 0) {
                document.getElementsByClassName('e-chart-type-ddb')[0].remove();
            }
            if (document.getElementsByClassName('e-charttheme-ddb').length > 0) {
                document.getElementsByClassName('e-charttheme-ddb')[0].remove();
            }
            delete this.ribbon.items[tabIdx].content[0];
            this.ribbon.items.length = this.ribbon.items.length - 1;
        }
    }
    createRibbon(refEle) {
        const ribbonElement = this.parent.createElement('div', { id: `${this.parent.element.id}_ribbon` });
        this.ribbon = new Ribbon({
            selectedTab: 0,
            menuItems: this.getRibbonMenuItems(),
            items: this.getRibbonItems(),
            fileMenuItemSelect: this.fileMenuItemSelect.bind(this),
            beforeOpen: this.fileMenuBeforeOpen.bind(this),
            beforeClose: this.fileMenuBeforeClose.bind(this),
            clicked: this.toolbarClicked.bind(this),
            created: this.ribbonCreated.bind(this),
            selecting: this.tabSelecting.bind(this),
            expandCollapse: this.expandCollapseHandler.bind(this),
            beforeFileMenuItemRender: this.beforeRenderHandler.bind(this),
            spreadInstance: (this.parent && this.parent.isReact) ? this.parent : null
        });
        this.ribbon.createElement = this.parent.createElement;
        if (refEle) {
            this.parent.element.insertBefore(ribbonElement, refEle);
        }
        else {
            this.parent.element.appendChild(ribbonElement);
        }
        this.ribbon.appendTo(ribbonElement);
    }
    tabSelecting(args) {
        if (args.selectingIndex !== this.ribbon.selectedTab) {
            const l10n = this.parent.serviceLocator.getService(locale);
            if (this.ribbon.items[args.selectingIndex] && this.ribbon.items[args.selectingIndex].header.text ===
                l10n.getConstant('Insert')) {
                const ribbonContent = this.ribbon.items[args.selectingIndex].content;
                for (let i = ribbonContent.length - 1; i >= 0; i--) {
                    if (ribbonContent[i].id === this.parent.element.id + '_chart') {
                        const chartBtn = ribbonContent[i].template;
                        if (chartBtn && !chartBtn.classList.contains('e-dropdown-btn')) {
                            this.createChartDdb(document.getElementById(this.parent.element.id + '_chart-btn'), true);
                        }
                        break;
                    }
                }
            }
            if (this.ribbon.items[args.selectedIndex] && this.ribbon.items[args.selectedIndex].header.text ===
                l10n.getConstant('Insert')) {
                const ribbonContent = this.ribbon.items[args.selectedIndex].content;
                for (let i = ribbonContent.length - 1; i >= 0; i--) {
                    if (ribbonContent[i].id === this.parent.element.id + '_chart') {
                        const chartBtn = ribbonContent[i].template;
                        if (chartBtn && chartBtn.classList.contains('e-dropdown-btn')) {
                            this.destroyComponent(chartBtn, 'dropdown-btn');
                        }
                        break;
                    }
                }
            }
            this.refreshRibbonContent(args.selectingIndex);
            this.parent.notify(tabSwitch, { activeTab: args.selectingIndex });
        }
    }
    beforeRenderHandler(args) {
        const l10n = this.parent.serviceLocator.getService(locale);
        if (args.item.text === l10n.getConstant('Open') && (!this.parent.openUrl || !this.parent.allowOpen)) {
            args.element.classList.add('e-disabled');
        }
        if (args.item.text === l10n.getConstant('SaveAs') && (!this.parent.saveUrl || !this.parent.allowSave)) {
            args.element.classList.add('e-disabled');
        }
        if (args.item.text === l10n.getConstant('Print') && !this.parent.allowPrint) {
            args.element.classList.add('e-disabled');
        }
    }
    getChartThemeDDB(id) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const chartThemeBtn = this.parent.createElement('button', { id: id + '_chart_theme', attrs: { 'type': 'button' }, className: 'e-ss-ddb' });
        chartThemeBtn.appendChild(this.parent.createElement('span', { className: 'e-tbar-btn-text' }));
        let theme = 'Material';
        const overlay = this.parent.element.querySelector('.e-ss-overlay-active');
        if (overlay) {
            let chart = overlay.querySelector('.e-chart');
            if (chart) {
                theme = getComponent(chart, 'chart').theme;
            }
            else {
                chart = overlay.querySelector('.e-accumulationchart');
                if (chart) {
                    theme = getComponent(chart, 'accumulationchart').theme;
                }
            }
        }
        const chartThemeDDB = new DropDownButton({
            items: this.getChartThemeDdbItems(theme),
            content: l10n.getConstant(theme),
            createPopupOnClick: true,
            select: (args) => {
                this.parent.notify(selectionComplete, { type: 'mousedown' });
                if (!args.element || !args.element.querySelector('.e-selected-icon')) {
                    chartThemeDDB.content = args.item.text;
                    chartThemeDDB.dataBind();
                    this.parent.notify(chartDesignTab, { chartTheme: args.item.id, triggerEvent: true });
                    chartThemeDDB.setProperties({ items: this.getChartThemeDdbItems(args.item.id) }, true);
                }
            },
            cssClass: 'e-flat e-charttheme-ddb',
            beforeOpen: (args) => {
                this.tBarDdbBeforeOpen(args.element, args.items, this.parent.serviceLocator.getService(locale).getConstant('Chart'));
            }
        });
        chartThemeDDB.createElement = this.parent.createElement;
        chartThemeDDB.appendTo(chartThemeBtn);
        return chartThemeBtn;
    }
    getNumFormatDDB(id, l10n) {
        const numFormatBtn = this.parent.createElement('button', { id: id + '_number_format', attrs: { 'type': 'button' }, className: 'e-ss-ddb' });
        const numFormatText = this.parent.createElement('span', { className: 'e-tbar-btn-text' });
        numFormatText.innerText = l10n.getConstant('General');
        numFormatBtn.appendChild(numFormatText);
        const eventArgs = { action: 'getLocalizedFormats' };
        this.parent.notify(localizedFormatAction, eventArgs);
        const defaultFormats = eventArgs.defaultFormats;
        const localizedFormats = eventArgs.localizedFormats;
        this.numFormatDDB = new DropDownButton({
            items: this.getNumFormatDdbItems(id),
            createPopupOnClick: true,
            select: (args) => {
                const l10n = this.parent.serviceLocator.getService(locale);
                if (args.item.text === l10n.getConstant('Custom')) {
                    this.renderCustomFormatDialog(defaultFormats, localizedFormats);
                }
                else {
                    const type = args.item.id.split(this.parent.element.id + '_')[1];
                    const format = getFormatFromType(type);
                    this.applyNumFormat(format);
                    const sheet = this.parent.getActiveSheet();
                    this.refreshNumFormatSelection(getTypeFromFormat(format, true), sheet, l10n, format);
                    const cellIndex = getCellIndexes(sheet.activeCell);
                    this.refreshTextAlign(sheet, getCell(cellIndex[0], cellIndex[1], sheet, false, true), type, cellIndex);
                    this.numFormatDDB.element.setAttribute('aria-label', type);
                    if (this.parent.showAggregate) {
                        this.parent.notify(showAggregate, {});
                    }
                }
            },
            open: (args) => this.numDDBOpen(args),
            beforeItemRender: (args) => this.previewNumFormat(args),
            cssClass: 'e-flat e-numformat-ddb',
            beforeOpen: (args) => {
                this.tBarDdbBeforeOpen(args.element, args.items, this.parent.serviceLocator.getService(locale).getConstant('NumberFormat'));
            }
        });
        this.numFormatDDB.createElement = this.parent.createElement;
        this.numFormatDDB.appendTo(numFormatBtn);
        return numFormatBtn;
    }
    getFontSizeDDB(id) {
        this.fontSizeDdb = new DropDownButton({
            cssClass: 'e-font-size-ddb',
            content: '11',
            createPopupOnClick: true,
            items: [{ text: '8' }, { text: '9' }, { text: '10' }, { text: '11' }, { text: '12' }, { text: '14' }, { text: '16' },
                { text: '18' }, { text: '20' }, { text: '22' }, { text: '24' }, { text: '26' }, { text: '28' }, { text: '36' },
                { text: '48' }, { text: '72' }],
            beforeOpen: (args) => {
                this.tBarDdbBeforeOpen(args.element, args.items, this.parent.serviceLocator.getService(locale).getConstant('FontSize'));
                this.refreshSelected(this.fontSizeDdb, args.element, 'content', 'text');
            },
            select: (args) => {
                const eventArgs = { style: { fontSize: `${args.item.text}pt` }, onActionUpdate: true };
                this.parent.notify(setCellFormat, eventArgs);
                if (!eventArgs.cancel) {
                    this.fontSizeDdb.content = eventArgs.style.fontSize.split('pt')[0];
                    this.fontSizeDdb.dataBind();
                }
                this.fontSizeDdb.element.setAttribute('aria-label', args.item.text);
            }
        });
        this.fontSizeDdb.createElement = this.parent.createElement;
        this.fontSizeDdb.appendTo(this.parent.createElement('button', { id: id + '_font_size', attrs: { 'type': 'button' }, className: 'e-ss-ddb' }));
        return this.fontSizeDdb.element;
    }
    getChartDDB(id, isChart) {
        const l10n = this.parent.serviceLocator.getService(locale);
        let chartBtn;
        if (isChart) {
            chartBtn = this.parent.createElement('button', { id: id + '_chart-btn', attrs: { 'type': 'button' } });
            const chartBtnSpan = this.parent.createElement('span', { id: id + '_chart' });
            chartBtnSpan.innerText = l10n.getConstant('Chart');
            chartBtn.appendChild(chartBtnSpan);
        }
        else {
            chartBtn = this.parent.createElement('button', { id: id + '_chart-type-btn', attrs: { 'type': 'button' } });
            const chartBtnSpan = this.parent.createElement('span', { id: id + '_chart_type' });
            chartBtnSpan.innerText = l10n.getConstant('ChartType');
            chartBtn.appendChild(chartBtnSpan);
            this.createChartDdb(chartBtn, false);
        }
        return chartBtn;
    }
    closeDropdownPopup(e) {
        if ((e.altKey && e.keyCode === 38) || e.keyCode === 27) {
            const dropdownObj = this[1];
            if (dropdownObj) {
                dropdownObj.toggle();
                focus(dropdownObj.element);
            }
        }
    }
    createChartDdb(chartBtn, isChart) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const menuClass = isChart ? 'e-chart-menu' : 'e-chart-type-menu';
        const ul = this.parent.createElement('ul', { id: `${this.parent.element.id}${isChart ? '_chart_menu' : '_chart_type_menu'}` });
        let chartMenu;
        const chartDdb = new DropDownButton({
            iconCss: `e-icons ${isChart ? 'e-chart-icon' : 'e-chart-type-icon'}`,
            cssClass: isChart ? 'e-chart-ddb' : 'e-chart-type-ddb',
            target: ul,
            createPopupOnClick: true,
            beforeOpen: (args) => {
                chartMenu = this.createChartMenu(ul, menuClass, l10n, chartDdb);
                this.tBarDdbBeforeOpen(args.element, chartMenu.items, this.parent.serviceLocator.getService(locale).getConstant('Chart'));
                EventHandler.add(ul, 'keydown', this.closeDropdownPopup, [this, chartDdb]);
            },
            open: () => focus(ul),
            beforeClose: (args) => {
                if (args.event && closest(args.event.target, '.' + menuClass)) {
                    args.cancel = true;
                }
                else {
                    EventHandler.remove(ul, 'keydown', this.closeDropdownPopup);
                    chartMenu.destroy();
                }
            }
        });
        chartDdb.createElement = this.parent.createElement;
        chartDdb.appendTo(chartBtn);
    }
    createChartMenu(ul, cssClass, l10n, chartDdb) {
        const chartMenu = new Menu({
            cssClass: cssClass,
            items: [
                {
                    iconCss: 'e-icons e-column', text: l10n.getConstant('Column'),
                    items: [{ id: 'column_chart' }]
                },
                {
                    iconCss: 'e-icons e-bar', text: l10n.getConstant('Bar'),
                    items: [{ id: 'bar_chart' }]
                },
                {
                    iconCss: 'e-icons e-area', text: l10n.getConstant('Area'),
                    items: [{ id: 'area_chart' }]
                },
                {
                    iconCss: 'e-icons e-pie-doughnut', text: l10n.getConstant('PieAndDoughnut'),
                    items: [{ id: 'pie_doughnut_chart' }]
                },
                {
                    iconCss: 'e-icons e-line', text: l10n.getConstant('Line'),
                    items: [{ id: 'line_chart' }]
                },
                // {
                //     iconCss: 'e-icons e-radar', text: l10n.getConstant('Radar'),
                //     items: [{ id: 'radar_chart' }]
                // },
                {
                    iconCss: 'e-icons e-scatter', text: l10n.getConstant('Scatter'),
                    items: [{ id: 'scatter_chart' }]
                }
            ],
            orientation: 'Vertical',
            beforeOpen: (args) => {
                let wrapperCls;
                if (args.parentItem.text === l10n.getConstant('Column')) {
                    args.element.firstChild.appendChild(column);
                    wrapperCls = 'e-column-chart';
                }
                else if (args.parentItem.text === l10n.getConstant('Bar')) {
                    args.element.firstChild.appendChild(bar);
                    wrapperCls = 'e-bar-chart';
                }
                else if (args.parentItem.text === l10n.getConstant('Area')) {
                    args.element.firstChild.appendChild(area);
                    wrapperCls = 'e-area-chart';
                }
                else if (args.parentItem.text === l10n.getConstant('Line')) {
                    args.element.firstChild.appendChild(line);
                    wrapperCls = 'e-line-chart';
                }
                else if (args.parentItem.text === l10n.getConstant('PieAndDoughnut')) {
                    args.element.firstChild.appendChild(pie);
                    wrapperCls = 'e-pie-doughnut-chart';
                }
                else if (args.parentItem.text === l10n.getConstant('Radar')) {
                    args.element.firstChild.appendChild(radar);
                    wrapperCls = 'e-radar-chart';
                }
                else if (args.parentItem.text === l10n.getConstant('Scatter')) {
                    args.element.firstChild.appendChild(scatter);
                    wrapperCls = 'e-scatter-chart';
                }
                if (wrapperCls) {
                    args.element.parentElement.classList.add(wrapperCls);
                    EventHandler.add(args.element, 'keydown', this.menuIconKeyDown.bind(this, `${wrapperCls} .e-menu-icon`, 0));
                }
            },
            select: (args) => this.chartSelected(args, chartDdb),
            beforeItemRender: (args) => {
                if (!args.item.text) {
                    args.element.removeAttribute('tabindex');
                }
            },
            beforeClose: (args) => {
                if (args.event && args.event.keyCode === 37) {
                    args.cancel = true;
                }
                else {
                    EventHandler.remove(args.element, 'keydown', this.menuIconKeyDown);
                }
            }
        });
        const column = this.parent.createElement('div', { id: 'column_main', className: 'e-column-main' });
        const column1Text = this.parent.createElement('div', { id: 'column1_text', className: 'e-column1-text' });
        column1Text.innerText = l10n.getConstant('Column');
        const column1Cont = this.parent.createElement('div', { id: 'column1_cont', className: 'e-column1-cont' });
        const column2Cont = this.parent.createElement('div', { id: 'column2_cont', className: 'e-column2-cont' });
        column.appendChild(column1Text);
        column.appendChild(column1Cont);
        //column.appendChild(column2Text);
        //column.appendChild(column2Cont);
        let cultureText = l10n.getConstant('ClusteredColumn');
        const clusteredColumn = this.parent.createElement('span', { id: 'clusteredColumn', className: 'e-clusteredcolumn e-column-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        cultureText = l10n.getConstant('StackedColumn');
        const stackedColumn = this.parent.createElement('span', { id: 'stackedColumn', className: 'e-stackedcolumn e-column-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        cultureText = l10n.getConstant('StackedColumn100');
        const stackedColumn100 = this.parent.createElement('span', { id: 'stackedColumn100', className: 'e-stackedcolumn100 e-column-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        const clusteredColumn3D = this.parent.createElement('span', { id: 'clusteredColumn3D', className: 'e-clusteredColumn3D e-column-icon' });
        const stackedColumn3D = this.parent.createElement('span', { id: 'stackedColumn3D', className: 'e-stackedColumn3D e-column-icon' });
        const stackedColumn1003D = this.parent.createElement('span', { id: 'stackedColumn1003D', className: 'e-stackedColumn1003D e-column-icon' });
        column1Cont.appendChild(clusteredColumn);
        column1Cont.appendChild(stackedColumn);
        column1Cont.appendChild(stackedColumn100);
        column2Cont.appendChild(clusteredColumn3D);
        column2Cont.appendChild(stackedColumn3D);
        column2Cont.appendChild(stackedColumn1003D);
        const bar = this.parent.createElement('div', { id: 'bar_main', className: 'e-bar-main' });
        const bar1Text = this.parent.createElement('div', { id: 'bar1_text', className: 'e-bar1-text' });
        bar1Text.innerText = l10n.getConstant('Bar');
        const bar1Cont = this.parent.createElement('div', { id: 'bar1_cont', className: 'e-bar1-cont' });
        const bar2Cont = this.parent.createElement('div', { id: 'bar2_cont', className: 'e-bar2-cont' });
        bar.appendChild(bar1Text);
        bar.appendChild(bar1Cont);
        //bar.appendChild(bar2Text);
        //bar.appendChild(bar2Cont);
        cultureText = l10n.getConstant('ClusteredBar');
        const clusteredBar = this.parent.createElement('span', { id: 'clusteredBar', className: 'e-clusteredbar e-bar-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        cultureText = l10n.getConstant('StackedBar');
        const stackedBar = this.parent.createElement('span', { id: 'stackedBar', className: 'e-stackedbar e-bar-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        cultureText = l10n.getConstant('StackedBar100');
        const stackedBar100 = this.parent.createElement('span', { id: 'stackedBar100', className: 'e-stackedbar100 e-bar-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        const clusteredBar3D = this.parent.createElement('span', { id: 'clusteredBar3D', className: 'e-clusteredBar3D e-bar-icon' });
        const stackedBar3D = this.parent.createElement('span', { id: 'stackedBar3D', className: 'e-stackedBar3D e-bar-icon' });
        const stackedBar1003D = this.parent.createElement('span', { id: 'stackedBar1003D', className: 'e-stackedBar1003D e-bar-icon' });
        bar1Cont.appendChild(clusteredBar);
        bar1Cont.appendChild(stackedBar);
        bar1Cont.appendChild(stackedBar100);
        bar2Cont.appendChild(clusteredBar3D);
        bar2Cont.appendChild(stackedBar3D);
        bar2Cont.appendChild(stackedBar1003D);
        const area = this.parent.createElement('div', { id: 'area_main', className: 'e-area-main' });
        const areaText = this.parent.createElement('div', { id: 'area_text', className: 'e-area-text' });
        areaText.innerText = l10n.getConstant('Area');
        const areaCont = this.parent.createElement('div', { id: 'area_cont', className: 'e-area-cont' });
        area.appendChild(areaText);
        area.appendChild(areaCont);
        cultureText = l10n.getConstant('Area');
        const defArea = this.parent.createElement('span', { id: 'area', className: 'e-area e-area-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        cultureText = l10n.getConstant('StackedArea');
        const stackedArea = this.parent.createElement('span', { id: 'stackedArea', className: 'e-stackedarea e-area-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        cultureText = l10n.getConstant('StackedArea100');
        const stackedArea100 = this.parent.createElement('span', { id: 'stackedArea100', className: 'e-stackedarea100 e-area-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        areaCont.appendChild(defArea);
        areaCont.appendChild(stackedArea);
        areaCont.appendChild(stackedArea100);
        const line = this.parent.createElement('div', { id: 'line_main', className: 'e-line-main' });
        const lineText = this.parent.createElement('div', { id: 'line_text', className: 'e-line-text' });
        lineText.innerText = l10n.getConstant('Line');
        const lineCont = this.parent.createElement('div', { id: 'line_cont', className: 'e-line-cont' });
        const lineContMarker = this.parent.createElement('div', { id: 'line_cont_marker', className: 'e-line-cont' });
        line.appendChild(lineText);
        line.appendChild(lineCont);
        line.appendChild(lineContMarker);
        cultureText = l10n.getConstant('Line');
        const defLine = this.parent.createElement('span', { id: 'line', className: 'e-line e-line-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        cultureText = l10n.getConstant('StackedLine');
        const stackedLine = this.parent.createElement('span', { id: 'stackedLine', className: 'e-stackedline e-line-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        cultureText = l10n.getConstant('StackedLine100');
        const stackedLine100 = this.parent.createElement('span', { id: 'stackedLine100', className: 'e-stackedline100 e-line-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        cultureText = l10n.getConstant('LineMarker');
        const defLineMarker = this.parent.createElement('span', { id: 'lineMarker', className: 'e-line-marker e-line-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        cultureText = l10n.getConstant('StackedLineMarker');
        const stackedLineMarker = this.parent.createElement('span', { id: 'stackedLineMarker', className: 'e-stackedline-marker e-line-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        cultureText = l10n.getConstant('StackedLine100Marker');
        const stackedLine100Marker = this.parent.createElement('span', { id: 'stackedLine100Marker', className: 'e-stackedline100-marker e-line-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        lineCont.appendChild(defLine);
        lineCont.appendChild(stackedLine);
        lineCont.appendChild(stackedLine100);
        lineContMarker.appendChild(defLineMarker);
        lineContMarker.appendChild(stackedLineMarker);
        lineContMarker.appendChild(stackedLine100Marker);
        const pie = this.parent.createElement('div', { id: 'pie_main', className: 'e-pie-main' });
        const pieText = this.parent.createElement('div', { id: 'pie_text', className: 'e-pie-text' });
        pieText.innerText = l10n.getConstant('Pie');
        const pieCont = this.parent.createElement('div', { id: 'pie_cont', className: 'e-pie-cont' });
        pie.appendChild(pieText);
        pie.appendChild(pieCont);
        cultureText = l10n.getConstant('Pie');
        const defPie = this.parent.createElement('span', { id: 'pie', className: 'e-pie e-pie-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        cultureText = l10n.getConstant('Doughnut');
        const doughnut = this.parent.createElement('span', { id: 'doughnut', className: 'e-doughnut e-pie-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        pieCont.appendChild(defPie);
        pieCont.appendChild(doughnut);
        const radar = this.parent.createElement('div', { id: 'radar_main', className: 'e-radar-main' });
        const radarText = this.parent.createElement('div', { id: 'radar_text', className: 'e-radar-text' });
        radarText.innerText = l10n.getConstant('Radar');
        const radarCont = this.parent.createElement('div', { id: 'radar_cont', className: 'e-radar-cont' });
        radar.appendChild(radarText);
        radar.appendChild(radarCont);
        const defradar = this.parent.createElement('span', { id: 'radar', className: 'e-radar e-radar-icon e-menu-icon e-icons', attrs: { tabindex: '-1' } });
        const radarMarkers = this.parent.createElement('span', { id: 'radar_markers', className: 'e-radar-markers e-radar-icon e-menu-icon e-icons', attrs: { tabindex: '-1' } });
        defradar.title = l10n.getConstant('BlueDataBar');
        radarMarkers.title = l10n.getConstant('GreenDataBar');
        radarCont.appendChild(defradar);
        radarCont.appendChild(radarMarkers);
        const scatter = this.parent.createElement('div', { id: 'scatter_main', className: 'e-scatter-main' });
        const scatterText = this.parent.createElement('div', { id: 'scatter_text', className: 'e-scatter-text' });
        cultureText = l10n.getConstant('Scatter');
        scatterText.innerText = cultureText;
        const scatterCont = this.parent.createElement('div', { id: 'scatter_cont', className: 'e-scatter-cont' });
        scatter.appendChild(scatterText);
        scatter.appendChild(scatterCont);
        const defscatter = this.parent.createElement('span', { id: 'scatter', className: 'e-scatter e-scatter-icon e-menu-icon e-icons',
            attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' } });
        scatterCont.appendChild(defscatter);
        chartMenu.createElement = this.parent.createElement;
        chartMenu.appendTo(ul);
        ul.classList.add('e-ul');
        return chartMenu;
    }
    getAddChartEleDBB(id) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const ul = this.parent.createElement('ul', { id: id + '_add_chart_menu' });
        let addChartMenu;
        this.addChartDdb = new DropDownButton({
            iconCss: 'e-icons e-addchart-icon',
            cssClass: 'e-addchart-ddb',
            target: ul,
            createPopupOnClick: true,
            close: () => focus(this.parent.element),
            beforeOpen: (args) => {
                addChartMenu = this.createAddChartMenu(ul, l10n);
                this.tBarDdbBeforeOpen(args.element, addChartMenu.items);
                EventHandler.add(ul, 'keydown', this.closeDropdownPopup, [this, this.addChartDdb]);
            },
            open: () => focus(ul),
            beforeClose: (args) => {
                if (args.event && closest(args.event.target, '.e-addchart-menu')) {
                    args.cancel = true;
                }
                else {
                    EventHandler.remove(ul, 'keydown', this.closeDropdownPopup);
                    addChartMenu.destroy();
                }
            }
        });
        this.addChartDdb.createElement = this.parent.createElement;
        const addChartBtn = this.parent.createElement('button', { id: id + '_addchart', attrs: { 'type': 'button' } });
        const chartBtnText = this.parent.createElement('span', { id: id + '_chart' });
        chartBtnText.innerText = l10n.getConstant('AddChartElement');
        addChartBtn.appendChild(chartBtnText);
        this.addChartDdb.appendTo(addChartBtn);
        return this.addChartDdb.element;
    }
    createAddChartMenu(ul, l10n) {
        const addChartMenu = new Menu({
            cssClass: 'e-addchart-menu', title: l10n.getConstant('AddChartElement'),
            items: [{
                    iconCss: 'e-icons e-axes', text: l10n.getConstant('Axes'),
                    items: [{
                            iconCss: 'e-icons e-ph-axes', id: 'PHAxes',
                            text: l10n.getConstant('PrimaryHorizontal')
                        },
                        {
                            iconCss: 'e-icons e-pv-axes', id: 'PVAxes',
                            text: l10n.getConstant('PrimaryVertical')
                        }]
                },
                {
                    iconCss: 'e-icons e-axis-title', text: l10n.getConstant('AxisTitle'),
                    items: [{
                            iconCss: 'e-icons e-ph-axistitle', id: 'PHAxisTitle',
                            text: l10n.getConstant('PrimaryHorizontal')
                        },
                        {
                            iconCss: 'e-icons e-pv-axistitle', id: 'PVAxisTitle',
                            text: l10n.getConstant('PrimaryVertical')
                        }]
                },
                {
                    iconCss: 'e-icons e-chart-title', text: l10n.getConstant('ChartTitle'),
                    items: [{ iconCss: 'e-icons e-ct-none', id: 'ChartTitleNone', text: l10n.getConstant('None') },
                        { iconCss: 'e-icons e-ct-abovechart', id: 'ChartTitleAbove', text: l10n.getConstant('AboveChart') }
                        // { iconCss: 'e-icons e-ct-farchart', id: 'chart_farchart', text: l10n.getConstant('AboveChart') },
                        // { iconCss: 'e-icons e-ct-nearchart', id: 'chart_nearchart', text: l10n.getConstant('AboveChart') }
                    ]
                },
                {
                    iconCss: 'e-icons e-data-labels', id: this.parent.element.id + 'data-labels', text: l10n.getConstant('DataLabels'),
                    items: [{ iconCss: 'e-icons e-dl-none', id: 'DLNone', text: l10n.getConstant('None') },
                        { iconCss: 'e-icons e-dl-center', id: 'DLCenter', text: l10n.getConstant('Center') },
                        { iconCss: 'e-icons e-dl-insideend', id: 'DLInsideend', text: l10n.getConstant('InsideEnd') },
                        { iconCss: 'e-icons e-dl-insidebase', id: 'DLInsidebase', text: l10n.getConstant('InsideBase') },
                        { iconCss: 'e-icons e-dl-outsideend', id: 'DLOutsideend', text: l10n.getConstant('OutsideEnd') }]
                },
                {
                    iconCss: 'e-icons e-gridlines', text: l10n.getConstant('Gridlines'),
                    items: [{
                            iconCss: 'e-icons e-gl-major-horizontal', id: 'GLMajorHorizontal',
                            text: l10n.getConstant('PrimaryMajorHorizontal')
                        },
                        {
                            iconCss: 'e-icons e-gl-major-vertical', id: 'GLMajorVertical',
                            text: l10n.getConstant('PrimaryMajorVertical')
                        },
                        {
                            iconCss: 'e-icons e-gl-minor-horizontal', id: 'GLMinorHorizontal',
                            text: l10n.getConstant('PrimaryMinorHorizontal')
                        },
                        {
                            iconCss: 'e-icons e-gl-minor-vertical', id: 'GLMinorVertical',
                            text: l10n.getConstant('PrimaryMinorVertical')
                        }]
                },
                {
                    iconCss: 'e-icons e-legends', text: l10n.getConstant('Legends'),
                    items: [{ iconCss: 'e-icons e-legends-none', id: 'LegendNone', text: l10n.getConstant('None') },
                        { iconCss: 'e-icons e-legends-right', id: 'LegendsRight', text: l10n.getConstant('Right') },
                        { iconCss: 'e-icons e-legends-left', id: 'LegendsLeft', text: l10n.getConstant('Left') },
                        { iconCss: 'e-icons e-legends-bottom', id: 'LegendsBottom', text: l10n.getConstant('Bottom') },
                        { iconCss: 'e-icons e-legends-top', id: 'LegendsTop', text: l10n.getConstant('Top') }]
                }],
            orientation: 'Vertical',
            select: this.addChartEleSelected.bind(this),
            beforeOpen: (args) => {
                if (args.parentItem.id === this.parent.element.id + 'data-labels') {
                    const overlay = this.parent.element.querySelector('.e-ss-overlay-active');
                    if (overlay) {
                        const chart = overlay.querySelector('.e-chart');
                        if (chart) {
                            const chartObj = getComponent(chart, 'chart');
                            if (chartObj.series[0] && chartObj.series[0].type.includes('Line')) {
                                const updateTextNode = (listIcon, key) => {
                                    if (listIcon) {
                                        const dlList = listIcon.parentElement;
                                        dlList.innerHTML = '';
                                        dlList.appendChild(listIcon);
                                        dlList.appendChild(document.createTextNode(l10n.getConstant(key)));
                                    }
                                };
                                updateTextNode(args.element.querySelector('.e-dl-insideend'), 'Above');
                                updateTextNode(args.element.querySelector('.e-dl-insidebase'), 'Below');
                                const outsideIcon = args.element.querySelector('.e-dl-outsideend');
                                if (outsideIcon) {
                                    outsideIcon.parentElement.style.display = 'none';
                                }
                            }
                        }
                    }
                }
            }
        });
        addChartMenu.createElement = this.parent.createElement;
        addChartMenu.appendTo(ul);
        ul.classList.add('e-ul');
        return addChartMenu;
    }
    getCFDBB(id) {
        const ul = this.parent.createElement('ul', { id: id + '_cf_menu' });
        let cfMenu;
        this.cfDdb = new DropDownButton({
            iconCss: 'e-icons e-conditionalformatting-icon',
            cssClass: 'e-cf-ddb',
            target: ul,
            createPopupOnClick: true,
            close: () => focus(this.parent.element),
            beforeOpen: (args) => {
                cfMenu = this.createCFMenu(ul);
                this.tBarDdbBeforeOpen(args.element, cfMenu.items, this.parent.serviceLocator.getService(locale).getConstant('ConditionalFormatting'));
                EventHandler.add(ul, 'keydown', this.closeDropdownPopup, [this, this.cfDdb]);
            },
            open: () => focus(ul),
            beforeClose: (args) => {
                if (args.event && closest(args.event.target, '.e-cf-menu')) {
                    args.cancel = true;
                }
                else {
                    EventHandler.remove(ul, 'keydown', this.closeDropdownPopup);
                    if (cfMenu && cfMenu.element) {
                        removeElements(this.spanElements);
                        this.spanElements = [];
                        removeElements(this.iconWrapElements);
                        this.iconWrapElements = [];
                        removeElements(this.iconSetElements);
                        this.iconSetElements = [];
                        removeElements(this.iconSetGroupElement);
                        this.iconSetGroupElement = [];
                        cfMenu.destroy();
                        cfMenu.element.remove();
                    }
                }
            }
        });
        this.cfDdb.createElement = this.parent.createElement;
        this.cfDdb.appendTo(this.parent.createElement('button', { id: id + '_conditionalformatting', attrs: { 'type': 'button' } }));
        return this.cfDdb.element;
    }
    createCFMenu(ul) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const addIcons = (icons, category, appendTo) => {
            let content;
            icons.forEach((icon) => {
                content = l10n.getConstant(icon + category);
                const span = this.parent.createElement('span', {
                    id: icon + category, className: `e-${icon.toLowerCase()} e-cf-icon`,
                    attrs: { 'title': content, 'aria-label': content, tabindex: '-1' }
                });
                this.spanElements.push(span);
                appendTo.appendChild(span);
            });
        };
        const cfMenu = new Menu({
            cssClass: 'e-cf-menu',
            items: [{
                    iconCss: 'e-icons e-hlcellrules', text: l10n.getConstant('HighlightCellsRules'),
                    items: [{ iconCss: 'e-icons e-greaterthan', id: 'cf_greaterthan_dlg', text: l10n.getConstant('GreaterThan') + '...' },
                        { iconCss: 'e-icons e-lessthan', id: 'cf_lessthan_dlg', text: l10n.getConstant('LessThan') + '...' },
                        { iconCss: 'e-icons e-between', id: 'cf_between_dlg', text: l10n.getConstant('Between') + '...' },
                        { iconCss: 'e-icons e-equalto', id: 'cf_eqaulto_dlg', text: l10n.getConstant('CFEqualTo') + '...' },
                        { iconCss: 'e-icons e-textcontains', id: 'cf_textcontains_dlg', text: l10n.getConstant('TextThatContains') + '...' },
                        { iconCss: 'e-icons e-adateoccuring', id: 'cf_adateoccuring_dlg', text: l10n.getConstant('ADateOccuring') + '...' },
                        { iconCss: 'e-icons e-duplicate', id: 'cf_duplicatevalues_dlg', text: l10n.getConstant('DuplicateValues') + '...' }]
                },
                {
                    iconCss: 'e-icons e-topbottomrules', text: l10n.getConstant('TopBottomRules'),
                    items: [{ iconCss: 'e-icons e-top10items', id: 'cf_top10items_dlg', text: l10n.getConstant('Top10Items') + '...' },
                        { iconCss: 'e-icons e-top10', id: 'cf_top10_dlg', text: l10n.getConstant('Top10') + ' %...' },
                        { iconCss: 'e-icons e-bottom10items', id: 'cf_bottom10items_dlg', text: l10n.getConstant('Bottom10Items') + '...' },
                        { iconCss: 'e-icons e-bottom10', id: 'cf_bottom10_dlg', text: l10n.getConstant('Bottom10') + ' %...' },
                        { iconCss: 'e-icons e-aboveaverage', id: 'cf_aboveaverage_dlg', text: l10n.getConstant('AboveAverage') + '...' },
                        { iconCss: 'e-icons e-belowaverage', id: 'cf_belowaverage_dlg', text: l10n.getConstant('BelowAverage') + '...' }]
                },
                { iconCss: 'e-icons e-databars', text: l10n.getConstant('DataBars'), items: [{ id: 'db_icons1' }, { id: 'db_icons2' }] },
                { iconCss: 'e-icons e-colorscales', text: l10n.getConstant('ColorScales'), items: [{ id: 'cs_icons1' }, { id: 'cs_icons2' },
                        { id: 'cs_icons3' }] },
                { iconCss: 'e-icons e-iconsets', text: l10n.getConstant('IconSets'), items: [{ id: 'is_icons' }] },
                {
                    iconCss: 'e-icons e-clearrules', text: l10n.getConstant('ClearRules'),
                    items: [{ id: 'cf_cr_cells', text: l10n.getConstant('SelectedCells') },
                        { id: 'cf_cr_sheet', text: l10n.getConstant('EntireSheet') }]
                }],
            orientation: 'Vertical',
            beforeOpen: (args) => {
                if (args.parentItem.iconCss === 'e-icons e-databars') {
                    args.element.parentElement.classList.add('e-databars');
                    addIcons(['Blue', 'Green', 'Red'], 'DataBar', args.element.firstChild);
                    addIcons(['Orange', 'LightBlue', 'Purple'], 'DataBar', args.element.lastChild);
                    EventHandler.add(args.element, 'keydown', this.menuIconKeyDown.bind(this, 'e-cf-icon', 3));
                }
                else if (args.parentItem.iconCss === 'e-icons e-colorscales') {
                    args.element.parentElement.classList.add('e-colorscales');
                    addIcons(['GYR', 'RYG', 'GWR', 'RWG'], 'ColorScale', args.element.firstChild);
                    addIcons(['BWR', 'RWB', 'WR', 'RW'], 'ColorScale', args.element.querySelector('#cs_icons2'));
                    addIcons(['GW', 'WG', 'GY', 'YG'], 'ColorScale', args.element.lastChild);
                    EventHandler.add(args.element, 'keydown', this.menuIconKeyDown.bind(this, 'e-cf-icon', 4));
                }
                else if (args.parentItem.iconCss === 'e-icons e-iconsets') {
                    args.element.parentElement.classList.add('e-iconsets');
                    const iconSetGroup = this.parent.createElement('div', { id: 'is', className: 'e-is' });
                    this.iconSetGroupElement.push(iconSetGroup);
                    const iconSets = [
                        { hdr: 'Directional' }, {
                            cont: [
                                { cls: '3arrows', key: 'ThreeArrowsColor', id: 'ThreeArrows', count: 3 },
                                { cls: '3arrowsgray', key: 'ThreeArrowsGray', count: 3 },
                                { cls: '3triangles', key: 'ThreeTriangles', count: 3 },
                                { cls: '4arrowsgray', key: 'FourArrowsGray', count: 4 },
                                { cls: '4arrows', key: 'FourArrowsColor', id: 'FourArrows', count: 4 },
                                { cls: '5arrowsgray', key: 'FiveArrowsGray', count: 5 },
                                { cls: '5arrows', key: 'FiveArrowsColor', id: 'FiveArrows', count: 5 }
                            ]
                        },
                        { hdr: 'Shapes' }, {
                            cont: [
                                { cls: '3trafficlights', key: 'ThreeTrafficLights1', count: 3 },
                                { cls: '3rafficlights2', key: 'ThreeTrafficLights2', count: 3 },
                                { cls: '3signs', key: 'ThreeSigns', count: 3 },
                                { cls: '4trafficlights', key: 'FourTrafficLights', count: 4 },
                                { cls: '4redtoblack', key: 'RedToBlack', id: 'FourRedToBlack', count: 4 }
                            ]
                        },
                        { hdr: 'Indicators' }, {
                            cont: [
                                { cls: '3symbols', key: 'ThreeSymbols1', id: 'ThreeSymbols', count: 3 },
                                { cls: '3symbols2', key: 'ThreeSymbols2', count: 3 },
                                { cls: '3flags', key: 'ThreeFlags', count: 3 }
                            ]
                        },
                        { hdr: 'Ratings' }, {
                            cont: [
                                { cls: '3stars', key: 'ThreeStars', count: 3 },
                                { cls: '4rating', key: 'FourRatings', id: 'FourRating', count: 4 },
                                { cls: '5quarters', key: 'FiveQuarters', count: 5 },
                                { cls: '5rating', key: 'FiveRatings', id: 'FiveRating', count: 5 },
                                { cls: '5boxes', key: 'FiveBoxes', count: 5 }
                            ]
                        }
                    ];
                    let iconSetEle;
                    let iconWrap;
                    let cultureText;
                    let countIdx;
                    iconSets.forEach((iconSet, index) => {
                        iconSetEle = this.parent.createElement('div', { id: `is${index + 1}`, className: `e-is${index + 1}` });
                        this.iconSetElements.push(iconSetEle);
                        if (iconSet.hdr) {
                            iconSetEle.innerText = l10n.getConstant(iconSet.hdr);
                        }
                        else {
                            iconSet.cont.forEach((icon) => {
                                cultureText = l10n.getConstant(icon.key);
                                iconWrap =
                                    this.parent.createElement('div', {
                                        id: icon.id || icon.key, className: `e-${icon.cls} e-is-wrapper`,
                                        attrs: { title: cultureText, 'aria-label': cultureText, tabindex: '-1' }
                                    });
                                this.iconWrapElements.push(iconWrap);
                                for (countIdx = 0; countIdx < icon.count; countIdx++) {
                                    const span = this.createElement('span', `e-${icon.cls}-${countIdx + 1} e-iconsetspan`);
                                    this.spanElements.push(span);
                                    iconWrap.appendChild(span);
                                }
                                iconSetEle.appendChild(iconWrap);
                            });
                        }
                        iconSetGroup.appendChild(iconSetEle);
                    });
                    args.element.firstChild.appendChild(iconSetGroup);
                    EventHandler.add(args.element, 'keydown', this.menuIconKeyDown.bind(this, 'e-is-wrapper', 0));
                }
            },
            select: this.cfSelected.bind(this),
            beforeItemRender: (args) => {
                if (args.item.id.includes('db_icons') || args.item.id.includes('cs_icons') || args.item.id === 'is_icons') {
                    args.element.removeAttribute('tabindex');
                }
            },
            beforeClose: (args) => {
                const cfIcons = ['e-icons e-databars', 'e-icons e-colorscales', 'e-icons e-iconsets'].indexOf(args.parentItem.iconCss) > -1;
                args.cancel = args.event && args.event.keyCode === 37 && cfIcons;
                if (cfIcons && !args.cancel) {
                    EventHandler.remove(args.element, 'keydown', this.menuIconKeyDown);
                }
            }
        });
        cfMenu.createElement = this.parent.createElement;
        cfMenu.appendTo(ul);
        ul.classList.add('e-ul');
        return cfMenu;
    }
    menuIconKeyDown(iconCls, rowWiseCount, e) {
        let index;
        let icons = [];
        if (!e) {
            index = 0;
            icons = [].slice.call(document.querySelectorAll(`.${iconCls}`));
        }
        else if (e.keyCode === 40 || e.keyCode === 39 || e.keyCode === 38 || e.keyCode === 37) {
            e.preventDefault();
            icons = [].slice.call(document.querySelectorAll(`.${iconCls}`));
            index = icons.indexOf(e.target);
            if (index === -1) {
                index = 0;
            }
            else if (e.keyCode === 39) {
                index++;
                if (index === icons.length) {
                    index = 0;
                }
            }
            else if (e.keyCode === 37) {
                index--;
                if (index === -1) {
                    index = icons.length - 1;
                }
            }
            else if (!iconCls.includes('e-menu-icon')) {
                let totalIcons = icons.length;
                let firstIndexes;
                let secIndexes;
                if (!rowWiseCount) {
                    rowWiseCount = 2;
                    if (e.keyCode === 40) {
                        firstIndexes = [6, 11, 14, 19];
                        secIndexes = [5, 10, 13];
                    }
                    else {
                        firstIndexes = [7, 12, 15];
                        secIndexes = [8, 13, 16];
                    }
                    totalIcons--;
                }
                if (e.keyCode === 40) {
                    if (index === totalIcons - 1) {
                        index = 0;
                    }
                    else {
                        index += firstIndexes && firstIndexes.indexOf(index) > -1 ? 1 :
                            (secIndexes && secIndexes.indexOf(index) > -1 ? 3 : rowWiseCount);
                        if (firstIndexes) {
                            totalIcons++;
                        }
                        if (index >= totalIcons) {
                            index = (index - totalIcons) + 1;
                        }
                    }
                }
                else {
                    if (index === 0) {
                        index = totalIcons - 1;
                    }
                    else {
                        index -= firstIndexes && firstIndexes.indexOf(index) > -1 ? 1 :
                            (secIndexes && secIndexes.indexOf(index) > -1 ? 3 : rowWiseCount);
                        if (index < 0) {
                            index = firstIndexes ? totalIcons : (totalIcons + index) - 1;
                        }
                    }
                }
            }
        }
        if (icons[index]) {
            focus(icons[index]);
        }
    }
    createElement(tag, className) {
        return this.parent.createElement(tag, { className: className });
    }
    getBordersDBB(id) {
        const ul = this.parent.createElement('ul', { id: id + '_borders_menu' });
        this.cPickerEle = this.parent.createElement('input', { id: `${id}_cell_border_color`, attrs: { 'type': 'color' } });
        this.parent.element.appendChild(this.cPickerEle);
        this.colorPicker = new ColorPicker$1({
            cssClass: 'e-border-colorpicker',
            mode: 'Palette',
            inline: true,
            beforeTileRender: (args) => {
                args.element.tabIndex = -1;
            },
            change: (args) => {
                const border = this.border.split(' ');
                border[2] = args.currentValue.hex;
                this.border = border.join(' ');
            }
        });
        this.colorPicker.createElement = this.parent.createElement;
        this.colorPicker.appendTo(this.cPickerEle);
        let bordersMenu;
        this.bordersDdb = new DropDownButton({
            iconCss: 'e-icons e-bottom-borders',
            cssClass: 'e-borders-ddb',
            target: ul,
            createPopupOnClick: true,
            beforeOpen: (args) => {
                bordersMenu = this.createBorderMenu(ul);
                this.tBarDdbBeforeOpen(args.element, bordersMenu.items, this.parent.serviceLocator.getService(locale).getConstant('Borders'), 1);
                EventHandler.add(ul, 'keydown', this.closeDropdownPopup, [this, this.bordersDdb]);
            },
            open: () => focus(ul),
            beforeClose: (args) => {
                if (args.event && closest(args.event.target, '.e-borders-menu')) {
                    args.cancel = true;
                }
                else {
                    EventHandler.remove(ul, 'keydown', this.closeDropdownPopup);
                    bordersMenu.destroy();
                }
            },
            close: () => focus(this.bordersDdb.element)
        });
        this.bordersDdb.createElement = this.parent.createElement;
        this.bordersDdb.appendTo(this.parent.createElement('button', { id: id + '_borders', attrs: { 'type': 'button' } }));
        return this.bordersDdb.element;
    }
    createBorderMenu(ul) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const id = this.parent.element.id;
        const bordersMenu = new Menu({
            cssClass: 'e-borders-menu',
            items: [{ iconCss: 'e-icons e-top-borders', text: l10n.getConstant('TopBorders'), id: `${id}_border_topborders` }, {
                    iconCss: 'e-icons e-left-borders',
                    text: l10n.getConstant('LeftBorders'), id: `${id}_border_leftborders`
                }, { iconCss: 'e-icons e-right-borders', text: l10n.getConstant('RightBorders'), id: `${id}_border_rightborders` }, {
                    iconCss: 'e-icons e-bottom-borders', text: l10n.getConstant('BottomBorders'), id: `${id}_border_bottomborders`
                }, {
                    iconCss: 'e-icons e-all-borders', text: l10n.getConstant('AllBorders'), id: `${id}_border_allborders`
                }, { iconCss: 'e-icons e-horizontal-borders', text: l10n.getConstant('HorizontalBorders'), id: `${id}_border_horizontalborders` }, {
                    iconCss: 'e-icons e-vertical-borders', text: l10n.getConstant('VerticalBorders'), id: `${id}_border_verticalborders`
                }, {
                    iconCss: 'e-icons e-outside-borders',
                    text: l10n.getConstant('OutsideBorders'), id: `${id}_border_outsideborders`
                }, { iconCss: 'e-icons e-inside-borders', text: l10n.getConstant('InsideBorders'), id: `${id}_border_insideborders` },
                { iconCss: 'e-icons e-no-borders', text: l10n.getConstant('NoBorders'), id: `${id}_border_noborders` }, { separator: true }, {
                    text: l10n.getConstant('BorderColor'), items: [{ id: `${id}_border_colors` }], id: `${id}_border_bordercolor`
                }, {
                    text: l10n.getConstant('BorderStyle'), items: [
                        { iconCss: 'e-icons e-selected-icon', id: `${id}_1px` }, { id: `${id}_2px` },
                        { id: `${id}_3px` }, { id: `${id}_dashed` },
                        { id: `${id}_dotted` }, { id: `${id}_double` }
                    ]
                }],
            orientation: 'Vertical',
            beforeOpen: (args) => {
                if (args.parentItem.id === `${id}_border_bordercolor`) {
                    this.colorPicker.refresh();
                    const cPickerWrapper = this.colorPicker.element.parentElement;
                    args.element.firstElementChild.appendChild(cPickerWrapper);
                    cPickerWrapper.style.display = 'inline-block';
                    args.element.parentElement.classList.add('e-border-color');
                    args.element.firstElementChild.removeAttribute('tabindex');
                }
                else {
                    args.element.classList.add('e-border-style');
                }
            },
            beforeClose: (args) => {
                if (args.event && args.parentItem.id === `${id}_border_bordercolor`) {
                    if (!closest(args.event.target, '.e-border-colorpicker') ||
                        closest(args.event.target, '.e-apply') || closest(args.event.target, '.e-cancel')) {
                        this.colorPicker = getComponent(this.cPickerEle, 'colorpicker');
                        if (this.colorPicker.mode === 'Picker') {
                            this.colorPicker.mode = 'Palette';
                            this.colorPicker.dataBind();
                        }
                        const cPickerWrapper = this.colorPicker.element.parentElement;
                        cPickerWrapper.style.display = '';
                        this.parent.element.appendChild(cPickerWrapper);
                    }
                    else {
                        args.cancel = true;
                    }
                }
            },
            onOpen: (args) => {
                if (args.parentItem.id === `${id}_border_bordercolor`) {
                    args.element.parentElement.style.overflow = 'visible';
                    const colorPalatte = args.element.querySelector('.e-color-palette .e-palette');
                    if (colorPalatte) {
                        focus(colorPalatte);
                    }
                }
            },
            onClose: () => focus(bordersMenu.element),
            select: (args) => {
                this.borderSelected(args, bordersMenu);
            }
        });
        bordersMenu.createElement = this.parent.createElement;
        bordersMenu.appendTo(ul);
        ul.classList.add('e-ul');
        return bordersMenu;
    }
    chartSelected(args, chartDdb) {
        const isChart = !isNullOrUndefined(closest(args.element, '.e-chart-menu'));
        const eleId = args.element.id;
        if (('column_chart' + 'bar_chart' + 'area_chart' + 'pie_doughnut_chart' +
            'line_chart' + 'radar_chart' + 'scatter_chart').includes(eleId)) {
            if (args.item && (!args.item.items || !args.item.items.length)) {
                chartDdb.toggle();
            }
            const id = args.event.target.id;
            this.parent.notify(insertChart, { action: eleId, id: id, isChart: isChart });
        }
    }
    addChartEleSelected(args) {
        const eleId = args.element.id;
        this.parent.notify(chartDesignTab, { addChartEle: eleId, triggerEvent: true });
        if (args.item && (!args.item.items || !args.item.items.length)) {
            this.addChartDdb.toggle();
        }
    }
    cfSelected(args) {
        const sheet = this.parent.getActiveSheet();
        if (args.item.id.includes('_dlg')) {
            this.parent.notify(renderCFDlg, { action: args.item.text });
        }
        else {
            const isCFIcons = args.item.id.includes('icons');
            if (isCFIcons || args.item.id === 'cf_cr_cells' || args.item.id === 'cf_cr_sheet') {
                if (isReadOnlyCells(this.parent, getSwapRange(getRangeIndexes(sheet.selectedRange)))) {
                    this.parent.notify(readonlyAlert, null);
                }
                else if (isCFIcons) {
                    const trgt = args.event.target;
                    this.parent.notify(setCFRule, { cfModel: { type: trgt.id || trgt.parentElement.id, range: sheet.selectedRange },
                        isAction: true });
                }
                else if (args.item.id === 'cf_cr_cells') {
                    this.parent.notify(clearCFRule, { range: sheet.selectedRange, isAction: true });
                }
                else if (args.item.id === 'cf_cr_sheet') {
                    this.parent.conditionalFormat = null;
                    this.parent.notify(clearCFRule, { isAction: true });
                }
            }
        }
        if (args.item && (!args.item.items || !args.item.items.length)) {
            this.cfDdb.toggle();
        }
    }
    borderSelected(args, bordersMenu) {
        this.bordersDdb.element.setAttribute('aria-label', args.item.text);
        const id = this.parent.element.id;
        if (args.item.items.length || args.item.id === `${id}_border_colors`) {
            return;
        }
        if (!args.item.text) {
            const border = this.border.split(' ');
            const prevStyleId = border[1] === 'solid' ? `${id}_${border[0]}` : `${id}_${border[1]}`;
            if (prevStyleId === args.item.id) {
                return;
            }
            if (args.item.id === `${id}_1px` || args.item.id === `${id}_2px` || args.item.id === `${id}_3px`) {
                border[0] = args.item.id.split(`${id}_`)[1];
                border[1] = 'solid';
            }
            else {
                border[1] = args.item.id.split(`${id}_`)[1];
                border[0] = border[1] === 'double' ? '3px' : '1px';
            }
            this.border = border.join(' ');
            bordersMenu.items[12].items.forEach((item) => {
                if (item.id === prevStyleId) {
                    item.iconCss = null;
                }
                if (item.id === args.item.id) {
                    item.iconCss = 'e-icons e-selected-icon';
                }
            });
            bordersMenu.setProperties({ 'items': bordersMenu.items }, true);
            return;
        }
        this.bordersDdb.toggle();
        this.parent.showSpinner();
        switch (args.item.id) {
            case `${id}_border_topborders`:
                this.parent.notify(setCellFormat, { style: { borderTop: this.border }, onActionUpdate: true });
                break;
            case `${id}_border_leftborders`:
                this.parent.notify(setCellFormat, { style: { borderLeft: this.border }, onActionUpdate: true });
                break;
            case `${id}_border_rightborders`:
                this.parent.notify(setCellFormat, { style: { borderRight: this.border }, onActionUpdate: true });
                break;
            case `${id}_border_bottomborders`:
                this.parent.notify(setCellFormat, { style: { borderBottom: this.border }, onActionUpdate: true });
                break;
            case `${id}_border_allborders`:
                this.parent.notify(setCellFormat, { style: { border: this.border }, onActionUpdate: true });
                break;
            case `${id}_border_horizontalborders`:
                this.parent.notify(setCellFormat, { style: { border: this.border }, onActionUpdate: true, borderType: 'Horizontal' });
                break;
            case `${id}_border_verticalborders`:
                this.parent.notify(setCellFormat, { style: { border: this.border }, onActionUpdate: true, borderType: 'Vertical' });
                break;
            case `${id}_border_outsideborders`:
                this.parent.notify(setCellFormat, { style: { border: this.border }, onActionUpdate: true, borderType: 'Outer' });
                break;
            case `${id}_border_insideborders`:
                this.parent.notify(setCellFormat, { style: { border: this.border }, onActionUpdate: true, borderType: 'Inner' });
                break;
            case `${id}_border_noborders`:
                this.parent.notify(setCellFormat, { style: { border: '' }, onActionUpdate: true });
                break;
        }
        this.parent.hideSpinner();
    }
    getFontNameDDB(id) {
        const fontNameBtn = this.parent.createElement('button', { id: id + '_font_name', attrs: { 'type': 'button' }, className: 'e-ss-ddb' });
        const fontBtnText = this.parent.createElement('span', { className: 'e-tbar-btn-text' });
        fontBtnText.innerText = 'Calibri';
        fontNameBtn.appendChild(fontBtnText);
        this.fontNameDdb = new DropDownButton({
            cssClass: 'e-font-family',
            items: this.getFontFamilyItems(),
            createPopupOnClick: true,
            select: (args) => {
                const eventArgs = { style: { fontFamily: args.item.text }, onActionUpdate: true };
                this.parent.notify(setCellFormat, eventArgs);
                fontNameBtn.setAttribute('aria-label', args.item.text);
                if (!eventArgs.cancel) {
                    this.refreshFontNameSelection(eventArgs.style.fontFamily);
                }
            },
            beforeOpen: (args) => {
                this.tBarDdbBeforeOpen(args.element, args.items, this.parent.serviceLocator.getService(locale).getConstant(('Font')));
            }
        });
        this.fontNameDdb.createElement = this.parent.createElement;
        this.fontNameDdb.appendTo(fontNameBtn);
        return fontNameBtn;
    }
    getBtn(id, name, text, bindEvent = true) {
        const btnObj = new Button({ iconCss: `e-icons e-${name}-icon`, cssClass: 'e-flat', isToggle: true });
        btnObj.createElement = this.parent.createElement;
        btnObj.appendTo(this.parent.createElement('button', { id: `${id}_${name}`, attrs: { 'aria-label': text, 'type': 'button' } }));
        if (bindEvent) {
            btnObj.element.addEventListener('click', this.toggleBtnClicked.bind(this));
        }
        return btnObj.element;
    }
    datavalidationDDB(id) {
        const l10n = this.parent.serviceLocator.getService(locale);
        let direction;
        this.datavalidationDdb = new DropDownButton({
            cssClass: 'e-datavalidation-ddb',
            iconCss: 'e-datavalidation-icon e-icons',
            content: l10n.getConstant('DataValidation'),
            items: [
                { text: l10n.getConstant('DataValidation') },
                { text: l10n.getConstant('HighlightInvalidData') },
                { text: l10n.getConstant('ClearHighlight') },
                { text: l10n.getConstant('ClearValidation') }
            ],
            createPopupOnClick: true,
            beforeOpen: (args) => {
                this.refreshSelected(this.datavalidationDdb, args.element, 'iconCss');
                args.element.setAttribute('aria-label', l10n.getConstant('DataValidation'));
            },
            select: (args) => {
                switch (args.item.text) {
                    case l10n.getConstant('DataValidation'):
                        this.parent.notify(initiateDataValidation, null);
                        break;
                    case l10n.getConstant('HighlightInvalidData'):
                        this.parent.notify(invalidData, {});
                        break;
                    case l10n.getConstant('ClearHighlight'):
                        this.parent.notify(invalidData, { isRemoveHighlight: true });
                        break;
                    case l10n.getConstant('ClearValidation'):
                        this.parent.notify(removeDataValidation, { isAction: true });
                        break;
                    default:
                        direction = args.item.text === l10n.getConstant('SortAscending') ? 'Ascending' : 'Descending';
                        this.parent.notify(applySort, { sortOptions: { sortDescriptors: { order: direction } } });
                        break;
                }
                this.datavalidationDdb.element.setAttribute('aria-label', args.item.text);
            }
        });
        this.datavalidationDdb.createElement = this.parent.createElement;
        this.datavalidationDdb.appendTo(this.parent.createElement('button', { id: id + '_datavalidation', attrs: { 'type': 'button' }, className: 'e-ss-ddb' }));
        return this.datavalidationDdb.element;
    }
    getTextAlignDDB(id) {
        const l10n = this.parent.serviceLocator.getService(locale);
        this.textAlignDdb = new DropDownButton({
            cssClass: 'e-align-ddb',
            iconCss: 'e-icons e-left-icon',
            items: [{ iconCss: 'e-icons e-left-icon' }, { iconCss: 'e-icons e-center-icon' }, { iconCss: 'e-icons e-right-icon' }],
            beforeItemRender: this.alignItemRender.bind(this),
            createPopupOnClick: true,
            beforeOpen: (args) => {
                this.refreshSelected(this.textAlignDdb, args.element, 'iconCss');
                args.element.setAttribute('aria-label', l10n.getConstant('HorizontalAlignment'));
            },
            select: (args) => {
                const eventArgs = {
                    style: { textAlign: args.item.iconCss.split(' e-')[1].split('-icon')[0] }, onActionUpdate: true
                };
                this.parent.notify(setCellFormat, eventArgs);
                if (!eventArgs.cancel) {
                    this.textAlignDdb.iconCss = `e-icons e-${eventArgs.style.textAlign}-icon`;
                    this.textAlignDdb.dataBind();
                }
                this.textAlignDdb.element.setAttribute('aria-label', (l10n.getConstant('HorizontalAlignment') + ' ' + l10n.getConstant('Align' + this.getAlignText(args))));
            }
        });
        this.textAlignDdb.createElement = this.parent.createElement;
        this.textAlignDdb.appendTo(this.parent.createElement('button', { id: id + '_text_align', attrs: { 'type': 'button' }, className: 'e-ss-ddb' }));
        return this.textAlignDdb.element;
    }
    getVerticalAlignDDB(id) {
        const l10n = this.parent.serviceLocator.getService(locale);
        this.verticalAlignDdb = new DropDownButton({
            cssClass: 'e-align-ddb',
            iconCss: 'e-icons e-bottom-icon',
            items: [{ iconCss: 'e-icons e-top-icon' }, { iconCss: 'e-icons e-middle-icon' }, { iconCss: 'e-icons e-bottom-icon' }],
            beforeItemRender: this.alignItemRender.bind(this),
            createPopupOnClick: true,
            beforeOpen: (args) => {
                this.refreshSelected(this.verticalAlignDdb, args.element, 'iconCss');
                args.element.setAttribute('aria-label', l10n.getConstant('VerticalAlignment'));
            },
            select: (args) => {
                const eventArgs = {
                    style: { verticalAlign: args.item.iconCss.split(' e-')[1].split('-icon')[0] }, onActionUpdate: true
                };
                this.parent.notify(setCellFormat, eventArgs);
                if (!eventArgs.cancel) {
                    this.verticalAlignDdb.iconCss = `e-icons e-${eventArgs.style.verticalAlign}-icon`;
                    this.verticalAlignDdb.dataBind();
                }
                this.verticalAlignDdb.element.setAttribute('aria-label', (l10n.getConstant('VerticalAlignment') + ' ' + l10n.getConstant('Align' + this.getAlignText(args))));
            }
        });
        this.verticalAlignDdb.createElement = this.parent.createElement;
        this.verticalAlignDdb.appendTo(this.parent.createElement('button', { id: id + '_vertical_align', attrs: { 'type': 'button' }, className: 'e-ss-ddb' }));
        return this.verticalAlignDdb.element;
    }
    getMergeSplitBtn(id) {
        this.parent.element.appendChild(this.parent.createElement('button', { id: id + '_merge', attrs: { 'type': 'button' } }));
        const l10n = this.parent.serviceLocator.getService(locale);
        this.mergeSplitBtn = new SplitButton({
            cssClass: 'e-merge-ddb',
            iconCss: 'e-icons e-merge-icon',
            createPopupOnClick: true,
            items: [{ text: l10n.getConstant('MergeAll'), id: `${id}_merge_all` }, { text: l10n.getConstant('MergeHorizontally'), id: `${id}_merge_horizontally` }, { text: l10n.getConstant('MergeVertically'), id: `${id}_merge_vertically` },
                { separator: true, id: `${id}_merge_separator` }, { text: l10n.getConstant('Unmerge'), id: `${id}_unmerge` }],
            select: this.mergeSelectHandler.bind(this),
            click: (args) => {
                args.element.setAttribute('aria-label', l10n.getConstant('MergeCells'));
                if (args.element.classList.contains('e-active')) {
                    this.unMerge();
                }
                else {
                    this.merge(`${this.parent.element.id}_merge_all`);
                }
            },
            created: () => {
                const mergeCellTitle = l10n.getConstant('MergeCells');
                this.mergeSplitBtn.element.title = mergeCellTitle;
                this.mergeSplitBtn.element.setAttribute('aria-label', mergeCellTitle);
                this.mergeSplitBtn.element.nextElementSibling.title = l10n.getConstant('SelectMergeType');
            },
            beforeOpen: (args) => args.element.setAttribute('aria-label', l10n.getConstant('MergeCells'))
        });
        this.mergeSplitBtn.createElement = this.parent.createElement;
        this.mergeSplitBtn.appendTo('#' + id + '_merge');
        return this.mergeSplitBtn.element.parentElement;
    }
    mergeSelectHandler(args) {
        if (args.item.id === `${this.parent.element.id}_unmerge`) {
            this.unMerge();
        }
        else {
            this.merge(args.item.id);
        }
        this.mergeSplitBtn.element.setAttribute('aria-label', args.item.text);
    }
    unMerge(args) {
        const sheet = this.parent.getActiveSheet();
        const indexes = getSwapRange(getRangeIndexes(sheet.selectedRange));
        if (isReadOnlyCells(this.parent, indexes)) {
            this.parent.notify(readonlyAlert, null);
            return;
        }
        this.parent.showSpinner();
        const selectedRange = sheet.selectedRange;
        const mergeCollection = [];
        for (let i = indexes[0]; i <= indexes[2]; i++) {
            for (let j = indexes[1]; j <= indexes[3]; j++) {
                const cell = getCell(i, j, sheet);
                if (cell && (cell.rowSpan > 1 || cell.colSpan > 1)) {
                    const mergeArgs = { range: [i, j, i, j] };
                    this.parent.notify(mergedRange, mergeArgs);
                    mergeCollection.push(mergeArgs.range);
                }
            }
        }
        const mergeObj = {
            merge: false, range: args ? (args.range || selectedRange) : selectedRange,
            isAction: true, refreshRibbon: true, type: 'All'
        };
        if (mergeCollection.length > 0) {
            mergeObj.mergeCollection = mergeCollection;
        }
        this.parent.notify(setMerge, mergeObj);
        this.toggleActiveState(false);
        this.parent.hideSpinner();
    }
    merge(itemId) {
        const sheet = this.parent.getActiveSheet();
        const indexes = getRangeIndexes(sheet.selectedRange);
        let cell;
        if (isReadOnlyCells(this.parent, getSwapRange(indexes))) {
            this.parent.notify(readonlyAlert, null);
            return;
        }
        let isDataPresent;
        const isMergeAll = itemId.includes('merge_all');
        for (let i = indexes[0]; i <= indexes[2]; i++) {
            for (let j = indexes[1]; j <= indexes[3]; j++) {
                if (i === indexes[0] && j === indexes[1] && isMergeAll) {
                    continue;
                }
                if (i === indexes[0] && itemId.includes('merge_vertically')) {
                    continue;
                }
                if (j === indexes[1] && itemId.includes('_merge_horizontally')) {
                    continue;
                }
                cell = getCell(i, j, sheet) || {};
                if (cell.value || cell.formula) {
                    isDataPresent = true;
                }
            }
        }
        if (!isDataPresent) {
            this.performMerge(itemId);
            if (isMergeAll) {
                this.toggleActiveState(true);
            }
            return;
        }
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        dialogInst.show({
            height: 200, width: 400, isModal: true, showCloseIcon: true, cssClass: 'e-merge-alert-dlg',
            content: this.parent.serviceLocator.getService(locale).getConstant('MergeCellsAlert'),
            beforeOpen: (args) => {
                const dlgArgs = {
                    dialogName: 'MergeAlertDialog',
                    element: args.element, target: args.target, cancel: args.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    args.cancel = true;
                }
                else {
                    focus(this.parent.element);
                }
            },
            buttons: [{
                    buttonModel: { content: this.parent.serviceLocator.getService(locale).getConstant('Ok'), isPrimary: true },
                    click: () => {
                        dialogInst.hide();
                        this.performMerge(itemId);
                        if (isMergeAll) {
                            this.toggleActiveState(true);
                        }
                    }
                }]
        });
    }
    performMerge(itemId) {
        const id = this.parent.element.id;
        this.parent.showSpinner();
        switch (itemId) {
            case `${id}_merge_all`:
                this.parent.notify(setMerge, { merge: true, range: this.parent.getActiveSheet().selectedRange,
                    type: 'All', isAction: true, refreshRibbon: true });
                break;
            case `${id}_merge_horizontally`:
                this.parent.notify(setMerge, { merge: true, range: this.parent.getActiveSheet().selectedRange,
                    type: 'Horizontally', isAction: true });
                break;
            case `${id}_merge_vertically`:
                this.parent.notify(setMerge, { merge: true, range: this.parent.getActiveSheet().selectedRange,
                    type: 'Vertically', isAction: true });
                break;
        }
        this.parent.hideSpinner();
    }
    getSortFilterDDB(id) {
        const l10n = this.parent.serviceLocator.getService(locale);
        let direction;
        this.sortingDdb = new DropDownButton({
            cssClass: 'e-sort-filter-ddb',
            iconCss: 'e-icons e-sort-filter-icon',
            items: [
                { text: l10n.getConstant('SortAscending'), iconCss: 'e-icons e-sort-asc' },
                { text: l10n.getConstant('SortDescending'), iconCss: 'e-icons e-sort-desc' },
                { text: l10n.getConstant('CustomSort') + '...', iconCss: 'e-icons e-sort-custom' },
                { separator: true },
                { text: l10n.getConstant('Filter'), iconCss: 'e-icons e-filter-apply', id: id + '_applyfilter' },
                { text: l10n.getConstant('ClearAllFilter'), iconCss: 'e-icons e-filter-clear', id: id + '_clearfilter' },
                { text: l10n.getConstant('ReapplyFilter'), iconCss: 'e-icons e-filter-reapply', id: id + '_reapplyfilter' }
            ],
            createPopupOnClick: true,
            beforeItemRender: (args) => {
                const eventArgs = { isFiltered: false, isClearAll: true };
                this.parent.notify(getFilteredColumn, eventArgs);
                if (!this.parent.allowSorting && (args.item.text === l10n.getConstant('SortAscending') ||
                    args.item.text === l10n.getConstant('SortDescending') || args.item.text === (l10n.getConstant('CustomSort') + '...'))) {
                    args.element.classList.add('e-disabled');
                }
                if (!this.parent.allowFiltering && args.item.text === (l10n.getConstant('Filter'))) {
                    args.element.classList.add('e-disabled');
                }
                if (args.item.id === id + '_clearfilter' || args.item.id === id + '_reapplyfilter') {
                    if (!eventArgs.isFiltered) {
                        args.element.classList.add('e-disabled');
                    }
                    else {
                        args.element.classList.remove('e-disabled');
                    }
                }
            },
            beforeOpen: (args) => {
                this.refreshSelected(this.sortingDdb, args.element, 'iconCss');
                args.element.setAttribute('aria-label', this.parent.serviceLocator.getService(locale).getConstant('SortAndFilter'));
            },
            select: (args) => {
                const prevSort = [];
                if (args.item.text === l10n.getConstant('SortAscending') || args.item.text === l10n.getConstant('SortDescending') ||
                    args.item.text === l10n.getConstant('CustomSort') + '...') {
                    const range = getRangeIndexes(this.parent.getActiveSheet().selectedRange);
                    const sortRange = getDataRange(range[0], range[1], this.parent.getActiveSheet());
                    if (isReadOnlyCells(this.parent, sortRange)) {
                        this.parent.notify(readonlyAlert, null);
                        return;
                    }
                }
                switch (args.item.text) {
                    case l10n.getConstant('Filter'):
                        this.parent.notify(initiateFilterUI, {});
                        break;
                    case l10n.getConstant('ClearAllFilter'):
                        this.parent.notify(clearFilter, { isAction: true });
                        break;
                    case l10n.getConstant('ReapplyFilter'):
                        this.parent.notify(reapplyFilter, null);
                        break;
                    case l10n.getConstant('CustomSort') + '...':
                        this.parent.notify(initiateCustomSort, null);
                        break;
                    default:
                        direction = args.item.text === l10n.getConstant('SortAscending') ? 'Ascending' : 'Descending';
                        if (this.parent.sortCollection) {
                            for (let i = this.parent.sortCollection.length - 1; i >= 0; i--) {
                                if (this.parent.sortCollection[i] &&
                                    this.parent.sortCollection[i].sheetIndex === this.parent.activeSheetIndex) {
                                    prevSort.push(this.parent.sortCollection[i]);
                                    this.parent.sortCollection.splice(i, 1);
                                }
                            }
                        }
                        this.parent.notify(updateSortCollection, { sortOptions: { sortDescriptors: { order: direction } } });
                        this.parent.notify(applySort, { sortOptions: { sortDescriptors: { order: direction } }, previousSort: prevSort });
                        break;
                }
                this.sortingDdb.element.setAttribute('aria-label', args.item.text);
            }
        });
        this.sortingDdb.createElement = this.parent.createElement;
        this.sortingDdb.appendTo(this.parent.createElement('button', { id: id + '_sorting', attrs: { 'type': 'button' }, className: 'e-ss-ddb' }));
        return this.sortingDdb.element;
    }
    getFindBtn(id) {
        const findToolbtn = this.parent.createElement('button', { id: id + '_findbtn', attrs: { 'type': 'button', 'aria-label': this.parent.serviceLocator.getService(locale).getConstant('FindReplaceTooltip') } });
        this.findDdb = new Button({ cssClass: 'e-spreadsheet-find-ddb e-flat', iconCss: 'e-icons e-search-icon' });
        this.findDdb.createElement = this.parent.createElement;
        this.findDdb.appendTo(findToolbtn);
        findToolbtn.onclick = (e) => {
            this.parent.notify(findToolDlg, { event: e });
        };
        return this.findDdb.element;
    }
    getClearDDB(id) {
        const l10n = this.parent.serviceLocator.getService(locale);
        this.clearDdb = new DropDownButton({
            cssClass: 'e-clear-ddb',
            iconCss: 'e-icons e-clear-icon',
            items: [
                { text: l10n.getConstant('ClearAll'), id: id + '_Clear All' },
                { text: l10n.getConstant('ClearFormats'), id: id + '_Clear Formats' },
                { text: l10n.getConstant('ClearContents'), id: id + '_Clear Contents' },
                { text: l10n.getConstant('ClearHyperlinks'), id: id + '_Clear Hyperlinks' }
            ],
            createPopupOnClick: true,
            beforeOpen: (args) => {
                args.element.setAttribute('aria-label', this.parent.serviceLocator.getService(locale).getConstant('Clear'));
            },
            beforeItemRender: (args) => {
                const sheet = this.parent.getActiveSheet();
                const indexes = getSwapRange(getRangeIndexes(sheet.selectedRange));
                if (sheet.isProtected && sheet.protectSettings.formatCells && args.item.id !== id + '_Clear Formats' && (args.item.id === id + '_Clear Hyperlinks' || isLockedCells(this.parent, indexes))) {
                    args.element.classList.add('e-disabled');
                    args.element.setAttribute('aria-disabled', 'true');
                }
            },
            select: (args) => {
                this.parent.notify(clearViewer, { options: { type: args.item.id.replace(id + '_', '') }, isAction: true });
                this.clearDdb.element.setAttribute('aria-label', args.item.text);
            }
        });
        this.clearDdb.createElement = this.parent.createElement;
        this.clearDdb.appendTo(this.parent.createElement('button', { id: id + '_clear', attrs: { 'type': 'button' }, className: 'e-ss-ddb' }));
        return this.clearDdb.element;
    }
    ribbonCreated() {
        const text = this.parent.serviceLocator.getService(locale).getConstant('CollapseToolbar');
        attributes(this.ribbon.element.querySelector('.e-drop-icon'), { 'role': 'button', 'tabindex': '-1', 'title': text, 'aria-label': text });
        if (this.ribbon.toolbarObj) {
            this.ribbon.toolbarObj.allowKeyboard = this.parent.enableKeyboardNavigation;
            this.ribbon.toolbarObj.dataBind();
        }
    }
    alignItemRender(args) {
        args.element.title = this.parent.serviceLocator.getService(locale).getConstant('Align' + this.getAlignText(args));
    }
    getAlignText(args) {
        const text = args.item.iconCss.split(' e-')[1].split('-icon')[0];
        return text[0].toUpperCase() + text.slice(1, text.length);
    }
    toggleBtnClicked(e) {
        const target = closest(e.target, '.e-btn');
        const parentId = this.parent.element.id;
        const id = target.id;
        let property = setCellFormat;
        let value;
        let defaultModel;
        let activeModel;
        let eventArgs;
        let key;
        switch (id) {
            case `${parentId}_bold`:
                defaultModel = { fontWeight: 'normal' };
                activeModel = { fontWeight: 'bold' };
                key = 'fontWeight';
                break;
            case `${parentId}_italic`:
                defaultModel = { fontStyle: 'normal' };
                activeModel = { fontStyle: 'italic' };
                key = 'fontStyle';
                break;
            case `${parentId}_line-through`:
                property = textDecorationUpdate;
                defaultModel = { textDecoration: 'line-through' };
                activeModel = defaultModel;
                key = 'textDecoration';
                break;
            case `${parentId}_underline`:
                property = textDecorationUpdate;
                defaultModel = { textDecoration: 'underline' };
                activeModel = defaultModel;
                key = 'textDecoration';
                break;
        }
        if (target.classList.contains('e-active')) {
            value = activeModel[`${key}`];
            eventArgs = { style: activeModel, onActionUpdate: true };
            this.parent.notify(property, eventArgs);
            if (eventArgs.cancel) {
                target.classList.remove('e-active');
            }
        }
        else {
            value = defaultModel[`${key}`];
            eventArgs = { style: defaultModel, onActionUpdate: true };
            this.parent.notify(property, eventArgs);
            if (eventArgs.cancel) {
                target.classList.add('e-active');
            }
        }
        if (!eventArgs.cancel && value !== eventArgs.style[`${key}`]) {
            this.refreshToggleBtn(getCellIndexes(this.parent.getActiveSheet().activeCell));
        }
    }
    getCellStyleValue(cssProp, indexes) {
        const cell = getCell(indexes[0], indexes[1], this.parent.getActiveSheet());
        let value = this.parent.cellStyle[`${cssProp}`];
        if (cell && cell.style && cell.style[`${cssProp}`]) {
            value = cell.style[`${cssProp}`];
        }
        return value;
    }
    refreshSelected(inst, element, key, itemKey = key) {
        for (let i = 0; i < inst.items.length; i++) {
            if (inst.items[i][`${itemKey}`] === inst[`${key}`]) {
                element.children[i].classList.add('e-selected');
                break;
            }
        }
    }
    expandCollapseHandler(args) {
        const target = this.ribbon.element.querySelector('.e-drop-icon');
        const l10n = this.parent.serviceLocator.getService(locale);
        if (args.expanded) {
            target.title = l10n.getConstant('CollapseToolbar');
            target.setAttribute('aria-label', l10n.getConstant('ExpandToolbar'));
        }
        else {
            target.title = l10n.getConstant('ExpandToolbar');
            target.setAttribute('aria-label', l10n.getConstant('CollapseToolbar'));
        }
        this.parent.setPanelSize();
    }
    getChartThemeDdbItems(theme) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const items = [];
        const themes = ['Material', 'Fabric', 'Bootstrap', 'HighContrastLight', 'MaterialDark', 'FabricDark', 'HighContrast',
            'BootstrapDark', 'Bootstrap4', 'Bootstrap5Dark', 'Bootstrap5', 'TailwindDark', 'Tailwind', 'Tailwind3', 'Tailwind3Dark', 'FluentDark', 'Fluent', 'Fluent2', 'Fluent2Dark',
            'Material3', 'Material3Dark'];
        themes.forEach((id) => {
            items.push({ id: id, text: l10n.getConstant(id), iconCss: id === theme ? 'e-icons e-selected-icon' : '' });
        });
        return items;
    }
    getNumFormatDdbItems(id) {
        const l10n = this.parent.serviceLocator.getService(locale);
        return [
            { id: id + '_General', text: l10n.getConstant('General') },
            { id: id + '_Number', text: l10n.getConstant('Number') },
            { id: id + '_Currency', text: l10n.getConstant('Currency') },
            { id: id + '_Accounting', text: l10n.getConstant('Accounting') },
            { id: id + '_ShortDate', text: l10n.getConstant('ShortDate') },
            { id: id + '_LongDate', text: l10n.getConstant('LongDate') },
            { id: id + '_Time', text: l10n.getConstant('Time') },
            { id: id + '_Percentage', text: l10n.getConstant('Percentage') },
            { id: id + '_Fraction', text: l10n.getConstant('Fraction') },
            { id: id + '_Scientific', text: l10n.getConstant('Scientific') },
            { id: id + '_Text', text: l10n.getConstant('Text') },
            { id: id + '_Custom', text: l10n.getConstant('Custom') }
        ];
    }
    getFontFamilyItems() {
        return [{ text: 'Arial' }, { text: 'Arial Black' }, { text: 'Axettac Demo' }, { text: 'Batang' }, { text: 'Book Antiqua' },
            { text: 'Calibri', iconCss: 'e-icons e-selected-icon' }, { text: 'Comic Sans MS' }, { text: 'Courier' }, { text: 'Courier New' },
            { text: 'Din Condensed' }, { text: 'Georgia' }, { text: 'Helvetica' }, { text: 'Helvetica New' }, { text: 'Roboto' },
            { text: 'Tahoma' }, { text: 'Times New Roman' }, { text: 'Verdana' }];
    }
    applyNumFormat(format) {
        const sheet = this.parent.getActiveSheet();
        const eventArgs = {
            format: format, range: sheet.selectedRange, cancel: false, requestType: 'NumberFormat'
        };
        const actionArgs = {
            range: sheet.name + '!' + eventArgs.range, format: eventArgs.format, requestType: 'NumberFormat'
        };
        const isReadonly = isReadOnlyCells(this.parent, getSwapRange(getRangeIndexes(eventArgs.range)));
        if (!isReadonly) {
            this.parent.trigger('beforeCellFormat', eventArgs);
            this.parent.notify(beginAction, { eventArgs: eventArgs, action: 'format' });
            if (eventArgs.cancel) {
                return eventArgs.format;
            }
        }
        this.parent.notify(applyNumberFormatting, eventArgs);
        this.parent.notify(selectionComplete, { type: 'mousedown' });
        if (!isReadonly) {
            this.parent.notify(completeAction, { eventArgs: actionArgs, action: 'format' });
        }
        return eventArgs.format;
    }
    renderCustomFormatDialog(defaultFormats, localizedFormats) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dummyDiv = this.parent.createElement('div');
        const dialogCont = this.parent.createElement('div', { className: 'e-custom-dialog' });
        const dialogBtn = this.parent.createElement('button', { className: 'e-btn', attrs: { 'type': 'button' } });
        dialogBtn.innerText = l10n.getConstant('Apply');
        const sampleDiv = this.parent.createElement('div', { className: 'e-custom-sample' });
        sampleDiv.innerText = l10n.getConstant('CustomFormatTypeList') + ':';
        const inputButtondiv = this.parent.createElement('div', { className: 'e-input-button' });
        const inputElem = this.parent.createElement('input', { className: 'e-input e-dialog-input', attrs: { 'type': 'text', 'name': 'input', 'spellcheck': 'false',
                'placeholder': l10n.getConstant('CustomFormatPlaceholder') } });
        const listviewCont = this.parent.createElement('div', { className: 'e-custom-listview' });
        const customFormatDialog = this.parent.serviceLocator.getService(dialog);
        const listview = new ListView({
            dataSource: localizedFormats,
            select: (args) => {
                // Listview trim the front and end spaces, so we are taking the textContent from selected element instead of using text.
                inputElem.value = args.item.textContent;
                if (args.event && args.event.type === 'keydown' && args.item) {
                    args.item.focus();
                }
            }
        });
        inputButtondiv.appendChild(inputElem);
        inputButtondiv.appendChild(dialogBtn);
        dialogCont.appendChild(inputButtondiv);
        dialogCont.appendChild(sampleDiv);
        dialogCont.appendChild(listviewCont);
        listview.appendTo(listviewCont);
        if (localizedFormats[4] !== defaultFormats[4]) {
            const listItems = listview.element.getElementsByClassName('e-list-text');
            for (let idx = 0, len = listItems.length; idx < len; idx++) {
                if (listItems[idx].textContent !== localizedFormats[idx]) {
                    listItems[idx].textContent = localizedFormats[idx];
                }
            }
        }
        const applyBtnClickHandler = () => {
            const format = inputElem.value;
            const formatIdx = localizedFormats.indexOf(format);
            let defaultFormat;
            if (formatIdx > -1) {
                defaultFormat = defaultFormats[formatIdx];
            }
            else {
                defaultFormat = convertToDefaultFormat(this.parent, format);
            }
            defaultFormat = this.applyNumFormat(defaultFormat);
            if (defaultFormat) {
                this.refreshNumFormatSelection(getTypeFromFormat(defaultFormat, true), this.parent.getActiveSheet(), l10n, defaultFormat);
                this.parent.notify(localizedFormatAction, { action: 'addToCustomFormats', format, defaultFormat });
            }
            customFormatDialog.hide();
            if (this.parent.showAggregate) {
                this.parent.notify(showAggregate, {});
            }
        };
        dialogBtn.addEventListener('click', applyBtnClickHandler);
        const inputChangeHandler = () => {
            const selectedList = listview.getSelectedItems();
            if (selectedList) {
                listview.unselectItem();
            }
        };
        inputElem.addEventListener('input', inputChangeHandler);
        customFormatDialog.show({
            header: l10n.getConstant('CustomFormat'),
            cssClass: 'e-custom-format-dlg',
            height: this.parent.cssClass.indexOf('e-bigger') > -1 ? 502 : 480,
            width: 440,
            isModal: true,
            showCloseIcon: true,
            content: dialogCont,
            footerTemplate: dummyDiv,
            beforeOpen: (beforeOpenArgs) => {
                const dlgArgs = {
                    dialogName: 'CustomNumberFormatDlg',
                    element: beforeOpenArgs.element, target: beforeOpenArgs.target, cancel: beforeOpenArgs.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    beforeOpenArgs.cancel = true;
                }
                else {
                    const sheet = this.parent.getActiveSheet();
                    const actCell = getCellIndexes(sheet.activeCell);
                    const cell = getCell(actCell[0], actCell[1], sheet);
                    if (cell && cell.format) {
                        const formatIdx = defaultFormats.indexOf(cell.format);
                        listview.selectItem(listview.element.getElementsByClassName('e-list-item')[formatIdx]);
                    }
                    focus(this.parent.element);
                }
            }
        });
    }
    tBarDdbBeforeOpen(element, items, targetLabel, separatorCount = 0) {
        const viewportHeight = this.parent.viewport.height;
        let actualHeight = (parseInt(getComputedStyle(element.firstElementChild).height, 10) * (items.length - separatorCount)) +
            (parseInt(getComputedStyle(element).paddingTop, 10) * 2);
        if (separatorCount) {
            const separatorStyle = getComputedStyle(element.querySelector('.e-separator'));
            actualHeight += (separatorCount * (parseInt(separatorStyle.borderBottomWidth, 10) + (parseInt(separatorStyle.marginTop, 10) * 2)));
        }
        if (actualHeight > viewportHeight) {
            element.style.height = `${viewportHeight}px`;
            element.style.overflowY = 'auto';
        }
        else {
            if (element.style.height) {
                element.style.height = '';
                element.style.overflowY = '';
            }
        }
        element.setAttribute('aria-label', targetLabel);
    }
    numDDBOpen(args) {
        this.numPopupWidth = 0;
        const elemList = args.element.querySelectorAll('span.e-numformat-preview-text');
        for (let i = 0, len = elemList.length; i < len; i++) {
            if (this.numPopupWidth < elemList[i].offsetWidth) {
                this.numPopupWidth = elemList[i].offsetWidth;
            }
        }
        const popWidth = this.numPopupWidth + 160;
        document.querySelector('.e-numformat-ddb.e-dropdown-popup').style.width = `${popWidth}px`;
    }
    previewNumFormat(args) {
        if (args.item.id.includes('_Custom')) {
            return;
        }
        const numElem = this.parent.createElement('div', { className: 'e-numformat-text', styles: 'width:100%', innerHTML: args.element.innerHTML });
        args.element.innerHTML = '';
        const sheet = this.parent.getActiveSheet();
        const cellIndex = getCellIndexes(sheet.activeCell);
        const cell = getCell(cellIndex[0], cellIndex[1], sheet, false, true);
        if (!isNullOrUndefined(cell.value) || cell.value !== '') {
            const format = getFormatFromType(args.item.id.split(this.parent.element.id + '_')[1]);
            const eventArgs = { type: args.item.text, formattedText: '', value: cell.value, format: format,
                cell: { value: cell.value, format: format }, skipFormatCheck: isImported(this.parent) };
            this.parent.notify(getFormattedCellObject, eventArgs);
            const previewElem = this.parent.createElement('span', { className: 'e-numformat-preview-text', styles: 'float:right;' });
            previewElem.innerText = eventArgs.formattedText;
            numElem.appendChild(previewElem);
        }
        args.element.appendChild(numElem);
    }
    refreshRibbonContent(activeTab) {
        if (!this.ribbon) {
            return;
        }
        if (isNullOrUndefined(activeTab)) {
            activeTab = this.ribbon.selectedTab;
        }
        const l10n = this.parent.serviceLocator.getService(locale);
        const sheet = this.parent.getActiveSheet();
        const cellIndexes = getCellIndexes(sheet.activeCell);
        switch (this.ribbon.items[activeTab].header.text) {
            case l10n.getConstant('Home'):
                this.refreshHomeTabContent(cellIndexes);
                break;
            case l10n.getConstant('Insert'): {
                if (sheet.isProtected) {
                    if (sheet.protectSettings.insertLink &&
                        !isLocked(getCell(cellIndexes[0], cellIndexes[1], sheet), getColumn(sheet, cellIndexes[1]))) {
                        this.enableToolbarItems([{
                                tab: l10n.getConstant('Insert'),
                                items: [`${this.parent.element.id}_hyperlink`], enable: true
                            }]);
                    }
                    else {
                        this.enableToolbarItems([{
                                tab: l10n.getConstant('Insert'),
                                items: [`${this.parent.element.id}_hyperlink`], enable: false
                            }]);
                    }
                }
                break;
            }
            case l10n.getConstant('Formulas'):
                if (sheet.isProtected) {
                    if (!isLocked(getCell(cellIndexes[0], cellIndexes[1], sheet), getColumn(sheet, cellIndexes[1]))) {
                        this.enableToolbarItems([{
                                tab: l10n.getConstant('Formulas'),
                                items: [`${this.parent.element.id}_insert_function`], enable: true
                            }]);
                    }
                    else {
                        this.enableToolbarItems([{
                                tab: l10n.getConstant('Formulas'),
                                items: [`${this.parent.element.id}_insert_function`], enable: false
                            }]);
                    }
                }
                break;
            case l10n.getConstant('Data'):
                this.refreshDataTabContent(activeTab);
                break;
            case l10n.getConstant('View'):
                this.refreshViewTabContent(activeTab);
                break;
        }
    }
    refreshHomeTabContent(indexes) {
        if (!isNullOrUndefined(document.getElementById(this.parent.element.id + '_number_format'))) {
            this.numFormatDDB = getComponent(document.getElementById(this.parent.element.id + '_number_format'), DropDownButton);
        }
        const sheet = this.parent.getActiveSheet();
        const actCell = getCellIndexes(sheet.activeCell);
        const l10n = this.parent.serviceLocator.getService(locale);
        const cell = getCell(actCell[0], actCell[1], sheet, false, true);
        const type = getTypeFromFormat(cell.format || 'General', true);
        this.refreshNumFormatSelection(type, sheet, l10n, cell.format);
        if (sheet.isProtected && this.parent.enableClipboard &&
            this.parent.clipboardModule.copiedInfo) {
            this.parent.notify(enableToolbarItems, [{
                    items: [this.parent.element.id + '_paste'],
                    enable: !isLocked(cell, getColumn(sheet, actCell[1]))
                }]);
        }
        if (this.fontNameDdb) {
            if (sheet.isProtected && !sheet.protectSettings.formatCells) {
                this.refreshFontNameSelection('Calibri');
            }
            else {
                this.refreshFontNameSelection(this.getCellStyleValue('fontFamily', indexes));
            }
        }
        if (this.fontSizeDdb) {
            let value = this.getCellStyleValue('fontSize', indexes);
            if (sheet.isProtected && !sheet.protectSettings.formatCells) {
                this.fontSizeDdb.content = '11';
            }
            else {
                value = value.includes('pt') ? value.split('pt')[0] : '11';
                if (value !== this.fontSizeDdb.content) {
                    this.fontSizeDdb.content = value;
                    this.fontSizeDdb.dataBind();
                }
            }
        }
        this.refreshTextAlign(sheet, cell, type, indexes);
        if (this.verticalAlignDdb) {
            const value = `e-icons e-${this.getCellStyleValue('verticalAlign', indexes).toLowerCase()}-icon`;
            if (sheet.isProtected && !sheet.protectSettings.formatCells) {
                this.verticalAlignDdb.iconCss = 'e-icons e-bottom-icon';
            }
            else {
                if (value !== this.verticalAlignDdb.iconCss) {
                    this.verticalAlignDdb.iconCss = value;
                    this.verticalAlignDdb.dataBind();
                }
            }
        }
        this.refreshToggleBtn(indexes);
        if (!sheet.isProtected && (cell.rowSpan > 1 || cell.colSpan > 1)) {
            this.enableToolbarItems([{ tab: l10n.getConstant('Home'), items: [`${this.parent.element.id}_merge_cells`],
                    enable: true }]);
            this.toggleActiveState(true);
        }
        else {
            const indexes = getRangeIndexes(sheet.selectedRange);
            this.enableToolbarItems([{ tab: l10n.getConstant('Home'), items: [`${this.parent.element.id}_merge_cells`],
                    enable: indexes[0] !== indexes[2] || indexes[1] !== indexes[3] }]);
            this.toggleActiveState(false);
        }
    }
    refreshTextAlign(sheet, cell, type, indexes) {
        if (this.textAlignDdb) {
            let style = this.getCellStyleValue('textAlign', indexes);
            if (sheet.isProtected && !sheet.protectSettings.formatCells) {
                this.textAlignDdb.iconCss = 'e-icons e-left-icon';
            }
            else {
                if (cell.value !== undefined && style === 'left' && (type === 'Accounting' || (isNumber(cell.value) && type !== 'Text'))) {
                    style = 'right';
                }
                const value = `e-icons e-${style.toLowerCase()}-icon`;
                if (value !== this.textAlignDdb.iconCss) {
                    this.textAlignDdb.iconCss = value;
                    this.textAlignDdb.dataBind();
                }
            }
        }
    }
    toggleActiveState(active) {
        const l10n = this.parent.serviceLocator.getService(locale);
        if (!this.parent.getActiveSheet().isProtected) {
            if (active) {
                if (!this.mergeSplitBtn.element.classList.contains('e-active')) {
                    this.mergeSplitBtn.element.classList.add('e-active');
                    this.mergeSplitBtn.element.title = l10n.getConstant('UnmergeCells');
                }
            }
            else {
                if (this.mergeSplitBtn.element.classList.contains('e-active')) {
                    this.mergeSplitBtn.element.classList.remove('e-active');
                    this.mergeSplitBtn.element.title = l10n.getConstant('MergeCells');
                }
            }
        }
    }
    refreshToggleBtn(indexes) {
        const sheet = this.parent.getActiveSheet();
        let btn;
        const id = this.parent.element.id;
        let value;
        let isActive;
        const cell = getCell(indexes[0], indexes[1], sheet);
        const fontProps = ['fontWeight', 'fontStyle', 'textDecoration', 'textDecoration'];
        ['bold', 'italic', 'line-through', 'underline', 'wrap'].forEach((name, index) => {
            btn = document.getElementById(`${id}_${name}`);
            if (btn) {
                isActive = false;
                if (!sheet.isProtected || sheet.protectSettings.formatCells) {
                    if (name === 'wrap') {
                        isActive = this.parent.allowWrap && cell && cell.wrap;
                    }
                    else if (this.parent.allowCellFormatting) {
                        value = this.getCellStyleValue(fontProps[index], indexes).toLowerCase();
                        isActive = value.indexOf(name) > -1;
                    }
                }
                if (isActive) {
                    btn.classList.add('e-active');
                }
                else {
                    if (btn.classList.contains('e-active')) {
                        btn.classList.remove('e-active');
                    }
                }
            }
        });
    }
    refreshFontNameSelection(fontFamily) {
        fontFamily = fontFamily.split('"').join('');
        this.fontNameDdb.element.firstElementChild.textContent = fontFamily;
        for (let i = 0; i < this.fontNameDdb.items.length; i++) {
            if (this.fontNameDdb.items[i].text === fontFamily) {
                this.fontNameDdb.items[i].iconCss = 'e-icons e-selected-icon';
                if (i !== this.fontNameIndex) {
                    this.fontNameDdb.items[this.fontNameIndex].iconCss = '';
                }
                this.fontNameDdb.setProperties({ 'items': this.fontNameDdb.items }, true);
                this.fontNameIndex = i;
                break;
            }
        }
        if (['Arial', 'Arial Black', 'Axettac Demo', 'Batang', 'Book Antiqua', 'Calibri', 'Comic Sans MS', 'Courier',
            'Courier New', 'Din Condensed', 'Georgia', 'Helvetica', 'Helvetica New', 'Roboto',
            'Tahoma', 'Times New Roman', 'Verdana'].indexOf(fontFamily) < 0) {
            this.fontNameDdb.items[this.fontNameIndex].iconCss = '';
        }
        this.fontNameDdb.element.setAttribute('aria-label', fontFamily);
    }
    refreshNumFormatSelection(type, sheet, l10n, format) {
        if (this.numFormatDDB) {
            if (sheet.isProtected && !sheet.protectSettings.formatCells) {
                type = 'General';
            }
            else {
                if (format && type === 'General' && format !== 'General') {
                    type = 'Custom';
                }
                type = l10n.getConstant(type);
            }
            for (let i = 0; i < this.numFormatDDB.items.length; i++) {
                if (this.numFormatDDB.items[i].iconCss !== '') {
                    this.numFormatDDB.items[i].iconCss = '';
                }
                if (this.numFormatDDB.items[i].text === type) {
                    this.numFormatDDB.items[i].iconCss = 'e-icons e-selected-icon';
                }
            }
            this.numFormatDDB.element.firstElementChild.textContent = type;
            this.numFormatDDB.setProperties({ 'items': this.numFormatDDB.items }, true);
            this.numFormatDDB.element.setAttribute('aria-label', type);
        }
    }
    fileMenuItemSelect(args) {
        const selectArgs = extend({ cancel: false }, args);
        this.parent.trigger('fileMenuItemSelect', selectArgs);
        const id = this.parent.element.id;
        let dialogInst;
        if (!selectArgs.cancel) {
            switch (args.item.id) {
                case `${id}_Print`:
                    this.parent.print();
                    break;
                case `${id}_Open`:
                    select('#' + id + '_fileUpload', this.parent.element).click();
                    focus(this.parent.element);
                    break;
                case `${id}_Xlsx`:
                case `${id}_Xls`:
                case `${id}_Csv`:
                case `${id}_Pdf`:
                    this.parent.notify(exportDialog, args);
                    break;
                case `${id}_New`:
                    dialogInst = this.parent.serviceLocator.getService(dialog);
                    dialogInst.show({
                        height: 200, width: 400, isModal: true, showCloseIcon: true,
                        content: this.parent.serviceLocator.getService(locale).getConstant('DestroyAlert'),
                        beforeOpen: (args) => {
                            const dlgArgs = {
                                dialogName: 'DestroySheetDialog',
                                element: args.element, target: args.target, cancel: args.cancel
                            };
                            this.parent.trigger('dialogBeforeOpen', dlgArgs);
                            if (dlgArgs.cancel) {
                                args.cancel = true;
                            }
                            else {
                                focus(this.parent.element);
                            }
                        },
                        buttons: [{
                                buttonModel: {
                                    content: this.parent.serviceLocator.getService(locale).getConstant('Ok'), isPrimary: true
                                },
                                click: () => {
                                    dialogInst.hide();
                                    this.parent.refresh(true);
                                }
                            }]
                    });
                    break;
            }
        }
    }
    toolbarClicked(args) {
        if (args.item && !(args.item.id === 'spreadsheet_find')) {
            const parentId = this.parent.element.id;
            const sheet = this.parent.getActiveSheet();
            let evtHArgs;
            let evtglArgs;
            let indexes;
            let selectCell;
            switch (args.item.id) {
                case parentId + '_headers':
                    evtHArgs = {
                        isShow: !sheet.showHeaders,
                        sheetIdx: this.parent.activeSheetIndex,
                        cancel: false
                    };
                    this.parent.notify(completeAction, { eventArgs: evtHArgs, action: 'headers' });
                    if (evtHArgs.cancel) {
                        return;
                    }
                    this.parent.setSheetPropertyOnMute(sheet, 'showHeaders', !sheet.showHeaders);
                    this.parent.serviceLocator.getService('sheet').showHideHeaders();
                    this.toggleRibbonItems({ props: 'Headers', activeTab: this.ribbon.selectedTab });
                    break;
                case parentId + '_gridlines':
                    evtglArgs = {
                        isShow: !sheet.showGridLines,
                        sheetIdx: this.parent.activeSheetIndex,
                        cancel: false
                    };
                    this.parent.notify(completeAction, { eventArgs: evtglArgs, action: 'gridLines' });
                    if (evtglArgs.cancel) {
                        return;
                    }
                    this.parent.setSheetPropertyOnMute(sheet, 'showGridLines', !sheet.showGridLines);
                    this.toggleRibbonItems({ props: 'GridLines', activeTab: this.ribbon.selectedTab });
                    break;
                case parentId + '_protect':
                    this.parent.notify(toggleProtect, {});
                    break;
                case parentId + '_undo':
                    this.parent.notify(performUndoRedo, { isUndo: true });
                    break;
                case parentId + '_redo':
                    this.parent.notify(performUndoRedo, { isUndo: false });
                    break;
                case parentId + '_freezepanes':
                    indexes = getCellIndexes(sheet.topLeftCell);
                    selectCell = sheet.frozenRows || sheet.frozenColumns ? indexes : getCellIndexes(sheet.activeCell);
                    this.parent.notify(freeze, { row: selectCell[0] - indexes[0], column: selectCell[1] - indexes[1], triggerEvent: true });
                    break;
                case parentId + '_freezerows':
                    this.parent.notify(freeze, { row: sheet.frozenRows ? 0 : getCellIndexes(sheet.activeCell)[0] - getCellIndexes(sheet.topLeftCell)[0], column: sheet.frozenColumns, triggerEvent: true });
                    break;
                case parentId + '_freezecolumns':
                    this.parent.notify(freeze, { row: sheet.frozenRows, column: sheet.frozenColumns ? 0 : getCellIndexes(sheet.activeCell)[1] - getCellIndexes(sheet.topLeftCell)[1], triggerEvent: true });
                    break;
                case parentId + '_protectworkbook':
                    if (this.parent.password.length > 0) {
                        this.parent.notify(unProtectWorkbook, null);
                    }
                    else {
                        if (this.parent.isProtected) {
                            this.parent.isProtected = false;
                            if (this.parent.showSheetTabs) {
                                this.parent.element.querySelector('.e-add-sheet-tab').removeAttribute('disabled');
                                this.parent.element.querySelector('.e-add-sheet-tab').classList.remove('e-disabled');
                            }
                            this.toggleRibbonItems({ props: 'Protectworkbook', activeTab: this.ribbon.selectedTab });
                            this.parent.notify(completeAction, { action: 'protectWorkbook', eventArgs: { isProtected: false } });
                        }
                        else if (this.parent.element.querySelector('.e-add-sheet-tab').classList.contains('e-disabled')) {
                            this.toggleRibbonItems({ props: 'Protectworkbook', activeTab: this.ribbon.selectedTab });
                        }
                        else {
                            this.parent.notify(protectWorkbook, null);
                        }
                    }
                    break;
            }
            this.parent.notify(ribbonClick, args);
        }
    }
    toggleRibbonItems(args) {
        let text = '';
        const viewtabHeader = this.parent.serviceLocator.getService(locale).getConstant('View');
        const datatabHeader = this.parent.serviceLocator.getService(locale).getConstant('Data');
        if (this.ribbon.items[this.ribbon.selectedTab].header.text === viewtabHeader) {
            if (isNullOrUndefined(args.activeTab)) {
                for (let i = 0, len = this.ribbon.items.length; i < len; i++) {
                    if (this.ribbon.items[i].header.text === viewtabHeader) {
                        args.activeTab = i;
                        break;
                    }
                }
            }
            const text = this.getLocaleText(args.props);
            if (args.props === 'GridLines') {
                this.parent.serviceLocator.getService('sheet').toggleGridlines();
            }
            const id = `${this.parent.element.id}_${args.props.toLowerCase()}`;
            const len = this.ribbon.items[args.activeTab].content.length;
            for (let i; i < len; i++) {
                if (this.ribbon.items[args.activeTab].content[i].type === 'Separator') {
                    continue;
                }
                if (this.ribbon.items[args.activeTab].content[i].id === id) {
                    this.ribbon.items[args.activeTab].content[i].text = text;
                    this.ribbon.setProperties({ 'items': this.ribbon.items }, true);
                }
            }
            if (this.ribbon.items[this.ribbon.selectedTab].header.text === viewtabHeader && args.props !== 'Protect') {
                this.updateToggleText(args.props.toLowerCase(), text);
            }
        }
        if (this.ribbon.items[this.ribbon.selectedTab].header.text === datatabHeader) {
            if (isNullOrUndefined(args.activeTab)) {
                for (let i = 0, len = this.ribbon.items.length; i < len; i++) {
                    if (this.ribbon.items[i].header.text === datatabHeader) {
                        args.activeTab = i;
                        break;
                    }
                }
            }
            const id = `${this.parent.element.id}_${args.props.toLowerCase()}`;
            if (id === this.parent.element.id + '_protect') {
                const len = this.ribbon.items[this.ribbon.selectedTab].content.length;
                let j;
                for (j = 0; j < len; j++) {
                    if (this.ribbon.items[this.ribbon.selectedTab].content[j].id === this.parent.element.id + '_protect') {
                        break;
                    }
                }
                text = this.getLocaleProtectText('Sheet', true);
            }
            else if (id === this.parent.element.id + '_protectworkbook') {
                const len = this.ribbon.items[this.ribbon.selectedTab].content.length;
                let j;
                for (j = 0; j < len; j++) {
                    if (this.ribbon.items[this.ribbon.selectedTab].content[j].id === this.parent.element.id + '_protectworkbook') {
                        break;
                    }
                }
                if (this.parent.isProtected || this.parent.password.length > 0) {
                    text = this.getLocaleProtectWorkbook('UnprotectWorkbook');
                }
                else if (!this.parent.isProtected) {
                    text = this.getLocaleProtectWorkbook('ProtectWorkbook');
                }
            }
            const len = this.ribbon.items[args.activeTab].content.length;
            for (let i; i < len; i++) {
                if (this.ribbon.items[args.activeTab].content[i].type === 'Separator') {
                    continue;
                }
                if (this.ribbon.items[args.activeTab].content[i].id === id) {
                    this.ribbon.items[args.activeTab].content[i].text = text;
                    this.ribbon.setProperties({ 'items': this.ribbon.items }, true);
                }
            }
            if (this.ribbon.items[this.ribbon.selectedTab].header.text === datatabHeader) {
                this.updateToggleText(args.props.toLowerCase(), text);
            }
        }
    }
    enableFileMenuItems(args) {
        this.ribbon.enableMenuItems(args.items, args.enable, args.isUniqueId);
    }
    hideRibbonTabs(args) {
        this.ribbon.hideTabs(args.tabs, args.hide);
    }
    addRibbonTabs(args) {
        this.ribbon.addTabs(args.items, args.insertBefore);
        const nextTab = select('.e-ribbon .e-tab-header .e-toolbar-item:not(.e-menu-tab).e-hide', this.parent.element);
        if (nextTab) {
            this.parent.updateActiveBorder(selectAll('.e-ribbon .e-tab-header .e-toolbar-item:not(.e-menu-tab)', this.parent.element)[this.ribbon.selectedTab]);
        }
    }
    updateToggleText(item, text) {
        const ele = select(`#${this.parent.element.id}_${item} .e-tbar-btn-text`, this.ribbon.element);
        if (item === 'protect' || item === 'protectworkbook') {
            ele.parentElement.setAttribute('aria-label', text);
        }
        else {
            ele.parentElement.setAttribute('aria-label', ele.textContent);
        }
        getUpdateUsingRaf(() => {
            if (ele) {
                ele.textContent = text;
            }
        });
        if (item === 'headers') {
            const findDlgEle = this.parent.element.getElementsByClassName('e-findtool-dlg')[0];
            if (findDlgEle && findDlgEle.classList.contains('e-popup-open')) {
                this.parent.notify(findToolDlg, { refreshPosition: true, dialogEle: findDlgEle });
            }
        }
    }
    refreshViewTabContent(activeTab) {
        const id = this.parent.element.id;
        const sheet = this.parent.getActiveSheet();
        const l10n = this.parent.serviceLocator.getService(locale);
        let tabItem;
        for (let i = 0; i < this.ribbon.items[activeTab].content.length; i++) {
            tabItem = this.ribbon.items[activeTab].content[i];
            if (tabItem.type === 'Separator') {
                continue;
            }
            if (tabItem.id === `${id}_headers`) {
                this.updateViewTabContent(activeTab, 'Headers', i);
            }
            if (tabItem.id === `${id}_gridlines`) {
                this.updateViewTabContent(activeTab, 'GridLines', i);
            }
            if (tabItem.id === (`${id}_freezepanes`)) {
                if (sheet.frozenRows || sheet.frozenColumns) {
                    if (tabItem.text === l10n.getConstant('FreezePanes')) {
                        this.updateToggleText('freezepanes', this.updateRibbonItemText('Unfreeze', 'Panes', i, activeTab));
                    }
                }
                else {
                    if (tabItem.text === l10n.getConstant('UnfreezePanes')) {
                        this.updateToggleText('freezepanes', this.updateRibbonItemText('Freeze', 'Panes', i, activeTab));
                    }
                }
            }
            if (tabItem.id === (`${id}_freezerows`)) {
                if (sheet.frozenRows) {
                    if (tabItem.text === l10n.getConstant('FreezeRows')) {
                        this.updateToggleText('freezerows', this.updateRibbonItemText('Unfreeze', 'Rows', i, activeTab));
                    }
                }
                else {
                    if (tabItem.text === l10n.getConstant('UnfreezeRows')) {
                        this.updateToggleText('freezerows', this.updateRibbonItemText('Freeze', 'Rows', i, activeTab));
                    }
                }
            }
            if (tabItem.id === (`${id}_freezecolumns`)) {
                if (sheet.frozenColumns) {
                    if (tabItem.text === l10n.getConstant('FreezeColumns')) {
                        this.updateToggleText('freezecolumns', this.updateRibbonItemText('Unfreeze', 'Columns', i, activeTab));
                    }
                }
                else {
                    if (tabItem.text === l10n.getConstant('UnfreezeColumns')) {
                        this.updateToggleText('freezecolumns', this.updateRibbonItemText('Freeze', 'Columns', i, activeTab));
                    }
                }
            }
        }
    }
    updateViewTabContent(activeTab, item, idx) {
        const sheet = this.parent.getActiveSheet();
        const l10n = this.parent.serviceLocator.getService(locale);
        if (sheet['show' + item]) {
            if (this.ribbon.items[activeTab].content[idx].text === l10n.getConstant('Show' + item)) {
                this.updateToggleText(item.toLowerCase(), this.updateRibbonItemText('Hide', item, idx, activeTab));
            }
        }
        else {
            if (this.ribbon.items[activeTab].content[idx].text === l10n.getConstant('Hide' + item)) {
                this.updateToggleText(item.toLowerCase(), this.updateRibbonItemText('Show', item, idx, activeTab));
            }
        }
    }
    updateRibbonItemText(showHideText, item, idx, activeTab) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const text = l10n.getConstant(showHideText + item);
        this.ribbon.items[activeTab].content[idx].text = text;
        this.ribbon.setProperties({ 'items': this.ribbon.items }, true);
        return text;
    }
    refreshDataTabContent(activeTab) {
        const id = this.parent.element.id;
        let updated;
        for (let j = 0; j < this.ribbon.items[activeTab].content.length; j++) {
            if (this.ribbon.items[activeTab].content[j].type === 'Separator') {
                continue;
            }
            if (this.ribbon.items[activeTab].content[j].id === `${id}_protect`) {
                this.updateDataTabContent(activeTab, 'Sheet', j);
                if (updated) {
                    break;
                }
                updated = true;
            }
            if (this.ribbon.items[activeTab].content[j].id === `${id}_protectworkbook`) {
                this.updateDataTabContent(activeTab, 'Workbook', j);
            }
        }
    }
    updateDataTabContent(activeTab, item, idx) {
        const sheet = this.parent.getActiveSheet();
        const l10n = this.parent.serviceLocator.getService(locale);
        if (item === 'Sheet') {
            if (sheet.isProtected) {
                if (this.ribbon.items[activeTab].content[idx].text === l10n.getConstant('Protect' + item)) {
                    this.ribbon.items[activeTab].content[idx].cssClass = 'e-active';
                    this.updateProtectBtn('Unprotect', item, idx, activeTab);
                }
            }
            else {
                this.updateProtectBtn('Protect', item, idx, activeTab);
            }
        }
        else if (item === 'Workbook') {
            const l10n = this.parent.serviceLocator.getService(locale);
            if (this.parent.isProtected) {
                if (this.ribbon.items[activeTab].content[idx].text === l10n.getConstant('Protect' + item)) {
                    this.updateToggleText('protectworkbook', this.updateRibbonItemText('Unprotect', item, idx, activeTab));
                }
            }
            else {
                if (this.ribbon.items[activeTab].content[idx].text === l10n.getConstant('Unprotect' + item)) {
                    this.updateToggleText('protectworkbook', this.updateRibbonItemText('Protect', item, idx, activeTab));
                }
            }
        }
    }
    updateProtectBtn(protectText, item, idx, activeTab) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const text = l10n.getConstant(protectText + item);
        this.ribbon.items[activeTab].content[idx].text = text;
        this.ribbon.setProperties({ 'items': this.ribbon.items }, true);
        this.updateToggleText('protect', text);
    }
    updateProtectWorkbookBtn(protectText, item, idx, activeTab) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const text = l10n.getConstant(protectText);
        this.ribbon.items[activeTab].content[idx].text = text;
        this.ribbon.setProperties({ 'items': this.ribbon.items }, true);
        this.updateToggleText('protectworkbook', text);
    }
    addToolbarItems(args) {
        const l10n = this.parent.serviceLocator.getService(locale);
        this.ribbon.addToolbarItems(l10n.getConstant(args.tab), args.items, args.index);
        if (this.parent && this.parent.isReact && this.parent.portals &&
            this.ribbon.toolbarObj && this.ribbon.toolbarObj.portals) {
            this.parent.portals = this.parent.portals.concat(this.ribbon.toolbarObj.portals);
            this.parent['renderReactTemplates']();
        }
    }
    enableToolbarItems(args) {
        args.forEach((arg) => {
            this.ribbon.enableItems(arg.tab || this.ribbon.items[this.ribbon.selectedTab].header.text, arg.items, arg.enable);
        });
    }
    createMobileView() {
        const parentId = this.parent.element.id;
        const toobar = this.parent.createElement('div', { className: 'e-header-toolbar' });
        const menu = this.parent.createElement('ul');
        toobar.appendChild(menu);
        const toolbarObj = new Toolbar({
            items: [
                { prefixIcon: 'e-tick-icon', align: 'Left', id: parentId + 'focused_tick', cssClass: 'e-focused-tick' },
                { template: menu, align: 'Right', id: parentId + 'file_menu' }
            ],
            clicked: (args) => {
                switch (args.item.id) {
                    case parentId + 'focused_tick':
                        this.parent.element.classList.remove('e-mobile-focused');
                        this.parent.renderModule.setSheetPanelSize();
                        break;
                }
            },
            created: () => {
                const menuObj = new Menu({
                    cssClass: 'e-mobile e-file-menu',
                    enableRtl: true,
                    showItemOnClick: true,
                    items: this.getRibbonMenuItems(),
                    select: this.fileMenuItemSelect.bind(this),
                    beforeOpen: (args) => {
                        args.element.parentElement.classList.remove('e-rtl');
                        this.fileMenuBeforeOpen(args);
                    },
                    beforeClose: this.fileMenuBeforeClose.bind(this)
                });
                menuObj.createElement = this.parent.createElement;
                menuObj.appendTo(menu);
            }
        });
        toolbarObj.createElement = this.parent.createElement;
        toolbarObj.appendTo(toobar);
        this.parent.element.insertBefore(toobar, this.parent.element.firstElementChild);
        this.renderMobileToolbar();
    }
    renderMobileToolbar() {
        const toolbarPanel = this.parent.createElement('div', { className: 'e-toolbar-panel e-ribbon' });
        const toolbar = this.parent.createElement('div');
        const ddb = this.parent.createElement('button', { attrs: { 'type': 'button' } });
        toolbarPanel.appendChild(toolbar);
        toolbarPanel.appendChild(ddb);
        toolbarPanel.style.display = 'block';
        this.parent.element.appendChild(toolbarPanel);
        const ddbObj = new DropDownButton({
            cssClass: 'e-caret-hide',
            content: this.ribbon.items[0].header.text,
            items: [
                { text: this.ribbon.items[0].header.text },
                { text: this.ribbon.items[1].header.text },
                { text: this.ribbon.items[2].header.text },
                { text: this.ribbon.items[3].header.text }
            ],
            createPopupOnClick: true,
            select: (args) => {
                if (args.item.text !== ddbObj.content) {
                    toolbarObj.element.style.display = 'none';
                    ddbObj.content = args.item.text;
                    ddbObj.dataBind();
                    toolbarObj.items = this.ribbon.items[ddbObj.items.indexOf(args.item) + 1].content;
                    toolbarObj.width = `calc(100% - ${ddb.getBoundingClientRect().width}px)`;
                    toolbarObj.element.style.display = '';
                    toolbarObj.dataBind();
                    toolbarObj.items[0].text = args.item.text;
                    toolbarObj.dataBind();
                }
            },
            open: (args) => {
                const element = args.element.parentElement;
                const clientRect = element.getBoundingClientRect();
                const offset = calculatePosition(ddbObj.element, 'right', 'bottom');
                element.style.left = `${offset.left - clientRect.width}px`;
                element.style.top = `${offset.top - clientRect.height}px`;
                for (let i = 0; i < ddbObj.items.length; i++) {
                    if (ddbObj.content === ddbObj.items[i].text) {
                        args.element.children[i].classList.add('e-selected');
                        break;
                    }
                }
            },
            close: () => focus(this.parent.element)
        });
        ddbObj.createElement = this.parent.createElement;
        ddbObj.appendTo(ddb);
        const toolbarObj = new Toolbar({
            width: `calc(100% - ${ddb.getBoundingClientRect().width}px)`,
            items: this.ribbon.items[0].content,
            clicked: this.toolbarClicked.bind(this)
        });
        toolbarObj.createElement = this.parent.createElement;
        toolbarObj.appendTo(toolbar);
        toolbarPanel.style.display = '';
    }
    fileMenuBeforeOpen(args) {
        const l10n = this.parent.serviceLocator.getService(locale);
        let wrapper;
        const contents = ['.xlsx', '.xls', '.csv', '.pdf'];
        if (args.parentItem.text === l10n.getConstant('SaveAs')) {
            [].slice.call(args.element.children).forEach((li, index) => {
                wrapper = this.parent.createElement('div', { innerHTML: li.innerHTML });
                li.innerHTML = '';
                const extension = this.parent.createElement('span', { className: 'e-extension' });
                extension.innerText = contents[index];
                wrapper.appendChild(extension);
                li.appendChild(wrapper);
            });
        }
        this.parent.trigger('fileMenuBeforeOpen', args);
        args.element.setAttribute('aria-label', l10n.getConstant('File'));
    }
    enableRibbonTabs(args) {
        this.ribbon.enableTabs(args.tabs, args.enable);
    }
    fileMenuBeforeClose(args) {
        this.parent.trigger('fileMenuBeforeClose', args);
        if (args.parentItem && args.event && args.event.keyCode === 37 &&
            args.parentItem.id === `${this.parent.element.id}_File`) {
            getUpdateUsingRaf(() => {
                const tabItem = this.ribbon.element.querySelector('.e-tab-header .e-toolbar-item .e-tab-wrap');
                if (tabItem) {
                    focus(tabItem);
                    const menuItem = tabItem.querySelector('.e-menu-item.e-focused');
                    if (menuItem) {
                        menuItem.classList.remove('e-focused');
                    }
                }
            });
        }
    }
    hideFileMenuItems(args) {
        this.ribbon.hideMenuItems(args.items, args.hide, args.isUniqueId);
    }
    addFileMenuItems(args) {
        this.ribbon.addMenuItems(args.items, args.text, args.insertAfter, args.isUniqueId);
    }
    hideToolbarItems(args) {
        this.ribbon.hideToolbarItems(args.tab, args.indexes, args.hide);
    }
    protectSheetHandler(args) {
        const sheet = this.parent.getActiveSheet();
        const l10n = this.parent.serviceLocator.getService(locale);
        if ((sheet.isProtected && sheet.protectSettings.formatCells) || !sheet.isProtected) {
            if (this.parent.allowCellFormatting) {
                this.enableToolbarItems([{ tab: l10n.getConstant('Home'), items: args.enableHomeBtnId, enable: true }]);
                if (sheet.isProtected && sheet.protectSettings.formatCells) {
                    this.enableToolbarItems([{ tab: l10n.getConstant('Home'), items: args.enableHomeBtnId.slice(15, 16), enable: false }]);
                }
            }
            else {
                this.enableToolbarItems([{ tab: l10n.getConstant('Home'), items: args.enableHomeBtnId.slice(3, 14), enable: false }]);
            }
            if (!this.parent.allowWrap) {
                this.enableToolbarItems([{ tab: l10n.getConstant('Home'), items: args.enableHomeBtnId.slice(14, 15), enable: false }]);
            }
            if (!this.parent.allowNumberFormatting) {
                this.enableToolbarItems([{ tab: l10n.getConstant('Home'), items: args.enableHomeBtnId.slice(2, 3), enable: false }]);
            }
            this.parent.notify(setUndoRedo, null);
        }
        else {
            this.enableToolbarItems([{ tab: l10n.getConstant('Home'), items: args.disableHomeBtnId, enable: false }]);
        }
        if ((sheet.isProtected && sheet.protectSettings.insertLink) || !sheet.isProtected) {
            if (!this.parent.allowHyperlink || (sheet.isProtected && sheet.protectSettings.insertLink)) {
                this.enableToolbarItems([{ tab: l10n.getConstant('Insert'), items: args.enableInsertBtnId.slice(0, 1), enable: false }]);
            }
            else {
                this.enableToolbarItems([{ tab: l10n.getConstant('Insert'), items: args.enableInsertBtnId, enable: true }]);
            }
        }
        else {
            this.enableToolbarItems([{ tab: l10n.getConstant('Insert'), items: args.enableInsertBtnId, enable: false }]);
        }
        this.enableToolbarItems([{ tab: l10n.getConstant('Home'), items: args.findBtnId, enable: !sheet.isProtected || sheet.protectSettings.selectCells ||
                    sheet.protectSettings.selectUnLockedCells }]);
        const len = this.ribbon.items[this.ribbon.selectedTab].content.length;
        let i;
        for (i = 0; i < len; i++) {
            if (this.ribbon.items[this.ribbon.selectedTab].content[i].id === this.parent.element.id + '_protectworkbook') {
                break;
            }
        }
        if (sheet.isProtected) {
            if (this.parent.isProtected && this.parent.element.querySelector('#' + this.parent.element.id + '_protectworkbook') &&
                this.parent.element.querySelector('#' + this.parent.element.id + '_protectworkbook')
                    .querySelector('.e-tbar-btn-text').textContent === l10n.getConstant('UnprotectWorkbook')) {
                if (this.ribbon.items[this.ribbon.selectedTab].header.text === l10n.getConstant('Data')) {
                    this.ribbon.items[this.ribbon.selectedTab].content[i].text = l10n.getConstant('UnprotectWorkbook');
                }
            }
            else {
                if (this.ribbon.items[this.ribbon.selectedTab].header.text === l10n.getConstant('Data')) {
                    this.ribbon.items[this.ribbon.selectedTab].content[i].text = l10n.getConstant('ProtectWorkbook');
                }
            }
            this.enableToolbarItems([{ tab: l10n.getConstant('Insert'), items: args.imageBtnId, enable: false }]);
            this.enableToolbarItems([{ tab: l10n.getConstant('Data'), items: args.dataValidationBtnId, enable: false }]);
            this.enableToolbarItems([{ tab: l10n.getConstant('Formulas'), items: args.enableFrmlaBtnId, enable: false }]);
            this.enableToolbarItems([{ tab: l10n.getConstant('Insert'), items: args.chartBtnId, enable: false }]);
        }
        else {
            if (this.parent.isProtected && this.parent.element.querySelector('#' + this.parent.element.id + '_protectworkbook') &&
                this.parent.element.querySelector('#' + this.parent.element.id + '_protectworkbook')
                    .querySelector('.e-tbar-btn-text').textContent === l10n.getConstant('UnprotectWorkbook')) {
                if (this.ribbon.items[this.ribbon.selectedTab].header.text === l10n.getConstant('Data')) {
                    this.ribbon.items[this.ribbon.selectedTab].content[i].text = l10n.getConstant('UnprotectWorkbook');
                }
            }
            else {
                if (this.ribbon.items[this.ribbon.selectedTab].header.text === l10n.getConstant('Data')) {
                    this.ribbon.items[this.ribbon.selectedTab].content[i].text = l10n.getConstant('ProtectWorkbook');
                }
            }
            this.enableToolbarItems([{ tab: l10n.getConstant('Insert'), items: args.imageBtnId, enable: this.parent.allowImage }]);
            this.enableToolbarItems([{ tab: l10n.getConstant('Data'), items: args.dataValidationBtnId,
                    enable: this.parent.allowDataValidation }]);
            this.enableToolbarItems([{ tab: l10n.getConstant('Formulas'), items: args.enableFrmlaBtnId, enable: true }]);
            this.enableToolbarItems([{ tab: l10n.getConstant('Insert'), items: args.chartBtnId, enable: this.parent.allowChart }]);
        }
    }
    updateMergeItem(e) {
        if (this.parent.allowMerge && (isMouseMove(e) || e.type === 'touchmove' ||
            (e.shiftKey && (e.type === 'mousedown' || e.type === 'touchend')))) {
            const sheet = this.parent.getActiveSheet();
            if (!sheet.isProtected) {
                let indexes = getRangeIndexes(sheet.selectedRange);
                if (indexes[1] === indexes[3] && indexes[0] === indexes[2]) {
                    this.enableToolbarItems([{ tab: this.parent.serviceLocator.getService(locale).getConstant('Home'),
                            items: [`${this.parent.element.id}_merge_cells`], enable: false }]);
                    this.toggleActiveState(false);
                }
                else {
                    this.enableToolbarItems([{ tab: this.parent.serviceLocator.getService(locale).getConstant('Home'),
                            items: [`${this.parent.element.id}_merge_cells`], enable: true }]);
                    indexes = getSwapRange(indexes);
                    const cell = getCell(indexes[0], indexes[1], sheet, false, true);
                    if (cell.rowSpan > 1 || cell.colSpan > 1) {
                        this.toggleActiveState((!(cell.rowSpan > 1) || indexes[0] + cell.rowSpan - 1 === indexes[2]) && (!(cell.colSpan > 1) ||
                            indexes[1] + cell.colSpan - 1 === indexes[3]));
                    }
                    else {
                        this.toggleActiveState(false);
                    }
                }
            }
        }
    }
    onPropertyChanged(prop) {
        const l10 = this.parent.serviceLocator.getService(locale);
        const id = this.parent.element.id;
        const sheet = this.parent.getActiveSheet();
        switch (prop) {
            case 'allowFreezePane':
                this.ribbon.enableItems(l10.getConstant('View'), [`${id}_freezepanes`, `${id}_freezerows`, `${id}_freezecolumns`], this.parent.allowFreezePane);
                break;
            case 'showRibbon':
                if (this.parent.showRibbon) {
                    this.initialize(true);
                }
                else if (this.ribbon) {
                    this.destroy();
                }
                break;
            case 'allowImage':
                this.ribbon.enableItems(l10.getConstant('Insert'), [`${id}_image`], this.parent.allowImage);
                break;
            case 'allowChart':
                this.ribbon.enableItems(l10.getConstant('Insert'), [`${id}_chart`], this.parent.allowChart);
                if (!this.parent.allowChart) {
                    this.removeDesignChart();
                }
                break;
            case 'allowWrap':
            case 'allowCellFormatting':
                this.refreshToggleBtn(getCellIndexes(sheet.activeCell));
                if (!sheet.isProtected || sheet.protectSettings.formatCells) {
                    if (prop === 'allowWrap') {
                        this.ribbon.enableItems(l10.getConstant('Home'), [`${id}_wrap`], this.parent.allowWrap);
                    }
                    else {
                        const formatIds = [`${id}_font_name`, `${id}_font_size`, `${id}_bold`, `${id}_italic`, `${id}_line-through`,
                            `${id}_underline`, `${id}_font_color_picker`, `${id}_fill_color_picker`, `${id}_borders`, `${id}_merge_cells`,
                            `${id}_text_align`, `${id}_vertical_align`];
                        this.enableToolbarItems([{ tab: l10.getConstant('Home'), items: formatIds, enable: this.parent.allowCellFormatting }]);
                    }
                }
                break;
            case 'allowNumberFormatting':
                if (!sheet.isProtected || sheet.protectSettings.formatCells) {
                    this.ribbon.enableItems(l10.getConstant('Home'), [`${id}_number_format`], this.parent.allowNumberFormatting);
                }
                break;
            case 'calculationMode':
                this.parent.notify(enableToolbarItems, [{
                        tab: l10.getConstant('Formulas'), items: [this.parent.element.id + '_calc_current_sheet',
                            this.parent.element.id + '_calc_entire_sheets'], enable: this.parent.calculationMode === 'Manual'
                    }]);
                if (this.calcTypeOptions) {
                    this.calcTypeOptions.items[0].iconCss = this.parent.calculationMode === 'Automatic' ? 'e-icons e-selected-icon' : '';
                    this.calcTypeOptions.items[1].iconCss = this.parent.calculationMode === 'Manual' ? 'e-icons e-selected-icon' : '';
                }
                if (this.parent.calculationMode === 'Automatic') {
                    this.parent.calculateNow('Workbook');
                }
                break;
        }
    }
    addEventListener() {
        this.parent.on(ribbon, this.ribbonOperation, this);
        this.parent.on(enableToolbarItems, this.enableToolbarItems, this);
        this.parent.on(activeCellChanged, this.refreshRibbonContent, this);
        this.parent.on(updateToggleItem, this.toggleRibbonItems, this);
        this.parent.on(enableFileMenuItems, this.enableFileMenuItems, this);
        this.parent.on(hideRibbonTabs, this.hideRibbonTabs, this);
        this.parent.on(addRibbonTabs, this.addRibbonTabs, this);
        this.parent.on(addToolbarItems, this.addToolbarItems, this);
        this.parent.on(hideFileMenuItems, this.hideFileMenuItems, this);
        this.parent.on(addFileMenuItems, this.addFileMenuItems, this);
        this.parent.on(hideToolbarItems, this.hideToolbarItems, this);
        this.parent.on(enableRibbonTabs, this.enableRibbonTabs, this);
        this.parent.on(protectCellFormat, this.protectSheetHandler, this);
        this.parent.on(selectionComplete, this.updateMergeItem, this);
        this.parent.on(refreshRibbonIcons, this.refreshRibbonContent, this);
        this.parent.on(insertDesignChart, this.insertDesignChart, this);
        this.parent.on(removeDesignChart, this.removeDesignChart, this);
        this.parent.on(unMerge, this.unMerge, this);
    }
    destroy() {
        const parentElem = this.parent.element;
        const ribbonEle = this.ribbon ? this.ribbon.element : null;
        const cPickerEle = this.cPickerEle;
        const id = parentElem.id;
        const l10n = this.parent.serviceLocator.getService(locale);
        const ribbonTabObj = getComponent(parentElem.querySelector('.e-tab'), 'tab');
        let curTabIndex;
        if (ribbonTabObj) {
            curTabIndex = ribbonTabObj.selectedItem;
        }
        this.switchRibbonTab(l10n.getConstant('Home'));
        ['bold', 'italic', 'line-through', 'underline', 'cut', 'copy', 'undo', 'redo', 'wrap'].forEach((name) => {
            destroyComponent(select('#' + `${id}_${name}`, parentElem), Button);
        });
        if (this.pasteSplitBtn) {
            this.pasteSplitBtn.destroy();
        }
        this.pasteSplitBtn = null;
        if (this.mergeSplitBtn) {
            this.mergeSplitBtn.destroy();
        }
        this.mergeSplitBtn = null;
        if (this.numFormatDDB) {
            this.numFormatDDB.destroy();
        }
        this.numFormatDDB = null;
        if (this.fontSizeDdb) {
            this.fontSizeDdb.destroy();
        }
        this.fontSizeDdb = null;
        if (this.fontNameDdb) {
            this.fontNameDdb.destroy();
        }
        this.fontNameDdb = null;
        if (this.textAlignDdb) {
            this.textAlignDdb.destroy();
        }
        this.textAlignDdb = null;
        if (this.verticalAlignDdb) {
            this.verticalAlignDdb.destroy();
        }
        this.verticalAlignDdb = null;
        if (this.sortingDdb) {
            this.sortingDdb.destroy();
        }
        this.sortingDdb = null;
        if (this.clearDdb) {
            this.clearDdb.destroy();
        }
        this.clearDdb = null;
        if (this.colorPicker) {
            this.colorPicker.destroy();
        }
        this.colorPicker = null;
        this.destroyComponent(`${id}_borders_menu`, 'menu');
        if (this.bordersDdb) {
            this.bordersDdb.destroy();
        }
        this.bordersDdb = null;
        if (this.findDdb) {
            this.findDdb.destroy();
        }
        this.findDdb = null;
        this.destroyComponent(id + '_chart_menu', 'menu');
        this.destroyComponent(id + '_chart_type_menu', 'menu');
        this.destroyComponent(id + '_chart-btn', 'dropdown-btn');
        this.destroyComponent(id + '_chart-type-btn', 'dropdown-btn');
        this.destroyComponent(`${id}_cf_menu`, 'menu');
        if (this.cfDdb) {
            this.cfDdb.destroy();
            if (this.cfDdb.element) {
                this.cfDdb.element.remove();
            }
        }
        this.cfDdb = null;
        this.detachPopupElement(id);
        this.parent.notify('destroyRibbonComponents', null);
        if (curTabIndex) {
            ribbonTabObj.selectedItem = curTabIndex;
            ribbonTabObj.dataBind();
        }
        if (this.addChartDdb) {
            this.addChartDdb.destroy();
            this.addChartDdb = null;
        }
        this.destroyComponent(id + '_chart_theme', 'menu');
        this.destroyComponent(id + '_chart_theme', 'dropdown-btn');
        this.destroyComponent(id + '_chart-type-btn', 'menu');
        this.destroyComponent(id + '_chart-type-btn', 'dropdown-btn');
        if (this.datavalidationDdb) {
            this.datavalidationDdb.destroy();
        }
        this.datavalidationDdb = null;
        if (cPickerEle) {
            detach(cPickerEle);
        }
        const customFormatDlg = this.parent.serviceLocator.getService(dialog);
        if (customFormatDlg.dialogInstance && customFormatDlg.dialogInstance.element.classList.contains('e-custom-format-dlg')) {
            customFormatDlg.hide(true);
        }
        this.cPickerEle = null;
        if (this.border) {
            this.border = '';
        }
        if (this.fontNameIndex) {
            this.fontNameIndex = null;
        }
        if (this.preTabIdx) {
            this.preTabIdx = null;
        }
        if (this.numPopupWidth) {
            this.numPopupWidth = null;
        }
        if (this.ribbon) {
            this.ribbon.destroy();
        }
        if (ribbonEle) {
            detach(ribbonEle);
        }
        this.ribbon = null;
        this.removeEventListener();
        this.parent = null;
    }
    destroyComponent(id, moduleName) {
        const ele = typeof id === 'string' ? document.getElementById(id) : id;
        if (ele) {
            if (moduleName !== 'menu' || ele.childElementCount) {
                const compObj = getComponent(ele, moduleName);
                if (compObj) {
                    compObj.destroy();
                    if (moduleName === 'dropdown-btn') {
                        const popup = document.getElementById(`${ele.id}-popup`);
                        if (popup) {
                            detach(popup);
                        }
                    }
                }
            }
            if (moduleName === 'menu') {
                detach(ele);
            }
        }
    }
    detachPopupElement(id) {
        ['_conditionalformatting', '_chart-type-btn', '_chart-btn', '_borders'].forEach((selector) => {
            const ddbPopup = document.getElementById(`${id}${selector}-popup`);
            if (ddbPopup) {
                detach(ddbPopup);
            }
        });
    }
    switchRibbonTab(tabInnerText) {
        let tabId;
        const tabTextElements = this.parent.element.querySelectorAll('.e-tab-text');
        for (let i = 0; i < tabTextElements.length; i++) {
            const element = tabTextElements[i];
            if (element.textContent.toLowerCase() === tabInnerText.toLowerCase()) {
                const parentElement = element.closest('.e-toolbar-item');
                if (parentElement) {
                    tabId = parentElement.getAttribute('data-id');
                    break;
                }
            }
        }
        const tabObj = getComponent(this.parent.element.querySelector('.e-tab'), 'tab');
        if (tabObj && !isNullOrUndefined(tabId)) {
            tabObj.selectedItem = tabObj.getItemIndex(tabId);
            tabObj.dataBind();
        }
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(ribbon, this.ribbonOperation);
            this.parent.off(enableToolbarItems, this.enableToolbarItems);
            this.parent.off(activeCellChanged, this.refreshRibbonContent);
            this.parent.off(updateToggleItem, this.toggleRibbonItems);
            this.parent.off(enableFileMenuItems, this.enableFileMenuItems);
            this.parent.off(hideRibbonTabs, this.hideRibbonTabs);
            this.parent.off(addRibbonTabs, this.addRibbonTabs);
            this.parent.off(addToolbarItems, this.addToolbarItems);
            this.parent.off(hideFileMenuItems, this.hideFileMenuItems);
            this.parent.off(addFileMenuItems, this.addFileMenuItems);
            this.parent.off(hideToolbarItems, this.hideToolbarItems);
            this.parent.off(enableRibbonTabs, this.enableRibbonTabs);
            this.parent.off(protectCellFormat, this.protectSheetHandler);
            this.parent.off(selectionComplete, this.updateMergeItem);
            this.parent.off(refreshRibbonIcons, this.refreshRibbonContent);
            this.parent.off(insertDesignChart, this.insertDesignChart);
            this.parent.off(removeDesignChart, this.removeDesignChart);
            this.parent.off(unMerge, this.unMerge);
        }
    }
}

/**
 * Represents Formula bar for Spreadsheet.
 */
class FormulaBar {
    constructor(parent) {
        this.categoryCollection = [];
        this.formulaCollection = [];
        this.isGoto = false;
        this.parent = parent;
        this.addEventListener();
    }
    getModuleName() {
        return 'formulaBar';
    }
    createFormulaBar(args) {
        if (!this.parent.showFormulaBar && this.insertFnRipple) {
            this.destroy();
            return;
        }
        const l10n = this.parent.serviceLocator.getService(locale);
        const id = this.parent.element.id;
        const fBarWrapper = this.parent.createElement('div', { className: 'e-formula-bar-panel' });
        if (!this.parent.isMobileView()) {
            const nameBox = this.parent.createElement('input', { id: id + '_name_box', attrs: { type: 'text' } });
            fBarWrapper.appendChild(nameBox);
            this.comboBoxInstance = new ComboBox({
                value: 'A1',
                cssClass: 'e-name-box',
                width: '',
                noRecordsTemplate: initializeCSPTemplate(function () { return ''; }),
                fields: { text: 'name', value: 'refersTo' },
                beforeOpen: this.nameBoxBeforeOpen.bind(this),
                blur: this.nameBoxBlur.bind(this),
                select: this.nameBoxSelect.bind(this),
                open: () => {
                    if (this.isDevice) {
                        window.browserDetails.isDevice = true;
                    }
                },
                change: () => {
                    /** */
                }
            });
            this.comboBoxInstance.createElement = this.parent.createElement;
            this.comboBoxInstance.appendTo(nameBox);
            this.comboBoxInstance.element.parentElement.title = l10n.getConstant('NameBox');
        }
        const insertFnBtn = fBarWrapper.appendChild(this.parent.createElement('button', {
            className: 'e-btn e-css e-flat e-icon-btn e-insert-function', attrs: { 'title': l10n.getConstant('InsertFunction'), 'type': 'button' }
        }));
        insertFnBtn.appendChild(this.parent.createElement('span', { className: 'e-btn-icon e-icons' }));
        this.insertFnRipple = rippleEffect(fBarWrapper, { selector: '.e-insert-function' });
        fBarWrapper.appendChild(this.parent.createElement('div', { className: 'e-separator' }));
        const formulaBarLocale = l10n.getConstant('FormulaBar');
        const textarea = fBarWrapper.appendChild(this.parent.createElement('textarea', {
            className: 'e-formula-bar e-css', id: id + '_formula_input',
            attrs: { 'title': formulaBarLocale, 'aria-label': formulaBarLocale, 'spellcheck': 'false' }
        }));
        textarea.rows = 1;
        if (this.parent.isMobileView()) {
            textarea.placeholder = l10n.getConstant('MobileFormulaBarPlaceHolder');
            EventHandler.add(textarea, 'focus', this.textAreaFocusIn, this);
            EventHandler.add(textarea, 'blur', this.textAreaFocusOut, this);
        }
        else {
            const text = l10n.getConstant('ExpandFormulaBar');
            fBarWrapper.appendChild(this.parent.createElement('span', { className: 'e-drop-icon e-icons', attrs: { 'title': text, 'role': 'button',
                    'tabindex': '-1', 'aria-label': text } }));
        }
        if (args && args.uiUpdate) {
            this.parent.element.insertBefore(fBarWrapper, document.getElementById(id + '_sheet_panel'));
        }
        else {
            this.parent.element.appendChild(fBarWrapper);
        }
    }
    textAreaFocusIn() {
        const formulaPanel = this.parent.element.querySelector('.e-formula-bar-panel');
        const tickBtn = this.parent.createElement('button', { className: 'e-btn e-css e-flat e-icon-btn e-formula-submit', attrs: { 'type': 'button' } });
        tickBtn.appendChild(this.parent.createElement('span', { className: 'e-btn-icon e-icons e-tick-icon' }));
        formulaPanel.classList.add('e-focused');
        formulaPanel.appendChild(tickBtn);
    }
    textAreaFocusOut() {
        const formulaPanel = this.parent.element.querySelector('.e-formula-bar-panel');
        formulaPanel.classList.remove('e-focused');
        detach(formulaPanel.querySelector('.e-formula-submit'));
    }
    keyDownHandler(e) {
        const trgtElem = e.target;
        if (this.parent.isEdit && (!this.parent.getActiveSheet().isProtected || (trgtElem.classList.contains('e-formula-bar') && !trgtElem.disabled))) {
            if ((checkIsFormula(trgtElem.value) || (trgtElem.validity && trgtElem.value.toString().indexOf('=') === 0)) &&
                (e.keyCode === 16 || e.keyCode === 17)) {
                return;
            }
            if (trgtElem.classList.contains('e-formula-bar') && (!e.shiftKey || (e.shiftKey && !isNavigationKey(e.keyCode)))) {
                this.parent.notify(editOperation, { action: 'refreshEditor', value: trgtElem.value, refreshEditorElem: true });
            }
        }
    }
    keyUpHandler(e) {
        if (this.parent.isEdit) {
            const trgtElem = e.target;
            if (trgtElem.classList.contains('e-formula-bar')) {
                const eventArg = { action: 'getCurrentEditValue', editedValue: '' };
                this.parent.notify(editOperation, eventArg);
                if (eventArg.editedValue !== trgtElem.value && e.keyCode !== 16 && e.keyCode !== 17 &&
                    (!e.shiftKey || (e.shiftKey && !isNavigationKey(e.keyCode)))) {
                    this.parent.notify(editOperation, { action: 'refreshEditor', value: trgtElem.value, refreshEditorElem: true });
                }
            }
        }
    }
    nameBoxBeforeOpen(args) {
        if (this.comboBoxInstance.element.classList.contains('e-name-editing')) {
            args.cancel = true;
        }
        else {
            this.comboBoxInstance.element.select();
            this.isDevice = window.browserDetails.isDevice;
            if (this.isDevice) {
                window.browserDetails.isDevice = false;
            }
        }
    }
    nameBoxBlur() {
        if (this.comboBoxInstance.element.classList.contains('e-name-editing')) {
            this.comboBoxInstance.element.classList.remove('e-name-editing');
            this.updateValueAfterMouseUp();
        }
    }
    nameBoxSelect(args) {
        if (args.isInteracted && (!args.e || args.e.type !== 'keydown' || (args.e.keyCode !== 40 &&
            args.e.keyCode !== 38))) {
            const refersTo = args.itemData.refersTo.substr(1);
            const sheetIdx = getSheetIndex(this.parent, getSheetNameFromAddress(refersTo));
            if (sheetIdx === undefined) {
                return;
            }
            let range = getRangeFromAddress(refersTo);
            const sheet = getSheet(this.parent, sheetIdx);
            let left;
            let right;
            if (range.indexOf(':') === -1) {
                left = right = range.replace('$', '');
            }
            else {
                const colIndex = range.indexOf(':');
                left = range.substr(0, colIndex).replace('$', '');
                right = range.substr(colIndex + 1, range.length).replace('$', '');
            }
            if (right.match(/\D/g) && !right.match(/[0-9]/g) && left.match(/\D/g) && !left.match(/[0-9]/g)) {
                left = left + '1';
                right = right + sheet.rowCount;
                range = left + ':' + right;
            }
            else if (!right.match(/\D/g) && right.match(/[0-9]/g) && !left.match(/\D/g) && left.match(/[0-9]/g)) {
                left = getCellAddress(parseInt(left, 10) - 1, 0);
                right = getCellAddress(parseInt(right, 10) - 1, sheet.colCount - 1);
                range = left + ':' + right;
            }
            if (sheetIdx === this.parent.activeSheetIndex) {
                if (!this.parent.isEdit) {
                    this.parent.selectRange(range);
                }
                this.parent.notify(addressHandle, { range: range, isSelect: false, isMouseDown: false, isNameBoxSelect: true });
                focus(this.parent.element);
            }
            else {
                updateSelectedRange(this.parent, range, sheet);
                this.parent.activeSheetIndex = sheetIdx;
                this.parent.notify(addressHandle, { range: range, isSelect: false, isMouseDown: false, isNameBoxSelect: true });
                focus(this.parent.element);
            }
        }
    }
    formulaBarUpdateHandler(e) {
        const sheet = this.parent.getActiveSheet();
        const range = sheet.selectedRange.split(':');
        let address;
        const editArgs = { action: 'getElement', element: null };
        this.parent.notify(editOperation, editArgs);
        const formulaBar = this.parent.element.querySelector('.e-formula-bar');
        if (e.type === 'mousemove' || e.type === 'pointermove') {
            const indexes1 = getRangeIndexes(range[0]);
            const indexes2 = getRangeIndexes(range[1]);
            address = `${Math.abs(indexes1[0] - indexes2[0]) + 1}R x ${Math.abs(indexes1[1] - indexes2[1]) + 1}C`;
            if (this.parent.isEdit) {
                if (e.target && !e.target.classList.contains('e-spreadsheet-edit')) {
                    this.parent.notify(editValue, {});
                }
                else if (editArgs.element) {
                    formulaBar.value = editArgs.element.textContent;
                }
            }
        }
        else {
            address = range[0];
            const cellAddr = `${getSheetName(this.parent)}!${address}`;
            getData(this.parent, cellAddr, false, true).then((values) => {
                if (!this.parent) {
                    return;
                }
                values.forEach((cell) => {
                    const value = this.getFormulaBarValue(cell);
                    const eventArgs = { action: 'getCurrentEditValue', editedValue: '' };
                    this.parent.notify(editOperation, eventArgs);
                    const formulaInp = document.getElementById(this.parent.element.id + '_formula_input');
                    const previousVal = formulaInp.value;
                    formulaInp.value = value;
                    if (!eventArgs.editedValue || !checkIsFormula(eventArgs.editedValue.toString(), true)) {
                        this.parent.notify(editOperation, { action: 'refreshEditor', value: value, refreshEditorElem: true });
                    }
                    if (this.parent.isEdit) {
                        if (e.target && !e.target.classList.contains('e-spreadsheet-edit')) {
                            this.parent.notify(editValue, { isMouseDown: isMouseDown(e), formulaBarVal: previousVal });
                        }
                        else if (editArgs.element) {
                            formulaBar.value = editArgs.element.textContent;
                        }
                    }
                });
            });
        }
        this.updateComboBoxValue(address);
    }
    getFormulaBarValue(cell) {
        let value = '';
        if (cell) {
            if (cell.formula) {
                value = cell.formula;
            }
            else if (!isNullOrUndefined(cell.value) && cell.value !== '') {
                const option = {};
                let type = cell.format && isCustomDateTime(cell.format, true, option, true) && option.type;
                if (type === 'date' || type === 'time' || type === 'datetime') {
                    const dateVal = intToDate(Number(cell.value));
                    if (dateVal && dateVal.toString() !== 'Invalid Date' && dateVal.getFullYear() >= 1900) {
                        const intl = new Internationalization();
                        let time = getFormatFromType('Time');
                        if (time === 'h:mm:ss AM/PM') {
                            time = 'h:mm:ss a';
                        }
                        const format = cell.format.toLowerCase();
                        // isCustomDateTime returns as type 'time' for 'm', 'mm' and 'mmm' format, so we converting as 'date' type.
                        if (type === 'time' && format.includes('m') && !format.includes(':m') && !format.includes('m:') &&
                            !format.includes('[m') && !format.includes('am')) {
                            type = 'date';
                        }
                        const valArr = cell.value.toString().split('.');
                        const isDateTimeVal = valArr.length === 2;
                        const timeVal = isDateTimeVal ? intToDate(parseFloat((valArr[0] + 1) + '.' + valArr[1]) ||
                            Number(cell.value)) : dateVal;
                        if (type === 'date') {
                            const dateObj = { type: 'date' };
                            dateObj.skeleton = 'yMd';
                            value = intl.formatDate(dateVal, dateObj);
                            if (isDateTimeVal) {
                                value += ' ' + intl.formatDate(timeVal, { type: 'time', skeleton: 'medium', format: time });
                            }
                        }
                        else {
                            if (Number(cell.value) >= 1 || type === 'datetime') {
                                value = intl.formatDate(dateVal, { type: 'date', skeleton: 'yMd' }) + ' ';
                            }
                            value += intl.formatDate(timeVal, { type: 'time', skeleton: 'medium', format: time });
                        }
                    }
                }
                else if (cell.format && cell.format.includes('%') && isNumber(cell.value)) {
                    value = this.parent.getDisplayText(cell);
                    if (!value.includes('%')) {
                        value = '';
                    }
                }
                if (!value) {
                    value = cell.value.toString();
                    if (value.toLowerCase() === 'true' || value.toLowerCase() === 'false') {
                        value = value.toUpperCase();
                    }
                    else if (this.parent.locale !== 'en-US') {
                        const decimalSep = getNumericObject(this.parent.locale).decimal;
                        if (decimalSep !== '.' && isNumber(value) && value.includes('.')) {
                            value = value.replace('.', decimalSep);
                        }
                    }
                }
            }
            else if (cell.hyperlink) {
                value = typeof cell.hyperlink === 'string' ? cell.hyperlink : (cell.hyperlink.address || '');
            }
        }
        return value;
    }
    updateValueAfterMouseUp() {
        this.updateComboBoxValue(this.parent.getActiveSheet().selectedRange.split(':')[0]);
    }
    updateComboBoxValue(value) {
        const sheet = this.parent.getActiveSheet();
        const range = getSheetName(this.parent) + '!' + sheet.selectedRange;
        const eventArgs = {
            action: 'getNameFromRange', range: range, definedName: null
        };
        this.parent.notify(formulaOperation, eventArgs);
        if (eventArgs.definedName) {
            value = eventArgs.definedName.name;
        }
        if (!this.parent.isMobileView()) {
            if (this.comboBoxInstance.text === value) {
                return;
            }
            this.comboBoxInstance.text = value;
            this.comboBoxInstance.dataBind();
        }
    }
    disabletextarea() {
        const element = this.getFormulaBar();
        if (this.parent.getActiveSheet().isProtected && !this.parent.isEdit) {
            element.disabled = true;
        }
        else {
            element.disabled = false;
        }
    }
    updateNameBoxValue(definedName, isRemove) {
        const id = this.parent.element.id;
        const comboBoxInstance = getComponent(this.parent.element.querySelector(`#${id}_name_box`), 'combobox');
        const activeSheet = this.parent.getActiveSheet();
        if (isRemove) {
            if (comboBoxInstance.text === definedName.name) {
                comboBoxInstance.value = activeSheet.activeCell;
                comboBoxInstance.dataBind();
            }
        }
        else {
            const refRangeArr = definedName.refersTo.split('!');
            if (refRangeArr.length === 2 && definedName.refersTo.startsWith('=')) {
                const refSheetName = refRangeArr[0].split('=')[1].replace(/'/g, '');
                const referredRange = definedName.refersTo.split('!')[1];
                if (refSheetName === activeSheet.name && referredRange === activeSheet.selectedRange) {
                    comboBoxInstance.value = definedName.name;
                    comboBoxInstance.dataBind();
                }
            }
        }
    }
    formulaBarScrollEdit() {
        const index = getRangeIndexes(this.parent.getActiveSheet().selectedRange);
        const viewportIndexes = getCellIndexes(this.parent.getActiveSheet().topLeftCell);
        if (index[0] < viewportIndexes[0]) {
            this.parent.goTo(this.parent.getActiveSheet().selectedRange);
            this.isGoto = true;
        }
        this.parent.notify(editOperation, { action: 'startEdit', refreshCurPos: false });
    }
    formulaBarClickHandler(e) {
        const target = e.target;
        const sheet = this.parent.getActiveSheet();
        const isSheetProtected = sheet.isProtected;
        const range = getCellIndexes(sheet.activeCell);
        const cell = getCell(range[0], range[1], sheet);
        const isCellLocked = isLocked(cell, getColumn(sheet, range[1]));
        if (target.classList.contains('e-drop-icon') && target.parentElement.classList.contains('e-formula-bar-panel')) {
            this.toggleFormulaBar(target);
        }
        else if (target.classList.contains('e-formula-bar')) {
            if (isReadOnly(cell, getColumn(sheet, range[1]), getRow(sheet, range[0]))) {
                this.parent.notify(readonlyAlert, null);
                return;
            }
            if ((!this.parent.isEdit && (!isSheetProtected || (isSheetProtected && !isCellLocked))) ||
                (this.parent.isEdit && isSheetProtected && !target.disabled)) {
                this.formulaBarScrollEdit();
            }
            else if (isSheetProtected && isCellLocked) {
                this.parent.notify(editAlert, null);
            }
        }
        else if (target.parentElement && target.parentElement.classList.contains('e-name-box')) {
            if (target.classList.contains('e-ddl-icon')) {
                const eventArgs = { action: 'getNames', names: [] };
                this.parent.notify(formulaOperation, eventArgs);
                if (this.comboBoxInstance.dataSource.length !== eventArgs.names.length ||
                    this.comboBoxInstance.value === this.comboBoxInstance.text) {
                    const searchText = this.comboBoxInstance.text;
                    this.comboBoxInstance.dataSource = eventArgs.names;
                    const definedName = eventArgs.names.find((name) => name.name === searchText);
                    this.comboBoxInstance.value = definedName ? definedName.refersTo : this.comboBoxInstance.value;
                    this.comboBoxInstance.dataBind();
                }
            }
            else {
                this.comboBoxInstance.element.classList.add('e-name-editing');
                this.comboBoxInstance.element.select();
            }
        }
        if (!isNullOrUndefined(target.offsetParent) && ((target.offsetParent.classList.contains('e-insert-function')) ||
            (target.classList.contains('e-insert-function')) || (this.parent.element.id + '_insert_function' === target.offsetParent.id)
            || (this.parent.element.id + '_insert_function' === target.id) ||
            target.parentElement.classList.contains('e-insert-function')
            || (this.parent.element.id + '_insert_function' === target.parentElement.id))) {
            this.renderInsertDlg();
        }
    }
    renderInsertDlg() {
        const sheet = this.parent.getActiveSheet();
        const activeCell = getCellIndexes(sheet.activeCell);
        if (sheet.isProtected) {
            if (isLocked(getCell(activeCell[0], activeCell[1], sheet), getColumn(sheet, activeCell[1])) && !this.parent.isEdit) {
                this.parent.notify(editAlert, null);
                return;
            }
        }
        const cell = getCell(activeCell[0], activeCell[1], sheet);
        if (isReadOnly(cell, getColumn(sheet, activeCell[1]), getRow(sheet, activeCell[0]))) {
            this.parent.notify(readonlyAlert, null);
            return;
        }
        const l10n = this.parent.serviceLocator.getService(locale);
        let isOpen = !this.parent.isEdit;
        const args = { action: 'getCurrentEditValue', editedValue: '' };
        if (!isOpen) {
            const eventArgs = { action: 'isFormulaEditing', isFormulaEdit: false };
            this.parent.notify(formulaOperation, eventArgs);
            isOpen = eventArgs.isFormulaEdit;
            this.parent.notify(editOperation, args);
        }
        if (isOpen || args.editedValue === '') {
            if (!this.parent.element.querySelector('.e-spreadsheet-function-dlg')) {
                if (args.editedValue === '') {
                    this.parent.notify(editOperation, { action: 'refreshEditor', value: '=' });
                }
                const formulaDescription = this.parent.createElement('div', { className: 'e-formula-description', id: this.parent.element.id + '_description_content' });
                const categoryContent = this.parent.createElement('div', { className: 'e-category-content', id: this.parent.element.id + '_category_content' });
                categoryContent.innerText = l10n.getConstant('PickACategory');
                const dropDownElement = this.parent.createElement('input', { className: 'e-formula-category', id: this.parent.element.id + '_formula_category' });
                const listViewElement = this.parent.createElement('div', { className: 'e-formula-list', id: this.parent.element.id + '_formula_list' });
                const descriptionContent = this.parent.createElement('div', { className: 'e-description-content' });
                descriptionContent.innerText = l10n.getConstant('Description');
                const headerContent = this.parent.createElement('div', { className: 'e-header-content' });
                headerContent.innerText = l10n.getConstant('InsertFunction');
                const categoryArgs = { action: 'getFormulaCategory', categoryCollection: [] };
                this.parent.notify(workbookFormulaOperation, categoryArgs);
                this.categoryCollection = categoryArgs.categoryCollection;
                let categoryPopupOpen;
                this.categoryList = new DropDownList({
                    dataSource: this.categoryCollection, cssClass: 'e-ss-formula-category', index: 0, width: '285px', popupHeight: '210px',
                    select: this.dropDownSelect.bind(this),
                    open: () => categoryPopupOpen = true,
                    close: () => categoryPopupOpen = false
                });
                const listArgs = { action: 'getLibraryFormulas', formulaCollection: [] };
                this.parent.notify(workbookFormulaOperation, listArgs);
                this.formulaCollection = listArgs.formulaCollection;
                this.formulaList = new ListView({
                    dataSource: this.formulaCollection.sort(),
                    actionComplete: this.updateFormulaList.bind(this),
                    select: this.listSelected.bind(this), width: '285px', height: '200px'
                });
                let isCancelled;
                this.dialog = this.parent.serviceLocator.getService(dialog);
                this.dialog.show({
                    header: headerContent.outerHTML,
                    content: categoryContent.outerHTML + dropDownElement.outerHTML + listViewElement.outerHTML +
                        descriptionContent.outerHTML + formulaDescription.outerHTML,
                    width: '320px', height: '485px', cssClass: 'e-spreadsheet-function-dlg',
                    showCloseIcon: true, isModal: true,
                    beforeOpen: (args) => {
                        const dlgArgs = {
                            dialogName: 'InsertFunctionDialog', element: args.element, target: args.target, cancel: args.cancel
                        };
                        this.parent.trigger('dialogBeforeOpen', dlgArgs);
                        if (dlgArgs.cancel) {
                            this.dialog.dialogInstance.setProperties({ beforeClose: undefined }, true);
                            isCancelled = args.cancel = true;
                        }
                        else {
                            focus(this.parent.element);
                        }
                    },
                    open: this.dialogOpen.bind(this), beforeClose: this.dialogBeforeClose.bind(this), close: this.dialogClose.bind(this),
                    buttons: [
                        {
                            click: (event) => {
                                if (event && event.keyCode === 13 && !categoryPopupOpen) {
                                    return;
                                }
                                this.selectFormula();
                            },
                            buttonModel: { content: l10n.getConstant('Ok'), isPrimary: true }
                        }
                    ]
                });
                if (isCancelled) {
                    this.categoryList = this.formulaList = null;
                }
                else {
                    this.categoryList.appendTo('#' + this.parent.element.id + '_formula_category');
                    this.formulaList.appendTo('#' + this.parent.element.id + '_formula_list');
                    EventHandler.add(this.formulaList.element, 'dblclick', this.formulaClickHandler, this);
                }
            }
        }
    }
    toggleFormulaBar(target) {
        const parent = target.parentElement;
        const l10n = this.parent.serviceLocator.getService(locale);
        if (parent.classList.contains('e-expanded')) {
            parent.classList.remove('e-expanded');
            document.getElementById(this.parent.element.id + '_formula_input').rows = 1;
            target.title = l10n.getConstant('ExpandFormulaBar');
            target.setAttribute('aria-label', l10n.getConstant('CollapseFormulaBar'));
        }
        else {
            parent.classList.add('e-expanded');
            document.getElementById(this.parent.element.id + '_formula_input').rows = 3;
            target.title = l10n.getConstant('CollapseFormulaBar');
            target.setAttribute('aria-label', l10n.getConstant('ExpandFormulaBar'));
        }
        this.parent.setPanelSize();
    }
    dialogOpen() {
        getUpdateUsingRaf(() => {
            const okBtn = this.dialog.dialogInstance.element.querySelector('.e-footer-content .e-primary');
            const l10n = this.parent.serviceLocator.getService(locale);
            okBtn.setAttribute('aria-label', l10n.getConstant('InsertFunction') + ' ' + l10n.getConstant('Ok'));
            if (this.categoryList) {
                focus(this.categoryList.element);
            }
        });
    }
    dialogClose() {
        const args = { action: 'getCurrentEditValue', editedValue: '' };
        this.parent.notify(editOperation, args);
        if (args.editedValue.toString().trim() === '=') {
            this.parent.notify(editOperation, { action: 'refreshEditor', value: '' });
        }
    }
    dialogBeforeClose() {
        EventHandler.remove(this.formulaList.element, 'dblclick', this.formulaClickHandler);
        const dialogContentEle = document.getElementsByClassName('e-spreadsheet-function-dlg')[0].
            querySelector('.e-dlg-content');
        dialogContentEle.parentNode.removeChild(dialogContentEle);
        this.categoryList.destroy();
        this.categoryList = null;
        this.formulaList.destroy();
        this.formulaList = null;
    }
    selectFormula() {
        const formulaText = this.formulaList.getSelectedItems().text;
        const sheet = getSheet(this.parent, this.parent.activeSheetIndex);
        if (this.parent.isEdit) {
            this.parent.notify(editOperation, {
                action: 'refreshEditor', value: formulaText + '(', refreshFormulaBar: true,
                refreshEditorElem: true, isAppend: true
            });
        }
        else {
            this.parent.notify(editOperation, { action: 'startEdit', value: '=' + formulaText + '(', address: sheet.activeCell });
            this.parent.notify(formulaBarOperation, { action: 'refreshFormulabar', value: '=' + formulaText + '(' });
        }
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.dialog.dialogInstance.storeActiveElement = document.getElementById(this.parent.element.id + '_edit');
        this.dialog.hide();
    }
    listSelected(args) {
        this.updateFormulaDescription();
        if (args.isInteracted && args.item) {
            args.item.focus();
        }
    }
    updateFormulaList() {
        this.activeListFormula();
        this.updateFormulaDescription();
    }
    dropDownSelect(args) {
        this.formulaCollection = [];
        const listArgs = {
            action: 'getLibraryFormulas',
            formulaCollection: []
        };
        if (args.item.textContent === 'All') {
            this.parent.notify(workbookFormulaOperation, listArgs);
            this.formulaCollection = listArgs.formulaCollection;
        }
        else {
            const category = args.item.textContent;
            const selectArgs = {
                action: 'dropDownSelectFormulas',
                formulaCollection: [],
                selectCategory: category
            };
            this.parent.notify(workbookFormulaOperation, selectArgs);
            this.formulaCollection = selectArgs.formulaCollection;
        }
        this.formulaList.dataSource = this.formulaCollection.sort();
    }
    activeListFormula() {
        const acListEle = document.getElementById(this.parent.element.id + '_formula_list');
        const firstElement = acListEle.children[0].children[0].firstElementChild;
        this.formulaList.selectItem(firstElement);
    }
    updateFormulaDescription() {
        let selectedFormula = this.formulaList.getSelectedItems().text;
        const descriptionArgs = {
            action: 'getFormulaDescription',
            description: '',
            selectedList: selectedFormula,
            isCustom: false
        };
        this.parent.notify(workbookFormulaOperation, descriptionArgs);
        const okBtn = this.dialog.dialogInstance.element.querySelector('.e-footer-content .e-primary');
        if (okBtn.hasAttribute('aria-label')) {
            okBtn.removeAttribute('aria-label');
        }
        const descriptionArea = document.getElementById(this.parent.element.id + '_description_content');
        selectedFormula = (selectedFormula === 'AND') ? 'CalculateAND' : (selectedFormula === 'OR') ? 'CalculateOR' : selectedFormula;
        descriptionArea.textContent = descriptionArgs.isCustom ? descriptionArgs.description :
            this.parent.serviceLocator.getService(locale).getConstant(selectedFormula);
    }
    formulaClickHandler(args) {
        const trgtElem = args.target;
        const sheet = getSheet(this.parent, this.parent.activeSheetIndex);
        if (trgtElem.offsetParent.classList.contains('e-text-content') || trgtElem.classList.contains('e-list-item')) {
            if (this.parent.isEdit) {
                this.parent.notify(editOperation, {
                    action: 'refreshEditor', value: trgtElem.innerText + '(', refreshFormulaBar: true,
                    refreshEditorElem: true, isAppend: true
                });
            }
            else {
                this.parent.notify(editOperation, { action: 'startEdit', value: '=' + trgtElem.innerText + '(', address: sheet.activeCell });
                this.parent.notify(formulaBarOperation, { action: 'refreshFormulabar', value: '=' + trgtElem.innerText + '(' });
            }
            this.dialog.hide();
        }
    }
    addEventListener() {
        this.parent.on(formulaBar, this.createFormulaBar, this);
        this.parent.on(click, this.formulaBarClickHandler, this);
        this.parent.on(keyDown, this.keyDownHandler, this);
        this.parent.on(renderInsertDlg, this.renderInsertDlg, this);
        this.parent.on(keyUp, this.keyUpHandler, this);
        this.parent.on(selectionComplete, this.formulaBarUpdateHandler, this);
        this.parent.on(mouseUpAfterSelection, this.updateValueAfterMouseUp, this);
        this.parent.on(formulaBarOperation, this.editOperationHandler, this);
        this.parent.on(enableFormulaInput, this.disabletextarea, this);
        this.parent.on(isFormulaBarEdit, this.isFormulaBarEdit, this);
    }
    destroy() {
        this.removeEventListener();
        if (this.comboBoxInstance) {
            this.comboBoxInstance.destroy();
        }
        this.comboBoxInstance = null;
        this.categoryCollection = null;
        this.formulaCollection = null;
        this.dialog = null;
        this.isGoto = null;
        if (this.insertFnRipple) {
            this.insertFnRipple();
        }
        this.insertFnRipple = null;
        const formulaPanel = this.parent.element.querySelector('.e-formula-bar-panel');
        if (formulaPanel) {
            removeAllChildren(formulaPanel);
            detach(formulaPanel);
        }
        this.parent = null;
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(formulaBar, this.createFormulaBar);
            this.parent.off(click, this.formulaBarClickHandler);
            this.parent.off(renderInsertDlg, this.renderInsertDlg);
            this.parent.off(keyDown, this.keyDownHandler);
            this.parent.off(keyUp, this.keyUpHandler);
            this.parent.off(selectionComplete, this.formulaBarUpdateHandler);
            this.parent.off(mouseUpAfterSelection, this.updateValueAfterMouseUp);
            this.parent.off(formulaBarOperation, this.editOperationHandler);
            this.parent.off(enableFormulaInput, this.disabletextarea);
            this.parent.off(isFormulaBarEdit, this.isFormulaBarEdit);
        }
    }
    editOperationHandler(args) {
        switch (args.action) {
            case 'refreshFormulabar':
                if (args.cell) {
                    this.getFormulaBar().value = this.getFormulaBarValue(args.cell);
                }
                else {
                    this.getFormulaBar().value = isUndefined$1(args.value) ? '' : args.value;
                }
                break;
            case 'setNameBoxValue':
                this.updateNameBoxValue(args.definedName, args.isRemove);
                break;
            case 'getElement':
                args.element = this.getFormulaBar();
                break;
        }
    }
    isFormulaBarEdit(args) {
        const edit = this.parent.isEdit;
        if (edit && this.isGoto) {
            args.isEdit = true;
        }
        else {
            args.isEdit = false;
        }
    }
    getFormulaBar() {
        return select('#' + this.parent.element.id + '_formula_input', this.parent.element);
    }
}

/**
 * @hidden
 * The `Formula` module is used to handle the formulas and its functionalities in Spreadsheet.
 */
class Formula {
    /**
     * Constructor for formula module in Spreadsheet.
     *
     * @private
     * @param {Spreadsheet} parent - Constructor for formula module in Spreadsheet.
     */
    constructor(parent) {
        this.isFormulaBar = false;
        this.isFormula = false;
        this.isPopupOpened = false;
        this.isPreventClose = false;
        this.isSubFormula = false;
        this.parent = parent;
        this.addEventListener();
        //Spreadsheet.Inject(WorkbookFormula);
    }
    /**
     * Get the module name.
     *
     * @returns {string} - Get the module name.
     * @private
     */
    getModuleName() {
        return 'formula';
    }
    /**
     * To destroy the formula module.
     *
     * @returns {void} - To destroy the formula module.
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        if (this.autocompleteInstance) {
            this.autocompleteInstance.destroy();
            if (this.autocompleteInstance.element) {
                this.autocompleteInstance.element.remove();
                this.autocompleteInstance.element = null;
            }
        }
        this.autocompleteInstance = null;
        if (this.acInputElement) {
            this.acInputElement.remove();
            this.acInputElement = null;
        }
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(formulaOperation, this.performFormulaOperation, this);
        this.parent.on(keyUp, this.keyUpHandler, this);
        this.parent.on(keyDown, this.keyDownHandler, this);
        this.parent.on(click, this.formulaClick, this);
        this.parent.on(refreshFormulaDatasource, this.refreshFormulaDatasource, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(formulaOperation, this.performFormulaOperation);
            this.parent.off(keyUp, this.keyUpHandler);
            this.parent.off(keyDown, this.keyDownHandler);
            this.parent.off(click, this.formulaClick);
            this.parent.off(refreshFormulaDatasource, this.refreshFormulaDatasource);
        }
    }
    performFormulaOperation(args) {
        const action = args.action;
        const l10n = this.parent.serviceLocator.getService(locale);
        switch (action) {
            case 'renderAutoComplete':
                this.renderAutoComplete();
                break;
            case 'endEdit':
                this.endEdit();
                break;
            case 'addDefinedName':
                args.isAdded = this.addDefinedName(args.definedName);
                break;
            case 'getNames':
                if (!args.sheetName) {
                    args.sheetName = getSheetName(this.parent);
                }
                args.names = this.getNames(args.sheetName);
                break;
            case 'getNameFromRange':
                args.definedName = this.getNameFromRange(args.range);
                break;
            case 'isFormulaEditing':
                args.isFormulaEdit = this.isFormula;
                break;
            case 'isCircularReference': {
                const dialogInst = this.parent.serviceLocator.getService(dialog);
                const dialogContent = l10n.getConstant('CircularReference');
                const triggerEvent = (dlgArgs) => {
                    this.parent.trigger('dialogBeforeOpen', dlgArgs);
                    if (dlgArgs.content !== dialogContent) {
                        dialogInst.dialogInstance.content = dlgArgs.content;
                        dialogInst.dialogInstance.dataBind();
                    }
                };
                const dlgInst = dialogInst.dialogInstance;
                if (dlgInst && dlgInst.visible && dlgInst.element.classList.contains('e-circularref-dlg')) {
                    triggerEvent({ dialogName: 'CircularReferenceDialog', element: dlgInst.element, target: this.parent.element, cancel: false,
                        cellAddress: args.address, content: dialogContent });
                }
                else {
                    const cellAddress = args.address;
                    dialogInst.show({
                        height: 180, width: 400, isModal: true, showCloseIcon: true, cssClass: 'e-circularref-dlg', content: dialogContent,
                        beforeOpen: (args) => {
                            const dlgArgs = { dialogName: 'CircularReferenceDialog', element: args.element,
                                target: args.target, cancel: args.cancel, cellAddress, content: dialogContent };
                            triggerEvent(dlgArgs);
                            args.cancel = dlgArgs.cancel;
                        }
                    });
                }
                args.argValue = '0';
                break;
            }
        }
    }
    renderAutoComplete() {
        if (!select('#' + this.parent.element.id + '_ac', this.parent.element)) {
            const acElem = this.parent.createElement('input', { id: this.parent.element.id + '_ac', className: 'e-ss-ac' });
            this.parent.element.appendChild(acElem);
            const eventArgs = {
                action: 'getLibraryFormulas',
                formulaCollection: []
            };
            this.parent.notify(workbookFormulaOperation, eventArgs);
            const autoCompleteOptions = {
                dataSource: eventArgs.formulaCollection,
                cssClass: 'e-ss-atc',
                popupWidth: '130px',
                allowFiltering: true,
                filterType: 'StartsWith',
                sortOrder: 'Ascending',
                open: this.onSuggestionOpen.bind(this),
                close: this.onSuggestionClose.bind(this),
                select: this.onSelect.bind(this),
                actionComplete: this.onSuggestionComplete.bind(this)
            };
            this.autocompleteInstance = new AutoComplete(autoCompleteOptions, acElem);
            this.autocompleteInstance.createElement = this.parent.createElement;
            this.acInputElement = acElem;
        }
    }
    onSuggestionOpen(e) {
        this.isPopupOpened = true;
        e.popup.relateTo = this.getRelateToElem();
        e.popup.element.firstChild.style.maxHeight = '180px';
        new Promise((resolve) => {
            setTimeout(() => { resolve(); }, 100);
        }).then(() => {
            this.triggerKeyDownEvent(keyCodes.DOWN);
        });
    }
    onSuggestionClose(e) {
        if (this.isPreventClose) {
            e.cancel = true;
        }
        else {
            this.isPopupOpened = false;
        }
    }
    onSelect(e) {
        let updatedFormulaValue = '=' + e.itemData.value + '(';
        if (this.isSubFormula) {
            const editValue = this.getEditingValue();
            let parseIndex = editValue.lastIndexOf(this.parent.listSeparator);
            if (parseIndex > -1) {
                updatedFormulaValue = editValue.slice(0, parseIndex + 1);
            }
            else {
                parseIndex = editValue.lastIndexOf('(');
                if (parseIndex > -1) {
                    updatedFormulaValue = editValue.slice(0, parseIndex + 1);
                }
            }
            updatedFormulaValue += e.itemData.value + '(';
        }
        this.parent.notify(editOperation, {
            action: 'refreshEditor', value: updatedFormulaValue,
            refreshFormulaBar: true, refreshEditorElem: true, refreshCurPos: !this.isFormulaBar
        });
        if (this.isPopupOpened) {
            this.hidePopUp();
            const suggPopupElem = select('#' + this.parent.element.id + '_ac_popup');
            if (suggPopupElem) {
                detach(suggPopupElem);
            }
            this.isPopupOpened = false;
        }
    }
    onSuggestionComplete(args) {
        this.isPreventClose = args.result.length > 0;
        if (!this.isPreventClose) {
            args.cancel = true;
            this.hidePopUp();
        }
    }
    refreshFormulaDatasource() {
        const eventArgs = {
            action: 'getLibraryFormulas',
            formulaCollection: []
        };
        this.parent.notify(workbookFormulaOperation, eventArgs);
        if (this.autocompleteInstance) {
            this.autocompleteInstance.dataSource = eventArgs.formulaCollection;
        }
    }
    keyUpHandler(e) {
        if (this.parent.isEdit) {
            let editValue = this.getEditingValue();
            this.isFormula = checkIsFormula(editValue);
            if (this.isFormula || this.isPopupOpened) {
                if (e.keyCode !== keyCodes.TAB && this.isFormula) {
                    editValue = this.getSuggestionKeyFromFormula(editValue);
                }
                this.refreshFormulaSuggestion(e, editValue);
            }
        }
        else if (this.isPopupOpened) {
            this.hidePopUp();
        }
    }
    keyDownHandler(e) {
        const keyCode = e.keyCode;
        if (this.isFormula) {
            if (this.isPopupOpened) {
                switch (keyCode) {
                    case keyCodes.UP:
                    case keyCodes.DOWN:
                        e.preventDefault();
                        this.triggerKeyDownEvent(keyCode);
                        break;
                    case keyCodes.TAB:
                        e.preventDefault();
                        this.triggerKeyDownEvent(keyCodes.ENTER);
                        break;
                }
            }
        }
        else {
            const trgtElem = e.target;
            if (trgtElem.id === this.parent.element.id + '_name_box') {
                switch (keyCode) {
                    case keyCodes.ENTER:
                        if (!document.querySelector('.e-name-box.e-popup-open')) {
                            this.addDefinedName({ name: trgtElem.value });
                            focus(this.parent.element);
                        }
                        break;
                    case keyCodes.ESC:
                        focus(this.parent.element);
                        break;
                }
            }
        }
    }
    formulaClick(e) {
        if (this.parent.isEdit) {
            const trgtElem = e.target;
            this.isFormulaBar = trgtElem.classList.contains('e-formula-bar');
        }
    }
    refreshFormulaSuggestion(e, formula) {
        if (formula.length > 0) {
            const autoCompleteElem = this.autocompleteInstance.element;
            const keyCode = e.keyCode;
            const isSuggestionAlreadyOpened = this.isPopupOpened;
            if (!isNavigationKey(keyCode)) {
                autoCompleteElem.value = formula;
                autoCompleteElem.dispatchEvent(new Event('input'));
                autoCompleteElem.dispatchEvent(new Event('keyup'));
                if (isSuggestionAlreadyOpened) {
                    this.triggerKeyDownEvent(keyCodes.DOWN);
                }
            }
        }
        else {
            if (this.isPopupOpened) {
                this.isPreventClose = false;
                this.hidePopUp();
            }
        }
    }
    endEdit() {
        this.isSubFormula = false;
        this.isPreventClose = false;
        this.isFormula = false;
        this.isFormulaBar = false;
        if (this.isPopupOpened) {
            this.hidePopUp();
            const suggPopupElem = select('#' + this.parent.element.id + '_ac_popup');
            if (suggPopupElem) {
                detach(suggPopupElem);
            }
            this.isPopupOpened = false;
        }
    }
    hidePopUp() {
        this.autocompleteInstance.hidePopup();
    }
    getSuggestionKeyFromFormula(formula) {
        let suggestValue = '';
        formula = formula.substr(1); //remove = char.
        if (formula) {
            const bracketIndex = formula.lastIndexOf('(');
            formula = formula.substr(bracketIndex + 1);
            const fSplit = formula.split(this.parent.listSeparator);
            if (fSplit.length === 1) {
                suggestValue = fSplit[0];
                this.isSubFormula = bracketIndex > -1;
            }
            else {
                suggestValue = fSplit[fSplit.length - 1];
                this.isSubFormula = true;
            }
            const isAlphaNumeric = suggestValue.match(/\w/);
            if (!isAlphaNumeric || (isAlphaNumeric && isAlphaNumeric.index !== 0)) {
                suggestValue = '';
            }
        }
        return suggestValue;
    }
    getRelateToElem() {
        const eventArgs = { action: 'getElement' };
        if (this.isFormulaBar) {
            this.parent.notify(formulaBarOperation, eventArgs);
        }
        else {
            this.parent.notify(editOperation, eventArgs);
        }
        return eventArgs.element;
    }
    getEditingValue() {
        const eventArgs = { action: 'getCurrentEditValue', editedValue: '' };
        this.parent.notify(editOperation, eventArgs);
        return eventArgs.editedValue;
    }
    triggerKeyDownEvent(keyCode) {
        const autoCompleteElem = this.autocompleteInstance.element;
        autoCompleteElem.dispatchEvent(new Event('input'));
        const eventArg = new Event('keydown');
        eventArg['keyCode'] = keyCode;
        eventArg['which'] = keyCode;
        eventArg['altKey'] = false;
        eventArg['shiftKey'] = false;
        eventArg['ctrlKey'] = false;
        /* eslint-enable @typescript-eslint/dot-notation */
        autoCompleteElem.dispatchEvent(eventArg);
    }
    getNames(sheetName) {
        const names = this.parent.definedNames.filter((name) => name.scope === 'Workbook' || name.scope === '' || name.scope === sheetName);
        return names;
    }
    getNameFromRange(range) {
        const singleRange = range.slice(0, range.indexOf(':'));
        const sRange = range.substring(range.lastIndexOf('!') + 1).split(':');
        const isSingleCell = sRange.length > 1 && sRange[0] === sRange[1];
        let sheetName;
        let referRange;
        const name = this.parent.definedNames.filter((name) => {
            sheetName = name.refersTo.substring(0, name.refersTo.lastIndexOf('!'));
            referRange = name.refersTo.substring(name.refersTo.lastIndexOf('!') + 1);
            if (sheetName.includes('\'') && sheetName.match(/^='.*'$/)) {
                sheetName = '=' + sheetName.slice(2, -1);
            }
            const referValue = sheetName + '!' + referRange.split('$').join('');
            if (isSingleCell && referValue === '=' + singleRange) {
                return true;
            }
            return referValue === '=' + range;
        });
        return name && name[0];
    }
    addDefinedName(definedName) {
        const name = definedName.name;
        let isAdded = false;
        if (name && isCellReference(name.toUpperCase())) {
            this.parent.goTo(name);
            return isAdded;
        }
        if (!definedName.refersTo) {
            const sheet = getSheet(this.parent, this.parent.activeSheetIndex);
            let sheetName = getSheetName(this.parent);
            sheetName = sheetName.indexOf(' ') !== -1 ? '\'' + sheetName + '\'' : sheetName;
            let selectRange = sheet.selectedRange;
            if (!isNullOrUndefined(selectRange)) {
                const colIndex = selectRange.indexOf(':');
                let left = selectRange.substr(0, colIndex);
                let right = selectRange.substr(colIndex + 1, selectRange.length);
                if (parseInt(right.replace(/\D/g, ''), 10) === sheet.rowCount && parseInt(left.replace(/\D/g, ''), 10) === 1) {
                    right = right.replace(/[0-9]/g, '');
                    left = left.replace(/[0-9]/g, '');
                    selectRange = '$' + left + ':$' + right;
                }
                else if (getCellIndexes(right)[1] === sheet.colCount - 1 && getCellIndexes(left)[1] === 0) {
                    right = right.replace(/\D/g, '');
                    left = left.replace(/\D/g, '');
                    selectRange = '$' + left + ':$' + right;
                }
                else {
                    selectRange = left === right ? left : selectRange;
                }
            }
            definedName.refersTo = sheetName + '!' + selectRange;
            definedName.scope = 'Workbook';
        }
        if (name.length > 0 && (/^([a-zA-Z_0-9.]){0,255}$/.test(name))) {
            const eventArgs = {
                action: 'addDefinedName', definedName: definedName, isAdded: false
            };
            this.parent.notify(workbookFormulaOperation, eventArgs);
            isAdded = eventArgs.isAdded;
            if (!eventArgs.isAdded) {
                this.parent.serviceLocator.getService(dialog).show({
                    content: this.parent.serviceLocator.getService(locale).getConstant('DefineNameExists'),
                    width: '300',
                    beforeOpen: (args) => {
                        const dlgArgs = {
                            dialogName: 'DefineNameExistsDialog',
                            element: args.element, target: args.target, cancel: args.cancel
                        };
                        this.parent.trigger('dialogBeforeOpen', dlgArgs);
                        if (dlgArgs.cancel) {
                            args.cancel = true;
                        }
                    }
                });
            }
        }
        else {
            this.parent.serviceLocator.getService(dialog).show({
                content: this.parent.serviceLocator.getService(locale).getConstant('DefineNameInValid'),
                width: '300',
                beforeOpen: (args) => {
                    const dlgArgs = {
                        dialogName: 'DefineNameInValidDialog',
                        element: args.element, target: args.target, cancel: args.cancel
                    };
                    this.parent.trigger('dialogBeforeOpen', dlgArgs);
                    if (dlgArgs.cancel) {
                        args.cancel = true;
                    }
                }
            });
        }
        return isAdded;
    }
}

/**
 * Represents SheetTabs for Spreadsheet.
 */
class SheetTabs {
    constructor(parent) {
        this.aggregateContent = '';
        this.selaggregateCnt = 'Sum';
        this.parent = parent;
        this.addEventListener();
    }
    getModuleName() {
        return 'sheetTabs';
    }
    createSheetTabs() {
        if (!this.parent.showSheetTabs && this.tabInstance) {
            this.destroy();
            return;
        }
        const l10n = this.parent.serviceLocator.getService(locale);
        const panel = this.parent.createElement('div', {
            className: 'e-sheet-tab-panel', id: this.parent.element.id + '_sheet_tab_panel'
        });
        const addBtn = this.parent.createElement('button', {
            className: 'e-add-sheet-tab e-btn e-css e-flat e-icon-btn' + (this.parent.allowInsert ? '' : ' e-disabled'),
            attrs: { 'title': l10n.getConstant('AddSheet'), 'type': 'button' }
        });
        addBtn.appendChild(this.parent.createElement('span', { className: 'e-btn-icon e-icons e-add-icon' }));
        addBtn.addEventListener('click', this.addSheetTab.bind(this));
        addBtn.disabled = !this.parent.allowInsert;
        panel.appendChild(addBtn);
        this.addBtnRipple = rippleEffect(panel, { selector: '.e-add-sheet-tab' });
        const ddb = this.parent.createElement('button', { attrs: { 'title': l10n.getConstant('ListAllSheets'), 'type': 'button' } });
        panel.appendChild(ddb);
        this.parent.element.appendChild(panel);
        const items = this.getSheetTabItems();
        this.dropDownInstance = new DropDownButton({
            iconCss: 'e-icons',
            items: items.ddbItems,
            createPopupOnClick: true,
            beforeItemRender: (args) => {
                const sheet = this.parent.sheets[this.dropDownInstance.items.indexOf(args.item)];
                if (sheet.state === 'Hidden') {
                    args.element.classList.add('e-hide');
                }
                else if (sheet.state === 'VeryHidden') {
                    args.element.style.display = 'none';
                }
            },
            select: (args) => this.updateSheetTab({ idx: this.dropDownInstance.items.indexOf(args.item) }),
            beforeOpen: (args) => this.beforeOpenHandler(this.dropDownInstance, args.element, l10n.getConstant('ListAllSheets')),
            open: (args) => this.openHandler(this.dropDownInstance, args.element, 'left'),
            cssClass: 'e-sheets-list e-flat e-caret-hide',
            close: () => this.focusTab(this.tabInstance.element)
        });
        this.dropDownInstance.createElement = this.parent.createElement;
        this.dropDownInstance.appendTo(ddb);
        const sheetTab = this.parent.createElement('div', { className: 'e-sheet-tab' });
        let cancelSelect;
        this.tabInstance = new Tab({
            selectedItem: this.parent.activeSheetIndex,
            overflowMode: 'Scrollable',
            items: items.tabItems,
            scrollStep: 250,
            selecting: (args) => {
                if (args.selectingIndex === args.selectedIndex) {
                    return;
                }
                if (cancelSelect) {
                    cancelSelect = false;
                }
                else {
                    const beginEventArgs = { currentSheetIndex: args.selectingIndex, previousSheetIndex: args.selectedIndex, cancel: false };
                    this.parent.notify(beginAction, { eventArgs: beginEventArgs, action: 'gotoSheet' });
                    cancelSelect = beginEventArgs.cancel;
                }
            },
            selected: (args) => {
                if (!args.isInteracted) {
                    args.preventFocus = true;
                }
                this.goToSheet(args, cancelSelect, true);
            },
            created: () => {
                const tBarItems = this.tabInstance.element.querySelector('.e-toolbar-items');
                tBarItems.classList.add('e-sheet-tabs-items');
                EventHandler.add(tBarItems, 'dblclick', this.renameSheetTab, this);
            }
        });
        panel.appendChild(sheetTab);
        this.tabInstance.createElement = this.parent.createElement;
        this.tabInstance.appendTo(sheetTab);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        EventHandler.remove(this.tabInstance.element, 'keydown', this.tabInstance.spaceKeyDown);
        const sheetCount = items.tabItems.length;
        let sheet;
        for (let i = 0; i < sheetCount; i++) {
            sheet = getSheet(this.parent, i);
            const arg = { action: 'addSheet', sheetName: 'Sheet' + sheet.id, sheetId: sheet.id, visibleName: sheet.name };
            this.parent.notify(workbookFormulaOperation, arg);
        }
        this.parent.notify(workbookFormulaOperation, { action: 'initiateDefinedNames' });
        this.parent.notify(protectSheet, null);
    }
    goToSheet(args, cancelSelect, triggerEvent) {
        if (args.selectedIndex === args.previousIndex) {
            return;
        }
        if (cancelSelect) {
            this.tabInstance.selectedItem = args.previousIndex;
            this.tabInstance.dataBind();
            focus(this.parent.element);
            return;
        }
        this.parent.notify(removeDesignChart, {});
        if (this.parent.isEdit) {
            const selection = window.getSelection();
            const editArgs = { action: 'getCurrentEditValue', editedValue: '' };
            this.parent.notify(editOperation, editArgs);
            let formula = editArgs.editedValue ? checkIsFormula(editArgs.editedValue, true) : false;
            if (!formula && selection && selection.focusNode && selection.focusNode.classList &&
                selection.focusNode.classList.contains('e-formula-bar-panel')) {
                formula = checkIsFormula(this.parent.element.querySelector('.e-formula-bar').value, true);
            }
            if (!formula) {
                this.parent.endEdit();
            }
        }
        this.parent.activeSheetIndex = args.selectedIndex;
        this.parent.dataBind();
        this.updateDropDownItems(args.selectedIndex, args.previousIndex);
        const eventArgs = {
            action: 'registerGridInCalc',
            sheetID: (args.selectedIndex + 1).toString()
        };
        this.parent.notify(workbookFormulaOperation, eventArgs);
        if (triggerEvent) {
            this.parent.notify(completeAction, {
                eventArgs: { previousSheetIndex: args.previousIndex, currentSheetIndex: args.selectedIndex }, action: 'gotoSheet'
            });
            getUpdateUsingRaf(() => focus(this.parent.element));
        }
    }
    updateDropDownItems(curIdx, prevIdx) {
        if (prevIdx > -1) {
            this.dropDownInstance.items[prevIdx].iconCss = '';
        }
        this.dropDownInstance.items[curIdx].iconCss = 'e-selected-icon e-icons';
        this.dropDownInstance.setProperties({ 'items': this.dropDownInstance.items }, true);
    }
    beforeOpenHandler(instance, element, localeText) {
        const viewportHeight = this.parent.viewport.height;
        const actualHeight = (parseInt(getComputedStyle(element.firstElementChild).height, 10) *
            instance.items.length) + (parseInt(getComputedStyle(element).paddingTop, 10) * 2);
        if (actualHeight > viewportHeight) {
            element.style.height = `${viewportHeight}px`;
            element.style.overflowY = 'auto';
        }
        element.parentElement.style.visibility = 'hidden';
        if (localeText) {
            element.setAttribute('aria-label', localeText);
        }
    }
    openHandler(instance, element, positionX) {
        const wrapper = element.parentElement;
        let height;
        const collide = isCollide(wrapper);
        if (collide.indexOf('bottom') === -1) {
            height = element.style.overflowY === 'auto' ? this.parent.viewport.height : wrapper.getBoundingClientRect().height;
            const offset = calculatePosition(instance.element, positionX, 'top');
            if (positionX === 'right') {
                offset.left -= wrapper.getBoundingClientRect().width;
            }
            wrapper.style.left = `${offset.left}px`;
            wrapper.style.top = `${offset.top - height}px`;
        }
        wrapper.style.visibility = '';
        focus(element);
    }
    getSheetTabItems() {
        const tabItems = [];
        const ddbItems = [];
        let sheetName;
        this.parent.sheets.forEach((sheet, index) => {
            sheetName = getSheetName(this.parent, index).replace(/</g, '&lt;').replace(/>/g, '&gt;');
            tabItems.push({ header: { 'text': sheetName }, visible: sheet.state === 'Visible' });
            ddbItems.push({ text: sheetName, iconCss: index === this.parent.activeSheetIndex ? 'e-selected-icon e-icons' : '' });
        });
        return { tabItems: tabItems, ddbItems: ddbItems };
    }
    refreshSheetTab() {
        const items = this.getSheetTabItems();
        this.dropDownInstance.items = items.ddbItems;
        this.dropDownInstance.setProperties({ 'items': this.dropDownInstance.items }, true);
        this.tabInstance.items = items.tabItems;
        this.tabInstance.selectedItem = this.parent.activeSheetIndex;
        this.tabInstance.dataBind();
    }
    addSheetTab() {
        this.parent.notify(insertModel, { model: this.parent, start: this.parent.activeSheetIndex + 1, end: this.parent.activeSheetIndex + 1, modelType: 'Sheet', isAction: true, activeSheetIndex: this.parent.activeSheetIndex + 1 });
    }
    insertSheetTab(args) {
        this.parent.notify(removeDesignChart, {});
        if (!args.preventUpdate || args.startIdx === this.tabInstance.selectedItem) {
            this.dropDownInstance.items[this.tabInstance.selectedItem].iconCss = '';
        }
        for (let i = args.startIdx; i <= args.endIdx; i++) {
            const sheetName = this.parent.sheets[i].name.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            this.dropDownInstance.items.splice(i, 0, { text: sheetName });
            this.tabInstance.addTab([{ header: { text: sheetName }, content: '' }], i);
        }
        if (!args.preventUpdate || args.startIdx === this.tabInstance.selectedItem) {
            this.dropDownInstance.items[args.startIdx].iconCss = 'e-selected-icon e-icons';
        }
        this.dropDownInstance.setProperties({ 'items': this.dropDownInstance.items }, true);
        if (args.preventUpdate) {
            if (args.startIdx !== this.tabInstance.selectedItem) {
                this.refreshSheetTab();
            }
            else {
                this.parent.notify(protectSheet, null);
            }
        }
        else {
            this.updateSheetTab({ idx: args.startIdx, preventDataBind: true });
        }
    }
    updateSheetTab(args) {
        if (args.name === 'activeSheetChanged') {
            args.idx = this.parent.skipHiddenSheets(args.idx);
        }
        else {
            if (this.parent.sheets[args.idx].state === 'Hidden') {
                if (this.parent.isProtected) {
                    return;
                }
                this.showSheet({ sheetIndex: args.idx, triggerEvent: true });
            }
        }
        this.tabInstance.selectedItem = args.idx;
        if (!args.preventDataBind) {
            this.tabInstance.dataBind();
        }
        this.parent.notify(protectSheet, null);
    }
    showSheet(args) {
        this.parent.setSheetPropertyOnMute(this.parent.sheets[args.sheetIndex], 'state', 'Visible');
        this.tabInstance.hideTab(args.sheetIndex, false);
        if (args.triggerEvent) {
            this.parent.notify(completeAction, { action: 'showSheet', eventArgs: { sheetIndex: args.sheetIndex } });
        }
    }
    switchSheetTab(args) {
        const target = closest(args.event.target, '.e-toolbar-item');
        if (!target) {
            return;
        }
        const name = target.querySelector('.e-tab-text').textContent;
        const disableItems = [];
        const id = `${this.parent.element.id}_cmenu`;
        for (let i = 0, len = this.parent.sheets.length; i < len; i++) {
            if (this.parent.sheets[i].name === name) {
                if (this.parent.activeSheetIndex !== i) {
                    this.updateSheetTab({ idx: i });
                }
                break;
            }
        }
        if (args.element.classList.contains('e-contextmenu') && args.items[0] &&
            args.items[0].id === `${this.parent.element.id}_cmenu_insert_sheet`) {
            if (this.skipHiddenSheets() === 1) {
                //let id: string = `${this.parent.element.id}_cmenu`;
                //this.parent.enableFileMenuItems([`${id}_hide_sheet`, `${id}_delete_sheet`], false, true);
                disableItems.push(`${id}_hide_sheet`, `${id}_delete_sheet`);
            }
            if (!this.parent.allowInsert || this.parent.isProtected) {
                disableItems.push(`${id}_insert_sheet`);
            }
            if (!this.parent.allowDelete && disableItems.indexOf(`${id}_delete_sheet`) > -1) {
                disableItems.push(`${id}_delete_sheet`);
            }
        }
        if (this.parent.password.length > 0 || this.parent.isProtected) {
            if (disableItems.indexOf(`${id}_insert_sheet`) > -1) {
                disableItems.push(`${id}_insert_sheet`);
            }
            if (disableItems.indexOf(`${id}_delete_sheet`) > -1) {
                disableItems.push(`${id}_delete_sheet`);
            }
            disableItems.push(`${id}_duplicate`, `${id}_rename`, `${id}_hide_sheet`, `${id}_delete_sheet`, `${id}_insert_sheet`, `${id}_move_left`, `${id}_move_right`);
        }
        this.parent.enableContextMenuItems(disableItems, false, true);
    }
    skipHiddenSheets() {
        let count = this.parent.sheets.length;
        this.parent.sheets.forEach((sheet) => {
            if (sheet.state !== 'Visible') {
                --count;
            }
        });
        return count;
    }
    renameSheetTab() {
        let target = this.tabInstance.element.querySelector('.e-toolbar-item.e-active');
        if (target) {
            target = target.querySelector('.e-text-wrap');
            const value = target.querySelector('.e-tab-text').textContent;
            const args = {
                eventArgs: {
                    name: value, index: this.parent.getActiveSheet().id
                },
                action: 'renameSheet', cancel: false
            };
            this.parent.trigger('actionBegin', args);
            if (args.cancel || this.parent.isProtected) {
                return;
            }
            const input = this.parent.createElement('input', {
                id: this.parent.element.id + '_rename_input',
                className: 'e-input e-sheet-rename', styles: `width: ${target.getBoundingClientRect().width}px`, attrs: {
                    'type': 'text', 'name': 'Rename', 'required': '', 'value': value, 'spellcheck': 'false', 'maxlength': '31'
                }
            });
            target.firstElementChild.style.display = 'none';
            target.appendChild(input);
            EventHandler.add(document, 'mousedown touchstart', this.renameInputFocusOut, this);
            EventHandler.add(input, 'keydown', this.renameKeyDown, this);
            EventHandler.add(input, 'input', this.updateWidth, this);
            input.focus();
            input.setSelectionRange(0, value.length);
            EventHandler.remove(closest(target, '.e-toolbar-items'), 'dblclick', this.renameSheetTab);
        }
    }
    updateWidth(e) {
        const target = e.target;
        let len = target.value.length;
        const value = target.value.split(' ');
        if (value.length) {
            const spaceLen = value.length - 1;
            len -= spaceLen;
            len += (spaceLen * 0.5);
        }
        target.style.width = `${len}ch`;
    }
    renameKeyDown(e) {
        if (e.keyCode === 32) {
            e.stopPropagation();
        }
        else if (e.keyCode === 27) {
            this.removeRenameInput(e.target);
            this.focusTab(this.tabInstance.element);
        }
        else if (e.keyCode === 13) {
            this.renameInputFocusOut(e);
        }
    }
    renameInputFocusOut(e) {
        let target = e.target;
        if ((e.type === 'mousedown' || e.type === 'touchstart') && (target.classList.contains('e-sheet-rename') ||
            closest(target, '.e-dlg-container'))) {
            return;
        }
        target = document.getElementById(this.parent.element.id + '_rename_input');
        const value = target.value;
        const l10n = this.parent.serviceLocator.getService(locale);
        if (value) {
            const idx = this.tabInstance.selectedItem;
            // eslint-disable-next-line no-useless-escape
            if (!value.match(new RegExp('.*[\\[\\]\\*\\\\\/\\?].*'))) {
                if (this.parent.sheets[idx].name !== value) {
                    for (let i = 0, len = this.parent.sheets.length; i < len; i++) {
                        if (i !== this.parent.activeSheetIndex && this.parent.sheets[i].name.toLowerCase() ===
                            value.toLowerCase()) {
                            this.showRenameDialog(target, l10n.getConstant('SheetRenameAlreadyExistsAlert'));
                            return;
                        }
                    }
                }
                const items = this.removeRenameInput(target);
                if (this.parent.sheets[idx].name !== value) {
                    this.parent.setSheetPropertyOnMute(this.parent.sheets[idx], 'name', value);
                    this.updateSheetName({ value: value, idx: idx, items: items });
                }
                if (e.type === 'keydown') {
                    this.focusTab(items);
                }
                else if ((closest(e.target, '.e-spreadsheet'))) {
                    focus(this.parent.element);
                }
            }
            else {
                this.showRenameDialog(target, l10n.getConstant('SheetRenameInvalidAlert'));
            }
        }
        else {
            this.showRenameDialog(target, l10n.getConstant('SheetRenameEmptyAlert'));
        }
        this.parent.notify(completeAction, { eventArgs: { index: this.parent.getActiveSheet().id, value: value }, action: 'renameSheet' });
    }
    focusTab(context) {
        focus(select('.e-toolbar-item.e-active .e-tab-wrap', context));
    }
    updateSheetName(args) {
        const pName = this.tabInstance.items[args.idx].header.text.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
        const name = args.value.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        this.tabInstance.items[args.idx].header.text = name;
        this.dropDownInstance.items[args.idx].text = name;
        this.dropDownInstance.setProperties({ 'items': this.dropDownInstance.items }, true);
        const sheetTabText = args.items.querySelectorAll('.e-toolbar-item')[args.idx].querySelector('.e-tab-text');
        sheetTabText.textContent = '';
        sheetTabText.appendChild(document.createTextNode(args.value));
        if (args.value.indexOf('  ') > -1) {
            this.tabInstance.setProperties({ 'items': this.tabInstance.items }, true);
        }
        else {
            this.tabInstance.dataBind();
        }
        this.parent.notify(sheetRenameUpdate, { value: args.value, pName: pName });
        if (this.parent.allowChart) {
            const range = [];
            let lastIndex;
            this.parent.chartColl.forEach((chart) => {
                if (chart.range.includes('!')) {
                    lastIndex = chart.range.lastIndexOf('!');
                    range[0] = chart.range.substring(0, lastIndex);
                    range[1] = chart.range.substring(lastIndex + 1);
                    if (range[0].toLowerCase() === pName.toLowerCase()) {
                        range[0] = args.value;
                        chart.range = range.join('!');
                    }
                }
            });
        }
    }
    hideSheet(args) {
        const actionArgs = {
            action: 'hideSheet', eventArgs: { sheetIndex: args.sheetIndex, cancel: false }
        };
        if (args.triggerEvent) {
            this.parent.notify(beginAction, actionArgs);
            if (actionArgs.eventArgs.cancel) {
                return;
            }
        }
        this.parent.setSheetPropertyOnMute(getSheet(this.parent, args.sheetIndex), 'state', 'Hidden');
        this.tabInstance.hideTab(args.sheetIndex);
        if (args.triggerEvent) {
            delete actionArgs.eventArgs.cancel;
            this.parent.notify(completeAction, actionArgs);
        }
    }
    removeRenameInput(target) {
        const textEle = target.parentElement.querySelector('.e-tab-text');
        const sheetItems = closest(target, '.e-toolbar-items');
        EventHandler.add(sheetItems, 'dblclick', this.renameSheetTab, this);
        EventHandler.remove(document, 'mousedown touchstart', this.renameInputFocusOut);
        EventHandler.remove(target, 'keydown', this.renameKeyDown);
        EventHandler.remove(target, 'input', this.updateWidth);
        remove(target);
        textEle.style.display = '';
        return sheetItems;
    }
    showRenameDialog(target, content) {
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        let isCancelled;
        dialogInst.show({
            height: 180, width: 400, isModal: true, showCloseIcon: true,
            content: content,
            beforeOpen: (args) => {
                const dlgArgs = {
                    dialogName: 'SheetRenameDialog',
                    element: args.element, target: args.target, cancel: args.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    isCancelled = args.preventFocus = args.cancel = true;
                }
                else {
                    args.element.querySelector('.e-footer-content .e-primary').setAttribute('aria-label', `${content} ${this.parent.serviceLocator.getService(locale).getConstant('Ok')}`);
                    focus(target);
                }
            },
            close: () => {
                if (isCancelled) {
                    getUpdateUsingRaf(() => {
                        const curPosition = [target.selectionStart, target.selectionEnd];
                        focus(target);
                        target.setSelectionRange(curPosition[0], curPosition[1]);
                    });
                }
                else {
                    target.setSelectionRange(0, target.value.length);
                }
            }
        });
    }
    focusRenameInput() {
        const input = document.getElementById(this.parent.element.id + '_rename_input');
        if (input) {
            input.focus();
        }
    }
    removeSheetTab(args) {
        if (args.count && (args.count === this.parent.sheets.length)) {
            return;
        }
        const l10n = this.parent.serviceLocator.getService(locale);
        if (this.skipHiddenSheets() > 1) {
            const sheet = args.sheetName ?
                getSheet(this.parent, getSheetIndex(this.parent, args.sheetName)) :
                this.parent.getActiveSheet();
            const sheetIndex = isNullOrUndefined(args.index) ? getSheetIndex(this.parent, sheet.name) : args.index;
            const eventArgs = {
                index: sheetIndex,
                sheetCount: this.parent.sheets.length,
                sheetName: sheet.name
            };
            const isDataAvail = sheet.rows && sheet.rows.length ?
                (sheet.rows.length === 1 ? (sheet.rows[0].cells && sheet.rows[0].cells.length ? true : false) : true) : false;
            if (isDataAvail) {
                const dialogInst = this.parent.serviceLocator.getService(dialog);
                if (args.clicked) {
                    this.forceDelete(sheetIndex);
                }
                else {
                    dialogInst.show({
                        height: 200, width: 400, isModal: true, showCloseIcon: true, cssClass: 'e-delete-sheet-dlg',
                        content: l10n.getConstant('DeleteSheetAlert'),
                        beforeOpen: (args) => {
                            const dlgArgs = {
                                dialogName: 'DeleteSheetDialog',
                                element: args.element, target: args.target, cancel: args.cancel
                            };
                            this.parent.trigger('dialogBeforeOpen', dlgArgs);
                            if (dlgArgs.cancel) {
                                args.cancel = true;
                            }
                            else {
                                args.element.querySelector('.e-footer-content .e-primary').setAttribute('aria-label', `${l10n.getConstant('DeleteSheetAlert')} ${l10n.getConstant('Ok')}`);
                                focus(this.parent.element);
                            }
                        },
                        buttons: [{
                                buttonModel: { content: l10n.getConstant('Ok'), isPrimary: true },
                                click: () => {
                                    dialogInst.hide();
                                    this.forceDelete(sheetIndex);
                                    this.parent.notify(clearUndoRedoCollection, null);
                                    if (args && !args.isAction) {
                                        eventArgs.sheetCount = this.parent.sheets.length;
                                        this.parent.notify(completeAction, { eventArgs: eventArgs, action: 'removeSheet' });
                                    }
                                }
                            }]
                    });
                }
            }
            else {
                this.parent.notify(refreshInsertDelete, { startIndex: sheetIndex, endIndex: sheetIndex, modelType: 'Sheet', isDelete: true });
                this.parent.notify(workbookFormulaOperation, { action: 'deleteSheetTab', sheetId: getSheet(this.parent, sheetIndex).id });
                this.destroySheet(sheetIndex);
                this.parent.notify(clearUndoRedoCollection, null);
                if (args && !args.isAction) {
                    eventArgs.sheetCount = this.parent.sheets.length;
                    this.parent.notify(completeAction, { eventArgs: eventArgs, action: 'removeSheet' });
                }
            }
        }
        else {
            this.parent.serviceLocator.getService(dialog).show({
                height: 180, width: 400, isModal: true, showCloseIcon: true,
                content: l10n.getConstant('DeleteSingleLastSheetAlert'),
                beforeOpen: (args) => {
                    const dlgArgs = {
                        dialogName: 'DeleteSingleSheetDialog',
                        element: args.element, target: args.target, cancel: args.cancel
                    };
                    this.parent.trigger('dialogBeforeOpen', dlgArgs);
                    if (dlgArgs.cancel) {
                        args.cancel = true;
                    }
                }
            });
        }
    }
    forceDelete(sheetIndex) {
        this.parent.notify(removeDesignChart, {});
        this.parent.notify(refreshInsertDelete, { startIndex: sheetIndex, endIndex: sheetIndex, modelType: 'Sheet', isDelete: true });
        this.parent.notify(workbookFormulaOperation, { action: 'deleteSheetTab', sheetId: getSheet(this.parent, sheetIndex).id });
        this.destroySheet(sheetIndex);
    }
    destroySheet(sheetIndex) {
        const activeSheetIdx = isNullOrUndefined(sheetIndex) ? this.parent.activeSheetIndex : sheetIndex;
        this.parent.removeSheet(activeSheetIdx);
        this.parent.notify(sheetsDestroyed, { sheetIndex: activeSheetIdx });
        this.dropDownInstance.items.splice(activeSheetIdx, 1);
        this.dropDownInstance.setProperties({ 'items': this.dropDownInstance.items }, true);
        this.tabInstance.removeTab(activeSheetIdx);
        const activeIndex = this.parent.skipHiddenSheets(this.tabInstance.selectedItem);
        this.parent.activeSheetIndex = activeIndex;
        this.parent.setProperties({ activeSheetIndex: activeIndex }, true);
        this.parent.renderModule.refreshSheet();
        this.tabInstance.selectedItem = activeIndex;
        this.tabInstance.dataBind();
        this.updateDropDownItems(activeIndex);
        this.parent.notify(protectSheet, null);
    }
    showAggregate(args) {
        if (isSingleCell(getRangeIndexes(this.parent.getActiveSheet().selectedRange)) || (args && args.remove)) {
            this.removeAggregate();
            return;
        }
        const eventArgs = { Count: 0, Sum: '0', Avg: '0', Min: '0', Max: '0', countOnly: true };
        this.parent.notify(aggregateComputation, eventArgs);
        if (eventArgs.Count > 1) {
            this.aggregateContent = eventArgs.countOnly ? 'Count' : this.selaggregateCnt;
            if (eventArgs.countOnly) {
                this.aggregateContent = 'Count';
                delete eventArgs.Sum;
                delete eventArgs.Avg;
                delete eventArgs.Min;
                delete eventArgs.Max;
            }
            const btnClass = eventArgs.countOnly ? 'e-aggregate-list e-flat e-aggregate-list-countonly e-caret-hide'
                : 'e-aggregate-list e-flat';
            delete eventArgs.countOnly;
            const key = this.aggregateContent;
            const content = `${key}: ${eventArgs[key.toString()]}`;
            if (!this.aggregateDropDown) {
                const aggregateEle = this.parent.createElement('button', { id: this.parent.element.id + '_aggregate', attrs: { 'type': 'button' } });
                document.getElementById(`${this.parent.element.id}_sheet_tab_panel`).appendChild(aggregateEle);
                this.aggregateDropDown = new DropDownButton({
                    content: content,
                    items: this.getAggregateItems(eventArgs),
                    createPopupOnClick: true,
                    select: (args) => {
                        this.parent.notify(aggregateComputation, eventArgs);
                        this.updateAggregateContent(args.item.text, { Count: eventArgs.Count, Sum: eventArgs.Sum, Avg: eventArgs.Avg, Min: eventArgs.Min,
                            Max: eventArgs.Max }, true);
                    },
                    beforeOpen: (args) => this.beforeOpenHandler(this.aggregateDropDown, args.element),
                    open: (args) => this.openHandler(this.aggregateDropDown, args.element, 'right'),
                    close: () => focus(this.parent.element),
                    cssClass: btnClass
                });
                this.aggregateDropDown.createElement = this.parent.createElement;
                this.aggregateDropDown.appendTo(aggregateEle);
            }
            else {
                this.updateAggregateContent(content, eventArgs);
            }
        }
        else {
            this.removeAggregate();
        }
    }
    getAggregateItems(args) {
        const items = [];
        let text;
        let iconCss;
        let argsKey;
        Object.keys(args).forEach((key) => {
            argsKey = args[`${key}`];
            if (argsKey !== aggregateComputation) {
                text = `${key}: ${argsKey}`;
                iconCss = key === this.aggregateContent ? 'e-selected-icon e-icons' : '';
                items.push({ text: text, iconCss: iconCss });
            }
        });
        return items;
    }
    updateAggregateContent(text, eventArgs, isSelect) {
        this.aggregateContent = text.split(': ')[0];
        if (isSelect) {
            this.selaggregateCnt = text.split(': ')[0];
        }
        this.aggregateDropDown.content = text;
        this.aggregateDropDown.dataBind();
        this.aggregateDropDown.setProperties({ 'items': this.getAggregateItems(eventArgs) }, true);
    }
    removeAggregate() {
        if (!isNullOrUndefined(this.aggregateDropDown)) {
            this.aggregateDropDown.destroy();
            remove(this.aggregateDropDown.element);
            this.aggregateDropDown = null;
        }
    }
    addEventListener() {
        this.parent.on(sheetTabs, this.createSheetTabs, this);
        this.parent.on(refreshSheetTabs, this.refreshSheetTab, this);
        this.parent.on(insertSheetTab, this.insertSheetTab, this);
        this.parent.on(removeSheetTab, this.removeSheetTab, this);
        this.parent.on(renameSheetTab, this.renameSheetTab, this);
        this.parent.on(cMenuBeforeOpen, this.switchSheetTab, this);
        this.parent.on(activeSheetChanged, this.updateSheetTab, this);
        this.parent.on(activeCellChanged, this.removeAggregate, this);
        this.parent.on(focusRenameInput, this.focusRenameInput, this);
        this.parent.on(sheetNameUpdate, this.updateSheetName, this);
        this.parent.on(hideSheet, this.hideSheet, this);
        this.parent.on(showAggregate, this.showAggregate, this);
        this.parent.on(goToSheet, this.goToSheet, this);
        this.parent.on(showSheet, this.showSheet, this);
    }
    destroy() {
        this.removeEventListener();
        if (this.dropDownInstance) {
            this.dropDownInstance.destroy();
        }
        this.dropDownInstance = null;
        if (this.tabInstance) {
            this.tabInstance.destroy();
        }
        this.tabInstance = null;
        this.removeAggregate();
        this.aggregateContent = null;
        if (this.addBtnRipple) {
            this.addBtnRipple();
        }
        this.addBtnRipple = null;
        EventHandler.remove(document, 'mousedown touchstart', this.renameInputFocusOut);
        const ele = document.getElementById(this.parent.element.id + '_sheet_tab_panel');
        if (ele) {
            remove(ele);
        }
        if (this.selaggregateCnt) {
            this.selaggregateCnt = null;
        }
        this.parent = null;
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(sheetTabs, this.createSheetTabs);
            this.parent.off(refreshSheetTabs, this.refreshSheetTab);
            this.parent.off(insertSheetTab, this.insertSheetTab);
            this.parent.off(removeSheetTab, this.removeSheetTab);
            this.parent.off(renameSheetTab, this.renameSheetTab);
            this.parent.off(cMenuBeforeOpen, this.switchSheetTab);
            this.parent.off(activeSheetChanged, this.updateSheetTab);
            this.parent.off(activeCellChanged, this.removeAggregate);
            this.parent.off(focusRenameInput, this.focusRenameInput);
            this.parent.off(sheetNameUpdate, this.updateSheetName);
            this.parent.off(hideSheet, this.hideSheet);
            this.parent.off(showAggregate, this.showAggregate);
            this.parent.off(goToSheet, this.goToSheet);
            this.parent.off(showSheet, this.showSheet);
        }
    }
}

class Open {
    constructor(parent) {
        this.isImportedFile = false;
        this.unProtectSheetIdx = [];
        this.parent = parent;
        this.addEventListener();
        this.renderFileUpload();
        //Spreadsheet.Inject(WorkbookOpen);
    }
    /**
     * Adding event listener for success and failure
     *
     * @returns {void} - Adding event listener for success and failure
     */
    addEventListener() {
        this.parent.on(openSuccess, this.openSuccess, this);
        this.parent.on(openFailure, this.openFailed, this);
        this.parent.on(sheetsDestroyed, this.sheetsDestroyHandler, this);
    }
    /**
     * Removing event listener for success and failure
     *
     * @returns {void} - Removing event listener for success and failure
     */
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(openSuccess, this.openSuccess);
            this.parent.off(openFailure, this.openFailed);
            this.parent.off(sheetsDestroyed, this.sheetsDestroyHandler);
        }
    }
    /**
     * Rendering upload component for importing files.
     *
     * @returns {void} - Rendering upload component for importing files.
     */
    renderFileUpload() {
        const uploadBox = this.parent.element.appendChild(this.parent.createElement('input', {
            id: this.parent.element.id + '_fileUpload',
            attrs: { type: 'file', accept: '.xls, .xlsx, .csv, .xlsm, .xlsb', name: 'fileUpload' }
        }));
        uploadBox.onchange = this.fileSelect.bind(this);
        uploadBox.onerror = this.openFailed.bind(this);
        uploadBox.style.display = 'none';
    }
    /**
     * Process after select the excel and image file.
     *
     * @param {Event} args - File select native event.
     * @returns {void} - Process after select the excel and image file.
     */
    fileSelect(args) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const filesData = args.target.files[0];
        if (filesData && filesData.length < 1) {
            return;
        }
        const impArgs = {
            file: filesData
        };
        this.parent.open(impArgs);
        select('#' + this.parent.element.id + '_fileUpload', this.parent.element).value = '';
    }
    /**
     * File open success event declaration.
     *
     * @param {string} response - File open success response text.
     * @returns {void} - File open success event declaration.
     */
    openSuccess(response) {
        const openError = ['UnsupportedFile', 'InvalidUrl', 'NeedPassword', 'InCorrectPassword', 'InCorrectSheetPassword',
            'CorrectSheetPassword', 'DataLimitExceeded', 'FileSizeLimitExceeded', 'ExternalWorkbook'];
        const openCancelFn = (action) => {
            this.parent.serviceLocator.getService(dialog).hide(true);
            const file = new File([], response.guid, { type: action.toLowerCase() });
            this.parent.open({ file: file, guid: response.guid, password: response.eventArgs.password, orginalFile: response.eventArgs.file });
        };
        if (openError.indexOf(response.data) > -1) {
            const l10n = this.parent.serviceLocator.getService(locale);
            if (openError[2] === response.data) {
                if (!this.parent.element.querySelector('.e-importprotectworkbook-dlg')) {
                    this.parent.notify(importProtectWorkbook, response.eventArgs);
                }
            }
            else if (openError[3] === response.data) {
                const alertSpan = this.parent.createElement('span', { className: 'e-importprotectpwd-alert-span' });
                alertSpan.innerText = l10n.getConstant('IncorrectPassword');
                (this.parent.element.querySelector('.e-importprotectworkbook-dlg').querySelector('.e-dlg-content')).appendChild(alertSpan);
            }
            else if (openError[4] === response.data) {
                const alertSpan = this.parent.createElement('span', { className: 'e-unprotectsheetpwd-alert-span' });
                alertSpan.innerText = l10n.getConstant('IncorrectPassword');
                (this.parent.element.querySelector('.e-unprotectworksheet-dlg').querySelector('.e-dlg-content')).appendChild(alertSpan);
            }
            else if (openError[5] === response.data) {
                this.parent.isOpen = false;
                this.parent.notify(unProtectSheetPassword, null);
                const dialogInst = this.parent.serviceLocator.getService(dialog);
                dialogInst.hide();
                this.parent.hideSpinner();
            }
            else if (openError[8] === response.data) {
                const dialogInst = this.parent.serviceLocator.getService(dialog);
                dialogInst.hide(true);
                const externalWorkbook = response.data.includes('ExternalWorkbook');
                this.parent.serviceLocator.getService(dialog).show({
                    content: this.parent.serviceLocator.getService('spreadsheetLocale').getConstant('ExternalWorkbook'),
                    width: '350', buttons: externalWorkbook ? [
                        {
                            click: openCancelFn.bind(this, `${response.data}Yes`),
                            buttonModel: { content: l10n.getConstant('Yes'), isPrimary: true }
                        },
                        {
                            click: openCancelFn.bind(this, `${response.data}No`),
                            buttonModel: { content: l10n.getConstant('No') }
                        }
                    ] : [],
                    beforeOpen: (args) => {
                        const dlgArgs = {
                            dialogName: 'OpenDialog',
                            element: args.element, target: args.target, cancel: args.cancel
                        };
                        this.parent.trigger('dialogBeforeOpen', dlgArgs);
                        if (dlgArgs.cancel) {
                            args.cancel = true;
                        }
                    }
                }, externalWorkbook ? true : null);
                this.parent.hideSpinner();
                return;
            }
            else {
                const dialogInst = this.parent.serviceLocator.getService(dialog);
                dialogInst.hide(true);
                const sizeLimitAlert = response.data.includes('LimitExceeded');
                this.parent.serviceLocator.getService(dialog).show({
                    content: this.parent.serviceLocator.getService('spreadsheetLocale')
                        .getConstant(response.data),
                    width: '300', buttons: sizeLimitAlert ? [
                        { click: openCancelFn.bind(this, `${response.data}Open`),
                            buttonModel: { content: l10n.getConstant('Ok'), isPrimary: true } },
                        { click: openCancelFn.bind(this, `${response.data}Cancel`),
                            buttonModel: { content: l10n.getConstant('Cancel') } }
                    ] : [],
                    beforeOpen: (args) => {
                        const dlgArgs = {
                            dialogName: 'OpenDialog',
                            element: args.element, target: args.target, cancel: args.cancel
                        };
                        this.parent.trigger('dialogBeforeOpen', dlgArgs);
                        if (dlgArgs.cancel) {
                            args.cancel = true;
                        }
                    }
                }, sizeLimitAlert ? true : null);
                this.parent.hideSpinner();
                return;
            }
        }
        else {
            const dialogInst = this.parent.serviceLocator.getService(dialog);
            dialogInst.hide();
            this.parent.showSpinner();
        }
        if (!this.parent.element) {
            return;
        }
        if (openError[5] !== response.data) {
            this.parent.notify(clearFormulaDependentCells, { cellRef: null, isOpen: true });
            if (!response.isOpenFromJson) {
                this.parent.trigger('openComplete', { response: response });
                this.parent.notify(completeAction, { response: response, action: 'import' });
            }
            if (this.parent.isProtected && this.parent.showSheetTabs && response.isOpenFromJson) {
                this.parent.element.querySelector('.e-add-sheet-tab').setAttribute('disabled', 'true');
                this.parent.element.querySelector('.e-add-sheet-tab').classList.add('e-disabled');
            }
            this.parent.renderModule.refreshSheet(response.isOpenFromJson, false, false, false, response);
            this.parent.notify(refreshSheetTabs, null);
            this.isImportedFile = true;
            response.context.preventFormatCheck = response.eventArgs && response.eventArgs.file && response.eventArgs.file.name &&
                !response.eventArgs.file.name.includes('.csv');
            this.unProtectSheetIdx = [];
            this.parent.hideSpinner();
        }
    }
    /**
     * File open failure event declaration.
     *
     * @param {object} args - Open failure arguments.
     * @returns {void} - File open failure event declaration.
     */
    openFailed(args) {
        this.parent.trigger('openFailure', args);
        this.parent.hideSpinner();
        /* Need to Implement */
    }
    sheetsDestroyHandler(args) {
        if (isNullOrUndefined(args.sheetIndex)) {
            this.isImportedFile = false;
            this.unProtectSheetIdx = [];
        }
    }
    /**
     * To Remove the event listeners.
     *
     * @returns {void} - To Remove the event listeners.
     */
    destroy() {
        this.removeEventListener();
        const uploadBox = select('#' + this.parent.element.id + '_fileUpload', this.parent.element);
        if (uploadBox) {
            detach(uploadBox);
        }
        this.isImportedFile = null;
        this.unProtectSheetIdx = null;
        this.parent = null;
    }
    /**
     * Get the sheet open module name.
     *
     * @returns {string} - Get the sheet open module name.
     */
    getModuleName() {
        return 'open';
    }
}

/**
 * `Save` module is used to handle the save action in Spreadsheet.
 */
class Save {
    /**
     * Constructor for Save module in Spreadsheet.
     *
     * @private
     * @param {Spreadsheet} parent - Specifies the Spreadsheet instance.
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
        //Spreadsheet.Inject(WorkbookSave);
    }
    /**
     * To destroy the Save module.
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(beginSave, this.initiateSave, this);
        this.parent.on(saveCompleted, this.saveCompleted, this);
        this.parent.on(saveError, this.showErrorDialog, this);
        this.parent.on(exportDialog, this.exportDialog, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(beginSave, this.initiateSave);
            this.parent.off(saveCompleted, this.saveCompleted);
            this.parent.off(saveError, this.showErrorDialog);
            this.parent.off(exportDialog, this.exportDialog);
        }
    }
    /**
     * Get the module name.
     *
     * @returns {string} - Get the module name.
     * @private
     */
    getModuleName() {
        return 'save';
    }
    /**
     * Initiate save process.
     *
     * @hidden
     * @returns {void} - Initiate save process.
     */
    initiateSave() {
        this.parent.showSpinner();
    }
    /**
     * Save action completed.
     *
     * @hidden
     * @returns {void} - Save action completed.
     */
    saveCompleted() {
        this.parent.hideSpinner();
    }
    showErrorDialog(args) {
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        dialogInst.show({
            isModal: true, showCloseIcon: true, height: 180, width: 400, content: args.content,
            beforeOpen: () => focus(this.parent.element)
        });
    }
    exportDialog(args) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        const type = args ? args.item.id.split(this.parent.element.id + '_')[1] : 'xlsx';
        if (isNullOrUndefined(this.parent.element.querySelector('.e-open-dlg'))) {
            const dlg = {
                isModal: true, showCloseIcon: true, cssClass: 'e-open-dlg',
                header: l10n.getConstant('SaveAs'),
                beforeOpen: (args) => {
                    const dlgArgs = {
                        dialogName: l10n.getConstant('SaveAs'),
                        element: args.element, target: args.target, cancel: args.cancel
                    };
                    this.parent.trigger('dialogBeforeOpen', dlgArgs);
                    if (dlgArgs.cancel) {
                        args.cancel = true;
                    }
                    else {
                        dialogInst.dialogInstance.content = this.OpenContent(type);
                        dialogInst.dialogInstance.dataBind();
                        this.parent.element.querySelector('.e-text-open').setSelectionRange(0, this.parent.element.querySelector('.e-text-open').value.length);
                        focus(this.parent.element);
                    }
                },
                buttons: [{
                        buttonModel: {
                            content: l10n.getConstant('Save'), isPrimary: true, cssClass: 'e-btn-open-ok'
                        },
                        click: () => {
                            const name = this.parent.element.querySelector('.e-text-open').value;
                            if (this.checkValidName(name)) {
                                dialogInst.hide();
                                const type = args ? args.item.id.split(`${this.parent.element.id}_`)[1] : 'Xlsx';
                                this.parent.save({ saveType: type, fileName: name });
                            }
                            else {
                                const saveButton = this.parent.element.querySelector('.e-btn-open-ok');
                                const saveButtonObj = getComponent(saveButton, 'btn');
                                saveButtonObj.disabled = true;
                                const l10n = this.parent.serviceLocator.getService(locale);
                                const error = name.length === 0 ? l10n.getConstant('EmptyFileName') :
                                    (name.length > 218 ? l10n.getConstant('LargeName') : l10n.getConstant('FileNameError'));
                                const fileSpan = this.parent.createElement('span', { className: 'e-file-alert-span' });
                                fileSpan.innerText = error;
                                if (this.parent.element.querySelector('.e-file-alert-span')) {
                                    this.parent.element.querySelector('.e-file-alert-span').remove();
                                }
                                (this.parent.element.querySelector('.e-open-dlg').querySelector('.e-dlg-content')).appendChild(fileSpan);
                            }
                        }
                    }]
            };
            dialogInst.show(dlg);
        }
        else {
            dialogInst.hide();
        }
    }
    checkValidName(name) {
        let isValidName = true;
        if (name.match(new RegExp('.*[\\[\\]\\*\\\\/\\?\\:\\<\\>\\|\\"].*')) || name.length < 1 || name.length > 218) {
            isValidName = false;
        }
        return isValidName;
    }
    OpenContent(type) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialogElem = this.parent.createElement('div', { className: 'e-open-dialog' });
        const openTextHeader = this.parent.createElement('div', { className: 'e-open-head' });
        const openTextE = this.parent.createElement('div', { className: 'e-input-group' });
        dialogElem.appendChild(openTextHeader);
        dialogElem.appendChild(openTextE);
        const header = l10n.getConstant('FileName');
        const id = `${this.parent.element.id}_filename`;
        const openTextH = this.parent.createElement('p', { className: 'e-header', id: id, attrs: { 'aria-label': `${l10n.getConstant('SaveAs')} ${header}` } });
        openTextH.innerText = header;
        const openTextIp = this.parent.createElement('input', { className: 'e-input e-text-open', attrs: { 'type': 'Text', 'aria-labelledby': id } });
        const openTextSpan = this.parent.createElement('span', { className: 'e-input-group-icon' });
        openTextIp.onkeyup = (e) => {
            if (this.parent.element.querySelector('.e-file-alert-span') && e.keyCode !== 13) {
                const saveButton = this.parent.element.querySelector('.e-btn-open-ok');
                const buttonObj = getComponent(saveButton, 'btn');
                buttonObj.disabled = false;
                this.parent.element.querySelector('.e-file-alert-span').remove();
            }
        };
        openTextHeader.appendChild(openTextH);
        openTextSpan.textContent = '.' + type.toLowerCase();
        openTextE.appendChild(openTextIp);
        openTextIp.setAttribute('value', 'Sample');
        openTextE.appendChild(openTextSpan);
        return dialogElem;
    }
}

/**
 * Represents context menu for Spreadsheet.
 */
class ContextMenu {
    /**
     * Constructor for ContextMenu module.
     *
     * @param {Spreadsheet} parent - Constructor for ContextMenu module.
     */
    constructor(parent) {
        this.parent = parent;
        this.init();
    }
    init() {
        this.initContextMenu();
        this.addEventListener();
    }
    initContextMenu() {
        const ul = document.createElement('ul');
        ul.id = this.parent.element.id + '_contextmenu';
        this.parent.element.appendChild(ul);
        this.contextMenuInstance = new ContextMenu$1({
            cssClass: 'e-spreadsheet-contextmenu',
            target: '#' + this.parent.element.id,
            select: this.selectHandler.bind(this),
            beforeOpen: this.beforeOpenHandler.bind(this),
            beforeClose: this.beforeCloseHandler.bind(this),
            beforeItemRender: (args) => {
                args.element.setAttribute('aria-label', args.item.text);
            }
        }, ul);
        ul.setAttribute('role', 'menu');
    }
    /**
     * Before close event handler.
     *
     * @param {BeforeOpenCloseMenuEventArgs} args - Specify the args
     * @returns {void} - Before close event handler.
     */
    beforeCloseHandler(args) {
        this.parent.trigger('contextMenuBeforeClose', args);
        if (this.parent.enableKeyboardShortcut && args.event && args.event.keyCode === 27) { // Esc key
            getUpdateUsingRaf(() => focus(this.parent.element));
        }
    }
    /**
     * Select event handler.
     *
     * @param {MenuEventArgs} args - Specify the args
     * @returns {void} - Select event handler.
     */
    selectHandler(args) {
        const selectArgs = extend({ cancel: false }, args);
        this.parent.trigger('contextMenuItemSelect', selectArgs);
        const id = this.parent.element.id + '_cmenu';
        const range = getRangeIndexes(this.parent.getActiveSheet().selectedRange);
        const prevSort = [];
        if ((args.item.id === id + '_ascending' || args.item.id === id + '_descending') && this.parent.sortCollection) {
            for (let i = this.parent.sortCollection.length - 1; i >= 0; i--) {
                if (this.parent.sortCollection[i] &&
                    this.parent.sortCollection[i].sheetIndex === this.parent.activeSheetIndex) {
                    prevSort.push(this.parent.sortCollection[i]);
                    this.parent.sortCollection.splice(i, 1);
                }
            }
        }
        if (args.item.id === id + '_delete_row' || args.item.id === id + '_delete_column' ||
            args.item.id === id + '_insert_column_before' || args.item.id === id + '_insert_column_after' ||
            args.item.id === id + '_insert_row_above' || args.item.id === id + '_insert_row_below') {
            const row = getRow(this.parent.getActiveSheet(), range[0]);
            const column = getColumn(this.parent.getActiveSheet(), range[1]);
            if ((row && !row.isReadOnly) && (column && !column.isReadOnly)) {
                if (isReadOnlyCells(this.parent, range)) {
                    this.parent.notify(readonlyAlert, null);
                    return;
                }
            }
        }
        if (args.item.id === id + '_ascending' || args.item.id === id + '_descending' || args.item.id === id + '_customsort') {
            const sortRange = getDataRange(range[0], range[1], this.parent.getActiveSheet());
            if (isReadOnlyCells(this.parent, sortRange)) {
                this.parent.notify(readonlyAlert, null);
                return;
            }
        }
        let field;
        if (!selectArgs.cancel) {
            let indexes;
            switch (args.item.id) {
                case id + '_cut':
                    this.parent.notify(cut, { invokeCopy: true, promise: Promise });
                    break;
                case id + '_copy':
                    this.parent.notify(copy, { invokeCopy: true, promise: Promise });
                    break;
                case id + '_paste':
                    this.parent.notify(paste, { isAction: true, isInternal: true, focus: true });
                    break;
                case id + '_pastevalues':
                    this.parent.notify(paste, { type: 'Values', isAction: true, isInternal: true, focus: true });
                    break;
                case id + '_pasteformats':
                    this.parent.notify(paste, { type: 'Formats', isAction: true, isInternal: true, focus: true });
                    break;
                case id + '_rename':
                    this.parent.notify(renameSheetTab, {});
                    break;
                case id + '_delete_sheet':
                    this.parent.notify(removeSheetTab, {});
                    focus(this.parent.element);
                    break;
                case id + '_insert_sheet':
                    this.parent.notify(insertModel, { model: this.parent, start: this.parent.activeSheetIndex,
                        end: this.parent.activeSheetIndex, modelType: 'Sheet', isAction: true, activeSheetIndex: this.parent.activeSheetIndex });
                    break;
                case id + '_hide_sheet':
                    this.parent.notify(hideSheet, { sheetIndex: this.parent.activeSheetIndex, triggerEvent: true });
                    break;
                case id + '_duplicate':
                    duplicateSheet(this.parent, undefined, true);
                    focus(this.parent.element);
                    break;
                case id + '_move_right':
                    moveSheet(this.parent, this.parent.activeSheetIndex + 1, null, true);
                    focus(this.parent.element);
                    break;
                case id + '_move_left':
                    moveSheet(this.parent, this.parent.activeSheetIndex - 1, null, true);
                    focus(this.parent.element);
                    break;
                case id + '_ascending':
                    this.parent.notify(updateSortCollection, { sortOptions: { sortDescriptors: { order: 'Ascending' } } });
                    this.parent.notify(applySort, { sortOptions: { sortDescriptors: { order: 'Ascending' } }, previousSort: prevSort });
                    break;
                case id + '_descending':
                    this.parent.notify(updateSortCollection, { sortOptions: { sortDescriptors: { order: 'Descending' } } });
                    this.parent.notify(applySort, { sortOptions: { sortDescriptors: { order: 'Descending' } }, previousSort: prevSort });
                    break;
                case id + '_customsort':
                    this.parent.notify(initiateCustomSort, null);
                    break;
                case id + '_filtercellvalue':
                    this.parent.notify(filterByCellValue, null);
                    break;
                case id + '_clearfilter':
                    field = getColumnHeaderText(getCellIndexes(this.parent.getActiveSheet().activeCell)[1] + 1);
                    this.parent.notify(clearFilter, { field: field });
                    break;
                case id + '_reapplyfilter':
                    this.parent.notify(reapplyFilter, null);
                    break;
                case id + '_hide_row':
                    indexes = getRangeIndexes(this.parent.getActiveSheet().selectedRange);
                    this.parent.notify(hideShow, {
                        startIndex: indexes[0], endIndex: indexes[2], hide: true, isCol: false, actionUpdate: true
                    });
                    break;
                case id + '_unhide_row':
                    indexes = getRangeIndexes(this.parent.getActiveSheet().selectedRange);
                    this.parent.notify(hideShow, {
                        startIndex: indexes[0], endIndex: indexes[2], hide: false, isCol: false, actionUpdate: true
                    });
                    break;
                case id + '_hide_column':
                    indexes = getRangeIndexes(this.parent.getActiveSheet().selectedRange);
                    this.parent.notify(hideShow, {
                        startIndex: indexes[1], endIndex: indexes[3], hide: true, isCol: true, actionUpdate: true
                    });
                    break;
                case id + '_unhide_column':
                    indexes = getRangeIndexes(this.parent.getActiveSheet().selectedRange);
                    this.parent.notify(hideShow, {
                        startIndex: indexes[1], endIndex: indexes[3], hide: false, isCol: true, actionUpdate: true
                    });
                    break;
                case id + '_insert_row_above':
                case id + '_delete_row':
                    indexes = getRangeIndexes(this.parent.getActiveSheet().selectedRange);
                    this.parent.notify(`${args.item.id.substr(id.length + 1, 6)}Model`, { model: this.parent.getActiveSheet(), start: indexes[0], end: indexes[2], modelType: 'Row', isAction: true,
                        insertType: 'above' });
                    break;
                case id + '_insert_row_below':
                    indexes = getSwapRange(getRangeIndexes(this.parent.getActiveSheet().selectedRange));
                    this.parent.notify(insertModel, { model: this.parent.getActiveSheet(), start: indexes[2] + 1, end: indexes[2] + 1 + (indexes[2] - indexes[0]), modelType: 'Row', isAction: true,
                        insertType: 'below' });
                    break;
                case id + '_insert_column_before':
                case id + '_delete_column':
                    indexes = getRangeIndexes(this.parent.getActiveSheet().selectedRange);
                    this.parent.notify(`${args.item.id.substr(id.length + 1, 6)}Model`, { model: this.parent.getActiveSheet(), start: indexes[1], end: indexes[3], modelType: 'Column', isAction: true,
                        insertType: 'before' });
                    break;
                case id + '_insert_column_after':
                    indexes = getSwapRange(getRangeIndexes(this.parent.getActiveSheet().selectedRange));
                    this.parent.notify(insertModel, { model: this.parent.getActiveSheet(), start: indexes[3] + 1, end: indexes[3] + 1 + (indexes[3] - indexes[1]), modelType: 'Column', isAction: true,
                        insertType: 'after' });
                    break;
                case id + '_addNote':
                    this.parent.notify(addNote, null);
                    break;
                case id + '_editNote':
                    this.parent.notify(editNote, null);
                    break;
                case id + '_deleteNote':
                    this.parent.notify(deleteNote, { rowIndex: null, columnIndex: null, isDeleteFromMenu: true });
                    break;
                case id + '_hyperlink':
                    this.parent.notify(initiateHyperlink, null);
                    break;
                case id + '_editHyperlink':
                    this.parent.notify(editHyperlink, null);
                    break;
                case id + '_openHyperlink':
                    this.parent.notify(openHyperlink, null);
                    break;
                case id + '_removeHyperlink':
                    this.parent.notify(removeHyperlink, { range: this.parent.getActiveSheet().selectedRange });
                    break;
                case id + '_protect':
                    this.parent.notify(toggleProtect, {});
                    break;
            }
        }
    }
    getInsertModel(startIndex, endIndex) {
        const model = [];
        for (let i = startIndex; i <= endIndex; i++) {
            if (i === startIndex) {
                model.push({ index: i });
            }
            else {
                model.push({});
            }
        }
        return model;
    }
    /**
     * Before open event handler.
     *
     * @param {BeforeOpenCloseMenuEventArgs} args - Specify the args.
     * @returns {void} - Before open event handler.
     */
    beforeOpenHandler(args) {
        const trgt = args.event.target;
        let canOpen;
        const filter = ['e-numericcontainer', 'e-active-cell', 'e-selection', 'e-row', 'e-header-row',
            'e-select-all-cell', 'e-sheet-tabs-items', 'e-spreadsheet-contextmenu'];
        let target;
        let items;
        for (let i = 0, len = filter.length; i < len; i++) {
            if (closest(trgt, '.' + filter[i])) {
                canOpen = true;
                break;
            }
        }
        if (canOpen) {
            target = this.getTarget(trgt);
        }
        else {
            const classesToCheck = ['e-header-cell', 'e-rowhdr-table', 'e-selectall-table', 'e-main-panel'];
            canOpen = classesToCheck.some((cls) => trgt.classList.contains(cls));
            if (canOpen && (parseInt(trgt.parentElement.style.zIndex, 10) > 1 ||
                parseInt(trgt.parentElement.parentElement.style.zIndex, 10) > 1)) {
                const event = args.event;
                const rowObj = {
                    clientY: event.clientY, isImage: false, target: trgt
                };
                const colObj = {
                    clientX: event.clientX, isImage: false, target: trgt
                };
                this.parent.notify(getRowIdxFromClientY, rowObj);
                this.parent.notify(getColIdxFromClientX, colObj);
                target = rowObj.size <= 0 ? 'ColumnHeader' : colObj.size <= 0 ? 'RowHeader' : 'Content';
            }
            else {
                canOpen = false;
            }
        }
        if (!canOpen) {
            args.cancel = true;
            return;
        }
        if (args.element.classList.contains('e-contextmenu')) {
            const sheet = this.parent.getActiveSheet();
            if (args.event.target && (trgt.classList.contains('e-rowresize') || trgt.classList.contains('e-colresize'))) {
                const range = getRangeIndexes(sheet.selectedRange);
                if (!(trgt.classList.contains('e-rowresize') ? range[1] === 0 && range[3] === sheet.colCount - 1 :
                    range[0] === 0 && range[2] === sheet.rowCount - 1)) {
                    args.cancel = true;
                    return;
                }
                if (trgt.classList.contains('e-rowresize') ? this.parent.hiddenCount(range[0], range[2]) !== Math.abs(range[2] - range[0]) +
                    1 : this.parent.hiddenCount(range[1], range[3], 'columns') !== Math.abs(range[3] - range[1]) + 1) {
                    items = this.getDataSource(target);
                }
                else {
                    items = this.getDataSource(target, trgt);
                }
            }
            else {
                if (target === 'Content') {
                    const range = getRangeIndexes(sheet.selectedRange);
                    const rowSelect = range[1] === 0 && range[3] === sheet.colCount - 1;
                    const colSelect = range[0] === 0 && range[2] === sheet.rowCount - 1;
                    target = rowSelect && colSelect ? 'SelectAll' : (rowSelect ? 'RowHeader' : (colSelect ? 'ColumnHeader' : 'Content'));
                }
                items = this.getDataSource(target, target === 'Footer' ? trgt : undefined);
            }
            this.contextMenuInstance.items = items;
            this.contextMenuInstance.dataBind();
        }
        else {
            items = args.items;
        }
        if (this.parent.selectionSettings.mode === 'None') {
            if (target === 'Content') {
                this.parent.enableContextMenuItems(['Filter'], false, false);
            }
        }
        if (target === 'ColumnHeader' || target === 'RowHeader') {
            if (args.element && args.element.childElementCount > 0) {
                const insertEle = target === 'ColumnHeader' ? args.element.querySelector('#' + this.parent.element.id + '_cmenu_insert_column') :
                    args.element.querySelector('#' + this.parent.element.id + '_cmenu_insert_row');
                const deleteEle = target ===
                    'ColumnHeader' ? args.element.querySelector('#' + this.parent.element.id + '_cmenu_delete_column') :
                    args.element.querySelector('#' + this.parent.element.id + '_cmenu_delete_row');
                if (this.parent.allowInsert && insertEle.classList.contains('e-disabled')) {
                    insertEle.classList.remove('e-disabled');
                }
                else if ((!this.parent.allowInsert || !!this.parent.element.querySelector('.e-selectall.e-highlight')) &&
                    !insertEle.classList.contains('e-disabled')) {
                    insertEle.classList.add('e-disabled');
                }
                if (this.parent.allowDelete && deleteEle.classList.contains('e-disabled')) {
                    deleteEle.classList.remove('e-disabled');
                }
                else if (!this.parent.allowDelete && !deleteEle.classList.contains('e-disabled')) {
                    deleteEle.classList.add('e-disabled');
                }
                if (this.parent.selectionSettings.mode === 'None') {
                    if (target === 'ColumnHeader') {
                        this.parent.enableContextMenuItems(['Insert Column', 'Delete Column', 'Hide Column'], false, false);
                    }
                    if (target === 'RowHeader') {
                        this.parent.enableContextMenuItems(['Insert Row', 'Delete Row', 'Hide Row'], false, false);
                    }
                }
            }
        }
        else if (target === 'Footer') {
            const sheetIdx = getSheetIndex(this.parent, trgt.textContent);
            if (sheetIdx === 0) {
                args.element.querySelector('#' + this.parent.element.id + '_cmenu_move_left').classList.add('e-disabled');
            }
            if (sheetIdx === this.parent.sheets.length - 1) {
                args.element.querySelector('#' + this.parent.element.id + '_cmenu_move_right').classList.add('e-disabled');
            }
            if (this.parent.selectionSettings.mode === 'None') {
                this.parent.enableContextMenuItems(['Insert'], false, false);
            }
        }
        this.parent.trigger('contextMenuBeforeOpen', args);
        this.parent.notify(cMenuBeforeOpen, extend(args, { target: target, items: items }));
    }
    /**
     * To get target area based on right click.
     *
     * @param {Element} target - Specify the target
     * @returns {string} - To get target area based on right click.
     */
    getTarget(target) {
        if (closest(target, '.e-sheet-content')) {
            return 'Content';
        }
        else if (closest(target, '.e-column-header')) {
            return target.classList.contains('e-header-cell') ? 'ColumnHeader' : 'Content';
        }
        else if (closest(target, '.e-row-header')) {
            return target.classList.contains('e-header-cell') ? 'RowHeader' : 'Content';
        }
        else if (closest(target, '.e-sheet-tabs-items')) {
            return 'Footer';
        }
        else if (closest(target, '.e-selectall-container')) {
            if (target.classList.contains('e-header-cell')) {
                return closest(target, '.e-header-row') ? 'ColumnHeader' : 'RowHeader';
            }
            return closest(target, '.e-select-all-cell') ? 'SelectAll' : 'Content';
        }
        else {
            return '';
        }
    }
    /**
     * To populate context menu items based on target area.
     *
     * @param {string} target - Specify the target
     * @param {Element} targetEle - Specify the target element
     * @returns {MenuItemModel[]} - To populate context menu items based on target area.
     */
    getDataSource(target, targetEle) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const items = [];
        const id = this.parent.element.id + '_cmenu';
        if (target === 'Content') {
            this.setClipboardData(items, l10n, id);
            items.push({ separator: true });
            //push filter and sort items here
            this.setFilterItems(items, id);
            this.setSortItems(items, id);
            items.push({ separator: true });
            if (this.parent.enableNotes) {
                this.setNotesMenu(items, id);
                items.push({ separator: true });
            }
            this.setHyperLink(items, id);
        }
        else if (target === 'RowHeader') {
            this.setClipboardData(items, l10n, id);
            const sheet = this.parent.getActiveSheet();
            const indexes = getRangeIndexes(sheet.selectedRange);
            this.setInsertDeleteItems(items, l10n, 'Row', id, [indexes[0], indexes[2]], ['Above', 'Below']);
            if (!targetEle || targetEle.classList.contains('e-rowresize') || !targetEle.parentElement ||
                !targetEle.parentElement.classList.value.includes('e-hide')) {
                this.setHideShowItems(items, l10n, 'Row', id, [indexes[0], indexes[2]]);
            }
        }
        else if (target === 'ColumnHeader') {
            this.setClipboardData(items, l10n, id);
            const sheet = this.parent.getActiveSheet();
            const indexes = getRangeIndexes(sheet.selectedRange);
            this.setInsertDeleteItems(items, l10n, 'Column', id, [indexes[1], indexes[3]], ['Before', 'After']);
            if (!targetEle || !targetEle.classList.value.includes('e-hide')) {
                this.setHideShowItems(items, l10n, 'Column', id, [indexes[1], indexes[3]]);
            }
        }
        else if (target === 'SelectAll') {
            this.setClipboardData(items, l10n, id);
            this.setFilterItems(items, id);
            this.setSortItems(items, id);
        }
        else if (target === 'Footer') {
            items.push({
                text: l10n.getConstant('Insert'), id: id + '_insert_sheet'
            });
            items.push({
                text: l10n.getConstant('Delete'), iconCss: 'e-icons e-delete', id: id + '_delete_sheet'
            });
            items.push({
                text: l10n.getConstant('DuplicateSheet'), id: id + '_duplicate'
            });
            items.push({
                text: l10n.getConstant('Rename'), id: id + '_rename'
            });
            items.push({
                text: l10n.getConstant('Hide'), id: id + '_hide_sheet'
            });
            this.setProtectSheetItems(items, id, targetEle);
            items.push({
                text: l10n.getConstant('MoveRight'), id: id + '_move_right'
            });
            items.push({
                text: l10n.getConstant('MoveLeft'), id: id + '_move_left'
            });
        }
        return items;
    }
    setProtectSheetItems(items, id, targetEle) {
        const l10n = this.parent.serviceLocator.getService(locale);
        if (getSheet(this.parent, getSheetIndex(this.parent, targetEle.textContent)).isProtected) {
            items.push({
                text: l10n.getConstant('UnprotectSheet'), id: id + '_protect', iconCss: 'e-icons e-protect-icon'
            });
        }
        else {
            items.push({
                text: l10n.getConstant('ProtectSheet'), id: id + '_protect', iconCss: 'e-icons e-protect-icon'
            });
        }
    }
    /**
     * Sets sorting related items to the context menu.
     *
     * @param {MenuItemModel[]} items - Specifies the item
     * @param {string} id - Specify the id.
     * @returns {void} - Sets sorting related items to the context menu.
     */
    setFilterItems(items, id) {
        if (this.parent.allowFiltering) {
            const l10n = this.parent.serviceLocator.getService(locale);
            const args = { clearFilterText: null, isFiltered: false };
            this.parent.notify(getFilteredColumn, args);
            items.push({
                text: l10n.getConstant('Filter'), id: id + '_filter',
                iconCss: '',
                items: [
                    { text: args.clearFilterText, iconCss: 'e-icons e-filter-clear', id: id + '_clearfilter' },
                    { text: l10n.getConstant('ReapplyFilter'), iconCss: 'e-icons e-filter-reapply', id: id + '_reapplyfilter' },
                    { separator: true },
                    { text: l10n.getConstant('FilterCellValue'), iconCss: '', id: id + '_filtercellvalue' }
                ]
            });
        }
    }
    /**
     * Sets sorting related items to the context menu.
     *
     * @param {MenuItemModel[]} items - Specifies the item
     * @param {string} id - Specify the id.
     * @returns {void} - Sets sorting related items to the context menu.
     */
    setSortItems(items, id) {
        const l10n = this.parent.serviceLocator.getService(locale);
        if (this.parent.allowSorting) {
            items.push({
                text: l10n.getConstant('Sort'), id: id + '_sort',
                iconCss: 'e-icons e-sort-icon',
                items: [
                    { text: l10n.getConstant('SortAscending'), iconCss: 'e-icons e-sort-asc', id: id + '_ascending' },
                    { text: l10n.getConstant('SortDescending'), iconCss: 'e-icons e-sort-desc', id: id + '_descending' },
                    { text: l10n.getConstant('CustomSort') + '...', iconCss: 'e-icons e-sort-custom', id: id + '_customsort' }
                ]
            });
        }
    }
    setHyperLink(items, id) {
        if (this.parent.allowHyperlink) {
            const l10n = this.parent.serviceLocator.getService(locale);
            const sheet = this.parent.getActiveSheet();
            const indexes = getCellIndexes(sheet.activeCell);
            const td = this.parent.getCell(indexes[0], indexes[1]);
            if (isNullOrUndefined(td)) {
                items.push({
                    text: l10n.getConstant('Hyperlink'), iconCss: 'e-icons e-hyperlink-icon', id: id + '_hyperlink'
                });
            }
            else if (!td.getElementsByClassName('e-hyperlink')[0] &&
                !td.classList.contains('e-hyperlink')) {
                items.push({
                    text: l10n.getConstant('Hyperlink'), iconCss: 'e-icons e-hyperlink-icon', id: id + '_hyperlink'
                });
            }
            else {
                items.push({ text: l10n.getConstant('EditHyperlink'), iconCss: 'e-icons e-edithyperlink-icon', id: id + '_editHyperlink' }, { text: l10n.getConstant('OpenHyperlink'), iconCss: 'e-icons e-openhyperlink-icon', id: id + '_openHyperlink' }, { text: l10n.getConstant('RemoveHyperlink'), iconCss: 'e-icons e-removehyperlink-icon', id: id + '_removeHyperlink' });
            }
        }
    }
    setNotesMenu(items, id) {
        if (this.parent.enableNotes) {
            const l10n = this.parent.serviceLocator.getService(locale);
            const cellIndexes = getCellIndexes(this.parent.getActiveSheet().activeCell);
            const targetElement = this.parent.getCell(cellIndexes[0], cellIndexes[1]);
            if (!isNullOrUndefined(targetElement) && targetElement.children.length > 0 && targetElement.children[(targetElement.children.length - 1)].className.indexOf('addNoteIndicator') > -1) {
                items.push({ text: l10n.getConstant('EditNote'), iconCss: 'e-icons e-edit-notes', id: id + '_editNote' }, { text: l10n.getConstant('DeleteNote'), iconCss: 'e-icons e-delete-notes', id: id + '_deleteNote' });
            }
            else {
                items.push({
                    text: l10n.getConstant('AddNote'), iconCss: 'e-icons e-add-notes', id: id + '_addNote'
                });
            }
        }
    }
    setClipboardData(items, l10n, id) {
        if (this.parent.enableClipboard) {
            items.push({
                text: l10n.getConstant('Cut'),
                iconCss: 'e-icons e-cut-icon', id: id + '_cut'
            });
            items.push({
                text: l10n.getConstant('Copy'),
                iconCss: 'e-icons e-copy-icon', id: id + '_copy'
            });
            items.push({
                text: l10n.getConstant('Paste'),
                iconCss: 'e-icons e-paste-icon', id: id + '_paste'
            });
            items.push({
                text: l10n.getConstant('PasteSpecial'), id: id + '_pastespecial',
                items: [
                    { text: l10n.getConstant('Values'), id: id + '_pastevalues' },
                    { text: l10n.getConstant('Formats'), id: id + '_pasteformats' }
                ]
            });
        }
    }
    setInsertDeleteItems(items, l10n, layout, id, indexes, subItems) {
        items.push({ separator: true });
        ['Insert', 'Delete'].forEach((action) => {
            if (indexes[0] === indexes[1]) {
                items.push({ text: l10n.getConstant(`${action}${layout}`), id: id + `_${action.toLowerCase()}_${layout.toLowerCase()}` });
            }
            else {
                items.push({ text: l10n.getConstant(`${action}${layout}s`), id: id + `_${action.toLowerCase()}_${layout.toLowerCase()}` });
            }
            if (action === 'Insert') {
                items[items.length - 1].items = [];
                subItems.forEach((item) => {
                    items[items.length - 1].items.push({
                        text: l10n.getConstant(item), id: `${items[items.length - 1].id}_${item.toLowerCase()}`
                    });
                });
            }
        });
    }
    setHideShowItems(items, l10n, layout, id, indexes) {
        if (indexes[0] === indexes[1]) {
            items.push({ text: l10n.getConstant(`Hide${layout}`), id: id + `_hide_${layout.toLowerCase()}` });
        }
        else {
            const StartIdx = indexes[0];
            indexes[0] = indexes[0] > indexes[1] ? indexes[1] : indexes[0];
            indexes[1] = indexes[1] > StartIdx ? indexes[1] : StartIdx;
            items.push({ text: l10n.getConstant(`Hide${layout}s`), id: id + `_hide_${layout.toLowerCase()}` });
        }
        if (this.parent.hiddenCount(indexes[0], indexes[1], `${layout.toLowerCase()}s`)) {
            items.push({ text: l10n.getConstant(`Unhide${layout}s`), id: id + `_unhide_${layout.toLowerCase()}` });
        }
    }
    /**
     * To add event listener.
     *
     * @returns {void} - To add event listener.
     */
    addEventListener() {
        this.parent.on(addContextMenuItems, this.addItemsHandler, this);
        this.parent.on(removeContextMenuItems, this.removeItemsHandler, this);
        this.parent.on(enableContextMenuItems, this.enableItemsHandler, this);
    }
    /**
     * To add context menu items before / after particular item.
     *
     * @param {InsertArgs} args - Specify the add item handler
     * @returns {void} - To add context menu items before / after particular item.
     */
    addItemsHandler(args) {
        if (args.insertAfter) {
            this.contextMenuInstance.insertAfter(args.items, args.text, args.isUniqueId);
        }
        else {
            this.contextMenuInstance.insertBefore(args.items, args.text, args.isUniqueId);
        }
    }
    /**
     * To remove context menu items.
     *
     * @param {RemoveArgs} args - Specifies the args
     * @returns {void} - To remove context menu items.
     */
    removeItemsHandler(args) {
        this.contextMenuInstance.removeItems(args.items, args.isUniqueId);
    }
    /**
     * To enable / disable context menu items.
     *
     * @param {EnableDisableArgs} args - Specifies the args
     * @returns {void} - To enable / disable context menu items.
     */
    enableItemsHandler(args) {
        this.contextMenuInstance.enableItems(args.items, args.enable, args.isUniqueId);
    }
    /**
     * To remove event listener.
     *
     * @returns {void} - To remove event listener.
     */
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(addContextMenuItems, this.addItemsHandler);
            this.parent.off(removeContextMenuItems, this.removeItemsHandler);
            this.parent.off(enableContextMenuItems, this.enableItemsHandler);
        }
    }
    /**
     * To get module name.
     *
     * @returns {string} - To get module name.
     */
    getModuleName() {
        return 'contextMenu';
    }
    /**
     * Destroy method.
     *
     * @returns {void} - Destroy method.
     */
    destroy() {
        this.removeEventListener();
        this.contextMenuInstance.destroy();
        const ele = document.getElementById(this.parent.element.id + '_contextmenu');
        if (ele) {
            detach(ele);
        }
        this.contextMenuInstance = null;
        this.parent = null;
    }
}

/**
 * Specifies number format.
 */
class NumberFormat {
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
        //Spreadsheet.Inject(WorkbookNumberFormat);
    }
    refreshCellElement(args) {
        this.parent.refreshNode(args.td, args);
    }
    getTextSpace(args) {
        args.width = getTextWidth(args.char, args.cell.style, this.parent.cellStyle);
    }
    rowFillHandler(args) {
        const cellElem = args.cellEle;
        if (cellElem) {
            let repeatCharSpan;
            let endCol = args.colIdx;
            if (args.cell.colSpan > 1) {
                const mergeArgs = { range: [args.rowIdx, args.colIdx, args.rowIdx, args.colIdx] };
                this.parent.notify(activeCellMergedRange, mergeArgs);
                endCol = mergeArgs.range[3];
            }
            let cellWidth = getExcludedColumnWidth(this.parent.getActiveSheet(), args.rowIdx, args.colIdx, endCol);
            const iconSetSpan = args.iconSetSpan || cellElem.querySelector('.e-iconsetspan');
            if (iconSetSpan) {
                cellWidth -= iconSetSpan.getBoundingClientRect().width;
            }
            if (args.updateFillSize) {
                repeatCharSpan = cellElem.querySelector('.e-fill');
                if (!repeatCharSpan || !repeatCharSpan.textContent) {
                    return;
                }
                args.repeatChar = repeatCharSpan.textContent[0];
                const beforeSpan = cellElem.querySelector('.e-fill-before');
                if (beforeSpan) {
                    cellWidth -= getTextWidth(beforeSpan.textContent, args.cell.style, this.parent.cellStyle);
                }
                const textSpan = cellElem.querySelector('.e-fill-sec');
                if (textSpan) {
                    cellWidth -= getTextWidth(textSpan.textContent, args.cell.style, this.parent.cellStyle);
                }
            }
            else {
                const noteIndicator = cellElem.querySelector('.e-addNoteIndicator');
                cellElem.innerText = '';
                if (args.beforeFillText) {
                    const beforeSpan = this.parent.createElement('span', { className: 'e-fill-before', styles: `float: ${this.parent.enableRtl ? 'right' : 'left'}` });
                    beforeSpan.innerText = args.beforeFillText;
                    cellElem.appendChild(beforeSpan);
                    cellWidth -= getTextWidth(args.beforeFillText, args.cell.style, this.parent.cellStyle);
                }
                repeatCharSpan = this.parent.createElement('span', { className: 'e-fill' });
                cellElem.appendChild(repeatCharSpan);
                if (args.afterFillText) {
                    const textSpan = this.parent.createElement('span', { className: 'e-fill-sec' });
                    textSpan.innerText = args.afterFillText;
                    cellElem.appendChild(textSpan);
                    cellWidth -= getTextWidth(args.afterFillText, args.cell.style, this.parent.cellStyle);
                }
                if (iconSetSpan) {
                    cellElem.insertBefore(iconSetSpan, cellElem.childNodes[0]);
                }
                if (noteIndicator) {
                    cellElem.appendChild(noteIndicator);
                }
            }
            const repeatCharWidth = getTextWidth(args.repeatChar, args.cell.style, this.parent.cellStyle);
            const repeatCount = parseInt((cellWidth / repeatCharWidth).toString(), 10);
            args.formattedText = repeatCount > 0 ? args.repeatChar.repeat(repeatCount) : '';
            repeatCharSpan.textContent = args.formattedText;
        }
    }
    /**
     * Adding event listener for number format.
     *
     * @hidden
     * @returns {void} - Adding event listener for number format.
     */
    addEventListener() {
        this.parent.on(refreshCellElement, this.refreshCellElement, this);
        this.parent.on(rowFillHandler, this.rowFillHandler, this);
        this.parent.on(getTextSpace, this.getTextSpace, this);
    }
    /**
     * Removing event listener for number format.
     *
     * @hidden
     * @returns {void} - Removing event listener for number format.
     */
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(refreshCellElement, this.refreshCellElement);
            this.parent.off(rowFillHandler, this.rowFillHandler);
            this.parent.off(getTextSpace, this.getTextSpace);
        }
    }
    /**
     * To Remove the event listeners.
     *
     * @returns {void} - To Remove the event listeners.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    /**
     * Get the workbook import module name.
     *
     * @returns {string} - Get the workbook import module name.
     */
    getModuleName() {
        return 'numberFormat';
    }
}

/**
 * `Sort` module is used to handle the sort action in Spreadsheet.
 */
class Sort {
    /**
     * Constructor for sort module.
     *
     * @param {Spreadsheet} parent - Specifies the Spreadsheet instance.
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * To destroy the sort module.
     *
     * @returns {void}
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(applySort, this.applySortHandler, this);
        this.parent.on(sortComplete, this.sortCompleteHandler, this);
        this.parent.on(initiateCustomSort, this.initiateCustomSortHandler, this);
        this.parent.on(sortImport, this.sortImport, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(applySort, this.applySortHandler);
            this.parent.off(sortComplete, this.sortCompleteHandler);
            this.parent.off(initiateCustomSort, this.initiateCustomSortHandler);
            this.parent.off(sortImport, this.sortImport);
        }
    }
    /**
     * Gets the module name.
     *
     * @returns {string} - Gets the module name.
     */
    getModuleName() {
        return 'sort';
    }
    /**
     * Validates the range and returns false when invalid.
     *
     * @returns {boolean} - Validates the range and returns false when invalid.
     */
    isValidSortRange() {
        const sheet = this.parent.getActiveSheet();
        const range = getSwapRange(getIndexesFromAddress(sheet.selectedRange));
        if (range[0] > sheet.usedRange.rowIndex || range[1] > sheet.usedRange.colIndex) {
            return false;
        }
        return true;
    }
    /**
     * sort while importing.
     *
     * @param {any} args - Specifies the args
     * @param {number} args.sheetIdx - Specifies the sheet index
     * @returns {void}
     */
    sortImport(args) {
        const sort = this.parent.sortCollection;
        let cell;
        const rowId = this.parent.getActiveSheet().usedRange.rowIndex - 1;
        const sheetIdx = args ? args.sheetIdx : this.parent.activeSheetIndex;
        for (let j = 0; j < sort.length; j++) {
            if (sort[j].sheetIndex === sheetIdx) {
                for (let i = 0; i < rowId; i++) {
                    cell = this.parent.getCell(i, sort[j].columnIndex);
                    if (cell && cell.querySelector('.e-filter-icon')) {
                        if (sort[j].order === 'Ascending' || sort[j].order === 'OnTop') {
                            if (!cell.querySelector('.e-filter-icon').classList.contains('e-sortasc-filter')) {
                                cell.querySelector('.e-filter-icon').classList.add('e-sortasc-filter');
                            }
                        }
                        else {
                            if (!cell.querySelector('.e-filter-icon').classList.contains('e-sortdesc-filter')) {
                                cell.querySelector('.e-filter-icon').classList.add('e-sortdesc-filter');
                            }
                        }
                        return;
                    }
                }
            }
        }
    }
    /**
     * Shows the range error alert dialog.
     *
     * @param {object} args - specify the args
     * @param {string} args.error - range error string.
     * @returns {void}
     */
    sortRangeAlertHandler(args) {
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        const l10n = this.parent.serviceLocator.getService(locale);
        dialogInst.show({
            height: 180, width: 400, isModal: true, showCloseIcon: true,
            content: args.error,
            beforeOpen: (openArgs) => {
                const dlgArgs = {
                    dialogName: args.error === l10n.getConstant('MultiRangeSortError') ? 'MultiRangeSortDialog' : 'SortRangeDialog',
                    content: args.error,
                    element: openArgs.element, target: openArgs.target, cancel: openArgs.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    openArgs.cancel = true;
                }
                else {
                    dialogInst.dialogInstance.content = dlgArgs.content;
                    focus(this.parent.element);
                }
            }
        });
        this.parent.hideSpinner();
    }
    /**
     * Initiates the custom sort dialog.
     *
     * @returns {void}
     */
    initiateCustomSortHandler() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const sheet = this.parent.getActiveSheet();
        if (!this.isValidSortRange() || sheet.rows.length === 0) {
            this.sortRangeAlertHandler({ error: l10n.getConstant('SortOutOfRangeError') });
            return;
        }
        if (isDiscontinuousRange(sheet.selectedRange)) {
            this.sortRangeAlertHandler({ error: l10n.getConstant('MultiRangeSortError') });
            return;
        }
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        let sortOptions;
        dialogInst.show({
            height: 400, width: 560, isModal: true, showCloseIcon: true, cssClass: 'e-customsort-dlg',
            header: l10n.getConstant('CustomSort'),
            beforeOpen: (args) => {
                const dlgArgs = {
                    dialogName: 'CustomSortDialog',
                    element: args.element, target: args.target, cancel: args.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    args.cancel = true;
                }
                else {
                    dialogInst.dialogInstance.content = this.customSortContent();
                    dialogInst.dialogInstance.dataBind();
                    focus(this.parent.element);
                }
            },
            buttons: [{
                    buttonModel: { content: l10n.getConstant('Ok'), isPrimary: true },
                    click: () => {
                        const element = dialogInst.dialogInstance.content;
                        const listview = getComponent(element.getElementsByClassName('e-list-sort e-listview e-lib')[0], 'listview');
                        const data = listview.dataSource;
                        this.clearError();
                        const errorElem = element.getElementsByClassName('e-sort-error')[0];
                        errorElem.style.display = 'block';
                        if (!this.validateError(data, element, errorElem)) {
                            sortOptions = { sortDescriptors: data, containsHeader: element.getElementsByClassName('e-sort-checkheader')[0].checked,
                                caseSensitive: element.getElementsByClassName('e-sort-checkcase')[0].checked };
                            dialogInst.hide();
                        }
                    }
                }],
            close: () => {
                if (sortOptions) {
                    getUpdateUsingRaf(() => this.applySortHandler({ sortOptions: sortOptions }));
                }
            }
        });
    }
    /**
     * Validates the errors of the sort criteria and displays the error.
     *
     * @param {Object} json - listview datasource.
     * @param {HTMLElement} dialogElem - dialog content element.
     * @param {HTMLElement} errorElem - element to display error.
     * @returns {boolean} - Return boolean value.
     */
    validateError(json, dialogElem, errorElem) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const hasEmpty = json.some((element) => element.field.toString() === '');
        if (hasEmpty) {
            Array.prototype.some.call(dialogElem.getElementsByClassName('e-sort-field'), (dropDown) => {
                const hasError = !getComponent(dropDown, 'dropdownlist').value;
                if (hasError) {
                    dropDown.parentElement.classList.add('e-error');
                }
                return hasError; //breaks the loop if only one error added.
            });
            errorElem.innerText = l10n.getConstant('SortEmptyFieldError');
            return true;
        }
        const temp = new Set();
        let duplicateField = '';
        const hasDuplicate = json.some((element) => {
            duplicateField = element.field.toString();
            return temp.size === temp.add(element.field).size;
        });
        let errorField = '';
        if (hasDuplicate) {
            let count = 0;
            Array.prototype.some.call(dialogElem.getElementsByClassName('e-sort-field'), (dropDown) => {
                const dropDownList = getComponent(dropDown, 'dropdownlist');
                if (dropDownList.value === duplicateField) {
                    dropDown.parentElement.classList.add('e-error');
                    errorField = dropDownList.text;
                    count++;
                }
                return count === 2; //breaks the loop when 2 errors added.
            });
            errorElem.innerText = '';
            const errorFieldEle = this.parent.createElement('strong');
            errorFieldEle.innerText = errorField;
            errorElem.appendChild(errorFieldEle);
            errorElem.appendChild(document.createTextNode(l10n.getConstant('SortDuplicateFieldError')));
            return true;
        }
        return false;
    }
    /**
     * Creates all the elements and generates the dialog content element.
     *
     * @returns {HTMLElement} - Returns the dialog element.
     */
    customSortContent() {
        const dialogElem = this.parent.createElement('div', { className: 'e-sort-dialog' });
        const fields = this.getFields();
        const listId = getUniqueID('customSort');
        const listviewObj = this.getCustomListview(listId);
        this.setHeaderTab(dialogElem, listviewObj, fields);
        const contentElem = this.parent.createElement('div', {
            className: 'e-sort-listsection',
            styles: ''
        });
        dialogElem.appendChild(contentElem);
        const listview = this.parent.createElement('div', { className: 'e-list-sort', styles: '' });
        contentElem.appendChild(listview);
        listviewObj.createElement = this.parent.createElement;
        listviewObj.appendTo(listview);
        listview.removeAttribute('tabindex');
        this.renderListItem(listId, listviewObj, true, fields);
        const errorElem = this.parent.createElement('div', { className: 'e-sort-error' });
        dialogElem.appendChild(errorElem);
        return dialogElem;
    }
    /**
     * Gets the fields data from the selected range.
     *
     * @returns {Object} - Gets the fields data from the selected range.
     */
    getFields() {
        const sheet = this.parent.getActiveSheet();
        const range = getSwapRange(getIndexesFromAddress(sheet.selectedRange));
        if (range[0] === range[2] && (range[2] - range[0]) === 0) { //for entire range
            range[0] = 0;
            range[1] = 0;
            range[3] = sheet.usedRange.colIndex;
            const args = { filterRange: [], hasFilter: false };
            this.parent.notify(getFilterRange, args);
            if (args.hasFilter && args.filterRange) {
                range[0] = args.filterRange[0];
            }
        }
        const fields = [];
        let text;
        let value;
        for (range[1]; range[1] <= range[3]; range[1]++) {
            const cell = getCell(range[0], range[1], sheet);
            value = 'Column ' + getColumnHeaderText(range[1] + 1);
            if (cell && cell.value) {
                text = cell.value;
                if (cell.format) {
                    const eventArgs = { formattedText: text, value: text, format: cell.format, rowIndex: range[0],
                        colIndex: range[1] };
                    this.parent.notify(getFormattedCellObject, eventArgs);
                    text = eventArgs.formattedText;
                }
            }
            else {
                text = value;
            }
            fields.push({ text: text, value: value });
        }
        return fields;
    }
    /**
     * Creates the header tab for the custom sort dialog.
     *
     * @param {HTMLElement} dialogElem - dialog content element.
     * @param {ListView} listviewObj - listview instance.
     * @param {Object} fields - fields data.
     * @returns {void} - set header tab.
     */
    setHeaderTab(dialogElem, listviewObj, fields) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const headerTabElement = this.parent.createElement('div', { className: 'e-sort-header' });
        dialogElem.appendChild(headerTabElement);
        const addButton = this.parent.createElement('button', { className: 'e-btn e-sort-addbtn e-flat', attrs: { 'type': 'button' } });
        addButton.innerText = l10n.getConstant('AddColumn');
        const footer = this.parent.element.querySelector('.e-customsort-dlg .e-footer-content');
        footer.insertBefore(addButton, footer.firstElementChild);
        addButton.addEventListener('click', () => {
            if (listviewObj) {
                const listId = getUniqueID('customSort');
                listviewObj.addItem([{ id: listId, text: l10n.getConstant('ThenBy'), field: '', order: 'ascending' }]);
                this.renderListItem(listId, listviewObj, checkHeaderObj.checked, fields, true);
            }
        });
        const checkHeaderObj = new CheckBox({
            label: l10n.getConstant('ContainsHeader'),
            checked: true,
            change: (args) => {
                const fieldsMap = args.checked ? { text: 'text', value: 'value' } : { text: 'value' };
                Array.prototype.forEach.call(dialogElem.getElementsByClassName('e-sort-field e-dropdownlist e-lib'), (dropDown) => {
                    const dropDownListObj = getComponent(dropDown, 'dropdownlist');
                    dropDownListObj.dataSource = null; //reset datasource.
                    dropDownListObj.dataSource = fields;
                    dropDownListObj.fields = fieldsMap;
                    dropDownListObj.dataBind();
                });
            },
            cssClass: 'e-sort-headercheckbox'
        });
        const headerCheckbox = this.parent.createElement('input', {
            className: 'e-sort-checkheader', attrs: { type: 'checkbox' }
        });
        headerTabElement.appendChild(headerCheckbox);
        checkHeaderObj.createElement = this.parent.createElement;
        checkHeaderObj.appendTo(headerCheckbox);
        const checkCaseObj = new CheckBox({
            label: l10n.getConstant('CaseSensitive'),
            checked: false,
            cssClass: 'e-sort-casecheckbox'
        });
        const caseCheckbox = this.parent.createElement('input', {
            className: 'e-sort-checkcase', attrs: { type: 'checkbox' }
        });
        headerTabElement.appendChild(caseCheckbox);
        checkCaseObj.createElement = this.parent.createElement;
        checkCaseObj.appendTo(caseCheckbox);
    }
    /**
     * Creates a listview instance.
     *
     * @param {string} listId - unique id of the list item.
     * @returns {void}
     */
    getCustomListview(listId) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const data = [{ id: listId, text: l10n.getConstant('SortBy'), field: '', order: 'ascending' }];
        enableRipple(false);
        const listviewObj = new ListView({
            dataSource: data,
            fields: { id: 'id' },
            height: '100%',
            /* eslint-disable */
            template: initializeCSPTemplate(function (data) {
                return ('<div class="e-sort-listwrapper">' +
                    `<span class="text">${data.text}</span>` +
                    '<div class="e-sort-row"><div class="e-sort-field"></div>' +
                    '<div class="e-sort-order">' +
                    `<span class="e-sort-ordertxt" style="display:none;">${data.order}</span></div>` +
                    '<span class="e-icons e-sort-delete" tabindex="0"></span></div>');
            }),
            /* eslint-enable */
            cssClass: 'e-sort-template'
        });
        return listviewObj;
    }
    /**
     * Triggers the click event for delete icon.
     *
     * @param {Element} element - current list item element.
     * @param {ListView} listviewObj - listview instance.
     * @returns {void}
     */
    deleteHandler(element, listviewObj) {
        const iconEle = element.getElementsByClassName('e-sort-delete')[0];
        //Event handler to bind the click event for delete icon
        iconEle.addEventListener('click', () => {
            if (element) {
                listviewObj.removeItem(element);
            }
        });
    }
    /**
     * Renders the dropdown and radio button components inside list item.
     *
     * @param {string} id - unique id of the list item.
     * @param {ListView} lvObj - listview instance.
     * @param {boolean} containsHeader - data contains header.
     * @param {string} fields - fields data.
     * @param {boolean} btn - boolean value.
     * @returns {void}
     */
    renderListItem(id, lvObj, containsHeader, fields, btn) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const element = lvObj.element.querySelector('li[data-uid=' + id + ']');
        const fieldsMap = containsHeader ? { text: 'text', value: 'value' } : { text: 'value' };
        const dropDown = element.getElementsByClassName('e-sort-field')[0];
        const dropDownListObj = new DropDownList({
            dataSource: fields,
            width: 'auto',
            cssClass: 'e-sort-field-ddl',
            fields: fieldsMap,
            placeholder: l10n.getConstant('SelectAColumn'),
            change: (args) => {
                if (!args.value) {
                    return;
                }
                Array.prototype.some.call(lvObj.dataSource, (item) => {
                    if (item.id === id) {
                        item.field = args.value.toString().replace('Column ', '');
                    }
                    return item.id === id; //breaks the loop when proper id found
                });
                this.clearError();
            }
        });
        dropDownListObj.createElement = this.parent.createElement;
        dropDownListObj.appendTo(dropDown);
        if (!btn) {
            dropDownListObj.index = 0;
        }
        /* sort ascending radio button */
        const orderRadio = element.getElementsByClassName('e-sort-order')[0];
        const ordertxtElem = orderRadio.getElementsByClassName('e-sort-ordertxt')[0];
        const isAscending = ordertxtElem.innerText.toLocaleLowerCase() === 'ascending';
        const radiobutton = new RadioButton({
            label: l10n.getConstant('SortAscending'),
            name: 'sortAZ_' + id, value: 'ascending', checked: isAscending, cssClass: 'e-sort-radiobutton',
            change: (args) => { this.setRadioBtnValue(lvObj, id, args.value); }
        });
        const radio = this.parent.createElement('input', {
            id: 'orderAsc_' + id, className: 'e-sort-radioasc', styles: '', attrs: { type: 'radio' }
        });
        orderRadio.appendChild(radio);
        radiobutton.createElement = this.parent.createElement;
        radiobutton.appendTo(radio);
        /* sort descending radio button */
        const radiobutton2 = new RadioButton({
            label: l10n.getConstant('SortDescending'),
            name: 'sortAZ_' + id, value: 'descending', checked: !isAscending, cssClass: 'e-sort-radiobutton',
            change: (args) => { this.setRadioBtnValue(lvObj, id, args.value); }
        });
        const radio2 = this.parent.createElement('input', {
            id: 'orderDesc_' + id, className: 'e-sort-radiodesc', styles: '', attrs: { type: 'radio' }
        });
        orderRadio.appendChild(radio2);
        radiobutton2.createElement = this.parent.createElement;
        radiobutton2.appendTo(radio2);
        this.deleteHandler(element, lvObj);
    }
    /**
     * Sets the new value of the radio button.
     *
     * @param {ListView} listviewObj - listview instance.
     * @param {string} id - unique id of the list item.
     * @param {string} value - new value.
     * @returns {void}
     */
    setRadioBtnValue(listviewObj, id, value) {
        if (!value) {
            return;
        }
        Array.prototype.some.call(listviewObj.dataSource, (item) => {
            if (item.id === id) {
                item.order = value;
            }
            return item.id === id; //breaks the loop when proper id found
        });
    }
    /**
     *
     * Clears the error from the dialog.
     *
     * @returns {void}
     */
    clearError() {
        const dialogElem = document.getElementsByClassName('e-sort-dialog')[0];
        const errorElem = dialogElem.getElementsByClassName('e-sort-error')[0];
        if (errorElem.style.display !== 'none' && errorElem.innerHTML !== '') {
            errorElem.style.display = 'none';
            Array.prototype.forEach.call(dialogElem.getElementsByClassName('e-error'), (element) => {
                element.classList.remove('e-error');
            });
        }
    }
    /**
     * Triggers sort events and applies sorting.
     *
     * @param {Object} args - Specifies the args.
     * @param {SortOptions} args.sortOptions - Specifies the sort options.
     * @param {string} args.range - Specifies the range.
     * @param {SortCollectionModel} args.previousSort - Specifies the previous sort collection.
     * @returns {void}
     */
    applySortHandler(args) {
        const sheet = this.parent.getActiveSheet();
        let address = args && args.range || sheet.selectedRange;
        const range = getSwapRange(getIndexesFromAddress(address));
        const sortOptions = args && args.sortOptions || { sortDescriptors: {} };
        let isSingle = range[0] === range[2];
        const eventArgs = { filterRange: [], hasFilter: false, sheetIdx: this.parent.activeSheetIndex };
        this.parent.notify(getFilterRange, eventArgs);
        if (eventArgs.hasFilter && (isSingle ? inRange(eventArgs.filterRange, range[0], range[1]) : (eventArgs.filterRange[0] ===
            range[0] && (this.parent.element.querySelector('.e-selectall.e-highlight') || (range[1] >= eventArgs.filterRange[1] && range[1]
            <= eventArgs.filterRange[3]) || (range[3] >= eventArgs.filterRange[1] && range[3] <= eventArgs.filterRange[3]))))) {
            range[0] = eventArgs.filterRange[0];
            range[1] = eventArgs.filterRange[1];
            range[2] = sheet.usedRange.rowIndex;
            range[3] = sheet.usedRange.colIndex;
            sortOptions.containsHeader = !eventArgs.allowHeaderFilter;
            isSingle = false;
        }
        address = getRangeAddress(range);
        const beforeArgs = { range: address, sortOptions: sortOptions, cancel: false };
        this.parent.trigger(beforeSort, beforeArgs);
        if (beforeArgs.cancel) {
            return;
        }
        this.parent.notify(beginAction, { eventArgs: beforeArgs, action: 'beforeSort' });
        this.parent.showSpinner();
        const promise = new Promise((resolve) => { resolve((() => { })()); });
        const sortArgs = { args: { range: beforeArgs.range, sortOptions: beforeArgs.sortOptions, checkForHeader: isSingle && address !== beforeArgs.range }, promise: promise, previousSort: args && args.previousSort };
        this.parent.notify(initiateSort, sortArgs);
        sortArgs.promise.then((sortArgs) => {
            this.sortCompleteHandler(sortArgs);
            this.parent.trigger(sortComplete, sortArgs);
            this.parent.notify(completeAction, { eventArgs: sortArgs, action: 'sorting' });
            if (document.activeElement.tagName === 'BODY') {
                focus(this.parent.element);
            }
            return Promise.resolve(sortArgs);
        }).catch((error) => {
            this.sortRangeAlertHandler({ error: error });
            return Promise.reject(error);
        });
    }
    /**
     *
     * Invoked when the sort action is completed.
     *
     * @param {SortEventArgs} args - Specifies the range and sort options.
     * @returns {void}
     */
    sortCompleteHandler(args) {
        let sheet;
        let range;
        let sheetIdx = this.parent.activeSheetIndex;
        if (args.range.includes('!')) {
            const lastIndex = args.range.lastIndexOf('!');
            sheetIdx = getSheetIndex(this.parent, args.range.substring(0, lastIndex));
            sheet = getSheet(this.parent, sheetIdx);
            range = getRangeIndexes(args.range.substring(lastIndex + 1));
        }
        else {
            sheet = this.parent.getActiveSheet();
            range = getRangeIndexes(args.range);
        }
        for (let i = range[0]; i <= range[2]; i++) {
            for (let j = range[1]; j <= range[3]; j++) {
                this.parent.notify(workbookFormulaOperation, { action: 'refreshCalculate', rowIndex: i, colIndex: j });
            }
        }
        this.parent.serviceLocator.getService('cell').refreshRange(range, true, true, false, false, isImported(this.parent), undefined, undefined, undefined, true);
        if (sheetIdx === this.parent.activeSheetIndex && sheet.conditionalFormats && sheet.conditionalFormats.length) {
            this.parent.notify(applyCF, { indexes: range });
        }
        this.parent.hideSpinner();
        this.parent.notify(refreshFilterRange, null);
    }
}

/**
 * `Filter` module is used to handle the filter action in Spreadsheet.
 */
class Filter {
    /**
     * Constructor for filter module.
     *
     * @param {Spreadsheet} parent - Specifies the Spreadsheet.
     */
    constructor(parent) {
        this.parent = parent;
        this.filterCollection = new Map();
        this.filterRange = new Map();
        this.filterBtn = parent.createElement('div', { className: 'e-filter-btn e-control e-btn e-lib e-filter-iconbtn e-icon-btn' });
        this.filterBtn.appendChild(parent.createElement('span', { className: 'e-btn-icon e-icons e-filter-icon' }));
        this.addEventListener();
    }
    /**
     * To destroy the filter module.
     *
     * @returns {void} - To destroy the filter module.
     */
    destroy() {
        this.removeEventListener();
        if (this.parent.refreshing && this.filterRange.size) {
            this.parent.filterCollection = [];
            this.filterRange.forEach((_value, sheetIdx) => {
                this.setFilteredCollection({ sheetIdx: sheetIdx, saveJson: { filterCollection: this.parent.filterCollection } });
            });
        }
        this.filterRange = null;
        this.filterCollection = null;
        if (this.filterBtn) {
            this.filterBtn.remove();
        }
        this.filterBtn = null;
        if (this.treeViewObj) {
            this.treeViewObj.destroy();
        }
        this.treeViewObj = null;
        if (this.treeViewEle) {
            this.treeViewEle.remove();
        }
        this.treeViewEle = null;
        if (this.cBox) {
            this.cBox.remove();
            this.cBox = null;
        }
        const filterPopupElement = document.querySelectorAll('.e-filter-popup');
        if (filterPopupElement) {
            filterPopupElement.forEach(function (element) {
                element.remove();
            });
        }
        this.parent = null;
    }
    addEventListener() {
        this.parent.on(filterRangeAlert, this.filterRangeAlertHandler, this);
        this.parent.on(initiateFilterUI, this.initiateFilterUIHandler, this);
        this.parent.on(mouseDown, this.filterMouseDownHandler, this);
        this.parent.on(renderFilterCell, this.renderFilterCellHandler, this);
        this.parent.on(refreshFilterRange, this.refreshFilterRange, this);
        this.parent.on(updateSortCollection, this.updateSortCollectionHandler, this);
        this.parent.on(beforeFltrcMenuOpen, this.beforeFilterMenuOpenHandler, this);
        this.parent.on(filterCmenuSelect, this.closeDialog, this);
        this.parent.on(reapplyFilter, this.reapplyFilterHandler, this);
        this.parent.on(filterByCellValue, this.filterByCellValueHandler, this);
        this.parent.on(clearFilter, this.clearFilterHandler, this);
        this.parent.on(getFilteredColumn, this.getFilteredColumnHandler, this);
        this.parent.on(cMenuBeforeOpen, this.cMenuBeforeOpenHandler, this);
        this.parent.on(filterCboxValue, this.filterCboxValueHandler, this);
        this.parent.on(getFilterRange, this.getFilterRangeHandler, this);
        this.parent.on(filterCellKeyDown, this.filterCellKeyDownHandler, this);
        this.parent.on(setFilteredCollection, this.setFilteredCollection, this);
        this.parent.on(contentLoaded, this.updateFilter, this);
        this.parent.on(beforeInsert, this.beforeInsertHandler, this);
        this.parent.on(beforeDelete, this.beforeDeleteHandler, this);
        this.parent.on(sheetsDestroyed, this.deleteSheetHandler, this);
        this.parent.on(clear, this.clearHandler, this);
        this.parent.on(filterDialogCreated, this.filterDialogCreatedHandler, this);
        this.parent.on(filterDialogClose, this.removeFilterClass, this);
        this.parent.on(duplicateSheetFilterHandler, this.duplicateSheetFilterHandler, this);
        this.parent.on(fltrPrevent, this.beforeFilteringHandler, this);
        this.parent.on(beforeCustomFilterOpen, this.customFilterOpen, this);
        this.parent.on(moveSheetHandler, this.moveSheetHandler, this);
        this.parent.on(refreshFilterCellsOnResize, this.refreshFilterCellsOnResize, this);
    }
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(filterRangeAlert, this.filterRangeAlertHandler);
            this.parent.off(initiateFilterUI, this.initiateFilterUIHandler);
            this.parent.off(mouseDown, this.filterMouseDownHandler);
            this.parent.off(renderFilterCell, this.renderFilterCellHandler);
            this.parent.off(refreshFilterRange, this.refreshFilterRange);
            this.parent.off(updateSortCollection, this.updateSortCollectionHandler);
            this.parent.off(beforeFltrcMenuOpen, this.beforeFilterMenuOpenHandler);
            this.parent.off(filterCmenuSelect, this.closeDialog);
            this.parent.off(reapplyFilter, this.reapplyFilterHandler);
            this.parent.off(filterByCellValue, this.filterByCellValueHandler);
            this.parent.off(clearFilter, this.clearFilterHandler);
            this.parent.off(getFilteredColumn, this.getFilteredColumnHandler);
            this.parent.off(cMenuBeforeOpen, this.cMenuBeforeOpenHandler);
            this.parent.off(filterCboxValue, this.filterCboxValueHandler);
            this.parent.off(getFilterRange, this.getFilterRangeHandler);
            this.parent.off(filterCellKeyDown, this.filterCellKeyDownHandler);
            this.parent.off(setFilteredCollection, this.setFilteredCollection);
            this.parent.off(contentLoaded, this.updateFilter);
            this.parent.off(beforeInsert, this.beforeInsertHandler);
            this.parent.off(beforeDelete, this.beforeDeleteHandler);
            this.parent.off(sheetsDestroyed, this.deleteSheetHandler);
            this.parent.off(clear, this.clearHandler);
            this.parent.off(filterDialogCreated, this.filterDialogCreatedHandler);
            this.parent.off(filterDialogClose, this.removeFilterClass);
            this.parent.off(duplicateSheetFilterHandler, this.duplicateSheetFilterHandler);
            this.parent.off(fltrPrevent, this.beforeFilteringHandler);
            this.parent.off(beforeCustomFilterOpen, this.customFilterOpen);
            this.parent.off(moveSheetHandler, this.moveSheetHandler);
            this.parent.off(refreshFilterCellsOnResize, this.refreshFilterCellsOnResize);
        }
    }
    /**
     * Gets the module name.
     *
     * @returns {string} - Gets the module name.
     */
    getModuleName() {
        return 'filter';
    }
    /**
     * Validates the range and returns false when invalid.
     *
     * @param {SheetModel} sheet - Specify the sheet.
     * @param {string} range - Specify the range.
     * @returns {void} - Validates the range and returns false when invalid.
     */
    isInValidFilterRange(sheet, range) {
        const selectedRange = range ? getSwapRange(getIndexesFromAddress(range)) :
            getSwapRange(getIndexesFromAddress(sheet.selectedRange));
        let isEmptySheet = false;
        if (sheet.usedRange.colIndex === 0 && sheet.usedRange.rowIndex === 0 && isNullOrUndefined(sheet.rows[sheet.usedRange.rowIndex])) {
            isEmptySheet = true; // For Filtering Empty sheet's A1 cell.
        }
        return selectedRange[0] > sheet.usedRange.rowIndex || selectedRange[1] > sheet.usedRange.colIndex || isEmptySheet;
    }
    /**
     * Shows the range error alert dialog.
     *
     * @param {any} args - Specifies the args
     * @param {string} args.error - range error string.
     * @returns {void} - Shows the range error alert dialog.
     */
    filterRangeAlertHandler(args) {
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        dialogInst.show({
            content: args.error, isModal: true,
            height: 180, width: 400, showCloseIcon: true,
            beforeOpen: (args) => {
                const dlgArgs = {
                    dialogName: 'FilterRangeDialog',
                    element: args.element, target: args.target, cancel: args.cancel
                };
                this.parent.trigger('dialogBeforeOpen', dlgArgs);
                if (dlgArgs.cancel) {
                    args.cancel = true;
                }
                else {
                    focus(this.parent.element);
                }
            }
        });
        this.parent.hideSpinner();
    }
    /**
     * Triggers before filter context menu opened and used to add sorting items.
     *
     * @param {any} args - Specifies the args
     * @param {HTMLElement} args.element - Specify the element
     * @returns {void} - Triggers before filter context menu opened and used to add sorting items.
     */
    beforeFilterMenuOpenHandler(args) {
        const l10n = this.parent.serviceLocator.getService(locale);
        args.element.classList.add('e-spreadsheet-contextmenu'); // to show sort icons
        const ul = args.element.querySelector('ul');
        this.addMenuItem(ul, l10n.getConstant('SortDescending'), 'e-filter-sortdesc', 'e-sort-desc');
        this.addMenuItem(ul, l10n.getConstant('SortAscending'), 'e-filter-sortasc', 'e-sort-asc');
        args.element.appendChild(ul);
    }
    /**
     * Creates new menu item element
     *
     * @param {Element} ul - Specify the element.
     * @param {string} text - Specify the text.
     * @param {string} className - Specify the className
     * @param {string} iconCss - Specify the iconCss
     * @returns {void} - Creates new menu item element
     */
    addMenuItem(ul, text, className, iconCss) {
        const li = this.parent.createElement('li', { className: className + ' e-menu-item' });
        if (!this.parent.allowSorting) {
            li.classList.add('e-disabled');
        }
        li.innerText = text;
        li.insertBefore(this.parent.createElement('span', { className: 'e-menu-icon e-icons ' + iconCss }), li.firstChild);
        ul.insertBefore(li, ul.firstChild);
    }
    /**
     * Initiates the filter UI for the selected range.
     *
     * @param {any} args - Specifies the args
     * @param {PredicateModel[]} args.predicates - Specify the predicates.
     * @param {number} args.range - Specify the range.
     * @param {Promise<FilterEventArgs>} args.promise - Spefify the promise.
     * @param {number} args.sIdx - Specify the sIdx
     * @param {boolean} args.isCut - Specify the bool value
     * @param {boolean} args.isUndoRedo - Specify the bool value
     * @param {boolean} args.isInternal - Specify the isInternal.
     * @param {boolean} args.useFilterRange - Specify the use Filter Range.
     * @param {boolean} args.isOpen - Specify the isOpen.
     * @param {boolean} args.allowHeaderFilter - Specify the allow header filter.
     * @returns {void} - Initiates the filter UI for the selected range.
     */
    initiateFilterUIHandler(args) {
        const predicates = args ? args.predicates : null;
        let sheetIdx = args.sIdx;
        if (!sheetIdx && sheetIdx !== 0) {
            sheetIdx = args.isOpen ? 0 : this.parent.activeSheetIndex;
        }
        let deferred;
        if (args.promise) {
            deferred = new Deferred();
            args.promise = deferred.promise;
        }
        const resolveFn = () => {
            if (deferred) {
                deferred.resolve();
            }
        };
        const isInternal = args.isInternal || args.isCut;
        if (this.filterRange.size > 0 && this.filterRange.has(sheetIdx) && !this.parent.isOpen && !predicates) { //disable filter
            this.removeFilter(sheetIdx, isInternal, false);
            resolveFn();
            return;
        }
        const sheet = getSheet(this.parent, sheetIdx);
        if (this.isInValidFilterRange(sheet, args.range)) {
            const l10n = this.parent.serviceLocator.getService(locale);
            this.filterRangeAlertHandler({ error: l10n.getConstant('FilterOutOfRangeError') });
            resolveFn();
            return;
        }
        let selectedRange = args.range || sheet.selectedRange;
        let eventArgs;
        let actionArgs;
        if (!isInternal) {
            eventArgs = { range: selectedRange, sheetIndex: sheetIdx, cancel: false, allowHeaderFilter: false };
            if (args.predicates) {
                eventArgs.predicates = args.predicates;
                eventArgs.previousPredicates = this.filterCollection.get(sheetIdx) && [].slice.call(this.filterCollection.get(sheetIdx));
            }
            else {
                eventArgs.filterOptions = { predicates: args.predicates };
            }
            eventArgs.useFilterRange = false;
            actionArgs = { action: 'filter', eventArgs: eventArgs };
            this.parent.notify(beginAction, actionArgs);
            if (eventArgs.cancel) {
                resolveFn();
                return;
            }
            delete eventArgs.cancel;
            args.useFilterRange = eventArgs.useFilterRange;
            args.allowHeaderFilter = eventArgs.allowHeaderFilter;
        }
        if (!args.range && (isInternal || selectedRange === eventArgs.range)) {
            let rangeIdx = getRangeIndexes(selectedRange);
            if (rangeIdx[0] === rangeIdx[2] && rangeIdx[1] === rangeIdx[3]) {
                rangeIdx = getDataRange(rangeIdx[0], rangeIdx[1], sheet);
                selectedRange = getRangeAddress(rangeIdx);
                if (!isInternal) {
                    eventArgs.range = selectedRange;
                }
            }
        }
        else if (!isInternal) {
            selectedRange = eventArgs.range;
        }
        if (predicates) {
            if (predicates.length) {
                const filterRange = this.filterRange.get(sheetIdx);
                if (filterRange) {
                    args.useFilterRange = filterRange.useFilterRange;
                    args.allowHeaderFilter = filterRange.allowHeaderFilter;
                }
                this.processRange(sheet, sheetIdx, selectedRange, true, args.useFilterRange, args.allowHeaderFilter);
                const range = this.filterRange.get(sheetIdx).range.slice();
                if (!args.allowHeaderFilter) {
                    range[0] = range[0] + 1; // to skip first row.
                }
                if (!args.useFilterRange) {
                    range[2] = sheet.usedRange.rowIndex; //filter range should be till used range.
                }
                range[1] = range[3] = getColIndex(predicates[0].field);
                const addr = `${sheet.name}!${this.getPredicateRange(range, predicates.slice(1, predicates.length))}`;
                const fullAddr = getRangeAddress(range);
                getData(this.parent, addr, true, true, null, true, null, null, false, fullAddr).then((jsonData) => {
                    this.filterSuccessHandler(new DataManager(jsonData), { action: 'filtering', filterCollection: predicates, field: predicates[0].field, sIdx: args.sIdx,
                        isInternal: isInternal, isOpen: args.isOpen, prevPredicates: eventArgs && eventArgs.previousPredicates });
                    resolveFn();
                });
                return;
            }
            else {
                this.clearFilterHandler({ sheetIndex: sheetIdx });
                resolveFn();
            }
        }
        else {
            this.processRange(sheet, sheetIdx, selectedRange, false, args.useFilterRange, args.allowHeaderFilter);
            resolveFn();
        }
        if (!isInternal) {
            this.parent.notify(completeAction, actionArgs);
            focus(this.parent.element);
        }
    }
    /**
     * Processes the range if no filter applied.
     *
     * @param {SheetModel} sheet - Specify the sheet.
     * @param {number} sheetIdx - Specify the sheet index.
     * @param {string} filterRange - Specify the filterRange.
     * @param {boolean} preventRefresh - To prevent refreshing the filter buttons.
     * @param {boolean} useFilterRange - Specifies whether to consider filtering range or used range during filering.
     * @param {boolean} allowHeaderFilter - Specifies whether to consider first row during filtering.
     * @returns {void} - Processes the range if no filter applied.
     */
    processRange(sheet, sheetIdx, filterRange, preventRefresh, useFilterRange, allowHeaderFilter) {
        const range = getSwapRange(getIndexesFromAddress(filterRange || sheet.selectedRange));
        if (range[0] === range[2] && range[1] === range[3]) { //if selected range is a single cell
            range[0] = 0;
            range[1] = 0;
            range[2] = sheet.usedRange.rowIndex;
            range[3] = sheet.usedRange.colIndex;
        }
        else if (range[3] > sheet.usedRange.colIndex) {
            range[3] = sheet.usedRange.colIndex;
        }
        const filterOption = { useFilterRange: useFilterRange,
            range: range };
        if (allowHeaderFilter) {
            filterOption.allowHeaderFilter = allowHeaderFilter;
        }
        this.filterRange.set(sheetIdx, filterOption);
        this.filterCollection.set(sheetIdx, []);
        if (!preventRefresh) {
            this.refreshFilterRange(range, false, sheetIdx);
        }
    }
    /**
     * Removes all the filter related collections for the active sheet.
     *
     * @param {number} sheetIdx - Specify the sheet index.
     * @param {boolean} isCut - Specify the bool value.
     * @param {boolean} preventRefresh - Specify the preventRefresh.
     * @param {boolean} clearAction - Specify the current action is clear or not.
     * @returns {void} - Removes all the filter related collections for the active sheet.
     */
    removeFilter(sheetIdx, isCut, preventRefresh, clearAction) {
        const filterOption = this.filterRange.get(sheetIdx);
        const range = filterOption.range.slice();
        const allowHeaderFilter = filterOption.allowHeaderFilter;
        const rangeAddr = getRangeAddress(range);
        let args;
        if (!isCut) {
            args = { action: 'filter', eventArgs: { range: rangeAddr, sheetIndex: sheetIdx, cancel: false }, isClearAction: clearAction };
            this.parent.notify(beginAction, args);
            if (args.eventArgs.cancel) {
                return;
            }
            delete args.eventArgs.cancel;
        }
        if (this.filterCollection.get(sheetIdx).length || preventRefresh) {
            if (this.filterCollection.get(sheetIdx).length && clearAction) {
                const newArgs = {
                    action: 'filter',
                    eventArgs: {
                        range: rangeAddr, sheetIndex: sheetIdx, predicates: [], previousPredicates: this.filterCollection.get(sheetIdx)
                    }, isClearAction: clearAction
                };
                this.parent.notify(completeAction, newArgs);
            }
            this.clearFilterHandler({ preventRefresh: preventRefresh, sheetIndex: sheetIdx });
        }
        this.filterRange.delete(sheetIdx);
        this.filterCollection.delete(sheetIdx);
        this.refreshFilterRange(range, true, sheetIdx, allowHeaderFilter);
        if (!isCut) {
            this.parent.notify(completeAction, args);
        }
    }
    /**
     * Handles filtering cell value based on context menu.
     *
     * @returns {void} - Handles filtering cell value based on context menu.
     */
    filterByCellValueHandler() {
        const sheetIdx = this.parent.activeSheetIndex;
        const sheet = this.parent.getActiveSheet();
        if (this.isInValidFilterRange(sheet)) {
            const l10n = this.parent.serviceLocator.getService(locale);
            this.filterRangeAlertHandler({ error: l10n.getConstant('FilterOutOfRangeError') });
            return;
        }
        const cell = getRangeIndexes(sheet.activeCell);
        let isNotFilterRange;
        if (!this.isFilterRange(sheetIdx, cell[0], cell[1])) {
            isNotFilterRange = true;
            this.processRange(sheet, sheetIdx);
        }
        const filterOption = this.filterRange.get(sheetIdx);
        const range = filterOption.range.slice();
        const filterRange = getRangeAddress(range);
        range[0] = range[0] + 1; // to skip first row.
        range[2] = sheet.usedRange.rowIndex; //filter range should be till used range.
        range[1] = range[3] = cell[1];
        const field = getColumnHeaderText(cell[1] + 1);
        const selectedCell = getCell(cell[0], cell[1], sheet);
        const cellVal = getValueFromFormat(this.parent, selectedCell, cell[0], cell[1]);
        const predicates = [{ field: field, operator: 'equal', type: this.getColumnType(sheet, cell[1], cell).type,
                matchCase: false, value: cellVal }];
        let prevPredicates = [].slice.call(this.filterCollection.get(sheetIdx));
        if (!prevPredicates.length) {
            prevPredicates = undefined;
        }
        const eventArgs = { range: filterRange, predicates: predicates,
            previousPredicates: prevPredicates, sheetIndex: sheetIdx, cancel: false, allowHeaderFilter: false };
        this.parent.notify(beginAction, { action: 'filter', eventArgs: eventArgs });
        if (eventArgs.cancel) {
            if (isNotFilterRange) {
                this.removeFilter(sheetIdx, true);
            }
            return;
        }
        if (eventArgs.allowHeaderFilter) {
            filterOption.allowHeaderFilter = eventArgs.allowHeaderFilter;
            range[0]--;
        }
        const addr = `${sheet.name}!${this.getPredicateRange(range, this.filterCollection.get(sheetIdx))}`;
        const fullAddr = getRangeAddress(range);
        getData(this.parent, addr, true, true, null, true, null, null, false, fullAddr).then((jsonData) => {
            this.filterSuccessHandler(new DataManager(jsonData), { action: 'filtering', filterCollection: predicates, field: field, isFilterByValue: true });
        });
    }
    /**
     * Creates filter buttons and renders the filter applied cells.
     *
     * @param { any} args - Specifies the args
     * @param { HTMLElement} args.td - specify the element
     * @param { number} args.rowIndex - specify the rowIndex
     * @param { number} args.colIndex - specify the colIndex
     * @param { number} args.sIdx - specify the sIdx
     * @param { boolean} args.isAction - specify the apply filter action.
     * @returns {void} - Creates filter buttons and renders the filter applied cells.
     */
    renderFilterCellHandler(args) {
        const sheetIdx = !isNullOrUndefined(args.sIdx) ? args.sIdx : this.parent.activeSheetIndex;
        if (sheetIdx === this.parent.activeSheetIndex) {
            const option = this.filterRange.get(sheetIdx) &&
                this.filterRange.get(sheetIdx);
            const range = option && option.range;
            if (range && (range[0] === args.rowIndex || option.allowHeaderFilter) && range[1] <= args.colIndex &&
                range[3] >= args.colIndex) {
                if (!args.td || args.td.classList.contains(option.allowHeaderFilter ? 'e-cell' : 'e-header-cell')) {
                    return;
                }
                let filterButton = args.td.querySelector('.e-filter-icon');
                let filterSortCls = '';
                const sortCollection = this.parent.sortCollection;
                const field = getColumnHeaderText(args.colIndex + 1);
                const predicates = this.filterCollection.get(sheetIdx);
                for (let i = 0; i < predicates.length; i++) {
                    if (predicates[i].field === field) {
                        filterSortCls = ' e-filtered';
                        break;
                    }
                }
                if (sortCollection) {
                    for (let i = 0; i < sortCollection.length; i++) {
                        if (sortCollection[i].sheetIndex === sheetIdx &&
                            sortCollection[i].columnIndex === args.colIndex) {
                            filterSortCls += sortCollection[i].order === 'Ascending' ? ' e-sortasc-filter' : ' e-sortdesc-filter';
                            break;
                        }
                    }
                }
                if (filterButton) {
                    filterButton.className = `e-btn-icon e-icons e-filter-icon${filterSortCls}`;
                }
                else {
                    let isNoteAvailable = false;
                    filterButton = this.filterBtn.cloneNode(true);
                    if (args.td.children.length > 0 && args.td.children[args.td.childElementCount - 1].className.indexOf('e-addNoteIndicator') > -1) {
                        args.td.removeChild(args.td.children[args.td.childElementCount - 1]);
                        isNoteAvailable = true;
                    }
                    filterButton.firstElementChild.className = `e-btn-icon e-icons e-filter-icon${filterSortCls}`;
                    args.td.insertBefore(filterButton, args.td.firstChild);
                    if (args.isAction) {
                        const sheet = getSheet(this.parent, sheetIdx);
                        if (getCell(args.rowIndex, args.colIndex, sheet, false, true).wrap) {
                            this.parent.notify(updateWrapCell, { rowIdx: args.rowIndex, colIdx: args.colIndex, sheet: sheet, ele: args.td });
                        }
                    }
                    if (isNoteAvailable) {
                        this.parent.notify(createNoteIndicator, { targetElement: args.td, rowIndex: args.rowIndex, columnIndex: args.colIndex });
                    }
                }
            }
        }
    }
    /**
     * Refreshes the filter header range.
     *
     * @param {number[]} filterRange - Specify the filterRange.
     * @param {boolean} remove - Specify the bool value
     * @param {number} sIdx - Specify the index.
     * @param {boolean} allowHeaderFilter - Specifies whether to consider first row during filtering.
     * @returns {void} - Refreshes the filter header range.
     */
    refreshFilterRange(filterRange, remove, sIdx, allowHeaderFilter) {
        let sheetIdx = sIdx;
        if (!sheetIdx && sheetIdx !== 0) {
            sheetIdx = this.parent.activeSheetIndex;
        }
        const filterOption = this.filterRange && this.filterRange.get(sheetIdx);
        if (!filterOption) {
            if (!filterRange) {
                filterRange = [0, 0, 0, 0];
            }
        }
        else {
            filterRange = filterRange || filterOption.range.slice();
            allowHeaderFilter = filterOption.allowHeaderFilter;
        }
        const range = filterRange;
        let cell;
        const sheet = getSheet(this.parent, sheetIdx);
        const frozenCol = this.parent.frozenColCount(sheet);
        for (let index = range[1]; index <= range[3]; index++) {
            if (allowHeaderFilter) {
                const table = index < frozenCol ? this.parent.sheetModule.getSelectAllTable() :
                    this.parent.getColHeaderTable();
                const headerRow = table && this.parent.getRow(0, table);
                cell = headerRow && this.parent.getCell(0, index, headerRow);
            }
            else {
                if (!isHiddenRow(sheet, range[0])) {
                    cell = this.parent.getCell(range[0], index);
                }
                else {
                    cell = null;
                }
            }
            if (remove) {
                if (cell) {
                    const filterBtn = cell.querySelector('.e-filter-btn');
                    if (filterBtn) {
                        let isNoteAvailable = false;
                        if (cell.children.length > 0 && cell.children[cell.childElementCount - 1].className.indexOf('e-addNoteIndicator') > -1) {
                            cell.removeChild(cell.children[cell.childElementCount - 1]);
                            isNoteAvailable = true;
                        }
                        filterBtn.parentElement.removeChild(filterBtn);
                        if (isNoteAvailable) {
                            this.parent.notify(createNoteIndicator, { targetElement: cell, rowIndex: range[0], columnIndex: index });
                        }
                    }
                }
            }
            else {
                this.renderFilterCellHandler({ td: cell, rowIndex: range[0], colIndex: index, sIdx: sheetIdx, isAction: true });
            }
        }
        if (this.parent.sortCollection) {
            this.parent.notify(sortImport, null);
        }
    }
    /**
     * Checks whether the provided cell is a filter cell.
     *
     * @param {number} sheetIdx - Specify the sheet index.
     * @param {number} rowIndex - Specify the row index
     * @param {number} colIndex - Specify the col index.
     * @returns {boolean} - Checks whether the provided cell is a filter cell.
     */
    isFilterCell(sheetIdx, rowIndex, colIndex) {
        const range = this.filterRange.has(sheetIdx) && this.filterRange.get(sheetIdx).range;
        return (range && range[0] === rowIndex && range[1] <= colIndex && range[3] >= colIndex);
    }
    /**
     * Checks whether the provided cell is in a filter range
     *
     * @param {number} sheetIdx - Specify the sheet index.
     * @param {number} rowIndex - Specify the row index
     * @param {number} colIndex - Specify the col index.
     * @returns {boolean} - Checks whether the provided cell is in a filter range
     */
    isFilterRange(sheetIdx, rowIndex, colIndex) {
        const range = this.filterRange.get(sheetIdx) && this.filterRange.get(sheetIdx).range;
        return (range && range[0] <= rowIndex && range[2] >= rowIndex && range[1] <= colIndex && range[3] >= colIndex);
    }
    /**
     * Gets the filter information from active cell
     *
     * @param {any} args - Specifies the args
     * @param {string} args.field - Specify the field
     * @param {string} args.clearFilterText - Specify the clearFilterText
     * @param {boolean} args.isFiltered - Specify the isFiltered
     * @param {boolean} args.isClearAll - Specify the isClearAll
     * @param {number} args.sheetIndex - Specify the sheet index value.
     * @returns {void} - Triggers before context menu created to enable or disable items.
     */
    getFilteredColumnHandler(args) {
        const sheetIdx = isUndefined$1(args.sheetIndex) ? this.parent.activeSheetIndex : args.sheetIndex;
        const l10n = this.parent.serviceLocator.getService(locale);
        args.clearFilterText = l10n.getConstant('ClearFilter');
        if (this.filterRange.has(sheetIdx)) {
            const filterCollection = this.filterCollection.get(sheetIdx);
            if (args.isClearAll) {
                args.isFiltered = filterCollection && filterCollection.length > 0;
                return;
            }
            const range = this.filterRange.get(sheetIdx).range.slice();
            const sheet = getSheet(this.parent, sheetIdx);
            const cell = getCellIndexes(sheet.activeCell);
            if (this.isFilterRange(sheetIdx, cell[0], cell[1])) {
                args.field = getColumnHeaderText(cell[1] + 1);
                const headerCell = getCell(range[0], cell[1], sheet);
                const cellValue = this.parent.getDisplayText(headerCell);
                args.clearFilterText = l10n.getConstant('ClearFilterFrom') + '"'
                    + (cellValue ? cellValue.toString() : 'Column ' + args.field) + '"';
                filterCollection.some((value) => {
                    args.isFiltered = value.field === args.field;
                    return args.isFiltered;
                });
            }
        }
    }
    /**
     * Triggers before context menu created to enable or disable items.
     *
     * @param {any} e - Specifies the args
     * @param {HTMLElement} e.element - Specify the element
     * @param {MenuItemModel[]} e.items - Specify the items
     * @param {MenuItemModel} e.parentItem - Specify the parentItem
     * @param {string} e.target - Specify the target
     * @returns {void} - Triggers before context menu created to enable or disable items.
     */
    cMenuBeforeOpenHandler(e) {
        const id = this.parent.element.id + '_cmenu';
        if (e.parentItem && e.parentItem.id === id + '_filter' && e.target === '') {
            const args = { isFiltered: false };
            this.getFilteredColumnHandler(args);
            this.parent.enableContextMenuItems([id + '_clearfilter', id + '_reapplyfilter'], !!args.isFiltered, true);
        }
    }
    /**
     * Closes the filter popup.
     *
     * @returns {void} - Closes the filter popup.
     */
    closeDialog() {
        const filterPopup = document.querySelector('.e-filter-popup');
        if (filterPopup && filterPopup.id.includes(this.parent.element.id)) {
            const excelFilter = getComponent(filterPopup, 'dialog');
            EventHandler.remove(filterPopup, getStartEvent(), this.filterMouseDownHandler);
            if (excelFilter) {
                excelFilter.hide();
            }
            this.parent.notify(filterDialogClose, null);
        }
    }
    removeFilterClass() {
        if (this.parent.element.style.position === 'relative') {
            this.parent.element.style.position = '';
        }
        if (this.parent.element.classList.contains('e-filter-open')) {
            this.parent.element.classList.remove('e-filter-open');
        }
    }
    /**
     * Returns true if the filter popup is opened.
     *
     * @returns {boolean} - Returns true if the filter popup is opened.
     */
    isPopupOpened() {
        const filterPopup = document.getElementsByClassName('e-filter-popup')[0];
        return filterPopup && filterPopup.id.includes(this.parent.element.id) && filterPopup.style.display !== 'none';
    }
    filterCellKeyDownHandler(args) {
        const sheet = this.parent.getActiveSheet();
        const indexes = getCellIndexes(sheet.activeCell);
        if (this.isFilterCell(this.parent.activeSheetIndex, indexes[0], indexes[1])) {
            if (args.closePopup) {
                this.closeDialog();
            }
            else {
                args.isFilterCell = true;
                if (!this.isPopupOpened()) {
                    const target = this.parent.getCell(indexes[0], indexes[1]);
                    if (target) {
                        this.openDialog(target);
                    }
                }
            }
        }
    }
    filterMouseDownHandler(e) {
        if ((Browser.isDevice && e.type === 'mousedown') || this.parent.getActiveSheet().isProtected) {
            return;
        }
        const target = e.target;
        if (target.classList.contains('e-filter-icon') || target.classList.contains('e-filter-btn')) {
            if (this.isPopupOpened()) {
                this.closeDialog();
            }
            this.openDialog((parentsUntil(target, 'e-cell') || parentsUntil(target, 'e-header-cell')));
        }
        else if (this.isPopupOpened()) {
            const offsetEle = target.offsetParent;
            if (!target.classList.contains('e-searchinput') && !target.classList.contains('e-searchclear') && (offsetEle &&
                !offsetEle.classList.contains('e-filter-popup') && !offsetEle.classList.contains('e-text-content') &&
                !offsetEle.classList.contains('e-checkboxtree') && !offsetEle.classList.contains('e-checkbox-wrapper'))) {
                this.closeDialog();
            }
            else {
                this.selectSortItemHandler(target);
            }
        }
    }
    cboxListSelected(args, selectedList, listCount, e, searched) {
        const wrapper = parentsUntil(e.target, 'e-ftrchk');
        if (wrapper) {
            const addCurCbox = searched && wrapper.querySelector('.e-add-current');
            if (addCurCbox) {
                if (addCurCbox.classList.contains('e-check')) {
                    classList(addCurCbox, ['e-uncheck'], ['e-check']);
                    if (!selectedList.length) {
                        args.btnObj.element.disabled = true;
                    }
                    return false;
                }
                else {
                    classList(addCurCbox, ['e-check'], ['e-uncheck']);
                    args.btnObj.element.disabled = false;
                    return true;
                }
            }
            let selectAll = wrapper.querySelector('.e-selectall');
            if (selectAll) {
                wrapper.querySelector('.e-chk-hidden').indeterminate = false;
                const uncheck = wrapper.querySelector('.e-frame').classList.contains('e-check');
                let checkBoxFrame;
                let text;
                for (let idx = searched ? 2 : 1, len = args.element.childElementCount; idx < len; idx++) {
                    checkBoxFrame = args.element.children[idx].querySelector('.e-frame');
                    removeClass([checkBoxFrame], ['e-check', 'e-stop', 'e-uncheck']);
                    if (uncheck) {
                        args.element.children[idx].querySelector('.e-chk-hidden').checked = false;
                        checkBoxFrame.classList.add('e-uncheck');
                        selectedList.splice(0, 1);
                    }
                    else {
                        args.element.children[idx].querySelector('.e-chk-hidden').checked = true;
                        checkBoxFrame.classList.add('e-check');
                        text = args.element.children[idx].querySelector('.e-checkboxfiltertext').textContent;
                        if (selectedList.indexOf(text) === -1) {
                            selectedList.push(text);
                        }
                    }
                }
            }
            else {
                const text = wrapper.querySelector('.e-checkboxfiltertext').textContent;
                if (wrapper.querySelector('.e-frame').classList.contains('e-check')) {
                    selectedList.splice(selectedList.indexOf(text), 1);
                }
                else {
                    selectedList.push(text);
                }
                toogleCheckbox(wrapper);
                selectAll = args.element.querySelector('.e-selectall');
            }
            this.updateState(args, selectAll, selectAll.parentElement.querySelector('.e-chk-hidden'), selectedList.length !== listCount, selectedList.length);
        }
        return null;
    }
    initCboxList(args, excelFilter, filterData) {
        const field = args.column.field;
        const sortedData = new DataManager(args.dataSource).executeLocal(new Query().sortBy(field + '_value', 'ascending'));
        const listData = [];
        const sheet = this.parent.getActiveSheet();
        const l10n = this.parent.serviceLocator.getService(locale);
        let cBoxFrag = document.createDocumentFragment();
        const selectAll = this.createSelectAll(args, excelFilter);
        cBoxFrag.appendChild(selectAll);
        let idCol = {};
        let hidden;
        let initSelectedList = [];
        let selectedList = [];
        let dataVal;
        sortedData.forEach((data) => {
            if (data[field] === '') {
                if (!idCol['isBlank']) {
                    idCol['isBlank'] = true;
                    const blankObj = {};
                    blankObj[field] = l10n.getConstant('Blanks');
                    hidden = isFilterHidden(sheet, Number(data['__rowIndex']) - 1);
                    const blankCbox = createCboxWithWrap(
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    getUid('cbox'), excelFilter.createCheckbox(blankObj[field], !hidden, blankObj), 'e-ftrchk');
                    if (cBoxFrag.childElementCount === 1) {
                        cBoxFrag.appendChild(blankCbox);
                    }
                    else {
                        cBoxFrag.insertBefore(blankCbox, cBoxFrag.children[1]);
                    }
                    listData.splice(0, 0, blankObj[field]);
                    if (!hidden) {
                        initSelectedList.push(blankObj[field]);
                        selectedList.push(blankObj[field]);
                    }
                }
            }
            else if (!idCol[data[field]]) {
                idCol[data[field]] = true;
                hidden = isFilterHidden(sheet, Number(data['__rowIndex']) - 1);
                dataVal = data[field];
                cBoxFrag.appendChild(
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                createCboxWithWrap(getUid('cbox'), excelFilter.createCheckbox(dataVal, !hidden, data), 'e-ftrchk'));
                listData.push(dataVal);
                if (!hidden) {
                    initSelectedList.push(dataVal);
                    selectedList.push(dataVal);
                }
            }
        });
        args.element.appendChild(cBoxFrag);
        const cBoxFrame = selectAll.querySelector('.e-frame');
        cBoxFrame.classList.add('e-selectall');
        const cBox = selectAll.querySelector('.e-chk-hidden');
        this.updateState(args, cBoxFrame, cBox, selectedList.length !== listData.length, selectedList.length);
        const mainCboxList = [].slice.call(args.element.childNodes);
        let searchedSelectedList;
        let searchedList;
        let addCurCboxSelected;
        args.element.addEventListener('click', (e) => {
            if (searchedSelectedList) {
                const isCurSelect = this.cboxListSelected(args, searchedSelectedList, args.element.childElementCount - 2, e, true);
                if (isCurSelect !== null) {
                    addCurCboxSelected = isCurSelect;
                }
            }
            else {
                this.cboxListSelected(args, selectedList, listData.length, e);
            }
        });
        let sortedFullData;
        let searchValue;
        const updateSearchedList = (val) => {
            if (val.toLowerCase().includes(searchValue)) {
                const obj = {};
                obj[args.column.field] = val;
                cBoxFrag.appendChild(
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                createCboxWithWrap(getUid('cbox'), excelFilter.createCheckbox(val, true, obj), 'e-ftrchk'));
                searchedList.push(val);
                searchedSelectedList.push(val);
            }
        };
        let performSearchOnData;
        const filterDataCount = args.dataSource.length > 1000 ? args.dataSource.length : 1000;
        let fullListData = listData;
        if (filterData.length <= filterDataCount) {
            performSearchOnData = () => {
                listData.forEach((val) => {
                    updateSearchedList(val);
                });
            };
        }
        else {
            performSearchOnData = () => {
                if (!sortedFullData) {
                    fullListData = [];
                    initSelectedList = [];
                    selectedList = [];
                    sortedFullData = new DataManager(filterData).executeLocal(new Query().sortBy(field + '_value', 'ascending'));
                    idCol = {};
                    sortedFullData.forEach((data) => {
                        if (data[field] === '') {
                            if (!idCol['isBlank']) {
                                idCol['isBlank'] = true;
                                dataVal = l10n.getConstant('Blanks');
                                fullListData.splice(0, 0, dataVal);
                                if (!isFilterHidden(sheet, Number(data['__rowIndex']) - 1)) {
                                    initSelectedList.push(dataVal);
                                    selectedList.push(dataVal);
                                }
                            }
                        }
                        else if (!idCol[data[field]]) {
                            dataVal = data[field];
                            idCol[dataVal] = true;
                            fullListData.push(data[field]);
                            if (!isFilterHidden(sheet, Number(data['__rowIndex']) - 1)) {
                                selectedList.push(dataVal);
                                initSelectedList.push(dataVal);
                            }
                        }
                    });
                }
                for (let filterIdx = 0, len = fullListData.length; filterIdx < len; filterIdx++) {
                    if (searchedList.length < filterDataCount) {
                        updateSearchedList(fullListData[filterIdx]);
                    }
                    else {
                        break;
                    }
                }
            };
        }
        const refreshCheckbox = (e) => {
            if (e.event.type === 'keyup') {
                searchValue = e.event.target.value.toLowerCase();
            }
            else if (e.event.target.classList.contains('e-search-icon')) {
                return;
            }
            cBoxFrag = document.createDocumentFragment();
            cBoxFrag.appendChild(selectAll);
            if (searchValue) {
                searchedList = [];
                searchedSelectedList = [];
                performSearchOnData();
                if (searchedSelectedList.length) {
                    this.updateState(args, cBoxFrame, cBox, false, 0);
                    selectAll.classList.remove('e-hide');
                    const obj = {};
                    obj[field] = l10n.getConstant('AddCurrentSelection');
                    const addCurrentCbox = createCboxWithWrap(
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    getUid('cbox'), excelFilter.createCheckbox(obj[field], false, obj), 'e-ftrchk');
                    cBoxFrag.insertBefore(addCurrentCbox, cBoxFrag.children[1]);
                    addCurrentCbox.querySelector('.e-frame').classList.add('e-add-current');
                }
                else {
                    selectAll.classList.add('e-hide');
                    const noRecordEle = this.parent.createElement('div', { className: 'e-checkfltrnmdiv' });
                    const noRecordText = this.parent.createElement('span');
                    noRecordText.innerText = l10n.getConstant('NoResult');
                    noRecordEle.appendChild(noRecordText);
                    cBoxFrag.appendChild(noRecordEle);
                    args.btnObj.element.disabled = true;
                }
            }
            else if (mainCboxList) {
                searchedSelectedList = null;
                searchedList = null;
                this.updateState(args, cBoxFrame, cBox, selectedList.length !== listData.length, selectedList.length);
                selectAll.classList.remove('e-hide');
                mainCboxList.forEach((element) => {
                    cBoxFrag.appendChild(element);
                });
            }
            args.element.innerHTML = '';
            args.element.appendChild(cBoxFrag);
        };
        const applyBtnClickHandler = () => {
            if (searchedList) {
                if (addCurCboxSelected) {
                    let text;
                    let index;
                    selectedList = initSelectedList;
                    for (let idx = 0, len = searchedList.length; idx < len; idx++) {
                        text = searchedList[idx];
                        if (searchedList.length === searchedSelectedList.length || searchedSelectedList.indexOf(text) > -1) {
                            if (selectedList.indexOf(text) === -1) {
                                selectedList.push(text);
                            }
                        }
                        else {
                            index = selectedList.indexOf(text);
                            if (index > -1) {
                                selectedList.splice(index, 1);
                            }
                        }
                    }
                }
                else {
                    selectedList = searchedSelectedList;
                }
            }
            const checkedLength = selectedList.length;
            if (checkedLength === listData.length && (!searchedSelectedList || filterData.length <= filterDataCount)) {
                this.filterSuccessHandler(new DataManager(args.dataSource), { action: 'clear-filter', field: args.column.field });
            }
            else {
                const predicates = [];
                const model = { field: field, ignoreAccent: false, matchCase: false, isFilterByMenu: true };
                const localeObj = getNumericObject(this.parent.locale);
                const updatePredicate = (val) => {
                    let type = args.type;
                    if (type === 'number') {
                        if (val === l10n.getConstant('Blanks')) {
                            val = '';
                            type = 'string';
                        }
                        else if (!isNumber(parseLocaleNumber([val], this.parent, localeObj)[0])) {
                            type = 'string';
                        }
                    }
                    predicates.push(Object.assign({ value: val, type: type }, model));
                };
                if (checkedLength > fullListData.length / 2) {
                    model.operator = 'notequal';
                    model.predicate = 'and';
                    for (let idx = 0, len = fullListData.length; idx < len; idx++) {
                        if (selectedList.indexOf(fullListData[idx]) === -1) {
                            updatePredicate(fullListData[idx]);
                        }
                    }
                }
                else {
                    model.operator = 'equal';
                    model.predicate = 'or';
                    for (let idx = 0, len = checkedLength; idx < len; idx++) {
                        updatePredicate(selectedList[idx]);
                    }
                }
                excelFilter.initiateFilter(predicates);
            }
        };
        this.wireFilterEvents(args, applyBtnClickHandler, refreshCheckbox.bind(this));
    }
    createSelectAll(args, excelFilter) {
        const selectAllObj = {};
        selectAllObj[args.column.field] = this.parent.serviceLocator.getService(locale).getConstant('SelectAll');
        const selectAll = createCboxWithWrap(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        getUid('cbox'), excelFilter.createCheckbox(selectAllObj[args.column.field], false, selectAllObj), 'e-ftrchk');
        return selectAll;
    }
    updateState(args, cBoxFrame, cBox, indeterminate, checkedCount) {
        removeClass([cBoxFrame], ['e-check', 'e-stop', 'e-uncheck']);
        if (args.btnObj.element.disabled) {
            args.btnObj.element.disabled = false;
        }
        if (indeterminate) {
            if (checkedCount) {
                cBoxFrame.classList.add('e-stop');
            }
            else {
                cBoxFrame.classList.add('e-uncheck');
                const addCurCbox = args.element.querySelector('.e-add-current');
                args.btnObj.element.disabled = !addCurCbox || !addCurCbox.classList.contains('e-check');
            }
        }
        else {
            cBoxFrame.classList.add('e-check');
        }
        cBox.indeterminate = indeterminate;
        cBox.checked = !indeterminate;
    }
    beforeFilteringHandler(evt) {
        if (evt.instance && evt.instance.options) {
            if (evt.isOpen && evt.instance.options.type === 'string') {
                const localeObj = getNumericObject(this.parent.locale);
                if (localeObj.decimal !== '.') {
                    const valArr = evt.arg3.toString().split('.');
                    if (valArr.length === 2) {
                        const parsedNumVal = valArr.join(localeObj.decimal);
                        if (isNumber(new Internationalization(this.parent.locale).parseNumber(parsedNumVal, { format: 'n' }))) {
                            evt.arg3 = parsedNumVal;
                        }
                    }
                }
            }
            const parseValue = (val, operator) => {
                if (operator && (operator === 'notequal' || this.isCustomNumFilter(operator))) {
                    if (val) {
                        if (isNumber(val)) {
                            val = parseFloat(val.toString());
                        }
                        else if (typeof val === 'string') {
                            const localeObj = getNumericObject(this.parent.locale);
                            const intl = new Internationalization(this.parent.locale);
                            let numArgs = {};
                            if (val.includes(localeObj.percentSign)) {
                                const valArr = val.trim().split('%');
                                if (valArr[0] !== '' && !valArr[1]) {
                                    numArgs = checkIsNumberAndGetNumber({ value: valArr[0] }, this.parent.locale, localeObj.group, localeObj.decimal);
                                }
                            }
                            if (numArgs.isNumber) {
                                val = Number(numArgs.value) / 100;
                            }
                            else {
                                const parsedNumVal = intl.parseNumber(val.trim(), { format: 'n' });
                                if (isNumber(parsedNumVal)) {
                                    if (/^(\(\d+\)|\d+)$/.test(val.trim())) {
                                        val = -parsedNumVal;
                                    }
                                    else {
                                        val = parsedNumVal;
                                    }
                                }
                                else {
                                    const checkVal = val.trim();
                                    const dateEventArgs = { value: checkVal, cell: { value: checkVal } };
                                    this.parent.notify(checkDateFormat, dateEventArgs);
                                    if (dateEventArgs.isTime || dateEventArgs.isDate) {
                                        val = parseFloat(dateEventArgs.updatedVal);
                                    }
                                }
                            }
                        }
                    }
                    else if (operator === 'notequal' && val === null) {
                        val = '';
                    }
                }
                else if (operator === 'equal') {
                    if (isNumber(val)) {
                        val = val.toString();
                    }
                    else if (typeof val === 'string' && isNumber(parseValue(val, 'notequal'))) {
                        val = val.trim();
                    }
                    else if (val === null) {
                        val = '';
                    }
                }
                return val;
            };
            if (evt.instance.options.type !== 'date') {
                evt.arg3 = parseValue(evt.arg3, evt.arg2);
                evt.arg8 = parseValue(evt.arg8, evt.arg7);
            }
            else if (evt.instance.options.format === 'yMd') {
                const parseDateTime = (val, operator) => {
                    if (val) {
                        if (typeof val === 'string') {
                            const checkVal = val.trim();
                            const dateEventArgs = { value: checkVal, cell: { value: checkVal } };
                            this.parent.notify(checkDateFormat, dateEventArgs);
                            if (dateEventArgs.isDate) {
                                val = operator === 'equal' ? dateEventArgs.dateObj : parseFloat(dateEventArgs.updatedVal);
                            }
                            else {
                                if (operator === 'equal' || operator === 'notequal') {
                                    const parsedNumVal = parseValue(val, 'notequal');
                                    if (isNumber(parsedNumVal)) {
                                        evt.instance.options.type = 'number';
                                        if (operator === 'notequal') {
                                            val = parsedNumVal;
                                        }
                                    }
                                    else {
                                        evt.instance.options.type = 'string';
                                    }
                                }
                            }
                        }
                        else if (isDateTime(val) && operator !== 'equal') {
                            val = dateToInt(val, true);
                        }
                    }
                    return val;
                };
                const filterDateInputs = document.querySelectorAll('.e-xlfl-valuediv input.e-datepicker');
                if (filterDateInputs.length === 2) {
                    evt.arg3 = parseDateTime(evt.arg3 || filterDateInputs[0].value, evt.arg2);
                    evt.arg8 = parseDateTime(evt.arg8 || filterDateInputs[1].value, evt.arg7);
                }
                else if (evt.arg3) {
                    evt.arg3 = parseDateTime(evt.arg3, evt.arg2);
                }
            }
        }
    }
    customFilterOpen(args) {
        const filterOptDiv = document.querySelectorAll('.e-xlfl-optrdiv input.e-dropdownlist');
        const criterias = [];
        for (let idx = 0; idx < filterOptDiv.length; idx++) {
            const dropDownList = getComponent(filterOptDiv[idx], 'dropdownlist');
            if (dropDownList) {
                criterias.push(dropDownList.value);
            }
        }
        const customFilterValues = [];
        if (criterias.length === 2) {
            const predicates = this.filterCollection.get(this.parent.activeSheetIndex);
            let criteriaIdx;
            for (let idx = 0; idx < predicates.length; idx++) {
                if (predicates[idx].field === args.column && predicates[idx].value !== null) {
                    criteriaIdx = criterias.indexOf(predicates[idx].operator);
                    if (criteriaIdx > -1) {
                        if (predicates[idx].operator === 'equal' && isDateTime(predicates[idx].value)) {
                            customFilterValues[criteriaIdx] = dateToInt(predicates[idx].value, true).toString();
                        }
                        else {
                            customFilterValues[criteriaIdx] = predicates[idx].value.toString();
                        }
                        criterias[criteriaIdx] = '';
                    }
                }
            }
        }
        const localeNumObj = getNumericObject(this.parent.locale);
        const getParsedVal = (val) => {
            if (localeNumObj.decimal !== '.' && isNumber(val)) {
                const parsedVal = val.toString();
                if (parsedVal.includes('.')) {
                    return parsedVal.replace('.', localeNumObj.decimal);
                }
            }
            return val;
        };
        const filterValInputs = document.querySelectorAll('.e-xlfl-valuediv input.e-ss-filter-input');
        if (filterValInputs.length) {
            for (let idx = 0; idx < filterValInputs.length; idx++) {
                const textObj = new TextBox({ placeholder: this.parent.serviceLocator.getService(locale).getConstant('CustomFilterPlaceHolder') });
                if (customFilterValues[idx]) {
                    textObj.value = getParsedVal(customFilterValues[idx]);
                }
                textObj.appendTo(filterValInputs[idx]);
            }
        }
        else {
            const filterValInputs = document.querySelectorAll('.e-xlfl-valuediv input.e-datepicker');
            let datePickerObj;
            let val;
            for (let idx = 0; idx < filterValInputs.length; idx++) {
                if (isNumber(customFilterValues[idx])) {
                    val = this.parent.getDisplayText({ value: customFilterValues[idx], format: getFormatFromType('ShortDate') +
                            (customFilterValues[idx].includes('.') ? ` ${getFormatFromType('Time')}` : '') });
                }
                else {
                    val = getParsedVal(customFilterValues[idx]);
                }
                datePickerObj = getComponent(filterValInputs[idx], 'datepicker');
                if (datePickerObj) {
                    datePickerObj.value = val;
                    filterValInputs[idx].value = val;
                }
            }
        }
    }
    wireFilterEvents(args, applyBtnClickHandler, refreshCheckboxes) {
        args.btnObj.element.addEventListener('click', applyBtnClickHandler.bind(this));
        args.searchBox.addEventListener('keydown', (e) => {
            if (e.keyCode === 13) {
                applyBtnClickHandler();
            }
        });
        const filterDlgCloseHandler = () => {
            this.parent.off(refreshCheckbox, refreshCheckboxes);
            this.parent.off(filterDialogClose, filterDlgCloseHandler);
            focus(this.parent.element);
        };
        this.parent.on(filterDialogClose, filterDlgCloseHandler, this);
        this.parent.on(refreshCheckbox, refreshCheckboxes, this);
    }
    initTreeView(args, excelFilter) {
        let checkedNodes = [];
        const allNodes = [];
        const idColl = {};
        let groupedYears = [];
        let groupedMonths = [];
        let groupedData = [];
        let otherData = [];
        let value;
        let month;
        let day;
        let date;
        let mId;
        let dId;
        let monthNum;
        let months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October',
            'November', 'December'];
        if (this.parent.locale !== 'en-US') {
            const formats = IntlBase.getDependables(cldrData, this.parent.locale, null).dateObject;
            const monthObj = formats.months['stand-alone'] ? formats.months['stand-alone'].wide : {};
            if (Object.keys(monthObj).length === 12) {
                months = Object.keys(monthObj).map(Number).map((key) => monthObj[key]);
            }
        }
        let grpObj;
        let indeterminate = false;
        const sheet = this.parent.getActiveSheet();
        const addNodes = (data) => {
            idColl[`${dId}`] = true;
            if (isFilterHidden(sheet, Number(data['__rowIndex']) - 1)) {
                indeterminate = true;
            }
            else {
                checkedNodes.push(dId);
            }
            allNodes.push(dId);
        };
        args.dataSource.forEach((data) => {
            date = data[args.column.field];
            if (typeof date === 'object' && !!Date.parse(date.toString())) {
                value = date.getFullYear().toString();
                if (!idColl[`${value}`]) {
                    grpObj = { __rowIndex: value, hasChild: true };
                    grpObj[args.column.field] = value;
                    groupedYears.push(grpObj);
                    idColl[`${value}`] = true;
                }
                monthNum = date.getMonth();
                month = months[monthNum];
                mId = value + ' ' + month;
                if (!idColl[`${mId}`]) {
                    grpObj = { __rowIndex: mId, pId: value, hasChild: true, month: monthNum };
                    grpObj[args.column.field] = month;
                    groupedMonths.push(grpObj);
                    idColl[`${mId}`] = true;
                }
                day = date.getDate();
                dId = mId + ' ' + day.toString();
                if (!idColl[`${dId}`]) {
                    grpObj = { __rowIndex: dId, pId: mId };
                    grpObj[args.column.field] = day;
                    groupedData.push(grpObj);
                    addNodes(data);
                }
            }
            else {
                if (!data[args.column.field] && data[args.column.field] !== 0) {
                    dId = 'blanks';
                    value = this.parent.serviceLocator.getService(locale).getConstant('Blanks');
                }
                else {
                    dId = 'text ' + data[args.column.field].toString().toLowerCase();
                    value = data[args.column.field];
                }
                if (!idColl[`${dId}`]) {
                    grpObj = { __rowIndex: dId };
                    grpObj[args.column.field] = value;
                    otherData.push(grpObj);
                    addNodes(data);
                }
            }
        });
        groupedYears = new DataManager(groupedYears).executeLocal(new Query().sortBy(args.column.field, 'decending'));
        groupedMonths = new DataManager(groupedMonths).executeLocal(new Query().sortBy('month', 'ascending'));
        groupedData = new DataManager(groupedData).executeLocal(new Query().sortBy(args.column.field, 'ascending'));
        groupedData = groupedYears.concat(groupedMonths.concat(groupedData));
        if (otherData.length) {
            otherData = new DataManager(otherData).executeLocal(new Query().sortBy(args.column.field, 'ascending'));
            groupedData = groupedData.concat(otherData);
        }
        const nodeClick = (args) => {
            const checkedNode = [args.node];
            if (args.event.target.classList.contains('e-fullrow') || args.event.key === 'Enter') {
                const getNodeDetails = treeViewObj.getNode(args.node);
                if (getNodeDetails.isChecked === 'true') {
                    treeViewObj.uncheckAll(checkedNode);
                }
                else {
                    treeViewObj.checkAll(checkedNode);
                }
            }
        };
        const selectAllClick = () => {
            cBox.indeterminate = false;
            if (cBoxFrame.classList.contains('e-check')) {
                treeViewObj.uncheckAll();
                cBoxFrame.classList.add('e-uncheck');
                cBox.checked = false;
            }
            else {
                treeViewObj.checkAll();
                cBoxFrame.classList.add('e-check');
                cBox.checked = true;
            }
        };
        const selectAll = this.createSelectAll(args, excelFilter);
        selectAll.addEventListener('click', selectAllClick.bind(this));
        selectAll.classList.add('e-spreadsheet-ftrchk');
        const cBoxFrame = selectAll.querySelector('.e-frame');
        cBoxFrame.classList.add('e-selectall');
        args.element.appendChild(selectAll);
        const cBox = selectAll.querySelector('.e-chk-hidden');
        const treeViewEle = this.parent.createElement('div');
        const treeViewObj = new TreeView({
            fields: { dataSource: groupedData, id: '__rowIndex', parentID: 'pId', text: args.column.field, hasChildren: 'hasChild' },
            enableRtl: this.parent.enableRtl, showCheckBox: true, cssClass: 'e-checkboxtree', checkedNodes: checkedNodes,
            nodeClicked: nodeClick.bind(this),
            keyPress: nodeClick.bind(this),
            nodeChecked: (e) => {
                if (e.action !== 'indeterminate') {
                    indeterminate = treeViewObj.checkedNodes.length !== treeViewObj.fields.dataSource.length;
                    this.updateState(args, cBoxFrame, cBox, indeterminate, treeViewObj.checkedNodes.length);
                }
            }
        });
        treeViewObj.createElement = this.parent.createElement;
        treeViewObj.appendTo(treeViewEle);
        args.element.appendChild(treeViewEle);
        checkedNodes = treeViewObj.checkedNodes;
        this.updateState(args, cBoxFrame, cBox, indeterminate, treeViewObj.checkedNodes.length);
        const applyBtnClickHandler = () => {
            if (treeViewObj.checkedNodes.length === groupedData.length) {
                this.filterSuccessHandler(new DataManager(args.dataSource), { action: 'clear-filter', field: args.column.field });
            }
            else {
                this.generatePredicate(treeViewObj.checkedNodes, otherData.length ? 'string' : args.type, args.column.field, excelFilter, allNodes, treeViewObj.checkedNodes.length > groupedData.length / 2);
            }
        };
        this.treeViewObj = treeViewObj;
        this.treeViewEle = treeViewEle;
        this.cBox = cBox;
        this.wireFilterEvents(args, applyBtnClickHandler, this.refreshCheckbox.bind(this, groupedData, treeViewObj, checkedNodes));
    }
    generatePredicate(checkedNodes, type, field, excelFilter, allNodes, isNotEqual) {
        const predicates = [];
        let predicate;
        const months = { 'January': 0, 'February': 1, 'March': 2, 'April': 3, 'May': 4, 'June': 5, 'July': 6,
            'August': 7, 'September': 8, 'October': 9, 'November': 10, 'December': 11 };
        let valArr;
        let date;
        let val;
        let otherType;
        const updateOtherPredicate = () => {
            if (valArr[0] === 'blanks') {
                predicates.push(Object.assign({ value: '', type: type }, predicate));
            }
            else if (valArr[0] === 'text') {
                valArr.splice(0, 1);
                val = valArr.join(' ');
                if (isNaN(Number(val))) {
                    otherType = 'string';
                }
                else {
                    val = Number(val);
                    otherType = 'number';
                }
                predicates.push(Object.assign({ value: val, type: otherType }, predicate));
            }
        };
        const setDate = () => {
            date = new Date(Number(valArr[0]), months[valArr[1]], Number(valArr[2]));
            if (date.getDate()) {
                predicates.push(Object.assign({ value: date, type: type }, predicate));
            }
            else {
                updateOtherPredicate();
            }
        };
        if (isNotEqual) {
            predicate = { field: field, ignoreAccent: false, matchCase: false, predicate: 'and', operator: 'notequal',
                isFilterByMenu: true };
            for (let i = 0, len = allNodes.length; i < len; i++) {
                if (checkedNodes.indexOf(allNodes[i]) === -1) {
                    valArr = allNodes[i].split(' ');
                    setDate();
                }
            }
        }
        else {
            predicate = { field: field, ignoreAccent: false, matchCase: false, predicate: 'or', operator: 'equal', isFilterByMenu: true };
            for (let i = 0, len = checkedNodes.length; i < len; i++) {
                valArr = checkedNodes[i].split(' ');
                if (valArr.length === 3) {
                    setDate();
                }
                else {
                    updateOtherPredicate();
                }
            }
        }
        excelFilter.initiateFilter(predicates);
    }
    refreshCheckbox(groupedData, treeViewObj, checkedNodes, args) {
        let searchValue;
        if (args.event.type === 'keyup') {
            searchValue = args.event.target.value;
        }
        else if (args.event.target.classList.contains('e-search-icon')) {
            return;
        }
        let filteredList;
        const changeData = () => {
            if (filteredList.length && !treeViewObj.fields.dataSource.length) {
                const wrapper = treeViewObj.element.parentElement;
                wrapper.getElementsByClassName('e-spreadsheet-ftrchk')[0].classList.remove('e-hide');
                detach(wrapper.getElementsByClassName('e-checkfltrnmdiv')[0]);
            }
            treeViewObj.fields.dataSource = filteredList;
            treeViewObj.dataBind();
        };
        if (searchValue) {
            filteredList = new DataManager(groupedData).executeLocal(new Query().where(new Predicate(treeViewObj.fields.text, 'contains', searchValue, true)));
            const filterId = {};
            const predicates = [];
            let key;
            let initList;
            const strFilter = isNaN(Number(searchValue));
            let expandId;
            let level;
            if (strFilter) {
                for (let i = 0; i < filteredList.length; i++) {
                    if (!filteredList[i]['hasChild']) {
                        continue;
                    }
                    predicates.push(new Predicate('pId', 'equal', filteredList[i]['__rowIndex'], false));
                    key = filteredList[i]['pId'];
                    if (!filterId[`${key}`]) {
                        predicates.push(new Predicate('__rowIndex', 'equal', key, false));
                        filterId[`${key}`] = true;
                    }
                }
                initList = filteredList;
                level = 1;
            }
            else {
                let year;
                const filterParentId = {};
                expandId = [];
                for (let i = 0; i < filteredList.length; i++) {
                    key = filteredList[i]['pId'];
                    if (key) {
                        year = key.split(' ')[0];
                        if (!filterId[`${key}`]) {
                            predicates.push(new Predicate('__rowIndex', 'equal', key, false));
                            filterId[`${key}`] = true;
                            expandId.push(year);
                            expandId.push(key);
                        }
                        if (!filterParentId[`${year}`]) {
                            if (!filterId[`${year}`]) {
                                predicates.push(new Predicate('__rowIndex', 'equal', year, false));
                                filterId[`${year}`] = true;
                            }
                            predicates.push(new Predicate('__rowIndex', 'equal', filteredList[i]['__rowIndex'], false));
                        }
                    }
                    else {
                        key = filteredList[i]['__rowIndex'];
                        if (!filterParentId[`${key}`]) {
                            predicates.push(new Predicate('__rowIndex', 'contains', key, false));
                            filterParentId[`${key}`] = true;
                        }
                    }
                }
                initList = [];
            }
            if (filteredList.length) {
                if (predicates.length) {
                    filteredList = initList.concat(new DataManager(groupedData).executeLocal(new Query().where(Predicate.or(predicates))));
                }
                changeData();
                treeViewObj.checkAll();
                const duration = treeViewObj.animation.expand.duration;
                treeViewObj.animation.expand.duration = 0;
                treeViewObj.expandAll(expandId, level);
                treeViewObj.animation.expand.duration = duration;
            }
            else if (treeViewObj.fields.dataSource.length) {
                changeData();
                const wrapper = treeViewObj.element.parentElement;
                wrapper.getElementsByClassName('e-spreadsheet-ftrchk')[0].classList.add('e-hide');
                const noRecordEle = this.parent.createElement('div', { className: 'e-checkfltrnmdiv' });
                const noRecordText = this.parent.createElement('span');
                noRecordText.innerText = this.parent.serviceLocator.getService(locale).getConstant('NoResult');
                noRecordEle.appendChild(noRecordText);
                wrapper.appendChild(noRecordEle);
            }
        }
        else {
            filteredList = groupedData;
            changeData();
            treeViewObj.checkedNodes = checkedNodes;
            treeViewObj.refresh();
        }
    }
    openDialog(cell) {
        const colIndex = parseInt(cell.getAttribute('aria-colindex'), 10);
        const field = getColumnHeaderText(colIndex);
        this.parent.showSpinner();
        const sheetIdx = this.parent.activeSheetIndex;
        const filterRange = this.filterRange.get(sheetIdx);
        const range = filterRange.range.slice();
        const sheet = this.parent.getActiveSheet();
        const filterCell = getCell(range[0], colIndex - 1, sheet);
        const displayName = this.parent.getDisplayText(filterCell);
        if (!filterRange.allowHeaderFilter) {
            range[0] = range[0] + 1; // to skip first row.
        }
        if (!filterRange.useFilterRange) {
            range[2] = sheet.usedRange.rowIndex; //filter range should be till used range.
        }
        const fullRange = [range[0], colIndex - 1, range[2], colIndex - 1];
        const totalRange = this.getPredicateRange(fullRange, this.filterCollection.get(sheetIdx), colIndex - 1);
        const otherColPredicate = totalRange.otherColPredicate;
        let curColPredicates;
        const curPredicate = totalRange.curPredicate;
        if (curPredicate.length) {
            curColPredicates = {};
            curColPredicates[field] = curPredicate;
        }
        const addr = `${sheet.name}!${totalRange.address}`;
        const fullAddr = getRangeAddress(fullRange);
        const col = this.getColumnType(sheet, colIndex - 1, range, true);
        const type = col.type;
        let templateColData;
        const isDateCol = type === 'date' || col.isDateAvail;
        const isNumCol = type === 'number';
        const templateFilter = isDateCol || isNumCol;
        const isMultiFormattedCol = col.isMultiFormattedCol;
        if (templateFilter && !totalRange.filteredCol) {
            templateColData = [];
        }
        getData(this.parent, addr, true, true, null, true, null, null, true, fullAddr, null, templateColData).then((jsonData) => {
            let checkBoxData;
            this.parent.element.style.position = 'relative';
            this.parent.element.classList.add('e-filter-open');
            let filterCollection;
            if (templateFilter) {
                if (templateColData || !otherColPredicate.length) {
                    checkBoxData = new DataManager(templateColData || jsonData);
                }
                else {
                    const options = this.getPredicates(otherColPredicate);
                    const data = applyPredicates(new DataManager(jsonData), options.predicates, options.equalOrPredicates);
                    checkBoxData = new DataManager(data);
                }
                const beforeCboxRender = (args) => {
                    this.parent.off(beforeCheckboxRender, beforeCboxRender);
                    args.isCheckboxFilterTemplate = true;
                    if (isDateCol) {
                        this.initTreeView(args, excelFilter);
                    }
                    else {
                        this.initCboxList(args, excelFilter, jsonData);
                    }
                };
                this.parent.on(beforeCheckboxRender, beforeCboxRender, this);
                filterCollection = [];
            }
            else {
                if (otherColPredicate.length) {
                    const options = this.getPredicates(otherColPredicate);
                    const data = applyPredicates(new DataManager(jsonData), options.predicates, options.equalOrPredicates);
                    checkBoxData = new DataManager(data);
                }
                else {
                    checkBoxData = new DataManager(jsonData);
                }
                filterCollection = this.getClonedPredicates(curPredicate);
            }
            const target = cell.querySelector('.e-filter-btn');
            const filterCol = {
                field: field, filter: {}
            };
            if (isNumCol) {
                const parent = this.parent;
                filterCol.filterTemplate = (element) => {
                    if (parent.isReact && element) {
                        element.appendChild(parent.createElement('input', { className: 'e-ss-filter-input' }));
                    }
                    else {
                        return [parent.createElement('input', { className: 'e-ss-filter-input' })];
                    }
                };
                const filterTemplateCallback = (template) => {
                    return (_data, _parent, _prop, _id, _isStringTemplate, _index, element) => {
                        return template(element);
                    };
                };
                filterCol.getFilterTemplate = () => filterTemplateCallback(filterCol.filterTemplate);
                if (parent.isReact && !parent.renderTemplates) {
                    parent.renderTemplates = (callback) => callback();
                }
            }
            const options = {
                type: type, field: field, format: (type === 'date' ? 'yMd' : null), displayName: displayName || 'Column ' + field,
                dataSource: checkBoxData || [], height: this.parent.element.classList.contains('e-bigger') ? 800 : 500, columns: [],
                hideSearchbox: false, filteredColumns: filterCollection, column: filterCol,
                handler: this.filterSuccessHandler.bind(this, new DataManager(jsonData)), target: target,
                position: { X: 0, Y: 0 }, localeObj: this.parent.serviceLocator.getService(locale), actualPredicate: curColPredicates,
                isFormatted: templateFilter && !isDateCol, isMultiFormattedCol: isMultiFormattedCol
            };
            const excelFilter = new ExcelFilterBase(this.parent, this.getLocalizedCustomOperators());
            excelFilter.openDialog(options);
            const filterPopup = document.querySelector('.e-filter-popup');
            if (filterPopup && filterPopup.id.includes(this.parent.element.id)) {
                EventHandler.add(filterPopup, getStartEvent(), this.filterMouseDownHandler, this);
                const parentOff = this.parent.element.getBoundingClientRect();
                const cellOff = target.getBoundingClientRect();
                const popupOff = filterPopup.getBoundingClientRect();
                let left = (cellOff.right - parentOff.left) - popupOff.width;
                if (left < 0) { // Left collision wrt spreadsheet left
                    left = cellOff.left - parentOff.left;
                }
                filterPopup.style.left = `${left * this.parent.viewport.scaleX}px`;
                filterPopup.style.top = '0px';
                filterPopup.style.visibility = 'hidden';
                if (filterPopup.classList.contains('e-hide')) {
                    filterPopup.classList.remove('e-hide');
                }
                let top = cellOff.bottom - parentOff.top;
                if (popupOff.height - (parentOff.bottom - cellOff.bottom) > 0) { // Bottom collision wrt spreadsheet bottom
                    top -= popupOff.height - (parentOff.bottom - cellOff.bottom);
                    if (top < 0) {
                        top = 0;
                    }
                }
                filterPopup.style.top = `${top * this.parent.viewport.scaleY}px`;
                filterPopup.style.visibility = '';
            }
            this.parent.hideSpinner();
        });
    }
    getPredicateRange(range, predicates, col) {
        let addr = getRangeAddress(range);
        let filteredCol;
        const otherColPredicate = [];
        const curPredicate = [];
        if (predicates && predicates.length) {
            let predicateRange;
            let colIdx;
            predicates.forEach((predicate) => {
                if (predicate.field) {
                    predicateRange = `${predicate.field}${range[0] + 1}:${predicate.field}${range[2] + 1}`;
                    colIdx = getColIndex(predicate.field);
                    if (!addr.includes(predicateRange)) {
                        addr += `,${predicateRange}`;
                        if (colIdx < range[1]) {
                            range[1] = colIdx;
                        }
                        if (colIdx > range[3]) {
                            range[3] = colIdx;
                        }
                    }
                    if (col !== undefined) {
                        if (colIdx === col) {
                            filteredCol = true;
                            curPredicate.push(predicate);
                        }
                        else {
                            otherColPredicate.push(predicate);
                        }
                    }
                }
            });
        }
        else {
            filteredCol = true;
        }
        return col === undefined ? addr :
            { address: addr, filteredCol: filteredCol, otherColPredicate: otherColPredicate, curPredicate: curPredicate };
    }
    filterDialogCreatedHandler() {
        const filterPopup = document.querySelector('.e-filter-popup');
        if (filterPopup && filterPopup.id.includes(this.parent.element.id) && filterPopup.classList.contains('e-popup-close')) {
            filterPopup.classList.add('e-hide');
        }
    }
    /**
     * Formats cell value for listing it in filter popup.
     *
     * @param {any} args - Specifies the args
     * @param {string | number} args.value - Specify the value
     * @param {object} args.column - Specify the column
     * @param {object} args.data - Specify the data
     * @returns {void} - Formats cell value for listing it in filter popup.
     */
    filterCboxValueHandler(args) {
        if (args.column && args.data) {
            const field = args.column.field;
            if (args.value) {
                const indexes = getCellIndexes(field + args.data['dataObj']['__rowIndex']);
                const cell = getCell(indexes[0], indexes[1], this.parent.getActiveSheet());
                if (cell && cell.format) {
                    args.value = this.parent.getDisplayText(cell);
                }
            }
        }
    }
    /**
     * Triggers when sorting items are chosen on context menu of filter popup.
     *
     * @param {HTMLElement} target - Specify the element.
     * @returns {void} - Triggers when sorting items are chosen on context menu of filter popup.
     */
    selectSortItemHandler(target) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const sortOrder = target.classList.contains('e-filter-sortasc') ? 'Ascending'
            : target.classList.contains('e-filter-sortdesc') ? 'Descending' : null;
        if (sortOrder === 'Ascending') {
            target.setAttribute('aria-label', l10n.getConstant('SortAscending'));
        }
        else {
            target.setAttribute('aria-label', l10n.getConstant('SortDescending'));
        }
        if (!sortOrder) {
            return;
        }
        const sheet = this.parent.getActiveSheet();
        const sheetIdx = this.parent.activeSheetIndex;
        const filterRange = this.filterRange.get(sheetIdx);
        const range = filterRange.range.slice();
        if (!filterRange.allowHeaderFilter) {
            range[0] = range[0] + 1; // to skip first row.
        }
        if (!filterRange.useFilterRange) {
            range[2] = sheet.usedRange.rowIndex; //filter range should be till used range.
        }
        if (isReadOnlyCells(this.parent, range)) {
            this.closeDialog();
            this.parent.notify(readonlyAlert, null);
            return;
        }
        this.parent.sortCollection = this.parent.sortCollection ? this.parent.sortCollection : [];
        const prevSort = [];
        for (let i = this.parent.sortCollection.length - 1; i >= 0; i--) {
            if (this.parent.sortCollection[i] && this.parent.sortCollection[i].sheetIndex === sheetIdx) {
                prevSort.push(this.parent.sortCollection[i]);
                this.parent.sortCollection.splice(i, 1);
            }
        }
        this.parent.sortCollection.push({ sortRange: getRangeAddress(range), columnIndex: getIndexesFromAddress(sheet.activeCell)[1], order: sortOrder,
            sheetIndex: sheetIdx });
        this.parent.notify(applySort, { sortOptions: { sortDescriptors: { order: sortOrder }, containsHeader: false }, previousSort: prevSort, range: getRangeAddress(range) });
        this.refreshFilterRange();
        this.closeDialog();
    }
    /**
     * Triggers when OK button or clear filter item is selected
     *
     * @param {DataManager} dataSource - Specify the data source
     * @param {Object} args - Specify the data source
     * @param {string} args.action - Specify the action
     * @param {PredicateModel[]} args.filterCollection - Specify the filter collection.
     * @param {string} args.field - Specify the field.
     * @param {number} args.sIdx - Specify the index.
     * @param {boolean} args.isInternal - Specify the isInternal.
     * @param {boolean} args.isFilterByValue - Specify the isFilterByValue.
     * @param {PredicateModel[]} args.prevPredicates - Specify the prevPredicates.
     * @param {boolean} args.isOpen - Specify the filtering action is after importing.
     * @returns {void} - Triggers when OK button or clear filter item is selected
     */
    filterSuccessHandler(dataSource, args) {
        let sheetIdx = args.sIdx;
        if (!sheetIdx && sheetIdx !== 0) {
            sheetIdx = args.isOpen ? 0 : this.parent.activeSheetIndex;
        }
        let prevPredicates = args.prevPredicates || [].slice.call(this.filterCollection.get(sheetIdx));
        if (args.isFilterByValue && !prevPredicates.length) {
            prevPredicates = undefined;
        }
        let predicates = this.filterCollection.get(sheetIdx);
        this.updatePredicate(predicates, args.field);
        if (args.action === 'clear-filter' && predicates.length === prevPredicates.length) {
            return;
        }
        if (args.action === 'filtering') {
            const processWildcards = (filterCollection) => {
                return filterCollection.map((predicate) => {
                    if (predicate && typeof predicate.value === 'string' && predicate.value.includes('*')) {
                        if (predicate.value.startsWith('*') && predicate.value.endsWith('*')) {
                            predicate.value = predicate.value.split('*').join('');
                            predicate.operator = 'contains';
                        }
                        else if (predicate.value.endsWith('*')) {
                            predicate.value = predicate.value.split('*').join('');
                            predicate.operator = 'startswith';
                        }
                        else if (predicate.value.startsWith('*')) {
                            predicate.value = predicate.value.split('*').join('');
                            predicate.operator = 'endswith';
                        }
                    }
                    return predicate;
                });
            };
            predicates = predicates.concat(processWildcards(args.filterCollection));
        }
        this.filterCollection.set(sheetIdx, predicates);
        const options = this.getPredicates(predicates);
        const filterOptions = { datasource: dataSource, predicates: options.predicates,
            equalOrPredicates: options.equalOrPredicates };
        const filterRange = this.filterRange.get(sheetIdx);
        if (!filterRange.useFilterRange) {
            filterRange.range[2] = getSheet(this.parent, sheetIdx).usedRange.rowIndex; //extend the range if filtered
        }
        this.applyFilter(filterOptions, getRangeAddress(filterRange.range), sheetIdx, prevPredicates, false, args.isInternal, args.isFilterByValue);
    }
    isCustomNumFilter(operator) {
        return operator.includes('greaterthan') || operator.includes('lessthan') || operator === 'between';
    }
    getClonedPredicates(predicates, equalOrFields = []) {
        const predicateCol = [];
        let predicate;
        let isNumCustomPredicate;
        for (let i = 0; i < predicates.length; i++) {
            predicate = predicates[i];
            if ((this.isCustomNumFilter(predicate.operator) || (!predicate.isFilterByMenu && predicate.operator === 'notequal')) &&
                isNumber(predicate.value)) {
                predicateCol.push(Object.assign({}, predicate, { field: `${predicate.field}_value`, type: 'number' }));
                isNumCustomPredicate = true;
            }
            else {
                if (!predicate.isFilterByMenu && predicate.operator === 'equal' && predicate.predicate === 'or') {
                    equalOrFields.push(predicate.field);
                }
                predicateCol.push(predicate);
            }
        }
        if (!isNumCustomPredicate && equalOrFields.length) {
            equalOrFields.splice(0);
        }
        return predicateCol;
    }
    updatePredicate(predicates, field) {
        const dataManager = new DataManager(predicates);
        const query = new Query();
        const fields = dataManager.executeLocal(query.where('field', 'equal', field));
        for (let index = 0; index < fields.length; index++) {
            let sameIndex = -1;
            for (let filterIndex = 0; filterIndex < predicates.length; filterIndex++) {
                if (predicates[filterIndex].field === fields[index].field) {
                    sameIndex = filterIndex;
                    break;
                }
            }
            if (sameIndex !== -1) {
                predicates.splice(sameIndex, 1);
            }
        }
    }
    /**
     * Triggers events for filtering and applies filter.
     *
     * @param {FilterOptions} filterOptions - Specify the filteroptions.
     * @param {string} range - Specify the range.
     * @param {number} sheetIdx - Specify the sheet index.
     * @param {PredicateModel[]} prevPredicates - Specify the predicates.
     * @param {boolean} refresh - Spefify the refresh.
     * @param {boolean} isInternal - Specify the isInternal.
     * @param {boolean} isFilterByValue - Specify the it is filter by value or not.
     * @returns {void} - Triggers events for filtering and applies filter.
     */
    applyFilter(filterOptions, range, sheetIdx, prevPredicates, refresh, isInternal, isFilterByValue) {
        const eventArgs = { range: range, predicates: [].slice.call(this.filterCollection.get(sheetIdx)),
            previousPredicates: prevPredicates, sheetIndex: sheetIdx, cancel: false };
        if (!isInternal && !isFilterByValue) {
            this.parent.notify(beginAction, { action: 'filter', eventArgs: eventArgs });
            if (eventArgs.cancel) {
                return;
            }
        }
        if (range.indexOf('!') < 0) {
            range = this.parent.sheets[sheetIdx].name + '!' + range;
        }
        this.parent.showSpinner();
        const promise = new Promise((resolve) => { resolve((() => { })()); });
        const filterArgs = { args: { range: range,
                filterOptions: filterOptions }, promise: promise, refresh: refresh };
        const prevChartIndexes = getChartsIndexes(this.parent);
        this.parent.notify(initiateFilter, filterArgs);
        const currentChartIndexes = getChartsIndexes(this.parent);
        this.parent.notify(refreshChartCellModel, { prevChartIndexes, currentChartIndexes });
        filterArgs.promise.then((args) => {
            this.refreshFilterRange();
            this.parent.hideSpinner();
            if (!isInternal) {
                delete eventArgs.cancel;
                this.parent.notify(completeAction, { action: 'filter', eventArgs: eventArgs });
                if (document.activeElement.id !== `${this.parent.element.id}_SearchBox`) {
                    focus(this.parent.element);
                }
            }
            return Promise.resolve(args);
        }).catch((error) => {
            this.filterRangeAlertHandler({ error: error });
            return Promise.reject(error);
        });
    }
    /**
     * Gets the predicates for the sheet
     *
     * @param {PredicateModel[]} predicateModel - Specifies the predicate collection.
     * @returns {Predicate[]} - Gets the predicates for the sheet
     */
    getPredicates(predicateModel) {
        let equalOrPredicates;
        const equalOrFields = [];
        const predicateCol = this.getClonedPredicates(predicateModel, equalOrFields);
        if (equalOrFields.length) {
            let field;
            let predicate;
            const equalOrPredicatesModel = new Map();
            for (let idx = 0; idx < predicateCol.length; idx++) {
                field = predicateCol[idx].field.replace('_value', '');
                if (equalOrFields.indexOf(field) > -1) {
                    predicate = predicateCol.splice(idx, 1)[0];
                    idx--;
                    if (equalOrPredicatesModel.has(field)) {
                        equalOrPredicatesModel.get(field).push(predicate);
                    }
                    else {
                        equalOrPredicatesModel.set(field, [predicate]);
                    }
                }
            }
            equalOrPredicates = [];
            let predicateList;
            equalOrPredicatesModel.forEach((predicates) => {
                predicateList = [];
                const excelPredicate = CheckBoxFilterBase.getPredicate(predicates);
                for (const prop of Object.keys(excelPredicate)) {
                    predicateList.push(excelPredicate[`${prop}`]);
                }
                equalOrPredicates.push(predicateList);
            });
        }
        const predicateList = [];
        const excelPredicate = CheckBoxFilterBase.getPredicate(predicateCol);
        for (const prop of Object.keys(excelPredicate)) {
            predicateList.push(excelPredicate[`${prop}`]);
        }
        return { predicates: predicateList, equalOrPredicates: equalOrPredicates };
    }
    /**
     * Gets the column type to pass it into the excel filter options.
     *
     * @param {SheetModel} sheet - Specify the sheet.
     * @param {number} colIndex - Specify the colindex
     * @param {number[]} range - Specify the range.
     * @param {boolean} isFilterDialog - Indicates whether the filter dialog UI is open.
     * @returns {string} - Gets the column type to pass it into the excel filter options.
     */
    getColumnType(sheet, colIndex, range, isFilterDialog) {
        let num = 0;
        let str = 0;
        let date = 0;
        const time = 0;
        let cell;
        let formatOption;
        let format;
        let isMultiFormattedCol;
        for (let i = range[0]; i <= range[2]; i++) {
            cell = getCell(i, colIndex, sheet);
            if (cell && !(isFilterDialog && !(cell.value || Number(cell.value) === 0))) {
                if (cell.format && cell.format !== 'General') {
                    const type = getTypeFromFormat(cell.format).toLowerCase();
                    switch (type) {
                        case 'number':
                        case 'currency':
                        case 'accounting':
                        case 'percentage':
                            num++;
                            break;
                        case 'shortdate':
                        case 'longdate':
                            date++;
                            break;
                        case 'time':
                            num++;
                            break;
                        case 'text':
                            str++;
                            break;
                        default:
                            formatOption = {};
                            if (isCustomDateTime(cell.format, true, formatOption)) {
                                if (formatOption.type === 'date') {
                                    date++;
                                }
                                else {
                                    num++;
                                }
                            }
                            else if (isNumber(cell.value)) {
                                num++;
                            }
                            else if (cell.value) {
                                str++;
                            }
                            break;
                    }
                    if (!format) {
                        format = cell.format;
                    }
                }
                else if (isNumber(cell.value)) {
                    num++;
                }
                else if (cell.value) {
                    str++;
                }
                if (format && format !== cell.format) {
                    isMultiFormattedCol = true;
                }
            }
        }
        return { type: (num > str && num > date && num > time) ? 'number' : (str >= num && str >= date && str >= time) ? 'string'
                : (date > num && date > str && date > time) ? 'date' : 'datetime', isDateAvail: !!date, isMultiFormattedCol: isMultiFormattedCol };
    }
    /**
     * Clear filter from the field.
     *
     * @param {any} args - Specifies the args
     * @param {{ field: string }} args.field - Specify the args
     * @param {boolean} args.isAction - Specify the isAction.
     * @param {boolean} args.preventRefresh - Specify the preventRefresh.
     * @param {number} args.sheetIndex - Specify the sheet index value.
     * @returns {void} - Clear filter from the field.
     */
    clearFilterHandler(args) {
        const sheetIndex = args && !isNullOrUndefined(args.sheetIndex) ? args.sheetIndex : this.parent.activeSheetIndex;
        if (args && args.field) {
            const predicates = [].slice.call(this.filterCollection.get(sheetIndex));
            if (predicates && predicates.length) {
                this.updatePredicate(predicates, args.field);
                this.initiateFilterUIHandler({ predicates: predicates, range: getRangeAddress(this.filterRange.get(sheetIndex).range), sIdx: sheetIndex });
            }
        }
        else {
            const isAction = args && args.isAction;
            const filterArgs = { isFiltered: false, isClearAll: true, sheetIndex: sheetIndex };
            this.getFilteredColumnHandler(filterArgs);
            if (filterArgs.isFiltered || (args && args.preventRefresh)) {
                let eventArgs;
                const sheet = getSheet(this.parent, sheetIndex);
                const filterRange = this.filterRange.get(sheetIndex);
                const range = filterRange.range;
                if (isAction) {
                    eventArgs = { range: getRangeAddress(range), predicates: [], previousPredicates: this.filterCollection.get(sheetIndex), sheetIndex: sheetIndex, cancel: false };
                    this.parent.notify(beginAction, { action: 'filter', eventArgs: eventArgs });
                    if (eventArgs.cancel) {
                        return;
                    }
                }
                this.filterCollection.set(sheetIndex, []);
                const len = filterRange.useFilterRange ? range[2] : sheet.usedRange.rowIndex;
                if (this.parent.scrollSettings.enableVirtualization && ((len - range[0]) + 1 > (this.parent.viewport.rowCount +
                    (this.parent.getThreshold('row') * 2)))) {
                    for (let i = 0; i <= len; i++) {
                        setRow(sheet, i, { hidden: false, isFiltered: false });
                    }
                    if (!args || !args.preventRefresh) {
                        this.parent.renderModule.refreshSheet(false, false, true);
                    }
                }
                else {
                    this.refreshFilterRange(null, null, sheetIndex);
                    const evtArgs = { startIndex: range[0], hide: false, isFiltering: true, refreshUI: false, endIndex: filterRange.useFilterRange ? range[2] : sheet.usedRange.rowIndex, sheetIndex: sheetIndex };
                    this.parent.notify(hideShow, evtArgs);
                    if (evtArgs.refreshUI && (!args || !args.preventRefresh)) {
                        this.parent.renderModule.refreshSheet(false, false, true);
                    }
                }
                if (isAction) {
                    delete eventArgs.cancel;
                    this.parent.notify(completeAction, { action: 'filter', eventArgs: eventArgs });
                    focus(this.parent.element);
                }
            }
        }
    }
    /**
     * Reapplies the filter.
     *
     * @param {boolean} isInternal - Specifies the isInternal.
     * @param {boolean} refresh - Specifies the refresh.
     * @returns {void} - Reapplies the filter.
     */
    reapplyFilterHandler(isInternal, refresh) {
        const sheetIdx = this.parent.activeSheetIndex;
        if (this.filterRange.has(sheetIdx)) {
            const predicates = this.filterCollection.get(sheetIdx);
            if (predicates && predicates.length) {
                const sheet = getSheet(this.parent, sheetIdx);
                const filterRange = this.filterRange.get(sheetIdx);
                const range = filterRange.range.slice();
                if (!filterRange.allowHeaderFilter) {
                    range[0] = range[0] + 1;
                }
                if (!filterRange.useFilterRange) {
                    range[2] = sheet.usedRange.rowIndex;
                }
                range[1] = range[3] = getColIndex(predicates[0].field);
                const addr = `${sheet.name}!${this.getPredicateRange(range, predicates.slice(1, predicates.length))}`;
                getData(this.parent, addr, true, true, null, true, null, null, false, getRangeAddress(range)).then((jsonData) => {
                    const options = this.getPredicates(this.filterCollection.get(sheetIdx));
                    this.applyFilter({ predicates: options.predicates, datasource: new DataManager(jsonData),
                        equalOrPredicates: options.equalOrPredicates }, getRangeAddress(filterRange.range), sheetIdx, [].slice.call(predicates), refresh, isInternal);
                });
            }
        }
    }
    /**
     * Gets the filter information of the sheet.
     *
     * @param {FilterInfoArgs} args - Specify the args
     * @returns {void} - Gets the filter information of the sheet.
     */
    getFilterRangeHandler(args) {
        const sheetIdx = isNullOrUndefined(args.sheetIdx) ? this.parent.activeSheetIndex : args.sheetIdx;
        const filterOption = this.filterRange && this.filterRange.get(sheetIdx);
        if (filterOption) {
            args.hasFilter = true;
            args.filterRange = filterOption.range;
            args.allowHeaderFilter = filterOption.allowHeaderFilter;
            args.isFiltered = this.filterCollection && this.filterCollection.get(sheetIdx) &&
                this.filterCollection.get(sheetIdx).length > 0;
        }
        else {
            args.hasFilter = false;
            args.filterRange = null;
        }
    }
    /**
     * Returns the custom operators for filter items.
     *
     * @returns {Object} - Returns the custom operators for filter items.
     */
    getLocalizedCustomOperators() {
        const l10n = this.parent.serviceLocator.getService(locale);
        const numOptr = [
            { value: 'equal', text: l10n.getConstant('Equal') },
            { value: 'greaterthan', text: l10n.getConstant('GreaterThan') },
            { value: 'greaterthanorequal', text: l10n.getConstant('GreaterThanOrEqual') },
            { value: 'lessthan', text: l10n.getConstant('LessThan') },
            { value: 'lessthanorequal', text: l10n.getConstant('LessThanOrEqual') },
            { value: 'notequal', text: l10n.getConstant('NotEqual') }
        ];
        const customOperators = {
            stringOperator: [
                { value: 'startswith', text: l10n.getConstant('StartsWith') },
                { value: 'endswith', text: l10n.getConstant('EndsWith') },
                { value: 'contains', text: l10n.getConstant('Contains') },
                { value: 'equal', text: l10n.getConstant('Equal') },
                { value: 'isempty', text: l10n.getConstant('IsEmpty') },
                { value: 'doesnotstartwith', text: l10n.getConstant('NotStartsWith') },
                { value: 'doesnotendwith', text: l10n.getConstant('NotEndsWith') },
                { value: 'doesnotcontain', text: l10n.getConstant('NotContains') },
                { value: 'notequal', text: l10n.getConstant('NotEqual') },
                { value: 'isnotempty', text: l10n.getConstant('IsNotEmpty') }
            ],
            numberOperator: numOptr,
            dateOperator: numOptr,
            datetimeOperator: numOptr,
            booleanOperator: [
                { value: 'equal', text: l10n.getConstant('Equal') },
                { value: 'notequal', text: l10n.getConstant('NotEqual') }
            ]
        };
        return customOperators;
    }
    /**
     * To set the filtered range and predicates collections in the save JSON object.
     *
     * @param {any} args - Specifies the args
     * @param {number} args.sheetIdx - Specifies the sheet index value.
     * @param {boolean} args.isSaveAction - Specifies the Save action.
     * @param {any} args.saveJson - Specifies save as Json.
     * @param {FilterCollectionModel[]} args.saveJson.filterCollection - Specifies the filter collection values.
     * @returns {void}
     */
    setFilteredCollection(args) {
        const filterArgs = { sheetIdx: args.sheetIdx };
        this.getFilterRangeHandler(filterArgs);
        if (filterArgs.hasFilter) {
            const filterModel = { sheetIndex: args.sheetIdx, filterRange: getRangeAddress(filterArgs.filterRange),
                hasFilter: true, column: [], criteria: [], value: [], dataType: [], predicates: [] };
            args.saveJson.filterCollection.push(filterModel);
            const predicates = this.filterCollection.get(args.sheetIdx);
            const predicateMap = new Map();
            let predicate;
            let type;
            const getPredicateValue = (val) => {
                if (isNullOrUndefined(val)) {
                    return '';
                }
                else if (args.isSaveAction && type === 'date') {
                    const dateVal = val;
                    val = `${dateVal.getMonth() + 1}/${dateVal.getDate()}/${dateVal.getFullYear()} ${dateVal.getHours()}:${dateVal.getMinutes()}:${dateVal.getSeconds()}`;
                }
                return val;
            };
            for (let idx = 0; idx < predicates.length; idx++) {
                predicate = predicates[idx];
                if (args.isSaveAction && predicate.operator === 'notequal' && predicate.isFilterByMenu) {
                    if (predicateMap.has(predicate.field)) {
                        predicateMap.get(predicate.field).push(predicate);
                    }
                    else {
                        predicateMap.set(predicate.field, [predicate]);
                    }
                }
                else {
                    filterModel.column.push(getColIndex(predicate.field));
                    filterModel.criteria.push(predicate.operator);
                    if (args.isSaveAction) {
                        if (predicate.operator === 'equal') {
                            type = isDateTime(predicate.value) ? 'date' : 'string';
                            filterModel.value.push(getPredicateValue(predicate.value));
                            filterModel.dataType.push(type);
                        }
                        else {
                            filterModel.value.push(predicate.value);
                            filterModel.dataType.push('custom');
                        }
                    }
                    else {
                        filterModel.value.push(predicate.value);
                        filterModel.dataType.push(predicate.type);
                    }
                    filterModel.predicates.push(predicate.predicate);
                }
            }
            const colDataMap = new Map();
            let colIdx;
            predicateMap.forEach((predicate, field) => {
                colIdx = getColIndex(field);
                if (!colDataMap.has(field)) {
                    colDataMap.set(field, this.getColData(colIdx, field, args.sheetIdx));
                }
                const colData = colDataMap.get(field);
                const predicateCol = this.getPredicates(predicate).predicates;
                const filteredData = new DataManager(colData).executeLocal(new Query().where(Predicate.and(predicateCol)));
                for (let idx = 0; idx < filteredData.length; idx++) {
                    filterModel.column.push(colIdx);
                    filterModel.criteria.push('equal');
                    type = isDateTime(filteredData[idx][field]) ? 'date' : 'string';
                    filterModel.value.push(getPredicateValue(filteredData[idx][field]));
                    filterModel.dataType.push(type);
                    filterModel.predicates.push('or');
                }
            });
        }
    }
    updateFilter(args) {
        if (this.parent.filterCollection && (args.initLoad || args.isOpen)) {
            let datePredicate;
            let predicates;
            let filterCol;
            const dateColData = {};
            let filteredData;
            let predicateCol;
            let filterOption;
            for (let i = 0; i < this.parent.filterCollection.length; i++) {
                filterCol = this.parent.filterCollection[i];
                let sIdx = filterCol.sheetIndex;
                if (i === 0 && !this.parent.isOpen && !args.isOpen) {
                    sIdx = 0;
                }
                predicates = [];
                if (filterCol.column) {
                    for (let j = 0; j < filterCol.column.length; j++) {
                        predicateCol = {
                            field: getColumnHeaderText(filterCol.column[j] + 1),
                            operator: this.getFilterOperator(filterCol.criteria[j]), value: typeof filterCol.value[j]
                                === 'string' ? filterCol.value[j].split('*').join('') : filterCol.value[j],
                            predicate: filterCol.predicates && filterCol.predicates[j],
                            type: filterCol.dataType && filterCol.dataType[j]
                        };
                        if (['year', 'month', 'day'].indexOf(predicateCol.type) > -1) {
                            const dateEventArgs = { value: predicateCol.value,
                                cell: { value: predicateCol.value } };
                            this.parent.notify(checkDateFormat, dateEventArgs);
                            if (dateEventArgs.isDate) {
                                const predicateVal = dateEventArgs.dateObj;
                                predicateCol.value = predicateVal;
                                if (predicateCol.type === 'day') {
                                    predicateCol.type = 'date';
                                    predicateCol.predicate = 'or';
                                    predicates.push(predicateCol);
                                }
                                else {
                                    predicateCol.operator = 'greaterthanorequal';
                                    predicateCol.predicate = 'and';
                                    const type = predicateCol.type;
                                    predicateCol.type = 'date';
                                    datePredicate = this.getPredicates([predicateCol, { field: predicateCol.field, operator: 'lessthanorequal', predicate: 'and',
                                            type: 'date', value: new Date(predicateVal.getFullYear(), type === 'year' ? 12 :
                                                predicateVal.getMonth() + 1, 0, 0, 0, 0) }]).predicates;
                                    if (!dateColData[predicateCol.field]) {
                                        dateColData[predicateCol.field] = this.getColData(filterCol.column[j], predicateCol.field, i);
                                    }
                                    filteredData = new DataManager(dateColData[predicateCol.field]).executeLocal(new Query().where(Predicate.and(datePredicate)));
                                    for (let k = 0; k < filteredData.length; k++) {
                                        predicates.push({ field: predicateCol.field, operator: 'equal', predicate: 'or', type: 'date',
                                            value: filteredData[k][predicateCol.field] });
                                    }
                                }
                            }
                        }
                        else {
                            filterOption = { isOpen: true, instance: { options: { type: predicateCol.type } },
                                arg3: predicateCol.value, arg2: predicateCol.operator };
                            this.beforeFilteringHandler(filterOption);
                            predicateCol.value = filterOption.arg3;
                            if (predicateCol.type === 'string' || predicateCol.type === 'custom') {
                                if (this.isCustomNumFilter(predicateCol.operator) && isNumber(predicateCol.value)) {
                                    predicateCol.type = 'number';
                                }
                            }
                            else if (predicateCol.type === 'date' && predicateCol.operator === 'equal' &&
                                typeof predicateCol.value === 'string' && predicateCol.value.includes('/') &&
                                predicateCol.value.includes(':')) {
                                const dateTimeStr = predicateCol.value.split(' ');
                                if (dateTimeStr.length === 2) {
                                    const dateArr = dateTimeStr[0].split('/');
                                    const timeArr = dateTimeStr[1].split(':');
                                    if (dateArr.length === 3 && timeArr.length === 3) {
                                        predicateCol.value = new Date(Number(dateArr[2]), Number(dateArr[0]) - 1, Number(dateArr[1]), Number(timeArr[0]), Number(timeArr[1]), Number(timeArr[2]));
                                    }
                                }
                            }
                            predicates.push(predicateCol);
                        }
                    }
                }
                if (!args.isOpen) {
                    for (let i = 0; i < predicates.length - 1; i++) {
                        if (predicates[i].field === predicates[i + 1].field) {
                            if (!predicates[i].predicate) {
                                predicates[i].predicate = 'or';
                            }
                            if (!predicates[i + 1].predicate) {
                                predicates[i + 1].predicate = 'or';
                            }
                        }
                    }
                }
                this.parent.notify(initiateFilterUI, { predicates: predicates.length ? predicates : undefined, range: filterCol.filterRange, sIdx: sIdx, isInternal: true, isOpen: args.isOpen });
            }
            if (this.parent.sortCollection) {
                this.parent.notify(sortImport, null);
            }
            this.parent.setProperties({ filterCollection: null }, true);
        }
    }
    getColData(colIdx, field, sheetIdx) {
        const sheet = getSheet(this.parent, sheetIdx);
        if (!sheet.rows || !sheet.rows.length) {
            return [];
        }
        const rows = [];
        let row;
        let cell;
        for (let rowIdx = 1, rowLen = sheet.rows.length; rowIdx < rowLen; rowIdx++) {
            if (sheet.rows[rowIdx]) {
                cell = getCell(rowIdx, colIdx, sheet, false, true);
                if (cell && cell.value) {
                    row = {};
                    row[field] = getValueFromFormat(this.parent, cell, rowIdx, colIdx);
                    rows.push(row);
                }
            }
        }
        return rows;
    }
    getFilterOperator(value) {
        switch (value) {
            case 'BeginsWith':
                value = 'startswith';
                break;
            case 'Less':
                value = 'lessthan';
                break;
            case 'EndsWith':
                value = 'endswith';
                break;
            case 'Equal':
                value = 'equal';
                break;
            case 'Notequal':
                value = 'notEqual';
                break;
            case 'Greater':
                value = 'greaterthan';
                break;
            case 'Contains':
                value = 'contains';
                break;
            case 'LessOrEqual':
                value = 'lessthanorequal';
                break;
            case 'GreaterOrEqual':
                value = 'greaterthanorequal';
                break;
            case 'NotContains':
                value = 'doesnotcontain';
                break;
            case 'NotBeginsWith':
                value = 'doesnotstartwith';
                break;
            case 'NotEndsWith':
                value = 'doesnotendwith';
                break;
            case 'Empty':
                value = 'isempty';
                break;
            case 'NotEmpty':
                value = 'isnotempty';
                break;
        }
        return value;
    }
    beforeInsertHandler(args) {
        if (args.modelType === 'Column') {
            const sheetIdx = isUndefined$1(args.activeSheetIndex) ? this.parent.activeSheetIndex : args.activeSheetIndex;
            if (this.filterRange.size && this.filterRange.has(sheetIdx)) {
                const range = this.filterRange.get(sheetIdx).range;
                if (this.isFilterCell(sheetIdx, range[0], args.index) || args.index < range[1]) {
                    range[3] += args.model.length;
                    if (args.index <= range[1]) {
                        range[1] += args.model.length;
                    }
                    this.filterCollection.get(sheetIdx).forEach((predicate) => {
                        const colIdx = getColIndex(predicate.field);
                        if (args.index <= colIdx) {
                            predicate.field = getColumnHeaderText(colIdx + args.model.length + 1);
                        }
                    });
                    if (this.parent.sortCollection) {
                        this.parent.sortCollection.forEach((sortCollection) => {
                            if (sortCollection.sheetIndex === sheetIdx && args.index <= sortCollection.columnIndex) {
                                sortCollection.columnIndex += args.model.length;
                            }
                        });
                    }
                }
            }
        }
        else if (args.modelType === 'Sheet') {
            for (const key of Array.from(this.filterRange.keys()).sort().reverse()) {
                if (args.index <= key) {
                    this.filterRange.set(key + args.model.length, this.filterRange.get(key));
                    this.filterRange.delete(key);
                    this.filterCollection.set(key + args.model.length, this.filterCollection.get(key));
                    this.filterCollection.delete(key);
                }
            }
            if (this.parent.sortCollection) {
                this.parent.sortCollection.forEach((sortCollection) => {
                    if (args.index <= sortCollection.sheetIndex) {
                        sortCollection.sheetIndex += args.model.length;
                    }
                });
            }
        }
    }
    beforeDeleteHandler(args) {
        if (args.modelType === 'Column') {
            const sheetIdx = this.parent.activeSheetIndex;
            if (this.filterRange.size && this.filterRange.has(sheetIdx)) {
                let isChanged = true;
                const range = this.filterRange.get(sheetIdx).range;
                if (args.start >= range[1] && args.end <= range[3]) { // in between
                    range[3] -= args.end - args.start + 1;
                }
                else if (args.start < range[1] && args.end < range[1]) { // before
                    range[1] -= args.end - args.start + 1;
                    range[3] -= args.end - args.start + 1;
                }
                else if (args.start < range[1] && args.end > range[1] && args.end < range[3]) { // from before to inbetween
                    range[1] = args.start;
                    range[3] -= args.end - args.start + 1;
                }
                else {
                    isChanged = false;
                }
                if (isChanged) {
                    const filterCollection = this.filterCollection.get(sheetIdx);
                    let isPredicateRemoved;
                    for (let i = filterCollection.length - 1; i >= 0; i--) {
                        const colIdx = getColIndex(filterCollection[i].field);
                        if (args.end < colIdx) {
                            filterCollection[i].field = getColumnHeaderText(colIdx - (args.end - args.start + 1) + 1);
                        }
                        else if (args.start <= colIdx && args.end >= colIdx) {
                            isPredicateRemoved = true;
                            filterCollection.splice(i, 1);
                        }
                    }
                    const sortColl = this.parent.sortCollection;
                    if (sortColl) {
                        for (let i = 0; i < sortColl.length; i++) {
                            if (sortColl[i].sheetIndex === sheetIdx) {
                                if (args.end < sortColl[i].columnIndex) {
                                    sortColl[i].columnIndex = sortColl[i].columnIndex - (args.end - args.start + 1);
                                    break;
                                }
                                else if (args.start <= sortColl[i].columnIndex && args.end >= sortColl[i].columnIndex) {
                                    sortColl.splice(i, 1);
                                    break;
                                }
                            }
                        }
                    }
                    if (range.some((value) => value < 0)) {
                        this.removeFilter(sheetIdx, true, true);
                        args.refreshSheet = true;
                    }
                    else if (isPredicateRemoved) {
                        if (filterCollection && filterCollection.length) {
                            this.reapplyFilterHandler(true, true);
                            args.refreshSheet = false;
                        }
                        else {
                            this.clearFilterHandler({ preventRefresh: true });
                            args.refreshSheet = true;
                        }
                    }
                }
            }
        }
    }
    deleteSheetHandler(args) {
        if (!isUndefined$1(args.sheetIndex)) {
            for (const key of Array.from(this.filterRange.keys()).sort().reverse()) {
                if (args.sheetIndex === key) {
                    this.filterRange.delete(key);
                    this.filterCollection.delete(key);
                }
                else if (args.sheetIndex < key) {
                    this.filterRange.set(key - 1, this.filterRange.get(key));
                    this.filterRange.delete(key);
                    this.filterCollection.set(key - 1, this.filterCollection.get(key));
                    this.filterCollection.delete(key);
                }
            }
            const sortColl = this.parent.sortCollection;
            if (sortColl) {
                for (let i = sortColl.length - 1; i >= 0; i--) {
                    if (args.sheetIndex === sortColl[i].sheetIndex) {
                        sortColl.splice(i, 1);
                    }
                    else if (args.sheetIndex < sortColl[i].sheetIndex) {
                        sortColl[i].sheetIndex -= 1;
                    }
                }
            }
        }
        else if (this.filterRange.get(this.parent.activeSheetIndex)) {
            this.filterRange.delete(this.parent.activeSheetIndex);
            this.filterCollection.delete(this.parent.activeSheetIndex);
        }
    }
    clearHandler(args) {
        const info = this.parent.getAddressInfo(args.range);
        if (this.filterRange.has(info.sheetIndex)) {
            const indexes = this.filterRange.get(info.sheetIndex).range.slice();
            if (inRange(info.indices, indexes[0], indexes[1]) && inRange(info.indices, indexes[0], indexes[3])) {
                this.removeFilter(info.sheetIndex, null, null, true);
            }
        }
    }
    duplicateSheetFilterHandler(args) {
        for (const key of Array.from(this.filterRange.keys()).sort().reverse()) {
            if (args.newSheetIndex <= key) {
                this.filterRange.set(key + 1, this.filterRange.get(key));
                this.filterRange.delete(key);
                this.filterCollection.set(key + 1, this.filterCollection.get(key));
                this.filterCollection.delete(key);
            }
            else {
                break;
            }
        }
        if (this.filterCollection.has(args.sheetIndex)) {
            this.filterCollection.set(args.newSheetIndex, [...this.filterCollection.get(args.sheetIndex)]);
        }
        if (this.filterRange.has(args.sheetIndex)) {
            const filterRange = this.filterRange.get(args.sheetIndex);
            this.filterRange.set(args.newSheetIndex, {
                useFilterRange: filterRange.useFilterRange, range: [...filterRange.range],
                allowHeaderFilter: filterRange.allowHeaderFilter
            });
        }
    }
    updateSortCollectionHandler(args) {
        if (args.isDuplicate) {
            if (this.parent.sortCollection && this.parent.sortCollection.length > 0) {
                const newSortCollection = [];
                for (let j = 0; j < this.parent.sortCollection.length; j++) {
                    const sortCol = this.parent.sortCollection[j];
                    if (sortCol.sheetIndex === args.curSheetIndex) {
                        const updatedSortCol = Object.assign({}, sortCol);
                        updatedSortCol.sheetIndex = args.newSheetIndex;
                        newSortCollection.push(updatedSortCol);
                    }
                }
                this.parent.sortCollection.push(...newSortCollection);
            }
            return;
        }
        const sheet = this.parent.getActiveSheet();
        const sheetIdx = this.parent.activeSheetIndex;
        const filterRange = this.filterRange.get(sheetIdx);
        if (filterRange) {
            const range = filterRange.range.slice();
            if (!filterRange.allowHeaderFilter) {
                range[0] = range[0] + 1; // to skip first row.
            }
            if (!filterRange.useFilterRange) {
                range[2] = sheet.usedRange.rowIndex; //filter range should be till used range.
            }
            const sortDescriptors = args.sortOptions.sortDescriptors;
            this.parent.sortCollection = this.parent.sortCollection ? this.parent.sortCollection : [];
            if (Array.isArray(sortDescriptors)) {
                for (let i = 0; i < sortDescriptors.length; i++) {
                    this.parent.sortCollection.push({
                        sortRange: getRangeAddress(range), columnIndex: getColIndex(sortDescriptors[i].field),
                        order: sortDescriptors[i].order, sheetIndex: sheetIdx
                    });
                }
            }
            else {
                this.parent.sortCollection.push({
                    sortRange: getRangeAddress(range), columnIndex: getIndexesFromAddress(sheet.activeCell)[1],
                    order: sortDescriptors.order, sheetIndex: sheetIdx
                });
            }
        }
    }
    moveSheetHandler(args) {
        let prevSheetFilterRange;
        let currentSheetFilterRange;
        let prevSheetFilterCollection;
        let currentSheetFilterCollection;
        if (this.filterRange.has(args.prevIndex)) {
            prevSheetFilterRange = this.filterRange.get(args.prevIndex);
            prevSheetFilterCollection = this.filterCollection.get(args.prevIndex);
        }
        if (this.filterRange.has(args.currentIndex)) {
            currentSheetFilterRange = this.filterRange.get(args.currentIndex);
            currentSheetFilterCollection = this.filterCollection.get(args.currentIndex);
        }
        if (prevSheetFilterRange && currentSheetFilterRange) {
            this.filterRange.set(args.currentIndex, prevSheetFilterRange);
            this.filterRange.set(args.prevIndex, currentSheetFilterRange);
            this.filterCollection.set(args.currentIndex, prevSheetFilterCollection);
            this.filterCollection.set(args.prevIndex, currentSheetFilterCollection);
        }
        else if (prevSheetFilterRange) {
            this.filterRange.set(args.currentIndex, prevSheetFilterRange);
            this.filterRange.delete(args.prevIndex);
            this.filterCollection.set(args.currentIndex, prevSheetFilterCollection);
            this.filterCollection.delete(args.prevIndex);
        }
        else if (currentSheetFilterRange) {
            this.filterRange.set(args.prevIndex, currentSheetFilterRange);
            this.filterRange.delete(args.currentIndex);
            this.filterCollection.set(args.prevIndex, currentSheetFilterCollection);
            this.filterCollection.delete(args.currentIndex);
        }
    }
    refreshFilterCellsOnResize(args) {
        const range = this.filterRange.has(this.parent.activeSheetIndex) &&
            this.filterRange.get(this.parent.activeSheetIndex).range;
        if (range && range[0] === args.rowIndex) {
            const sheet = this.parent.getActiveSheet();
            for (let colIdx = range[1]; colIdx <= range[3]; colIdx++) {
                if (getCell(args.rowIndex, colIdx, sheet, false, true).notes) {
                    const cellEle = this.parent.getCell(args.rowIndex, colIdx);
                    if (cellEle) {
                        this.parent.serviceLocator.getService('cell').refresh(args.rowIndex, colIdx, false, cellEle, false, false, true);
                    }
                }
            }
        }
    }
}

class SpreadsheetImage {
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
        this.renderImageUpload();
    }
    /**
     * Adding event listener for success and failure
     *
     * @returns {void} - Adding event listener for success and failure
     */
    addEventListener() {
        this.parent.on(insertImage, this.insertImage, this);
        this.parent.on(refreshImgCellObj, this.refreshImgCellObj, this);
        this.parent.on(createImageElement, this.createImageElement, this);
        this.parent.on(deleteImage, this.deleteImage, this);
        this.parent.on(refreshImagePosition, this.refreshInsDelImagePosition, this);
    }
    /**
     * Rendering upload component for importing images.
     *
     * @returns {void} - Rendering upload component for importing images.
     */
    renderImageUpload() {
        const uploadBox = this.parent.createElement('input', {
            id: this.parent.element.id + '_imageUpload',
            attrs: { type: 'file', accept: '.image, .jpg, .png, .gif ,jpeg', name: 'fileUpload' }
        });
        uploadBox.style.display = 'none';
        this.parent.element.appendChild(uploadBox);
        uploadBox.onchange = this.imageSelect.bind(this);
    }
    /**
     * Process after select the excel and image file.
     *
     * @param {Event} args - File select native event.
     * @returns {void} - Process after select the excel and image file.
     */
    imageSelect(args) {
        const file = args.target.files[0];
        if (!file) {
            return;
        }
        if (file.type.includes('image')) {
            this.insertImage({ file: file, isAction: true });
        }
        else {
            this.parent.serviceLocator.getService(dialog).show({ content: this.parent.serviceLocator.getService('spreadsheetLocale').getConstant('UnsupportedFile'),
                width: '300' });
        }
        args.target.value = '';
    }
    /**
     * Removing event listener for success and failure
     *
     * @returns {void} - Removing event listener for success and failure
     */
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(insertImage, this.insertImage);
            this.parent.off(refreshImgCellObj, this.refreshImgCellObj);
            this.parent.off(createImageElement, this.createImageElement);
            this.parent.off(deleteImage, this.deleteImage);
            this.parent.off(refreshImagePosition, this.refreshInsDelImagePosition);
        }
    }
    /* eslint-disable */
    insertImage(args, range) {
        this.binaryStringVal(args).then(src => this.createImageElement({ options: { src: src }, range: range, isPublic: true, isAction: args.isAction }));
    }
    binaryStringVal(args) {
        return new Promise((resolve, reject) => {
            let reader = new FileReader();
            reader.readAsDataURL(args.file);
            reader.onload = () => resolve(reader.result);
            reader.onerror = error => reject(error);
        });
    }
    /* eslint-enable */
    createImageElement(args) {
        const lastIndex = args.range ? args.range.lastIndexOf('!') : 0;
        const range = args.range ? (lastIndex > 0) ? args.range.substring(lastIndex + 1) : args.range
            : this.parent.getActiveSheet().selectedRange;
        const sheetIndex = (args.range && lastIndex > 0) ?
            getSheetIndex(this.parent, args.range.substring(0, lastIndex)) : this.parent.activeSheetIndex;
        const overlayObj = this.parent.serviceLocator.getService(overlay);
        const id = args.options.id ? args.options.id : getUniqueID(this.parent.element.id + '_overlay_picture_');
        const indexes = getRangeIndexes(range);
        const sheet = isUndefined$1(sheetIndex) && !args.isUndoRedo ? this.parent.getActiveSheet() :
            this.parent.sheets[sheetIndex];
        if (!sheet || this.parent.element.querySelector(`#${id}`)) {
            return;
        }
        if (args.isPublic && isReadOnlyCells(this.parent, indexes)) {
            if (args.isAction) {
                this.parent.notify(readonlyAlert, null);
            }
            return;
        }
        let eventArgs = { requestType: 'beforeInsertImage', range: sheet.name + '!' + range, imageData: args.options.src,
            sheetIndex: sheetIndex };
        if (args.isPublic) {
            this.parent.notify('actionBegin', { eventArgs: eventArgs, action: 'beforeInsertImage' });
        }
        if (eventArgs.cancel) {
            return;
        }
        let overlayProps = overlayObj.insertOverlayElement(id, range, sheetIndex);
        overlayProps.element.style.backgroundImage = 'url(\'' + args.options.src + '\')';
        if (args.options.height || args.options.left) {
            overlayProps.element.style.height = args.options.height + 'px';
            overlayProps.element.style.width = args.options.width + 'px';
            if (!isNullOrUndefined(args.options.top)) {
                overlayProps.element.style.top = Number(addDPRValue(args.options.top).toFixed(2)) + 'px';
            }
            if (!isNullOrUndefined(args.options.left)) {
                overlayProps.element.style.left = Number(addDPRValue(args.options.left).toFixed(2)) + 'px';
            }
        }
        if (sheet.frozenRows || sheet.frozenColumns) {
            overlayObj.adjustFreezePaneSize(args.options, overlayProps.element, range);
        }
        const imgData = {
            src: args.options.src, id: id, height: parseFloat(overlayProps.element.style.height.replace('px', '')),
            width: parseFloat(overlayProps.element.style.width.replace('px', '')),
            top: sheet.frozenRows || sheet.frozenColumns ? (indexes[0] ? getRowsHeight(sheet, 0, indexes[0] - 1) : 0) : overlayProps.top,
            left: sheet.frozenRows || sheet.frozenColumns ? (indexes[1] ? getColumnsWidth(sheet, 0, indexes[1] - 1) : 0) : overlayProps.left
        };
        this.parent.setUsedRange(indexes[0], indexes[1]);
        let isPositionChanged = false;
        const isElementRemoved = false;
        if (!args.isPublic && !args.isUndoRedo && (imgData.top !== args.options.top || imgData.left !== args.options.left)) {
            args.options.top = imgData.top;
            args.options.left = imgData.left;
            isPositionChanged = true;
        }
        const setImageEventArgs = {
            options: [imgData], range: sheet.name + '!' + range, isPositionChanged: isPositionChanged, isElementRemoved
        };
        if (args.isPublic || args.isUndoRedo || isPositionChanged) {
            this.parent.notify(setImage, setImageEventArgs);
        }
        if (isPositionChanged && setImageEventArgs.isElementRemoved) {
            overlayProps = overlayObj.insertOverlayElement(id, range, sheetIndex);
            overlayProps.element.style.backgroundImage = 'url(\'' + args.options.src + '\')';
        }
        const currCell = getCell(indexes[0], indexes[1], sheet);
        if (!currCell.image[currCell.image.length - 1].id) {
            currCell.image[currCell.image.length - 1].id = imgData.id;
        }
        if (!args.isUndoRedo && args.isPublic) {
            eventArgs = { requestType: 'insertImage', range: sheet.name + '!' + range, imageHeight: args.options.height ?
                    args.options.height : 300, imageWidth: args.options.width ? args.options.width : 400, imageData: args.options.src, id: id,
                sheetIndex: sheetIndex };
            this.parent.notify('actionComplete', { eventArgs: eventArgs, action: 'insertImage' });
        }
    }
    refreshInsDelImagePosition(args) {
        const count = args.count;
        const sheetIdx = args.sheetIdx;
        const sheet = this.parent.sheets[sheetIdx];
        let pictureElements;
        const currCellObj = getCell(args.rowIdx, args.colIdx, sheet);
        const imageLen = currCellObj.image.length;
        let top;
        let left;
        for (let i = 0; i < imageLen; i++) {
            pictureElements = document.getElementById(currCellObj.image[i].id);
            top = (args.type === 'Row') ? (args.status === 'insert') ? currCellObj.image[i].top + (count * 20) :
                currCellObj.image[i].top - (count * 20) : currCellObj.image[i].top;
            left = (args.type === 'Column') ? (args.status === 'insert') ? currCellObj.image[i].left + (count * 64) :
                currCellObj.image[i].left - (count * 64) : currCellObj.image[i].left;
            currCellObj.image[i].top = top;
            currCellObj.image[i].left = left;
            if (pictureElements) {
                pictureElements.style.top = top + 'px';
                pictureElements.style.left = left + 'px';
            }
        }
    }
    refreshImgCellObj(args) {
        const sheetIndex = isUndefined$1(args.sheetIdx) ? this.parent.activeSheetIndex : args.sheetIdx;
        const sheet = getSheet(this.parent, sheetIndex);
        const prevCellObj = getCell(args.prevRowIdx, args.prevColIdx, sheet);
        const currCellObj = getCell(args.currentRowIdx, args.currentColIdx, sheet);
        const prevCellImg = prevCellObj ? prevCellObj.image : [];
        let prevImgObj;
        let currImgObj;
        const prevCellImgLen = (prevCellImg && prevCellImg.length) ? prevCellImg.length : 0;
        if (prevCellObj && prevCellObj.image && prevCellImg.length > 0) {
            for (let i = 0; i < prevCellImgLen; i++) {
                if (prevCellImg[i] && prevCellImg[i].id === args.id) {
                    prevImgObj = prevCellImg[i];
                    prevImgObj.height = args.currentHeight;
                    prevImgObj.width = args.currentWidth;
                    prevImgObj.top = args.currentTop;
                    prevImgObj.left = args.currentLeft;
                    prevCellImg.splice(i, 1);
                }
            }
            if (currCellObj && currCellObj.image) {
                currImgObj = currCellObj.image;
                if (prevImgObj) {
                    currImgObj.push(prevImgObj);
                }
            }
            if (currImgObj) {
                setCell(args.currentRowIdx, args.currentColIdx, sheet, { image: currImgObj }, true);
            }
            else {
                setCell(args.currentRowIdx, args.currentColIdx, sheet, { image: [prevImgObj] }, true);
            }
            if (args.requestType === 'imageRefresh' && !args.isUndoRedo) {
                const eventArgs = {
                    requestType: 'imageRefresh', currentRowIdx: args.currentRowIdx, currentColIdx: args.currentColIdx,
                    prevRowIdx: args.prevRowIdx, prevColIdx: args.prevColIdx, prevTop: args.prevTop, prevLeft: args.prevLeft,
                    currentTop: args.currentTop, currentLeft: args.currentLeft, currentHeight: args.currentHeight,
                    currentWidth: args.currentWidth, prevHeight: args.prevHeight, prevWidth: args.prevWidth,
                    id: args.id, sheetIdx: this.parent.activeSheetIndex
                };
                this.parent.notify('actionComplete', { eventArgs: eventArgs, action: 'imageRefresh' });
            }
        }
    }
    deleteImage(args) {
        let sheet = args.sheet || this.parent.getActiveSheet();
        const pictureElements = document.getElementById(args.id);
        let rowIdx = args.rowIdx;
        let colIdx = args.colIdx;
        let address;
        if (pictureElements) {
            if (args.rowIdx === undefined && args.colIdx === undefined) {
                let imgTop;
                let imgleft;
                if (sheet.frozenRows || sheet.frozenColumns) {
                    const clientRect = pictureElements.getBoundingClientRect();
                    imgTop = { clientY: clientRect.top };
                    imgleft = { clientX: clientRect.left };
                    if (clientRect.top < this.parent.getColumnHeaderContent().getBoundingClientRect().bottom) {
                        imgTop.target = this.parent.getColumnHeaderContent();
                    }
                    if (clientRect.left < this.parent.getRowHeaderContent().getBoundingClientRect().right) {
                        imgleft.target = this.parent.getRowHeaderTable();
                    }
                }
                else {
                    imgTop = { clientY: parseFloat(pictureElements.style.top), isImage: true };
                    imgleft = { clientX: parseFloat(pictureElements.style.left), isImage: true };
                }
                this.parent.notify(getRowIdxFromClientY, imgTop);
                this.parent.notify(getColIdxFromClientX, imgleft);
                rowIdx = imgTop.clientY;
                colIdx = imgleft.clientX;
            }
            address = sheet.name + '!' + getCellAddress(rowIdx, colIdx);
            if (!args.preventEventTrigger) {
                const eventArgs = { address: address, cancel: false };
                this.parent.notify(beginAction, { action: 'deleteImage', eventArgs: eventArgs });
                if (eventArgs.cancel) {
                    return;
                }
            }
            document.getElementById(args.id).remove();
        }
        else if (!args.sheet) {
            const rangeVal = args.range ? args.range.lastIndexOf('!') > 0 ? args.range.substring(args.range.lastIndexOf('!') + 1)
                : args.range : this.parent.getActiveSheet().selectedRange;
            const sheetIndex = args.range && args.range.lastIndexOf('!') > 0 ?
                getSheetIndex(this.parent, args.range.substring(0, args.range.lastIndexOf('!'))) :
                this.parent.activeSheetIndex;
            const index = getRangeIndexes(rangeVal);
            rowIdx = index[0];
            colIdx = index[1];
            sheet = this.parent.sheets[sheetIndex];
        }
        let image = {};
        if (sheet) {
            const cellObj = getCell(rowIdx, colIdx, sheet);
            const prevCellImg = (cellObj && cellObj.image) ? cellObj.image : [];
            const imgLength = prevCellImg.length;
            for (let i = imgLength - 1; i >= 0; i--) {
                if (prevCellImg[i].id === args.id) {
                    image = prevCellImg.splice(i, 1)[0];
                }
            }
            setCell(rowIdx, colIdx, sheet, { image: prevCellImg }, true);
        }
        if (!args.preventEventTrigger) {
            this.parent.notify(completeAction, { action: 'deleteImage', eventArgs: { address: address, id: image.id, imageData: image.src, imageWidth: image.width, imageHeight: image.height, cancel: false }, preventAction: args.isUndoRedo, isClearAction: args.clearAction });
        }
    }
    /**
     * To Remove the event listeners.
     *
     * @returns {void} - To Remove the event listeners.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
    }
    /**
     * Get the sheet picture module name.
     *
     * @returns {string} - Get the sheet picture module name.
     */
    getModuleName() {
        return 'spreadsheetImage';
    }
}

Chart$1.Inject(ColumnSeries, LineSeries, BarSeries, AreaSeries, StackingColumnSeries, StackingLineSeries, StackingBarSeries, ScatterSeries);
Chart$1.Inject(StackingAreaSeries, Category, Legend, Tooltip$1, DataLabel);
AccumulationChart.Inject(PieSeries, AccumulationTooltip, AccumulationDataLabel, AccumulationLegend);
/**
 * Represents Chart support for Spreadsheet.
 */
class SpreadsheetChart {
    /**
     * Constructor for the Spreadsheet Chart module.
     *
     * @param {Spreadsheet} parent - Constructor for the Spreadsheet Chart module.
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * Adding event listener for success and failure
     *
     * @returns {void} - Adding event listener for success and failure
     */
    addEventListener() {
        this.parent.on(initiateChart, this.initiateChartHandler, this);
        this.parent.on(refreshChartCellObj, this.refreshChartCellObj, this);
        this.parent.on(refreshChartCellModel, this.refreshChartCellModel, this);
        this.parent.on(refreshChartCellOnInit, this.refreshChartCellObj, this);
        this.parent.on(deleteChart, this.deleteChart, this);
        this.parent.on(clearChartBorder, this.clearBorder, this);
        this.parent.on(insertChart, this.insertChartHandler, this);
        this.parent.on(chartRangeSelection, this.chartRangeHandler, this);
        this.parent.on(chartDesignTab, this.chartDesignTabHandler, this);
        this.parent.on(addChartEle, this.updateChartElement, this);
        this.parent.on(undoRedoForChartDesign, this.undoRedoForChartDesign, this);
        this.parent.on(refreshChart, this.refreshChartData, this);
    }
    insertChartHandler(args) {
        let chartType = 'Column';
        let markerVisible = false;
        switch (args.id) {
            case 'clusteredColumn':
                chartType = 'Column';
                break;
            case 'stackedColumn':
                chartType = 'StackingColumn';
                break;
            case 'stackedColumn100':
                chartType = 'StackingColumn100';
                break;
            case 'clusteredBar':
                chartType = 'Bar';
                break;
            case 'stackedBar':
                chartType = 'StackingBar';
                break;
            case 'stackedBar100':
                chartType = 'StackingBar100';
                break;
            case 'area':
                chartType = 'Area';
                break;
            case 'stackedArea':
                chartType = 'StackingArea';
                break;
            case 'stackedArea100':
                chartType = 'StackingArea100';
                break;
            case 'line':
                chartType = 'Line';
                break;
            case 'lineMarker':
                chartType = 'Line';
                markerVisible = true;
                break;
            case 'stackedLine':
                chartType = 'StackingLine';
                break;
            case 'stackedLineMarker':
                chartType = 'StackingLine';
                markerVisible = true;
                break;
            case 'stackedLine100':
                chartType = 'StackingLine100';
                break;
            case 'stackedLine100Marker':
                chartType = 'StackingLine100';
                markerVisible = true;
                break;
            case 'pie':
                chartType = 'Pie';
                break;
            case 'doughnut':
                chartType = 'Doughnut';
                break;
            //  case 'radar':
            //     chartType = ;
            //     break;
            //  case 'radar_markers':
            //     chartType = 'Column';
            //     break;
            case 'scatter':
                chartType = 'Scatter';
                break;
        }
        const chart = [{ type: chartType, markerSettings: { visible: markerVisible, isFilled: true } }];
        if (args.isChart) {
            this.parent.notify(setChart, { chart: chart });
            getUpdateUsingRaf(() => focus(this.parent.element));
        }
        else {
            this.parent.notify(chartDesignTab, { chartType: chartType, triggerEvent: true, markerVisible: markerVisible });
        }
    }
    chartRangeHandler() {
        const overlayEle = document.querySelector('.e-datavisualization-chart.e-ss-overlay-active');
        if (overlayEle) {
            const chartId = overlayEle.getElementsByClassName('e-control')[0].id;
            const chartColl = this.parent.chartColl;
            const chartCollLen = chartColl.length;
            for (let idx = 0; idx < chartCollLen; idx++) {
                const chartEle = document.getElementById(chartColl[idx].id);
                if (overlayEle && chartEle && chartColl[idx].id === chartId) {
                    this.initiateChartHandler({ option: chartColl[idx], isRefresh: true });
                }
            }
        }
    }
    refreshChartData(args) {
        if (!this.parent.chartColl || !this.parent.chartColl.length) {
            return;
        }
        let chart;
        let sheetName;
        let range;
        let insideRange;
        let chartEle;
        let chartObj;
        for (let i = 0, len = this.parent.chartColl.length; i < len; i++) {
            chart = this.parent.chartColl[i];
            if (chart.range.includes('!')) {
                sheetName = chart.range.substring(0, chart.range.lastIndexOf('!'));
                if (this.parent.activeSheetIndex !== getSheetIndex(this.parent, sheetName)) {
                    continue;
                }
                range = chart.range.substring(chart.range.lastIndexOf('!') + 1);
            }
            else {
                range = chart.range;
            }
            if (args.viewportIndexes) {
                for (let idx = 0; idx < args.viewportIndexes.length; idx++) {
                    if (checkRange([args.viewportIndexes[idx]], range)) {
                        insideRange = true;
                        break;
                    }
                }
            }
            else {
                insideRange = args.range ? checkRange([args.range], range) : (args.showHide ? this.inRowColumnRange(getRangeIndexes(range), args.rIdx, args.showHide) : inRange(getRangeIndexes(range), args.rIdx, args.cIdx));
            }
            if (insideRange || (args.isSelectAll && !args.isRefreshChart)) {
                chartEle = this.parent.element.querySelector('.' + chart.id);
                if (chartEle) {
                    chartObj = getComponent(chartEle, 'chart') || getComponent(chartEle, 'accumulationchart');
                    if (chartObj) {
                        chartObj.series = this.initiateChartHandler({ option: chart, isRefresh: true });
                        chartObj.refresh();
                    }
                }
            }
        }
    }
    inRowColumnRange(range, index, showHide) {
        return showHide === 'rows' ? index >= range[0] && index <= range[2] : index >= range[1] && index <= range[3];
    }
    refreshChartCellModel(args) {
        for (let i = 0, len = args.prevChartIndexes.length; i < len; i++) {
            const chart = args.prevChartIndexes[i].chart;
            const prevRowIdx = args.prevChartIndexes[i].chartRowIdx;
            const prevColIdx = args.prevChartIndexes[i].chartColIdx;
            const currentRowIdx = args.currentChartIndexes[i].chartRowIdx;
            const currentColIdx = args.currentChartIndexes[i].chartColIdx;
            const eventArgs = {
                prevTop: chart.top, prevLeft: chart.left, prevRowIdx: prevRowIdx, prevColIdx: prevColIdx,
                prevHeight: chart.height, prevWidth: chart.width, currentTop: chart.top, currentLeft: chart.left,
                currentRowIdx: currentRowIdx, currentColIdx: currentColIdx, currentHeight: chart.height,
                currentWidth: chart.width, id: chart.id, requestType: 'chartRefreshOnFilter'
            };
            this.parent.notify(refreshChartCellObj, eventArgs);
        }
    }
    refreshChartCellObj(args) {
        const sheetIndex = isUndefined$1(args.sheetIdx) ? this.parent.activeSheetIndex : args.sheetIdx;
        const sheet = getSheet(this.parent, sheetIndex);
        const prevCellObj = getCell(args.prevRowIdx, args.prevColIdx, sheet);
        const currCellObj = getCell(args.currentRowIdx, args.currentColIdx, sheet);
        const prevCellChart = prevCellObj ? prevCellObj.chart : [];
        let prevChartObj;
        let currChartObj;
        let prevCellChartLen = (prevCellChart && prevCellChart.length) ? prevCellChart.length : 0;
        if (prevCellChartLen) {
            for (let i = 0; i < prevCellChartLen; i++) {
                if (prevCellChart[i].id === args.id.split('_overlay')[0]) {
                    prevChartObj = prevCellChart[i];
                    prevChartObj.height = args.currentHeight;
                    prevChartObj.width = args.currentWidth;
                    prevChartObj.top = args.currentTop;
                    prevChartObj.left = args.currentLeft;
                    prevCellChart.splice(i, 1);
                    i--;
                    prevCellChartLen--;
                    for (let idx = 0, chartCollLen = this.parent.chartColl.length; idx < chartCollLen; idx++) {
                        if (prevChartObj.id === this.parent.chartColl[idx].id) {
                            prevChartObj.height = args.currentHeight;
                            this.parent.chartColl[idx].width = args.currentWidth;
                            this.parent.chartColl[idx].top = args.currentTop;
                            this.parent.chartColl[idx].left = args.currentLeft;
                        }
                    }
                }
            }
            if (currCellObj && currCellObj.chart) {
                currChartObj = currCellObj.chart;
                if (prevChartObj) {
                    currChartObj.push(prevChartObj);
                }
            }
            if (currChartObj) {
                setCell(args.currentRowIdx, args.currentColIdx, sheet, { chart: currChartObj }, true);
            }
            else {
                setCell(args.currentRowIdx, args.currentColIdx, sheet, { chart: [prevChartObj] }, true);
            }
            if (args.requestType === 'chartRefresh' && !args.isUndoRedo) {
                const eventArgs = {
                    requestType: 'chartRefresh', currentRowIdx: args.currentRowIdx, currentColIdx: args.currentColIdx,
                    currentWidth: args.currentWidth, prevHeight: args.prevHeight, prevWidth: args.prevWidth,
                    prevRowIdx: args.prevRowIdx, prevColIdx: args.prevColIdx, prevTop: args.prevTop, prevLeft: args.prevLeft,
                    currentTop: args.currentTop, currentLeft: args.currentLeft, currentHeight: args.currentHeight,
                    id: args.id, sheetIdx: sheetIndex
                };
                this.parent.notify('actionComplete', { eventArgs: eventArgs, action: 'chartRefresh' });
            }
        }
    }
    processChartRange(range, dataSheetIdx, opt) {
        let xRange;
        let yRange;
        let lRange;
        const minr = range[0];
        const minc = range[1];
        let isStringSeries = false;
        const maxr = range[2];
        const maxc = range[3];
        const isSingleRow = minr === maxr;
        const isSingleCol = minc === maxc;
        let isDateTimeFormat;
        let isDateTime;
        const sheet = getSheet(this.parent, dataSheetIdx);
        const autoDetectFormatFn = getAutoDetectFormatParser(this.parent);
        const getPropertyValue = (rIdx, cIdx, isFirstCol, checkDateTime) => {
            const cell = getCell(rIdx, cIdx, sheet);
            if (cell) {
                if (cell.formula && isNullOrUndefined(cell.value)) {
                    this.parent.notify(calculateFormula, { cell: cell, rowIdx: rIdx, colIdx: cIdx, sheetIndex: dataSheetIdx });
                }
                let value;
                if (cell.format) {
                    const formatObj = { value: cell.value, format: cell.format, formattedText: cell.value, cell: cell,
                        rowIndex: rIdx, colIndex: cIdx };
                    this.parent.notify(getFormattedCellObject, formatObj);
                    const isNum = isNumber(cell.value);
                    if (isNum && !isCustomDateTime(cell.format, true, null, true)) {
                        value = Number(cell.value);
                    }
                    else {
                        if (checkDateTime && isNum) {
                            isDateTimeFormat = true;
                        }
                        else if (isFirstCol && isNum) {
                            isDateTime = true;
                        }
                        value = formatObj.formattedText && formatObj.formattedText.toString();
                    }
                }
                else {
                    autoDetectFormatFn(cell);
                    value = cell.value;
                }
                return isNullOrUndefined(value) ? '' : value;
            }
            else {
                return '';
            }
        };
        const trVal = sheet ? getPropertyValue(minr, maxc, false, true) : '';
        const blVal = sheet ? getPropertyValue(maxr, minc, true) : '';
        const tlVal = sheet ? getPropertyValue(minr, minc, true) : '';
        if (!isNumber(blVal) || !tlVal) {
            isStringSeries = true;
        }
        if ((isNullOrUndefined(tlVal) || (opt.type === 'Scatter' && !opt.isSeriesInRows)) && !isSingleRow && !isSingleCol) {
            xRange = [minr + 1, minc, maxr, minc];
            yRange = [minr + 1, minc + 1, maxr, maxc];
            lRange = [minr, minc + 1, minr, maxc];
        }
        else if (!isNullOrUndefined(blVal) && isStringSeries && !isSingleRow && !isSingleCol && !isDateTimeFormat) {
            if (!isNullOrUndefined(trVal) && (!isNumber(trVal) || !tlVal)) {
                xRange = [minr + 1, minc, maxr, minc];
                yRange = [minr + 1, minc + 1, maxr, maxc];
                lRange = [minr, minc + 1, minr, maxc];
            }
            else {
                xRange = [minr, minc, maxr, minc];
                yRange = [minr, minc + 1, maxr, maxc];
            }
        }
        else {
            yRange = [minr, minc, maxr, maxc];
            if ((!isNullOrUndefined(trVal) && !isNumber(trVal) && !isDateTimeFormat)) {
                lRange = [minr, minc, minr, maxc];
                if (!isSingleRow) {
                    yRange[0] = yRange[0] + 1;
                }
            }
            else if ((isSingleRow || isSingleCol) && isNullOrUndefined(tlVal)) {
                lRange = [minr, minc, minr, maxc];
                if (isSingleRow) {
                    yRange[1] = yRange[1] + 1;
                    lRange[3] = lRange[1];
                }
                else {
                    yRange[0] = yRange[0] + 1;
                }
            }
        }
        return { xRange: xRange, yRange: yRange, lRange: lRange, isStringSeries: isStringSeries, isDateTime: isDateTime };
    }
    getRangeData(options) {
        const sheet = options.sheet;
        if (!options.range) {
            options.range = getRangeIndexes(sheet.selectedRange);
        }
        else if (typeof (options.range) === 'string') {
            options.range = getRangeIndexes(options.range);
        }
        const rangeData = [];
        let rObj;
        let cIdx;
        let formatArgs;
        let rIdx = options.range[0];
        const autoDetectFormatFn = options.isYvalue && getAutoDetectFormatParser(this.parent);
        while (rIdx <= options.range[2]) {
            if (isHiddenRow(sheet, rIdx)) {
                rIdx++;
                continue;
            }
            cIdx = options.range[1];
            while (cIdx <= options.range[3]) {
                if (isHiddenCol(sheet, cIdx)) {
                    cIdx++;
                    continue;
                }
                const cell = getCell(rIdx, cIdx, sheet, false, true);
                if (cell.formula && isNullOrUndefined(cell.value)) {
                    this.parent.notify(calculateFormula, { cell: cell, rowIdx: rIdx, colIdx: cIdx, sheetIndex: options.sheetIdx });
                }
                if (options.isYvalue) {
                    autoDetectFormatFn(cell);
                }
                rObj = { value: cell.value || (cell.value === 0 ? 0 : null) };
                if (cell.format) {
                    formatArgs = { formattedText: cell.value, value: cell.value, format: cell.format, cell: cell, skipFormatCheck: true };
                    this.parent.notify(getFormattedCellObject, formatArgs);
                    if (options.isYvalue) {
                        if (isNumber(cell.value)) {
                            rObj.value = Number(cell.value);
                            rObj.displayText = formatArgs.formattedText ? formatArgs.formattedText.toString() : '';
                        }
                        else {
                            rObj.displayText = rObj.value === null ? '' : this.parent.getDisplayText({ format: cell.format, value: '0' });
                            rObj.value = 0;
                        }
                    }
                    else {
                        if (options.isScatter && !options.isDateTime && isNumber(cell.value)) {
                            rObj.value = Number(cell.value);
                        }
                        else {
                            rObj.value = formatArgs.formattedText ? formatArgs.formattedText.toString() : null;
                        }
                    }
                }
                else if (options.isYvalue) {
                    if (isNumber(rObj.value)) {
                        rObj.displayText = rObj.value.toString();
                        rObj.value = Number(rObj.value);
                    }
                    else {
                        rObj.displayText = rObj.value === null ? '' : '0';
                        rObj.value = 0;
                    }
                }
                rangeData.push(rObj);
                cIdx++;
            }
            rIdx++;
        }
        return rangeData;
    }
    toArrayData(args) {
        const prop = 'value';
        let obj;
        let i = 0;
        const temp = [];
        const len = args.length;
        while (i < len) {
            obj = args[i];
            if (Object.keys(obj).length) {
                if (prop in obj) {
                    temp.push(obj[`${prop}`]);
                }
            }
            else {
                temp.push('');
            }
            i++;
        }
        return temp;
    }
    getVirtualXValues(limit) {
        let i = 1;
        const arr = [];
        while (i < limit) {
            arr.push(i.toString());
            i++;
        }
        return arr;
    }
    processChartSeries(options, sheetIndex, xRange, yRange, lRange, isDateTime) {
        options = options || {};
        let seriesName;
        const dataLabel = { name: 'displayText' };
        let xValue;
        let lValue;
        let diff;
        let pArr;
        let pObj = {};
        let j;
        let i = 0;
        let yInc = 0;
        const isPrint = this.parent.isPrintingProcessing;
        const sArr = [];
        sheetIndex = isNullOrUndefined(sheetIndex) ? this.parent.activeSheetIndex : sheetIndex;
        const sheet = getSheet(this.parent, sheetIndex);
        const isScatter = options && options.type === 'Scatter';
        const yValue = this.getRangeData({ range: yRange, sheet: sheet, isYvalue: true, sheetIdx: sheetIndex });
        const rDiff = ((yRange[2] - yRange[0]) + 1) - this.parent.hiddenCount(yRange[0], yRange[2], 'rows', sheet);
        const cDiff = ((yRange[3] - yRange[1]) + 1) - this.parent.hiddenCount(yRange[1], yRange[3], 'columns', sheet);
        if (options.isSeriesInRows) {
            xValue = lRange ? this.toArrayData(this.getRangeData({ range: lRange, sheet: sheet, isScatter: isScatter,
                isDateTime: isDateTime })) : this.getVirtualXValues(cDiff + 1);
            if (xRange) {
                lValue = this.toArrayData(this.getRangeData({ range: xRange, sheet: sheet }));
            }
            diff = rDiff;
        }
        else {
            xValue = xRange ? this.toArrayData(this.getRangeData({ range: xRange, sheet: sheet, isScatter: isScatter,
                isDateTime: isDateTime })) : this.getVirtualXValues(rDiff + 1);
            if (lRange) {
                lValue = this.toArrayData(this.getRangeData({ range: lRange, sheet: sheet }));
            }
            diff = cDiff;
        }
        const len = xValue.length;
        const inc = options.isSeriesInRows ? 1 : diff;
        if (!isNullOrUndefined(options.dataLabelSettings)) {
            dataLabel.visible = options.dataLabelSettings.visible;
            dataLabel.position = options.dataLabelSettings.position;
        }
        while (i < diff) {
            j = 0;
            pArr = [];
            yInc = options.isSeriesInRows ? yInc : i;
            while (j < len) {
                if (isNullOrUndefined(xValue[j])) {
                    xValue[j] = getUniqueID('spread-chart-empty-label-');
                }
                pArr.push({ x: xValue[j], y: yValue[yInc].value, displayText: yValue[yInc].displayText });
                yInc += inc;
                j++;
            }
            if (lValue && lValue.length > 0) {
                seriesName = lValue[i];
            }
            else {
                seriesName = options.type === 'Scatter' ? ('series' + (i + 1)) : ('series' + i);
            }
            seriesName = isNullOrUndefined(seriesName) ? '' : seriesName.toString();
            if (options.type) {
                const type = options.type;
                if (type === 'Line' || type === 'StackingLine' || type === 'StackingLine100') {
                    pObj = {
                        dataSource: pArr, type: options.type, xName: 'x', yName: 'y', name: seriesName,
                        animation: { enable: !isPrint }, tooltipMappingName: 'displayText',
                        marker: options.markerSettings ? { visible: options.markerSettings.visible, width: options.markerSettings.size,
                            height: options.markerSettings.size, shape: options.markerSettings.shape, dataLabel: dataLabel,
                            isFilled: options.markerSettings.isFilled, border: options.markerSettings.border,
                            fill: options.markerSettings.isFilled ? options.markerSettings.fill : null } : { dataLabel: dataLabel }
                    };
                }
                else if (type === 'Scatter') {
                    pObj = {
                        dataSource: pArr, type: options.type, xName: 'x', yName: 'y', name: seriesName,
                        tooltipMappingName: 'displayText', animation: { enable: !isPrint },
                        marker: { visible: false, width: 12, height: 12, shape: 'Circle', dataLabel: dataLabel }
                    };
                }
                else if (type === 'Pie' || type === 'Doughnut') {
                    pObj = {
                        dataSource: pArr, radius: '100%', xName: 'x', yName: 'y', innerRadius: options.type === 'Pie' ? '0%' : '40%',
                        dataLabel: { visible: !!dataLabel.visible, position: dataLabel.position === 'Outer' ? 'Outside' : 'Inside',
                            name: 'displayText', font: { fontWeight: '600' } },
                        animation: { enable: !isPrint }, tooltipMappingName: 'displayText'
                    };
                }
                else {
                    pObj = {
                        dataSource: pArr, type: options.type, xName: 'x', yName: 'y', animation: { enable: !isPrint },
                        name: seriesName, marker: { dataLabel: dataLabel }, tooltipMappingName: 'displayText'
                    };
                }
            }
            sArr.push(pObj);
            i++;
        }
        let retVal;
        if (options.type) {
            retVal = {
                series: sArr, xRange: options.isSeriesInRows ? lRange : xRange,
                yRange: yRange, lRange: options.isSeriesInRows ? xRange : lRange
            };
        }
        return retVal;
    }
    getAxisFormat(yRange) {
        let format = '';
        if (!isNullOrUndefined(yRange)) {
            const cell = getCell(yRange[0], yRange[1], this.parent.getActiveSheet());
            if (cell && cell.format) {
                format = cell.format;
            }
        }
        return format;
    }
    focusChartRange(xRange, yRange, lRange) {
        const border = ['e-rcborderright', 'e-rcborderbottom', 'e-vcborderright', 'e-vcborderbottom', 'e-bcborderright', 'e-bcborderbottom'];
        this.clearBorder();
        let range;
        const sheet = this.parent.getActiveSheet();
        const isFreezePane = !!(sheet.frozenRows || sheet.frozenColumns);
        if (lRange) {
            if (isFreezePane) {
                range = lRange;
            }
            else {
                this.parent.notify(focusBorder, {
                    startcell: { rowIndex: lRange[0], colIndex: lRange[1] },
                    endcell: { rowIndex: lRange[2], colIndex: lRange[3] }, classes: [border[0], border[1]]
                });
            }
        }
        if (xRange) {
            if (isFreezePane) {
                if (range) {
                    range[0] = Math.min(lRange[0], xRange[0]);
                    range[1] = Math.min(lRange[1], xRange[1]);
                    range[2] = Math.max(lRange[2], xRange[2]);
                    range[3] = Math.max(lRange[3], xRange[3]);
                }
                else {
                    range = xRange;
                }
            }
            else {
                this.parent.notify(focusBorder, {
                    startcell: { rowIndex: xRange[0], colIndex: xRange[1] },
                    endcell: { rowIndex: xRange[2], colIndex: xRange[3] }, classes: [border[2], border[3]]
                });
            }
        }
        if (isFreezePane && range) {
            this.parent.notify(focusBorder, {
                startcell: { rowIndex: Math.min(range[0], yRange[0]), colIndex: Math.min(range[1], yRange[1]) },
                endcell: {
                    rowIndex: Math.max(range[2], yRange[2]), colIndex: Math.max(range[3], yRange[3])
                }, classes: [border[4], border[5]]
            });
        }
        else {
            this.parent.notify(focusBorder, {
                startcell: { rowIndex: yRange[0], colIndex: yRange[1] },
                endcell: { rowIndex: yRange[2], colIndex: yRange[3] }, classes: [border[4], border[5]]
            });
        }
    }
    clearBorder() {
        const sheet = this.parent.getActiveSheet();
        if (sheet.frozenColumns || sheet.frozenRows) {
            const chartIndicator = [].slice.call(this.parent.element.getElementsByClassName('e-chart-range'));
            chartIndicator.forEach((indicator) => { detach(indicator); });
            return;
        }
        const mainCont = this.parent.getMainContent();
        const border = ['e-rcborderright', 'e-rcborderbottom', 'e-vcborderright', 'e-vcborderbottom', 'e-bcborderright', 'e-bcborderbottom'];
        for (let borderIdx = 0, borderLen = border.length; borderIdx < borderLen; borderIdx++) {
            const eleColl = mainCont.querySelectorAll('.' + border[borderIdx]);
            for (let tdIdx = 0, eleCollLen = eleColl.length; tdIdx < eleCollLen; tdIdx++) {
                const td = eleColl[tdIdx];
                td.classList.remove(border[borderIdx]);
            }
        }
    }
    initiateChartHandler(argsOpt) {
        const chart = argsOpt.option;
        let isRangeSelect = true;
        isRangeSelect = isNullOrUndefined(argsOpt.isInitCell) ? true : !argsOpt.isInitCell;
        argsOpt.triggerEvent = isNullOrUndefined(argsOpt.triggerEvent) ? true : argsOpt.triggerEvent;
        let seriesModel;
        argsOpt.isRefresh = isNullOrUndefined(argsOpt.isRefresh) ? false : argsOpt.isRefresh;
        const sheetIdx = (chart.range && chart.range.lastIndexOf('!') > 0) ?
            getSheetIndex(this.parent, chart.range.substring(0, chart.range.lastIndexOf('!'))) : this.parent.activeSheetIndex;
        const sheet = getSheet(this.parent, sheetIdx);
        let range = chart.range ? chart.range : this.parent.getActiveSheet().selectedRange;
        const rangeIdx = getRangeIndexes(range);
        let options = {};
        let isRowLesser;
        let eventArgs;
        if (!this.parent.allowChart && sheet.isProtected) {
            return seriesModel;
        }
        const args = {
            sheetIndex: sheetIdx, reqType: 'shape', type: 'actionBegin', shapeType: 'chart',
            action: 'create', options: chart, range: range, operation: 'create'
        };
        options = args.options;
        range = args.range;
        options = options || {};
        if (rangeIdx.length > 0 && !argsOpt.isRefresh && isRangeSelect) {
            const rDiff = rangeIdx[2] - rangeIdx[0];
            const cDiff = rangeIdx[3] - rangeIdx[1];
            if (rDiff < cDiff) {
                isRowLesser = true;
            }
        }
        options.isSeriesInRows = isRowLesser ? true : options.isSeriesInRows ? options.isSeriesInRows : false;
        argsOpt.dataSheetIdx = isNullOrUndefined(argsOpt.dataSheetIdx) ? sheetIdx : argsOpt.dataSheetIdx;
        const chartRange = this.processChartRange(rangeIdx, argsOpt.dataSheetIdx, options);
        const xRange = chartRange.xRange;
        const yRange = chartRange.yRange;
        const lRange = chartRange.lRange;
        if (sheetIdx === this.parent.activeSheetIndex && isRangeSelect) {
            this.focusChartRange(xRange, yRange, lRange);
        }
        if (argsOpt.triggerEvent && !argsOpt.isRefresh) {
            eventArgs = {
                type: chart.type, theme: chart.theme, isSeriesInRows: chart.isSeriesInRows, range: chart.range,
                markerSettings: options.markerSettings, dataLabelSettings: options.dataLabelSettings, title: options.title,
                legendSettings: options.legendSettings, primaryXAxis: options.primaryXAxis, primaryYAxis: options.primaryYAxis,
                id: chart.id, height: chart.height, width: chart.width, posRange: argsOpt.range, isInitCell: argsOpt.isInitCell,
                cancel: false, top: chart.top, left: chart.left
            };
            this.parent.notify(beginAction, { eventArgs: eventArgs, action: 'beforeInsertChart' });
            if (eventArgs.cancel) {
                return [];
            }
            chart.type = eventArgs.type;
            chart.theme = eventArgs.theme;
            chart.isSeriesInRows = eventArgs.isSeriesInRows;
            chart.markerSettings = eventArgs.markerSettings;
            chart.range = eventArgs.range;
            chart.id = eventArgs.id;
            chart.height = eventArgs.height;
            chart.width = eventArgs.width;
        }
        const chartOptions = this.processChartSeries(options, argsOpt.dataSheetIdx, xRange, yRange, lRange, chartRange.isDateTime);
        const primaryXAxis = {
            majorGridLines: chart.primaryXAxis && chart.primaryXAxis.majorGridLines &&
                !isNullOrUndefined(chart.primaryXAxis.majorGridLines.width) ?
                { width: chart.primaryXAxis.majorGridLines.width } : { width: 0 },
            minorGridLines: chart.primaryXAxis && chart.primaryXAxis.minorGridLines &&
                !isNullOrUndefined(chart.primaryXAxis.minorGridLines.width) ?
                { width: chart.primaryXAxis.minorGridLines.width } : { width: 0 },
            minorTicksPerInterval: chart.primaryXAxis && chart.primaryXAxis.minorGridLines && chart.primaryXAxis.minorGridLines.width > 0 ?
                5 : 0,
            lineStyle: { width: 0 },
            valueType: chart.type === 'Scatter' && !chartRange.isStringSeries && !chart.isSeriesInRows ? 'Double' : 'Category',
            rangePadding: chart.type === 'Scatter' && !chartRange.isStringSeries && !chart.isSeriesInRows ? 'Round' : 'Auto',
            visible: chart.primaryXAxis ? chart.primaryXAxis.visible : true,
            title: chart.primaryXAxis ? chart.primaryXAxis.title : '',
            edgeLabelPlacement: 'Shift'
        };
        const primaryYAxis = {
            lineStyle: { width: 0 },
            majorGridLines: chart.primaryYAxis && chart.primaryYAxis.majorGridLines &&
                !isNullOrUndefined(chart.primaryYAxis.majorGridLines.width) ?
                { width: chart.primaryYAxis.majorGridLines.width } : { width: 1 },
            minorGridLines: chart.primaryYAxis && chart.primaryYAxis.minorGridLines &&
                !isNullOrUndefined(chart.primaryYAxis.minorGridLines.width) ?
                { width: chart.primaryYAxis.minorGridLines.width } : { width: 0 },
            minorTicksPerInterval: chart.primaryYAxis && chart.primaryYAxis.minorGridLines && chart.primaryYAxis.minorGridLines.width > 0 ?
                5 : 0,
            visible: chart.primaryYAxis ? chart.primaryYAxis.visible : true,
            title: chart.primaryYAxis ? chart.primaryYAxis.title : '',
            edgeLabelPlacement: 'Shift'
        };
        if (argsOpt.isRefresh) {
            if (argsOpt.isSwitchRowColumn && chart.type === 'Scatter') {
                const chartObj = this.parent.element.querySelector('.' + chart.id);
                if (chartObj) {
                    const chartComp = getComponent(chartObj, 'chart');
                    chartComp.primaryXAxis.valueType = !chartRange.isStringSeries && !chart.isSeriesInRows ? 'Double' : 'Category';
                }
            }
            return chartOptions.series;
        }
        const id = chart.id + '_overlay';
        const overlayObj = this.parent.serviceLocator.getService(overlay);
        const eleRange = !isNullOrUndefined(argsOpt.isInitCell) && argsOpt.isInitCell ? argsOpt.range : range;
        const overlayProps = overlayObj.insertOverlayElement(id, eleRange, argsOpt.isChangeChartType ?
            this.parent.activeSheetIndex : getSheetIndexFromAddress(this.parent, eleRange));
        overlayProps.element.classList.add('e-datavisualization-chart');
        overlayProps.element.style.width = chart.width + 'px';
        overlayProps.element.style.height = chart.height + 'px';
        if (sheet && (sheet.frozenRows || sheet.frozenColumns)) {
            overlayObj.adjustFreezePaneSize(chart, overlayProps.element, eleRange);
        }
        else {
            if (isNullOrUndefined(chart.top)) {
                chart.top = overlayProps.top;
            }
            else {
                overlayProps.element.style.top = Number(addDPRValue(chart.top).toFixed(2)) + 'px';
            }
            if (isNullOrUndefined(chart.left)) {
                chart.left = overlayProps.left;
            }
            else {
                overlayProps.element.style.left = Number(addDPRValue(chart.left).toFixed(2)) + 'px';
            }
        }
        this.parent.notify(overlayEleSize, { height: chart.height, width: chart.width });
        const legendSettings = (chart.type === 'Pie' || chart.type === 'Doughnut') ? { position: 'Bottom', visible: true } : {};
        if (!isNullOrUndefined(chart.legendSettings)) {
            legendSettings.visible = chart.legendSettings.visible;
            legendSettings.position = chart.legendSettings.position;
        }
        const chartContent = this.parent.createElement('div', {
            id: chart.id, className: chart.id
        });
        const theme = chart.theme || 'Material';
        const primaryYAxisFormat = this.getAxisFormat(yRange);
        const primaryXAxisFormat = this.getAxisFormat(xRange);
        const borderWidth = Math.round(parseFloat(getComputedStyle(overlayProps.element).borderWidth)) * 2;
        const height = (parseFloat(overlayProps.element.style.height) - (isNaN(borderWidth) ? 0 : borderWidth)) + 'px';
        if (chart.type !== 'Pie' && chart.type !== 'Doughnut') {
            this.chart = new Chart$1({
                primaryXAxis: primaryXAxis,
                primaryYAxis: primaryYAxis,
                background: this.getThemeBgColor(theme),
                chartArea: { border: { width: 0 } },
                title: chart.title,
                legendSettings: legendSettings,
                theme: theme,
                series: chartOptions.series,
                tooltip: { enable: true, format: '${point.x} : <b>${point.tooltip}</b>' },
                width: overlayProps.element.style.width,
                height: height,
                enableRtl: this.parent.enableRtl,
                load: (args) => {
                    args.chart.theme = chart.theme || 'Material';
                },
                beforeResize: (args) => {
                    args.cancelResizedEvent = true; // This is for cancel the resized event.
                },
                axisLabelRender: (args) => {
                    if (args.axis.name === 'primaryYAxis' && primaryYAxisFormat && !chart.type.includes('100') &&
                        !isNullOrUndefined(args.value) && this.parent) {
                        args.text = this.parent.getDisplayText({ format: primaryYAxisFormat, value: args.value.toString() });
                    }
                    else if (args.axis.name === 'primaryXAxis' && args.text.startsWith('spread-chart-empty-label-')) {
                        args.text = '';
                    }
                    if (args.axis.name === 'primaryXAxis' && chart.type === 'Scatter' && !chartRange.isDateTime) {
                        if (args.axis.labels.length > 0 && !isNumber(args.text)) {
                            args.text = (args.axis.labels.indexOf(args.text) + 1).toString();
                        }
                        else if (primaryXAxisFormat && !isNullOrUndefined(args.value)) {
                            args.text = this.parent.getDisplayText({ format: primaryXAxisFormat, value: args.value.toString() });
                        }
                    }
                }
            });
            this.chart.appendTo(chartContent);
        }
        else {
            this.chart = new AccumulationChart({
                title: chart.title,
                legendSettings: legendSettings,
                theme: theme,
                background: this.getThemeBgColor(theme),
                series: chartOptions.series,
                width: overlayProps.element.style.width,
                height: height,
                center: { x: '50%', y: '50%' },
                tooltip: { enable: true, format: '${point.x} : <b>${point.tooltip}</b>' },
                enableSmartLabels: true,
                enableAnimation: true,
                enableRtl: this.parent.enableRtl,
                load: (args) => {
                    args.chart.theme = chart.theme || 'Material';
                },
                beforeResize: (args) => {
                    args.cancelResizedEvent = true; // This is for cancel the resized event.
                }
            });
            this.chart.appendTo(chartContent);
        }
        overlayProps.element.appendChild(chartContent);
        if (overlayProps.element.classList.contains('e-ss-overlay-active') && !this.parent.isPrintingProcessing) {
            this.parent.notify(insertDesignChart, { id: overlayProps.element.id });
        }
        if (argsOpt.triggerEvent) {
            this.parent.notify(completeAction, { eventArgs: eventArgs, action: 'insertChart' });
        }
        return seriesModel;
    }
    deleteChart(args) {
        this.clearBorder();
        let chartElements = null;
        let sheet = this.parent.getActiveSheet();
        if (isNullOrUndefined(args.id)) {
            chartElements = document.querySelector('.e-datavisualization-chart.e-ss-overlay-active');
            args.id = chartElements ? chartElements.getElementsByClassName('e-control')[0].id : null;
        }
        else {
            args.id = args.id.includes('overlay') ? args.id : args.id + '_overlay';
            chartElements = document.getElementById(args.id);
        }
        if (isNullOrUndefined(args.id)) {
            return;
        }
        else {
            args.id = args.id.includes('overlay') ? args.id : args.id + '_overlay';
        }
        let rowIdx;
        let colIdx;
        let prevCellChart;
        let isRemoveEle = false;
        let chartObj;
        for (let i = 0, chartCollLen = this.parent.chartColl.length; i < chartCollLen; i++) {
            if (this.parent.chartColl[i].id === args.id.split('_overlay')[0]) {
                chartObj = this.parent.chartColl[i];
                break;
            }
        }
        const eventArgs = {
            id: chartObj.id, range: chartObj.range, type: chartObj.type, markerSettings: chartObj.markerSettings,
            dataLabelSettings: chartObj.dataLabelSettings, title: chartObj.title, legendSettings: chartObj.legendSettings,
            primaryXAxis: chartObj.primaryXAxis, primaryYAxis: chartObj.primaryYAxis, theme: chartObj.theme,
            height: chartObj.height, width: chartObj.width, isSeriesInRows: chartObj.isSeriesInRows,
            isInitCell: true, posRange: null, top: chartObj.top, left: chartObj.left, cancel: false
        };
        if (chartElements) {
            let chartTop;
            let chartleft;
            if (sheet.frozenRows || sheet.frozenColumns) {
                const clientRect = chartElements.getBoundingClientRect();
                chartTop = { clientY: clientRect.top };
                chartleft = { clientX: clientRect.left };
                if (clientRect.top < this.parent.getColumnHeaderContent().getBoundingClientRect().bottom) {
                    chartTop.target = this.parent.getColumnHeaderContent();
                }
                if (clientRect.left < this.parent.getRowHeaderContent().getBoundingClientRect().right) {
                    chartleft.target = this.parent.getRowHeaderTable();
                }
            }
            else {
                chartTop = { clientY: parseFloat(chartElements.style.top), isImage: true };
                chartleft = { clientX: parseFloat(chartElements.style.left), isImage: true };
            }
            this.parent.notify(deleteChartColl, { id: args.id });
            this.parent.notify(getRowIdxFromClientY, chartTop);
            this.parent.notify(getColIdxFromClientX, chartleft);
            isRemoveEle = true;
            rowIdx = chartTop.clientY;
            colIdx = chartleft.clientX;
            sheet = this.parent.sheets[this.parent.activeSheetIndex];
        }
        else {
            this.parent.notify(deleteChartColl, { id: args.id });
            const lastIndex = args.range ? args.range.lastIndexOf('!') : 0;
            const sheetIndex = args.range && lastIndex > 0 ?
                getSheetIndex(this.parent, args.range.substring(0, lastIndex)) : this.parent.activeSheetIndex;
            const rangeVal = args.range ? lastIndex > 0 ? args.range.substring(lastIndex + 1) : args.range :
                this.parent.getActiveSheet().selectedRange;
            const index = getRangeIndexes(rangeVal);
            rowIdx = index[0];
            colIdx = index[1];
            sheet = this.parent.sheets[sheetIndex];
        }
        const cellObj = getCell(rowIdx, colIdx, sheet);
        if (cellObj) {
            prevCellChart = cellObj.chart;
        }
        let chartLength = prevCellChart ? prevCellChart.length : null;
        for (let i = 0; i < chartLength; i++) {
            if (args.id === prevCellChart[i].id + '_overlay') {
                prevCellChart.splice(i, 1);
                chartLength = prevCellChart.length;
            }
        }
        if (isRemoveEle) {
            document.getElementById(args.id).remove();
            this.parent.notify(removeDesignChart, {});
        }
        setCell(rowIdx, colIdx, sheet, { chart: prevCellChart }, true);
        eventArgs.posRange = sheet.name + '!' + getCellAddress(rowIdx, colIdx);
        if (!args.isUndoRedo) {
            this.parent.notify(completeAction, { eventArgs: eventArgs, action: 'deleteChart', isClearAction: args.clearAction });
        }
    }
    updateChartModel(eleId, chartComp, currCellObj, chartCollId, isAccumulationChart) {
        const accumulationChartComp = chartComp;
        chartComp = chartComp;
        const chartId = this.parent.chartColl[chartCollId].id;
        if (isAccumulationChart &&
            ['PHAxes', 'PVAxes', 'PHAxisTitle', 'PVAxisTitle', 'GLMajorHorizontal',
                'GLMajorVertical', 'GLMinorHorizontal', 'GLMinorVertical'].indexOf(eleId) > -1) {
            return;
        }
        for (let idx = 0, chartsCount = currCellObj.chart.length; idx < chartsCount; idx++) {
            if (currCellObj.chart[idx].id === chartId) {
                switch (eleId) {
                    case 'PHAxes':
                    case 'PHAxisTitle':
                        if (isNullOrUndefined(currCellObj.chart[idx].primaryXAxis)) {
                            currCellObj.chart[idx].primaryXAxis = {};
                            this.parent.chartColl[chartCollId].primaryXAxis = {};
                        }
                        if (eleId === 'PHAxes') {
                            currCellObj.chart[idx].primaryXAxis.visible = chartComp.primaryXAxis.visible;
                            this.parent.chartColl[chartCollId].primaryXAxis.visible = chartComp.primaryXAxis.visible;
                        }
                        else if (eleId === 'PHAxisTitle') {
                            currCellObj.chart[idx].primaryXAxis.title = chartComp.primaryXAxis.title;
                            this.parent.chartColl[chartCollId].primaryXAxis.title = chartComp.primaryXAxis.title;
                        }
                        break;
                    case 'PVAxes':
                    case 'PVAxisTitle':
                        if (isNullOrUndefined(currCellObj.chart[idx].primaryYAxis)) {
                            currCellObj.chart[idx].primaryYAxis = {};
                            this.parent.chartColl[chartCollId].primaryYAxis = {};
                        }
                        if (eleId === 'PVAxes') {
                            currCellObj.chart[idx].primaryYAxis.visible = chartComp.primaryYAxis.visible;
                            this.parent.chartColl[chartCollId].primaryYAxis.visible = chartComp.primaryYAxis.visible;
                        }
                        else if (eleId === 'PVAxisTitle') {
                            currCellObj.chart[idx].primaryYAxis.title = chartComp.primaryYAxis.title;
                            this.parent.chartColl[chartCollId].primaryYAxis.title = chartComp.primaryYAxis.title;
                        }
                        break;
                    case 'ChartTitleNone':
                    case 'ChartTitleAbove':
                        currCellObj.chart[idx].title = chartComp.title;
                        this.parent.chartColl[chartCollId].title = chartComp.title;
                        break;
                    case 'DLNone':
                    case 'DLCenter':
                    case 'DLInsideend':
                    case 'DLInsidebase':
                    case 'DLOutsideend':
                        if (isNullOrUndefined(currCellObj.chart[idx].dataLabelSettings)) {
                            currCellObj.chart[idx].dataLabelSettings = {};
                            this.parent.chartColl[chartCollId].dataLabelSettings = {};
                        }
                        if (eleId === 'DLNone') {
                            currCellObj.chart[idx].dataLabelSettings.visible = false;
                            this.parent.chartColl[chartCollId].dataLabelSettings.visible = false;
                        }
                        else {
                            currCellObj.chart[idx].dataLabelSettings.visible = true;
                            this.parent.chartColl[chartCollId].dataLabelSettings.visible = true;
                            let position;
                            if (isAccumulationChart) {
                                position = accumulationChartComp.series[0].dataLabel.position === 'Outside' ? 'Outer' : 'Middle';
                            }
                            else {
                                position = chartComp.series[0].marker.dataLabel.position;
                            }
                            currCellObj.chart[idx].dataLabelSettings.position = position;
                            this.parent.chartColl[chartCollId].dataLabelSettings.position = position;
                        }
                        break;
                    case 'GLMajorHorizontal':
                        if (isNullOrUndefined(currCellObj.chart[idx].primaryYAxis)) {
                            currCellObj.chart[idx].primaryYAxis = {};
                            this.parent.chartColl[chartCollId].primaryYAxis = {};
                        }
                        if (isNullOrUndefined(currCellObj.chart[idx].primaryYAxis.majorGridLines)) {
                            currCellObj.chart[idx].primaryYAxis.majorGridLines = {};
                            this.parent.chartColl[chartCollId].primaryYAxis.majorGridLines = {};
                        }
                        currCellObj.chart[idx].primaryYAxis.majorGridLines.width = chartComp.primaryYAxis.majorGridLines.width;
                        this.parent.chartColl[chartCollId].primaryYAxis.majorGridLines.width =
                            chartComp.primaryYAxis.majorGridLines.width;
                        break;
                    case 'GLMajorVertical':
                        if (isNullOrUndefined(currCellObj.chart[idx].primaryXAxis)) {
                            currCellObj.chart[idx].primaryXAxis = {};
                            this.parent.chartColl[chartCollId].primaryXAxis = {};
                        }
                        if (isNullOrUndefined(currCellObj.chart[idx].primaryXAxis.majorGridLines)) {
                            currCellObj.chart[idx].primaryXAxis.majorGridLines = {};
                            this.parent.chartColl[chartCollId].primaryXAxis.majorGridLines = {};
                        }
                        currCellObj.chart[idx].primaryXAxis.majorGridLines.width = chartComp.primaryXAxis.majorGridLines.width;
                        this.parent.chartColl[chartCollId].primaryXAxis.majorGridLines.width =
                            chartComp.primaryXAxis.majorGridLines.width;
                        break;
                    case 'GLMinorHorizontal':
                        if (isNullOrUndefined(currCellObj.chart[idx].primaryYAxis)) {
                            currCellObj.chart[idx].primaryYAxis = {};
                            this.parent.chartColl[chartCollId].primaryYAxis = {};
                        }
                        if (isNullOrUndefined(currCellObj.chart[idx].primaryYAxis.minorGridLines)) {
                            currCellObj.chart[idx].primaryYAxis.minorGridLines = {};
                            this.parent.chartColl[chartCollId].primaryYAxis.minorGridLines = {};
                        }
                        currCellObj.chart[idx].primaryYAxis.minorGridLines.width = chartComp.primaryYAxis.minorGridLines.width;
                        this.parent.chartColl[chartCollId].primaryYAxis.minorGridLines.width =
                            chartComp.primaryYAxis.minorGridLines.width;
                        break;
                    case 'GLMinorVertical':
                        if (isNullOrUndefined(currCellObj.chart[idx].primaryXAxis)) {
                            currCellObj.chart[idx].primaryXAxis = {};
                            this.parent.chartColl[chartCollId].primaryXAxis = {};
                        }
                        if (isNullOrUndefined(currCellObj.chart[idx].primaryXAxis.minorGridLines)) {
                            currCellObj.chart[idx].primaryXAxis.minorGridLines = {};
                            this.parent.chartColl[chartCollId].primaryXAxis.minorGridLines = {};
                        }
                        currCellObj.chart[idx].primaryXAxis.minorGridLines.width = chartComp.primaryXAxis.minorGridLines.width;
                        this.parent.chartColl[chartCollId].primaryXAxis.minorGridLines.width =
                            chartComp.primaryXAxis.minorGridLines.width;
                        break;
                    case 'LegendNone':
                    case 'LegendsRight':
                    case 'LegendsLeft':
                    case 'LegendsBottom':
                    case 'LegendsTop':
                        if (isNullOrUndefined(currCellObj.chart[idx].legendSettings)) {
                            currCellObj.chart[idx].legendSettings = {};
                            this.parent.chartColl[chartCollId].legendSettings = {};
                        }
                        currCellObj.chart[idx].legendSettings.visible = chartComp.legendSettings.visible;
                        this.parent.chartColl[chartCollId].legendSettings.visible = chartComp.legendSettings.visible;
                        if (eleId !== 'LegendNone') {
                            currCellObj.chart[idx].legendSettings.position = chartComp.legendSettings.position;
                            this.parent.chartColl[chartCollId].legendSettings.position =
                                chartComp.legendSettings.position;
                            break;
                        }
                }
            }
        }
    }
    updateChartElement(value, chartComp, currCellObj, chartCollId, title, isAccumulationChart, address, triggerEvent) {
        if (isAccumulationChart &&
            ['PHAxes', 'PVAxes', 'PHAxisTitle', 'PVAxisTitle', 'GLMajorHorizontal',
                'GLMajorVertical', 'GLMinorHorizontal', 'GLMinorVertical'].indexOf(value) > -1) {
            return;
        }
        let chartSeries;
        switch (value) {
            case 'PHAxes':
                chartComp = chartComp;
                chartComp.primaryXAxis.visible = !chartComp.primaryXAxis.visible;
                break;
            case 'PVAxes':
                chartComp = chartComp;
                chartComp.primaryYAxis.visible = !chartComp.primaryYAxis.visible;
                break;
            case 'PHAxisTitle':
                chartComp = chartComp;
                chartComp.primaryXAxis.title = title;
                break;
            case 'PVAxisTitle':
                chartComp = chartComp;
                chartComp.primaryYAxis.title = title;
                break;
            case 'ChartTitleNone':
                chartComp.title = '';
                break;
            case 'ChartTitleAbove':
                chartComp.title = title;
                break;
            case 'DLNone':
            case 'DLCenter':
            case 'DLInsideend':
            case 'DLInsidebase':
            case 'DLOutsideend':
                chartComp = isAccumulationChart ? chartComp : chartComp;
                chartSeries = chartComp.series;
                if (value === 'DLNone') {
                    for (let idx = 0, len = chartSeries.length; idx < len; idx++) {
                        if (isAccumulationChart) {
                            chartSeries[idx].dataLabel.visible = false;
                        }
                        else {
                            chartSeries[idx].marker.dataLabel.visible = false;
                        }
                    }
                }
                else {
                    for (let idx = 0, len = chartSeries.length; idx < len; idx++) {
                        if (isAccumulationChart) {
                            const position = value === 'DLOutsideend' ? 'Outside' : 'Inside';
                            chartSeries[idx].dataLabel.visible = true;
                            chartSeries[idx].dataLabel.position = position;
                        }
                        else {
                            const position = value === 'DLCenter' ? 'Middle' : value === 'DLInsideend' ? 'Top' : value === 'DLInsidebase' ?
                                'Bottom' : value === 'DLOutsideend' ? 'Outer' : chartSeries[0].marker.dataLabel.position;
                            chartSeries[idx].marker.dataLabel.visible = true;
                            chartSeries[idx].marker.dataLabel.position = position;
                        }
                    }
                }
                chartComp.series = chartSeries;
                if (isAccumulationChart) {
                    chartComp.refresh();
                }
                break;
            case 'GLMajorHorizontal':
                chartComp = chartComp;
                chartComp.primaryYAxis.majorGridLines.width = chartComp.primaryYAxis.majorGridLines.width === 0 ? 1 : 0;
                break;
            case 'GLMajorVertical':
                chartComp = chartComp;
                chartComp.primaryXAxis.majorGridLines.width = chartComp.primaryXAxis.majorGridLines.width === 0 ? 1 : 0;
                break;
            case 'GLMinorHorizontal':
                chartComp = chartComp;
                chartComp.primaryYAxis.minorTicksPerInterval = chartComp.primaryYAxis.minorGridLines.width === 0 ? 5 : 0;
                chartComp.primaryYAxis.minorGridLines.width = chartComp.primaryYAxis.minorGridLines.width === 0 ? 1 : 0;
                break;
            case 'GLMinorVertical':
                chartComp = chartComp;
                chartComp.primaryXAxis.minorTicksPerInterval = chartComp.primaryXAxis.minorGridLines.width === 0 ? 5 : 0;
                chartComp.primaryXAxis.minorGridLines.width = chartComp.primaryXAxis.minorGridLines.width === 0 ? 1 : 0;
                break;
            case 'LegendNone':
                chartComp.legendSettings.visible = false;
                break;
            case 'LegendsRight':
            case 'LegendsLeft':
            case 'LegendsBottom':
            case 'LegendsTop':
                chartComp.legendSettings.visible = true;
                chartComp.legendSettings.position = value === 'LegendsRight' ? 'Right' : value === 'LegendsLeft' ? 'Left' : value ===
                    'LegendsBottom' ? 'Bottom' : value === 'LegendsTop' ? 'Top' : chartComp.legendSettings.position;
                break;
        }
        this.updateChartModel(value, chartComp, currCellObj, chartCollId, isAccumulationChart);
        if (triggerEvent) {
            const eventArgs = { addChartEle: value, id: chartComp.element.id + '_overlay', title: title, address: address };
            this.parent.notify(completeAction, { action: 'chartDesign', eventArgs: eventArgs });
        }
    }
    undoRedoForChartDesign(args) {
        const overlayElem = document.getElementById(args.id);
        if (!overlayElem) {
            return;
        }
        const chartElem = this.getChartElement(overlayElem);
        let chartComp = getComponent(chartElem, 'chart');
        if (isNullOrUndefined(chartComp)) {
            chartComp = getComponent(chartElem, 'accumulationchart');
        }
        const addressInfo = this.parent.getAddressInfo(args.address);
        const cell = getCell(addressInfo.indices[0], addressInfo.indices[1], getSheet(this.parent, addressInfo.sheetIndex));
        const chartCollectionId = this.getChartCollectionId(chartElem.id);
        let chart;
        let property = args.addChartEle;
        let title = args.title;
        for (let i = 0; i < args.beforeActionData.cellDetails[0].chart.length; i++) {
            if (chartElem.id === args.beforeActionData.cellDetails[0].chart[i].id) {
                chart = args.beforeActionData.cellDetails[0].chart[i];
                break;
            }
        }
        const isMarkerEnabled = isNullOrUndefined(chart.markerSettings) ? false : chart.markerSettings.visible;
        if (args.switchRowColumn) {
            this.switchRowColumn(chartCollectionId, chartElem.id, chartComp, cell);
        }
        else if (args.chartTheme) {
            this.switchChartTheme(chartCollectionId, chartElem.id, args.isUndo ? chart.theme : args.chartTheme, chartComp, cell);
        }
        else if (args.chartType) {
            this.switchChartType(chartCollectionId, chartElem.id, args.isUndo ? chart.type : args.chartType, chartComp, cell, false, args.isUndo ? isMarkerEnabled : args.chartMarker, 'undoRedo');
        }
        else if (args.addChartEle) {
            if (args.isUndo) {
                let position;
                switch (property) {
                    case 'DLNone':
                    case 'DLCenter':
                    case 'DLInsideend':
                    case 'DLInsidebase':
                    case 'DLOutsideend':
                        position = chart.dataLabelSettings && chart.dataLabelSettings.position;
                        property = position === 'Middle' ? 'DLCenter' : position === 'Top' ? 'DLInsideend' : position === 'Bottom' ?
                            'DLInsidebase' : position === 'Outer' ? 'DLOutsideend' : 'DLNone';
                        break;
                    case 'LegendNone':
                    case 'LegendsRight':
                    case 'LegendsLeft':
                    case 'LegendsBottom':
                    case 'LegendsTop':
                        if (chart.legendSettings && !chart.legendSettings.visible) {
                            position = 'LegendNone';
                        }
                        else {
                            position = chart.legendSettings && chart.legendSettings.position;
                            property = position === 'Right' ? 'LegendsRight' : position === 'Left' ? 'LegendsLeft' : position ===
                                'Bottom' ? 'LegendsBottom' : position === 'Top' ? 'LegendsTop' : 'LegendsBottom';
                        }
                        break;
                    case 'PVAxisTitle':
                        title = chart.primaryYAxis && chart.primaryYAxis.title;
                        break;
                    case 'PHAxisTitle':
                        title = chart.primaryXAxis && chart.primaryXAxis.title;
                        break;
                    case 'ChartTitleNone':
                    case 'ChartTitleAbove':
                        title = chart.title;
                        break;
                }
            }
            this.updateChartElement(property, chartComp, cell, chartCollectionId, title, null, args.address);
        }
    }
    chartDesignTabHandler(args) {
        let isAccumulationChart = false;
        const sheet = this.parent.sheets[this.parent.activeSheetIndex];
        const switchRowColumn = args.switchRowColumn;
        const chartType = args.chartType;
        const chartTheme = args.chartTheme;
        const addChartEle = args.addChartEle;
        let chartComp = null;
        const overlayElem = args.id ? document.getElementById(args.id) : document.querySelector('.e-datavisualization-chart.e-ss-overlay-active');
        if (!overlayElem) {
            return;
        }
        const opensTitleDialog = addChartEle === 'ChartTitleAbove' || addChartEle === 'PHAxisTitle' || addChartEle === 'PVAxisTitle';
        let chartTop;
        let chartleft;
        if (sheet.frozenRows || sheet.frozenColumns) {
            const clientRect = overlayElem.getBoundingClientRect();
            chartTop = { clientY: clientRect.top };
            chartleft = { clientX: clientRect.left };
            if (clientRect.top < this.parent.getColumnHeaderContent().getBoundingClientRect().bottom) {
                chartTop.target = this.parent.getColumnHeaderContent();
            }
            if (clientRect.left < this.parent.getRowHeaderContent().getBoundingClientRect().right) {
                chartleft.target = this.parent.getRowHeaderTable();
            }
        }
        else {
            chartTop = { clientY: overlayElem.offsetTop, isImage: true };
            chartleft = { clientX: overlayElem.offsetLeft, isImage: true };
        }
        this.parent.notify(getRowIdxFromClientY, chartTop);
        this.parent.notify(getColIdxFromClientX, chartleft);
        const currCellObj = getCell(chartTop.clientY, chartleft.clientX, sheet);
        const address = sheet.name + '!' + getCellAddress(chartTop.clientY, chartleft.clientX);
        if (args.triggerEvent) {
            const eventArgs = {
                switchRowColumn: args.switchRowColumn, chartType: args.chartType, chartTheme: args.chartTheme,
                addChartEle: args.addChartEle, id: overlayElem.id, address: address, cancel: false
            };
            this.parent.notify(beginAction, { action: 'chartDesign', eventArgs: eventArgs });
            if (eventArgs.cancel) {
                return;
            }
        }
        const chartObj = this.getChartElement(overlayElem);
        const chartId = chartObj.getAttribute('id');
        const chartCollId = this.getChartCollectionId(chartId);
        if (chartObj) {
            chartComp = getComponent(chartObj, 'chart');
            if (isNullOrUndefined(chartComp)) {
                chartComp = getComponent(chartObj, 'accumulationchart');
                isAccumulationChart = true;
            }
        }
        if (switchRowColumn) {
            this.switchRowColumn(chartCollId, chartId, chartComp, currCellObj);
        }
        if (chartType) {
            this.switchChartType(chartCollId, chartId, chartType, chartComp, currCellObj, args.markerVisible);
        }
        if (chartTheme) {
            this.switchChartTheme(chartCollId, chartId, chartTheme, chartComp, currCellObj);
        }
        if (addChartEle) {
            if (opensTitleDialog && !args.title) {
                if (this.parent.element.getElementsByClassName('e-title-dlg').length > 0) {
                    return;
                }
                else {
                    this.titleDlgHandler(addChartEle, chartComp, currCellObj, chartCollId, isAccumulationChart, address, args.triggerEvent);
                }
            }
            else {
                this.updateChartElement(addChartEle, chartComp, currCellObj, chartCollId, args.title, isAccumulationChart);
            }
        }
        if (args.triggerEvent && !opensTitleDialog) {
            const eventArgs = {
                switchRowColumn: args.switchRowColumn, chartType: args.chartType, chartMarker: args.markerVisible,
                chartTheme: args.chartTheme, addChartEle: args.addChartEle, id: overlayElem.id, address: address
            };
            this.parent.notify(completeAction, { action: 'chartDesign', eventArgs: eventArgs });
        }
    }
    switchRowColumn(chartCollId, chartId, chartComp, cell) {
        const chart = this.parent.chartColl[chartCollId];
        chart.isSeriesInRows = isNullOrUndefined(chart.isSeriesInRows) ? true : !chart.isSeriesInRows;
        for (let idx = 0, chartCount = cell.chart.length; idx < chartCount; idx++) {
            if (cell.chart[idx].id === chartId) {
                cell.chart[idx].isSeriesInRows = chart.isSeriesInRows;
            }
        }
        const chartSeries = this.initiateChartHandler({ option: chart, isRefresh: true, isSwitchRowColumn: true });
        chartComp.series = chartSeries;
    }
    switchChartTheme(chartCollId, chartId, theme, chartComp, cell) {
        this.parent.chartColl[chartCollId].theme = theme;
        for (let idx = 0, chartCount = cell.chart.length; idx < chartCount; idx++) {
            if (cell.chart[idx].id === chartId) {
                cell.chart[idx].theme = theme;
            }
        }
        chartComp.setProperties({ theme: theme, background: this.getThemeBgColor(theme) }, true);
        chartComp.refresh();
    }
    getThemeBgColor(theme) {
        let bg;
        if (theme.includes('Dark')) {
            switch (theme) {
                case 'MaterialDark':
                    bg = '#383838';
                    break;
                case 'FabricDark':
                    bg = '#242424';
                    break;
                case 'BootstrapDark':
                    bg = '#1b1b1b';
                    break;
                case 'Bootstrap5Dark':
                    bg = '#212529';
                    break;
                case 'TailwindDark':
                    bg = '#1f2937';
                    break;
                case 'Tailwind3Dark':
                    bg = '#111827';
                    break;
                case 'FluentDark':
                    bg = '#1b1a19';
                    break;
                case 'Fluent2Dark':
                    bg = '#292929';
                    break;
                case 'Material3Dark':
                    bg = '#1C1B1F';
                    break;
            }
        }
        else if (theme.includes('HighContrast')) {
            bg = '#000000';
        }
        else {
            bg = '#FFFFFF';
        }
        return bg;
    }
    switchChartType(chartCollId, chartId, chartType, chartComp, cell, markerVisible, enableMarker, action) {
        const type = this.parent.chartColl[chartCollId].type;
        this.parent.chartColl[chartCollId].type = chartType;
        for (let idx = 0, chartCount = cell.chart.length; idx < chartCount; idx++) {
            if (cell.chart[idx].id === chartId) {
                cell.chart[idx].type = chartType;
                if (!isNullOrUndefined(cell.chart[idx].markerSettings)) {
                    cell.chart[idx].markerSettings.visible = markerVisible;
                }
            }
        }
        if (chartType !== 'Pie' && chartType !== 'Doughnut') {
            if (type === 'Pie' || type === 'Doughnut') {
                if (!isNullOrUndefined(this.parent.chartColl[chartCollId].markerSettings)) {
                    if (markerVisible) {
                        this.parent.chartColl[chartCollId].markerSettings.visible = markerVisible;
                    }
                    else if (action === 'undoRedo') {
                        this.parent.chartColl[chartCollId].markerSettings.visible = enableMarker;
                    }
                    else {
                        this.parent.chartColl[chartCollId].markerSettings.visible = false;
                    }
                }
                else if (markerVisible && (chartType === 'Line' || chartType === 'StackingLine' || chartType === 'StackingLine100')) {
                    this.parent.chartColl[chartCollId].markerSettings = { shape: 'Circle', visible: true, isFilled: false };
                }
                this.changeCharType(chartCollId);
            }
            else {
                if (type !== chartType) {
                    if (chartType === 'Scatter') {
                        const labels = chartComp.primaryXAxis['labels'];
                        if (labels && labels.length > 0 && isNumber(labels[labels.length - 1])) {
                            chartComp.primaryXAxis.valueType = 'Double';
                        }
                    }
                    else if (chartComp.primaryXAxis.valueType === 'Double') {
                        chartComp.primaryXAxis.valueType = 'Category';
                    }
                }
                const chartSeries = chartComp.series;
                const isLineChart = chartType === 'Line' || chartType === 'StackingLine' || chartType === 'StackingLine100';
                for (let idx = 0, len = chartSeries.length; idx < len; idx++) {
                    chartSeries[idx].type = chartType;
                    if (isLineChart) {
                        chartSeries[idx].marker.visible = markerVisible;
                        chartSeries[idx].marker.shape = isNullOrUndefined(chartSeries[idx].marker.shape) ? 'Circle' : chartSeries[idx].marker.shape;
                        if (action === 'undoRedo') {
                            chartSeries[idx].marker.visible = enableMarker;
                        }
                    }
                    else {
                        chartSeries[idx].marker.visible = false;
                    }
                }
                chartComp.series = chartSeries;
                chartComp.refresh();
            }
        }
        else {
            if (type === 'Pie' || type === 'Doughnut') {
                const chartSeries = chartComp.series;
                for (let idx = 0, len = chartSeries.length; idx < len; idx++) {
                    chartSeries[idx].innerRadius = chartType === 'Pie' ? '0%' : '40%';
                }
                chartComp.series = chartSeries;
                chartComp.refresh();
            }
            else {
                this.changeCharType(chartCollId);
            }
        }
    }
    getChartElement(overlayElem) {
        let chartObj = overlayElem.querySelector('.e-chart');
        if (isNullOrUndefined(chartObj)) {
            chartObj = overlayElem.querySelector('.e-accumulationchart');
        }
        return chartObj;
    }
    getChartCollectionId(id) {
        let chartCollectionId;
        for (let i = 0, len = this.parent.chartColl.length; i < len; i++) {
            if (id === this.parent.chartColl[i].id) {
                chartCollectionId = i;
            }
        }
        return chartCollectionId;
    }
    changeCharType(chartCollId) {
        let chartEle = document.getElementById(this.parent.chartColl[chartCollId].id);
        let chartParEle = closest(chartEle, '.e-datavisualization-chart');
        chartParEle.remove();
        this.initiateChartHandler({
            option: this.parent.chartColl[chartCollId], isInitCell: false, triggerEvent: false, isPaste: false,
            isChangeChartType: true
        });
        chartEle = document.getElementById(this.parent.chartColl[chartCollId].id);
        chartParEle = closest(chartEle, '.e-datavisualization-chart');
        if (!chartParEle.classList.contains('e-ss-overlay-active')) {
            chartParEle.classList.add('e-ss-overlay-active');
        }
    }
    titleDlgHandler(addChartEle, chartComp, currCellObj, chartCollId, isAccumulationChart, address, triggerEvent) {
        let title = '';
        if (isAccumulationChart && (addChartEle === 'PHAxisTitle' || addChartEle === 'PVAxisTitle')) {
            return;
        }
        const l10n = this.parent.serviceLocator.getService(locale);
        const dialogInst = this.parent.serviceLocator.getService(dialog);
        dialogInst.show({
            width: 375, showCloseIcon: true, isModal: true, cssClass: 'e-title-dlg',
            header: addChartEle === 'chart_abovechart' ? l10n.getConstant('ChartTitle') : addChartEle ===
                'PHAxisTitle' ? l10n.getConstant('HorizontalAxisTitle') : l10n.getConstant('VerticalAxisTitle'),
            beforeOpen: () => {
                dialogInst.dialogInstance.content = this.titleDlgContent(addChartEle, chartComp);
                dialogInst.dialogInstance.dataBind();
                this.parent.element.focus();
            },
            buttons: [{
                    buttonModel: {
                        content: l10n.getConstant('Ok'),
                        isPrimary: true,
                        cssClass: 'e-btn e-clearall-btn e-flat'
                    },
                    click: () => {
                        const dlgCont = this.parent.element.querySelector('.e-title-dlg').
                            getElementsByClassName('e-title-dlg-content')[0];
                        title = dlgCont.getElementsByTagName('input')[0].value;
                        dialogInst.hide();
                        this.updateChartElement(addChartEle, chartComp, currCellObj, chartCollId, title, null, address, triggerEvent);
                    }
                }]
        });
        dialogInst.dialogInstance.refresh();
    }
    titleDlgContent(addChartEle, chartComp) {
        const l10n = this.parent.serviceLocator.getService(locale);
        const dlgContent = this.parent.createElement('div', { className: 'e-title-dlg-content' });
        const value1Text = this.parent.createElement('span', { className: 'e-header e-top-header' });
        value1Text.innerText = l10n.getConstant('EnterTitle');
        const value1Inp = this.parent.createElement('input', { className: 'e-input', id: 'titleInput', attrs: { type: 'text' } });
        dlgContent.appendChild(value1Text);
        dlgContent.appendChild(value1Inp);
        if (chartComp) {
            if (addChartEle === 'PHAxisTitle') {
                value1Inp.value = chartComp.primaryXAxis.title ? chartComp.primaryXAxis.title : value1Inp.value;
            }
            else if (addChartEle === 'PVAxisTitle') {
                value1Inp.value = chartComp.primaryYAxis.title ? chartComp.primaryYAxis.title : value1Inp.value;
            }
            else {
                value1Inp.value = chartComp.title ? chartComp.title : value1Inp.value;
            }
        }
        return dlgContent;
    }
    /**
     * Removing event listener for success and failure
     *
     * @returns {void} - Removing event listener for success and failure
     */
    removeEventListener() {
        if (!this.parent.isDestroyed) {
            this.parent.off(initiateChart, this.initiateChartHandler);
            this.parent.off(refreshChartCellObj, this.refreshChartCellObj);
            this.parent.off(refreshChartCellOnInit, this.refreshChartCellModel);
            this.parent.off(refreshChartCellModel, this.refreshChartCellModel);
            this.parent.off(deleteChart, this.deleteChart);
            this.parent.off(clearChartBorder, this.clearBorder);
            this.parent.off(insertChart, this.insertChartHandler);
            this.parent.off(chartRangeSelection, this.chartRangeHandler);
            this.parent.off(chartDesignTab, this.chartDesignTabHandler);
            this.parent.off(addChartEle, this.updateChartElement);
            this.parent.off(undoRedoForChartDesign, this.undoRedoForChartDesign);
            this.parent.off(refreshChart, this.refreshChartData);
        }
    }
    /**
     * To Remove the event listeners.
     *
     * @returns {void} - To Remove the event listeners.
     */
    destroy() {
        this.removeEventListener();
        this.parent = null;
        let chartEle = null;
        if (this.chart) {
            chartEle = this.chart.element;
            this.chart.destroy();
        }
        if (chartEle) {
            detach(chartEle);
        }
        this.chart = null;
    }
    /**
     * Get the sheet chart module name.
     *
     * @returns {string} - Get the module name.
     */
    getModuleName() {
        return 'spreadsheetChart';
    }
}

/**
 * This class supports the printing functionality in Spreadsheet.
 */
class Print {
    /**
     * Constructor for Print module
     *
     * @param {Spreadsheet} parent - Specifies the spreadsheet instance.
     */
    constructor(parent) {
        this.totalSheetCount = [];
        this.workbookActiveSheetCount = 0;
        this.defaultCellWidth = 64;
        this.defaultCellHeight = 19;
        this.pageCounts = [];
        this.initialRowCount = 0;
        this.chartHeight = 0;
        this.columnIndex = 0;
        this.rowIndex = 0;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.multipleCanvasDataURL = [];
        this.chartElements = [];
        this.totalCharts = 0;
        this.isChartLoaded = false;
        this.chartLoadedCount = 0;
        this.isImageLoaded = false;
        this.totalImages = 0;
        this.imageLoadedCount = 0;
        this.endRow = 0;
        this.isColumn = true;
        this.startNewPageCount = 0;
        this.allowTimer = false;
        this.parent = parent;
    }
    /**
     * To create the print module.
     *
     * @param {Spreadsheet} spreadsheet - Specifies the spreadsheet instance.
     * @param {PrintOptions} printOptions - Specifies the print options.
     * @returns {void} - To create the print module.
     * @private
     */
    print(spreadsheet, printOptions) {
        spreadsheet.isPrintingProcessing = true;
        this.multipleCanvasDataURL = [];
        this.chartElements = [];
        if (printOptions.type === 'ActiveSheet') {
            const sheet = spreadsheet.sheets[spreadsheet.activeSheetIndex];
            this.activeSheetPrint(spreadsheet, sheet, printOptions, spreadsheet.activeSheetIndex);
        }
        else {
            this.totalSheetCount = [];
            this.workbookActiveSheetCount = 1;
            for (let i = 0; i < spreadsheet.sheets.length; i++) {
                if (spreadsheet.sheets[i].state === 'Visible') {
                    this.totalSheetCount.push(i);
                    if (this.totalSheetCount.length > 1 && this.parent.sheets[i].ranges.length > 0) {
                        const isDatasourceAvailable = this.parent.sheets[i].ranges.some((range) => {
                            return !isNullOrUndefined(range.dataSource);
                        });
                        if (isDatasourceAvailable) {
                            this.allowTimer = true;
                            const sheet = spreadsheet.sheets[i];
                            const address = getCellAddress(0, 0) + ':' + getCellAddress(sheet.rowCount - 1, sheet.colCount - 1);
                            const cellIndexes = getIndexesFromAddress(address);
                            this.parent.notify(updateSheetFromDataSource, { sheet: sheet, indexes: cellIndexes });
                        }
                    }
                }
            }
            if (this.allowTimer) {
                this.allowTimer = false;
                setTimeout(() => {
                    this.activeSheetPrint(spreadsheet, spreadsheet.sheets[this.totalSheetCount[0]], printOptions, this.totalSheetCount[0]);
                }, 2000);
            }
            else {
                this.activeSheetPrint(spreadsheet, spreadsheet.sheets[this.totalSheetCount[0]], printOptions, this.totalSheetCount[0]);
            }
        }
    }
    updateChartRowAndColumnIndices(spreadsheet, sheetIndex) {
        const sheet = spreadsheet.sheets[sheetIndex];
        this.rowIndex = sheet.usedRange.rowIndex;
        this.columnIndex = sheet.usedRange.colIndex;
        if (spreadsheet.chartColl.length > 0) {
            for (let i = 0; i < spreadsheet.chartColl.length; i++) {
                const chart = spreadsheet.chartColl[i];
                const sheetIdx = getSheetIndex(spreadsheet, chart.range.substring(0, chart.range.lastIndexOf('!')));
                if (sheetIndex === sheetIdx) {
                    const chartleft = { clientX: chart.left, isImage: true };
                    const chartTop = { clientY: chart.top, isImage: true };
                    spreadsheet.notify(getRowIdxFromClientY, chartTop);
                    spreadsheet.notify(getColIdxFromClientX, chartleft);
                    if (chartTop.clientY > sheet.usedRange.rowIndex) {
                        this.rowIndex = Math.max(this.rowIndex, chartTop.clientY);
                    }
                    if (chartleft.clientX > sheet.usedRange.colIndex) {
                        this.columnIndex = Math.max(this.columnIndex, chartleft.clientX);
                    }
                }
            }
        }
    }
    activeSheetPrint(spreadsheet, sheet, printOptions, sheetIndex) {
        this.updateChartRowAndColumnIndices(spreadsheet, sheetIndex);
        this.pageCounts = this.calculatePageCount(sheet, 1000, printOptions.allowRowColumnHeader);
        let canvas;
        let context;
        this.initialRowCount = 0;
        this.parent.currentPrintSheetIndex = sheetIndex;
        this.endRow = this.rowIndex + 1;
        this.processCell(0, 0, this.endRow, 2, [], context, canvas, sheet, this, 0, 0, true, sheetIndex, printOptions);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    processCell(page, rowsCount, rowCount, currentX, currentY, context, canvas, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sheet, printInstance, pageHeight = 0, height = 0, isCanvasDataUrl = true, sheetIndex, printOptions) {
        const defaultCellSpace = 0;
        const allowColumnAndRow = printOptions.allowRowColumnHeader;
        const headerWidth = 37;
        let lineHeight = 0;
        this.chartHeight = 0;
        let isExtraLine = false;
        for (let i = page; i < this.pageCounts.length; i++) {
            this.chartLoadedCount = 0;
            this.totalCharts = 0;
            this.imageLoadedCount = 0;
            this.totalImages = 0;
            pageHeight += (i === 0 ? 0 : 1100);
            // Create canvas element
            canvas = document.createElement('canvas');
            context = canvas.getContext('2d');
            canvas.width = 1000;
            canvas.height = 1100;
            context.font = '11pt Calibri';
            context.textBaseline = 'bottom';
            context['index'] = i;
            context['width'] = 1000;
            if (isCanvasDataUrl || (!this.isImageLoaded && !this.isChartLoaded)) {
                currentY = [];
                currentX = 0;
                height = 0;
            }
            // Loop through rows
            for (let j = rowsCount; j < this.endRow; j++) {
                isCanvasDataUrl = true;
                let borderOfHeaderText = false;
                this.isColumn = this.isColumn ? this.isColumn : (j === 0);
                const bottomStyle = { borderBottom: '1px solid black' };
                const rowHeight = (sheet.rows[j] && sheet.rows[j].height || this.defaultCellHeight);
                this.initialRowCount = j;
                currentX = defaultCellSpace;
                const start = i === 0 ? 0 : this.pageCounts[i - 1] + 1;
                const end = this.pageCounts[i];
                height += (isNullOrUndefined(sheet.rows[j]) ? this.defaultCellHeight : rowHeight + (j === 0 && allowColumnAndRow
                    ? this.defaultCellHeight : 0));
                let cellHeight = isNullOrUndefined(sheet.rows[j]) ? this.defaultCellHeight :
                    sheet.rows[j] && sheet.rows[j].height || this.defaultCellHeight;
                if (height > 1080) {
                    this.startNewPageCount = j;
                    lineHeight = allowColumnAndRow ? rowHeight + (j === 0 && allowColumnAndRow ? this.defaultCellHeight : 0) : 0;
                    borderOfHeaderText = false;
                    this.isColumn = true;
                    if (this.isImageLoaded || this.isChartLoaded) {
                        break;
                    }
                    pageHeight += 1100;
                    if (isCanvasDataUrl) {
                        this.multipleCanvasDataURL.push(canvas.toDataURL());
                    }
                    isCanvasDataUrl = true;
                    canvas = document.createElement('canvas');
                    context = canvas.getContext('2d');
                    canvas.width = 1000;
                    canvas.height = 1100;
                    context.font = '11pt Calibri';
                    context.textBaseline = 'bottom';
                    context['index'] = i;
                    context['width'] = 1000;
                    for (let m = 0; m < currentY.length; m++) {
                        if (currentY[m] !== undefined) {
                            currentY[m] -= height - cellHeight;
                        }
                    }
                    height = (allowColumnAndRow || printOptions.allowGridLines) ?
                        rowHeight + (allowColumnAndRow ? this.defaultCellHeight : 0) : rowHeight;
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                let style = { borderBottom: '1px solid black', borderTop: '1px solid black', borderLeft: '1px solid black', borderRight: '1px solid black' };
                const rightStyle = { borderRight: '1px solid black' };
                if (allowColumnAndRow && this.isColumn) {
                    for (let k = start; k <= end; k++) {
                        const columnText = getColumnHeaderText(k + 1);
                        const columnIndex = k === start ? 2 : 1;
                        context.font = '11pt Calibri';
                        for (let m = 0; m < columnIndex; m++) {
                            let titleWidth = (m === 0 && columnIndex === 2) ? headerWidth : (sheet.columns[k] &&
                                sheet.columns[k].hidden ? 0 : ((sheet.columns[k] &&
                                sheet.columns[k].width) || this.defaultCellWidth));
                            titleWidth = currentX + titleWidth > 1000 ? titleWidth - 1 - (currentX + titleWidth - 1000) :
                                titleWidth;
                            if (titleWidth !== 0) {
                                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                const textMetrics = context.measureText(columnText);
                                const textWidth = textMetrics.width;
                                const locationX = printInstance.calculateTextPosition(textWidth, titleWidth, currentX, 'Center');
                                const locationY = this.defaultCellHeight;
                                context.fillText(k === start && m === 0 ? '' : columnText, locationX, locationY);
                                printInstance.drawBorder(context, style, currentX, 0, titleWidth, this.defaultCellHeight);
                                currentX += titleWidth;
                                currentY[k] = this.defaultCellHeight;
                                if (k === end && (columnIndex === 2 ? m === 1 : m === 0)) {
                                    this.isColumn = !(k === end);
                                    currentX = 0;
                                }
                            }
                            else if (k === end) {
                                this.isColumn = false;
                                currentX = 0;
                            }
                        }
                    }
                }
                if (!isNullOrUndefined(sheet.rows[j]) && (isNullOrUndefined(sheet.rows[j].hidden) ||
                    !sheet.rows[j].hidden)) {
                    borderOfHeaderText = this.endRow === sheet.rows.length ? ((height + (sheet.rows[j + 1] ?
                        (sheet.rows[j + 1].height || this.defaultCellHeight) : this.defaultCellHeight)) +
                        (j === 0 && allowColumnAndRow ? this.defaultCellHeight : 0) > 1080) || (j === sheet.rows.length - 1) : false;
                    // Loop through cells in a row
                    for (let k = start; k <= end; k++) {
                        const cell = sheet.rows[j] && !isNullOrUndefined(sheet.rows[j].cells) &&
                            sheet.rows[j].cells[k];
                        if (!isNullOrUndefined(cell) && !isNullOrUndefined(cell.style)) {
                            style = this.setBorderStyle(cell, style);
                        }
                        if (isNullOrUndefined(sheet.columns[k]) || isNullOrUndefined(sheet.columns[k].hidden) ||
                            !sheet.columns[k].hidden) {
                            const isColumnSpan = !isNullOrUndefined(sheet.rows[j].cells) &&
                                !isNullOrUndefined(sheet.rows[j].cells[k]) &&
                                !isNaN(sheet.rows[j].cells[k].colSpan) &&
                                start > k + sheet.rows[j].cells[k].colSpan;
                            const isRowSpan = !isNullOrUndefined(sheet.rows[j].cells) &&
                                !isNullOrUndefined(sheet.rows[j].cells[k]) &&
                                !isNaN(sheet.rows[j].cells[k].rowSpan) &&
                                !(j + sheet.rows[j].cells[k].rowSpan > this.startNewPageCount) &&
                                this.startNewPageCount !== 0;
                            let cellText = '';
                            let cellWidthSpan;
                            let cellWidth;
                            const cellRowSpan = !isNullOrUndefined(cell) ? (isNaN(cell.rowSpan) || isColumnSpan || isRowSpan) ? 1 :
                                Math.max(cell.rowSpan, 0) : 1;
                            currentY[k] = (isNaN(currentY[k]) ? defaultCellSpace : currentY[k]);
                            if (allowColumnAndRow && k === start) {
                                context.font = '11pt Calibri';
                                let rowHeaderHeight = currentY[k];
                                if (cellRowSpan > 0) {
                                    for (let o = 0; o < (cellRowSpan === 0 ? 1 : cellRowSpan); o++) {
                                        currentX = 0;
                                        rowHeaderHeight += (o === 0 ? 0 : (sheet.rows[j + o] && sheet.rows[j + o - 1].height ||
                                            this.defaultCellHeight));
                                        printInstance.rowHeaderText((j + 1 + o).toString(), context, printInstance, headerWidth, currentX, style, rowHeaderHeight, sheet.rows[j + o].height || this.defaultCellHeight);
                                        currentX += headerWidth;
                                    }
                                }
                                else {
                                    currentX = 0;
                                    currentX += headerWidth;
                                }
                            }
                            if (!isNullOrUndefined(cell) && cell) {
                                const fontSize = (cell.style ? cell.style.fontSize || '11pt' : '11pt');
                                let color = (cell.style ? cell.style.color || '#000000' : '#000000');
                                if (!isNaN(sheet.rows[j].cells[k].rowSpan) &&
                                    sheet.rows[j].cells[k].rowSpan > 1) {
                                    if (isNaN(sheet.rows[j + 1].cells[k].rowSpan)) {
                                        this.parent.merge(`${getColumnHeaderText(k + 1)}${j + 1}:${getColumnHeaderText(k + 1)}${j + sheet.rows[j].cells[k].rowSpan - 1}`);
                                    }
                                }
                                if (!isNaN(sheet.rows[j].cells[k].colSpan) &&
                                    sheet.rows[j].cells[k].colSpan > 1) {
                                    if (!isNullOrUndefined(sheet.rows[j + 1]) && !isNullOrUndefined(sheet.rows[j + 1].cells) &&
                                        sheet.rows[j + 1].cells.length > 0 && (!isNullOrUndefined(sheet.rows[j + 1].cells[k]) &&
                                        isNaN(sheet.rows[j + 1].cells[k].colSpan))) {
                                        this.parent.merge('' + getColumnHeaderText(k + 1) + (j + 1) + ':' +
                                            getColumnHeaderText(k + 1 + sheet.rows[j].cells[k].colSpan - 1) + (j + 1));
                                    }
                                    else if (isNullOrUndefined(sheet.rows[j].cells[k + 1].colSpan)) {
                                        for (let m = 1; m < sheet.rows[j].cells[k].colSpan; m++) {
                                            sheet.rows[j].cells[k + m]['colSpan'] = -m;
                                        }
                                    }
                                }
                                cellWidthSpan = (isNaN(sheet.rows[j].cells[k].colSpan) || isColumnSpan) ? 1 :
                                    Math.max(sheet.rows[j].cells[k].colSpan, 0);
                                if (sheet.rows[j].cells[k].rowSpan && !isColumnSpan &&
                                    sheet.rows[j].cells[k].rowSpan < 0) {
                                    // eslint-disable-next-line max-len
                                    const colSpan = sheet.rows[j + sheet.rows[j].cells[k].rowSpan].cells[k].colSpan;
                                    cellWidthSpan = colSpan ? colSpan : cellWidthSpan;
                                }
                                if ((k === start || (k > 0 && sheet.columns && sheet.columns[k - 1] &&
                                    sheet.columns[k - 1].hidden && (sheet.rows[j].cells[k - 1] &&
                                    sheet.rows[j].cells[k - 1].colSpan > 1))) &&
                                    cellWidthSpan <= 0) {
                                    cellWidthSpan = 1;
                                }
                                const backgroundColor = (cell.style ? cell.style.backgroundColor || '#ffffff' : '#ffffff');
                                const textAlign = cell.style ? cell.style['textAlign'] : '';
                                context.font = fontSize;
                                context.fillStyle = color;
                                let cellWidthSpanArray = [];
                                if (cellWidthSpan > 1) {
                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                    const widthColumn = sheet.columns.slice(k, k + cellWidthSpan);
                                    for (let o = 0; o < widthColumn.length; o++) {
                                        cellWidthSpanArray.push(widthColumn['hidden'] ? 0 : ((widthColumn[o] && widthColumn[o]['width']) ||
                                            this.defaultCellWidth));
                                    }
                                    if (cellWidthSpanArray.length === 0) {
                                        cellWidthSpanArray.push((this.defaultCellWidth * cellWidthSpan));
                                    }
                                    else if (cellWidthSpanArray.length !== cellWidthSpan) {
                                        cellWidthSpanArray = cellWidthSpanArray.map((value) => value +
                                            (this.defaultCellWidth * (cellWidthSpan - 1 - cellWidthSpanArray.length)));
                                    }
                                }
                                cellWidth = cellWidthSpan > 1 ? cellWidthSpanArray.reduce((acc, width) => acc + width, 0) :
                                    cellWidthSpan === 1 ? (sheet.columns[k] && sheet.columns[k].width ||
                                        this.defaultCellWidth) : 0;
                                cellWidth = currentX + cellWidth > 1000 ? cellWidth - 1 - (currentX + cellWidth - 1000) : cellWidth;
                                cellHeight = cellRowSpan > 1 ? sheet.rows.slice(j, j + cellRowSpan).map((row) => row.height ||
                                    this.defaultCellHeight).reduce((accumulator, currentValue) => accumulator +
                                    (currentValue || this.defaultCellHeight), 0) : cellRowSpan === 1 ? rowHeight : 0;
                                const verticalAlign = (cell.style ? cell.style['verticalAlign'] || 'Bottom' : 'Bottom').toLowerCase();
                                if (!isNullOrUndefined(cell.image) && cell.image.length > 0) {
                                    this.processImages(i, j, cell, canvas, context, height, this.endRow, rowHeight, lineHeight, allowColumnAndRow, printOptions, sheet, printInstance, currentX, currentY, pageHeight, sheetIndex);
                                }
                                if (!isNullOrUndefined(cell.chart) && cell.chart.length > 0) {
                                    this.handleCharts(i, j, cell, context, canvas, height, this.endRow, this.initialRowCount, lineHeight, rowHeight, allowColumnAndRow, printOptions, sheet, printInstance, this.multipleCanvasDataURL, currentX, currentY, pageHeight, sheetIndex);
                                }
                                if (!isNullOrUndefined(cell.value) || !isNullOrUndefined(cell.formula) ||
                                    !isNullOrUndefined(cell.hyperlink)) {
                                    let position;
                                    if (cell.formula && cell.format) {
                                        if (this.parent.calculationMode === 'Automatic') {
                                            this.parent.notify(workbookFormulaOperation, {
                                                action: 'refreshCalculate', rowIndex: j, colIndex: k,
                                                value: cell.formula, isFormula: checkIsFormula(cell.formula), sheetIndex: sheetIndex
                                            });
                                        }
                                        const numberFormatArgs = {
                                            value: cell.value, format: cell.format,
                                            rowIndex: j, colIndex: k, sheetIndex: this.parent.activeSheetIndex,
                                            cell: cell, refresh: true
                                        };
                                        cellText = this.parent.workbookNumberFormatModule.getFormattedCell(numberFormatArgs);
                                        position = `${textAlign ? textAlign : numberFormatArgs.isRightAlign ? 'Right' : 'Left'}`;
                                    }
                                    else if (cell.format) {
                                        const numberFormatArgs = {
                                            value: cell.value, format: cell.format,
                                            rowIndex: j, colIndex: k, sheetIndex: this.parent.activeSheetIndex,
                                            cell: cell, refresh: true
                                        };
                                        cellText = this.parent.workbookNumberFormatModule.getFormattedCell(numberFormatArgs);
                                        position = `${textAlign ? textAlign : numberFormatArgs.isRightAlign ? 'Right' : 'Left'}`;
                                    }
                                    else if (cell.formula) {
                                        if (this.parent.calculationMode === 'Automatic') {
                                            this.parent.notify(workbookFormulaOperation, {
                                                action: 'refreshCalculate', rowIndex: j, colIndex: k,
                                                value: cell.formula, isFormula: checkIsFormula(cell.formula), sheetIndex: sheetIndex
                                            });
                                        }
                                        cellText = cell.value;
                                        position = `${textAlign ? textAlign : 'Left'}`;
                                    }
                                    else {
                                        if (!isNullOrUndefined(cell.hyperlink)) {
                                            if (isNullOrUndefined(cell.value)) {
                                                cell.value = (!isNullOrUndefined(cell.hyperlink) && typeof cell.hyperlink === 'object') ? cell.hyperlink['address'] : cell.hyperlink || cell.hyperlink['address'];
                                            }
                                            else if (isNullOrUndefined(cell.value) || cell.value === '') {
                                                cell.value = typeof cell.hyperlink === 'object' ? cell.hyperlink['address'] : cell.hyperlink;
                                            }
                                            color = cell.style ? cell.style.color || '#00e' : '#00e';
                                        }
                                        cellText = cell.value;
                                        const isNumber = !isNullOrUndefined(cell.value) && cell.value !== '' ? new RegExp('^[^\\p{L}]*$', 'u').test(cell.value) : false;
                                        position = '' + (textAlign ? textAlign : isNumber ? 'Right' : 'Left');
                                    }
                                    const textSize = (cell.style ? cell.style.fontSize || '11pt' : '11pt');
                                    const fontFamily = (cell.style ? cell.style.fontFamily || 'Calibri' : 'Calibri');
                                    const fontstyle = (cell.style ? cell.style.fontStyle || '' : '');
                                    const fontWeight = (cell.style ? cell.style.fontWeight || 'normal' : 'normal');
                                    context.font = `${fontstyle} ${fontWeight} ${textSize} ${fontFamily}`;
                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                    let textMetrics = context.measureText(cellText);
                                    let textWidth = textMetrics.width;
                                    // eslint-disable-next-line
                                    const textHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;
                                    if (cell.wrap) {
                                        const cellLineHeight = this.defaultCellHeight < cellHeight ? ((parseInt(textSize.replace('pt', ''), 10) / 72) * 96) : cellHeight;
                                        const endColIdx = cell.colSpan > 1 ? k + cell.colSpan - 1 : k;
                                        const colWidth = getDPRValue(getColumnsWidth(sheet, k, endColIdx) - (4 + (getBorderWidth(j, k, sheet) || 1)), true);
                                        const textLines = this.wrapText(cellText, colWidth, cell.style, this.parent.cellStyle);
                                        const space = (textLines.length === 1) ? cellHeight :
                                            (textLines.length * cellLineHeight === cellHeight) ? cellLineHeight :
                                                (textLines.length * cellLineHeight < cellHeight) ?
                                                    cellHeight - ((textLines.length - 1) * cellLineHeight) : cellLineHeight;
                                        const startY = currentY[k] + (verticalAlign === 'top' ? cellLineHeight : verticalAlign === 'middle' ?
                                            space > cellLineHeight + (space / 4) ? cellLineHeight + (space / 4) : space : space);
                                        context.save();
                                        context.beginPath();
                                        context.rect(currentX, currentY[k], cellWidth, cellHeight);
                                        context.clip();
                                        context.fillStyle = backgroundColor;
                                        context.fillRect(currentX, currentY[k], cellWidth, (cellHeight + (verticalAlign === 'top' ? cellLineHeight : 0)));
                                        textLines.forEach((line, index) => {
                                            context.fillStyle = color;
                                            textMetrics = context.measureText(line);
                                            textWidth = textMetrics.width;
                                            const locationX = printInstance.calculateTextPosition(textWidth, cellWidth, currentX, position, true);
                                            const locationY = startY + index * cellLineHeight;
                                            if (position.toLowerCase() === 'right') {
                                                context.textAlign = 'right';
                                                context.fillText(line.trim(), locationX, locationY);
                                            }
                                            else {
                                                context.fillText(line, locationX, locationY);
                                            }
                                            printInstance.textDecoration(cell, context, locationX, locationY, color, textMetrics, cellText, cellWidth);
                                        });
                                        context.restore();
                                    }
                                    else {
                                        context.save();
                                        context.beginPath();
                                        context.rect(currentX, currentY[k], cellWidth, cellHeight);
                                        context.clip();
                                        context.fillStyle = backgroundColor;
                                        context.fillRect(currentX, currentY[k], cellWidth, cellHeight);
                                        context.fillStyle = color;
                                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                        let locationX = printInstance.calculateTextPosition(textWidth, cellWidth, currentX, position);
                                        let locationY = currentY[k];
                                        const midValue = (cellHeight / 2) + (textHeight / 2);
                                        if (verticalAlign === 'top') {
                                            context.textBaseline = 'top'; // Set baseline to the top to ensure consistent vertical placement. Baseline at top means no additional offset needed
                                        }
                                        else if (verticalAlign === 'middle' && cellHeight > midValue) {
                                            locationY += midValue; // Center text vertically
                                        }
                                        else {
                                            locationY += cellHeight; // Align text in default or bottom
                                        }
                                        if (!isNullOrUndefined(cell.style)) {
                                            locationY = (!isNullOrUndefined(cell.style.borderBottom) && cell.style.borderBottom.indexOf('double') > -1) || (!isNullOrUndefined(cell.style.borderTop) && cell.style.borderTop.indexOf('double') > -1) ? locationY - 2 : locationY;
                                            locationX = (!isNullOrUndefined(cell.style.borderLeft) && cell.style.borderLeft.indexOf('double') > -1) || (!isNullOrUndefined(cell.style.borderRight) && cell.style.borderRight.indexOf('double') > -1) ? locationX + (position === 'Left' ? 2 : -3) : locationX;
                                        }
                                        context.fillText(cellText, locationX, locationY);
                                        context.restore();
                                        printInstance.textDecoration(cell, context, locationX, locationY, color, textMetrics, cellText, cellWidth);
                                    }
                                }
                                else {
                                    printInstance.rowHeaderRect(context, currentX, currentY[k], cellWidth, cellHeight, backgroundColor);
                                }
                                if (cell.style && (cellWidth > 0 || cellHeight > 0) && (cell.style.borderBottom || cell.style.borderTop
                                    || cell.style.borderLeft || cell.style.borderRight && ((isNullOrUndefined(cell.rowSpan) &&
                                    isNullOrUndefined(cell.colSpan)) || (!isNullOrUndefined(cell.rowSpan) && cell.rowSpan > 0) ||
                                    (!isNullOrUndefined(cell.colSpan) && cell.colSpan > 0)))) {
                                    printInstance.drawBorder(context, cell.style, currentX, (currentY[k] <= 0 ? 2 : currentY[k]), cellWidth, cellHeight);
                                }
                            }
                            const currentWidth = (cellWidthSpan <= 0 ? cellWidth : (cellWidth ||
                                (sheet.columns[k] && sheet.columns[k].width) || this.defaultCellWidth));
                            if (printOptions.allowGridLines) {
                                style.borderRight = k === end && allowColumnAndRow ? undefined : '1px solid black';
                                printInstance.drawBorder(context, style, currentX, currentY[k], currentWidth, cellHeight);
                            }
                            currentX += currentWidth;
                            let currentYValue = 0;
                            if (cellRowSpan > 1) {
                                currentYValue = currentY[k];
                                for (let m = k; m < k + cellWidthSpan; m++) {
                                    const cell = sheet.rows[j] && !isNullOrUndefined(sheet.rows[j].cells) &&
                                        sheet.rows[j].cells[m];
                                    if (cell && !isNullOrUndefined(cell.image)) {
                                        this.processImages(i, j, cell, canvas, context, height, this.endRow, rowHeight, lineHeight, allowColumnAndRow, printOptions, sheet, printInstance, currentX, currentY, pageHeight, sheetIndex);
                                    }
                                    else if (cell && !isNullOrUndefined(cell.chart)) {
                                        this.handleCharts(i, j, cell, context, canvas, height, this.endRow, this.initialRowCount, lineHeight, rowHeight, allowColumnAndRow, printOptions, sheet, printInstance, this.multipleCanvasDataURL, currentX, currentY, pageHeight, sheetIndex);
                                    }
                                    if (cell.style && m === k && cellHeight > 0 && (cell.style.borderBottom || cell.style.borderTop ||
                                        cell.style.borderLeft || cell.style.borderRight)) {
                                        printInstance.drawBorder(context, cell.style, currentX, currentY[k], 2, cellHeight);
                                    }
                                    currentY[m] = (isNaN(currentY[m]) ? defaultCellSpace :
                                        currentY[m]) + cellHeight;
                                }
                                k += cellWidthSpan - 1;
                            }
                            if (k === end && allowColumnAndRow) {
                                printInstance.drawBorder(context, rightStyle, currentX - 2, currentY[k] - currentYValue, 2, cellHeight);
                            }
                            if (k === end && allowColumnAndRow && borderOfHeaderText && !isExtraLine) {
                                printInstance.drawBorder(context, bottomStyle, 0, currentY[k] - currentYValue, currentX, cellHeight);
                                borderOfHeaderText = false;
                            }
                            if (cellRowSpan <= 1) {
                                currentY[k] += cellHeight;
                            }
                        }
                        else if (allowColumnAndRow && k === start) {
                            const cellRowSpan = !isNullOrUndefined(cell) ?
                                isNaN(sheet.rows[j].cells[k].rowSpan) ? 1 :
                                    Math.max(sheet.rows[j].cells[k].rowSpan, 0) : 1;
                            currentY[k] = (isNaN(currentY[k]) ? defaultCellSpace : currentY[k]);
                            let rowHeaderHeight = currentY[k];
                            context.font = '11pt Calibri';
                            for (let o = 0; o < cellRowSpan; o++) {
                                currentX = 0;
                                rowHeaderHeight += (o === 0 ? 0 : (sheet.rows[j + o] && sheet.rows[j + o - 1].height ||
                                    this.defaultCellHeight));
                                printInstance.rowHeaderText((j + 1 + o).toString(), context, printInstance, headerWidth, currentX, style, rowHeaderHeight, sheet.rows[j + o].height || this.defaultCellHeight);
                                currentX += headerWidth;
                            }
                            currentY[k] += cellHeight;
                        }
                    }
                }
                else if ( isNullOrUndefined(sheet.rows[j])) {
                    let style = { borderBottom: '1px solid black', borderTop: '1px solid black', borderLeft: '1px solid black', borderRight: '1px solid black' };
                    borderOfHeaderText = ((height + cellHeight) + (j === 0 && allowColumnAndRow ?
                        this.defaultCellHeight : 0) > 1080) || (j === sheet.rows.length - 1) || (j === this.endRow - 1);
                    for (let k = start; k <= end; k++) {
                        const cell = sheet.rows[j] && !isNullOrUndefined(sheet.rows[j].cells) &&
                            sheet.rows[j].cells[k];
                        if (!isNullOrUndefined(cell) && !isNullOrUndefined(cell.style)) {
                            style = this.setBorderStyle(cell, style);
                        }
                        if (allowColumnAndRow && k === start) {
                            printInstance.rowHeaderText((j + 1).toString(), context, printInstance, headerWidth, currentX, style, currentY[k], this.defaultCellHeight);
                            currentX += headerWidth;
                        }
                        let cellWidth = (sheet.columns[k] && sheet.columns[k].width || this.defaultCellWidth);
                        cellWidth = currentX + cellWidth > 1000 ? cellWidth - 1 - (currentX + cellWidth - 1000) : cellWidth;
                        currentY[k] = (isNaN(currentY[k]) ? defaultCellSpace : currentY[k]);
                        if (printOptions.allowGridLines) {
                            printInstance.drawBorder(context, style, currentX, currentY[k], cellWidth, cellHeight);
                        }
                        else if (allowColumnAndRow && !printOptions.allowGridLines && k === end) {
                            printInstance.drawBorder(context, { borderRight: '1px solid black' }, currentX, currentY[k], cellWidth, cellHeight);
                        }
                        currentX += cellWidth;
                        if (k === end && allowColumnAndRow && borderOfHeaderText) {
                            printInstance.drawBorder(context, bottomStyle, 0, currentY[k], currentX, cellHeight);
                            borderOfHeaderText = false;
                        }
                        currentY[k] += cellHeight;
                    }
                }
            }
            if (!this.isImageLoaded && !this.isChartLoaded) {
                if (isCanvasDataUrl && this.endRow > 0) {
                    this.multipleCanvasDataURL.push(canvas.toDataURL());
                }
                rowsCount = 0;
                if (this.pageCounts.length - 1 === i) {
                    printInstance.canvasPrint(this.parent, sheetIndex, printOptions);
                }
            }
            else if (this.isImageLoaded || this.isChartLoaded) {
                break;
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setBorderStyle(cell, style) {
        style.borderBottom = !isNullOrUndefined(cell.style.borderBottom) ? cell.style.borderBottom : style.borderBottom;
        style.borderTop = !isNullOrUndefined(cell.style.borderTop) ? cell.style.borderTop : style.borderTop;
        style.borderRight = !isNullOrUndefined(cell.style.borderRight) ? cell.style.borderRight : style.borderRight;
        style.borderLeft = !isNullOrUndefined(cell.style.borderLeft) ? cell.style.borderLeft : style.borderLeft;
        return style;
    }
    setToDefault() {
        this.parent.currentPrintSheetIndex = 0;
        this.initialRowCount = 0;
        this.chartHeight = 0;
        this.totalCharts = 0;
        this.totalImages = 0;
        this.chartLoadedCount = 0;
        this.imageLoadedCount = 0;
        this.endRow = 0;
        this.pageCounts = [];
        this.multipleCanvasDataURL = [];
        this.chartElements = [];
        this.isChartLoaded = false;
        this.isImageLoaded = false;
        this.startNewPageCount = 0;
    }
    handleCharts(i, j, cell, context, canvas, height, rowCount, initialRowCount, lineHeight, rowHeight, allowColumnAndRow, printOptions, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sheet, printInstance, multipleCanvasDataURL, currentX, currentY, pageHeight, sheetIndex) {
        if (!isNullOrUndefined(cell.chart)) {
            for (const chart of cell.chart) {
                this.totalCharts += 1;
                const image = new Image();
                chart.left = !isNullOrUndefined(chart.left) ? chart.left : 0;
                chart.top = !isNullOrUndefined(chart.top) ? chart.top : 0;
                let chartElement = document.getElementById(chart.id);
                if (isNullOrUndefined(chartElement)) {
                    this.parent.insertChart([chart]);
                    chartElement = document.getElementById(chart.id);
                    this.chartElements.push(chart.id + '_overlay');
                }
                if (!isNullOrUndefined(chartElement)) {
                    this.chartHeight = chart.height;
                    const isExtraLine = (this.initialRowCount + Math.ceil(chart.height / 19) > this.endRow) &&
                        (printOptions.allowRowColumnHeader || printOptions.allowGridLines);
                    if (isExtraLine) {
                        if (sheet.rows.length - 1 === j) {
                            const extraSpace = rowHeight + (allowColumnAndRow ? this.defaultCellHeight : 0);
                            if (canvas.height > height + (this.chartHeight - extraSpace)) {
                                this.endRow += Math.ceil((this.chartHeight - extraSpace) / 19);
                            }
                            else {
                                this.endRow += Math.ceil((canvas.height - (height + extraSpace)) / 19);
                            }
                        }
                    }
                    const svgElement = chartElement.cloneNode(true);
                    const url = window.URL.createObjectURL(new Blob([(new XMLSerializer()).serializeToString(svgElement.childNodes[1])], { type: 'image/svg+xml' }));
                    image.onload = () => {
                        const chartLeftIndex = Math.ceil(chart.left / 1000) - 1;
                        const chartTopIndex = Math.ceil(chart.top / 1080) - 1;
                        const left = chart.left + (allowColumnAndRow ? 37 : 0);
                        const top = chart.top + (allowColumnAndRow ? 19 : 0) + (chartTopIndex > 0 ? lineHeight : 0);
                        context.drawImage(image, chartLeftIndex <= 0 ? left : left - (chartLeftIndex * 1000), chartTopIndex <= 0 ? top : top - (chartTopIndex * 1160), chart.width, chart.height);
                        this.chartLoadedCount++;
                        if (this.chartLoadedCount === this.totalCharts) {
                            currentX += chart.width;
                            this.isChartLoaded = false;
                            if (!this.isImageLoaded) {
                                multipleCanvasDataURL.push(canvas.toDataURL());
                                const startValue = (this.initialRowCount === sheet.rows.length - 1 && height < 1080) ?
                                    sheet.rows.length : this.initialRowCount;
                                const endValue = this.endRow;
                                this.processCell(i, (startValue + 1 === endValue ? endValue : startValue), endValue, currentX, currentY, context, canvas, sheet, printInstance, pageHeight, height, false, sheetIndex, printOptions);
                            }
                        }
                    };
                    image.src = url;
                    this.isChartLoaded = true;
                }
            }
        }
    }
    processImages(i, j, cell, canvas, context, height, rowCount, rowHeight, lineHeight, allowColumnAndRow, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    printOptions, sheet, printInstance, currentX, currentY, pageHeight, sheetIndex) {
        if (!isNullOrUndefined(cell.image)) {
            for (const image of cell.image) {
                this.totalImages += 1;
                const img = new Image();
                img.src = image.src;
                image.left = !isNullOrUndefined(image.left) ? image.left : 0;
                image.top = !isNullOrUndefined(image.top) ? image.top : 0;
                this.chartHeight = image.height;
                const isExtraLine = (this.initialRowCount + Math.ceil(image.height / 19) > this.endRow) &&
                    (printOptions.allowRowColumnHeader || printOptions.allowGridLines);
                if (isExtraLine) {
                    if (j === sheet.rows.length - 1) {
                        const extraSpace = (rowHeight + (allowColumnAndRow ? this.defaultCellHeight : 0));
                        if (canvas.height > (height + (this.chartHeight - extraSpace))) {
                            this.endRow += Math.ceil((this.chartHeight - extraSpace) / 19);
                        }
                        else {
                            this.endRow += Math.ceil((canvas.height - (height + extraSpace)) / 19);
                        }
                    }
                }
                img.onload = () => {
                    const imageLeftIndex = Math.ceil(image.left / 1000) - 1;
                    const imageTopIndex = Math.ceil(image.top / 1080) - 1;
                    const left = image.left + (allowColumnAndRow ? 37 : 0);
                    const top = image.top + (allowColumnAndRow ? 19 : 0) + (imageTopIndex > 0 ? lineHeight : 0);
                    context.drawImage(img, (imageLeftIndex <= 0 ? left : left - (imageLeftIndex * 1000)), (imageTopIndex <= 0 ? top : top - (imageTopIndex * 1160)), image.width, image.height);
                    this.imageLoadedCount++;
                    if (this.imageLoadedCount === this.totalImages) {
                        this.isImageLoaded = false;
                        currentX += image.width;
                        if (!this.isChartLoaded) {
                            this.multipleCanvasDataURL.push(canvas.toDataURL());
                            const startValue = (this.initialRowCount === sheet.rows.length - 1 &&
                                height < 1080) ? sheet.rows.length : this.initialRowCount;
                            const endValue = this.endRow;
                            this.processCell(i, (startValue + 1 === endValue ? endValue : startValue), endValue, currentX, currentY, context, canvas, sheet, printInstance, pageHeight, height, false, sheetIndex, printOptions);
                        }
                    }
                };
                img.onerror = () => {
                    this.imageLoadedCount++; // Increment count to prevent indefinite waiting
                    if (this.imageLoadedCount === this.totalImages) {
                        this.isImageLoaded = false;
                        if (!this.isChartLoaded) {
                            this.multipleCanvasDataURL.push(canvas.toDataURL());
                            const startValue = (this.initialRowCount === sheet.rows.length - 1 &&
                                height < 1080) ? sheet.rows.length : this.initialRowCount;
                            const endValue = this.endRow;
                            this.processCell(i, (startValue + 1 === endValue ? endValue : startValue), endValue, currentX, currentY, context, canvas, sheet, printInstance, pageHeight, height, false, sheetIndex, printOptions);
                        }
                    }
                };
            }
            this.isImageLoaded = true;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    textDecoration(cell, context, locationX, locationY, color, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    textMetrics, cellText, cellWidth) {
        if (cellText !== '' && (!isNullOrUndefined(cell.style) && !isNullOrUndefined(cell.style.textDecoration) &&
            cell.style.textDecoration.toLowerCase().indexOf('underline') > -1 || !isNullOrUndefined(cell.hyperlink))) {
            context.beginPath();
            context.moveTo(locationX, locationY - 3);
            context.lineTo(locationX + (textMetrics.width > cellWidth ? cellWidth :
                textMetrics.width), locationY - 3);
            context.strokeStyle = color;
            context.lineWidth = 1;
            context.stroke();
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    rowHeaderRect(context, currentX, currentY, cellWidth, cellHeight, backgroundColor = '#ffffff') {
        context.save();
        context.beginPath();
        context.rect(currentX, currentY, cellWidth, cellHeight);
        context.clip();
        context.fillStyle = backgroundColor;
        context.fillRect(currentX, currentY, cellWidth, cellHeight);
        context.restore();
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    rowHeaderText(rowText, context, printInstance, headerWidth, currentX, style, currentY, height) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const textMetrics = context.measureText(rowText);
        const textWidth = textMetrics.width;
        const locationX = printInstance.calculateTextPosition(textWidth, headerWidth, currentX, 'Center');
        const locationY = currentY;
        context.save();
        context.beginPath();
        context.rect(currentX, currentY, headerWidth, height);
        context.clip();
        context.fillStyle = '#000000';
        context.fillText(rowText, locationX, (locationY + height));
        printInstance.drawBorder(context, style, currentX, (currentY || 0), headerWidth, height);
        context.restore();
    }
    canvasPrint(spreadSheet, sheetIndex, printOptions) {
        if (printOptions.type === 'Workbook' && (this.totalSheetCount.length - 1) >= this.workbookActiveSheetCount) {
            const currentSheetIndex = this.totalSheetCount[this.workbookActiveSheetCount];
            const sheet = spreadSheet.sheets[currentSheetIndex];
            this.workbookActiveSheetCount++;
            this.activeSheetPrint(spreadSheet, sheet, printOptions, currentSheetIndex);
        }
        else {
            for (let i = 0; i < this.chartElements.length; i++) {
                const chartElement = document.getElementById(this.chartElements[i]);
                if (!isNullOrUndefined(chartElement)) {
                    chartElement.remove();
                }
            }
            if (this.multipleCanvasDataURL.length > 0) {
                const browserUserAgent = navigator.userAgent;
                const printWindow = window.open(' ', '_blank', 'height=' + window.outerHeight + ',width=' + window.outerWidth + ',tabbar=no');
                printWindow.document.write('<html><head><title></title></head><body>');
                const canvasWidth = 1000; // Adjust as needed
                const canvasHeight = 1400; // Adjust as needed
                if ((browserUserAgent.indexOf('Chrome') !== -1) || (browserUserAgent.indexOf('Safari') !== -1) ||
                    (browserUserAgent.indexOf('Firefox')) !== -1) {
                    printWindow.document.write('<!DOCTYPE html>');
                    printWindow.document.write('<html><head><style>html, body {  }'
                        + ' img { height: 100%; width: 100%; display: block; }@media print { body {  }'
                        + ' img { width:100%; width:100%; box-sizing: border-box; }br, button { display: none; }'
                        + ' div{ page-break-inside: avoid; }} @page{ size:' + canvasWidth.toString() + 'px ' + canvasHeight.toString() + 'px; }</style></head><body>');
                }
                else {
                    printWindow.document.write('<!DOCTYPE html>');
                    printWindow.document.write('<html><head>'
                        + '<style>html, body {  } img { height: 100%; width: 100%; }@media print { body {  }'
                        + 'img { width:100%; width:100%; box-sizing: border-box; }br, button { display: none; } '
                        + 'div{ page-break-inside: avoid; }} @page{ size:' + canvasWidth.toString() + 'px ' + canvasHeight.toString() + 'px; }</style></head><body>');
                }
                this.multipleCanvasDataURL.forEach((dataURL, index) => {
                    const canvas = printWindow.document.createElement('canvas');
                    canvas.width = canvasWidth;
                    canvas.height = canvasHeight;
                    const context = canvas.getContext('2d');
                    const image = new Image();
                    image.onload = () => {
                        context.drawImage(image, 0, 0, canvasWidth, canvasHeight);
                        if (index === this.multipleCanvasDataURL.length - 1) {
                            spreadSheet.isPrintingProcessing = false;
                            printWindow.print();
                            printWindow.document.close();
                            printWindow.close();
                            spreadSheet.printModule.setToDefault();
                        }
                    };
                    image.src = dataURL;
                    printWindow.document.body.appendChild(canvas);
                });
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    drawBorder(context, borderStyles, locationX, locationY, cellWidth, cellHeight) {
        const { borderBottom, borderLeft, borderRight, borderTop, borderColor } = borderStyles;
        context.strokeStyle = borderColor || 'black';
        if (!isNullOrUndefined(borderBottom) && borderBottom.indexOf('#FFFFFF') === -1) {
            context.strokeStyle = borderBottom.split(' ')[2];
            this.drawPath(locationX, (locationY === 2 ? -2 : locationY) + cellHeight, locationX + cellWidth, (locationY === 2 ? -2 : locationY) + cellHeight, context, borderBottom, false, borderStyles, 'bottom');
        }
        if (!isNullOrUndefined(borderLeft) && borderLeft.indexOf('#FFFFFF') === -1) {
            context.strokeStyle = borderLeft.split(' ')[2];
            this.drawPath(locationX, locationY, locationX, (locationY === 2 ? -2 : locationY) + cellHeight, context, borderLeft, true, borderStyles, 'left');
        }
        if (!isNullOrUndefined(borderRight) && borderRight.indexOf('#FFFFFF') === -1) {
            context.strokeStyle = borderRight.split(' ')[2];
            this.drawPath(locationX + cellWidth, locationY, locationX + cellWidth, (locationY === 2 ? -2 : locationY) + cellHeight, context, borderRight, false, borderStyles, 'right');
        }
        if (!isNullOrUndefined(borderTop) && borderTop.indexOf('#FFFFFF') === -1) {
            context.strokeStyle = borderTop.split(' ')[2];
            this.drawPath(locationX, locationY, locationX + cellWidth, locationY, context, borderTop, true, borderStyles, 'top');
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    drawPath(startX, startY, endX, endY, context, border, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    isLeftOrTop, borderStyles, position) {
        context.beginPath();
        if (border.indexOf('dashed') > -1) {
            context.setLineDash([3, 2]);
            context.lineWidth = border.split(' ')[0].split('')[0];
        }
        else if (border.indexOf('dotted') > -1) {
            context.setLineDash([1, 1]);
            context.lineWidth = border.split(' ')[0].split('')[0];
        }
        else if (border.indexOf('double') > -1) {
            context.setLineDash([]);
            const isAllBorder = !isNullOrUndefined(borderStyles.borderBottom) && !isNullOrUndefined(borderStyles.borderLeft) &&
                !isNullOrUndefined(borderStyles.borderRight) && !isNullOrUndefined(borderStyles.borderTop);
            const isLeftBottom = !isNullOrUndefined(borderStyles.borderBottom) && !isNullOrUndefined(borderStyles.borderLeft) &&
                isNullOrUndefined(borderStyles.borderRight) && isNullOrUndefined(borderStyles.borderTop);
            const isLeftTop = isNullOrUndefined(borderStyles.borderBottom) && !isNullOrUndefined(borderStyles.borderLeft) &&
                isNullOrUndefined(borderStyles.borderRight) && !isNullOrUndefined(borderStyles.borderTop);
            const isLeftTopBotom = !isNullOrUndefined(borderStyles.borderBottom) && !isNullOrUndefined(borderStyles.borderLeft) &&
                isNullOrUndefined(borderStyles.borderRight) && !isNullOrUndefined(borderStyles.borderTop);
            const isRightBottom = !isNullOrUndefined(borderStyles.borderBottom) && isNullOrUndefined(borderStyles.borderLeft) &&
                !isNullOrUndefined(borderStyles.borderRight) && isNullOrUndefined(borderStyles.borderTop);
            const isRightTop = isNullOrUndefined(borderStyles.borderBottom) && isNullOrUndefined(borderStyles.borderLeft) &&
                !isNullOrUndefined(borderStyles.borderRight) && !isNullOrUndefined(borderStyles.borderTop);
            const isRightTopBottom = !isNullOrUndefined(borderStyles.borderBottom) && isNullOrUndefined(borderStyles.borderLeft) &&
                !isNullOrUndefined(borderStyles.borderRight) && !isNullOrUndefined(borderStyles.borderTop);
            const isLeftTopRight = isNullOrUndefined(borderStyles.borderBottom) && !isNullOrUndefined(borderStyles.borderLeft) &&
                !isNullOrUndefined(borderStyles.borderRight) && !isNullOrUndefined(borderStyles.borderTop);
            const isLeftBottomRight = !isNullOrUndefined(borderStyles.borderBottom) && !isNullOrUndefined(borderStyles.borderLeft)
                && !isNullOrUndefined(borderStyles.borderRight) && isNullOrUndefined(borderStyles.borderTop);
            context.lineWidth = 1;
            const extraSpace = 3;
            if (isAllBorder) {
                if (startX === endX) {
                    if (isLeftOrTop) {
                        this.drawDoubleBorder(context, startX, startY, endX, endY, startX + extraSpace, startY + extraSpace, endX + extraSpace, endY - (extraSpace - 1));
                    }
                    else {
                        this.drawDoubleBorder(context, startX, startY, endX, endY, startX - extraSpace, startY + extraSpace, endX - extraSpace, endY - (extraSpace - 1));
                    }
                }
                else if (startY === endY) {
                    if (isLeftOrTop) {
                        this.drawDoubleBorder(context, startX, startY, endX, endY, startX + (extraSpace - 1), startY + extraSpace, endX - (extraSpace - 1), endY + extraSpace);
                    }
                    else {
                        this.drawDoubleBorder(context, startX, startY, endX, endY, startX + (extraSpace - 1), startY - extraSpace, endX - (extraSpace - 1), endY - extraSpace);
                    }
                }
            }
            else if (isLeftBottom) {
                if (position === 'left') {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX + extraSpace, startY, endX + extraSpace, endY - (extraSpace - 1));
                }
                else {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX + (extraSpace - 1), startY - extraSpace, endX, endY - extraSpace);
                }
            }
            else if (isLeftTop) {
                if (position === 'left') {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX + extraSpace, startY + (extraSpace - 1), endX + extraSpace, endY);
                }
                else {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX + (extraSpace - 1), startY + extraSpace, endX, endY + extraSpace);
                }
            }
            else if (isLeftTopBotom) {
                if (position === 'left') {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX + extraSpace, startY + extraSpace, endX + extraSpace, endY - (extraSpace - 1));
                }
                else if (position === 'top') {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX + (extraSpace - 1), startY + extraSpace, endX, endY + extraSpace);
                }
                else {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX + (extraSpace - 1), startY - extraSpace, endX, endY - extraSpace);
                }
            }
            else if (isRightBottom) {
                if (position === 'right') {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX - extraSpace, startY, endX - extraSpace, endY - (extraSpace - 1));
                }
                else {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX, startY - extraSpace, endX - (extraSpace - 1), endY - extraSpace);
                }
            }
            else if (isRightTop) {
                if (position === 'right') {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX - extraSpace, startY + extraSpace, endX - extraSpace, endY);
                }
                else {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX, startY + extraSpace, endX - (extraSpace - 1), endY + extraSpace);
                }
            }
            else if (isRightTopBottom) {
                if (position === 'right') {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX - extraSpace, startY + extraSpace, endX - extraSpace, endY - (extraSpace - 1));
                }
                else if (position === 'top') {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX, startY + extraSpace, endX - (extraSpace - 1), endY + extraSpace);
                }
                else {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX, startY - extraSpace, endX - (extraSpace - 1), endY - extraSpace);
                }
            }
            else if (isLeftTopRight) {
                if (position === 'right') {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX - extraSpace, startY + extraSpace, endX - extraSpace, endY);
                }
                else if (position === 'top') {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX + extraSpace, startY + extraSpace, endX - (extraSpace - 1), endY + extraSpace);
                }
                else {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX + extraSpace, startY + extraSpace, endX + extraSpace, endY);
                }
            }
            else if (isLeftBottomRight) {
                if (position === 'right') {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX - extraSpace, startY, endX - extraSpace, endY - (extraSpace - 1));
                }
                else if (position === 'bottom') {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX + (extraSpace - 1), startY - extraSpace, endX - (extraSpace - 1), endY - extraSpace);
                }
                else {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX + extraSpace, startY, endX + extraSpace, endY - (extraSpace - 1));
                }
            }
            else {
                if (startX === endX) {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX + (position === 'left' ? extraSpace : -extraSpace), startY, endX + (position === 'left' ? extraSpace : -extraSpace), endY);
                }
                else if (startY === endY) {
                    this.drawDoubleBorder(context, startX, startY, endX, endY, startX, startY +
                        (position === 'top' ? extraSpace : -extraSpace), endX, endY + (position === 'top' ? extraSpace : -extraSpace));
                }
            }
            context.stroke();
            return;
        }
        else {
            context.setLineDash([]);
            context.lineWidth = border.split(' ')[0].split('')[0];
        }
        context.moveTo(startX, startY);
        context.lineTo(endX, endY);
        context.stroke();
    }
    drawDoubleBorder(context, startX1, startY1, endX1, endY1, startX2, startY2, endX2, endY2) {
        context.moveTo(startX1, startY1);
        context.lineTo(endX1, endY1);
        context.moveTo(startX2, startY2);
        context.lineTo(endX2, endY2);
    }
    calculateTextPosition(textWidth, totalWidth, currentX, position, isWrap) {
        let x;
        const space = 3;
        const availableSpace = totalWidth;
        if (availableSpace >= textWidth) {
            switch (position.toLowerCase()) {
                case 'left':
                    x = currentX + space;
                    break;
                case 'center':
                    x = currentX + (availableSpace - textWidth) / 2;
                    break;
                case 'right':
                    if (isWrap) {
                        x = currentX + (availableSpace - space);
                    }
                    else {
                        x = currentX + (availableSpace - space) - textWidth;
                    }
                    break;
            }
        }
        else if (textWidth < totalWidth) {
            x = position.toLowerCase() === 'left' ? currentX + space : position.toLowerCase() === 'center' ? currentX + (totalWidth - textWidth) / 2
                : currentX + totalWidth - textWidth;
        }
        else {
            x = currentX + space;
        }
        return x;
    }
    calculatePageCount(sheet, columnHeaderWidth, allowColumnAndRow) {
        let allowHeader = allowColumnAndRow;
        const colIndex = this.columnIndex;
        if (sheet.columns.length === 0) {
            const columnCount = Math.floor(columnHeaderWidth / this.defaultCellWidth) - (allowHeader ? 1 : 0);
            return Array(Math.max(1, Math.ceil(colIndex / columnCount))).fill(columnCount);
        }
        let pageWidthCount = 0;
        const pageCount = [];
        for (let i = 0; i <= colIndex; i++) {
            const column = sheet.columns && sheet.columns[i];
            const columnWidth = (allowHeader ? 27 : 0) + ((column && column.hidden) ? 0 :
                (column && !isNullOrUndefined(column.width)) ? column.width : this.defaultCellWidth);
            pageWidthCount += columnWidth;
            allowHeader = false;
            if (pageWidthCount > columnHeaderWidth) {
                pageCount.push(i - 1);
                allowHeader = true;
                pageWidthCount = columnWidth;
            }
        }
        if (pageCount.length === 0 || colIndex > pageCount[pageCount.length - 1]) {
            pageCount.push(colIndex);
        }
        return pageCount;
    }
    wrapText(text, colwidth, style, parentStyle) {
        if (isNullOrUndefined(text)) {
            return [''];
        }
        const displayText = [];
        let width;
        let splitTextArr;
        let lWidth;
        let cWidth;
        let prevChars;
        let prevWidth = 0;
        const textArr = text.toString().split(' ');
        const spaceWidth = getTextWidth(' ', style, parentStyle, true);
        let hypenWidth;
        let lines;
        let lineText = '';
        let lineCnt = 0;
        let maxCnt = 0;
        const calculateCount = (txt) => {
            if (prevWidth) {
                displayText.push(lineText);
            }
            if (getDPRValue(width / colwidth, true) > 1) {
                txt.split('').forEach((val) => {
                    cWidth = getTextWidth(val, style, parentStyle, true);
                    lWidth += cWidth;
                    prevChars += val;
                    if (getDPRValue(lWidth, true) > colwidth) {
                        displayText.push(prevChars);
                        lWidth = cWidth;
                        prevChars = val;
                    }
                });
                width = lWidth;
                txt = prevChars;
            }
            lineText = txt;
            prevWidth = width;
        };
        const lastTextLen = textArr.length - 1;
        const addSpace = (size, textIdx) => {
            if (getDPRValue(size + spaceWidth, true) / colwidth >= 1) {
                width += 0;
            }
            else {
                width += spaceWidth;
                if (textIdx !== lastTextLen) {
                    lineText += ' ';
                }
            }
        };
        textArr.forEach((txt, textIdx) => {
            lWidth = 0;
            cWidth = 0;
            prevChars = '';
            width = getTextWidth(txt, style, parentStyle, true);
            lines = getDPRValue(prevWidth + width, true) / colwidth;
            if (lines > 1) {
                splitTextArr = txt.split('-');
                if (splitTextArr.length > 1) {
                    const lastIdx = splitTextArr.length - 1;
                    splitTextArr.forEach((splitText, index) => {
                        lWidth = 0;
                        cWidth = 0;
                        prevChars = '';
                        if (!hypenWidth) {
                            hypenWidth = getTextWidth('-', style, parentStyle, true);
                        }
                        width = getTextWidth(splitText, style, parentStyle, true);
                        if (index < lastIdx) {
                            width += hypenWidth;
                            splitText += '-';
                        }
                        lines = getDPRValue(prevWidth + width, true) / colwidth;
                        if (lines > 1) {
                            calculateCount(splitText);
                            if (index === lastIdx) {
                                addSpace(width, textIdx);
                            }
                        }
                        else {
                            lineText += splitText;
                            if (index === lastIdx && textArr[textArr.length - 1] !== txt) {
                                addSpace(prevWidth + width, textIdx);
                            }
                            prevWidth += width;
                        }
                    });
                }
                else {
                    calculateCount(txt);
                    addSpace(width, textIdx);
                }
            }
            else {
                lineText += txt;
                addSpace(prevWidth + width, textIdx);
                prevWidth += width;
            }
        });
        if (prevWidth) {
            lineCnt = getDPRValue(prevWidth - spaceWidth, true) / colwidth;
            maxCnt = parseFloat((lineCnt).toString().split('.')[0]);
            displayText.push(lineText);
        }
        return displayText;
    }
    /**
     * Get module name.
     *
     * @returns {string} - Returns the module name.
     */
    getModuleName() {
        return 'print';
    }
    /**
     * To destroy the print.
     *
     * @returns {void}
     * @private
     */
    destroy() {
        this.setToDefault();
        this.totalSheetCount = [];
        this.parent = null;
    }
}

var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Spreadsheet_1;
/**
 * Represents the Spreadsheet component.
 *
 * ```html
 * <div id='spreadsheet'></div>
 * <script>
 *  let spreadsheetObj = new Spreadsheet();
 *  spreadsheetObj.appendTo('#spreadsheet');
 * </script>
 * ```
 */
let Spreadsheet = Spreadsheet_1 = class Spreadsheet extends Workbook {
    /**
     * Constructor for creating the widget.
     *
     * @param  {SpreadsheetModel} options - Configures Spreadsheet options.
     * @param  {string|HTMLElement} element - Element to render Spreadsheet.
     */
    constructor(options, element) {
        super(options);
        /** @hidden */
        this.viewport = {
            rowCount: 0, colCount: 0, height: 0, topIndex: 0, leftIndex: 0, width: 0,
            bottomIndex: 0, rightIndex: 0, beforeFreezeHeight: 0, beforeFreezeWidth: 0, scaleX: 1, scaleY: 1
        };
        this.needsID = true;
        Spreadsheet_1.Inject(Ribbon$1, FormulaBar, SheetTabs, Selection, Edit, KeyboardNavigation, KeyboardShortcut, Clipboard, DataBind, Open, ContextMenu, Save, NumberFormat, CellFormat, Formula, WrapText, WorkbookEdit, WorkbookOpen, WorkbookSave, WorkbookCellFormat, WorkbookNumberFormat, WorkbookFormula, Sort, WorkbookSort, Resize, UndoRedo, WorkbookFilter, Filter, SpreadsheetHyperlink, WorkbookHyperlink, Insert, Delete, WorkbookInsert, WorkbookDelete, DataValidation, WorkbookDataValidation, Print, ProtectSheet, WorkbookProtectSheet, FindAndReplace, WorkbookFindAndReplace, Merge, WorkbookMerge, SpreadsheetImage, ConditionalFormatting, WorkbookImage, WorkbookConditionalFormat, SpreadsheetChart, WorkbookChart, AutoFill, WorkbookAutoFill, SpreadsheetNote);
        if (element) {
            this.appendTo(element);
        }
    }
    /**
     * To get cell element.
     *
     * @param {number} rowIndex - specify the rowIndex.
     * @param {number} colIndex - specify the colIndex.
     * @param {HTMLTableElement} row - specify the row.
     * @returns {HTMLElement} - Get cell element
     * @hidden
     */
    getCell(rowIndex, colIndex, row) {
        let td;
        if (this.insideViewport(rowIndex, colIndex)) {
            if (!row) {
                row = this.getRow(rowIndex, null, colIndex);
            }
            colIndex = this.getViewportIndex(colIndex, true);
            td = row ? row.cells[colIndex] : row;
        }
        return td;
    }
    /**
     * Get cell element.
     *
     * @param {number} index - specify the index.
     * @param {HTMLTableElement} table - specify the table.
     * @param {number} colIdx - specify the column index.
     * @returns {HTMLTableRowElement} - Get cell element
     * @hidden
     */
    getRow(index, table, colIdx) {
        if (!table) {
            const sheet = this.getActiveSheet();
            const frozenRow = this.frozenRowCount(sheet);
            const frozenCol = this.frozenColCount(sheet);
            if (isNullOrUndefined(colIdx) || index > frozenRow - 1 && colIdx > frozenCol - 1) {
                table = this.getContentTable();
            }
            else {
                table = index < frozenRow && colIdx < frozenCol ? this.sheetModule.getSelectAllTable() : (index < frozenRow ?
                    this.getColHeaderTable() : this.getRowHeaderTable());
            }
        }
        index = this.getViewportIndex(index);
        return table ? table.rows[index] : null;
    }
    /**
     * To get hidden row/column count between two specified index.
     *
     * Set `layout` as `columns` if you want to get column hidden count.
     *
     * @param {number} startIndex - specify the startIndex.
     * @param {number} endIndex - specify the endIndex.
     * @param {string} layout - specify the layout.
     * @param {SheetModel} sheet - specify the sheet.
     * @returns {number} - To get hidden row/column count between two specified index.
     * @hidden
     */
    hiddenCount(startIndex, endIndex, layout = 'rows', sheet = this.getActiveSheet()) {
        let count = 0;
        let rowColModel;
        for (let i = startIndex; i <= endIndex; i++) {
            rowColModel = sheet[`${layout}`][i];
            if (rowColModel && rowColModel.hidden) {
                count++;
            }
        }
        return count;
    }
    /**
     * To get row/column viewport index.
     *
     * @param {number} index - specify the index.
     * @param {boolean} isCol - specify the bool value.
     * @returns {number} - To get row/column viewport index.
     * @hidden
     */
    getViewportIndex(index, isCol) {
        const sheet = this.getActiveSheet();
        const frozenCol = this.frozenColCount(sheet);
        const frozenRow = this.frozenRowCount(sheet);
        if (isCol) {
            if (frozenCol) {
                const leftIndex = getCellIndexes(sheet.topLeftCell)[1];
                if (index < frozenCol) {
                    index -= this.hiddenCount(leftIndex, index, 'columns');
                    index -= leftIndex;
                    return index + 1;
                }
                else {
                    index -= this.hiddenCount(this.viewport.leftIndex + frozenCol, index, 'columns');
                    index -= (this.viewport.leftIndex + frozenCol);
                    return index;
                }
            }
            else {
                index -= this.hiddenCount(this.viewport.leftIndex, index, 'columns');
                index -= this.viewport.leftIndex;
            }
        }
        else {
            if (frozenRow) {
                const topIndex = getCellIndexes(sheet.topLeftCell)[0];
                if (index < frozenRow) {
                    index -= this.hiddenCount(topIndex, index);
                    index -= topIndex;
                    return index + 1;
                }
                else {
                    index -= this.hiddenCount(this.viewport.topIndex + frozenRow, index);
                    index -= (this.viewport.topIndex + frozenRow);
                    return index;
                }
            }
            else {
                index -= this.hiddenCount(this.viewport.topIndex, index);
                index -= this.viewport.topIndex;
            }
        }
        return index;
    }
    /**
     * To initialize the services;
     *
     * @returns {void} - To initialize the services.
     * @hidden
     */
    preRender() {
        super.preRender();
        this.serviceLocator = new ServiceLocator;
        this.initServices();
    }
    initServices() {
        this.serviceLocator.register(locale, new L10n(this.getModuleName(), defaultLocale, this.locale));
        this.serviceLocator.register(dialog, new Dialog(this));
        this.serviceLocator.register(actionEvents, new ActionEvents(this));
        this.serviceLocator.register(overlay, new Overlay(this));
    }
    /**
     * To Initialize the component rendering.
     *
     * @returns {void} - To Initialize the component rendering.
     * @hidden
     */
    render() {
        super.render();
        this.element.setAttribute('tabindex', '0');
        this.renderModule = new Render(this);
        this.renderSpreadsheet();
        this.wireEvents();
        if (this.created && !this.refreshing) {
            if (this.created.observers) {
                if (this.created.observers.length > 0) {
                    let observerObject = { observers: this.created.observers };
                    if (this.isAngular) {
                        observerObject = { observers: this.created.observers,
                            currentObservers: this.created.observers };
                        this.created.currentObservers = [];
                    }
                    this.createdHandler = observerObject;
                    this.created.observers = [];
                }
            }
            else {
                this.createdHandler = this.created;
                this.setProperties({ created: undefined }, true);
            }
        }
    }
    renderSpreadsheet() {
        if (this.cssClass) {
            addClass([this.element], this.cssClass.split(' '));
        }
        this.setHeight();
        this.setWidth();
        createSpinner({ target: this.element }, this.createElement);
        if (this.cssClass && this.cssClass.indexOf('e-mobile-view') === -1 && this.isMobileView()) {
            this.element.classList.add('e-mobile-view');
        }
        if (Browser.isDevice) {
            this.element.classList.add('e-device');
        }
        this.sheetModule = this.serviceLocator.getService('sheet');
        if (this.allowScrolling) {
            this.scrollModule = new Scroll(this);
        }
        if (this.scrollSettings.enableVirtualization) {
            new VirtualScroll(this);
        }
        this.renderModule.render();
        new ShowHide(this);
    }
    /**
     * By default, Spreadsheet shows the spinner for all its actions. To manually show spinner you this method at your needed time.
     *
     * {% codeBlock src='spreadsheet/showSpinner/index.md' %}{% endcodeBlock %}
     *
     * @returns {void} - shows spinner
     */
    showSpinner() {
        showSpinner(this.element);
    }
    /**
     * To hide showed spinner manually.
     *
     * {% codeBlock src='spreadsheet/hideSpinner/index.md' %}{% endcodeBlock %}
     *
     * @returns {void} - To hide showed spinner manually.
     */
    hideSpinner() {
        hideSpinner(this.element);
    }
    /**
     * To protect the particular sheet.
     *
     * {% codeBlock src='spreadsheet/protectSheet/index.md' %}{% endcodeBlock %}
     *
     * @param {number | string} sheet - Specifies the sheet to protect.
     * @param {ProtectSettingsModel} protectSettings - Specifies the protect sheet options.
     * @default { selectCells: 'false', formatCells: 'false', formatRows: 'false', formatColumns:'false', insertLink:'false' }
     * @param {string} password - Specifies the password to protect.
     * @returns {void} - To protect the particular sheet.
     */
    protectSheet(sheet, protectSettings, password) {
        super.protectSheet(sheet, protectSettings, password);
    }
    /**
     * To unprotect the particular sheet.
     *
     * {% codeBlock src='spreadsheet/unprotectSheet/index.md' %}{% endcodeBlock %}
     *
     * @param {number | string} sheet - Specifies the sheet name or index to Unprotect.
     * @returns {void} - To unprotect the particular sheet.
     */
    unprotectSheet(sheet) {
        super.unprotectSheet(sheet);
    }
    /**
     * To find the specified cell value.
     *
     * {% codeBlock src='spreadsheet/find/index.md' %}{% endcodeBlock %}
     *
     * @param {FindOptions} args - Specifies the replace value with find args to replace specified cell value.
     * @param {string} args.value - Specifies the value to be find.
     * @param {string} args.mode - Specifies the value to be find within sheet or workbook.
     * @param {string} args.searchBy - Specifies the value to be find by row or column.
     * @param {boolean} args.isCSen - Specifies the find match with case sensitive or not.
     * @param {boolean} args.isEMatch - Specifies the find match with entire match or not.
     * @param {string} args.findOpt - Specifies the next or previous find match.
     * @param {number} args.sheetIndex - Specifies the current sheet to find.
     * @default { mode: 'Sheet', searchBy: 'By Row', isCSen: 'false', isEMatch:'false' }
     * @returns {void} - To find the specified cell value.
     */
    find(args) {
        const activeCell = this.getActiveSheet().activeCell;
        super.findHandler(args);
        if (!args.isAction) {
            if (activeCell !== this.getActiveSheet().activeCell) {
                return this.getActiveSheet().name + '!' + this.getActiveSheet().activeCell;
            }
            else {
                return null;
            }
        }
    }
    /**
     * To replace the specified cell value.
     *
     * {% codeBlock src='spreadsheet/replace/index.md' %}{% endcodeBlock %}
     *
     * @param {FindOptions} args - Specifies the replace value with find args to replace specified cell value.
     * @param {string} args.replaceValue - Specifies the replacing value.
     * @param {string} args.replaceBy - Specifies the value to be replaced for one or all.
     * @param {string} args.value - Specifies the value to be replaced
     * @returns {void} - To replace the specified cell value.
     */
    replace(args) {
        args = {
            value: args.value, mode: args.mode ? args.mode : 'Sheet', isCSen: args.isCSen ? args.isCSen : false,
            isEMatch: args.isEMatch ? args.isEMatch : false, searchBy: args.searchBy ? args.searchBy : 'By Row',
            replaceValue: args.replaceValue, replaceBy: args.replaceBy,
            sheetIndex: isUndefined$1(args.sheetIndex) ? this.activeSheetIndex : args.sheetIndex, findOpt: args.findOpt ? args.findOpt : ''
        };
        super.replaceHandler(args);
    }
    /**
     * To Find All the Match values Address within Sheet or Workbook.
     *
     * {% codeBlock src='spreadsheet/findAll/index.md' %}{% endcodeBlock %}
     *
     * @param {string} value - Specifies the value to find.
     * @param {string} mode - Specifies the value to be find within Sheet/Workbook.
     * @param {boolean} isCSen - Specifies the find match with case sensitive or not.
     * @param {boolean} isEMatch - Specifies the find match with entire match or not.
     * @param {number} sheetIndex - Specifies the sheetIndex. If not specified, it will consider the active sheet.
     * @returns {string[]} - To Find All the Match values Address within Sheet or Workbook.
     */
    findAll(value, mode, isCSen, isEMatch, sheetIndex) {
        mode = mode ? mode : 'Sheet';
        sheetIndex = sheetIndex < this.sheets.length ? sheetIndex : this.activeSheetIndex;
        isCSen = isCSen ? isCSen : false;
        isEMatch = isEMatch ? isEMatch : false;
        const findCollection = [];
        const findAllArguments = {
            value: value, mode: mode, sheetIndex: sheetIndex, isCSen: isCSen,
            isEMatch: isEMatch, findCollection: findCollection
        };
        this.notify(findAllValues, findAllArguments);
        return findCollection;
    }
    /**
     * Used to navigate to cell address within workbook.
     *
     * {% codeBlock src='spreadsheet/goTo/index.md' %}{% endcodeBlock %}
     *
     * @param {string} address - Specifies the cell address you need to navigate.
     * You can specify the address in two formats,
     * `{sheet name}!{cell address}` - Switch to specified sheet and navigate to specified cell address.
     * `{cell address}` - Navigate to specified cell address with in the active sheet.
     * @returns {void} - Used to navigate to cell address within workbook.
     */
    goTo(address) {
        if (address.includes('!')) {
            const idx = getSheetIndex(this, getSheetNameFromAddress(address));
            if (idx === undefined) {
                return;
            }
            if (idx !== this.activeSheetIndex) {
                const selectRange = address.substring(address.lastIndexOf('!') + 1);
                const activeCell = selectRange.split(':')[0];
                const sheet = this.sheets[idx];
                this.setSheetPropertyOnMute(sheet, 'activeCell', activeCell);
                this.setSheetPropertyOnMute(sheet, 'selectedRange', selectRange);
                const cellIndex = getCellIndexes(activeCell);
                if (sheet.frozenColumns || sheet.frozenRows) {
                    const topLeftCell = getCellIndexes(sheet.topLeftCell);
                    if (!((sheet.frozenRows && cellIndex[0] < topLeftCell[0]) || (sheet.frozenColumns && cellIndex[1] < topLeftCell[1]))) {
                        const frozenRow = this.frozenRowCount(sheet);
                        const frozenCol = this.frozenColCount(sheet);
                        const curCell = [];
                        const paneCell = [];
                        const paneTopLeftCell = getCellIndexes(sheet.paneTopLeftCell);
                        if (frozenRow) {
                            curCell.push(topLeftCell[0]);
                            if (cellIndex[0] >= frozenRow) {
                                paneCell.push(cellIndex[0]);
                            }
                            else {
                                paneCell.push(paneTopLeftCell[0]);
                            }
                        }
                        else {
                            curCell.push(cellIndex[0]);
                            paneCell.push(cellIndex[0]);
                        }
                        if (frozenCol) {
                            curCell.push(topLeftCell[1]);
                            if (cellIndex[1] >= frozenCol) {
                                paneCell.push(cellIndex[1]);
                            }
                            else {
                                paneCell.push(paneTopLeftCell[1]);
                            }
                        }
                        else {
                            curCell.push(cellIndex[1]);
                            paneCell.push(cellIndex[1]);
                        }
                        this.setSheetPropertyOnMute(sheet, 'topLeftCell', getCellAddress(curCell[0], curCell[1]));
                        this.setSheetPropertyOnMute(sheet, 'paneTopLeftCell', getCellAddress(paneCell[0], paneCell[1]));
                    }
                }
                else {
                    if (cellIndex[0] < this.viewport.rowCount) {
                        cellIndex[0] = 0;
                    }
                    if (cellIndex[1] < this.viewport.colCount) {
                        cellIndex[1] = 0;
                    }
                    this.updateTopLeftCell(cellIndex[0], cellIndex[1], null, sheet);
                }
                this.activeSheetIndex = idx;
                this.dataBind();
                return;
            }
        }
        const indexes = getRangeIndexes(address);
        const sheet = this.getActiveSheet();
        const frozenRow = this.frozenRowCount(sheet);
        const frozenCol = this.frozenColCount(sheet);
        const insideDomCount = this.insideViewport(indexes[0], indexes[1]);
        if (insideDomCount) {
            this.selectRange(address);
            let viewportIndexes = getCellIndexes(sheet.paneTopLeftCell);
            let viewportSize = this.viewport.height;
            if (this.allowScrolling) {
                viewportSize -= this.getScrollElement().parentElement.getBoundingClientRect().height;
            }
            let threshold = 0;
            let lastRowIdx = 0;
            if (frozenRow) {
                const topLeftIndexes = getCellIndexes(sheet.topLeftCell);
                for (let i = topLeftIndexes[0]; i < frozenRow; i++) {
                    threshold += getRowHeight(sheet, i);
                    if (threshold > viewportSize) {
                        lastRowIdx = i;
                        break;
                    }
                }
            }
            if (lastRowIdx === 0) {
                for (let i = viewportIndexes[0]; i <= this.viewport.bottomIndex; i++) {
                    threshold += getRowHeight(sheet, i);
                    if (threshold > viewportSize) {
                        lastRowIdx = i;
                        break;
                    }
                    else if (i === this.viewport.bottomIndex) {
                        lastRowIdx = this.viewport.bottomIndex;
                    }
                }
            }
            viewportIndexes[2] = lastRowIdx;
            let lastColIdx = 0;
            threshold = 0;
            viewportSize = this.viewport.width - this.sheetModule.getScrollSize();
            if (frozenCol) {
                const topLeftIndexes = getCellIndexes(sheet.topLeftCell);
                for (let i = topLeftIndexes[1]; i < frozenCol; i++) {
                    threshold += getColumnWidth(sheet, i);
                    if (threshold > viewportSize) {
                        lastColIdx = i;
                        break;
                    }
                }
            }
            if (lastColIdx === 0) {
                for (let i = viewportIndexes[1]; i <= this.viewport.rightIndex; i++) {
                    threshold += getColumnWidth(sheet, i);
                    if (threshold > viewportSize) {
                        lastColIdx = i;
                        break;
                    }
                    else if (i === this.viewport.rightIndex) {
                        lastColIdx = this.viewport.rightIndex;
                    }
                }
            }
            viewportIndexes[3] = lastColIdx;
            if (indexes[0] >= viewportIndexes[0] && indexes[0] < viewportIndexes[2] && indexes[1] >= viewportIndexes[1] &&
                indexes[1] < viewportIndexes[3]) {
                return;
            }
            if (frozenRow || frozenCol) {
                viewportIndexes = [].concat(getCellIndexes(sheet.topLeftCell), [frozenRow, viewportIndexes[3]]);
                if (indexes[0] >= viewportIndexes[0] && indexes[0] < viewportIndexes[2] && indexes[1] >= viewportIndexes[1] &&
                    indexes[1] < viewportIndexes[3]) {
                    return;
                }
                viewportIndexes[2] = lastRowIdx;
                viewportIndexes[3] = frozenCol;
                if (indexes[0] >= viewportIndexes[0] && indexes[0] < viewportIndexes[2] && indexes[1] >= viewportIndexes[1] &&
                    indexes[1] < viewportIndexes[3]) {
                    return;
                }
            }
        }
        let content = this.getMainContent().parentElement;
        let vTrack;
        let cVTrack;
        let offset;
        let vWidth;
        let vHeight;
        let scrollableSize;
        if (indexes[0] === frozenRow) {
            offset = 0;
        }
        else {
            offset = getRowsHeight(sheet, frozenRow, indexes[0] - 1, true);
            if (this.scrollSettings.enableVirtualization) {
                scrollableSize = offset + this.getContentTable().getBoundingClientRect().height;
                vHeight = parseFloat(content.querySelector('.e-virtualtrack').style.height);
                if (scrollableSize > vHeight) {
                    scrollableSize += 10;
                    vTrack = content.querySelector('.e-virtualtrack');
                    vTrack.style.height = `${scrollableSize}px`;
                    getUpdateUsingRaf(() => { vTrack.style.height = `${vHeight}px`; });
                }
            }
        }
        content.scrollTop = offset;
        content = this.element.getElementsByClassName('e-scroller')[0];
        if (indexes[1] === frozenCol) {
            offset = 0;
        }
        else {
            offset = getColumnsWidth(sheet, frozenCol, indexes[1] - 1, true);
            if (this.scrollSettings.enableVirtualization) {
                scrollableSize = offset + this.getContentTable().getBoundingClientRect().width;
                vWidth = parseFloat(content.querySelector('.e-virtualtrack').style.width);
                if (scrollableSize > vWidth) {
                    scrollableSize += 10;
                    vTrack = content.querySelector('.e-virtualtrack');
                    vTrack.style.width = `${scrollableSize}px`;
                    cVTrack = this.getColumnHeaderContent().querySelector('.e-virtualtrack');
                    cVTrack.style.width = `${scrollableSize}px`;
                    vTrack = this.getMainContent().querySelector('.e-virtualtrack');
                    vTrack.style.width = `${scrollableSize}px`;
                    getUpdateUsingRaf(() => {
                        vTrack.style.width = `${vWidth}px`;
                        cVTrack.style.width = `${vWidth}px`;
                    });
                }
            }
        }
        content.scrollLeft = offset;
        if (!insideDomCount) {
            this.selectRange(address);
        }
    }
    /**
     * @hidden
     * @param {number} rowIndex - Specifies the row index.
     * @param {number} colIndex - Specifies the column index.
     * @returns {boolean} - Specifies the boolean value.
     */
    insideViewport(rowIndex, colIndex) {
        const sheet = this.getActiveSheet();
        if (sheet.frozenRows || sheet.frozenColumns) {
            const frozenRow = this.frozenRowCount(sheet);
            const frozenCol = this.frozenColCount(sheet);
            const indexes = getCellIndexes(sheet.topLeftCell);
            return ((rowIndex >= indexes[0] && rowIndex < frozenRow) || (rowIndex >= this.viewport.topIndex + frozenRow && rowIndex <=
                this.viewport.bottomIndex)) && ((colIndex >= indexes[1] && colIndex < frozenCol) || (colIndex >= this.viewport.leftIndex +
                frozenCol && colIndex <= this.viewport.rightIndex));
        }
        else {
            return rowIndex >= this.viewport.topIndex && rowIndex <= this.viewport.bottomIndex && colIndex >= this.viewport.leftIndex &&
                colIndex <= this.viewport.rightIndex;
        }
    }
    /**
     * Used to resize the Spreadsheet.
     *
     * {% codeBlock src='spreadsheet/resize/index.md' %}{% endcodeBlock %}
     *
     * @returns {void} - Used to resize the Spreadsheet.
     */
    resize() {
        this.renderModule.setSheetPanelSize();
        if (this.scrollSettings.enableVirtualization) {
            this.renderModule.refreshSheet(false, true);
        }
    }
    /**
     * To cut the specified cell or cells properties such as value, format, style etc...
     *
     * {% codeBlock src='spreadsheet/cut/index.md' %}{% endcodeBlock %}
     *
     * @param {string} address - Specifies the range address to cut.
     * @returns {Promise<Object>} - To cut the specified cell or cells properties such as value, format, style etc...
     */
    cut(address) {
        const promise = new Promise((resolve) => { resolve((() => { })()); });
        this.notify(cut, address ? {
            range: getIndexesFromAddress(address),
            sId: this.sheets[getSheetIndex(this, getSheetNameFromAddress(address))] ?
                this.sheets[getSheetIndex(this, getSheetNameFromAddress(address))].id : this.getActiveSheet().id,
            promise: promise, invokeCopy: true, isPublic: true
        } : { promise: promise, invokeCopy: true, isPublic: true });
        return promise;
    }
    /**
     * To copy the specified cell or cells properties such as value, format, style etc...
     *
     * {% codeBlock src='spreadsheet/copy/index.md' %}{% endcodeBlock %}
     *
     * @param {string} address - Specifies the range address.
     * @returns {Promise<Object>} - To copy the specified cell or cells properties such as value, format, style etc...
     */
    copy(address) {
        const promise = new Promise((resolve) => { resolve((() => { })()); });
        this.notify(copy, address ? {
            range: getIndexesFromAddress(address),
            sId: this.sheets[getSheetIndex(this, getSheetNameFromAddress(address))] ?
                this.sheets[getSheetIndex(this, getSheetNameFromAddress(address))].id : this.getActiveSheet().id,
            promise: promise, invokeCopy: true, isPublic: true
        } : { promise: promise, invokeCopy: true, isPublic: true });
        return promise;
    }
    /**
     * This method is used to paste the cut or copied cells in to specified address.
     *
     * {% codeBlock src='spreadsheet/paste/index.md' %}{% endcodeBlock %}
     *
     * @param {string} address - Specifies the cell or range address.
     * @param {PasteSpecialType} type - Specifies the type of paste.
     * @returns {void} - used to paste the cut or copied cells in to specified address.
     */
    paste(address, type) {
        this.notify(paste, {
            range: address ? getIndexesFromAddress(address) : address,
            sIdx: address ? getSheetIndex(this, getSheetNameFromAddress(address)) : address,
            type: type, isAction: true, isInternal: true
        });
    }
    /**
     * To update the action which need to perform.
     *
     * {% codeBlock src='spreadsheet/updateAction/index.md' %}{% endcodeBlock %}
     *
     * @param {string} options - It describes an action and event args to perform.
     * @param {string} options.action - specifies an action.
     * @param {string} options.eventArgs - specifies an args to perform an action.
     * @returns {void} - To update the action which need to perform.
     */
    updateAction(options) {
        updateAction(options, this);
    }
    setHeight() {
        if (this.height) {
            if (this.height.toString().indexOf('%') > -1) {
                this.element.style.minHeight = '400px';
            }
            this.element.style.height = formatUnit(this.height);
        }
    }
    setWidth() {
        if (this.width) {
            if (this.width.toString().indexOf('%') > -1 || this.width === 'auto') {
                this.element.style.minWidth = '300px';
            }
            this.element.style.width = formatUnit(this.width);
        }
    }
    /**
     * Set the width of column.
     *
     * {% codeBlock src='spreadsheet/setColWidth/index.md' %}{% endcodeBlock %}
     *
     * @param {number} width - To specify the width
     * @param {number} colIndex - To specify the colIndex
     * @param {number} sheetIndex - To specify the sheetIndex
     * @returns {void} - Set the width of column.
     */
    setColWidth(width = 64, colIndex = 0, sheetIndex) {
        const sheet = isNullOrUndefined(sheetIndex) ? this.getActiveSheet() : this.sheets[sheetIndex];
        if (sheet && (!sheet.isProtected || sheet.protectSettings.formatColumns)) {
            const mIndex = colIndex;
            const colWidth = (typeof width === 'number') ? width + 'px' : width;
            colIndex = isNullOrUndefined(colIndex) ? getCellIndexes(sheet.activeCell)[1] : colIndex;
            const setColModel = () => {
                getColumn(sheet, mIndex).width = parseInt(colWidth, 10) > 0 ? parseInt(colWidth, 10) : 0;
                sheet.columns[mIndex].customWidth = true;
            };
            const frozenCol = this.frozenColCount(sheet);
            if (sheet.id === this.getActiveSheet().id) {
                if ((colIndex >= this.viewport.leftIndex + frozenCol && colIndex <= this.viewport.rightIndex) ||
                    (frozenCol && colIndex < frozenCol)) {
                    colIndex = this.getViewportIndex(colIndex, true);
                    const eleWidth = getColumnWidth(sheet, mIndex, null, true);
                    let threshold = getDPRValue(parseInt(colWidth, 10)) - eleWidth;
                    if (threshold < 0 && eleWidth < -(threshold)) {
                        threshold = -eleWidth;
                    }
                    setColModel();
                    this.notify(colWidthChanged, { threshold, colIdx: mIndex, checkWrapCell: true });
                    setResize(mIndex, colIndex, colWidth, true, this);
                }
                else {
                    const oldWidth = getColumnWidth(sheet, colIndex);
                    let threshold;
                    if (parseInt(colWidth, 10) > 0) {
                        threshold = -(oldWidth - parseInt(colWidth, 10));
                    }
                    else {
                        threshold = -oldWidth;
                    }
                    setColModel();
                    this.notify(colWidthChanged, { threshold, colIdx: colIndex });
                }
                this.notify(positionAutoFillElement, null);
            }
            else {
                setColModel();
            }
        }
    }
    /**
     * Set the height of row.
     *
     * {% codeBlock src='spreadsheet/setRowHeight/index.md' %}{% endcodeBlock %}
     *
     * @param {number} height - Specifies height needs to be updated. If not specified, it will set the default height 20.
     * @param {number} rowIndex - Specifies the row index. If not specified, it will consider the first row.
     * @param {number} sheetIndex - Specifies the sheetIndex. If not specified, it will consider the active sheet.
     * @param {boolean} edited - Specifies the boolean value.
     * @param {boolean} skipCustomRow - When this parameter is enabled, the method will skip updating the row height if it has already been modified and its 'customHeight' property is set to true.
     * @returns {void} - Set the height of row.
     */
    setRowHeight(height = 20, rowIndex = 0, sheetIndex, edited, skipCustomRow) {
        const sheet = isNullOrUndefined(sheetIndex) ? this.getActiveSheet() : this.sheets[sheetIndex];
        if (sheet) {
            const mIndex = rowIndex;
            rowIndex = isNullOrUndefined(rowIndex) ? getCellIndexes(sheet.activeCell)[0] : rowIndex;
            if (skipCustomRow && sheet.rows[rowIndex] && sheet.rows[rowIndex].customHeight) {
                return;
            }
            const rowHeight = (typeof height === 'number') ? height + 'px' : height;
            const setRowModel = () => {
                setRowHeight(sheet, mIndex, parseInt(rowHeight, 10) > 0 ? parseInt(rowHeight, 10) : 0);
                sheet.rows[mIndex].customHeight = true;
            };
            if (sheet.id === this.getActiveSheet().id) {
                const frozenRow = this.frozenRowCount(sheet);
                if ((rowIndex >= this.viewport.topIndex + frozenRow && rowIndex <= this.viewport.bottomIndex) ||
                    (frozenRow && rowIndex < frozenRow)) {
                    rowIndex = this.getViewportIndex(mIndex);
                    const eleHeight = getRowHeight(sheet, mIndex, true);
                    let threshold = getDPRValue(parseInt(rowHeight, 10)) - eleHeight;
                    if (threshold < 0 && eleHeight < -(threshold)) {
                        threshold = -eleHeight;
                    }
                    setRowModel();
                    this.notify(rowHeightChanged, { threshold: threshold, rowIdx: mIndex, isCustomHgt: true });
                    if (isNullOrUndefined(edited)) {
                        edited = false;
                    }
                    if (!edited) {
                        setResize(mIndex, rowIndex, rowHeight, false, this);
                        edited = false;
                    }
                }
                else {
                    const oldHeight = getRowHeight(sheet, rowIndex);
                    let threshold;
                    if (parseInt(rowHeight, 10) > 0) {
                        threshold = -(oldHeight - parseInt(rowHeight, 10));
                    }
                    else {
                        threshold = -oldHeight;
                    }
                    setRowModel();
                    this.notify(rowHeightChanged, { threshold: threshold, rowIdx: mIndex });
                }
                this.notify(positionAutoFillElement, null);
            }
            else {
                setRowModel();
            }
        }
    }
    /**
     * Allows you to set the height to the single or multiple rows.
     *
     * @param {number} height - Specifies the height for row.
     * @param {string[]} ranges - Specifies the row range to set the height. If the sheet name is not specified then height will apply to
     * the rows in the active sheet. Possible values are
     * * Single row range: ['2'] or ['2:2']
     * * Multiple rows range: ['1:100']
     * * Multiple rows with discontinuous range - ['1:10', '15:25', '30:40']
     * * Multiple rows with different sheets - ['Sheet1!1:50', 'Sheet2!1:50', 'Sheet3!1:50'].
     * @param {boolean} skipCustomRows - When this parameter is enabled, it will skip updating the heights of rows where the height has already been modified, and its 'customHeight' property is set to true.
     * @returns {void}
     */
    setRowsHeight(height = 20, ranges, skipCustomRows) {
        if (!ranges) {
            ranges = [`${1}:${this.getActiveSheet().usedRange.rowIndex + 1}`];
        }
        this.setSize(height, ranges, (idx) => Number(idx) - 1, this.setRowHeight.bind(this), skipCustomRows);
    }
    /**
     * Allows you to set the width to the single or multiple columns.
     *
     * @param {number} width - Specifies the width for column.
     * @param {string[]} ranges - Specifies the column range to set the width. If the sheet name is not specified then width will apply to
     * the column in the active sheet. Possible values are
     * * Single column range: ['F'] or ['F:F']
     * * Multiple columns range: ['A:F']
     * * Multiple columns with discontinuous range - ['A:C', 'G:I', 'K:M']
     * * Multiple columns with different sheets - ['Sheet1!A:H', 'Sheet2!A:H', 'Sheet3!A:H'].
     * @returns {void}
     */
    setColumnsWidth(width = 64, ranges) {
        if (!ranges) {
            ranges = [`A:${getColumnHeaderText(this.getActiveSheet().usedRange.colIndex + 1)}`];
        }
        this.setSize(width, ranges, (headerText) => getColIndex(headerText), this.setColWidth.bind(this));
    }
    setSize(width, ranges, getIndex, updateSize, skipCustomRows) {
        let sheetIdx;
        let rangeArr;
        let sheetName;
        let startIdx;
        let endIdx;
        ranges.forEach((range) => {
            if (range.includes('!')) {
                sheetName = range.substring(0, range.lastIndexOf('!'));
                sheetIdx = getSheetIndex(this, sheetName);
                range = range.substring(range.lastIndexOf('!') + 1);
            }
            else {
                sheetIdx = this.activeSheetIndex;
            }
            if (range.includes(':')) {
                rangeArr = range.split(':');
                startIdx = getIndex(rangeArr[0]);
                endIdx = getIndex(rangeArr[1]);
            }
            else {
                startIdx = endIdx = getIndex(range);
            }
            for (let idx = startIdx; idx <= endIdx; idx++) {
                updateSize(width, idx, sheetIdx, false, skipCustomRows);
            }
        });
    }
    /**
     * This method is used to autofit the range of rows or columns
     *
     * {% codeBlock src='spreadsheet/autoFit/index.md' %}{% endcodeBlock %}
     *
     * @param {string} range - range of rows or columns that needs to be autofit.
     *
     * @returns {void} - used to autofit the range of rows or columns
     * ```html
     * <div id='Spreadsheet'></div>
     * ```
     * ```typescript
     * let spreadsheet = new Spreadsheet({
     *      allowResizing: true
     * ...
     * }, '#Spreadsheet');
     * spreadsheet.autoFit('A:D'); // Auto fit from A to D columns
     * Spreadsheet.autoFit('1:4'); // Auto fit from 1 to 4 rows
     *
     * ```
     */
    autoFit(range) {
        let sheetIdx;
        if (range.indexOf('!') !== -1) {
            sheetIdx = getSheetIndex(this, range.substring(0, range.lastIndexOf('!')));
            range = range.substring(range.lastIndexOf('!') + 1);
        }
        const values = this.getIndexes(range);
        let startIdx = values.startIdx;
        let endIdx = values.endIdx;
        const isCol = values.isCol;
        const maximumColInx = isCol ? getColIndex('XFD') : 1048576;
        if (startIdx <= maximumColInx) {
            if (endIdx > maximumColInx) {
                endIdx = maximumColInx;
            }
        }
        else {
            return;
        }
        for (startIdx; startIdx <= endIdx; startIdx++) {
            this.notify(setAutoFit, { idx: startIdx, isCol, sheetIdx: sheetIdx });
        }
    }
    /**
     * @hidden
     * @param {string} range - specify the range.
     * @returns {number | boolean} - to get the index.
     *
     */
    getIndexes(range) {
        let startIsCol;
        let endIsCol;
        let start;
        let end;
        if (range.indexOf(':') !== -1) {
            const starttoend = range.split(':');
            start = starttoend[0];
            end = starttoend[1];
        }
        else {
            start = range;
            end = range;
        }
        if (!isNullOrUndefined(start)) {
            const startValues = this.getAddress(start);
            start = startValues.address;
            startIsCol = startValues.isCol;
        }
        if (!isNullOrUndefined(end)) {
            const endValues = this.getAddress(end);
            end = endValues.address;
            endIsCol = endValues.isCol;
        }
        const isCol = startIsCol === true && endIsCol === true ? true : false;
        const startIdx = isCol ? getColIndex(start.toUpperCase()) : parseInt(start, 10);
        const endIdx = isCol ? getColIndex(end.toUpperCase()) : parseInt(end, 10);
        return { startIdx: startIdx, endIdx: endIdx, isCol: isCol };
    }
    getAddress(address) {
        let isCol;
        if (address.substring(0, 1).match(/\D/g)) {
            isCol = true;
            address = address.replace(/[0-9]/g, '');
            return { address: address, isCol: isCol };
        }
        else if (address.substring(0, 1).match(/[0-9]/g) && address.match(/\D/g)) {
            return { address: '', isCol: false };
        }
        else {
            address = (parseInt(address, 10) - 1).toString();
            return { address: address, isCol: isCol };
        }
    }
    /**
     * To add the hyperlink in the cell
     *
     * {% codeBlock src='spreadsheet/addHyperlink/index.md' %}{% endcodeBlock %}
     *
     * @param {string | HyperlinkModel} hyperlink - to specify the hyperlink
     * @param {string} address - to specify the address
     * @param {string} displayText - to specify the text to be displayed, by default value of the cell will be displayed.
     * @returns {void} - To add the hyperlink in the cell
     */
    addHyperlink(hyperlink, address, displayText) {
        this.insertHyperlink(hyperlink, address, displayText, true);
    }
    /**
     * To remove the hyperlink in the cell
     *
     * {% codeBlock src='spreadsheet/removeHyperlink/index.md' %}{% endcodeBlock %}
     *
     * @param {string} range - To specify the range
     * @returns {void} - To remove the hyperlink in the cell
     */
    removeHyperlink(range) {
        this.notify(removeHyperlink, { range: range, preventEventTrigger: true });
    }
    /**
     * @hidden
     * @param {string | HyperlinkModel} hyperlink - specify the hyperlink
     * @param {string} address - To specify the address
     * @param {string} displayText - To specify the displayText
     * @param {boolean} isMethod - To specify the bool value
     * @returns {void} - to insert the hyperlink
     */
    insertHyperlink(hyperlink, address, displayText, isMethod) {
        if (this.allowHyperlink) {
            let sheetName;
            let sheetIdx;
            let cellIdx;
            let sheet = this.getActiveSheet();
            address = address ? address : sheet.name + '!' + sheet.activeCell;
            cellIdx = getRangeIndexes(address);
            if (isReadOnlyCells(this, cellIdx)) {
                this.notify(readonlyAlert, null);
                return;
            }
            const prevELem = this.getCell(cellIdx[0], cellIdx[1]);
            const classList = [];
            for (let i = 0; prevELem && i < prevELem.classList.length; i++) {
                classList.push(prevELem.classList[i]);
            }
            const befArgs = { hyperlink: hyperlink, address: address, displayText: displayText, cancel: false };
            const aftArgs = { hyperlink: hyperlink, address: address, displayText: displayText };
            if (!isMethod) {
                this.trigger(beforeHyperlinkCreate, befArgs);
                this.notify(beginAction, { action: 'hyperlink', eventArgs: befArgs });
            }
            if (!befArgs.cancel) {
                hyperlink = befArgs.hyperlink;
                address = befArgs.address;
                const args = {
                    hyperlink: hyperlink, cell: address, displayText: displayText, triggerEvt: !isMethod
                };
                this.notify(setLinkModel, args);
                if (address && address.lastIndexOf('!') !== -1) {
                    const lastIndex = address.lastIndexOf('!');
                    sheetName = address.substring(0, lastIndex);
                    const sheets = this.sheets;
                    for (let idx = 0; idx < sheets.length; idx++) {
                        if (sheets[idx].name === sheetName) {
                            sheetIdx = idx;
                        }
                    }
                    sheet = this.sheets[sheetIdx];
                    address = address.substring(lastIndex + 1);
                }
                if (!sheet) {
                    return;
                }
                address = address ? address : this.getActiveSheet().activeCell;
                cellIdx = getRangeIndexes(address);
                if (!isMethod) {
                    this.trigger(afterHyperlinkCreate, aftArgs);
                    this.notify(completeAction, { action: 'hyperlink', eventArgs: befArgs });
                }
                if (sheet === this.getActiveSheet()) {
                    this.serviceLocator.getService('cell').refreshRange(cellIdx, false, false, false, true, isImported(this));
                    for (let i = 0; i < classList.length; i++) {
                        if (!this.getCell(cellIdx[0], cellIdx[1]).classList.contains(classList[i])) {
                            this.getCell(cellIdx[0], cellIdx[1]).classList.add(classList[i]);
                        }
                    }
                    this.notify(refreshRibbonIcons, null);
                }
            }
        }
    }
    /**
     * This method is used to add data validation.
     *
     * {% codeBlock src='spreadsheet/addDataValidation/index.md' %}{% endcodeBlock %}
     *
     * @param {ValidationModel} rules - specifies the validation rules like type, operator, value1, value2, ignoreBlank, inCellDropDown, isHighlighted arguments.
     * @param {string} range - range that needs to be add validation.
     * @returns {void} - used to add data validation.
     */
    addDataValidation(rules, range) {
        super.addDataValidation(rules, range);
    }
    /**
     * This method is used for remove validation.
     *
     * {% codeBlock src='spreadsheet/removeDataValidation/index.md' %}{% endcodeBlock %}
     *
     * @param {string} range - range that needs to be remove validation.
     * @returns {void} - This method is used for remove validation.
     */
    removeDataValidation(range) {
        super.removeDataValidation(range);
    }
    /**
     * This method is used to highlight the invalid data.
     *
     * {% codeBlock src='spreadsheet/addInvalidHighlight/index.md' %}{% endcodeBlock %}
     *
     * @param {string} range - range that needs to be highlight the invalid data.
     * @returns {void} - This method is used to highlight the invalid data.
     */
    addInvalidHighlight(range) {
        super.addInvalidHighlight(range);
    }
    /**
     * This method is used for remove highlight from invalid data.
     *
     * {% codeBlock src='spreadsheet/removeInvalidHighlight/index.md' %}{% endcodeBlock %}
     *
     * @param {string} range - range that needs to be remove invalid highlight.
     * @returns {void} - This method is used for remove highlight from invalid data.
     */
    removeInvalidHighlight(range) {
        super.removeInvalidHighlight(range);
    }
    /**
     * This method is used to add conditional formatting.
     *
     * {% codeBlock src='spreadsheet/conditionalFormat/index.md' %}{% endcodeBlock %}
     *
     * @param {ConditionalFormatModel} conditionalFormat - Specify the conditionalFormat.
     * @returns {void} - used to add conditional formatting.
     */
    conditionalFormat(conditionalFormat) {
        super.conditionalFormat(conditionalFormat);
    }
    /**
     * This method is used for remove conditional formatting.
     *
     * {% codeBlock src='spreadsheet/clearConditionalFormat/index.md' %}{% endcodeBlock %}
     *
     * @param {string} range - range that needs to be remove conditional formatting.
     * @returns {void} - used for remove conditional formatting.
     */
    clearConditionalFormat(range) {
        range = range || this.getActiveSheet().selectedRange;
        super.clearConditionalFormat(range);
    }
    /**
     * @hidden
     * @returns {void} - set Panel Size.
     */
    setPanelSize() {
        if (this.height !== 'auto') {
            const panel = document.getElementById(this.element.id + '_sheet_panel');
            panel.style.height = `${(this.element.getBoundingClientRect().height * this.viewport.scaleY) -
                getSiblingsHeight(panel, null, this.viewport.scaleY)}px`;
        }
    }
    /**
     * Opens the Excel file.
     *
     * {% codeBlock src='spreadsheet/open/index.md' %}{% endcodeBlock %}
     *
     * @param {OpenOptions} options - Options for opening the excel file.
     * @returns {void} - Open the Excel file.
     */
    open(options) {
        this.isOpen = true;
        super.open(options);
        if (this.isOpen) {
            this.showSpinner();
        }
    }
    /**
     * Used to hide/show the rows in spreadsheet.
     *
     * @param {number} startIndex - Specifies the start row index.
     * @param {number} endIndex - Specifies the end row index.
     * @param {boolean} hide - To hide/show the rows in specified range.
     * @returns {void} - To hide/show the rows in spreadsheet.
     */
    hideRow(startIndex, endIndex = startIndex, hide = true) {
        if (this.renderModule) {
            this.notify(hideShow, { startIndex: startIndex, endIndex: endIndex, hide: hide, actionUpdate: false });
        }
        else {
            super.hideRow(startIndex, endIndex, hide);
        }
    }
    /**
     * Used to hide/show the columns in spreadsheet.
     *
     * @param {number} startIndex - Specifies the start column index.
     * @param {number} endIndex - Specifies the end column index.
     * @param {boolean} hide - Set `true` / `false` to hide / show the columns.
     * @returns {void} - To hide/show the columns in spreadsheet.
     */
    hideColumn(startIndex, endIndex = startIndex, hide = true) {
        if (this.renderModule) {
            this.notify(hideShow, { startIndex: startIndex, endIndex: endIndex, hide: hide, isCol: true, actionUpdate: false });
        }
        else {
            super.hideColumn(startIndex, endIndex, hide);
        }
    }
    /**
     * This method is used to Clear contents, formats and hyperlinks in spreadsheet.
     *
     * {% codeBlock src='spreadsheet/clear/index.md' %}{% endcodeBlock %}
     *
     * @param {ClearOptions} options - Options for clearing the content, formats and hyperlinks in spreadsheet.
     * @returns {void} -  Used to Clear contents, formats and hyperlinks in spreadsheet
     */
    clear(options) {
        this.notify(clearViewer, { options: options });
    }
    /**
     * Used to refresh the spreadsheet in UI level.
     *
     * {% codeBlock src='spreadsheet/refresh/index.md' %}{% endcodeBlock %}
     *
     * @param {boolean} isNew - Specifies `true` / `false` to create new workbook in spreadsheet.
     * @returns {void} -  Used to refresh the spreadsheet.
     */
    refresh(isNew) {
        if (this.isReact) {
            this['clearTemplate']();
        }
        if (isNew) {
            this.notify(clearCopy, null);
            this.sheets.length = 0;
            this.sheetNameCount = 1;
            this.notify(sheetsDestroyed, {});
            this.notify(clearUndoRedoCollection, null);
            this.createSheet();
            this.activeSheetIndex = this.sheets.length - 1;
            this.notify(refreshSheetTabs, null);
            this.notify(workbookFormulaOperation, { action: 'initSheetInfo' });
            this.renderModule.refreshSheet();
        }
        else {
            if (this.createdHandler) {
                const refreshFn = () => {
                    this.off(spreadsheetCreated, refreshFn);
                    this.refresh();
                };
                this.on(spreadsheetCreated, refreshFn, this);
            }
            else {
                this.notify(deInitProperties, {});
                super.refresh();
            }
        }
    }
    /**
     * Used to set the image in spreadsheet.
     *
     * {% codeBlock src='spreadsheet/insertImage/index.md' %}{% endcodeBlock %}
     *
     * @param {ImageModel} images - Specifies the options to insert image in spreadsheet.
     * @param {string} range - Specifies the range in spreadsheet.
     * @returns {void} -  Used to set the image in spreadsheet.
     */
    insertImage(images, range) {
        let i;
        for (i = 0; i < images.length; i++) {
            this.notify(createImageElement, {
                options: images[i],
                range: range ? range : this.getActiveSheet().selectedRange, isPublic: true
            });
        }
    }
    /**
     * Used to delete the image in spreadsheet.
     *
     * {% codeBlock src='spreadsheet/deleteImage/index.md' %}{% endcodeBlock %}
     *
     * @param {string} id - Specifies the id of the image element to be deleted.
     * @param {string} range - Specifies the range in spreadsheet.
     * @returns {void} - Used to delete the image in spreadsheet.
     */
    deleteImage(id, range) {
        this.notify(deleteImage, { id: id, range: range ? range : this.getActiveSheet().selectedRange });
    }
    /**
     * Gets the row header div of the Spreadsheet.
     *
     * @returns {Element} - Gets the row header div of the Spreadsheet.
     * @hidden
     */
    getRowHeaderContent() {
        return this.sheetModule.getRowHeaderPanel();
    }
    /**
     * Gets the column header div of the Spreadsheet.
     *
     * @returns {HTMLElement} - Gets the column header div of the Spreadsheet.
     * @hidden
     */
    getColumnHeaderContent() {
        return this.sheetModule.getColHeaderPanel();
    }
    /**
     * Gets the main content div of the Spreadsheet.
     *
     * @returns {HTMLElement} - Gets the main content div of the Spreadsheet.
     * @hidden
     */
    getMainContent() {
        return this.sheetModule.getContentPanel();
    }
    /**
     * Get the select all div of spreadsheet
     *
     * @returns {HTMLElement} - Get the select all div of spreadsheet
     */
    getSelectAllContent() {
        return this.sheetModule.getSelectAllContent();
    }
    /**
     * Gets the horizontal scroll element of the Spreadsheet.
     *
     * @returns {HTMLElement} - Gets the column header div of the Spreadsheet.
     * @hidden
     */
    getScrollElement() {
        return this.sheetModule.getScrollElement();
    }
    /**
     * Get the main content table element of spreadsheet.
     *
     * @returns {HTMLTableElement} -Get the main content table element of spreadsheet.
     * @hidden
     */
    getContentTable() {
        return this.sheetModule.getContentTable();
    }
    /**
     * Get the row header table element of spreadsheet.
     *
     * @returns {HTMLTableElement} - Get the row header table element of spreadsheet.
     * @hidden
     */
    getRowHeaderTable() {
        return this.sheetModule.getRowHeaderTable();
    }
    /**
     * Get the column header table element of spreadsheet.
     *
     * @returns {HTMLTableElement} - Get the column header table element of spreadsheet.
     * @hidden
     */
    getColHeaderTable() {
        return this.sheetModule.getColHeaderTable();
    }
    /**
     * To get the backup element count for row and column virtualization.
     *
     * @param {'row' | 'col'} layout -  specify the layout.
     * @returns {number} - To get the backup element count for row and column virtualization.
     * @hidden
     */
    getThreshold(layout) {
        const threshold = Math.round((this.viewport[layout + 'Count'] + 1) / 2);
        return threshold < 15 ? 15 : threshold;
    }
    /**
     * @hidden
     * @returns {boolean} - Returns the bool value.
     */
    isMobileView() {
        return (!isNullOrUndefined(this.cssClass) && (this.cssClass.indexOf('e-mobile-view') > -1 || Browser.isDevice) && this.cssClass.indexOf('e-desktop-view') === -1)
            && false;
    }
    /**
     * @hidden
     * @param {number} sheetId - Specifies the sheet id.
     * @param {number} rowIndex - specify the row index.
     * @param {number} colIndex - specify the col index.
     * @param {string} formulaCellReference - specify the col index.
     * @param {boolean} refresh - specify the col index.
     * @param {boolean} isUnique - specifies the unique formula.
     * @param {boolean} isSubtotal - specifies the subtotal formula.
     * @returns {string | number} - to get Value Row Col.
     */
    getValueRowCol(sheetId, rowIndex, colIndex, formulaCellReference, refresh, isUnique, isSubtotal) {
        return super.getValueRowCol(sheetId, rowIndex, colIndex, formulaCellReference, refresh, isUnique, isSubtotal);
    }
    /**
     * Updates the properties of a specified cell.
     *
     * {% codeBlock src='spreadsheet/updateCell/index.md' %}{% endcodeBlock %}
     *
     * @param {CellModel} cell - The properties to update for the specified cell.
     * @param {string} address - The address of the cell to update. If not provided, the active cell's address will be used.
     * @param {boolean} enableDependentCellUpdate - Specifies whether dependent cells should also be updated. Default value is <c>true</c>.
     * @returns {void} - This method does not return a value.
     */
    updateCell(cell, address, enableDependentCellUpdate) {
        if (isNullOrUndefined(enableDependentCellUpdate)) {
            enableDependentCellUpdate = true;
        }
        this.updateCellInfo(cell, address, enableDependentCellUpdate, undefined, undefined, true);
    }
    /**
     * Updates the properties of a specified cell.
     *
     * @param {CellModel} cell - The properties to update for the specified cell.
     * @param {string} address - The address of the cell to update. If not provided, the active cell's address will be used.
     * @param {boolean} isDependentUpdate - Specifies whether dependent cells should also be updated.
     * @param {UndoRedoEventArgs} cellInformation - It holds the undoRedoCollections.
     * @param {boolean} isRedo - It holds the undo redo information.
     * @param {boolean} isPublic - It holds whether updateCell public method is used.
     * @returns {void} - This method does not return a value.
     *
     * @hidden
     */
    updateCellInfo(cell, address, isDependentUpdate, cellInformation, isRedo, isPublic) {
        address = address || this.getActiveSheet().activeCell;
        if (isReadOnlyCells(this, getRangeIndexes(address))) {
            return;
        }
        const isFinite = this.scrollSettings.isFinite;
        super.updateCellDetails(cell, address, cellInformation, isRedo, isDependentUpdate, isFinite, isPublic);
    }
    /**
     * Used to get a row data from the data source with updated cell value.
     *
     * {% codeBlock src='spreadsheet/getRowData/index.md' %}{% endcodeBlock %}
     *
     * @param {number} index - Specifies the row index.
     * @param {number} sheetIndex - Specifies the sheet index. By default, it consider the active sheet index.
     * @returns {Object[]} - Return row data.
     */
    getRowData(index, sheetIndex) {
        return super.getRowData(index, sheetIndex);
    }
    /**
     * Sorts the range of cells in the active sheet.
     *
     * {% codeBlock src='spreadsheet/sort/index.md' %}{% endcodeBlock %}
     *
     * @param {SortOptions} sortOptions - options for sorting.
     * @param {string} range - address of the data range.
     * @returns {Promise<SortEventArgs>} - Sorts the range of cells in the active sheet.
     */
    sort(sortOptions, range) {
        if (!this.allowSorting) {
            return Promise.reject();
        }
        const prevSort = [];
        if (this.sortCollection) {
            for (let i = this.sortCollection.length - 1; i >= 0; i--) {
                if (this.sortCollection[i] && this.sortCollection[i].sheetIndex === this.activeSheetIndex) {
                    prevSort.push(this.sortCollection[i]);
                    this.sortCollection.splice(i, 1);
                }
            }
        }
        this.notify(updateSortCollection, { sortOptions: sortOptions });
        return super.sort(sortOptions, range, prevSort).then((args) => {
            this.notify(sortComplete, args);
            return Promise.resolve(args);
        });
    }
    /**
     * @hidden
     * @param {number} sheetId - specify the sheet id.
     * @param {string | number} value - Specify the value.
     * @param {number} rowIndex - Specify the row index.
     * @param {number} colIndex - Specify the col index.
     * @param {string} formula - Specify the col index.
     * @param {boolean} isRandomFormula - Specify the random formula.
     * @returns {void} - To set value for row and col.
     */
    setValueRowCol(sheetId, value, rowIndex, colIndex, formula, isRandomFormula) {
        if (!this.isEdit && value === '#CIRCULARREF!') {
            const sheet = getSheet(this, getSheetIndexFromId(this, sheetId));
            const circularArgs = { action: 'isCircularReference', argValue: value,
                address: `${sheet.name}!${getColumnHeaderText(colIndex)}${rowIndex}` };
            this.notify(formulaOperation, circularArgs);
            value = circularArgs.argValue;
        }
        super.setValueRowCol(sheetId, value, rowIndex, colIndex, formula, isRandomFormula);
        if (this.allowEditing) {
            this.notify(editOperation, {
                action: 'refreshDependentCellValue', rowIdx: rowIndex, colIdx: colIndex,
                sheetIdx: getSheetIndexFromId(this, sheetId)
            });
        }
        else {
            const sheetIdx = getSheetIndexFromId(this, sheetId);
            rowIndex--;
            colIndex--;
            if (this.activeSheetIndex === sheetIdx) {
                const sheet = getSheet(this, sheetIdx);
                let td;
                if (!isHiddenRow(sheet, rowIndex) && !isHiddenCol(sheet, colIndex)) {
                    td = this.getCell(rowIndex, colIndex);
                }
                if (td) {
                    if (td.parentElement) {
                        const curRowIdx = td.parentElement.getAttribute('aria-rowindex');
                        if (curRowIdx && Number(curRowIdx) - 1 !== rowIndex) {
                            return;
                        }
                    }
                    const cell = getCell(rowIndex, colIndex, sheet);
                    const nodeEventArgs = {
                        value: cell.value, format: cell.format, onLoad: true,
                        formattedText: cell.value, isRightAlign: false, type: 'General', cell: cell,
                        rowIndex: rowIndex, colIndex: colIndex, isRowFill: false
                    };
                    this.notify(getFormattedCellObject, nodeEventArgs);
                    this.refreshNode(td, nodeEventArgs);
                }
            }
        }
    }
    /**
     * Get component name.
     *
     * @returns {string} - Get component name.
     * @hidden
     */
    getModuleName() {
        return 'spreadsheet';
    }
    /**
     * The `calculateNow` method is used to calculate any uncalculated formulas in a spreadsheet.
     * This method accepts an option to specify whether the calculation should be performed for the entire workbook or a specific sheet.
     *
     * @param {string} [scope] - Specifies the scope of the calculation. Acceptable values are `Sheet` or `Workbook`.
     * If not provided, the default scope is `Sheet`.
     * * `Sheet`: Calculates formulas only on the current sheet or a specified sheet.
     * * `Workbook`: Calculates formulas across the entire workbook.
     * @param {number | string} [sheet] - The index or name of the sheet to calculate if the scope is set to `Sheet`.
     * If not provided and the scope is `Sheet`, the current active sheet will be used.
     * @returns {Promise<void>} - A promise that resolves when the calculation is complete.
     * The promise does not return a specific value, but it can be used to perform actions after the calculation has finished.
     */
    calculateNow(scope, sheet) {
        return super.calculateNow(scope, sheet);
    }
    /**
     * @hidden
     * @param {Element} td - Specify the element.
     * @param {NumberFormatArgs} args - specify the args.
     * @returns {void} - to refresh the node.
     */
    refreshNode(td, args) {
        let value;
        if (td) {
            if (args) {
                args.result = isNullOrUndefined(args.formattedText) ? (isNullOrUndefined(args.result) ? '' : args.result) :
                    args.formattedText.toString();
                if (!args.isRowFill) {
                    const beforeFillSpan = td.querySelector('.e-fill-before');
                    if (beforeFillSpan) {
                        detach(beforeFillSpan);
                    }
                    const spanFillElem = select('.' + 'e-fill', td);
                    if (spanFillElem) {
                        detach(spanFillElem);
                        td.style.display = 'table-cell';
                    }
                    const spanFillSecElem = select('.' + 'e-fill-sec', td);
                    if (spanFillSecElem) {
                        detach(spanFillSecElem);
                    }
                }
                const spanElem = select('#' + this.element.id + '_currency', td);
                if (spanElem) {
                    detach(spanElem);
                }
                if (args.type === 'Accounting' && isNumber(args.value) && args.result.includes(args.curSymbol)) {
                    let curSymbol;
                    let result;
                    let setVal;
                    if (args.result.trim().endsWith(args.curSymbol)) {
                        result = args.result;
                    }
                    else {
                        curSymbol = args.result.includes(' ' + args.curSymbol) ? ' ' + args.curSymbol : args.curSymbol;
                        result = args.result.split(curSymbol).join('');
                    }
                    const dataBarVal = td.querySelector('.e-databar-value');
                    const iconSetSpan = td.querySelector('.e-iconsetspan');
                    let tdContainer = td;
                    let nodeElement;
                    if (td.children.length > 0 && td.children[td.childElementCount - 1].className.indexOf('e-addNoteIndicator') > -1) {
                        nodeElement = document.getElementsByClassName('e-addNoteIndicator')[0];
                    }
                    if (dataBarVal) {
                        this.refreshNode(dataBarVal, { result: result });
                        tdContainer = td.querySelector('.e-cf-databar') || td;
                    }
                    else if (td.querySelector('a')) {
                        td.querySelector('a').textContent = result;
                    }
                    else {
                        setVal = true;
                        td.innerText = '';
                    }
                    if (iconSetSpan) {
                        td.insertBefore(iconSetSpan, td.firstElementChild);
                    }
                    if (curSymbol) {
                        const curr = this.createElement('span', { id: this.element.id + '_currency', styles: 'float: left' });
                        curr.innerText = curSymbol;
                        tdContainer.appendChild(curr);
                        if (!isNullOrUndefined(nodeElement)) {
                            tdContainer.appendChild(nodeElement);
                        }
                    }
                    if (setVal) {
                        td.innerHTML += result;
                    }
                    td.classList.add('e-right-align');
                    return;
                }
                else {
                    let alignClass;
                    if (args.result && (args.result.toLowerCase() === 'true' || args.result.toLowerCase() === 'false')) {
                        args.result = args.result.toUpperCase();
                        alignClass = 'e-center-align';
                        args.isRightAlign = true; // Re-use this to center align the cell.
                    }
                    else {
                        alignClass = 'e-right-align';
                    }
                    value = args.result;
                    if (!this.allowWrap) {
                        if (value.toString().includes('\n')) {
                            value = value.replace(/\n/g, '');
                        }
                    }
                    if (args.isRightAlign) {
                        td.classList.add(alignClass);
                    }
                    else {
                        td.classList.remove(alignClass);
                    }
                }
            }
            value = !isNullOrUndefined(value) ? value : '';
            if (!isNullOrUndefined(args.rowIndex) && !isNullOrUndefined(args.colIndex)) {
                attributes(td, { 'aria-label': (value ? value + ' ' : '') + getCellAddress(args.rowIndex, args.colIndex) });
            }
            let node = td.lastChild;
            if (node && node.nodeName === 'SPAN' && node.classList.contains('e-iconsetspan')) {
                node = null;
            }
            const nodeIndicator = td.querySelector('.e-addNoteIndicator');
            if (nodeIndicator) {
                node = nodeIndicator.previousSibling;
            }
            if (td.querySelector('.e-databar-value')) {
                node = td.querySelector('.e-databar-value').lastChild;
            }
            if (td.querySelector('.e-hyperlink')) {
                if (args.cell && args.cell.wrap && value && value.toString().indexOf('\n')) {
                    td.querySelector('.e-hyperlink').textContent = value;
                }
                node = td.querySelector('.e-hyperlink').lastChild;
            }
            const wrapContent = td.querySelector('.e-wrap-content');
            if (wrapContent && !(td.querySelector('.e-hyperlink') || td.querySelector('.e-databar-value'))) {
                if (!wrapContent.lastChild) {
                    wrapContent.appendChild(document.createTextNode(''));
                }
                node = wrapContent.lastChild;
            }
            if ((this.isAngular || this.isVue) &&
                td.classList.contains('e-cell-template') && node && (node.nodeType === 8 || node.nodeType === 3)) {
                if (node.nodeType === 3 || value !== '') {
                    const checkNodeFn = () => {
                        if (!td.childElementCount) {
                            if (node.nodeType === 3) {
                                if (!args.isRowFill) {
                                    node.nodeValue = value;
                                }
                            }
                            else {
                                td.appendChild(document.createTextNode(value));
                            }
                        }
                    };
                    if (this.isAngular) {
                        getUpdateUsingRaf(checkNodeFn);
                    }
                    else {
                        checkNodeFn();
                    }
                }
            }
            else if (node && (node.nodeType === 3 || node.nodeType === 1)) {
                if (!args.isRowFill) {
                    if (!isNullOrUndefined(node.className) &&
                        node.className.indexOf('e-addNoteIndicator') > -1) {
                        node = td.lastChild;
                        node.nodeValue = value;
                    }
                    else {
                        node.nodeValue = value;
                    }
                }
            }
            else {
                td.appendChild(document.createTextNode(value));
            }
        }
    }
    /**
     * @hidden
     * @param {CellStyleModel} style - specify the style.
     * @param {number} lines - Specify the lines.
     * @param {number} borderWidth - Specify the borderWidth.
     * @returns {number} - To calculate Height
     */
    calculateHeight(style, lines = 1, borderWidth = 1) {
        const fontSize = (style && style.fontSize) || this.cellStyle.fontSize;
        const threshold = style.fontFamily === 'Arial Black' ? 1.44 : 1.24;
        return ((fontSize.indexOf('pt') > -1 ? parseInt(fontSize, 10) * 1.33 : parseInt(fontSize, 10)) * threshold * lines) +
            (borderWidth * threshold);
    }
    /**
     * @hidden
     * @param {number} startIdx - specify the start index.
     * @param {number} endIdx - Specify the end index.
     * @param {string} layout - Specify the rows.
     * @param {boolean} finite - Specifies the scroll mode.
     * @returns {number[]} - To skip the hidden rows.
     */
    skipHidden(startIdx, endIdx, layout = 'rows', finite = this.scrollSettings.isFinite) {
        const sheet = this.getActiveSheet();
        let totalCount;
        if (this.scrollSettings.isFinite) {
            totalCount = (layout === 'rows' ? sheet.rowCount : sheet.colCount) - 1;
        }
        for (let i = startIdx; i <= endIdx; i++) {
            if ((sheet[`${layout}`])[i] && (sheet[`${layout}`])[i].hidden) {
                if (startIdx === i) {
                    startIdx++;
                }
                endIdx++;
                if (finite && endIdx > totalCount) {
                    endIdx = totalCount;
                    break;
                }
            }
            else if (!finite && this.scrollSettings.isFinite && endIdx > totalCount) {
                if ((sheet[`${layout}`])[i - 1] && (sheet[`${layout}`])[i - 1].hidden) {
                    endIdx--;
                    break;
                }
            }
        }
        return [startIdx, endIdx];
    }
    /**
     * @hidden
     * @param {HTMLElement} nextTab - Specify the element.
     * @param {string} selector - Specify the selector
     * @returns {void} - To update the active border.
     */
    updateActiveBorder(nextTab, selector = '.e-ribbon') {
        const indicator = select(`${selector} .e-tab-header .e-indicator`, this.element);
        indicator.style.display = 'none';
        setStyleAttribute$1(indicator, { 'left': '', 'right': '' });
        setStyleAttribute$1(indicator, {
            'left': nextTab.offsetLeft + 'px', 'right': nextTab.parentElement.offsetWidth - (nextTab.offsetLeft + nextTab.offsetWidth) + 'px'
        });
        indicator.style.display = '';
    }
    /**
     * To perform the undo operation in spreadsheet.
     *
     * {% codeBlock src='spreadsheet/undo/index.md' %}{% endcodeBlock %}
     *
     * @returns {void} - To perform the undo operation in spreadsheet.
     */
    undo() {
        this.notify(performUndoRedo, { isUndo: true, isPublic: true });
    }
    /**
     * To perform the redo operation in spreadsheet.
     *
     * {% codeBlock src='spreadsheet/redo/index.md' %}{% endcodeBlock %}
     *
     * @returns {void} - To perform the redo operation in spreadsheet.
     */
    redo() {
        this.notify(performUndoRedo, { isUndo: false, isPublic: true });
    }
    /**
     * To update the undo redo collection in spreadsheet.
     *
     * {% codeBlock src='spreadsheet/updateUndoRedoCollection/index.md' %}{% endcodeBlock %}
     *
     * @param {object} args - options for undo redo.
     * @returns {void} - To update the undo redo collection in spreadsheet.
     */
    updateUndoRedoCollection(args) {
        this.notify(updateUndoRedoCollection, { args: args, isPublic: true });
    }
    /**
     * Adds the defined name to the Spreadsheet.
     *
     * {% codeBlock src='spreadsheet/addDefinedName/index.md' %}{% endcodeBlock %}
     *
     * @param {DefineNameModel} definedName - Specifies the name, scope, comment, refersTo.
     * @returns {boolean} - Return the added status of the defined name.
     */
    addDefinedName(definedName) {
        const eventArgs = {
            action: 'addDefinedName',
            isAdded: false,
            definedName: definedName
        };
        this.notify(formulaOperation, eventArgs);
        return eventArgs.isAdded;
    }
    /**
     * Removes the defined name from the Spreadsheet.
     *
     * {% codeBlock src='spreadsheet/removeDefinedName/index.md' %}{% endcodeBlock %}
     *
     * @param {string} definedName - Specifies the name.
     * @param {string} scope - Specifies the scope of the defined name.
     * @returns {boolean} - Return the removed status of the defined name.
     */
    removeDefinedName(definedName, scope) {
        return super.removeDefinedName(definedName, scope);
    }
    mouseClickHandler(e) {
        this.notify(click, e);
    }
    mouseDownHandler(e) {
        this.notify(mouseDown, e);
    }
    keyUpHandler(e) {
        if (closest(e.target, '.e-find-dlg')) {
            this.notify(findKeyUp, e);
        }
        else {
            this.notify(keyUp, e);
        }
    }
    keyDownHandler(e) {
        const findToolDlg = closest(e.target, '.e-findtool-dlg');
        if (findToolDlg) {
            if (e.keyCode === 9) {
                const target = e.target;
                if (e.shiftKey) {
                    if (target.classList.contains('e-text-findNext-short')) {
                        const focusEle = findToolDlg.querySelector('.e-findRib-close .e-tbar-btn');
                        if (focusEle) {
                            e.preventDefault();
                            focusEle.focus();
                        }
                    }
                }
                else if (target.classList.contains('e-tbar-btn') && target.parentElement.classList.contains('e-findRib-close')) {
                    focus(findToolDlg);
                }
            }
        }
        else {
            this.notify(keyDown, e);
            const dialogbox = closest(e.target, '.e-dialog');
            if (!this.enableKeyboardNavigation && (document.activeElement.classList.contains('e-cell') || dialogbox)) {
                if ([38, 40, 33, 34, 35, 36, 9].indexOf(e.keyCode) > -1) {
                    e.preventDefault();
                }
            }
        }
    }
    freeze(e) {
        if (!this.allowFreezePane || e.row < 0 || e.column < 0) {
            return;
        }
        if (e.triggerEvent) {
            const args = {
                row: e.row, column: e.column,
                cancel: false, sheetIndex: this.activeSheetIndex
            };
            this.notify(beginAction, { eventArgs: args, action: 'freezePanes' });
            if (args.cancel) {
                return;
            }
        }
        this.on(contentLoaded, this.freezePaneUpdated, this);
        this.freezePanes(e.row, e.column);
        this.notify(refreshRibbonIcons, null);
    }
    freezePaneUpdated() {
        this.off(contentLoaded, this.freezePaneUpdated);
        const sheet = this.getActiveSheet();
        focus(this.element);
        this.notify(completeAction, { eventArgs: { row: sheet.frozenRows, column: sheet.frozenColumns,
                sheetIndex: this.activeSheetIndex }, action: 'freezePanes' });
    }
    /**
     * Binding events to the element while component creation.
     *
     * @returns {void} - Binding events to the element while component creation.
     */
    wireEvents() {
        EventHandler.add(this.element, 'click', this.mouseClickHandler, this);
        EventHandler.add(this.element, getStartEvent(), this.mouseDownHandler, this);
        EventHandler.add(this.element, 'keyup', this.keyUpHandler, this);
        EventHandler.add(this.element, 'keydown', this.keyDownHandler, this);
        this.on(freeze, this.freeze, this);
        this.on(refreshInsertDelete, this.refreshInsertDelete, this);
    }
    /**
     * Destroys the component (detaches/removes all event handlers, attributes, classes, and empties the component element).
     *
     * {% codeBlock src='spreadsheet/destroy/index.md' %}{% endcodeBlock %}
     *
     * @returns {void} - Destroys the component.
     */
    destroy() {
        if (this.isReact) {
            this['clearTemplate']();
        }
        this.unwireEvents();
        this.notify(spreadsheetDestroyed, null);
        super.destroy();
        this.element.innerHTML = '';
        this.element.removeAttribute('tabindex');
        this.element.removeAttribute('role');
        this.element.style.removeProperty('height');
        this.element.style.removeProperty('width');
        this.element.style.removeProperty('min-height');
        this.element.style.removeProperty('min-width');
        if (this.sheetModule) {
            this.sheetModule.destroy();
        }
    }
    /**
     * Unbinding events from the element while component destroy.
     *
     * @returns {void} - Unbinding events from the element while component destroy.
     */
    unwireEvents() {
        EventHandler.remove(this.element, 'click', this.mouseClickHandler);
        EventHandler.remove(this.element, getStartEvent(), this.mouseDownHandler);
        EventHandler.remove(this.element, 'keyup', this.keyUpHandler);
        EventHandler.remove(this.element, 'keydown', this.keyDownHandler);
        this.off(freeze, this.freeze);
        this.off(refreshInsertDelete, this.refreshInsertDelete);
    }
    refreshInsertDelete(args) {
        if (args.modelType === 'Sheet') {
            return;
        }
        let updated;
        let indexes;
        args.sheet.ranges.forEach((range) => {
            if (range.template && range.address) {
                indexes = getRangeIndexes(range.address);
                updated = this.updateRangeOnInsertDelete(args, indexes);
                if (updated) {
                    range.address = getRangeAddress(indexes);
                }
            }
        });
        this.setSheetPropertyOnMute(args.sheet, 'ranges', args.sheet.ranges);
    }
    /**
     * To add context menu items.
     *
     * {% codeBlock src='spreadsheet/addContextMenu/index.md' %}{% endcodeBlock %}
     *
     * @param {MenuItemModel[]} items - Items that needs to be added.
     * @param {string} text - Item before / after that the element to be inserted.
     * @param {boolean} insertAfter - Set `false` if the `items` need to be inserted before the `text`.
     * By default, `items` are added after the `text`.
     * @param {boolean} isUniqueId - Set `true` if the given `text` is a unique id.
     * @returns {void} - To add context menu items.
     */
    addContextMenuItems(items, text, insertAfter = true, isUniqueId) {
        this.notify(addContextMenuItems, { items: items, text: text, insertAfter: insertAfter, isUniqueId: isUniqueId });
    }
    /**
     * To remove existing context menu items.
     *
     * {% codeBlock src='spreadsheet/removeContextMenuItems/index.md' %}{% endcodeBlock %}
     *
     * @param {string[]} items - Items that needs to be removed.
     * @param {boolean} isUniqueId - Set `true` if the given `text` is a unique id.
     * @returns {void} - To remove existing context menu items.
     */
    removeContextMenuItems(items, isUniqueId) {
        this.notify(removeContextMenuItems, { items: items, isUniqueId: isUniqueId });
    }
    /**
     * To enable / disable context menu items.
     *
     * {% codeBlock src='spreadsheet/enableContextMenuItems/index.md' %}{% endcodeBlock %}
     *
     * @param {string[]} items - Items that needs to be enabled / disabled.
     * @param {boolean} enable - Set `true` / `false` to enable / disable the menu items.
     * @param {boolean} isUniqueId - Set `true` if the given `text` is a unique id.
     * @returns {void} - To enable / disable context menu items.
     */
    enableContextMenuItems(items, enable = true, isUniqueId) {
        this.notify(enableContextMenuItems, { items: items, enable: enable, isUniqueId: isUniqueId });
    }
    /**
     * To enable / disable file menu items.
     *
     * {% codeBlock src='spreadsheet/enableFileMenuItems/index.md' %}{% endcodeBlock %}
     *
     * @param {string[]} items - Items that needs to be enabled / disabled.
     * @param {boolean} enable - Set `true` / `false` to enable / disable the menu items.
     * @param {boolean} isUniqueId - Set `true` if the given file menu items `text` is a unique id.
     * @returns {void} - To enable / disable file menu items.
     */
    enableFileMenuItems(items, enable = true, isUniqueId) {
        this.notify(enableFileMenuItems, { items: items, enable: enable, isUniqueId: isUniqueId });
    }
    /**
     * To show/hide the file menu items in Spreadsheet ribbon.
     *
     * {% codeBlock src='spreadsheet/hideFileMenuItems/index.md' %}{% endcodeBlock %}
     *
     * @param {string[]} items - Specifies the file menu items text which is to be show/hide.
     * @param {boolean} hide - Set `true` / `false` to hide / show the file menu items.
     * @param {boolean} isUniqueId - Set `true` if the given file menu items `text` is a unique id.
     * @returns {void} - To show/hide the file menu items in Spreadsheet ribbon.
     */
    hideFileMenuItems(items, hide = true, isUniqueId) {
        this.notify(hideFileMenuItems, { items: items, hide: hide, isUniqueId: isUniqueId });
    }
    /**
     * To add custom file menu items.
     *
     * {% codeBlock src='spreadsheet/addFileMenuItems/index.md' %}{% endcodeBlock %}
     *
     * @param {MenuItemModel[]} items - Specifies the ribbon file menu items to be inserted.
     * @param {string} text - Specifies the existing file menu item text before / after which the new file menu items to be inserted.
     * @param {boolean} insertAfter - Set `false` if the `items` need to be inserted before the `text`.
     * By default, `items` are added after the `text`.
     * @param {boolean} isUniqueId - Set `true` if the given file menu items `text` is a unique id.
     * @returns {void} - To add custom file menu items.
     */
    addFileMenuItems(items, text, insertAfter = true, isUniqueId) {
        this.notify(addFileMenuItems, { items: items, text: text, insertAfter: insertAfter, isUniqueId: isUniqueId });
    }
    /**
     * To show/hide the existing ribbon tabs.
     *
     * {% codeBlock src='spreadsheet/hideRibbonTabs/index.md' %}{% endcodeBlock %}
     *
     * @param {string[]} tabs - Specifies the tab header text which needs to be shown/hidden.
     * @param {boolean} hide - Set `true` / `false` to hide / show the ribbon tabs.
     * @returns {void} - To show/hide the existing ribbon tabs.
     */
    hideRibbonTabs(tabs, hide = true) {
        this.notify(hideRibbonTabs, { tabs: tabs, hide: hide });
    }
    /**
     * To enable / disable the existing ribbon tabs.
     *
     * {% codeBlock src='spreadsheet/enableRibbonTabs/index.md' %}{% endcodeBlock %}
     *
     * @param {string[]} tabs - Specifies the tab header text which needs to be enabled / disabled.
     * @param {boolean} enable - Set `true` / `false` to enable / disable the ribbon tabs.
     * @returns {void} - To enable / disable the existing ribbon tabs.
     */
    enableRibbonTabs(tabs, enable = true) {
        this.notify(enableRibbonTabs, { tabs: tabs, enable: enable });
    }
    /**
     * To add custom ribbon tabs.
     *
     * {% codeBlock src='spreadsheet/addRibbonTabs/index.md' %}{% endcodeBlock %}
     *
     * @param {RibbonItemModel[]} items - Specifies the ribbon tab items to be inserted.
     * @param {string} insertBefore - Specifies the existing ribbon header text before which the new tabs will be inserted.
     * If not specified, the new tabs will be inserted at the end.
     * @returns {void} - To add custom ribbon tabs.
     */
    addRibbonTabs(items, insertBefore) {
        this.notify(addRibbonTabs, { items: items, insertBefore: insertBefore });
    }
    /**
     * Enables or disables the specified ribbon toolbar items or all ribbon items.
     *
     * {% codeBlock src='spreadsheet/enableToolbarItems/index.md' %}{% endcodeBlock %}
     *
     * @param {string} tab - Specifies the ribbon tab header text under which the toolbar items need to be enabled / disabled.
     * @param {number[]} items - Specifies the toolbar item indexes / unique id's which needs to be enabled / disabled.
     * If it is not specified the entire toolbar items will be enabled / disabled.
     * @param  {boolean} enable - Boolean value that determines whether the toolbar items should be enabled or disabled.
     * @returns {void} - Enables or disables the specified ribbon toolbar items or all ribbon items.
     */
    enableToolbarItems(tab, items, enable) {
        this.notify(enableToolbarItems, [{ tab: tab, items: items, enable: enable === undefined ? true : enable }]);
    }
    /**
     * To show/hide the existing Spreadsheet ribbon toolbar items.
     *
     * {% codeBlock src='spreadsheet/hideToolbarItems/index.md' %}{% endcodeBlock %}
     *
     * @param {string} tab - Specifies the ribbon tab header text under which the specified items needs to be hidden / shown.
     * @param {number[]} indexes - Specifies the toolbar indexes which needs to be shown/hidden from UI.
     * @param {boolean} hide - Set `true` / `false` to hide / show the toolbar items.
     * @returns {void} - To show/hide the existing Spreadsheet ribbon toolbar items.
     */
    hideToolbarItems(tab, indexes, hide = true) {
        this.notify(hideToolbarItems, { tab: tab, indexes: indexes, hide: hide });
    }
    /**
     * To add the custom items in Spreadsheet ribbon toolbar.
     *
     * {% codeBlock src='spreadsheet/addToolbarItems/index.md' %}{% endcodeBlock %}
     *
     * @param {string} tab - Specifies the ribbon tab header text under which the specified items will be inserted.
     * @param {ItemModel[]} items - Specifies the ribbon toolbar items that needs to be inserted.
     * @param {number} index - Specifies the index text before which the new items will be inserted.
     * If not specified, the new items will be inserted at the end of the toolbar.
     * @returns {void} - To add the custom items in Spreadsheet ribbon toolbar.
     */
    addToolbarItems(tab, items, index) {
        this.notify(addToolbarItems, { tab: tab, items: items, index: index });
    }
    /**
     * Selects the cell / range of cells with specified address.
     *
     * {% codeBlock src='spreadsheet/selectRange/index.md' %}{% endcodeBlock %}
     *
     * @param {string} address - Specifies the range address.
     * @returns {void} - To select the range.
     */
    selectRange(address) {
        if (this.isEdit) {
            this.notify(editOperation, { action: 'endEdit' });
        }
        this.notify(selectRange, { address: address });
    }
    /**
     * Allows you to select a chart from the active sheet. To select a specific chart from the active sheet, pass the chart `id`.
     * If you pass an empty argument, the chart present in the active cell will be selected. If the active cell does not have a chart,
     * the initially rendered chart will be selected from the active sheet.
     *
     * @param {string} id - Specifies the chart `id` to be selected.
     * @returns {void}
     */
    selectChart(id) {
        this.selectOverlay(id, true);
    }
    /**
     * Allows you to select an image from the active sheet. To select a specific image from the active sheet, pass the image `id`.
     * If you pass an empty argument, the image present in the active cell will be selected. If the active cell does not have an image,
     * the initially rendered image will be selected from the active sheet.
     *
     * @param {string} id - Specifies the image `id` to be selected.
     * @returns {void}
     */
    selectImage(id) {
        this.selectOverlay(id);
    }
    selectOverlay(id, isChart) {
        const sheet = this.getActiveSheet();
        if (sheet.isProtected || !this.allowEditing) {
            return;
        }
        if (!id) {
            const activeCell = getCellIndexes(sheet.activeCell);
            const cell = getCell(activeCell[0], activeCell[1], sheet, false, true);
            if (isChart) {
                if (cell.chart && cell.chart.length) {
                    id = cell.chart[cell.chart.length - 1].id;
                }
            }
            else if (cell.image && cell.image.length) {
                id = cell.image[cell.image.length - 1].id;
            }
        }
        let overlayEle;
        if (id) {
            overlayEle = this.element.querySelector(`#${id}`);
            if (!overlayEle.classList.contains('e-ss-overlay')) {
                overlayEle = overlayEle.parentElement;
            }
        }
        else {
            overlayEle = this.element.querySelector(`.e-ss-overlay${isChart ? '.e-datavisualization-chart' : ':not(.e-datavisualization-chart)'}`);
        }
        if (overlayEle) {
            let isChartActive;
            const activeOverlay = this.element.getElementsByClassName('e-ss-overlay-active')[0];
            if (activeOverlay) {
                activeOverlay.classList.remove('e-ss-overlay-active');
                isChartActive = activeOverlay.classList.contains('e-datavisualization-chart');
                if (isChartActive) {
                    this.notify(clearChartBorder, null);
                }
            }
            overlayEle.classList.add('e-ss-overlay-active');
            if (overlayEle.classList.contains('e-datavisualization-chart')) {
                this.notify(focusChartBorder, { id: overlayEle.id });
                if (!isChartActive) {
                    this.notify(insertDesignChart, { id: overlayEle.id });
                }
            }
            else if (isChartActive) {
                this.notify(removeDesignChart, null);
            }
        }
    }
    /**
     * Allows you to remove a selection from the active chart.
     *
     * @returns {void}
     */
    deselectChart() {
        this.notify(refreshOverlayElem, { selector: '.e-datavisualization-chart' });
    }
    /**
     * Allows you to remove a selection from the active image.
     *
     * @returns {void}
     */
    deselectImage() {
        this.notify(refreshOverlayElem, { selector: ':not(.e-datavisualization-chart)' });
    }
    /**
     * Start edit the active cell.
     *
     * {% codeBlock src='spreadsheet/startEdit/index.md' %}{% endcodeBlock %}
     *
     * @returns {void} - Start edit the active cell.
     */
    startEdit() {
        this.notify(editOperation, { action: 'startEdit', isNewValueEdit: false });
    }
    /**
     * Cancels the edited state, this will not update any value in the cell.
     *
     * {% codeBlock src='spreadsheet/closeEdit/index.md' %}{% endcodeBlock %}
     *
     * @returns {void} - Cancels the edited state, this will not update any value in the cell.
     */
    closeEdit() {
        this.notify(editOperation, { action: 'cancelEdit' });
    }
    /**
     * If Spreadsheet is in editable state, you can save the cell by invoking endEdit.
     *
     * {% codeBlock src='spreadsheet/endEdit/index.md' %}{% endcodeBlock %}
     *
     * @returns {void} - If Spreadsheet is in editable state, you can save the cell by invoking endEdit.
     */
    endEdit() {
        this.notify(editOperation, { action: 'endEdit', isPublic: true });
    }
    /**
     * This method is used to print the active sheet or the entire workbook.
     *
     * @param {printOptions} printOptions - Represents the settings to customize the print type, row and column headers and gridlines in the printing operation.
     * @returns {void}
     */
    print(printOptions = { type: 'ActiveSheet', allowRowColumnHeader: false, allowGridLines: false }) {
        if (this.allowPrint && !isNullOrUndefined(this.printModule)) {
            this.printModule.print(this, printOptions);
        }
    }
    /**
     * Called internally if any of the property value changed.
     *
     * @param  {SpreadsheetModel} newProp - Specify the new properties
     * @param  {SpreadsheetModel} oldProp - Specify the old properties
     * @returns {void} - Called internally if any of the property value changed.
     * @hidden
     */
    onPropertyChanged(newProp, oldProp) {
        super.onPropertyChanged(newProp, oldProp);
        let sheetTabsRefreshed;
        for (const prop of Object.keys(newProp)) {
            let header;
            let addBtn;
            const sheet = this.getActiveSheet();
            const horizontalScroll = this.getScrollElement();
            switch (prop) {
                case 'enableRtl':
                    if (newProp.locale || newProp.currencyCode) {
                        break;
                    }
                    header = this.getColumnHeaderContent();
                    if (header) {
                        header = header.parentElement;
                    }
                    if (!header) {
                        break;
                    }
                    if (newProp.enableRtl) {
                        header.style.marginRight = '';
                        document.getElementById(this.element.id + '_sheet_panel').classList.add('e-rtl');
                    }
                    else {
                        header.style.marginLeft = '';
                        document.getElementById(this.element.id + '_sheet_panel').classList.remove('e-rtl');
                    }
                    if (this.allowScrolling) {
                        this.scrollModule.setPadding(true);
                    }
                    if (this.allowAutoFill) {
                        const autofillEle = this.element.querySelector('.e-dragfill-ddb');
                        if (autofillEle) {
                            const autofillDdb = getComponent(autofillEle, 'dropdown-btn');
                            if (autofillDdb) {
                                autofillDdb.enableRtl = newProp.enableRtl;
                                autofillDdb.dataBind();
                            }
                        }
                    }
                    this.sheetModule.setPanelWidth(sheet, this.getRowHeaderContent(), true);
                    if (this.allowImage || this.allowChart) {
                        const overlays = this.element.getElementsByClassName('e-ss-overlay');
                        let chart;
                        let overlay;
                        let chartEle;
                        for (let idx = 0, overlayLen = overlays.length - 1; idx <= overlayLen; idx++) {
                            overlay = overlays[0];
                            if (overlay.classList.contains('e-datavisualization-chart')) {
                                chartEle = overlay.querySelector('.e-accumulationchart');
                                if (chartEle) {
                                    chart = getComponent(chartEle, 'accumulationchart');
                                }
                                else {
                                    chartEle = overlay.querySelector('.e-chart');
                                    chart = chartEle && getComponent(chartEle, 'chart');
                                }
                                if (chart) {
                                    chart.destroy();
                                }
                            }
                            detach(overlay);
                            if (idx === overlayLen) {
                                this.notify(updateView, {});
                            }
                        }
                    }
                    if (horizontalScroll) {
                        horizontalScroll.scrollLeft = 0;
                    }
                    this.selectRange(sheet.selectedRange);
                    break;
                case 'cssClass':
                    if (oldProp.cssClass) {
                        removeClass([this.element], oldProp.cssClass.split(' '));
                    }
                    if (newProp.cssClass) {
                        addClass([this.element], newProp.cssClass.split(' '));
                    }
                    break;
                case 'activeSheetIndex':
                    this.renderModule.refreshSheet();
                    this.notify(activeSheetChanged, { idx: newProp.activeSheetIndex });
                    break;
                case 'width':
                    this.setWidth();
                    this.resize();
                    break;
                case 'height':
                    this.setHeight();
                    this.resize();
                    break;
                case 'showRibbon':
                    this.notify(ribbon, { prop: 'showRibbon', onPropertyChange: true });
                    break;
                case 'showFormulaBar':
                    this.notify(formulaBar, { uiUpdate: true });
                    break;
                case 'showSheetTabs':
                    this.notify(sheetTabs, null);
                    break;
                case 'cellStyle':
                    this.renderModule.refreshSheet();
                    break;
                case 'allowEditing':
                    if (this.allowEditing) {
                        this.notify(editOperation, { action: 'renderEditor' });
                        if (this.enableKeyboardNavigation) {
                            // Remove and reassign the `keyDown` and `mouseDown` event in `KeyboardNavigation` and `Selection` module.
                            // To execute the respective event after editing operation.
                            this.enableKeyboardNavigation = false;
                            this.dataBind();
                            this.enableKeyboardNavigation = true;
                            this.dataBind();
                            const mode = this.selectionSettings.mode;
                            if (mode !== 'None') {
                                this.selectionSettings.mode = 'None';
                                this.dataBind();
                                this.selectionSettings.mode = mode;
                                this.dataBind();
                            }
                        }
                    }
                    else {
                        this.notify(refreshOverlayElem, null);
                    }
                    break;
                case 'allowInsert':
                    addBtn = this.element.getElementsByClassName('e-add-sheet-tab')[0];
                    if (addBtn) {
                        addBtn.disabled = !this.allowInsert;
                        if (this.allowInsert) {
                            if (addBtn.classList.contains('e-disabled')) {
                                addBtn.classList.remove('e-disabled');
                            }
                        }
                        else {
                            if (!addBtn.classList.contains('e-disabled')) {
                                addBtn.classList.add('e-disabled');
                            }
                        }
                    }
                    break;
                case 'sheets':
                    if (newProp.sheets === this.sheets) {
                        this.renderModule.refreshSheet();
                        this.notify(refreshSheetTabs, null);
                        this.notify(workbookFormulaOperation, { action: 'initSheetInfo' });
                        break;
                    }
                    Object.keys(newProp.sheets).forEach((sheetIndex, index) => {
                        const sheetIdx = Number(sheetIndex);
                        const sheet = newProp.sheets[sheetIdx];
                        const curSheet = getSheet(this, sheetIdx);
                        if (sheet.ranges && Object.keys(sheet.ranges).length) {
                            const ranges = Object.keys(sheet.ranges);
                            let newRangeIdx;
                            ranges.forEach((rangeIdx, idx) => {
                                if (!sheet.ranges[Number(rangeIdx)].info) {
                                    newRangeIdx = idx;
                                }
                            });
                            let rangeIdx;
                            let range;
                            let curRange;
                            let dataSource;
                            ranges.forEach((rangeIndex, idx) => {
                                if (isUndefined$1(newRangeIdx) || newRangeIdx === idx) {
                                    rangeIdx = Number(rangeIndex);
                                    range = sheet.ranges[rangeIdx];
                                    curRange = curSheet.ranges[rangeIdx];
                                    dataSource = range.dataSource;
                                    if (range.fieldsOrder && curRange.info && !dataSource && curRange.dataSource) {
                                        dataSource = curRange.dataSource;
                                    }
                                    if (dataSource) {
                                        this.notify(dataSourceChanged, { sheetIdx: sheetIdx, rangeIdx: rangeIdx, changedData: dataSource });
                                    }
                                }
                            });
                        }
                        else if (sheet.paneTopLeftCell && oldProp.sheets && oldProp.sheets[`${sheetIdx}`] &&
                            oldProp.sheets[`${sheetIdx}`].paneTopLeftCell) {
                            if (this.activeSheetIndex !== Number(sheetIdx)) {
                                return;
                            }
                            const cIdx = getCellIndexes(sheet.paneTopLeftCell);
                            const pIdx = getCellIndexes(oldProp.sheets[`${sheetIdx}`].paneTopLeftCell);
                            if (cIdx[0] !== pIdx[0]) {
                                const frozenRow = this.frozenRowCount(this.getActiveSheet());
                                const top = cIdx[0] > frozenRow ? getRowsHeight(this.getActiveSheet(), frozenRow, cIdx[0] - 1) : 0;
                                this.notify(updateScroll, { top: top });
                            }
                            if (cIdx[1] !== pIdx[1]) {
                                const frozenCol = this.frozenColCount(this.getActiveSheet());
                                const left = cIdx[1] > frozenCol ? getColumnsWidth(this.getActiveSheet(), frozenCol, cIdx[1] - 1) : 0;
                                this.notify(updateScroll, { left: left });
                            }
                        }
                        else {
                            if (index === 0) {
                                this.renderModule.refreshSheet();
                            }
                            if (this.showSheetTabs && sheet.name && !sheetTabsRefreshed) {
                                const items = select('.e-sheet-tabs-items', this.element);
                                const idx = Number(sheetIdx);
                                if (items.children[idx + 1]) {
                                    this.notify(sheetNameUpdate, { items: items, value: sheet.name, idx: idx });
                                }
                                else {
                                    this.notify(refreshSheetTabs, null);
                                    sheetTabsRefreshed = true;
                                }
                            }
                        }
                    });
                    break;
                case 'locale':
                    this.refresh();
                    break;
                case 'currencyCode':
                    if (!newProp.locale) {
                        this.refresh();
                    }
                    break;
                case 'password':
                    if (this.password.length > 0) {
                        if (this.showSheetTabs) {
                            this.element.querySelector('.e-add-sheet-tab').setAttribute('disabled', 'true');
                            this.element.querySelector('.e-add-sheet-tab').classList.add('e-disabled');
                        }
                    }
                    break;
                case 'isProtected':
                    if (this.isProtected) {
                        const addBtn = this.element.getElementsByClassName('e-add-sheet-tab')[0];
                        if (addBtn) {
                            addBtn.disabled = this.isProtected;
                            if (this.isProtected) {
                                if (addBtn.classList.contains('e-disabled')) {
                                    addBtn.classList.add('e-disabled');
                                }
                            }
                            else {
                                if (!addBtn.classList.contains('e-disabled')) {
                                    addBtn.classList.remove('e-disabled');
                                }
                            }
                        }
                    }
                    break;
                case 'allowFreezePane':
                    this.notify(ribbon, { prop: 'allowFreezePane', onPropertyChange: true });
                    break;
                case 'allowImage':
                case 'allowChart':
                    this.renderModule.refreshSheet();
                    this.notify(ribbon, { prop: prop, onPropertyChange: true });
                    break;
                case 'calculationMode':
                    if (oldProp.calculationMode === 'Manual') {
                        this.notify(workbookFormulaOperation, { action: 'ClearDependentCellCollection' });
                    }
                    this.notify(ribbon, { prop: prop, onPropertyChange: true });
                    break;
                case 'allowResizing':
                    if (newProp.allowResizing) {
                        this.notify(propertyChange, { propertyName: prop });
                    }
                    break;
                case 'enableNotes':
                    if (newProp.enableNotes) {
                        this.notify(updateView, {});
                    }
                    break;
                case 'allowNumberFormatting':
                case 'allowWrap':
                case 'allowCellFormatting':
                    this.notify(ribbon, { prop: prop, onPropertyChange: true });
                    this.notify(updateView, {});
                    break;
                case 'showAggregate':
                    this.notify(showAggregate, { remove: !this.showAggregate });
                    break;
            }
        }
    }
    /**
     * To provide the array of modules needed for component rendering.
     *
     * @returns {ModuleDeclaration[]} - To provide the array of modules needed for component rendering.
     * @hidden
     */
    requiredModules() {
        return getRequiredModules(this);
    }
    /**
     * Appends the control within the given HTML Div element.
     *
     * {% codeBlock src='spreadsheet/appendTo/index.md' %}{% endcodeBlock %}
     *
     * @param {string | HTMLElement} selector - Target element where control needs to be appended.
     * @returns {void} - Appends the control within the given HTML Div element.
     */
    appendTo(selector) {
        super.appendTo(selector);
    }
    /**
     * Filters the range of cells in the sheet.
     *
     * @hidden
     * @param {FilterOptions} filterOptions - specifiy the FilterOptions.
     * @param {string} range - Specify the range
     * @returns {Promise<FilterEventArgs>} - Filters the range of cells in the sheet.
     */
    filter(filterOptions, range) {
        if (!this.allowFiltering) {
            return Promise.reject();
        }
        range = range || this.getActiveSheet().selectedRange;
        return super.filter(filterOptions, range);
    }
    /**
     * Clears the filter changes of the sheet.
     *
     * {% codeBlock src='spreadsheet/clearFilter/index.md' %}{% endcodeBlock %}
     *
     * @param {string} field - Specify the field.
     * @param {number} sheetIndex - Specify the index of the sheet.
     * @returns {void} - To clear the filter.
     */
    clearFilter(field, sheetIndex) {
        this.notify(clearFilter, { field: field, sheetIndex: sheetIndex });
    }
    /**
     * Applies the filter UI in the range of cells in the sheet.
     *
     * {% codeBlock src='spreadsheet/applyFilter/index.md' %}{% endcodeBlock %}
     *
     * @param {PredicateModel[]} predicates - Specifies the predicates.
     * @param {string} range - Specify the range.
     * @returns {Promise<void>} - to apply the filter.
     */
    applyFilter(predicates, range) {
        if (!this.allowFiltering) {
            return Promise.reject();
        }
        const promise = new Promise((resolve) => { resolve((() => { })()); });
        if (predicates && predicates.length) {
            let eventArgs;
            predicates.forEach((predicate) => {
                eventArgs = { instance: { options: { type: predicate.type, format: predicate.type === 'date' && 'yMd' } },
                    arg3: predicate.value, arg2: predicate.operator };
                this.notify(fltrPrevent, eventArgs);
                predicate.value = eventArgs.arg3;
            });
        }
        const sheetIdx = range ? getSheetIndexFromAddress(this, range) : this.activeSheetIndex;
        const filterArgs = { predicates: predicates, range: range, isInternal: true, promise: promise, sIdx: sheetIdx };
        this.notify(initiateFilterUI, filterArgs);
        return filterArgs.promise;
    }
    /**
     * To add custom library function.
     *
     *  {% codeBlock src='spreadsheet/addCustomFunction/index.md' %}{% endcodeBlock %}
     *
     * @param {string} functionHandler - Custom function handler name
     * @param {string} functionName - Custom function name
     * @param  {string} formulaDescription - Specifies formula description.
     * @returns {void} - To add custom function.
     */
    addCustomFunction(functionHandler, functionName, formulaDescription) {
        super.addCustomFunction(functionHandler, functionName, formulaDescription);
        this.notify(refreshFormulaDatasource, null);
    }
    /**
     * Sets or releases the read-only status for a specified range in the given sheet.
     *
     * @param {boolean} readOnly - A boolean indicating whether the range should be set as read-only (true) or editable (false).
     * @param {string} range - The range to be set as read-only. It can be a single cell, a range of cells (e.g., "A1:B5"), a column (e.g., "C"), or a row (e.g., "10").
     * @param {number} sheetIndex - The index of the sheet where the range is located. If not provided, it defaults to the active sheet index.
     * @returns {void} - Sets the read-only status for a specified range in the given sheet.
     *
     */
    setRangeReadOnly(readOnly, range, sheetIndex) {
        range = range || this.getActiveSheet().selectedRange;
        const sheetIdx = sheetIndex || this.activeSheetIndex;
        const indexes = getSwapRange(getRangeIndexes(range));
        const sheet = getSheet(this, sheetIdx);
        if (isNullOrUndefined(sheet)) {
            return;
        }
        this.notify('actionBegin', { action: 'readonly', eventArgs: { readOnly, range, sheetIdx } });
        if (isColumnRange(range) || (indexes[0] === 0 && indexes[2] === sheet.rowCount - 1)) {
            for (let col = indexes[1]; col <= indexes[3]; col++) {
                if (!readOnly) {
                    const column = getColumn(sheet, col);
                    if (column && column.isReadOnly) {
                        delete column.isReadOnly;
                    }
                }
                else {
                    setColumn(sheet, col, { isReadOnly: readOnly });
                }
            }
        }
        else if (isRowRange(range) || (indexes[1] === 0 && indexes[3] === sheet.colCount - 1)) {
            for (let row = indexes[0]; row <= indexes[2]; row++) {
                if (!readOnly) {
                    const rowValue = getRow(sheet, row);
                    if (rowValue && rowValue.isReadOnly) {
                        delete rowValue.isReadOnly;
                    }
                }
                else {
                    setRow(sheet, row, { isReadOnly: readOnly });
                }
            }
        }
        else {
            for (let colIdx = indexes[1]; colIdx <= indexes[3]; colIdx++) {
                for (let rowIdx = indexes[0]; rowIdx <= indexes[2]; rowIdx++) {
                    if (!readOnly) {
                        const cell = getCell(rowIdx, colIdx, sheet);
                        if (cell && cell.isReadOnly) {
                            delete cell.isReadOnly;
                        }
                    }
                    else {
                        setCell(rowIdx, colIdx, sheet, { isReadOnly: readOnly }, true);
                    }
                }
            }
        }
        // Added the e-readonly class to cell range/column for providing the customization option from sample end to the readonly mode cells.
        for (let colIndex = indexes[1]; colIndex <= indexes[3]; colIndex++) {
            for (let rowIndex = indexes[0]; rowIndex <= indexes[2]; rowIndex++) {
                const cell = this.getCell(rowIndex, colIndex);
                if (!readOnly && cell && cell.classList.contains('e-readonly')) {
                    cell.classList.remove('e-readonly');
                }
                else if (cell && !cell.classList.contains('e-readonly')) {
                    cell.className += ' e-readonly';
                }
            }
        }
        this.notify('actionComplete', { action: 'readonly', eventArgs: { readOnly, range, sheetIdx } });
    }
};
__decorate$9([
    Property('')
], Spreadsheet.prototype, "cssClass", void 0);
__decorate$9([
    Property(true)
], Spreadsheet.prototype, "allowScrolling", void 0);
__decorate$9([
    Property(true)
], Spreadsheet.prototype, "allowResizing", void 0);
__decorate$9([
    Property(true)
], Spreadsheet.prototype, "showAggregate", void 0);
__decorate$9([
    Property(true)
], Spreadsheet.prototype, "enableClipboard", void 0);
__decorate$9([
    Property(true)
], Spreadsheet.prototype, "enableContextMenu", void 0);
__decorate$9([
    Property(true)
], Spreadsheet.prototype, "enableKeyboardNavigation", void 0);
__decorate$9([
    Property(true)
], Spreadsheet.prototype, "enableKeyboardShortcut", void 0);
__decorate$9([
    Property(true)
], Spreadsheet.prototype, "allowUndoRedo", void 0);
__decorate$9([
    Property(true)
], Spreadsheet.prototype, "allowWrap", void 0);
__decorate$9([
    Complex({}, SelectionSettings)
], Spreadsheet.prototype, "selectionSettings", void 0);
__decorate$9([
    Complex({}, ScrollSettings)
], Spreadsheet.prototype, "scrollSettings", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "beforeCellRender", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "beforeSelect", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "select", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "contextMenuBeforeOpen", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "fileMenuBeforeOpen", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "contextMenuBeforeClose", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "dialogBeforeOpen", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "fileMenuBeforeClose", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "contextMenuItemSelect", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "fileMenuItemSelect", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "beforeDataBound", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "dataBound", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "dataSourceChanged", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "cellEdit", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "cellEditing", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "cellEdited", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "cellSave", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "beforeCellSave", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "created", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "beforeSort", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "beforeHyperlinkCreate", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "afterHyperlinkCreate", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "beforeHyperlinkClick", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "afterHyperlinkClick", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "beforeConditionalFormat", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "actionBegin", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "actionComplete", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "openComplete", void 0);
__decorate$9([
    Event$1()
], Spreadsheet.prototype, "sortComplete", void 0);
__decorate$9([
    Property('USD')
], Spreadsheet.prototype, "currencyCode", void 0);
Spreadsheet = Spreadsheet_1 = __decorate$9([
    NotifyPropertyChanges
], Spreadsheet);

export { AutoFill, AutoFillSettings, Axis, BasicFormulas, Border, CalcSheetFamilyItem, Calculate, CalculateCommon, Cell, CellFormat, CellRenderer, CellStyle, Chart, Clipboard, Column, CommonErrors, ConditionalFormat, ConditionalFormatting, ContextMenu, DISABLED, DataBind, DataLabelSettings, DataValidation, DefineName, Delete, Edit, ExcelFileFormats, Filter, FilterCollection, FindAndReplace, Format, Formula, FormulaBar, FormulaError, FormulaInfo, FormulasErrorsStrings, Hyperlink, Image$1 as Image, Insert, KeyboardNavigation, KeyboardShortcut, LegendSettings, MajorGridLines, MarkerSettings, Merge, MinorGridLines, NumberFormat, Open, OpenSettings, Parser, ProtectSettings, ProtectSheet, Range, Render, Resize, Ribbon$1 as Ribbon, Row, RowRenderer, Save, Scroll, ScrollSettings, Selection, SelectionSettings, Sheet, SheetRender, SheetTabs, ShowHide, Sort, SortCollection, Spreadsheet, SpreadsheetChart, SpreadsheetHyperlink, SpreadsheetImage, SpreadsheetNote, UndoRedo, UsedRange, Validation, ValueChangedArgs, VirtualScroll, WRAPTEXT, Workbook, WorkbookAutoFill, WorkbookCellFormat, WorkbookChart, WorkbookConditionalFormat, WorkbookDataValidation, WorkbookDelete, WorkbookEdit, WorkbookFilter, WorkbookFindAndReplace, WorkbookFormula, WorkbookHyperlink, WorkbookImage, WorkbookInsert, WorkbookMerge, WorkbookNumberFormat, WorkbookOpen, WorkbookProtectSheet, WorkbookSave, WorkbookSort, WrapText, actionEvents, activeCellChanged, activeCellMergedRange, activeSheetChanged, addChartEle, addContextMenuItems, addDPRValue, addFileMenuItems, addHighlight, addHyperlink, addListValidationDropdown, addNote, addRibbonTabs, addToolbarItems, addressHandle, afterHyperlinkClick, afterHyperlinkCreate, aggregateComputation, applyCF, applyCellFormat, applyLockCells, applyMerge, applyNumberFormatting, applyPredicates, applyProtect, applySort, autoFill, autoFit, beforeCellUpdate, beforeCheckboxRender, beforeContentLoaded, beforeDataBound, beforeDelete, beforeFilter, beforeHyperlinkClick, beforeHyperlinkCreate, beforeInsert, beforeRibbonCreate, beforeSort, beforeVirtualContentLoaded, beginAction, beginSave, cMenuBeforeOpen, calculateFormula, cellNavigate, cellValidation, chartDesignTab, chartRangeSelection, checkColumnValidation, checkDateFormat, checkFormulaRef, checkIsFormula, checkMerge, checkNumberFormat, checkPrevMerge, checkRange, checkUniqueRange, clear, clearAllFilter, clearCF, clearCFRule, clearCellRef, clearChartBorder, clearCopy, clearFilter, clearFormulaDependentCells, clearInvalid, clearRange, clearUndoRedoCollection, clearViewer, click, colWidthChanged, collaborativeUpdate, columnIndex, commputeFormulaValue, completeAction, configureLocalizedFormat, contentLoaded, contextMenuOpen, convertToDefaultFormat, copy, count, createHyperlinkElement, createImageElement, createNoteIndicator, created, cut, dataBound, dataChanged, dataSourceChanged, dataValidate, dateToInt, deInitProperties, defaultLocale, deleteAction, deleteChart, deleteChartColl, deleteFormatRange, deleteHyperlink, deleteImage, deleteModel, deleteNote, destroyComponent, dialog, duplicateSheet, duplicateSheetFilterHandler, editAlert, editHyperlink, editNote, editOperation, editValue, enableContextMenuItems, enableFileMenuItems, enableFormulaInput, enableRibbonTabs, enableToolbarItems, evaluate, executeTaskAsync, exportDialog, fillColor, filterByCellValue, filterCellKeyDown, filterComplete, filterRangeAlert, find, findAllValues, findCount, findDlg, findHandler, findKeyUp, findMaxValue, findToolDlg, findWorkbookHandler, finiteAlert, focus, focusBorder, focusChartBorder, focusRenameInput, fontColor, forRefSelRender, formulaBar, formulaBarOperation, formulaBarUpdate, formulaInValidation, formulaKeyUp, formulaOperation, freeze, getAddressFromSelectedRange, getAddressInfo, getAlphalabel, getAutoDetectFormatParser, getBeforeActionData, getBorderHeight, getBorderWidth, getBottomOffset, getCell, getCellAddress, getCellIndexes, getCellPosition, getCellRefValue, getChartColIdxFromClientX, getChartRowIdxFromClientY, getChartsIndexes, getClientX, getClientY, getColGroupWidth, getColIdxFromClientX, getColIndex, getColorCode, getColumn, getColumnHeaderText, getColumnWidth, getColumnsWidth, getCustomColors, getDPRValue, getData, getDataRange, getEndEvent, getExcludedColumnWidth, getFillInfo, getFilterRange, getFilteredColumn, getFormatFromType, getFormattedBarText, getFormattedCellObject, getGcd, getIndexesFromAddress, getLeadingSpaces, getLineHeight, getLines, getMaxHgt, getMaxSheetId, getModel, getMoveEvent, getPageX, getPageY, getRangeAddress, getRangeFromAddress, getRangeIndexes, getRequiredModules, getRightIdx, getRow, getRowHeight, getRowIdxFromClientY, getRowsHeight, getScrollBarWidth, getSelectedRange, getSheet, getSheetIndex, getSheetIndexByName, getSheetIndexFromAddress, getSheetIndexFromId, getSheetName, getSheetNameCount, getSheetNameFromAddress, getSheetProperties, getSiblingsHeight, getSingleSelectedRange, getSkeletonVal, getSplittedAddressForColumn, getStandardHeight, getStartEvent, getSwapRange, getTextHeight, getTextHeightWithBorder, getTextSpace, getTextWidth, getTrailingSpaces, getTypeFromFormat, getUniqueRange, getUpdateUsingRaf, getUpdatedFormula, getUpdatedFormulaOnInsertDelete, getUpdatedRange, getUpdatedScrollPosition, getValueFromFormat, getViewportIndexes, getWorkbookRequiredModules, getautofillDDB, goToSheet, goto, gotoDlg, hasTemplate, hiddenMerge, hideAutoFillElement, hideAutoFillOptions, hideFileMenuItems, hideRibbonTabs, hideSheet, hideShow, hideToolbarItems, importProtectWorkbook, inRange, inView, initSheet, initiateChart, initiateChartModel, initiateCur, initiateCustomSort, initiateDataValidation, initiateEdit, initiateFilter, initiateFilterUI, initiateFormulaReference, initiateHyperlink, initiateSort, initiatelink, insert, insertChart, insertDesignChart, insertFormatRange, insertImage, insertMerge, insertModel, insertSheetTab, intToDate, invalidData, isCellReference, isChar, isColumnRange, isColumnSelected, isCustomDateTime, isDateTime, isDiscontinuousRange, isExternalFileLink, isFilterHidden, isFormulaBarEdit, isHeightCheckNeeded, isHiddenCol, isHiddenRow, isImported, isInMultipleRange, isInRange, isLocked, isLockedCells, isMouseDown, isMouseMove, isMouseUp, isNavigationKey, isNumber, isReadOnly, isReadOnlyCells, isRowRange, isRowSelected, isSingleCell, isTouchEnd, isTouchMove, isTouchStart, isUndefined, isValidCellReference, isValidation, keyCodes, keyDown, keyUp, locale, localeData, localizedFormatAction, locateElem, mergedRange, mouseDown, mouseUpAfterSelection, moveOrDuplicateSheet, moveSheet, moveSheetHandler, onContentScroll, onHorizontalScroll, onSave, onVerticalScroll, openFailure, openHyperlink, openSuccess, overlay, overlayEleSize, parseDecimalNumber, parseFormulaArgument, parseIntValue, parseLocaleNumber, paste, performAutoFill, performUndoRedo, positionAutoFillElement, processIdx, propertyChange, protectCellFormat, protectSelection, protectSheet, protectSheetWorkBook, protectWorkbook, protectsheetHandler, queryCellInfo, rangeSelectionByKeydown, reApplyFormula, readonlyAlert, reapplyFilter, refreshCell, refreshCellElement, refreshChart, refreshChartCellModel, refreshChartCellObj, refreshChartCellOnInit, refreshChartSize, refreshCheckbox, refreshClipboard, refreshFilterCellsOnResize, refreshFilterRange, refreshFormulaDatasource, refreshImagePosition, refreshImgCellObj, refreshInsertDelete, refreshOverlayElem, refreshRibbon, refreshRibbonIcons, refreshSheetTabs, removeAllChildren, removeContextMenuItems, removeDataValidation, removeDesignChart, removeElements, removeHighlight, removeHyperlink, removeNoteContainer, removeRangeEle, removeSheetTab, removeUniquecol, removeWorkbookProtection, renameSheetTab, renderCFDlg, renderFilterCell, renderInsertDlg, replace, replaceAll, replaceAllDialog, ribbon, ribbonClick, rowFillHandler, rowHeightChanged, saveCompleted, saveError, selectAutoFillRange, selectRange, selectionComplete, selectionStatus, setActionData, setAriaOptions, setAutoFill, setAutoFit, setCFRule, setCell, setCellFormat, setChart, setColMinWidth, setColumn, setFilteredCollection, setImage, setLinkModel, setLockCells, setMaxHgt, setMerge, setPosition, setProtectWorkbook, setResize, setRow, setRowEleHeight, setRowHeight, setStandardHeight, setStyleAttribute, setTextLineHeight, setUndoRedo, setVisibleMergeIndex, setWidthAndHeight, sheetCreated, sheetNameUpdate, sheetRenameUpdate, sheetTabs, sheetsDestroyed, showAggregate, showFindAlert, showNote, showSheet, skipDefaultValue, skipHiddenIdx, sortComplete, sortImport, sortRangeAlert, spreadsheetCreated, spreadsheetDestroyed, startEdit, tabSwitch, textDecorationUpdate, toDate, toFraction, toggleProtect, triggerDataChange, unMerge, unProtectSheetPassword, unProtectWorkbook, undoRedoForChartDesign, unprotectSheet, unprotectsheetHandler, updateAction, updateCFModel, updateCell, updateHighlight, updateMergeBorder, updateNoteContainer, updateRowColCount, updateScroll, updateScrollValue, updateSelectedRange, updateSheetFromDataSource, updateSortCollection, updateSortedDataOnCell, updateTableWidth, updateToggle, updateToggleItem, updateTranslate, updateUndoRedoCollection, updateUsedRange, updateView, updateWrapCell, validationError, virtualContentLoaded, workBookeditAlert, workbookDestroyed, workbookEditOperation, workbookFormulaOperation, workbookLocale, workbookOpen, workbookReadonlyAlert, wrap, wrapEvent };
//# sourceMappingURL=ej2-spreadsheet.es2015.js.map
