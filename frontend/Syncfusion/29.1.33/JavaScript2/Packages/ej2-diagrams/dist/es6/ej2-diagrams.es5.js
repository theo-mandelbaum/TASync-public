import { Property, ChildProperty, Collection, ComplexFactory, initializeCSPTemplate, Complex, isBlazor, compile, CollectionFactory, Component, Browser, EventHandler, Event, isNullOrUndefined, createElement, getValue, remove, L10n, Fetch, Droppable, Draggable } from '@syncfusion/ej2-base';
import { Tooltip } from '@syncfusion/ej2-popups';
import { DataManager, Query } from '@syncfusion/ej2-data';
import { ContextMenu, Accordion } from '@syncfusion/ej2-navigations';

/**
 * Size defines and processes the size(width/height) of the objects
 */
var Size = /** @class */ (function () {
    function Size(width, height) {
        this.width = width;
        this.height = height;
    }
    /**
     * isEmpty method \
     *
     * @returns { boolean } isEmpty method .\
     *
     * @private
     */
    Size.prototype.isEmpty = function () {
        return this.height === 0 && this.width === 0;
    };
    // public static get empty(): Size {
    //     return new Size();
    // }
    // public get isEmpty(): boolean {
    //     return this.equals(Size.empty);
    // }
    // public equals(size2: Size): boolean {
    //     return this.width === size2.width && this.height === size2.height;
    // }
    // public union(size: Size): void {
    //     size.width = Math.max(size.width, this.width);
    //     size.height = Math.max(size.height, this.height);
    // }
    /**
     * clone method \
     *
     * @returns { Size } clone method .\
     *
     * @private
     */
    Size.prototype.clone = function () {
        return new Size(this.width, this.height);
    };
    return Size;
}());

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Defines and processes coordinates
 */
var Point = /** @class */ (function (_super) {
    __extends(Point, _super);
    function Point() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * equals method \
     *
     * @returns { boolean } equals method .\
     * @param {PointModel} point1 - provide the point1 value.
     * @param {PointModel} point2 - provide the point1 value.
     *
     * @private
     */
    Point.equals = function (point1, point2) {
        if (point1 === point2) {
            return true;
        }
        if (!point1 || !point2) {
            return false;
        }
        return !point1 || !point2 || point1.x === point2.x && point1.y === point2.y;
    };
    /**
     * isEmptyPoint method \
     *
     * @returns { boolean } isEmptyPoint method .\
     * @param {PointModel} point - provide the points value.
     *
     * @private
     */
    Point.isEmptyPoint = function (point) {
        if (point.x && point.y) {
            return false;
        }
        return true;
    };
    // public add(point1: PointModel, point2: PointModel): PointModel {
    //     return { x: point1.x + point2.x, y: point1.y + point2.y };
    // }
    // public subtract(point1: PointModel, point2: PointModel): PointModel {
    //     return { x: point1.x - point2.x, y: point1.y - point2.y };
    // }
    // public multiply(point1: PointModel, point2: PointModel): PointModel {
    //     return {
    //         x: point1.x * point2.x, y: point1.y * point2.y
    //     };
    // }
    // public crossProduct(point1: PointModel, point2: PointModel): PointModel {
    //     return {
    //         x: point1.x * point2.y, y: point2.x * point1.y
    //     };
    // }
    // public offset(offsetX: number, offsetY: number): void {
    //     this.x += offsetX;
    //     this.y += offsetY;
    // }
    // public rotate(angle: number): PointModel {
    //     let c: number = Math.cos(angle);
    //     let s: number = Math.sin(angle);
    //     return {
    //         x: c * this.x - s * this.y, y: s * this.x + c * this.y
    //     };
    // }
    // public distance(point2: PointModel): number {
    //     return Math.sqrt(Math.pow(this.x - point2.x, 2) + Math.pow(this.y - point2.y, 2));
    // }
    /**
     * transform method \
     *
     * @returns { PointModel } transform method .\
     * @param {PointModel} point - provide the points value.
     * @param {number} angle - provide the points value.
     * @param {number} length - provide the points value.
     *
     * @private
     */
    Point.transform = function (point, angle, length) {
        var pt = { x: 0, y: 0 };
        pt.x = Math.round((point.x + length * Math.cos(angle * Math.PI / 180)) * 100) / 100;
        pt.y = Math.round((point.y + length * Math.sin(angle * Math.PI / 180)) * 100) / 100;
        return pt;
    };
    /**
     * findLength method \
     *
     * @returns { number } findLength method .\
     * @param {PointModel} s - provide the points value.
     * @param {PointModel} e - provide the points value.
     *
     * @private
     */
    Point.findLength = function (s, e) {
        var length = Math.sqrt(Math.pow((s.x - e.x), 2) + Math.pow((s.y - e.y), 2));
        return length;
    };
    /**
     * findAngle method \
     *
     * @returns { number } findAngle method .\
     * @param {PointModel} point1 - provide the points value.
     * @param {PointModel} point2 - provide the points value.
     *
     * @private
     */
    Point.findAngle = function (point1, point2) {
        var angle = Math.atan2(point2.y - point1.y, point2.x - point1.x);
        angle = (180 * angle / Math.PI);
        angle %= 360;
        if (angle < 0) {
            angle += 360;
        }
        return angle;
    };
    /**
     * distancePoints method \
     *
     * @returns { number } distancePoints method .\
     * @param {PointModel} pt1 - provide the points value.
     * @param {PointModel} pt2 - provide the points value.
     *
     * @private
     */
    Point.distancePoints = function (pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
    };
    /**
     * getLengthFromListOfPoints method \
     *
     * @returns { number } getLengthFromListOfPoints method .\
     * @param {PointModel[]} points - provide the points value.
     *
     * @private
     */
    Point.getLengthFromListOfPoints = function (points) {
        var length = 0;
        for (var j = 0; j < points.length - 1; j++) {
            length += this.distancePoints(points[parseInt(j.toString(), 10)], points[j + 1]);
        }
        return length;
    };
    /**
     * adjustPoint method \
     *
     * @returns { PointModel } adjustPoint method .\
     * @param {PointModel} source - provide the points value.
     * @param {PointModel} target - provide the points value.
     * @param {boolean} isStart - provide the isStart value.
     * @param {number} length - provide the length value.
     *
     * @private
     */
    Point.adjustPoint = function (source, target, isStart, length) {
        var pt = isStart ? { x: source.x, y: source.y } : { x: target.x, y: target.y };
        var angle;
        if (source.x === target.x) {
            if (source.y < target.y && isStart || source.y > target.y && !isStart) {
                pt.y += length;
            }
            else {
                pt.y -= length;
            }
        }
        else if (source.y === target.y) {
            if (source.x < target.x && isStart || source.x > target.x && !isStart) {
                pt.x += length;
            }
            else {
                pt.x -= length;
            }
        }
        else {
            if (isStart) {
                angle = this.findAngle(source, target);
                pt = this.transform(source, angle, length);
            }
            else {
                angle = this.findAngle(target, source);
                pt = this.transform(target, angle, length);
            }
        }
        return pt;
    };
    /**
     * direction method \
     *
     * @returns { string } direction method .\
     * @param {PointModel} pt1 - provide the points value.
     * @param {PointModel} pt2 - provide the points value.
     *
     * @private
     */
    Point.direction = function (pt1, pt2) {
        if (Math.abs(pt2.x - pt1.x) > Math.abs(pt2.y - pt1.y)) {
            return pt1.x < pt2.x ? 'Right' : 'Left';
        }
        else {
            return pt1.y < pt2.y ? 'Bottom' : 'Top';
        }
    };
    //Move these methods to util
    //public CompareTo(point: PointModel): number {
    //    let result: number = this.X.CompareTo(point.X);
    //    return result != 0 ? result : this.Y.CompareTo(point.Y);
    //}
    //public CompareOnYAxis(point: PointModel): number {
    //    let result: number = this.X.CompareTo(point.X);
    //    return result != 0 ? result : this.Y.CompareTo(point.Y);
    //}
    //public CompareOnXAxis(point: PointModel): number {
    //    let result: number = this.Y.CompareTo(point.Y);
    //    return result != 0 ? result : this.X.CompareTo(point.X);
    //}
    // public round(): void {
    //     this.x = Math.round(this.x);
    //     this.y = Math.round(this.y);
    // }
    /**
     * getClassName method \
     *
     * @returns { string } getClassName method .\
     *
     * @private
     */
    Point.prototype.getClassName = function () {
        return 'Point';
    };
    __decorate([
        Property(0)
    ], Point.prototype, "x", void 0);
    __decorate([
        Property(0)
    ], Point.prototype, "y", void 0);
    return Point;
}(ChildProperty));

/**
 * These utility methods help to process the data and to convert it to desired dimensions
 */
/**
 * processPathData method \
 *
 * @returns {Object[]} processPathData method .\
 * @param { string } data - provide the data  value.
 * @private
 */
function processPathData(data) {
    var collection = [];
    var j;
    var arrayCollection = parsePathData(data);
    if (arrayCollection.length > 0) {
        for (var i = 0; i < arrayCollection.length; i++) {
            var ob = arrayCollection[parseInt(i.toString(), 10)];
            var char = '';
            char = ob[0];
            switch (char.toLowerCase()) {
                case 'm':
                    for (j = 1; j < ob.length; j++) {
                        collection.push({ command: char, x: ob[parseInt(j.toString(), 10)], y: ob[j + 1] });
                        j = j + 1;
                        if (char === 'm') {
                            char = 'l';
                        }
                        else if (char === 'M') {
                            char = 'L';
                        }
                    }
                    break;
                case 'l':
                case 't':
                    for (j = 1; j < ob.length; j++) {
                        collection.push({ command: char, x: ob[parseInt(j.toString(), 10)], y: ob[j + 1] });
                        j = j + 1;
                    }
                    break;
                case 'h':
                    for (j = 1; j < ob.length; j++) {
                        collection.push({ command: char, x: ob[parseInt(j.toString(), 10)] });
                    }
                    break;
                case 'v':
                    for (j = 1; j < ob.length; j++) {
                        collection.push({ command: char, y: ob[parseInt(j.toString(), 10)] });
                    }
                    break;
                case 'z':
                    collection.push({ command: char });
                    break;
                case 'c':
                    for (j = 1; j < ob.length; j++) {
                        collection.push({
                            command: char, x1: ob[parseInt(j.toString(), 10)], y1: ob[j + 1], x2: ob[j + 2],
                            y2: ob[j + 3], x: ob[j + 4], y: ob[j + 5]
                        });
                        j = j + 5;
                    }
                    break;
                case 's':
                    for (j = 1; j < ob.length; j++) {
                        collection.push({ command: char, x2: ob[parseInt(j.toString(), 10)], y2: ob[j + 1], x: ob[j + 2], y: ob[j + 3] });
                        j = j + 3;
                    }
                    break;
                case 'q':
                    for (j = 1; j < ob.length; j++) {
                        collection.push({ command: char, x1: ob[parseInt(j.toString(), 10)], y1: ob[j + 1], x: ob[j + 2], y: ob[j + 3] });
                        j = j + 3;
                    }
                    break;
                case 'a':
                    for (j = 1; j < ob.length; j++) {
                        collection.push({
                            command: char, r1: ob[parseInt(j.toString(), 10)], r2: ob[j + 1], angle: ob[j + 2], largeArc: ob[j + 3],
                            sweep: ob[j + 4], x: ob[j + 5], y: ob[j + 6]
                        });
                        j = j + 6;
                    }
                    break;
            }
        }
    }
    return collection;
}
/**
 * parsePathData method \
 *
 * @returns {Object[]} parsePathData method .\
 * @param { string } data - provide the data  value.
 * @private
 */
function parsePathData(data) {
    var tokenizer = /([a-z]+)|([+-]?(?:\d+\.?\d*|\.\d+))/gi;
    var current = [];
    var commands = [];
    var match = {};
    tokenizer.lastIndex = 0;
    var isExponential = false;
    match = tokenizer.exec(data);
    while (match) {
        if (match[1] === 'e') {
            //let s1: string = '';
            isExponential = true;
        }
        else if (match[1]) {
            if (match[1].toLowerCase() === 'zm') {
                if (current.length) {
                    commands.push(current);
                }
                commands.push(['Z']);
                current = [match[1].substring(1, 2)];
            }
            else {
                if (current.length) {
                    commands.push(current);
                }
                current = [match[1]];
            }
            isExponential = false;
        }
        else {
            if (!current.length) {
                current = [];
            }
            if (!isExponential) {
                current.push(Number(match[2]));
            }
            isExponential = false;
        }
        match = tokenizer.exec(data);
    }
    if (current.length) {
        commands.push(current);
    }
    return commands;
}
/**
 * getRectanglePath method \
 *
 * @returns {string} getRectanglePath method .\
 * @param { number } cornerRadius - provide the data  value.
 * @param { number } height - provide the height  value.
 * @param { number } width - provide the width  value.
 * @private
 */
function getRectanglePath(cornerRadius, height, width) {
    var x = 0;
    var y = 0;
    var path = '';
    var points = [{ x: x + cornerRadius, y: y }, { x: x + width - cornerRadius, y: y },
        { x: x + width, y: y + cornerRadius }, { x: x + width, y: y + height - cornerRadius },
        { x: x + width - cornerRadius, y: y + height }, { x: x + cornerRadius, y: y + height },
        { x: x, y: y + height - cornerRadius }, { x: x, y: y + cornerRadius }
    ];
    var corners = [{ x: x + width, y: y }, { x: x + width, y: y + height }, { x: x, y: y + height }, { x: x, y: y }];
    var corner = 0;
    var point2;
    var next;
    path = 'M' + points[0].x + ' ' + points[0].y;
    var i;
    for (i = 0; i < points.length; i = i + 2) {
        point2 = points[i + 1];
        path += 'L' + point2.x + ' ' + point2.y;
        next = points[i + 2] || points[0];
        path += 'Q' + corners[parseInt(corner.toString(), 10)].x + ' ' + corners[parseInt(corner.toString(), 10)].y + ' ' + next.x + ' ' + next.y;
        corner++;
    }
    return path;
}
/**
 * getPolygonPath method \
 *
 * @returns {string} getPolygonPath method .\
 * @param { PointModel[] } collection - provide the data  value.
 * @private
 */
function getPolygonPath(collection) {
    var path = '';
    var seg;
    path = 'M' + collection[0].x + ' ' + collection[0].y;
    var i;
    for (i = 1; i < collection.length; i++) {
        seg = collection[parseInt(i.toString(), 10)];
        path += 'L' + seg.x + ' ' + seg.y;
    }
    path += 'Z';
    return path;
}
/**
 * getFreeHandPath method \
 *
 * @returns {string} getFreeHandPath method .\
 * @param { PointModel[] } collection - provide the data  value.
 * @private
 */
function getFreeHandPath(collection) {
    var k;
    for (k = 0; k < collection.length; k++) {
        collection[parseInt(k.toString(), 10)].x = Math.round(collection[parseInt(k.toString(), 10)].x);
        collection[parseInt(k.toString(), 10)].y = Math.round(collection[parseInt(k.toString(), 10)].y);
    }
    var path = '';
    var seg;
    path = 'M' + collection[0].x + ' ' + collection[0].y;
    var i;
    for (i = 1; i < collection.length; i++) {
        seg = collection[parseInt(i.toString(), 10)];
        path += 'L' + seg.x + ' ' + seg.y;
    }
    return path;
}
/* eslint-disable */
/**
 * pathSegmentCollection method \
 *
 * @returns {string} pathSegmentCollection method .\
 * @param { Object[]} collection - provide the collection  value.
 * @private
 */
function pathSegmentCollection(collection) {
    var x0;
    var y0;
    var x1;
    var y1;
    var x2;
    var y2;
    var x;
    var y;
    var length;
    var i;
    var segments = [];
    for (x = 0, y = 0, i = 0, length = collection.length; i < length; ++i) {
        var obj = collection[i];
        var seg = obj;
        var char = '';
        char = seg.command;
        if ('y1' in seg) {
            y1 = seg.y1;
        }
        if ('y2' in seg) {
            y2 = seg.y2;
        }
        if ('x1' in seg) {
            x1 = seg.x1;
        }
        if ('x2' in seg) {
            x2 = seg.x2;
        }
        if ('x' in seg) {
            x = seg.x;
        }
        if ('y' in seg) {
            y = seg.y;
        }
        var prev = segments[segments.length - 1];
        switch (char) {
            case 'M':
                segments.push({ command: 'M', x: x, y: y });
                break;
            case 'L':
                segments.push({ command: 'L', x0: x0, y0: y0, x: x, y: y });
                break;
            case 'H':
                segments.push({ command: 'L', x0: x0, y0: y0, x: x, y: y0 });
                break;
            case 'V':
                segments.push({ command: 'L', x0: x0, y0: y0, x: x0, y: y });
                break;
            case 'C':
                segments.push({ command: 'C', x0: x0, y0: y0, x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y });
                break;
            case 'S':
                if (prev) {
                    var ctrl = void 0;
                    if (prev.command === 'C' || prev.command === 'S') {
                        ctrl = { x: prev.x2, y: prev.y2 };
                    }
                    else {
                        ctrl = { x: x0, y: y0 };
                    }
                    var cpt2 = { x: 2 * x0 - ctrl.x, y: 2 * y0 - ctrl.y };
                    segments.push({ command: 'C', x0: x0, y0: y0, x1: cpt2.x, y1: cpt2.y, x2: x2, y2: y2, x: x, y: y });
                }
                break;
            case 'Q':
                //ctx.quadraticCurveTo(x1, y1, x, y);
                segments.push({ command: 'Q', x0: x0, y0: y0, x1: x1, y1: y1, x: x, y: y });
                break;
            case 'T':
                if (prev) {
                    var ctrl = void 0;
                    if (prev.command === 'Q') {
                        ctrl = { x: prev.x1, y: prev.y1 };
                    }
                    else {
                        ctrl = { x: x0, y: y0 };
                    }
                    var cpt2 = { x: 2 * x0 - ctrl.x, y: 2 * y0 - ctrl.y };
                    segments.push({ command: 'Q', x0: x0, y0: y0, x1: cpt2.x, y1: cpt2.y, x: x, y: y });
                }
                break;
            case 'A':
                var newSeg = seg;
                newSeg.command = 'A';
                segments.push(newSeg);
                break;
            case 'Z':
            case 'z':
                segments.push({ command: 'Z' });
                x = x0;
                y = y0;
                break;
        }
        x0 = x;
        y0 = y;
    }
    return segments;
}
/**
 * transformPath method \
 *
 * @returns {string} transformPath method .\
 * @param { Object[]} arr - provide the collection  value.
 * @param { number} sX - provide the collection  value.
 * @param { number} sY - provide the collection  value.
 * @param { boolean} s - provide the collection  value.
 * @param {number} bX - provide the collection  value.
 * @param { number} bY - provide the collection  value.
 * @param { number} iX - provide the collection  value.
 * @param { number} iY - provide the collection  value.
 * @private
 */
function transformPath(arr, sX, sY, s, bX, bY, iX, iY) {
    var x1;
    var y1;
    var x2;
    var y2;
    var x;
    var y;
    var length;
    var i;
    var newSeg;
    for (x = 0, y = 0, i = 0, length = arr.length; i < length; ++i) {
        var obj = arr[i];
        var seg = obj;
        var char = seg.command;
        if ('x' in seg) {
            x = seg.x;
        }
        if ('y' in seg) {
            y = seg.y;
        }
        if ('y1' in seg) {
            y1 = seg.y1;
        }
        if ('y2' in seg) {
            y2 = seg.y2;
        }
        if ('x1' in seg) {
            x1 = seg.x1;
        }
        if ('x2' in seg) {
            x2 = seg.x2;
        }
        if (s) {
            if (x !== undefined) {
                x = scalePathData(x, sX, bX, iX);
            }
            if (y !== undefined) {
                y = scalePathData(y, sY, bY, iY);
            }
            if (x1 !== undefined) {
                x1 = scalePathData(x1, sX, bX, iX);
            }
            if (y1 !== undefined) {
                y1 = scalePathData(y1, sY, bY, iY);
            }
            if (x2 !== undefined) {
                x2 = scalePathData(x2, sX, bX, iX);
            }
            if (y2 !== undefined) {
                y2 = scalePathData(y2, sY, bY, iY);
            }
        }
        else {
            if (x !== undefined) {
                x = Number((x + sX).toFixed(2));
            }
            if (y !== undefined) {
                y = Number((y + sY).toFixed(2));
            }
            if (x1 !== undefined) {
                x1 = Number((x1 + sX).toFixed(2));
            }
            if (y1 !== undefined) {
                y1 = Number((y1 + sY).toFixed(2));
            }
            if (x2 !== undefined) {
                x2 = Number((x2 + sX).toFixed(2));
            }
            if (y2 !== undefined) {
                y2 = Number((y2 + sY).toFixed(2));
            }
        }
        var scaledPath = { x: x, y: y, x1: x1, y1: y1, x2: x2, y2: y2, r1: seg.r1, r2: seg.r2 };
        newSeg = updatedSegment(seg, char, scaledPath, s, sX, sY);
        if (newSeg) {
            arr[i] = newSeg;
        }
    }
    var pathData = getPathString(arr);
    return pathData;
}
/**
 * updatedSegment method \
 *
 * @returns {string} updatedSegment method .\
 * @param { PathSegment} segment - provide the collection  value.
 * @param { PathSegment} char - provide the collection  value.
 * @param { number} obj - provide the collection  value.
 * @param { boolean} isScale - provide the collection  value.
 * @param {number} sX - provide the collection  value.
 * @param { number} sY - provide the collection  value.
 * @private
 */
function updatedSegment(segment, char, obj, isScale, sX, sY) {
    switch (char) {
        case 'M':
            segment.x = obj.x;
            segment.y = obj.y;
            break;
        case 'L':
            segment.x = obj.x;
            segment.y = obj.y;
            break;
        case 'H':
            segment.x = obj.x;
            break;
        case 'V':
            segment.y = obj.y;
            break;
        case 'C':
            segment.x = obj.x;
            segment.y = obj.y;
            segment.x1 = obj.x1;
            segment.y1 = obj.y1;
            segment.x2 = obj.x2;
            segment.y2 = obj.y2;
            break;
        case 'S':
            segment.x = obj.x;
            segment.y = obj.y;
            segment.x2 = obj.x2;
            segment.y2 = obj.y2;
            break;
        case 'Q':
            segment.x = obj.x;
            segment.y = obj.y;
            segment.x1 = obj.x1;
            segment.y1 = obj.y1;
            break;
        case 'T':
            segment.x = obj.x;
            segment.y = obj.y;
            break;
        case 'A':
            var r1 = obj.r1;
            var r2 = obj.r2;
            if (isScale) {
                obj.r1 = r1 = (r1 * sX);
                obj.r2 = r2 = (r2 * sY);
            }
            segment.x = obj.x;
            segment.y = obj.y;
            segment.r1 = obj.r1;
            segment.r2 = obj.r2;
            break;
        case 'z':
        case 'Z':
            segment = { command: 'Z' };
            break;
    }
    return segment;
}
/* eslint-enable */
/**
 * scalePathData method \
 *
 * @returns {string} scalePathData method .\
 * @param { number} val - provide the val  value.
 * @param { number} scaleFactor - provide the scaleFactor  value.
 * @param { number} oldOffset - provide the oldOffset  value.
 * @param { number} newOffset - provide the newOffset  value.
 * @private
 */
function scalePathData(val, scaleFactor, oldOffset, newOffset) {
    if (val !== oldOffset) {
        if (newOffset !== oldOffset) {
            val = (((val * scaleFactor) - (Number(oldOffset) * scaleFactor - Number(oldOffset)))
                + (newOffset - Number(oldOffset)));
        }
        else {
            val = ((Number(val) * scaleFactor) - (Number(oldOffset) * scaleFactor - Number(oldOffset)));
        }
    }
    else {
        if (newOffset !== oldOffset) {
            val = newOffset;
        }
    }
    return Number(val.toFixed(2));
}
/**
 * splitArrayCollection method \
 *
 * @returns {Object[]} splitArrayCollection method .\
 * @param { Object[]} arrayCollection - provide the val  value.
 * @private
 */
function splitArrayCollection(arrayCollection) {
    var x0;
    var y0;
    var x1;
    var y1;
    var x2;
    var y2;
    var x;
    var y;
    var length;
    var i;
    for (x = 0, y = 0, i = 0, length = arrayCollection.length; i < length; ++i) {
        var path = arrayCollection[parseInt(i.toString(), 10)];
        var seg = path;
        var char = seg.command;
        if (/[MLHVCSQTA]/.test(char)) {
            if ('x' in seg) {
                seg.x = x = seg.x;
            }
            if ('y' in seg) {
                seg.y = y = seg.y;
            }
        }
        else {
            if ('x1' in seg) {
                seg.x1 = x1 = x + seg.x1;
            }
            if ('x2' in seg) {
                seg.x2 = x2 = x + seg.x2;
            }
            if ('y1' in seg) {
                seg.y1 = y1 = y + seg.y1;
            }
            if ('y2' in seg) {
                seg.y2 = y2 = y + seg.y2;
            }
            if ('x' in seg) {
                seg.x = x += seg.x;
            }
            if ('y' in seg) {
                seg.y = y += seg.y;
            }
            var newSeg = void 0;
            switch (char) {
                case 'm':
                case 'M':
                    newSeg = { command: 'M', x: x, y: y };
                    break;
                case 'l':
                case 'L':
                    newSeg = { command: 'L', x: x, y: y };
                    break;
                case 'h':
                case 'H':
                    newSeg = { command: 'H', x: x };
                    break;
                case 'v':
                case 'V':
                    newSeg = { command: 'V', y: y };
                    break;
                case 'c':
                case 'C':
                    newSeg = { command: 'C', x: x, y: y, x1: x1, y1: y1, x2: x2, y2: y2 };
                    break;
                case 's':
                case 'S':
                    newSeg = { command: 'S', x: x, y: y, x2: x2, y2: y2 };
                    break;
                case 'q':
                case 'Q':
                    newSeg = { command: 'Q', x: x, y: y, x1: x1, y1: y1 };
                    break;
                case 't':
                case 'T':
                    newSeg = { command: 'T', x: x, y: y };
                    break;
                case 'a':
                case 'A':
                    newSeg = { command: 'A', x: x, y: y };
                    newSeg.r1 = seg.r1;
                    newSeg.r2 = seg.r2;
                    newSeg.angle = seg.angle;
                    newSeg.largeArc = seg.largeArc;
                    newSeg.sweep = seg.sweep;
                    break;
                case 'z':
                case 'Z':
                    newSeg = { command: 'Z' };
                    x = x0;
                    y = y0;
                    newSeg = arrayCollection[parseInt(i.toString(), 10)];
                    break;
            }
            if (newSeg) {
                arrayCollection[parseInt(i.toString(), 10)] = newSeg;
            }
        }
        if (char === 'M' || char === 'm') {
            x0 = x;
            y0 = y;
        }
    }
    return arrayCollection;
}
/**
 * getPathString method \
 *
 * @returns {string} getPathString method .\
 * @param { Object[]} arrayCollection - provide the val  value.
 * @private
 */
function getPathString(arrayCollection) {
    var getNewString = '';
    var i;
    for (i = 0; i < arrayCollection.length; i++) {
        if (i === 0) {
            getNewString += getString(arrayCollection[parseInt(i.toString(), 10)]);
        }
        else {
            getNewString += ' ' + getString(arrayCollection[parseInt(i.toString(), 10)]);
        }
    }
    return getNewString;
}
/* eslint-disable */
/**
 * getString method \
 *
 * @returns {string} getString method .\
 * @param { PathSegment} arrayCollection - provide the val  value.
 * @private
 */
function getString(obj) {
    var string = '';
    switch (obj.command) {
        case 'Z':
        case 'z':
            string = obj.command;
            break;
        case 'M':
        case 'm':
        case 'L':
        case 'l':
            string = obj.command + ' ' + obj.x + ' ' + obj.y;
            break;
        case 'C':
        case 'c':
            string = obj.command + ' ' + obj.x1 + ' ' + obj.y1 + ' ' + obj.x2 + ' ' + obj.y2 + ' ' + obj.x + ' ' + obj.y;
            break;
        case 'Q':
        case 'q':
            string = obj.command + ' ' + obj.x1 + ' ' + obj.y1 + ' ' + obj.x + ' ' + obj.y;
            break;
        case 'A':
        case 'a':
            var cmd = obj.command;
            var ang = obj.angle;
            var l = (obj.largeArc ? '1' : '0');
            var s = (obj.sweep ? '1' : '0');
            string = cmd + ' ' + obj.r1 + ' ' + obj.r2 + ' ' + ang + ' ' + l + ' ' + s + ' ' + obj.x + ' ' + obj.y;
            break;
        case 'H':
        case 'h':
            string = obj.command + ' ' + obj.x;
            break;
        case 'V':
        case 'v':
            string = obj.command + ' ' + obj.y;
            break;
        case 'S':
        case 's':
            string = obj.command + ' ' + obj.x2 + ' ' + obj.y2 + ' ' + obj.x + ' ' + obj.y;
            break;
        case 'T':
        case 't':
            string = obj.command + ' ' + obj.x + ' ' + obj.y;
    }
    return string;
}

/**
 * Rect defines and processes rectangular regions
 */
var Rect = /** @class */ (function () {
    function Rect(x, y, width, height) {
        /**
         * Sets the x-coordinate of the starting point of a rectangular region
         *
         * @default 0
         */
        this.x = Number.MAX_VALUE;
        /**
         * Sets the y-coordinate of the starting point of a rectangular region
         *
         * @default 0
         */
        this.y = Number.MAX_VALUE;
        /**
         * Sets the width of a rectangular region
         *
         * @default 0
         */
        this.width = 0;
        /**
         * Sets the height of a rectangular region
         *
         * @default 0
         */
        this.height = 0;
        if (x === undefined || y === undefined) {
            x = y = Number.MAX_VALUE;
            width = height = 0;
        }
        else {
            if (width === undefined) {
                width = 0;
            }
            if (height === undefined) {
                height = 0;
            }
        }
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    Object.defineProperty(Rect.prototype, "left", {
        // eslint-disable-next-line jsdoc/require-returns
        /**   @private  */
        get: function () {
            return this.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "right", {
        /**
         * right method \
         *
         * @returns { Rect } right method .\
         *
         * @private
         */
        get: function () {
            return this.x + this.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "top", {
        /**
         * toBounds method \
         *
         * @returns { Rect } toBounds method .\
         *
         * @private
         */
        get: function () {
            return this.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "bottom", {
        /**
         * bottom method \
         *
         * @returns { Rect } bottom method .\
         *
         * @private
         */
        get: function () {
            return this.y + this.height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "topLeft", {
        /**
         * topLeft method \
         *
         * @returns { Rect } topLeft method .\
         *
         * @private
         */
        get: function () {
            return { x: this.left, y: this.top };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "topRight", {
        /**
         * topRight method \
         *
         * @returns { Rect } topRight method .\
         *
         * @private
         */
        get: function () {
            return { x: this.right, y: this.top };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "bottomLeft", {
        /**
         * bottomLeft method \
         *
         * @returns { Rect } bottomLeft method .\
         *
         * @private
         */
        get: function () {
            return { x: this.left, y: this.bottom };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "bottomRight", {
        /**
         * bottomRight method \
         *
         * @returns { Rect } bottomRight method .\
         *
         * @private
         */
        get: function () {
            return { x: this.right, y: this.bottom };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "middleLeft", {
        /**
         * middleLeft method \
         *
         * @returns { Rect } middleLeft method .\
         *
         * @private
         */
        get: function () {
            return { x: this.left, y: this.y + this.height / 2 };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "middleRight", {
        /**
         * middleRight method \
         *
         * @returns { Rect } middleRight method .\
         *
         * @private
         */
        get: function () {
            return { x: this.right, y: this.y + this.height / 2 };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "topCenter", {
        /**
         * topCenter method \
         *
         * @returns { Rect } topCenter method .\
         *
         * @private
         */
        get: function () {
            return { x: this.x + this.width / 2, y: this.top };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "bottomCenter", {
        /**
         * bottomCenter method \
         *
         * @returns { Rect } bottomCenter method .\
         *
         * @private
         */
        get: function () {
            return { x: this.x + this.width / 2, y: this.bottom };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "center", {
        /**
         * center method \
         *
         * @returns { PointModel } center method .\
         *
         * @private
         */
        get: function () {
            return { x: this.x + this.width / 2, y: this.y + this.height / 2 };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * equals method \
     *
     * @returns { boolean } equals method .\
     * @param {Rect} rect1 - provide the rect1 value.
     * @param {Rect} rect2 - provide the rect2 value.
     *
     * @private
     */
    Rect.prototype.equals = function (rect1, rect2) {
        return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;
    };
    /**
     * uniteRect method \
     *
     * @returns { Rect } uniteRect method .\
     * @param {Rect} rect - provide the points value.
     *
     * @private
     */
    Rect.prototype.uniteRect = function (rect) {
        var right = Math.max(isNaN(this.right) || this.x === Number.MAX_VALUE ? rect.right : this.right, rect.right);
        var bottom = Math.max(isNaN(this.bottom) || this.y === Number.MAX_VALUE ? rect.bottom : this.bottom, rect.bottom);
        this.x = Math.min(this.left, rect.left);
        this.y = Math.min(this.top, rect.top);
        this.width = right - this.x;
        this.height = bottom - this.y;
        return this;
    };
    /**
     * unitePoint method \
     *
     * @returns { void } unitePoint method .\
     * @param {PointModel} point - provide the points value.
     *
     * @private
     */
    Rect.prototype.unitePoint = function (point) {
        if (this.x === Number.MAX_VALUE) {
            this.x = point.x;
            this.y = point.y;
            return;
        }
        var x = Math.min(this.left, point.x);
        var y = Math.min(this.top, point.y);
        var right = Math.max(this.right, point.x);
        var bottom = Math.max(this.bottom, point.y);
        this.x = x;
        this.y = y;
        this.width = right - this.x;
        this.height = bottom - this.y;
    };
    // public intersection(rect: Rect): Rect {
    //     if (this.intersects(rect)) {
    //         let left: number = Math.max(this.left, rect.left);
    //         let top: number = Math.max(this.top, rect.top);
    //         let right: number = Math.min(this.right, rect.right);
    //         let bottom: number = Math.min(this.bottom, rect.bottom);
    //         return new Rect(left, top, right - left, bottom - top);
    //     }
    //     return Rect.empty;
    // }
    /**
     * Inflate method \
     *
     * @returns { Rect } Inflate method .\
     * @param {number} padding - provide the points value.
     *
     * @private
     */
    Rect.prototype.Inflate = function (padding) {
        this.x -= padding;
        this.y -= padding;
        this.width += padding * 2;
        this.height += padding * 2;
        return this;
    };
    //public Inflate(size: Size): Rect {
    //    this.x -= size.Width;
    //    this.y -= size.Height;
    //    this.width += size.Width * 2;
    //    this.height += size.Height * 2;
    //    return this;
    //}
    // public inflate(width: number, height: number): void {
    //     this.x -= width;
    //     this.y -= height;
    //     this.width += width * 2;
    //     this.height += height * 2;
    // }
    /**
     * intersects method \
     *
     * @returns { boolean } intersects method .\
     * @param {Rect} rect - provide the points value.
     *
     * @private
     */
    Rect.prototype.intersects = function (rect) {
        if (this.right < rect.left || this.left > rect.right || this.top > rect.bottom || this.bottom < rect.top) {
            return false;
        }
        return true;
    };
    /**
     * containsRect method \
     *
     * @returns { boolean } containsRect method .\
     * @param {Rect} rect - provide the points value.
     *
     * @private
     */
    Rect.prototype.containsRect = function (rect) {
        return this.left <= rect.left && this.right >= rect.right && this.top <= rect.top && this.bottom >= rect.bottom;
    };
    /**
     * containsPoint method \
     *
     * @returns { boolean } containsPoint method .\
     * @param {PointModel} point - provide the points value.
     * @param {number} padding - provide the padding value.
     *
     * @private
     */
    Rect.prototype.containsPoint = function (point, padding) {
        if (padding === void 0) { padding = 0; }
        return this.left - padding <= point.x && this.right + padding >= point.x
            && this.top - padding <= point.y && this.bottom + padding >= point.y;
    };
    // public toPoints(): PointModel[] {
    //     let points: PointModel[] = [];
    //     points.push(this.topLeft);
    //     points.push(this.topRight);
    //     points.push(this.bottomLeft);
    //     points.push(this.bottomRight);
    //     return points;
    // }
    /**
     * toBounds method \
     *
     * @returns { Rect } toBounds method .\
     * @param {PointModel[]} points - provide the points value.
     *
     * @private
     */
    Rect.toBounds = function (points) {
        var rect = new Rect();
        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
            var pt = points_1[_i];
            rect.unitePoint(pt);
        }
        return rect;
    };
    /**   @private  */
    Rect.empty = new Rect(Number.MAX_VALUE, Number.MIN_VALUE, 0, 0);
    return Rect;
}());

/**
 * Matrix module is used to transform points based on offsets, angle
 */
/** @private */
var MatrixTypes;
(function (MatrixTypes) {
    MatrixTypes[MatrixTypes["Identity"] = 0] = "Identity";
    MatrixTypes[MatrixTypes["Translation"] = 1] = "Translation";
    MatrixTypes[MatrixTypes["Scaling"] = 2] = "Scaling";
    MatrixTypes[MatrixTypes["Unknown"] = 4] = "Unknown";
})(MatrixTypes || (MatrixTypes = {}));
/** @private */
var Matrix = /** @class */ (function () {
    function Matrix(m11, m12, m21, m22, offsetX, offsetY, type) {
        this.m11 = m11;
        this.m12 = m12;
        this.m21 = m21;
        this.m22 = m22;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        // if (type === undefined) {
        //     this.type = MatrixTypes.Unknown;
        // } else {
        //     this.type = type;
        // }
        this.type = type;
    }
    return Matrix;
}());
/**
 * Will identify the  matrix .\
 *
 * @returns {Matrix}  Will identify the  matrix .
 * @private
 */
function identityMatrix() {
    return new Matrix(1, 0, 0, 1, 0, 0, MatrixTypes.Identity);
}
/**
 * Will transform the points by matrix .\
 *
 * @returns {PointModel[]}  Will transform the points by matrix .
 *
 * @param {Matrix} matrix - provide the matrix value  .
 * @param {number} point -  provide the points value.
 * @private
 */
function transformPointByMatrix(matrix, point) {
    var pt = multiplyPoint(matrix, point.x, point.y);
    return { x: Math.round(pt.x * 100) / 100, y: Math.round(pt.y * 100) / 100 };
}
/**
 * Will transform the points by matrix .\
 *
 * @returns {PointModel[]}  Will transform the points by matrix .
 *
 * @param {Matrix} matrix - provide the matrix value  .
 * @param {number} points -  provide the points value.
 * @private
 */
function transformPointsByMatrix(matrix, points) {
    var transformedPoints = [];
    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
        var point = points_1[_i];
        transformedPoints.push(transformPointByMatrix(matrix, point));
    }
    return transformedPoints;
}
/**
 * Will rotate the matrix .\
 *
 * @returns {void}  Will rotate the matrix .
 *
 * @param {Matrix} matrix - provide the matrix value  .
 * @param {number} angle - provide the angle value.
 * @param {number} centerX - provide the centerX value .
 * @param {number} centerY - provide the centerY value .
 * @private
 */
function rotateMatrix(matrix, angle, centerX, centerY) {
    angle %= 360.0;
    multiplyMatrix(matrix, createRotationRadians(angle * 0.017453292519943295, centerX ? centerX : 0, centerY ? centerY : 0));
}
/**
 * Will scale the matrix .\
 *
 * @returns {void} Will scale the matrix .
 *
 * @param {Matrix} matrix - provide the matrix value  .
 * @param {number} scaleX - provide the scaleXvalue.
 * @param {number} scaleY - provide the scaleY value .
 * @param {number} centerX - provide the centerX value .
 * @param {number} centerY - provide the centerY value .
 * @private
 */
function scaleMatrix(matrix, scaleX, scaleY, centerX, centerY) {
    if (centerX === void 0) { centerX = 0; }
    if (centerY === void 0) { centerY = 0; }
    multiplyMatrix(matrix, createScaling(scaleX, scaleY, centerX, centerY));
}
/**
 * Will translate the matrix .\
 *
 * @returns {void} Will translate the matrix .
 *
 * @param {Matrix} matrix - provide the matrix value  .
 * @param {number} offsetX - provide the offset x value.
 * @param {number} offsetY - provide the offset y value .
 * @private
 */
function translateMatrix(matrix, offsetX, offsetY) {
    //Removed identity and unknown matrix type checking
    matrix.offsetX += offsetX;
    matrix.offsetY += offsetY;
    matrix.type |= MatrixTypes.Translation;
}
/**
 * Will create scaling value .\
 *
 * @returns {Matrix} Will create scaling value . .
 *
 * @param {Matrix} scaleX - provide the scale x value  .
 * @param {number} scaleY - provide the scale y value.
 * @param {number} centerX - provide the centerX x value .
 * @param {number} centerY - provide the centerX y value .
 * @private
 */
function createScaling(scaleX, scaleY, centerX, centerY) {
    var result = identityMatrix();
    result.type = !(centerX || centerY) ? MatrixTypes.Scaling : MatrixTypes.Scaling | MatrixTypes.Translation;
    setMatrix(result, scaleX, 0.0, 0.0, scaleY, centerX - scaleX * centerX, centerY - scaleY * centerY);
    return result;
}
/**
 * Will create the rotation radians.\
 *
 * @returns {Matrix} Will create the rotation radians .
 *
 * @param {Matrix} angle - provide the angle  .
 * @param {number} centerX - provide the x value .
 * @param {number} centerY - provide the y value .
 * @private
 */
function createRotationRadians(angle, centerX, centerY) {
    var result = identityMatrix();
    var num = Math.sin(angle);
    var num2 = Math.cos(angle);
    var offsetX = centerX * (1.0 - num2) + centerY * num;
    var offsetY = centerY * (1.0 - num2) - centerX * num;
    result.type = MatrixTypes.Unknown;
    setMatrix(result, num2, num, -num, num2, offsetX, offsetY);
    return result;
}
/**
 * Multiply the point .\
 *
 * @returns {void} Multiply the point .
 *
 * @param {Matrix} matrix - Provide the matrix .
 * @param {number} x - provide the x value .
 * @param {number} y - provide the y value .
 * @private
 */
function multiplyPoint(matrix, x, y) {
    switch (matrix.type) {
        //Removed identity and translation and scaling matrix type checking
        case MatrixTypes.Translation | MatrixTypes.Scaling:
            x *= matrix.m11;
            x += matrix.offsetX;
            y *= matrix.m22;
            y += matrix.offsetY;
            break;
        default:
            // eslint-disable-next-line no-case-declarations
            var num = y * matrix.m21 + matrix.offsetX;
            // eslint-disable-next-line no-case-declarations
            var num2 = x * matrix.m12 + matrix.offsetY;
            x *= matrix.m11;
            x += num;
            y *= matrix.m22;
            y += num2;
            break;
    }
    return { x: x, y: y };
}
/**
 * Will multiply the matrix .\
 *
 * @returns {void} Will multiply the matrix .
 *
 * @param {Matrix} matrix1 - Provide the matrix 1 value .
 * @param {Matrix} matrix2 - Provide the matrix 2 value .
 * @private
 */
function multiplyMatrix(matrix1, matrix2) {
    var type = matrix1.type;
    var type2 = matrix2.type;
    //Removed identity matrix type checking
    if (type === MatrixTypes.Identity) {
        assignMatrix(matrix1, matrix2);
        matrix1.type = matrix2.type;
        return;
    }
    //Removed translation matrix type checking
    if (type !== MatrixTypes.Translation) {
        var num = type << 4 | type2;
        //Removed num 34,35,36
        switch (num) {
            case 50:
                matrix1.m11 *= matrix2.m11;
                matrix1.m22 *= matrix2.m22;
                matrix1.offsetX *= matrix2.m11;
                matrix1.offsetY *= matrix2.m22;
                return;
            case 51:
                matrix1.m11 *= matrix2.m11;
                matrix1.m22 *= matrix2.m22;
                matrix1.offsetX = matrix2.m11 * matrix1.offsetX + matrix2.offsetX;
                matrix1.offsetY = matrix2.m22 * matrix1.offsetY + matrix2.offsetY;
                return;
            case 52: break;
            default:
                switch (num) {
                    case 66:
                    case 67:
                    case 68: break;
                    default: return;
                }
                break;
        }
        var result = identityMatrix();
        var m11New = matrix1.m11 * matrix2.m11 + matrix1.m12 * matrix2.m21;
        var m12New = matrix1.m11 * matrix2.m12 + matrix1.m12 * matrix2.m22;
        var m21New = matrix1.m21 * matrix2.m11 + matrix1.m22 * matrix2.m21;
        var m22New = matrix1.m21 * matrix2.m12 + matrix1.m22 * matrix2.m22;
        var offsetX_1 = matrix1.offsetX * matrix2.m11 + matrix1.offsetY * matrix2.m21 + matrix2.offsetX;
        var offsetY_1 = matrix1.offsetX * matrix2.m12 + matrix1.offsetY * matrix2.m22 + matrix2.offsetY;
        setMatrix(result, m11New, m12New, m21New, m22New, offsetX_1, offsetY_1);
        if (result.m21 || result.m12) {
            result.type = MatrixTypes.Unknown;
        }
        else {
            if (result.m11 && result.m11 !== 1.0 || result.m22 && result.m22 !== 1.0) {
                result.type = MatrixTypes.Scaling;
            }
            if (result.offsetX || result.offsetY) {
                result.type |= MatrixTypes.Translation;
            }
            if ((result.type & (MatrixTypes.Translation | MatrixTypes.Scaling)) === MatrixTypes.Identity) {
                result.type = MatrixTypes.Identity;
            }
            result.type = MatrixTypes.Scaling | MatrixTypes.Translation;
        }
        assignMatrix(matrix1, result);
        matrix1.type = result.type;
        return;
    }
    var offsetX = matrix1.offsetX;
    var offsetY = matrix1.offsetY;
    matrix1.offsetX = offsetX * matrix2.m11 + offsetY * matrix2.m21 + matrix2.offsetX;
    matrix1.offsetY = offsetX * matrix2.m12 + offsetY * matrix2.m22 + matrix2.offsetY;
    if (type2 === MatrixTypes.Unknown) {
        matrix1.type = MatrixTypes.Unknown;
        return;
    }
    matrix1.type = (MatrixTypes.Translation | MatrixTypes.Scaling);
}
/**
 * set the matrix .\
 *
 * @returns {void} set the matrix .
 *
 * @param {Matrix} mat - Provide the matrix 1 value .
 * @param {number} m11 - Provide the matrix m11 value .
 * @param {number} m12 - Provide the matrix m11 value .
 * @param {number} m21 - Provide the matrix m11 value .
 * @param {number} m22 - Provide the matrix m11 value .
 * @param {number} x - Provide the matrix m11 value .
 * @param {number} y - Provide the matrix m11 value .
 * @private
 */
function setMatrix(mat, m11, m12, m21, m22, x, y) {
    mat.m11 = m11;
    mat.m12 = m12;
    mat.m21 = m21;
    mat.m22 = m22;
    mat.offsetX = x;
    mat.offsetY = y;
}
/**
 * Assign the matrix .\
 *
 * @returns {void} Assign the matrix .
 *
 * @param {Matrix} matrix1 - Provide the element type as string .
 * @param {Matrix} matrix2 - Provide the element type as string .
 * @private
 */
function assignMatrix(matrix1, matrix2) {
    matrix1.m11 = matrix2.m11;
    matrix1.m12 = matrix2.m12;
    matrix1.m21 = matrix2.m21;
    matrix1.m22 = matrix2.m22;
    matrix1.offsetX = matrix2.offsetX;
    matrix1.offsetY = matrix2.offsetY;
    matrix1.type = matrix2.type;
}

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**   @private  */
// eslint-disable-next-line prefer-const
var getGradientType = function (obj) {
    if (obj) {
        //Removed isBlazor code
        switch (obj.type) {
            case 'Linear':
                return LinearGradient;
            case 'Radial':
                return RadialGradient;
            default:
                return LinearGradient;
        }
    }
    return LinearGradient;
};
/**
 * Layout Model module defines the styles and types to arrange objects in containers
 */
var Thickness = /** @class */ (function () {
    function Thickness(left, right, top, bottom) {
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
    }
    return Thickness;
}());
/**
 * Defines the space to be left between an object and its immediate parent
 */
var Margin = /** @class */ (function (_super) {
    __extends$1(Margin, _super);
    function Margin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(0)
    ], Margin.prototype, "left", void 0);
    __decorate$1([
        Property(0)
    ], Margin.prototype, "right", void 0);
    __decorate$1([
        Property(0)
    ], Margin.prototype, "top", void 0);
    __decorate$1([
        Property(0)
    ], Margin.prototype, "bottom", void 0);
    return Margin;
}(ChildProperty));
/**
 * Defines the Shadow appearance of the objects
 * ```html
 * <div id='diagram'></div>
 * ```
 * ```typescript
 *  let nodes: NodeModel[] = [{ id: 'node2', width: 100, height: 100,
 *  constraints: NodeConstraints.Default | NodeConstraints.Shadow,
 *  shadow: { angle: 45, distance: 5, opacity: 0.7, color: 'grey'}
 * }];
 * let diagram: Diagram = new Diagram({
 * ...
 *   nodes: nodes,
 * ...
 * });
 * diagram.appendTo('#diagram');
 * ```
 */
var Shadow = /** @class */ (function (_super) {
    __extends$1(Shadow, _super);
    function Shadow() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(45)
    ], Shadow.prototype, "angle", void 0);
    __decorate$1([
        Property(5)
    ], Shadow.prototype, "distance", void 0);
    __decorate$1([
        Property(0.7)
    ], Shadow.prototype, "opacity", void 0);
    __decorate$1([
        Property('lightgrey')
    ], Shadow.prototype, "color", void 0);
    return Shadow;
}(ChildProperty));
/**
 * Defines the different colors and the region of color transitions
 * ```html
 * <div id='diagram'></div>
 * ```
 * ```typescript
 * let stopscol: StopModel[] = [];
 * let stops1: StopModel = { color: 'white', offset: 0, opacity: 0.7 };
 * stopscol.push(stops1);
 * let stops2: StopModel = { color: 'red', offset: 0, opacity: 0.3 };
 * stopscol.push(stops2);
 * let gradient: RadialGradientModel = { cx: 50, cy: 50, fx: 50, fy: 50, stops: stopscol, type: 'Radial' };
 * let nodes: NodeModel[] = [{ id: 'node1', width: 100, height: 100,
 * style: { gradient: gradient }
 * }];
 * let diagram: Diagram = new Diagram({
 * ...
 *   nodes: nodes,
 * ...
 * });
 * diagram.appendTo('#diagram');
 * ```
 */
var Stop = /** @class */ (function (_super) {
    __extends$1(Stop, _super);
    function Stop() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @private
     * Returns the name of class Stop
     */
    Stop.prototype.getClassName = function () {
        return 'Stop';
    };
    __decorate$1([
        Property('')
    ], Stop.prototype, "color", void 0);
    __decorate$1([
        Property(0)
    ], Stop.prototype, "offset", void 0);
    __decorate$1([
        Property(1)
    ], Stop.prototype, "opacity", void 0);
    return Stop;
}(ChildProperty));
/**
 * Paints the node with a smooth transition from one color to another color
 */
var Gradient = /** @class */ (function (_super) {
    __extends$1(Gradient, _super);
    function Gradient() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Collection([], Stop)
    ], Gradient.prototype, "stops", void 0);
    __decorate$1([
        Property('None')
    ], Gradient.prototype, "type", void 0);
    __decorate$1([
        Property('')
    ], Gradient.prototype, "id", void 0);
    return Gradient;
}(ChildProperty));
/**
 * Defines the linear gradient of styles
 * ```html
 * <div id='diagram'></div>
 * ```
 * ```typescript
 * let stopscol: StopModel[] = [];
 * let stops1: StopModel = { color: 'white', offset: 0, opacity: 0.7 };
 * stopscol.push(stops1);
 * let stops2: StopModel = { color: 'red', offset: 0, opacity: 0.3 };
 * stopscol.push(stops2);
 * let gradient: LinearGradientModel = { x1: 0, x2: 50, y1: 0, y2: 50, stops: stopscol, type: 'Linear' };
 * let nodes: NodeModel[] = [{ id: 'node1', width: 100, height: 100,
 * style: { gradient: gradient }
 * }];
 * let diagram: Diagram = new Diagram({
 * ...
 *   nodes: nodes,
 * ...
 * });
 * diagram.appendTo('#diagram');
 * ```
 */
/**
 * Paints the node with linear color transitions
 */
var DiagramGradient = /** @class */ (function (_super) {
    __extends$1(DiagramGradient, _super);
    function DiagramGradient() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(0)
    ], DiagramGradient.prototype, "x1", void 0);
    __decorate$1([
        Property(0)
    ], DiagramGradient.prototype, "x2", void 0);
    __decorate$1([
        Property(0)
    ], DiagramGradient.prototype, "y1", void 0);
    __decorate$1([
        Property(0)
    ], DiagramGradient.prototype, "y2", void 0);
    __decorate$1([
        Property(0)
    ], DiagramGradient.prototype, "cx", void 0);
    __decorate$1([
        Property(0)
    ], DiagramGradient.prototype, "cy", void 0);
    __decorate$1([
        Property(0)
    ], DiagramGradient.prototype, "fx", void 0);
    __decorate$1([
        Property(0)
    ], DiagramGradient.prototype, "fy", void 0);
    __decorate$1([
        Property(50)
    ], DiagramGradient.prototype, "r", void 0);
    return DiagramGradient;
}(Gradient));
/**
 * Paints the node with linear color transitions
 */
var LinearGradient = /** @class */ (function (_super) {
    __extends$1(LinearGradient, _super);
    function LinearGradient() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(0)
    ], LinearGradient.prototype, "x1", void 0);
    __decorate$1([
        Property(0)
    ], LinearGradient.prototype, "x2", void 0);
    __decorate$1([
        Property(0)
    ], LinearGradient.prototype, "y1", void 0);
    __decorate$1([
        Property(0)
    ], LinearGradient.prototype, "y2", void 0);
    return LinearGradient;
}(Gradient));
/**
 * A focal point defines the beginning of the gradient, and a circle defines the end point of the gradient
 * ```html
 * <div id='diagram'></div>
 * ```
 * ```typescript
 * let stopscol: StopModel[] = [];
 * let stops1: StopModel = { color: 'white', offset: 0, opacity: 0.7 };
 * stopscol.push(stops1);
 * let stops2: StopModel = { color: 'red', offset: 0, opacity: 0.3 };
 * stopscol.push(stops2);
 * let gradient: RadialGradientModel = { cx: 50, cy: 50, fx: 50, fy: 50, stops: stopscol, type: 'Radial' };
 * let nodes: NodeModel[] = [{ id: 'node1', width: 100, height: 100,
 * style: { gradient: gradient }
 * }];
 * let diagram: Diagram = new Diagram({
 * ...
 *   nodes: nodes,
 * ...
 * });
 * diagram.appendTo('#diagram');
 * ```
 */
var RadialGradient = /** @class */ (function (_super) {
    __extends$1(RadialGradient, _super);
    function RadialGradient() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property(0)
    ], RadialGradient.prototype, "cx", void 0);
    __decorate$1([
        Property(0)
    ], RadialGradient.prototype, "cy", void 0);
    __decorate$1([
        Property(0)
    ], RadialGradient.prototype, "fx", void 0);
    __decorate$1([
        Property(0)
    ], RadialGradient.prototype, "fy", void 0);
    __decorate$1([
        Property(50)
    ], RadialGradient.prototype, "r", void 0);
    return RadialGradient;
}(Gradient));
/**
 * Defines the style of shape/path
 */
var ShapeStyle = /** @class */ (function (_super) {
    __extends$1(ShapeStyle, _super);
    function ShapeStyle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property('white')
    ], ShapeStyle.prototype, "fill", void 0);
    __decorate$1([
        Property('black')
    ], ShapeStyle.prototype, "strokeColor", void 0);
    __decorate$1([
        Property('')
    ], ShapeStyle.prototype, "strokeDashArray", void 0);
    __decorate$1([
        Property(1)
    ], ShapeStyle.prototype, "strokeWidth", void 0);
    __decorate$1([
        Property(1)
    ], ShapeStyle.prototype, "opacity", void 0);
    __decorate$1([
        ComplexFactory(getGradientType)
    ], ShapeStyle.prototype, "gradient", void 0);
    return ShapeStyle;
}(ChildProperty));
/**
 * Defines the stroke style of a path
 */
var StrokeStyle = /** @class */ (function (_super) {
    __extends$1(StrokeStyle, _super);
    function StrokeStyle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property('transparent')
    ], StrokeStyle.prototype, "fill", void 0);
    return StrokeStyle;
}(ShapeStyle));
/**
 * Defines the appearance of text
 * ```html
 * <div id='diagram'></div>
 * ```
 * ```typescript
 * let style: TextStyleModel = { strokeColor: 'black', opacity: 0.5, whiteSpace:'CollapseSpace', strokeWidth: 1 };
 * let node: NodeModel;
 * node = {
 * ...
 * id: 'node', width: 100, height: 100, offsetX: 100, offsetY: 100,
 * annotations : [{
 * content: 'text', style: style }];
 * ...
 * };
 * let diagram: Diagram = new Diagram({
 * ...
 *   nodes: [node],
 * ...
 * });
 * diagram.appendTo('#diagram');
 * ```
 */
var TextStyle = /** @class */ (function (_super) {
    __extends$1(TextStyle, _super);
    function TextStyle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property('black')
    ], TextStyle.prototype, "color", void 0);
    __decorate$1([
        Property('Arial')
    ], TextStyle.prototype, "fontFamily", void 0);
    __decorate$1([
        Property(12)
    ], TextStyle.prototype, "fontSize", void 0);
    __decorate$1([
        Property(false)
    ], TextStyle.prototype, "italic", void 0);
    __decorate$1([
        Property(false)
    ], TextStyle.prototype, "bold", void 0);
    __decorate$1([
        Property('CollapseSpace')
    ], TextStyle.prototype, "whiteSpace", void 0);
    __decorate$1([
        Property('WrapWithOverflow')
    ], TextStyle.prototype, "textWrapping", void 0);
    __decorate$1([
        Property('Center')
    ], TextStyle.prototype, "textAlign", void 0);
    __decorate$1([
        Property('None')
    ], TextStyle.prototype, "textDecoration", void 0);
    __decorate$1([
        Property('Wrap')
    ], TextStyle.prototype, "textOverflow", void 0);
    __decorate$1([
        Property('transparent')
    ], TextStyle.prototype, "fill", void 0);
    return TextStyle;
}(ShapeStyle));
/**
 * Defines the style of shape/path
 */
var DiagramShapeStyle = /** @class */ (function (_super) {
    __extends$1(DiagramShapeStyle, _super);
    function DiagramShapeStyle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$1([
        Property('white')
    ], DiagramShapeStyle.prototype, "fill", void 0);
    __decorate$1([
        Property('Wrap')
    ], DiagramShapeStyle.prototype, "textOverflow", void 0);
    __decorate$1([
        Property(1)
    ], DiagramShapeStyle.prototype, "strokeWidth", void 0);
    __decorate$1([
        ComplexFactory(getGradientType)
    ], DiagramShapeStyle.prototype, "gradient", void 0);
    __decorate$1([
        Property(1)
    ], DiagramShapeStyle.prototype, "opacity", void 0);
    __decorate$1([
        Property(false)
    ], DiagramShapeStyle.prototype, "italic", void 0);
    __decorate$1([
        Property('')
    ], DiagramShapeStyle.prototype, "strokeDashArray", void 0);
    __decorate$1([
        Property('black')
    ], DiagramShapeStyle.prototype, "color", void 0);
    __decorate$1([
        Property(12)
    ], DiagramShapeStyle.prototype, "fontSize", void 0);
    __decorate$1([
        Property('Arial')
    ], DiagramShapeStyle.prototype, "fontFamily", void 0);
    __decorate$1([
        Property('CollapseSpace')
    ], DiagramShapeStyle.prototype, "whiteSpace", void 0);
    __decorate$1([
        Property('Center')
    ], DiagramShapeStyle.prototype, "textAlign", void 0);
    __decorate$1([
        Property('None')
    ], DiagramShapeStyle.prototype, "textDecoration", void 0);
    __decorate$1([
        Property(false)
    ], DiagramShapeStyle.prototype, "bold", void 0);
    __decorate$1([
        Property('black')
    ], DiagramShapeStyle.prototype, "strokeColor", void 0);
    __decorate$1([
        Property('WrapWithOverflow')
    ], DiagramShapeStyle.prototype, "textWrapping", void 0);
    return DiagramShapeStyle;
}(ChildProperty));

/**
 * enum module defines the public enumerations
 */
/**
 * @private
 */
var BlazorAction;
(function (BlazorAction) {
    /** Return the layout value is true when doLayout is called   */
    BlazorAction[BlazorAction["Default"] = 0] = "Default";
    /** Need to return the layout value when doLayout is called  */
    BlazorAction[BlazorAction["expandNode"] = 2] = "expandNode";
    /** Enabled during the mouse interaction  */
    BlazorAction[BlazorAction["interaction"] = 4] = "interaction";
    /** Enable when the group action start in history */
    BlazorAction[BlazorAction["GroupingInProgress"] = 8] = "GroupingInProgress";
    /** Enable when the group action start to clone another group node */
    BlazorAction[BlazorAction["GroupClipboardInProcess"] = 16] = "GroupClipboardInProcess";
    /** Enable when the clear the object to prevent the server update */
    BlazorAction[BlazorAction["ClearObject"] = 32] = "ClearObject";
})(BlazorAction || (BlazorAction = {}));
/**
 * Defines how the diagram elements have to be flipped with respect to its immediate parent
 * * FlipHorizontal - Translate the diagram element throughout its immediate parent
 * * FlipVertical - Rotate the diagram element throughout its immediate parent
 * * Both - Rotate  and Translate the diagram element throughout its immediate parent
 * * None - Set the flip Direction as None
 */
var FlipDirection;
(function (FlipDirection) {
    /**
     * FlipHorizontal - Translate the diagram element throughout its immediate parent
     */
    FlipDirection[FlipDirection["Horizontal"] = 1] = "Horizontal";
    /**
     * FlipVertical - Rotate the diagram element throughout its immediate parent
     */
    FlipDirection[FlipDirection["Vertical"] = 2] = "Vertical";
    /**
     * Both - Rotate and Translate the diagram element throughout its immediate parent
     */
    FlipDirection[FlipDirection["Both"] = 3] = "Both";
    /**
     * None - Set the flip Direction as None
     */
    FlipDirection[FlipDirection["None"] = 0] = "None";
})(FlipDirection || (FlipDirection = {}));
/**
 * Constraints to define when a port has to be visible
 * Visible - Always shows the port
 * Hidden - Always hides the port
 * Hover - Shows the port when the mouse hovers over a node
 * Connect - Shows the port when a connection end point is dragged over a node
 * Default - By default the ports will be visible when a node is hovered and being tried to connect
 *
 * @aspNumberEnum
 */
var PortVisibility;
(function (PortVisibility) {
    /** Always shows the port */
    PortVisibility[PortVisibility["Visible"] = 1] = "Visible";
    /** Always hides the port */
    PortVisibility[PortVisibility["Hidden"] = 2] = "Hidden";
    /** Shows the port when the mouse hovers over a node */
    PortVisibility[PortVisibility["Hover"] = 4] = "Hover";
    /** Shows the port when a connection end point is dragged over a node */
    PortVisibility[PortVisibility["Connect"] = 8] = "Connect";
})(PortVisibility || (PortVisibility = {}));
/**
 * Defines the constraints to Enables / Disables some features of Snapping.
 * None - Snapping does not happen
 * ShowHorizontalLines - Displays only the horizontal gridlines in diagram.
 * ShowVerticalLines - Displays only the Vertical gridlines in diagram.
 * ShowLines - Display both Horizontal and Vertical gridlines.
 * SnapToHorizontalLines - Enables the object to snap only with horizontal gridlines.
 * SnapToVerticalLines - Enables the object to snap only with horizontal gridlines.
 * SnapToLines - Enables the object to snap with both horizontal and Vertical gridlines.
 * snapToObject - Enables the object to snap with the other objects in the diagram.
 *
 * @IgnoreSingular
 * @aspNumberEnum
 */
var SnapConstraints;
(function (SnapConstraints) {
    /** None - Snapping does not happen */
    SnapConstraints[SnapConstraints["None"] = 0] = "None";
    /** ShowHorizontalLines - Displays only the horizontal gridlines in diagram. */
    SnapConstraints[SnapConstraints["ShowHorizontalLines"] = 1] = "ShowHorizontalLines";
    /** ShowVerticalLines - Displays only the Vertical gridlines in diagram  */
    SnapConstraints[SnapConstraints["ShowVerticalLines"] = 2] = "ShowVerticalLines";
    /** ShowLines - Display both Horizontal and Vertical gridlines */
    SnapConstraints[SnapConstraints["ShowLines"] = 3] = "ShowLines";
    /** SnapToHorizontalLines - Enables the object to snap only with horizontal gridlines */
    SnapConstraints[SnapConstraints["SnapToHorizontalLines"] = 4] = "SnapToHorizontalLines";
    /** SnapToVerticalLines - Enables the object to snap only with horizontal gridlines */
    SnapConstraints[SnapConstraints["SnapToVerticalLines"] = 8] = "SnapToVerticalLines";
    /** SnapToLines - Enables the object to snap with both horizontal and Vertical gridlines */
    SnapConstraints[SnapConstraints["SnapToLines"] = 12] = "SnapToLines";
    /** SnapToObject - Enables the object to snap with the other objects in the diagram. */
    SnapConstraints[SnapConstraints["SnapToObject"] = 16] = "SnapToObject";
    /** Shows gridlines and enables snapping */
    SnapConstraints[SnapConstraints["All"] = 31] = "All";
})(SnapConstraints || (SnapConstraints = {}));
/**
 * Defines the visibility of the selector handles
 * None - Hides all the selector elements
 * ConnectorSourceThumb - Shows/hides the source thumb of the connector
 * ConnectorTargetThumb - Shows/hides the target thumb of the connector
 * ResizeSouthEast - Shows/hides the bottom right resize handle of the selector
 * ResizeSouthWest - Shows/hides the bottom left resize handle of the selector
 * ResizeNorthEast - Shows/hides the top right resize handle of the selector
 * ResizeNorthWest - Shows/hides the top left resize handle of the selector
 * ResizeEast - Shows/hides the middle right resize handle of the selector
 * ResizeWest - Shows/hides the middle left resize handle of the selector
 * ResizeSouth - Shows/hides the bottom center resize handle of the selector
 * ResizeNorth - Shows/hides the top center resize handle of the selector
 * Rotate - Shows/hides the rotate handle of the selector
 * UserHandles - Shows/hides the user handles of the selector
 * Resize - Shows/hides all resize handles of the selector
 *
 * @aspNumberEnum
 * @IgnoreSingular
 */
var SelectorConstraints;
(function (SelectorConstraints) {
    /** Hides all the selector elements */
    SelectorConstraints[SelectorConstraints["None"] = 1] = "None";
    /** Shows/hides the source thumb of the connector */
    SelectorConstraints[SelectorConstraints["ConnectorSourceThumb"] = 2] = "ConnectorSourceThumb";
    /** Shows/hides the target thumb of the connector */
    SelectorConstraints[SelectorConstraints["ConnectorTargetThumb"] = 4] = "ConnectorTargetThumb";
    /** Shows/hides the bottom right resize handle of the selector */
    SelectorConstraints[SelectorConstraints["ResizeSouthEast"] = 8] = "ResizeSouthEast";
    /** Shows/hides the bottom left resize handle of the selector */
    SelectorConstraints[SelectorConstraints["ResizeSouthWest"] = 16] = "ResizeSouthWest";
    /** Shows/hides the top right resize handle of the selector */
    SelectorConstraints[SelectorConstraints["ResizeNorthEast"] = 32] = "ResizeNorthEast";
    /** Shows/hides the top left resize handle of the selector */
    SelectorConstraints[SelectorConstraints["ResizeNorthWest"] = 64] = "ResizeNorthWest";
    /** Shows/hides the middle right resize handle of the selector  */
    SelectorConstraints[SelectorConstraints["ResizeEast"] = 128] = "ResizeEast";
    /** Shows/hides the middle left resize handle of the selector */
    SelectorConstraints[SelectorConstraints["ResizeWest"] = 256] = "ResizeWest";
    /** Shows/hides the bottom center resize handle of the selector */
    SelectorConstraints[SelectorConstraints["ResizeSouth"] = 512] = "ResizeSouth";
    /** Shows/hides the top center resize handle of the selector */
    SelectorConstraints[SelectorConstraints["ResizeNorth"] = 1024] = "ResizeNorth";
    /**  Shows/hides the rotate handle of the selector */
    SelectorConstraints[SelectorConstraints["Rotate"] = 2048] = "Rotate";
    /** Shows/hides the user handles of the selector */
    SelectorConstraints[SelectorConstraints["UserHandle"] = 4096] = "UserHandle";
    /** Shows/hides the default tooltip of nodes and connectors */
    SelectorConstraints[SelectorConstraints["ToolTip"] = 8192] = "ToolTip";
    /** Shows/hides all resize handles of the selector */
    SelectorConstraints[SelectorConstraints["ResizeAll"] = 2046] = "ResizeAll";
    /** Shows all handles of the selector  */
    SelectorConstraints[SelectorConstraints["All"] = 16382] = "All";
})(SelectorConstraints || (SelectorConstraints = {}));
/**
 * Defines the connection point of the connectors in the layout
 * SamePoint - Connectors will connect with same point in the layout
 * DifferentPoint - Connectors will connect with different points in the layout
 */
var ConnectionPointOrigin;
(function (ConnectionPointOrigin) {
    /** SamePoint - Connectors will connect with same point in the layout */
    ConnectionPointOrigin["SamePoint"] = "SamePoint";
    /** DifferentPoint - Connectors will connect with different points in the layout */
    ConnectionPointOrigin["DifferentPoint"] = "DifferentPoint";
})(ConnectionPointOrigin || (ConnectionPointOrigin = {}));
/**
 * Defines the child nodes need to arranged in linear manner in layout
 * Linear - Child nodes will be arranged in linear manner
 * Nonlinear - Child nodes will be arranged in not linear manner
 */
var ChildArrangement;
(function (ChildArrangement) {
    /** Linear - Child nodes will be arranged in linear manner */
    ChildArrangement["Linear"] = "Linear";
    /** Nonlinear - Child nodes will be arranged in not linear manner */
    ChildArrangement["Nonlinear"] = "Nonlinear";
})(ChildArrangement || (ChildArrangement = {}));
/**
 * Defines the constraints to enable/disable certain features of connector.
 * * None - Interaction of the connectors cannot be done.
 * * Select - Selects the connector.
 * * Delete - Delete the connector.
 * * Drag - Drag the connector.
 * * DragSourceEnd - Drag the source end of the connector.
 * * DragTargetEnd - Drag the target end of the connector.
 * * DragSegmentThump - Drag the segment thumb of the connector.
 * * AllowDrop - Allow to drop a node.
 * * Bridging - Creates bridge  on intersection of two connectors.
 * * BridgeObstacle -
 * * InheritBridging - Creates bridge  on intersection of two connectors.
 * * PointerEvents - Sets the pointer events.
 * * Tooltip - Displays a tooltip for the connectors.
 * * InheritToolTip - Displays a tooltip for the connectors.
 * * Interaction - Features of the connector used for interaction.
 * * ReadOnly - Enables ReadOnly
 * * InheritSegmentThumbShape- Enables or disables to inherit the value of segmentThumbShape
 * * InheritSegmentThumbSize - Enables or disables to inherit the value of segmentThumbSize
 * * Default - Default features of the connector.
 *
 * @aspNumberEnum
 * @IgnoreSingular
 */
var ConnectorConstraints;
(function (ConnectorConstraints) {
    /** Disable all connector Constraints. */
    ConnectorConstraints[ConnectorConstraints["None"] = 1] = "None";
    /** Enables connector to be selected. */
    ConnectorConstraints[ConnectorConstraints["Select"] = 2] = "Select";
    /** Enables connector to be Deleted. */
    ConnectorConstraints[ConnectorConstraints["Delete"] = 4] = "Delete";
    /** Enables connector to be Dragged. */
    ConnectorConstraints[ConnectorConstraints["Drag"] = 8] = "Drag";
    /** Enables connectors source end to be selected. */
    ConnectorConstraints[ConnectorConstraints["DragSourceEnd"] = 16] = "DragSourceEnd";
    /** Enables connectors target end to be selected. */
    ConnectorConstraints[ConnectorConstraints["DragTargetEnd"] = 32] = "DragTargetEnd";
    /** Enables control point and end point of every segment in a connector for editing. */
    ConnectorConstraints[ConnectorConstraints["DragSegmentThumb"] = 64] = "DragSegmentThumb";
    /** Enables AllowDrop constraints to the  connector. */
    ConnectorConstraints[ConnectorConstraints["AllowDrop"] = 128] = "AllowDrop";
    /** Enables bridging to the connector. */
    ConnectorConstraints[ConnectorConstraints["Bridging"] = 256] = "Bridging";
    /** Enables or Disables Bridge Obstacles with overlapping of connectors. */
    ConnectorConstraints[ConnectorConstraints["BridgeObstacle"] = 512] = "BridgeObstacle";
    /** Enables bridging to the connector. */
    ConnectorConstraints[ConnectorConstraints["InheritBridging"] = 1024] = "InheritBridging";
    /** Used to set the pointer events. */
    ConnectorConstraints[ConnectorConstraints["PointerEvents"] = 2048] = "PointerEvents";
    /** Enables or disables tool tip for the connectors */
    ConnectorConstraints[ConnectorConstraints["Tooltip"] = 4096] = "Tooltip";
    /** Enables or disables tool tip for the connectors */
    ConnectorConstraints[ConnectorConstraints["InheritTooltip"] = 8192] = "InheritTooltip";
    /** Enables Interaction. */
    ConnectorConstraints[ConnectorConstraints["Interaction"] = 4218] = "Interaction";
    /** Enables ReadOnly */
    ConnectorConstraints[ConnectorConstraints["ReadOnly"] = 16384] = "ReadOnly";
    /** Enables or disables routing to the connector. */
    ConnectorConstraints[ConnectorConstraints["LineRouting"] = 32768] = "LineRouting";
    /** Enables or disables routing to the connector. */
    ConnectorConstraints[ConnectorConstraints["InheritLineRouting"] = 65536] = "InheritLineRouting";
    /** Enables or disables near node padding to the connector. */
    ConnectorConstraints[ConnectorConstraints["ConnectToNearByNode"] = 131072] = "ConnectToNearByNode";
    /** Enables or disables near port padding to the connector. */
    ConnectorConstraints[ConnectorConstraints["ConnectToNearByPort"] = 262144] = "ConnectToNearByPort";
    /** Enables or disables Enables or disables near port and node padding to the connector. */
    ConnectorConstraints[ConnectorConstraints["ConnectToNearByElement"] = 393216] = "ConnectToNearByElement";
    /**Enables or disables to inherit the value of segmentThumbShape */
    ConnectorConstraints[ConnectorConstraints["InheritSegmentThumbShape"] = 524288] = "InheritSegmentThumbShape";
    /**Enables or disables to inherit the value of segmentThumbSize */
    ConnectorConstraints[ConnectorConstraints["InheritSegmentThumbSize"] = 1048576] = "InheritSegmentThumbSize";
    /** Enables all constraints. */
    ConnectorConstraints[ConnectorConstraints["Default"] = 2043454] = "Default";
})(ConnectorConstraints || (ConnectorConstraints = {}));
/**
 * Enables/Disables the annotation constraints
 * ReadOnly - Enables/Disables the ReadOnly Constraints
 * InheritReadOnly - Enables/Disables the InheritReadOnly Constraints
 * Select -Enables/Disable select support for the annotation
 * Drag - Enables/Disable drag support for the annotation
 * Resize - Enables/Disable resize support for the annotation
 * Rotate - Enables/Disable rotate support for the annotation
 * Interaction - Enables annotation to inherit the interaction option
 * None - Disable all annotation constraints
 *
 * @aspNumberEnum
 * @IgnoreSingular
 */
var AnnotationConstraints;
(function (AnnotationConstraints) {
    /** Enables/Disables the ReadOnly Constraints */
    AnnotationConstraints[AnnotationConstraints["ReadOnly"] = 2] = "ReadOnly";
    /** Enables/Disables the InheritReadOnly Constraints */
    AnnotationConstraints[AnnotationConstraints["InheritReadOnly"] = 4] = "InheritReadOnly";
    /** Enables/Disable select support for the annotation */
    AnnotationConstraints[AnnotationConstraints["Select"] = 8] = "Select";
    /** Enables/Disable drag support for the annotation */
    AnnotationConstraints[AnnotationConstraints["Drag"] = 16] = "Drag";
    /** Enables/Disable resize support for the annotation */
    AnnotationConstraints[AnnotationConstraints["Resize"] = 32] = "Resize";
    /** Enables/Disable rotate support for the annotation */
    AnnotationConstraints[AnnotationConstraints["Rotate"] = 64] = "Rotate";
    /** Enables or disables tool tip for the annotation */
    AnnotationConstraints[AnnotationConstraints["Tooltip"] = 128] = "Tooltip";
    /** Enables annotation to inherit the interaction option */
    AnnotationConstraints[AnnotationConstraints["Interaction"] = 120] = "Interaction";
    /** Disable all annotation Constraints */
    AnnotationConstraints[AnnotationConstraints["None"] = 0] = "None";
})(AnnotationConstraints || (AnnotationConstraints = {}));
/**
 * Enables/Disables certain features of node
 * None - Disable all node Constraints
 * Select - Enables node to be selected
 * Drag - Enables node to be Dragged
 * Rotate - Enables node to be Rotate
 * Shadow - Enables node to display shadow
 * PointerEvents - Enables node to provide pointer  option
 * Delete - Enables node to delete
 * InConnect - Enables node to provide in connect option
 * OutConnect - Enables node to provide out connect option
 * Individual - Enables node to provide individual resize option
 * Expandable - Enables node to provide Expandable option
 * AllowDrop - Enables node to provide allow to drop option
 * Inherit - Enables node to inherit the interaction option
 * ResizeNorthEast - Enable ResizeNorthEast of the node
 * ResizeEast - Enable ResizeEast of the node
 * ResizeSouthEast - Enable ResizeSouthEast of the node
 * ResizeSouth - Enable ResizeSouthWest of the node
 * ResizeSouthWest - Enable ResizeSouthWest of the node
 * ResizeSouth - Enable ResizeSouth of the node
 * ResizeSouthWest - Enable ResizeSouthWest of the node
 * ResizeWest - Enable ResizeWest of the node
 * ResizeNorth - Enable ResizeNorth of the node
 * Resize - Enables the Aspect ratio fo the node
 * AspectRatio - Enables the Aspect ratio fo the node
 * Tooltip - Enables or disables tool tip for the Nodes
 * InheritTooltip - Enables or disables tool tip for the Nodes
 * ReadOnly - Enables the  ReadOnly support for Annotation
 * Default - Enables all constraints
 *
 * @aspNumberEnum
 * @IgnoreSingular
 */
var NodeConstraints;
(function (NodeConstraints) {
    /** Disable all node Constraints. */
    NodeConstraints[NodeConstraints["None"] = 0] = "None";
    /** Enables node to be selected. */
    NodeConstraints[NodeConstraints["Select"] = 2] = "Select";
    /** Enables node to be Dragged. */
    NodeConstraints[NodeConstraints["Drag"] = 4] = "Drag";
    /** Enables node to be Rotate. */
    NodeConstraints[NodeConstraints["Rotate"] = 8] = "Rotate";
    /** Enables node to display shadow. */
    NodeConstraints[NodeConstraints["Shadow"] = 16] = "Shadow";
    /** Enables node to provide pointer  option */
    NodeConstraints[NodeConstraints["PointerEvents"] = 32] = "PointerEvents";
    /** Enables node to delete */
    NodeConstraints[NodeConstraints["Delete"] = 64] = "Delete";
    /** Enables node to provide in connect option */
    NodeConstraints[NodeConstraints["InConnect"] = 128] = "InConnect";
    /** Enables node to provide out connect option */
    NodeConstraints[NodeConstraints["OutConnect"] = 256] = "OutConnect";
    /** Enables node to provide individual resize option */
    NodeConstraints[NodeConstraints["Individual"] = 512] = "Individual";
    /** Enables node to provide Expandable option */
    NodeConstraints[NodeConstraints["Expandable"] = 1024] = "Expandable";
    /** Enables node to provide allow to drop option */
    NodeConstraints[NodeConstraints["AllowDrop"] = 2048] = "AllowDrop";
    /** Enables node to inherit the interaction option */
    NodeConstraints[NodeConstraints["Inherit"] = 78] = "Inherit";
    /** Enable ResizeNorthEast of the node  */
    NodeConstraints[NodeConstraints["ResizeNorthEast"] = 4096] = "ResizeNorthEast";
    /** Enable ResizeEast of the node  */
    NodeConstraints[NodeConstraints["ResizeEast"] = 8192] = "ResizeEast";
    /** Enable ResizeSouthEast of the node  */
    NodeConstraints[NodeConstraints["ResizeSouthEast"] = 16384] = "ResizeSouthEast";
    /** Enable ResizeSouth of the node  */
    NodeConstraints[NodeConstraints["ResizeSouth"] = 32768] = "ResizeSouth";
    /** Enable ResizeSouthWest of the node  */
    NodeConstraints[NodeConstraints["ResizeSouthWest"] = 65536] = "ResizeSouthWest";
    /** Enable ResizeWest of the node  */
    NodeConstraints[NodeConstraints["ResizeWest"] = 131072] = "ResizeWest";
    /** Enable ResizeNorthWest of the node  */
    NodeConstraints[NodeConstraints["ResizeNorthWest"] = 262144] = "ResizeNorthWest";
    /** Enable ResizeNorth of the node  */
    NodeConstraints[NodeConstraints["ResizeNorth"] = 524288] = "ResizeNorth";
    /** Enable Resize of the node  */
    NodeConstraints[NodeConstraints["Resize"] = 1044480] = "Resize";
    /** Enables the Aspect ratio fo the node */
    NodeConstraints[NodeConstraints["AspectRatio"] = 1048576] = "AspectRatio";
    /** Enables or disables tool tip for the Nodes */
    NodeConstraints[NodeConstraints["Tooltip"] = 2097152] = "Tooltip";
    /** Enables or disables tool tip for the Nodes */
    NodeConstraints[NodeConstraints["InheritTooltip"] = 4194304] = "InheritTooltip";
    /** Enables the  ReadOnly support for Annotation */
    NodeConstraints[NodeConstraints["ReadOnly"] = 8388608] = "ReadOnly";
    /** hide all resize support for node */
    NodeConstraints[NodeConstraints["HideThumbs"] = 16777216] = "HideThumbs";
    /** Enables or disables child in parent for the swimLane node */
    NodeConstraints[NodeConstraints["AllowMovingOutsideLane"] = 33554432] = "AllowMovingOutsideLane";
    /** Enables all constraints */
    NodeConstraints[NodeConstraints["Default"] = 5240814] = "Default";
})(NodeConstraints || (NodeConstraints = {}));
/** Enables/Disables The element actions
 * None - Diables all element actions are none
 * ElementIsPort - Enable element action is port
 * ElementIsGroup - Enable element action as Group
 *
 * @private
 */
var ElementAction;
(function (ElementAction) {
    /** Disables all element actions are none  */
    ElementAction[ElementAction["None"] = 0] = "None";
    /** Enable the element action is Port  */
    ElementAction[ElementAction["ElementIsPort"] = 2] = "ElementIsPort";
    /** Enable the element action as Group  */
    ElementAction[ElementAction["ElementIsGroup"] = 4] = "ElementIsGroup";
    /** Enable the element action if swimlaneHeader is rendered  */
    ElementAction[ElementAction["HorizontalLaneHeader"] = 8] = "HorizontalLaneHeader";
})(ElementAction || (ElementAction = {}));
/** Enables/Disables the handles of the selector
 * Rotate - Enable Rotate Thumb
 * ConnectorSource - Enable Connector source point
 * ConnectorTarget - Enable Connector target point
 * ResizeNorthEast - Enable ResizeNorthEast Resize
 * ResizeEast - Enable ResizeEast Resize
 * ResizeSouthEast - Enable ResizeSouthEast Resize
 * ResizeSouth - Enable ResizeSouth Resize
 * ResizeSouthWest - Enable ResizeSouthWest Resize
 * ResizeWest - Enable ResizeWest Resize
 * ResizeNorthWest - Enable ResizeNorthWest Resize
 * ResizeNorth - Enable ResizeNorth Resize
 * Default - Enables all constraints
 *
 * @private
 */
var ThumbsConstraints;
(function (ThumbsConstraints) {
    /** Enable Rotate Thumb  */
    ThumbsConstraints[ThumbsConstraints["Rotate"] = 2] = "Rotate";
    /** Enable Connector source point  */
    ThumbsConstraints[ThumbsConstraints["ConnectorSource"] = 4] = "ConnectorSource";
    /** Enable Connector target point  */
    ThumbsConstraints[ThumbsConstraints["ConnectorTarget"] = 8] = "ConnectorTarget";
    /** Enable ResizeNorthEast Resize  */
    ThumbsConstraints[ThumbsConstraints["ResizeNorthEast"] = 16] = "ResizeNorthEast";
    /** Enable ResizeEast Resize  */
    ThumbsConstraints[ThumbsConstraints["ResizeEast"] = 32] = "ResizeEast";
    /** Enable ResizeSouthEast Resize */
    ThumbsConstraints[ThumbsConstraints["ResizeSouthEast"] = 64] = "ResizeSouthEast";
    /** Enable ResizeSouth Resize */
    ThumbsConstraints[ThumbsConstraints["ResizeSouth"] = 128] = "ResizeSouth";
    /** Enable ResizeSouthWest Resize */
    ThumbsConstraints[ThumbsConstraints["ResizeSouthWest"] = 256] = "ResizeSouthWest";
    /** Enable ResizeWest Resize */
    ThumbsConstraints[ThumbsConstraints["ResizeWest"] = 512] = "ResizeWest";
    /** Enable ResizeNorthWest Resize */
    ThumbsConstraints[ThumbsConstraints["ResizeNorthWest"] = 1024] = "ResizeNorthWest";
    /** Enable ResizeNorth Resize */
    ThumbsConstraints[ThumbsConstraints["ResizeNorth"] = 2048] = "ResizeNorth";
    /** Enables all constraints */
    ThumbsConstraints[ThumbsConstraints["Default"] = 4094] = "Default";
})(ThumbsConstraints || (ThumbsConstraints = {}));
/**
 * Enables/Disables certain features of diagram
 * None - Disable DiagramConstraints constraints
 * Bridging - Enables/Disable Bridging support for connector
 * UndoRedo - Enables/Disable the Undo/Redo support
 * Tooltip - Enables/Disable Tooltip support
 * UserInteraction - Enables/Disable UserInteraction support for the diagram
 * ApiUpdate - Enables/Disable ApiUpdate support for the diagram
 * PageEditable - Enables/Disable PageEditable support for the diagram
 * Zoom - Enables/Disable Zoom support for the diagram
 * PanX - Enables/Disable PanX support for the diagram
 * PanY - Enables/Disable PanY support for the diagram
 * Pan - Enables/Disable Pan support the diagram
 * ZoomTextEdit - Enables/Disables zooming the text box while editing the text
 * Virtualization - Enables/Disable Virtualization support the diagram
 * LineRouting - Enables/ Disable the line routing
 * AvoidLineOverlapping - Enables/Disables the line overlapping resolution globally in the diagram
 * Default - Enables/Disable all constraints
 *
 * @aspNumberEnum
 * @IgnoreSingular
 */
var DiagramConstraints;
(function (DiagramConstraints) {
    /** Disable DiagramConstraints constraints */
    DiagramConstraints[DiagramConstraints["None"] = 1] = "None";
    /** Enables/Disable Bridging support for connector */
    DiagramConstraints[DiagramConstraints["Bridging"] = 2] = "Bridging";
    /** Enables/Disable the Undo/Redo support */
    DiagramConstraints[DiagramConstraints["UndoRedo"] = 4] = "UndoRedo";
    /** Enables/Disable Tooltip support */
    DiagramConstraints[DiagramConstraints["Tooltip"] = 8] = "Tooltip";
    /** Enables/Disable UserInteraction support for the diagram */
    DiagramConstraints[DiagramConstraints["UserInteraction"] = 16] = "UserInteraction";
    /** Enables/Disable ApiUpdate support for the diagram */
    DiagramConstraints[DiagramConstraints["ApiUpdate"] = 32] = "ApiUpdate";
    /** Enables/Disable PageEditable support for the diagram */
    DiagramConstraints[DiagramConstraints["PageEditable"] = 48] = "PageEditable";
    /** Enables/Disable Zoom support for the diagram */
    DiagramConstraints[DiagramConstraints["Zoom"] = 64] = "Zoom";
    /** Enables/Disable PanX support for the diagram */
    DiagramConstraints[DiagramConstraints["PanX"] = 128] = "PanX";
    /** Enables/Disable PanY support for the diagram */
    DiagramConstraints[DiagramConstraints["PanY"] = 256] = "PanY";
    /** Enables/Disable Pan support the diagram */
    DiagramConstraints[DiagramConstraints["Pan"] = 384] = "Pan";
    /** Enables/Disables zooming the text box while editing the text */
    DiagramConstraints[DiagramConstraints["ZoomTextEdit"] = 512] = "ZoomTextEdit";
    /** Enables/Disable Virtualization support the diagram */
    DiagramConstraints[DiagramConstraints["Virtualization"] = 1024] = "Virtualization";
    /** Enables/ Disable the line routing */
    DiagramConstraints[DiagramConstraints["LineRouting"] = 2048] = "LineRouting";
    /** Enables/Disables the line overlapping resolution globally in the diagram */
    DiagramConstraints[DiagramConstraints["AvoidLineOverlapping"] = 4096] = "AvoidLineOverlapping";
    /** Enables/Disable all constraints */
    DiagramConstraints[DiagramConstraints["Default"] = 500] = "Default";
})(DiagramConstraints || (DiagramConstraints = {}));
/**
 * Activates the diagram tools
 * None - Enables/Disable single select support for the diagram
 * SingleSelect - Enables/Disable single select support for the diagram
 * MultipleSelect - Enables/Disable MultipleSelect select support for the diagram
 * ZoomPan - Enables/Disable ZoomPan support for the diagram
 * DrawOnce - Enables/Disable continuousDraw support for the diagram
 * ContinuousDraw - Enables/Disable continuousDraw support for the diagram
 * Default - Enables/Disable all constraints
 *
 * @aspNumberEnum
 * @IgnoreSingular
 */
var DiagramTools;
(function (DiagramTools) {
    /** Disable all constraints */
    DiagramTools[DiagramTools["None"] = 0] = "None";
    /** Enables/Disable single select support for the diagram */
    DiagramTools[DiagramTools["SingleSelect"] = 1] = "SingleSelect";
    /** Enables/Disable MultipleSelect select support for the diagram */
    DiagramTools[DiagramTools["MultipleSelect"] = 2] = "MultipleSelect";
    /** Enables/Disable ZoomPan support for the diagram */
    DiagramTools[DiagramTools["ZoomPan"] = 4] = "ZoomPan";
    /** Enables/Disable DrawOnce support for the diagram */
    DiagramTools[DiagramTools["DrawOnce"] = 8] = "DrawOnce";
    /** Enables/Disable continuousDraw support for the diagram */
    DiagramTools[DiagramTools["ContinuousDraw"] = 16] = "ContinuousDraw";
    /** Enables/Disable all constraints */
    DiagramTools[DiagramTools["Default"] = 3] = "Default";
})(DiagramTools || (DiagramTools = {}));
/**
 * Defines the container/canvas transform
 * Self - Sets the transform type as Self
 * Parent - Sets the transform type as Parent
 */
var Transform;
(function (Transform) {
    /** Self - Sets the transform type as Self */
    Transform[Transform["Self"] = 1] = "Self";
    /** Parent - Sets the transform type as Parent */
    Transform[Transform["Parent"] = 2] = "Parent";
})(Transform || (Transform = {}));
/**
 * Defines the rendering mode for diagram
 * Canvas - Sets the rendering mode type as Canvas
 * Svg - Sets the rendering mode type as Svg
 */
var RenderMode;
(function (RenderMode) {
    /** Canvas - Sets the rendering mode type as Canvas */
    RenderMode[RenderMode["Canvas"] = 0] = "Canvas";
    /** Svg - Sets the rendering mode type as Svg */
    RenderMode[RenderMode["Svg"] = 1] = "Svg";
})(RenderMode || (RenderMode = {}));
/**
 * Sets a combination of key modifiers, on recognition of which the command will be executed.They are
 * * None - no modifiers are pressed
 * * Control - ctrl key
 * * Meta - meta key im mac
 * * Alt - alt key
 * * Shift - shift key
 *
 * @aspNumberEnum
 * @IgnoreSingular
 */
var KeyModifiers;
(function (KeyModifiers) {
    /** No modifiers are pressed */
    KeyModifiers[KeyModifiers["None"] = 0] = "None";
    /** The CTRL key */
    KeyModifiers[KeyModifiers["Control"] = 1] = "Control";
    /** The Meta key pressed in Mac */
    KeyModifiers[KeyModifiers["Meta"] = 1] = "Meta";
    /** The ALT key */
    KeyModifiers[KeyModifiers["Alt"] = 2] = "Alt";
    /** The Shift key */
    KeyModifiers[KeyModifiers["Shift"] = 4] = "Shift";
})(KeyModifiers || (KeyModifiers = {}));
/**
 * Sets the key value, on recognition of which the command will be executed. They are
 * * none - no key
 * * Number0 = The 0 key
 * * Number1 = The 1 key
 * * Number2 = The 2 key
 * * Number3 = The 3 key
 * * Number4 = The 4 key
 * * Number5 = The 5 key
 * * Number6 = The 6 key
 * * Number7 = The 7 key
 * * Number8 = The 8 key
 * * Number9 = The 9 key
 * * Number0 = The 0 key
 * * BackSpace = The BackSpace key
 * * F1 = The f1 key
 * * F2 = The f2 key
 * * F3 = The f3 key
 * * F4 = The f4 key
 * * F5 = The f5 key
 * * F6 = The f6 key
 * * F7 = The f7 key
 * * F8 = The f8 key
 * * F9 = The f9 key
 * * F10 = The f10 key
 * * F11 = The f11 key
 * * F12 = The f12 key
 * * A = The a key
 * * B = The b key
 * * C = The c key
 * * D = The d key
 * * E = The e key
 * * F = The f key
 * * G = The g key
 * * H = The h key
 * * I = The i key
 * * J = The j key
 * * K = The k key
 * * L = The l key
 * * M = The m key
 * * N = The n key
 * * O = The o key
 * * P = The p key
 * * Q = The q key
 * * R = The r key
 * * S = The s key
 * * T = The t key
 * * U = The u key
 * * V = The v key
 * * W = The w key
 * * X = The x key
 * * Y = The y key
 * * Z = The z key
 * * Left = The left key
 * * Right = The right key
 * * Top = The top key
 * * Bottom = The bottom key
 * * Escape = The Escape key
 * * Tab = The tab key
 * * Delete = The delete key
 * * Enter = The enter key
 * * The Space key
 * * The page up key
 * * The page down key
 * * The end key
 * * The home key
 * * The Minus
 * * The Plus
 * * The Star
 * * The Open Square Bracket
 * * The close Square Bracket
 *
 * @aspNumberEnum
 * @IgnoreSingular
 */
var Keys;
(function (Keys) {
    /** No key pressed */
    Keys[Keys["None"] = null] = "None";
    /** The 0 key */
    Keys[Keys["Number0"] = 0] = "Number0";
    /** The 1 key */
    Keys[Keys["Number1"] = 1] = "Number1";
    /** The 2 key */
    Keys[Keys["Number2"] = 2] = "Number2";
    /** The 3 key */
    Keys[Keys["Number3"] = 3] = "Number3";
    /** The 4 key */
    Keys[Keys["Number4"] = 4] = "Number4";
    /** The 5 key */
    Keys[Keys["Number5"] = 5] = "Number5";
    /** The 6 key */
    Keys[Keys["Number6"] = 6] = "Number6";
    /** The 7 key */
    Keys[Keys["Number7"] = 7] = "Number7";
    /** The 8 key */
    Keys[Keys["Number8"] = 8] = "Number8";
    /** The 9 key */
    Keys[Keys["Number9"] = 9] = "Number9";
    /** The A key */
    Keys[Keys["A"] = 65] = "A";
    /** The B key */
    Keys[Keys["B"] = 66] = "B";
    /** The C key */
    Keys[Keys["C"] = 67] = "C";
    /** The D key */
    Keys[Keys["D"] = 68] = "D";
    /** The E key */
    Keys[Keys["E"] = 69] = "E";
    /** The F key */
    Keys[Keys["F"] = 70] = "F";
    /** The G key */
    Keys[Keys["G"] = 71] = "G";
    /** The H key */
    Keys[Keys["H"] = 72] = "H";
    /** The I key */
    Keys[Keys["I"] = 73] = "I";
    /** The J key */
    Keys[Keys["J"] = 74] = "J";
    /** The K key */
    Keys[Keys["K"] = 75] = "K";
    /** The L key */
    Keys[Keys["L"] = 76] = "L";
    /** The M key */
    Keys[Keys["M"] = 77] = "M";
    /** The N key */
    Keys[Keys["N"] = 78] = "N";
    /** The O key */
    Keys[Keys["O"] = 79] = "O";
    /** The P key */
    Keys[Keys["P"] = 80] = "P";
    /** The Q key */
    Keys[Keys["Q"] = 81] = "Q";
    /** The R key */
    Keys[Keys["R"] = 82] = "R";
    /** The S key */
    Keys[Keys["S"] = 83] = "S";
    /** The T key */
    Keys[Keys["T"] = 84] = "T";
    /** The U key */
    Keys[Keys["U"] = 85] = "U";
    /** The V key */
    Keys[Keys["V"] = 86] = "V";
    /** The W key */
    Keys[Keys["W"] = 87] = "W";
    /** The X key */
    Keys[Keys["X"] = 88] = "X";
    /** The Y key */
    Keys[Keys["Y"] = 89] = "Y";
    /** The Z key */
    Keys[Keys["Z"] = 90] = "Z";
    /** The left arrow key */
    Keys[Keys["Left"] = 37] = "Left";
    /** The up arrow key */
    Keys[Keys["Up"] = 38] = "Up";
    /** The right arrow key */
    Keys[Keys["Right"] = 39] = "Right";
    /** The down arrow key */
    Keys[Keys["Down"] = 40] = "Down";
    /** The Escape key */
    Keys[Keys["Escape"] = 27] = "Escape";
    /** The Space key */
    Keys[Keys["Space"] = 32] = "Space";
    /** The page up key */
    Keys[Keys["PageUp"] = 33] = "PageUp";
    /** The Space key */
    Keys[Keys["PageDown"] = 34] = "PageDown";
    /** The Space key */
    Keys[Keys["End"] = 35] = "End";
    /** The Space key */
    Keys[Keys["Home"] = 36] = "Home";
    /** The delete key */
    Keys[Keys["Delete"] = 46] = "Delete";
    /** The tab key */
    Keys[Keys["Tab"] = 9] = "Tab";
    /** The enter key */
    Keys[Keys["Enter"] = 13] = "Enter";
    /** The BackSpace key */
    Keys[Keys["BackSpace"] = 8] = "BackSpace";
    /** The F1 key */
    Keys[Keys["F1"] = 112] = "F1";
    /** The F2 key */
    Keys[Keys["F2"] = 113] = "F2";
    /** The F3 key */
    Keys[Keys["F3"] = 114] = "F3";
    /** The F4 key */
    Keys[Keys["F4"] = 115] = "F4";
    /** The F5 key */
    Keys[Keys["F5"] = 116] = "F5";
    /** The F6 key */
    Keys[Keys["F6"] = 117] = "F6";
    /** The F7 key */
    Keys[Keys["F7"] = 118] = "F7";
    /** The F8 key */
    Keys[Keys["F8"] = 119] = "F8";
    /** The F9 key */
    Keys[Keys["F9"] = 120] = "F9";
    /** The F10 key */
    Keys[Keys["F10"] = 121] = "F10";
    /** The F111 key */
    Keys[Keys["F11"] = 122] = "F11";
    /** The F12 key */
    Keys[Keys["F12"] = 123] = "F12";
    /** The Star */
    Keys[Keys["Star"] = 56] = "Star";
    /** The Plus */
    Keys[Keys["Plus"] = 187] = "Plus";
    /** The Minus */
    Keys[Keys["Minus"] = 189] = "Minus";
    /** The Open Square bracket */
    Keys[Keys["BracketLeft"] = 219] = "BracketLeft";
    /** The close Square bracket */
    Keys[Keys["BracketRight"] = 221] = "BracketRight";
})(Keys || (Keys = {}));
/**
 * Enables/Disables certain actions of diagram
 * * Render - Indicates the diagram is in render state.
 * * PublicMethod - Indicates the diagram public method is in action.
 * * ToolAction - Indicates the diagram Tool is in action.
 * * UndoRedo - Indicates the diagram undo/redo is in action.
 * * TextEdit - Indicates the text editing is in progress.
 * * Group - Indicates the group is in progress.
 * * Clear - Indicates diagram have clear all.
 * * PreventClearSelection - prevents diagram from clear selection
 */
var DiagramAction;
(function (DiagramAction) {
    /** Indicates the diagram is in render state.r */
    DiagramAction[DiagramAction["Render"] = 2] = "Render";
    /** Indicates the diagram public method is in action. */
    DiagramAction[DiagramAction["PublicMethod"] = 4] = "PublicMethod";
    /** Indicates the diagram Tool is in action. */
    DiagramAction[DiagramAction["ToolAction"] = 8] = "ToolAction";
    /** Indicates the diagram undo/redo is in action. */
    DiagramAction[DiagramAction["UndoRedo"] = 16] = "UndoRedo";
    /** Indicates the text editing is in progress. */
    DiagramAction[DiagramAction["TextEdit"] = 32] = "TextEdit";
    /** Indicates the group is in progress. */
    DiagramAction[DiagramAction["Group"] = 64] = "Group";
    /** Indicates diagram have clear all. */
    DiagramAction[DiagramAction["Clear"] = 128] = "Clear";
    /** prevents diagram from clear selection. */
    DiagramAction[DiagramAction["PreventClearSelection"] = 256] = "PreventClearSelection";
    /** Indicates whether drag or rotate tool has been activated */
    DiagramAction[DiagramAction["Interactions"] = 512] = "Interactions";
    /** Use to prevent the history during some action in diagram */
    DiagramAction[DiagramAction["PreventHistory"] = 1024] = "PreventHistory";
    /** Use to prevent the icon while expand a node in diagram */
    DiagramAction[DiagramAction["PreventIconsUpdate"] = 2048] = "PreventIconsUpdate";
    /** Use to prevent the collection change event while dragging lane from palette and over it in diagram */
    DiagramAction[DiagramAction["PreventCollectionChangeOnDragOver"] = 4096] = "PreventCollectionChangeOnDragOver";
    /** Use to prevent the z order on dragging the diagram elements */
    DiagramAction[DiagramAction["PreventZIndexOnDragging"] = 8192] = "PreventZIndexOnDragging";
    /** Indicates whether group dragging has been activated */
    DiagramAction[DiagramAction["isGroupDragging"] = 16384] = "isGroupDragging";
    /** Indicates whether drag is initiated by mouse  */
    DiagramAction[DiagramAction["DragUsingMouse"] = 32768] = "DragUsingMouse";
    /** Indicates whether decorator property is changed or not */
    DiagramAction[DiagramAction["DecoratorPropertyChange"] = 65536] = "DecoratorPropertyChange";
    /** Avoid dropping of child nodes into the swim lane */
    DiagramAction[DiagramAction["PreventLaneContainerUpdate"] = 131072] = "PreventLaneContainerUpdate";
})(DiagramAction || (DiagramAction = {}));
/**
 * Defines the Selector type to be drawn
 * None - Draws Normal selector with resize handles
 * Symbol - Draws only the rectangle for the selector
 */
var RendererAction;
(function (RendererAction) {
    /** None - Draws Normal selector with resize handles */
    RendererAction[RendererAction["None"] = 2] = "None";
    /** DrawSelectorBorder - Draws only the Border for the selector */
    RendererAction[RendererAction["DrawSelectorBorder"] = 4] = "DrawSelectorBorder";
    /** PreventRenderSelector - Avoid the render of selector during interaction */
    RendererAction[RendererAction["PreventRenderSelector"] = 8] = "PreventRenderSelector";
})(RendererAction || (RendererAction = {}));
var RealAction;
(function (RealAction) {
    RealAction[RealAction["None"] = 0] = "None";
    RealAction[RealAction["PreventDrag"] = 2] = "PreventDrag";
    RealAction[RealAction["PreventScale"] = 4] = "PreventScale";
    RealAction[RealAction["PreventDataInit"] = 8] = "PreventDataInit";
    /** Indicates when the diagram is scrolled horizontal using scroll bar */
    RealAction[RealAction["hScrollbarMoved"] = 16] = "hScrollbarMoved";
    /** Indicates when the diagram is scrolled vertical using scroll bar */
    RealAction[RealAction["vScrollbarMoved"] = 32] = "vScrollbarMoved";
    /** Indicates whether animation happens or not  */
    RealAction[RealAction["AnimationClick"] = 64] = "AnimationClick";
    /** Enable the group action */
    RealAction[RealAction["EnableGroupAction"] = 128] = "EnableGroupAction";
    /** Indicate action in Progress */
    RealAction[RealAction["PanInProgress"] = 256] = "PanInProgress";
    /** Indicate overview action  */
    RealAction[RealAction["OverViewAction"] = 512] = "OverViewAction";
})(RealAction || (RealAction = {}));
/** @private */
var ScrollActions;
(function (ScrollActions) {
    ScrollActions[ScrollActions["None"] = 0] = "None";
    /** Indicates when the scroll properties are changed using property change */
    ScrollActions[ScrollActions["PropertyChange"] = 1024] = "PropertyChange";
    /** Indicates when the scroll properties are changed using interaction */
    ScrollActions[ScrollActions["Interaction"] = 2048] = "Interaction";
})(ScrollActions || (ScrollActions = {}));
/** @private */
var NoOfSegments;
(function (NoOfSegments) {
    NoOfSegments[NoOfSegments["Zero"] = 0] = "Zero";
    NoOfSegments[NoOfSegments["One"] = 1] = "One";
    NoOfSegments[NoOfSegments["Two"] = 2] = "Two";
    NoOfSegments[NoOfSegments["Three"] = 3] = "Three";
    NoOfSegments[NoOfSegments["Four"] = 4] = "Four";
    NoOfSegments[NoOfSegments["Five"] = 5] = "Five";
})(NoOfSegments || (NoOfSegments = {}));
/**
 * events of diagram
 *
 * @private
 */
var DiagramEvent;
(function (DiagramEvent) {
    DiagramEvent[DiagramEvent["collectionChange"] = 0] = "collectionChange";
    DiagramEvent[DiagramEvent["rotateChange"] = 1] = "rotateChange";
    DiagramEvent[DiagramEvent["positionChange"] = 2] = "positionChange";
    DiagramEvent[DiagramEvent["propertyChange"] = 3] = "propertyChange";
    DiagramEvent[DiagramEvent["selectionChange"] = 4] = "selectionChange";
    DiagramEvent[DiagramEvent["sizeChange"] = 5] = "sizeChange";
    DiagramEvent[DiagramEvent["drop"] = 6] = "drop";
    DiagramEvent[DiagramEvent["sourcePointChange"] = 7] = "sourcePointChange";
    DiagramEvent[DiagramEvent["targetPointChange"] = 8] = "targetPointChange";
    DiagramEvent[DiagramEvent["connectionChange"] = 9] = "connectionChange";
    DiagramEvent[DiagramEvent["animationComplete"] = 10] = "animationComplete";
    DiagramEvent[DiagramEvent["click"] = 11] = "click";
    DiagramEvent[DiagramEvent["doubleClick"] = 12] = "doubleClick";
    DiagramEvent[DiagramEvent["scrollChange"] = 13] = "scrollChange";
    DiagramEvent[DiagramEvent["dragEnter"] = 14] = "dragEnter";
    DiagramEvent[DiagramEvent["dragLeave"] = 15] = "dragLeave";
    DiagramEvent[DiagramEvent["dragOver"] = 16] = "dragOver";
    DiagramEvent[DiagramEvent["textEdit"] = 17] = "textEdit";
    DiagramEvent[DiagramEvent["paletteSelectionChange"] = 18] = "paletteSelectionChange";
    DiagramEvent[DiagramEvent["historyChange"] = 19] = "historyChange";
    DiagramEvent[DiagramEvent["mouseEnter"] = 20] = "mouseEnter";
    DiagramEvent[DiagramEvent["mouseLeave"] = 21] = "mouseLeave";
    DiagramEvent[DiagramEvent["mouseOver"] = 22] = "mouseOver";
    DiagramEvent[DiagramEvent["expandStateChange"] = 23] = "expandStateChange";
    DiagramEvent[DiagramEvent["segmentCollectionChange"] = 24] = "segmentCollectionChange";
    DiagramEvent[DiagramEvent["commandExecute"] = 25] = "commandExecute";
    DiagramEvent[DiagramEvent["historyStateChange"] = 26] = "historyStateChange";
    DiagramEvent[DiagramEvent["onUserHandleMouseDown"] = 27] = "onUserHandleMouseDown";
    DiagramEvent[DiagramEvent["onUserHandleMouseUp"] = 28] = "onUserHandleMouseUp";
    DiagramEvent[DiagramEvent["onUserHandleMouseEnter"] = 29] = "onUserHandleMouseEnter";
    DiagramEvent[DiagramEvent["onUserHandleMouseLeave"] = 30] = "onUserHandleMouseLeave";
    DiagramEvent[DiagramEvent["onImageLoad"] = 31] = "onImageLoad";
    DiagramEvent[DiagramEvent["onDoBindingInit"] = 32] = "onDoBindingInit";
    DiagramEvent[DiagramEvent["keyUp"] = 33] = "keyUp";
    DiagramEvent[DiagramEvent["keyDown"] = 34] = "keyDown";
    DiagramEvent[DiagramEvent["fixedUserHandleClick"] = 35] = "fixedUserHandleClick";
    DiagramEvent[DiagramEvent["elementDraw"] = 36] = "elementDraw";
    DiagramEvent[DiagramEvent["mouseWheel"] = 37] = "mouseWheel";
    DiagramEvent[DiagramEvent["segmentChange"] = 38] = "segmentChange";
    DiagramEvent[DiagramEvent["onFixedUserHandleMouseDown"] = 39] = "onFixedUserHandleMouseDown";
    DiagramEvent[DiagramEvent["onFixedUserHandleMouseUp"] = 40] = "onFixedUserHandleMouseUp";
    DiagramEvent[DiagramEvent["onFixedUserHandleMouseEnter"] = 41] = "onFixedUserHandleMouseEnter";
    DiagramEvent[DiagramEvent["onFixedUserHandleMouseLeave"] = 42] = "onFixedUserHandleMouseLeave";
    DiagramEvent[DiagramEvent["loaded"] = 43] = "loaded";
    DiagramEvent[DiagramEvent["layoutUpdated"] = 44] = "layoutUpdated";
})(DiagramEvent || (DiagramEvent = {}));
/** Enables/Disables certain features of port connection
 *
 * @aspNumberEnum
 * @IgnoreSingular
 */
var PortConstraints;
(function (PortConstraints) {
    /** Disable all constraints  */
    PortConstraints[PortConstraints["None"] = 1] = "None";
    /** Enables connections with connector  */
    PortConstraints[PortConstraints["Drag"] = 2] = "Drag";
    /** Enables to create the connection when mouse hover on the port  */
    PortConstraints[PortConstraints["Draw"] = 4] = "Draw";
    /** Enables to only connect the target end of connector */
    PortConstraints[PortConstraints["InConnect"] = 8] = "InConnect";
    /** Enables to only connect the source end of connector */
    PortConstraints[PortConstraints["OutConnect"] = 16] = "OutConnect";
    /**Enables or disables the Tooltip  for the ports*/
    PortConstraints[PortConstraints["ToolTip"] = 32] = "ToolTip";
    /** Enables or disables the Tooltip for the ports */
    PortConstraints[PortConstraints["InheritTooltip"] = 64] = "InheritTooltip";
    /** Enables all constraints */
    PortConstraints[PortConstraints["Default"] = 24] = "Default";
})(PortConstraints || (PortConstraints = {}));
/**
 * Defines the context menu click
 * contextMenuClick - Sets the context menu click as contextMenuClick
 */
var contextMenuClick = 
/** contextMenuClick - Sets the context menu click as contextMenuClick */
'contextMenuClick';
/**
 * Defines the context menu open
 * contextMenuOpen - Sets the context menu open as contextMenuOpen
 */
var contextMenuOpen = 
/** contextMenuOpen - Sets the context menu open as contextMenuOpen */
'contextMenuOpen';
/**
 * Defines the context menu Before Item Render
 * contextMenuBeforeItemRender - Sets the context menu open as contextMenuBeforeItemRender
 */
var contextMenuBeforeItemRender = 
/** contextMenuBeforeItemRender - Sets the context menu open as contextMenuBeforeItemRender */
'contextMenuBeforeItemRender';
/**
 * Defines the visibility of the control points in the Bezier connector
 */
var ControlPointsVisibility;
(function (ControlPointsVisibility) {
    /** None - Hides all the control points of the Bezier connector*/
    ControlPointsVisibility[ControlPointsVisibility["None"] = 1] = "None";
    /** Source - Shows the source control point*/
    ControlPointsVisibility[ControlPointsVisibility["Source"] = 2] = "Source";
    /** Target - Shows the target control point*/
    ControlPointsVisibility[ControlPointsVisibility["Target"] = 4] = "Target";
    /** Intermediate - Shows the intermediate control points*/
    ControlPointsVisibility[ControlPointsVisibility["Intermediate"] = 8] = "Intermediate";
    /** All - Shows all the control points of the Bezier connector*/
    ControlPointsVisibility[ControlPointsVisibility["All"] = 14] = "All";
})(ControlPointsVisibility || (ControlPointsVisibility = {}));
var BezierSmoothness;
(function (BezierSmoothness) {
    /** Disable all smoothness Constraints. */
    BezierSmoothness[BezierSmoothness["None"] = 0] = "None";
    /** Enables the  SymmetricAngle for a bezier segment to the angle between the control point as same. */
    BezierSmoothness[BezierSmoothness["SymmetricAngle"] = 2] = "SymmetricAngle";
    /** Enables the SymmetricDistance for bezier segment to the distance between the control point as same. */
    BezierSmoothness[BezierSmoothness["SymmetricDistance"] = 4] = "SymmetricDistance";
    /** Enables the symmetric for bezier segment to the distance and angle between the control point as same. */
    BezierSmoothness[BezierSmoothness["Default"] = 6] = "Default";
})(BezierSmoothness || (BezierSmoothness = {}));

/**
 * DiagramElement module defines the basic unit of diagram
 */
var DiagramElement = /** @class */ (function () {
    function DiagramElement() {
        /**
         * Sets/Gets the reference point of the element
         * ```html
         * <div id='diagram'></div>
         * ```
         * ```typescript
         * let stackPanel: StackPanel = new StackPanel();
         * stackPanel.offsetX = 300; stackPanel.offsetY = 200;
         * stackPanel.width = 100; stackPanel.height = 100;
         * stackPanel.style.fill = 'red';
         * stackPanel.pivot = { x: 0.5, y: 0.5 };
         * let diagram: Diagram = new Diagram({
         * ...
         * basicElements: [stackPanel],
         * ...
         * });
         * diagram.appendTo('#diagram');
         * ```
         */
        this.pivot = { x: 0.5, y: 0.5 };
        /**
         * Sets or gets whether the content of the element needs to be measured
         */
        this.isDirt = true;
        /**
         * set to true during print and eport
         */
        /** @private */
        this.isExport = false;
        /**
         * set scaling value for print and export
         */
        /** @private */
        this.exportScaleValue = { x: 0, y: 0 };
        /**
         * set scaling value for print and export
         */
        /** @private */
        this.exportScaleOffset = { x: 0, y: 0 };
        /**
         * Check whether style need to be apply or not
         */
        /** @private */
        this.canApplyStyle = true;
        /**
         * Sets or gets whether the content of the element to be visible
         */
        this.visible = true;
        /**
         * Sets/Gets the x-coordinate of the element
         */
        this.offsetX = 0;
        /**
         * Sets/Gets the y-coordinate of the element
         */
        this.offsetY = 0;
        /**
         * Set the corner of the element
         */
        this.cornerRadius = 0;
        /**
         * Sets/Gets the minimum height of the element
         */
        this.minHeight = undefined;
        /**
         * Sets/Gets the minimum width of the element
         */
        this.minWidth = undefined;
        /**
         * Sets/Gets the maximum width of the element
         */
        this.maxWidth = undefined;
        /**
         * Sets/Gets the maximum height of the element
         */
        this.maxHeight = undefined;
        /**
         * Sets/Gets the width of the element
         */
        this.width = undefined;
        /**
         * Sets/Gets the height of the element
         */
        this.height = undefined;
        /**
         * Sets/Gets the rotate angle of the element
         */
        this.rotateAngle = 0;
        /**
         * Sets/Gets the margin of the element
         */
        this.margin = { left: 0, right: 0, top: 0, bottom: 0 };
        /**
         * Sets/Gets the allowed direction for connections to the port
         */
        this.connectionDirection = 'Auto';
        /**
         * Sets/Gets how the element has to be horizontally arranged with respect to its immediate parent
         * * Stretch - Stretches the diagram element throughout its immediate parent
         * * Left - Aligns the diagram element at the left of its immediate parent
         * * Right - Aligns the diagram element at the right of its immediate parent
         * * Center - Aligns the diagram element at the center of its immediate parent
         * * Auto - Aligns the diagram element based on the characteristics of its immediate parent
         */
        this.horizontalAlignment = 'Auto';
        /**
         * Sets/Gets how the element has to be vertically arranged with respect to its immediate parent
         * * Stretch - Stretches the diagram element throughout its immediate parent
         * * Top - Aligns the diagram element at the top of its immediate parent
         * * Bottom - Aligns the diagram element at the bottom of its immediate parent
         * * Center - Aligns the diagram element at the center of its immediate parent
         * * Auto - Aligns the diagram element based on the characteristics of its immediate parent
         */
        this.verticalAlignment = 'Auto';
        /**
         * Sets/Gets the mirror image of diagram element in both horizontal and vertical directions
         * * FlipHorizontal - Translate the diagram element throughout its immediate parent
         * * FlipVertical - Rotate the diagram element throughout its immediate parent
         */
        this.flip = FlipDirection.None;
        /**
         * Sets/Gets the element that is to be flipped in assigned flip direction along with the node
         */
        this.flipMode = 'All';
        /**
         * Sets whether the element has to be aligned with respect to a point/with respect to its immediate parent
         * * Point - Diagram elements will be aligned with respect to a point
         * * Object - Diagram elements will be aligned with respect to its immediate parent
         */
        this.relativeMode = 'Point';
        /**
         * Sets whether the element has to be transformed based on its parent or not
         * * Self - Sets the transform type as Self
         * * Parent - Sets the transform type as Parent
         */
        this.transform = Transform.Self | Transform.Parent;
        /**
         * Sets the style of the element
         */
        this.style = { fill: 'white', strokeColor: 'black', opacity: 1, strokeWidth: 1 };
        /**
         * Gets the minimum size that is required by the element
         */
        this.desiredSize = new Size();
        /**
         * Gets the size that the element will be rendered
         */
        this.actualSize = new Size();
        /**
         * Gets the rotate angle that is set to the immediate parent of the element
         */
        this.parentTransform = 0;
        /** @private */
        this.preventContainer = false;
        /**
         * Gets/Set the boolean value for the element
         */
        this.isSvgRender = false;
        /**
         * Gets/Sets the boundary of the element
         */
        this.bounds = new Rect(0, 0, 0, 0);
        /**
         * Defines the appearance of the shadow of the element
         */
        this.shadow = null;
        /**
         * Defines the description of the diagram element
         */
        this.description = '';
        /**
         * Defines whether the element has to be measured or not
         */
        this.staticSize = false;
        /**
         * Defines the shape of the diagram element
         */
        this.shapeType = '';
        /**
         * check whether the element is rect or not
         */
        this.isRectElement = false;
        /** @private */
        this.isCalculateDesiredSize = true;
        /**
         * Set the offset values for container in flipping
         */
        /** @private */
        this.flipOffset = { x: 0, y: 0 };
        /**
         * Defines whether the element is group or port
         */
        /** @private */
        this.elementActions = ElementAction.None;
        /** @private */
        this.inversedAlignment = true;
        //private variables
        this.position = undefined;
        this.unitMode = undefined;
        /**   @private  */
        this.float = false;
        this.floatingBounds = undefined;
    }
    // public constructor() {
    //     this.id = randomId();
    // }
    /**
     * Sets the offset of the element with respect to its parent \
     *
     * @returns { void }Sets the offset of the element with respect to its parent\
     * @param {number} x - provide the x value.
     * @param {number} y - provide the y value.
     * @param {UnitMode} mode - provide the id value.
     *
     * @private
     */
    DiagramElement.prototype.setOffsetWithRespectToBounds = function (x, y, mode) {
        this.unitMode = mode;
        this.position = { x: x, y: y };
    };
    /**
     * Gets the position of the element with respect to its parent \
     *
     * @returns { PointModel } Gets the position of the element with respect to its parent\
     * @param {Size} size - provide the x value.
     *
     * @private
     */
    DiagramElement.prototype.getAbsolutePosition = function (size) {
        if (this.position !== undefined) {
            if (this.unitMode === 'Absolute') {
                return this.position;
            }
            else {
                return {
                    x: this.position.x * size.width, y: this.position.y * size.height
                };
            }
        }
        return undefined;
    };
    Object.defineProperty(DiagramElement.prototype, "outerBounds", {
        get: function () {
            return this.floatingBounds || this.bounds;
        },
        /**
         * used to set the outer bounds value \
         *
         * @returns { void } used to set the outer bounds value.\
         * @param {Rect} bounds - provide the id value.
         *
         * @private
         */
        set: function (bounds) {
            this.floatingBounds = bounds;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Measures the minimum space that the element requires \
     *
     * @returns { void } Measures the minimum space that the element requires.\
     * @param {Size} availableSize - provide the id value.
     * @param {Object} obj - provide the id value.
     * @param {Function} callback - provide the id value.
     *
     * @private
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    DiagramElement.prototype.measure = function (availableSize, obj, callback) {
        var width = this.width !== undefined ? this.width : (availableSize.width || 0) - this.margin.left - this.margin.right;
        var height = this.height !== undefined ? this.height : (availableSize.height || 0) - this.margin.top - this.margin.bottom;
        if (this.id) {
            if (height === 0 && (this.elementActions & ElementAction.HorizontalLaneHeader)) {
                height = this.actualSize.height;
            }
        }
        this.desiredSize = new Size(width, height);
        if (this.isCalculateDesiredSize) {
            this.desiredSize = this.validateDesiredSize(this.desiredSize, availableSize);
        }
        return this.desiredSize;
    };
    /**
     * Arranges the element \
     *
     * @returns { PointModel } Arranges the element\
     * @param {Size} desiredSize - provide the x value.
     *
     * @private
     */
    DiagramElement.prototype.arrange = function (desiredSize) {
        this.actualSize = desiredSize;
        this.updateBounds();
        return this.actualSize;
    };
    /**
     * Updates the bounds of the element \
     *
     * @returns { void } Updates the bounds of the element\
     *
     * @private
     */
    DiagramElement.prototype.updateBounds = function () {
        this.bounds = getBounds(this);
    };
    /**
     * Validates the size of the element with respect to its minimum and maximum size \
     *
     * @returns { Size } Validates the size of the element with respect to its minimum and maximum size.\
     * @param {Size} desiredSize - provide the id value.
     * @param {Size} availableSize - provide the id value.
     *
     * @private
     */
    DiagramElement.prototype.validateDesiredSize = function (desiredSize, availableSize) {
        //Empty canvas
        if (this.isRectElement && !this.width && !this.minWidth && !this.maxWidth) {
            desiredSize.width = 50;
        }
        if (this.isRectElement && !this.height && !this.minHeight && !this.maxHeight) {
            desiredSize.height = 50;
        }
        if (desiredSize === undefined || this.width !== undefined &&
            this.height !== undefined) {
            desiredSize = desiredSize || new Size();
            desiredSize.width = this.width === undefined ? (availableSize.width || 0)
                - this.margin.left - this.margin.right : this.width;
            desiredSize.height = this.height === undefined ? (availableSize.height || 0)
                - this.margin.top - this.margin.bottom : this.height;
        }
        //Considering min values
        if (this.minWidth !== undefined) {
            desiredSize.width = Math.max(desiredSize.width, this.minWidth);
        }
        if (this.minHeight !== undefined) {
            desiredSize.height = Math.max(desiredSize.height, this.minHeight);
        }
        //Considering max values
        if (this.maxWidth !== undefined && this.maxWidth !== 0) {
            desiredSize.width = Math.min(desiredSize.width, this.maxWidth);
        }
        if (this.maxHeight !== undefined && this.maxHeight !== 0) {
            desiredSize.height = Math.min(desiredSize.height, this.maxHeight);
        }
        return desiredSize;
    };
    return DiagramElement;
}());

var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Container module is used to group related objects
 */
var Container = /** @class */ (function (_super) {
    __extends$2(Container, _super);
    function Container() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Gets/Sets the space between the container and its immediate children
         */
        _this.padding = new Thickness(0, 0, 0, 0);
        //private members
        _this.desiredBounds = undefined;
        /** @private */
        _this.measureChildren = true;
        /**   @private  */
        _this.prevRotateAngle = 0;
        return _this;
    }
    /**
     * returns whether the container has child elements or not
     */
    Container.prototype.hasChildren = function () {
        if (this.children !== undefined && this.children.length > 0) {
            return true;
        }
        return false;
    };
    /**
     * Measures the minimum space that the container requires
     *
     * @param {Size} availableSize
     * @param {string} id
     * @param {Function} callback
     */
    Container.prototype.measure = function (availableSize, id, callback) {
        // measure the element and find the desired size
        this.desiredBounds = undefined;
        var desired = undefined;
        var child;
        var childBounds;
        if (this.hasChildren()) {
            //Measuring the children
            for (var i = 0; i < this.children.length; i++) {
                child = this.children[parseInt(i.toString(), 10)];
                if (child.horizontalAlignment === 'Stretch' && !availableSize.width) {
                    availableSize.width = child.bounds.width;
                }
                if (child.verticalAlignment === 'Stretch' && !availableSize.height) {
                    availableSize.height = child.bounds.height;
                }
                var force = child.horizontalAlignment === 'Stretch' || child.verticalAlignment === 'Stretch';
                if (this.measureChildren || force || (child instanceof Container && child.measureChildren !== undefined)) {
                    child.measure(availableSize, id, callback);
                }
                childBounds = this.GetChildrenBounds(child);
                if (child.horizontalAlignment !== 'Stretch' && child.verticalAlignment !== 'Stretch') {
                    if (this.desiredBounds === undefined) {
                        this.desiredBounds = childBounds;
                    }
                    else {
                        this.desiredBounds.uniteRect(childBounds);
                    }
                }
                else if (this.actualSize && !this.actualSize.width && !this.actualSize.height &&
                    !child.preventContainer && child.horizontalAlignment === 'Stretch' && child.verticalAlignment === 'Stretch') {
                    if (this.desiredBounds === undefined) {
                        this.desiredBounds = child.bounds;
                    }
                    else {
                        this.desiredBounds.uniteRect(child.bounds);
                    }
                }
            }
            if (this.desiredBounds !== undefined && this.rotateAngle !== 0) {
                var offsetPt = {
                    x: this.desiredBounds.x + this.desiredBounds.width * this.pivot.x,
                    y: this.desiredBounds.y + this.desiredBounds.height * this.pivot.y
                };
                var newPoint = rotatePoint(this.rotateAngle, undefined, undefined, offsetPt);
                this.desiredBounds.x = newPoint.x - this.desiredBounds.width * this.pivot.x;
                this.desiredBounds.y = newPoint.y - this.desiredBounds.height * this.pivot.y;
            }
            /**
             * Adding padding to the group bounds during initial rendering and for the group selection
             */
            if (this.desiredBounds !== undefined) {
                this.desiredBounds.width += this.padding.left + this.padding.right;
                this.desiredBounds.height += this.padding.top + this.padding.bottom;
                this.desiredBounds.x -= this.padding.left;
                this.desiredBounds.y -= this.padding.top;
            }
            if (this.desiredBounds) {
                desired = new Size(this.desiredBounds.width, this.desiredBounds.height);
            }
        }
        desired = this.validateDesiredSize(desired, availableSize);
        this.stretchChildren(desired);
        this.desiredSize = desired;
        return desired;
    };
    /**
     * Arranges the container and its children
     *
     * @param {Size} desiredSize  - provide the desiredSize value
     */
    Container.prototype.arrange = function (desiredSize) {
        var child;
        var childBounds = this.desiredBounds;
        if (childBounds) {
            var x = this.offsetX;
            var y = this.offsetY;
            this.offsetX = childBounds.x + childBounds.width * this.pivot.x;
            this.offsetY = childBounds.y + childBounds.height * this.pivot.y;
            // container has rotateAngle
            if (this.hasChildren()) {
                //Measuring the children
                for (var i = 0; i < this.children.length; i++) {
                    child = this.children[parseInt(i.toString(), 10)];
                    var arrange = false;
                    if (child.horizontalAlignment === 'Stretch') {
                        child.offsetX = this.offsetX;
                        child.parentTransform = this.parentTransform + this.rotateAngle;
                        if (this.flip && (this.elementActions & ElementAction.ElementIsGroup)) {
                            child.parentTransform = (this.flip === FlipDirection.Horizontal || this.flip === FlipDirection.Vertical) ?
                                -child.parentTransform : child.parentTransform;
                        }
                        arrange = true;
                    }
                    if (child.verticalAlignment === 'Stretch') {
                        child.offsetY = this.offsetY;
                        child.parentTransform = this.parentTransform + this.rotateAngle;
                        arrange = true;
                    }
                    if (arrange || this.measureChildren || (child instanceof Container && child.measureChildren !== undefined)) {
                        child.arrange(child.desiredSize);
                    }
                    //EJ2-839298 - Connector draw cursor is not enabled while hover the group node port
                    //EJ2-909503-Annotation for the group is behind its internal nodes
                    if (i === 0) {
                        var childBounds_1 = child.outerBounds;
                        this.outerBounds = new Rect(childBounds_1.x, childBounds_1.y, childBounds_1.width, childBounds_1.height);
                    }
                    else {
                        this.outerBounds.uniteRect(child.outerBounds);
                    }
                }
            }
        }
        this.actualSize = desiredSize;
        this.updateBounds();
        this.prevRotateAngle = this.rotateAngle;
        return desiredSize;
    };
    //protected methods
    /**
     * Stretches the child elements based on the size of the container
     *
     * @param {Size} size  - provide the size value
     */
    Container.prototype.stretchChildren = function (size) {
        if (this.hasChildren()) {
            for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child.horizontalAlignment === 'Stretch' || child.desiredSize.width === undefined) {
                    child.desiredSize.width = size.width - child.margin.left - child.margin.right;
                }
                if (child.verticalAlignment === 'Stretch' || child.desiredSize.height === undefined) {
                    child.desiredSize.height = size.height - child.margin.top - child.margin.bottom;
                }
                if (child instanceof Container) {
                    child.stretchChildren(child.desiredSize);
                }
            }
        }
    };
    /**
     * Considers the padding of the element when measuring its desired size
     * @param {Size} size - provide the size value
     */
    Container.prototype.applyPadding = function (size) {
        size.width += this.padding.left + this.padding.right;
        size.height += this.padding.top + this.padding.bottom;
    };
    /**
     * Finds the offset of the child element with respect to the container
     *
     * @param {DiagramElement} child - provide the child value
     * @param {PointModel} center - provide the center value
     */
    Container.prototype.findChildOffsetFromCenter = function (child, center) {
        var topLeft = { x: center.x - child.desiredSize.width / 2, y: center.y - child.desiredSize.height / 2 };
        var offset = getOffset(topLeft, child);
        //Rotate based on child rotate angle
        offset = rotatePoint(child.rotateAngle, center.x, center.y, offset);
        //Rotate based on parent pivot
        offset = rotatePoint(this.rotateAngle + this.parentTransform, this.offsetX, this.offsetY, offset);
        child.offsetX = offset.x;
        child.offsetY = offset.y;
    };
    //private methods - check its need
    Container.prototype.GetChildrenBounds = function (child) {
        var childSize = child.desiredSize.clone();
        var diffAngle = child.rotateAngle - this.rotateAngle;
        var refPoint = { x: child.offsetX, y: child.offsetY };
        var left = refPoint.x - childSize.width * child.pivot.x;
        var top = refPoint.y - childSize.height * child.pivot.y;
        var right = left + childSize.width;
        var bottom = top + childSize.height;
        var topLeft = { x: left, y: top };
        var topRight = { x: right, y: top };
        var bottomLeft = { x: left, y: bottom };
        var bottomRight = { x: right, y: bottom };
        topLeft = rotatePoint(child.rotateAngle, child.offsetX, child.offsetY, topLeft);
        topRight = rotatePoint(child.rotateAngle, child.offsetX, child.offsetY, topRight);
        bottomLeft = rotatePoint(child.rotateAngle, child.offsetX, child.offsetY, bottomLeft);
        bottomRight = rotatePoint(child.rotateAngle, child.offsetX, child.offsetY, bottomRight);
        if (this.rotateAngle !== 0) {
            topLeft = rotatePoint(-this.rotateAngle, undefined, undefined, topLeft);
            topRight = rotatePoint(-this.rotateAngle, undefined, undefined, topRight);
            bottomLeft = rotatePoint(-this.rotateAngle, undefined, undefined, bottomLeft);
            bottomRight = rotatePoint(-this.rotateAngle, undefined, undefined, bottomRight);
        }
        return Rect.toBounds([topLeft, topRight, bottomLeft, bottomRight]);
    };
    return Container;
}(DiagramElement));

var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * TextElement is used to display text/annotations
 */
var TextElement = /** @class */ (function (_super) {
    __extends$3(TextElement, _super);
    /**
     * set the id for each element
     */
    function TextElement() {
        var _this = _super.call(this) || this;
        /**
         * sets or gets the image source
         */
        _this.textContent = '';
        /** @private */
        _this.canMeasure = true;
        /**Gets or sets the reference mode for annotation rotation. */
        /** @private */
        _this.rotationReference = 'Parent';
        /** @private */
        _this.isLaneOrientation = false;
        /** @private */
        _this.canConsiderBounds = true;
        /** @private */
        _this.annotationVisibility = 'Visible';
        /**
         * sets the hyperlink color to blue
         */
        _this.hyperlink = {
            color: 'blue'
        };
        /** @private */
        _this.doWrap = true;
        _this.textNodes = [];
        /**
         * Defines the appearance of the text element
         */
        _this.style = {
            color: 'black', fill: 'transparent', strokeColor: 'black',
            strokeWidth: 1, fontFamily: 'Arial', fontSize: 12, whiteSpace: 'CollapseSpace',
            textWrapping: 'WrapWithOverflow', textAlign: 'Center', italic: false, bold: false,
            textDecoration: 'None', strokeDashArray: '', opacity: 5, gradient: null,
            textOverflow: 'Wrap'
        };
        _this.style.fill = 'transparent';
        _this.style.strokeColor = 'transparent';
        return _this;
    }
    Object.defineProperty(TextElement.prototype, "content", {
        /**
         *   gets the content for the text element \
         *
         * @returns { string | SVGElement }  gets the content for the text element.\
         *
         * @private
         */
        get: function () {
            return this.textContent;
        },
        /**
         *   sets the content for the text element \
         *
         * @returns { void }  sets the content for the text element.\
         * @param {string} value - provide the id value.
         *
         * @private
         */
        set: function (value) {
            if (this.textContent !== value) {
                this.textContent = value;
                this.isDirt = true;
                this.doWrap = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextElement.prototype, "childNodes", {
        /**
         *   gets the content for the text element \
         *
         * @returns { string | SVGElement }  gets the content for the text element.\
         *
         * @private
         */
        get: function () {
            return this.textNodes;
        },
        /**
         *   sets the content for the text element \
         *
         * @returns { void }  sets the content for the text element.\
         * @param {SubTextElement[]} value - provide the id value.
         *
         * @private
         */
        set: function (value) {
            this.textNodes = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextElement.prototype, "wrapBounds", {
        /**
         *   gets the wrapBounds for the text \
         *
         * @returns { string | SVGElement }  gets the wrapBounds for the text.\
         *
         * @private
         */
        get: function () {
            return this.textWrapBounds;
        },
        /**
         *    sets the wrapBounds for the text \
         *
         * @returns { void }   sets the wrapBounds for the text.\
         * @param {TextBounds} value - provide the id value.
         *
         * @private
         */
        set: function (value) {
            this.textWrapBounds = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *    sets the wrapBounds for the text \
     *
     * @returns { void }   sets the wrapBounds for the text.\
     *
     * @private
     */
    TextElement.prototype.refreshTextElement = function () {
        this.isDirt = true;
    };
    /**
     *Measures the minimum size that is required for the text element\
     *
     * @returns { Size }  Measures the minimum size that is required for the text element.\
     * @param {Size} availableSize - provide the id value.
     *
     * @private
     */
    TextElement.prototype.measure = function (availableSize) {
        var size;
        if (this.isDirt && this.canMeasure) {
            size = measureText(this, this.style, this.content, this.isLaneOrientation ?
                availableSize.height : (this.width || availableSize.width));
        }
        else {
            size = this.desiredSize;
        }
        if (this.width === undefined || this.height === undefined) {
            this.desiredSize = new Size(size.width, size.height);
        }
        else {
            this.desiredSize = new Size(this.width, this.height);
        }
        this.desiredSize = this.validateDesiredSize(this.desiredSize, availableSize);
        return this.desiredSize;
    };
    /**
     * Arranges the text element\
     *
     * @returns { Size }   Arranges the text element.\
     * @param {Size} desiredSize - provide the id value.
     *
     * @private
     */
    TextElement.prototype.arrange = function (desiredSize) {
        if (desiredSize.width !== this.actualSize.width || desiredSize.height !== this.actualSize.height || this.isDirt) {
            this.doWrap = true;
        }
        this.actualSize = desiredSize;
        this.updateBounds();
        this.isDirt = false;
        return this.actualSize;
    };
    return TextElement;
}(DiagramElement));

var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * PathElement takes care of how to align the path based on offsetX and offsetY
 */
var PathElement = /** @class */ (function (_super) {
    __extends$4(PathElement, _super);
    /**
     * set the id for each element
     */
    function PathElement() {
        var _this = _super.call(this) || this;
        /**
         * Gets or sets the geometry of the path element
         */
        _this.pathData = '';
        /**
         * Gets/Sets whether the path has to be transformed to fit the given x,y, width, height
         */
        _this.transformPath = true;
        /**
         * Gets/Sets the equivalent path, that will have the origin as 0,0
         */
        _this.absolutePath = '';
        /**   @private  */
        _this.canMeasurePath = false;
        //Private variables
        /**   @private  */
        _this.absoluteBounds = new Rect();
        return _this;
    }
    Object.defineProperty(PathElement.prototype, "data", {
        /**
         *   Gets the geometry of the path element\
         *
         * @returns { string | SVGElement }  Gets the geometry of the path element.\
         *
         * @private
         */
        get: function () {
            return this.pathData;
        },
        /**
         *  Sets the geometry of the path element \
         *
         * @returns { void } Sets the geometry of the path element.\
         * @param {string} value - provide the id value.
         *
         * @private
         */
        set: function (value) {
            if (this.pathData !== value) {
                this.pathData = value;
                this.isDirt = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * getPoints methods  \
     *
     * @returns { PointModel[] } Sets the geometry of the path element.\
     *
     * @private
     */
    PathElement.prototype.getPoints = function () {
        var _this = this;
        if (!this.pointTimer) {
            this.pointTimer = setTimeout(function () {
                _this.points = null;
                _this.pointTimer = null;
            }, 200);
        }
        this.points = this.points || findSegmentPoints(this);
        return translatePoints(this, this.points);
    };
    /**
     * Measures the minimum space that is required to render the element  \
     *
     * @returns { Size } Measures the minimum space that is required to render the element.\
     * @param {Size} availableSize - provide the id value.
     *
     * @private
     */
    PathElement.prototype.measure = function (availableSize) {
        //Performance issue - Avoiding measuring the connector path
        if (this.staticSize && this.width !== undefined && this.height !== undefined) {
            this.absoluteBounds = new Rect(this.offsetX - this.width * this.pivot.x, this.offsetY - this.height * this.pivot.y, this.width, this.height);
        }
        else if (this.isDirt && (this.transformPath || (this.width === undefined || this.height === undefined))
            && (!this.absoluteBounds || this.absoluteBounds.height === 0) || this.canMeasurePath) {
            //Measure the element only whent the path data is changed/ size is not specified
            this.absoluteBounds = measurePath(this.data ? this.data : '');
        }
        if (this.width === undefined) {
            this.desiredSize = new Size(this.absoluteBounds.width, this.height || this.absoluteBounds.height);
        }
        else if (this.height === undefined) {
            this.desiredSize = new Size(this.width || this.absoluteBounds.width, this.absoluteBounds.height);
        }
        else {
            this.desiredSize = new Size(this.width, this.height);
        }
        this.desiredSize = this.validateDesiredSize(this.desiredSize, availableSize);
        this.canMeasurePath = false;
        return this.desiredSize;
    };
    /**
     * Arranges the path element  \
     *
     * @returns { Size } Arranges the path element.\
     * @param {Size} desiredSize - provide the id value.
     *
     * @private
     */
    PathElement.prototype.arrange = function (desiredSize) {
        if (this.isDirt || this.actualSize.width !== desiredSize.width || this.actualSize.height !== desiredSize.height) {
            this.isDirt = true;
            this.absolutePath = this.updatePath(this.data, this.absoluteBounds, desiredSize);
            if (!this.staticSize) {
                this.points = null;
            }
        }
        this.actualSize = this.desiredSize;
        this.updateBounds();
        this.isDirt = false;
        return this.actualSize;
    };
    /**
     *  Translates the path to 0,0 and scales the path based on the actual size  \
     *
     * @returns { Size } Arranges the path element.\
     * @param {string} pathData - provide the id value.
     * @param {Rect} bounds - provide the id value.
     * @param {Size} actualSize - provide the id value.
     *
     * @private
     */
    PathElement.prototype.updatePath = function (pathData, bounds, actualSize) {
        var isScale = false;
        var newPathString = '';
        var scaleX = -bounds.x;
        var scaleY = -bounds.y;
        var arrayCollection = [];
        if (actualSize.width !== bounds.width || actualSize.height !== bounds.height) {
            scaleX = actualSize.width / Number(bounds.width ? bounds.width : 1);
            scaleY = actualSize.height / Number(bounds.height ? bounds.height : 1);
            isScale = true;
        }
        arrayCollection = processPathData(pathData);
        arrayCollection = splitArrayCollection(arrayCollection);
        if ((isScale || this.isDirt) && this.transformPath) {
            newPathString = transformPath(arrayCollection, scaleX, scaleY, isScale, bounds.x, bounds.y, 0, 0);
        }
        else {
            newPathString = getPathString(arrayCollection);
        }
        isScale = false;
        return newPathString;
    };
    return PathElement;
}(DiagramElement));

var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * ImageElement defines a basic image elements
 */
var ImageElement = /** @class */ (function (_super) {
    __extends$5(ImageElement, _super);
    /**
     * set the id for each element
     */
    function ImageElement() {
        var _this = _super.call(this) || this;
        /**
         * sets or gets the image source
         */
        _this.imageSource = '';
        /**
         * sets scaling factor of the image
         */
        _this.imageScale = 'None';
        /**
         * sets the alignment of the image
         */
        _this.imageAlign = 'None';
        /**
         * Sets how to stretch the image
         */
        _this.stretch = 'Stretch';
        return _this;
    }
    Object.defineProperty(ImageElement.prototype, "source", {
        /**
         * Gets the source for the image element
         */
        /**
         * Gets the source for the image element \
         *
         * @returns { void }Gets the source for the image element.\
         *
         * @private
         */
        get: function () {
            return this.imageSource;
        },
        /**
         * Sets the source for the image element \
         *
         * @returns { void }Sets the source for the image element.\
         * @param {string} value - provide the id value.
         *
         * @private
         */
        set: function (value) {
            this.imageSource = value;
            this.isDirt = true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Measures minimum space that is required to render the image \
     *
     * @returns { Size }Measures minimum space that is required to render the image.\
     * @param {Size} availableSize - provide the id value.
     * @param {Object} id - provide the id value.
     * @param {Function} callback - provide the id value.
     *
     * @private
     */
    ImageElement.prototype.measure = function (availableSize, id, callback) {
        if (this.isDirt && (this.stretch !== 'Stretch' || this.width === undefined && this.height === undefined)) {
            this.contentSize = measureImage(this.source, this.contentSize, id, callback);
            this.isDirt = false;
        }
        if (this.width !== undefined && this.height !== undefined) {
            this.desiredSize = new Size(this.width, this.height);
            this.contentSize = this.desiredSize;
        }
        else {
            this.desiredSize = this.contentSize;
        }
        this.desiredSize = this.validateDesiredSize(this.desiredSize, availableSize);
        return this.desiredSize;
    };
    /**
     * Arranges the image
     * @param {Size} desiredSize
     */
    /**
     * Arranges the image \
     *
     * @returns { Size }Arranges the image.\
     * @param {Size} desiredSize - provide the id value.
     *
     * @private
     */
    ImageElement.prototype.arrange = function (desiredSize) {
        this.actualSize = new Size(this.desiredSize.width, this.desiredSize.height);
        this.updateBounds();
        return this.actualSize;
    };
    return ImageElement;
}(DiagramElement));

var __extends$6 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Canvas module is used to define a plane(canvas) and to arrange the children based on margin
 */
var Canvas = /** @class */ (function (_super) {
    __extends$6(Canvas, _super);
    function Canvas() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Not applicable for canvas
         *
         *  @private
         */
        _this.measureChildren = undefined;
        return _this;
    }
    /**
     * Measures the minimum space that the canvas requires \
     *
     * @returns { Size } Measures the minimum space that the canvas requires .\
     * @param {string} id - provide the id value.
     * @param {Function} callback - provide the Connector value.
     *
     * @private
     */
    Canvas.prototype.measure = function (availableSize, id, callback) {
        var desired = undefined;
        var desiredBounds = undefined;
        if (this.hasChildren()) {
            //Measuring the children
            for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child instanceof TextElement) {
                    if (child.canMeasure) {
                        availableSize.width = availableSize.width || this.maxWidth || this.minWidth;
                        child.measure(availableSize);
                    }
                }
                else if (!(child instanceof TextElement)) {
                    child.measure(availableSize, id, callback);
                }
                var childSize = child.desiredSize.clone();
                if (child.rotateAngle !== 0) {
                    childSize = rotateSize(childSize, child.rotateAngle);
                }
                var right = childSize.width + child.margin.right;
                var bottom = childSize.height + child.margin.bottom;
                var childBounds = new Rect(child.margin.left, child.margin.top, right, bottom);
                if (child.float) {
                    var position = child.getAbsolutePosition(childSize);
                    if (position !== undefined) {
                        continue;
                    }
                }
                if ((!(child instanceof TextElement)) || (child instanceof TextElement && child.canConsiderBounds)) {
                    if (desiredBounds === undefined) {
                        desiredBounds = childBounds;
                    }
                    else {
                        desiredBounds.uniteRect(childBounds);
                    }
                }
            }
            if (desiredBounds) {
                var leftMargin = 0;
                var topMargin = 0;
                leftMargin = Math.max(desiredBounds.left, 0);
                topMargin = Math.max(desiredBounds.top, 0);
                desired = new Size(desiredBounds.width + leftMargin, desiredBounds.height + topMargin);
            }
        }
        desired = _super.prototype.validateDesiredSize.call(this, desired, availableSize);
        _super.prototype.stretchChildren.call(this, desired);
        //Considering padding values
        desired.width += this.padding.left + this.padding.right;
        desired.height += this.padding.top + this.padding.bottom;
        this.desiredSize = desired;
        return desired;
    };
    /**
     * Arranges the child elements of the canvas
     */
    Canvas.prototype.arrange = function (desiredSize, isStack) {
        this.outerBounds = new Rect();
        if (this.hasChildren()) {
            //let y: number;
            //let x: number;
            var y = this.offsetY - desiredSize.height * this.pivot.y + this.padding.top;
            var x = this.offsetX - desiredSize.width * this.pivot.x + this.padding.left;
            for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if ((child.transform & Transform.Parent) !== 0) {
                    child.parentTransform = this.parentTransform + this.rotateAngle;
                    if (this.flip !== FlipDirection.None || this.elementActions & ElementAction.ElementIsGroup) {
                        if ((this.flip === FlipDirection.Horizontal || this.flip === FlipDirection.Vertical) &&
                            !(child.elementActions & ElementAction.ElementIsPort)) {
                            //To update parentTransform for the diargam elements based on the flip mode.
                            this.setParentTransform(child);
                        }
                    }
                    var childSize = child.desiredSize.clone();
                    var topLeft = void 0;
                    var center = { x: 0, y: 0 };
                    var childX = x;
                    var childY = y;
                    if (child.relativeMode === 'Point') {
                        var position = child.getAbsolutePosition(desiredSize);
                        if (position !== undefined) {
                            childX += position.x;
                            childY += position.y;
                        }
                    }
                    if (child.relativeMode === 'Object') {
                        topLeft = this.alignChildBasedOnParent(child, childSize, desiredSize, childX, childY);
                        // 896059: Update the flip position of the node to get the docking point of node and connector
                        child.flip = this.flip;
                    }
                    else {
                        topLeft = this.alignChildBasedOnaPoint(child, childX, childY);
                    }
                    center = { x: topLeft.x + childSize.width / 2, y: topLeft.y + childSize.height / 2 };
                    _super.prototype.findChildOffsetFromCenter.call(this, child, center);
                }
                if (isStack && (child.horizontalAlignment === 'Stretch' || child.verticalAlignment === 'Stretch')) {
                    child.arrange(desiredSize);
                }
                else {
                    if (child instanceof TextElement && child.canMeasure) {
                        child.arrange(child.desiredSize);
                        this.outerBounds.uniteRect(child.outerBounds);
                    }
                    else if (!(child instanceof TextElement)) {
                        child.arrange(child.desiredSize);
                        this.outerBounds.uniteRect(child.outerBounds);
                    }
                }
            }
        }
        this.actualSize = desiredSize;
        this.updateBounds();
        this.outerBounds.uniteRect(this.bounds);
        return desiredSize;
    };
    Canvas.prototype.setParentTransform = function (child) {
        if (this.flipMode === 'All' || child instanceof ImageElement) {
            if (child.parentTransform > 0) {
                child.parentTransform = -child.parentTransform;
            }
        }
        else if (!(child instanceof ImageElement || child instanceof TextElement || child instanceof PathElement)
            && child instanceof DiagramElement) {
            if (child.parentTransform > 0) {
                child.parentTransform = -child.parentTransform;
            }
        }
        else if (child instanceof TextElement && child.position === undefined) {
            child.parentTransform = -child.parentTransform;
        }
        else if (this.flipMode === 'None') {
            if (!(child.elementActions & ElementAction.ElementIsPort) && child instanceof PathElement) {
                if (child.parentTransform > 0) {
                    child.parentTransform = -child.parentTransform;
                }
            }
        }
        else if (child instanceof PathElement) {
            if (child.parentTransform > 0) {
                child.parentTransform = -child.parentTransform;
            }
        }
        else if (this.flipMode === 'LabelText' || this.flipMode === 'LabelAndLabelText' || this.flipMode === 'PortAndLabelText') {
            if (child instanceof TextElement) {
                if (child.parentTransform > 0) {
                    child.parentTransform = -child.parentTransform;
                }
            }
        }
    };
    //Aligns the child element based on its parent
    Canvas.prototype.alignChildBasedOnParent = function (child, childSize, parentSize, x, y) {
        switch (child.horizontalAlignment) {
            case 'Auto':
            case 'Left':
                x += child.margin.left;
                break;
            case 'Right':
                x += parentSize.width - childSize.width - child.margin.right;
                break;
            case 'Stretch':
            case 'Center':
                x += parentSize.width / 2 - childSize.width / 2;
                break;
        }
        switch (child.verticalAlignment) {
            case 'Auto':
            case 'Top':
                y += child.margin.top;
                break;
            case 'Bottom':
                y += parentSize.height - childSize.height - child.margin.bottom;
                break;
            case 'Stretch':
            case 'Center':
                y += parentSize.height / 2 - childSize.height / 2;
                break;
        }
        return { x: x, y: y };
    };
    //Aligns the child elements based on a point
    Canvas.prototype.alignChildBasedOnaPoint = function (child, x, y) {
        x += child.margin.left - child.margin.right;
        y += child.margin.top - child.margin.bottom;
        switch (child.horizontalAlignment) {
            case 'Auto':
            case 'Left':
                x = child.inversedAlignment ? x : (x - child.desiredSize.width);
                break;
            case 'Stretch':
            case 'Center':
                x -= child.desiredSize.width * child.pivot.x;
                break;
            case 'Right':
                x = child.inversedAlignment ? (x - child.desiredSize.width) : x;
                break;
        }
        switch (child.verticalAlignment) {
            case 'Auto':
            case 'Top':
                y = child.inversedAlignment ? y : (y - child.desiredSize.height);
                break;
            case 'Stretch':
            case 'Center':
                y -= child.desiredSize.height * child.pivot.y;
                break;
            case 'Bottom':
                y = child.inversedAlignment ? (y - child.desiredSize.height) : y;
                break;
        }
        return { x: x, y: y };
    };
    return Canvas;
}(Container));

/**
 *  BasicShapeDictionary defines the shape of the built-in basic shapes \
 *
 * @returns { string }      BasicShapeDictionary defines the shape of the built-in basic shapes .\
 * @param {string} shape - provide the element value.
 *
 * @private
 */
function getBasicShape(shape) {
    return basicShapes[shape.toString()];
}
// eslint-disable-next-line prefer-const
var basicShapes = {
    //Rectangle,
    'Rectangle': 'M0,0 L50,0 L50,50 L0,50 z',
    //Ellipse,
    'Ellipse': 'M80.5,12.5 C80.5,19.127417 62.59139,24.5 40.5,24.5 C18.40861,24.5 0.5,19.127417 0.5,12.5' +
        'C0.5,5.872583 18.40861,0.5 40.5,0.5 C62.59139,0.5 80.5,5.872583 80.5,12.5 z',
    //Hexagon,
    'Hexagon': 'M30,0 L60,0 L90,30 L60,60 L30,60 L0,30 L30,0 z',
    //Parallelogram,
    'Parallelogram': 'M30,0 L60,0 L45,30 L15,30 z',
    //Triangle,
    'Triangle': 'M45,0 L90,45 L0,45 L45,0 z',
    //Plus,
    'Plus': 'M696.6084,158.2656 L674.8074,158.2656 L674.8074,136.4656 L658.4084,136.4656 L658.4084,158.2656 L636.6084,158.2656' +
        'L636.6084,174.6646 L658.4084,174.6646 L658.4084,196.4656 L674.8074,196.4656 L674.8074,174.6646 L696.6084,174.6646' +
        'L696.6084,158.2656 z',
    //Star,
    'Star': 'M540.3643,137.9336 L546.7973,159.7016 L570.3633,159.7296 L550.7723,171.9366 L558.9053,194.9966 L540.3643,179.4996' +
        'L521.8223,194.9966 L529.9553,171.9366 L510.3633,159.7296 L533.9313,159.7016 L540.3643,137.9336 z',
    //Pentagon,
    'Pentagon': 'M30,0 L60,30 L50,70 L10,70 L0,30 L30,0 z',
    //Heptagon,
    'Heptagon': 'M223.7783,195.7134 L207.1303,174.8364 L213.0713,148.8034 L237.1303,137.2174 L261.1883,148.8034 L267.1303,174.8364' +
        'L250.4813,195.7134 L223.7783,195.7134 z',
    //Octagon,
    'Octagon': 'M98.7319,196.4653 L81.1579,178.8923 L81.1579,154.0393 L98.7319,136.4653 L123.5849,136.4653' +
        'L141.1579,154.0393 L141.1579,178.8923 L123.5849,196.4653 L98.7319,196.4653 z',
    //Trapezoid,
    'Trapezoid': 'M127.2842,291.4492 L95.0322,291.4492 L81.1582,256.3152 L141.1582,256.3152 L127.2842,291.4492 z',
    //Decagon,
    'Decagon': 'M657.3379,302.4141 L642.3369,291.5161 L636.6089,273.8821 L642.3369,256.2481 L657.3379,245.3511 L675.8789,245.3511' +
        'L690.8789,256.2481 L696.6089,273.8821' +
        'L690.8789,291.5161 L675.8789,302.4141 L657.3379,302.4141 z',
    //RightTriangle,
    'RightTriangle': 'M836.293,292.9238 L776.293,292.9238 L776.293,254.8408 L836.293,292.9238 z',
    //Cylinder,
    'Cylinder': 'M 542.802,362.009C 542.802,368.452 525.341,373.676 503.802,373.676C 482.263,373.676 464.802,368.452 464.802,362.009' +
        'L 464.802,466.484C 464.802,472.928 482.263,478.151 503.802,478.151' +
        'C 525.341,478.151 542.802,472.928 542.802,466.484L 542.802,362.016C 542.802,368.459 525.341,373.534 503.802,373.534' +
        'C 482.263,373.534 464.802,368.31 464.802,361.867' +
        'L 464.802,362.016C 464.802,355.572 482.263,350.349 503.802,350.349C 525.341,350.349 542.802,355.572 542.802,362.016',
    //Diamond,
    'Diamond': 'M397.784,287.875 L369.5,316.159 L341.216,287.875 L369.5,259.591 L397.784,287.875 z'
};

var __extends$7 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * NativeElement defines the basic native elements
 */
var DiagramNativeElement = /** @class */ (function (_super) {
    __extends$7(DiagramNativeElement, _super);
    /**
     *  set the id for each element \
     *
     * @returns { void } set the id for each element.\
     * @param {string} nodeId - provide the id value.
     * @param {string} diagramId - provide the id value.
     *
     * @private
     */
    function DiagramNativeElement(nodeId, diagramId) {
        var _this = _super.call(this) || this;
        _this.data = '';
        /**
         * set the node id
         */
        _this.nodeId = '';
        /**
         * set the diagram id
         */
        _this.diagramId = '';
        /**
         * sets scaling factor of the Native Element
         */
        _this.scale = 'Stretch';
        _this.diagramId = diagramId;
        _this.nodeId = nodeId;
        return _this;
    }
    Object.defineProperty(DiagramNativeElement.prototype, "content", {
        /**
         *  get the id for each element \
         *
         * @returns { string | SVGElement } get the id for each element.\
         *
         * @private
         */
        get: function () {
            return this.data;
        },
        /**
         *  sets the geometry of the native element \
         *
         * @returns { void } sets the geometry of the native element.\
         * @param {string | SVGElement} value - provide the id value.
         *
         * @private
         */
        set: function (value) {
            this.data = value;
            if (!this.canReset) {
                this.canReset = true;
                this.template = getContent(this, false);
                this.canReset = false;
                this.isDirt = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     *Measures minimum space that is required to render the Native Element \
     *
     * @returns { Size }Measures minimum space that is required to render the Native Element.\
     * @param {Size} availableSize - provide the id value.
     *
     * @private
     */
    DiagramNativeElement.prototype.measure = function (availableSize) {
        if (this.isDirt) {
            var rect = measureNativeContent(this.template);
            this.contentSize = new Size();
            this.contentSize.width = rect.width;
            this.contentSize.height = rect.height;
            var x = rect.x;
            var y = rect.y;
            this.templatePosition = { x: x, y: y };
            this.isDirt = false;
        }
        if (this.width === undefined || this.height === undefined) {
            var getAvailableSize = measureNativeSvg(this.template);
            this.desiredSize = new Size(getAvailableSize.width, getAvailableSize.height);
        }
        else {
            this.desiredSize = new Size(this.width, this.height);
        }
        this.desiredSize = this.validateDesiredSize(this.desiredSize, availableSize);
        return this.desiredSize;
    };
    /**
     *Arranges the Native Element \
     *
     * @returns { Size }Arranges the Native Element.\
     * @param {Size} desiredSize - provide the id value.
     *
     * @private
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    DiagramNativeElement.prototype.arrange = function (desiredSize) {
        this.actualSize = new Size(this.desiredSize.width, this.desiredSize.height);
        this.updateBounds();
        return this.actualSize;
    };
    return DiagramNativeElement;
}(DiagramElement));

var __extends$8 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Defines the tooltip that should be shown when the mouse hovers over node.
 * An object that defines the description, appearance and alignments of tooltip
 */
var DiagramTooltip = /** @class */ (function (_super) {
    __extends$8(DiagramTooltip, _super);
    function DiagramTooltip() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$2([
        Property('')
    ], DiagramTooltip.prototype, "content", void 0);
    __decorate$2([
        Property('TopLeft')
    ], DiagramTooltip.prototype, "position", void 0);
    __decorate$2([
        Property('Mouse')
    ], DiagramTooltip.prototype, "relativeMode", void 0);
    __decorate$2([
        Property(true)
    ], DiagramTooltip.prototype, "showTipPointer", void 0);
    __decorate$2([
        Property('auto')
    ], DiagramTooltip.prototype, "width", void 0);
    __decorate$2([
        Property('auto')
    ], DiagramTooltip.prototype, "height", void 0);
    __decorate$2([
        Property('Auto')
    ], DiagramTooltip.prototype, "openOn", void 0);
    __decorate$2([
        Property()
    ], DiagramTooltip.prototype, "animation", void 0);
    __decorate$2([
        Property(false)
    ], DiagramTooltip.prototype, "isSticky", void 0);
    return DiagramTooltip;
}(ChildProperty));
/**
 * initTooltip method \
 *
 * @returns { Tooltip } initTooltip method .\
 * @param {Diagram} diagram - provide the points value.
 *
 * @private
 */
function initTooltip(diagram) {
    var tooltipOption = new Tooltip;
    tooltipOption = updateTooltipContent(diagram.tooltip, tooltipOption);
    var tooltip = new Tooltip(tooltipOption);
    tooltip.beforeCollision = beforeCollision;
    tooltip.beforeOpen = beforeOpen;
    tooltip.cssClass = 'e-diagram-tooltip';
    tooltip.opensOn = 'custom';
    tooltip.appendTo('#' + diagram.element.id);
    tooltip.close();
    return tooltip;
}
/**
 * beforeOpen method \
 *
 * @returns { void } beforeOpen method .\
 * @param {TooltipEventArgs} args - provide the points value.
 *
 * @private
 */
function beforeOpen(args) {
    if ((this.content === '' || this.content === undefined)) {
        args.element.style.display = 'none';
    }
}
/**
 * beforeCollision method \
 *
 * @returns { void } beforeCollision method .\
 * @param {TooltipEventArgs} args - provide the points value.
 *
 * @private
 */
function beforeCollision(args) {
    if ((args.collidedPosition && args.collidedPosition !== this.position)) {
        args.element.style.display = 'none';
    }
}
/**
 * updateTooltip method \
 *
 * @returns { Tooltip } updateTooltip method .\
 * @param {Diagram} diagram - provide the points value.
 * @param {NodeModel | ConnectorModel} node - provide the points value.
 *
 * @private
 */
function updateTooltip(diagram, node) {
    //let tooltip: DiagramTooltipModel;
    var tooltipObject = diagram.tooltipObject;
    var tooltip = node ? node.tooltip : diagram.tooltip;
    updateTooltipContent(tooltip, tooltipObject);
    return tooltipObject;
}
/**
 * updateTooltipContent method \
 *
 * @returns { Tooltip } updateTooltipContent method .\
 * @param {DiagramTooltipModel} tooltip - provide the points value.
 * @param {Tooltip} tooltipObject - provide the points value.
 *
 * @private
 */
function updateTooltipContent(tooltip, tooltipObject) {
    if (tooltip.content) {
        tooltipObject.content = tooltip.content;
        //Task 834121: Content-Security-Policy support for diagram
        if (typeof tooltip.content === 'string') {
            var contentTemp = function () {
                return tooltip.content;
            };
            tooltipObject.content = initializeCSPTemplate(contentTemp);
        }
        tooltipObject.position = tooltip.position;
        tooltipObject.showTipPointer = tooltip.showTipPointer;
        tooltipObject.width = tooltip.width;
        tooltipObject.height = tooltip.height;
        if (!tooltip.animation) {
            tooltipObject.animation = { close: { effect: 'None' } };
        }
        else {
            tooltipObject.animation = tooltip.animation;
        }
    }
    else {
        tooltipObject.close();
    }
    return tooltipObject;
}

var __extends$9 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Defines the behavior of connection ports
 */
var Port = /** @class */ (function (_super) {
    __extends$9(Port, _super);
    // tslint:disable-next-line:no-any
    function Port(parent, propName, defaultValue, isArray) {
        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
        _this.inEdges = [];
        _this.outEdges = [];
        return _this;
    }
    __decorate$3([
        Property('')
    ], Port.prototype, "id", void 0);
    __decorate$3([
        Property('Center')
    ], Port.prototype, "horizontalAlignment", void 0);
    __decorate$3([
        Property('Center')
    ], Port.prototype, "verticalAlignment", void 0);
    __decorate$3([
        Complex({}, Margin)
    ], Port.prototype, "margin", void 0);
    __decorate$3([
        Property(12)
    ], Port.prototype, "width", void 0);
    __decorate$3([
        Property(12)
    ], Port.prototype, "height", void 0);
    __decorate$3([
        Complex({}, ShapeStyle)
    ], Port.prototype, "style", void 0);
    __decorate$3([
        Property('Square')
    ], Port.prototype, "shape", void 0);
    __decorate$3([
        Property('Auto')
    ], Port.prototype, "connectionDirection", void 0);
    __decorate$3([
        Property(PortVisibility.Connect)
    ], Port.prototype, "visibility", void 0);
    __decorate$3([
        Property('')
    ], Port.prototype, "pathData", void 0);
    __decorate$3([
        Property(PortConstraints.Default)
    ], Port.prototype, "constraints", void 0);
    __decorate$3([
        Property()
    ], Port.prototype, "addInfo", void 0);
    __decorate$3([
        Property()
    ], Port.prototype, "outEdges", void 0);
    __decorate$3([
        Property()
    ], Port.prototype, "inEdges", void 0);
    __decorate$3([
        Complex({}, DiagramTooltip)
    ], Port.prototype, "tooltip", void 0);
    return Port;
}(ChildProperty));
/**
 * Defines the behavior of a port, that sticks to a point
 */
var PointPort = /** @class */ (function (_super) {
    __extends$9(PointPort, _super);
    function PointPort(parent, propName, defaultValue, isArray) {
        return _super.call(this, parent, propName, defaultValue, isArray) || this;
    }
    /**
     * getClassName method \
     *
     * @returns { string } toBounds method .\
     *
     * @private
     */
    PointPort.prototype.getClassName = function () {
        return 'PointPort';
    };
    __decorate$3([
        Complex({ x: 0.5, y: 0.5 }, Point)
    ], PointPort.prototype, "offset", void 0);
    return PointPort;
}(Port));
/**
 * Defines the behavior of a port, that sticks to a point
 */
var PathPort = /** @class */ (function (_super) {
    __extends$9(PathPort, _super);
    function PathPort(parent, propName, defaultValue, isArray) {
        return _super.call(this, parent, propName, defaultValue, isArray) || this;
    }
    /**
     * getClassName method \
     *
     * @returns { string } toBounds method .\
     *
     * @private
     */
    PathPort.prototype.getClassName = function () {
        return 'PathPort';
    };
    __decorate$3([
        Property(0.5)
    ], PathPort.prototype, "offset", void 0);
    __decorate$3([
        Complex({ x: 0, y: 0 }, Point)
    ], PathPort.prototype, "displacement", void 0);
    __decorate$3([
        Property('Center')
    ], PathPort.prototype, "alignment", void 0);
    return PathPort;
}(Port));

var __extends$a = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Defines the hyperlink for the annotations in the nodes/connectors
 */
var Hyperlink = /** @class */ (function (_super) {
    __extends$a(Hyperlink, _super);
    function Hyperlink() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$4([
        Property('blue')
    ], Hyperlink.prototype, "color", void 0);
    __decorate$4([
        Property('')
    ], Hyperlink.prototype, "content", void 0);
    __decorate$4([
        Property('')
    ], Hyperlink.prototype, "link", void 0);
    __decorate$4([
        Property('None')
    ], Hyperlink.prototype, "textDecoration", void 0);
    __decorate$4([
        Property('NewTab')
    ], Hyperlink.prototype, "hyperlinkOpenState", void 0);
    return Hyperlink;
}(ChildProperty));
/**
 * Defines the textual description of nodes/connectors
 */
var Annotation = /** @class */ (function (_super) {
    __extends$a(Annotation, _super);
    // tslint:disable-next-line:no-any
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function Annotation(parent, propName, defaultValue, isArray) {
        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
        if (!defaultValue.id) {
            if (parent.parentObj && parent.parentObj.propName && parent.parentObj.propName === 'phases') {
                _this.id = parent.parentObj.id;
            }
            else {
                _this.id = randomId();
            }
        }
        return _this;
    }
    __decorate$4([
        Property('')
    ], Annotation.prototype, "content", void 0);
    __decorate$4([
        Property(undefined)
    ], Annotation.prototype, "template", void 0);
    __decorate$4([
        Property('String')
    ], Annotation.prototype, "annotationType", void 0);
    __decorate$4([
        Property(true)
    ], Annotation.prototype, "visibility", void 0);
    __decorate$4([
        Property(AnnotationConstraints.InheritReadOnly)
    ], Annotation.prototype, "constraints", void 0);
    __decorate$4([
        Complex(undefined, Hyperlink)
    ], Annotation.prototype, "hyperlink", void 0);
    __decorate$4([
        Property('')
    ], Annotation.prototype, "id", void 0);
    __decorate$4([
        Property()
    ], Annotation.prototype, "width", void 0);
    __decorate$4([
        Property()
    ], Annotation.prototype, "height", void 0);
    __decorate$4([
        Property(0)
    ], Annotation.prototype, "rotateAngle", void 0);
    __decorate$4([
        Property('Parent')
    ], Annotation.prototype, "rotationReference", void 0);
    __decorate$4([
        Complex({ strokeWidth: 0, strokeColor: 'transparent', fill: 'transparent' }, TextStyle)
    ], Annotation.prototype, "style", void 0);
    __decorate$4([
        Property('Center')
    ], Annotation.prototype, "horizontalAlignment", void 0);
    __decorate$4([
        Property('Center')
    ], Annotation.prototype, "verticalAlignment", void 0);
    __decorate$4([
        Complex({}, Margin)
    ], Annotation.prototype, "margin", void 0);
    __decorate$4([
        Complex({ top: undefined, bottom: undefined, left: undefined, right: undefined }, Margin)
    ], Annotation.prototype, "dragLimit", void 0);
    __decorate$4([
        Property('Shape')
    ], Annotation.prototype, "type", void 0);
    __decorate$4([
        Complex({}, DiagramTooltip)
    ], Annotation.prototype, "tooltip", void 0);
    __decorate$4([
        Property()
    ], Annotation.prototype, "addInfo", void 0);
    return Annotation;
}(ChildProperty));
/**
 * Defines the textual description of nodes/connectors with respect to bounds
 */
var ShapeAnnotation = /** @class */ (function (_super) {
    __extends$a(ShapeAnnotation, _super);
    /* eslint-disable */
    function ShapeAnnotation(parent, propName, defaultValue, isArray) {
        return _super.call(this, parent, propName, defaultValue, isArray) || this;
    }
    // eslint-disable-next-line valid-jsdoc
    /**
     * @private
     * Returns the module of class ShapeAnnotation
     */
    ShapeAnnotation.prototype.getClassName = function () {
        return 'ShapeAnnotation';
    };
    __decorate$4([
        Complex({ x: 0.5, y: 0.5 }, Point)
    ], ShapeAnnotation.prototype, "offset", void 0);
    return ShapeAnnotation;
}(Annotation));
/**
 * Defines the connector annotation
 */
var PathAnnotation = /** @class */ (function (_super) {
    __extends$a(PathAnnotation, _super);
    /* eslint-disable */
    function PathAnnotation(parent, propName, defaultValue, isArray) {
        return _super.call(this, parent, propName, defaultValue, isArray) || this;
    }
    /* eslint-enable */
    /**
     * Returns the module of class PathAnnotation.
     *
     * @returns {string}  Returns the module of class PathAnnotation.
     * @private
     */
    PathAnnotation.prototype.getClassName = function () {
        return 'PathAnnotation';
    };
    __decorate$4([
        Property(0.5)
    ], PathAnnotation.prototype, "offset", void 0);
    __decorate$4([
        Complex({ x: 0, y: 0 }, Point)
    ], PathAnnotation.prototype, "displacement", void 0);
    __decorate$4([
        Property('Center')
    ], PathAnnotation.prototype, "alignment", void 0);
    __decorate$4([
        Property(false)
    ], PathAnnotation.prototype, "segmentAngle", void 0);
    return PathAnnotation;
}(Annotation));

/**
 *ShapeDictionary defines the shape of the default nodes and ports \
 *
 * @returns { string }     ShapeDictionary defines the shape of the default nodes and ports.\
 * @param {PortShapes} shape - provide the element value.
 *
 * @private
 */
function getPortShape(shape) {
    return portShapes[shape.toString()];
}
/**
 *ShapeDictionary defines the shape of the default nodes and ports \
 *
 * @returns { string }     ShapeDictionary defines the shape of the default nodes and ports.\
 * @param {DecoratorShapes} shape - provide the element value.
 * @param {DecoratorModel} decorator - provide the element value.
 *
 * @private
 */
function getDecoratorShape(shape, decorator) {
    if (shape === 'Custom') {
        return decorator.pathData;
    }
    return decoratorShapes["" + shape];
}
function getSegmentThumbShapeHorizontal(shapes) {
    return segmentThumbShapeHorizontal["" + shapes];
}
function getSegmentThumbShapeVertical(shapes) {
    return segmentThumbShapeVertical["" + shapes];
}
/**
 *sets the path data for different icon shapes \
 *
 * @returns { string }     sets the path data for different icon shapes\
 * @param {IconShapeModel} icon - provide the element value.
 *
 * @private
 */
function getIconShape(icon) {
    var data;
    switch (icon.shape) {
        case 'Minus':
            data = 'M0,50 L100,50';
            break;
        case 'Plus':
            data = 'M0,-50 L0,50 M-50,0 L50,0';
            break;
        case 'ArrowUp':
            data = 'M0,100 L50,0 L100,100 Z';
            break;
        case 'ArrowDown':
            data = 'M0,0 L50,100 L100,0 Z';
            break;
        case 'Path':
            data = icon.pathData;
            break;
    }
    return data;
}
// eslint-disable-next-line prefer-const
var portShapes = {
    'X': 'M14,14 L106,106 M106,14 L14,106',
    'Circle': 'M0,50 A50,50,0 1 1 100,50 A50,50,0 1 1 0,50 Z',
    'Square': 'M0,0 L10,0 L10,10 L0,10 z'
};
// eslint-disable-next-line prefer-const
var decoratorShapes = {
    'OpenArrow': 'M15.9,23 L5,16 L15.9,9 L17,10.7 L8.7,16 L17,21.3Z',
    'Square': 'M0,0 L10,0 L10,10 L0,10 z',
    'Fletch': 'M14.8,10c0,0-3.5,6,0.2,12c0,0-2.5-6-10.9-6C4.1,16,11.3,16,14.8,10z',
    'OpenFetch': 'M6,17c-0.6,0-1-0.4-1-1s0.4-1,1-1c10.9,0,11-5,11-5' +
        'c0-0.6,0.4-1,1-1s1,0.4,1,1C19,10.3,18.9,17,6,17C6,17,6,17,6,17z ' +
        'M18,23c-0.5,0-1-0.4-1-1c0-0.2-0.3-5-11-5c-0.6,0-1-0.5-1-1s0.4-1,1-1c0,0,0,0,0,0' +
        'c12.9,0,13,6.7,13,7    C19,22.6,18.6,23,18,23z',
    'IndentedArrow': 'M17,10c0,0-4.5,5.5,0,12L5,16L17,10z',
    'OutdentedArrow': 'M14.6,10c0,0,5.4,6,0,12L5,16L14.6,10z',
    'DoubleArrow': 'M19,10 L19,22 L13,16Z M12,10 L12,22 L6,16Z',
    'Arrow': 'M15,10 L15,22 L5,16Z',
    'Diamond': 'M12,23l-7-7l7-7l6.9,7L12,23z',
    'Circle': 'M0,50 A50,50,0 1 1 100,50 A50,50,0 1 1 0,50 Z'
};
var segmentThumbShapeHorizontal = {
    'Square': 'M0,0 L10,0 L10,10 L0,10 z',
    'Rhombus': 'M10,5 L5,10 L0,5 L5,0 L10,5 Z ',
    'Rectangle': 'M0,0 L15,0 L15,10 L0,10 z ',
    'OpenArrow': 'M15.9,23 L5,16 L15.9,9 L17,10.7 L8.7,16 L17,21.3Z',
    'Fletch': 'M9.82,0 C9.82,0,6.61,5,10,10 C10,10,7.71,5,0,5 C0,5,6.61,5,9.82,0 Z ',
    'OpenFetch': 'M0.71,5.71 C0.29,5.71,0,5.43,0,5 C0,4.57,0.29,4.29,0.71,4.29 C8.5,4.29,8.57,0.71,8.57,0.71 C8.57,0.29,8.86,0,9.29,0 C9.719999999999999,0,10,0.29,10,0.71 C10,0.93,9.93,5.71,0.71,5.71 C0.71,5.71,0.71,5.71,0.71,5.71 Z M9.29,10 C8.93,10,8.57,9.71,8.57,9.29 C8.57,9.14,8.36,5.71,0.71,5.71 C0.29,5.71,0,5.36,0,5 C0,4.64,0.29,4.29,0.71,4.29 C0.71,4.29,0.71,4.29,0.71,4.29 C9.93,4.29,10,9.07,10,9.29 C10,9.71,9.71,10,9.29,10 Z ',
    'IndentedArrow': 'M10,0 C10,0,6.25,4.58,10,10 L0,5 L10,0 Z ',
    'OutdentedArrow': 'M8,0 C8,0,12.5,5,8,10 L0,5 L8,0 Z ',
    'DoubleArrow': 'M19,10 L19,22 L13,16Z M12,10 L12,22 L6,16Z',
    'Arrow': 'M15,10 L15,22 L5,16Z',
    'Diamond': 'M10,5 L5,10 L0,5 L5,0 L10,5 Z  ',
    'Circle': 'M10,5 C10,7.76,7.76,10,5,10 C2.24,10,0,7.76,0,5 C0,2.24,2.24,0,5,0 C7.76,0,10,2.24,10,5 Z ',
    'Ellipse': 'M15,5 C15,7.76,11.64,10,7.5,10 C3.36,10,0,7.76,0,5 C0,2.24,3.36,0,7.5,0 C11.64,0,15,2.24,15,5 Z  '
};
var segmentThumbShapeVertical = {
    'Square': 'M0,0 L10,0 L10,10 L0,10 z',
    'Rhombus': 'M10,5 L5,10 L0,5 L5,0 L10,5 Z ',
    'Rectangle': 'M0,0 L15,0 L15,10 L0,10 z',
    'OpenArrow': 'M23,15.9 L16,5 L9,15.9 L10.7,17 L16,8.7 L21,17.3Z',
    'Fletch': 'M9.82,0 C9.82,0,6.61,5,10,10 C10,10,7.71,5,0,5 C0,5,6.61,5,9.82,0 Z ',
    'OpenFetch': 'M0.71,5.71 C0.29,5.71,0,5.43,0,5 C0,4.57,0.29,4.29,0.71,4.29 C8.5,4.29,8.57,0.71,8.57,0.71 C8.57,0.29,8.86,0,9.29,0 C9.719999999999999,0,10,0.29,10,0.71 C10,0.93,9.93,5.71,0.71,5.71 C0.71,5.71,0.71,5.71,0.71,5.71 Z M9.29,10 C8.93,10,8.57,9.71,8.57,9.29 C8.57,9.14,8.36,5.71,0.71,5.71 C0.29,5.71,0,5.36,0,5 C0,4.64,0.29,4.29,0.71,4.29 C0.71,4.29,0.71,4.29,0.71,4.29 C9.93,4.29,10,9.07,10,9.29 C10,9.71,9.71,10,9.29,10 Z ',
    'IndentedArrow': 'M10,0 C10,0,6.25,4.58,10,10 L0,5 L10,0 Z ',
    'OutdentedArrow': 'M8,0 C8,0,12.5,5,8,10 L0,5 L8,0 Z ',
    'DoubleArrow': 'M10,19 L22,19 L16,13Z M10,12 L22,12 L16,6Z',
    'Arrow': 'M10,15 L22,15 L16,5Z',
    'Diamond': 'M10,5 L5,10 L0,5 L5,0 L10,5 Z ',
    'Circle': 'M10,5 C10,7.76,7.76,10,5,10 C2.24,10,0,7.76,0,5 C0,2.24,2.24,0,5,0 C7.76,0,10,2.24,10,5 Z ',
    'Ellipse': 'M15,5 C15,7.76,11.64,10,7.5,10 C3.36,10,0,7.76,0,5 C0,2.24,3.36,0,7.5,0 C11.64,0,15,2.24,15,5 Z   '
};

/**
 * FlowShapeDictionary defines the shape of the built-in flow shapes \
 *
 * @returns { string }     FlowShapeDictionary defines the shape of the built-in flow shapes .\
 * @param {string} shape - provide the element value.
 *
 * @private
 */
function getFlowShape(shape) {
    return flowShapes[shape.toString()];
}
/* eslint-disable */
var flowShapes = {
    // Process,
    'Process': 'M419.511,76.687L359.511,76.687L359.511,43.086L419.511,43.086z',
    // Decision,
    'Decision': 'M 253.005,115.687L 200.567,146.071L 148.097,115.687L 200.534,85.304L 253.005,115.687 Z',
    // Document,
    'Document': 'M 60 31.9 c 0 0 -11 -7.7 -30 0 s -30 0 -30 0 V 0 h 60 V 31.9 Z',
    // PreDefinedProcess,
    'PreDefinedProcess': 'M 0,0 L 50,0 L 50,50 L 0,50 Z  M 8.334,0 L 8.334,50 M 41.667,0 L 41.667,50',
    // Terminator,
    'Terminator': 'M 269.711,29.33C 269.71,44.061 257.77,56 243.04,56L 158.058,56C 143.33,56 131.39,44.061 131.39,29.33L 131.39,29.33' +
        'C 131.391,14.6057 143.33,2.669 158.058,2.669L 243.044,2.669C 257.772,2.669 269.711,14.6057 269.711,29.333 Z',
    // PaperTap,
    'PaperTap': 'M0.0009,17.2042 L0.0009,47.165 C0.001,47.165 14.403,53.5455 25.00,47.165 C35.599,40.7852 44.403,43.5087 50.00,47.165' +
        'L50.001,17.2042 M50.001,32.7987 L50.001,2.8405 C50.001,2.8405 35.599,-3.5427 25.001,2.8405' +
        'C14.403,9.2237 5.599,6.494 0.0009,2.8405 L0.0009,32.7987',
    // DirectData,
    'DirectData': 'M 132.62 0 L 17.38 0 C 7.78 0 0 13.43 0 30 C 0 46.57 7.78 60 17.38 60 L 132.62 60 M 132.62 0' +
        'C 123.02 0 115.24 13.43 115.24 30 C 115.24 46.57 123.02 60 132.62 60 C 142.22 60 150 46.57 150 30 C 150 13.43 142.22 0 132.62 0 z ',
    // SequentialData,
    'SequentialData': 'M0.0029,24.999 C0.0029,11.1922 10.433,0.0021 23.295,0.0021 C36.159,0.00216 46.585,11.1922 46.585,24.999' +
        'C46.585,38.8057 36.159,49.9979 23.295,49.9979 C10.433,49.9979 0.0029,38.8057 0.0029,24.999 z M23.294,49.999 L50.002,49.999',
    // Sort,
    'Sort': 'M50.001,24.9971 L25.001,49.9971 L0.00097,24.9971 L25.001,-0.00286865 L50.001,24.9971 z' +
        ' M0.000976562,24.9971 L50.001,24.9971',
    // MultiDocument,
    'MultiDocument': 'M43.6826,40 C44.8746,40.6183 45.8586,41.3502 46.8366,42.1122 L46.8366,4.74487 L3.09857,4.74487 L3.09857,10.9544' +
        ' M46.837,35.143 C48.027,35.765 49.025,36.604 50.003,37.369 L50.003,0.002 L6.264,0.002 L6.264,4.744 M43.682,47.113 L43.682,10.765' +
        ' L0.0025,10.7652 L0.0025,47.1132 C0.0025,47.1132 12.5846,53.6101 21.8426,47.1132 C31.1006,40.6163 38.792,43.393 43.6826,47.1132 z',
    // Collate,
    'Collate': 'M50.001,0.0028 L25.001,25.0029 L0.00097,0.0028 L50.001,0.002 z M0.0009,50.002 L25.001,25.002' +
        'L50.001,50.002 L0.0009,50.0029 z',
    // SummingJunction,
    'SummingJunction': 'M7.3252,42.6768 L42.6772,7.3247 M42.6768,42.6768 L7.3248,7.3247 M0.0009,25.001 ' +
        'C0.0009,11.193 11.197,0.0009 25.001,0.0009' +
        ' C38.809,0.0009 50.001,11.193 50.001,25.001 C50.001,38.809 38.809,50.001 25.001,50.001 C11.197,50.00 0.0009,38.809 0.0009,25.00 z',
    // Or,
    'Or': 'M 0 50 L 100 50 M 50 100 L 50 0.0 M 0 50 C 0 22.384 22.392 0 50 0 C 77.616 0 100 22.384 100 50' +
        ' C 100 77.616 77.616 100 50 100 C 22.392 100 0 77.616 0 50 Z',
    // InternalStorage,
    'InternalStorage': 'M 0 3.81946A 2.5,3.81946 0 0,1 2.5,0L 47.5 0A 2.5,3.81946 0 0,1 50,3.81946' +
        'L 50 45.836A 2.5,3.819446 0 0,1 47.5,49.652778' +
        'L 2.5 49.652778A 2.5,3.819446 0 0,1 0,45.8336L 0 3.819446ZM 0 11.45834L 50 11.4583334M 12.5 0L 12.5 49.652778',
    // Extract,
    'Extract': 'M0,35 L30,0 L60,35 Z',
    // ManualOperation,
    'ManualOperation': 'M46.4,28.8 L14.8,28.8 L0,0 L60,0 Z',
    // Merge,
    'Merge': 'M60,0 L30,35 L0,0 Z',
    // OffPageReference,
    'OffPageReference': 'M60,33.3 L30.1,39 L0,33.3 L0,0 L60,0 Z',
    // SequentialAccessStorage,
    'SequentialAccessStorage': 'M 60 30 C 60 13.4 46.6 0 30 0 S 0 13.4 0 30 s 13.4 30 30 30 h 28.6 v -6.5 h -9.9' +
        'C 55.5 48 60 39.5 60 30 Z',
    // Annotation,
    'Annotation': 'M49.9984,50.0029 L-0.00271199,50.0029 L-0.00271199,0.00286865 L49.9984,0.00286865',
    // Annotation2,
    'Annotation2': 'M49.9977,50.0029 L25.416,50.0029 L25.416,0.00286865 L49.9977,0.00286865 M25.4166,25.0029 L-0.00227869,25.0029',
    // Data,
    'Data': 'M 10 0 L 40 0 L 30 40 L 0 40 Z',
    // Card,
    'Card': 'M275,60 L400,60 L400,110 L260,110 L260,75 Z',
    // Delay,
    'Delay': 'M0,0 L12.029,0 C14.212999,0 16,1.7869979 16,3.9709952 C16,6.1549926 14.212999,7.9409904 12.029,7.9409904 L0,7.9409904 z',
    // Preparation,
    'Preparation': 'M 1048.17 572 C 1051.06 568.86 1055.17 567.05 1059.5 567 L 1094.51 567'
        + ' C 1098.84 567.05 1102.95 568.86 1105.84 572' +
        ' L 1126.43 595 C 1127.01 596.28 1127.01 597.72 1126.43 599 L 1105.84 622 C 1102.95 625.14 1098.84 626.95 1094.51 627' +
        ' L 1059.5 627 C 1055.17 626.95 1051.06 625.14 1048.17 622 L 1027.58 599 C 1027 597.72 1027 596.28 1027.58 595 L 1048.17 572 Z',
    // Display,
    'Display': 'M47.8809,19.2914 L32.7968,-0.00594145 L11.3902,-0.00594145 C7.93166,-0.00594145 0.00124586,11.187 0.00124586,24.9968' +
        'C0.00124586,38.8032 7.93166,49.9962 11.3902,49.9962 L32.7968,49.99 L47.615,31.038 C47.615,31.0388 52.798,24.9968 47.880,19.2914 z',
    // ManualInput,
    'ManualInput': 'M 912 732 L 1006.85 707 C 1008.2 707 1009.5 707.53 1010.46 708.46 C 1011.41 709.4 1011.95 710.67 1011.95 712' +
        ' L 1011.95 762C 1012 764.41 1010.28 766.52 1007.87 767 L 917.1 767 C 915.75 767 914.45 766.47 913.49 765.54' +
        ' C 912.54 764.6 912 763.33 912 762 L 912 732 Z',
    // LoopLimit,
    'LoopLimit': 'M 8 9 L 27 9 L 33 15 L 33 26 C 33 27 33 27 32 27 L 4 27 C 3 27 2 27 2 26 L 2 15 L 8 9 Z',
    // StoredData
    'StoredData': 'M 5.55 0L 50 0A 1.5,30 0 0,1 50,0A 5.555,25 0 0,0 50,50A 1.5,30 0 0,1 50,50L 5.555 50A 5.55,25 0 0,1 5.555,0Z',
};
/* eslint-enable */

/* eslint-disable jsdoc/require-returns-check */
/**
 * Connector modules are used to dock and update the connectors
 */
/**
 * intermeditatePoints method\
 *
 * @returns {  Function }    getFunction method .\
 * @param {PointModel} element - provide the angle value.
 * @param {PointModel} layoutOrientation - provide the angle value.
 * @param {PointModel} lineDistribution - provide the angle value.
 * @private
 */
function findConnectorPoints(element, layoutOrientation, lineDistribution) {
    //const intermeditatePoints: PointModel[];
    var sourcePoint;
    if (element.type === 'Straight' || !element.sourceWrapper) {
        sourcePoint = getSourcePoint(element);
    }
    else {
        sourcePoint = element.sourceWrapper.corners.center;
    }
    // eslint-disable-next-line
    var intermeditatePoints = terminateConnection(element, sourcePoint, element.targetPoint, layoutOrientation, lineDistribution);
    setLineEndPoint(element, intermeditatePoints[0], false);
    setLineEndPoint(element, intermeditatePoints[intermeditatePoints.length - 1], true);
    return intermeditatePoints;
}
/**
 * getSourcePoint method\
 *
 * @returns {  PointModel }    getFunction method .\
 * @param {PointModel} element - provide the angle value.
 * @private
 */
function getSourcePoint(element) {
    var srcPoint;
    if (element.sourcePortWrapper) {
        var srcPort = element.sourcePortWrapper;
        //const srcNode: DiagramElement = element.sourceWrapper;
        var pt = { x: srcPort.offsetX, y: srcPort.offsetY };
        //const direction: string = getPortDirection(pt, cornersPointsBeforeRotation(srcNode), srcNode.bounds, false);
        srcPoint = pt;
    }
    else if (element.sourceID && element.sourceWrapper) {
        if (element.targetWrapper) {
            var sPoint = element.sourceWrapper.corners.center;
            var tPoint = element.targetWrapper.corners.center;
            srcPoint = getIntersection(element, element.sourceWrapper, sPoint, tPoint, false);
        }
        else {
            srcPoint = element.sourcePoint;
        }
    }
    else {
        srcPoint = element.sourcePoint;
    }
    return srcPoint;
}
/**
 * getDirection method \
 *
 * @returns { void }     getDirection method .\
 * @param {End} source - provide the source value.
 * @param {End} target - provide the target value.
 * @param {LayoutOrientation} layoutOrientation - provide the layoutOrientation value.
 *
 * @private
 */
function getDirection(source, target, layoutOrientation) {
    if (layoutOrientation === 'LeftToRight') {
        source.direction = source.direction ? source.direction : 'Right';
        target.direction = target.direction ? target.direction : 'Left';
    }
    else if (layoutOrientation === 'RightToLeft') {
        source.direction = source.direction ? source.direction : 'Left';
        target.direction = target.direction ? target.direction : 'Right';
    }
    else if (layoutOrientation === 'TopToBottom') {
        source.direction = source.direction ? source.direction : 'Bottom';
        target.direction = target.direction ? target.direction : 'Top';
    }
    else if (layoutOrientation === 'BottomToTop') {
        source.direction = source.direction ? source.direction : 'Top';
        target.direction = target.direction ? target.direction : 'Bottom';
    }
}
/**
 * terminateConnection method \
 *
 * @returns { PointModel[] }     terminateConnection method .\
 * @param {Connector} element - provide the element value.
 * @param {PointModel} srcPoint - provide the srcPoint value.
 * @param {PointModel} tarPoint - provide the tarPoint value.
 * @param {LayoutOrientation} layoutOrientation - provide the layoutOrientation value.
 * @param {boolean} lineDistribution - provide the lineDistribution value.
 *
 * @private
 */
function terminateConnection(element, srcPoint, tarPoint, layoutOrientation, lineDistribution) {
    var sourceNode = element.sourceWrapper;
    var targetNode = element.targetWrapper;
    var sourcePort = element.sourcePortWrapper;
    var targetPort = element.targetPortWrapper;
    var srcCorner;
    var tarCorner;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var intermeditatePoints = [];
    var srcDir;
    var tarDir;
    var minSpace = findMargin(element);
    var sourceMargin = { left: 5, right: 5, bottom: 5, top: 5 };
    var targetMargin = { left: 5, right: 5, bottom: 5, top: 5 };
    var source = { corners: srcCorner, point: srcPoint, direction: srcDir, margin: sourceMargin };
    var target = { corners: tarCorner, point: tarPoint, direction: tarDir, margin: targetMargin };
    var sourceCorners;
    var targetCorners;
    if (sourceNode !== undefined && targetNode !== undefined) {
        sourceCorners = cornersPointsBeforeRotation(sourceNode);
        targetCorners = cornersPointsBeforeRotation(targetNode);
        source.corners = sourceNode.corners;
        target.corners = targetNode.corners;
    }
    if (sourcePort !== undefined) {
        var port = { x: sourcePort.offsetX, y: sourcePort.offsetY };
        if (sourcePort.connectionDirection === 'Left' || sourcePort.connectionDirection === 'Top' || sourcePort.connectionDirection === 'Bottom' || sourcePort.connectionDirection === 'Right') {
            source.direction = sourcePort.connectionDirection;
        }
        else {
            source.direction = getPortDirection(port, sourceCorners, sourceNode.bounds);
        }
    }
    if (targetPort !== undefined) {
        var tarPortPt = { x: targetPort.offsetX, y: targetPort.offsetY };
        if (targetPort.connectionDirection === 'Left' || targetPort.connectionDirection === 'Right' || targetPort.connectionDirection === 'Bottom' || targetPort.connectionDirection === 'Top') {
            target.direction = targetPort.connectionDirection;
        }
        else {
            target.direction = getPortDirection(tarPortPt, targetCorners, targetNode.bounds);
        }
    }
    if (element.type === 'Bezier') {
        if (!element.isBezierEditing) {
            if (element.segments.length > 0) {
                var i = element.segments.length - 1;
                while (i >= 0) {
                    var seg = element.segments[parseInt(i.toString(), 10)];
                    if (seg.isInternalSegment) {
                        element.segments.pop();
                    }
                    i--;
                }
            }
        }
    }
    if (sourceNode !== undefined && targetNode !== undefined) {
        if (source.direction === undefined || target.direction === undefined) {
            if (layoutOrientation) {
                getDirection(source, target, layoutOrientation);
            }
            else {
                if (source.corners.top > target.corners.bottom &&
                    Math.abs(source.corners.top - target.corners.bottom) > minSpace) {
                    source.direction = source.direction ? source.direction : 'Top';
                    target.direction = target.direction ? target.direction : 'Bottom';
                }
                else if (source.corners.bottom < target.corners.top &&
                    Math.abs(source.corners.bottom - target.corners.top) > minSpace) {
                    source.direction = source.direction ? source.direction : 'Bottom';
                    target.direction = target.direction ? target.direction : 'Top';
                }
                else if ((source.corners.right < target.corners.left &&
                    Math.abs(source.corners.right - target.corners.left) > minSpace) ||
                    ((source.corners.right + minSpace < target.corners.left) ||
                        (target.corners.right >= source.corners.left - minSpace && source.corners.left > target.corners.left))) {
                    source.direction = source.direction ? source.direction : 'Right';
                    target.direction = target.direction ? target.direction : 'Left';
                }
                else if ((source.corners.left > target.corners.right &&
                    Math.abs(source.corners.left - target.corners.right) > (source.margin.left + source.margin.right)) ||
                    ((target.corners.right + minSpace < source.corners.left ||
                        (source.corners.right >= target.corners.left - minSpace
                            && source.corners.left < target.corners.left)))) {
                    source.direction = source.direction ? source.direction : 'Left';
                    target.direction = target.direction ? target.direction : 'Right';
                }
                else {
                    if (sourceNode.id !== targetNode.id && (!sourceCorners.equals(sourceCorners, targetCorners)) &&
                        targetCorners.containsPoint(sourceCorners.topCenter, source.margin.top)) {
                        source.direction = source.direction ? source.direction : 'Bottom';
                        target.direction = target.direction ? target.direction : 'Top';
                    }
                    else {
                        source.direction = source.direction ? source.direction : 'Top';
                        target.direction = target.direction ? target.direction : 'Bottom';
                    }
                }
            }
        }
        return defaultOrthoConnection(element, source.direction, target.direction, source.point, target.point, lineDistribution);
    }
    //It will be called only when there is only one end node
    checkLastSegmentasTerminal(element);
    if (element.sourceWrapper || element.targetWrapper) {
        connectToOneEnd(element, source, target);
    }
    if (element.type === 'Straight' || element.type === 'Bezier') {
        intermeditatePoints = intermeditatePointsForStraight(element, source, target);
    }
    else {
        if (element.type === 'Orthogonal' && element.segments && element.segments.length > 0 &&
            element.segments[0].length !== null &&
            element.segments[0].direction !== null) {
            intermeditatePoints = findPointToPointOrtho(element, source, target, sourceNode, targetNode, sourcePort, targetPort);
        }
        else {
            var extra = void 0;
            if (!source.direction) {
                source.direction = (target.direction) ? ((element.targetPortWrapper !== undefined) ? target.direction : getOppositeDirection(target.direction)) :
                    Point.direction(source.point, target.point);
            }
            else {
                extra = adjustSegmentLength(sourceNode.bounds, source, 20);
            }
            element.segments[0].points = intermeditatePoints = orthoConnection3Segment(element, source, target, extra);
        }
    }
    return intermeditatePoints;
}
/**
 * updateSegmentPoints method \
 *
 * @returns { PointModel[] }     updateSegmentPoints method .\
 * @param {End} source - provide the source value.
 * @param {OrthogonalSegment} segment - provide the segment value.
 *
 * @private
 */
function updateSegmentPoints(source, segment) {
    //let segPoint: PointModel; //let angle: number; //let extra: number;
    source.direction = segment.direction;
    segment.points = [];
    segment.points.push(source.point);
    var extra = (segment.direction === 'Left' || segment.direction === 'Top') ? -(segment.length) : segment.length;
    var angle = (segment.direction === 'Left' || segment.direction === 'Right') ? 0 : 90;
    var segPoint = addLineSegment(source.point, extra, angle);
    segment.points.push(segPoint);
    return segPoint;
}
/**
 * pointToPoint method \
 *
 * @returns { void }     pointToPoint method .\
 * @param {Connector} element - provide the element value.
 * @param {End} source - provide the source value.
 * @param {End} target - provide the target value.
 *
 * @private
 */
function pointToPoint(element, source, target) {
    var point;
    var direction;
    var portdirection;
    source.corners = (element.sourceWrapper) ? element.sourceWrapper.corners : undefined;
    if (element.sourcePortWrapper) {
        var port = { x: element.sourcePortWrapper.offsetX, y: element.sourcePortWrapper.offsetY };
        portdirection = getPortDirection(port, cornersPointsBeforeRotation(element.sourceWrapper), element.sourceWrapper.bounds);
        if (source.corners && (source.direction === 'Bottom' || source.direction === 'Top')) {
            if (target.point.x > source.corners.left && target.point.x < source.corners.right) {
                direction = (source.point.y > target.point.y) ? 'Top' : 'Bottom';
            }
        }
        else if (source.corners && (source.direction === 'Left' || source.direction === 'Right')) {
            if (target.point.y > source.corners.top && target.point.y < source.corners.bottom) {
                direction = (source.point.x > target.point.x) ? 'Left' : 'Right';
            }
        }
    }
    if (element.sourcePortWrapper && portdirection === getOppositeDirection(direction)) {
        var length_1;
        if ((portdirection === 'Left' || portdirection === 'Right') && (source.point.y >= source.corners.top
            && source.point.y <= source.corners.center.y) &&
            (target.point.y >= source.corners.top && target.point.y <= source.corners.center.y)) {
            source.direction = 'Top';
            length_1 = source.point.y - source.corners.top + 20;
        }
        else if ((portdirection === 'Left' || portdirection === 'Right') && (source.point.y > source.corners.center.y
            && source.point.y <= source.corners.bottom) &&
            (target.point.y > source.corners.center.y && target.point.y <= source.corners.bottom)) {
            source.direction = 'Bottom';
            length_1 = source.corners.bottom - source.point.y + 20;
        }
        else if ((portdirection === 'Top' || portdirection === 'Bottom') && (source.point.x >= source.corners.left
            && source.point.x <= source.corners.center.x) &&
            (target.point.x >= source.corners.left && target.point.x <= source.corners.center.x)) {
            source.direction = 'Left';
            length_1 = source.point.x - source.corners.left + 20;
        }
        else if ((portdirection === 'Top' || portdirection === 'Bottom') && (source.point.x <= source.corners.right
            && source.point.x > source.corners.center.x) &&
            (target.point.x <= source.corners.right && target.point.x < source.corners.center.x)) {
            source.direction = 'Right';
            length_1 = source.corners.right - source.point.x + 20;
        }
        if (source.direction && length_1) {
            point = orthoConnection3Segment(element, source, target, length_1, true);
        }
    }
    else {
        source.direction = (direction) ? direction : findSourceDirection(source.direction, source.point, target.point);
        point = orthoConnection2Segment(source, target);
    }
    return point;
}
/**
 * pointToNode method \
 *
 * @returns { void }     pointToNode method .\
 * @param {Connector} element - provide the element value.
 * @param {End} source - provide the source value.
 * @param {End} target - provide the target value.
 *
 * @private
 */
function pointToNode(element, source, target) {
    var point;
    target.corners = element.targetWrapper.corners;
    findDirection(element.targetWrapper, source, target, element);
    var direction = findSourceDirection(target.direction, source.point, target.point);
    if (source.direction === target.direction && (source.direction === 'Left' || source.direction === 'Right')) {
        source.direction = direction;
        point = orthoConnection3Segment(element, source, target, element.targetWrapper.width / 2 + 20);
        var source1 = source;
        source1.point = point[1];
        findDirection(element.targetWrapper, source, target, element);
        point = orthoConnection3Segment(element, source, target);
    }
    else {
        source.direction = direction;
        point = orthoConnection2Segment(source, target);
    }
    return point;
}
/**
 * addPoints method \
 *
 * @returns { void }     addPoints method .\
 * @param {Connector} element - provide the element value.
 * @param {End} source - provide the source value.
 * @param {End} target - provide the target value.
 *
 * @private
 */
function addPoints(element, source, target) {
    target.corners = element.targetWrapper.corners;
    var direction;
    var length;
    if (source.direction !== 'Left' && source.direction !== 'Right') {
        if (target.corners.center.y === source.point.y &&
            (!(target.corners.left <= source.point.x && source.point.x <= target.corners.right))) {
            direction = 'Top';
            length = target.corners.height / 2 + 20;
        }
        else if ((target.corners.center.y === source.point.y &&
            element.segments[element.segments.length - 2].direction === 'Bottom') ||
            (target.corners.center.y > source.point.y && source.point.y >= target.corners.top)) {
            direction = 'Top';
            length = (source.point.y - target.corners.top) + 20;
        }
        else if ((target.corners.center.y === source.point.y &&
            element.segments[element.segments.length - 2].direction === 'Top') ||
            (target.corners.center.y < source.point.y && source.point.y <= target.corners.bottom)) {
            direction = 'Bottom';
            length = (target.corners.bottom - source.point.y) + 20;
        }
        else if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&
            source.corners.top <= source.point.y && source.point.y <= source.corners.bottom) {
            direction = source.direction;
            length = (source.point.y > target.point.y) ? (source.point.y - source.corners.top + 20) :
                (source.corners.bottom - source.point.y + 20);
        }
    }
    else {
        if (target.corners.center.x === source.point.x &&
            (!(target.corners.top < source.point.y && source.point.y <= target.corners.bottom))) {
            direction = 'Left';
            length = target.corners.width / 2 + 20;
        }
        else if ((target.corners.center.x === source.point.x &&
            element.segments[element.segments.length - 2].direction === 'Right')
            || (target.corners.center.x > source.point.x && source.point.x >= target.corners.left)) {
            direction = 'Left';
            length = (source.point.x - target.corners.left) + 20;
        }
        else if ((target.corners.center.x === source.point.x &&
            element.segments[element.segments.length - 2].direction === 'Left') ||
            (target.corners.center.x <= source.point.x && source.point.x <= target.corners.right)) {
            direction = 'Right';
            length = (target.corners.right - source.point.x) + 20;
        }
        else if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&
            source.corners.left <= source.point.x && source.point.x <= source.corners.right) {
            direction = source.direction;
            length = (source.point.x > target.point.x) ? (source.point.x - source.corners.left + 20) :
                (source.corners.right - source.point.x + 20);
        }
    }
    var extra = (direction === 'Left' || direction === 'Top') ? -(length) : length;
    var angle = (direction === 'Left' || direction === 'Right') ? 0 : 90;
    var refPoint = source.point;
    source.point = addLineSegment(source.point, extra, angle);
    source.direction = Point.direction(source.point, target.point);
    if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&
        (source.corners.center.x === target.corners.center.x || source.corners.center.y === target.corners.center.y)) {
        source.direction = target.direction;
    }
    var point = orthoConnection3Segment(element, source, target);
    point.splice(0, 0, refPoint);
    return point;
}
/**
 * findSegmentDirection method \
 *
 * @returns { void }     findSegmentDirection method .\
 * @param {Connector} element - provide the element value.
 * @param {End} source - provide the source value.
 * @param {End} target - provide the target value.
 * @param {Direction} portDir - provide the target value.
 *
 * @private
 */
function findSegmentDirection(element, source, target, portDir) {
    var update = false;
    switch (target.direction) {
        case 'Left':
            if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && (portDir === 'Right' &&
                source.point.x > target.point.x && source.point.y >= source.corners.top &&
                source.point.y <= source.corners.bottom)
                || (((portDir === 'Bottom' && source.point.y > target.point.y) ||
                    (portDir === 'Top' && source.point.y < target.point.y)) &&
                    source.point.x >= source.corners.left && source.point.x <= source.corners.right)) {
                source.direction = (portDir === 'Right') ? ((source.point.y > target.point.y) ? 'Top' : 'Bottom') :
                    (source.point.x < target.point.x ? 'Right' : 'Left');
                update = true;
            }
            else if (source.point.x > target.point.x && (source.point.y > target.point.y || source.point.y < target.point.y)
                && (!(target.corners.top > source.point.y && target.corners.bottom < source.point.y))) {
                source.direction = 'Left';
            }
            else if ((source.point.x < target.point.x && source.point.y > target.point.y) ||
                (source.point.x > target.point.x && (source.point.y <= target.point.y)
                    && ((target.corners.top < source.point.y && target.corners.center.y >= source.point.y)))) {
                source.direction = 'Top';
            }
            else if ((source.point.x < target.point.x && source.point.y < target.point.y) ||
                (source.point.x > target.point.x && (source.point.y > target.point.y)
                    && ((target.corners.bottom < source.point.y && target.corners.center.y > source.point.y)))) {
                source.direction = 'Bottom';
            }
            else if (source.point.y === target.point.y && source.point.x < target.point.x) {
                source.direction = 'Right';
            }
            break;
        case 'Right':
            if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&
                ((portDir === 'Bottom' && source.point.y > target.point.y) ||
                    (portDir === 'Top' && source.point.y < target.point.y)) && source.point.x > target.point.x &&
                (source.point.x >= source.corners.left && source.point.x <= source.corners.right)) {
                source.direction = (source.point.x > target.point.x) ? 'Left' : 'Right';
                update = true;
            }
            else if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&
                portDir === 'Left' && source.point.x < target.point.x && (source.point.y >= source.corners.top &&
                source.point.y <= source.corners.bottom)) {
                source.direction = (source.point.y > target.point.y) ? 'Top' : 'Bottom';
                update = true;
            }
            else if (source.point.x < target.point.x && target.corners.top <= source.point.y
                && target.corners.bottom >= source.point.y && source.point.y === target.point.y) {
                source.direction = 'Top';
            }
            else if (source.point.y > target.point.y && source.point.x > target.point.x) {
                source.direction = 'Top';
            }
            else if (source.point.y < target.point.y && source.point.x > target.point.x) {
                source.direction = 'Bottom';
            }
            else if (source.point.x < target.point.x && (source.point.y > target.point.y ||
                source.point.y < target.point.y)) {
                source.direction = 'Right';
            }
            else if (source.point.y === target.point.y && source.point.x > target.point.x) {
                source.direction = 'Left';
            }
            break;
        case 'Top':
            if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && (portDir === 'Bottom' &&
                source.point.y > target.point.y && source.point.x >= source.corners.left &&
                source.point.x <= source.corners.right) || (((portDir === 'Right' && source.point.x > target.point.x) ||
                (portDir === 'Left' && target.point.y > source.point.y && target.point.x > source.point.x)) &&
                (source.point.y >= source.corners.top && source.point.y <= source.corners.bottom))) {
                source.direction = (portDir === 'Bottom') ? ((source.point.x > target.point.x) ? 'Left' : 'Right') :
                    (source.point.y < target.point.y) ? 'Bottom' : 'Top';
                update = true;
            }
            else if (source.point.x === target.point.x && source.point.y < target.point.y) {
                source.direction = 'Bottom';
            }
            else if (source.point.y > target.point.y && source.point.x > target.corners.left &&
                source.point.x < target.corners.right) {
                source.direction = 'Left';
            }
            else if (source.point.y >= target.point.y) {
                source.direction = 'Top';
            }
            else if (source.point.y < target.point.y && source.point.x > target.point.x) {
                source.direction = 'Left';
            }
            else if (source.point.y < target.point.y && source.point.x < target.point.x) {
                source.direction = 'Right';
            }
            break;
        case 'Bottom':
            if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && ((((portDir === 'Right') ||
                (portDir === 'Left' && target.point.x > source.point.x)) && (source.point.y > target.point.y) &&
                source.point.y >= source.corners.top && source.point.y <= source.corners.bottom) ||
                (((portDir === 'Top' && source.point.y < target.point.y)) &&
                    (source.point.x >= source.corners.left && source.point.x <= source.corners.right)))) {
                if (portDir === 'Right' || portDir === 'Left') {
                    source.direction = (source.point.y > target.point.y) ? 'Top' : 'Bottom';
                }
                else {
                    source.direction = (source.point.x > target.point.x) ? 'Left' : 'Right';
                }
                update = true;
            }
            else if (source.point.y < target.point.y && source.point.x > target.corners.left &&
                target.corners.right > source.point.x) {
                if (source.point.y < target.point.y && source.point.x > target.corners.left &&
                    target.corners.center.x >= source.point.x) {
                    source.direction = 'Left';
                }
                else if (source.point.y < target.point.y && source.point.x < target.corners.right &&
                    target.corners.center.x < source.point.x) {
                    source.direction = 'Right';
                }
            }
            else if (source.point.y > target.point.y && source.point.x > target.point.x) {
                source.direction = 'Left';
            }
            else if (source.point.y > target.point.y && source.point.x < target.point.x) {
                source.direction = 'Right';
            }
            else if (source.point.y <= target.point.y && (source.point.x > target.point.x || target.point.x > source.point.x)) {
                source.direction = 'Bottom';
            }
            break;
    }
    return update;
}
/**
 * pointToPort method \
 *
 * @returns { void }     pointToPort method .\
 * @param {Connector} element - provide the element value.
 * @param {End} source - provide the source value.
 * @param {End} target - provide the target value.
 *
 * @private
 */
function pointToPort(element, source, target) {
    var point;
    target.corners = element.targetWrapper.corners;
    var portdirection;
    var length;
    if (element.sourcePortWrapper !== undefined) {
        var port = { x: element.sourcePortWrapper.offsetX, y: element.sourcePortWrapper.offsetY };
        portdirection = getPortDirection(port, cornersPointsBeforeRotation(element.sourceWrapper), element.sourceWrapper.bounds);
    }
    var update = findSegmentDirection(element, source, target, portdirection);
    // EJ2-65063 - Added below condition !selectedSegmentIndex to prevent the connector segment to split from two points into four points
    if ((!element.selectedSegmentIndex) && element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&
        target.direction === getOppositeDirection(portdirection) &&
        ((((target.direction === 'Left' && source.point.x > target.point.x) || (target.direction === 'Right' &&
            source.point.x < target.point.x)) && source.point.y >= source.corners.top &&
            source.point.y <= source.corners.bottom) || (target.direction === 'Bottom' && source.point.y < target.point.y &&
            (source.point.x >= source.corners.left && source.point.x <= source.corners.right)))) {
        point = addPoints(element, source, target);
    }
    else if ((!element.selectedSegmentIndex) && source.direction === target.direction) {
        point = orthoConnection3Segment(element, source, target);
    }
    else if ((!element.selectedSegmentIndex) && (((target.direction === 'Left' && source.point.x > target.point.x) ||
        (target.direction === 'Right' && source.point.x < target.point.x)) && (source.direction === 'Top' || source.direction === 'Bottom')
        && ((source.point.y <= target.point.y) &&
            ((target.corners.top <= source.point.y && target.corners.bottom >= source.point.y)))) ||
        ((target.direction === 'Top' && source.point.y > target.point.y) ||
            (target.direction === 'Bottom' && source.point.y < target.point.y) &&
                ((target.corners.left <= source.point.x && target.corners.right >= source.point.x)))) {
        // EJ2-69304 - Return the 2 segment points if allowNodeOverlap is set as true.
        if (!element.selectedSegmentIndex) {
            point = addPoints(element, source, target);
        }
        else {
            point = orthoConnection2Segment(source, target);
        }
    }
    else {
        if ((!element.selectedSegmentIndex) && element.sourceWrapper !== undefined && element.targetWrapper !== undefined
            && element.targetPortWrapper !== undefined && ((source.direction === 'Left' || source.direction === 'Right')
            && (source.point.y >= source.corners.top && source.point.y <= source.corners.bottom)
            && (target.direction === 'Top' || target.direction === 'Bottom') &&
            (target.corners.center.x === source.corners.center.x))) {
            source.direction = (target.direction === 'Top') ? 'Bottom' : 'Top';
            length = (target.direction === 'Top') ? (source.corners.bottom - source.point.y + 20) :
                (source.point.y - source.corners.top + 20);
            point = orthoConnection3Segment(element, source, target, length);
        }
        else if ((!element.selectedSegmentIndex) && element.sourceWrapper !== undefined && element.targetWrapper !== undefined
            && element.targetPortWrapper !== undefined && ((source.direction === 'Top' || source.direction === 'Bottom') &&
            (source.point.x >= source.corners.left && source.point.x <= source.corners.right) &&
            (target.direction === 'Left' || target.direction === 'Right') && (target.corners.center.y === source.corners.center.y))) {
            source.direction = (target.direction === 'Left') ? 'Right' : 'Left';
            length = (target.direction === 'Left') ? (source.corners.right - source.point.x + 20) :
                (source.point.x - source.corners.left + 20);
            point = orthoConnection3Segment(element, source, target, length);
        }
        else if (update) {
            if (source.direction === 'Left' || source.direction === 'Right') {
                length = (source.direction === 'Left') ? (source.point.x - source.corners.left + 20) :
                    (source.corners.right - source.point.x + 20);
            }
            else {
                length = (source.direction === 'Top') ? (source.point.y - source.corners.top + 20) :
                    (source.corners.bottom - source.point.y + 20);
            }
            point = orthoConnection3Segment(element, source, target, length);
        }
        else {
            point = orthoConnection2Segment(source, target);
        }
    }
    return point;
}
/**
 * findPointToPointOrtho method \
 *
 * @returns { void }     findPointToPointOrtho method .\
 * @param {Connector} element - provide the element value.
 * @param {DiagramElement} source - provide the source value.
 * @param {DiagramElement} target - provide the target value.
 * @param {DiagramElement} sourceNode - provide the target value.
 * @param {DiagramElement} targetNode - provide the target value.
 * @param {DiagramElement} sourcePort - provide the sourcePort value.
 * @param {DiagramElement} targetPort - provide the targetPort value.
 *
 * @private
 */
function findPointToPointOrtho(element, source, target, sourceNode, targetNode, sourcePort, targetPort) {
    var j;
    var point;
    var intermeditatePoints = [];
    var direction;
    var port; //let seg: OrthogonalSegment;
    checkLastSegmentasTerminal(element);
    var removeSegment;
    if (element.segments.length > 0) {
        for (var i = 0; i < element.segments.length; i++) {
            var seg = element.segments[parseInt(i.toString(), 10)];
            if (i === 0 && element.sourcePortWrapper !== undefined) {
                port = { x: sourcePort.offsetX, y: sourcePort.offsetY };
                direction = getPortDirection(port, cornersPointsBeforeRotation(sourceNode), sourceNode.bounds);
                if (seg.direction === getOppositeDirection(direction)) {
                    seg.direction = direction;
                }
            }
            if (i > 0 && element.segments[i - 1].direction === seg.direction) {
                i = checkConsectiveSegmentAsSame(element, i, source);
            }
            else {
                var lastSegment = element.segments[i - 1];
                source.point = (seg.direction) ? updateSegmentPoints(source, seg) :
                    lastSegment.points[lastSegment.points.length - 1];
            }
            if (i === element.segments.length - 1) {
                if (!targetPort && !targetNode) {
                    point = pointToPoint(element, source, target);
                }
                else if (element.targetWrapper && element.targetPortWrapper === undefined) {
                    checkSourcePointInTarget(element, source);
                    point = pointToNode(element, source, target);
                }
                else {
                    point = pointToPort(element, source, target);
                }
                if (point) {
                    checkPreviousSegment(point, element);
                    seg.points = [];
                    if (point.length >= 2) {
                        for (j = 0; j < point.length; j++) {
                            seg.points.push(point[parseInt(j.toString(), 10)]);
                        }
                    }
                    else {
                        removeSegment = i;
                    }
                }
            }
            if (sourcePort && i === 0) {
                var sourcePoint = checkPortdirection(element, sourcePort, sourceNode);
                if (sourcePoint) {
                    source.point = sourcePoint;
                }
            }
        }
        if (removeSegment !== undefined) {
            if (removeSegment === element.segments.length - 1) {
                element.segments[removeSegment - 1].direction = null;
                element.segments[removeSegment - 1].length = null;
            }
            element.segments.splice(removeSegment, 1);
        }
        intermeditatePoints = returnIntermeditatePoints(element, intermeditatePoints);
    }
    return intermeditatePoints;
}
/**
 * checkPortdirection method \
 *
 * @returns { PointModel }     checkPortdirection method .\
 * @param {Connector} element - provide the element value.
 * @param {DiagramElement} sourcePort - provide the target value.
 * @param {DiagramElement} sourceNode - provide the target value.
 *
 * @private
 */
function checkPortdirection(element, sourcePort, sourceNode) {
    var port = { x: sourcePort.offsetX, y: sourcePort.offsetY };
    var point;
    var bounds = cornersPointsBeforeRotation(sourceNode);
    var direction = getPortDirection(port, bounds, sourceNode.bounds);
    var seg = element.segments[0];
    if (seg.direction !== direction) {
        pointsFromNodeToPoint(seg, direction, bounds, seg.points[0], seg.points[seg.points.length - 1], false);
        point = seg.points[seg.points.length - 1];
        seg.direction = Point.direction(seg.points[seg.points.length - 2], seg.points[seg.points.length - 1]);
    }
    return point;
}
/**
 * checkPreviousSegment method \
 *
 * @returns { PointModel }     checkPreviousSegment method .\
 * @param {Connector} tPoints - provide the element value.
 * @param {DiagramElement} connector - provide the target value.
 * @param {DiagramElement} source - provide the target value.
 *
 * @private
 */
function checkPreviousSegment(tPoints, connector, source) {
    var actualSegment = connector.segments[connector.segments.length - 2];
    var actualLastPoint = actualSegment.points[actualSegment.points.length - 1];
    var direction;
    if (((actualSegment.direction === 'Top' || actualSegment.direction === 'Bottom') && (actualLastPoint.x === tPoints[1].x)) ||
        ((actualSegment.direction === 'Left' || actualSegment.direction === 'Right') && (actualLastPoint.y === tPoints[1].y))) {
        actualSegment.points[actualSegment.points.length - 1] = tPoints[1];
        direction = Point.direction(actualSegment.points[0], actualSegment.points[actualSegment.points.length - 1]);
        if (connector.sourceWrapper !== undefined && connector.sourcePortWrapper === undefined &&
            direction === getOppositeDirection(actualSegment.direction)) {
            if (actualSegment.direction === 'Left' || actualSegment.direction === 'Right') {
                actualSegment.points[0].x = (actualSegment.direction === 'Right') ?
                    actualSegment.points[0].x - connector.sourceWrapper.corners.width :
                    actualSegment.points[0].x + connector.sourceWrapper.corners.width;
            }
            else {
                actualSegment.points[0].y = (actualSegment.direction === 'Bottom') ?
                    actualSegment.points[0].y - connector.sourceWrapper.corners.height :
                    actualSegment.points[0].y + connector.sourceWrapper.corners.height;
            }
        }
        actualSegment.direction = direction;
        actualSegment.length = Point.distancePoints(actualSegment.points[0], actualSegment.points[actualSegment.points.length - 1]);
        tPoints.splice(0, 1);
    }
}
/**
 * connectToOneEnd method \
 *
 * @returns { void }     connectToOneEnd method .\
 * @param {Connector} element - provide the element value.
 * @param {DiagramElement} source - provide the target value.
 * @param {DiagramElement} target - provide the target value.
 *
 * @private
 */
function connectToOneEnd(element, source, target) {
    var sourcePort = element.sourcePortWrapper;
    var targetPort = element.targetPortWrapper;
    var node = element.sourceWrapper;
    var fixedPoint = source.point;
    var nodeMargin = { left: 0, right: 0, top: 0, bottom: 0 };
    var nodeConnectingPoint = { x: 0, y: 0 };
    var refPoint;
    var nodeDirection = 'Top';
    if (!node) {
        node = element.targetWrapper;
        nodeMargin = target.margin;
    }
    else {
        fixedPoint = target.point;
        nodeMargin = source.margin;
    }
    if (element.type === 'Orthogonal') {
        if ((element.segments && element.segments.length > 0) && element.sourceWrapper &&
            element.segments[0].direction) {
            source.direction = element.segments[0].direction;
            nodeConnectingPoint = findPoint(node.corners, source.direction);
            refPoint = findPoint(node.corners, getOppositeDirection(source.direction));
            nodeConnectingPoint = getIntersection(element, node, nodeConnectingPoint, refPoint, false);
        }
        else {
            var source_1 = { corners: null, direction: null, point: fixedPoint, margin: nodeMargin };
            var target_1 = { corners: null, direction: null, point: null, margin: null };
            findDirection(node, source_1, target_1, element);
            nodeConnectingPoint = target_1.point;
            nodeDirection = target_1.direction;
        }
    }
    else {
        var segmentPoint = void 0;
        if (element.segments && element.segments.length > 1) {
            if (node === element.sourceWrapper) {
                segmentPoint = element.segments[0].point;
            }
            else {
                segmentPoint = element.segments[element.segments.length - 2].point;
            }
        }
        nodeConnectingPoint = getIntersection(element, node, node.bounds.center, (element.segments && element.segments.length > 1) ? segmentPoint : fixedPoint, node === element.targetWrapper);
    }
    if (node === element.sourceWrapper) {
        source.direction = source.direction || nodeDirection;
        source.point = nodeConnectingPoint;
        if (element.sourcePortWrapper) {
            source.point = { x: sourcePort.offsetX, y: sourcePort.offsetY };
            if (element.sourcePadding) {
                source.point = addPaddingToConnector(element, source, target, false);
            }
        }
    }
    else {
        target.direction = target.direction || nodeDirection;
        target.point = nodeConnectingPoint;
        if (element.targetPortWrapper) {
            target.point = { x: targetPort.offsetX, y: targetPort.offsetY };
            if (element.targetPadding) {
                target.point = addPaddingToConnector(element, source, target, true);
            }
        }
    }
}
/**
 * addPaddingToConnector method \
 *
 * @returns { void }     addPaddingToConnector method .\
 * @param {Connector} element - provide the element value.
 * @param {DiagramElement} source - provide the target value.
 * @param {DiagramElement} target - provide the target value.
 * @param {DiagramElement} isTarget - provide the target value.
 *
 * @private
 */
function addPaddingToConnector(element, source, target, isTarget) {
    var sourcePort = element.sourcePortWrapper;
    var targetPort = element.targetPortWrapper;
    var padding = (isTarget) ? element.targetPadding : element.sourcePadding;
    var paddingPort = (isTarget) ? targetPort : sourcePort;
    var rect = new Rect(paddingPort.bounds.x - padding, paddingPort.bounds.y - padding, paddingPort.actualSize.width + 2 * padding, paddingPort.actualSize.height + 2 * padding);
    var segmentPoints = [rect.topLeft, rect.topRight, rect.bottomRight, rect.bottomLeft];
    segmentPoints[segmentPoints.length] = segmentPoints[0];
    //const length: number = segmentPoints.length;
    var thisSegment = { x1: source.point.x, y1: source.point.y, x2: target.point.x, y2: target.point.y };
    var point = (isTarget) ? target.point : source.point;
    return getIntersectionPoints(thisSegment, segmentPoints, true, point) || point;
}
/**
 * checkSourceAndTargetIntersect method \
 *
 * @returns { void }     checkSourceAndTargetIntersect method .\
 * @param {DiagramElement} sourceWrapper - provide the sourceWrapper value.
 * @param {DiagramElement} targetWrapper - provide the targetWrapper value.
 * @param {Connector} connector - provide the Connector value.
 *
 * @private
 */
function checkSourceAndTargetIntersect(sourceWrapper, targetWrapper, connector) {
    var sourceSegment = createSegmentsCollection(sourceWrapper, connector.sourcePadding);
    var targetSegment = createSegmentsCollection(targetWrapper, connector.targetPadding);
    for (var i = 0; i < sourceSegment.length - 1; i++) {
        var srcSegment = sourceSegment[parseInt(i.toString(), 10)];
        for (var j = 0; j < targetSegment.length - 1; j++) {
            var tarSegmet = targetSegment[parseInt(j.toString(), 10)];
            if (intersect3(srcSegment, tarSegmet).enabled) {
                return true;
            }
        }
    }
    return false;
}
/**
 * createSegmentsCollection method \
 *
 * @returns { Segment[] }     createSegmentsCollection method .\
 * @param {DiagramElement} sourceWrapper - provide the sourceWrapper value.
 * @param {number} padding - provide the padding value.
 *
 * @private
 */
function createSegmentsCollection(sourceWrapper, padding) {
    var segments = [];
    var points = getPoints(sourceWrapper, sourceWrapper.corners, padding);
    points.push(points[0]);
    for (var i = 0; i < points.length - 1; i++) {
        segments.push(createLineSegment(points[parseInt(i.toString(), 10)], points[i + 1]));
    }
    return segments;
}
/**
 * createLineSegment method \
 *
 * @returns { Segment }     createLineSegment method .\
 * @param {PointModel} sPt - provide the sourceWrapper value.
 * @param {PointModel} tPt - provide the padding value.
 *
 * @private
 */
function createLineSegment(sPt, tPt) {
    var line = { x1: sPt.x, y1: sPt.y, x2: tPt.x, y2: tPt.y };
    return line;
}
/**
 * swapBounds method \
 *
 * @returns { Corners }     swapBounds method .\
 * @param {PointModel} object - provide the sourceWrapper value.
 * @param {PointModel} bounds - provide the padding value.
 * @param {Rect} outerBounds - provide the padding value.
 *
 * @private
 */
function swapBounds(object, bounds, outerBounds) {
    var rectBounds;
    var rotateAngle = object.rotateAngle + object.parentTransform;
    if (rotateAngle) {
        if (rotateAngle < 45) {
            return bounds;
        }
        else if (rotateAngle <= 135) {
            rectBounds = {
                width: bounds.width, height: bounds.height,
                topLeft: bounds.bottomLeft, topCenter: bounds.middleLeft, topRight: bounds.topLeft,
                middleLeft: bounds.bottomCenter, center: outerBounds.center, middleRight: bounds.topCenter,
                bottomLeft: bounds.bottomRight, bottomCenter: bounds.middleRight, bottomRight: bounds.topRight,
                left: outerBounds.left, right: outerBounds.right, top: outerBounds.top, bottom: outerBounds.bottom
            };
        }
        else if (rotateAngle <= 225) {
            rectBounds = {
                width: bounds.width, height: bounds.height,
                topLeft: bounds.bottomLeft, topCenter: bounds.bottomCenter, topRight: bounds.bottomRight,
                middleLeft: bounds.middleRight, center: outerBounds.center, middleRight: bounds.middleLeft,
                bottomLeft: bounds.topLeft, bottomCenter: bounds.topCenter, bottomRight: bounds.topRight,
                left: outerBounds.left, right: outerBounds.right, top: outerBounds.top,
                bottom: outerBounds.bottom
            };
        }
        else if (rotateAngle <= 315) {
            rectBounds = {
                width: bounds.width, height: bounds.height,
                topLeft: bounds.topRight, topCenter: bounds.middleRight, topRight: bounds.bottomRight,
                middleLeft: bounds.topCenter, center: outerBounds.center, middleRight: bounds.bottomCenter,
                bottomLeft: bounds.topLeft, bottomCenter: bounds.middleLeft, bottomRight: bounds.bottomLeft,
                left: outerBounds.left, right: outerBounds.right, top: outerBounds.top, bottom: outerBounds.bottom
            };
        }
        else {
            return bounds;
        }
        return rectBounds;
    }
    return bounds;
}
/**
 * defaultOrthoConnection method \
 *
 * @returns { PointModel[] }     defaultOrthoConnection method .\
 * @param {Connector} ele - provide the Connector value.
 * @param {Direction} srcDir - provide the srcDir value.
 * @param {Direction} tarDir - provide the srcDir value.
 * @param {PointModel} sPt - provide the sPt value.
 * @param {PointModel} tPt - provide the tPt value.
 * @param {Rect} lineDistribution - provide the padding value.
 *
 * @private
 */
/* tslint:disable */
// eslint-disable-next-line
function defaultOrthoConnection(ele, srcDir, tarDir, sPt, tPt, lineDistribution) {
    var sourceEle = ele.sourceWrapper;
    var targetEle = ele.targetWrapper;
    var srcPort = ele.sourcePortWrapper;
    var tarPort = ele.targetPortWrapper;
    var intermeditatePoints = [];
    var refPoint;
    var srcCor = sourceEle.corners;
    // eslint-disable-next-line
    var tarCor = targetEle.corners;
    var point = tarCor.center; //const i: number;
    var sourceMargin = { left: 5, right: 5, bottom: 5, top: 5 };
    var targetMargin = { left: 5, right: 5, bottom: 5, top: 5 };
    var source = { corners: srcCor, point: sPt, direction: srcDir, margin: sourceMargin };
    // eslint-disable-next-line
    var target = { corners: tarCor, point: tPt, direction: tarDir, margin: targetMargin };
    var srcBounds = swapBounds(sourceEle, srcCor, ele.sourceWrapper.bounds);
    var tarBounds = swapBounds(targetEle, tarCor, ele.targetWrapper.bounds);
    var isInterSect = false;
    if (ele.sourceWrapper && ele.targetWrapper) {
        isInterSect = checkSourceAndTargetIntersect(ele.sourceWrapper, ele.targetWrapper, ele);
    }
    if (srcPort !== undefined) {
        source.point = { x: srcPort.offsetX, y: srcPort.offsetY };
        switch (source.direction) {
            case 'Bottom':
            case 'Top':
                // eslint-disable-next-line
                source.point.y = source.point.y;
                break;
            case 'Left':
            case 'Right':
                // eslint-disable-next-line
                source.point.x = source.point.x;
                break;
        }
        if (ele.sourcePadding && !isInterSect) {
            if (tarPort) {
                target.point = {
                    x: tarPort.offsetX,
                    y: tarPort.offsetY
                };
            }
            source.point = addPaddingToConnector(ele, source, target, false);
        }
    }
    else {
        if (ele.type === 'Orthogonal' || ele.type === 'Bezier') {
            if (ele.segments && ele.segments.length > 0 && ele.segments[0].direction) {
                source.direction = ele.segments[0].direction;
            }
            source.point = findPoint(srcBounds, source.direction);
            refPoint = findPoint(srcBounds, getOppositeDirection(source.direction));
            source.point = getIntersection(ele, sourceEle, source.point, refPoint, false);
        }
        else {
            source.point = sourceEle.corners.center;
        }
    }
    if (tarPort !== undefined) {
        target.point = {
            x: tarPort.offsetX,
            y: tarPort.offsetY
        };
        switch (target.direction) {
            case 'Bottom':
            case 'Top':
                // eslint-disable-next-line
                target.point.y = target.point.y;
                break;
            case 'Left':
            case 'Right':
                // eslint-disable-next-line
                target.point.x = target.point.x;
                break;
        }
        if (ele.targetPadding && !isInterSect) {
            target.point = addPaddingToConnector(ele, source, target, true);
        }
    }
    else {
        if (ele.type === 'Orthogonal' || ele.type === 'Bezier') {
            target.point = findPoint(tarBounds, target.direction);
            refPoint = findPoint(tarBounds, getOppositeDirection(target.direction));
            target.point = getIntersection(ele, targetEle, target.point, refPoint, true);
        }
        else {
            target.point = targetEle.corners.center;
        }
    }
    if (ele.type !== 'Orthogonal') {
        var segment = void 0;
        var first = void 0;
        if (ele.type === 'Bezier') {
            //EJ2-67651 - Bezier segment points are static when we move the connector's source or target node.
            if ((ele.bezierSettings.allowSegmentsReset || (ele.segments.length === 0 ||
                (!Point.isEmptyPoint(ele.segments[ele.segments.length - 1].point))))) {
                intermeditatePoints = findOrthoSegments(ele, source, target, undefined, lineDistribution);
                intermeditatePoints = intermeditatePointsForStraight(ele, source, target);
                return intermeditatePoints;
            }
            else {
                checkLastSegmentasTerminal(ele);
            }
        }
        else {
            checkLastSegmentasTerminal(ele);
        }
        if (ele.sourcePortWrapper === undefined) {
            source.point = source.corners.center;
            if (ele.segments && ele.segments.length > 0) {
                first = ele.segments[0];
                segment = (!Point.isEmptyPoint(first.point)) ? first : undefined;
            }
            var tarPoint = (segment !== undefined) ? segment.point : target.point;
            if (ele.type === 'Bezier' && ele.segments.length > 0 &&
                ele.segments[0].vector1.angle && ele.segments[0].vector1.distance) {
                var value = Math.max(source.corners.width, source.corners.height);
                tarPoint = Point.transform(source.point, ele.segments[0].vector1.angle, value / 2);
            }
            source.point = isInterSect ? ele.sourceWrapper.bounds.center : getIntersection(ele, sourceEle, source.point, tarPoint, false);
        }
        if (ele.targetPortWrapper === undefined) {
            target.point = target.corners.center;
            if (ele.segments && ele.segments.length > 1) {
                first = ele.segments[ele.segments.length - 2];
                segment = (!Point.isEmptyPoint(first.point)) ? first : undefined;
            }
            var srcPoint = (segment) ? segment.point : source.point;
            if (ele.type === 'Bezier' && ele.segments.length > 0 &&
                ele.segments[ele.segments.length - 1].vector2.angle &&
                ele.segments[ele.segments.length - 1].vector2.distance) {
                var value = Math.max(source.corners.width, source.corners.height);
                srcPoint = Point.transform(target.point, ele.segments[0].vector2.angle, value / 2);
            }
            target.point = isInterSect ? ele.targetWrapper.bounds.center : getIntersection(ele, targetEle, srcPoint, target.point, true);
        }
        intermeditatePoints = intermeditatePointsForStraight(ele, source, target);
    }
    else {
        if (ele.type === 'Orthogonal' && (ele.segments && ele.segments.length > 0) &&
            ele.segments[0].direction !== null) {
            intermeditatePoints = findIntermeditatePoints(ele, source, target, srcPort, tarPort, sourceEle);
        }
        else {
            if (!ele.segments[0]) {
                var segment = new OrthogonalSegment(ele, 'segments', { type: 'Orthogonal' }, true);
                ele.segments.push(segment);
            }
            // eslint-disable-next-line
            ele.segments[0].points = intermeditatePoints = findOrthoSegments(ele, source, target, undefined, lineDistribution);
        }
    }
    return intermeditatePoints;
}
/**
 * intermeditatePointsForStraight method \
 *
 * @returns { PointModel[] }     intermeditatePointsForStraight method .\
 * @param {Connector} element - provide the Connector value.
 * @param {End} source - provide the source value.
 * @param {End} target - provide the target value.
 *
 * @private
 */
function intermeditatePointsForStraight(element, source, target) {
    var intermeditatePoints = [];
    if (element.segments && element.segments.length > 0) {
        var i = void 0;
        var segPoint = [];
        var srcPoint = source.point;
        for (i = 0; i < element.segments.length; i++) {
            var seg = element.segments[parseInt(i.toString(), 10)];
            segPoint = [];
            segPoint.push(srcPoint);
            if (i !== element.segments.length - 1) {
                segPoint.push(seg.point);
                srcPoint = seg.point;
            }
            else {
                segPoint.push(target.point);
            }
            element.segments[parseInt(i.toString(), 10)].points = segPoint;
            if (element.segments.length > 1 && Point.equals(seg.points[0], seg.points[1])) {
                (element.segments).splice(i, 1);
            }
            if (seg) {
                for (var j = 0; j < seg.points.length; j++) {
                    if (j > 0 || i === 0) {
                        intermeditatePoints.push(seg.points[parseInt(j.toString(), 10)]);
                    }
                }
            }
        }
    }
    return intermeditatePoints;
}
/**
 * findSourceDirection method \
 *
 * @returns { PointModel[] }     findSourceDirection method .\
 * @param {Direction} dir - provide the dir value.
 * @param {PointModel} srcPoint - provide the srcPoint value.
 * @param {PointModel} tarPoint - provide the tarPoint value.
 *
 * @private
 */
function findSourceDirection(dir, srcPoint, tarPoint) {
    var direction = (dir === 'Top' || dir === 'Bottom') ?
        ((tarPoint.x > srcPoint.x) ? 'Right' : 'Left') :
        ((tarPoint.y > srcPoint.y) ? 'Bottom' : 'Top');
    return direction;
}
/**
 * checkLastSegmentasTerminal method \
 *
 * @returns { void }     checkLastSegmentasTerminal method .\
 * @param {Connector} ele - provide the Connector value.
 *
 * @private
 */
function checkLastSegmentasTerminal(ele) {
    if (ele.type === 'Straight' || ele.type === 'Bezier') {
        if ((ele.segments.length === 0 || (ele.segments.length > 0 &&
            (!Point.isEmptyPoint(ele.segments[ele.segments.length - 1].point))))) {
            //let segment: BezierSegmentModel | StraightSegmentModel;
            if (ele.type === 'Bezier') {
                var segment = new BezierSegment(ele, 'segments', { type: 'Bezier', isInternalSegment: true }, true);
                (ele.segments).push(segment);
            }
            else {
                var segment = new StraightSegment(ele, 'segments', { type: 'Straight' }, true);
                (ele.segments).push(segment);
            }
        }
    }
    else {
        if (ele.segments.length > 0) {
            var isInvalid = false;
            var i = 0;
            while (i < ele.segments.length) {
                var seg = ele.segments[parseInt(i.toString(), 10)];
                if (isInvalid ||
                    (seg && !(seg instanceof OrthogonalSegment || seg instanceof StraightSegment || seg instanceof BezierSegment))) {
                    ele.segments.splice(i, 1);
                    isInvalid = true;
                }
                else {
                    i++;
                }
            }
        }
        if (ele.segments.length === 0 || ele.segments[ele.segments.length - 1].direction) {
            var segment = new OrthogonalSegment(ele, 'segments', { type: 'Orthogonal' }, true);
            ele.segments.push(segment);
        }
    }
}
/**
 * checkConsectiveSegmentAsSame method \
 *
 * @returns { number }     checkConsectiveSegmentAsSame method .\
 * @param {Connector} ele - provide the Connector value.
 * @param {Connector} i - provide the Connector value.
 * @param {Connector} source - provide the Connector value.
 *
 * @private
 */
function checkConsectiveSegmentAsSame(ele, i, source) {
    var seg = ele.segments[parseInt(i.toString(), 10)];
    var extra = (seg.direction === 'Left' || seg.direction === 'Top') ? -(seg.length) : seg.length;
    var angle = (seg.direction === 'Left' || seg.direction === 'Right') ? 0 : 90;
    var segPoint = addLineSegment(source.point, extra, angle);
    ele.segments[i - 1].length += seg.length;
    ele.segments[i - 1].points[1] = source.point = segPoint;
    ele.segments.splice(i, 1);
    i--;
    return i;
}
/**
 * nodeOrPortToNode method \
 *
 * @returns { PointModel[] }     nodeOrPortToNode method .\
 * @param {Connector} ele - provide the Connector value.
 * @param {End} source - provide the Connector value.
 * @param {End} target - provide the Connector value.
 *
 * @private
 */
function nodeOrPortToNode(ele, source, target) {
    var point;
    var portdirection;
    if (ele.sourcePortWrapper) {
        var port = { x: ele.sourcePortWrapper.offsetX, y: ele.sourcePortWrapper.offsetY };
        portdirection = getPortDirection(port, cornersPointsBeforeRotation(ele.sourceWrapper), ele.sourceWrapper.bounds);
    }
    findDirection(ele.targetWrapper, source, target, ele);
    var direction = findSourceDirection(target.direction, source.point, target.point);
    if (ele.sourcePortWrapper !== undefined && source.direction === target.direction &&
        ((source.direction === 'Top' || source.direction === 'Bottom') && (source.corners.center.x === target.corners.center.x)
            || (source.direction === 'Left' || source.direction === 'Right') && (source.corners.center.y === target.corners.center.y))) {
        source.direction = direction;
        point = (direction === 'Top' || direction === 'Bottom') ?
            orthoConnection3Segment(ele, source, target, ele.sourceWrapper.height / 2 + 20) :
            orthoConnection3Segment(ele, source, target, ele.sourceWrapper.width / 2 + 20);
        var source1 = source;
        source1.point = point[1];
        if (direction === 'Left' || direction === 'Right') {
            target.direction = direction;
            target.point = (direction === 'Left') ? target.corners.middleLeft : target.corners.middleRight;
        }
        else {
            findDirection(ele.targetWrapper, source, target, ele);
        }
        point = orthoConnection3Segment(ele, source, target);
    }
    else if (target.point.x >= source.corners.left && target.point.x <= source.corners.right &&
        source.point.y >= source.corners.top && source.point.y <= source.corners.bottom) {
        source.direction = (target.point.y > source.point.y) ? 'Bottom' : 'Top';
        var length_2 = (source.direction === 'Top') ? (source.point.y - source.corners.top + 20) :
            (source.corners.bottom - source.point.y + 20);
        point = orthoConnection3Segment(ele, source, target, length_2);
    }
    else if (ele.sourcePortWrapper && portdirection === getOppositeDirection(direction)) {
        var length_3;
        if ((portdirection === 'Left' || portdirection === 'Right') && (source.point.y >= source.corners.top
            && source.point.y <= source.corners.bottom)) {
            source.direction = (target.point.y > source.point.y) ? 'Bottom' : 'Top';
            length_3 = source.corners.height / 2 + 20;
        }
        else if ((portdirection === 'Top' || portdirection === 'Bottom') && (source.point.x >= source.corners.left
            && source.point.x <= source.corners.right)) {
            source.direction = (target.point.x > source.point.x) ? 'Right' : 'Left';
            length_3 = source.corners.width / 2 + 20;
        }
        if (source.direction && length_3) {
            point = orthoConnection3Segment(ele, source, target, length_3, true);
        }
        else {
            source.direction = direction;
            point = orthoConnection2Segment(source, target);
        }
    }
    else if (ele.sourcePortWrapper && portdirection === target.direction && (portdirection === 'Top' || portdirection === 'Bottom') &&
        (source.corners.center.x === target.corners.center.x)) {
        source.direction = (target.point.y > source.point.y) ? 'Bottom' : 'Top';
        var len = (source.direction === 'Bottom') ? (source.corners.bottom - source.point.y + 20) :
            (source.point.y - source.corners.top + 20);
        point = orthoConnection3Segment(ele, source, target, len);
    }
    else { //901771- Connector routing is not proper while setting the segment direction as "Left"
        if (source.direction === target.direction) {
            if (((source.direction === 'Left' || source.direction === 'Right') &&
                target.point.y > source.corners.top - 20 && target.point.y < source.corners.bottom + 20) ||
                ((source.direction === 'Top' || source.direction === 'Bottom') &&
                    target.point.x > source.corners.left - 20 && target.point.x < source.corners.right + 20)) {
                var prevdirection = source.direction;
                source.direction = direction;
                point = orthoConnection4Segment(source, target, prevdirection, point, 20, false);
            }
            else {
                source.direction = direction;
                point = orthoConnection2Segment(source, target);
            }
        }
        else {
            source.direction = direction;
            point = orthoConnection2Segment(source, target);
        }
    }
    return point;
}
/**
 * checkSourcePointInTarget method \
 *
 * @returns { void } checkSourcePointInTarget method .\
 * @param {Connector} ele - provide the Connector value.
 * @param {End} source - provide the Connector value.
 *
 * @private
 */
function checkSourcePointInTarget(ele, source) {
    if (ele.targetWrapper !== undefined && ele.targetPortWrapper === undefined) {
        var padding = 1;
        if (cornersPointsBeforeRotation(ele.targetWrapper).containsPoint(source.point, padding)) {
            var target = ele.targetWrapper;
            var segment = ele.segments[ele.segments.length - 2];
            var lastPoint = segment.points[segment.points.length - 1];
            var direction = getOppositeDirection(segment.direction);
            if (direction === 'Bottom') {
                if (lastPoint.y < target.corners.bottom + padding) {
                    segment.points[segment.points.length - 1].y = target.corners.bottom + 20;
                    segment.length = Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);
                }
            }
            else if (direction === 'Top') {
                if (lastPoint.y > target.corners.top - padding) {
                    segment.points[segment.points.length - 1].y = target.corners.top - 20;
                    segment.length = Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);
                }
            }
            else if (direction === 'Left') {
                if (lastPoint.x > target.corners.left - padding) {
                    segment.points[segment.points.length - 1].x = target.corners.left - 20;
                    segment.length = Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);
                }
            }
            else if (direction === 'Right') {
                if (lastPoint.x < target.corners.right + padding) {
                    segment.points[segment.points.length - 1].x = target.corners.right + 20;
                    segment.length = Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);
                }
            }
            source.point = segment.points[segment.points.length - 1];
        }
    }
}
/**
 * findIntermeditatePoints method \
 *
 * @returns { void } findIntermeditatePoints method .\
 * @param {Connector} ele - provide the ele value.
 * @param {End} source - provide the source value.
 * @param {End} target - provide the source value.
 * @param {DiagramElement} srcPort - provide the srcPort value.
 * @param {DiagramElement} tarPort - provide the tarPort value.
 * @param {DiagramElement} sourceEle - provide the sourceEle value.
 * @param {DiagramElement} targetEle - provide the targetEle value.
 * @private
 */
function findIntermeditatePoints(ele, source, target, srcPort, tarPort, sourceEle, targetEle) {
    var point;
    var intermeditatePoints = [];
    var seg;
    var j;
    var removeSegment;
    checkLastSegmentasTerminal(ele);
    for (var i = 0; i < ele.segments.length; i++) {
        seg = ele.segments[parseInt(i.toString(), 10)];
        if (srcPort && source.direction === getOppositeDirection(seg.direction)) {
            seg.direction = source.direction;
        }
        if (i > 0 && ele.segments[i - 1].direction === seg.direction) {
            i = checkConsectiveSegmentAsSame(ele, i, source);
        }
        else {
            if (seg.direction) {
                source.point = updateSegmentPoints(source, ele.segments[parseInt(i.toString(), 10)]);
            }
            else {
                var segment = ele.segments[i - 1];
                if (segment && segment.points && segment.points.length > 0) {
                    source.point = segment.points[segment.points.length - 1];
                }
            }
        }
        if (i === ele.segments.length - 1) {
            checkSourcePointInTarget(ele, source);
            if (tarPort === undefined) {
                point = nodeOrPortToNode(ele, source, target);
            }
            else {
                point = pointToPort(ele, source, target);
            }
            checkPreviousSegment(point, ele);
            seg.points = [];
            if (point.length >= 2) {
                for (j = 0; j < point.length; j++) {
                    if (!ele.selectedSegmentIndex) {
                        seg.points.push(point[parseInt(j.toString(), 10)]);
                    }
                    else {
                        // EJ2-65063 - If point length is greater then 2 means then empty the last segment points and set it as two points instead of four points
                        if (j === point.length - 1 && point.length > 2 && ele.segments.length > 2) {
                            // EJ2-69304 - Change the point calculation to work for all port combination
                            var point2 = { x: point[parseInt(j.toString(), 10)].x, y: source.point.y };
                            // EJ2 - 65063 - Empty the segment points
                            seg.points = [];
                            // EJ2-69304 - Calculate the point for segment and manually push the point in segment point calculation
                            seg.points.push(point2);
                            seg.points.push(point[parseInt(j.toString(), 10)]);
                            var segment = ele.segments[i - 1];
                            //EJ2 - Orthogonal connector gets broken when dragging segment thumb
                            if (ele.segments.length < 4) {
                                segment.points.pop();
                            }
                            // Bug 834713: Orthogonal connector routing is not proper, When allowNodeOverlap is Set to true.
                            segment.points = segment.points.concat(seg.points);
                        }
                        else {
                            seg.points.push(point[parseInt(j.toString(), 10)]);
                        }
                    }
                }
            }
            else {
                removeSegment = i;
            }
        }
        // EJ2-65063 - Added below condition !selectedSegmentIndex to restrict the connector segment to remove from its collection.
        if (removeSegment !== undefined && !ele.selectedSegmentIndex) {
            if (removeSegment === ele.segments.length - 1) {
                ele.segments[removeSegment - 1].direction = null;
                ele.segments[removeSegment - 1].length = null;
            }
            ele.segments.splice(removeSegment, 1);
        }
        if (srcPort && i === 0) {
            var sourcePoint = checkPortdirection(ele, srcPort, sourceEle);
            if (sourcePoint) {
                source.point = sourcePoint;
            }
        }
    }
    return returnIntermeditatePoints(ele, intermeditatePoints);
}
/**
 * returnIntermeditatePoints method \
 *
 * @returns { PointModel[] } returnIntermeditatePoints method .\
 * @param {Connector} element - provide the ele value.
 * @param {PointModel[]} intermeditatePoints - provide the source value.
 * @private
 */
function returnIntermeditatePoints(element, intermeditatePoints) {
    for (var i = 0; i < element.segments.length; i++) {
        var seg = element.segments[parseInt(i.toString(), 10)];
        for (var j = 0; j < seg.points.length; j++) {
            if (j > 0 || i === 0) {
                intermeditatePoints.push(seg.points[parseInt(j.toString(), 10)]);
            }
        }
    }
    return intermeditatePoints;
}
/**
 * findDirection method \
 *
 * @returns { void } findDirection method .\
 * @param {DiagramElement} node - provide the ele value.
 * @param {End} source - provide the source value.
 * @param {End} target - provide the source value.
 * @param {Connector} ele - provide the source value.
 * @private
 */
function findDirection(node, source, target, ele) {
    var nodeDirection;
    var nodeConnectingPoint = { x: 0, y: 0 };
    var nodeCorners = swapBounds(node, node.corners, node.bounds);
    var nodeMargin = source.margin;
    var fixedPoint = source.point;
    if (nodeCorners.bottomCenter.y + nodeMargin.bottom < fixedPoint.y) {
        nodeDirection = 'Bottom';
        nodeConnectingPoint = nodeCorners.bottomCenter;
    }
    else if (nodeCorners.topCenter.y - nodeMargin.top > fixedPoint.y) {
        nodeDirection = 'Top';
        nodeConnectingPoint = nodeCorners.topCenter;
    }
    else if (nodeCorners.middleLeft.x - nodeMargin.left > fixedPoint.x) {
        nodeDirection = 'Left';
        nodeConnectingPoint = nodeCorners.middleLeft;
    }
    else if (nodeCorners.middleRight.x + nodeMargin.right < fixedPoint.x) {
        nodeDirection = 'Right';
        nodeConnectingPoint = nodeCorners.middleRight;
    }
    else {
        var top_1 = Math.abs(fixedPoint.y - nodeCorners.topCenter.y);
        var right = Math.abs(fixedPoint.x - nodeCorners.middleRight.x);
        var bottom = Math.abs(fixedPoint.y - nodeCorners.bottomCenter.y);
        var left = Math.abs(fixedPoint.x - nodeCorners.middleLeft.x);
        var shortes = Number.MAX_VALUE;
        shortes = top_1;
        nodeDirection = 'Top';
        nodeConnectingPoint = nodeCorners.topCenter;
        if (shortes > right) {
            shortes = right;
            nodeDirection = 'Right';
            nodeConnectingPoint = nodeCorners.middleRight;
        }
        if (shortes > bottom) {
            shortes = bottom;
            nodeDirection = 'Bottom';
            nodeConnectingPoint = nodeCorners.bottomCenter;
        }
        if (shortes > left) {
            //shortes = left;
            nodeDirection = 'Left';
            nodeConnectingPoint = nodeCorners.middleLeft;
        }
    }
    target.point = nodeConnectingPoint;
    target.direction = nodeDirection;
    var refPoint = findPoint(nodeCorners, getOppositeDirection(target.direction));
    target.point = getIntersection(ele, node, target.point, refPoint, node === ele.targetWrapper);
}
/**
 * findOrthoSegments method \
 *
 * @returns { PointModel[] } findOrthoSegments method .\
 * @param {DiagramElement} ele - provide the ele value.
 * @param {End} source - provide the source value.
 * @param {End} target - provide the target value.
 * @param {Connector} extra - provide the extra value.
 * @param {boolean} lineDistribution - provide the lineDistribution value.
 * @private
 */
function findOrthoSegments(ele, source, target, extra, lineDistribution) {
    var swap = false;
    var intermeditatePoints = [];
    var seg;
    swap = getSwapping(source.direction, target.direction);
    if (swap) {
        swapPoints(source, target);
    }
    if (source.direction === 'Right' && target.direction === 'Left') {
        seg = getRightToLeftSegmentCount(ele, source, target, swap);
    }
    else if (source.direction === 'Right' && target.direction === 'Right') {
        seg = getRightToRightSegmentCount(ele, source, target);
    }
    else if (source.direction === 'Right' && target.direction === 'Top') {
        seg = getRightToTopSegmentCount(ele, source, target, swap);
    }
    else if (source.direction === 'Right' && target.direction === 'Bottom') {
        seg = getRightToBottomSegmentCount(ele, source, target, swap);
    }
    else if (source.direction === 'Bottom' && target.direction === 'Top') {
        seg = getBottomToTopSegmentCount(ele, source, target);
    }
    else if (source.direction === 'Bottom' && target.direction === 'Bottom') {
        /**
         * EJ2-56920-Option to adjust the distance between source node and target node.
         */
        var margin = findMargin(ele);
        source.margin = { left: margin, right: margin, top: margin, bottom: margin };
        target.margin = { left: margin, right: margin, top: margin, bottom: margin };
        seg = getBottomToBottomSegmentCount(ele, source, target);
    }
    else if (source.direction === 'Bottom' && target.direction === 'Left') {
        seg = getBottomToLeftSegmentCount(ele, source, target, swap);
    }
    else if (source.direction === 'Left' && target.direction === 'Left') {
        seg = getLeftToLeftSegmentCount(ele, source, target);
    }
    else if (source.direction === 'Left' && target.direction === 'Top') {
        seg = getLeftToTopSegmentCount(ele, source, target, swap);
    }
    else if (source.direction === 'Top' && target.direction === 'Top') {
        seg = getTopToTopSegmentCount(ele, source, target);
    }
    if (swap) {
        swapPoints(source, target);
    }
    intermeditatePoints = addOrthoSegments(ele, seg, source, target, extra, lineDistribution);
    if (ele.type === 'Bezier') {
        convertPointToBezierSegment(ele, seg, intermeditatePoints);
    }
    return intermeditatePoints;
}
/**
 * Returns the margin of source node and the target node
 *
 * @returns { number } - findMargin method .\
 * @param { Connector } element - provide the element value
 * @private
 */
function findMargin(element) {
    var margin;
    if (element.connectorSpacing >= 13) {
        margin = 13;
    }
    else if (element.connectorSpacing <= 1) {
        margin = 1;
    }
    else {
        margin = element.connectorSpacing;
    }
    return margin;
}
/**
 * findAngle method \
 *
 * @returns { number } findAngle method .\
 * @param {DiagramElement} s - provide the s value.
 * @param {End} e - provide the e value.
 * @private
 */
function findAngle(s, e) {
    var r = { x: e.x, y: s.y };
    //const sr: number = Point.findLength(s, r);
    var re = Point.findLength(r, e);
    var es = Point.findLength(e, s);
    var ang = Math.asin(re / es);
    ang = ang * 180 / Math.PI;
    if (s.x < e.x) {
        if (s.y > e.y) {
            ang = 360 - ang;
        }
    }
    else {
        if (s.y < e.y) {
            ang = 180 - ang;
        }
        else {
            ang = 180 + ang;
        }
    }
    return ang;
}
/**
 * findPoint method \
 *
 * @returns { number } findPoint method .\
 * @param {Corners} cor - provide the cor value.
 * @param {string} direction - provide the direction value.
 * @private
 */
function findPoint(cor, direction) {
    var point;
    switch (direction) {
        case 'Left':
            point = cor.middleLeft;
            break;
        case 'Top':
            point = cor.topCenter;
            break;
        case 'Right':
            point = cor.middleRight;
            break;
        case 'Bottom':
            point = cor.bottomCenter;
            break;
    }
    return point;
}
/**
 * pointsFromNodeToPoint method \
 *
 * @returns { number } pointsFromNodeToPoint method .\
 * @param {OrthogonalSegment} seg - provide the seg value.
 * @param {string} direction - provide the direction value.
 * @param {Rect} bounds - provide the bounds value.
 * @param {PointModel} point - provide the point value.
 * @param {PointModel} endPoint - provide the endPoint value.
 * @param {boolean} isTarget - provide the isTarget value.
 * @private
 */
function pointsFromNodeToPoint(seg, direction, bounds, point, endPoint, isTarget) {
    var minSpace = 13;
    var x;
    var points = [];
    var y;
    points.push(point);
    //let straight: boolean;
    var straight = (point.y === endPoint.y && (direction === 'Left' && endPoint.x < point.x ||
        direction === 'Right' && endPoint.x > point.x)) ||
        (point.x === endPoint.x && (direction === 'Top' && endPoint.y < point.y ||
            direction === 'Bottom' && endPoint.y > point.y));
    if (!straight) {
        if (direction === 'Top' || direction === 'Bottom') {
            if (direction === 'Top' && endPoint.y < point.y && endPoint.y > point.y - minSpace ||
                direction === 'Bottom' && endPoint.y > point.y && endPoint.y < point.y + minSpace) {
                y = direction === 'Top' ? bounds.top - minSpace : bounds.bottom + minSpace;
                points.push({ x: point.x, y: y });
                points.push({ x: point.x + (endPoint.x - point.x) / 2, y: y });
                points.push({ x: point.x + (endPoint.x - point.x) / 2, y: endPoint.y });
            }
            else if (Math.abs(point.x - endPoint.x) > minSpace &&
                (direction === 'Top' && endPoint.y < point.y || direction === 'Bottom' && endPoint.y > point.y)) {
                //twosegments
                points.push({ x: point.x, y: endPoint.y });
            }
            else {
                y = direction === 'Top' ? bounds.top - minSpace : bounds.bottom + minSpace;
                x = (endPoint.x < point.x) ? bounds.left - minSpace : bounds.right + minSpace;
                points.push({ x: point.x, y: y });
                points.push({ x: endPoint.x, y: y });
            }
        }
        else {
            if (direction === 'Left' && endPoint.x < point.x && endPoint.x > point.x - minSpace || direction === 'right' &&
                endPoint.x > point.x && endPoint.x < point.x + minSpace) {
                x = direction === 'Left' ? bounds.left - minSpace : bounds.right + minSpace;
                points.push({ x: x, y: point.y });
                points.push({ x: x, y: point.y + (endPoint.y - point.y) / 2 });
                points.push({ x: endPoint.x, y: point.y + (endPoint.y - point.y) / 2 });
            }
            else if (Math.abs(point.y - endPoint.y) > minSpace &&
                (direction === 'Left' && endPoint.x < point.x || direction === 'Right' && endPoint.x > point.x)) {
                points.push({ x: endPoint.x, y: point.y });
                //twosegments
            }
            else {
                x = direction === 'Left' ? bounds.left - minSpace : bounds.right + minSpace;
                points.push({ x: x, y: point.y });
                points.push({ x: x, y: endPoint.y });
            }
        }
        if (isTarget) {
            points.push(seg.points[0]);
            points.reverse();
        }
        seg.points = points;
    }
}
/**
 * addLineSegment method \
 *
 * @returns { PointModel } addLineSegment method .\
 * @param {PointModel} point - provide the seg value.
 * @param {number} extra - provide the direction value.
 * @param {number} angle - provide the bounds value.
 * @private
 */
function addLineSegment(point, extra, angle) {
    var segEnd = Point.transform(point, angle, extra);
    return segEnd;
}
/**
 * getIntersection method \
 *
 * @returns { PointModel } getIntersection method .\
 * @param {PointModel} ele - provide the ele value.
 * @param {number} bounds - provide the bounds value.
 * @param {number} sPt - provide the sPt value.
 * @param {number} tPt - provide the tPt value.
 * @param {number} isTar - provide the isTar value.
 * @private
 */
function getIntersection(ele, bounds, sPt, tPt, isTar) {
    sPt = { x: sPt.x, y: sPt.y };
    tPt = { x: tPt.x, y: tPt.y };
    //const angle: number = Point.findAngle(tPt, sPt); ///let child: PathElement;// let intersection: PointModel;
    var wrapper = isTar ? ele.targetWrapper : ele.sourceWrapper;
    var padding = (isTar ? ele.targetPadding : ele.sourcePadding);
    var rect;
    var segmentPoints;
    var point = isTar || (ele.type === 'Orthogonal' || ele.type === 'Bezier') ? sPt : tPt;
    //const sourcePoint: PointModel = Point.transform(sPt, angle, Math.max(wrapper.actualSize.height / 2, wrapper.actualSize.width / 2));
    var child = wrapper;
    var sPt1 = rotatePoint(-wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY, sPt);
    var tPt1 = rotatePoint(-wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY, tPt);
    if (ele.type === 'Orthogonal' || ele.type === 'Bezier') {
        var constValue = 5;
        if (sPt1.x === tPt1.x) {
            if (sPt1.y < tPt1.y) {
                sPt1.y -= constValue;
            }
            else {
                sPt1.y += constValue;
            }
        }
        if (sPt1.y === tPt1.y) {
            if (sPt1.x < tPt1.x) {
                sPt1.x -= constValue;
            }
            else {
                sPt1.x += constValue;
            }
        }
        sPt = rotatePoint(wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY, sPt1);
    }
    else {
        //const angle: number = isTar ? Point.findAngle(sPt, tPt) : Point.findAngle(tPt, sPt);
        if (isTar) {
            var angle = Point.findAngle(sPt, tPt);
            tPt = Point.transform({ x: tPt.x, y: tPt.y }, angle, Math.max(wrapper.actualSize.width, wrapper.actualSize.height));
        }
        else {
            var angle = Point.findAngle(tPt, sPt);
            sPt = Point.transform({ x: sPt.x, y: sPt.y }, angle, Math.max(wrapper.actualSize.width, wrapper.actualSize.height));
        }
    }
    if ((ele.sourcePadding || ele.targetPadding)) {
        rect = new Rect(wrapper.bounds.x - padding, wrapper.bounds.y - padding, wrapper.actualSize.width + 2 * padding, wrapper.actualSize.height + 2 * padding);
    }
    if (wrapper instanceof PathElement && wrapper.data) {
        segmentPoints = rect ? [rect.topLeft, rect.topRight, rect.bottomRight, rect.bottomLeft] : child.getPoints();
        if (((child.data.split('m').length - 1) + (child.data.split('M').length - 1)) === 1) {
            segmentPoints[segmentPoints.length] = segmentPoints[0];
        }
    }
    else {
        segmentPoints = rect ? [rect.topLeft, rect.topRight, rect.bottomRight, rect.bottomLeft] : getPoints(wrapper, wrapper.corners);
        segmentPoints[segmentPoints.length] = segmentPoints[0];
    }
    //const length: number = segmentPoints.length;
    var thisSegment = { x1: sPt.x, y1: sPt.y, x2: tPt.x, y2: tPt.y };
    return getIntersectionPoints(thisSegment, segmentPoints, true, point) || sPt;
}
/**
 * setLineEndPoint method \
 *
 * @returns { PointModel } setLineEndPoint method .\
 * @param {PointModel} element - provide the ele value.
 * @param {number} point - provide the bounds value.
 * @param {number} isTarget - provide the sPt value.
 * @private
 */
function setLineEndPoint(element, point, isTarget) {
    point.x = Math.round(point.x * 100) / 100;
    point.y = Math.round(point.y * 100) / 100;
    if (isTarget) {
        element.targetPoint = point;
    }
    else {
        element.sourcePoint = point;
    }
    return point;
}
/**
 * getIntersectionPoints method \
 *
 * @returns { PointModel } getIntersectionPoints method .\
 * @param {Segment} thisSegment - provide the ele value.
 * @param {Object[]} pts - provide the bounds value.
 * @param {boolean} minimal - provide the sPt value.
 * @param {PointModel} point - provide the sPt value.
 * @private
 */
function getIntersectionPoints(thisSegment, pts, minimal, point) {
    var length = pts.length;
    var min;
    var segment = {
        x1: pts[0].x, y1: pts[0].y, x2: pts[1].x,
        y2: pts[1].y
    };
    var intersection = intersectSegment(thisSegment, segment);
    if (intersection) {
        // if (!minimal) { return intersection; } //commented because minimal is always true
        min = Point.distancePoints(intersection, point);
    }
    if (isNaN(min) || min > 0) {
        for (var i = 1; i < length - 1; i++) {
            segment = {
                x1: pts[parseInt(i.toString(), 10)].x, y1: pts[parseInt(i.toString(), 10)].y,
                x2: pts[i + 1].x, y2: pts[i + 1].y
            };
            var intersect = intersectSegment(thisSegment, segment);
            if (intersect) {
                // if (!minimal) { return intersect; }//commented because minimal is always true
                var dist = Point.distancePoints(intersect, point);
                if (isNaN(min) || min > dist) {
                    min = dist;
                    intersection = intersect;
                }
                if (min >= 0 && min <= 1) {
                    break;
                }
            }
        }
    }
    return intersection;
}
/**
 * intersectSegment method \
 *
 * @returns { PointModel } intersectSegment method .\
 * @param {Segment} segment1 - provide the ele value.
 * @param {Segment} segment2 - provide the bounds value.
 * @private
 */
function intersectSegment(segment1, segment2) {
    var x1 = segment1.x1;
    var y1 = segment1.y1;
    var x2 = segment1.x2;
    var y2 = segment1.y2;
    var x3 = segment2.x1;
    var y3 = segment2.y1;
    var x4 = segment2.x2;
    var y4 = segment2.y2;
    var a1;
    var a2;
    var b1;
    var b2;
    var c1;
    var c2;
    var x;
    var y;
    var r1;
    var r2;
    var r3;
    var r4;
    var offset;
    var num;
    // eslint-disable-next-line
    a1 = y2 - y1;
    b1 = x1 - x2;
    c1 = (x2 * y1) - (x1 * y2);
    // eslint-disable-next-line
    r3 = ((a1 * x3) + (b1 * y3) + c1);
    r4 = ((a1 * x4) + (b1 * y4) + c1);
    if ((r3 !== 0) && (r4 !== 0) && sameSign(r3, r4)) {
        return null;
    }
    // eslint-disable-next-line
    a2 = y4 - y3;
    b2 = x3 - x4;
    c2 = (x4 * y3) - (x3 * y4);
    // eslint-disable-next-line
    r1 = (a2 * x1) + (b2 * y1) + c2;
    r2 = (a2 * x2) + (b2 * y2) + c2;
    if ((r1 !== 0) && (r2 !== 0) && (sameSign(r1, r2))) {
        return null;
    }
    var denom = (a1 * b2) - (a2 * b1);
    if (denom === 0) {
        return null;
    }
    if (denom < 0) {
        offset = -denom / 2;
    }
    else {
        offset = denom / 2;
    }
    offset = 0;
    num = (b1 * c2) - (b2 * c1);
    if (num < 0) {
        x = (num - offset) / denom;
    }
    else {
        x = (num + offset) / denom;
    }
    num = (a2 * c1) - (a1 * c2);
    if (num < 0) {
        y = (num - offset) / denom;
    }
    else {
        y = (num + offset) / denom;
    }
    return { x: x, y: y };
}
/**
 * sameSign method \
 *
 * @returns { boolean } sameSign method .\
 * @param {Connector} a - provide the Connector value.
 * @param {End} b - provide the source End value.
 * @private
 */
function sameSign(a, b) {
    return ((a * b) >= 0);
}
/**
 * getRightToLeftSegmentCount method \
 *
 * @returns { NoOfSegments } getRightToLeftSegmentCount method .\
 * @param {Connector} element - provide the Connector value.
 * @param {End} source - provide the source End value.
 * @param {End} target - provide the target  End value.
 * @param {boolean} swap - provide the swap value.
 * @private
 */
function getRightToLeftSegmentCount(element, source, target, swap) {
    var srcPort = element.sourcePortWrapper;
    //let targetPort: DiagramElement = element.targetPortWrapper;
    var pts;
    var diffY = Math.round(Math.abs(source.point.y - target.point.y));
    //let diffX: number = Math.round(Math.abs(source.point.x - target.point.x));
    var right = { x: Math.max(source.point.x, source.corners.right), y: source.point.y };
    var left = { x: Math.min(target.point.x, target.corners.left), y: target.point.y };
    var margin = findMargin(element);
    if (swap) {
        //let point: PointModel;
        var point = left;
        left = right;
        right = point;
    }
    if (!(source.corners.bottom + margin < target.corners.top - margin ||
        source.corners.top - margin > target.corners.bottom + margin)) {
        if (element.type !== 'Bezier') {
            margin = 0;
        }
        else if (target.corners.left - source.corners.right <= margin * 2 && target.corners.left - source.corners.right >= 5) {
            margin = 0;
        }
    }
    source.margin = { left: margin, right: margin, top: margin, bottom: margin };
    target.margin = { left: margin, right: margin, top: margin, bottom: margin };
    if (diffY === 0 && (source.corners.right < target.corners.left
        || (swap && source.corners.right < target.corners.left))) {
        pts = NoOfSegments.One;
    }
    else if (source.point.x + source.margin.right < target.point.x - target.margin.left) {
        pts = NoOfSegments.Three;
    }
    else if (element.sourceWrapper !== element.targetWrapper &&
        (cornersPointsBeforeRotation(element.sourceWrapper).containsPoint(left) ||
            cornersPointsBeforeRotation(element.targetWrapper).containsPoint(right))) {
        pts = NoOfSegments.Three;
    }
    else if (source.corners.bottom <= target.corners.top) {
        pts = NoOfSegments.Five;
    }
    else if (source.corners.top >= target.corners.top) {
        pts = NoOfSegments.Five;
    }
    else if ((srcPort !== undefined && srcPort.offsetY <= target.corners.top) ||
        (srcPort === undefined && source.corners.right <= target.corners.top)) {
        pts = NoOfSegments.Five;
    }
    else if ((srcPort !== undefined && srcPort.offsetY >= target.corners.bottom) ||
        (srcPort === undefined && source.corners.right >= target.corners.bottom)) {
        pts = NoOfSegments.Five;
    }
    else {
        pts = NoOfSegments.Five;
    }
    return pts;
}
/**
 * getRightToRightSegmentCount method \
 *
 * @returns { NoOfSegments } getRightToRightSegmentCount method .\
 * @param {Connector} element - provide the Connector value.
 * @param {End} sourceObj - provide the source End value.
 * @param {End} targetObj - provide the target  End value.
 * @private
 */
function getRightToRightSegmentCount(element, sourceObj, targetObj) {
    var sourcePort = element.sourcePortWrapper;
    var tarPort = element.targetPortWrapper;
    var pts;
    var diffX = sourceObj.point.x - targetObj.point.x;
    var diffY = sourceObj.point.y - targetObj.point.y;
    var margin = findMargin(element);
    targetObj.margin = { left: margin, right: margin, top: margin, bottom: margin };
    sourceObj.margin = { left: margin, right: margin, top: margin, bottom: margin };
    if (sourceObj.corners.right >= targetObj.corners.right) {
        if ((sourcePort !== undefined && (sourcePort.offsetY < targetObj.corners.top - targetObj.margin.top ||
            sourcePort.offsetY > targetObj.corners.bottom + targetObj.margin.bottom)) ||
            (sourcePort === undefined && sourceObj.corners.middleRight.y < targetObj.corners.top)) {
            pts = NoOfSegments.Three;
        }
        else if ((sourcePort !== undefined && sourcePort.offsetY > targetObj.corners.bottom + targetObj.margin.bottom
            && sourceObj.corners.top > targetObj.corners.bottom) ||
            (sourcePort === undefined && sourceObj.corners.middleRight.y > targetObj.corners.bottom)) {
            pts = NoOfSegments.Three;
        }
        else if ((sourcePort !== undefined && sourcePort.offsetY < targetObj.corners.top - targetObj.margin.top
            && sourceObj.corners.bottom > targetObj.corners.top) ||
            (sourcePort === undefined && sourceObj.corners.middleRight.y > targetObj.corners.bottom)) {
            pts = NoOfSegments.Three;
        }
        else if (sourceObj.corners.right < targetObj.corners.left ||
            targetObj.corners.right < sourceObj.corners.left) {
            pts = NoOfSegments.Five;
        }
        else if (diffX === 0 || diffY === 0) {
            pts = NoOfSegments.One;
        }
        else {
            pts = NoOfSegments.Three;
        }
    }
    else if ((tarPort !== undefined && sourceObj.corners.bottom < tarPort.offsetY - targetObj.margin.top) ||
        (tarPort === undefined && sourceObj.corners.bottom < targetObj.corners.middleRight.y)) {
        pts = NoOfSegments.Three;
    }
    else if ((tarPort !== undefined && sourceObj.corners.top > tarPort.offsetY + targetObj.margin.right) ||
        (tarPort === undefined && sourceObj.corners.top > targetObj.corners.middleRight.y)) {
        pts = NoOfSegments.Three;
    }
    else if ((tarPort !== undefined && ((sourcePort !== undefined && sourcePort.offsetX < targetObj.corners.left &&
        sourcePort.offsetX !== tarPort.offsetX && (Math.abs(sourceObj.corners.right - targetObj.corners.left) <= 20)) ||
        (sourcePort === undefined && sourceObj.corners.right < targetObj.corners.left &&
            sourceObj.corners.center.x !== targetObj.corners.center.x && sourceObj.corners.center.y !== targetObj.corners.center.y)))) {
        pts = NoOfSegments.Three;
    }
    else if (sourceObj.corners.right < targetObj.corners.left) {
        pts = NoOfSegments.Five;
    }
    else if (diffX === 0 || diffY === 0) {
        pts = NoOfSegments.One;
    }
    else {
        pts = NoOfSegments.Three;
    }
    return pts;
}
/**
 * getRightToTopSegmentCount method \
 *
 * @returns { NoOfSegments } getRightToTopSegmentCount method .\
 * @param {Connector} element - provide the element value.
 * @param {End} source - provide the target  value.
 * @param {End} target - provide the target  value.
 * @param {End} swap - provide the swap value.
 * @private
 */
function getRightToTopSegmentCount(element, source, target, swap) {
    var tarPort = element.targetPortWrapper;
    var srcPort = element.sourcePortWrapper;
    var right = { x: Math.max(source.point.x, source.corners.right), y: source.point.y };
    var top = { x: target.point.x, y: Math.min(target.point.y, target.corners.top) };
    var margin = findMargin(element);
    var pts;
    target.margin = { left: margin, right: margin, top: margin, bottom: margin };
    source.margin = { top: margin, bottom: margin, left: margin, right: margin };
    if (swap) {
        //let port: DiagramElement;
        var port = srcPort;
        srcPort = tarPort;
        tarPort = port;
        var point = right;
        right = top;
        top = point;
    }
    if ((srcPort !== undefined && srcPort.offsetY < target.corners.top - target.margin.top) ||
        (srcPort === undefined && source.corners.bottom < target.corners.top - target.margin.top)) {
        if (source.corners.bottom < target.corners.top) {
            if ((tarPort !== undefined && source.corners.right + source.margin.right < tarPort.offsetX) ||
                (tarPort === undefined && source.corners.right + source.margin.right < target.corners.topCenter.x)) {
                pts = NoOfSegments.Two;
            }
            else {
                pts = NoOfSegments.Four;
            }
        }
        else if ((tarPort !== undefined && source.corners.left > tarPort.offsetX) ||
            (tarPort === undefined && source.corners.left > target.corners.topCenter.x)) {
            pts = NoOfSegments.Four;
        }
        else {
            pts = NoOfSegments.Two;
        }
    }
    else if (srcPort !== undefined && Math.abs(source.corners.right - target.corners.left) <= 5 &&
        Math.abs(srcPort.offsetY - target.corners.top) <= 5) {
        pts = NoOfSegments.Two;
    }
    else if (tarPort !== undefined && source.corners.right < target.corners.left
        && Math.abs(tarPort.offsetX - source.corners.topCenter.x) >= 25
        && source.corners.middleRight.y + source.margin.right < tarPort.offsetY) {
        pts = NoOfSegments.Two;
    }
    else if (source.corners.right < target.corners.left) {
        pts = NoOfSegments.Four;
    }
    else if (element.sourceWrapper !== element.targetWrapper &&
        (cornersPointsBeforeRotation(element.sourceWrapper).containsPoint(top) ||
            cornersPointsBeforeRotation(element.targetWrapper).containsPoint(right))) {
        pts = NoOfSegments.Two;
    }
    else {
        pts = NoOfSegments.Four;
    }
    return pts;
}
/**
 * getRightToTopSegmentCount method \
 *
 * @returns { NoOfSegments } getRightToTopSegmentCount method .\
 * @param {Connector} element - provide the element value.
 * @param {End} source - provide the target  value.
 * @param {End} target - provide the target  value.
 * @param {End} swap - provide the swap value.
 * @private
 */
function getRightToBottomSegmentCount(element, source, target, swap) {
    var margin = findMargin(element);
    source.margin = { left: margin, right: margin, top: margin, bottom: margin };
    target.margin = { left: margin, right: margin, top: margin, bottom: margin };
    var pts;
    var srcPort = element.sourcePortWrapper;
    var tarPort = element.targetPortWrapper;
    //let right: PointModel = { x: Math.max(source.point.x, source.corners.right), y: source.point.y };
    //let bottom: PointModel = { x: target.point.x, y: Math.max(target.point.y, target.corners.bottom) };
    if (swap) {
        //let port: DiagramElement;
        var port = srcPort;
        srcPort = tarPort;
        tarPort = port;
    }
    if ((srcPort !== undefined && srcPort.offsetY > target.corners.bottom + target.margin.bottom) ||
        (srcPort === undefined && source.corners.middleRight.y > target.corners.bottom + target.margin.bottom)) {
        if (source.corners.top > target.corners.bottom) {
            if ((tarPort !== undefined && source.corners.right + source.margin.right < tarPort.offsetX) ||
                (tarPort === undefined && source.corners.right + source.margin.right < target.corners.bottomCenter.x)) {
                pts = NoOfSegments.Two;
            }
            else {
                pts = NoOfSegments.Four;
            }
        }
        else if ((tarPort !== undefined && source.corners.left > tarPort.offsetX) ||
            (tarPort === undefined && source.corners.left > target.corners.bottomCenter.x)) {
            pts = NoOfSegments.Four;
        }
        else {
            pts = NoOfSegments.Two;
        }
    }
    else if (srcPort !== undefined &&
        Math.abs(source.corners.right - target.corners.left) <= 25 &&
        Math.abs(srcPort.offsetY - target.corners.bottom) <= 25) {
        pts = NoOfSegments.Two;
    }
    else if (source.corners.right < target.corners.left) {
        pts = NoOfSegments.Four;
    }
    else {
        pts = NoOfSegments.Four;
    }
    return pts;
}
/**
 * getBottomToTopSegmentCount method \
 *
 * @returns { NoOfSegments } getBottomToTopSegmentCount method .\
 * @param {Connector} element - provide the connector value.
 * @param {End} source - provide the source value.
 * @param {End} target - provide the target  value.
 * @private
 */
function getBottomToTopSegmentCount(element, source, target) {
    var pts;
    var diffX = source.point.x - target.point.x;
    //const diffY: number = source.point.y - target.point.y;
    //let bottom: PointModel = { x: source.point.x, y: Math.max(source.point.y, source.corners.bottom) };
    //let top: PointModel = { x: target.point.x, y: Math.min(target.point.y, target.corners.top) };
    var margin = findMargin(element);
    if (!(source.corners.right + margin < target.corners.left - margin ||
        source.corners.left - margin > target.corners.right + margin)) {
        if (element.type !== 'Bezier') {
            margin = 0;
        }
        else if (target.corners.top - source.corners.bottom <= margin * 2 && target.corners.top - source.corners.bottom >= 5) {
            margin = 0;
        }
    }
    source.margin = { left: margin, right: margin, top: margin, bottom: margin };
    target.margin = { left: margin, right: margin, top: margin, bottom: margin };
    if (diffX === 0 && source.corners.bottom < target.corners.top) {
        pts = NoOfSegments.One;
    }
    else if (source.corners.bottom + source.margin.bottom < target.corners.top - target.margin.top) {
        pts = NoOfSegments.Three;
    }
    else if (source.corners.right + source.margin.right < target.corners.left - target.margin.left) {
        pts = NoOfSegments.Five;
    }
    else if (source.corners.left - source.margin.left > target.corners.right + target.margin.right) {
        pts = NoOfSegments.Five;
    }
    else {
        pts = NoOfSegments.Five;
    }
    return pts;
}
/**
 * getBottomToLeftSegmentCount method \
 *
 * @returns { NoOfSegments } getBottomToLeftSegmentCount method .\
 * @param {End} element - provide the element value.
 * @param {End} source - provide the source  value.
 * @param {End} target - provide the target  value.
 * @param {End} swap - provide the swap  value.
 * @private
 */
function getBottomToLeftSegmentCount(element, source, target, swap) {
    var srcPort = element.sourcePortWrapper;
    var tarPort = element.targetPortWrapper;
    //let bottom: PointModel = { x: source.point.x, y: Math.max(source.point.y, source.corners.bottom) };
    //let left: PointModel = { x: Math.min(target.point.x, target.corners.left), y: target.point.y };
    var margin = findMargin(element);
    target.margin = { left: margin, right: margin, top: margin, bottom: margin };
    source.margin = { top: margin, bottom: margin, left: margin, right: margin };
    var pts;
    if (swap) {
        //let port: DiagramElement;
        var port = srcPort;
        srcPort = tarPort;
        tarPort = port;
    }
    if ((srcPort !== undefined && srcPort.offsetX < target.corners.left - target.margin.left) ||
        (srcPort === undefined && source.corners.bottomCenter.x < target.corners.bottomLeft.x - target.margin.left)) {
        if (source.corners.right < target.corners.left) {
            if ((tarPort !== undefined && source.corners.bottom + source.margin.bottom < tarPort.offsetY) ||
                (tarPort === undefined && source.corners.bottom + source.margin.bottom < target.corners.middleLeft.y)) {
                pts = NoOfSegments.Two;
            }
            else {
                pts = NoOfSegments.Four;
            }
        }
        else if ((tarPort !== undefined && source.corners.top > tarPort.offsetY) ||
            (tarPort === undefined && source.corners.top > target.corners.middleLeft.y)) {
            pts = NoOfSegments.Four;
        }
        else {
            pts = NoOfSegments.Two;
        }
    }
    else if (tarPort !== undefined &&
        Math.abs(source.corners.right - target.corners.left) <= 25 &&
        Math.abs(tarPort.offsetY - source.corners.bottom) <= 25) {
        pts = NoOfSegments.Two;
    }
    else {
        pts = NoOfSegments.Four;
    }
    return pts;
}
/**
 * getBottomToBottomSegmentCount method \
 *
 * @returns { NoOfSegments } getBottomToBottomSegmentCount method .\
 * @param {End} element - provide the element value.
 * @param {End} source - provide the source  value.
 * @param {End} target - provide the target  value.
 * @private
 */
function getBottomToBottomSegmentCount(element, source, target) {
    var srcPort = element.sourcePortWrapper;
    var tarPort = element.targetPortWrapper;
    var difX = Math.round(Math.abs(source.point.x - target.point.x));
    var diffY = Math.round(Math.abs(target.point.y - target.point.y));
    var pts;
    if (source.corners.bottom < target.corners.bottom) {
        if ((srcPort !== undefined && srcPort.offsetX < target.corners.left - target.margin.left) ||
            (srcPort === undefined && source.corners.bottomCenter.x < target.corners.left - target.margin.left)) {
            pts = NoOfSegments.Three;
        }
        else if ((srcPort !== undefined && srcPort.offsetX > target.corners.right + target.margin.right) ||
            (srcPort === undefined && source.corners.bottomCenter.x > target.corners.right + target.margin.right)) {
            pts = NoOfSegments.Three;
        }
        else if (source.corners.bottom < target.corners.top) {
            pts = NoOfSegments.Five;
        }
        else if (difX === 0 || diffY === 0) {
            pts = NoOfSegments.One;
        }
        else {
            pts = NoOfSegments.Three;
        }
    }
    else if ((tarPort !== undefined && source.corners.left - source.margin.left > tarPort.offsetX) ||
        (tarPort === undefined && source.corners.left > target.corners.left)) {
        pts = NoOfSegments.Three;
    }
    else if ((tarPort !== undefined && source.corners.right + source.margin.right < tarPort.offsetX) ||
        (tarPort === undefined &&
            source.corners.right < target.corners.right)) {
        pts = NoOfSegments.Three;
    }
    else if (source.corners.top > target.corners.bottom) {
        pts = NoOfSegments.Five;
    }
    else if (difX === 0 || diffY === 0) {
        pts = NoOfSegments.One;
    }
    else {
        pts = NoOfSegments.Three;
    }
    return pts;
}
/**
 * getLeftToTopSegmentCount method \
 *
 * @returns { NoOfSegments } getLeftToTopSegmentCount method .\
 * @param {End} element - provide the element value.
 * @param {End} source - provide the source  value.
 * @param {End} target - provide the target  value.
 * @param {End} swap - provide the swap  value.
 * @private
 */
function getLeftToTopSegmentCount(element, source, target, swap) {
    var pts;
    var sourcePort = element.sourcePortWrapper;
    var margin = findMargin(element);
    target.margin = { left: margin, right: margin, top: margin, bottom: margin };
    source.margin = { top: margin, bottom: margin, left: margin, right: margin };
    var tarPort = element.targetPortWrapper;
    var left = { x: Math.min(source.point.x, source.corners.left), y: source.point.y };
    var top = { x: target.point.x, y: Math.min(target.point.y, target.corners.top) };
    if (swap) {
        //let port: DiagramElement;
        var port = sourcePort;
        sourcePort = tarPort;
        tarPort = port;
        var point = left;
        left = top;
        top = point;
    }
    if ((sourcePort !== undefined && sourcePort.offsetY < target.corners.top - target.margin.top) ||
        (sourcePort === undefined && (source.corners.bottom < target.corners.top - target.margin.top ||
            source.corners.middleLeft.y < target.corners.top - target.margin.top))) {
        if (source.corners.bottom < target.corners.top) {
            if ((tarPort !== undefined && source.corners.left - source.margin.left > tarPort.offsetX) ||
                (tarPort === undefined && source.corners.left - source.margin.left > target.corners.topCenter.x)) {
                pts = NoOfSegments.Two;
            }
            else {
                pts = NoOfSegments.Four;
            }
        }
        else if ((tarPort !== undefined && source.corners.right < tarPort.offsetX) ||
            (tarPort === undefined && source.corners.right < target.corners.topCenter.x)) {
            pts = NoOfSegments.Four;
        }
        else {
            pts = NoOfSegments.Two;
        }
    }
    else if (sourcePort !== undefined &&
        Math.abs(source.corners.left - target.corners.right) <= 25 &&
        Math.abs(sourcePort.offsetY - target.corners.top) <= 25) {
        pts = NoOfSegments.Two;
    }
    else if (element.sourceWrapper !== element.targetWrapper &&
        (cornersPointsBeforeRotation(element.sourceWrapper).containsPoint(top) ||
            cornersPointsBeforeRotation(element.targetWrapper).containsPoint(left))) {
        pts = NoOfSegments.Two;
    }
    else if (source.corners.left > target.corners.right) {
        pts = NoOfSegments.Four;
    }
    else {
        pts = NoOfSegments.Four;
    }
    return pts;
}
/**
 * getLeftToLeftSegmentCount method \
 *
 * @returns { NoOfSegments } getLeftToLeftSegmentCount method .\
 * @param {End} element - provide the element value.
 * @param {End} source - provide the source  value.
 * @param {End} target - provide the target  value.
 * @private
 */
function getLeftToLeftSegmentCount(element, source, target) {
    var srcPort = element.sourcePortWrapper;
    var targetPort = element.targetPortWrapper;
    var margin = findMargin(element);
    source.margin = { left: margin, right: margin, top: margin, bottom: margin };
    target.margin = { left: margin, right: margin, top: margin, bottom: margin };
    var diffX = Math.round(Math.abs(source.point.x - target.point.x));
    var diffY = Math.round(Math.abs(source.point.y - target.point.y));
    var pts;
    if (source.corners.left < target.corners.left) {
        if ((targetPort !== undefined && source.corners.bottom + source.margin.bottom < targetPort.offsetY) ||
            (targetPort === undefined && source.corners.bottom + source.margin.bottom < target.corners.middleLeft.y)) {
            pts = NoOfSegments.Three;
        }
        else if ((targetPort !== undefined && source.corners.top - source.margin.top > targetPort.offsetY) ||
            (targetPort === undefined && source.corners.top - source.margin.top > target.corners.middleLeft.y)) {
            pts = NoOfSegments.Three;
        }
        else if (source.corners.right < target.corners.left ||
            target.corners.right < source.corners.left) {
            pts = NoOfSegments.Five;
        }
        else if (diffX === 0 || diffY === 0) {
            pts = NoOfSegments.One;
        }
        else {
            pts = NoOfSegments.Three;
        }
    }
    else if ((srcPort !== undefined && srcPort.offsetY < target.corners.top - target.margin.top) ||
        (srcPort === undefined && source.corners.middleLeft.y < target.corners.top)) {
        pts = NoOfSegments.Three;
    }
    else if ((srcPort !== undefined && srcPort.offsetY > target.corners.bottom + target.margin.bottom) ||
        (srcPort === undefined && source.corners.middleLeft.y > target.corners.bottom + target.margin.bottom)) {
        pts = NoOfSegments.Three;
    }
    else if (source.corners.left > target.corners.right) {
        pts = NoOfSegments.Five;
    }
    else if (diffX === 0 || diffY === 0) {
        pts = NoOfSegments.One;
    }
    else {
        pts = NoOfSegments.Three;
    }
    return pts;
}
/**
 * getTopToTopSegmentCount method \
 *
 * @returns { NoOfSegments } getTopToTopSegmentCount method .\
 * @param {End} element - provide the element value.
 * @param {End} source - provide the source  value.
 * @param {End} target - provide the target  value.
 * @private
 */
function getTopToTopSegmentCount(element, source, target) {
    var srcPort = element.sourcePortWrapper;
    var targetPort = element.targetPortWrapper;
    var diffX = Math.round(Math.abs(source.point.x - target.point.x));
    var diffY = Math.round(Math.abs(source.point.y - target.point.y));
    var margin = findMargin(element);
    target.margin = { left: margin, right: margin, top: margin, bottom: margin };
    source.margin = { top: margin, bottom: margin, left: margin, right: margin };
    var pts;
    if (source.corners.top < target.corners.top) {
        if ((targetPort !== undefined && source.corners.left - source.margin.left > targetPort.offsetX) ||
            (targetPort === undefined && source.corners.left > target.corners.left)) {
            pts = NoOfSegments.Three;
        }
        else if ((targetPort !== undefined && source.corners.right + source.margin.right < targetPort.offsetX) ||
            (targetPort === undefined && source.corners.right < target.corners.right)) {
            pts = NoOfSegments.Three;
        }
        else if (source.corners.bottom < target.corners.top) {
            pts = NoOfSegments.Five;
        }
        else if (diffX === 0 || diffY === 0) {
            pts = NoOfSegments.One;
        }
        else {
            pts = NoOfSegments.Three;
        }
    }
    else if ((srcPort !== undefined && srcPort.offsetX > target.corners.right + target.margin.right) ||
        (srcPort === undefined && source.corners.left > target.corners.right)) {
        pts = NoOfSegments.Three;
    }
    else if ((srcPort !== undefined && srcPort.offsetX < target.corners.left - target.margin.left) ||
        (srcPort === undefined && source.corners.bottomRight.x < target.corners.left)) {
        pts = NoOfSegments.Three;
    }
    else if (source.corners.top > target.corners.bottom) {
        pts = NoOfSegments.Five;
    }
    else if (diffX === 0 || diffY === 0) {
        pts = NoOfSegments.One;
    }
    else {
        pts = NoOfSegments.Three;
    }
    return pts;
}
/**
 * addOrthoSegments method \
 *
 * @returns {  PointModel[] } addOrthoSegments method .\
 * @param {Connector} element - provide the element value.
 * @param {NoOfSegments} seg - provide the seg  value.
 * @param {End} sourceEnd - provide the source  value.
 * @param {End} targetEnd - provide the target  value.
 * @param {number} segLength - provide the segLength  value.
 * @param {boolean} lineDistribution - provide the lineDistribution  value.
 * @private
 */
function addOrthoSegments(element, seg, sourceEnd, targetEnd, segLength, lineDistribution) {
    var src = element.sourceWrapper;
    var tar = element.targetWrapper;
    //let tarPort: DiagramElement = element.targetPortWrapper;
    var intermeditatePoints;
    var srcCorner = src.corners;
    var tarCorner = tar.corners;
    var value;
    var extra = 20;
    var source = { corners: sourceEnd.corners, point: sourceEnd.point, direction: sourceEnd.direction, margin: sourceEnd.margin };
    var target = { corners: targetEnd.corners, point: targetEnd.point, direction: targetEnd.direction, margin: targetEnd.margin };
    if (source.direction !== target.direction || seg === NoOfSegments.Five) {
        if (source.direction === getOppositeDirection(target.direction) || seg === NoOfSegments.Three) {
            switch (source.direction) {
                case 'Left':
                    if (srcCorner.middleLeft.x > tarCorner.middleRight.x) {
                        value = (srcCorner.middleLeft.x - tarCorner.middleRight.x) / 2;
                        extra = !lineDistribution ? Math.min(extra, value) : value;
                    }
                    break;
                case 'Right':
                    if (srcCorner.middleRight.x < tarCorner.middleLeft.x) {
                        value = (tarCorner.middleLeft.x - srcCorner.middleRight.x) / 2;
                        extra = !lineDistribution ? Math.min(extra, value) : value;
                    }
                    break;
                case 'Top':
                    if (srcCorner.topCenter.y > tarCorner.bottomCenter.y) {
                        value = (srcCorner.topCenter.y - tarCorner.bottomCenter.y) / 2;
                        extra = !lineDistribution ? Math.min(extra, value) : value;
                    }
                    break;
                case 'Bottom':
                    if (srcCorner.bottomCenter.y < tarCorner.topCenter.y) {
                        value = (tarCorner.topCenter.y - srcCorner.bottomCenter.y) / 2;
                        extra = !lineDistribution ? Math.min(extra, value) : value;
                    }
                    break;
            }
        }
    }
    extra = adjustSegmentLength(srcCorner, source, extra);
    var isBezier = element.type === 'Bezier';
    if (segLength) {
        extra = Math.max(extra, segLength);
    }
    if (seg === NoOfSegments.One) {
        intermeditatePoints = [source.point, target.point];
    }
    if (seg === NoOfSegments.Two) {
        intermeditatePoints = orthoConnection2Segment(source, target);
    }
    if (seg === NoOfSegments.Three) {
        intermeditatePoints = orthoConnection3Segment(element, source, target, extra, undefined, isBezier);
    }
    if (seg === NoOfSegments.Four) {
        var prevDir = undefined;
        intermeditatePoints = orthoConnection4Segment(source, target, prevDir, intermeditatePoints, extra, isBezier);
    }
    if (seg === NoOfSegments.Five) {
        intermeditatePoints = orthoConnection5Segment(source, target, extra, isBezier);
    }
    return intermeditatePoints;
}
/**
 * adjustSegmentLength method \
 *
 * @returns {  PointModel[] } adjustSegmentLength method .\
 * @param {Rect | Corners} bounds - provide the element value.
 * @param {End} source - provide the seg  value.
 * @param {number} extra - provide the source  value.
 * @private
 */
function adjustSegmentLength(bounds, source, extra) {
    switch (source.direction) {
        case 'Left':
            if (source.point.x > bounds.left) {
                extra = (source.point.x - bounds.left) > extra ? ((source.point.x - bounds.left) + extra) : extra;
            }
            break;
        case 'Right':
            if (source.point.x < bounds.right) {
                extra = (bounds.right - source.point.x) > extra ? ((bounds.right - source.point.x) + extra) : extra;
            }
            break;
        case 'Top':
            if (source.point.y > bounds.top) {
                extra = (source.point.y - bounds.top) > extra ? ((source.point.y - bounds.top) + extra) : extra;
            }
            break;
        case 'Bottom':
            if (source.point.y < bounds.bottom) {
                extra = (bounds.bottom - source.point.y) > extra ? ((bounds.bottom - source.point.y) + extra) : extra;
            }
            break;
    }
    return extra;
}
/**
 * orthoConnection2Segment method \
 *
 * @returns {  PointModel[] } orthoConnection2Segment method .\
 * @param {Rect | Corners} source - provide the source value.
 * @param {End} target - provide the target  value.
 * @private
 */
function orthoConnection2Segment(source, target) {
    var intermeditatePoints;
    switch (source.direction) {
        case 'Left':
        case 'Right':
            // eslint-disable-next-line
            var point1 = { x: target.point.x, y: source.point.y };
            intermeditatePoints = (Point.equals(source.point, point1) || Point.equals(target.point, point1)) ?
                [source.point, target.point] : [source.point, point1, target.point];
            break;
        case 'Top':
        case 'Bottom':
            // eslint-disable-next-line no-case-declarations
            var point2 = { x: source.point.x, y: target.point.y };
            intermeditatePoints = (Point.equals(source.point, point2) || Point.equals(target.point, point2)) ?
                [source.point, target.point] : [source.point, point2, target.point];
            break;
    }
    return intermeditatePoints;
}
/**
 * orthoConnection3Segment method \
 *
 * @returns {  PointModel[] } orthoConnection2Segment method .\
 * @param {Connector} element - provide the source value.
 * @param {End} source - provide the target  value.
 * @param {End} target - provide the target  value.
 * @param {number} extra - provide the target  value.
 * @param {boolean} allow - provide the target  value.
 * @param {boolean} isBezier - provide the isBezier boolean value.
 * @private
 */
function orthoConnection3Segment(element, source, target, extra, allow, isBezier) {
    if (isBezier === void 0) { isBezier = false; }
    if (!extra) {
        extra = 20;
    }
    if (isBezier) {
        if (source.direction !== target.direction) {
            if (source.direction === 'Left' || source.direction === 'Right') {
                extra = Math.floor(Math.abs(source.point.x - target.point.x) * 0.5);
            }
            else {
                extra = Math.floor(Math.abs(source.point.y - target.point.y) * 0.5);
            }
        }
    }
    var srcPort = element.sourcePortWrapper;
    var intermeditatePoints;
    var segmentValue;
    var next;
    var diffx = target.point.x - source.point.x;
    var diffy = target.point.y - source.point.y;
    var temp;
    if (!allow && (Math.abs(diffx) < 0.001 || Math.abs(diffy) < 0.001)) {
        if (target.direction === undefined) {
            intermeditatePoints = [source.point, target.point];
            return intermeditatePoints;
        }
    }
    if (element.targetWrapper === undefined && Math.abs(diffx) <= 31 && Math.abs(diffy) <= 31) {
        if ((source.direction === 'Left' || source.direction === 'Right')) {
            if (Math.abs(diffy) < 12) {
                source.direction = (source.point.y > target.point.y) ? 'Top' : 'Bottom';
            }
        }
        else {
            if (Math.abs(diffx) < 12) {
                source.direction = (source.point.x > target.point.x) ? 'Left' : 'Right';
            }
        }
        if (Math.abs(diffx) > 12 || Math.abs(diffy) > 12) {
            return orthoConnection2Segment(source, target);
        }
        else {
            extra += 5;
        }
    }
    if (source.direction === 'Left' || source.direction === 'Right') {
        if (source.direction === 'Right') {
            if (target.direction !== undefined && target.direction === 'Right') {
                extra = Math.max(source.point.x, target.point.x) - source.point.x + extra;
            }
            if (source.point.x > target.point.x && srcPort === undefined) {
                extra = -extra;
            }
        }
        else {
            if (target.direction !== undefined && target.direction === 'Left') {
                extra = source.point.x - Math.min(source.point.x, target.point.x) + extra;
            }
            if (source.point.x > target.point.x || srcPort !== undefined || source.direction === 'Left') {
                extra = -extra;
            }
        }
        temp = target.point.y - source.point.y;
        segmentValue = addLineSegment(source.point, extra, 0);
        temp = target.point.y - segmentValue.y;
        if (temp !== 0) {
            next = addLineSegment(segmentValue, target.point.y - segmentValue.y, 90);
        }
    }
    else if (source.direction === 'Top' || source.direction === 'Bottom') {
        if (source.direction === 'Bottom') {
            if (target.direction !== undefined && target.direction === 'Bottom') {
                extra = Math.max(source.point.y, target.point.y) - source.point.y + extra;
            }
        }
        else {
            if (target.direction !== undefined && target.direction === 'Top') {
                extra = source.point.y - Math.min(source.point.y, target.point.y) + extra;
            }
            if (source.point.y > target.point.y || (srcPort !== undefined) || source.direction === 'Top') {
                extra = -extra;
            }
        }
        temp = target.point.x - source.point.x;
        if (source.direction === 'Top') {
            segmentValue = addLineSegment(source.point, extra, 90);
        }
        else {
            segmentValue = addLineSegment(source.point, extra, 90);
        }
        temp = target.point.x - segmentValue.x;
        if (temp !== 0) {
            next = addLineSegment(segmentValue, target.point.x - segmentValue.x, 0);
        }
    }
    if (temp === 0) {
        return intermeditatePoints = [
            source.point,
            target.point
        ];
    }
    intermeditatePoints = [
        source.point,
        segmentValue,
        next,
        target.point
    ];
    return intermeditatePoints;
}
/**
 * orthoConnection5Segment method \
 *
 * @returns {  PointModel[] } orthoConnection5Segment method .\
 * @param {Connector} source - provide the source value.
 * @param {End} target - provide the target  value.
 * @param {End} extra - provide the extra  value.
 * @param {boolean} isBezier - provide the isBezier  value.
 * @private
 */
function orthoConnection5Segment(source, target, extra, isBezier) {
    if (extra === void 0) { extra = 20; }
    if (isBezier === void 0) { isBezier = false; }
    if (isBezier) {
        extra = 20;
    }
    var intermeditatePoints;
    var length = extra;
    var sLeft = source.corners.left - source.margin.left;
    var sRight = source.corners.right + source.margin.right;
    var sBottom = source.corners.bottom + source.margin.bottom;
    var sTop = source.corners.top - source.margin.top;
    var tLeft = target.corners.left - target.margin.left;
    var tRight = target.corners.right + target.margin.right;
    var tBottom = target.corners.bottom + target.margin.bottom;
    var tTop = target.corners.top - target.margin.top;
    var segmentValue;
    switch (source.direction) {
        case 'Left':
            if ((sTop > tTop && sTop < tBottom || sBottom < tBottom && sBottom > tTop) &&
                sLeft > tLeft && sLeft <= tRight && extra >= 20) {
                length = source.point.x - target.corners.left + length;
            }
            if (isBezier && source.direction === target.direction) {
                if (source.corners.left > target.corners.left && source.corners.left - target.corners.right >= 20) {
                    length = (source.corners.left - target.corners.right) / 2;
                }
            }
            segmentValue = addLineSegment(source.point, length, 180);
            break;
        case 'Top':
            if ((sLeft > tLeft && sLeft < tRight || sRight < tRight && sRight > tLeft) &&
                sTop > tTop && sTop <= tBottom && extra >= 20) {
                length = source.point.y - target.corners.top + length;
            }
            if (isBezier && source.direction === target.direction) {
                if (source.corners.top > target.corners.top && source.corners.top - target.corners.bottom >= 20) {
                    length = (source.corners.top - target.corners.bottom) / 2;
                }
            }
            segmentValue = addLineSegment(source.point, length, 270);
            break;
        case 'Right':
            if ((sTop > tTop && sTop < tBottom || sBottom < tBottom && sBottom > tTop) &&
                sRight < tRight && sRight >= tLeft && extra >= 20) {
                length = target.corners.right - source.point.x + length;
            }
            if (isBezier && source.direction === target.direction) {
                if (source.corners.right < target.corners.right && target.corners.left - source.corners.right >= 20) {
                    length = (target.corners.left - source.corners.right) / 2;
                }
            }
            segmentValue = addLineSegment(source.point, length, 0);
            break;
        case 'Bottom':
            if ((sLeft > tLeft && sLeft < tRight || sRight < tRight && sRight > tLeft) &&
                sBottom < tBottom && sBottom >= tTop && extra >= 20) {
                length = target.corners.bottom - source.point.y + length;
            }
            if (isBezier && source.direction === target.direction) {
                if (source.corners.bottom < target.corners.bottom && target.corners.top - source.corners.bottom >= 20) {
                    length = (target.corners.top - source.corners.bottom) / 2;
                }
            }
            segmentValue = addLineSegment(source.point, length, 90);
            break;
    }
    intermeditatePoints = [
        source.point,
        segmentValue
    ];
    var newExtra = undefined;
    if (source.direction === 'Top' || source.direction === 'Bottom') {
        var prevDir = source.direction;
        source.direction = segmentValue.x > target.point.x ? 'Left' : 'Right';
        source.point = segmentValue;
        newExtra = isBezier ? Math.abs(segmentValue.x - target.point.x) * 0.5 : newExtra;
        intermeditatePoints = orthoConnection4Segment(source, target, prevDir, intermeditatePoints, newExtra, isBezier);
    }
    else {
        var prevDir = source.direction;
        source.direction = segmentValue.y > target.point.y ? 'Top' : 'Bottom';
        source.point = segmentValue;
        newExtra = isBezier ? Math.abs(segmentValue.y - target.point.y) * 0.5 : newExtra;
        intermeditatePoints = orthoConnection4Segment(source, target, prevDir, intermeditatePoints, newExtra, isBezier);
    }
    return intermeditatePoints;
}
/**
 * orthoConnection4Segment method \
 *
 * @returns {  PointModel[] } orthoConnection4Segment method .\
 * @param {End} source - provide the target  value.
 * @param {End} target - provide the target  value.
 * @param {string} prevDir - provide the target  value.
 * @param {PointModel[]} interPt - provide the target  value.
 * @param {number} e - provide the target  value.
 * @param {boolean} isBezier - provide the target  value.
 * @private
 */
function orthoConnection4Segment(source, target, prevDir, interPt, e, isBezier) {
    if (e === void 0) { e = 20; }
    if (isBezier === void 0) { isBezier = false; }
    var segmentValue;
    if (prevDir === undefined) {
        source.margin = { left: 2, right: 2, top: 2, bottom: 2 };
        target.margin = { left: 0, right: 5, top: 0, bottom: 5 };
        if (isBezier) {
            source.margin = { left: 10, right: 10, top: 10, bottom: 10 };
            target.margin = { left: 10, right: 10, top: 10, bottom: 10 };
            if (source.direction === 'Left') {
                e = getLeftLength(source, target, prevDir, e);
                if (source.corners.left - target.corners.right >= 5) {
                    e = Math.abs(source.point.x - source.corners.left) + Math.floor(source.corners.left - target.corners.right) * 0.5;
                }
            }
            else if (source.direction === 'Right') {
                e = getRightLength(source, target, e, prevDir);
                if (target.corners.left - source.corners.right >= 5) {
                    e = Math.abs(source.point.x - source.corners.right) + Math.floor(target.corners.left - source.corners.right) * 0.5;
                }
            }
            else if (source.direction === 'Top') {
                e = getTopLength(source, target, prevDir, e);
                if (source.corners.top - target.corners.bottom >= 5) {
                    e = Math.abs(source.point.y - source.corners.top) + Math.floor(source.corners.top - target.corners.bottom) * 0.5;
                }
            }
            else if (source.direction === 'Bottom') {
                e = getBottomLength(source, target, e, prevDir);
                if (target.corners.top - source.corners.bottom >= 5) {
                    e = Math.abs(source.point.y - source.corners.bottom) + Math.floor(target.corners.top - source.corners.bottom) * 0.5;
                }
            }
        }
    }
    else {
        if (source.direction === 'Bottom') {
            if (isBezier) {
                if (target.corners.top - source.corners.bottom < 20) {
                    e = (target.corners.bottom - source.point.y) + 25;
                }
            }
            else {
                if (target.corners.top > source.corners.bottom && target.corners.top - source.corners.bottom < 20) {
                    e = (target.corners.top - source.corners.bottom) / 2;
                }
            }
        }
        else if (source.direction === 'Top') {
            if (isBezier) {
                if (source.corners.top - target.corners.bottom < 20) {
                    e = (source.point.y - target.corners.top) + 25;
                }
            }
            else {
                if (target.corners.bottom < source.corners.top && source.corners.top - target.corners.bottom < 20) {
                    e = (source.corners.top - target.corners.bottom) / 2;
                }
            }
        }
        else if (source.direction === 'Right') {
            if (isBezier) {
                if (target.corners.left - source.corners.right < 20) {
                    e = (target.corners.right - source.point.x) + 25;
                }
            }
            else {
                if (target.corners.left > source.corners.right && target.corners.left - source.corners.right < 20) {
                    e = (target.corners.left - source.corners.right) / 2;
                }
            }
        }
        else if (source.direction === 'Left') {
            if (isBezier) {
                if (source.corners.left - target.corners.right < 20) {
                    e = (source.point.x - target.corners.left) + 25;
                }
            }
            else {
                if (target.corners.right < source.corners.left && source.corners.left - target.corners.right < 20) {
                    e = (source.corners.left - target.corners.right) / 2;
                }
            }
        }
        if (prevDir === target.direction && isBezier) {
            if ((target.direction === 'Bottom' && source.point.y > target.point.y) ||
                (target.direction === 'Top' && source.point.y < target.point.y)) {
                if (source.direction === 'Left') {
                    e = getLeftLength(source, target, prevDir, 20);
                }
                else if (source.direction === 'Right') {
                    e = getRightLength(source, target, 20, prevDir);
                }
            }
            else if ((target.direction === 'Right' && source.point.x > target.point.x) ||
                (target.direction === 'Left' && source.point.x < target.point.x)) {
                if (source.direction === 'Top') {
                    e = getTopLength(source, target, prevDir, 20);
                }
                else if (source.direction === 'Bottom') {
                    e = getBottomLength(source, target, 20, prevDir);
                }
            }
        }
    }
    switch (source.direction) {
        case 'Left':
            e = isBezier ? e : getLeftLength(source, target, prevDir, e);
            segmentValue = addLineSegment(source.point, e, 180);
            break;
        case 'Right':
            e = isBezier ? e : getRightLength(source, target, e, prevDir);
            segmentValue = addLineSegment(source.point, e, 0);
            break;
        case 'Top':
            e = isBezier ? e : getTopLength(source, target, prevDir, e);
            segmentValue = addLineSegment(source.point, e, 270);
            break;
        case 'Bottom':
            e = isBezier ? e : getBottomLength(source, target, e, prevDir);
            segmentValue = addLineSegment(source.point, e, 90);
    }
    if (interPt !== undefined) {
        interPt.push(segmentValue);
    }
    else {
        interPt = [
            source.point,
            segmentValue
        ];
    }
    if (source.direction === 'Top' || source.direction === 'Bottom') {
        getOrtho3Seg(segmentValue, 'horizontal', source, target, interPt, isBezier);
    }
    else if (source.direction === 'Right' || source.direction === 'Left') {
        getOrtho3Seg(segmentValue, 'vertical', source, target, interPt, isBezier);
    }
    return interPt;
}
/**
 * getOrtho3Seg method \
 *
 * @returns {  void } getOrtho3Seg method .\
 * @param {PointModel} sPt - provide the sPt  value.
 * @param {string} orientation - provide the orientation  value.
 * @param {End} src - provide the src  value.
 * @param {End} tar - provide the tar  value.
 * @param {PointModel[]} points - provide the points  value.
 * @param {boolean} isBezier - provide the isBezier  value.
 * @private
 */
function getOrtho3Seg(sPt, orientation, src, tar, points, isBezier) {
    var point1;
    var point2;
    var point3;
    if (orientation === 'horizontal') {
        src.margin = { left: 0, right: 10, top: 0, bottom: 10 };
        tar.margin = { left: 0, right: 10, top: 0, bottom: 10 };
    }
    else if (orientation === 'vertical') {
        src.margin = { left: 10, right: 0, top: 10, bottom: 0 };
        tar.margin = { left: 10, right: 0, top: 10, bottom: 0 };
    }
    var extra = 20;
    if (orientation === 'horizontal') {
        switch (tar.direction) {
            case 'Left':
                if (src.corners.right + src.margin.right < tar.corners.left - tar.margin.left &&
                    (tar.corners.left - src.margin.right - src.corners.right > extra || (src.corners.top - src.margin.top <= tar.point.y &&
                        src.corners.bottom + src.margin.bottom >= tar.point.y))) {
                    if (isBezier && (src.direction === 'Top' || src.direction === 'Bottom')) {
                        var gap = Math.abs(tar.corners.left - src.corners.right) / 2;
                        extra = src.corners.right - sPt.x + gap;
                    }
                    else {
                        var gap = Math.min(Math.abs(tar.corners.left - src.corners.right) / 2, 20);
                        extra = src.corners.right - sPt.x + gap;
                    }
                }
                else {
                    if ((src.direction === 'Top' && sPt.y > tar.point.y) || (src.direction === 'Bottom' && sPt.y < tar.point.y)) {
                        extra = Math.min(tar.corners.left, sPt.x) - sPt.x - 20;
                    }
                    else if (sPt.x >= src.corners.left - src.margin.left && sPt.x <= src.corners.right + src.margin.right) {
                        extra = Math.min(tar.corners.left, src.corners.left) - sPt.x - 20;
                    }
                    else {
                        extra = tar.corners.left - sPt.x - 20;
                    }
                }
                break;
            case 'Right':
                if (src.corners.left - src.margin.left > tar.corners.right + tar.margin.right &&
                    (src.corners.left - src.margin.right - tar.corners.right > extra || (src.corners.top - src.margin.top <= tar.point.y &&
                        src.corners.bottom + src.margin.bottom >= tar.point.y))) {
                    if (isBezier && (src.direction === 'Top' || src.direction === 'Bottom')) {
                        var gap = Math.abs(src.corners.left - tar.corners.right) / 2;
                        extra = src.corners.left - sPt.x - gap;
                    }
                    else {
                        var gap = Math.min(Math.abs(src.corners.left - tar.corners.right) / 2, 20);
                        extra = src.corners.left - sPt.x - gap;
                    }
                }
                else {
                    if ((src.direction === 'Top' && sPt.y > tar.point.y) || (src.direction === 'Bottom' && sPt.y < tar.point.y)) {
                        extra = Math.max(tar.corners.right, sPt.x) - sPt.x + 20;
                    }
                    else if (sPt.x >= src.corners.left - src.margin.left && sPt.x <= src.corners.right + src.margin.right) {
                        extra = Math.max(tar.corners.right, src.corners.right) - sPt.x + 20;
                    }
                    else {
                        extra = tar.corners.right - sPt.x + 20;
                    }
                }
                break;
        }
        point1 = addLineSegment(sPt, extra, 0);
        point2 = addLineSegment(point1, tar.point.y - sPt.y, 90);
        point3 = tar.point;
    }
    else if (orientation === 'vertical') {
        switch (tar.direction) {
            case 'Top':
                if (src.corners.bottom + src.margin.bottom < tar.corners.top - tar.margin.top &&
                    (tar.corners.top - src.margin.top - src.corners.bottom > extra || (src.corners.left - src.margin.left <= tar.point.x &&
                        src.corners.right + src.margin.right >= tar.point.x))) {
                    if (isBezier && (src.direction === 'Right' || src.direction === 'Left')) {
                        var gap = Math.abs(tar.corners.top - src.corners.bottom) / 2;
                        extra = src.corners.bottom - sPt.y + gap;
                    }
                    else {
                        var gap = Math.min(Math.abs(tar.corners.top - src.corners.bottom) / 2, 20);
                        extra = src.corners.bottom - sPt.y + gap;
                    }
                }
                else {
                    if ((src.direction === 'Left' && sPt.x > tar.point.x) || (src.direction === 'Right' && sPt.x < tar.point.x)) {
                        extra = Math.min(tar.corners.top, sPt.y) - sPt.y - 20;
                    }
                    else if (sPt.y >= src.corners.top - src.margin.top && sPt.y <= src.corners.bottom + src.margin.bottom) {
                        extra = Math.min(tar.corners.top, src.corners.top) - sPt.y - 20;
                    }
                    else {
                        extra = tar.corners.top - sPt.y - 20;
                    }
                }
                break;
            case 'Bottom':
                if (src.corners.top - src.margin.top > tar.corners.bottom + tar.margin.bottom &&
                    (src.corners.top - src.margin.top - tar.corners.bottom > extra || (src.corners.left - src.margin.left <= tar.point.x &&
                        src.corners.right + src.margin.right >= tar.point.x))) {
                    if (isBezier && (src.direction === 'Right' || src.direction === 'Left')) {
                        var gap = Math.abs(src.corners.top - tar.corners.bottom) / 2;
                        extra = src.corners.top - sPt.y - gap;
                    }
                    else {
                        var gap = Math.min(Math.abs(src.corners.top - tar.corners.bottom) / 2, 20);
                        extra = src.corners.top - sPt.y - gap;
                    }
                }
                else {
                    if ((src.direction === 'Left' && sPt.x > tar.point.x) || (src.direction === 'Right' && sPt.x < tar.point.x)) {
                        extra = Math.max(tar.corners.bottom, sPt.y) - sPt.y + 20;
                    }
                    else if (sPt.y >= src.corners.top - src.margin.top && sPt.y <= src.corners.bottom + src.margin.bottom) {
                        extra = Math.max(tar.corners.bottom, src.corners.bottom) - sPt.y + 20;
                    }
                    else {
                        extra = tar.corners.bottom - sPt.y + 20;
                    }
                }
                break;
        }
        point1 = addLineSegment(sPt, extra, 90);
        point2 = addLineSegment(point1, tar.point.x - sPt.x, 0);
        point3 = tar.point;
    }
    points.push(point1);
    points.push(point2);
    points.push(point3);
}
/**
 * getTopLength method \
 *
 * @returns {  number } getTopLength method .\
 * @param {End} source - provide the sPt  value.
 * @param {End} target - provide the sPt  value.
 * @param {string} preDir - provide the orientation  value.
 * @param {number} length - provide the src  value.
 * @private
 */
function getTopLength(source, target, preDir, length) {
    if (source.corners.top - source.margin.top > target.corners.top + target.margin.top &&
        source.corners.top - source.margin.top <= target.corners.bottom + target.margin.bottom) {
        if (target.direction === 'Right' && source.point.x < target.point.x) {
            length += source.corners.top - target.corners.top;
        }
        else if (target.direction === 'Left' && source.point.x > target.point.x) {
            length += source.corners.top - target.corners.top;
        }
        length += source.point.y - source.corners.top;
    }
    else {
        if ((preDir !== undefined && preDir !== 'Left') && target.direction === 'Right' && source.point.x < target.point.x) {
            length += Math.abs(source.point.y - target.corners.bottom);
        }
        else if ((preDir !== undefined && preDir !== 'Right') && target.direction === 'Left'
            && target.point.x < source.point.x) {
            length += Math.abs(source.point.y - target.corners.bottom);
        }
        else {
            length += source.point.y - source.corners.top;
        }
    }
    return length;
}
/**
 * getLeftLength method \
 *
 * @returns {  number } getLeftLength method .\
 * @param {End} source - provide the sPt  value.
 * @param {End} target - provide the sPt  value.
 * @param {string} prevDir - provide the orientation  value.
 * @param {number} segLength - provide the src  value.
 * @private
 */
function getLeftLength(source, target, prevDir, segLength) {
    if (source.corners.left - source.margin.left > target.corners.left - target.margin.left &&
        source.corners.left - source.margin.left <= target.corners.right + target.margin.right) {
        if (target.direction === 'Bottom' && source.point.y < target.point.y) {
            segLength += source.corners.left - target.corners.left;
        }
        else if (target.direction === 'Top' && source.point.y > target.point.y) {
            segLength += source.corners.left - target.corners.left;
        }
        segLength += source.point.x - source.corners.left;
    }
    else {
        if ((prevDir !== undefined && prevDir !== 'Top') && target.direction === 'Bottom' && source.point.y < target.point.y) {
            segLength += Math.abs(source.point.x - target.corners.right);
        }
        else if ((prevDir !== undefined && prevDir !== 'Bottom') &&
            target.direction === 'Top' && target.point.y < source.point.y) {
            segLength += Math.abs(source.point.x - target.corners.right);
        }
        else {
            segLength += source.point.x - source.corners.left;
        }
    }
    return segLength;
}
/**
 * getRightLength method \
 *
 * @returns {  number } getRightLength method .\
 * @param {End} source - provide the sPt  value.
 * @param {End} target - provide the orientation  value.
 * @param {number} length - provide the src  value.
 * @param {string} prevDir - provide the src  value.
 * @private
 */
function getRightLength(source, target, length, prevDir) {
    if (source.corners.right + source.margin.right < target.corners.right + target.margin.right &&
        source.corners.right + source.margin.right >= target.corners.left - target.margin.left) {
        if (target.direction === 'Bottom' && source.point.y < target.point.y) {
            length += target.corners.right - source.corners.right;
        }
        else if (target.direction === 'Top' && source.point.y > target.point.y) {
            length += target.corners.right - source.corners.right;
        }
        length += source.corners.right - source.point.x;
    }
    else {
        if ((prevDir !== undefined && prevDir !== 'Top') && target.direction === 'Bottom' && source.point.y < target.point.y) {
            length += Math.abs(source.point.x - target.corners.right);
        }
        else if ((prevDir !== undefined && prevDir !== 'Bottom') && target.direction === 'Top' && target.point.y < source.point.y) {
            length += Math.abs(source.point.x - target.corners.right);
        }
        else {
            length += source.corners.right - source.point.x;
        }
    }
    return length;
}
/**
 * getBottomLength method \
 *
 * @returns {  number } getBottomLength method .\
 * @param {End} source - provide the source  value.
 * @param {End} target - provide the target  value.
 * @param {number} segLength - provide the segLength  value.
 * @param {string} prevDir - provide the src  value.
 * @private
 */
function getBottomLength(source, target, segLength, prevDir) {
    if (source.corners.bottom + source.margin.bottom < target.corners.bottom + target.margin.bottom &&
        source.corners.bottom + source.margin.bottom >= target.corners.top - target.margin.top) {
        if (target.direction === 'Right' && source.point.x < target.point.x) {
            segLength += target.corners.bottom - source.corners.bottom;
        }
        else if (target.direction === 'Left' && source.point.x > target.point.x) {
            segLength += target.corners.bottom - source.corners.bottom;
        }
        segLength += source.corners.bottom - source.point.y;
    }
    else {
        if ((prevDir !== undefined && prevDir !== 'Left') &&
            target.direction === 'Right' && source.point.x < target.point.x) {
            segLength += Math.abs(source.point.y - target.corners.bottom);
        }
        else if ((prevDir !== undefined && prevDir !== 'Right') &&
            target.direction === 'Left' && target.point.x < source.point.x) {
            segLength += Math.abs(source.point.y - target.corners.bottom);
        }
        else {
            segLength += source.corners.bottom - source.point.y;
        }
    }
    return segLength;
}
function convertPointToBezierSegment(element, segCount, pts) {
    if (element.type === 'Bezier') {
        if (element.segments.length === 0) {
            var start = pts[0];
            var end = pts[pts.length - 1];
            if (segCount === NoOfSegments.One) {
                var distance = Math.min(20, Point.findLength(start, end) * 0.5);
                var vector1 = { angle: findAngle(start, end), distance: distance };
                var vector2 = { angle: findAngle(end, start), distance: distance };
                var dir = Point.direction(start, end);
                var ori = dir === 'Left' || dir === 'Right' ? 'Horizontal' : 'Vertical';
                var segment = new BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector1, vector2: vector2, orientation: ori }, true);
                (element.segments).push(segment);
            }
            else if (segCount === NoOfSegments.Two) {
                var mid = pts[1];
                var vector1 = { angle: findAngle(start, mid), distance: Point.findLength(start, mid) * 0.5 };
                var vector2 = { angle: findAngle(end, mid), distance: Point.findLength(end, mid) * 0.5 };
                var dir = Point.direction(start, mid);
                var ori = dir === 'Left' || dir === 'Right' ? 'Horizontal' : 'Vertical';
                var segment = new BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector1, vector2: vector2, orientation: ori }, true);
                (element.segments).push(segment);
            }
            else if (segCount === NoOfSegments.Three) {
                var mid1 = pts[1];
                var mid2 = pts[pts.length - 2];
                var mid = { x: (mid1.x + mid2.x) * 0.5, y: (mid1.y + mid2.y) * 0.5 };
                var vector1 = { angle: findAngle(start, mid1), distance: Point.findLength(start, mid1) * 0.5 };
                var vector2 = { angle: findAngle(mid, mid1), distance: Point.findLength(mid, mid1) * 0.5 };
                var dir1 = Point.direction(start, mid1);
                var ori1 = dir1 === 'Left' || dir1 === 'Right' ? 'Horizontal' : 'Vertical';
                var segment1 = new BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector1, vector2: vector2, point: mid, orientation: ori1 }, true);
                (element.segments).push(segment1);
                var vector3 = { angle: findAngle(mid, mid2), distance: Point.findLength(mid, mid2) * 0.5 };
                var vector4 = { angle: findAngle(end, mid2), distance: Point.findLength(end, mid2) * 0.5 };
                var dir2 = Point.direction(mid, mid2);
                var ori2 = dir2 === 'Left' || dir2 === 'Right' ? 'Horizontal' : 'Vertical';
                var segment2 = new BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector3, vector2: vector4, orientation: ori2 }, true);
                (element.segments).push(segment2);
            }
            else if (segCount === NoOfSegments.Four) {
                var mid1 = pts[1];
                var mid2 = pts[2];
                var mid3 = pts[3];
                var center1 = { x: (mid1.x + mid2.x) * 0.5, y: (mid1.y + mid2.y) * 0.5 };
                var center2 = { x: (mid2.x + mid3.x) * 0.5, y: (mid2.y + mid3.y) * 0.5 };
                var vector1 = { angle: findAngle(start, mid1), distance: Point.findLength(start, mid1) * 0.5 };
                var vector2 = { angle: findAngle(center1, mid1), distance: Point.findLength(center1, mid1) * 0.5 };
                var dir1 = Point.direction(start, mid1);
                var ori1 = dir1 === 'Left' || dir1 === 'Right' ? 'Horizontal' : 'Vertical';
                var segment1 = new BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector1, vector2: vector2, point: center1, orientation: ori1 }, true);
                (element.segments).push(segment1);
                var vector3 = { angle: findAngle(center1, mid2), distance: Point.findLength(center1, mid2) * 0.5 };
                var vector4 = { angle: findAngle(center2, mid2), distance: Point.findLength(center2, mid2) * 0.5 };
                var dir2 = Point.direction(center1, mid2);
                var ori2 = dir2 === 'Left' || dir2 === 'Right' ? 'Horizontal' : 'Vertical';
                var segment2 = new BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector3, vector2: vector4, point: center2, orientation: ori2 }, true);
                (element.segments).push(segment2);
                var vector5 = { angle: findAngle(center2, mid3), distance: Point.findLength(center2, mid3) * 0.5 };
                var vector6 = { angle: findAngle(end, mid3), distance: Point.findLength(end, mid3) * 0.5 };
                var dir3 = Point.direction(center2, mid3);
                var ori3 = dir3 === 'Left' || dir3 === 'Right' ? 'Horizontal' : 'Vertical';
                var segment3 = new BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector5, vector2: vector6, orientation: ori3 }, true);
                (element.segments).push(segment3);
            }
            else if (segCount === NoOfSegments.Five) {
                var mid1 = pts[1];
                var mid2 = pts[2];
                var mid3 = pts[3];
                var mid4 = pts[4];
                var center1 = { x: (mid1.x + mid2.x) * 0.5, y: (mid1.y + mid2.y) * 0.5 };
                var center2 = { x: (mid2.x + mid3.x) * 0.5, y: (mid2.y + mid3.y) * 0.5 };
                var center3 = { x: (mid3.x + mid4.x) * 0.5, y: (mid3.y + mid4.y) * 0.5 };
                var vector1 = { angle: findAngle(start, mid1), distance: Point.findLength(start, mid1) * 0.5 };
                var vector2 = { angle: findAngle(center1, mid1), distance: Point.findLength(center1, mid1) * 0.5 };
                var dir1 = Point.direction(start, mid1);
                var ori1 = dir1 === 'Left' || dir1 === 'Right' ? 'Horizontal' : 'Vertical';
                var segment1 = new BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector1, vector2: vector2, point: center1, orientation: ori1 }, true);
                (element.segments).push(segment1);
                var vector3 = { angle: findAngle(center1, mid2), distance: Point.findLength(center1, mid2) * 0.5 };
                var vector4 = { angle: findAngle(center2, mid2), distance: Point.findLength(center2, mid2) * 0.5 };
                var dir2 = Point.direction(center1, mid2);
                var ori2 = dir2 === 'Left' || dir2 === 'Right' ? 'Horizontal' : 'Vertical';
                var segment2 = new BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector3, vector2: vector4, point: center2, orientation: ori2 }, true);
                (element.segments).push(segment2);
                var vector5 = { angle: findAngle(center2, mid3), distance: Point.findLength(center2, mid3) * 0.5 };
                var vector6 = { angle: findAngle(center3, mid3), distance: Point.findLength(center3, mid3) * 0.5 };
                var dir3 = Point.direction(center2, mid3);
                var ori3 = dir3 === 'Left' || dir3 === 'Right' ? 'Horizontal' : 'Vertical';
                var segment3 = new BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector5, vector2: vector6, point: center3, orientation: ori3 }, true);
                (element.segments).push(segment3);
                var vector7 = { angle: findAngle(center3, mid4), distance: Point.findLength(center3, mid4) * 0.5 };
                var vector8 = { angle: findAngle(end, mid4), distance: Point.findLength(end, mid4) * 0.5 };
                var dir4 = Point.direction(center3, mid4);
                var ori4 = dir4 === 'Left' || dir4 === 'Right' ? 'Horizontal' : 'Vertical';
                var segment4 = new BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector7, vector2: vector8, orientation: ori4 }, true);
                (element.segments).push(segment4);
            }
            else {
                var segment = new BezierSegment(element, 'segments', { type: 'Bezier' }, true);
                (element.segments).push(segment);
            }
        }
        else {
            for (var i = 0; i < element.segments.length; i++) {
                if (element.bezierSettings.allowSegmentsReset) {
                    element.segments[parseInt(i.toString(), 10)].isInternalSegment = true;
                }
            }
        }
    }
}
/**
 * getSwapping method \
 *
 * @returns {  boolean } getSwapping method .\
 * @param {string} srcDir - provide the source  value.
 * @param {string} tarDir - provide the target  value.
 * @private
 */
function getSwapping(srcDir, tarDir) {
    var swap = false;
    switch (srcDir) {
        case 'Left':
            switch (tarDir) {
                case 'Right':
                case 'Bottom':
                    swap = true;
                    break;
            }
            break;
        case 'Top':
            switch (tarDir) {
                case 'Left':
                case 'Right':
                case 'Bottom':
                    swap = true;
                    break;
            }
            break;
        case 'Bottom':
            switch (tarDir) {
                case 'Right':
                    swap = true;
                    break;
            }
            break;
    }
    return swap;
}
/**
 * swapPoints method \
 *
 * @returns {  void } swapPoints method .\
 * @param {End} source - provide the source  value.
 * @param {End} target - provide the target  value.
 * @private
 */
function swapPoints(source, target) {
    var direction = source.direction;
    source.direction = target.direction;
    target.direction = direction;
    var point = source.point;
    source.point = target.point;
    target.point = point;
    var corner = source.corners;
    source.corners = target.corners;
    target.corners = corner;
}
/**
 * getPortDirection method \
 *
 * @returns {  boolean } getPortDirection method .\
 * @param {PointModel} point - provide the point  value.
 * @param {Corners} corner - provide the corner  value.
 * @param {Rect} bounds - provide the bounds  value.
 * @param {boolean} closeEdge - provide the closeEdge  value.
 * @private
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function getPortDirection(point, corner, bounds, closeEdge) {
    var direction;
    var boundsValue = corner === undefined ? bounds : corner;
    var one = boundsValue.topLeft;
    var two = boundsValue.topRight;
    var three = boundsValue.bottomRight;
    var four = boundsValue.bottomLeft;
    var center = boundsValue.center;
    var angle = findAngle(center, point);
    var fourty5 = findAngle(center, three);
    var one35 = findAngle(center, four);
    var two25 = findAngle(center, one);
    var three15 = findAngle(center, two);
    if (angle > two25 && angle < three15) {
        direction = 'Top';
        // if (bounds.width < bounds.height && closeEdge) {
        //     let height: number = (bounds.height - bounds.width) / 2;
        //     let width: number = bounds.width;
        //     if (Math.abs(point.x - one.x) < Math.abs(point.x - two.x)) {
        //         direction = checkCloseEdge(direction, new Rect(one.x, one.y, width, height), point, 'Left');
        //     } else {
        //         direction = checkCloseEdge(direction, new Rect(two.x - bounds.width, two.y, width, height), point, 'Right');
        //     }
        // }
    }
    else if (angle >= fourty5 && angle < one35) {
        direction = 'Bottom';
        // if (bounds.width < bounds.height && closeEdge) {
        //     let height: number = (bounds.height - bounds.width) / 2;
        //     let width: number = bounds.width;
        //     if (Math.abs(point.x - four.x) < Math.abs(point.x - three.x)) {
        //         direction = checkCloseEdge(direction, new Rect(four.x, four.y - height, width, height), point, 'Left');
        //     } else {
        //         let value: Rect = new Rect(three.x - bounds.width, three.y - bounds.height / 4, bounds.width, bounds.height / 4);
        //         direction = checkCloseEdge(direction, value, point, 'Right');
        //     }
        // }
    }
    else if (angle >= one35 && angle <= two25) {
        direction = 'Left';
        // if (bounds.width > bounds.height && closeEdge) {
        //     let width: number = (bounds.width - bounds.height) / 2;
        //     let height: number = bounds.height;
        //     if (Math.abs(point.y - one.y) < Math.abs(point.y - four.y)) {
        //         direction = checkCloseEdge(direction, new Rect(one.x, one.y, width, height), point, 'Top');
        //     } else {
        //         direction = checkCloseEdge(direction, new Rect(four.x, four.y - height, width, height), point, 'Bottom');
        //     }
        // }
    }
    else if (angle >= three15 || angle < fourty5) {
        direction = 'Right';
        // if (bounds.width > bounds.height && closeEdge) {
        //     let width: number = (bounds.width - bounds.height) / 2;
        //     let height: number = bounds.height;
        //     if (Math.abs(point.y - two.y) < Math.abs(point.y - three.y)) {
        //         direction = checkCloseEdge(direction, new Rect(two.x - width, two.y, width, height), point, 'Top');
        //     } else {
        //         direction = checkCloseEdge(direction,
        //new Rect(three.x - width, three.y - height, width, height), point, 'Bottom');
        //     }
        // }
    }
    else {
        direction = 'Right';
    }
    return direction;
}
// function checkCloseEdge(direction: string, threshold: Rect, port: PointModel, nearest: string): string {
// if (threshold) {
//     switch (direction) {
//         case 'Bottom':
//         case 'Top':
//             let left: number = Math.abs(threshold.left - port.x);
//             let right: number = Math.abs(threshold.right - port.x);
//             let ver: number = direction === 'Top' ? Math.abs(threshold.top - port.y) : Math.abs(threshold.bottom - port.y);
//             if (left < right) {
//                 if (left < ver) {
//                     return 'Left';
//                 }
//             } else {
//                 if (right < ver) {
//                     return 'Right';
//                 }
//             }
//             break;
//         case 'Left':
//         case 'Right':
//             let top: number = Math.abs(threshold.top - port.y);
//             let bottom: number = Math.abs(threshold.bottom - port.y);
//             let hor: number = direction === 'Left' ? Math.abs(threshold.left - port.x) : Math.abs(threshold.right - port.x);
//             if (top < bottom) {
//                 if (top < hor) {
//                     return 'Top';
//                 }
//             } else {
//                 if (bottom < hor) {
//                     return 'Bottom';
//                 }
//             }
//             break;
//     }
// }
//Meant for dock port
//    return direction;
//  }
/**
 * getOuterBounds method \
 *
 * @returns {  Rect } getOuterBounds method .\
 * @param {Connector} obj - provide the point  value.
 * @private
 */
function getOuterBounds(obj) {
    //let outerBounds: Rect;
    var outerBounds = obj.wrapper.children[0].bounds;
    if (obj.sourceDecorator.shape !== 'None') {
        outerBounds.uniteRect(obj.wrapper.children[1].bounds);
    }
    if (obj.targetDecorator.shape !== 'None') {
        outerBounds.uniteRect(obj.wrapper.children[2].bounds);
    }
    return outerBounds;
}
/**
 * getOppositeDirection method \
 *
 * @returns {  string } getOppositeDirection method .\
 * @param {string} direction - provide the direction  value.
 * @private
 */
function getOppositeDirection(direction) {
    switch (direction) {
        case 'Top':
            return 'Bottom';
        case 'Bottom':
            return 'Top';
        case 'Left':
            return 'Right';
        case 'Right':
            return 'Left';
    }
    return 'auto';
}

var __extends$b = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * customize the size of the individual palette items.
 */
var SymbolSize = /** @class */ (function (_super) {
    __extends$b(SymbolSize, _super);
    function SymbolSize() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$5([
        Property()
    ], SymbolSize.prototype, "width", void 0);
    __decorate$5([
        Property()
    ], SymbolSize.prototype, "height", void 0);
    return SymbolSize;
}(ChildProperty));
/**
 * Defines the size and description of a symbol
 */
var SymbolPaletteInfo = /** @class */ (function (_super) {
    __extends$b(SymbolPaletteInfo, _super);
    function SymbolPaletteInfo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$5([
        Property()
    ], SymbolPaletteInfo.prototype, "width", void 0);
    __decorate$5([
        Property()
    ], SymbolPaletteInfo.prototype, "height", void 0);
    __decorate$5([
        Property()
    ], SymbolPaletteInfo.prototype, "fit", void 0);
    __decorate$5([
        Property()
    ], SymbolPaletteInfo.prototype, "description", void 0);
    __decorate$5([
        Property()
    ], SymbolPaletteInfo.prototype, "template", void 0);
    __decorate$5([
        Property()
    ], SymbolPaletteInfo.prototype, "tooltip", void 0);
    return SymbolPaletteInfo;
}(ChildProperty));

var __extends$c = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Defines the common behavior of nodes, connectors and groups
 */
var NodeBase = /** @class */ (function (_super) {
    __extends$c(NodeBase, _super);
    function NodeBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$6([
        Property('')
    ], NodeBase.prototype, "id", void 0);
    __decorate$6([
        Property(Number.MIN_VALUE)
    ], NodeBase.prototype, "zIndex", void 0);
    __decorate$6([
        Complex({}, Margin)
    ], NodeBase.prototype, "margin", void 0);
    __decorate$6([
        Property(true)
    ], NodeBase.prototype, "visible", void 0);
    __decorate$6([
        Complex({}, DiagramTooltip)
    ], NodeBase.prototype, "tooltip", void 0);
    __decorate$6([
        Property(false)
    ], NodeBase.prototype, "excludeFromLayout", void 0);
    __decorate$6([
        Property()
    ], NodeBase.prototype, "addInfo", void 0);
    __decorate$6([
        Property(FlipDirection.None)
    ], NodeBase.prototype, "flip", void 0);
    __decorate$6([
        Property('All')
    ], NodeBase.prototype, "flipMode", void 0);
    __decorate$6([
        Complex({}, SymbolPaletteInfo)
    ], NodeBase.prototype, "symbolInfo", void 0);
    return NodeBase;
}(ChildProperty));

var __extends$d = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * HTMLElement defines the basic html elements
 */
var DiagramHtmlElement = /** @class */ (function (_super) {
    __extends$d(DiagramHtmlElement, _super);
    /**
     * set the id for each element \
     *
     * @returns { void }set the id for each element\
     * @param {string} nodeId - provide the x value.
     * @param {string} diagramId - provide the y value.
     * @param {string} annotationId - provide the id value.
     * @param {string} nodeTemplate - provide the id value.
     *
     * @private
     */
    function DiagramHtmlElement(nodeId, diagramId, annotationId, nodeTemplate) {
        var _this = _super.call(this) || this;
        _this.data = '';
        /**
         * Gets the node id for the element
         */
        _this.nodeId = '';
        /**
         * defines the id of the annotation on rendering template on label.
         * @private
         */
        _this.annotationId = '';
        /**
         * Gets the diagram id for the html element
         */
        _this.diagramId = '';
        _this.diagramId = diagramId;
        _this.nodeId = nodeId;
        _this.annotationId = annotationId;
        _this.templateFn = templateCompiler(nodeTemplate);
        return _this;
    }
    /**
     * getNodeTemplate method \
     *
     * @returns { Function } getNodeTemplate method .\
     *
     * @private
     */
    DiagramHtmlElement.prototype.getNodeTemplate = function () {
        return this.templateFn;
    };
    Object.defineProperty(DiagramHtmlElement.prototype, "content", {
        /**
         * Gets or sets the geometry of the html element \
         *
         * @returns { string | HTMLElement } Gets or sets the geometry of the html element \
         *
         * @private
         */
        get: function () {
            return this.data;
        },
        /**
         * Gets or sets the value of the html element \
         *
         * @returns { void }Gets or sets the value of the html element\
         * @param {string | HTMLElement} value - provide the value value.
         *
         * @private
         */
        set: function (value) {
            this.data = value;
            if (!this.canReset) {
                this.canReset = true;
                if (!this.isTemplate) {
                    this.template = getContent(this, true);
                }
                this.canReset = false;
                this.isDirt = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    return DiagramHtmlElement;
}(DiagramElement));

var __extends$e = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Specifies the behavior of fixedUserHandles
 */
/** @private */
var FixedUserHandle = /** @class */ (function (_super) {
    __extends$e(FixedUserHandle, _super);
    function FixedUserHandle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$7([
        Property('')
    ], FixedUserHandle.prototype, "id", void 0);
    __decorate$7([
        Property('transparent')
    ], FixedUserHandle.prototype, "fill", void 0);
    __decorate$7([
        Property('black')
    ], FixedUserHandle.prototype, "iconStrokeColor", void 0);
    __decorate$7([
        Property(0)
    ], FixedUserHandle.prototype, "iconStrokeWidth", void 0);
    __decorate$7([
        Property(true)
    ], FixedUserHandle.prototype, "visibility", void 0);
    __decorate$7([
        Property(10)
    ], FixedUserHandle.prototype, "width", void 0);
    __decorate$7([
        Property(10)
    ], FixedUserHandle.prototype, "height", void 0);
    __decorate$7([
        Property('transparent')
    ], FixedUserHandle.prototype, "handleStrokeColor", void 0);
    __decorate$7([
        Property(1)
    ], FixedUserHandle.prototype, "handleStrokeWidth", void 0);
    __decorate$7([
        Property('')
    ], FixedUserHandle.prototype, "pathData", void 0);
    __decorate$7([
        Property(0)
    ], FixedUserHandle.prototype, "cornerRadius", void 0);
    __decorate$7([
        Complex({ left: 0, right: 0, top: 0, bottom: 0 }, Margin)
    ], FixedUserHandle.prototype, "padding", void 0);
    __decorate$7([
        Complex({}, DiagramTooltip)
    ], FixedUserHandle.prototype, "tooltip", void 0);
    return FixedUserHandle;
}(ChildProperty));
/**
 * Defines the node Fixed User Handle
 */
var NodeFixedUserHandle = /** @class */ (function (_super) {
    __extends$e(NodeFixedUserHandle, _super);
    function NodeFixedUserHandle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$7([
        Complex({ x: 0, y: 0 }, Point)
    ], NodeFixedUserHandle.prototype, "offset", void 0);
    __decorate$7([
        Complex({}, Margin)
    ], NodeFixedUserHandle.prototype, "margin", void 0);
    return NodeFixedUserHandle;
}(FixedUserHandle));
/**
 * Defines the connector Fixed User Handle
 */
var ConnectorFixedUserHandle = /** @class */ (function (_super) {
    __extends$e(ConnectorFixedUserHandle, _super);
    function ConnectorFixedUserHandle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$7([
        Property(0.5)
    ], ConnectorFixedUserHandle.prototype, "offset", void 0);
    __decorate$7([
        Property('Center')
    ], ConnectorFixedUserHandle.prototype, "alignment", void 0);
    __decorate$7([
        Complex({ x: 0, y: 0 }, Point)
    ], ConnectorFixedUserHandle.prototype, "displacement", void 0);
    return ConnectorFixedUserHandle;
}(FixedUserHandle));

/**
 * constraints-util module contains the common constraints \
 *
 * @returns { number }   constraints-util module contains the common constraints  .\
 *
 * @param {ConnectorModel | NodeModel | PathAnnotationModel | ShapeAnnotationModel} node - Provide the DiagramElement value.
 * @private
 */
function canSelect(node) {
    if (node) {
        var state = 0;
        if ((node instanceof ShapeAnnotation) || (node instanceof PathAnnotation)) {
            state = node.constraints & AnnotationConstraints.Select;
        }
        else if (node instanceof Connector) {
            state = node.constraints & ConnectorConstraints.Select;
        }
        else {
            state = node.constraints & NodeConstraints.Select;
        }
        return state;
    }
    return 1;
}
/**
 * Used to check whether we can move the objects ot not\
 *
 * @returns { number }   Used to check whether we can move the objects ot not  .\
 *
 * @param {ConnectorModel | NodeModel | PathAnnotationModel | ShapeAnnotationModel} node - Used to check whether we can move the objects ot not.
 * @private
 */
function canMove(node) {
    if (node) {
        var state = 0;
        if ((node instanceof ShapeAnnotation) || (node instanceof PathAnnotation)) {
            state = node.constraints & AnnotationConstraints.Drag;
        }
        else if (node instanceof Connector) {
            state = node.constraints & ConnectorConstraints.Drag;
        }
        else if (node instanceof Selector) {
            state = 1;
        }
        else {
            state = node.constraints & NodeConstraints.Drag;
        }
        return state;
    }
    return 1;
}
/**
 * Used to check the canEnablePointerEvents\
 *
 * @returns { number }   Used to check whether we can move the objects ot not  .\
 *
 * @param {ConnectorModel | NodeModel} node - Used to check whether we can move the objects ot not.
 * @param {Diagram} diagram - Used to check whether we can move the objects ot not.
 * @private
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function canEnablePointerEvents(node, diagram) {
    var state = 0;
    if (node instanceof Connector) {
        state = node.constraints & ConnectorConstraints.PointerEvents;
    }
    else {
        state = node.constraints & NodeConstraints.PointerEvents;
    }
    return state;
}
/**
 * Used to check the canDelete of the element \
 *
 * @returns { number }   Used to check the canDelete of the element   .\
 *
 * @param {ConnectorModel | NodeModel} node - Used to check whether we can move the objects ot not.
 * @private
 */
function canDelete(node) {
    var state = 0;
    if (node instanceof Connector) {
        state = node.constraints & ConnectorConstraints.Delete;
    }
    else {
        state = node.constraints & NodeConstraints.Delete;
    }
    return state;
}
/**
 * Used to check the bridging of the element \
 *
 * @returns { number }   Used to check the bridging of the element   .\
 *
 * @param {ConnectorModel | NodeModel} connector - provide the connector value.
 * @param {ConnectorModel | NodeModel} diagram - provide the diagram value.
 * @private
 */
function canBridge(connector, diagram) {
    var state = 0;
    if (connector.constraints & ConnectorConstraints.Bridging) {
        state = connector.constraints & ConnectorConstraints.Bridging;
    }
    else if (connector.constraints & ConnectorConstraints.InheritBridging) {
        state = diagram.constraints & DiagramConstraints.Bridging;
    }
    else {
        state = 0;
    }
    return state;
}
/**
 * Used to check the routing  of the element \
 *
 * @returns { number }   Used to check the routing  of the element .\
 *
 * @param {ConnectorModel | NodeModel} connector - provide the connector value.
 * @param {ConnectorModel | NodeModel} diagram - provide the diagram value.
 * @private
 */
function canEnableRouting(connector, diagram) {
    var state = 0;
    if (connector.constraints & ConnectorConstraints.LineRouting) {
        state = connector.constraints & ConnectorConstraints.LineRouting;
    }
    else if (connector.constraints & ConnectorConstraints.InheritLineRouting) {
        state = diagram.constraints & DiagramConstraints.LineRouting;
    }
    return state;
}
/**
 * Used to check the  source end dragof the element \
 *
 * @returns { number }   Used to check the  source end dragof the element. \
 *
 * @param {ConnectorModel | NodeModel} connector - provide the connector value.
 * @private
 */
function canDragSourceEnd(connector) {
    return connector.constraints & ConnectorConstraints.DragSourceEnd;
}
/**
 * Used to check the target end drag   of the element \
 *
 * @returns { number }   Used to check the target end drag   of the element .\
 *
 * @param {ConnectorModel | NodeModel} connector - provide the connector value.
 * @private
 */
function canDragTargetEnd(connector) {
    return connector.constraints & ConnectorConstraints.DragTargetEnd;
}
/**
 * Used to check the segment  drag   of the element \
 *
 * @returns { number }   Used to check the segment  drag   of the element .\
 *
 * @param {ConnectorModel | NodeModel} connector - provide the connector value.
 * @private
 */
function canDragSegmentThumb(connector) {
    return connector.constraints & ConnectorConstraints.DragSegmentThumb;
}
/**
 * Used to check the routing  drag   of the element \
 *
 * @returns { number }   Used to check the segment  drag   of the element .\
 *
 * @param {NodeModel | ShapeAnnotationModel | PathAnnotationModel} node - provide the connector value.
 * @private
 */
function canRotate(node) {
    if ((node instanceof ShapeAnnotation) || (node instanceof PathAnnotation)) {
        return node.constraints & AnnotationConstraints.Rotate;
    }
    else {
        return node.constraints & NodeConstraints.Rotate;
    }
}
/**
 * Used to check shadown constraints   of the element \
 *
 * @returns { number }   Used to check shadown constraints   of the element .\
 *
 * @param {NodeModel} node - provide the connector value.
 * @private
 */
function canShadow(node) {
    return node.constraints & NodeConstraints.Shadow;
}
/**
 * Used to check canInConnect constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {NodeModel} node - provide the node value.
 * @private
 */
function canInConnect(node) {
    if ((node instanceof Node) && (node.constraints & NodeConstraints.InConnect)) {
        return node.constraints & NodeConstraints.InConnect;
    }
    return 0;
}
/**
 * Used to check canPortInConnect constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {PointPortModel} port - provide the PointPortModel value.
 * @private
 */
function canPortInConnect(port) {
    if (port && port.constraints) {
        if (!(port.constraints & PortConstraints.None) && (port.constraints & PortConstraints.InConnect)) {
            return port.constraints & PortConstraints.InConnect;
        }
    }
    return 0;
}
/**
 * Used to check canOutConnect constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {NodeModel} node - provide the node value.
 * @private
 */
function canOutConnect(node) {
    if ((node instanceof Node) && (node.constraints & NodeConstraints.OutConnect)) {
        return node.constraints & NodeConstraints.OutConnect;
    }
    return 0;
}
/**
 * Used to check canPortOutConnect constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {PointPortModel} port - provide the node value.
 * @private
 */
function canPortOutConnect(port) {
    if (port && port.constraints) {
        if (!(port.constraints & PortConstraints.None) && (port.constraints & PortConstraints.OutConnect)) {
            return port.constraints & PortConstraints.OutConnect;
        }
    }
    return 0;
}
/**
 * Used to check canResize constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {NodeModel | ShapeAnnotationModel | PathAnnotationModel} node - provide the node value.
 * @param {NodeModel | ShapeAnnotationModel | PathAnnotationModel} direction - provide the node value.
 * @private
 */
function canResize(node, direction) {
    var returnValue = 0;
    if (node instanceof ShapeAnnotation || node instanceof PathAnnotation) {
        returnValue = node.constraints & AnnotationConstraints.Resize;
    }
    else if (node) {
        if (direction === 'SouthEast') {
            returnValue = node.constraints & NodeConstraints.ResizeSouthEast;
        }
        else if (direction === 'East') {
            returnValue = node.constraints & NodeConstraints.ResizeEast;
        }
        else if (direction === 'NorthEast') {
            returnValue = node.constraints & NodeConstraints.ResizeNorthEast;
        }
        else if (direction === 'South') {
            returnValue = node.constraints & NodeConstraints.ResizeSouth;
        }
        else if (direction === 'North') {
            returnValue = node.constraints & NodeConstraints.ResizeNorth;
        }
        else if (direction === 'SouthWest') {
            returnValue = node.constraints & NodeConstraints.ResizeSouthWest;
        }
        else if (direction === 'West') {
            returnValue = node.constraints & NodeConstraints.ResizeWest;
        }
        else if (direction === 'NorthWest') {
            returnValue = node.constraints & NodeConstraints.ResizeNorthWest;
        }
    }
    return returnValue;
}
/**
 * Used to check canAllowDrop constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {ConnectorModel | NodeModel} node - provide the node value.
 * @private
 */
function canAllowDrop(node) {
    var state = 0;
    if (node instanceof Connector) {
        state = node.constraints & ConnectorConstraints.AllowDrop;
    }
    else {
        state = node.constraints & NodeConstraints.AllowDrop;
    }
    return state;
}
/**
 * Used to check canVitualize constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} diagram - provide the Diagram value.
 * @private
 */
function canVitualize(diagram) {
    return diagram.constraints & DiagramConstraints.Virtualization;
}
/**
 * Used to check canEnableToolTip constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {ConnectorModel | NodeModel} node - provide the node value.
 * @param {Diagram} diagram - provide the Diagram value.
 * @private
 */
function canEnableToolTip(node, diagram) {
    var state = 0;
    if (node instanceof Connector) {
        if (node.constraints & ConnectorConstraints.Tooltip) {
            state = node.constraints & ConnectorConstraints.Tooltip;
        }
        else if (node.constraints & ConnectorConstraints.InheritTooltip) {
            state = diagram.constraints & DiagramConstraints.Tooltip;
        }
    }
    else if (node instanceof PointPort || node instanceof PathPort) {
        if (node.constraints & PortConstraints.ToolTip) {
            state = node.constraints & PortConstraints.ToolTip;
        }
        else if (node.constraints & PortConstraints.InheritTooltip) {
            state = diagram.constraints & DiagramConstraints.Tooltip;
        }
    }
    else if (node instanceof ShapeAnnotation || node instanceof PathAnnotation) {
        if (node.constraints & AnnotationConstraints.Tooltip) {
            state = node.constraints & AnnotationConstraints.Tooltip;
        }
    }
    else {
        if (node.constraints & NodeConstraints.Tooltip) {
            state = node.constraints & NodeConstraints.Tooltip;
        }
        else if (node.constraints & NodeConstraints.InheritTooltip) {
            state = diagram.constraints & DiagramConstraints.Tooltip;
        }
    }
    return state;
}
/**
 * Used to check canSingleSelect constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} model - provide the Diagram value.
 * @private
 */
function canSingleSelect(model) {
    return model.tool & DiagramTools.SingleSelect;
}
/**
 * Used to check canMultiSelect constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} model - provide the Diagram value.
 * @private
 */
function canMultiSelect(model) {
    return model.tool & DiagramTools.MultipleSelect;
}
/**
 * Used to check canZoomPan constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} model - provide the Diagram value.
 * @private
 */
function canZoomPan(model) {
    return model.tool & DiagramTools.ZoomPan;
}
/**
 * Used to check canContinuousDraw constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} model - provide the Diagram value.
 * @private
 */
function canContinuousDraw(model) {
    return model.tool & DiagramTools.ContinuousDraw;
}
/**
 * Used to check canDrawOnce constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} model - provide the Diagram value.
 * @private
 */
function canDrawOnce(model) {
    return model.tool & DiagramTools.DrawOnce;
}
/**
 * Used to check defaultTool constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} model - provide the Diagram value.
 * @private
 */
function defaultTool(model) {
    return (model.tool & DiagramTools.SingleSelect) || (model.tool & DiagramTools.MultipleSelect);
}
/**
 * Used to check canZoom constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} model - provide the Diagram value.
 * @private
 */
function canZoom(model) {
    return model.constraints & DiagramConstraints.Zoom;
}
/**
 * Used to check canPan constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} model - provide the Diagram value.
 * @private
 */
function canPan(model) {
    return model.constraints & DiagramConstraints.Pan;
}
/**
 * Used to check canUserInteract constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} model - provide the Diagram value.
 * @private
 */
function canUserInteract(model) {
    return model.constraints & DiagramConstraints.UserInteraction;
}
/**
 * Used to check canApiInteract constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} model - provide the Diagram value.
 * @private
 */
function canApiInteract(model) {
    return model.constraints & DiagramConstraints.ApiUpdate;
}
/**
 * Used to check canPanX constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} model - provide the Diagram value.
 * @private
 */
function canPanX(model) {
    return ((model.constraints & DiagramConstraints.PanX));
}
/**
 * Used to check canPanY constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} model - provide the Diagram value.
 * @private
 */
function canPanY(model) {
    return ((model.constraints & DiagramConstraints.PanY));
}
/**
 * Used to check canZoomTextEdit constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} diagram - provide the Diagram value.
 * @private
 */
function canZoomTextEdit(diagram) {
    return ((diagram.constraints & DiagramConstraints.ZoomTextEdit));
}
/**
 * Used to check canPageEditable constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} model - provide the Diagram value.
 * @private
 */
function canPageEditable(model) {
    return canApiInteract(model) || (model.diagramActions & DiagramAction.ToolAction);
}
/**
 * Used to check enableReadOnly constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {Diagram} annotation - provide the annotation value.
 * @param {Diagram} node - provide the node value.
 * @private
 */
function enableReadOnly(annotation, node) {
    var enumValue = 0;
    enumValue = (node instanceof Connector) ? ConnectorConstraints.ReadOnly : NodeConstraints.ReadOnly;
    if (node.shape.type === 'Text') {
        return node.constraints & NodeConstraints.ReadOnly;
    }
    else if (node.constraints & enumValue) {
        if (annotation.constraints & AnnotationConstraints.InheritReadOnly) {
            return 1;
        }
        else {
            return 0;
        }
    }
    else if (annotation.constraints & AnnotationConstraints.ReadOnly) {
        return 1;
    }
    return 0;
}
/**
 * Used to check canDraw constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {PointPortModel | NodeModel} port - provide the Diagram value.
 * @param {Diagram} diagram - provide the Diagram value.
 * @private
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function canDraw(port, diagram) {
    return port.constraints & PortConstraints.Draw;
}
/**
 * Used to check canDrag constraints   of the element \
 *
 * @returns { number }   Used to check canInConnect constraints   of the element .\
 *
 * @param {PointPortModel | NodeModel} port - provide the Diagram value.
 * @param {Diagram} diagram - provide the Diagram value.
 * @private
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function canDrag(port, diagram) {
    return port.constraints & PortConstraints.Drag;
}
/**
 * Used to check canPreventClearSelection constraints   of the element \
 *
 * @returns { boolean }   Used to check canInConnect constraints   of the element .\
 *
 * @param {PointPortModel | NodeModel} diagramActions - provide the diagramActions value.
 * @private
 */
function canPreventClearSelection(diagramActions) {
    if (diagramActions & DiagramAction.PreventClearSelection) {
        return true;
    }
    else {
        return false;
    }
}
/**
 * Used to check canDrawThumbs \
 *
 * @returns { boolean }   Used to check canInConnect constraints   of the element .\
 *
 * @param {RendererAction} rendererActions - provide the RendererAction value.
 * @private
 */
function canDrawThumbs(rendererActions) {
    if (!(rendererActions & RendererAction.DrawSelectorBorder)) {
        return true;
    }
    else {
        return false;
    }
}
/**
 * Used to check avoidDrawSelector \
 *
 * @returns { boolean }   Used to check canInConnect constraints   of the element .\
 *
 * @param {RendererAction} rendererActions - provide the RendererAction value.
 * @private
 */
function avoidDrawSelector(rendererActions) {
    if ((rendererActions & RendererAction.PreventRenderSelector)) {
        return true;
    }
    else {
        return false;
    }
}

var __extends$f = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Grid panel is used to arrange the children in a table like structure
 */
var GridPanel = /** @class */ (function (_super) {
    __extends$f(GridPanel, _super);
    function GridPanel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.childTable = [];
        _this.cellStyle = {};
        _this.desiredRowHeight = [];
        _this.desiredCellWidth = [];
        return _this;
    }
    /**
     * rowDefinitions method \
     *
     * @returns { RowDefinition[] } columnDefinitions method .\
     *
     * @private
     */
    GridPanel.prototype.rowDefinitions = function () {
        return this.rowDefns;
    };
    /**
     * columnDefinitions method \
     *
     * @returns { ColumnDefinition[] } columnDefinitions method .\
     *
     * @private
     */
    GridPanel.prototype.columnDefinitions = function () {
        return this.colDefns;
    };
    GridPanel.prototype.addObject = function (obj, rowId, columnId, rowSpan, columnSpan) {
        //check if exists
        if (this.rows.length >= rowId) {
            var row = this.rows[parseInt(rowId.toString(), 10)];
            if (row.cells.length > columnId) {
                columnSpan = columnSpan || 1;
                rowSpan = rowSpan || 1;
                var cell = row.cells[parseInt(columnId.toString(), 10)];
                cell.columnSpan = Math.max(columnSpan, cell.columnSpan);
                cell.rowSpan = Math.max(rowSpan, cell.rowSpan);
                var object = new GridCellItem();
                object = obj;
                object.rowId = rowId;
                object.columnId = columnId;
                object.columnSpan = columnSpan;
                this.childTable[object.id] = object;
                this.addObjectToCell(object, cell);
            }
        }
    };
    // public setCellStyle(rowId: number, columnId: number, cellStyle: ShapeStyleModel): void {
    //     if (this.rows.length > rowId) {
    //         let row: GridRow = this.rows[rowId];
    //         if (row.cells.length > columnId) {
    //             let cell: GridCell = row.cells[columnId];
    //             cell.style = cellStyle;
    //         }
    //     }
    // }
    // public getRowId(obj: DiagramElement): number {
    //     return (this.childTable[obj.id] as GridCellItem).rowId;
    // }
    // public getColumnId(obj: DiagramElement): number {
    //     return (this.childTable[obj.id] as GridCellItem).columnId;
    // }
    // public getRowSpan(obj: DiagramElement): number {
    //     return (this.childTable[obj.id] as GridCellItem).rowSpan;
    // }
    // public getColumnSpan(obj: DiagramElement): number {
    //     return (this.childTable[obj.id] as GridCellItem).columnSpan;
    // }
    GridPanel.prototype.addObjectToCell = function (obj, cell) {
        if (!cell.children) {
            cell.children = [];
        }
        // obj.minWidth = cell.desiredCellWidth; obj.minHeight = cell.desiredCellHeight;
        obj.style.strokeColor = 'black';
        obj.style.strokeWidth = 1;
        //Bug 853721: Grid lines remain hidden when lane fill is set to transparent.
        // Removed below code in which the fill set as white.
        // obj.style.fill = 'white';
        cell.children.push(obj);
    };
    /**
     * updateProperties method \
     *
     * @returns { void } updateProperties method .\
     * @param {number} offsetX - provide the Connector value.
     * @param {number} offsetY - provide the Connector value.
     * @param {number} width - provide the Connector value.
     * @param {number} height - provide the Connector value.
     *
     * @private
     */
    GridPanel.prototype.updateProperties = function (offsetX, offsetY, width, height) {
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.width = width;
        this.height = height;
    };
    /**
     * setDefinitions method \
     *
     * @returns { void } setDefinitions method .\
     * @param {RowDefinition[]} rows - provide the rows value.
     * @param {ColumnDefinition[]} columns - provide the Connector value.
     *
     * @private
     */
    GridPanel.prototype.setDefinitions = function (rows, columns) {
        this.rowDefns = rows;
        this.colDefns = columns;
        this.children = [];
        this.rows = this.rows || [];
        for (var i = 0; i < rows.length; i++) {
            var rowDefn = rows[parseInt(i.toString(), 10)];
            var row = new GridRow();
            row.cells = [];
            var defaultCell = new ColumnDefinition();
            //replace this 100 with a proper property
            defaultCell.width = this.width;
            var columns_1 = this.colDefns;
            if (columns_1 === undefined || columns_1.length < 1) {
                columns_1 = [defaultCell];
            }
            this.addCellInRow(columns_1, rowDefn, row);
            this.rows.push(row);
        }
    };
    /**
     * addCellInRow method \
     *
     * @returns { void } addCellInRow method .\
     * @param {ColumnDefinition[]} columns - provide the rows value.
     * @param {RowDefinition} rowDefn - provide the Connector value.
     * @param {GridRow} row - provide the Connector value.
     *
     * @private
     */
    GridPanel.prototype.addCellInRow = function (columns, rowDefn, row) {
        for (var j = 0; j < columns.length; j++) {
            var colDefn = columns[parseInt(j.toString(), 10)];
            var cell = new GridCell();
            cell.children = [];
            this.cellStyle.fill = 'none';
            this.cellStyle.strokeColor = 'none';
            cell.id = randomId();
            cell.style = this.cellStyle;
            cell.desiredCellWidth = cell.minWidth = colDefn.width;
            cell.desiredCellHeight = cell.minHeight = rowDefn.height;
            row.cells.push(cell);
            this.children.push(cell);
        }
    };
    /**
     * calculateSize method \
     *
     * @returns { void } calculateSize method .\
     *
     * @private
     */
    GridPanel.prototype.calculateSize = function () {
        var rows = this.rows || [];
        var calculateHeight = 0;
        var calculateWidth = 0;
        for (var i = 0; i < rows.length; i++) {
            var row = this.rows[parseInt(i.toString(), 10)];
            calculateWidth = 0;
            for (var j = 0; j < row.cells.length; j++) {
                calculateWidth += row.cells[parseInt(j.toString(), 10)].desiredCellWidth;
                if (j === row.cells.length - 1) {
                    if (this.width && this.width !== calculateWidth) {
                        row.cells[parseInt(j.toString(), 10)].desiredCellWidth += (this.width - calculateWidth);
                        row.cells[parseInt(j.toString(), 10)].minWidth = row.cells[parseInt(j.toString(), 10)].desiredCellWidth;
                        if (row.cells[parseInt(j.toString(), 10)].children && row.cells[parseInt(j.toString(), 10)].children.length) {
                            row.cells[parseInt(j.toString(), 10)].children[0].width =
                                row.cells[parseInt(j.toString(), 10)].desiredCellWidth;
                        }
                        this.colDefns[parseInt(j.toString(), 10)].width = row.cells[parseInt(j.toString(), 10)].desiredCellWidth;
                    }
                    calculateHeight += row.cells[parseInt(j.toString(), 10)].desiredCellHeight;
                    if (i === rows.length - 1) {
                        if (this.height && this.height !== calculateHeight) {
                            var height = (this.height - calculateHeight);
                            if (height > 0) {
                                for (var k = 0; k < row.cells.length; k++) {
                                    row.cells[parseInt(k.toString(), 10)].desiredCellHeight += height;
                                    row.cells[parseInt(k.toString(), 10)].minHeight =
                                        row.cells[parseInt(k.toString(), 10)].desiredCellHeight =
                                            row.cells[parseInt(k.toString(), 10)].desiredCellHeight;
                                    if (row.cells[parseInt(k.toString(), 10)].children
                                        && row.cells[parseInt(k.toString(), 10)].children.length) {
                                        row.cells[parseInt(k.toString(), 10)].children[0].height =
                                            row.cells[parseInt(k.toString(), 10)].desiredCellHeight;
                                    }
                                }
                                this.rowDefns[parseInt(i.toString(), 10)].height += height;
                            }
                        }
                    }
                }
            }
        }
    };
    /**
     * updateRowHeight method \
     *
     * @returns { void } updateRowHeight method .\
     * @param {number} rowId - provide the rows value.
     * @param {number} height - provide the Connector value.
     * @param {boolean} isConsiderChild - provide the Connector value.
     * @param {number} padding - provide the Connector value.
     * @param {boolean} isUndoRedo - Provide if its undo-redo action or not
     * @private
     */
    GridPanel.prototype.updateRowHeight = function (rowId, height, isConsiderChild, padding, isUndoRedo) {
        var row = this.rows[parseInt(rowId.toString(), 10)];
        this.rowDefns[parseInt(rowId.toString(), 10)].height = height;
        if (this.height !== undefined) {
            this.height += height - row.cells[0].desiredCellHeight;
        }
        for (var i = 0; i < row.cells.length; i++) {
            row.cells[parseInt(i.toString(), 10)].desiredCellHeight = row.cells[parseInt(i.toString(), 10)].minHeight = height;
            if (row.cells[parseInt(i.toString(), 10)].children && row.cells[parseInt(i.toString(), 10)].children.length) {
                row.cells[parseInt(i.toString(), 10)].children[0].height = height;
                this.setTextRefresh(row.cells[parseInt(i.toString(), 10)].children[0]);
            }
        }
        this.desiredRowHeight[parseInt(rowId.toString(), 10)] = height;
        this.measure(new Size(this.width, this.height));
        this.arrange(this.desiredSize);
        if (isConsiderChild) {
            var minHeight = (padding !== undefined) ? this.calculateCellHeightBasedOnChildren(rowId, padding) :
                this.calculateCellHeight(rowId);
            if (minHeight > height && !isUndoRedo) {
                this.updateRowHeight(rowId, minHeight, false);
            }
        }
    };
    GridPanel.prototype.setTextRefresh = function (canvas) {
        if (canvas.children && canvas.children.length) {
            // eslint-disable-next-line @typescript-eslint/ban-types
            var children = canvas.children;
            for (var i = 0; i < children.length; i++) {
                if (children[parseInt(i.toString(), 10)] instanceof TextElement) {
                    children[parseInt(i.toString(), 10)].refreshTextElement();
                }
                if (children[parseInt(i.toString(), 10)] instanceof Canvas) {
                    this.setTextRefresh(children[parseInt(i.toString(), 10)]);
                }
            }
        }
    };
    /**
     * updateColumnWidth method \
     *
     * @returns { void } updateColumnWidth method .\
     * @param {number} colId - provide the rows value.
     * @param {number} width - provide the Connector value.
     * @param {boolean} isConsiderChild - provide the Connector value.
     * @param {number} padding - provide the Connector value.
     * @param {boolean} isUndoRedo - Provide if its undo-redo action or not
     *
     * @private
     */
    GridPanel.prototype.updateColumnWidth = function (colId, width, isConsiderChild, padding, isUndoRedo) {
        this.colDefns[parseInt(colId.toString(), 10)].width = width;
        if (this.width !== undefined) {
            this.width += width - this.rows[this.rows.length - 1].cells[parseInt(colId.toString(), 10)].desiredCellWidth;
        }
        for (var i = 0; i < this.rows.length; i++) {
            this.setTextRefresh(this.rows[parseInt(i.toString(), 10)].cells[0]);
            this.rows[parseInt(i.toString(), 10)].cells[parseInt(colId.toString(), 10)].desiredCellWidth =
                this.rows[parseInt(i.toString(), 10)].cells[parseInt(colId.toString(), 10)].minWidth = width;
            if (this.rows[parseInt(i.toString(), 10)].cells[parseInt(colId.toString(), 10)].children
                && this.rows[parseInt(i.toString(), 10)].cells[parseInt(colId.toString(), 10)].children.length) {
                this.rows[parseInt(i.toString(), 10)].cells[parseInt(colId.toString(), 10)].children[0].width = width;
            }
        }
        this.desiredCellWidth[parseInt(colId.toString(), 10)] = width;
        this.measure(new Size(this.width, this.height));
        this.arrange(this.desiredSize);
        if (isConsiderChild) {
            var minWidth = (padding !== undefined) ? this.calculateCellWidthBasedOnChildren(colId, padding) :
                this.calculateCellWidth(colId);
            if (minWidth > width && !isUndoRedo) {
                this.updateColumnWidth(colId, minWidth, false);
            }
        }
    };
    GridPanel.prototype.calculateCellWidth = function (colIndex) {
        var maxWidth;
        var width;
        var cell;
        for (var i = 0; i < this.rows.length; i++) {
            cell = this.rows[parseInt(i.toString(), 10)].cells[parseInt(colIndex.toString(), 10)];
            if (cell.columnSpan === 1) {
                width = (cell.outerBounds.width > cell.bounds.width &&
                    (cell.children.length === 0 || cell.children[0].maxWidth === undefined)) ? cell.outerBounds.width : cell.bounds.width;
                if (maxWidth) {
                    maxWidth = (maxWidth < width) ? width : maxWidth;
                }
                else {
                    maxWidth = width;
                }
            }
        }
        return maxWidth;
    };
    GridPanel.prototype.calculateCellHeight = function (rowIndex) {
        var maxHeight;
        var height;
        var cell;
        var row = this.rows[parseInt(rowIndex.toString(), 10)];
        for (var i = 0; i < row.cells.length; i++) {
            cell = row.cells[parseInt(i.toString(), 10)];
            height = (cell.outerBounds.height > cell.bounds.height) ? cell.outerBounds.height : cell.bounds.height;
            if (maxHeight) {
                maxHeight = (maxHeight < height) ? height : maxHeight;
            }
            else {
                maxHeight = height;
            }
        }
        return maxHeight;
    };
    GridPanel.prototype.calculateCellSizeBasedOnChildren = function (cell, option, padding, maxSize) {
        var maxBounds;
        var canvas = (cell && cell.children.length > 0) ? cell.children[0] : undefined;
        if (canvas && cell.columnSpan === 1) {
            maxBounds = (option === 'Width') ? canvas.bounds.right : canvas.bounds.bottom;
            if (!maxSize) {
                maxSize = (option === 'Width') ? canvas.bounds.width : canvas.bounds.height;
            }
            for (var j = 0; j < canvas.children.length; j++) {
                var children = canvas.children[parseInt(j.toString(), 10)];
                if (children instanceof Canvas) {
                    if (children.id.indexOf('header') === -1) {
                        var bounds = ((option === 'Width') ? children.bounds.right : children.bounds.bottom) + padding;
                        if (bounds > maxBounds) {
                            var size = (bounds - maxBounds) + ((option === 'Width') ? canvas.bounds.width : canvas.bounds.height);
                            if (maxSize) {
                                maxSize = (maxSize < size) ? size : maxSize;
                            }
                        }
                    }
                }
            }
        }
        return maxSize;
    };
    GridPanel.prototype.calculateCellWidthBasedOnChildren = function (colIndex, padding) {
        var maxWidth; //let width: number;  let maxBounds: number; let canvas: Canvas;
        var cell;
        for (var i = 0; i < this.rows.length; i++) {
            cell = this.rows[parseInt(i.toString(), 10)].cells[parseInt(colIndex.toString(), 10)];
            maxWidth = this.calculateCellSizeBasedOnChildren(cell, 'Width', padding, maxWidth);
        }
        return maxWidth;
    };
    GridPanel.prototype.calculateCellHeightBasedOnChildren = function (rowIndex, padding) {
        var maxHeight;
        var cell;
        // let maxBounds: number; let canvas: Canvas;
        var row = this.rows[parseInt(rowIndex.toString(), 10)];
        for (var i = 0; i < row.cells.length; i++) {
            cell = row.cells[parseInt(i.toString(), 10)];
            maxHeight = this.calculateCellSizeBasedOnChildren(cell, 'Height', padding, maxHeight);
        }
        return maxHeight;
    };
    /**
     * addRow method \
     *
     * @returns { void } addRow method .\
     * @param {number} rowId - provide the rowId value.
     * @param {number} rowDefn - provide the rowDefn value.
     * @param {boolean} isMeasure - provide the isMeasure value.
     *
     * @private
     */
    GridPanel.prototype.addRow = function (rowId, rowDefn, isMeasure) {
        if (this.rowDefns.length > 0) {
            this.rowDefns.splice(rowId, 0, rowDefn);
        }
        else {
            this.rowDefns.push(rowDefn);
        }
        var row = new GridRow();
        row.cells = [];
        var defaultCell = new ColumnDefinition();
        defaultCell.width = this.width;
        var columns = this.colDefns;
        this.addCellInRow(columns, rowDefn, row);
        if (rowId > this.rows.length - 1) {
            this.rows.push(row);
        }
        else {
            this.rows.splice(rowId, 0, row);
        }
        if (isMeasure) {
            this.measure(new Size(this.width, this.height));
            this.arrange(this.desiredSize);
        }
    };
    /**
     * addColumn method \
     *
     * @returns { void } addColumn method .\
     * @param {number} columnId - provide the rowId value.
     * @param {number} column - provide the rowDefn value.
     * @param {boolean} isMeasure - provide the isMeasure value.
     *
     * @private
     */
    GridPanel.prototype.addColumn = function (columnId, column, isMeasure) {
        var row;
        var rowDefn;
        var colDefn;
        var cell;
        var rows = this.rows;
        if (this.colDefns.length > 0) {
            this.colDefns.splice(columnId, 0, column);
        }
        else {
            this.colDefns.push(column);
        }
        if (this.width !== undefined) {
            this.width += column.width;
        }
        for (var i = 0; i < rows.length; i++) {
            row = rows[parseInt(i.toString(), 10)];
            rowDefn = this.rowDefns[parseInt(i.toString(), 10)];
            colDefn = column;
            cell = new GridCell();
            cell.style = this.cellStyle;
            cell.desiredCellWidth = cell.minWidth = colDefn.width;
            cell.desiredCellHeight = cell.minHeight = rowDefn.height;
            cell.children = [];
            if (columnId > row.cells.length - 1) {
                row.cells.push(cell);
            }
            else {
                row.cells.splice(columnId, 0, cell);
            }
            this.children.push(cell);
        }
        if (isMeasure) {
            this.measure(new Size(this.width, this.height));
            this.arrange(this.desiredSize);
        }
    };
    /**
     * removeRow method \
     *
     * @returns { void } removeRow method .\
     * @param {number} rowId - provide the rowId value.
     *
     * @private
     */
    GridPanel.prototype.removeRow = function (rowId) {
        var cell;
        var element;
        var rows = this.rows;
        var removeRow = rows[parseInt(rowId.toString(), 10)];
        this.height -= this.rowDefns[parseInt(rowId.toString(), 10)].height;
        for (var i = 0; i < removeRow.cells.length; i++) {
            cell = removeRow.cells[parseInt(i.toString(), 10)];
            this.children.splice(this.children.indexOf(cell), 1);
            element = document.getElementById(cell.id + '_groupElement');
            if (element && element.parentElement) {
                element.parentElement.removeChild(element);
            }
        }
        this.rows.splice(rowId, 1);
        this.rowDefns.splice(rowId, 1);
        this.measure(new Size(this.width, this.height));
        this.arrange(this.desiredSize);
    };
    /**
     * removeColumn method \
     *
     * @returns { void } removeColumn method .\
     * @param {number} columnId - provide the rowId value.
     *
     * @private
     */
    GridPanel.prototype.removeColumn = function (columnId) {
        var cell;
        var element;
        var rows = this.rows;
        this.width -= this.colDefns[parseInt(columnId.toString(), 10)].width;
        for (var i = 0; i < rows.length; i++) {
            cell = rows[parseInt(i.toString(), 10)].cells[parseInt(columnId.toString(), 10)];
            this.children.splice(this.children.indexOf(cell), 1);
            element = document.getElementById(cell.id + '_groupElement');
            if (element && element.parentElement) {
                element.parentElement.removeChild(element);
            }
            rows[parseInt(i.toString(), 10)].cells.splice(columnId, 1);
        }
        this.colDefns.splice(columnId, 1);
        this.measure(new Size(this.width, this.height));
        this.arrange(this.desiredSize);
    };
    /**
     * updateRowIndex method \
     *
     * @returns { void } updateRowIndex method .\
     * @param {number} currentIndex - provide the rowId value.
     * @param {number} newIndex - provide the rowId value.
     *
     * @private
     */
    GridPanel.prototype.updateRowIndex = function (currentIndex, newIndex) {
        //const rows: GridRow[] = this.rows;
        var temp = this.rows[parseInt(currentIndex.toString(), 10)];
        this.rows.splice(currentIndex, 1);
        this.rows.splice(newIndex, 0, temp);
        var tempRow = this.rowDefns[parseInt(currentIndex.toString(), 10)];
        this.rowDefns.splice(currentIndex, 1);
        this.rowDefns.splice(newIndex, 0, tempRow);
        this.measure(new Size(this.width, this.height));
        this.arrange(this.desiredSize);
    };
    /**
     * updateColumnIndex method \
     *
     * @returns { void } updateColumnIndex method .\
     * @param {number} startRowIndex - provide the startRowIndex value.
     * @param {number} currentIndex - provide the currentIndex value.
     * @param {number} newIndex - provide the newIndex value.
     *
     * @private
     */
    GridPanel.prototype.updateColumnIndex = function (startRowIndex, currentIndex, newIndex) {
        var temp;
        var cell;
        for (var i = startRowIndex; i < this.rows.length; i++) {
            temp = this.rows[parseInt(i.toString(), 10)];
            cell = this.rows[parseInt(i.toString(), 10)].cells[parseInt(currentIndex.toString(), 10)];
            temp.cells.splice(currentIndex, 1);
            temp.cells.splice(newIndex, 0, cell);
        }
        var tempCol = this.colDefns[parseInt(currentIndex.toString(), 10)];
        this.colDefns.splice(currentIndex, 1);
        this.colDefns.splice(newIndex, 0, tempCol);
        var tempSize = this.desiredCellWidth[parseInt(currentIndex.toString(), 10)];
        this.desiredCellWidth.splice(currentIndex, 1);
        this.desiredCellWidth.splice(newIndex, 0, tempSize);
        this.measure(new Size(this.width, this.height));
        this.arrange(this.desiredSize);
    };
    /**
     * measure method \
     *
     * @returns { Size } measure method .\
     * @param {Size} availableSize - provide the startRowIndex value.
     *
     * @private
     */
    GridPanel.prototype.measure = function (availableSize) {
        var desired = undefined;
        if (this.rows !== undefined && this.rows.length > 0) {
            var i = 0;
            var j = 0;
            desired = new Size(0, 0);
            this.calculateSize();
            for (var _i = 0, _a = this.rows; _i < _a.length; _i++) {
                var row = _a[_i];
                j = 0;
                for (var _b = 0, _c = row.cells; _b < _c.length; _b++) {
                    var cell = _c[_b];
                    var size = cell.measure(new Size(cell.desiredCellWidth, cell.desiredCellHeight));
                    if (cell.rowSpan === 1) {
                        if (j === 0 || this.desiredRowHeight[parseInt(i.toString(), 10)] === undefined) {
                            this.desiredRowHeight[parseInt(i.toString(), 10)] = size.height;
                        }
                        else {
                            this.desiredRowHeight[parseInt(i.toString(), 10)] =
                                Math.max(size.height, this.desiredRowHeight[parseInt(i.toString(), 10)]);
                        }
                    }
                    if (cell.columnSpan === 1) {
                        if (i === 0 || this.desiredCellWidth[parseInt(j.toString(), 10)] === undefined) {
                            this.desiredCellWidth[parseInt(j.toString(), 10)] = size.width;
                        }
                        else {
                            this.desiredCellWidth[parseInt(j.toString(), 10)] =
                                Math.max(size.width, this.desiredCellWidth[parseInt(j.toString(), 10)]);
                        }
                        if (i === this.rows.length - 1) {
                            desired.width += this.desiredCellWidth[parseInt(j.toString(), 10)];
                        }
                    }
                    j++;
                }
                desired.height += this.desiredRowHeight[parseInt(i.toString(), 10)];
                i++;
            }
            //to-do update definitions
            i = j = 0;
            var rowIndex = 0;
            for (var _d = 0, _e = this.rows; _d < _e.length; _d++) {
                var row = _e[_d];
                j = 0;
                var cellIndex = 0;
                for (var _f = 0, _g = row.cells; _f < _g.length; _f++) {
                    var cell = _g[_f];
                    if (cell.columnSpan !== 1) {
                        cell.desiredSize.width = 0;
                        for (var start = 0; start < cell.columnSpan; start++) {
                            if ((start + j) < row.cells.length) {
                                cell.desiredSize.width += this.desiredCellWidth[start + j];
                                cell.minWidth = cell.desiredSize.width;
                                cell.measure(cell.desiredSize);
                            }
                        }
                        j++;
                    }
                    else {
                        cell.desiredSize.width = this.desiredCellWidth[parseInt(cellIndex.toString(), 10)];
                        cell.measure(cell.desiredSize);
                    }
                    if (cell.rowSpan !== 1) {
                        cell.desiredSize.height = 0;
                        for (var start = 0; start < cell.rowSpan; start++) {
                            if ((start + rowIndex) < this.rows.length) {
                                cell.desiredSize.height += this.desiredRowHeight[start + rowIndex];
                                cell.minHeight = cell.desiredSize.height;
                                cell.measure(cell.desiredSize);
                            }
                        }
                    }
                    else {
                        cell.desiredSize.height = this.desiredRowHeight[parseInt(rowIndex.toString(), 10)];
                        cell.measure(cell.desiredSize);
                    }
                    i++;
                    cellIndex++;
                }
                rowIndex++;
            }
        }
        if (desired === undefined) {
            desired = _super.prototype.validateDesiredSize.call(this, desired, availableSize);
        }
        _super.prototype.stretchChildren.call(this, desired);
        this.desiredSize = desired;
        return desired;
    };
    /**
     * arrange method \
     *
     * @returns { Size } arrange method .\
     * @param {Size} desiredSize - provide the startRowIndex value.
     * @param {boolean} isChange - provide the startRowIndex value.
     *
     * @private
     */
    GridPanel.prototype.arrange = function (desiredSize, isChange) {
        var j = 0;
        var i = 0;
        if (this.rows !== undefined && this.rows.length > 0) {
            var x = this.offsetX - desiredSize.width * this.pivot.x;
            var y = this.offsetY - desiredSize.height * this.pivot.y;
            var cellX = x;
            for (var _i = 0, _a = this.rows; _i < _a.length; _i++) {
                var row = _a[_i];
                cellX = x;
                j = 0;
                for (var _b = 0, _c = row.cells; _b < _c.length; _b++) {
                    var cell = _c[_b];
                    var cellWidth = Math.max(this.desiredCellWidth[parseInt(j.toString(), 10)], cell.desiredSize.width);
                    var cellHeight = Math.max(this.desiredRowHeight[parseInt(i.toString(), 10)], cell.desiredSize.height);
                    cell.offsetX = cellX + cellWidth * cell.pivot.x;
                    cell.offsetY = y + cellHeight * cell.pivot.y;
                    cellX += this.desiredCellWidth[parseInt(j.toString(), 10)];
                    cell.arrange(new Size(cellWidth, cellHeight));
                    j++;
                }
                y += this.desiredRowHeight[parseInt(i.toString(), 10)];
                i++;
            }
            if (isChange) {
                // Need to remove the unwanted the child elements in the grid
                // Used for row span and column span.
                var cell = void 0;
                var row = void 0;
                var k = void 0;
                var z = void 0;
                var removeCell = void 0;
                for (i = 0; i < this.rows.length; i++) {
                    row = this.rows[parseInt(i.toString(), 10)];
                    for (j = 0; j < row.cells.length; j++) {
                        cell = row.cells[parseInt(j.toString(), 10)];
                        if (cell.columnSpan > 1) {
                            // remove a child element when a column span is greater than 1
                            this.children.splice((this.children.indexOf(cell)) + 1, cell.columnSpan - 1);
                        }
                        if (cell.rowSpan > 1) {
                            for (k = i, z = 0; ((k + cell.rowSpan - 1) < this.rows.length && z < cell.rowSpan - 1); k++, z++) {
                                removeCell = this.rows[k + 1].cells[parseInt(j.toString(), 10)];
                                // remove a child element when a row span is greater than 1
                                this.children.splice(this.children.indexOf(removeCell), 1);
                            }
                        }
                    }
                }
            }
        }
        this.actualSize = desiredSize;
        this.updateBounds();
        return desiredSize;
    };
    return GridPanel;
}(Container));
/**
 * Defines the behavior of the RowDefinition of node
 */
var RowDefinition = /** @class */ (function () {
    function RowDefinition() {
        /** returns the height of node */
        this.height = undefined;
    }
    return RowDefinition;
}());
/**
 * Defines the behavior of the ColumnDefinition of node
 */
var ColumnDefinition = /** @class */ (function () {
    function ColumnDefinition() {
        /** returns the width of node */
        this.width = undefined;
    }
    return ColumnDefinition;
}());
/** @private */
var GridRow = /** @class */ (function () {
    function GridRow() {
        this.cells = null;
    }
    return GridRow;
}());
/** @private */
var GridCell = /** @class */ (function (_super) {
    __extends$f(GridCell, _super);
    function GridCell() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.columnSpan = 1;
        _this.rowSpan = 1;
        return _this;
    }
    return GridCell;
}(Canvas));
var GridCellItem = /** @class */ (function (_super) {
    __extends$f(GridCellItem, _super);
    function GridCellItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.rowId = 0;
        _this.columnId = 0;
        _this.rowSpan = 1;
        _this.columnSpan = 1;
        return _this;
    }
    return GridCellItem;
}(DiagramElement));

/**
 * SwimLane modules are used to rendering and interaction.
 */
/** @private */
/**
 * initSwimLane method \
 *
 * @returns {void} initSwimLane method .\
 * @param { GridPanel} grid - provide the grid  value.
 * @param { Diagram} diagram - provide the diagram  value.
 * @param {NodeModel} node - provide the node  value.
 * @private
 */
function initSwimLane(grid, diagram, node) {
    if (!node.width && node.shape.phases.length === 0) {
        node.width = 100;
    }
    var row = [];
    var columns = [];
    var index = 0;
    var shape = node.shape;
    var orientation = shape.orientation === 'Horizontal' ? true : false;
    if (shape.header && shape.hasHeader) {
        createRow(row, shape.header.height);
    }
    initGridRow(row, orientation, node);
    initGridColumns(columns, orientation, node);
    grid.setDefinitions(row, columns);
    if (shape.header && shape.hasHeader) {
        headerDefine(grid, diagram, node);
        index++;
    }
    if (shape.phases.length > 0 && shape.phaseSize) {
        for (var k = 0; k < shape.phases.length; k++) {
            if (shape.phases[parseInt(k.toString(), 10)].id === '') {
                shape.phases[parseInt(k.toString(), 10)].id = randomId();
            }
            phaseDefine(grid, diagram, node, index, orientation, k);
        }
        index++;
    }
    if (shape.lanes.length > 0) {
        for (var k = 0; k < shape.lanes.length; k++) {
            if (shape.lanes[parseInt(k.toString(), 10)].id === '') {
                shape.lanes[parseInt(k.toString(), 10)].id = randomId();
            }
            laneCollection(grid, diagram, node, index, k, orientation);
            index++;
        }
    }
}
/**
 * addObjectToGrid method \
 *
 * @returns {Container} addObjectToGrid method .\
 * @param { Diagram} diagram - provide the diagram  value.
 * @param { GridPanel} grid - provide the grid  value.
 * @param {NodeModel} parent - provide the parent  value.
 * @param {NodeModel} object - provide the object  value.
 * @param {boolean} isHeader - provide the isHeader  value.
 * @param {boolean} isPhase - provide the isPhase  value.
 * @param {boolean} isLane - provide the isLane  value.
 * @param {string} canvas - provide the canvas  value.
 * @private
 */
function addObjectToGrid(diagram, grid, parent, object, isHeader, isPhase, isLane, canvas) {
    var node = new Node(diagram, 'nodes', object, true);
    node.parentId = parent.id;
    node.isHeader = (isHeader) ? true : false;
    node.isPhase = (isPhase) ? true : false;
    node.isLane = (isLane) ? true : false;
    var id = (isPhase) ? 'PhaseHeaderParent' : 'LaneHeaderParent';
    if (canvas) {
        node["" + id] = canvas;
    }
    node.constraints &= ~(NodeConstraints.InConnect | NodeConstraints.OutConnect);
    node.constraints |= NodeConstraints.HideThumbs;
    diagram.initObject(node);
    diagram.nodes.push(node);
    if (node.wrapper.children.length > 0) {
        for (var i = 0; i < node.wrapper.children.length; i++) {
            var child = node.wrapper.children[parseInt(i.toString(), 10)];
            if (child instanceof DiagramElement) {
                child.isCalculateDesiredSize = false;
            }
            if (child instanceof TextElement) {
                child.canConsiderBounds = false;
                if (!isHeader && (parent.shape.orientation === 'Vertical' && isPhase) ||
                    (parent.shape.orientation !== 'Vertical' && isLane)) {
                    child.isLaneOrientation = true;
                    child.refreshTextElement();
                }
            }
        }
        node.wrapper.measure(new Size(undefined, undefined));
        node.wrapper.arrange(node.wrapper.desiredSize);
    }
    return node.wrapper;
}
/**
 * headerDefine method \
 *
 * @returns {void} headerDefine method .\
 * @param { GridPanel} grid - provide the grid  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {NodeModel} object - provide the object  value.
 * @private
 */
function headerDefine(grid, diagram, object) {
    var maxWidth = 0;
    var columns = grid.columnDefinitions();
    var shape = object.shape;
    for (var i = 0; i < columns.length; i++) {
        maxWidth += columns[parseInt(i.toString(), 10)].width;
    }
    shape.header.id = shape.header.id || randomId();
    var node = {
        id: object.id + shape.header.id,
        annotations: [cloneObject(shape.header.annotation)],
        style: shape.header.style ? shape.header.style : undefined,
        offsetX: object.offsetX, offsetY: object.offsetY,
        rowIndex: 0, columnIndex: 0,
        maxWidth: maxWidth,
        container: { type: 'Canvas', orientation: 'Horizontal' }
    };
    if (!canSelect(object)) {
        node.constraints &= ~NodeConstraints.Select;
    }
    var wrapper = addObjectToGrid(diagram, grid, object, node, true);
    grid.addObject(wrapper, 0, 0, 1, grid.columnDefinitions().length);
}
/**
 * phaseDefine method \
 *
 * @returns {void} phaseDefine method .\
 * @param { GridPanel} grid - provide the grid  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {NodeModel} object - provide the object  value.
 * @param {number} indexValue - provide the indexValue  value.
 * @param {boolean} orientation - provide the orientation  value.
 * @param {number} phaseIndex - provide the phaseIndex  value.
 * @private
 */
function phaseDefine(grid, diagram, object, indexValue, orientation, phaseIndex) {
    var rowValue = 0;
    var colValue = 0;
    var maxWidth;
    var shape = object.shape;
    if (orientation) {
        colValue = phaseIndex;
        rowValue = indexValue;
        maxWidth = grid.columnDefinitions()[parseInt(phaseIndex.toString(), 10)].width;
    }
    else {
        rowValue = shape.header && shape.hasHeader ? phaseIndex + 1 : phaseIndex;
    }
    var phaseObject = {
        annotations: [cloneObject(shape.phases[parseInt(phaseIndex.toString(), 10)].header.annotation)],
        maxWidth: maxWidth,
        id: object.id + shape.phases[parseInt(phaseIndex.toString(), 10)].id + '_header',
        addInfo: shape.phases[parseInt(phaseIndex.toString(), 10)].addInfo,
        offsetX: object.offsetX, offsetY: object.offsetY,
        style: shape.phases[parseInt(phaseIndex.toString(), 10)].style,
        rowIndex: rowValue, columnIndex: colValue,
        container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }
    };
    phaseObject.annotations[0].rotateAngle = orientation ? 0 : 270;
    if (!canSelect(object)) {
        phaseObject.constraints &= ~NodeConstraints.Select;
    }
    shape.phases[parseInt(phaseIndex.toString(), 10)].header.id = phaseObject.id;
    var wrapper = addObjectToGrid(diagram, grid, object, phaseObject, false, true, false, shape.phases[parseInt(phaseIndex.toString(), 10)].id);
    grid.addObject(wrapper, rowValue, colValue);
}
/**
 * laneCollection method \
 *
 * @returns {void} laneCollection method .\
 * @param { GridPanel} grid - provide the grid  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {NodeModel} object - provide the object  value.
 * @param {number} indexValue - provide the indexValue  value.
 * @param {number} laneIndex - provide the laneIndex  value.
 * @param {boolean} orientation - provide the orientation  value.
 * @private
 */
function laneCollection(grid, diagram, object, indexValue, laneIndex, orientation) {
    var laneNode;
    var parentWrapper;
    var gridCell;
    var canvas;
    var childWrapper;
    var shape = object.shape;
    var value = shape.phases.length || 1;
    var isHeader = (shape.header && shape.hasHeader) ? 1 : 0;
    var rowValue = orientation ? indexValue : isHeader;
    var phaseCount = (shape.phaseSize && shape.phases.length > 0) ? 1 : 0;
    for (var l = 0; l < value; l++) {
        var colValue = orientation ? l : laneIndex + phaseCount;
        gridCell = grid.rows[parseInt(rowValue.toString(), 10)].cells[parseInt(colValue.toString(), 10)];
        canvas = {
            id: object.id + shape.lanes[parseInt(laneIndex.toString(), 10)].id + l,
            rowIndex: rowValue, columnIndex: colValue,
            width: gridCell.minWidth, height: gridCell.minHeight,
            offsetX: object.offsetX, offsetY: object.offsetY,
            style: shape.lanes[parseInt(laneIndex.toString(), 10)].style,
            addInfo: shape.lanes[parseInt(laneIndex.toString(), 10)].addInfo,
            constraints: NodeConstraints.Default | NodeConstraints.ReadOnly | NodeConstraints.AllowDrop,
            container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }
        };
        if (!canSelect(object)) {
            canvas.constraints &= ~NodeConstraints.Select;
        }
        parentWrapper = addObjectToGrid(diagram, grid, object, canvas, false, false, true);
        if (shape.phases && shape.phases.length > 0 && shape.phases[parseInt(l.toString(), 10)]) {
            var phase = diagram.nameTable[shape.phases[parseInt(l.toString(), 10)].header.id];
            if (phase) {
                phase.laneGrids.splice(laneIndex, 0, canvas.id);
            }
        }
        parentWrapper.children[0].isCalculateDesiredSize = false;
        if (l === 0) {
            laneNode = {
                id: object.id + shape.lanes[parseInt(laneIndex.toString(), 10)].id + '_' + l + '_header',
                style: shape.lanes[parseInt(laneIndex.toString(), 10)].header.style,
                annotations: [cloneObject(shape.lanes[parseInt(laneIndex.toString(), 10)].header.annotation)],
                offsetX: object.offsetX, offsetY: object.offsetY,
                rowIndex: rowValue, columnIndex: colValue,
                container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }
            };
            laneNode.annotations[0].rotateAngle = orientation ? 270 : 0;
            shape.lanes[parseInt(laneIndex.toString(), 10)].header.id = laneNode.id;
            // eslint-disable-next-line
            (orientation) ? laneNode.width = shape.lanes[laneIndex].header.width :
                laneNode.height = shape.lanes[parseInt(laneIndex.toString(), 10)].header.height;
            if (!canSelect(object)) {
                laneNode.constraints &= ~NodeConstraints.Select;
            }
            childWrapper = addObjectToGrid(diagram, grid, object, laneNode, false, false, true, shape.lanes[parseInt(laneIndex.toString(), 10)].id);
            if (orientation) {
                childWrapper.children[0].elementActions = childWrapper.children[0].elementActions | ElementAction.HorizontalLaneHeader;
            }
            parentWrapper.children.push(childWrapper);
        }
        grid.addObject(parentWrapper, rowValue, colValue);
        if (!orientation) {
            rowValue++;
        }
        colValue = orientation ? l : laneIndex + 1;
    }
}
/**
 * createRow method \
 *
 * @returns {void} createRow method .\
 * @param { RowDefinition[]} row - provide the row  value.
 * @param {number} height - provide the height  value.
 * @private
 */
function createRow(row, height) {
    var rows = new RowDefinition();
    rows.height = height;
    row.push(rows);
}
/**
 * createColumn method \
 *
 * @returns {void} createColumn method .\
 * @param {number} width - provide the width  value.
 * @private
 */
function createColumn(width) {
    var cols = new ColumnDefinition();
    cols.width = width;
    return cols;
}
/**
 * initGridRow method \
 *
 * @returns {void} initGridRow method .\
 * @param {RowDefinition[]} row - provide the row  value.
 * @param {boolean} orientation - provide the row  value.
 * @param {NodeModel} object - provide the row  value.
 * @private
 */
function initGridRow(row, orientation, object) {
    var totalHeight = 0;
    var height;
    var shape = object.shape;
    if (row.length > 0) {
        for (var i = 0; i < row.length; i++) {
            totalHeight += row[parseInt(i.toString(), 10)].height;
        }
    }
    if (orientation) {
        if (shape.phases.length > 0 && shape.phaseSize) {
            totalHeight += shape.phaseSize;
            createRow(row, shape.phaseSize);
        }
        if (shape.lanes.length > 0) {
            for (var i = 0; i < shape.lanes.length; i++) {
                height = shape.lanes[parseInt(i.toString(), 10)].height;
                totalHeight += height;
                if (i === shape.lanes.length - 1 && totalHeight < object.height) {
                    height += object.height - totalHeight;
                }
                createRow(row, height);
            }
        }
    }
    else {
        if (shape.phases.length > 0) {
            var phaseHeight = 0;
            for (var i = 0; i < shape.phases.length; i++) {
                var phaseOffset = shape.phases[parseInt(i.toString(), 10)].offset;
                if (i === 0) {
                    phaseHeight += phaseOffset;
                }
                else {
                    phaseOffset -= phaseHeight;
                    phaseHeight += phaseOffset;
                }
                height = phaseOffset;
                totalHeight += height;
                if (i === shape.phases.length - 1 && totalHeight < object.height) {
                    height += object.height - totalHeight;
                }
                createRow(row, height);
            }
        }
        else {
            createRow(row, object.height);
        }
    }
}
/**
 * initGridColumns method \
 *
 * @returns {void} initGridRow method .\
 * @param {ColumnDefinition[]} columns - provide the row  value.
 * @param {boolean} orientation - provide the row  value.
 * @param {NodeModel} object - provide the row  value.
 * @private
 */
function initGridColumns(columns, orientation, object) {
    var totalWidth = 0;
    var shape = object.shape;
    var phaseOffset;
    var cols;
    var k;
    var j;
    var value;
    if (shape.phases.length > 0 && shape.orientation === 'Horizontal') {
        for (j = 0; j < shape.phases.length; j++) {
            phaseOffset = shape.phases[parseInt(j.toString(), 10)].offset;
            if (j === 0) {
                totalWidth += phaseOffset;
            }
            else {
                phaseOffset -= totalWidth;
                totalWidth += phaseOffset;
            }
            cols = createColumn(phaseOffset);
            if (j === shape.phases.length - 1 && totalWidth < object.width) {
                cols.width += object.width - totalWidth;
            }
            columns.push(cols);
        }
    }
    else if (!orientation) {
        value = (shape.phaseSize && shape.phases.length > 0) ? shape.lanes.length
            + 1 : shape.lanes.length;
        if (shape.phaseSize && shape.phases.length > 0) {
            totalWidth += shape.phaseSize;
            cols = createColumn(shape.phaseSize);
            columns.push(cols);
        }
        for (k = 0; k < shape.lanes.length; k++) {
            totalWidth += shape.lanes[parseInt(k.toString(), 10)].width;
            cols = createColumn(shape.lanes[parseInt(k.toString(), 10)].width);
            if (k === shape.lanes.length - 1 && totalWidth < object.width) {
                cols.width += object.width - totalWidth;
            }
            columns.push(cols);
        }
        if ((shape.phases.length === 0 && shape.lanes.length === 0)) {
            cols = createColumn(object.width);
            columns.push(cols);
        }
    }
    else {
        cols = createColumn(object.width);
        columns.push(cols);
    }
}
/**
 * getConnectors method \
 *
 * @returns {void} getConnectors method .\
 * @param {Diagram} diagram - provide the row  value.
 * @param {GridPanel} grid - provide the row  value.
 * @param {number} rowIndex - provide the row  value.
 * @param {boolean} isRowUpdate - provide the row  value.
 * @private
 */
function getConnectors(diagram, grid, rowIndex, isRowUpdate) {
    var connectors = [];
    var conn = 0;
    var childNode;
    var node;
    var k;
    var j;
    var canvas;
    var row;
    var length = grid.rowDefinitions().length;
    var edges;
    for (var i_1 = 0; i_1 < length; i_1++) {
        row = grid.rows[parseInt(i_1.toString(), 10)];
        for (j = 0; j < row.cells.length; j++) {
            canvas = row.cells[parseInt(j.toString(), 10)].children[0];
            if (canvas && canvas.children && canvas.children.length) {
                for (k = 1; k < canvas.children.length; k++) {
                    childNode = canvas.children[parseInt(k.toString(), 10)];
                    node = diagram.getObject(childNode.id);
                    if (node && (node.inEdges.length > 0 || node.outEdges.length > 0)) {
                        edges = node.inEdges.concat(node.outEdges);
                        for (conn = 0; conn < edges.length; conn++) {
                            if (connectors.indexOf(edges[parseInt(conn.toString(), 10)]) === -1) {
                                connectors.push(edges[parseInt(conn.toString(), 10)]);
                            }
                        }
                    }
                }
            }
        }
    }
    return connectors;
}
/**
 * swimLaneMeasureAndArrange method \
 *
 * @returns {void} swimLaneMeasureAndArrange method .\
 * @param {NodeModel} obj - provide the row  value.
 * @private
 */
function swimLaneMeasureAndArrange(obj) {
    var canvas = obj.wrapper;
    canvas.measure(new Size(obj.width, obj.height));
    if (canvas.children[0] instanceof GridPanel) {
        var grid = canvas.children[0];
        var isMeasure = false;
        if (grid.width && grid.width < grid.desiredSize.width) {
            isMeasure = true;
            grid.width = grid.desiredSize.width;
        }
        if (grid.height && grid.height < grid.desiredSize.height) {
            isMeasure = true;
            grid.height = grid.desiredSize.height;
        }
        if (isMeasure) {
            grid.measure(new Size(grid.width, grid.height));
        }
    }
    canvas.arrange(canvas.desiredSize);
}
/**
 * ChangeLaneIndex method \
 *
 * @returns {void} ChangeLaneIndex method .\
 * @param {Diagram} diagram - provide the row  value.
 * @param {NodeModel} obj - provide the row  value.
 * @param {number} startRowIndex - provide the row  value.
 * @private
 */
function ChangeLaneIndex(diagram, obj, startRowIndex) {
    var container = obj.wrapper.children[0];
    var i;
    var j;
    var k;
    var l;
    var object;
    var subChild;
    var row;
    var cell;
    var child;
    for (i = startRowIndex; i < container.rows.length; i++) {
        row = container.rows[parseInt(i.toString(), 10)];
        for (j = 0; j < row.cells.length; j++) {
            cell = row.cells[parseInt(j.toString(), 10)];
            if (cell.children && cell.children.length > 0) {
                for (k = 0; k < cell.children.length; k++) {
                    child = cell.children[parseInt(k.toString(), 10)];
                    object = diagram.nameTable[child.id];
                    if (object.isLane && child.children.length > 1) {
                        // 912905: Multi-selecting and deleting swimlane objects causes the diagram to break
                        for (l = 1; l < child.children.length; l++) {
                            subChild = diagram.nameTable[child.children[parseInt(l.toString(), 10)].id];
                            if (subChild && subChild.isLane) {
                                subChild.rowIndex = i;
                                subChild.columnIndex = j;
                            }
                        }
                    }
                    object.rowIndex = i;
                    object.columnIndex = j;
                }
            }
        }
    }
}
/**
 * arrangeChildNodesInSwimLane method \
 *
 * @returns {void} arrangeChildNodesInSwimLane method .\
 * @param {Diagram} diagram - provide the row  value.
 * @param {NodeModel} obj - provide the row  value.
 * @private
 */
function arrangeChildNodesInSwimLane(diagram, obj) {
    var grid = obj.wrapper.children[0];
    var shape = obj.shape;
    var padding = shape.padding;
    var lanes = shape.lanes;
    var top = grid.bounds.y;
    var rowvalue;
    var columnValue;
    var phaseCount = (shape.phaseSize > 0) ? shape.phases.length : 0;
    var node;
    var canvas;
    var cell;
    var i;
    var j;
    var k;
    var orientation = shape.orientation === 'Horizontal' ? true : false;
    var col = orientation ? shape.phases.length || 1 : lanes.length + 1;
    var row = orientation ? ((shape.header && shape.hasHeader) ? 1 : 0) +
        (shape.phases.length > 0 ? 1 : 0) + (shape.lanes.length)
        : (shape.header && shape.hasHeader ? 1 : 0) + shape.phases.length;
    if (phaseCount === 0 && !orientation && shape.lanes.length) {
        row += 1;
    }
    if (orientation) {
        rowvalue = (shape.header && shape.hasHeader ? 1 : 0) + (phaseCount > 0 ? 1 : 0);
        columnValue = 0;
    }
    else {
        rowvalue = (shape.header && shape.hasHeader ? 1 : 0);
        columnValue = phaseCount > 0 ? 1 : 0;
    }
    if (lanes.length > 0) {
        top += (shape.header && shape.hasHeader) ? shape.header.height : 0;
        for (i = 0; i < lanes.length; i++) {
            for (j = 0; j < lanes[parseInt(i.toString(), 10)].children.length; j++) {
                node = lanes[parseInt(i.toString(), 10)].children[parseInt(j.toString(), 10)];
                node.offsetX = lanes[parseInt(i.toString(), 10)].width;
                node.offsetY = lanes[parseInt(i.toString(), 10)].height;
                diagram.initObject(node);
                diagram.nodes.push(node);
                canvas = node.wrapper;
                if (orientation) {
                    for (k = columnValue; k < col; k++) {
                        cell = grid.rows[parseInt(rowvalue.toString(), 10)].cells[parseInt(k.toString(), 10)];
                        if (canvas.margin.left < (cell.bounds.right - grid.bounds.x)) {
                            node.parentId = cell.children[0].id;
                            if (k > columnValue) {
                                canvas.margin.left = canvas.margin.left - (cell.bounds.left - grid.bounds.left);
                            }
                            else {
                                if ((cell.children[0].children[1].actualSize.width + padding) >= canvas.margin.left) {
                                    canvas.margin.left = cell.children[0].children[1].actualSize.width + padding;
                                }
                            }
                            if (canvas.margin.left < padding) {
                                canvas.margin.left = padding;
                            }
                            if (canvas.margin.top < padding) {
                                canvas.margin.top = padding;
                            }
                            addChildToLane(canvas, node, diagram);
                            break;
                        }
                    }
                }
                else {
                    for (var k_1 = rowvalue; k_1 < row; k_1++) {
                        cell = grid.rows[parseInt(k_1.toString(), 10)].cells[parseInt(columnValue.toString(), 10)];
                        if (canvas.margin.top < (cell.bounds.bottom - top)) {
                            node.parentId = cell.children[0].id;
                            if (k_1 > rowvalue) {
                                canvas.margin.top = canvas.margin.top - (cell.bounds.top - top);
                            }
                            else {
                                if ((cell.children[0].children[1].actualSize.height + padding) >= canvas.margin.top) {
                                    canvas.margin.top = cell.children[0].children[1].actualSize.height + padding;
                                }
                            }
                            if (canvas.margin.left < padding) {
                                canvas.margin.left = padding;
                            }
                            if (canvas.margin.top < padding) {
                                canvas.margin.top = padding;
                            }
                            addChildToLane(canvas, node, diagram);
                            break;
                        }
                    }
                }
            }
            // eslint-disable-next-line
            orientation ? rowvalue++ : columnValue++;
        }
    }
    grid.measure(new Size(obj.width, obj.height));
    grid.arrange(grid.desiredSize);
    updateChildOuterBounds(grid, obj);
    obj.width = obj.wrapper.width = grid.width;
    obj.height = obj.wrapper.height = grid.height;
    updateHeaderMaxWidth(diagram, obj);
    obj.wrapper.measure(new Size(obj.width, obj.height));
    obj.wrapper.arrange(grid.desiredSize);
    checkLaneChildrenOffset(obj);
    checkPhaseOffset(obj, diagram);
    checkLaneSize(obj);
}
/**
 * addChildToLane method \
 *
 * @returns {void} addChildToLane method .\
 * @param {Container} canvas - provide the row  value.
 * @param {NodeModel} node - provide the row  value.
 * @param {Diagram} diagram - provide the row  value.
 * @private
 */
function addChildToLane(canvas, node, diagram) {
    canvas.measure(new Size(node.width, node.height));
    canvas.arrange(canvas.desiredSize);
    var parent = diagram.getObject(node.parentId);
    diagram.addChild(parent, node.id);
}
/**
 * updateChildOuterBounds method \
 *
 * @returns {void} updateChildOuterBounds method .\
 * @param {GridPanel} grid - provide the row  value.
 * @param {NodeModel} obj - provide the row  value.
 * @private
 */
function updateChildOuterBounds(grid, obj) {
    var columnDefinitions = grid.columnDefinitions();
    var rowDefinitions = grid.rowDefinitions();
    var i;
    var k;
    var j;
    var cell;
    var child;
    var row;
    var rowIndex = findStartLaneIndex(obj);
    if (obj.shape.orientation === 'Vertical') {
        if (rowIndex === 0) {
            rowIndex = (obj.shape.header && obj.shape.hasHeader) ? 1 : 0;
        }
    }
    var padding = obj.shape.padding;
    for (i = 0; i < columnDefinitions.length; i++) {
        grid.updateColumnWidth(i, columnDefinitions[parseInt(i.toString(), 10)].width, true, padding);
    }
    for (i = rowIndex; i < rowDefinitions.length; i++) {
        grid.updateRowHeight(i, rowDefinitions[parseInt(i.toString(), 10)].height, true, padding);
    }
    for (k = 0; k < rowDefinitions.length; k++) {
        row = grid.rows[parseInt(k.toString(), 10)];
        for (i = 0; i < columnDefinitions.length; i++) {
            cell = row.cells[parseInt(i.toString(), 10)];
            if (cell.children && cell.children.length > 0) {
                for (j = 0; j < cell.children.length; j++) {
                    child = cell.children[parseInt(j.toString(), 10)];
                    if (child.maxWidth) {
                        child.maxWidth = cell.actualSize.width;
                    }
                    if (child.maxHeight) {
                        child.maxHeight = cell.actualSize.height;
                    }
                }
            }
        }
    }
}
/**
 * checkLaneSize method \
 *
 * @returns {void} checkLaneSize method .\
 * @param {NodeModel} obj - provide the row  value.
 * @private
 */
function checkLaneSize(obj) {
    if (obj.shape.type === 'SwimLane' && !obj.shape.isLane && !obj.shape.isPhase) {
        // 910832 - Lane height updating to negative values wrongly during resizing
        var lane = void 0;
        var i = void 0;
        var j = void 0;
        var k = void 0;
        var size = void 0; //let laneCount: number = 0;
        var lanes = obj.shape.lanes;
        var laneIndex = findStartLaneIndex(obj);
        var rows = obj.wrapper.children[0].rowDefinitions();
        var columns = obj.wrapper.children[0].columnDefinitions();
        var widthSize = void 0;
        var heightSize = void 0;
        for (i = 0; i < lanes.length; i++, laneIndex++) {
            lane = lanes[parseInt(i.toString(), 10)];
            if (obj.shape.orientation === 'Horizontal') {
                size = rows[parseInt(laneIndex.toString(), 10)].height;
                if (lane.height !== size) {
                    lane.height = size;
                }
                for (j = 0; j < columns.length; j++) {
                    widthSize = columns[parseInt(j.toString(), 10)].width;
                    if (lane.width !== widthSize) {
                        lane.width = widthSize;
                    }
                }
            }
            else {
                size = columns[parseInt(laneIndex.toString(), 10)].width;
                if (lane.width !== size) {
                    lane.width = size;
                }
                for (k = 0; k < rows.length; k++) {
                    heightSize = rows[parseInt(k.toString(), 10)].height;
                    if (lane.height !== heightSize) {
                        lane.height = heightSize;
                    }
                }
            }
        }
    }
}
/**
 * checkPhaseOffset method \
 *
 * @returns {void} checkPhaseOffset method .\
 * @param {NodeModel} obj - provide the obj  value.
 * @param {Diagram} diagram - provide the obj  value.
 * @private
 */
function checkPhaseOffset(obj, diagram) {
    var shape = obj.shape;
    var phases = shape.phases;
    var i;
    var offset;
    var phaseRow;
    var phase;
    var gridRowIndex = (shape.header && shape.hasHeader) ? 1 : 0;
    var grid = obj.wrapper.children[0];
    var top = grid.bounds.y + ((shape.header && shape.hasHeader) ? shape.header.height : 0);
    if (obj.shape.type === 'SwimLane') {
        obj = diagram.getObject(obj.id) || obj;
        if (phases.length > 0) {
            grid = obj.wrapper.children[0];
            if (shape.orientation === 'Horizontal') {
                phaseRow = (shape.header && shape.hasHeader) ? grid.rows[1] : grid.rows[0];
                for (i = 0; i < phases.length; i++) {
                    phase = phaseRow.cells[parseInt(i.toString(), 10)].children[0];
                    offset = phase.bounds.right - grid.bounds.x;
                    if (phases[parseInt(i.toString(), 10)].offset !== offset) {
                        phases[parseInt(i.toString(), 10)].offset = offset;
                    }
                    diagram.nameTable[phase.id].maxWidth = phase.maxWidth;
                }
            }
            else {
                for (i = 0; i < phases.length; i++) {
                    phase = grid.rows[gridRowIndex + i].cells[0].children[0];
                    offset = phase.bounds.bottom - top;
                    if (phases[parseInt(i.toString(), 10)].offset !== offset) {
                        phases[parseInt(i.toString(), 10)].offset = offset;
                    }
                    diagram.nameTable[phase.id].maxWidth = phase.maxWidth;
                }
            }
        }
    }
}
/**
 * updateConnectorsProperties method \
 *
 * @returns {void} checkPhaseOffset method .\
 * @param {string[]} connectors - provide the obj  value.
 * @param {Diagram} diagram - provide the obj  value.
 * @private
 */
function updateConnectorsProperties(connectors, diagram) {
    if (connectors && connectors.length > 0) {
        var edges = void 0;
        if (diagram.lineRoutingModule && (diagram.constraints & DiagramConstraints.LineRouting)) {
            diagram.lineRoutingModule.renderVirtualRegion(diagram, true);
        }
        for (var i = 0; i < connectors.length; i++) {
            edges = diagram.getObject(connectors[parseInt(i.toString(), 10)]);
            if (diagram.lineRoutingModule && (diagram.constraints & DiagramConstraints.LineRouting) && edges.type === 'Orthogonal') {
                diagram.lineRoutingModule.refreshConnectorSegments(diagram, edges, true);
            }
            else {
                diagram.connectorPropertyChange(edges, {}, {
                    sourceID: edges.sourceID, targetID: edges.targetID
                });
            }
        }
    }
}
/**
 * laneInterChanged method \
 *
 * @returns {void} laneInterChanged method .\
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {NodeModel} obj - provide the obj  value.
 * @param {NodeModel} target - provide the target  value.
 * @param {PointModel} position - provide the position  value.
 * @private
 */
function laneInterChanged(diagram, obj, target, position) {
    var index;
    var undoElement;
    var entry;
    var redoElement;
    var sourceIndex;
    var targetIndex;
    var temp;
    var sourceLaneIndex;
    var targetLaneIndex;
    var rowIndex;
    var swimLane = (diagram.getObject(obj.parentId));
    var shape = swimLane.shape;
    var grid = swimLane.wrapper.children[0];
    var lanes = shape.lanes;
    var connectors = getConnectors(diagram, grid, obj.rowIndex);
    if ((shape.orientation === 'Horizontal' && obj.rowIndex !== target.rowIndex) ||
        (shape.orientation === 'Vertical' && obj.columnIndex !== target.columnIndex)) {
        if (shape.orientation === 'Horizontal') {
            sourceIndex = obj.rowIndex;
            targetIndex = target.rowIndex;
            index = ((shape.header && shape.hasHeader) ? 1 : 0) + (shape.phases.length && shape.phaseSize ? 1 : 0);
            sourceLaneIndex = obj.rowIndex - index;
            targetLaneIndex = target.rowIndex - index;
            if (lanes[parseInt(sourceLaneIndex.toString(), 10)].canMove) {
                if (sourceLaneIndex < targetLaneIndex) {
                    if (position && target.wrapper.offsetY > position.y) {
                        targetIndex += (targetLaneIndex > 0) ? -1 : 1;
                        targetLaneIndex += (targetLaneIndex > 0) ? -1 : 1;
                    }
                }
                else {
                    if (position && target.wrapper.offsetY < position.y) {
                        targetIndex += 1;
                        targetLaneIndex += 1;
                    }
                }
                if (sourceIndex !== targetIndex) {
                    grid.updateRowIndex(sourceIndex, targetIndex);
                    //To update the laneGrids arrangement after swaping lanes
                    updatePhaseLaneGrids(sourceLaneIndex, targetLaneIndex, swimLane, diagram);
                }
            }
        }
        else {
            sourceIndex = obj.columnIndex;
            targetIndex = target.columnIndex;
            index = (shape.phases.length && shape.phaseSize) ? 1 : 0;
            sourceLaneIndex = obj.columnIndex - index;
            targetLaneIndex = target.columnIndex - index;
            rowIndex = (shape.header && shape.hasHeader) ? 1 : 0;
            if (lanes[parseInt(sourceLaneIndex.toString(), 10)].canMove) {
                if (sourceLaneIndex < targetLaneIndex) {
                    if (position && target.wrapper.offsetX > position.x) {
                        targetIndex += (targetLaneIndex > 0) ? -1 : 1;
                        targetLaneIndex += (targetLaneIndex > 0) ? -1 : 1;
                    }
                }
                else {
                    if (position && target.wrapper.offsetX < position.x) {
                        targetIndex += 1;
                        targetLaneIndex += 1;
                    }
                }
                if (sourceIndex !== targetIndex) {
                    if ((shape.phaseSize === 0 || shape.phases.length === 0) && (targetIndex === 0 || sourceIndex === 0)) {
                        if (shape.header && shape.hasHeader) {
                            var changeHeaderIndex = (targetIndex === 0) ? sourceIndex : targetIndex;
                            grid.rows[0].cells[parseInt(changeHeaderIndex.toString(), 10)].children = grid.rows[0].cells[0].children;
                            grid.rows[0].cells[parseInt(changeHeaderIndex.toString(), 10)].columnSpan = grid.rows[0].cells[0].columnSpan;
                            grid.rows[0].cells[0].children = [];
                        }
                    }
                    grid.updateColumnIndex(0, sourceIndex, targetIndex);
                    //To update the laneGrids arrangement after swaping lanes
                    updatePhaseLaneGrids(sourceLaneIndex, targetLaneIndex, swimLane, diagram);
                }
            }
        }
        if (sourceIndex !== targetIndex) {
            temp = lanes[parseInt(sourceLaneIndex.toString(), 10)];
            if (temp.canMove) {
                undoElement = {
                    target: cloneObject(target), source: cloneObject(obj)
                };
                temp = lanes[parseInt(sourceLaneIndex.toString(), 10)];
                lanes.splice(sourceLaneIndex, 1);
                lanes.splice(targetLaneIndex, 0, temp);
                redoElement = {
                    target: cloneObject(undoElement.source), source: cloneObject(undoElement.target)
                };
                entry = {
                    type: 'LanePositionChanged', redoObject: redoElement,
                    undoObject: undoElement, category: 'Internal'
                };
                if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {
                    diagram.commandHandler.addHistoryEntry(entry);
                }
                ChangeLaneIndex(diagram, swimLane, 0);
                updateConnectorsProperties(connectors, diagram);
                updateSwimLaneChildPosition(lanes, diagram);
                swimLane.wrapper.measure(new Size(swimLane.width, swimLane.height));
                swimLane.wrapper.arrange(swimLane.wrapper.desiredSize);
                diagram.updateDiagramObject(swimLane);
            }
        }
    }
    diagram.updateDiagramElementQuad();
}
/**
 * Swaps the positions of two lane grid entries within each phase of a swimlane.
 *
 * @param {number} sourceIndex - The index of the lane grid to be moved.
 * @param {number} targetIndex - The index where the lane grid should be moved to.
 * @param {NodeModel} swimlane - The swimlane node containing the phases.
 * @param {Diagram} diagram - The diagram instance containing the node data.
 * @returns {void}
 * @private
 */
function updatePhaseLaneGrids(sourceIndex, targetIndex, swimlane, diagram) {
    var phases = swimlane.shape.phases;
    if (phases && phases.length > 0) {
        for (var i = 0; i < phases.length; i++) {
            var phaseId = swimlane.id + phases[parseInt(i.toString(), 10)].id + '_header';
            var phaseObj = diagram.nameTable["" + phaseId];
            if (phaseObj && phaseObj.laneGrids && sourceIndex >= 0 && targetIndex >= 0 &&
                sourceIndex < phaseObj.laneGrids.length && targetIndex < phaseObj.laneGrids.length) {
                // Remove the element at sourceIndex
                var removed = phaseObj.laneGrids.splice(sourceIndex, 1)[0];
                // Insert it at targetIndex
                phaseObj.laneGrids.splice(targetIndex, 0, removed);
            }
        }
    }
}
/**
 * updateSwimLaneObject method \
 *
 * @returns {void} updateSwimLaneObject method .\
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {Node} obj - provide the obj  value.
 * @param {NodeModel} swimLane - provide the target  value.
 * @param {NodeModel} helperObject - provide the position  value.
 * @param {number} widthDiff - provide the difference in colum width.
 * @param {number} heightDiff - provide the difference in row height.
 * @private
 */
function updateSwimLaneObject(diagram, obj, swimLane, helperObject, widthDiff, heightDiff) {
    var parentNode = diagram.getObject(swimLane.id);
    var shape = parentNode.shape;
    var index = (shape.header && shape.hasHeader) ? 1 : 0;
    var lanes = shape.lanes;
    var phases = shape.phases;
    var helperWidth = helperObject.wrapper.actualSize.width;
    var helperHeight = helperObject.wrapper.actualSize.height;
    var objWidth = obj.wrapper.actualSize.width;
    var objHeight = obj.wrapper.actualSize.height;
    var i;
    var j;
    var isUndoRedo = false;
    if (diagram.diagramActions & DiagramAction.UndoRedo) {
        isUndoRedo = true;
    }
    var grid = parentNode.wrapper.children[0];
    // 910832 - Lane height updating to negative values wrongly during resizing
    if (parentNode.shape.type === 'SwimLane') {
        if (shape.orientation === 'Horizontal') {
            if (obj.isPhase) {
                // phases[obj.columnIndex].offset = obj.wrapper.width;
                for (var p = obj.columnIndex; p < phases.length; p++) {
                    phases[parseInt(p.toString(), 10)].offset += widthDiff;
                    //929543: To get the minWidth of phase and if the updated size less than min width then we set minWindth.
                    var curPhase = diagram.nameTable[phases[parseInt(p.toString(), 10)].header.id];
                    if (curPhase) {
                        var gridPhase = grid.rows[curPhase.rowIndex].cells[curPhase.columnIndex];
                        var gridPhaseMinWidth = gridPhase.minWidth;
                        if (phases[parseInt(p.toString(), 10)].offset < gridPhaseMinWidth) {
                            phases[parseInt(p.toString(), 10)].offset = gridPhaseMinWidth;
                        }
                    }
                }
                for (i = 0; i < lanes.length; i++) {
                    lanes[parseInt(i.toString(), 10)].width = (!isUndoRedo ? obj.wrapper.width : helperWidth);
                }
            }
            else {
                index = (shape.phaseSize && shape.phases.length > 0) ? index + 1 : index;
                lanes[(obj.rowIndex - index)].height = (!isUndoRedo ? obj.wrapper.height : helperHeight);
            }
        }
        else {
            if (obj.isPhase) {
                // phases[(obj.rowIndex - index)].offset = obj.wrapper.height;
                for (var p = obj.rowIndex - index; p < phases.length; p++) {
                    phases[parseInt(p.toString(), 10)].offset += heightDiff;
                    //929543: To get the minHeight of phase and if the updated size less than min height then we set minHeight
                    var curPhase = diagram.nameTable[phases[parseInt(p.toString(), 10)].header.id];
                    if (curPhase) {
                        var gridPhase = grid.rows[curPhase.rowIndex].cells[curPhase.columnIndex];
                        var gridPhaseMinHeight = gridPhase.minHeight;
                        if (phases[parseInt(p.toString(), 10)].offset < gridPhaseMinHeight) {
                            phases[parseInt(p.toString(), 10)].offset = gridPhaseMinHeight;
                        }
                    }
                }
                for (j = 0; j < lanes.length; j++) {
                    lanes[parseInt(j.toString(), 10)].height = obj.wrapper.height;
                }
            }
            else {
                index = (shape.phaseSize && shape.phases.length > 0) ? 1 : 0;
                lanes[(obj.columnIndex - index)].width = obj.wrapper.width;
            }
        }
    }
}
/**
 * findLaneIndex method \
 *
 * @returns {number} findLaneIndex method .\
 * @param {NodeModel} swimLane - provide the diagram  value.
 * @param {NodeModel} laneObj - provide the obj  value.
 * @private
 */
function findLaneIndex(swimLane, laneObj) {
    var laneIndex;
    var shape = swimLane.shape;
    var index = (shape.header && shape.hasHeader) ? 1 : 0;
    if (shape.orientation === 'Horizontal') {
        index += shape.phases.length > 0 ? 1 : 0;
        laneIndex = laneObj.rowIndex - index;
    }
    else {
        laneIndex = laneObj.columnIndex - (shape.phaseSize && shape.phases.length > 0 ? 1 : 0);
    }
    return laneIndex;
}
/**
 * findPhaseIndex method \
 *
 * @returns {number} findPhaseIndex method .\
 * @param {NodeModel} phase - provide the diagram  value.
 * @param {NodeModel} swimLane - provide the obj  value.
 * @private
 */
function findPhaseIndex(phase, swimLane) {
    var shape = swimLane.shape;
    var index = (shape.header && shape.hasHeader) ? 1 : 0;
    var phaseIndex = (shape.orientation === 'Horizontal') ? phase.columnIndex : phase.rowIndex - index;
    return phaseIndex;
}
/**
 * findStartLaneIndex method \
 *
 * @returns {number} findStartLaneIndex method .\
 * @param {NodeModel} swimLane - provide the obj  value.
 * @private
 */
function findStartLaneIndex(swimLane) {
    var index = 0;
    var shape = swimLane.shape;
    if (shape.orientation === 'Horizontal') {
        index = (shape.header && shape.hasHeader) ? 1 : 0;
    }
    if (shape.phases.length > 0 && shape.phaseSize) {
        index += 1;
    }
    return index;
}
/**
 * updatePhaseMaxWidth method \
 *
 * @returns {void} updatePhaseMaxWidth method .\
 * @param {NodeModel} parent - provide the obj  value.
 * @param {Diagram} diagram - provide the obj  value.
 * @param {Canvas} wrapper - provide the obj  value.
 * @param {number} columnIndex - provide the obj  value.
 * @private
 */
function updatePhaseMaxWidth(parent, diagram, wrapper, columnIndex) {
    var shape = parent.shape;
    if (shape.phases.length > 0) {
        var node = diagram.nameTable[shape.phases[parseInt(columnIndex.toString(), 10)].header.id];
        if (node && node.maxWidth < wrapper.outerBounds.width) {
            node.maxWidth = wrapper.outerBounds.width;
            node.wrapper.maxWidth = wrapper.outerBounds.width;
        }
    }
}
/**
 * updateHeaderMaxWidth method \
 *
 * @returns {void} updateHeaderMaxWidth method .\
 * @param {NodeModel} diagram - provide the obj  value.
 * @param {NodeModel} swimLane - provide the obj  value.
 * @private
 */
function updateHeaderMaxWidth(diagram, swimLane) {
    if (swimLane.shape.header && swimLane.shape.hasHeader) {
        var grid = swimLane.wrapper.children[0];
        var id = grid.rows[0].cells[0].children[0].id;
        var headerNode = diagram.nameTable["" + id];
        if (headerNode && headerNode.isHeader && (headerNode.maxWidth < swimLane.width || headerNode.wrapper.maxWidth < swimLane.width)) {
            headerNode.maxWidth = swimLane.width;
            headerNode.wrapper.maxWidth = swimLane.width;
        }
    }
}
/**
 * addLane method \
 *
 * @returns {void} addLane method .\
 * @param {Diagram} diagram - provide the obj  value.
 * @param {NodeModel} parent - provide the obj  value.
 * @param {LaneModel} lane - provide the obj  value.
 * @param {number} count - provide the obj  value.
 * @private
 */
function addLane(diagram, parent, lane, count) {
    var args;
    var swimLane = diagram.nameTable[parent.id];
    if (swimLane.shape.type === 'SwimLane') {
        diagram.protectPropertyChange(true);
        var grid = swimLane.wrapper.children[0];
        var bounds = grid.bounds;
        var shape = swimLane.shape;
        var redoObj = void 0;
        var orientation_1 = false;
        var entry = void 0;
        var index = void 0;
        var children = void 0;
        var j = void 0;
        var i = void 0;
        var c = void 0;
        var cell = void 0;
        var child = void 0;
        var point = void 0;
        var laneObj = new Lane(shape, 'lanes', lane, true);
        //To set default height and width incase of undefined height or width.
        lane.height = lane.height || laneObj.height;
        lane.width = lane.width || laneObj.width;
        //913805-perform undo/redo for headerless swimlane,the change won't be properly reverted.
        index = (shape.orientation === 'Vertical') ? 1 : (shape.header && shape.hasHeader) ? 1 : 0;
        if (shape.orientation === 'Horizontal') {
            orientation_1 = true;
            index = shape.phases.length > 0 ? index + 1 : index;
        }
        var connectors = getConnectors(diagram, grid);
        var laneIndex = (count !== undefined) ? count : shape.lanes.length;
        index += laneIndex;
        args = {
            element: laneObj, cause: diagram.diagramActions, diagramAction: diagram.getDiagramAction(diagram.diagramActions), state: 'Changing', type: 'Addition', cancel: false, laneIndex: laneIndex
        };
        diagram.triggerEvent(DiagramEvent.collectionChange, args);
        if (!args.cancel) {
            if (orientation_1) {
                var rowDef = new RowDefinition();
                rowDef.height = lane.height;
                grid.addRow(index, rowDef, false);
                swimLane.height = (swimLane.height !== undefined) ? swimLane.height + lane.height : swimLane.height;
                swimLane.wrapper.height = grid.height = swimLane.height;
            }
            else {
                var colDef = new ColumnDefinition();
                colDef.width = lane.width;
                grid.addColumn(laneIndex + 1, colDef, false);
                if (swimLane.width) {
                    swimLane.width += lane.width;
                    swimLane.wrapper.width = grid.width = swimLane.width;
                }
                //913805-Headerless vertical swimlane phase header get vanished.
                if (shape.hasHeader) {
                    grid.rows[0].cells[0].columnSpan += 1;
                }
            }
            if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {
                laneObj.id = (laneObj.id === '') ? randomId() : laneObj.id;
            }
            if (count !== undefined) {
                shape.lanes.splice(count, 0, laneObj);
            }
            else {
                shape.lanes.push(laneObj);
            }
            args = {
                element: laneObj, cause: diagram.diagramActions, diagramAction: diagram.getDiagramAction(diagram.diagramActions), state: 'Changed', type: 'Addition', cancel: false, laneIndex: laneIndex
            };
            diagram.triggerEvent(DiagramEvent.collectionChange, args);
            laneCollection(grid, diagram, swimLane, index, laneIndex, orientation_1);
            redoObj = (shape.orientation === 'Horizontal') ?
                diagram.nameTable[grid.rows[parseInt(index.toString(), 10)].cells[0].children[0].id] :
                ((shape.header && shape.hasHeader) ?
                    diagram.nameTable[grid.rows[1].cells[parseInt(index.toString(), 10)].children[0].id] :
                    diagram.nameTable[grid.rows[0].cells[parseInt(index.toString(), 10)].children[0].id]);
            if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {
                entry = {
                    type: 'LaneCollectionChanged', changeType: 'Insert', undoObject: cloneObject(laneObj),
                    redoObject: cloneObject(redoObj), category: 'Internal'
                };
                diagram.addHistoryEntry(entry);
            }
            var startRowIndex = (shape.orientation === 'Horizontal') ?
                index : ((shape.header && shape.hasHeader) ? 1 : 0);
            ChangeLaneIndex(diagram, swimLane, startRowIndex);
            swimLaneMeasureAndArrange(swimLane);
            updateHeaderMaxWidth(diagram, swimLane);
            children = lane.children;
            var childAdded = false;
            if (children && children.length > 0) {
                for (j = 0; j < children.length; j++) {
                    childAdded = false;
                    child = children[parseInt(j.toString(), 10)];
                    point = { x: child.wrapper.offsetX, y: child.wrapper.offsetY };
                    var padding = { left: 0, right: 0, top: 0, bottom: 0 };
                    if (shape.orientation === 'Horizontal') {
                        padding.bottom = bounds.y - grid.bounds.y;
                        //839579 - swimlane delete Lane and perform undo redo issue
                        cell = grid.rows[parseInt(index.toString(), 10)].cells[parseInt(j.toString(), 10)];
                        for (i = 0; i < grid.rows[parseInt(index.toString(), 10)].cells.length; i++) {
                            addChildNodeToNewLane(diagram, grid.rows[parseInt(index.toString(), 10)].cells[parseInt(i.toString(), 10)], point, child, padding);
                        }
                    }
                    else {
                        //Bug 876330: After performing cut operations followed by an undo, lanes and nodes in the swimlane are not rendered properly.
                        // To iterate the lane and check whether the child node is inside the vertical lane. If so then we cut the loop.
                        // eslint-disable-next-line no-labels
                        childAddBreak: for (var r = 0; r <= grid.rows.length; r++) {
                            for (c = 0; c < grid.rows[parseInt(r.toString(), 10)].cells.length; c++) {
                                //Padding to compensate the original position of swimlane before drag.
                                padding.right = bounds.x - grid.bounds.x;
                                cell = grid.rows[parseInt(r.toString(), 10)].cells[parseInt(c.toString(), 10)];
                                childAdded = addChildNodeToNewLane(diagram, cell, point, child, padding);
                                if (childAdded) {
                                    // eslint-disable-next-line no-labels
                                    break childAddBreak;
                                }
                            }
                        }
                    }
                }
            }
            updateConnectorsProperties(connectors, diagram);
            diagram.drag(swimLane, bounds.x - grid.bounds.x, bounds.y - grid.bounds.y);
        }
        diagram.protectPropertyChange(false);
    }
}
/**
 * addChildNodeToNewLane method \
 *
 * @returns {void} addChildNodeToNewLane method .\
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {GridCell} cell - provide the cell  value.
 * @param {PointModel} point - provide the point  value.
 * @param {NodeModel} child - provide the child  value.
 * @param {MarginModel | number} padding - provide the padding value.
 * @private
 */
function addChildNodeToNewLane(diagram, cell, point, child, padding) {
    var childAdded = false;
    if (cell.children && cell.children.length > 0) {
        var canvas = cell.children[0];
        var parent_1 = diagram.nameTable[canvas.id];
        if (containsChildPoint(canvas.bounds, point, padding)) {
            diagram.addChild(parent_1, child);
            childAdded = true;
        }
    }
    return childAdded;
}
/**
 * containsChildPoint method \
 *
 * @returns {boolean} containsChildPoint method .\
 * @param {Rect} bounds - provide the bounds  value.
 * @param {PointModel} point - provide the point  value.
 * @param {MarginModel} padding - provide the padding  value.
 * @private
 */
function containsChildPoint(bounds, point, padding) {
    var leftPadding = padding.left || 0;
    var rightPadding = padding.right || 0;
    var topPadding = padding.top || 0;
    var bottomPadding = padding.bottom || 0;
    return bounds.left - leftPadding <= point.x && bounds.right + rightPadding >= point.x
        && bounds.top - topPadding <= point.y && bounds.bottom + bottomPadding >= point.y;
}
/**
 * addPhase method \
 *
 * @returns {void} addPhase method .\
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {NodeModel} parent - provide the cell  value.
 * @param {PhaseModel} newPhase - provide the point  value.
 * @private
 */
function addPhase(diagram, parent, newPhase) {
    if (parent.shape.type === 'SwimLane') {
        var gridRowIndex = void 0;
        var phaseNode = void 0;
        var phase = void 0;
        var previousPhase = void 0;
        var nextPhase = void 0;
        var phaseIndex = void 0;
        var i = void 0;
        var x = parent.wrapper.bounds.x;
        var y = parent.wrapper.bounds.y;
        var shape = parent.shape;
        var padding = shape.padding;
        var phasesCollection = shape.phases;
        var width = void 0;
        var grid = parent.wrapper.children[0];
        var orientation_2 = shape.orientation === 'Horizontal' ? true : false;
        gridRowIndex = (shape.header && shape.hasHeader) ? 0 : -1;
        if (shape.phases.length > 0) {
            gridRowIndex += 1;
        }
        var laneHeaderSize = (orientation_2) ? shape.lanes[0].header.width : shape.lanes[0].header.height;
        if (newPhase.offset > laneHeaderSize) {
            for (i = 0; i < phasesCollection.length; i++) {
                phase = phasesCollection[parseInt(i.toString(), 10)];
                previousPhase = (i > 0) ? phasesCollection[i - 1] : phase;
                if (phase.offset > newPhase.offset) {
                    width = (i > 0) ? newPhase.offset - previousPhase.offset : newPhase.offset;
                    if (orientation_2) {
                        var nextCol = grid.columnDefinitions()[parseInt(i.toString(), 10)];
                        nextCol.width -= width;
                        nextPhase = diagram.nameTable[shape.phases[parseInt(i.toString(), 10)].header.id];
                        nextPhase.maxWidth = nextPhase.wrapper.maxWidth = nextCol.width;
                        grid.updateColumnWidth(i, nextCol.width, false);
                        var addPhase_1 = new ColumnDefinition();
                        addPhase_1.width = width;
                        phaseIndex = i;
                        grid.addColumn(i, addPhase_1, false);
                        break;
                    }
                    else {
                        var nextRow = grid.rowDefinitions()[i + gridRowIndex];
                        nextRow.height -= width;
                        nextPhase = diagram.nameTable[shape.phases[parseInt(i.toString(), 10)].header.id];
                        grid.updateRowHeight(i + gridRowIndex, nextRow.height, false);
                        var addPhase_2 = new RowDefinition();
                        addPhase_2.height = width;
                        phaseIndex = i;
                        grid.addRow(i + gridRowIndex, addPhase_2, false);
                        break;
                    }
                }
            }
            if (diagram.diagramActions & DiagramAction.UndoRedo && phaseIndex === undefined) {
                var entry = diagram.historyManager.currentEntry.next;
                if (entry.isLastPhase) {
                    phaseIndex = phasesCollection.length;
                    addLastPhase(phaseIndex, parent, entry, grid, orientation_2);
                }
            }
            //897967: Exception throws while perform addPhase with offset higher than existing phases offset
            if (phaseIndex >= 0) {
                var phaseObj = new Phase((parent.shape), 'phases', newPhase, true);
                if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {
                    phaseObj.id += randomId();
                }
                shape.phases.splice(phaseIndex, 0, phaseObj);
                phaseDefine(grid, diagram, parent, gridRowIndex, orientation_2, phaseIndex);
                if (orientation_2) {
                    phaseNode = diagram.nameTable[grid.rows[parseInt(gridRowIndex.toString(), 10)].cells[parseInt(phaseIndex.toString(), 10)].children[0].id];
                    if (phaseIndex === 0 && shape.header && shape.hasHeader) {
                        grid.rows[0].cells[0].children = grid.rows[0].cells[1].children;
                        grid.rows[0].cells[1].children = [];
                        var fristRow = grid.rows[0];
                        for (var i_2 = 0; i_2 < fristRow.cells.length; i_2++) {
                            fristRow.cells[parseInt(i_2.toString(), 10)].minWidth = undefined;
                            if (i_2 === 0) {
                                fristRow.cells[parseInt(i_2.toString(), 10)].columnSpan = grid.rows[0].cells.length;
                            }
                            else {
                                fristRow.cells[parseInt(i_2.toString(), 10)].columnSpan = 1;
                            }
                        }
                    }
                    addHorizontalPhase(diagram, parent, grid, phaseIndex, orientation_2, newPhase);
                    var col = grid.columnDefinitions();
                    grid.updateColumnWidth(phaseIndex, col[parseInt(phaseIndex.toString(), 10)].width, true, padding);
                    phaseNode.maxWidth = phaseNode.wrapper.maxWidth = col[parseInt(phaseIndex.toString(), 10)].width;
                    if (col.length > phaseIndex + 1) {
                        var nextPhaseNode = diagram.nameTable[grid.rows[parseInt(gridRowIndex.toString(), 10)].cells[phaseIndex + 1].children[0].id];
                        grid.updateColumnWidth(phaseIndex + 1, col[phaseIndex + 1].width, true, padding);
                        nextPhaseNode.maxWidth = nextPhaseNode.wrapper.maxWidth = col[phaseIndex + 1].width;
                    }
                    parent.width = parent.wrapper.width = parent.wrapper.children[0].width = grid.width;
                }
                else {
                    phaseNode = diagram.nameTable[grid.rows[gridRowIndex + phaseIndex].cells[0].children[0].id];
                    var row = grid.rowDefinitions();
                    var size = row[gridRowIndex + phaseIndex].height;
                    addVerticalPhase(diagram, parent, grid, gridRowIndex + phaseIndex, orientation_2, newPhase);
                    grid.updateRowHeight(gridRowIndex + phaseIndex, size, true, padding);
                    if (row.length > gridRowIndex + phaseIndex + 1) {
                        size = row[gridRowIndex + phaseIndex + 1].height;
                        grid.updateRowHeight(gridRowIndex + phaseIndex + 1, size, true, padding);
                    }
                    parent.height = parent.wrapper.height = parent.wrapper.children[0].height = grid.actualSize.height;
                }
                swimLaneMeasureAndArrange(parent);
                parent.width = parent.wrapper.actualSize.width;
                updateHeaderMaxWidth(diagram, parent);
                diagram.drag(parent, x - parent.wrapper.bounds.x, y - parent.wrapper.bounds.y);
                checkPhaseOffset(parent, diagram);
                //911372-Lane Selector not updated after adding new phase at runtime
                diagram.commandHandler.select(phaseNode);
                if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {
                    var entry = {
                        type: 'PhaseCollectionChanged', changeType: 'Insert', undoObject: cloneObject(phaseObj),
                        redoObject: cloneObject(phaseNode), category: 'Internal'
                    };
                    diagram.addHistoryEntry(entry);
                }
                diagram.updateDiagramObject(parent);
            }
        }
    }
}
/**
 * addLastPhase method \
 *
 * @returns {void} addLastPhase method .\
 * @param {number} phaseIndex - provide the diagram  value.
 * @param {NodeModel} parent - provide the cell  value.
 * @param {HistoryEntry} entry - provide the point  value.
 * @param {GridPanel} grid - provide the grid  value.
 * @param {boolean} orientation - provide the orientation  value.
 * @param {PhaseModel} newPhase - provide the newPhase  value.
 * @private
 */
function addLastPhase(phaseIndex, parent, entry, grid, orientation, newPhase) {
    var shape = parent.shape;
    var prevPhase = shape.phases[phaseIndex - 2];
    var prevOffset = entry.previousPhase.offset;
    if (orientation) {
        var nextCol = grid.columnDefinitions()[phaseIndex - 1];
        var addPhase_3 = new ColumnDefinition();
        if (phaseIndex > 1) {
            addPhase_3.width = (nextCol.width) - (prevOffset - prevPhase.offset);
            nextCol.width = prevOffset - prevPhase.offset;
        }
        else {
            addPhase_3.width = nextCol.width - prevOffset;
            nextCol.width = prevOffset;
        }
        grid.updateColumnWidth(phaseIndex - 1, nextCol.width, false);
        grid.addColumn(phaseIndex, addPhase_3, false);
    }
    else {
        var nextCol = grid.rowDefinitions()[parseInt(phaseIndex.toString(), 10)];
        var addPhase_4 = new RowDefinition();
        if (phaseIndex > 1) {
            addPhase_4.height = entry.undoObject.offset - prevOffset;
            nextCol.height = prevOffset - prevPhase.offset;
        }
        else {
            addPhase_4.height = nextCol.height - prevOffset;
            nextCol.height = prevOffset;
        }
        grid.updateRowHeight(phaseIndex, nextCol.height, false);
        grid.addRow(1 + phaseIndex, addPhase_4, false);
    }
}
/**
 * addHorizontalPhase method \
 *
 * @returns {void} addHorizontalPhase method .\
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {NodeModel} node - provide the cell  value.
 * @param {GridPanel} grid - provide the point  value.
 * @param {number} index - provide the point  value.
 * @param {boolean} orientation - provide the point  value.
 * @param {PhaseModel} newPhase - provide the phase value.
 * @private
 */
function addHorizontalPhase(diagram, node, grid, index, orientation, newPhase) {
    var shape = node.shape;
    var nextCell;
    var i;
    var prevCell;
    var gridCell;
    var row;
    var laneIndex = findStartLaneIndex(node);
    if (shape.header && shape.hasHeader) {
        grid.rows[0].cells[0].columnSpan = grid.rows[0].cells.length;
    }
    for (i = laneIndex; i < grid.rows.length; i++) {
        row = grid.rows[parseInt(i.toString(), 10)];
        prevCell = row.cells[index - 1];
        gridCell = row.cells[parseInt(index.toString(), 10)];
        nextCell = row.cells[index + 1];
        addSwimlanePhases(diagram, node, prevCell, gridCell, nextCell, i, index, newPhase);
    }
    ChangeLaneIndex(diagram, node, 1);
}
/**
 * addVerticalPhase method \
 *
 * @returns {void} addVerticalPhase method .\
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {NodeModel} node - provide the cell  value.
 * @param {GridPanel} grid - provide the point  value.
 * @param {number} rowIndex - provide the point  value.
 * @param {boolean} orientation - provide the point  value.
 * @param {PhaseModel} newPhase - provide the phase value.
 * @private
 */
function addVerticalPhase(diagram, node, grid, rowIndex, orientation, newPhase) {
    var prevCell;
    var gridCell;
    var nextCell;
    var row = grid.rows[parseInt(rowIndex.toString(), 10)];
    var nextRow = grid.rows[rowIndex + 1];
    var prevRow = grid.rows[rowIndex - 1];
    for (var i = 1; i < row.cells.length; i++) {
        gridCell = row.cells[parseInt(i.toString(), 10)];
        nextCell = (nextRow) ? nextRow.cells[parseInt(i.toString(), 10)] : undefined;
        prevCell = (prevRow) ? prevRow.cells[parseInt(i.toString(), 10)] : undefined;
        addSwimlanePhases(diagram, node, prevCell, gridCell, nextCell, rowIndex, i, newPhase);
    }
    ChangeLaneIndex(diagram, node, 1);
}
/**
 * addSwimlanePhases method \
 *
 * @returns {void} addSwimlanePhases method .\
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {NodeModel} node - provide the node  value.
 * @param {GridPanel} prevCell - provide the prevCell  value.
 * @param {number} gridCell - provide the gridCell  value.
 * @param {boolean} nextCell - provide the nextCell  value.
 * @param {boolean} rowIndex - provide the rowIndex  value.
 * @param {boolean} columnIndex - provide the columnIndex  value.
 * @param {PhaseModel} newPhase - provide the phase value.
 * @private
 */
function addSwimlanePhases(diagram, node, prevCell, gridCell, nextCell, rowIndex, columnIndex, newPhase) {
    var x;
    var y;
    var shape = node.shape;
    var orientation = shape.orientation === 'Horizontal' ? true : false;
    var grid = node.wrapper.children[0];
    var width = gridCell.desiredCellWidth;
    var height = gridCell.desiredCellHeight;
    //const col: number = (orientation) ? rowIndex : columnIndex;
    //let parentWrapper: Container;
    var j;
    var i = (orientation) ? node.shape.hasHeader ? rowIndex : rowIndex + 1 : columnIndex;
    if (prevCell) {
        x = orientation ? prevCell.bounds.x + prevCell.bounds.width : prevCell.bounds.x;
        y = orientation ? prevCell.bounds.y : prevCell.bounds.y + prevCell.bounds.height;
    }
    else {
        x = grid.bounds.x;
        y = nextCell.bounds.y;
    }
    var rect = new Rect(x, y, width, height);
    // Bug-908135: Redoing the undoed phase collection followed by node collection threw exception.
    var tempRowIndex = node.shape.hasHeader ? rowIndex - 1 : rowIndex;
    var laneId = node.id + ((orientation) ? shape.lanes[i - 2] : shape.lanes[i - 1]).id;
    var tempID = (orientation ? (columnIndex - 1) : (tempRowIndex - 1)).toString() +
        (orientation ? columnIndex : tempRowIndex).toString();
    var canvasID = laneId + tempID;
    while (Object.prototype.hasOwnProperty.call(diagram.nameTable, canvasID)) {
        tempID = (orientation ? (columnIndex - 1) : (tempRowIndex - 1)).toString() + tempID;
        canvasID = laneId + tempID;
    }
    var canvas = {
        id: canvasID,
        rowIndex: rowIndex, columnIndex: columnIndex,
        width: gridCell.minWidth, height: gridCell.minHeight,
        style: ((orientation) ? shape.lanes[i - 2] : shape.lanes[i - 1]).style,
        constraints: NodeConstraints.Default | NodeConstraints.AllowDrop,
        container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }
    };
    var headerIndex = shape.hasHeader ? 0 : -1;
    //To set the old lane id while creating lanes in undo-redo
    if (newPhase.laneGrids && newPhase.laneGrids.length > 0) {
        var index = orientation ? (rowIndex - (2 + headerIndex)) : columnIndex - 1;
        if (!diagram.nameTable[newPhase.laneGrids[parseInt(index.toString(), 10)]]) {
            canvas.id = newPhase.laneGrids[parseInt(index.toString(), 10)];
        }
    }
    //To store the lane ids in a collection while creating phase lanes
    var phaseIndex = orientation ? columnIndex : rowIndex - 1;
    if (shape.phases[parseInt(phaseIndex.toString(), 10)]) {
        var phase = diagram.nameTable[shape.phases[parseInt(phaseIndex.toString(), 10)].header.id];
        if (phase) {
            phase.laneGrids.push(canvas.id);
        }
    }
    var parentWrapper = addObjectToGrid(diagram, grid, node, canvas, false, false, true);
    parentWrapper.children[0].isCalculateDesiredSize = false;
    grid.addObject(parentWrapper, rowIndex, columnIndex);
    if (nextCell && nextCell.children && nextCell.children.length) {
        for (j = 0; j < nextCell.children.length; j++) {
            if (orientation) {
                diagram.nameTable[nextCell.children[parseInt(j.toString(), 10)].id].columnIndex += 1;
            }
            else {
                diagram.nameTable[nextCell.children[parseInt(j.toString(), 10)].id].rowIndex += 1;
            }
        }
    }
    arrangeChildInGrid(diagram, nextCell, gridCell, rect, parentWrapper, orientation, prevCell);
}
/**
 * arrangeChildInGrid method \
 *
 * @returns {void} arrangeChildInGrid method .\
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {GridCell} nextCell - provide the nextCell  value.
 * @param {GridPanel} gridCell - provide the gridCell  value.
 * @param {Rect} rect - provide the rect  value.
 * @param {Container} parentWrapper - provide the parentWrapper  value.
 * @param {boolean} orientation - provide the orientation  value.
 * @param {GridCell} prevCell - provide the prevCell  value.
 * @private
 */
function arrangeChildInGrid(diagram, nextCell, gridCell, rect, parentWrapper, orientation, prevCell) {
    var child;
    var point;
    var childNode;
    var parent = diagram.nameTable[parentWrapper.id];
    var changeCell = (!nextCell) ? prevCell : nextCell;
    var swimLane = diagram.nameTable[parent.parentId];
    var padding = swimLane.shape.padding;
    if (changeCell.children && changeCell.children[0].children.length > 1) {
        for (var j = 1; j < changeCell.children[0].children.length; j++) {
            child = changeCell.children[0].children[parseInt(j.toString(), 10)];
            childNode = diagram.nameTable[child.id];
            point = (orientation) ? { x: child.bounds.x, y: child.bounds.center.y } :
                { x: child.bounds.center.x, y: child.bounds.top };
            if (rect.containsPoint(point)) {
                gridCell.children[0].children.push(child);
                changeCell.children[0].children.splice(j, 1);
                j--;
                diagram.deleteChild(childNode, undefined, true);
                if (!childNode.isLane) {
                    childNode.parentId = parentWrapper.id;
                }
                if (!parent.children) {
                    parent.children = [];
                }
                if (!nextCell) {
                    if (orientation) {
                        childNode.margin.left = childNode.wrapper.bounds.x - changeCell.children[0].bounds.right;
                    }
                    else {
                        childNode.margin.top = childNode.wrapper.bounds.y - changeCell.children[0].bounds.bottom;
                    }
                }
                parent.children.push(child.id);
                childNode.zIndex = parent.zIndex + 1;
                diagram.removeElements(childNode);
            }
            else if (nextCell) {
                if (orientation) {
                    childNode.margin.left -= gridCell.desiredCellWidth;
                    if (padding > childNode.margin.left) {
                        childNode.margin.left = padding;
                    }
                }
                else {
                    childNode.margin.top -= gridCell.desiredCellHeight;
                    if (padding > childNode.margin.top) {
                        childNode.margin.top = padding;
                    }
                }
            }
        }
    }
}
/**
 * swimLaneSelection method \
 *
 * @returns {void} swimLaneSelection method .\
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {NodeModel} node - provide the node  value.
 * @param {string} corner - provide the corner  value.
 * @private
 */
function swimLaneSelection(diagram, node, corner) {
    if (node.shape.type === 'SwimLane' && (corner === 'ResizeSouth' || corner === 'ResizeEast')) {
        var shape = node.shape;
        var wrapper = node.wrapper.children[0];
        var child = void 0;
        var index = void 0;
        if (corner === 'ResizeSouth') {
            if (shape.orientation === 'Vertical') {
                child = wrapper.rows[wrapper.rows.length - 1].cells[0];
            }
            else {
                index = wrapper.rows.length - 1;
                child = wrapper.rows[parseInt(index.toString(), 10)].cells[wrapper.rows[parseInt(index.toString(), 10)].cells.length - 1];
            }
        }
        else {
            index = (shape.header && shape.hasHeader) ? 1 : 0;
            child = wrapper.rows[parseInt(index.toString(), 10)].cells[wrapper.rows[parseInt(index.toString(), 10)].cells.length - 1];
        }
        diagram.commandHandler.select(diagram.nameTable[child.children[0].id]);
    }
}
/**
 * pasteSwimLane method \
 *
 * @returns {void} pasteSwimLane method .\
 * @param {Diagram} swimLane - provide the diagram  value.
 * @param {NodeModel} diagram - provide the diagram  value.
 * @param {string} clipboardData - provide the clipboardData  value.
 * @param {string} laneNode - provide the laneNode  value.
 * @param {string} isLane - provide the isLane  value.
 * @param {string} isUndo - provide the isUndo  value.
 * @private
 */
function pasteSwimLane(swimLane, diagram, clipboardData, laneNode, isLane, isUndo) {
    var i;
    var j;
    var lane;
    var phase;
    var node;
    var ranId = randomId();
    var cloneLane;
    var childX;
    var childY;
    var shape = swimLane.shape; //let lanes: LaneModel[];
    var phases = shape.phases;
    var nodeX = swimLane.offsetX - swimLane.wrapper.actualSize.width / 2;
    var nodeY = swimLane.offsetY - swimLane.wrapper.actualSize.height / 2;
    var childNodeIds = [];
    if (shape.orientation === 'Vertical') {
        nodeY += (shape.header && shape.hasHeader) ? shape.header.height : 0;
    }
    if (!isUndo) {
        if (!isLane) {
            swimLane.id += ranId;
            if (shape && shape.header && shape.hasHeader) {
                shape.header.id += ranId;
            }
            else {
                shape.header = undefined;
            }
        }
        for (i = 0; phases && i < phases.length; i++) {
            phase = phases[parseInt(i.toString(), 10)];
            phase.id += ranId;
        }
    }
    var lanes = (isLane) ? [clipboardData.childTable[laneNode.id]] : shape.lanes;
    for (i = 0; lanes && i < lanes.length; i++) {
        lane = lanes[parseInt(i.toString(), 10)];
        if (!isUndo) {
            lane.id += ranId;
        }
        for (j = 0; lane.children && j < lane.children.length; j++) {
            node = lane.children[parseInt(j.toString(), 10)];
            childNodeIds.push(node.id);
            childX = node.wrapper.offsetX - node.width / 2;
            childY = node.wrapper.offsetY - node.height / 2;
            node.zIndex = Number.MIN_VALUE;
            node.inEdges = node.outEdges = [];
            if (isUndo || (clipboardData && (clipboardData.pasteIndex === 1 || clipboardData.pasteIndex === 0))) {
                if (shape.orientation === 'Vertical') {
                    node.margin.top = childY - nodeY;
                }
                else {
                    node.margin.left = childX - nodeX;
                }
            }
            if (!isUndo) {
                node.id += ranId;
            }
        }
    }
    if (!isUndo) {
        if (isLane) {
            var newShape = {
                lanes: lanes,
                phases: phases, phaseSize: shape.phaseSize,
                type: 'SwimLane', orientation: shape.orientation,
                header: { annotation: { content: 'Title' }, height: 50 }
            };
            cloneLane = { shape: newShape };
            if (shape.orientation === 'Horizontal') {
                //Facing issues with headerless horizontal swimlane paste.
                var headerHeight = 0;
                if (shape.hasHeader) {
                    headerHeight = shape.header.height;
                }
                cloneLane.width = swimLane.wrapper.actualSize.width;
                cloneLane.height = laneNode.wrapper.actualSize.height + headerHeight + shape.phaseSize;
                cloneLane.offsetX = swimLane.wrapper.offsetX + (clipboardData.pasteIndex * 10);
                cloneLane.offsetY = laneNode.wrapper.offsetY + (clipboardData.pasteIndex * 10);
            }
            else {
                cloneLane.width = laneNode.wrapper.actualSize.width;
                cloneLane.height = swimLane.wrapper.actualSize.height;
                cloneLane.offsetX = laneNode.wrapper.offsetX + (clipboardData.pasteIndex * 10);
                cloneLane.offsetY = swimLane.wrapper.offsetY + (clipboardData.pasteIndex * 10);
            }
            swimLane = cloneLane;
        }
        if (clipboardData.pasteIndex !== 0) {
            swimLane.offsetX += 10;
            swimLane.offsetY += 10;
        }
        swimLane.zIndex = Number.MIN_VALUE;
        swimLane = diagram.add(swimLane);
        if (!isLane) {
            for (var _i = 0, _a = Object.keys(clipboardData.childTable); _i < _a.length; _i++) {
                var i_3 = _a[_i];
                var connector = clipboardData.childTable["" + i_3];
                //Internal Bug 909158: Connector disconnects inside swimlane.
                //Added below code to avoid duplicate addition of connector when copy paste multiple swimlanes.
                //Also to properly connect between child nodes of two swimlanes.
                if (connector.parentSwimlaneId && connector.parentSwimlaneId + ranId === swimLane.id) {
                    connector.id += ranId;
                    if (childNodeIds.indexOf(connector.sourceID) !== -1) {
                        connector.sourceID += ranId;
                    }
                    if (childNodeIds.indexOf(connector.targetID) !== -1) {
                        connector.targetID += ranId;
                    }
                    connector.zIndex = Number.MIN_VALUE;
                    diagram.add(connector);
                }
                else if (childNodeIds.indexOf(connector.sourceID) !== -1) {
                    connector.sourceID += ranId;
                }
                else if (childNodeIds.indexOf(connector.targetID) !== -1) {
                    connector.targetID += ranId;
                }
            }
        }
        if (diagram.mode !== 'SVG') {
            diagram.refreshDiagramLayer();
        }
        diagram.select([swimLane]);
    }
    return swimLane;
}
/**
 * gridSelection method \
 *
 * @returns {void} gridSelection method .\
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {SelectorModel} selectorModel - provide the selectorModel  value.
 * @param {string} id - provide the id  value.
 * @param {boolean} isSymbolDrag - provide the isSymbolDrag  value.
 * @private
 */
function gridSelection(diagram, selectorModel, id, isSymbolDrag) {
    var canvas;
    var node = selectorModel.nodes[0];
    if (isSymbolDrag || checkParentAsContainer(diagram, node, true)) {
        var targetnode = void 0;
        var bounds = void 0;
        var swimLaneId = void 0;
        var element = new DiagramElement();
        if (id) {
            swimLaneId = (diagram.nameTable["" + id].parentId);
            targetnode = node = diagram.nameTable["" + id];
        }
        var wrapper = !id ? node.wrapper : targetnode.wrapper;
        var parentNode = diagram.nameTable[swimLaneId || node.parentId];
        if (parentNode && parentNode.container.type === 'Grid') {
            canvas = new Canvas();
            canvas.children = [];
            if (isSymbolDrag || !(node.isHeader)) {
                if ((parentNode.container.orientation === 'Horizontal' && node.isPhase) ||
                    (parentNode.container.orientation === 'Vertical' &&
                        (node.rowIndex > 0 && node.columnIndex > 0 || node.isLane))) {
                    bounds = findBounds(parentNode, (targetnode) ? targetnode.columnIndex : node.columnIndex, (parentNode.shape.header && parentNode.shape.hasHeader) ? true : false);
                    canvas.offsetX = bounds.center.x;
                    canvas.offsetY = bounds.center.y;
                    element.width = bounds.width;
                    element.height = bounds.height;
                }
                else {
                    canvas.offsetX = parentNode.offsetX;
                    canvas.offsetY = wrapper.offsetY;
                    element.width = parentNode.wrapper.actualSize.width;
                    element.height = wrapper.actualSize.height;
                }
            }
            canvas.children.push(element);
            canvas.measure(new Size());
            canvas.arrange(canvas.desiredSize);
        }
    }
    return canvas;
}
/**
 * removeLaneChildNode method \
 *
 * @returns {void} removeLaneChildNode method .\
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {NodeModel} swimLaneNode - provide the diagram  value.
 * @param {NodeModel} currentObj - provide the currentObj  value.
 * @param {NodeModel} isChildNode - provide the isChildNode  value.
 * @param {number} laneIndex - provide the laneIndex  value.
 * @private
 */
function removeLaneChildNode(diagram, swimLaneNode, currentObj, isChildNode, laneIndex) {
    laneIndex = (laneIndex !== undefined) ? laneIndex : findLaneIndex(swimLaneNode, currentObj);
    var preventHistory = false;
    var lanenode = swimLaneNode.shape.lanes[parseInt(laneIndex.toString(), 10)];
    for (var j = lanenode.children.length - 1; j >= 0; j--) {
        if (isChildNode) {
            if (isChildNode.id === lanenode.children[parseInt(j.toString(), 10)].id) {
                lanenode.children.splice(j, 1);
            }
        }
        else {
            diagram.removeDependentConnector(lanenode.children[parseInt(j.toString(), 10)]);
            if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {
                diagram.diagramActions = diagram.diagramActions | DiagramAction.UndoRedo;
                preventHistory = true;
            }
            diagram.remove(lanenode.children[parseInt(j.toString(), 10)]);
            lanenode.children.splice(j, 1);
            if (preventHistory) {
                diagram.diagramActions = diagram.diagramActions & ~DiagramAction.UndoRedo;
            }
        }
    }
}
/**
 * getGridChildren method \
 *
 * @returns {DiagramElement} getGridChildren method .\
 * @param {Diagram} obj - provide the obj  value.
 * @private
 */
function getGridChildren(obj) {
    var children = obj.children[0];
    return children;
}
/**
 * removeSwimLane method \
 *
 * @returns {void} removeSwimLane method .\
 * @param {Diagram} diagram - provide the obj  value.
 * @param {NodeModel} obj - provide the obj  value.
 * @private
 */
function removeSwimLane(diagram, obj) {
    var rows = obj.wrapper.children[0].rows;
    //let preventHistory: boolean = false;
    var node;
    var i;
    var j;
    var k;
    var child;
    var removeNode;
    for (i = 0; i < rows.length; i++) {
        for (j = 0; j < rows[parseInt(i.toString(), 10)].cells.length; j++) {
            child = getGridChildren(rows[parseInt(i.toString(), 10)].cells[parseInt(j.toString(), 10)]);
            if (child && child.children) {
                for (k = child.children.length - 1; k >= 0; k--) {
                    if (child.children[parseInt(k.toString(), 10)].children) {
                        removeNode = diagram.nameTable[child.children[parseInt(k.toString(), 10)].id];
                        if (removeNode) {
                            if (removeNode.isLane) {
                                deleteNode(diagram, removeNode);
                            }
                            else {
                                diagram.removeDependentConnector(removeNode);
                                diagram.diagramActions |= DiagramAction.PreventHistory;
                                if ((removeNode.constraints & NodeConstraints.Delete)) {
                                    diagram.remove(removeNode);
                                }
                                else {
                                    removeChildInContainer(diagram, removeNode, {}, false);
                                }
                                diagram.diagramActions &= ~DiagramAction.PreventHistory;
                            }
                        }
                    }
                }
            }
            if (child) {
                node = diagram.nameTable[child.id];
                if (node) {
                    deleteNode(diagram, node);
                }
            }
        }
    }
}
/**
 * deleteNode method \
 *
 * @returns {void} deleteNode method .\
 * @param {Diagram} diagram - provide the obj  value.
 * @param {NodeModel} node - provide the obj  value.
 * @private
 */
function deleteNode(diagram, node) {
    if (node) {
        diagram.nodes.splice(diagram.nodes.indexOf(node), 1);
        diagram.removeFromAQuad(node);
        diagram.removeObjectsFromLayer(node);
        delete diagram.nameTable[node.id];
        diagram.removeElements(node);
    }
}
/**
 * removeLane method \
 *
 * @returns {void} removeLane method .\
 * @param {Diagram} diagram - provide the obj  value.
 * @param {NodeModel} lane - provide the obj  value.
 * @param {NodeModel} swimLane - provide the obj  value.
 * @param {LaneModel} lanes - provide the obj  value.
 * @private
 */
function removeLane(diagram, lane, swimLane, lanes) {
    var args;
    if (swimLane.shape.type === 'SwimLane') {
        var shape = swimLane.shape;
        var laneIndex = void 0;
        if (shape.lanes.length === 1) {
            diagram.remove(swimLane);
        }
        else {
            var x = swimLane.wrapper.bounds.x;
            var y = swimLane.wrapper.bounds.y;
            var row = void 0;
            var i = void 0;
            var cell = void 0;
            var j = void 0;
            var child = void 0;
            var grid = swimLane.wrapper.children[0];
            laneIndex = (lanes) ? (shape.lanes.indexOf(lanes)) : findLaneIndex(swimLane, lane);
            args = {
                element: lane, cause: diagram.diagramActions, diagramAction: diagram.getDiagramAction(diagram.diagramActions), state: 'Changing', type: 'Removal', cancel: false, laneIndex: laneIndex
            };
            diagram.triggerEvent(DiagramEvent.collectionChange, args);
            if (!args.cancel) {
                var removableLane = shape.lanes[parseInt(laneIndex.toString(), 10)];
                //Bug 876330: After performing cut operations followed by an undo, lanes and nodes in the swimlane are not rendered properly.
                //Here we are removing the children from lane and re-adding it to the lane after getting it from diagram nodes collection.
                //Because the wrapper of nodes are not updated properly after undo operation.
                var removableLaneChild = removableLane.children;
                removableLane.children = [];
                for (var i_4 = 0; i_4 < removableLaneChild.length; i_4++) {
                    var child_1 = diagram.getObject(removableLaneChild[parseInt(i_4.toString(), 10)].id);
                    if (child_1) {
                        removableLane.children.push(child_1);
                    }
                }
                var undoObj = cloneObject(shape.lanes[parseInt(laneIndex.toString(), 10)]);
                removeLaneChildNode(diagram, swimLane, lane, undefined, laneIndex);
                if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {
                    var entry = {
                        type: 'LaneCollectionChanged', changeType: 'Remove', undoObject: undoObj,
                        redoObject: cloneObject(lane), category: 'Internal'
                    };
                    diagram.addHistoryEntry(entry);
                }
                shape.lanes.splice(laneIndex, 1);
                var index = (lane) ? (shape.orientation === 'Horizontal' ? lane.rowIndex : lane.columnIndex) :
                    (findStartLaneIndex(swimLane) + laneIndex);
                if (shape.orientation === 'Horizontal') {
                    row = grid.rows[parseInt(index.toString(), 10)];
                    for (i = 0; i < row.cells.length; i++) {
                        cell = row.cells[parseInt(i.toString(), 10)];
                        if (cell && cell.children.length > 0) {
                            for (j = 0; j < cell.children.length; j++) {
                                child = cell.children[parseInt(j.toString(), 10)];
                                removeChildren(diagram, child);
                                //To remove the lane Id from the laneGrid collection of phase
                                removeLaneGridFromPhase(child, swimLane, diagram);
                            }
                        }
                    }
                    grid.removeRow(index);
                }
                else {
                    swimLane.width = (swimLane.width !== undefined) ?
                        swimLane.width - grid.rows[0].cells[parseInt(index.toString(), 10)].actualSize.width : swimLane.width;
                    for (i = 0; i < grid.rows.length; i++) {
                        cell = grid.rows[parseInt(i.toString(), 10)].cells[parseInt(index.toString(), 10)];
                        if (cell && cell.children.length > 0) {
                            for (j = 0; j < cell.children.length; j++) {
                                child = cell.children[parseInt(j.toString(), 10)];
                                removeChildren(diagram, child);
                                //To remove the lane Id from the laneGrid collection of phase
                                removeLaneGridFromPhase(child, swimLane, diagram);
                            }
                        }
                    }
                    grid.removeColumn(index);
                }
                args = {
                    element: lane, cause: diagram.diagramActions, diagramAction: diagram.getDiagramAction(diagram.diagramActions), state: 'Changed', type: 'Removal', cancel: false, laneIndex: laneIndex
                };
                diagram.triggerEvent(DiagramEvent.collectionChange, args);
                swimLane.width = swimLane.wrapper.width = grid.width;
                swimLane.height = swimLane.wrapper.height = grid.height;
                swimLaneMeasureAndArrange(swimLane);
                if (swimLane.shape.orientation === 'Vertical') {
                    index = 0;
                }
                ChangeLaneIndex(diagram, swimLane, index);
                diagram.drag(swimLane, x - swimLane.wrapper.bounds.x, y - swimLane.wrapper.bounds.y);
                diagram.updateDiagramObject(swimLane);
            }
        }
    }
}
/**
 * removeLaneGridFromPhase method \
 *
 * @returns {void} removeLaneGridFromPhase method .\
 * @param {Canvas} child - provide the child lane value.
 * @param {Swimlane} swimlane - provide the swimlane value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @private
 */
function removeLaneGridFromPhase(child, swimlane, diagram) {
    var id = child.id;
    var phases = swimlane.shape.phases;
    if (phases && phases.length > 0) {
        for (var i = 0; i < phases.length; i++) {
            var phaseId = swimlane.id + phases[parseInt(i.toString(), 10)].id + '_header';
            var phase = diagram.nameTable["" + phaseId];
            var index = phase.laneGrids.indexOf(id);
            if (index !== -1) {
                phase.laneGrids.splice(index, 1);
            }
        }
    }
}
/**
 * removeChildren method \
 *
 * @returns {void} removeChildren method .\
 * @param {Diagram} diagram - provide the obj  value.
 * @param {Canvas} canvas - provide the obj  value.
 * @private
 */
function removeChildren(diagram, canvas) {
    var i;
    var node;
    if (canvas instanceof Canvas) {
        if (canvas.children.length > 0) {
            for (i = 0; i < canvas.children.length; i++) {
                if (canvas.children[parseInt(i.toString(), 10)] instanceof Canvas) {
                    removeChildren(diagram, canvas.children[parseInt(i.toString(), 10)]);
                }
            }
        }
        node = diagram.getObject(canvas.id);
        deleteNode(diagram, node);
    }
}
/**
 * removePhase method \
 *
 * @returns {void} removePhase method .\
 * @param {Diagram} diagram - provide the obj  value.
 * @param {NodeModel} phase - provide the obj  value.
 * @param {NodeModel} swimLane - provide the obj  value.
 * @param {PhaseModel} swimLanePhases - provide the obj  value.
 * @private
 */
function removePhase(diagram, phase, swimLane, swimLanePhases) {
    diagram.protectPropertyChange(true);
    var x = swimLane.wrapper.bounds.x;
    var y = swimLane.wrapper.bounds.y;
    var isLastPhase = false;
    var previousPhase;
    var shape = swimLane.shape;
    var grid = swimLane.wrapper.children[0];
    var phaseIndex = swimLanePhases ? shape.phases.indexOf(swimLanePhases) : findPhaseIndex(phase, swimLane);
    var phaseLength = shape.phases.length;
    if (shape.phases.length > 1) {
        if (phaseIndex === phaseLength - 1) {
            isLastPhase = true;
            previousPhase = cloneObject(shape.phases[phaseIndex - 1]);
        }
        var undoObj = cloneObject(shape.phases[parseInt(phaseIndex.toString(), 10)]);
        shape.phases.splice(phaseIndex, 1);
        if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {
            var entry = {
                type: 'PhaseCollectionChanged', changeType: 'Remove', undoObject: undoObj, previousPhase: previousPhase,
                redoObject: cloneObject(phase), category: 'Internal', isLastPhase: isLastPhase
            };
            //Adding laneGrid colelction values to the undo and redo object to use it for creating the lane ids in undo-redo.
            entry.undoObject.laneGrids = phase.laneGrids;
            entry.redoObject.laneGrids = phase.laneGrids;
            diagram.addHistoryEntry(entry);
        }
        if (shape.orientation === 'Horizontal') {
            removeHorizontalPhase(diagram, grid, phase, phaseIndex);
        }
        else {
            removeVerticalPhase(diagram, grid, phase, phaseIndex, swimLane);
        }
        updateHeaderMaxWidth(diagram, swimLane);
        //878835- selecting swimlane phase after deleting first phase wihtout header throws error
        ChangeLaneIndex(diagram, swimLane, swimLane.isHeader ? 1 : 0);
        checkPhaseOffset(swimLane, diagram);
        diagram.protectPropertyChange(false);
        diagram.updateDiagramObject(swimLane);
    }
}
/**
 * removeHorizontalPhase method \
 *
 * @returns {void} removeHorizontalPhase method .\
 * @param {Diagram} diagram - provide the obj  value.
 * @param {GridPanel} grid - provide the obj  value.
 * @param {NodeModel} phase - provide the obj  value.
 * @param {number} phaseIndex - provide the obj  value.
 * @private
 */
function removeHorizontalPhase(diagram, grid, phase, phaseIndex) {
    var row;
    var cell;
    var prevCell;
    var actualChild; //let prevChild: Canvas;
    var prevCanvas;
    var width;
    phaseIndex = (phaseIndex !== undefined) ? phaseIndex : phase.columnIndex;
    var i;
    var j;
    var k;
    var child;
    var node;
    var object;
    for (i = 0; i < grid.rows.length; i++) {
        row = grid.rows[parseInt(i.toString(), 10)];
        if (row.cells.length > 1) {
            cell = row.cells[parseInt(phaseIndex.toString(), 10)];
            prevCell = (row.cells.length - 1 === phaseIndex) ? row.cells[phaseIndex - 1] :
                row.cells[phaseIndex + 1];
            prevCanvas = prevCell.children[0];
            if (cell.children.length > 0) {
                actualChild = cell.children[0];
                node = diagram.nameTable[actualChild.id];
                if (prevCell.children.length === 0 && cell.children.length > 0) {
                    prevCell.children = cell.children;
                    prevCell.columnSpan = cell.columnSpan - 1;
                }
                else {
                    for (j = 0; j < actualChild.children.length; j++) {
                        child = actualChild.children[parseInt(j.toString(), 10)];
                        if (child instanceof Canvas) {
                            object = diagram.nameTable[child.id];
                            if (!object.isLane) {
                                object.parentId = prevCanvas.id;
                            }
                            if ((row.cells.length - 1 === phaseIndex)) {
                                object.margin.left = object.wrapper.bounds.x - prevCanvas.bounds.x;
                                child.margin.left = object.wrapper.bounds.x - prevCanvas.bounds.x;
                            }
                            prevCanvas.children.push(child);
                            if (diagram.nameTable[prevCanvas.id]) {
                                var parentNode = diagram.nameTable[prevCanvas.id];
                                if (!parentNode.children) {
                                    parentNode.children = [];
                                }
                                parentNode.children.push(child.id);
                            }
                            actualChild.children.splice(j, 1);
                            j--;
                            if (node && node.children && node.children.indexOf(object.id) !== -1) {
                                node.children.splice(node.children.indexOf(object.id), 1);
                            }
                        }
                        if ((row.cells.length - 1 !== phaseIndex)) {
                            for (k = 0; k < prevCanvas.children.length; k++) {
                                var prevChild = prevCanvas.children[parseInt(k.toString(), 10)];
                                if (prevChild instanceof Canvas) {
                                    var prevNode = diagram.nameTable[prevChild.id];
                                    prevNode.margin.left = prevNode.wrapper.bounds.x - actualChild.bounds.x;
                                    prevChild.margin.left = prevNode.wrapper.bounds.x - actualChild.bounds.x;
                                }
                            }
                        }
                    }
                    if (node && node.isPhase) {
                        var object_1 = diagram.nameTable[prevCanvas.id];
                        if (object_1) {
                            prevCanvas.maxWidth = object_1.wrapper.maxWidth = object_1.wrapper.maxWidth += node.wrapper.maxWidth;
                        }
                    }
                    deleteNode(diagram, node);
                }
            }
        }
    }
    var prevWidth = grid.columnDefinitions()[parseInt(phaseIndex.toString(), 10)].width;
    grid.removeColumn(phaseIndex);
    if ((phaseIndex < grid.columnDefinitions().length)) {
        width = grid.columnDefinitions()[parseInt(phaseIndex.toString(), 10)].width;
        width += prevWidth;
        grid.updateColumnWidth(phaseIndex, width, true);
    }
    else {
        width = grid.columnDefinitions()[phaseIndex - 1].width;
        width += prevWidth;
        grid.updateColumnWidth(phaseIndex - 1, width, true);
    }
}
/**
 * removeVerticalPhase method \
 *
 * @returns {void} removeVerticalPhase method .\
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {GridPanel} grid - provide the grid  value.
 * @param {NodeModel} phase - provide the phase  value.
 * @param {number} phaseIndex - provide the phaseIndex  value.
 * @param {number} swimLane - provide the swimLane  value.
 * @private
 */
function removeVerticalPhase(diagram, grid, phase, phaseIndex, swimLane) {
    var cell;
    var height;
    var i;
    var j;
    var k;
    var prevCell;
    var prevChild;
    var shape = swimLane.shape;
    var child;
    var object;
    var phaseRowIndex = (phaseIndex !== undefined) ? ((shape.header) ? phaseIndex + 1 : phaseIndex) : phase.rowIndex;
    var row = grid.rows[parseInt(phaseRowIndex.toString(), 10)];
    var top = swimLane.wrapper.bounds.y;
    var phaseCount = shape.phases.length;
    if (shape.header !== undefined && shape.hasHeader) {
        top += grid.rowDefinitions()[0].height;
    }
    var prevRow = (phaseIndex === phaseCount) ? grid.rows[phaseRowIndex - 1] : grid.rows[phaseRowIndex + 1];
    for (i = 0; i < row.cells.length; i++) {
        cell = row.cells[parseInt(i.toString(), 10)];
        prevCell = prevRow.cells[parseInt(i.toString(), 10)];
        prevChild = prevCell.children[0];
        if (cell.children.length > 0) {
            var children = cell.children[0];
            var node = diagram.nameTable[children.id];
            if (phaseIndex < phaseCount) {
                for (k = 0; k < prevChild.children.length; k++) {
                    child = prevChild.children[parseInt(k.toString(), 10)];
                    if (child instanceof Canvas) {
                        object = diagram.nameTable[child.id];
                        object.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : children.bounds.y);
                        child.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : children.bounds.y);
                    }
                }
            }
            for (j = 0; j < children.children.length; j++) {
                child = children.children[parseInt(j.toString(), 10)];
                if (child instanceof Canvas) {
                    object = diagram.nameTable[child.id];
                    object.parentId = prevChild.id;
                    if (phaseIndex === phaseCount) {
                        object.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : prevChild.bounds.y);
                        child.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : prevChild.bounds.y);
                    }
                    prevChild.children.push(child);
                    children.children.splice(j, 1);
                    j--;
                    if (node.children && node.children.indexOf(object.id) !== -1) {
                        node.children.splice(node.children.indexOf(object.id), 1);
                    }
                }
            }
            deleteNode(diagram, node);
        }
    }
    var prevHeight = grid.rowDefinitions()[parseInt(phaseRowIndex.toString(), 10)].height;
    grid.removeRow(phaseRowIndex);
    if ((phaseRowIndex < grid.rowDefinitions().length)) {
        height = grid.rowDefinitions()[parseInt(phaseRowIndex.toString(), 10)].height;
        height += prevHeight;
        grid.updateRowHeight(phaseRowIndex, height, true);
    }
    else {
        height = grid.rowDefinitions()[phaseRowIndex - 1].height;
        height += prevHeight;
        grid.updateRowHeight(phaseRowIndex - 1, height, true);
    }
}
/**
 * considerSwimLanePadding method \
 *
 * @returns {void} considerSwimLanePadding method .\
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {NodeModel} node - provide the grid  value.
 * @param {number} padding - provide the phase  value.
 * @private
 */
function considerSwimLanePadding(diagram, node, padding) {
    var lane = diagram.nameTable[node.parentId];
    if (lane && lane.isLane) {
        var swimLane = diagram.nameTable[lane.parentId];
        var grid = swimLane.wrapper.children[0];
        //let x: number = swimLane.wrapper.bounds.x; let y: number = swimLane.wrapper.bounds.y;
        if (!diagram.multiselect) {
            grid.updateColumnWidth(lane.columnIndex, grid.columnDefinitions()[lane.columnIndex].width, true, padding);
            grid.updateRowHeight(lane.rowIndex, grid.rowDefinitions()[lane.rowIndex].height, true, padding);
        }
        var canvas = lane.wrapper;
        var laneHeader = void 0;
        //For Multi-selected nodes
        node.diffX = node.diffX || 0;
        node.diffY = node.diffY || 0;
        if (node.diffX > 0) {
            node.margin.left += (node.diffX + padding);
        }
        if (node.diffY > 0) {
            node.margin.top += (node.diffY + padding);
        }
        if (node.margin.left < padding) {
            node.margin.left = padding;
        }
        if (node.margin.top < padding) {
            node.margin.top = padding;
        }
        for (var i = 0; i < canvas.children.length; i++) {
            var child = canvas.children[parseInt(i.toString(), 10)];
            if (child instanceof Canvas) {
                var childNode = diagram.nameTable[child.id];
                if (childNode.isLane) {
                    laneHeader = childNode.wrapper;
                    break;
                }
            }
        }
        if (laneHeader) {
            if (swimLane.shape.orientation === 'Horizontal') {
                if (node.margin.left < padding + laneHeader.actualSize.width) {
                    node.margin.left = padding + laneHeader.actualSize.width;
                }
            }
            else {
                if (node.margin.top < padding + laneHeader.actualSize.height) {
                    node.margin.top = padding + laneHeader.actualSize.height;
                }
            }
        }
        swimLane.wrapper.measure(new Size(swimLane.width, swimLane.height));
        swimLane.wrapper.arrange(swimLane.wrapper.desiredSize);
        node.offsetX = node.wrapper.offsetX;
        node.offsetY = node.wrapper.offsetY;
        diagram.nodePropertyChange(node, {}, { margin: { left: node.margin.left, top: node.margin.top } });
        node.isResized = false;
        //EJ2-68372- Text-Annotation in event node is not positioned properly while drag the swimlane
        // if (diagram.bpmnModule && node.shape.type === 'Bpmn' && (node.shape as BpmnShapeModel).annotations &&  (node.shape as BpmnShapeModel).annotations.length > 0) {
        //     diagram.nodePropertyChange(node as Node, {} as Node, { margin: { left: node.margin.left, top: node.margin.top } } as Node);
        // }
        grid.measure(new Size(grid.width, grid.height));
        grid.arrange(grid.desiredSize);
        swimLane.width = swimLane.wrapper.width = swimLane.wrapper.children[0].actualSize.width;
        swimLane.height = swimLane.wrapper.height = swimLane.wrapper.children[0].actualSize.height;
    }
}
/**
 * checkLaneChildrenOffset method \
 *
 * @returns {void} checkLaneChildrenOffset method .\
 * @param {NodeModel} swimLane - provide the diagram  value.
 * @private
 */
function checkLaneChildrenOffset(swimLane) {
    if (swimLane.shape.type === 'SwimLane') {
        var lanes = swimLane.shape.lanes;
        var lane = void 0;
        var child = void 0;
        for (var i = 0; i < lanes.length; i++) {
            lane = lanes[parseInt(i.toString(), 10)];
            for (var j = 0; j < lane.children.length; j++) {
                child = lane.children[parseInt(j.toString(), 10)];
                child.offsetX = child.wrapper.offsetX;
                child.offsetY = child.wrapper.offsetY;
            }
        }
    }
}
/**
 * findLane method \
 *
 * @returns {LaneModel} findLane method .\
 * @param {Node} laneNode - provide the laneNode  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @private
 */
function findLane(laneNode, diagram) {
    var lane;
    if (laneNode.isLane) {
        var swimLane = diagram.getObject(laneNode.parentId);
        if (swimLane && swimLane.shape.type === 'SwimLane' && laneNode.isLane) {
            var laneIndex = findLaneIndex(swimLane, laneNode);
            lane = swimLane.shape.lanes[parseInt(laneIndex.toString(), 10)];
        }
    }
    return lane;
}
/**
 * Checks if node and its parent got selected
 *
 * @param {Node} node - node to check, if its parent got selected with it.
 * @param {Diagram} diagram - provide the diagram value.
 * @returns {boolean} whether node and its parent got selected or not.
 * @private
 */
function isParentNodeSelected(node, diagram) {
    return node.parentId && diagram.selectedItems.nodes.indexOf(diagram.nameTable[node.parentId]) !== -1;
}
/**
 * Checks two different sub lane nodes are a representation of the same lane.
 *
 * @param {Node} node1 - Provide the node to compare to.
 * @param {Node} node2 - Provide the node to compare with.
 * @param {Diagram} diagram - Provide the diagram value.
 * @returns {boolean} Whether two nodes are representation of the same lane.
 * @private
 */
function checkSameLaneNodes(node1, node2, diagram) {
    if ((node1.isLane && node2.isLane) && node1.id !== node2.id && node1.parentId === node2.parentId) {
        if (findLane(node1, diagram) === findLane(node2, diagram)) {
            return true;
        }
    }
    return false;
}
/**
 * canLaneInterchange method \
 *
 * @returns {boolean} canLaneInterchange method .\
 * @param {Node} laneNode - provide the laneNode  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @private
 */
function canLaneInterchange(laneNode, diagram) {
    if (laneNode.isLane) {
        var lane = findLane(laneNode, diagram);
        var eventHandler = 'eventHandler';
        var resize = diagram["" + eventHandler].action;
        var canResize = resize.includes('Resize');
        if (canResize || lane.canMove) {
            return true;
        }
    }
    return false;
}
/**
 * updateSwimLaneChildPosition method \
 *
 * @returns {void} updateSwimLaneChildPosition method .\
 * @param {Lane[]} lanes - provide the laneNode  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @private
 */
function updateSwimLaneChildPosition(lanes, diagram) {
    var lane;
    var node;
    for (var i = 0; i < lanes.length; i++) {
        lane = lanes[parseInt(i.toString(), 10)];
        for (var j = 0; j < lane.children.length; j++) {
            node = diagram.nameTable[lane.children[parseInt(j.toString(), 10)].id];
            node.offsetX = node.wrapper.offsetX;
            node.offsetY = node.wrapper.offsetY;
        }
    }
}

/**
 * Interaction for Container
 */
//#region canvas Container interaction
/**
 * updateCanvasBounds method\
 *
 * @returns {  void }    updateCanvasBounds method .\
 * @param {Diagram} diagram - provide the diagram value.
 * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.
 * @param {PointModel} position - provide the position value.
 * @param {boolean} isBoundsUpdate - provide the isBoundsUpdate value.
 * @private
 */
function updateCanvasBounds(diagram, obj, position, isBoundsUpdate) {
    var container;
    var connectorList = [];
    var groupAction = false;
    if (checkParentAsContainer(diagram, obj, true)) {
        diagram.protectPropertyChange(true);
        container = diagram.nameTable[obj.parentId];
        var wrapper = container.wrapper;
        if (diagram.selectedItems.nodes.length > 1) {
            diagram.multiselect = true;
        }
        else {
            diagram.multiselect = false;
        }
        if (container && container.container.type === 'Canvas') {
            if ((isBoundsUpdate || (wrapper.bounds.x <= position.x && wrapper.bounds.right >= position.x &&
                (wrapper.bounds.y <= position.y && wrapper.bounds.bottom >= position.y) && !diagram.multiselect))) {
                var parentWrapper = void 0;
                var y = wrapper.bounds.y;
                var x = wrapper.bounds.x;
                var parent_1 = diagram.nameTable[container.parentId] || container;
                var shape = parent_1.shape;
                if (shape.type === 'SwimLane') {
                    groupAction = updateLaneBoundsAfterAddChild(container, parent_1, obj, diagram, true);
                }
                else {
                    var parent_2 = diagram.nameTable[container.parentId] || container;
                    var shape_1 = parent_2.shape;
                    parentWrapper = parent_2.wrapper;
                    if (wrapper.actualSize.width < wrapper.outerBounds.width &&
                        (!(wrapper.bounds.x > wrapper.outerBounds.x))) {
                        if (container.rowIndex !== undefined) {
                            //const columnIndex:number = parent.columns.length - 1;
                            parentWrapper.updateColumnWidth(container.columnIndex, wrapper.outerBounds.width, true);
                            if (shape_1.orientation === 'Horizontal' && shape_1.phaseSize) {
                                updatePhaseMaxWidth(parent_2, diagram, wrapper, container.columnIndex);
                            }
                            updateHeaderMaxWidth(diagram, parent_2);
                            diagram.drag(parent_2, x - wrapper.bounds.x, y - wrapper.bounds.y);
                        }
                        else {
                            diagram.scale(container, (1 + ((wrapper.outerBounds.width - wrapper.actualSize.width) / wrapper.actualSize.width)), 1, ((wrapper.outerBounds.x < wrapper.bounds.x) ? { x: 1, y: 0.5 } : { x: 0, y: 0.5 }));
                        }
                    }
                    if (wrapper.actualSize.height < wrapper.outerBounds.height &&
                        (!(wrapper.bounds.y > wrapper.outerBounds.y))) {
                        if (container.rowIndex !== undefined) {
                            parentWrapper.updateRowHeight(container.rowIndex, wrapper.outerBounds.height, true);
                            diagram.drag(parent_2, x - wrapper.bounds.x, y - wrapper.bounds.y);
                        }
                        else {
                            diagram.scale(container, 1, (1 + ((wrapper.outerBounds.height - wrapper.actualSize.height) / wrapper.actualSize.height)), ((wrapper.outerBounds.y < wrapper.bounds.y) ? { x: 0.5, y: 1 } : { x: 0.5, y: 0 }));
                        }
                    }
                }
            }
            diagram.select([obj]);
            updateConnectorsProperties(connectorList, diagram);
        }
        diagram.protectPropertyChange(false);
    }
    return groupAction;
}
/**
 * removeChildInContainer method\
 *
 * @returns {  void }    removeChildInContainer method .\
 * @param {Diagram} diagram - provide the diagram value.
 * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.
 * @param {PointModel} position - provide the position value.
 * @param {boolean} isBoundsUpdate - provide the isBoundsUpdate value.
 * @private
 */
function removeChildInContainer(diagram, obj, position, isBoundsUpdate) {
    var container; //let connectorList: string[] = [];
    if (checkParentAsContainer(diagram, obj, true) && !(diagram.cancelPositionChange)) {
        var isProtectedOnChange = 'isProtectedOnChange';
        var propertyChangeValue = diagram["" + isProtectedOnChange];
        diagram.protectPropertyChange(true);
        container = diagram.nameTable[obj.parentId];
        var wrapper = container.wrapper;
        if (container && container.container.type === 'Canvas') {
            if ((!isBoundsUpdate && (!(wrapper.bounds.x <= position.x && wrapper.bounds.right >= position.x &&
                (wrapper.bounds.y <= position.y && wrapper.bounds.bottom >= position.y))))) {
                if (!(obj.constraints & NodeConstraints.AllowMovingOutsideLane)) {
                    var undoObj = cloneObject(obj);
                    diagram.clearSelection();
                    removeChildrenInLane(diagram, obj);
                    obj.parentId = '';
                    //EJ2-65676 - Exception throws on updating node annotation after drag and drop from swimlane to diagram canvas.
                    obj.parentObj = diagram;
                    obj.propName = 'nodes';
                    var entry = {
                        type: 'ChildCollectionChanged', category: 'Internal',
                        undoObject: undoObj, redoObject: cloneObject(obj)
                    };
                    diagram.addHistoryEntry(entry);
                    if (diagram.commandHandler.isContainer) {
                        diagram.commandHandler.isContainer = false;
                        diagram.endGroupAction();
                    }
                    moveSwinLaneChild(obj, diagram);
                }
            }
        }
        diagram.protectPropertyChange(propertyChangeValue);
    }
}
/**
 * findBounds method\
 *
 * @returns {  NodeModel | ConnectorModel  }    findBounds method .\
 * @param {NodeModel} obj - provide the diagram value.
 * @param {number} columnIndex - provide the isVertical value.
 * @param {boolean} isHeader - provide the isVertical value.
 * @private
 */
function findBounds(obj, columnIndex, isHeader) {
    var rect = new Rect();
    var rows = (obj.shape.type === 'SwimLane') ?
        obj.wrapper.children[0].rows : obj.wrapper.rows;
    for (var i = ((isHeader) ? 1 : 0); i < rows.length; i++) {
        rect.uniteRect(rows[parseInt(i.toString(), 10)].cells[parseInt(columnIndex.toString(), 10)].bounds);
    }
    return rect;
}
/**
 * createHelper method\
 *
 * @returns {  NodeModel | ConnectorModel  }    createHelper method .\
 * @param {Diagram} diagram - provide the diagram value.
 * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.
 * @private
 */
function createHelper(diagram, obj) {
    var newObj;
    var cloneObject = {};
    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
        var prop = _a[_i];
        cloneObject["" + prop] = obj["" + prop];
    }
    if (getObjectType(obj) === Node) {
        newObj = new Node(diagram, 'nodes', cloneObject, true);
        newObj.id = obj.id;
        diagram.initObject(newObj);
    }
    diagram.updateDiagramObject(newObj);
    return newObj;
}
/**
 * renderContainerHelper method\
 *
 * @returns {  NodeModel | ConnectorModel  }    renderContainerHelper method .\
 * @param {Diagram} diagram - provide the diagram value.
 * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.
 * @private
 */
function renderContainerHelper(diagram, obj) {
    diagram.enableServerDataBinding(false);
    var object;
    var container;
    var nodes;
    if (!isBlazor()) {
        if (diagram.selectedObject.helperObject) {
            nodes = diagram.selectedObject.helperObject;
        }
        else if (diagram.selectedItems.nodes.length > 0 || diagram.selectedItems.connectors.length > 0) {
            if (obj instanceof Selector && obj.nodes.length + obj.connectors.length === 1) {
                object = (obj.nodes.length > 0) ? obj.nodes[0] : obj.connectors[0];
                container = diagram.selectedItems.wrapper.children[0];
            }
            else {
                object = obj;
                //Removed isBlazor code
                container = diagram.selectedItems.wrapper;
            }
            diagram.selectedObject.actualObject = object;
            // Added below code to render helper object for multiselected nodes inside swimlane to avoid interaction related issues.
            var dragObject = object instanceof Selector
                ? (object.nodes.length > 0 ? object.nodes[0] : object) : object;
            diagram.selectedObject.actualObject = object;
            if ((!diagram.currentSymbol) && (((dragObject.isLane && canLaneInterchange(dragObject, diagram) &&
                checkParentAsContainer(diagram, dragObject))
                || ((!dragObject.isLane) && checkParentAsContainer(diagram, dragObject))) ||
                ((diagram.constraints & DiagramConstraints.LineRouting) && diagram.selectedItems.nodes.length > 0))) {
                var node = {
                    id: 'helper',
                    rotateAngle: container.rotateAngle,
                    offsetX: container.offsetX, offsetY: container.offsetY,
                    minWidth: container.minWidth, minHeight: container.minHeight,
                    maxWidth: container.maxWidth, maxHeight: container.maxHeight,
                    width: container.actualSize.width,
                    height: container.actualSize.height,
                    style: { strokeDashArray: '2 2', fill: 'transparent', strokeColor: '#7D7D7D', strokeWidth: 2 }
                };
                nodes = createHelper(diagram, node);
                diagram.selectedObject.helperObject = nodes;
            }
        }
    }
    diagram.enableServerDataBinding(true);
    return nodes;
}
/**
 * checkParentAsContainer method\
 *
 * @returns {  void  }    checkParentAsContainer method .\
 * @param {Diagram} diagram - provide the diagram value.
 * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.
 * @param {boolean} isChild - provide the isChild value.
 * @private
 */
function checkParentAsContainer(diagram, obj, isChild) {
    var parentNode = (isChild) ? diagram.nameTable[obj.parentId] :
        (diagram.nameTable[obj.parentId] || obj);
    if (parentNode && parentNode.container) {
        return true;
    }
    return false;
}
/**
 * checkChildNodeInContainer method\
 *
 * @returns {  void  }    checkChildNodeInContainer method .\
 * @param {Diagram} diagram - provide the diagram value.
 * @param {NodeModel} obj - provide the isVertical value.
 * @private
 */
function checkChildNodeInContainer(diagram, obj) {
    var parentNode = diagram.nameTable[obj.parentId];
    obj.laneMargin = { left: obj.margin.left, right: obj.margin.right, top: obj.margin.top, bottom: obj.margin.bottom };
    //To handle the resize of bpmn node which has text annotation inside swimlane
    if (obj.hasTextAnnotation) {
        for (var i = 0; i < obj.outEdges.length; i++) {
            var connector = diagram.nameTable[obj.outEdges[parseInt(i.toString(), 10)]];
            if (connector.isBpmnAnnotationConnector) {
                var textNode = diagram.nameTable[connector.targetID];
                var oldObject = { width: obj.wrapper.actualSize.width, height: obj.wrapper.actualSize.height,
                    offsetX: obj.wrapper.offsetX, offsetY: obj.wrapper.offsetY };
                var oldX = obj.wrapper.offsetX;
                var oldY = obj.wrapper.offsetY;
                var offset = diagram.getTextAnnotationOffset(obj, textNode, oldObject, oldX, oldY);
                var difX = offset.x - oldX;
                var difY = offset.y - oldY;
                if (difX || difY || obj.width !== obj.wrapper.actualSize.width || obj.height !== obj.wrapper.actualSize.height) {
                    obj.isResized = true;
                    if (!obj.resizeDif) {
                        obj.resizeDif = [];
                    }
                    obj.resizeDif[textNode.id] = { x: difX, y: difY };
                }
            }
        }
    }
    if (parentNode.container.type === 'Canvas') {
        obj.margin.left = (obj.offsetX - parentNode.wrapper.bounds.x - (obj.width / 2));
        obj.margin.top = (obj.offsetY - parentNode.wrapper.bounds.y - (obj.height / 2));
    }
    diagram.nodePropertyChange(obj, {}, {
        width: obj.width, height: obj.height,
        offsetX: obj.offsetX, offsetY: obj.offsetY,
        margin: {
            left: obj.margin.left,
            right: obj.margin.right, top: obj.margin.top,
            bottom: obj.margin.bottom
        }, rotateAngle: obj.rotateAngle
    });
    //EJ2-913789 - Lane size gets varied upon undo redo the node drop
    if (diagram.undoRedoModule && parentNode.isLane && diagram.undoRedoModule.checkRedo &&
        (obj.margin.left < 0 || obj.margin.top < 0)) {
        removeChildrenInLane(diagram, obj);
    }
    if (!parentNode.isLane) {
        parentNode.wrapper.measure(new Size());
        parentNode.wrapper.arrange(parentNode.wrapper.desiredSize);
    }
}
function removeChildrenInLane(diagram, node) {
    if (node.parentId && node.parentId !== '') {
        var prevParentNode = diagram.nameTable[node.parentId];
        if (prevParentNode.isLane && prevParentNode.parentId) {
            var swimlane = diagram.nameTable[prevParentNode.parentId];
            var canvasId = (prevParentNode.id.slice(swimlane.id.length));
            var prevParentId = canvasId.substring(0, canvasId.length - 1);
            var lanes = swimlane.shape.lanes;
            var lane = void 0;
            for (var i = 0; i < lanes.length; i++) {
                lane = lanes[parseInt(i.toString(), 10)];
                if (prevParentId === lane.id) {
                    for (var j = 0; j < lane.children.length; j++) {
                        if (lane.children[parseInt(j.toString(), 10)].id === node.id) {
                            lane.children.splice(j, 1);
                            j--;
                        }
                    }
                }
            }
        }
        diagram.deleteChild(node);
    }
}
/**
 *
 * @param { NodeModel | ConnectorModel} obj - Provide the obj value.
 * @param { NodeModel } swimlane  - Provide the swimlane value.
 * @param { Diagram } diagram - Provide the diagram value.
 * @returns { void } updateZindex method .\
 * @private
 */
function updateZindex(obj, swimlane, diagram) {
    var objLayer = diagram.commandHandler.getObjectLayer(obj.id);
    var zIndexTable = objLayer.zIndexTable;
    var targetZIndex = swimlane.zIndex + 1;
    // Find a unique zIndex
    while (zIndexTable[parseInt(targetZIndex.toString(), 10)] !== undefined) {
        targetZIndex++;
    }
    // Assign the unique zIndex to the node
    delete objLayer.zIndexTable[obj.zIndex];
    obj.zIndex = targetZIndex;
    objLayer.zIndexTable[parseInt(targetZIndex.toString(), 10)] = obj.id;
}
/**
 * addChildToContainer method\
 *
 * @returns {  void  }    addChildToContainer method .\
 * @param {DiagramElement} diagram - provide the element value.
 * @param {boolean} parent - provide the isVertical value.
 * @param {PointModel} node - provide the node value.
 * @param {Diagram} isUndo - provide the isUndo value.
 * @param {boolean} historyAction - provide the historyAction value.
 * @param {boolean} canUpdateZindex - provide the canUpdateZindex value.
 * @private
 */
function addChildToContainer(diagram, parent, node, isUndo, historyAction, canUpdateZindex) {
    if (!diagram.currentSymbol) {
        diagram.protectPropertyChange(true);
        var swimlane = diagram.nameTable[parent.parentId];
        node = diagram.getObject(node.id) || node;
        //Bug 909155: Issue in connecting nodes with ports.
        //When we add child nodes at runtime and perform undo redo, the child node is not selectable as the zIndex of swimlane is higher than child node.
        //Added below code to update the zIndex of the child node.
        if (swimlane && swimlane.zIndex > node.zIndex && canUpdateZindex) {
            updateZindex(node, swimlane, diagram);
        }
        var child = (diagram.nodes.indexOf(node) !== -1) ? node.id : node;
        if (parent.container.type === 'Canvas' && !historyAction) {
            var left = (node.wrapper.offsetX - node.wrapper.actualSize.width / 2) -
                (parent.wrapper.offsetX - parent.wrapper.actualSize.width / 2);
            var top_1 = (node.wrapper.offsetY - node.wrapper.actualSize.height / 2) -
                (parent.wrapper.offsetY - parent.wrapper.actualSize.height / 2);
            node.margin.left = left;
            node.margin.top = top_1;
        }
        else if (swimlane) {
            var swimLaneBounds = swimlane.wrapper.bounds;
            var parentBounds = parent.wrapper.bounds;
            if (swimlane.shape.orientation === 'Horizontal') {
                node.margin.left -= parentBounds.x - swimLaneBounds.x;
            }
            else {
                var laneHeaderId = parent.parentId + swimlane.shape.lanes[0].id + '_0_header';
                node.margin.top -= parentBounds.y - swimLaneBounds.y - diagram.nameTable["" + laneHeaderId].wrapper.bounds.height;
            }
        }
        var container = diagram.nameTable[parent.id];
        if (!container.children) {
            container.children = [];
        }
        if (container.children.indexOf(node.id) === -1) {
            removeChildrenInLane(diagram, node);
            if (diagram.getObject(node.id)) {
                diagram.removeElements(node);
            }
            var undoObj = cloneObject(node);
            diagram.addChild(container, child);
            node = diagram.getObject(node.id);
            if (container.isLane && container.parentId) {
                swimlane = diagram.nameTable[container.parentId];
                var lanes = swimlane.shape.lanes;
                var canvasId = (container.id.slice(swimlane.id.length));
                var currentParentId = canvasId.substring(0, canvasId.length - 1);
                for (var i = 0; i < lanes.length; i++) {
                    if (container.isLane && currentParentId === lanes[parseInt(i.toString(), 10)].id) {
                        // eslint-disable-next-line
                        if (!(node.parentObj instanceof Diagram)) {
                            // eslint-disable-next-line
                            node.parentObj = lanes[parseInt(i.toString(), 10)];
                        }
                        // 878719: Resolve ESLint errors
                        // eslint-disable-next-line no-prototype-builtins
                        if (!diagram.nameTable.hasOwnProperty(node.id)) {
                            lanes[parseInt(i.toString(), 10)].children.push(node);
                        }
                    }
                }
            }
            diagram.updateDiagramObject(node);
            moveSwinLaneChild(node, diagram);
            if (!container.parentId) {
                diagram.updateDiagramObject(container);
            }
            else if (!isUndo) {
                if (!diagram.multiselect) {
                    updateLaneBoundsAfterAddChild(container, swimlane, node, diagram);
                }
                else {
                    considerSwimLanePadding(diagram, node, 20);
                    diagram.updateDiagramElementQuad();
                }
            }
            if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {
                var entry = {
                    type: 'ChildCollectionChanged', category: 'Internal',
                    undoObject: undoObj, redoObject: cloneObject(node), historyAction: historyAction ? 'AddNodeToLane' : undefined
                };
                diagram.addHistoryEntry(entry);
            }
        }
        else if (!isUndo && diagram.multiselect) {
            considerSwimLanePadding(diagram, node, 20);
            diagram.updateDiagramElementQuad();
        }
        diagram.protectPropertyChange(false);
    }
}
function moveSwinLaneChild(node, diagram) {
    var sourceNode = getDiagramElement(node.id + '_groupElement', diagram.element.id);
    var targetId = (node.parentId) ? node.parentId + '_groupElement' : diagram.element.id + '_diagramLayer';
    var targetNode = getDiagramElement(targetId, diagram.element.id);
    if (sourceNode && targetNode) {
        targetNode.appendChild(sourceNode);
    }
}
function updateLaneBoundsWithSelector(container, selector, diagram, isBoundsUpdate) {
    var swimLane = diagram.nameTable[container.parentId];
    var isSelector = true;
    updateLaneBoundsAfterAddChild(container, swimLane, selector, diagram, isBoundsUpdate, isSelector);
}
function updateLaneBoundsAfterAddChild(container, swimLane, node, diagram, isBoundsUpdate, isSelector) {
    var undoObject = cloneObject(container);
    var isUpdateRow;
    var isUpdateColumn;
    var isGroupAction = false;
    var padding = swimLane.shape.padding;
    var containerBounds = container.wrapper.bounds;
    var containerOuterBounds = container.wrapper.outerBounds;
    var nodeBounds = node.wrapper.bounds;
    if (swimLane && swimLane.shape.type === 'SwimLane' &&
        (containerBounds.right < nodeBounds.right + padding ||
            containerBounds.bottom < nodeBounds.bottom + padding || (isSelector && containerBounds.top > nodeBounds.top + padding))) {
        var grid = swimLane.wrapper.children[0];
        var x = grid.bounds.x;
        var y = grid.bounds.y;
        var size = void 0;
        var headerSize = void 0;
        // EJ2-913788 Drag and drop a node with more size than lane height and width
        var isHeader = container.wrapper.children.find(function (child) { return child.id.includes('header'); });
        var isHorizontal = (swimLane.shape.orientation === 'Horizontal');
        if (containerBounds.right < nodeBounds.right + padding &&
            containerOuterBounds.x <= containerBounds.x) {
            if (isHorizontal && isHeader) {
                headerSize = isHeader ? isHeader.width : 0;
                size = (nodeBounds.right - containerBounds.right) + (containerBounds.left - nodeBounds.left) +
                    headerSize + padding * 2;
            }
            else {
                size = (nodeBounds.right - containerBounds.right) + (containerBounds.left - nodeBounds.left) + padding * 2;
            }
            // size = nodeBounds.right - containerBounds.right;
            isUpdateColumn = true;
            grid.updateColumnWidth(container.columnIndex, containerBounds.width + size, true, padding);
        }
        if (containerBounds.bottom < nodeBounds.bottom + padding &&
            containerOuterBounds.y <= containerBounds.y) {
            if (!isHorizontal && isHeader) {
                headerSize = isHeader ? isHeader.height : 0;
                size = (nodeBounds.bottom - containerBounds.bottom) + (containerBounds.top - nodeBounds.top) +
                    headerSize + padding * 2;
            }
            else {
                size = (nodeBounds.bottom - containerBounds.bottom) + (containerBounds.top - nodeBounds.top) + padding * 2;
            }
            // size = nodeBounds.bottom - containerBounds.bottom;
            isUpdateRow = true;
            grid.updateRowHeight(container.rowIndex, containerBounds.height + size, true, padding);
        }
        if (isSelector && containerBounds.top > nodeBounds.top - padding &&
            containerOuterBounds.y <= containerBounds.y) {
            if (!isHorizontal && isHeader) {
                headerSize = isHeader ? isHeader.height : 0;
                size = (containerBounds.top - nodeBounds.top) + (nodeBounds.bottom - containerBounds.bottom) +
                    headerSize + padding * 2;
            }
            else {
                size = (containerBounds.top - nodeBounds.top) + (nodeBounds.bottom - containerBounds.bottom) + padding * 2;
            }
            // Adjust the size based on the top boundary difference
            if (size > 0) {
                isUpdateRow = true;
                grid.updateRowHeight(container.rowIndex, containerBounds.height + size, true, padding);
            }
        }
        if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {
            if (isBoundsUpdate) {
                diagram.startGroupAction();
                isGroupAction = true;
            }
            if (isUpdateRow) {
                var entry = {
                    category: 'Internal',
                    type: 'RowHeightChanged',
                    undoObject: undoObject, redoObject: cloneObject(container)
                };
                diagram.addHistoryEntry(entry);
            }
            if (isUpdateColumn) {
                var entry = {
                    category: 'Internal',
                    type: 'ColumnWidthChanged',
                    undoObject: undoObject, redoObject: cloneObject(container)
                };
                diagram.addHistoryEntry(entry);
            }
        }
        swimLane.width = swimLane.wrapper.width = grid.width;
        swimLane.height = swimLane.wrapper.height = grid.height;
        swimLaneMeasureAndArrange(swimLane);
        if (swimLane.shape.orientation === 'Horizontal') {
            updatePhaseMaxWidth(swimLane, diagram, container.wrapper, container.columnIndex);
        }
        updateHeaderMaxWidth(diagram, swimLane);
        diagram.drag(swimLane, x - grid.bounds.x, y - grid.bounds.y);
        checkPhaseOffset(swimLane, diagram);
        checkLaneSize(swimLane);
    }
    if (!isSelector) {
        considerSwimLanePadding(diagram, node, padding);
    }
    diagram.updateDiagramElementQuad();
    return isGroupAction;
}
//#endregion
//# reginon stack panel interaction
/**
 * renderStackHighlighter method\
 *
 * @returns {  void  }    renderStackHighlighter method .\
 * @param {DiagramElement} element - provide the element value.
 * @param {boolean} isVertical - provide the isVertical value.
 * @param {PointModel} position - provide the position value.
 * @param {Diagram} diagram - provide the diagram value.
 * @param {boolean} isUml - provide the isUml value.
 * @param {boolean} isSwimlane - provide the isSwimlane value.
 * @private
 */
function renderStackHighlighter(element, isVertical, position, diagram, isUml, isSwimlane) {
    var adornerSvg = getAdornerLayerSvg(diagram.element.id);
    diagram.diagramRenderer.renderStackHighlighter(element, adornerSvg, diagram.scroller.transform, isVertical, position, isUml, isSwimlane);
}
/**
 * moveChildInStack method\
 *
 * @returns {  void }    moveChildInStack method .\
 * @param {Node} sourceNode - provide the sourceNode value.
 * @param {Node} target - provide the target value.
 * @param {Diagram} diagram - provide the diagram value.
 * @param {Actions} action - provide the action value.
 * @private
 */
function moveChildInStack(sourceNode, target, diagram, action) {
    var obj = sourceNode;
    var parent = diagram.nameTable[obj.parentId];
    var sourceParent = diagram.nameTable[obj.parentId];
    if (target && sourceParent && sourceParent.container && sourceParent.container.type === 'Stack' &&
        target.container && target.container.type === 'Stack' && (sourceParent.id !== target.parentId)) {
        var value = sourceParent.wrapper.children.indexOf(obj.wrapper);
        if (value > -1) {
            diagram.nameTable[obj.id].parentId = target.id;
            sourceParent.wrapper.children.splice(value, 1);
        }
    }
    if (target && target.parentId && obj.parentId && action === 'Drag' &&
        sourceParent.container && sourceParent.container.type === 'Stack') {
        var targetIndex = parent.wrapper.children.indexOf(target.wrapper);
        var sourceIndex = parent.wrapper.children.indexOf(obj.wrapper);
        var undoElement = {
            targetIndex: targetIndex, target: target,
            sourceIndex: sourceIndex, source: sourceNode
        };
        parent.wrapper.children.splice(sourceIndex, 1);
        parent.wrapper.children.splice(targetIndex, 0, obj.wrapper);
        var redoElement = {
            targetIndex: sourceIndex, target: target,
            sourceIndex: targetIndex, source: sourceNode
        };
        var entry = {
            type: 'StackChildPositionChanged', redoObject: redoElement,
            undoObject: undoElement, category: 'Internal'
        };
        diagram.commandHandler.addHistoryEntry(entry);
    }
}
//#end region
//# region Swimlane rendering
//#end region

/**
 * Finds the action to be taken for the object under mouse
 *
 */
/* tslint:disable */
/**
 * findToolToActivate method\
 *
 * @returns {Actions}    findToolToActivate method .\
 * @param {Object} obj - provide the options value.
 * @param {DiagramElement} wrapper - provide the options value.
 * @param {PointModel} position - provide the options value.
 * @param {Diagram} diagram - provide the options value.
 * @param {ITouches[] | TouchList} touchStart - provide the options value.
 * @param {ITouches[] | TouchList} touchMove - provide the options value.
 * @param {NodeModel | PointPortModel | ShapeAnnotationModel | PathAnnotationModel} target - provide the options value.
 * @private
 */
function findToolToActivate(obj, wrapper, position, diagram, touchStart, touchMove, target) {
    //let conn: Connector = diagram.selectedItems.connectors[0] as Connector;
    if (touchMove && touchMove.length > 1 && touchStart && touchStart.length > 1) {
        return 'PinchZoom';
    }
    if (diagram.currentSymbol) {
        return 'Drag';
    }
    var eventHandler = 'eventHandler';
    if (diagram["" + eventHandler].action === 'PortDraw') {
        diagram.tool &= ~DiagramTools.DrawOnce;
    }
    //Drawing Tools
    if ((canDrawOnce(diagram) || canContinuousDraw(diagram)) && diagram.drawingObject) {
        return 'Draw';
    }
    if (hasSelection(diagram)) {
        var handle = diagram.selectedItems;
        if (handle.wrapper && canShowCorner(handle.constraints, 'UserHandle')) {
            for (var _i = 0, _a = handle.userHandles; _i < _a.length; _i++) {
                var obj_1 = _a[_i];
                if (obj_1.visible) {
                    var paddedBounds = getUserHandlePosition(handle, obj_1, diagram.scroller.transform);
                    if (contains(position, paddedBounds, obj_1.size / (2 * diagram.scroller.transform.scale))) {
                        return obj_1.name;
                    }
                }
            }
        }
    }
    if (hasSelection(diagram)) {
        var element = (diagram.selectedItems.annotation) ?
            diagram.selectedItems.wrapper.children[0] : diagram.selectedItems.wrapper;
        var selectorBnds = element.bounds;
        var handle = diagram.selectedItems;
        var paddedBounds = new Rect(selectorBnds.x, selectorBnds.y, selectorBnds.width, selectorBnds.height);
        if (hasSingleConnection(diagram) && !diagram.selectedItems.annotation) {
            var conn = diagram.selectedItems.connectors[0];
            var sourcePaddingValue = (diagram.selectedItems.handleSize / 2) / diagram.scrollSettings.currentZoom;
            var targetPaddingValue = (diagram.selectedItems.handleSize / 2) / diagram.scrollSettings.currentZoom;
            if (canShowCorner(handle.constraints, 'ResizeAll')) {
                if ((canShowCorner(handle.constraints, 'ConnectorSourceThumb'))
                    && canDragSourceEnd(conn) && contains(position, conn.sourcePoint, sourcePaddingValue)) {
                    return 'ConnectorSourceEnd';
                }
                if ((canShowCorner(handle.constraints, 'ConnectorTargetThumb'))
                    && canDragTargetEnd(conn) && contains(position, conn.targetPoint, targetPaddingValue)) {
                    return 'ConnectorTargetEnd';
                }
                var action = checkForConnectorSegment(conn, handle, position, diagram);
                if (action !== 'OrthoThumb') {
                    if ((canShowCorner(handle.constraints, 'ConnectorSourceThumb'))
                        && canDragSourceEnd(conn)) {
                        if (action) {
                            return action;
                        }
                    }
                    if ((canShowCorner(handle.constraints, 'ConnectorTargetThumb'))
                        && canDragTargetEnd(conn)) {
                        if (action) {
                            return action;
                        }
                    }
                }
                else {
                    return action;
                }
            }
        }
        else {
            var ten = (diagram.selectedItems.handleSize / 2) / diagram.scroller.currentZoom;
            var tenRotate = 10 / diagram.scroller.currentZoom;
            var matrix = identityMatrix();
            rotateMatrix(matrix, element.rotateAngle + element.parentTransform, element.offsetX, element.offsetY);
            //check for resizing tool
            var x = element.offsetX - element.pivot.x * element.actualSize.width;
            var y = element.offsetY - element.pivot.y * element.actualSize.height;
            var rotateThumb = {
                x: x + ((element.pivot.x === 0.5 ? element.pivot.x * 2 : element.pivot.x) * element.actualSize.width / 2),
                y: y - 30 / diagram.scroller.currentZoom
            };
            rotateThumb = transformPointByMatrix(matrix, rotateThumb);
            var labelSelection = diagram.selectedItems.annotation ? true : false;
            var labelRotate = (labelSelection && (canRotate(diagram.selectedItems.annotation))) ? true : false;
            if (canShowCorner(handle.constraints, 'Rotate') && contains(position, rotateThumb, tenRotate) &&
                (diagram.selectedItems.thumbsConstraints & ThumbsConstraints.Rotate)) {
                if (labelSelection && labelRotate) {
                    return 'LabelRotate';
                }
                else if (!labelSelection) {
                    return 'Rotate';
                }
            }
            paddedBounds.Inflate(ten);
            if (paddedBounds.containsPoint(position)) {
                var action = checkResizeHandles(diagram, element, position, matrix, x, y);
                if (action) {
                    return action;
                }
            }
        }
    }
    //Panning
    if (canZoomPan(diagram) && !obj) {
        return 'Pan';
    }
    //826364 - Drawing Tool is not activated on hovering the ports while both ZoomPan and single select constraints enabled
    if ((target instanceof PointPort || target instanceof PathPort)
        && (!canZoomPan(diagram) || (canSingleSelect(diagram) || canMultiSelect(diagram)))) {
        var action = findPortToolToActivate(diagram, target);
        if (action !== 'None') {
            return action;
        }
    }
    if ((target instanceof ShapeAnnotation || target instanceof PathAnnotation) && (!canZoomPan(diagram) && (canSelect(target)))) {
        if (isSelected(diagram, target, undefined, wrapper) && canMove(target)) {
            return 'LabelDrag';
        }
        return 'LabelSelect';
    }
    if (obj !== null) {
        if (obj instanceof Node || obj instanceof Connector) {
            if (wrapper && wrapper.id) {
                var id = wrapper.id.split(obj.id)[1];
                if (id && id.match('^_icon')) {
                    return 'LayoutAnimation';
                }
            }
            if (wrapper && wrapper.id) {
                var userid = void 0;
                for (var i = 0; i < obj.fixedUserHandles.length; i++) {
                    userid = obj.fixedUserHandles[parseInt(i.toString(), 10)].id;
                    if (wrapper.id && (wrapper.id.indexOf(userid) > -1)) {
                        return 'FixedUserHandle';
                    }
                }
            }
            if (wrapper instanceof TextElement && wrapper.hyperlink.link) {
                return 'Hyperlink';
            }
            if (canMove(obj) && isSelected(diagram, obj, false) && diagram.selectedItems.annotation === undefined) {
                if ((obj instanceof Connector && !(contains(position, obj.sourcePoint, obj.hitPadding) ||
                    contains(position, obj.targetPoint, obj.hitPadding))) ||
                    !(obj instanceof Connector)) {
                    return 'Drag';
                }
            }
            else if (obj && canZoomPan(diagram) && !defaultTool(diagram)) {
                return 'Pan';
            }
            else if (diagram.selectedItems.nodes.length && diagram.selectedItems.nodes[0].isLane &&
                diagram.selectedItems.wrapper && diagram.selectedItems.wrapper.bounds.containsPoint(position)) {
                return 'Drag';
            }
            else {
                return 'Select';
            }
        }
        else {
            return 'Select';
        }
    }
    return 'Select';
}
/* tslint:enable */
function checkResizeHandles(diagram, element, position, matrix, x, y) {
    var action;
    if ((diagram.selectedItems.nodes.length === 1 && diagram.selectedItems.connectors.length === 0)
        && diagram.selectedItems.nodes[0].container) {
        action = checkResizeHandleForContainer(diagram, element, position, x, y);
    }
    if (!action && (!diagram.selectedItems.nodes[0] || (!diagram.selectedItems.nodes[0].isPhase &&
        !diagram.selectedItems.nodes[0].isLane && diagram.selectedItems.nodes[0].shape.type !== 'SwimLane'))) {
        action = checkForResizeHandles(diagram, element, position, matrix, x, y);
    }
    if (action) {
        return action;
    }
    return null;
}
/**
 * checkForConnectorSegment method\
 *
 * @returns {Actions}    checkForConnectorSegment method .\
 * @param {Connector} conn - provide the options value.
 * @param {SelectorModel} handle - provide the options value.
 * @param {PointModel} position - provide the options value.
 * @param {Diagram} diagram - provide the options value.
 * @private
 */
function checkForConnectorSegment(conn, handle, position, diagram) {
    //(EJ2-70650)-Unable to drag bezier control thumb, when we increase handleSize value
    //Added below code for drag the bezier control thumb while increasing handle size (Changing cursor from pointer to drag cursor)
    var targetPaddingValue = (handle.handleSize / 2) / diagram.scrollSettings.currentZoom;
    var sourcePaddingValue = (handle.handleSize / 2) / diagram.scrollSettings.currentZoom;
    if (conn.type === 'Bezier' && diagram.connectorEditingToolModule) {
        for (var i = 0; i < conn.segments.length; i++) {
            var segment = (conn.segments)[parseInt(i.toString(), 10)];
            // EJ2-67447 - Bezier segment control points are clickable after hiding it with controlPointsVisibility property.
            // The below condition is used to check the control points visibility of the connector.
            if (contains(position, !Point.isEmptyPoint(segment.point1) ? segment.point1 : segment.bezierPoint1, sourcePaddingValue) && ((i === 0 && canShowControlPoints(conn.bezierSettings.controlPointsVisibility, 'Source')) || (i !== 0 && canShowControlPoints(conn.bezierSettings.controlPointsVisibility, 'Intermediate')))) {
                return 'BezierSourceThumb';
            }
            if (contains(position, !Point.isEmptyPoint(segment.point2) ? segment.point2 : segment.bezierPoint2, targetPaddingValue) && ((i === conn.segments.length - 1 && canShowControlPoints(conn.bezierSettings.controlPointsVisibility, 'Target')) || (i !== conn.segments.length - 1 && canShowControlPoints(conn.bezierSettings.controlPointsVisibility, 'Intermediate')))) {
                return 'BezierTargetThumb';
            }
        }
    }
    if (diagram.connectorEditingToolModule && canDragSegmentThumb(conn)) {
        // 927583: Segment points cannot be dragged when the pointer is in the outer part of the segmentThumb
        var inheritSegmentThumbSize = (conn.constraints & ConnectorConstraints.InheritSegmentThumbSize);
        var segmentThumbSize = inheritSegmentThumbSize ? diagram.segmentThumbSize : conn.segmentThumbSize;
        var padding = (segmentThumbSize > 20) && conn.type !== 'Straight' ? segmentThumbSize / 2 : 10;
        padding = padding / diagram.scrollSettings.currentZoom;
        if (conn.type === 'Straight' || conn.type === 'Bezier') {
            for (var i = 0; i < conn.segments.length; i++) {
                //let segment: StraightSegmentModel | BezierSegmentModel;
                var segment = (conn.segments)[parseInt(i.toString(), 10)];
                if (contains(position, segment.point, padding)) {
                    return 'SegmentEnd';
                }
            }
        }
        else {
            for (var i = 0; i < conn.segments.length; i++) {
                var segPoint = { x: 0, y: 0 };
                var segment = (conn.segments)[parseInt(i.toString(), 10)];
                if (segment.allowDrag) {
                    for (var j = 0; j < segment.points.length - 1; j++) {
                        var length_1 = Point.distancePoints(segment.points[parseInt(j.toString(), 10)], segment.points[j + 1]);
                        if (length_1 >= 50) {
                            segPoint.x = ((segment.points[parseInt(j.toString(), 10)].x + segment.points[j + 1].x) / 2);
                            segPoint.y = ((segment.points[parseInt(j.toString(), 10)].y + segment.points[j + 1].y) / 2);
                            //Bug 857928: Issue in connector selection while enabling segment thumb.
                            //Instead of setting static value 30, we have set the hit padding of connector.
                            // 927583: Segment points cannot be dragged when the pointer is in the outer part of the segmentThumb
                            if (contains(position, segPoint, padding)) {
                                return 'OrthoThumb';
                            }
                        }
                    }
                }
            }
        }
    }
    else if (canDragSegmentThumb(conn)) {
        console.warn('[WARNING] :: Module "ConnectorEditing" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
    }
    return null;
}
/**
 * findPortToolToActivate method\
 *
 * @returns {boolean}    findPortToolToActivate method .\
 * @param {Diagram} diagram - provide the options value.
 * @param {NodeModel | PointPortModel} target - provide the options value.
 * @param {ITouches[] | TouchList} touchStart - provide the options value.
 * @param {ITouches[] | TouchList} touchMove - provide the options value.
 * @private
 */
function findPortToolToActivate(diagram, target, 
// eslint-disable-next-line
touchStart, touchMove) {
    if (canDrag(target) && (checkPortRestriction(target, PortVisibility.Hover)
        || (checkPortRestriction(target, PortVisibility.Visible)))) {
        if ((target.constraints & PortConstraints.Drag)) {
            return 'PortDrag';
        }
    }
    else if (canDraw(target) && (checkPortRestriction(target, PortVisibility.Hover)
        || (checkPortRestriction(target, PortVisibility.Visible)))) {
        if (target.constraints & PortConstraints.Draw) {
            diagram.drawingObject = {};
            var connector = { type: 'Orthogonal', sourcePortID: target.id };
            diagram.drawingObject = connector;
            diagram.tool |= DiagramTools.DrawOnce;
            diagram.currentDrawingObject = connector;
            return 'PortDraw';
        }
    }
    return 'None';
}
/**
 * Resize handle for container and also object.
 * @param {Diagram} diagram - provide the options value.
 * @param {DiagramElement} element - provide the options value.
 * @param {PointModel} position - provide the options value.
 * @param {number} x - provide the options value.
 * @param {number} y - provide the options value.
 * @returns {Actions}    Resize handle for container and also object.\
 *
 * @private
 */
function checkResizeHandleForContainer(diagram, element, position, x, y) {
    var ten = 10 / diagram.scroller.currentZoom;
    var selectedItems = diagram.selectedItems;
    var width = element.actualSize.width;
    var height = element.actualSize.height;
    // 910600: Update cursor type in swimlane based on the values
    var left = new Rect(x, y, element.style.strokeWidth, height);
    var right = new Rect(x + width, y, element.style.strokeWidth, height);
    var top = new Rect(x, y, width, element.style.strokeWidth);
    var bottom = new Rect(x, y + height, width, element.style.strokeWidth);
    var container = checkParentAsContainer(diagram, diagram.selectedItems.nodes[0], true) ?
        diagram.nameTable[diagram.selectedItems.nodes[0].parentId] : diagram.selectedItems.nodes[0];
    // 924599: Resize Cursor Not Enabled for Phase with Width Less Than 40
    if (canResizeCorner(selectedItems.constraints, 'ResizeEast', selectedItems.thumbsConstraints, selectedItems) &&
        right.containsPoint(position, ten)) {
        return 'ResizeEast';
    }
    if (canResizeCorner(selectedItems.constraints, 'ResizeSouth', selectedItems.thumbsConstraints, selectedItems) &&
        bottom.containsPoint(position, ten)) {
        return 'ResizeSouth';
    }
    if (container.container.type !== 'Grid') {
        if (canResizeCorner(selectedItems.constraints, 'ResizeWest', selectedItems.thumbsConstraints, selectedItems) &&
            left.containsPoint(position, ten)) {
            return 'ResizeWest';
        }
        if (canResizeCorner(selectedItems.constraints, 'ResizeNorth', selectedItems.thumbsConstraints, selectedItems) &&
            top.containsPoint(position, ten)) {
            return 'ResizeNorth';
        }
    }
    return null;
}
function checkForResizeHandles(diagram, element, position, matrix, x, y) {
    var forty = 40 / diagram.scroller.currentZoom;
    var ten = (diagram.selectedItems.handleSize / 2) / diagram.scroller.currentZoom;
    var selectedItems = diagram.selectedItems;
    var labelSelection = (selectedItems.annotation) ? true : false;
    if (element.actualSize.width >= forty && element.actualSize.height >= forty) {
        if (canResizeCorner(selectedItems.constraints, 'ResizeSouthEast', selectedItems.thumbsConstraints, selectedItems) && contains(position, transformPointByMatrix(matrix, { x: x + element.actualSize.width, y: y + element.actualSize.height }), ten)) {
            return (labelSelection) ? 'LabelResizeSouthEast' : 'ResizeSouthEast';
        }
        if (canResizeCorner(selectedItems.constraints, 'ResizeSouthWest', selectedItems.thumbsConstraints, selectedItems) &&
            contains(position, transformPointByMatrix(matrix, { x: x, y: y + element.actualSize.height }), ten)) {
            return (labelSelection) ? 'LabelResizeSouthWest' : 'ResizeSouthWest';
        }
        if (canResizeCorner(selectedItems.constraints, 'ResizeNorthEast', selectedItems.thumbsConstraints, selectedItems) &&
            contains(position, transformPointByMatrix(matrix, { x: x + element.actualSize.width, y: y }), ten)) {
            return (labelSelection) ? 'LabelResizeNorthEast' : 'ResizeNorthEast';
        }
        if (canResizeCorner(selectedItems.constraints, 'ResizeNorthWest', selectedItems.thumbsConstraints, selectedItems) &&
            contains(position, transformPointByMatrix(matrix, { x: x, y: y }), ten)) {
            return (labelSelection) ? 'LabelResizeNorthWest' : 'ResizeNorthWest';
        }
    }
    if (canResizeCorner(selectedItems.constraints, 'ResizeEast', selectedItems.thumbsConstraints, selectedItems) && contains(position, transformPointByMatrix(matrix, { x: x + element.actualSize.width, y: y + element.actualSize.height / 2 }), ten)) {
        return (labelSelection) ? 'LabelResizeEast' : 'ResizeEast';
    }
    if (canResizeCorner(selectedItems.constraints, 'ResizeWest', selectedItems.thumbsConstraints, selectedItems) &&
        contains(position, transformPointByMatrix(matrix, { x: x, y: y + element.actualSize.height / 2 }), ten)) {
        return (labelSelection) ? 'LabelResizeWest' : 'ResizeWest';
    }
    if (canResizeCorner(selectedItems.constraints, 'ResizeSouth', selectedItems.thumbsConstraints, selectedItems) && contains(position, transformPointByMatrix(matrix, { x: x + element.actualSize.width / 2, y: y + element.actualSize.height }), ten)) {
        return (labelSelection) ? 'LabelResizeSouth' : 'ResizeSouth';
    }
    if (canResizeCorner(selectedItems.constraints, 'ResizeNorth', selectedItems.thumbsConstraints, selectedItems) &&
        contains(position, transformPointByMatrix(matrix, { x: x + element.actualSize.width / 2, y: y }), ten)) {
        return (labelSelection) ? 'LabelResizeNorth' : 'ResizeNorth';
    }
    return null;
}
/**
 * contains method\
 *
 * @returns {boolean}    contains method .\
 * @param {PointModel} mousePosition - provide the options value.
 * @param {PointModel} corner - provide the corner value.
 * @param {number} padding - provide the padding value.
 * @private
 */
function contains(mousePosition, corner, padding) {
    if (mousePosition.x >= corner.x - padding && mousePosition.x <= corner.x + padding) {
        if (mousePosition.y >= corner.y - padding && mousePosition.y <= corner.y + padding) {
            return true;
        }
    }
    return false;
}
/**
 * hasSelection method\
 *
 * @returns {boolean}    hasSelection method .\
 * @param {Diagram} diagram - provide the options value.
 * @private
 */
function hasSelection(diagram) {
    if (diagram.selectedItems.nodes.length > 0 || diagram.selectedItems.connectors.length > 0) {
        return true;
    }
    return false;
}
/**
 * hasSingleConnection method\
 *
 * @returns {boolean}    hasSingleConnection method .\
 * @param {Diagram} diagram - provide the options value.
 * @private
 */
function hasSingleConnection(diagram) {
    if (diagram.selectedItems.connectors.length === 1 && !diagram.selectedItems.nodes.length) {
        return true;
    }
    return false;
}
/**
 * isSelected method\
 *
 * @returns {boolean}    isSelected method .\
 * @param {Diagram} diagram - provide the options value.
 * @param {Object} element - provide the options value.
 * @param {boolean} firstLevel - provide the options value.
 * @param {DiagramElement} wrapper - provide the options value.
 * @private
 */
function isSelected(diagram, element, firstLevel, wrapper) {
    if (firstLevel === void 0) { firstLevel = true; }
    if (element instanceof Selector) {
        return true;
    }
    if (element instanceof Node) {
        while (element) {
            if (diagram.selectedItems.nodes.indexOf(element) !== -1 && diagram.selectedItems.annotation === undefined) {
                return true;
            }
            if (!firstLevel) {
                element = diagram.nameTable[element.parentId];
            }
            else {
                break;
            }
        }
    }
    else if (element instanceof Connector) {
        if (diagram.selectedItems.connectors.indexOf(element) !== -1 && diagram.selectedItems.annotation === undefined) {
            return true;
        }
    }
    else if (element instanceof ShapeAnnotation || element instanceof PathAnnotation) {
        if (diagram.selectedItems.annotation && diagram.selectedItems.wrapper.children[0].id === wrapper.id) {
            return true;
        }
    }
    return false;
}
/**
 * getCursor method\
 *
 * @returns {boolean}    getCursor method .\
 * @param {Actions} cursor - provide the options value.
 * @param {number} angle - provide the options value.
 * @private
 */
function getCursor(cursor, angle) {
    //to avoid angles less than 0 & angles greater than 360
    angle += 360;
    angle %= 360;
    if (cursor.indexOf('Resize') === -1) {
        return cursors["" + cursor];
    }
    else {
        var dir = cursors["" + cursor];
        if ((angle >= 0 && angle < 25) || (angle >= 160 && angle <= 205) || (angle >= 340 && angle <= 360)) {
            return dir;
        }
        else if ((angle >= 25 && angle <= 70) || (angle >= 205 && angle <= 250)) {
            if (dir === 'n-resize' || dir === 's-resize') {
                return 'ne-resize';
            }
            else if (dir === 'nw-resize' || dir === 'se-resize') {
                return 'n-resize';
            }
            else if (dir === 'e-resize' || dir === 'w-resize') {
                return 'nw-resize';
            }
            else {
                return 'e-resize';
            }
        }
        else if ((angle >= 70 && angle <= 115) || (angle >= 250 && angle <= 295)) {
            if (dir === 'n-resize' || dir === 's-resize') {
                return 'e-resize';
            }
            else if (dir === 'nw-resize' || dir === 'se-resize') {
                return 'ne-resize';
            }
            else if (dir === 'e-resize' || dir === 'w-resize') {
                return 'n-resize';
            }
            else {
                return 'nw-resize';
            }
        }
        else if ((angle >= 115 && angle <= 155) || (angle >= 295 && angle <= 340)) {
            if (dir === 'n-resize' || dir === 's-resize') {
                return 'nw-resize';
            }
            else if (dir === 'nw-resize' || dir === 'se-resize') {
                return 'e-resize';
            }
            else if (dir === 'e-resize' || dir === 'w-resize') {
                return 'ne-resize';
            }
        }
        else {
            return 'n-resize';
        }
    }
    return cursors["" + cursor];
}
var cursors = {
    'None': 'default',
    'Rotate': 'crosshair',
    'Select': 'default',
    'Drag': 'move',
    'ResizeWest': 'w-resize',
    'ResizeEast': 'e-resize',
    'ResizeSouth': 's-resize',
    'ResizeNorth': 'n-resize',
    'Draw': 'crosshair',
    'PortDraw': 'crosshair',
    'ResizeNorthEast': 'ne-resize',
    'ResizeNorthWest': 'nw-resize',
    'ResizeSouthEast': 'se-resize',
    'ResizeSouthWest': 'sw-resize',
    'ConnectorSourceEnd': 'move',
    'ConnectorTargetEnd': 'move',
    'BezierSourceThumb': 'move',
    'BezierTargetThumb': 'move',
    'OrthoThumb': 'move',
    'SegmentEnd': 'move',
    'Pan': 'grab',
    'Hyperlink': 'pointer',
    'PortDrag': 'pointer',
    'LabelSelect': 'pointer',
    'LabelDrag': 'move',
    'LabelRotate': 'crosshair',
    'LabelResizeWest': 'w-resize',
    'LabelResizeEast': 'e-resize',
    'LabelResizeSouth': 's-resize',
    'LabelResizeNorth': 'n-resize',
    'LabelResizeNorthEast': 'ne-resize',
    'LabelResizeNorthWest': 'nw-resize',
    'LabelResizeSouthEast': 'se-resize',
    'LabelResizeSouthWest': 'sw-resize'
};

var __extends$g = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/**
 * Defines the interactive tools
 */
var ToolBase = /** @class */ (function () {
    /**
     * Initializes the tool
     *
     * @param {CommandHandler} command Command that is corresponding to the current action
     * @param protectChange
     */
    function ToolBase(command, protectChange) {
        if (protectChange === void 0) { protectChange = false; }
        /**
         * Command that is corresponding to the current action
         */
        this.commandHandler = null;
        // protected deepDiffer: DeepDiffMapper = new DeepDiffMapper();
        /**
         * Sets/Gets whether the interaction is being done
         */
        this.inAction = false;
        /**
         * Sets/Gets the protect change
         */
        this.isProtectChange = false;
        /**
         * Sets/Gets the current element that is under mouse
         */
        this.currentElement = null;
        /**   @private  */
        this.blocked = false;
        this.isTooltipVisible = false;
        /** @private */
        this.childTable = {};
        /**
         * Sets/Gets the previous object when mouse down
         */
        this.undoElement = { nodes: [], connectors: [] };
        this.checkProperty = true;
        this.undoParentElement = { nodes: [], connectors: [] };
        this.commandHandler = command;
        this.isProtectChange = protectChange;
    }
    ToolBase.prototype.startAction = function (currentElement) {
        this.currentElement = currentElement;
        this.inAction = true;
    };
    /**
     * @param args
     * @private
     */
    ToolBase.prototype.mouseDown = function (args) {
        this.currentElement = args.source;
        this.startPosition = this.currentPosition = this.prevPosition = args.position;
        this.isTooltipVisible = true;
        this.startAction(args.source);
        this.checkProperty = true;
        // Bug fix - EJ2-44495 -Node does not gets selected on slight movement of mouse when drag constraints disabled for node
        this.mouseDownElement = args.source;
    };
    ToolBase.prototype.checkPropertyValue = function () {
        if (this.checkProperty) {
            this.commandHandler.startTransaction(this.isProtectChange);
        }
    };
    /**
     * @param args
     * @private
     */
    ToolBase.prototype.mouseMove = function (args) {
        this.currentPosition = args.position;
        if (this.inAction) {
            this.commandHandler.startTransaction(this.isProtectChange);
            this.checkProperty = false;
        }
        //this.currentElement = currentElement;
        return !this.blocked;
    };
    /**
     * @param args
     * @private
     */
    ToolBase.prototype.mouseUp = function (args) {
        this.checkPropertyValue();
        this.currentPosition = args.position;
        // this.currentElement = currentElement;
        this.isTooltipVisible = false;
        this.commandHandler.endTransaction(this.isProtectChange);
        this.endAction();
        // Bug fix - EJ2-44495 -Node does not gets selected on slight movement of mouse when drag constraints disabled for node
        this.mouseDownElement = null;
    };
    ToolBase.prototype.endAction = function () {
        if (!this.isTooltipVisible) {
            this.commandHandler.closeTooltip();
        }
        this.commandHandler = null;
        this.currentElement = null;
        this.currentPosition = null;
        this.inAction = false;
        this.blocked = false;
    };
    /**
     * @param args
     * @private
     */
    ToolBase.prototype.mouseWheel = function (args) {
        this.currentPosition = args.position;
    };
    /**
     * @param args
     * @private
     */
    ToolBase.prototype.mouseLeave = function (args) {
        this.mouseUp(args);
    };
    ToolBase.prototype.updateSize = function (shape, startPoint, endPoint, corner, initialBounds, angle) {
        shape = this.commandHandler.renderContainerHelper(shape) || shape;
        var horizontalsnap = { snapped: false, offset: 0, left: false, right: false };
        var verticalsnap = { snapped: false, offset: 0, top: false, bottom: false };
        var difx = this.currentPosition.x - this.startPosition.x;
        var dify = this.currentPosition.y - this.startPosition.y;
        var snapEnabled = (!(shape instanceof TextElement)) && this.commandHandler.snappingModule
            && this.commandHandler.snappingModule.canSnap();
        var snapLine = snapEnabled ? this.commandHandler.snappingModule.getLayer() : null;
        var rotateAngle = (shape instanceof TextElement) ? angle : shape.rotateAngle;
        var matrix;
        matrix = identityMatrix();
        rotateMatrix(matrix, -rotateAngle, 0, 0);
        var x = shape.offsetX;
        var y = shape.offsetY;
        var w = shape.width;
        var h = shape.height;
        x = x - w * shape.pivot.x;
        y = y - h * shape.pivot.y;
        var deltaWidth = 0;
        var deltaHeight = 0;
        var diff;
        var width = (shape instanceof TextElement) ? shape.actualSize.width : shape.width;
        var height = (shape instanceof TextElement) ? shape.actualSize.height : shape.height;
        switch (corner) {
            case 'ResizeWest':
                diff = transformPointByMatrix(matrix, ({ x: difx, y: dify }));
                difx = diff.x;
                dify = diff.y;
                deltaHeight = 1;
                difx = snapEnabled ? this.commandHandler.snappingModule.snapLeft(horizontalsnap, verticalsnap, snapLine, difx, dify, shape, endPoint === startPoint, initialBounds) :
                    difx;
                dify = 0;
                deltaWidth = (initialBounds.width - difx) / width;
                break;
            case 'ResizeEast':
                diff = transformPointByMatrix(matrix, ({ x: difx, y: dify }));
                difx = diff.x;
                dify = diff.y;
                difx = snapEnabled ? this.commandHandler.snappingModule.snapRight(horizontalsnap, verticalsnap, snapLine, difx, dify, shape, endPoint === startPoint, initialBounds) :
                    difx;
                dify = 0;
                deltaWidth = (initialBounds.width + difx) / width;
                deltaHeight = 1;
                break;
            case 'ResizeNorth':
                deltaWidth = 1;
                diff = transformPointByMatrix(matrix, ({ x: difx, y: dify }));
                difx = diff.x;
                dify = diff.y;
                dify = snapEnabled ? this.commandHandler.snappingModule.snapTop(horizontalsnap, verticalsnap, snapLine, difx, dify, shape, endPoint === startPoint, initialBounds) :
                    dify;
                deltaHeight = (initialBounds.height - dify) / height;
                break;
            case 'ResizeSouth':
                deltaWidth = 1;
                diff = transformPointByMatrix(matrix, ({ x: difx, y: dify }));
                difx = diff.x;
                dify = diff.y;
                dify = snapEnabled ? this.commandHandler.snappingModule.snapBottom(horizontalsnap, verticalsnap, snapLine, difx, dify, shape, endPoint === startPoint, initialBounds) :
                    dify;
                deltaHeight = (initialBounds.height + dify) / height;
                break;
            case 'ResizeNorthEast':
                diff = transformPointByMatrix(matrix, ({ x: difx, y: dify }));
                difx = diff.x;
                dify = diff.y;
                difx = snapEnabled ? this.commandHandler.snappingModule.snapRight(horizontalsnap, verticalsnap, snapLine, difx, dify, shape, endPoint === startPoint, initialBounds) :
                    difx;
                dify = snapEnabled ? this.commandHandler.snappingModule.snapTop(horizontalsnap, verticalsnap, snapLine, difx, dify, shape, endPoint === startPoint, initialBounds) :
                    dify;
                deltaWidth = (initialBounds.width + difx) / width;
                deltaHeight = (initialBounds.height - dify) / height;
                break;
            case 'ResizeNorthWest':
                diff = transformPointByMatrix(matrix, ({ x: difx, y: dify }));
                difx = diff.x;
                dify = diff.y;
                dify = !snapEnabled ? dify : this.commandHandler.snappingModule.snapTop(horizontalsnap, verticalsnap, snapLine, difx, dify, shape, endPoint === startPoint, initialBounds);
                difx = !snapEnabled ? difx : this.commandHandler.snappingModule.snapLeft(horizontalsnap, verticalsnap, snapLine, difx, dify, shape, endPoint === startPoint, initialBounds);
                deltaWidth = (initialBounds.width - difx) / width;
                deltaHeight = (initialBounds.height - dify) / height;
                break;
            case 'ResizeSouthEast':
                diff = transformPointByMatrix(matrix, ({ x: difx, y: dify }));
                difx = diff.x;
                dify = diff.y;
                dify = !snapEnabled ? dify : this.commandHandler.snappingModule.snapBottom(horizontalsnap, verticalsnap, snapLine, difx, dify, shape, endPoint === startPoint, initialBounds);
                difx = !snapEnabled ? difx : this.commandHandler.snappingModule.snapRight(horizontalsnap, verticalsnap, snapLine, difx, dify, shape, endPoint === startPoint, initialBounds);
                deltaHeight = (initialBounds.height + dify) / height;
                deltaWidth = (initialBounds.width + difx) / width;
                break;
            case 'ResizeSouthWest':
                diff = transformPointByMatrix(matrix, ({ x: difx, y: dify }));
                difx = diff.x;
                dify = diff.y;
                dify = snapEnabled ? this.commandHandler.snappingModule.snapBottom(horizontalsnap, verticalsnap, snapLine, difx, dify, shape, endPoint === startPoint, initialBounds) : dify;
                difx = snapEnabled ? this.commandHandler.snappingModule.snapLeft(horizontalsnap, verticalsnap, snapLine, difx, dify, shape, endPoint === startPoint, initialBounds) : difx;
                deltaWidth = (initialBounds.width - difx) / width;
                deltaHeight = (initialBounds.height + dify) / height;
                break;
        }
        return { width: deltaWidth, height: deltaHeight };
    };
    ToolBase.prototype.getPivot = function (corner) {
        switch (corner) {
            case 'ResizeWest':
                return { x: 1, y: 0.5 };
            case 'ResizeEast':
                return { x: 0, y: 0.5 };
            case 'ResizeNorth':
                return { x: 0.5, y: 1 };
            case 'ResizeSouth':
                return { x: 0.5, y: 0 };
            case 'ResizeNorthEast':
                return { x: 0, y: 1 };
            case 'ResizeNorthWest':
                return { x: 1, y: 1 };
            case 'ResizeSouthEast':
                return { x: 0, y: 0 };
            case 'ResizeSouthWest':
                return { x: 1, y: 0 };
        }
        return { x: 0.5, y: 0.5 };
    };
    //method to get node shape name
    ToolBase.prototype.getShapeType = function () {
        var shape;
        // eslint-disable-next-line no-constant-condition
        if (this.commandHandler.diagram.drawingObject.shape.type === 'Image' ||
            this.commandHandler.diagram.drawingObject.shape.type === 'HTML' ||
            this.commandHandler.diagram.drawingObject.shape.type === 'Native' ||
            this.commandHandler.diagram.drawingObject.shape.type === 'Path') {
            shape = this.commandHandler.diagram.drawingObject.shape.type;
        }
        else {
            shape = this.commandHandler.diagram.drawingObject.shape.shape;
        }
        return shape;
    };
    //EJ2-52203-Method to trigger ElementDraw Event when we draw node or connector with the drawing Tool
    ToolBase.prototype.triggerElementDrawEvent = function (source, state, objectType, elementType, isMouseDownAction) {
        var arg = {
            source: source, state: state, objectType: objectType, cancel: false, elementType: elementType
        };
        this.commandHandler.triggerEvent(DiagramEvent.elementDraw, arg);
        if (isMouseDownAction && arg.cancel) {
            {
                this.commandHandler.diagram.resetTool();
                this.inAction = false;
            }
        }
    };
    return ToolBase;
}());
/**
 * Helps to select the objects
 */
var SelectTool = /** @class */ (function (_super) {
    __extends$g(SelectTool, _super);
    function SelectTool(commandHandler, protectChange, action) {
        var _this = _super.call(this, commandHandler, true) || this;
        _this.action = action;
        return _this;
    }
    /**
     * @param args
     * @private
     */
    SelectTool.prototype.mouseDown = function (args) {
        this.inAction = true;
        _super.prototype.mouseDown.call(this, args);
    };
    /**
     * @param args
     * @private
     */
    SelectTool.prototype.mouseMove = function (args) {
        _super.prototype.mouseMove.call(this, args);
        //draw selected region
        if (this.inAction && Point.equals(this.currentPosition, this.prevPosition) === false) {
            var rect = Rect.toBounds([this.prevPosition, this.currentPosition]);
            // Bug fix - EJ2-44495 -Node does not gets selected on slight movement of mouse when drag constraints disabled for node
            if (this.mouseDownElement && !canMove(this.mouseDownElement)) {
                this.commandHandler.clearObjectSelection(this.mouseDownElement);
            }
            else {
                this.commandHandler.clearSelectedItems();
                this.commandHandler.drawSelectionRectangle(rect.x, rect.y, rect.width, rect.height);
            }
        }
        return !this.blocked;
    };
    /**
     * @param args
     * @private
     */
    SelectTool.prototype.mouseUp = function (args) {
        this.checkPropertyValue();
        //rubber band selection
        if (!this.commandHandler.isUserHandle(this.currentPosition)) {
            if (Point.equals(this.currentPosition, this.prevPosition) === false && this.inAction) {
                var region = Rect.toBounds([this.prevPosition, this.currentPosition]);
                this.commandHandler.doRubberBandSelection(region);
            }
            else {
                //single selection
                var arrayNodes = this.commandHandler.getSelectedObject();
                if (!this.commandHandler.hasSelection() || !args.info || !args.info.ctrlKey) {
                    this.commandHandler.clearSelection(args.source === null ? true : false);
                    if (this.action === 'LabelSelect') {
                        this.commandHandler.labelSelect(args.source, args.sourceWrapper, arrayNodes);
                    }
                    else if (args.source) {
                        this.commandHandler.selectObjects([args.source], false, arrayNodes);
                    }
                }
                else {
                    //handling multiple selection
                    if (args && args.source) {
                        if (!this.commandHandler.isSelected(args.source)) {
                            this.commandHandler.selectObjects([args.source], true);
                        }
                        else {
                            if (args.clickCount === 1) {
                                this.commandHandler.unSelect(args.source);
                                // this.commandHandler.updateBlazorSelector();
                            }
                        }
                    }
                }
            }
        }
        this.inAction = false;
        _super.prototype.mouseUp.call(this, args);
    };
    /**
     * @param args
     * @private
     */
    SelectTool.prototype.mouseLeave = function (args) {
        if (this.inAction) {
            this.mouseUp(args);
        }
    };
    return SelectTool;
}(ToolBase));
var FixedUserHandleTool = /** @class */ (function (_super) {
    __extends$g(FixedUserHandleTool, _super);
    function FixedUserHandleTool() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param args
     * @private
     */
    FixedUserHandleTool.prototype.mouseUp = function (args) {
        this.checkPropertyValue();
        this.inAction = false;
        var val = args.source;
        var fixedUserHandle;
        var iconId = args.sourceWrapper.id;
        for (var i = 0; i < val.fixedUserHandles.length; i++) {
            if (iconId.indexOf(val.fixedUserHandles[parseInt(i.toString(), 10)].id) > -1) {
                fixedUserHandle = val.fixedUserHandles[parseInt(i.toString(), 10)];
            }
        }
        var arg = {
            fixedUserHandle: fixedUserHandle,
            element: args.source
        };
        var trigger = DiagramEvent.fixedUserHandleClick;
        this.commandHandler.triggerEvent(trigger, arg);
        _super.prototype.mouseUp.call(this, args);
    };
    return FixedUserHandleTool;
}(ToolBase));
/**
 * Helps to edit the selected connectors
 */
var ConnectTool = /** @class */ (function (_super) {
    __extends$g(ConnectTool, _super);
    function ConnectTool(commandHandler, endPoint) {
        var _this = _super.call(this, commandHandler, true) || this;
        _this.isConnected = false;
        _this.endPoint = endPoint;
        return _this;
    }
    /**
     * @param args
     * @private
     */
    ConnectTool.prototype.mouseDown = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var oldValue, connectors, i, segment, segmentpoint1, segmentpoint2;
            return __generator(this, function (_a) {
                this.inAction = true;
                this.undoElement = undefined;
                if (!(this instanceof ConnectorDrawingTool)) {
                    this.undoElement = cloneObject(args.source);
                }
                _super.prototype.mouseDown.call(this, args);
                if (args.source && args.source.connectors) {
                    oldValue = { x: this.prevPosition.x, y: this.prevPosition.y };
                    connectors = args.source.connectors[0];
                    this.oldConnector = cloneObject(connectors);
                }
                // Sets the selected segment
                if (this.endPoint === 'BezierSourceThumb' || this.endPoint === 'BezierTargetThumb') {
                    for (i = 0; i < connectors.segments.length; i++) {
                        segment = connectors.segments[parseInt(i.toString(), 10)];
                        segmentpoint1 = !Point.isEmptyPoint(segment.point1) ? segment.point1 : segment.bezierPoint1;
                        segmentpoint2 = !Point.isEmptyPoint(segment.point2) ? segment.point2 : segment.bezierPoint2;
                        //(EJ2-70650)-Unable to drag bezier control thumb, when we increase handleSize value
                        //Added below code for drag the bezier control thumb while increasing handle size(For hitPadding)
                        if (this.currentElement.handleSize !== connectors.hitPadding) {
                            connectors.hitPadding = this.currentElement.handleSize;
                        }
                        if (contains(this.currentPosition, segmentpoint1, connectors.hitPadding) ||
                            contains(this.currentPosition, segmentpoint2, connectors.hitPadding)) {
                            this.selectedSegment = segment;
                        }
                    }
                }
                this.currentPosition = args.position;
                return [2 /*return*/];
            });
        });
    };
    /**
     * @param args
     * @private
     */
    ConnectTool.prototype.mouseUp = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var connector, nodeEndId, portEndId, arg, oldValues, newValues, connector, targetPortName, targetNodeNode, target, arg, trigger, obj, entry, obj, entry, connector;
            return __generator(this, function (_a) {
                if (!isBlazor() && this.isConnected && args.source.connectors) {
                    connector = args.source.connectors[0];
                    nodeEndId = this.endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';
                    portEndId = this.endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';
                    arg = {
                        connector: cloneBlazorObject(connector),
                        oldValue: { nodeId: this.oldConnector["" + nodeEndId], portId: this.oldConnector["" + portEndId] },
                        newValue: { nodeId: connector["" + nodeEndId], portId: connector["" + portEndId] }, cancel: false,
                        state: 'Changed', connectorEnd: this.endPoint
                    };
                    //875655- ConnectionChange Event not triggered in Changed state for port change in same node
                    if (connector["" + nodeEndId] !== this.oldConnector["" + nodeEndId] || connector["" + portEndId] !== this.oldConnector["" + portEndId]) {
                        this.commandHandler.triggerEvent(DiagramEvent.connectionChange, arg);
                        this.isConnected = false;
                    }
                }
                this.checkPropertyValue();
                this.commandHandler.updateSelector();
                this.commandHandler.removeSnap();
                if ((!(this instanceof ConnectorDrawingTool)) && ((this.endPoint === 'ConnectorSourceEnd' &&
                    args.source.connectors.length &&
                    ((!Point.equals(args.source.connectors[0].sourcePoint, this.undoElement.connectors[0].sourcePoint) ||
                        (args.source.connectors[0].sourceID !== this.undoElement.connectors[0].sourceID)))) ||
                    (this.endPoint === 'ConnectorTargetEnd' &&
                        ((!Point.equals(args.source.connectors[0].targetPoint, this.undoElement.connectors[0].targetPoint))
                            || (args.source.connectors[0].targetID !== this.undoElement.connectors[0].targetID))))) {
                    oldValues = void 0;
                    newValues = void 0;
                    connector = void 0;
                    if (args.source && args.source.connectors && this.endPoint === 'ConnectorSourceEnd') {
                        //941055: The sourcePointChange event's old and new values are the same
                        oldValues = { x: this.oldConnector.sourcePoint.x, y: this.oldConnector.sourcePoint.y };
                        connector = args.source.connectors[0];
                        newValues = { x: connector.sourcePoint.x, y: connector.sourcePoint.y };
                    }
                    else if (args.source && args.source.connectors && this.endPoint === 'ConnectorTargetEnd') {
                        oldValues = { x: this.oldConnector.targetPoint.x, y: this.oldConnector.targetPoint.y };
                        connector = args.source.connectors[0];
                        newValues = { x: connector.targetPoint.x, y: connector.targetPoint.y };
                    }
                    targetPortName = void 0;
                    targetNodeNode = void 0;
                    if (args.target) {
                        target = this.commandHandler.findTarget(args.targetWrapper, args.target, this.endPoint === 'ConnectorSourceEnd', true);
                        // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                        targetNodeNode = target.id;
                        if (target instanceof PointPort) {
                            //941055: The target node is undefined while connected to the port
                            targetPortName = target.id;
                            targetNodeNode = args.target.id;
                        }
                    }
                    arg = {
                        connector: connector, state: 'Completed', targetNode: targetNodeNode,
                        oldValue: oldValues, newValue: newValues, cancel: false, targetPort: targetPortName
                    };
                    trigger = this.endPoint === 'ConnectorSourceEnd' ? DiagramEvent.sourcePointChange : DiagramEvent.targetPointChange;
                    this.commandHandler.triggerEvent(trigger, arg);
                    this.commandHandler.removeTerminalSegment(connector, true);
                    if (this.undoElement && args.source) {
                        obj = void 0;
                        obj = cloneObject(args.source);
                        entry = {
                            type: 'ConnectionChanged', redoObject: cloneObject(obj), undoObject: cloneObject(this.undoElement),
                            category: 'Internal'
                        };
                        this.commandHandler.addHistoryEntry(entry);
                    }
                }
                else if (!(this instanceof ConnectorDrawingTool) &&
                    (this.endPoint === 'BezierTargetThumb' || this.endPoint === 'BezierSourceThumb')) {
                    if (this.undoElement && args.source) {
                        obj = cloneObject(args.source);
                        entry = {
                            type: 'SegmentChanged', redoObject: obj, undoObject: this.undoElement, category: 'Internal'
                        };
                        this.commandHandler.addHistoryEntry(entry);
                    }
                }
                // this.commandHandler.updateBlazorSelector();
                this.canCancel = undefined;
                this.tempArgs = undefined;
                //(EJ2-66201) - Exception occurs when mouse-hover on ports in node
                if (args.source && args.source.connectors) {
                    connector = args.source.connectors[0];
                    if (connector.isBezierEditing) {
                        connector.isBezierEditing = false;
                    }
                }
                _super.prototype.mouseUp.call(this, args);
                return [2 /*return*/];
            });
        });
    };
    /* tslint:disable */
    /**
     * @param args
     * @private
     */
    ConnectTool.prototype.mouseMove = function (args) {
        _super.prototype.mouseMove.call(this, args);
        var tempArgs;
        if ((!(this instanceof ConnectorDrawingTool)) && ((this.endPoint === 'ConnectorSourceEnd' &&
            Point.equals(args.source.connectors[0].sourcePoint, this.undoElement.connectors[0].sourcePoint)) ||
            (this.endPoint === 'ConnectorTargetEnd' &&
                Point.equals(args.source.connectors[0].targetPoint, this.undoElement.connectors[0].targetPoint)))) {
            var oldValue = void 0;
            var connectors = void 0;
            if (args.source && args.source.connectors) {
                oldValue = { x: this.prevPosition.x, y: this.prevPosition.y };
                connectors = args.source.connectors[0];
            }
            var targetPort = void 0;
            var targetNode = void 0;
            if (args.target) {
                targetNode = args.target.id;
                var target = this.commandHandler.findTarget(args.targetWrapper, args.target, this.endPoint === 'ConnectorSourceEnd', true);
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                (target instanceof PointPort || target instanceof BpmnSubEvent) ? targetPort = target.id : targetNode = target.id;
            }
            var arg = {
                connector: connectors, state: 'Start', targetNode: targetNode,
                oldValue: oldValue, newValue: oldValue, cancel: false, targetPort: targetPort
            };
            var trigger = this.endPoint === 'ConnectorSourceEnd' ?
                DiagramEvent.sourcePointChange : DiagramEvent.targetPointChange;
            this.commandHandler.triggerEvent(trigger, arg);
        }
        this.currentPosition = args.position;
        if (this.currentPosition && this.prevPosition) {
            var diffX = this.currentPosition.x - this.prevPosition.x;
            var diffY = this.currentPosition.y - this.prevPosition.y;
            var newValue = void 0;
            var oldValue = void 0;
            var inPort = void 0;
            var outPort = void 0;
            this.currentPosition = this.commandHandler.snapConnectorEnd(this.currentPosition);
            var connector = void 0;
            if (args.source && args.source.connectors) {
                newValue = { x: this.currentPosition.x, y: this.currentPosition.y };
                oldValue = { x: this.prevPosition.x, y: this.prevPosition.y };
                connector = args.source.connectors[0];
            }
            var targetPortId = void 0;
            var targetNodeId = void 0;
            if (args.target) {
                var target = this.commandHandler.findTarget(args.targetWrapper, args.target, this.endPoint === 'ConnectorSourceEnd', true);
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                (target instanceof PointPort) ? targetPortId = target.id : targetNodeId = target.id;
            }
            var arg = {
                connector: connector, state: 'Progress', targetNode: targetNodeId,
                oldValue: oldValue, newValue: newValue, cancel: false, targetPort: targetPortId
            };
            if (!(this instanceof ConnectorDrawingTool)) {
                var trigger = this.endPoint === 'ConnectorSourceEnd' ?
                    DiagramEvent.sourcePointChange : DiagramEvent.targetPointChange;
                this.commandHandler.triggerEvent(trigger, arg);
            }
            if (args.target) {
                inPort = getInOutConnectPorts(args.target, true);
                outPort = getInOutConnectPorts(args.target, false);
            }
            if (!arg.cancel && this.inAction && this.endPoint !== undefined && diffX !== 0 || diffY !== 0) {
                // EJ2-65331 - The condition checks whether the cancel argument is true or false
                if (!arg.cancel) {
                    this.blocked = !this.commandHandler.dragConnectorEnds(this.endPoint, args.source, this.currentPosition, this.selectedSegment, args.target, targetPortId);
                    this.commandHandler.updateSelector();
                }
                if (args.target && ((this.endPoint === 'ConnectorSourceEnd' && (canOutConnect(args.target) || canPortOutConnect(outPort)))
                    || (this.endPoint === 'ConnectorTargetEnd' && (canInConnect(args.target) || canPortInConnect(inPort))))) {
                    if (this.commandHandler.canDisconnect(this.endPoint, args, targetPortId, targetNodeId)) {
                        tempArgs = this.commandHandler.disConnect(args.source, this.endPoint, this.canCancel);
                        this.isConnected = true;
                    }
                    var target = this.commandHandler.findTarget(args.targetWrapper, args.target, this.endPoint === 'ConnectorSourceEnd', true);
                    if (target instanceof Node) {
                        if ((canInConnect(target) && this.endPoint === 'ConnectorTargetEnd')
                            || (canOutConnect(target) && this.endPoint === 'ConnectorSourceEnd')) {
                            tempArgs = this.commandHandler.connect(this.endPoint, args, this.canCancel);
                            this.isConnected = true;
                        }
                    }
                    else {
                        var isConnect = this.checkConnect(target);
                        if (isConnect) {
                            this.isConnected = true;
                            tempArgs = this.commandHandler.connect(this.endPoint, args, this.canCancel);
                        }
                    }
                }
                else if (this.endPoint.indexOf('Bezier') === -1) {
                    this.isConnected = true;
                    tempArgs = this.commandHandler.disConnect(args.source, this.endPoint, this.canCancel);
                    this.commandHandler.updateSelector();
                }
            }
            if (this.commandHandler.canEnableDefaultTooltip()) {
                var content_1 = this.getTooltipContent(args.position);
                var contentTemp = function () {
                    return content_1;
                };
                this.commandHandler.showTooltip(args.source, args.position, initializeCSPTemplate(contentTemp), 'ConnectTool', this.isTooltipVisible);
                this.isTooltipVisible = false;
            }
            if (tempArgs) {
                this.tempArgs = tempArgs;
            }
        }
        this.prevPosition = this.currentPosition;
        return !this.blocked;
    };
    /**
     * @param args
     * @private
     */
    ConnectTool.prototype.mouseLeave = function (args) {
        this.mouseUp(args);
    };
    ConnectTool.prototype.getTooltipContent = function (position) {
        return 'X:' + Math.round(position.x) + ' ' + 'Y:' + Math.round(position.y);
    };
    ConnectTool.prototype.checkConnect = function (target) {
        if (canPortInConnect(target) && this.endPoint === 'ConnectorTargetEnd') {
            return true;
        }
        else if (canPortOutConnect(target) && this.endPoint === 'ConnectorSourceEnd') {
            return true;
        }
        else if (!(target.constraints & PortConstraints.None) && !canPortInConnect(target) && !canPortOutConnect(target)
            && (target.constraints === undefined || (target.constraints & (PortConstraints.Default & ~(PortConstraints.InConnect | PortConstraints.OutConnect))) > 0)) {
            return true;
        }
        return false;
    };
    /**   @private  */
    ConnectTool.prototype.endAction = function () {
        _super.prototype.endAction.call(this);
        this.prevPosition = null;
        this.endPoint = null;
    };
    return ConnectTool;
}(ToolBase));
/**
 * Drags the selected objects
 */
var MoveTool = /** @class */ (function (_super) {
    __extends$g(MoveTool, _super);
    function MoveTool(commandHandler, objType) {
        var _this = _super.call(this, commandHandler, true) || this;
        /**   @private  */
        _this.currentTarget = null;
        _this.isStartAction = false;
        _this.canCancel = false;
        _this.canTrigger = false;
        _this.objectType = objType;
        return _this;
    }
    /**
     * @param args
     * @private
     */
    MoveTool.prototype.mouseDown = function (args) {
        if (args.source instanceof Node || args.source instanceof Connector) {
            var arrayNodes = this.commandHandler.getSelectedObject();
            this.commandHandler.selectObjects([args.source], args.info && args.info.ctrlKey, arrayNodes);
            var selectedObject = { nodes: [], connectors: [] };
            if (args.source instanceof Node) {
                selectedObject.nodes.push(cloneObject(args.source));
            }
            else {
                selectedObject.connectors.push(cloneObject(args.source));
            }
            this.undoElement = cloneObject(selectedObject);
            //909582-History change event args old value is undefined upon node drag
            var wrapper = args.source.wrapper;
            this.undoElement.offsetX = wrapper.offsetX;
            this.undoElement.offsetY = wrapper.offsetY;
        }
        else {
            this.undoElement = cloneObject(args.source);
        }
        this.undoParentElement = this.commandHandler.getSubProcess(args.source);
        if (this.objectType === 'Port') {
            this.portId = args.sourceWrapper.id;
        }
        this.commandHandler.insertBlazorConnector(args.source);
        _super.prototype.mouseDown.call(this, args);
        this.initialOffset = { x: 0, y: 0 };
    };
    MoveTool.prototype.getPort = function (args) {
        var port;
        var sourceId = args.source.id;
        var sourcePorts = args.source.ports;
        for (var i = 0; i < sourcePorts.length; i++) {
            if (args.sourceWrapper.id === sourceId + '_' + sourcePorts[parseInt(i.toString(), 10)].id) {
                port = sourcePorts[parseInt(i.toString(), 10)];
                break;
            }
        }
        return port;
    };
    /* tslint:disable */
    /**
     * @param args
     * @param isPreventHistory
     * @param args
     * @param isPreventHistory
     * @private
     */
    MoveTool.prototype.mouseUp = function (args, isPreventHistory) {
        return __awaiter(this, void 0, void 0, function () {
            var oldValues, newValues, obj, historyAdded, object, redoObject, wrapper, isSubGroupSelection, currentSelection, i, isSelector, isSingleSelectedObject, isSameSize, isDifferentPosition, isDifferentSourcePoint, isDifferentTargetPoint, arg, canAddHistory, nameTable, i, entry, entry_1, snappedPoint, canSplit, i, i, arg, nodes, isEndGroup, i, i, helper, entry, port, nodePorts, connPorts, i, i, arg;
            return __generator(this, function (_a) {
                this.checkPropertyValue();
                historyAdded = false;
                redoObject = { nodes: [], connectors: [] };
                if (this.objectType !== 'Port') {
                    if (args.source instanceof Node || args.source instanceof Connector) {
                        if (args.source instanceof Node) {
                            redoObject.nodes.push(cloneObject(args.source));
                        }
                        else {
                            redoObject.connectors.push(cloneObject(args.source));
                        }
                        obj = cloneObject(redoObject);
                        wrapper = args.source.wrapper;
                        obj.offsetX = wrapper.offsetX;
                        obj.offsetY = wrapper.offsetY;
                    }
                    else {
                        obj = cloneObject(args.source);
                    }
                    object = this.commandHandler.renderContainerHelper(args.source) || args.source || this.commandHandler.renderContainerHelper(args.source);
                    if ((object.id === 'helper') || (object.id !== 'helper')) {
                        isSubGroupSelection = false;
                        if (object instanceof Selector) {
                            currentSelection = cloneObject(object);
                            // check currentSelection.selectedObjects array contains same object of this.undoElement.selectedObjects array
                            if (currentSelection.selectedObjects.length === this.undoElement.selectedObjects.length) {
                                for (i = 0; i < currentSelection.selectedObjects.length; i++) {
                                    if (currentSelection.selectedObjects[parseInt(i.toString(), 10)].id !==
                                        this.undoElement.selectedObjects[parseInt(i.toString(), 10)].id) {
                                        isSubGroupSelection = true;
                                        break;
                                    }
                                }
                            }
                        }
                        isSelector = object instanceof Selector;
                        isSingleSelectedObject = object instanceof Selector && object.selectedObjects && object.selectedObjects.length === 1;
                        isSameSize = object instanceof Selector && Math.round(object.width) === Math.round(this.undoElement.width) && Math.round(object.height) === Math.round(this.undoElement.height);
                        isDifferentPosition = object.offsetX !== this.undoElement.offsetX || object.offsetY !== this.undoElement.offsetY;
                        isDifferentSourcePoint = object.sourcePoint !== this.undoElement.sourcePoint;
                        isDifferentTargetPoint = object.targetPoint !== this.undoElement.targetPoint;
                        if (!isSubGroupSelection &&
                            (((isSelector && (isSameSize || isSingleSelectedObject)) || !isSelector) && (isDifferentPosition || isDifferentSourcePoint || isDifferentTargetPoint))
                            || this.isSelectionHasConnector(object)) {
                            if (args.source) {
                                newValues = { offsetX: args.source.wrapper.offsetX, offsetY: args.source.wrapper.offsetY };
                                oldValues = { offsetX: args.source.wrapper.offsetX, offsetY: args.source.wrapper.offsetY };
                            }
                            arg = {
                                source: args.source, state: 'Completed', oldValue: this.intialValue, newValue: newValues,
                                target: this.currentTarget, targetPosition: this.currentPosition, allowDrop: true, cancel: false
                            };
                            arg = {
                                source: cloneBlazorObject(args.source), state: 'Completed',
                                oldValue: cloneBlazorObject(this.intialValue), newValue: cloneBlazorObject(newValues),
                                target: cloneBlazorObject(this.currentTarget), targetPosition: cloneBlazorObject(this.currentPosition),
                                allowDrop: arg.allowDrop, cancel: arg.cancel
                            };
                            canAddHistory = true;
                            //EJ2-69852): Position Change event trigger for clicking second time in swimlane header issue
                            if (object.id === 'helper') {
                                if (this.canTrigger) {
                                    //EJ2-925499 - Undo/Redo not working after moveing multiselected nodes inside swimlane while line routing enabled
                                    if ((obj.nodes.length > 1 || obj.connectors.length > 1) && (this.commandHandler.diagram.lineRoutingModule &&
                                        (this.commandHandler.diagram.constraints & DiagramConstraints.LineRouting))) {
                                        nameTable = this.commandHandler.diagram.nameTable;
                                        for (i = 0; i < obj.nodes.length; i++) {
                                            if (!(nameTable[obj.nodes[parseInt(i.toString(), 10)].parentId] &&
                                                nameTable[obj.nodes[parseInt(i.toString(), 10)].parentId].isLane)) {
                                                canAddHistory = false;
                                                break;
                                            }
                                        }
                                    }
                                    else {
                                        canAddHistory = true;
                                    }
                                    this.commandHandler.triggerEvent(DiagramEvent.positionChange, arg);
                                    this.connectorEndPointChangeEvent(arg);
                                }
                                else {
                                    canAddHistory = false;
                                }
                            }
                            else {
                                this.commandHandler.triggerEvent(DiagramEvent.positionChange, arg);
                                this.connectorEndPointChangeEvent(arg);
                            }
                            if (!isPreventHistory && canAddHistory) {
                                this.commandHandler.startGroupAction();
                                historyAdded = true;
                                entry = {
                                    type: 'PositionChanged',
                                    redoObject: cloneObject(obj), undoObject: cloneObject(this.undoElement), category: 'Internal'
                                };
                                if (obj.nodes[0] && obj.nodes[0].processId) {
                                    entry_1 = {
                                        type: 'SizeChanged', category: 'Internal',
                                        undoObject: this.undoParentElement, redoObject: this.commandHandler.getSubProcess(args.source)
                                    };
                                    this.commandHandler.addHistoryEntry(entry_1);
                                }
                                this.commandHandler.addHistoryEntry(entry);
                            }
                        }
                    }
                    snappedPoint = this.commandHandler.snapPoint(this.prevPosition, this.currentPosition, 0, 0);
                    this.commandHandler.removeSnap();
                    this.commandHandler.removeHighlighter();
                    if (args.source && this.currentTarget && canAllowDrop(this.currentTarget) &&
                        this.commandHandler.isDroppable(args.source, this.currentTarget)) {
                        canSplit = true;
                        this.commandHandler.drop(this.currentElement, this.currentTarget, this.currentPosition);
                        if (this.currentTarget && this.currentTarget instanceof Connector) {
                            if (this.commandHandler.diagram.enableConnectorSplit === true) {
                                //EJ2-894577- Restricting the connector splitting if any one edge is already connected to the node
                                if (this.currentElement && this.currentElement instanceof Node) {
                                    if (this.currentElement.children !== undefined) {
                                        for (i = 0; i < this.currentElement.children.length; i++) {
                                            if (this.currentElement.children[parseInt(i.toString(), 10)] === this.currentTarget.sourceID ||
                                                this.currentElement.children[parseInt(i.toString(), 10)] === this.currentTarget.targetID) {
                                                canSplit = false;
                                            }
                                        }
                                    }
                                    else {
                                        if (this.currentElement.id === this.currentTarget.sourceID || this.currentElement.id === this.currentTarget.targetID) {
                                            canSplit = false;
                                        }
                                    }
                                    if (canSplit) {
                                        this.commandHandler.connectorSplit(this.currentElement, this.currentTarget);
                                    }
                                }
                                else if (this.currentElement instanceof Selector && !(this.commandHandler.PreventConnectorSplit)) {
                                    if (this.currentElement.nodes[0].children) {
                                        for (i = 0; i < this.currentElement.nodes[0].children.length; i++) {
                                            if (this.currentElement.nodes[0].children[parseInt(i.toString(), 10)] === this.currentTarget.sourceID ||
                                                this.currentElement.nodes[0].children[parseInt(i.toString(), 10)] === this.currentTarget.targetID) {
                                                canSplit = false;
                                            }
                                        }
                                    }
                                    else {
                                        if ((this.currentElement.nodes[0]).id === this.currentTarget.sourceID ||
                                            (this.currentElement.nodes[0]).id === this.currentTarget.targetID) {
                                            canSplit = false;
                                        }
                                    }
                                    if (canSplit) {
                                        this.commandHandler.connectorSplit(this.currentElement.nodes[0], this.currentTarget);
                                        this.commandHandler.PreventConnectorSplit = false;
                                    }
                                }
                            }
                        }
                        arg = {
                            element: args.source, target: this.currentTarget, position: this.currentPosition, cancel: false
                        };
                        this.commandHandler.triggerEvent(DiagramEvent.drop, arg);
                        if (!arg.cancel && args.source && this.commandHandler.isParentAsContainer(this.currentTarget) && !this.commandHandler.isTargetSubProcess(this.currentTarget)) {
                            nodes = (args.source instanceof Selector) ? args.source.nodes : [args.source];
                            isEndGroup = false;
                            for (i = 0; i < nodes.length; i++) {
                                if (nodes[0].parentId === nodes[parseInt(i.toString(), 10)].parentId) ;
                                else {
                                    break;
                                }
                            }
                            // 902192: Diagram node resized wrongly while dragging and drop on multiple selected nodes in another lane Issue Fix
                            if (this.commandHandler.diagram.selectedItems.nodes.length !== nodes.length) {
                                nodes = this.commandHandler.diagram.selectedItems.nodes;
                            }
                            if (this.commandHandler.diagram.selectedItems.nodes.length > 1) {
                                //929543: To calculate the difference between the target lane bounds and selector bounds.
                                // We use this difference values to set the margin left and margin top for the child nodes of lane.
                                nodes = this.calculateDiff(this.commandHandler.diagram.selectedItems, this.currentTarget, this.commandHandler.diagram);
                                this.commandHandler.diagram.multiselect = true;
                            }
                            else {
                                this.commandHandler.diagram.multiselect = false;
                            }
                            for (i = 0; i < nodes.length; i++) {
                                if (!nodes[parseInt(i.toString(), 10)].container && !(this.commandHandler.diagram.cancelPositionChange)) {
                                    isEndGroup = true;
                                    this.commandHandler.updateLaneChildrenZindex(nodes[parseInt(i.toString(), 10)], this.currentTarget);
                                    this.commandHandler.dropChildToContainer(this.currentTarget, nodes[parseInt(i.toString(), 10)]);
                                    this.commandHandler.renderContainerHelper(nodes[parseInt(i.toString(), 10)]);
                                }
                            }
                            //929543: To update the lane size based on the dropped child nodes entire bounds.
                            if (nodes.length > 1) {
                                helper = this.commandHandler.diagram.nameTable['helper'];
                                if (helper) {
                                    updateLaneBoundsWithSelector(this.currentTarget, helper, this.commandHandler.diagram);
                                }
                            }
                            if (historyAdded && this.commandHandler.isContainer && isEndGroup) {
                                this.commandHandler.endGroupAction();
                            }
                        }
                    }
                    if (args.source && this.currentTarget) {
                        this.commandHandler.dropAnnotation(args.source, this.currentTarget);
                    }
                    this.commandHandler.updateSelector();
                    if (historyAdded && !this.commandHandler.isContainer) {
                        this.commandHandler.endGroupAction();
                    }
                }
                else {
                    redoObject.nodes.push(cloneObject(args.source));
                    args.portId = this.portId;
                    obj = cloneObject(redoObject);
                    entry = {
                        type: 'PortPositionChanged', objectId: this.portId,
                        redoObject: cloneObject(obj), undoObject: cloneObject(this.undoElement), category: 'Internal'
                    };
                    this.commandHandler.addHistoryEntry(entry);
                    port = this.getPort(args);
                    if (port) {
                        nodePorts = this.undoElement.nodes.length > 0 ? this.undoElement.nodes[0].ports : [];
                        connPorts = this.undoElement.connectors.length > 0 ? this.undoElement.connectors[0].ports : [];
                        for (i = 0; i < nodePorts.length; i++) {
                            if (port.id === nodePorts[parseInt(i.toString(), 10)].id) {
                                oldValues = {
                                    offsetX: nodePorts[parseInt(i.toString(), 10)].offset.x,
                                    offsetY: nodePorts[parseInt(i.toString(), 10)].offset.y
                                };
                                newValues = { offsetX: port.offset.x, offsetY: port.offset.y };
                                break;
                            }
                        }
                        for (i = 0; i < connPorts.length; i++) {
                            if (port.id === connPorts[parseInt(i.toString(), 10)].id) {
                                oldValues = {
                                    offset: connPorts[parseInt(i.toString(), 10)].offset
                                };
                                newValues = { offset: port.offset };
                                break;
                            }
                        }
                    }
                    arg = {
                        source: port, state: 'Completed', oldValue: oldValues, newValue: newValues,
                        target: this.currentTarget, targetPosition: this.currentPosition, allowDrop: true, cancel: false
                    };
                    this.commandHandler.triggerEvent(DiagramEvent.positionChange, arg);
                }
                // this.commandHandler.updateBlazorSelector();
                _super.prototype.mouseUp.call(this, args);
                return [2 /*return*/];
            });
        });
    };
    MoveTool.prototype.clearDiff = function (nodes) {
        nodes.forEach(function (node, index) {
            delete node.diffX;
            delete node.diffY;
        });
    };
    MoveTool.prototype.calculateDiff = function (selector, target, diagram) {
        this.clearDiff(selector.nodes);
        var selectorLeft = selector.wrapper.bounds.left;
        var selectorTop = selector.wrapper.bounds.top;
        var targetLeft = target.wrapper.bounds.left;
        var targetTop = target.wrapper.bounds.top;
        var diffLeft;
        var diffTop;
        var swimlane = diagram.nameTable[target.parentId];
        if (target.columnIndex === 0 && swimlane && swimlane.shape.orientation === 'Horizontal') {
            targetLeft += 50;
        }
        if (target.rowIndex === 1 && swimlane && swimlane.shape.orientation === 'Vertical') {
            targetTop += 50;
        }
        if (selectorLeft < targetLeft) {
            diffLeft = targetLeft - selectorLeft;
        }
        else {
            diffLeft = 0;
        }
        if (selectorTop < targetTop) {
            diffTop = targetTop - selectorTop;
        }
        else {
            diffTop = 0;
        }
        var nodes = selector.nodes;
        nodes.forEach(function (node, index) {
            node.diffX = diffLeft;
            node.diffY = diffTop;
        });
        return nodes;
    };
    //EJ2-59309-While drag the connected node the connector endPointChange event does not get trigger
    MoveTool.prototype.connectorEndPointChangeEvent = function (arg, snappedPoint) {
        var selectedElement = arg.source;
        if (selectedElement instanceof Selector && selectedElement.nodes.length > 0) {
            for (var i = 0; i < selectedElement.nodes.length; i++) {
                var node = selectedElement.nodes[parseInt(i.toString(), 10)];
                if (node && node.inEdges.length > 0) {
                    for (var j = 0; j < node.inEdges.length; j++) {
                        var connector = this.commandHandler.diagram.getObject(node.inEdges[parseInt(j.toString(), 10)]);
                        this.triggerEndPointEvent(connector, arg, snappedPoint, 'targetPointChange');
                    }
                }
                if (node && node.outEdges.length > 0) {
                    for (var j = 0; j < node.outEdges.length; j++) {
                        var connector = this.commandHandler.diagram.getObject(node.outEdges[parseInt(j.toString(), 10)]);
                        this.triggerEndPointEvent(connector, arg, snappedPoint, 'sourcePointChange');
                    }
                }
            }
        }
    };
    MoveTool.prototype.triggerEndPointEvent = function (connector, arg, snappedPoint, eventName) {
        var args = {
            connector: connector, state: arg.state, targetNode: connector.targetID, targetPort: connector.targetPortID,
            sourceNode: connector.sourceID, sourcePort: connector.sourcePortID, oldValue: { x: connector.targetPoint.x, y: connector.targetPoint.y },
            newValue: { x: connector.targetPoint.x + (snappedPoint ? snappedPoint.x : 0), y: connector.targetPoint.y + (snappedPoint ? snappedPoint.y : 0) }, cancel: arg.cancel
        };
        this.commandHandler.triggerEvent((eventName === 'targetPointChange') ? DiagramEvent.targetPointChange : DiagramEvent.sourcePointChange, args);
    };
    MoveTool.prototype.isSelectionHasConnector = function (args) {
        if (args.nodes && args.connectors && args.nodes.length > 0 && args.connectors.length > 0 &&
            (args.width !== this.undoElement.width || args.height !== this.undoElement.height)) {
            return true;
        }
        return false;
    };
    // private getBlazorPositionChangeEventArgs(args: IDraggingEventArgs | IBlazorDraggingEventArgs, target: IElement): any {
    // args = {
    //     source: cloneBlazorObject(args.source), state: args.state, oldValue: args.oldValue, newValue: args.newValue,
    //     target: getObjectType(target) === Connector ? { connector: cloneBlazorObject(target) }
    //         : { node: cloneBlazorObject(target) },
    //     targetPosition: this.currentPosition, allowDrop: true, cancel: false
    // };
    // return args as IBlazorDraggingEventArgs;
    // }
    /* tslint:disable */
    /**
     * @param args
     * @private
     */
    MoveTool.prototype.mouseMove = function (args) {
        _super.prototype.mouseMove.call(this, args);
        var isSame = false;
        var object;
        object = this.commandHandler.renderContainerHelper(args.source) ||
            args.source;
        if (object instanceof Node || object instanceof Connector) {
            if (object instanceof Node) {
                if (object.offsetX === this.undoElement.nodes[0].offsetX &&
                    object.offsetY === this.undoElement.nodes[0].offsetY) {
                    isSame = true;
                }
            }
            else {
                if (Point.equals(object.sourcePoint, this.undoElement.connectors[0].sourcePoint) &&
                    Point.equals(object.targetPoint, this.undoElement.connectors[0].targetPoint)) {
                    isSame = true;
                }
            }
        }
        else {
            if (object.wrapper.offsetX === this.undoElement.wrapper.offsetX &&
                object.wrapper.offsetY === this.undoElement.wrapper.offsetY) {
                isSame = true;
            }
        }
        var oldValues;
        if (object) {
            oldValues = { offsetX: object.wrapper.offsetX, offsetY: object.wrapper.offsetY };
        }
        var arg = {
            source: object, state: 'Start', oldValue: oldValues, newValue: oldValues,
            target: args.target, targetPosition: args.position, allowDrop: true, cancel: false
        };
        arg = {
            source: cloneBlazorObject(object), state: 'Start', oldValue: cloneBlazorObject(oldValues),
            newValue: cloneBlazorObject(oldValues),
            target: args.target, targetPosition: args.position, allowDrop: arg.allowDrop, cancel: arg.cancel
        };
        //EJ2-909578: - Position change incorrect event args value for port dragging
        if (this.objectType === 'Port') {
            var port = this.getPort(args);
            if (port) {
                var nodePorts = this.undoElement.nodes.length > 0 ? this.undoElement.nodes[0].ports : [];
                var connPorts = this.undoElement.connectors.length > 0 ? this.undoElement.connectors[0].ports : [];
                for (var i = 0; i < nodePorts.length; i++) {
                    oldValues = { offsetX: port.offset.x, offsetY: port.offset.y };
                    if (port.offset.x !== nodePorts[parseInt(i.toString(), 10)].offset.x || port.offset.y !== nodePorts[parseInt(i.toString(), 10)].offset.y) {
                        isSame = false;
                        break;
                    }
                }
                for (var i = 0; i < connPorts.length; i++) {
                    oldValues = { offset: port.offset };
                    if (port.offset !== connPorts[parseInt(i.toString(), 10)].offset) {
                        isSame = false;
                        break;
                    }
                }
            }
            arg = {
                source: port, state: 'Start', oldValue: oldValues, newValue: oldValues,
                target: args.target, targetPosition: args.position, allowDrop: true, cancel: false
            };
        }
        //(EJ2-277624)-In the positionChange event, during the completed state, old and new values remain identical.
        if (!this.isStartAction) {
            this.intialValue = { offsetX: object.wrapper.offsetX, offsetY: object.wrapper.offsetY };
            if ((this.commandHandler.diagram.lineRoutingModule &&
                (this.commandHandler.diagram.constraints & DiagramConstraints.LineRouting)
                && (this.commandHandler.diagram.layout.type !== 'ComplexHierarchicalTree'))) {
                var INFLATE_MARGIN = 40;
                var nodeBounds = getBounds(object.wrapper);
                nodeBounds.Inflate(INFLATE_MARGIN);
                var nearbyObjects = this.commandHandler.diagram.spatialSearch.findObjects(nodeBounds);
                for (var _i = 0, nearbyObjects_1 = nearbyObjects; _i < nearbyObjects_1.length; _i++) {
                    var item = nearbyObjects_1[_i];
                    if (item instanceof Connector && this.commandHandler.diagram.routedConnectors.indexOf(item.id) === -1) ;
                }
            }
        }
        if (isSame && !isBlazor()) {
            this.commandHandler.triggerEvent(DiagramEvent.positionChange, arg);
            this.connectorEndPointChangeEvent(arg);
            this.isStartAction = true;
        }
        this.commandHandler.diagram.cancelPositionChange = arg.cancel;
        this.currentPosition = args.position;
        if (this.objectType !== 'Port') {
            var x = this.currentPosition.x - this.prevPosition.x;
            var y = this.currentPosition.y - this.prevPosition.y;
            var diffX = this.initialOffset.x + (this.currentPosition.x - this.prevPosition.x);
            var diffY = this.initialOffset.y + (this.currentPosition.y - this.prevPosition.y);
            this.commandHandler.dragOverElement(args, this.currentPosition);
            this.commandHandler.disConnect(args.source);
            this.commandHandler.removeSnap();
            var oldValues_1;
            var newValues = void 0;
            var snappedPoint = this.commandHandler.snapPoint(this.prevPosition, this.currentPosition, diffX, diffY);
            this.initialOffset.x = diffX - snappedPoint.x;
            this.initialOffset.y = diffY - snappedPoint.y;
            if (object) {
                oldValues_1 = { offsetX: object.wrapper.offsetX, offsetY: object.wrapper.offsetY };
                newValues = {
                    offsetX: object.wrapper.offsetX + snappedPoint.x,
                    offsetY: object.wrapper.offsetY + snappedPoint.y
                };
            }
            if (this.currentTarget && args.target !== this.currentTarget) {
                this.commandHandler.removeChildFromBPmn(args.source, args.target, this.currentTarget);
            }
            this.currentTarget = args.target;
            var arg_1 = {
                source: object, state: 'Progress', oldValue: oldValues_1, newValue: newValues,
                target: args.target, targetPosition: args.position, allowDrop: true, cancel: false
            };
            this.commandHandler.triggerEvent(DiagramEvent.positionChange, arg_1);
            this.commandHandler.diagram.cancelPositionChange = arg_1.cancel;
            this.canTrigger = true;
            this.connectorEndPointChangeEvent(arg_1, snappedPoint);
            if (!arg_1.cancel && !this.canCancel) {
                this.blocked = !this.commandHandler.dragSelectedObjects(snappedPoint.x, snappedPoint.y);
                var blocked = !(this.commandHandler.mouseOver(this.currentElement, this.currentTarget, this.currentPosition));
                this.blocked = this.blocked || blocked;
            }
            this.commandHandler.removeStackHighlighter();
            this.commandHandler.renderStackHighlighter(args);
            if (this.currentTarget && (args.source !== this.currentTarget) &&
                this.commandHandler.isDroppable(args.source, this.currentTarget) && args.source.id !== 'helper') {
                var object_1 = (args.source instanceof Selector) ? args.source.nodes[0] : args.source;
                if ((!this.commandHandler.isParentAsContainer(object_1, true))
                    && (object_1.shape.type !== 'SwimLane' && !object_1.shape.isPhase)) {
                    if (this.currentTarget.isLane) {
                        this.commandHandler.renderStackHighlighter(args, this.currentTarget);
                    }
                    else {
                        this.commandHandler.drawHighlighter(this.currentTarget);
                    }
                }
            }
            else {
                this.commandHandler.removeHighlighter();
            }
            if (this.commandHandler.canEnableDefaultTooltip()) {
                var content_2 = this.getTooltipContent(args.source);
                var contentTemp = function () {
                    return content_2;
                };
                this.commandHandler.showTooltip(args.source, args.position, initializeCSPTemplate(contentTemp), 'MoveTool', this.isTooltipVisible);
                this.isTooltipVisible = false;
            }
        }
        else {
            var matrix = identityMatrix();
            var node = args.source;
            var oldValues_2;
            var newValues = void 0;
            var nodePorts = this.undoElement.nodes.length > 0 ? this.undoElement.nodes[0].ports : [];
            var connPorts = this.undoElement.connectors.length > 0 ? this.undoElement.connectors[0].ports : [];
            var port = this.getPort(args);
            if (port) {
                for (var i = 0; i < nodePorts.length; i++) {
                    oldValues_2 = { offsetX: port.offset.x, offsetY: port.offset.y };
                    break;
                }
                for (var i = 0; i < connPorts.length; i++) {
                    oldValues_2 = { offset: port.offset };
                    break;
                }
            }
            rotateMatrix(matrix, -node.rotateAngle || -node.wrapper.rotateAngle, node.offsetX || node.wrapper.offsetX, node.offsetY || node.wrapper.offsetY);
            var prevPosition = transformPointByMatrix(matrix, { x: this.prevPosition.x, y: this.prevPosition.y });
            var position = transformPointByMatrix(matrix, { x: args.position.x, y: args.position.y });
            this.commandHandler.portDrag(args.source, args.sourceWrapper, position.x - prevPosition.x, position.y - prevPosition.y);
            //EJ2-909578: - Position change incorrect event args value for port dragging
            //Required correction on data type
            if (port) {
                for (var i = 0; i < nodePorts.length; i++) {
                    newValues = { offsetX: port.offset.x, offsetY: port.offset.y };
                    break;
                }
                for (var i = 0; i < connPorts.length; i++) {
                    newValues = { offset: port.offset };
                    break;
                }
            }
            var arg_2 = {
                source: port, state: 'Progress', oldValue: oldValues_2, newValue: newValues,
                target: args.target, targetPosition: args.position, allowDrop: true, cancel: false
            };
            this.commandHandler.triggerEvent(DiagramEvent.positionChange, arg_2);
        }
        this.prevPosition = this.currentPosition;
        return !this.blocked;
    };
    MoveTool.prototype.getTooltipContent = function (node) {
        return 'X:' + Math.round(node.wrapper.bounds.x) + ' ' + 'Y:' + Math.round(node.wrapper.bounds.y);
    };
    /**
     * @param args
     * @private
     */
    MoveTool.prototype.mouseLeave = function (args) {
        this.mouseUp(args);
    };
    /**   @private  */
    MoveTool.prototype.endAction = function () {
        _super.prototype.endAction.call(this);
        this.currentTarget = null;
        this.prevPosition = null;
    };
    return MoveTool;
}(ToolBase));
/**
 * Rotates the selected objects
 */
var RotateTool = /** @class */ (function (_super) {
    __extends$g(RotateTool, _super);
    function RotateTool(commandHandler) {
        var _this = _super.call(this, commandHandler, true) || this;
        /** @private */
        _this.rotateStart = false;
        return _this;
    }
    /**
     * @param args
     * @private
     */
    RotateTool.prototype.mouseDown = function (args) {
        this.undoElement = cloneObject(args.source);
        if (this.undoElement.nodes[0] && this.undoElement.nodes[0].children) {
            var objects = [];
            var nodes = this.commandHandler.getAllDescendants(this.undoElement.nodes[0], objects);
            for (var i = 0; i < nodes.length; i++) {
                var node = this.commandHandler.cloneChild(nodes[parseInt(i.toString(), 10)].id);
                this.childTable[nodes[parseInt(i.toString(), 10)].id] = cloneObject(node);
            }
        }
        _super.prototype.mouseDown.call(this, args);
    };
    /**
     * @param args
     * @private
     */
    RotateTool.prototype.mouseUp = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var object, oldValue, newValue, arg, obj, entry;
            return __generator(this, function (_a) {
                this.checkPropertyValue();
                object = this.commandHandler.renderContainerHelper(args.source) || args.source;
                if (this.undoElement.rotateAngle !== object.wrapper.rotateAngle) {
                    oldValue = { rotateAngle: this.undoElement.rotateAngle };
                    newValue = { rotateAngle: object.wrapper.rotateAngle };
                    arg = {
                        source: args.source, state: 'Completed', oldValue: oldValue,
                        newValue: newValue, cancel: false
                    };
                    this.commandHandler.triggerEvent(DiagramEvent.rotateChange, arg);
                    obj = void 0;
                    obj = cloneObject(args.source);
                    entry = {
                        type: 'RotationChanged', redoObject: cloneObject(obj), undoObject: cloneObject(this.undoElement), category: 'Internal',
                        childTable: this.childTable
                    };
                    this.commandHandler.addHistoryEntry(entry);
                    this.commandHandler.updateSelector();
                    this.rotateStart = false;
                }
                // this.commandHandler.updateBlazorSelector();
                this.canCancel = undefined;
                this.tempArgs = undefined;
                _super.prototype.mouseUp.call(this, args);
                return [2 /*return*/];
            });
        });
    };
    /**
     * @param args
     * @private
     */
    RotateTool.prototype.mouseMove = function (args) {
        _super.prototype.mouseMove.call(this, args);
        var object;
        object = this.commandHandler.renderContainerHelper(args.source) || args.source;
        if (this.undoElement.rotateAngle === object.wrapper.rotateAngle && !this.rotateStart) {
            var oldValue_1 = { rotateAngle: object.wrapper.rotateAngle };
            var arg_3 = {
                source: args.source, state: 'Start', oldValue: oldValue_1, newValue: oldValue_1, cancel: false
            };
            this.commandHandler.triggerEvent(DiagramEvent.rotateChange, arg_3);
            this.rotateStart = true;
        }
        this.currentPosition = args.position;
        var refPoint = { x: object.wrapper.offsetX, y: object.wrapper.offsetY };
        var angle = Point.findAngle(refPoint, this.currentPosition) + 90;
        var snapAngle = this.commandHandler.snapAngle(angle);
        angle = snapAngle !== 0 ? snapAngle : angle;
        angle = (angle + 360) % 360;
        var oldValue = { rotateAngle: object.wrapper.rotateAngle };
        var newValue = { rotateAngle: angle };
        var arg = {
            source: args.source, state: 'Progress', oldValue: oldValue,
            newValue: newValue, cancel: false
        };
        var arg1 = {
            source: cloneBlazorObject(args.source), state: 'Progress', oldValue: cloneBlazorObject(oldValue),
            newValue: cloneBlazorObject(newValue), cancel: arg.cancel
        };
        this.commandHandler.triggerEvent(DiagramEvent.rotateChange, arg1);
        if (!arg1.cancel) {
            this.blocked = !(this.commandHandler.rotateSelectedItems(angle - object.wrapper.rotateAngle));
        }
        if (this.commandHandler.canEnableDefaultTooltip()) {
            var content_3 = this.getTooltipContent(args.source);
            var contentTemp = function () {
                return content_3;
            };
            this.commandHandler.showTooltip(args.source, args.position, initializeCSPTemplate(contentTemp), 'RotateTool', this.isTooltipVisible);
            this.isTooltipVisible = false;
        }
        return !this.blocked;
    };
    RotateTool.prototype.getTooltipContent = function (node) {
        return Math.round((node.rotateAngle % 360)).toString() + '\xB0';
    };
    /**
     * @param args
     * @private
     */
    RotateTool.prototype.mouseLeave = function (args) {
        this.mouseUp(args);
    };
    /**   @private  */
    RotateTool.prototype.endAction = function () {
        _super.prototype.endAction.call(this);
    };
    return RotateTool;
}(ToolBase));
/**
 * Scales the selected objects
 */
var ResizeTool = /** @class */ (function (_super) {
    __extends$g(ResizeTool, _super);
    function ResizeTool(commandHandler, corner) {
        var _this = _super.call(this, commandHandler, true) || this;
        /** @private */
        _this.resizeStart = false;
        /**   @private  */
        _this.initialBounds = new Rect();
        _this.canCancel = false;
        _this.corner = corner;
        return _this;
    }
    /**
     * @param args
     * @private
     */
    ResizeTool.prototype.mouseDown = function (args) {
        this.undoElement = cloneObject(args.source);
        this.undoParentElement = this.commandHandler.getSubProcess(args.source);
        _super.prototype.mouseDown.call(this, args);
        if (this.undoElement.nodes[0] && this.undoElement.nodes[0].children) {
            var elements = [];
            var nodes = this.commandHandler.getAllDescendants(this.undoElement.nodes[0], elements);
            for (var i = 0; i < nodes.length; i++) {
                var node = this.commandHandler.cloneChild(nodes[parseInt(i.toString(), 10)].id);
                this.childTable[nodes[parseInt(i.toString(), 10)].id] = cloneObject(node);
            }
        }
        this.commandHandler.checkSelection(args.source, this.corner);
        _super.prototype.mouseDown.call(this, args);
        this.initialBounds.x = args.source.wrapper.offsetX;
        this.initialBounds.y = args.source.wrapper.offsetY;
        this.initialBounds.height = args.source.wrapper.actualSize.height;
        this.initialBounds.width = args.source.wrapper.actualSize.width;
    };
    /**
     * @param args
     * @param isPreventHistory
     * @param args
     * @param isPreventHistory
     * @private
     */
    ResizeTool.prototype.mouseUp = function (args, isPreventHistory) {
        return __awaiter(this, void 0, void 0, function () {
            var object, deltaValues, oldValue, arg, obj, entry, entry_2;
            return __generator(this, function (_a) {
                this.checkPropertyValue();
                this.commandHandler.removeSnap();
                this.commandHandler.updateSelector();
                object = this.commandHandler.renderContainerHelper(args.source) || args.source;
                if ((this.undoElement.offsetX !== object.wrapper.offsetX || this.undoElement.offsetY !== object.wrapper.offsetY ||
                    this.undoElement.width !== object.wrapper.bounds.width || this.undoElement.height !== object.wrapper.bounds.height)) {
                    deltaValues = this.updateSize(args.source, this.currentPosition, this.prevPosition, this.corner, this.initialBounds);
                    this.blocked = this.scaleObjects(deltaValues.width, deltaValues.height, this.corner, this.currentPosition, this.prevPosition, object);
                    oldValue = {
                        width: args.source.wrapper.actualSize.width, height: args.source.wrapper.actualSize.height
                    };
                    arg = {
                        source: cloneBlazorObject(args.source), state: 'Completed',
                        oldValue: this.startValues, newValue: oldValue, cancel: false
                    };
                    this.commandHandler.triggerEvent(DiagramEvent.sizeChange, arg);
                    obj = cloneObject(args.source);
                    entry = {
                        type: 'SizeChanged', redoObject: cloneObject(obj), undoObject: cloneObject(this.undoElement), category: 'Internal',
                        childTable: this.childTable
                    };
                    this.resizeStart = false;
                    if (!isPreventHistory) {
                        this.commandHandler.startGroupAction();
                        this.commandHandler.addHistoryEntry(entry);
                        if (obj.nodes[0] && obj.nodes[0].processId) {
                            entry_2 = {
                                type: 'SizeChanged', redoObject: this.commandHandler.getSubProcess(args.source),
                                undoObject: this.undoParentElement, category: 'Internal'
                            };
                            this.commandHandler.addHistoryEntry(entry_2);
                        }
                        this.commandHandler.endGroupAction();
                    }
                }
                // this.commandHandler.updateBlazorSelector();
                _super.prototype.mouseUp.call(this, args);
                return [2 /*return*/, !this.blocked];
            });
        });
    };
    /**
     * @param args
     * @private
     */
    ResizeTool.prototype.mouseMove = function (args) {
        _super.prototype.mouseMove.call(this, args);
        var object;
        object = this.commandHandler.renderContainerHelper(args.source) || args.source;
        if (this.undoElement.offsetX === object.wrapper.offsetX && this.undoElement.offsetY === object.wrapper.offsetY && !this.resizeStart) {
            var oldValue = {
                width: args.source.wrapper.actualSize.width, height: args.source.wrapper.actualSize.height
            };
            //EJ2-866122 - Need to enhance the sizeChange Event
            this.startValues = oldValue;
            var arg = {
                source: args.source, state: 'Start', oldValue: oldValue, newValue: this.currentElement, cancel: false
            };
            this.commandHandler.triggerEvent(DiagramEvent.sizeChange, arg);
            this.resizeStart = true;
        }
        this.currentPosition = args.position;
        var x = this.currentPosition.x - this.startPosition.x;
        var y = this.currentPosition.y - this.startPosition.y;
        var changes = { x: x, y: y };
        changes = rotatePoint(-this.currentElement.wrapper.rotateAngle, undefined, undefined, changes);
        var sx = (this.currentElement.wrapper.actualSize.width + changes.x) / this.currentElement.wrapper.actualSize.width;
        var sy = (this.currentElement.wrapper.actualSize.height + changes.y) / this.currentElement.wrapper.actualSize.height;
        changes = this.getChanges(changes);
        this.commandHandler.removeSnap();
        var deltaValues = this.updateSize(args.source, this.startPosition, this.currentPosition, this.corner, this.initialBounds);
        this.blocked = !(this.scaleObjects(deltaValues.width, deltaValues.height, this.corner, this.startPosition, this.currentPosition, object));
        if (this.commandHandler.canEnableDefaultTooltip()) {
            var content_4 = this.getTooltipContent(args.source);
            //Task 834121: Content-Security-Policy support for diagram
            var contentTemp = function () {
                return content_4;
            };
            this.commandHandler.showTooltip(args.source, args.position, initializeCSPTemplate(contentTemp), 'ResizeTool', this.isTooltipVisible);
            this.isTooltipVisible = false;
        }
        this.prevPosition = this.currentPosition;
        return !this.blocked;
    };
    /**
     * @param args
     * @private
     */
    ResizeTool.prototype.mouseLeave = function (args) {
        this.mouseUp(args);
    };
    ResizeTool.prototype.getTooltipContent = function (node) {
        return 'W:' + Math.round(node.wrapper.bounds.width) + ' ' + 'H:' + Math.round(node.wrapper.bounds.height);
    };
    ResizeTool.prototype.getChanges = function (change) {
        switch (this.corner) {
            case 'ResizeEast':
                return { x: change.x, y: 0 };
            case 'ResizeSouthEast':
                return change;
            case 'ResizeSouth':
                return { x: 0, y: change.y };
            case 'ResizeNorth':
                return { x: 0, y: -change.y };
            case 'ResizeNorthEast':
                return { x: change.x, y: -change.y };
            case 'ResizeNorthWest':
                return { x: -change.x, y: -change.y };
            case 'ResizeWest':
                return { x: -change.x, y: 0 };
            case 'ResizeSouthWest':
                return { x: -change.x, y: change.y };
        }
        return change;
    };
    /**
     * Updates the size with delta width and delta height using scaling.
     */
    /**
     * Aspect ratio used to resize the width or height based on resizing the height or width
     *
     * @param deltaWidth
     * @param deltaHeight
     * @param corner
     * @param startPoint
     * @param endPoint
     * @param source
     * @param deltaWidth
     * @param deltaHeight
     * @param corner
     * @param startPoint
     * @param endPoint
     * @param source
     * @param deltaWidth
     * @param deltaHeight
     * @param corner
     * @param startPoint
     * @param endPoint
     * @param source
     * @param deltaWidth
     * @param deltaHeight
     * @param corner
     * @param startPoint
     * @param endPoint
     * @param source
     * @param deltaWidth
     * @param deltaHeight
     * @param corner
     * @param startPoint
     * @param endPoint
     * @param source
     * @param deltaWidth
     * @param deltaHeight
     * @param corner
     * @param startPoint
     * @param endPoint
     * @param source
     */
    ResizeTool.prototype.scaleObjects = function (deltaWidth, deltaHeight, corner, startPoint, endPoint, source) {
        if (source instanceof Selector && source.nodes.length === 1 && source.nodes[0].constraints & NodeConstraints.AspectRatio) {
            if (corner === 'ResizeWest' || corner === 'ResizeEast' || corner === 'ResizeNorth' || corner === 'ResizeSouth') {
                if (!(deltaHeight === 1 && deltaWidth === 1)) {
                    deltaHeight = deltaWidth = Math.max(deltaHeight === 1 ? 0 : deltaHeight, deltaWidth === 1 ? 0 : deltaWidth);
                }
            }
            else {
                deltaHeight = deltaWidth = Math.max(deltaHeight, deltaWidth);
            }
        }
        var oldValue = {
            width: source.width, height: source.height
        };
        this.blocked = this.commandHandler.scaleSelectedItems(deltaWidth, deltaHeight, this.getPivot(this.corner));
        var newValue = {
            width: source.width, height: source.height
        };
        var arg;
        arg = { source: source, state: 'Progress', oldValue: oldValue, newValue: newValue, cancel: false };
        var arg1;
        arg1 = {
            source: cloneBlazorObject(source), state: 'Progress',
            oldValue: cloneBlazorObject(oldValue), newValue: cloneBlazorObject(newValue), cancel: arg.cancel
        };
        this.commandHandler.triggerEvent(DiagramEvent.sizeChange, arg1);
        if (arg1.cancel || this.canCancel) {
            this.commandHandler.scaleSelectedItems(1 / deltaWidth, 1 / deltaHeight, this.getPivot(this.corner));
        }
        return this.blocked;
    };
    return ResizeTool;
}(ToolBase));
/**
 * Draws a node that is defined by the user
 */
var NodeDrawingTool = /** @class */ (function (_super) {
    __extends$g(NodeDrawingTool, _super);
    function NodeDrawingTool(commandHandler, sourceObject) {
        var _this = _super.call(this, commandHandler, true) || this;
        _this.sourceObject = sourceObject;
        return _this;
    }
    /**
     * @param args
     * @private
     */
    NodeDrawingTool.prototype.mouseDown = function (args) {
        _super.prototype.mouseDown.call(this, args);
        this.inAction = true;
        this.commandHandler.setFocus();
        this.triggerElementDrawEvent(args.source, 'Start', 'Node', this.getShapeType(), true);
    };
    /**
     * @param args
     * @private
     */
    NodeDrawingTool.prototype.mouseMove = function (args) {
        _super.prototype.mouseMove.call(this, args);
        var checkBoundaryConstraints;
        var node = {
            offsetX: this.currentPosition.x, width: 3, height: 3,
            offsetY: this.currentPosition.y
        };
        if (!this.drawingObject) {
            this.drawingObject = this.commandHandler.drawObject(node);
        }
        this.triggerElementDrawEvent(this.drawingObject, 'Progress', 'Node', this.getShapeType(), false);
        if (this.inAction && Point.equals(this.currentPosition, this.prevPosition) === false) {
            var rect = Rect.toBounds([this.prevPosition, this.currentPosition]);
            checkBoundaryConstraints = this.commandHandler.checkBoundaryConstraints(undefined, undefined, rect);
            if (checkBoundaryConstraints) {
                this.commandHandler.updateNodeDimension(this.drawingObject, rect);
            }
        }
        return checkBoundaryConstraints;
    };
    /**
     * @param args
     * @private
     */
    NodeDrawingTool.prototype.mouseUp = function (args) {
        this.checkPropertyValue();
        var checkBoundaryConstraints;
        var rect = Rect.toBounds([this.prevPosition, this.currentPosition]);
        checkBoundaryConstraints = this.commandHandler.checkBoundaryConstraints(undefined, undefined, rect);
        if (this.drawingObject && this.drawingObject instanceof Node) {
            this.commandHandler.addObjectToDiagram(this.drawingObject);
            this.triggerElementDrawEvent(this.drawingObject, 'Completed', 'Node', this.getShapeType(), false);
            this.drawingObject = null;
        }
        // this.commandHandler.updateBlazorSelector();
        _super.prototype.mouseUp.call(this, args);
        this.inAction = false;
    };
    /**   @private  */
    NodeDrawingTool.prototype.endAction = function () {
        _super.prototype.endAction.call(this);
    };
    /**
     * @param args
     * @private
     */
    NodeDrawingTool.prototype.mouseLeave = function (args) {
        if (this.inAction) {
            this.mouseUp(args);
        }
    };
    return NodeDrawingTool;
}(ToolBase));
/**
 * Draws a connector that is defined by the user
 */
var ConnectorDrawingTool = /** @class */ (function (_super) {
    __extends$g(ConnectorDrawingTool, _super);
    function ConnectorDrawingTool(commandHandler, endPoint, sourceObject) {
        var _this = _super.call(this, commandHandler, endPoint) || this;
        _this.sourceObject = sourceObject;
        return _this;
    }
    /**
     * @param args
     * @private
     */
    ConnectorDrawingTool.prototype.mouseDown = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                _super.prototype.mouseDown.call(this, args);
                this.inAction = true;
                this.commandHandler.setFocus();
                this.triggerElementDrawEvent(args.source, 'Start', 'Connector', this.commandHandler.diagram.drawingObject.type, true);
                return [2 /*return*/];
            });
        });
    };
    /**
     * @param args
     * @private
     */
    ConnectorDrawingTool.prototype.mouseMove = function (args) {
        this.commandHandler.enableServerDataBinding(false);
        if (this.inAction) {
            var connector = {
                sourcePoint: this.currentPosition, targetPoint: this.currentPosition
            };
            if (!this.drawingObject) {
                this.drawingObject = this.commandHandler.drawObject(connector);
            }
            args.source = this.drawingObject;
            this.triggerElementDrawEvent(args.source, 'Progress', 'Connector', this.drawingObject.type, false);
            //Bug 874781: Port Draw Connection is not proper with group node.
            if (args.actualObject && (args.actualObject.parentId || args.actualObject.children) && this.drawingObject.sourceID === '') {
                this.setTarget(args);
            }
            if (((args.target && args.target instanceof Node) || (args.actualObject && args.sourceWrapper && checkPort(args.actualObject, args.sourceWrapper)))
                && (this.endPoint !== 'ConnectorTargetEnd' || (canInConnect(args.target)))) {
                this.commandHandler.connect(this.endPoint, args);
            }
            this.endPoint = 'ConnectorTargetEnd';
        }
        if (!this.inAction) {
            this.commandHandler.updateSelector();
            //EJ2-899368 : Highlighters for Connector Element Draw with userhandle updated wrongly
            if (args.source && !args.source.isLane && args.sourceWrapper) {
                this.commandHandler.renderHighlighter(args, true);
            }
        }
        _super.prototype.mouseMove.call(this, args);
        this.commandHandler.enableServerDataBinding(true);
        return !this.blocked;
    };
    // Sets the target while drawing connector from the group node port or its children port.
    ConnectorDrawingTool.prototype.setTarget = function (args) {
        if (args.target) {
            if (!args.sourceWrapper.id.includes(args.target.id)) {
                if (args.target.parentId && args.sourceWrapper.id.includes(args.target.parentId)) {
                    args.target = this.commandHandler.diagram.nameTable[args.target.parentId];
                }
            }
        }
        else {
            if (!args.sourceWrapper.id.includes(args.actualObject.id)) {
                if (args.actualObject.parentId && args.sourceWrapper.id.includes(args.actualObject.parentId)) {
                    args.target = this.commandHandler.diagram.nameTable[args.actualObject.parentId];
                }
            }
            else {
                args.target = args.actualObject;
            }
        }
    };
    /**
     * @param args
     * @private
     */
    ConnectorDrawingTool.prototype.mouseUp = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.commandHandler.enableServerDataBinding(false);
                this.checkPropertyValue();
                if (this.drawingObject && this.drawingObject instanceof Connector) {
                    this.commandHandler.addObjectToDiagram(this.drawingObject);
                    this.triggerElementDrawEvent(this.drawingObject, 'Completed', 'Connector', this.drawingObject.type, false);
                    this.drawingObject = null;
                }
                // this.commandHandler.updateBlazorSelector();
                this.inAction = false;
                this.commandHandler.enableServerDataBinding(true);
                _super.prototype.mouseUp.call(this, args);
                return [2 /*return*/];
            });
        });
    };
    /**   @private  */
    ConnectorDrawingTool.prototype.endAction = function () {
        _super.prototype.endAction.call(this);
    };
    /**
     * @param args
     * @private
     */
    ConnectorDrawingTool.prototype.mouseLeave = function (args) {
        if (this.inAction) {
            this.mouseUp(args);
        }
    };
    return ConnectorDrawingTool;
}(ConnectTool));
var TextDrawingTool = /** @class */ (function (_super) {
    __extends$g(TextDrawingTool, _super);
    function TextDrawingTool(commandHandler) {
        return _super.call(this, commandHandler, true) || this;
    }
    /**
     * @param args
     * @private
     */
    TextDrawingTool.prototype.mouseDown = function (args) {
        _super.prototype.mouseDown.call(this, args);
        this.commandHandler.clearSelection();
        var node = {
            shape: { type: 'Text' },
            offsetX: this.currentPosition.x,
            offsetY: this.currentPosition.y
        };
        if (!args.source) {
            this.drawingNode = this.commandHandler.drawObject(node);
        }
    };
    /**
     * @param args
     * @private
     */
    TextDrawingTool.prototype.mouseMove = function (args) {
        _super.prototype.mouseMove.call(this, args);
        if (!this.drawingNode) {
            var node = {
                shape: { type: 'Text' }, offsetX: this.currentPosition.x, width: 30, height: 30,
                // EJ2-42640-Text size is different if Text Node is created over another diagram commited by sivakumar sekar
                // commanded style property and added it after the object is drawn
                // style: { strokeDashArray: '2 2', fill: 'transparent' },
                offsetY: this.currentPosition.y
            };
            this.drawingNode = this.commandHandler.drawObject(node);
            this.drawingNode.style.strokeDashArray = '2 2';
            this.drawingNode.style.fill = 'transparent';
        }
        else {
            this.drawingNode.style.strokeColor = 'black';
            this.drawingNode.style.strokeDashArray = '2 2';
            this.drawingNode.style.fill = 'transparent';
        }
        if (this.inAction && Point.equals(this.currentPosition, this.prevPosition) === false) {
            var rect = Rect.toBounds([this.prevPosition, this.currentPosition]);
            this.commandHandler.updateNodeDimension(this.drawingNode, rect);
        }
        return !this.blocked;
    };
    /**
     * @param args
     * @private
     */
    TextDrawingTool.prototype.mouseUp = function (args) {
        this.checkPropertyValue();
        if (this.drawingNode) {
            this.drawingNode.style.strokeColor = 'none';
            this.drawingNode.style.fill = 'none';
        }
        else {
            this.drawingNode = args.source;
        }
        if (this.drawingNode && (this.drawingNode instanceof Node)) {
            this.commandHandler.addText(this.drawingNode, this.currentPosition);
        }
        _super.prototype.mouseUp.call(this, args);
        this.inAction = false;
    };
    /**   @private  */
    TextDrawingTool.prototype.endAction = function () {
        _super.prototype.endAction.call(this);
    };
    return TextDrawingTool;
}(ToolBase));
/**
 * Pans the diagram control on drag
 */
var ZoomPanTool = /** @class */ (function (_super) {
    __extends$g(ZoomPanTool, _super);
    function ZoomPanTool(commandHandler, zoom) {
        var _this = _super.call(this, commandHandler) || this;
        _this.zooming = zoom;
        return _this;
    }
    /**
     * @param args
     * @private
     */
    ZoomPanTool.prototype.mouseDown = function (args) {
        _super.prototype.mouseDown.call(this, args);
        this.inAction = true;
        this.commandHandler.setBlazorDiagramProps(true);
    };
    /**
     * @param args
     * @private
     */
    ZoomPanTool.prototype.mouseMove = function (args) {
        _super.prototype.mouseMove.call(this, args);
        if (this.inAction) {
            if (!this.zooming && Point.equals(this.currentPosition, this.prevPosition) === false) {
                var difX = this.currentPosition.x - this.prevPosition.x;
                var difY = this.currentPosition.y - this.prevPosition.y;
                this.commandHandler.scroll(difX, difY, this.currentPosition);
            }
            else if (args.moveTouches && args.moveTouches.length && args.moveTouches.length >= 2) {
                var startTouch0 = args.startTouches[0];
                var startTouch1 = args.startTouches[1];
                var moveTouch0 = args.moveTouches[0];
                var moveTouch1 = args.moveTouches[1];
                var scale = this.getDistance(moveTouch0, moveTouch1) / this.getDistance(startTouch0, startTouch1);
                var focusPoint = args.position;
                // 927527: Diagram flickers while performing pinch zoom
                if (scale !== 1) {
                    this.commandHandler.zoom(scale, 0, 0, focusPoint);
                }
                this.updateTouch(startTouch0, moveTouch0);
                this.updateTouch(startTouch1, moveTouch1);
            }
        }
        this.commandHandler.dataBinding();
        return !this.blocked;
    };
    /**
     * @param args
     * @private
     */
    ZoomPanTool.prototype.mouseUp = function (args) {
        this.commandHandler.setBlazorDiagramProps(false);
        this.checkPropertyValue();
        this.commandHandler.updatePanState(false);
        _super.prototype.mouseUp.call(this, args);
        this.inAction = false;
    };
    /**   @private  */
    ZoomPanTool.prototype.endAction = function () {
        _super.prototype.endAction.call(this);
    };
    ZoomPanTool.prototype.getDistance = function (touch1, touch2) {
        var x = touch2.pageX - touch1.pageX;
        var y = touch2.pageY - touch1.pageY;
        return Math.sqrt((x * x) + (y * y));
    };
    ZoomPanTool.prototype.updateTouch = function (startTouch, moveTouch) {
        startTouch.pageX = moveTouch.pageX;
        startTouch.pageY = moveTouch.pageY;
    };
    return ZoomPanTool;
}(ToolBase));
/**
 * Animate the layout during expand and collapse
 */
var ExpandTool = /** @class */ (function (_super) {
    __extends$g(ExpandTool, _super);
    function ExpandTool(commandHandler) {
        return _super.call(this, commandHandler, true) || this;
    }
    /**
     * @param args
     * @private
     */
    ExpandTool.prototype.mouseUp = function (args) {
        this.checkPropertyValue();
        this.commandHandler.initExpand(args);
        _super.prototype.mouseUp.call(this, args);
    };
    return ExpandTool;
}(ToolBase));
/**
 * Opens the annotation hypeLink at mouse up
 */
var LabelTool = /** @class */ (function (_super) {
    __extends$g(LabelTool, _super);
    function LabelTool(commandHandler) {
        return _super.call(this, commandHandler, true) || this;
    }
    /**
     * @param args
     * @private
     */
    LabelTool.prototype.mouseUp = function (args) {
        this.checkPropertyValue();
        var tab = '_blank';
        var windowOption = '';
        var windowHeight = window.innerHeight;
        var windowWidth = window.innerWidth;
        var screenTop = window.screenTop;
        var screenLeft = window.screenLeft;
        if (args.sourceWrapper.hyperlink.hyperlinkOpenState === 'CurrentTab') {
            tab = '_self';
        }
        else if (args.sourceWrapper.hyperlink.hyperlinkOpenState === 'NewWindow') {
            windowOption = 'height=' + windowHeight + ',width=' + windowWidth + ',top=' + screenTop + ',left=' + screenLeft;
        }
        var win = window.open(args.sourceWrapper.hyperlink.link, tab, windowOption);
        win.focus();
        _super.prototype.mouseUp.call(this, args);
    };
    return LabelTool;
}(ToolBase));
/**
 * Draws a Polygon shape node dynamically using polygon Tool
 */
var PolygonDrawingTool = /** @class */ (function (_super) {
    __extends$g(PolygonDrawingTool, _super);
    function PolygonDrawingTool(commandHandler) {
        return _super.call(this, commandHandler, true) || this;
    }
    /**
     * @param args
     * @private
     */
    PolygonDrawingTool.prototype.mouseDown = function (args) {
        _super.prototype.mouseDown.call(this, args);
        this.inAction = true;
        if (!this.drawingObject) {
            this.startPoint = { x: this.startPosition.x, y: this.startPosition.y };
            var node = {
                offsetX: this.currentPosition.x,
                offsetY: this.currentPosition.y,
                width: 5, height: 5,
                // 916722: Apply custom style to polygon shape by removing the default style during polygon drawing.
                shape: {
                    type: 'Basic',
                    shape: 'Polygon',
                    points: [{ x: this.startPoint.x, y: this.startPoint.y }, { x: this.currentPosition.x, y: this.currentPosition.y }]
                }
            };
            // 920152: elementDraw event not triggered for Polygon Drawing tool
            this.triggerElementDrawEvent(args.source, 'Start', 'Node', this.getShapeType(), true);
            this.drawingObject = this.commandHandler.drawObject(node);
        }
        else {
            var pt = void 0;
            var obj = this.drawingObject.shape;
            pt = obj.points[obj.points.length - 1];
            pt = { x: pt.x, y: pt.y };
            this.drawingObject.shape.points.push(pt);
        }
    };
    /**
     * @param args
     * @private
     */
    PolygonDrawingTool.prototype.mouseMove = function (args) {
        _super.prototype.mouseMove.call(this, args);
        if (this.inAction) {
            var obj = this.drawingObject.shape;
            obj.points[obj.points.length - 1].x = this.currentPosition.x;
            obj.points[obj.points.length - 1].y = this.currentPosition.y;
            this.drawingObject.wrapper.children[0].data = getPolygonPath(this.drawingObject.shape.points);
            // 920152: elementDraw event not triggered for Polygon Drawing tool
            this.triggerElementDrawEvent(this.drawingObject, 'Progress', 'Node', this.getShapeType(), false);
            if (this.inAction && Point.equals(this.currentPosition, this.prevPosition) === false) {
                var region = Rect.toBounds(this.drawingObject.shape.points);
                this.commandHandler.updateNodeDimension(this.drawingObject, region);
            }
        }
        return true;
    };
    /**
     * @param args
     * @param dblClickArgs
     * @param args
     * @param dblClickArgs
     * @private
     */
    PolygonDrawingTool.prototype.mouseUp = function (args, dblClickArgs) {
        this.checkPropertyValue();
        _super.prototype.mouseMove.call(this, args);
        if (this.inAction) {
            this.inAction = false;
            this.commandHandler.addObjectToDiagram(this.drawingObject);
            // 920152: elementDraw event not triggered for Polygon Drawing tool
            this.triggerElementDrawEvent(this.drawingObject, 'Completed', 'Node', this.getShapeType(), false);
        }
        this.endAction();
    };
    /**
     * @param args
     * @private
     */
    PolygonDrawingTool.prototype.mouseWheel = function (args) {
        _super.prototype.mouseWheel.call(this, args);
        this.mouseMove(args);
    };
    /**   @private  */
    PolygonDrawingTool.prototype.endAction = function () {
        this.inAction = false;
        this.drawingObject = null;
    };
    return PolygonDrawingTool;
}(ToolBase));
/**
 * Draws a PolyLine Connector dynamically using PolyLine Drawing Tool
 */
var PolyLineDrawingTool = /** @class */ (function (_super) {
    __extends$g(PolyLineDrawingTool, _super);
    function PolyLineDrawingTool(commandHandler) {
        return _super.call(this, commandHandler, true) || this;
    }
    /**
     * @param args
     * @private
     */
    PolyLineDrawingTool.prototype.mouseMove = function (args) {
        _super.prototype.mouseMove.call(this, args);
        if (this.inAction) {
            var obj = this.drawingObject;
            obj.targetPoint = this.currentPosition;
            // 920152: elementDraw event not triggered for Polyline Drawing tool
            // 927554: ElementDraw Arguments updated wrongly for Polyline drawing
            this.triggerElementDrawEvent(this.drawingObject, 'Progress', 'Connector', this.commandHandler.diagram.drawingObject.type, false);
            this.commandHandler.updateConnectorPoints(obj);
        }
        return true;
    };
    /**
     * @param args
     * @private
     */
    PolyLineDrawingTool.prototype.mouseDown = function (args) {
        _super.prototype.mouseDown.call(this, args);
        this.inAction = true;
        if (!this.drawingObject) {
            var connector = {
                id: 'Connector',
                type: 'Straight',
                sourcePoint: this.currentPosition,
                targetPoint: this.currentPosition
            };
            // 920152: elementDraw event not triggered for Polyline Drawing tool
            this.triggerElementDrawEvent(args.source, 'Start', 'Connector', this.commandHandler.diagram.drawingObject.type, true);
            if (this.inAction) {
                this.drawingObject = this.commandHandler.drawObject(connector);
            }
        }
        else {
            var drawObject = this.drawingObject;
            var segment = void 0;
            segment = new StraightSegment(drawObject, 'segments', { type: 'Straight' }, true);
            segment.point = this.currentPosition;
            drawObject.segments[drawObject.segments.length - 1] = segment;
        }
    };
    /**
     * @param args
     * @private
     */
    PolyLineDrawingTool.prototype.mouseWheel = function (args) {
        _super.prototype.mouseWheel.call(this, args);
        this.mouseMove(args);
    };
    /**
     * @param args
     * @private
     */
    PolyLineDrawingTool.prototype.mouseUp = function (args) {
        this.checkPropertyValue();
        _super.prototype.mouseMove.call(this, args);
        if (this.inAction) {
            if (this.drawingObject) {
                var drawObject = this.drawingObject;
                drawObject.segments[drawObject.segments.length - 1].point = { x: 0, y: 0 };
                this.commandHandler.addObjectToDiagram(this.drawingObject);
                // 920152: elementDraw event not triggered for Polyline Drawing tool
                // 927554: ElementDraw Arguments updated wrongly for Polyline drawing
                this.triggerElementDrawEvent(this.drawingObject, 'Completed', 'Connector', this.commandHandler.diagram.drawingObject.type, false);
            }
        }
        this.endAction();
    };
    /**   @private  */
    PolyLineDrawingTool.prototype.endAction = function () {
        this.drawingObject = null;
        this.inAction = false;
    };
    return PolyLineDrawingTool;
}(ToolBase));
var LabelDragTool = /** @class */ (function (_super) {
    __extends$g(LabelDragTool, _super);
    function LabelDragTool(commandHandler) {
        return _super.call(this, commandHandler, true) || this;
    }
    /**
     * @param args
     * @private
     */
    LabelDragTool.prototype.mouseDown = function (args) {
        this.inAction = true;
        this.undoElement = cloneObject(args.source);
        this.annotationId = args.sourceWrapper.id;
        _super.prototype.mouseDown.call(this, args);
    };
    /**
     * @param args
     * @private
     */
    LabelDragTool.prototype.mouseMove = function (args) {
        _super.prototype.mouseMove.call(this, args);
        var difx = this.currentPosition.x - this.prevPosition.x;
        var dify = this.currentPosition.y - this.prevPosition.y;
        var node = args.source;
        if (node instanceof Node) {
            var matrix = identityMatrix();
            rotateMatrix(matrix, -node.rotateAngle, 0, 0);
            var diff = transformPointByMatrix(matrix, { x: difx, y: dify });
            difx = diff.x;
            dify = diff.y;
        }
        if (this.inAction) {
            this.commandHandler.labelDrag(args.source, args.sourceWrapper, difx, dify);
            this.commandHandler.updateSelector();
        }
        this.prevPosition = this.currentPosition;
        return !this.blocked;
    };
    /**
     * @param args
     * @private
     */
    LabelDragTool.prototype.mouseUp = function (args) {
        this.checkPropertyValue();
        var redoValue = args.source;
        this.inAction = false;
        var entryValue = {
            type: 'AnnotationPropertyChanged',
            objectId: this.annotationId, undoObject: cloneObject(this.undoElement),
            category: 'Internal', redoObject: cloneObject(redoValue)
        };
        this.commandHandler.addHistoryEntry(entryValue);
        _super.prototype.mouseUp.call(this, args);
    };
    /**
     * @param args
     * @private
     */
    LabelDragTool.prototype.mouseLeave = function (args) {
        this.mouseUp(args);
    };
    return LabelDragTool;
}(ToolBase));
var LabelResizeTool = /** @class */ (function (_super) {
    __extends$g(LabelResizeTool, _super);
    function LabelResizeTool(commandHandler, corner) {
        var _this = _super.call(this, commandHandler, true) || this;
        _this.corner = corner;
        return _this;
    }
    /**
     * @param args
     * @private
     */
    LabelResizeTool.prototype.mouseDown = function (args) {
        this.inAction = true;
        var object = (args.source.nodes.length) ?
            args.source.nodes[0] : args.source.connectors[0];
        this.annotationId = args.source.wrapper.children[0].id;
        this.undoElement = cloneObject(object);
        var annotation = args.source.wrapper.children[0];
        this.initialBounds = {
            x: annotation.offsetX,
            y: annotation.offsetY,
            width: annotation.actualSize.width,
            height: annotation.actualSize.height
        };
        _super.prototype.mouseDown.call(this, args);
    };
    /**
     * @param args
     * @private
     */
    LabelResizeTool.prototype.mouseMove = function (args) {
        _super.prototype.mouseMove.call(this, args);
        if (this.inAction) {
            this.resizeObject(args);
        }
        return !this.blocked;
    };
    /**
     * @param args
     * @private
     */
    LabelResizeTool.prototype.mouseUp = function (args) {
        this.checkPropertyValue();
        var redoObject = (args.source.nodes.length) ?
            args.source.nodes[0] : args.source.connectors[0];
        this.inAction = false;
        var entry = {
            type: 'AnnotationPropertyChanged', objectId: this.annotationId,
            redoObject: cloneObject(redoObject), undoObject: cloneObject(this.undoElement), category: 'Internal'
        };
        this.commandHandler.addHistoryEntry(entry);
        _super.prototype.mouseUp.call(this, args);
    };
    /**
     * @param args
     * @private
     */
    LabelResizeTool.prototype.mouseLeave = function (args) {
        this.mouseUp(args);
    };
    /**
     * @param args
     * @private
     */
    LabelResizeTool.prototype.resizeObject = function (args) {
        var object;
        object = (args.source.nodes.length) ? args.source.nodes[0] : args.source.connectors[0];
        var textElement = args.source.wrapper.children[0];
        var deltaWidth;
        var deltaHeight;
        var center = { x: textElement.offsetX, y: textElement.offsetY };
        var rotateAngle = textElement.rotateAngle;
        rotateAngle += (object instanceof Node) ? object.rotateAngle : 0;
        rotateAngle = (rotateAngle + 360) % 360;
        var trans = identityMatrix();
        rotateMatrix(trans, rotateAngle, center.x, center.y);
        var corner = this.corner.slice(5);
        var pivot = this.updateSize(textElement, this.startPosition, this.currentPosition, corner, this.initialBounds, rotateAngle);
        var x = textElement.offsetX - textElement.actualSize.width * textElement.pivot.x;
        var y = textElement.offsetY - textElement.actualSize.height * textElement.pivot.y;
        var pivotPoint = this.getPivot(corner);
        pivotPoint = { x: x + textElement.actualSize.width * pivotPoint.x, y: y + textElement.actualSize.height * pivotPoint.y };
        var point = transformPointByMatrix(trans, pivotPoint);
        pivot.x = point.x;
        pivot.y = point.y;
        deltaWidth = pivot.width;
        deltaHeight = pivot.height;
        deltaWidth = (deltaWidth < 0) ? 1 : deltaWidth;
        deltaHeight = (deltaHeight < 0) ? 1 : deltaHeight;
        this.commandHandler.labelResize(object, args.source.annotation, deltaWidth, deltaHeight, pivot, args.source);
        this.commandHandler.updateSelector();
    };
    return LabelResizeTool;
}(ToolBase));
var LabelRotateTool = /** @class */ (function (_super) {
    __extends$g(LabelRotateTool, _super);
    function LabelRotateTool(commandHandler) {
        return _super.call(this, commandHandler, true) || this;
    }
    /**
     * @param args
     * @private
     */
    LabelRotateTool.prototype.mouseDown = function (args) {
        this.inAction = true;
        this.annotationId = args.source.wrapper.children[0].id;
        var object = (args.source.nodes.length) ?
            args.source.nodes[0] : args.source.connectors[0];
        this.undoElement = cloneObject(object);
        _super.prototype.mouseDown.call(this, args);
    };
    /**
     * @param args
     * @private
     */
    LabelRotateTool.prototype.mouseMove = function (args) {
        _super.prototype.mouseMove.call(this, args);
        if (args.source) {
            if (this.inAction) {
                var object = args.source.nodes[0] ? args.source.nodes[0] :
                    args.source.connectors[0];
                var annotation = void 0;
                annotation = (args.source.annotation);
                this.commandHandler.labelRotate(object, annotation, this.currentPosition, args.source);
                this.commandHandler.updateSelector();
            }
        }
        this.prevPosition = this.currentPosition;
        return !this.blocked;
    };
    /**
     * @param args
     * @private
     */
    LabelRotateTool.prototype.mouseUp = function (args) {
        this.checkPropertyValue();
        this.inAction = false;
        var redoEntry = (args.source.nodes.length) ?
            args.source.nodes[0] : args.source.connectors[0];
        var entryObject = {
            type: 'AnnotationPropertyChanged', objectId: this.annotationId,
            redoObject: cloneObject(redoEntry),
            undoObject: cloneObject(this.undoElement), category: 'Internal'
        };
        this.commandHandler.addHistoryEntry(entryObject);
        _super.prototype.mouseUp.call(this, args);
    };
    /**
     * @param args
     * @private
     */
    LabelRotateTool.prototype.mouseLeave = function (args) {
        this.mouseUp(args);
    };
    return LabelRotateTool;
}(ToolBase));
/**
 * EJ2-33302 - Freehand drawing support in diagram control.
 */
var FreeHandTool = /** @class */ (function (_super) {
    __extends$g(FreeHandTool, _super);
    function FreeHandTool(commandHandler) {
        return _super.call(this, commandHandler, true) || this;
    }
    /**
     * mouseMove - Collect the points using current mouse position and convert it into pathData.
     * @param args
     * @private
     */
    FreeHandTool.prototype.mouseMove = function (args) {
        _super.prototype.mouseMove.call(this, args);
        if (this.inAction) {
            var obj = this.drawingObject.shape;
            var pt = this.currentPosition;
            obj.points.push(pt);
            this.drawingObject.wrapper.children[0].data = getFreeHandPath(this.drawingObject.shape.points);
            obj.data = getFreeHandPath(obj.points);
            // 920152: elementDraw event not triggered for Freehand Drawing tool
            this.triggerElementDrawEvent(args.source, 'Progress', 'Connector', this.drawingObject.type, false);
            if (this.inAction && Point.equals(this.currentPosition, this.prevPosition) === false) {
                var region = Rect.toBounds(this.drawingObject.shape.points);
                this.commandHandler.updateNodeDimension(this.drawingObject, region);
            }
        }
        return true;
    };
    /**
     * @param args
     * @private
     */
    FreeHandTool.prototype.mouseDown = function (args) {
        _super.prototype.mouseDown.call(this, args);
        this.inAction = true;
        this.startPoint = { x: this.startPosition.x, y: this.startPosition.y };
        var node = {
            offsetX: this.currentPosition.x,
            offsetY: this.currentPosition.y,
            width: 5, height: 5,
            style: { strokeColor: 'black', strokeWidth: 1, fill: 'transparent' },
            shape: {
                type: 'Path',
                points: [{ x: this.startPoint.x, y: this.startPoint.y }, { x: this.currentPosition.x, y: this.currentPosition.y }]
            }
        };
        // 920152: elementDraw event not triggered for Freehand Drawing tool
        this.triggerElementDrawEvent(args.source, 'Start', 'Connector', this.commandHandler.diagram.drawingObject.type, true);
        this.drawingObject = this.commandHandler.drawObject(node);
    };
    /**
     * mouseUp - Remove the drawn object. Reduce and smoothen the collected points and create
     * a bezier connector using the smoothened points.
     * @param args
     * @private
     */
    FreeHandTool.prototype.mouseUp = function (args) {
        this.checkPropertyValue();
        var tolerance = 10;
        var smoothValue = 0.5;
        if (this.inAction) {
            this.inAction = false;
            var obj = this.drawingObject.shape;
            var points = obj.points;
            this.commandHandler.addObjectToDiagram(this.drawingObject);
            var prevId = this.drawingObject.id;
            var prevObj = this.commandHandler.diagram.nameTable["" + prevId];
            this.commandHandler.diagram.remove(prevObj);
            points = this.pointReduction(points, tolerance);
            // 927557: controlPointsVisibility Property values not considered in Freehand drawing
            var bezierSettings = {};
            if (this.commandHandler.diagram.drawingObject.bezierSettings) {
                bezierSettings = this.commandHandler.diagram.drawingObject.bezierSettings;
            }
            if (bezierSettings.allowSegmentsReset === undefined) {
                bezierSettings.allowSegmentsReset = false;
            }
            //EJ2-69816 - Added below code to set the allow segment reset as false to avoid the unwanted segment reset.
            var newObj = {
                id: 'newConnector' + randomId(), type: 'Bezier',
                sourcePoint: { x: points[0].x, y: points[0].y }, targetPoint: { x: points[points.length - 1].x, y: points[points.length - 1].y },
                //EJ2-873504[BUG]- Source and target decorator for free hand connector is not rendered.
                segments: [], bezierSettings: bezierSettings
            };
            this.drawingObject = this.commandHandler.drawObject(newObj);
            this.drawingObject = this.bezierCurveSmoothness(points, smoothValue, this.drawingObject, obj);
            this.commandHandler.updateConnectorPoints(this.drawingObject);
            this.commandHandler.addObjectToDiagram(this.drawingObject);
            // 920152: elementDraw event not triggered for Freehand Drawing tool
            // 927554: ElementDraw Arguments updated wrongly for Freehand drawing
            this.triggerElementDrawEvent(this.drawingObject, 'Completed', 'Connector', this.commandHandler.diagram.drawingObject.type, false);
            //(EJ2-70838)- Added code to resolve style property not added dynamically for freehand connector
            // Added code to resolve style property not added dynamically for freehand connector
            _super.prototype.mouseUp.call(this, args);
        }
    };
    /**
     * Reduce the collected points based on tolerance value.
     * @param points
     * @param tolerance
     * @returns points
     */
    FreeHandTool.prototype.pointReduction = function (points, tolerance) {
        if (points === null || points.length < 3) {
            return points;
        }
        var firstPoint = 0;
        var lastPoint = points.length - 1;
        var pointIndex = [];
        pointIndex.push(firstPoint);
        pointIndex.push(lastPoint);
        while (points[parseInt(firstPoint.toString(), 10)] === (points[parseInt(lastPoint.toString(), 10)])) {
            lastPoint--;
        }
        this.reduction(points, firstPoint, lastPoint, tolerance, pointIndex);
        var returnedPoints = [];
        pointIndex.sort(function (a, b) { return a - b; });
        pointIndex.forEach(function (element) {
            returnedPoints.push(points[parseInt(element.toString(), 10)]);
        });
        return returnedPoints;
    };
    FreeHandTool.prototype.reduction = function (points, firstPoint, lastPoint, tolerance, pointIndex) {
        var maxDistance = 0;
        var largestPointIndex = 0;
        for (var i = firstPoint; i < lastPoint; i++) {
            var distance = this.perpendicularDistance(points[parseInt(firstPoint.toString(), 10)], points[parseInt(lastPoint.toString(), 10)], points[parseInt(i.toString(), 10)]);
            if (distance > maxDistance) {
                maxDistance = distance;
                largestPointIndex = i;
            }
        }
        if (maxDistance > tolerance && largestPointIndex !== 0) {
            pointIndex.push(largestPointIndex);
            this.reduction(points, firstPoint, largestPointIndex, tolerance, pointIndex);
            this.reduction(points, largestPointIndex, lastPoint, tolerance, pointIndex);
        }
    };
    /**
     * Calculate the perpendicular distance of each point with first and last points
     * @param point1
     * @param point2
     * @param point3
     * @returns
     */
    FreeHandTool.prototype.perpendicularDistance = function (point1, point2, point3) {
        var area = Math.abs(.5 * ((point1.x * point2.y - point2.x * point1.y) +
            (point2.x * point3.y - point3.x * point2.y) + (point3.x * point1.y - point1.x * point3.y)));
        var base = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
        var height = area / base * 2;
        return height;
    };
    /**
     * Smoothen the bezier curve based on the points and smoothValue.
     * @param points
     * @param smoothValue
     * @param drawingObject
     * @param obj
     * @returns drawingObject
     */
    FreeHandTool.prototype.bezierCurveSmoothness = function (points, smoothValue, drawingObject, obj) {
        if (points.length < 3) {
            return drawingObject;
        }
        for (var i = 0; i < points.length - 1; i++) {
            var pointx1 = points[parseInt(i.toString(), 10)].x;
            var pointy1 = points[parseInt(i.toString(), 10)].y;
            var pointx2 = points[i + 1].x;
            var pointy2 = points[i + 1].y;
            var pointx0 = void 0;
            var pointy0 = void 0;
            if (i === 0) {
                var previousPoint = points[parseInt(i.toString(), 10)];
                pointx0 = previousPoint.x;
                pointy0 = previousPoint.y;
            }
            else {
                pointx0 = points[i - 1].x;
                pointy0 = points[i - 1].y;
            }
            var pointx3 = void 0;
            var pointy3 = void 0;
            if (i === points.length - 2) {
                var nextPoint = points[i + 1];
                pointx3 = nextPoint.x;
                pointy3 = nextPoint.y;
            }
            else {
                pointx3 = points[i + 2].x;
                pointy3 = points[i + 2].y;
            }
            var xc1 = (pointx0 + pointx1) / 2.0;
            var yc1 = (pointy0 + pointy1) / 2.0;
            var xc2 = (pointx1 + pointx2) / 2.0;
            var yc2 = (pointy1 + pointy2) / 2.0;
            var xc3 = (pointx2 + pointx3) / 2.0;
            var yc3 = (pointy2 + pointy3) / 2.0;
            var point0 = {};
            var point1 = {};
            var point2 = {};
            var point3 = {};
            point0.x = pointx0;
            point0.y = pointy0;
            point1.x = pointx1;
            point1.y = pointy1;
            point2.x = pointx2;
            point2.y = pointy2;
            point3.x = pointx3;
            point3.y = pointy3;
            var len1 = Point.findLength(point0, point1);
            var len2 = Point.findLength(point1, point2);
            var len3 = Point.findLength(point2, point3);
            var k1 = len1 / (len1 + len2);
            var k2 = len2 / (len2 + len3);
            var xm1 = xc1 + (xc2 - xc1) * k1;
            var ym1 = yc1 + (yc2 - yc1) * k1;
            var xm2 = xc2 + (xc3 - xc2) * k2;
            var ym2 = yc2 + (yc3 - yc2) * k2;
            var Controlpointx1 = xm1 + (xc2 - xm1) * smoothValue + pointx1 - xm1;
            var Controlpointy1 = ym1 + (yc2 - ym1) * smoothValue + pointy1 - ym1;
            var Controlpointx2 = xm2 + (xc2 - xm2) * smoothValue + pointx2 - xm2;
            var Controlpointy2 = ym2 + (yc2 - ym2) * smoothValue + pointy2 - ym2;
            var segment = new BezierSegment(obj, 'segments', { type: 'Bezier' }, true);
            var cnPt1 = { x: Controlpointx1, y: Controlpointy1 };
            var cnPt2 = { x: Controlpointx2, y: Controlpointy2 };
            var segSourcePoint = { x: pointx1, y: pointy1 };
            var segTargetPoint = { x: pointx2, y: pointy2 };
            segment.type = 'Bezier';
            drawingObject.segments[parseInt(i.toString(), 10)] = segment;
            if (i === 0) {
                cnPt1 = { x: pointx1, y: pointy1 };
            }
            if (i === points.length - 2) {
                cnPt2 = { x: pointx2, y: pointy2 };
            }
            drawingObject.segments[parseInt(i.toString(), 10)].vector1 = { angle: findAngle(segSourcePoint, cnPt1), distance: Point.findLength(segSourcePoint, cnPt1) };
            drawingObject.segments[parseInt(i.toString(), 10)].vector2 = { angle: findAngle(segTargetPoint, cnPt2), distance: Point.findLength(segTargetPoint, cnPt2) };
            drawingObject.segments[parseInt(i.toString(), 10)].point = segTargetPoint;
        }
        return drawingObject;
    };
    return FreeHandTool;
}(ToolBase));

var __extends$h = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var getConnectorType = function (obj) {
    //Removed isBlazor code
    if (obj) {
        switch (obj.type) {
            case 'Bpmn':
                return BpmnFlow;
            case 'UmlActivity':
                return ActivityFlow;
            case 'UmlClassifier':
                return RelationShip;
            default:
                return ConnectorShape;
        }
    }
    return ConnectorShape;
};
var getSegmentType = function (obj) {
    if (obj) {
        //Removed isBlazor code
        switch (obj.type) {
            case 'Straight':
                return StraightSegment;
            case 'Bezier':
                return BezierSegment;
            case 'Orthogonal':
                return OrthogonalSegment;
            default:
                return StraightSegment;
        }
    }
    return undefined;
};
/**
 * Decorators are used to decorate the end points of the connector with some predefined path geometry
 */
var Decorator = /** @class */ (function (_super) {
    __extends$h(Decorator, _super);
    function Decorator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$8([
        Property(10)
    ], Decorator.prototype, "width", void 0);
    __decorate$8([
        Property(10)
    ], Decorator.prototype, "height", void 0);
    __decorate$8([
        Property('Arrow')
    ], Decorator.prototype, "shape", void 0);
    __decorate$8([
        Complex({ fill: 'black', strokeColor: 'black', strokeWidth: 1 }, ShapeStyle)
    ], Decorator.prototype, "style", void 0);
    __decorate$8([
        Complex({ x: 0, y: 0.5 }, Point)
    ], Decorator.prototype, "pivot", void 0);
    __decorate$8([
        Property('')
    ], Decorator.prototype, "pathData", void 0);
    return Decorator;
}(ChildProperty));
/**
 * Describes the length and angle between the control point and the start point of bezier segment
 */
var Vector = /** @class */ (function (_super) {
    __extends$h(Vector, _super);
    function Vector() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$8([
        Property(0)
    ], Vector.prototype, "angle", void 0);
    __decorate$8([
        Property(0)
    ], Vector.prototype, "distance", void 0);
    return Vector;
}(ChildProperty));
/**
 * Describes the length and angle between the control point and the start point of bezier segment
 */
var BezierSettings = /** @class */ (function (_super) {
    __extends$h(BezierSettings, _super);
    function BezierSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$8([
        Property(ControlPointsVisibility.All)
    ], BezierSettings.prototype, "controlPointsVisibility", void 0);
    __decorate$8([
        Property('FreeForm')
    ], BezierSettings.prototype, "segmentEditOrientation", void 0);
    __decorate$8([
        Property(BezierSmoothness.Default)
    ], BezierSettings.prototype, "smoothness", void 0);
    __decorate$8([
        Property(true)
    ], BezierSettings.prototype, "allowSegmentsReset", void 0);
    return BezierSettings;
}(ChildProperty));
/**
 * Sets the type of the connector
 */
var ConnectorShape = /** @class */ (function (_super) {
    __extends$h(ConnectorShape, _super);
    function ConnectorShape() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$8([
        Property('None')
    ], ConnectorShape.prototype, "type", void 0);
    return ConnectorShape;
}(ChildProperty));
/**
 * Sets the type of the flow in a BPMN Process
 */
var ActivityFlow = /** @class */ (function (_super) {
    __extends$h(ActivityFlow, _super);
    function ActivityFlow() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$8([
        Property('Object')
    ], ActivityFlow.prototype, "flow", void 0);
    __decorate$8([
        Property(30)
    ], ActivityFlow.prototype, "exceptionFlowHeight", void 0);
    return ActivityFlow;
}(ConnectorShape));
/**
 * Sets the type of the flow in a BPMN Process
 */
var BpmnFlow = /** @class */ (function (_super) {
    __extends$h(BpmnFlow, _super);
    function BpmnFlow() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$8([
        Property('Sequence')
    ], BpmnFlow.prototype, "flow", void 0);
    __decorate$8([
        Property('Normal')
    ], BpmnFlow.prototype, "sequence", void 0);
    __decorate$8([
        Property('Default')
    ], BpmnFlow.prototype, "message", void 0);
    __decorate$8([
        Property('Default')
    ], BpmnFlow.prototype, "association", void 0);
    return BpmnFlow;
}(ConnectorShape));
/**
 * Defines the behavior of connector segments
 */
var ConnectorSegment = /** @class */ (function (_super) {
    __extends$h(ConnectorSegment, _super);
    // tslint:disable-next-line:no-any
    function ConnectorSegment(parent, propName, defaultValue, isArray) {
        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
        _this.points = [];
        return _this;
    }
    __decorate$8([
        Property('Straight')
    ], ConnectorSegment.prototype, "type", void 0);
    __decorate$8([
        Property(true)
    ], ConnectorSegment.prototype, "allowDrag", void 0);
    return ConnectorSegment;
}(ChildProperty));
/**
 * Defines the behavior of straight segments
 */
var StraightSegment = /** @class */ (function (_super) {
    __extends$h(StraightSegment, _super);
    function StraightSegment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class StraightSegment
     *
     * @private
     */
    StraightSegment.prototype.getClassName = function () {
        return 'StraightSegment';
    };
    __decorate$8([
        Complex({ x: 0, y: 0 }, Point)
    ], StraightSegment.prototype, "point", void 0);
    return StraightSegment;
}(ConnectorSegment));
/**
 * Defines the behavior of bezier segments
 */
var BezierSegment = /** @class */ (function (_super) {
    __extends$h(BezierSegment, _super);
    function BezierSegment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @private
     * Returns the name of class BezierSegment
     */
    BezierSegment.prototype.getClassName = function () {
        return 'BezierSegment';
    };
    /**
     * @private
     * Returns the total points of the bezier curve
     */
    BezierSegment.prototype.getPoints = function (segments, start) {
        var points = [];
        if (points.length > 0 || start != null) {
            var st = points.length > 0 ? points[points.length - 1] : start;
            var bezier = this.bezireToPoly(st, segments);
            // 878719: Resolve ESLint errors
            // eslint-disable-next-line prefer-spread
            points.push.apply(points, bezier);
        }
        return points;
    };
    /**
     * @private
     * Returns the total points of the bezier curve
     */
    BezierSegment.prototype.bezireToPoly = function (start, segment) {
        var points = [];
        if (segment) {
            var bezSeg = segment;
            var pt0 = start;
            var pt1 = bezSeg.bezierPoint1;
            var pt2 = bezSeg.bezierPoint2;
            var pt3 = { x: bezSeg.points[1].x, y: bezSeg.points[1].y };
            this.flattenCubicBezier(points, pt0, pt1, pt2, pt3, 10);
        }
        return points;
    };
    /**
     * @private
     * Returns the total points of the bezier curve
     */
    BezierSegment.prototype.flattenCubicBezier = function (points, ptStart, ptCtrl1, ptCtrl2, ptEnd, tolerance) {
        var max = ((Point.findLength(ptStart, ptCtrl1) + Point.findLength(ptCtrl1, ptCtrl2)
            + Point.findLength(ptCtrl2, ptEnd)) / tolerance);
        var i;
        for (i = 0; i <= max; i++) {
            var t = i / max;
            var x = (1 - t) * (1 - t) * (1 - t) * ptStart.x +
                3 * t * (1 - t) * (1 - t) * ptCtrl1.x +
                3 * t * t * (1 - t) * ptCtrl2.x +
                t * t * t * ptEnd.x;
            var y = (1 - t) * (1 - t) * (1 - t) * ptStart.y +
                3 * t * (1 - t) * (1 - t) * ptCtrl1.y +
                3 * t * t * (1 - t) * ptCtrl2.y +
                t * t * t * ptEnd.y;
            points.push({ x: x, y: y });
        }
    };
    __decorate$8([
        Property('Horizontal')
    ], BezierSegment.prototype, "orientation", void 0);
    __decorate$8([
        Complex({ x: 0, y: 0 }, Point)
    ], BezierSegment.prototype, "point1", void 0);
    __decorate$8([
        Complex({ x: 0, y: 0 }, Point)
    ], BezierSegment.prototype, "point2", void 0);
    __decorate$8([
        Complex({ angle: 0, distance: 0 }, Vector)
    ], BezierSegment.prototype, "vector1", void 0);
    __decorate$8([
        Complex({ angle: 0, distance: 0 }, Vector)
    ], BezierSegment.prototype, "vector2", void 0);
    return BezierSegment;
}(StraightSegment));
/**
 * Defines the behavior of orthogonal segments
 */
var OrthogonalSegment = /** @class */ (function (_super) {
    __extends$h(OrthogonalSegment, _super);
    function OrthogonalSegment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the module of class OrthogonalSegment
     *
     * @private
     */
    OrthogonalSegment.prototype.getClassName = function () {
        return 'OrthogonalSegment';
    };
    __decorate$8([
        Property(null)
    ], OrthogonalSegment.prototype, "length", void 0);
    __decorate$8([
        Property(null)
    ], OrthogonalSegment.prototype, "direction", void 0);
    return OrthogonalSegment;
}(ConnectorSegment));
/**
 * Defines the behavior of orthogonal segments
 */
var DiagramConnectorSegment = /** @class */ (function (_super) {
    __extends$h(DiagramConnectorSegment, _super);
    function DiagramConnectorSegment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @private
     * Returns the module of class OrthogonalSegment
     */
    DiagramConnectorSegment.prototype.getClassName = function () {
        return 'DiagramConnectorSegment';
    };
    __decorate$8([
        Property('Straight')
    ], DiagramConnectorSegment.prototype, "type", void 0);
    __decorate$8([
        Property(true)
    ], DiagramConnectorSegment.prototype, "allowDrag", void 0);
    __decorate$8([
        Complex({ x: 0, y: 0 }, Point)
    ], DiagramConnectorSegment.prototype, "point", void 0);
    __decorate$8([
        Complex({ x: 0, y: 0 }, Point)
    ], DiagramConnectorSegment.prototype, "point1", void 0);
    __decorate$8([
        Complex({ x: 0, y: 0 }, Point)
    ], DiagramConnectorSegment.prototype, "point2", void 0);
    __decorate$8([
        Complex({ angle: 0, distance: 0 }, Vector)
    ], DiagramConnectorSegment.prototype, "vector1", void 0);
    __decorate$8([
        Complex({ angle: 0, distance: 0 }, Vector)
    ], DiagramConnectorSegment.prototype, "vector2", void 0);
    __decorate$8([
        Property(null)
    ], DiagramConnectorSegment.prototype, "length", void 0);
    __decorate$8([
        Property(null)
    ], DiagramConnectorSegment.prototype, "direction", void 0);
    return DiagramConnectorSegment;
}(ChildProperty));
/**
 * Get the direction of the control points while the bezier is connected to the node
 */
function getDirection$1(bounds, points, excludeBounds) {
    var center = bounds.center;
    var direction;
    var part = excludeBounds ? 45 : (180 / (2 + 2 / (bounds.height / bounds.width)));
    var fourty5 = part;
    var one35 = (180 - part);
    var two25 = one35 + (2 * part);
    var three15 = 360 - part;
    var angle = findAngle(points, center);
    if (angle > fourty5 && angle < one35) {
        return direction = 'top';
    }
    else if (angle > one35 && angle < two25) {
        return direction = 'right';
    }
    else if (angle > two25 && angle < three15) {
        return direction = 'bottom';
    }
    else {
        return direction = 'left';
    }
}
function isEmptyVector(element) {
    if (!element.distance && !element.angle) {
        return true;
    }
    return false;
}
/**
 * Get the bezier points if control points are not given.
 */
function getBezierPoints(sourcePoint, targetPoint, direction) {
    var distance = 60;
    var value = { x: 0, y: 0 };
    if (!direction) {
        if (Math.abs(targetPoint.x - sourcePoint.x) > Math.abs(targetPoint.y - sourcePoint.y)) {
            direction = sourcePoint.x < targetPoint.x ? 'right' : 'left';
        }
        else {
            direction = sourcePoint.y < targetPoint.y ? 'bottom' : 'top';
        }
    }
    switch (direction) {
        case 'bottom':
        case 'top':
            distance = Math.min(Math.abs(sourcePoint.y - targetPoint.y) * 0.45, distance);
            value = { x: sourcePoint.x, y: sourcePoint.y + (direction === 'bottom' ? distance : -distance) };
            break;
        case 'right':
        case 'left':
            distance = Math.min(Math.abs(sourcePoint.x - targetPoint.x) * 0.45, distance);
            value = { x: sourcePoint.x + (direction === 'right' ? distance : -distance), y: sourcePoint.y };
            break;
    }
    return value;
}
/**
 * Get the bezier curve bounds.
 */
function getBezierBounds(startPoint, controlPoint1, controlPoint2, endPoint, connector) {
    var minx = 0;
    var miny = 0;
    var maxx = 0;
    var maxy = 0;
    var tolerancevalue = 3;
    var max = Number((connector.distance(controlPoint1, startPoint) +
        connector.distance(controlPoint2, controlPoint1) +
        connector.distance(endPoint, controlPoint2)) / tolerancevalue);
    if (max !== 0) {
        for (var i = 0; i <= max; i++) {
            var t = i / max;
            var x = (1 - t) * (1 - t) * (1 - t) * startPoint.x +
                3 * t * (1 - t) * (1 - t) * controlPoint1.x +
                3 * t * t * (1 - t) * controlPoint2.x +
                t * t * t * endPoint.x;
            var y = (1 - t) * (1 - t) * (1 - t) * startPoint.y +
                3 * t * (1 - t) * (1 - t) * controlPoint1.y +
                3 * t * t * (1 - t) * controlPoint2.y +
                t * t * t * endPoint.y;
            if (i === 0) {
                minx = maxx = x;
                miny = maxy = y;
            }
            else {
                minx = Math.min(x, minx);
                miny = Math.min(y, miny);
                maxx = Math.max(x, maxx);
                maxy = Math.max(y, maxy);
            }
        }
    }
    return {
        x: minx, y: miny, width: maxx - minx, height: maxy - miny,
        left: minx, top: miny, right: (minx + (maxx - minx)), bottom: (miny + (maxy - miny)),
        center: { x: (minx + (maxx - minx)) / 2, y: (miny + (maxy - miny)) / 2 }
    };
}
/**
 * Get the intermediate bezier curve for point over connector
 */
function bezierPoints(connector, startPoint, point1, point2, endPoint, i, max) {
    var pt = { x: 0, y: 0 };
    var t = i / max;
    var x = (1 - t) * (1 - t) * (1 - t) * startPoint.x +
        3 * t * (1 - t) * (1 - t) * point1.x +
        3 * t * t * (1 - t) * point2.x +
        t * t * t * endPoint.x;
    pt.x = x;
    var y = (1 - t) * (1 - t) * (1 - t) * startPoint.y +
        3 * t * (1 - t) * (1 - t) * point1.y +
        3 * t * t * (1 - t) * point2.y +
        t * t * t * endPoint.y;
    pt.y = y;
    return pt;
}
/**
 * Defines the behavior of the UMLActivity Classifier multiplicity connection defaults
 */
var MultiplicityLabel = /** @class */ (function (_super) {
    __extends$h(MultiplicityLabel, _super);
    function MultiplicityLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$8([
        Property(true)
    ], MultiplicityLabel.prototype, "optional", void 0);
    __decorate$8([
        Property(undefined)
    ], MultiplicityLabel.prototype, "lowerBounds", void 0);
    __decorate$8([
        Property(undefined)
    ], MultiplicityLabel.prototype, "upperBounds", void 0);
    return MultiplicityLabel;
}(ChildProperty));
/**
 * Defines the behavior of the UMLActivity Classifier multiplicity connection defaults
 */
var ClassifierMultiplicity = /** @class */ (function (_super) {
    __extends$h(ClassifierMultiplicity, _super);
    function ClassifierMultiplicity() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$8([
        Property('OneToOne')
    ], ClassifierMultiplicity.prototype, "type", void 0);
    __decorate$8([
        Complex({}, MultiplicityLabel)
    ], ClassifierMultiplicity.prototype, "target", void 0);
    __decorate$8([
        Complex({}, MultiplicityLabel)
    ], ClassifierMultiplicity.prototype, "source", void 0);
    return ClassifierMultiplicity;
}(ChildProperty));
/**
 * Defines the behavior of the UMLActivity shape
 */
var RelationShip = /** @class */ (function (_super) {
    __extends$h(RelationShip, _super);
    function RelationShip() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$8([
        Property('UmlClassifier')
    ], RelationShip.prototype, "type", void 0);
    __decorate$8([
        Property('Aggregation')
    ], RelationShip.prototype, "relationship", void 0);
    __decorate$8([
        Property('Directional')
    ], RelationShip.prototype, "associationType", void 0);
    __decorate$8([
        Complex({}, ClassifierMultiplicity)
    ], RelationShip.prototype, "multiplicity", void 0);
    return RelationShip;
}(ConnectorShape));
/**
 * Connector shape for blazor
 */
var DiagramConnectorShape = /** @class */ (function (_super) {
    __extends$h(DiagramConnectorShape, _super);
    function DiagramConnectorShape() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$8([
        Property('None')
    ], DiagramConnectorShape.prototype, "type", void 0);
    __decorate$8([
        Property('Directional')
    ], DiagramConnectorShape.prototype, "associationType", void 0);
    __decorate$8([
        Property('Aggregation')
    ], DiagramConnectorShape.prototype, "relationship", void 0);
    __decorate$8([
        Complex({}, ClassifierMultiplicity)
    ], DiagramConnectorShape.prototype, "multiplicity", void 0);
    __decorate$8([
        Property('Sequence')
    ], DiagramConnectorShape.prototype, "bpmnFlow", void 0);
    __decorate$8([
        Property('Default')
    ], DiagramConnectorShape.prototype, "message", void 0);
    __decorate$8([
        Property('Normal')
    ], DiagramConnectorShape.prototype, "sequence", void 0);
    __decorate$8([
        Property('Default')
    ], DiagramConnectorShape.prototype, "association", void 0);
    __decorate$8([
        Property('Object')
    ], DiagramConnectorShape.prototype, "umlActivityFlow", void 0);
    __decorate$8([
        Property(30)
    ], DiagramConnectorShape.prototype, "exceptionFlowHeight", void 0);
    return DiagramConnectorShape;
}(ChildProperty));
/**
 * Connectors are used to create links between nodes
 */
var Connector = /** @class */ (function (_super) {
    __extends$h(Connector, _super);
    // tslint:disable-next-line:no-any
    function Connector(parent, propName, defaultValue, isArray) {
        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
        /** @private */
        _this.parentId = '';
        /** @private */
        _this.bridges = [];
        /** @private */
        _this.status = 'None';
        /** @private */
        _this.outEdges = [];
        /** @private */
        _this.inEdges = [];
        if (_this.shape && _this.shape.type === 'UmlActivity') {
            setUMLActivityDefaults(defaultValue, _this);
        }
        if (defaultValue && defaultValue.shape && defaultValue.shape.type !== 'None') {
            setConnectorDefaults(defaultValue, _this);
        }
        return _this;
    }
    /* tslint:disable */
    Connector.prototype.setPortID = function (diagram, isTarget) {
        if (this.targetID && this.sourceID) {
            var targetNode = diagram.nameTable[this.targetID];
            var sourceNode = diagram.nameTable[this.sourceID];
            var ports = isTarget ? (targetNode && targetNode.ports) : (sourceNode && sourceNode.ports);
            var port = void 0;
            for (var i = 0; ports && i < ports.length; i++) {
                port = ports[parseInt(i.toString(), 10)];
                if (this.targetPortID === port.id && isTarget) {
                    if ((port.constraints & PortConstraints.None) || !(port.constraints & PortConstraints.InConnect)) {
                        this.targetPortID = '';
                    }
                }
                else if (this.sourcePortID === port.id && !isTarget) {
                    if ((port.constraints & PortConstraints.None) || !(port.constraints & PortConstraints.OutConnect)) {
                        this.sourcePortID = '';
                    }
                }
            }
        }
    };
    /* tslint:enable */
    /** @private */
    // tslint:disable-next-line:no-any
    Connector.prototype.init = function (diagram) {
        if (!this.id) {
            this.id = randomId();
        }
        if (this.sourcePortID) {
            this.setPortID(diagram);
        }
        if (this.targetPortID) {
            this.setPortID(diagram, true);
        }
        var bpmnElement;
        var container = new Canvas();
        var segment = new PathElement();
        segment.id = this.id + '_path';
        var srcDecorator = new PathElement();
        var targetDecorator = new PathElement();
        segment = this.getSegmentElement(this, segment);
        //let bounds: Rect;
        var points = [];
        points = this.type === 'Bezier' ? this.intermediatePoints : this.getConnectorPoints(this.type);
        points = this.clipDecorators(this, points);
        var bounds = Rect.toBounds(points);
        container.width = bounds.width;
        container.height = bounds.height;
        container.offsetX = bounds.x + container.pivot.x * bounds.width;
        container.offsetY = bounds.y + container.pivot.y * bounds.height;
        switch (this.shape.type) {
            case 'Bpmn':
                // eslint-disable-next-line no-case-declarations
                var flow = this.shape.flow;
                switch (flow) {
                    case 'Sequence':
                        bpmnElement = this.getBpmnSequenceFlow();
                        break;
                    case 'Association':
                        bpmnElement = new PathElement();
                        bpmnElement.visible = false;
                        this.getBpmnAssociationFlow();
                        break;
                    case 'Message':
                        bpmnElement = this.getBpmnMessageFlow();
                        segment = this.getSegmentElement(this, segment);
                        this.updateShapePosition(this, bpmnElement);
                        break;
                }
                break;
            case 'UmlActivity':
                // eslint-disable-next-line no-case-declarations
                var activityFlow = this.shape.flow;
                switch (activityFlow) {
                    case 'Object':
                        this.getUMLObjectFlow();
                        break;
                    case 'Exception':
                        this.getUMLExceptionFlow(segment);
                        break;
                }
                break;
            case 'UmlClassifier':
                this.getConnectorRelation();
                break;
        }
        var anglePoints = this.intermediatePoints;
        if (this.type === 'Bezier') {
            var firstSegment = this.segments[0];
            var lastSegment = this.segments[this.segments.length - 1];
            anglePoints = [!Point.isEmptyPoint(lastSegment.point2) ? lastSegment.point2 : lastSegment.bezierPoint2,
                !Point.isEmptyPoint(firstSegment.point1) ? firstSegment.point1 : firstSegment.bezierPoint1];
        }
        var accessContent = 'getDescription';
        var getDescription = diagram["" + accessContent];
        //const strokeWidth: number = this.sourceWrapper ? this.sourceWrapper.style.strokeWidth / 2 / 2 : 0;
        srcDecorator = this.getDecoratorElement(points[0], anglePoints[1], this.sourceDecorator, true, getDescription);
        targetDecorator = this.getDecoratorElement(points[points.length - 1], anglePoints[anglePoints.length - 2], this.targetDecorator, false, getDescription);
        srcDecorator.id = this.id + '_srcDec';
        targetDecorator.id = this.id + '_tarDec';
        segment.style = this.style;
        /* tslint:disable:no-string-literal */
        segment.style['fill'] = 'transparent';
        if (getDescription !== undefined) {
            // tslint:disable-next-line:no-any
            var wrapperContent = getDescription(this, diagram);
            segment.description = wrapperContent ? wrapperContent : this.id;
        }
        container.style.strokeColor = 'transparent';
        container.style.fill = 'transparent';
        container.style.strokeWidth = 0;
        container.children = [segment, srcDecorator, targetDecorator];
        container.id = this.id;
        if (bpmnElement !== undefined) {
            container.children.push(bpmnElement);
        }
        container.offsetX = segment.offsetX;
        container.offsetY = segment.offsetY;
        container.width = segment.width;
        container.height = segment.height;
        for (var i = 0; this.annotations !== undefined, i < this.annotations.length; i++) {
            container.children.push(this.getAnnotationElement(this.annotations[parseInt(i.toString(), 10)], this.intermediatePoints, bounds, getDescription, diagram.element.id, diagram.annotationTemplate));
        }
        for (var i = 0; this.fixedUserHandles !== undefined, i < this.fixedUserHandles.length; i++) {
            container.children.push(this.getFixedUserHandle(this.fixedUserHandles[parseInt(i.toString(), 10)], this.intermediatePoints, bounds, diagram.fixedUserHandleTemplate, diagram.element.id));
        }
        // Feature 826644: Support to add ports to the connector.
        this.initPorts(getDescription, container, bounds);
        this.wrapper = container;
        return container;
    };
    /** @private */
    Connector.prototype.initPorts = function (accessibilityContent, container, bounds) {
        for (var i = 0; this.ports !== undefined, i < this.ports.length; i++) {
            container.children.push(this.initPort(this.ports[parseInt(i.toString(), 10)], this.intermediatePoints, bounds, accessibilityContent));
        }
    };
    // Feature 826644: Support to add ports to the connector. Added below method to init the connector port.
    /** @private */
    Connector.prototype.initPort = function (ports, points, bounds, accessibilityContent) {
        var portWrapper = new PathElement();
        portWrapper.height = ports.height;
        portWrapper.width = ports.width;
        portWrapper.margin = ports.margin;
        ports.shape = ports.shape || 'Square';
        var pathdata = (ports.shape === 'Custom') ? ports.pathData : getPortShape(ports.shape);
        portWrapper.data = pathdata;
        portWrapper.horizontalAlignment = ports.horizontalAlignment;
        portWrapper.verticalAlignment = ports.verticalAlignment;
        // eslint-disable-next-line prefer-const
        portWrapper = this.initPortWrapper(ports, points, bounds, portWrapper, this);
        // tslint:disable-next-line:no-any
        var wrapperContent;
        var contentAccessibility = getFunction(accessibilityContent);
        if (contentAccessibility) {
            wrapperContent = contentAccessibility(portWrapper, this);
        }
        portWrapper.description = wrapperContent ? wrapperContent : portWrapper.id;
        portWrapper.elementActions = portWrapper.elementActions | ElementAction.ElementIsPort;
        portWrapper.isPathPort = true;
        return portWrapper;
    };
    // Feature 826644: Support to add ports to the connector. Added below method to init the connector portwrapper.
    /** @private */
    Connector.prototype.initPortWrapper = function (ports, points, bounds, portContent, Connector) {
        ports.id = ports.id || randomId();
        // Creates port element
        var pivotPoint = { x: 0, y: 0 };
        var getPointloop = getPortsPosition(points, ports);
        var newPoint = getPointloop.point;
        portContent.id = this.id + '_' + (ports.id);
        var style = ports.style;
        portContent.style = {
            fill: style.fill, strokeColor: style.strokeColor, gradient: null,
            opacity: style.opacity, strokeDashArray: style.strokeDashArray, strokeWidth: style.strokeWidth
        };
        if (bounds.width === 0) {
            bounds.width = this.style.strokeWidth;
        }
        if (bounds.height === 0) {
            bounds.height = this.style.strokeWidth;
        }
        var offsetPoint = { x: ((newPoint.x - bounds.x) / bounds.width), y: ((newPoint.y - bounds.y) / bounds.height) };
        pivotPoint.x = bounds.width * offsetPoint.x;
        pivotPoint.y = bounds.height * offsetPoint.y;
        var align = alignLabelOnSegments(ports, getPointloop.angle, points);
        var hAlign = align.hAlign;
        var vAlign = align.vAlign;
        var horizor;
        var verzor;
        if (hAlign === 'left') {
            horizor = 'Left';
            pivotPoint.x += ports.displacement.x;
        }
        else if (hAlign === 'right') {
            horizor = 'Right';
            pivotPoint.x -= ports.displacement.x;
        }
        else if (hAlign === 'center') {
            horizor = 'Center';
        }
        if (vAlign === 'top') {
            verzor = 'Top';
            pivotPoint.y += ports.displacement.y;
        }
        else if (vAlign === 'bottom') {
            verzor = 'Bottom';
            pivotPoint.y -= ports.displacement.y;
        }
        else if (vAlign === 'center') {
            verzor = 'Center';
        }
        portContent.horizontalAlignment = horizor;
        portContent.verticalAlignment = verzor;
        if (Connector && Connector.flipMode !== 'Label' && Connector.flipMode !== 'None') {
            portContent = updatePortEdges(portContent, this.flip, ports);
        }
        else {
            portContent = updatePortEdges(portContent, 'None', ports);
        }
        portContent.float = true;
        portContent.connectionDirection = ports.connectionDirection;
        portContent.setOffsetWithRespectToBounds(pivotPoint.x, pivotPoint.y, 'Absolute');
        portContent.relativeMode = 'Point';
        portContent.visible = checkPortRestriction(ports, PortVisibility.Visible) &&
            !checkPortRestriction(ports, PortVisibility.Hover) && !checkPortRestriction(ports, PortVisibility.Connect) ? true : false;
        portContent.elementActions = portContent.elementActions | ElementAction.ElementIsPort;
        return portContent;
    };
    Connector.prototype.getConnectorRelation = function () {
        var shape = this.shape;
        if (shape.relationship === 'Association') {
            this.segments[0].type = 'Straight';
            this.sourceDecorator.shape = 'None';
            this.targetDecorator.shape = 'Arrow';
        }
        else if (shape.relationship === 'Inheritance') {
            this.segments[0].type = 'Orthogonal';
            this.sourceDecorator.shape = 'None';
            this.targetDecorator.shape = 'Arrow';
        }
        else if (shape.relationship === 'Composition') {
            this.segments[0].type = 'Orthogonal';
            this.sourceDecorator.shape = 'Diamond';
            this.targetDecorator.shape = 'None';
        }
        else if (shape.relationship === 'Aggregation') {
            this.segments[0].type = 'Orthogonal';
            this.sourceDecorator.shape = 'Diamond';
            this.targetDecorator.shape = 'None';
        }
        else if (shape.relationship === 'Dependency') {
            this.segments[0].type = 'Orthogonal';
            this.sourceDecorator.shape = 'None';
            this.targetDecorator.shape = 'OpenArrow';
        }
        else if (shape.relationship === 'Realization') {
            this.segments[0].type = 'Orthogonal';
            this.sourceDecorator.shape = 'None';
            this.targetDecorator.shape = 'Arrow';
        }
        if (shape.associationType === 'BiDirectional') {
            this.sourceDecorator.shape = 'None';
            this.targetDecorator.shape = 'None';
        }
        var text1 = '';
        //let lower: MultiplicityLabelModel;
        //let upper: MultiplicityLabelModel;
        var sourceText = '';
        var targetText = '';
        var text = '';
        if (shape.multiplicity.source) {
            shape.multiplicity.source.lowerBounds = shape.multiplicity.source.lowerBounds;
            shape.multiplicity.source.upperBounds = shape.multiplicity.source.upperBounds;
        }
        if (shape.multiplicity.target) {
            shape.multiplicity.target.lowerBounds = shape.multiplicity.target.lowerBounds;
            shape.multiplicity.target.upperBounds = shape.multiplicity.target.upperBounds;
        }
        var lower = shape.multiplicity.source;
        var upper = shape.multiplicity.target;
        text = lower.upperBounds ? lower.lowerBounds + '...' + lower.upperBounds : lower.lowerBounds;
        text1 = upper.upperBounds ? upper.lowerBounds + '...' + upper.upperBounds : upper.lowerBounds;
        if (shape.multiplicity.type === 'ManyToOne') {
            shape.multiplicity.target.optional = false;
            sourceText = text ? text : '*';
            targetText = '1';
        }
        if (shape.multiplicity.type === 'OneToMany') {
            shape.multiplicity.source.optional = false;
            targetText = text1 ? text1 : '*';
            sourceText = '1';
        }
        //831806 -Added ManyToMany relationship for UML class connector annotation label
        if (shape.multiplicity.type === 'ManyToMany') {
            sourceText = text ? text : '*';
            targetText = text1 ? text1 : '*';
        }
        if (shape.multiplicity.type === 'OneToOne') {
            shape.multiplicity.target.optional = false;
            shape.multiplicity.source.optional = false;
            sourceText = '1';
            targetText = '1';
        }
        this.annotations = [
            {
                id: this.id + 'sourcelabel', content: sourceText, offset: 0, alignment: 'Before',
                margin: { right: 5, bottom: 5 }
            },
            {
                id: this.id + 'targetlabel', content: targetText, offset: 1, alignment: 'Before',
                margin: { right: 5, bottom: 5 }
            }
        ];
    };
    Connector.prototype.getBpmnSequenceFlow = function () {
        var segment = new PathElement();
        var pathseq = new PathElement();
        if ((this.shape.sequence) === 'Normal' && this.type !== 'Bezier') {
            this.targetDecorator.shape = 'Arrow';
        }
        if ((this.shape.sequence) === 'Default') {
            segment = this.getSegmentElement(this, segment);
            var anglePoints = this.intermediatePoints;
            pathseq = updatePathElement(anglePoints, this);
            this.targetDecorator.shape = 'Arrow';
        }
        if ((this.shape.sequence) === 'Conditional') {
            this.targetDecorator.shape = 'Arrow';
            this.sourceDecorator.shape = 'Diamond';
            pathseq.id = this.id + this.shape.type;
        }
        return pathseq;
    };
    /** @private */
    Connector.prototype.getUMLObjectFlow = function () {
        if (this.annotations) {
            for (var i = 0; i < this.annotations.length; i++) {
                this.annotations[parseInt(i.toString(), 10)].content = '[' + this.annotations[parseInt(i.toString(), 10)].content + ']';
            }
        }
    };
    /** @private */
    Connector.prototype.getUMLExceptionFlow = function (segment) {
        this.type = 'Straight';
        var height = (this.shape.exceptionFlowHeight) / 2;
        var midPt = { x: (this.targetPoint.x + this.sourcePoint.x) / 2, y: (this.targetPoint.y + this.sourcePoint.y) / 2 };
        var xDist = midPt.x - this.sourcePoint.x;
        var yDist = midPt.y - this.sourcePoint.y;
        var dist = Math.sqrt(xDist * xDist + yDist * yDist);
        var fractionOfTotal = (height) / dist;
        var midPt2 = { x: midPt.x - xDist * fractionOfTotal, y: midPt.y - yDist * fractionOfTotal };
        var midPt1 = { x: midPt.x + xDist * fractionOfTotal, y: midPt.y + yDist * fractionOfTotal };
        var matrix = identityMatrix();
        rotateMatrix(matrix, 315, midPt.x, midPt.y);
        this.segments = [];
        var segments = new StraightSegment(this, 'segments', { type: 'Straight', point: transformPointByMatrix(matrix, midPt1) }, true);
        (this.segments).push(segments);
        segments = new StraightSegment(this, 'segments', { type: 'Straight', point: transformPointByMatrix(matrix, midPt2) }, true);
        (this.segments).push(segments);
        segment = this.getSegmentElement(this, segment);
    };
    Connector.prototype.getBpmnAssociationFlow = function () {
        if ((this.shape.association) === 'Default') {
            this.targetDecorator.shape = 'None';
            this.style.strokeDashArray = '2 2';
        }
        if ((this.shape.association) === 'Directional') {
            this.targetDecorator.shape = 'OpenArrow';
            this.style.strokeDashArray = '2 2';
        }
        if ((this.shape.association) === 'BiDirectional') {
            this.targetDecorator.shape = 'OpenArrow';
            this.sourceDecorator.shape = 'OpenArrow';
            this.style.strokeDashArray = '2 2';
        }
    };
    // 882378 - Added below code to provide template support for fixedUserHandles in connectors
    /** @private */
    Connector.prototype.getFixedUserHandle = function (fixedUserHandle, points, bounds, fixedUserHandleTemplate, diagramId) {
        var fixedUserHandleContainer;
        if (fixedUserHandle.pathData === '' && fixedUserHandleTemplate) {
            fixedUserHandleContainer = new DiagramHtmlElement(this.id, diagramId, undefined, fixedUserHandleTemplate);
            fixedUserHandleContainer.isTemplate = true;
            fixedUserHandleContainer.template = getContent(fixedUserHandleContainer, true, fixedUserHandle);
            fixedUserHandle.id = fixedUserHandle.id || randomId();
            fixedUserHandleContainer.id = this.id + '_' + fixedUserHandle.id;
        }
        else {
            fixedUserHandleContainer = new Canvas();
            var children = [];
            fixedUserHandleContainer.children = children;
            fixedUserHandle.id = fixedUserHandle.id || randomId();
            fixedUserHandleContainer.id = this.id + '_' + fixedUserHandle.id;
            var symbolIcon = initFixedUserHandlesSymbol(fixedUserHandle, fixedUserHandleContainer);
            fixedUserHandleContainer.children.push(symbolIcon);
        }
        fixedUserHandleContainer.float = true;
        fixedUserHandleContainer.visible = fixedUserHandle.visibility;
        fixedUserHandleContainer.width = fixedUserHandle.width;
        fixedUserHandleContainer.height = fixedUserHandle.height;
        fixedUserHandleContainer.style.strokeWidth = fixedUserHandle.handleStrokeWidth;
        fixedUserHandleContainer.style.fill = fixedUserHandle.fill;
        fixedUserHandleContainer.style.strokeColor = fixedUserHandle.handleStrokeColor;
        fixedUserHandleContainer.cornerRadius = fixedUserHandle.cornerRadius;
        this.updateAnnotation(fixedUserHandle, points, bounds, fixedUserHandleContainer);
        fixedUserHandleContainer.description = fixedUserHandleContainer.id;
        return fixedUserHandleContainer;
    };
    Connector.prototype.getBpmnMessageFlow = function () {
        var segmentMessage = new PathElement();
        this.targetDecorator.shape = 'Arrow';
        this.targetDecorator.width = 10;
        this.targetDecorator.height = 10;
        this.sourceDecorator.shape = 'Circle';
        this.sourceDecorator.style.fill = 'white';
        this.targetDecorator.style.fill = 'white';
        if (((this.shape.message) === 'InitiatingMessage') ||
            ((this.shape.message) === 'NonInitiatingMessage')) {
            segmentMessage.id = this.id + '_' + (this.shape.message);
            segmentMessage.width = 25;
            segmentMessage.height = 15;
            segmentMessage.data = 'M0,0 L19.8,12.8 L40,0 L0, 0 L0, 25.5 L40, 25.5 L 40, 0';
            segmentMessage.horizontalAlignment = 'Center';
            segmentMessage.verticalAlignment = 'Center';
            segmentMessage.transform = Transform.Self;
            segmentMessage.style.fill = (this.shape.message) === 'NonInitiatingMessage' ? 'lightgrey' : 'white';
        }
        return segmentMessage;
    };
    /** @private */
    Connector.prototype.distance = function (pt1, pt2) {
        return findDistance(pt1, pt2);
    };
    /**   @private  */
    Connector.prototype.findPath = function (sourcePt, targetPt) {
        return findPath(sourcePt, targetPt);
    };
    /** @private */
    Connector.prototype.getAnnotationElement = function (annotation, points, bounds, getDescription, diagramId, annotationTemplate) {
        annotation.content = annotation.content || '';
        annotation.id = annotation.id || randomId();
        var textele;
        //Removed isBlazor code
        if (diagramId && (annotation.template || annotation.annotationType === 'Template'
            || (annotationTemplate && annotation.content === ''))) {
            // Task 834121: Content-Security-Policy support for diagram
            var diagramElement = document.getElementById(diagramId);
            var instance = 'ej2_instances';
            var diagram = diagramElement["" + instance][0];
            textele = new DiagramHtmlElement(this.id, diagramId, annotation.id, annotationTemplate);
            if (annotation.template && typeof annotation.template === 'function' && diagram.isReact) {
                textele.templateFn = compile(annotation.template);
                textele.isTemplate = true;
            }
            //908155-Annotation template update wrongly while do interaction for connector
            if (annotation.height === undefined && annotation.annotationType === 'String' && (annotation.template || annotation.content === '')) {
                annotation.height = bounds.height;
            }
            textele = getTemplateContent(textele, annotation, annotationTemplate, diagram);
        }
        else {
            textele = new TextElement();
            //876030 - Adding hyperlink for connectors
            var link = annotation.hyperlink.link ? annotation.hyperlink : undefined;
            textele.style = annotation.style;
            textele.style.color = link ? link.color || textele.hyperlink.color : annotation.style.color;
            textele.hyperlink.link = annotation.hyperlink.link || undefined;
            textele.hyperlink.hyperlinkOpenState = annotation.hyperlink.hyperlinkOpenState || undefined;
            textele.hyperlink.textDecoration = annotation.hyperlink.textDecoration || undefined;
            textele.content = link ? link.content ||
                textele.hyperlink.link : annotation.content;
        }
        textele.constraints = annotation.constraints;
        textele.visible = annotation.visibility;
        textele.annotationVisibility = textele.visible ? 'Visible' : 'Collapsed';
        textele.rotateAngle = annotation.rotateAngle;
        textele.horizontalAlignment = annotation.horizontalAlignment;
        textele.verticalAlignment = annotation.verticalAlignment;
        textele.width = annotation.width;
        textele.height = annotation.height;
        if (bounds.width !== undefined && !annotation.template) {
            textele.width = (annotation.width || bounds.width) - annotation.margin.left - annotation.margin.right;
        }
        textele.margin = annotation.margin;
        textele.id = this.id + '_' + annotation.id;
        if (bounds.width === 0) {
            bounds.width = this.style.strokeWidth;
        }
        if (bounds.height === 0) {
            bounds.height = this.style.strokeWidth;
        }
        // tslint:disable-next-line:no-any
        var wrapperContent;
        var description = getFunction(getDescription);
        if (description) {
            wrapperContent = description(annotation, this);
        }
        textele.description = wrapperContent ? wrapperContent : textele.id;
        this.updateAnnotation(annotation, points, bounds, textele);
        return textele;
    };
    /** @private */
    Connector.prototype.updateAnnotation = function (annotation, points, bounds, textElement, canRefresh) {
        //let getPointloop: SegmentInfo;
        //let align: Alignment; let hAlign: string;
        var pivotPoint = { x: 0, y: 0 };
        //Bug 881512: Wrapping of the connector annotation at run time not working properly.
        //To refresh the annotation at run time while moving connector end points or while moving nodes connected with connector.
        if ((textElement instanceof TextElement) && (!canRefresh)) {
            textElement.refreshTextElement();
        }
        textElement.width = (annotation.width || bounds.width);
        var getPointloop = getAnnotationPosition(points, annotation);
        var newPoint = getPointloop.point;
        if (annotation instanceof PathAnnotation && annotation.segmentAngle) {
            textElement.rotateAngle = annotation.rotateAngle + getPointloop.angle;
            textElement.rotateAngle = (textElement.rotateAngle + 360) % 360;
        }
        if (bounds.width === 0) {
            bounds.width = this.style.strokeWidth;
        }
        if (bounds.height === 0) {
            bounds.height = this.style.strokeWidth;
        }
        var offsetPoint = { x: ((newPoint.x - bounds.x) / bounds.width), y: ((newPoint.y - bounds.y) / bounds.height) };
        pivotPoint.x = bounds.width * offsetPoint.x;
        pivotPoint.y = bounds.height * offsetPoint.y;
        var align = alignLabelOnSegments(annotation, getPointloop.angle, points);
        var hAlign = align.hAlign;
        var vAlign = align.vAlign;
        var horizor;
        var verzor;
        if (hAlign === 'left') {
            horizor = 'Left';
            pivotPoint.x += annotation.displacement.x;
        }
        else if (hAlign === 'right') {
            horizor = 'Right';
            pivotPoint.x -= annotation.displacement.x;
        }
        else if (hAlign === 'center') {
            horizor = 'Center';
        }
        if (vAlign === 'top') {
            verzor = 'Top';
            pivotPoint.y += annotation.displacement.y;
        }
        else if (vAlign === 'bottom') {
            verzor = 'Bottom';
            pivotPoint.y -= annotation.displacement.y;
        }
        else if (vAlign === 'center') {
            verzor = 'Center';
        }
        textElement.horizontalAlignment = horizor;
        textElement.verticalAlignment = verzor;
        textElement.setOffsetWithRespectToBounds(pivotPoint.x, pivotPoint.y, 'Absolute');
        textElement.relativeMode = 'Point';
    };
    /** @private */
    Connector.prototype.getConnectorPoints = function (type, points, layoutOrientation, lineDistribution) {
        //const width: number = Math.abs(this.sourcePoint.x - this.targetPoint.x);
        //const height: number = Math.abs(this.sourcePoint.y - this.targetPoint.y);
        points = findConnectorPoints(this, layoutOrientation, lineDistribution);
        var newPoints = points.slice(0);
        if (newPoints && newPoints.length > 0) {
            this.sourcePoint = newPoints[0];
            this.targetPoint = newPoints[newPoints.length - 1];
        }
        return newPoints;
    };
    /** @private */
    Connector.prototype.clipDecorator = function (connector, points, isSource, diagramAction) {
        var point = { x: 0, y: 0 };
        var start = { x: 0, y: 0 };
        var end = { x: 0, y: 0 };
        var length = points.length;
        start = !isSource ? points[length - 1] : points[0];
        end = !isSource ? points[length - 2] : points[1];
        var len = Point.distancePoints(start, end);
        len = (len === 0) ? 1 : len;
        var strokeWidth = 1;
        var node = isSource ? connector.sourceWrapper : connector.targetWrapper;
        if (node) {
            strokeWidth = node.style.strokeWidth;
            if (diagramAction && ((diagramAction) & DiagramAction.DecoratorPropertyChange)) {
                strokeWidth = 1;
            }
        }
        var width = strokeWidth - 1;
        point.x = (Math.round(start.x + width * (end.x - start.x) / len));
        point.y = (Math.round(start.y + width * (end.y - start.y) / len));
        if ((isSource && connector.sourceDecorator.shape !== 'None') ||
            (!isSource && connector.targetDecorator.shape !== 'None')) {
            point = Point.adjustPoint(point, end, true, (diagramAction & DiagramAction.DecoratorPropertyChange) ? 0 : (strokeWidth / 2));
        }
        return point;
    };
    /** @private */
    Connector.prototype.clipDecorators = function (connector, pts, diagramAction) {
        if (connector.sourceDecorator.shape !== 'None') {
            pts[0] = this.clipDecorator(connector, pts, true, diagramAction);
        }
        if (connector.targetDecorator.shape !== 'None') {
            pts[pts.length - 1] = this.clipDecorator(connector, pts, false, diagramAction);
        }
        return pts;
    };
    /** @private */
    Connector.prototype.updateSegmentElement = function (connector, points, element, diagramActions) {
        var bounds = new Rect();
        //let point: PointModel[];
        var segmentPath = this.getSegmentPath(connector, points, diagramActions);
        if (connector.type === 'Bezier') {
            if (this.segments.length > 0) {
                for (var i = 0; i < this.segments.length; i++) {
                    var segment = this.segments[parseInt(i.toString(), 10)];
                    var connectorSegment = connector.segments[parseInt(i.toString(), 10)];
                    // eslint-disable-next-line max-len
                    var point1 = !Point.isEmptyPoint(segment.point1) ? connectorSegment.point1 : connectorSegment.bezierPoint1;
                    // eslint-disable-next-line max-len
                    var point2 = !Point.isEmptyPoint(segment.point2) ? connectorSegment.point2 : connectorSegment.bezierPoint2;
                    bounds.uniteRect(getBezierBounds(segment.points[0], point1, point2, segment.points[1], connector));
                }
            }
        }
        else {
            bounds = Rect.toBounds(points);
        }
        element.width = bounds.width;
        element.height = bounds.height;
        element.offsetX = bounds.x + element.width / 2;
        element.offsetY = bounds.y + element.height / 2;
        element.data = segmentPath;
        if (connector.wrapper) {
            connector.wrapper.offsetX = element.offsetX;
            connector.wrapper.offsetY = element.offsetY;
            connector.wrapper.width = bounds.width;
            connector.wrapper.height = bounds.height;
        }
        return element;
    };
    /** @private */
    Connector.prototype.getSegmentElement = function (connector, segmentElement, layoutOrientation, diagramActions, isFlip) {
        if (isFlip === void 0) { isFlip = true; }
        //let bounds: Rect; let segmentPath: string;
        var points = [];
        if (isFlip) {
            flipConnector(connector);
        }
        points = this.getConnectorPoints(connector.type, undefined, layoutOrientation);
        this.intermediatePoints = points;
        segmentElement.staticSize = true;
        segmentElement = this.updateSegmentElement(connector, points, segmentElement, diagramActions);
        return segmentElement;
    };
    /** @private */
    Connector.prototype.getDecoratorElement = function (offsetPoint, adjacentPoint, decorator, isSource, getDescription) {
        var decEle = new PathElement();
        decEle.transform = Transform.Self;
        this.updateDecoratorElement(decEle, offsetPoint, adjacentPoint, decorator);
        if (getDescription !== undefined) {
            // tslint:disable-next-line:no-any
            var wrapperContent = getDescription(decorator, this);
            decEle.description = wrapperContent ? wrapperContent :
                ('Specifies the ' + isSource ? 'source' : 'target' + 'port element of the connector');
        }
        return decEle;
    };
    Connector.prototype.bridgePath = function (connector, path, pointIndex) {
        var pathData = path;
        if (connector.bridges.length > 0) {
            if (connector.type === 'Straight' && connector.segments.length < 2) {
                for (var n = 0; n < connector.bridges.length; n++) {
                    var bridge = connector.bridges[parseInt(n.toString(), 10)];
                    if (!bridge.rendered) {
                        pathData += ' L' + bridge.startPoint.x + ' ' + bridge.startPoint.y;
                        pathData += bridge.path;
                        bridge.rendered = true;
                    }
                }
            }
            else if (connector.type === 'Orthogonal' || (connector.type === 'Straight' && connector.segments.length > 1)) {
                for (var n = 0; n < connector.bridges.length; n++) {
                    var bridge = connector.bridges[parseInt(n.toString(), 10)];
                    if (bridge.segmentPointIndex === pointIndex) {
                        if (!bridge.rendered) {
                            if (bridge.segmentPointIndex === pointIndex) {
                                pathData += ' L' + bridge.startPoint.x + ' ' + bridge.startPoint.y;
                                pathData += bridge.path;
                                bridge.rendered = true;
                            }
                        }
                    }
                }
            }
        }
        return pathData;
    };
    /** @private */
    Connector.prototype.updateDecoratorElement = function (element, pt, adjacentPoint, decorator) {
        //let getPath: string;// let angle: number;
        element.offsetX = pt.x;
        element.offsetY = pt.y;
        var angle = Point.findAngle(pt, adjacentPoint);
        var getPath = getDecoratorShape(decorator.shape, decorator);
        var size = new Size(decorator.width, decorator.height);
        element.pivot.x = decorator.pivot.x;
        element.pivot.y = decorator.pivot.y;
        element.style = decorator.style;
        element.rotateAngle = angle;
        element.data = getPath;
        element.canMeasurePath = true;
        element.width = size.width;
        element.height = size.height;
    };
    /** @private */
    Connector.prototype.getSegmentPath = function (connector, points, diagramAction) {
        var path = '';
        var getPt;
        var end;
        var st;
        var pts = [];
        var j = 0;
        while (j < points.length) {
            pts.push({ x: points[parseInt(j.toString(), 10)].x, y: points[parseInt(j.toString(), 10)].y });
            j++;
        }
        for (var m = 0; m < connector.bridges.length; m++) {
            var bridge = connector.bridges[parseInt(m.toString(), 10)];
            bridge.rendered = false;
        }
        pts = this.clipDecorators(connector, pts, diagramAction);
        if (this.cornerRadius > 0 && this.type !== 'Bezier') {
            for (var j_1 = 0; j_1 < pts.length - 1; j_1++) {
                getPt = pts[parseInt(j_1.toString(), 10)];
                if (j_1 === 0) {
                    path = 'M' + getPt.x + ' ' + getPt.y;
                }
                var segLength = Point.distancePoints(pts[parseInt(j_1.toString(), 10)], pts[j_1 + 1]);
                if (segLength > 0) {
                    if (j_1 < pts.length - 2) {
                        if (segLength < this.cornerRadius * 2) {
                            end = Point.adjustPoint(pts[parseInt(j_1.toString(), 10)], pts[j_1 + 1], false, segLength / 2);
                        }
                        else {
                            end = Point.adjustPoint(pts[parseInt(j_1.toString(), 10)], pts[j_1 + 1], false, this.cornerRadius);
                        }
                    }
                    else {
                        end = pts[j_1 + 1];
                    }
                    if (j_1 > 0) {
                        if (segLength < this.cornerRadius * 2) {
                            st = Point.adjustPoint(pts[parseInt(j_1.toString(), 10)], pts[j_1 + 1], true, segLength / 2);
                            if (j_1 < pts.length - 2) {
                                end = null;
                            }
                        }
                        else {
                            st = Point.adjustPoint(pts[parseInt(j_1.toString(), 10)], pts[j_1 + 1], true, this.cornerRadius);
                        }
                    }
                    if (st) {
                        path += 'Q' + getPt.x + ' ' + getPt.y + ' ' + st.x + ' ' + st.y;
                    }
                    if (end) {
                        if (connector.bridges.length > 0) {
                            path = this.bridgePath(connector, path, j_1);
                            if (connector.type === 'Orthogonal') {
                                path = this.bridgePath(connector, path, j_1 + 1);
                            }
                        }
                        path += ' L' + end.x + ' ' + end.y;
                    }
                }
            }
        }
        else {
            if (this.type === 'Bezier') {
                var isrezise = void 0;
                var isDrawing = void 0;
                if (this.parentObj.element) {
                    var action = this.parentObj.element.ej2_instances[0]['eventHandler'].action;
                    isrezise = (this.parentObj.element.ej2_instances[0]['eventHandler']).tool instanceof ResizeTool;
                    isDrawing = action.includes('PortDraw') || action.includes('Drag');
                }
                var direction = void 0;
                var segments = this.segments;
                for (var j_2 = 0; j_2 < segments.length; j_2++) {
                    if (pts.length > 2) {
                        segments[parseInt(j_2.toString(), 10)].bezierPoint1 = { x: 0, y: 0 };
                        segments[parseInt(j_2.toString(), 10)].bezierPoint2 = { x: 0, y: 0 };
                    }
                    if (Point.isEmptyPoint(segments[parseInt(j_2.toString(), 10)].point1) &&
                        !segments[parseInt(j_2.toString(), 10)].vector1.angle && !segments[parseInt(j_2.toString(), 10)].vector1.distance) {
                        if ((connector.sourceID || this.sourcePortID) && this.sourceWrapper && !isDrawing && !isrezise) {
                            direction = getDirection$1(this.sourceWrapper.bounds, pts[parseInt(j_2.toString(), 10)], true);
                        }
                        segments[parseInt(j_2.toString(), 10)].bezierPoint1 = getBezierPoints(pts[parseInt(j_2.toString(), 10)], pts[j_2 + 1], direction);
                    }
                    else if (segments[parseInt(j_2.toString(), 10)].vector1.angle
                        || segments[parseInt(j_2.toString(), 10)].vector1.distance) {
                        segments[parseInt(j_2.toString(), 10)].bezierPoint1
                            = Point.transform(pts[parseInt(j_2.toString(), 10)], segments[parseInt(j_2.toString(), 10)].vector1.angle, segments[parseInt(j_2.toString(), 10)].vector1.distance);
                    }
                    else {
                        segments[parseInt(j_2.toString(), 10)].bezierPoint1 = {
                            x: segments[parseInt(j_2.toString(), 10)].point1.x || segments[parseInt(j_2.toString(), 10)].bezierPoint1.x,
                            y: segments[parseInt(j_2.toString(), 10)].point1.y || segments[parseInt(j_2.toString(), 10)].bezierPoint1.y
                        };
                    }
                    if (Point.isEmptyPoint(segments[parseInt(j_2.toString(), 10)].point2) &&
                        !segments[parseInt(j_2.toString(), 10)].vector2.angle && !segments[parseInt(j_2.toString(), 10)].vector2.distance) {
                        if ((connector.targetID || this.targetPortID) && this.targetWrapper && !isDrawing && !isrezise) {
                            direction = getDirection$1(this.targetWrapper.bounds, pts[j_2 + 1], true);
                        }
                        segments[parseInt(j_2.toString(), 10)].bezierPoint2 = getBezierPoints(pts[j_2 + 1], pts[parseInt(j_2.toString(), 10)], direction);
                    }
                    else if (segments[parseInt(j_2.toString(), 10)].vector2.angle
                        || segments[parseInt(j_2.toString(), 10)].vector2.distance) {
                        segments[parseInt(j_2.toString(), 10)].bezierPoint2
                            = Point.transform(pts[j_2 + 1], segments[parseInt(j_2.toString(), 10)].vector2.angle, segments[parseInt(j_2.toString(), 10)].vector2.distance);
                    }
                    else {
                        segments[parseInt(j_2.toString(), 10)].bezierPoint2 = {
                            x: segments[parseInt(j_2.toString(), 10)].point2.x || segments[parseInt(j_2.toString(), 10)].bezierPoint2.x,
                            y: segments[parseInt(j_2.toString(), 10)].point2.y || segments[parseInt(j_2.toString(), 10)].bezierPoint2.y
                        };
                    }
                }
                pts.splice(1, 0, { x: segments[0].bezierPoint1.x, y: segments[0].bezierPoint1.y });
                pts.splice(pts.length - 1, 0, {
                    x: segments[segments.length - 1].bezierPoint2.x, y: segments[segments.length - 1].bezierPoint2.y
                });
                pts = this.clipDecorators(connector, pts, diagramAction);
                for (var j_3 = 0; j_3 < segments.length; j_3++) {
                    if (j_3 === 0) {
                        path = 'M' + pts[0].x + ' ' + pts[0].y;
                    }
                    var lastPoint = (j_3 === segments.length - 1) ? pts[pts.length - 1].x + ' ' + pts[pts.length - 1].y :
                        segments[parseInt(j_3.toString(), 10)].points[segments[parseInt(j_3.toString(), 10)].points.length - 1].x + ' ' + segments[parseInt(j_3.toString(), 10)].points[segments[parseInt(j_3.toString(), 10)].points.length - 1].y;
                    path += 'C' +
                        segments[parseInt(j_3.toString(), 10)].bezierPoint1.x + ' ' + segments[parseInt(j_3.toString(), 10)].bezierPoint1.y + ' ' + segments[parseInt(j_3.toString(), 10)].bezierPoint2.x + ' '
                        + segments[parseInt(j_3.toString(), 10)].bezierPoint2.y + ' ' + lastPoint;
                }
            }
            else {
                for (var k = 0; k < pts.length; k++) {
                    getPt = pts[parseInt(k.toString(), 10)];
                    if (k === 0) {
                        path = 'M' + getPt.x + ' ' + getPt.y;
                    }
                    if (k > 0) {
                        path = this.bridgePath(connector, path, k);
                        path += ' ' + 'L' + getPt.x + ' ' + getPt.y;
                    }
                }
            }
        }
        return path;
    };
    /** @private */
    Connector.prototype.updateShapeElement = function (connector) {
        var element;
        switch (connector.shape.type) {
            case 'Bpmn':
                if (connector.wrapper.children[3] instanceof PathElement) {
                    element = connector.wrapper.children[3];
                }
                if (connector.shape.flow === 'Message') {
                    this.updateShapePosition(connector, element);
                }
                break;
            case 'UmlActivity':
                if (connector.shape.flow === 'Exception') {
                    this.getUMLExceptionFlow(connector.wrapper.children[0]);
                }
                break;
        }
    };
    /** @private */
    Connector.prototype.updateShapePosition = function (connector, element) {
        var segmentOffset = 0.5;
        var anglePoints = this.intermediatePoints;
        //Bug 860251: Bpmn message flow and sequence flow connector child path is not rendered properly.
        //To get the path offset of message flow.
        var offset = getPathOffset(anglePoints, element, segmentOffset);
        element.offsetX = offset.x;
        element.offsetY = offset.y;
    };
    /** @hidden */
    Connector.prototype.scale = function (sw, sh, width, height, refObject) {
        var tx = 0;
        var ty = 0;
        if (this.wrapper && this.wrapper.outerBounds) {
            var outerBounds = getOuterBounds(this);
            // EJ2-56887 - Connector do not get rendered properly in symbol palette.
            // Added the absolute command to change the connector height to positive if it is in negative value.
            var connWidth = Math.abs((this.wrapper.bounds.width || this.style.strokeWidth || 1) - 2);
            var connHeight = Math.abs((this.wrapper.bounds.height || this.style.strokeWidth || 1) - 2);
            tx = (outerBounds.width - connWidth);
            ty = (outerBounds.height - connHeight);
            sw = Math.abs((width - (Math.max(tx, ty))) / connWidth);
            sh = Math.abs((height - (Math.max(tx, ty))) / connHeight);
            tx = ty = Math.min(tx, ty);
        }
        sw = sh = Math.min(sw, sh);
        var matrix = identityMatrix();
        refObject = refObject || this.wrapper;
        rotateMatrix(matrix, -refObject.rotateAngle, refObject.offsetX, refObject.offsetY);
        scaleMatrix(matrix, sw, sh, refObject.offsetX, refObject.offsetY);
        rotateMatrix(matrix, refObject.rotateAngle, refObject.offsetX, refObject.offsetY);
        var points = transformPointsByMatrix(matrix, this.intermediatePoints);
        this.sourcePoint = points[0];
        this.targetPoint = points[points.length - 1];
        points = this.intermediatePoints = findConnectorPoints(this);
        updateConnector(this, points);
        return { x: tx, y: ty };
    };
    /**
     * @private
     * Returns the name of class Connector
     */
    Connector.prototype.getClassName = function () {
        return 'Connector';
    };
    __decorate$8([
        ComplexFactory(getConnectorType)
    ], Connector.prototype, "shape", void 0);
    __decorate$8([
        Property(ConnectorConstraints.Default)
    ], Connector.prototype, "constraints", void 0);
    __decorate$8([
        Property(10)
    ], Connector.prototype, "bridgeSpace", void 0);
    __decorate$8([
        Collection([], PathAnnotation)
    ], Connector.prototype, "annotations", void 0);
    __decorate$8([
        Complex({}, Point)
    ], Connector.prototype, "sourcePoint", void 0);
    __decorate$8([
        Complex({}, Point)
    ], Connector.prototype, "targetPoint", void 0);
    __decorate$8([
        Collection([], ConnectorFixedUserHandle)
    ], Connector.prototype, "fixedUserHandles", void 0);
    __decorate$8([
        CollectionFactory(getSegmentType)
    ], Connector.prototype, "segments", void 0);
    __decorate$8([
        Property('')
    ], Connector.prototype, "sourceID", void 0);
    __decorate$8([
        Property('')
    ], Connector.prototype, "targetID", void 0);
    __decorate$8([
        Property(10)
    ], Connector.prototype, "hitPadding", void 0);
    __decorate$8([
        Property(0)
    ], Connector.prototype, "connectionPadding", void 0);
    __decorate$8([
        Property('Straight')
    ], Connector.prototype, "type", void 0);
    __decorate$8([
        Property('Circle')
    ], Connector.prototype, "segmentThumbShape", void 0);
    __decorate$8([
        Property(10)
    ], Connector.prototype, "segmentThumbSize", void 0);
    __decorate$8([
        Property(0)
    ], Connector.prototype, "cornerRadius", void 0);
    __decorate$8([
        Complex({ shape: 'None' }, Decorator)
    ], Connector.prototype, "sourceDecorator", void 0);
    __decorate$8([
        Complex({ shape: 'Arrow' }, Decorator)
    ], Connector.prototype, "targetDecorator", void 0);
    __decorate$8([
        Complex({}, DiagramTooltip)
    ], Connector.prototype, "tooltip", void 0);
    __decorate$8([
        Property('')
    ], Connector.prototype, "sourcePortID", void 0);
    __decorate$8([
        Property('')
    ], Connector.prototype, "targetPortID", void 0);
    __decorate$8([
        Property(0)
    ], Connector.prototype, "sourcePadding", void 0);
    __decorate$8([
        Complex({}, SymbolSize)
    ], Connector.prototype, "previewSize", void 0);
    __decorate$8([
        Complex({}, SymbolSize)
    ], Connector.prototype, "dragSize", void 0);
    __decorate$8([
        Property(0)
    ], Connector.prototype, "targetPadding", void 0);
    __decorate$8([
        Property(13)
    ], Connector.prototype, "connectorSpacing", void 0);
    __decorate$8([
        Complex({ strokeWidth: 1, strokeColor: 'black' }, StrokeStyle)
    ], Connector.prototype, "style", void 0);
    __decorate$8([
        Property(null)
    ], Connector.prototype, "maxSegmentThumb", void 0);
    __decorate$8([
        Property(false)
    ], Connector.prototype, "allowNodeOverlap", void 0);
    __decorate$8([
        Complex({}, BezierSettings)
    ], Connector.prototype, "bezierSettings", void 0);
    __decorate$8([
        Collection([], PathPort)
    ], Connector.prototype, "ports", void 0);
    __decorate$8([
        Property(null)
    ], Connector.prototype, "wrapper", void 0);
    return Connector;
}(NodeBase));

var __extends$i = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Represents the Ruler component that measures the Diagram objects, indicate positions, and align Diagram elements.
 * ```html
 * <div id='ruler'>Show Ruler</div>
 * ```
 * ```typescript
 * <script>
 *   var rulerObj = new Ruler({ showRuler: true });
 *   rulerObj.appendTo('#ruler');
 * </script>
 * ```
 */
var Ruler = /** @class */ (function (_super) {
    __extends$i(Ruler, _super);
    /**
     *  Constructor for creating the Ruler Component
     *
     * @param {RulerModel} options The ruler model.
     * @param {string | HTMLElement} element The ruler element.
     */
    function Ruler(options, element) {
        var _this = _super.call(this, options, element) || this;
        /**   @private  */
        _this.offset = 0;
        /**   @private  */
        _this.scale = 1;
        return _this;
    }
    /**
     * Initializes the values of private members.
     *
     * @returns {void}  Initializes the values of private members.
     * @private
     */
    Ruler.prototype.preRender = function () {
        this.unWireEvents();
        this.wireEvents();
    };
    /**
     * Renders the rulers.
     *
     * @returns {void}  Renders the rulers.
     * @private
     */
    Ruler.prototype.render = function () {
        this.updateRulerGeometry();
        this.renderComplete();
    };
    /**
     * Core method to return the component name.
     *
     * @returns {string}  Core method to return the component name.
     * @private
     */
    Ruler.prototype.getModuleName = function () {
        return 'Ruler';
    };
    /**
     *To destroy the ruler
     *
     * @returns {void} To destroy the ruler
     */
    Ruler.prototype.destroy = function () {
        this.unWireEvents();
        this.notify('destroy', {});
        _super.prototype.destroy.call(this);
        this.element.classList.remove('e-ruler');
    };
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @returns {string}  Get the properties to be maintained in the persisted state.
     */
    Ruler.prototype.getPersistData = function () {
        var keyEntity = ['loaded'];
        return this.addOnPersist(keyEntity);
    };
    /**
     * Refreshes the ruler when the Ruler properties are updated\
     *
     * @returns {  void}    Refreshes the ruler when the Ruler properties are updated .\
     * @param {RulerModel} newProp - provide the newProp value.
     * @param {RulerModel} oldProp - provide the oldProp value.
     * @private
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Ruler.prototype.onPropertyChanged = function (newProp, oldProp) {
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'length':
                case 'interval':
                case 'segmentWidth':
                case 'tickAlignment':
                case 'markerColor':
                case 'thickness':
                    this.updateRuler();
                    break;
            }
        }
    };
    Ruler.prototype.updateRulerGeometry = function () {
        this.element.style.textAlign = 'left';
        this.renderRulerSpace();
        this.updateRuler();
    };
    Ruler.prototype.renderRulerSpace = function () {
        var rulerGeometry = this.getRulerGeometry();
        var div = document.getElementById(this.element.id + '_ruler_space');
        if (!div) {
            div = createHtmlElement('div', {
                'id': this.element.id + '_ruler_space',
                'style': 'height:' + rulerGeometry.height + 'px;width:' + rulerGeometry.width + 'px;cssFloat:' + 'left;'
            });
            this.element.appendChild(div);
        }
        return div;
    };
    Ruler.prototype.updateRuler = function () {
        var rulerSize = this.getRulerSize();
        var rulerGeometry = this.getRulerGeometry();
        var length = 0;
        var offset = 0;
        var availableSize = new Size();
        var svg = this.getRulerSVG(rulerGeometry);
        if (svg) {
            length = this.length;
            availableSize.height = rulerSize;
            offset = this.offset;
            if (length && length !== Infinity) {
                var unitLength = length + this.segmentWidth;
                var unitOffset = offset;
                this.updateSegments(unitOffset, (unitLength + Math.abs(unitOffset)), svg, rulerSize);
            }
        }
    };
    Ruler.prototype.updateSegments = function (start, end, svg, rulerSize) {
        var run = start;
        var trans = { trans: 0 };
        while (run < end) {
            var rulerSegment = this.getNewSegment(run, svg);
            if (rulerSegment) {
                svg.appendChild(rulerSegment.segment);
                run = this.updateSegment(start, end, rulerSegment, run, trans, rulerSize);
            }
        }
    };
    Ruler.prototype.updateSegment = function (start, end, rulerSegment, run, trans, rulerSize) {
        var segWidth = this.updateSegmentWidth(this.scale);
        if (run === start) {
            this.startValue = Math.floor(start / segWidth) * segWidth / this.scale;
            this.startValue = (this.startValue % 1) !== 0 ? Number((this.startValue).toFixed(1)) : this.startValue;
            rulerSegment.label.textContent = this.startValue.toString();
            this.defStartValue = run = this.startValue * this.scale;
            if (this.orientation === 'Horizontal') {
                this.hRulerOffset = start - run;
            }
            else {
                this.vRulerOffset = start - run;
            }
        }
        else {
            this.startValue = (run / this.scale);
            this.startValue = (this.startValue % 1) !== 0 ? Number((this.startValue).toFixed(1)) : this.startValue;
            rulerSegment.label.textContent = this.startValue.toString();
        }
        this.updateTickLabel(rulerSegment, rulerSize);
        var translate = (this.orientation === 'Horizontal') ? ((trans.trans + 0.5) + ',0.5') : ('0.5,' + (trans.trans + 0.5));
        rulerSegment.segment.setAttribute('transform', 'translate(' + translate + ')');
        trans.trans += segWidth;
        run += segWidth;
        return run;
    };
    Ruler.prototype.updateTickLabel = function (rulerSegment, rulerSize) {
        var bBox = rulerSegment.segment.lastChild.getBBox();
        var isHorizontal = (this.orientation === 'Horizontal') ? true : false;
        var isRightOrBottom = (this.tickAlignment === 'RightOrBottom') ? true : false;
        var x = isHorizontal ? 2 : 0;
        var y = isHorizontal ? (isRightOrBottom ? (rulerSize / 2 + (11 / 2) - (11 / 2)) :
            (rulerSize / 2 + (11 / 2))) : bBox.height;
        var translate = isRightOrBottom ? (-(bBox.width + 2) + ',' + ((rulerSize / 2) - bBox.height)) :
            (-(bBox.width + 2) + ',' + ((rulerSize / 2) - bBox.height / 2));
        var attr = isHorizontal ? { 'x': x, 'y': y } :
            { 'x': x, 'y': y, 'transform': 'rotate(270)' + 'translate(' + translate + ')' };
        setAttributeSvg(rulerSegment.segment.lastChild, attr);
    };
    Ruler.prototype.getNewSegment = function (run, svg) {
        var segment = this.createNewTicks(run, svg);
        var label = this.createTickLabel(svg, segment);
        return { segment: segment, label: label };
    };
    Ruler.prototype.createNewTicks = function (run, svg) {
        var tick;
        var tickInterval;
        var segmentWidth = this.updateSegmentWidth(this.scale);
        //let g: SVGElement;
        var attr = { 'class': 'e-ruler-segment' };
        var g = createSvgElement('g', attr);
        for (var i = 0; i < this.interval; i++) {
            tickInterval = segmentWidth / this.interval;
            tick = this.createTick(svg, tickInterval, i + 1, run);
            g.appendChild(tick);
        }
        return g;
    };
    Ruler.prototype.getLinePoint = function (svg, tickInterval, length) {
        var segmentWidth = this.updateSegmentWidth(this.scale);
        var rulerSize = this.getRulerSize();
        tickInterval = tickInterval * (length - 1);
        length = ((tickInterval % segmentWidth) === 0) ? rulerSize : rulerSize * 0.3;
        return length;
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Ruler.prototype.createTick = function (svg, tickInterval, length, run) {
        var ruler;
        //let line: SVGElement;
        var linePoint = this.getLinePoint(svg, tickInterval, length);
        var rulerSize = this.getRulerSize();
        //let args: IArrangeTickOptions;
        //let attr: Object;
        var isHorizontal = (this.orientation === 'Horizontal') ? true : false;
        var isRightOrBottom = (this.tickAlignment === 'RightOrBottom') ? true : false;
        var arrangeTick = getFunction(this.arrangeTick);
        // eslint-disable-next-line
        var args = { ruler: ruler, tickLength: linePoint, tickInterval: ((this.segmentWidth / this.interval) * (length - 1)) };
        if (arrangeTick) {
            arrangeTick(args);
        }
        linePoint = args.tickLength;
        var point = tickInterval * (length - 1);
        var x1 = isHorizontal ? point : (isRightOrBottom ? rulerSize : 0);
        var x2 = isHorizontal ? point : (isRightOrBottom ? (rulerSize - linePoint) : (rulerSize - (rulerSize - linePoint)));
        var y1 = isHorizontal ? (isRightOrBottom ? rulerSize : (rulerSize - (rulerSize - linePoint))) : point;
        var y2 = isHorizontal ? (isRightOrBottom ? (rulerSize - linePoint) : 0) : point;
        var attr = { 'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2, 'stroke-width': '1', 'stroke': 'black' };
        var line = createSvgElement('line', attr);
        line.setAttribute('class', 'e-ruler-tick');
        return line;
    };
    Ruler.prototype.createTickLabel = function (svg, segment) {
        var text;
        if (segment) {
            var attr = { 'class': 'e-ruler-tick-label' };
            text = createSvgElement('text', attr);
            segment.appendChild(text);
        }
        return text;
    };
    /**
     * @private
     * @param {number} scale
     */
    /**
     * updateSegmentWidth method\
     *
     * @returns {number}    updateSegmentWidth method .\
     * @param {string} scale - provide the scale value.
     *
     * @private
     */
    Ruler.prototype.updateSegmentWidth = function (scale) {
        if (this.segmentWidth !== 100) {
            return this.segmentWidth;
        }
        var five = 25;
        var multiples = 1;
        var div;
        //let scaleRound: number;
        var fifty = 100;
        var scaleRound = Math.pow(2, Math.round(Math.log(scale) / Math.log(2)));
        div = fifty;
        div = (fifty / scaleRound);
        while (div > 100) {
            multiples /= 10;
            div /= 10;
        }
        while (div < 25) {
            multiples *= 10;
            div *= 10;
        }
        if (div >= five && div % five !== 0) {
            div = Math.round(div / five) * five;
        }
        return div * scale / multiples;
    };
    Ruler.prototype.createMarkerLine = function (rulerSvg, rulerObj, attr) {
        var line;
        if (rulerObj) {
            line = rulerSvg.getElementById(rulerObj.id + '_marker');
            if (line) {
                line.parentNode.removeChild(line);
            }
            line = createSvgElement('line', attr);
        }
        return line;
    };
    /**
     * updateSegmentWidth method\
     *
     * @returns {void}    updateSegmentWidth method .\
     * @param {HTMLElement} rulerObj - Defines the ruler Object
     * @param {PointModel} currentPoint - Defines the current point for ruler Object
     * @param {number} offset - Defines the offset ruler Object
     *
     * @private
     */
    Ruler.prototype.drawRulerMarker = function (rulerObj, currentPoint, offset) {
        var rulerSvg;
        var rulerSize;
        var scale;
        var diff;
        var i;
        var attr;
        var line;
        var isHorizontal = this.orientation === 'Horizontal' ? true : false;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var rulerSvgElements = rulerObj.getElementsByTagName('svg');
        for (i = 0; i < rulerSvgElements.length; i++) {
            if (rulerSvgElements[parseInt(i.toString(), 10)]) {
                rulerSvg = rulerSvgElements[parseInt(i.toString(), 10)];
            }
            break;
        }
        if (rulerSvg) {
            rulerSize = this.getRulerSize();
            attr = {
                'id': rulerObj.id + '_marker', 'x1': 0, 'y1': 0, 'x2': (isHorizontal ? 0 : rulerSize),
                'y2': (isHorizontal ? rulerSize : 0), 'stroke': this.markerColor, 'stroke-width': 1.5,
                'class': 'e-d-ruler-marker'
            };
            line = this.createMarkerLine(rulerSvg, rulerObj, attr);
            scale = this.scale;
            diff = this.offset - this.defStartValue;
            var point = isHorizontal ? currentPoint.x : currentPoint.y;
            var move = (point * scale) + offset + diff;
            line.setAttribute('transform', 'translate(' + (isHorizontal ? ((move + 0.5) + ' 0.5') : ('0.5 ' + (move + 0.5))) + ')');
            rulerSvg.appendChild(line);
        }
    };
    Ruler.prototype.getRulerGeometry = function () {
        return new Size(this.element ? this.element.getBoundingClientRect().width : 0, this.element ? this.element.getBoundingClientRect().height : 0);
    };
    Ruler.prototype.getRulerSize = function () {
        return this.thickness;
    };
    Ruler.prototype.getRulerSVG = function (rulerGeometry) {
        var rulerSpace;
        var rulerSize = this.getRulerSize();
        var svg;
        if (this.element) {
            rulerSpace = document.getElementById(this.element.id + '_ruler_space');
            if (rulerSpace) {
                var attr = {
                    'id': this.element.id + '_Ruler_svg',
                    width: this.orientation === 'Horizontal' ? (rulerGeometry.width + 200) : rulerSize + 'px',
                    height: this.orientation === 'Horizontal' ? rulerSize : (rulerGeometry.height + 200) + 'px',
                    style: 'position:inherit;'
                };
                svg = createSvgElement('svg', attr);
                if (rulerSpace.childNodes.length > 0) {
                    for (var i = rulerSpace.childNodes.length - 1; i >= 0; i--) {
                        rulerSpace.childNodes[parseInt(i.toString(), 10)].parentNode.removeChild(rulerSpace.childNodes[parseInt(i.toString(), 10)]);
                    }
                }
                rulerSpace.appendChild(svg);
            }
        }
        return svg;
    };
    /**
     * Method to bind events for the ruler \
     *
     * @returns {void}    Method to bind events for the ruler .\
     * @private
     */
    Ruler.prototype.wireEvents = function () {
        //wire Events
    };
    /**
     *  Method to unbind events for the ruler \
     *
     * @returns {void}     Method to unbind events for the ruler .\
     * @private
     */
    Ruler.prototype.unWireEvents = function () {
        //unWire Events
    };
    __decorate$9([
        Property(5)
    ], Ruler.prototype, "interval", void 0);
    __decorate$9([
        Property(100)
    ], Ruler.prototype, "segmentWidth", void 0);
    __decorate$9([
        Property('Horizontal')
    ], Ruler.prototype, "orientation", void 0);
    __decorate$9([
        Property('RightOrBottom')
    ], Ruler.prototype, "tickAlignment", void 0);
    __decorate$9([
        Property('red')
    ], Ruler.prototype, "markerColor", void 0);
    __decorate$9([
        Property(25)
    ], Ruler.prototype, "thickness", void 0);
    __decorate$9([
        Property(null)
    ], Ruler.prototype, "arrangeTick", void 0);
    __decorate$9([
        Property(400)
    ], Ruler.prototype, "length", void 0);
    return Ruler;
}(Component));

/**
 * defines the helper methods for the ruler
 */
/**
 * renderOverlapElement method \
 *
 * @returns {void} renderOverlapElement method .\
 * @param { Diagram} diagram - provide the content  value.
 * @private
 */
function renderOverlapElement(diagram) {
    var rulerSize = getRulerSize(diagram);
    var attributes = {
        'id': diagram.element.id + '_overlapRuler',
        style: 'height:' + rulerSize.height + 'px;width:' + rulerSize.width + 'px;position:absolute;left:0;top:0',
        class: 'e-ruler-overlap'
    };
    var overlap = createHtmlElement('div', attributes);
    diagram.element.insertBefore(overlap, diagram.element.firstChild);
}
/**
 * renderRuler method \
 *
 * @returns {void} renderRuler method .\
 * @param { Diagram} diagram - provide the content  value.
 * @param { boolean} isHorizontal - provide the content  value.
 * @private
 */
function renderRuler(diagram, isHorizontal) {
    var div = document.getElementById(diagram.element.id + (isHorizontal ? '_hRuler' : '_vRuler'));
    var rulerSize = getRulerSize(diagram);
    var rulerGeometry = getRulerGeometry(diagram);
    var margin = isHorizontal ? ('margin-left:' + rulerSize.width + 'px;') : ('margin-top:' + rulerSize.height + 'px;');
    if (!div) {
        var style = 'height:' + (isHorizontal ? rulerSize.height : (rulerGeometry.height + 100)) + 'px;overflow:hidden;width:' +
            (isHorizontal ? (rulerGeometry.width + 100) : rulerSize.width) + 'px;position:absolute;font-size:11px;' + margin;
        var attributes = {
            'id': diagram.element.id + (isHorizontal ? '_hRuler' : '_vRuler'),
            style: style
        };
        div = createHtmlElement('div', attributes);
    }
    diagram.element.insertBefore(div, diagram.element.firstChild);
    var diagramRuler = isHorizontal ? diagram.rulerSettings.horizontalRuler : diagram.rulerSettings.verticalRuler;
    var ruler = new Ruler(diagramRuler);
    ruler.orientation = isHorizontal ? 'Horizontal' : 'Vertical';
    ruler.length = (isHorizontal ? rulerGeometry.width : rulerGeometry.height) + diagramRuler.segmentWidth;
    ruler.appendTo('#' + diagram.element.id + (isHorizontal ? '_hRuler' : '_vRuler'));
    // eslint-disable-next-line
    isHorizontal ? diagram.hRuler = ruler : diagram.vRuler = ruler;
    var rulerObj = document.getElementById(diagram.element.id + (isHorizontal ? '_hRuler' : '_vRuler'));
    // eslint-disable-next-line
    isHorizontal ? diagram.hRuler.element = rulerObj : diagram.vRuler.element = rulerObj;
}
/**
 * updateRuler method \
 *
 * @returns {void} updateRuler method .\
 * @param { Diagram} diagram - provide the diagram  value.
 * @private
 */
function updateRuler(diagram) {
    var hOffset = -diagram.scroller.horizontalOffset;
    var vOffset = -diagram.scroller.verticalOffset;
    if (diagram && diagram.rulerSettings.showRulers) {
        diagram.hRuler.length = 0;
        diagram.vRuler.length = 0;
        if (hOffset !== undefined && diagram.hRuler.element) {
            updateRulerDimension(diagram, diagram.hRuler, hOffset, true);
        }
        if (vOffset !== undefined && diagram.vRuler.element) {
            updateRulerDimension(diagram, diagram.vRuler, vOffset, false);
        }
    }
    else {
        removeRulerElements(diagram);
    }
}
/**
 * removeRulerElements method \
 *
 * @returns {void} removeRulerElements method .\
 * @param { Diagram} diagram - provide the diagram  value.
 * @private
 */
function removeRulerElements(diagram) {
    removeElement(diagram.element.id + '_hRuler');
    removeElement(diagram.element.id + '_vRuler');
    removeElement(diagram.element.id + '_overlapRuler');
}
/**
 * getRulerSize method \
 *
 * @returns {void} getRulerSize method .\
 * @param { Diagram} diagram - provide the diagram  value.
 * @private
 */
function getRulerSize(diagram) {
    var top = 0;
    var left = 0;
    if (diagram.rulerSettings.showRulers) {
        top = diagram.rulerSettings.horizontalRuler.thickness;
        left = diagram.rulerSettings.verticalRuler.thickness;
    }
    return new Size(left, top);
}
/**
 * getRulerGeometry method \
 *
 * @returns {void} getRulerGeometry method .\
 * @param { Diagram} diagram - provide the diagram  value.
 * @private
 */
function getRulerGeometry(diagram) {
    var rulerSize = getRulerSize(diagram);
    var height = diagram.scroller.viewPortHeight;
    var width = diagram.scroller.viewPortWidth;
    if (width < diagram.element.clientWidth - rulerSize.width) {
        width = diagram.element.clientWidth - rulerSize.width;
    }
    if (height < diagram.element.clientHeight - rulerSize.height) {
        height = diagram.element.clientHeight - rulerSize.height;
    }
    if (diagram.hRuler && diagram.hRuler.length) {
        width = diagram.hRuler.length;
    }
    if (diagram.vRuler && diagram.vRuler.length) {
        height = diagram.vRuler.length;
    }
    return new Size(width, height);
}
/**
 * removeRulerMarkers method \
 *
 * @returns {void} removeRulerMarkers method .\
 * @private
 */
function removeRulerMarkers() {
    var markers = document.getElementsByClassName('e-d-ruler-marker');
    var marker;
    var i;
    if (markers && markers.length > 0) {
        for (i = markers.length - 1; i >= 0; i--) {
            marker = markers[parseInt(i.toString(), 10)];
            if (marker) {
                marker.parentNode.removeChild(marker);
            }
        }
    }
}
/**
 * drawRulerMarkers method \
 *
 * @returns {void} drawRulerMarkers method .\
 * @param { Diagram} diagram - provide the content  value.
 * @param { PointModel} currentPoint - provide the content  value.
 * @private
 */
function drawRulerMarkers(diagram, currentPoint) {
    if (diagram.rulerSettings.showRulers) {
        diagram.hRuler.drawRulerMarker(diagram.hRuler.element, currentPoint, diagram.scroller.horizontalOffset);
        diagram.vRuler.drawRulerMarker(diagram.vRuler.element, currentPoint, diagram.scroller.verticalOffset);
    }
}
/**
 * updateRulerDimension method \
 *
 * @returns {void} updateRulerDimension method .\
 * @param { Diagram} diagram - provide the content  value.
 * @param { Ruler} ruler - provide the content  value.
 * @param { number} offset - provide the content  value.
 * @param { boolean} isHorizontal - provide the content  value.
 * @private
 */
function updateRulerDimension(diagram, ruler, offset, isHorizontal) {
    var rulerSize = getRulerSize(diagram);
    var rulerGeometry = getRulerGeometry(diagram);
    var diagramRuler = isHorizontal ? diagram.rulerSettings.horizontalRuler : diagram.rulerSettings.verticalRuler;
    updateRulerDiv(diagram, rulerGeometry, isHorizontal);
    updateRulerSpace(diagram, rulerGeometry, isHorizontal);
    ruler.offset = offset;
    ruler.scale = diagram.scroller.currentZoom;
    ruler.length = (isHorizontal ? rulerGeometry.width : rulerGeometry.height) + 100;
    ruler.arrangeTick = getFunction(diagramRuler.arrangeTick);
    ruler.dataBind();
    var rulerObj = isHorizontal ? diagram.hRuler.element : diagram.vRuler.element;
    if (isHorizontal) {
        rulerObj.style.marginLeft = (rulerSize.width - ruler.hRulerOffset) + 'px';
    }
    else {
        rulerObj.style.marginTop = (rulerSize.height - ruler.vRulerOffset) + 'px';
    }
}
/**
 * updateRulerSpace method \
 *
 * @returns {void} updateRulerSpace method .\
 * @param { Diagram} diagram - provide the content  value.
 * @param { Size} rulerGeometry - provide the content  value.
 * @param { boolean} isHorizontal - provide the content  value.
 * @private
 */
function updateRulerSpace(diagram, rulerGeometry, isHorizontal) {
    var div = document.getElementById(diagram.element.id + (isHorizontal ? '_hRuler_ruler_space' : '_vRuler_ruler_space'));
    var ruler = isHorizontal ? diagram.hRuler : diagram.vRuler;
    if (div && diagram && rulerGeometry) {
        div.style.width = (isHorizontal ? (rulerGeometry.width + (ruler.segmentWidth * 2)) : ruler.thickness) + 'px';
        div.style.height = (isHorizontal ? ruler.thickness : (rulerGeometry.height + (ruler.segmentWidth * 2))) + 'px';
    }
}
/**
 * updateRulerDiv method \
 *
 * @returns {void} updateRulerDiv method .\
 * @param { Diagram} diagram - provide the content  value.
 * @param { Size} rulerGeometry - provide the content  value.
 * @param { boolean} isHorizontal - provide the content  value.
 * @private
 */
function updateRulerDiv(diagram, rulerGeometry, isHorizontal) {
    var div = document.getElementById(diagram.element.id + (isHorizontal ? '_hRuler' : '_vRuler'));
    var ruler = isHorizontal ? diagram.hRuler : diagram.vRuler;
    if (div && diagram && rulerGeometry) {
        div.style.width = (isHorizontal ? (rulerGeometry.width + ruler.segmentWidth) : ruler.thickness) + 'px';
        div.style.height = (isHorizontal ? ruler.thickness : (rulerGeometry.height + ruler.segmentWidth)) + 'px';
        // eslint-disable-next-line
        div = document.getElementById(diagram.element.id + '_overlapRuler');
        if (div) {
            // eslint-disable-next-line
            isHorizontal ? (div.style.height = ruler.thickness + 'px') : (div.style.width = ruler.thickness + 'px');
        }
    }
}

var __extends$j = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * A collection of frequently used commands that will be added around the selector
 * ```html
 * <div id='diagram'></div>
 * ```
 * ```typescript
 * let nodes: NodeModel[] = [{
 *           id: 'node1', width: 100, height: 100, offsetX: 100, offsetY: 100,
 *           annotations: [{ content: 'Default Shape' }]
 *       },
 *       {
 *           id: 'node2', width: 100, height: 100, offsetX: 300, offsetY: 100,
 *           shape: {
 *               type: 'Basic', shape: 'Ellipse'
 *           },
 *           annotations: [{ content: 'Path Element' }]
 *       }
 *       ];
 *       let connectors: ConnectorModel[] = [{
 *           id: 'connector1',
 *           type: 'Straight',
 *           sourcePoint: { x: 100, y: 300 },
 *           targetPoint: { x: 200, y: 400 },
 *       }];
 * let handle: UserHandleModel[] = [
 * { name: 'handle', margin: { top: 0, bottom: 0, left: 0, right: 0 }, offset: 0,
 * pathData: 'M 376.892,225.284L 371.279,211.95L 376.892,198.617L 350.225,211.95L 376.892,225.284 Z',
 * side: 'Top', horizontalAlignment: 'Center', verticalAlignment: 'Center',
 * pathColor: 'yellow' }];
 * let diagram: Diagram = new Diagram({
 * ...
 *     connectors: connectors, nodes: nodes,
 *     selectedItems: { constraints: SelectorConstraints.All, userHandles: handle },
 * ...
 * });
 * diagram.appendTo('#diagram');
 * ```
 * @default {}
 */
var UserHandle = /** @class */ (function (_super) {
    __extends$j(UserHandle, _super);
    function UserHandle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * Returns the name of class UserHandle
     *
     * @returns {string}  Returns the name of class UserHandle
     * @private
     */
    UserHandle.prototype.getClassName = function () {
        return 'UserHandle';
    };
    __decorate$a([
        Property('')
    ], UserHandle.prototype, "name", void 0);
    __decorate$a([
        Property('')
    ], UserHandle.prototype, "pathData", void 0);
    __decorate$a([
        Property('')
    ], UserHandle.prototype, "content", void 0);
    __decorate$a([
        Property('')
    ], UserHandle.prototype, "source", void 0);
    __decorate$a([
        Property('#000000')
    ], UserHandle.prototype, "backgroundColor", void 0);
    __decorate$a([
        Property('Top')
    ], UserHandle.prototype, "side", void 0);
    __decorate$a([
        Property('')
    ], UserHandle.prototype, "borderColor", void 0);
    __decorate$a([
        Property(0.5)
    ], UserHandle.prototype, "borderWidth", void 0);
    __decorate$a([
        Property(25)
    ], UserHandle.prototype, "size", void 0);
    __decorate$a([
        Property('white')
    ], UserHandle.prototype, "pathColor", void 0);
    __decorate$a([
        Property(10)
    ], UserHandle.prototype, "displacement", void 0);
    __decorate$a([
        Property(true)
    ], UserHandle.prototype, "visible", void 0);
    __decorate$a([
        Property(0)
    ], UserHandle.prototype, "offset", void 0);
    __decorate$a([
        Complex({}, Margin)
    ], UserHandle.prototype, "margin", void 0);
    __decorate$a([
        Property('Center')
    ], UserHandle.prototype, "horizontalAlignment", void 0);
    __decorate$a([
        Property('Center')
    ], UserHandle.prototype, "verticalAlignment", void 0);
    __decorate$a([
        Property(false)
    ], UserHandle.prototype, "disableNodes", void 0);
    __decorate$a([
        Property(false)
    ], UserHandle.prototype, "disableConnectors", void 0);
    __decorate$a([
        Complex({}, DiagramTooltip)
    ], UserHandle.prototype, "tooltip", void 0);
    __decorate$a([
        Property('')
    ], UserHandle.prototype, "template", void 0);
    return UserHandle;
}(ChildProperty));

/**
 * UMLActivityShapeDictionary defines the shape of the built-in uml activity shapes \
 *
 * @returns { string } UMLActivityShapeDictionary defines the shape of the built-in uml activity shapes .\
 * @param {string} shape - provide the shape value.
 *
 * @private
 */
function getUMLActivityShape(shape) {
    return umlActivityShapes[shape.toString()];
}
/* eslint-disable */
var umlActivityShapes = {
    // Action,
    'Action': 'M 90 82.895 C 90 86.819 86.776 90 82.8 90 H 7.2 C 3.224 90 0 86.819 0 82.895' +
        ' V 7.105 C 0 3.181 3.224 0 7.2 0 h 75.6 C 86.776 0 90 3.181 90 7.105 V 82.895 Z',
    // Decision,
    'Decision': 'M10,19.707L0.293,10L10,0.293L19.707,10L10,19.707z',
    // MergeNode,
    'MergeNode': 'M10,19.707L0.293,10L10,0.293L19.707,10L10,19.707z',
    // InitialNode,
    'InitialNode': 'M10,19.5c-5.238,0-9.5-4.262-9.5-9.5S4.762,0.5,10,0.5s9.5,4.262,9.5,9.5S15.238,19.5,10,19.5z',
    // ForkNode,
    'ForkNode': 'm0.75,0.75l636.00002,0l0,290l-636.00002,0l0,-290z',
    // JoinNode,
    'JoinNode': 'm0.75,0.75l636.00002,0l0,290l-636.00002,0l0,-290z',
    // TimeEvent,
    'TimeEvent': 'M50.001,0.00286865 L25.001,25.0029 L0.000976562,0.00286865 L50.001,0.00286865 z' +
        ' M0.000976562,50.0029 L25.001,25.0029 L50.001,50.0029 L0.000976562,50.0029 z',
    // AcceptingEvent,
    'AcceptingEvent': 'M17.8336 32.164 L29.64 24 L17.32 16 L48.1664 16 L48.5 32 Z',
    // SendSignal,
    'SendSignal': 'M48.164 31.8336 L56 23.832 L47.836 16 L16.168 16 L16.1668 31.8336 Z',
    // ReceiveSignal,
    'ReceiveSignal': 'M48.1664 31.8336 L39.836 24 L47.836 16 L16.168 16 L16.168 31.836 Z',
    // StructuredNode,
    'StructuredNode': 'M0,0 L50,0 L50,50 L0,50 z',
    // Note,
    'Note': 'M20 12 L4 12 L4 22 L22 22 L22 14 L20 14 L20 12 L22 14 Z'
};
/* eslint-enable */

var __extends$k = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Defines the combination of keys and modifier keys
 */
var KeyGesture = /** @class */ (function (_super) {
    __extends$k(KeyGesture, _super);
    function KeyGesture() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$b([
        Property()
    ], KeyGesture.prototype, "key", void 0);
    __decorate$b([
        Property()
    ], KeyGesture.prototype, "keyModifiers", void 0);
    return KeyGesture;
}(ChildProperty));
/**
 * Defines a command and a key gesture to define when the command should be executed
 */
var Command = /** @class */ (function (_super) {
    __extends$k(Command, _super);
    function Command() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * Returns the name of class Command
     *
     * @returns {string}  Returns the name of class Command
     * @private
     */
    Command.prototype.getClassName = function () {
        return 'Command';
    };
    __decorate$b([
        Property('')
    ], Command.prototype, "name", void 0);
    __decorate$b([
        Property()
    ], Command.prototype, "canExecute", void 0);
    __decorate$b([
        Property()
    ], Command.prototype, "execute", void 0);
    __decorate$b([
        Complex({}, KeyGesture)
    ], Command.prototype, "gesture", void 0);
    __decorate$b([
        Property('')
    ], Command.prototype, "parameter", void 0);
    return Command;
}(ChildProperty));
/**
 * Defines the collection of commands and the corresponding key gestures
 *
 */
var CommandManager = /** @class */ (function (_super) {
    __extends$k(CommandManager, _super);
    function CommandManager() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$b([
        Collection([], Command)
    ], CommandManager.prototype, "commands", void 0);
    return CommandManager;
}(ChildProperty));
/**
 * Defines the behavior of the context menu items
 */
var ContextMenuSettings = /** @class */ (function (_super) {
    __extends$k(ContextMenuSettings, _super);
    function ContextMenuSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$b([
        Property()
    ], ContextMenuSettings.prototype, "show", void 0);
    __decorate$b([
        Property()
    ], ContextMenuSettings.prototype, "showCustomMenuOnly", void 0);
    __decorate$b([
        Property()
    ], ContextMenuSettings.prototype, "items", void 0);
    return ContextMenuSettings;
}(ChildProperty));

/**
 * SVG Renderer
 */
/** @private */
var SvgRenderer = /** @class */ (function () {
    function SvgRenderer() {
    }
    /**
     * Draw the shawdow  for the rectangle shape in diagram \
     *
     *  @returns {void}  Draw the shawdow  for the rectangle shape in diagram .\
     *
     *  @param { SVGElement} options - Provide the base attributes .
     *  @param { RectAttributes} canvas - Provide the canvas values .
     *  @param { string} collection - Provide the collection value.
     *  @param { boolean} parentSvg - Provide the parent SVG values .
     *  @private
     */
    SvgRenderer.prototype.renderShadow = function (options, canvas, collection, parentSvg) {
        if (collection === void 0) { collection = null; }
        var pointModel = { x: 0, y: 0 };
        var point = Point.transform(pointModel, options.shadow.angle, options.shadow.distance);
        //const tX: number = options.x + point.x; const tY: number = options.y + point.y;
        //let pivotX: number = tX + options.width * options.pivotX;
        //let pivotY: number = tY + options.height * options.pivotY;
        var type;
        var shadowElement;
        if (parentSvg) {
            shadowElement = parentSvg.getElementById(canvas.id + '_shadow');
        }
        if (!shadowElement) {
            type = collection ? 'path' : 'rect';
            shadowElement = document.createElementNS('http://www.w3.org/2000/svg', type);
            canvas.appendChild(shadowElement);
        }
        var attr = {
            'id': canvas.id + '_shadow', 'fill': options.shadow.color, 'stroke': options.shadow.color,
            'opacity': options.shadow.opacity.toString(),
            'transform': 'rotate(' + options.angle + ',' + (options.x + options.width * options.pivotX) + ','
                + (options.y + options.height * options.pivotY) + ')' +
                'translate(' + (options.x + point.x) + ',' + (options.y + point.y) + ')'
        };
        if (parentSvg) {
            var svgContainer = parentSvg.getElementById(canvas.id);
            if (svgContainer) {
                svgContainer.insertBefore(shadowElement, svgContainer.firstChild);
            }
        }
        setAttributeSvg(shadowElement, attr);
        if (!collection) {
            setAttributeSvg(shadowElement, { 'width': options.width, 'height': options.height });
        }
        else if (collection) {
            this.renderPath(shadowElement, options, collection);
        }
    };
    /**
     * Return the dashed array values \
     *
     *  @returns {number[]}  Return the dashed array values .\
     *  @param { SVGElement} dashArray - Return the dashed array values .
     *  @private
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    SvgRenderer.prototype.parseDashArray = function (dashArray) {
        var dashes = [];
        return dashes;
    };
    /**
     * Draw the Rectangle for the diagram \
     *
     *  @returns {void}  Draw the Rectangle for the diagram .\
     *
     *  @param { SVGElement} svg - Provide the SVG .
     *  @param { RectAttributes} options - Provide the Rect attributes .
     *  @param { string} diagramId - Provide the diagram id .
     *  @param { boolean} onlyRect - Provide the boolean attribute for the shawdow rendering  .
     *  @param { boolean} isSelector - Provide the selector possobilities .
     *  @param { SVGSVGElement} parentSvg - Provide the parent svg element .
     *  @param { Object} ariaLabel - Provide the Arial label attributes .
     *  @param { boolean} isCircularHandle - Provide the boolean attribute for the circular handle .
     *  @param { number} enableSelector - Provide the selector possobilities .
     *  @private
     */
    SvgRenderer.prototype.drawRectangle = function (svg, options, diagramId, onlyRect, isSelector, parentSvg, ariaLabel, isCircularHandle, enableSelector) {
        if (options.shadow && !onlyRect) {
            this.renderShadow(options, svg, undefined, parentSvg);
        }
        var id;
        if (options.id === svg.id) {
            id = options.id + '_container';
        }
        else {
            id = options.id;
        }
        var rect;
        if (parentSvg) {
            rect = parentSvg.getElementById(id);
        }
        if (!rect || isSelector) {
            rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            svg.appendChild(rect);
        }
        var shadowElement;
        if (parentSvg && !options.shadow) {
            shadowElement = parentSvg.getElementById(options.id + '_groupElement_shadow');
            if (shadowElement) {
                shadowElement.parentNode.removeChild(shadowElement);
            }
        }
        if (parentSvg) {
            shadowElement = parentSvg.getElementById(options.id + '_groupElement_shadow');
            if (shadowElement) {
                shadowElement.style.visibility = options.visible ? 'visible' : 'hidden';
            }
        }
        var attr;
        // EJ2-65895 - Added below code to calculate the transform to render the circular handle
        if (isCircularHandle) {
            attr = {
                'id': id, 'x': options.x.toString(), 'y': options.y.toString(), 'width': options.width.toString(),
                'height': options.height.toString(), 'visibility': options.visible ? 'visible' : 'hidden',
                'transform': 'rotate(' + options.angle + ','
                    + (options.x + options.width / 2) + ',' + (options.y + options.height / 2) + ')',
                'rx': options.cornerRadius || 0, 'ry': options.cornerRadius || 0, 'opacity': options.opacity
            };
        }
        else {
            attr = {
                'id': id, 'x': options.x.toString(), 'y': options.y.toString(), 'width': options.width.toString(),
                'height': options.height.toString(), 'visibility': options.visible ? 'visible' : 'hidden',
                'transform': 'rotate(' + options.angle + ','
                    + (options.x + options.width * options.pivotX) + ',' + (options.y + options.height * options.pivotY) + ')',
                'rx': options.cornerRadius || 0, 'ry': options.cornerRadius || 0, 'opacity': options.opacity
            };
        }
        if (ariaLabel) {
            // BLAZ-24062: Adding 'aria-label' without role attribute it causes violation in accessibility test
            attr['role'] = 'img';
            attr['aria-label'] = ariaLabel;
        }
        var classval = options.class || '';
        if (!enableSelector) {
            if (classval.includes('e-diagram-resize-handle') || classval.includes('e-diagram-endpoint-handle') || classval.includes('e-diagram-bezier-control-handle')) {
                classval += ' e-disabled';
            }
        }
        if (options.class) {
            attr['class'] = classval;
        }
        var poiterEvents = 'pointer-events';
        if (!ariaLabel) {
            attr["" + poiterEvents] = 'none';
        }
        setAttributeSvg(rect, attr);
        this.setSvgStyle(rect, options, diagramId);
    };
    /**
     * Update the diagram selection region \
     *
     *  @returns {void}  Update the diagram selection region .\
     *
     *  @param { SVGElement} gElement - Provide the element type.
     *  @param { RectAttributes} options - Provide the Rect attributes .
     *  @private
     */
    SvgRenderer.prototype.updateSelectionRegion = function (gElement, options) {
        var rect;
        rect = gElement.parentNode.getElementById(options.id);
        var attr = {
            'id': options.id, 'x': options.x.toString(), 'y': options.y.toString(), 'width': options.width.toString(),
            'height': options.height.toString(), 'transform': 'rotate(' + options.angle + ','
                + (options.x + options.width * options.pivotX) + ',' + (options.y + options.height * options.pivotY) + ')',
            class: 'e-diagram-selected-region'
        };
        if (!rect) {
            rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            gElement.appendChild(rect);
        }
        this.setSvgStyle(rect, options);
        setAttributeSvg(rect, attr);
    };
    /**
     * Create the g element for the diagram \
     *
     *  @returns {SVGGElement}   Create the g element for the diagram .\
     *
     *  @param { SVGElement} elementType - Provide the element type.
     *  @param { Object} attribute - Provide the attributes for the g element.
     *  @private
     */
    SvgRenderer.prototype.createGElement = function (elementType, attribute) {
        var gElement = createSvgElement(elementType, attribute);
        return gElement;
    };
    /**
     * Draw the line for the diagram\
     *
     *  @returns {void}  Draw the line for the diagram .\
     *
     *  @param { SVGElement} gElement - Provide the g element .
     *  @param { LineAttributes} options - Provide the line element attributes .
     *  @private
     */
    SvgRenderer.prototype.drawLine = function (gElement, options) {
        var line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        this.setSvgStyle(line, options);
        var pivotX = options.x + options.width * options.pivotX;
        var pivotY = options.y + options.height * options.pivotY;
        //const kk: string = '';
        var attr = {
            'id': options.id,
            'x1': options.startPoint.x + options.x,
            'y1': options.startPoint.y + options.y,
            'x2': options.endPoint.x + options.x,
            'y2': options.endPoint.y + options.y,
            'stroke': options.stroke,
            'stroke-width': options.strokeWidth.toString(), 'opacity': options.opacity.toString(),
            'transform': 'rotate(' + options.angle + ' ' + pivotX + ' ' + pivotY + ')',
            'visibility': options.visible ? 'visible' : 'hidden'
        };
        if (options.class) {
            attr['class'] = options.class;
        }
        setAttributeSvg(line, attr);
        gElement.appendChild(line);
    };
    /**
     * Draw the circle for the diagram\
     *
     *  @returns {void}  Draw the circle for the diagram .\
     *
     *  @param { SVGElement} gElement - Provide the g element .
     *  @param { CircleAttributes} options - Provide the circle element attributes .
     *  @param {string} enableSelector - Provide the selector constraints string .
     *  @param {Object} ariaLabel - Provide arial label value .
     *  @private
     */
    SvgRenderer.prototype.drawCircle = function (gElement, options, enableSelector, ariaLabel) {
        var circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        this.setSvgStyle(circle, options);
        var classval = options.class || '';
        if (!enableSelector) {
            classval += ' e-disabled';
        }
        var attr = {
            'id': options.id,
            'cx': options.centerX,
            'cy': options.centerY,
            'r': options.radius,
            'visibility': options.visible ? 'visible' : 'hidden',
            'class': classval
        };
        if (ariaLabel) {
            // BLAZ-24062: Adding 'aria-label' without role attribute it causes violation in accessibility test
            attr['role'] = 'img';
            attr['aria-label'] = ariaLabel;
        }
        circle.style.display = options.visible ? 'block' : 'none';
        setAttributeSvg(circle, attr);
        gElement.appendChild(circle);
    };
    /**
     * Draw the path element for the diagram\
     *
     *  @returns {void}  Draw the path element for the diagram .\
     *
     *  @param { SVGElement} svg - Provide the SVG element .
     *  @param { PathAttributes} options - Provide the path element attributes .
     *  @param {string} diagramId - Provide the diagram id .
     *  @param {boolean} isSelector - Provide selector boolean value .
     *  @param {SVGSVGElement} parentSvg - Provide the parent SVG element .
     *  @param {Object} ariaLabel - Provide arial label value .
     *  @param {number} scale - Provide the scale value .
     *  @private
     */
    SvgRenderer.prototype.drawPath = function (svg, options, diagramId, isSelector, parentSvg, ariaLabel, scale) {
        //const id: string = svg.id + '_shape' + x.toString();
        var collection = [];
        collection = processPathData(options.data);
        collection = pathSegmentCollection(collection);
        if (options.shadow) {
            this.renderShadow(options, svg, collection, parentSvg);
        }
        var shadowElement;
        if (parentSvg && !options.shadow) {
            shadowElement = parentSvg.getElementById(options.id + '_groupElement_shadow');
            if (shadowElement) {
                shadowElement.parentNode.removeChild(shadowElement);
            }
        }
        if (parentSvg) {
            shadowElement = parentSvg.getElementById(options.id + '_groupElement_shadow');
            if (shadowElement) {
                shadowElement.style.visibility = options.visible ? 'visible' : 'hidden';
            }
        }
        var path;
        if (parentSvg) {
            path = parentSvg.getElementById(options.id);
        }
        if (!path || isSelector) {
            path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            // Check if the parent of the SVG element has the ID 'diagram_nativeLayer'
            if (svg.parentElement && svg.parentElement.id === 'diagram_nativeLayer') {
                // Create a new 'g' element with the ID based on path.id + '_groupElement'
                var groupElement = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                groupElement.id = options.id + "_groupElement";
                // Append the 'g' element as a child of the SVG element
                svg.appendChild(groupElement);
                // Append the path as a child of the newly created 'g' element
                groupElement.appendChild(path);
            }
            else {
                // If the parent is not 'diagram_nativeLayer', append the path directly to the SVG
                svg.appendChild(path);
            }
        }
        this.renderPath(path, options, collection);
        var attr = {};
        if (scale) {
            attr = {
                'id': options.id, 'transform': 'rotate(' + options.angle + ',' + (options.x + options.width * options.pivotX) + ','
                    + (options.y + options.height * options.pivotY) + ')' + 'translate(' + (options.x) + ',' + (options.y) + '),scale(' + scale + ')',
                'visibility': options.visible ? 'visible' : 'hidden', 'opacity': options.opacity
            };
        }
        else {
            attr = {
                'id': options.id, 'transform': 'rotate(' + options.angle + ',' + (options.x + options.width * options.pivotX) + ','
                    + (options.y + options.height * options.pivotY) + ')' + 'translate(' + (options.x) + ',' + (options.y) + ')',
                'visibility': options.visible ? 'visible' : 'hidden', 'opacity': options.opacity
            };
        }
        if (ariaLabel) {
            // BLAZ-24062: Adding 'aria-label' without role attribute it causes violation in accessibility test
            attr['role'] = 'img';
            attr['aria-label'] = ariaLabel;
        }
        if (options.class) {
            attr['class'] = options.class;
        }
        setAttributeSvg(path, attr);
        this.setSvgStyle(path, options, diagramId);
    };
    /**
     * Draw the path element for the diagram\
     *
     *  @returns {void}  Draw the path element for the diagram .\
     *
     *  @param { SVGElement} svg - Provide the SVG element .
     *  @param {PathAttributes} options - Provide the path element attributes .
     *  @param {Object[]} collection - Provide the parent SVG element .
     *  @private
     */
    SvgRenderer.prototype.renderPath = function (svg, options, collection) {
        var x1;
        var y1;
        var x2;
        var y2;
        var x;
        var y;
        var length;
        var i;
        var segments = collection;
        var d = '';
        for (x = 0, y = 0, i = 0, length = segments.length; i < length; ++i) {
            var obj = segments[parseInt(i.toString(), 10)];
            var segment = obj;
            var char = segment.command;
            if ('x1' in segment) {
                x1 = segment.x1;
            }
            if ('x2' in segment) {
                x2 = segment.x2;
            }
            if ('y1' in segment) {
                y1 = segment.y1;
            }
            if ('y2' in segment) {
                y2 = segment.y2;
            }
            if ('x' in segment) {
                x = segment.x;
            }
            if ('y' in segment) {
                y = segment.y;
            }
            switch (char) {
                case 'M':
                    d = d + 'M' + x.toString() + ',' + y.toString() + ' ';
                    break;
                case 'L':
                    d = d + 'L' + x.toString() + ',' + y.toString() + ' ';
                    break;
                case 'C':
                    d = d + 'C' + x1.toString() + ',' + y1.toString() + ',' + x2.toString() + ',' + y2.toString() + ',';
                    d += x.toString() + ',' + y.toString() + ' ';
                    break;
                case 'Q':
                    d = d + 'Q' + x1.toString() + ',' + y1.toString() + ',' + x.toString() + ',' + y.toString() + ' ';
                    break;
                case 'A':
                    d = d + 'A' + segment.r1.toString() + ',' + segment.r2.toString() + ',' + segment.angle.toString() + ',';
                    d += segment.largeArc.toString() + ',' + segment.sweep + ',' + x.toString() + ',' + y.toString() + ' ';
                    break;
                case 'Z':
                case 'z':
                    d = d + 'Z' + ' ';
                    break;
            }
        }
        svg.setAttribute('d', d);
    };
    SvgRenderer.prototype.setSvgFontStyle = function (text, options) {
        text.style.fontStyle = options.italic ? 'italic' : 'normal';
        text.style.fontWeight = options.bold ? 'bold' : 'normal';
        text.style.fontSize = options.fontSize.toString() + 'px';
        text.style.fontFamily = options.fontFamily;
    };
    /**
     * Draw the text element for the diagram\
     *
     *  @returns {void}  Draw the text element for the diagram .\
     *
     *  @param { SVGElement} canvas - Provide the SVG element .
     *  @param {TextAttributes} options - Provide the text element attributes .
     *  @param {SVGSVGElement} parentSvg - Provide the parent SVG element .
     *  @param {Object} ariaLabel - Provide the label properties .
     *  @param {string} diagramId - Provide the diagram id .
     *  @param {number} scaleValue - Provide the scale value .
     *  @param {any} renderer - Provide the renderer value .
     *  @private
     */
    SvgRenderer.prototype.drawText = function (canvas, options, parentSvg, ariaLabel, diagramId, scaleValue, renderer) {
        if (options.content !== undefined) {
            var parentNode = renderer.groupElement;
            var textNode = void 0;
            var childNodes = void 0;
            var wrapBounds = void 0;
            var position = void 0;
            var child = void 0;
            var tspanElement = void 0;
            var offsetX = 0;
            var offsetY = 0;
            var i = 0;
            var text = void 0;
            var nodeContent = void 0;
            if (parentSvg) {
                text = parentSvg.getElementById(options.id + '_text');
            }
            if (text) {
                if (options.doWrap) {
                    while (text.firstChild) {
                        text.removeChild(text.firstChild);
                    }
                }
            }
            else {
                options.doWrap = true;
                text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                if (options.whiteSpace === 'pre-wrap') {
                    text.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
                }
                if (parentNode) {
                    nodeContent = document.getElementById(parentNode.id + '_content_groupElement');
                }
                if (nodeContent && parentNode && parentNode.children && parentNode.children[0] instanceof DiagramNativeElement) {
                    var textTag = this.createGElement('g', { id: ariaLabel + '_groupElement' });
                    nodeContent.appendChild(textTag);
                    textTag.appendChild(text);
                }
                else {
                    canvas.appendChild(text);
                }
            }
            var pivotX = options.x + options.width * options.pivotX;
            var pivotY = options.y + options.height * options.pivotY;
            var childNodesHeight = 0;
            if (options.doWrap || options.textOverflow !== 'Wrap') {
                //(EJ2-70658)- Node annotation disappear, while giving same id for annotation in two different diagrams
                //Added the below code for removing the extra span element that added when we double click the text annotation node
                while (text.firstChild) {
                    text.removeChild(text.firstChild);
                }
                this.setSvgStyle(text, options, diagramId);
                this.setSvgFontStyle(text, options);
                textNode = document.createTextNode(options.content);
                childNodes = options.childNodes;
                wrapBounds = options.wrapBounds;
                position = this.svgLabelAlign(options, wrapBounds, childNodes);
                if (wrapBounds.width > options.width && options.textOverflow !== 'Wrap' && options.textWrapping === 'NoWrap') {
                    childNodes[0].text = overFlow(options.content, options);
                }
                for (i = 0; i < childNodes.length; i++) {
                    tspanElement = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                    textNode = document.createTextNode(childNodes[parseInt(i.toString(), 10)].text);
                    child = childNodes[parseInt(i.toString(), 10)];
                    child.x = setChildPosition(child, childNodes, i, options);
                    if (options.textAlign === 'justify' || options.textAlign === 'left') {
                        offsetX = 0;
                    }
                    else {
                        offsetX = position.x + child.x - wrapBounds.x;
                    }
                    offsetY = position.y + child.dy * (i) + ((options.fontSize) * 0.8);
                    if ((options.textOverflow === 'Clip' || options.textOverflow === 'Ellipsis') &&
                        (options.textWrapping === 'WrapWithOverflow' || options.textWrapping === 'Wrap') && parentNode) {
                        var size = (options.isHorizontalLane) ? parentNode.actualSize.width : parentNode.actualSize.height;
                        if (offsetY < size) {
                            if (options.textOverflow === 'Ellipsis' && childNodes[i + 1]) {
                                var temp = childNodes[i + 1];
                                var y = position.y + temp.dy * (i + 1) + ((options.fontSize) * 0.8);
                                if (y > size) {
                                    child.text = child.text.slice(0, child.text.length - 3);
                                    child.text = child.text.concat('...');
                                    textNode.data = child.text;
                                }
                            }
                            //EJ2-863489 - Node annotation textAlign "Justify" option is not working correctly
                            this.alignText(text, tspanElement, child, textNode, offsetX, offsetY, i, options, childNodes);
                            childNodesHeight += child.dy;
                        }
                        else {
                            break;
                        }
                    }
                    else {
                        //EJ2-863489 - Node annotation textAlign "Justify" option is not working correctly
                        this.alignText(text, tspanElement, child, textNode, offsetX, offsetY, i, options, childNodes);
                    }
                }
            }
            if (childNodesHeight && options.isHorizontalLane) {
                pivotX = options.parentOffsetX + options.pivotX;
                pivotY = options.parentOffsetY + options.pivotY;
                options.y = options.parentOffsetY - childNodesHeight * options.pivotY + 0.5;
            }
            if (options.textDecoration && options.textDecoration === 'LineThrough') {
                options.textDecoration = wordBreakToString(options.textDecoration);
            }
            var attr = {
                'id': options.id + '_text', 'fill': options.color, 'visibility': options.visible ? 'visible' : 'hidden',
                'text-decoration': options.textDecoration, 'transform': 'rotate(' + options.angle + ','
                    + (pivotX) + ',' + (pivotY) + ')'
                    + 'translate(' + (options.x) + ',' + (options.y) + ')', 'opacity': options.opacity
            };
            if (ariaLabel) {
                // BLAZ-24062: Adding 'aria-label' without role attribute it causes violation in accessibility test
                attr['role'] = 'img';
                attr['aria-label'] = ariaLabel;
            }
            setAttributeSvg(text, attr);
        }
    };
    SvgRenderer.prototype.alignText = function (text, tspanElement, child, textNode, offsetX, offsetY, i, options, childNodes) {
        //EJ2-863489 - Node annotation textAlign "Justify" option is not working correctly
        if (options.textAlign !== 'justify') {
            this.setText(text, tspanElement, child, textNode, offsetX, offsetY, options);
        }
        else {
            if (i !== childNodes.length - 1) {
                var textlength = options.width;
                var adjustlen = 'spacing';
                this.setText(text, tspanElement, child, textNode, offsetX, offsetY, options, textlength, adjustlen);
            }
            else {
                this.setText(text, tspanElement, child, textNode, offsetX, offsetY, options);
            }
        }
    };
    SvgRenderer.prototype.setText = function (text, tspanElement, child, textNode, offsetX, offsetY, options, textlength, adjustlen) {
        if (options.textAlign !== 'justify') {
            setAttributeSvg(tspanElement, { 'x': offsetX.toString(), 'y': offsetY.toString() });
        }
        else {
            setAttributeSvg(tspanElement, { 'x': offsetX.toString(), 'y': offsetY.toString(), 'textLength': textlength ? textlength : 0, 'lengthAdjust': adjustlen ? adjustlen : 'spacing' });
        }
        text.setAttribute('fill', child.text);
        tspanElement.appendChild(textNode);
        text.appendChild(tspanElement);
    };
    /**
     * Draw the image element for the diagram\
     *
     *  @returns {void} Draw the image element for the diagram .
     *  @param { SVGElement | HTMLCanvasElement} canvas - Provide the SVG element .
     *  @param {ImageAttributes} obj - Provide the image attributes .
     *  @param {SVGSVGElement} parentSvg - Provide the parent SVG element .
     *  @param {boolean} fromPalette - Provide the pointer event value .
     *  @private
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    SvgRenderer.prototype.drawImage = function (canvas, obj, parentSvg, fromPalette) {
        ///const id: string = obj.id + '_image';
        var image;
        if (parentSvg) {
            image = parentSvg.getElementById(obj.id + 'image');
        }
        if (!image) {
            image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
            canvas.appendChild(image);
        }
        var imageObj = new Image();
        imageObj.src = obj.source;
        var scale = obj.scale !== 'None' ? obj.scale : '';
        //Removed isBlazor code
        var imgAlign = obj.alignment;
        var aspectRatio = imgAlign.charAt(0).toLowerCase() + imgAlign.slice(1);
        if (scale !== 'Stretch') {
            aspectRatio += ' ' + scale.charAt(0).toLowerCase() + scale.slice(1);
        }
        var attr = {
            'id': obj.id + 'image', 'x': obj.x.toString(), 'y': obj.y.toString(), 'transform': 'rotate(' + obj.angle + ','
                + (obj.x + obj.width * obj.pivotX) + ',' + (obj.y + obj.height * obj.pivotY) + ')',
            'width': obj.width.toString(), 'visibility': obj.visible ? 'visible' : 'hidden',
            'height': obj.height.toString(), 'preserveAspectRatio': aspectRatio,
            //832073 - Opacity when set to Zero for image node is not working - opacity value of 1 is already set as default
            'opacity': obj.opacity.toString()
        };
        setAttributeSvg(image, attr);
        image.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', imageObj.src.toString());
    };
    /**
     * Draw the HTML element for the diagram\
     *
     *  @returns {void} Draw the native element for the diagram.
     *  @param {DiagramHtmlElement} element - Provide the element .
     *  @param {HTMLElement} canvas - Provide the canvas element  .
     *  @param {Transforms} transform - Provide the transform value .
     *  @param {boolean} value - Provide the pointer event value .
     *  @param {number} indexValue - Provide the index value .
     *  @private
     */
    SvgRenderer.prototype.drawHTMLContent = function (element, canvas, transform, value, indexValue) {
        var htmlElement;
        var parentHtmlElement;
        if (canvas) {
            //869698- drag performance is slow when dealing with 1000 plus HTML shapes and Overview feature
            htmlElement = canvas.querySelector('#' + element.id + '_html_element');
        }
        if (!htmlElement) {
            parentHtmlElement = canvas.querySelector(('#' + element.id + '_html_element')) ||
                canvas.querySelector(('#' + element.nodeId + '_html_element'));
            if (!parentHtmlElement) {
                var attr_1 = {
                    'id': element.nodeId + '_html_element',
                    'class': 'foreign-object'
                };
                parentHtmlElement = createHtmlElement('div', attr_1);
            }
            var attr = {
                'id': element.id + '_html_element',
                'class': 'foreign-object'
            };
            htmlElement = createHtmlElement('div', attr);
            var diagram = document.getElementById(element.diagramId).ej2_instances[0];
            var isOverviewLayer = false;
            if (canvas.parentNode && canvas.parentNode.parentNode && canvas.parentNode.parentNode.parentNode && canvas.parentNode.parentNode.parentNode.classList.contains('e-overview')) {
                isOverviewLayer = true;
            }
            if (isOverviewLayer) {
                //893685: HTML node with node Template not shown in Overview in React.
                if (diagram.isReact) {
                    diagram.renderReactTemplates(function () {
                        htmlElement.appendChild(element.template.cloneNode(true));
                    });
                }
                else {
                    htmlElement.appendChild(element.template.cloneNode(true));
                }
            }
            else {
                //Bug 852259: User handle template not working properly after saving and loading the diagram.
                // After serialization the template will be in string format, so we need to convert it to element.
                if (typeof element.template === 'string') {
                    var temp = document.createElement('div');
                    temp.innerHTML = element.template;
                    element.template = temp;
                    var handle = diagram.selectedItems.userHandles.filter(function (x) {
                        return x.name === (element.id.split('_shape')[0]) && x.template !== '';
                    });
                    handle[0].template = element.template;
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                // 883335-Exception Throws When Loading Data Without Defining Node Template at Application Level
                if (element.isTemplate && element.template) {
                    htmlElement.appendChild(element.template);
                }
                else if (element.template) {
                    htmlElement.appendChild(element.template.cloneNode(true));
                }
            }
            if (indexValue !== undefined && canvas.childNodes.length > indexValue) {
                canvas.insertBefore(htmlElement, canvas.childNodes[parseInt(indexValue.toString(), 10)]);
            }
            parentHtmlElement.appendChild(htmlElement);
            canvas.appendChild(parentHtmlElement);
        }
        var point = cornersPointsBeforeRotation(element).topLeft;
        htmlElement.style.height = element.actualSize.height + 'px';
        htmlElement.style.width = element.actualSize.width + 'px';
        htmlElement.style.left = point.x + 'px';
        htmlElement.style.top = point.y + 'px';
        htmlElement.style.position = 'absolute';
        htmlElement.style.transform = "rotate(" + (element.rotateAngle + element.parentTransform) + "deg)";
        htmlElement.style.pointerEvents = value ? 'all' : 'none';
        htmlElement.style.visibility = element.visible ? 'visible' : 'hidden';
        htmlElement.style.opacity = element.style.opacity.toString();
    };
    /**
     * Draw the native element for the diagram\
     *
     *  @returns {void} Draw the native element for the diagram.
     *  @param {DiagramNativeElement} element - Provide the node element .
     *  @param {HTMLCanvasElement} canvas - Provide the SVG element  .
     *  @param {number} height - Provide the height for the shape .
     *  @param {number} width - Provide the width for the shape .
     *  @param {SVGSVGElement} parentSvg - Provide the parent svg for  the shape .
     *  @private
     */
    SvgRenderer.prototype.drawNativeContent = function (element, canvas, height, width, parentSvg) {
        var nativeElement;
        var clipPath;
        if (parentSvg) {
            nativeElement = parentSvg.getElementById(element.id + '_native_element');
            clipPath = parentSvg.getElementById(element.id + '_clip');
        }
        if (!nativeElement) {
            nativeElement = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            nativeElement.setAttribute('id', element.id + '_native_element');
            nativeElement.appendChild(element.template.cloneNode(true));
            var svgContentTag = this.createGElement('g', { id: element.id + '_inner_native_element' });
            svgContentTag.appendChild(nativeElement);
            canvas.appendChild(svgContentTag);
        }
        if (clipPath) {
            nativeElement.removeChild(clipPath);
        }
        nativeElement.style.visibility = element.visible ? 'visible' : 'hidden';
        nativeElement.style.opacity = element.style.opacity ? element.style.opacity.toString() : '1';
        this.setNativTransform(element, nativeElement, height, width);
        if (element.scale === 'Slice') {
            this.drawClipPath(element, nativeElement, height, width, parentSvg);
        }
        setAttributeSvg(nativeElement, element.description ? { 'role': 'img', 'aria-label': element.description } : {});
    };
    SvgRenderer.prototype.setNativTransform = function (element, nativeElement, height, width) {
        //let angle: number;
        var contentWidth = element.contentSize.width !== 0 ? element.contentSize.width : 1;
        var contentHeight = element.contentSize.height !== 0 ? element.contentSize.height : 1;
        var x = element.templatePosition.x * width / contentWidth;
        var y = element.templatePosition.y * height / contentHeight;
        nativeElement.setAttribute('transform', 'rotate(' + element.parentTransform + ',' + element.offsetX + ',' + element.offsetY +
            ') translate(' + (element.offsetX - x - width * element.pivot.x) + ',' + (element.offsetY - y - height * element.pivot.y) +
            ') scale(' + (width / contentWidth) + ',' + (height / contentHeight) + ')');
    };
    /**
     *used to crop the given native element into a rectangle of the given size .\
     *
     *  @returns {SVGElement} used to crop the given native element into a rectangle of the given size.
     *  @param {DiagramNativeElement} node - Provide the node element .
     *  @param {SVGElement} group - Provide the SVG element  .
     *  @param {number} height - Provide the height for the shape .
     *  @param {number} width - Provide the width for the shape .
     *  @param {SVGSVGElement} parentSvg - Provide the parent svg for  the shape .
     *  @private
     */
    SvgRenderer.prototype.drawClipPath = function (node, group, height, width, parentSvg) {
        var contentWidth = node.contentSize.width;
        var contentHeight = node.contentSize.height;
        //let actualWidth: number = node.actualSize.width;
        //let actualHeight: number = node.actualSize.height;
        var clipWidth = node.width / (width / contentWidth);
        var clipHeight = node.height / (height / contentHeight);
        var x = node.templatePosition.x + (node.width >= node.height ? 0 : (contentWidth - clipWidth) / 2);
        var y = node.templatePosition.y + (node.height >= node.width ? 0 : (contentHeight - clipHeight) / 2);
        var clipPath = parentSvg.getElementById(node.id + '_clip');
        clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
        clipPath.setAttribute('id', node.id + '_clip');
        group.appendChild(clipPath);
        var rect = parentSvg.getElementById(node.id + '_clip_rect');
        rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        clipPath.appendChild(rect);
        var attr = {
            'id': node.id + '_clip_rect', 'width': clipWidth.toString(), 'height': clipHeight.toString(),
            'x': x.toString(), 'y': y.toString()
        };
        setAttributeSvg(rect, attr);
        if (checkBrowserInfo()) {
            group.setAttribute('clip-path', 'url(' + location.protocol + '//' + location.host + location.pathname +
                '#' + node.id + '_clip)');
        }
        else {
            group.setAttribute('clip-path', 'url(#' + node.id + '_clip)');
        }
        return group;
    };
    /**
     * Draw the gradient for the diagram shapes .\
     *
     *  @returns {SVGElement} Draw the gradient for the diagram shapes.
     *  @param {StyleAttributes} options - Provide the options  for the gradient  element .
     *  @param {SVGElement} svg - Provide the SVG element  .
     *  @param {string} diagramId - Provide the diagram id .
     *  @private
     */
    SvgRenderer.prototype.renderGradient = function (options, svg, diagramId) {
        var max;
        var min;
        var grd;
        var svgContainer = getBackgroundLayerSvg(diagramId);
        var defs = svgContainer.getElementById(diagramId + 'gradient_pattern');
        if (!defs) {
            defs = createSvgElement('defs', { id: diagramId + 'gradient_pattern' });
            svgContainer.insertBefore(defs, svgContainer.firstChild);
        }
        var radial;
        var linear; //let stop: StopModel; let offset: number;
        removeGradient(svg.id);
        if (options.gradient.type !== 'None') {
            for (var i = 0; i < options.gradient.stops.length; i++) {
                max = !max ? options.gradient.stops[parseInt(i.toString(), 10)].offset
                    : Math.max(max, options.gradient.stops[parseInt(i.toString(), 10)].offset);
                min = !min ? options.gradient.stops[parseInt(i.toString(), 10)].offset
                    : Math.min(min, options.gradient.stops[parseInt(i.toString(), 10)].offset);
            }
            if (options.gradient.type === 'Linear') {
                linear = options.gradient;
                linear.id = svg.id + '_linear';
                grd = this.createLinearGradient(linear);
                defs.appendChild(grd);
            }
            else {
                radial = options.gradient;
                radial.id = svg.id + '_radial';
                grd = this.createRadialGradient(radial);
                defs.appendChild(grd);
            }
            for (var i = 0; i < options.gradient.stops.length; i++) {
                var stop_1 = options.gradient.stops[parseInt(i.toString(), 10)];
                var offset = min < 0 ? (max + stop_1.offset) / (2 * max) : stop_1.offset / max;
                var stopElement = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                setAttributeSvg(stopElement, { 'offset': offset.toString(), 'style': 'stop-color:' + stop_1.color });
                grd.appendChild(stopElement);
            }
        }
        return grd;
    };
    /**
     * Draw the Linear gradient for the diagram .\
     *
     *  @returns {SVGElement} Draw the Linear gradient for the diagram.
     *  @param {LinearGradientModel} linear - Provide the objects for the gradient  element .
     *  @private
     */
    SvgRenderer.prototype.createLinearGradient = function (linear) {
        var lineargradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        var attr = {
            'id': linear.id, 'x1': linear.x1 + '%', 'y1': linear.y1 + '%', 'x2': linear.x2 + '%', 'y2': linear.y2 + '%'
        };
        setAttributeSvg(lineargradient, attr);
        return lineargradient;
    };
    /**
     * Draw the radial gradient for the diagram .\
     *
     *  @returns {SVGElement} Draw the radial gradient for the diagram.
     *  @param {RadialGradientModel} radial - Provide the objects for the gradient  element .
     *  @private
     */
    SvgRenderer.prototype.createRadialGradient = function (radial) {
        var radialgradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
        var attr = {
            'id': radial.id, 'cx': radial.cx + '%', 'cy': radial.cy + '%', 'r': radial.r + '%', 'fx': radial.fx + '%', 'fy': radial.fy + '%'
        };
        setAttributeSvg(radialgradient, attr);
        return radialgradient;
    };
    /**
     * Set the SVG style for the SVG elements in the diagram.\
     *
     *  @returns {void}
     *  @param {SVGElement} svg - Provide the canvas element .
     *  @param {StyleAttributes} style - Provide the canvas element .
     *  @param {string} diagramId - Provide the canvas element .
     *  @private
     */
    SvgRenderer.prototype.setSvgStyle = function (svg, style, diagramId) {
        if (style.canApplyStyle || style.canApplyStyle === undefined) {
            if (style.fill === 'none') {
                style.fill = 'transparent';
            }
            if (style.stroke === 'none') {
                style.stroke = 'transparent';
            }
            var dashArray = [];
            var fill = void 0;
            if (style.dashArray) {
                var canvasRenderer = new CanvasRenderer();
                dashArray = canvasRenderer.parseDashArray(style.dashArray);
            }
            if (style.gradient && style.gradient.type !== 'None' && diagramId) {
                var grd = this.renderGradient(style, svg, diagramId);
                if (checkBrowserInfo()) {
                    fill = 'url(' + location.protocol + '//' + location.host + location.pathname + '#' + grd.id + ')';
                }
                else {
                    fill = 'url(#' + grd.id + ')';
                }
            }
            else {
                fill = style.fill;
            }
            if (style.stroke) {
                svg.setAttribute('stroke', style.stroke);
            }
            if (style.strokeWidth !== undefined && style.strokeWidth !== null) {
                svg.setAttribute('stroke-width', style.strokeWidth.toString());
            }
            if (dashArray) {
                svg.setAttribute('stroke-dasharray', dashArray.toString() || 'none');
            }
            if (fill) {
                svg.setAttribute('fill', fill);
            }
        }
    };
    //end region
    // text utility
    /**
     * Draw the SVG label.\
     *
     * @returns {PointModel} Draw the SVG label .
     *  @param {TextAttributes} text - Provide the canvas element .
     *  @param {Object} wrapBound - Provide the canvas element .
     *  @param {SubTextElement []} childNodes - Provide the canvas element .
     * @private
     */
    SvgRenderer.prototype.svgLabelAlign = function (text, wrapBound, childNodes) {
        var bounds = new Size(wrapBound.width, childNodes.length * (text.fontSize * 1.2));
        var pos = { x: 0, y: 0 };
        var x = 0;
        var y = 1.2;
        var offsetX = text.width * 0.5;
        var offsety = text.height * 0.5;
        var pointX = offsetX;
        var pointY = offsety;
        if (text.textAlign === 'left' || text.textAlign === 'justify') {
            pointX = 0;
        }
        else if (text.textAlign === 'center') {
            if (wrapBound.width > text.width && (text.textOverflow === 'Ellipsis' || text.textOverflow === 'Clip')) {
                if (text.textWrapping === 'NoWrap') {
                    pointX = 0;
                }
                else {
                    pointX = text.width * 0.5;
                }
            }
            else {
                pointX = text.width * 0.5;
            }
        }
        else if (text.textAlign === 'right') {
            pointX = (text.width * 1);
        }
        pos.x = x + pointX + (wrapBound ? wrapBound.x : 0);
        pos.y = y + pointY - bounds.height / 2;
        return pos;
    };
    return SvgRenderer;
}());

/**
 * Renderer module is used to render basic diagram elements
 */
/** @private */
var DiagramRenderer = /** @class */ (function () {
    function DiagramRenderer(name, svgRender, isSvgMode) {
        /**   @private  */
        this.renderer = null;
        /** @private */
        this.isSvgMode = true;
        /** @private */
        this.touchMove = undefined;
        this.transform = { x: 0, y: 0 };
        this.diagramId = name;
        this.element = getDiagramElement(this.diagramId);
        this.svgRenderer = svgRender;
        this.isSvgMode = isSvgMode;
        this.renderer = isSvgMode ? new SvgRenderer() : new CanvasRenderer();
    }
    /**
     * Method used to set the cur \
     *
     *  @param {HTMLElement} canvas - Provide the canvas .
     *  @param {string} cursor - Provide the element .
     * @returns {void }   Method used to set the layer  .\
     * @private
     */
    DiagramRenderer.prototype.setCursor = function (canvas, cursor) {
        canvas.style.cursor = cursor;
    };
    /**
     * Method used to set the layer \
     *
     * @returns {void }   Method used to set the layer  .\
     *
     * @private
     */
    DiagramRenderer.prototype.setLayers = function () {
        this.iconSvgLayer = this.element.getElementsByClassName('e-ports-expand-layer')[0];
        this.adornerSvgLayer = this.element.getElementsByClassName('e-adorner-layer')[0];
        this.nativeSvgLayer = this.element.getElementsByClassName('e-native-layer')[0];
        this.diagramSvgLayer = this.element.getElementsByClassName('e-diagram-layer')[0];
    };
    DiagramRenderer.prototype.getAdornerLayer = function () {
        var adornerLayer = getAdornerLayer(this.diagramId);
        return adornerLayer;
    };
    DiagramRenderer.prototype.getParentSvg = function (element, targetElement, canvas) {
        if (this.diagramId && element && element.id) {
            if (element.id.split('_icon_content').length > 1 || element.id.split('_nodeport').length > 1 ||
                (element.elementActions & ElementAction.ElementIsPort)) {
                return this.iconSvgLayer;
            }
            if (targetElement && targetElement === 'selector') {
                return this.adornerSvgLayer;
            }
            else if (element instanceof DiagramNativeElement) {
                return this.nativeSvgLayer;
            }
            else {
                return this.diagramSvgLayer;
            }
        }
        return canvas;
    };
    DiagramRenderer.prototype.getParentElement = function (element, defaultParent, svgElement, indexValue) {
        var layerGElement = defaultParent;
        if (svgElement && this.diagramId && element && element.id) {
            if (element.id.split('_icon_content').length > 1) {
                layerGElement = svgElement.getElementById(this.diagramId + '_diagramExpander');
                defaultParent = null;
            }
            else if (element.id.split('_nodeport').length > 1) {
                layerGElement = svgElement.getElementById(this.diagramId + '_diagramPorts');
            }
            else if (element instanceof DiagramNativeElement) {
                layerGElement = svgElement.getElementById(this.diagramId + '_nativeLayer');
                defaultParent = null;
            }
            else if (element.elementActions & ElementAction.ElementIsPort) {
                layerGElement = svgElement.getElementById(this.diagramId + '_diagramPorts');
                defaultParent = null;
            }
            else {
                layerGElement = svgElement.getElementById(this.diagramId + '_diagramLayer');
            }
            var groupElement = this.getGroupElement(element, defaultParent || layerGElement, indexValue);
            layerGElement = groupElement.g;
            if (groupElement.svg) {
                svgElement = groupElement.svg;
            }
        }
        return { g: layerGElement, svg: svgElement };
    };
    DiagramRenderer.prototype.getGroupElement = function (element, canvas, indexValue) {
        var gElement;
        var parentSvg = this.getParentSvg(element);
        var svgElement;
        if (canvas && parentSvg) {
            if (parentSvg) {
                gElement = parentSvg.getElementById(element.id + '_groupElement');
                if (!gElement && parentSvg !== this.nativeSvgLayer) { //code added
                    var nativeSvg = this.nativeSvgLayer;
                    gElement = nativeSvg.getElementById(element.id + '_groupElement');
                    svgElement = nativeSvg;
                }
            }
            if (!gElement) {
                gElement = this.svgRenderer.createGElement('g', { id: element.id + '_groupElement' });
                if (indexValue !== undefined && canvas.childNodes.length > indexValue) {
                    canvas.insertBefore(gElement, canvas.childNodes[parseInt(indexValue.toString(), 10)]);
                }
                else {
                    canvas.appendChild(gElement);
                }
            }
        }
        return { g: gElement, svg: svgElement };
    };
    /**
     * Method used to render the diagram element \
     *
     * @returns {void }   Method used to render the diagram element  .\
     *
     * @param {DiagramElement} element - Provide the DiagramElement value.
     * @param {HTMLCanvasElement | SVGElement } canvas - Provide the canvas value.
     * @param {HTMLElement } htmlLayer - Provide the HTMLElement value.
     * @param {Transforms } transform - Provide the Transforms value.
     * @param {SVGSVGElement} parentSvg - Provide the SVGSVGElement value.
     * @param {boolean } createParent - Provide the boolean value.
     * @param {boolean } fromPalette - Provide the boolean value.
     * @param {number } indexValue - Provide the indexValue value.
     * @param {boolean } isPreviewNode - Provide the isPreviewNode value.
     * @param {object } centerPoint - Provide the centerPoint value.
     * @param {object} portCenterPoint - Provide the portCenterPoint value.
     * @private
     */
    DiagramRenderer.prototype.renderElement = function (element, canvas, htmlLayer, transform, parentSvg, createParent, fromPalette, indexValue, isPreviewNode, centerPoint, portCenterPoint) {
        if (element instanceof Container) {
            element.id = element.id ? element.id : randomId();
            this.renderContainer(element, canvas, htmlLayer, transform, parentSvg, createParent, fromPalette, indexValue, isPreviewNode, centerPoint, portCenterPoint);
        }
        else if (element instanceof ImageElement) {
            this.renderImageElement(element, canvas, transform, parentSvg, fromPalette);
        }
        else if (element instanceof PathElement) {
            this.renderPathElement(element, canvas, transform, parentSvg, fromPalette, isPreviewNode, portCenterPoint);
        }
        else if (element instanceof TextElement) {
            this.renderTextElement(element, canvas, transform, parentSvg, fromPalette, centerPoint);
        }
        else if (element instanceof DiagramNativeElement) {
            this.renderNativeElement(element, canvas, transform, parentSvg, fromPalette);
        }
        else if (element instanceof DiagramHtmlElement) {
            this.renderHTMLElement(element, canvas, htmlLayer, transform, parentSvg, fromPalette, indexValue);
        }
        else {
            this.renderRect(element, canvas, transform, parentSvg, isPreviewNode);
        }
    };
    /**
     * Method used to draw the selection rectangle for the node \
     *
     * @returns {void }  Method used to draw the selection rectangle for the node  .\
     *
     * @param {number} x - Provide the DiagramElement value.
     * @param {number } y - Provide the SVGElement value.
     * @param {number } w - Provide the Transforms value.
     * @param {number } h - Provide the Transforms value.
     * @param {HTMLCanvasElement | SVGElement } canvas - Provide the Transforms value.
     * @param {number } t - Provide the Transforms value.
     * @private
     */
    DiagramRenderer.prototype.drawSelectionRectangle = function (x, y, w, h, canvas, t) {
        x = (x + t.tx) * t.scale;
        y = (y + t.ty) * t.scale;
        var options = {
            width: w * t.scale, height: h * t.scale,
            x: x + 0.5, y: y + 0.5, fill: 'transparent', stroke: 'gray', angle: 0,
            pivotX: 0.5, pivotY: 0.5, strokeWidth: 1,
            dashArray: '6 3', opacity: 1,
            visible: true, id: canvas.id + '_selected_region'
        };
        var adornerLayer = this.getAdornerLayer();
        this.svgRenderer.updateSelectionRegion(adornerLayer, options);
    };
    /**
     * Method used to render the highlighter \
     *
     * @returns {void }  Method used to render the highlighter  .\
     *
     * @param {DiagramElement} element - Provide the DiagramElement value.
     * @param {SVGElement } canvas - Provide the SVGElement value.
     * @param {Transforms } transform - Provide the Transforms value.
     * @private
     */
    DiagramRenderer.prototype.renderHighlighter = function (element, canvas, transform) {
        var width = element.actualSize.width || 2;
        var height = element.actualSize.height || 2;
        var x = element.offsetX - width * element.pivot.x;
        var y = element.offsetY - height * element.pivot.y;
        x = (x + transform.tx) * transform.scale;
        y = (y + transform.ty) * transform.scale;
        var options = {
            width: width * transform.scale, height: height * transform.scale,
            x: x, y: y, fill: 'transparent', stroke: '#8CC63F', angle: element.rotateAngle,
            pivotX: element.pivot.x, pivotY: element.pivot.y, strokeWidth: 4,
            dashArray: '', opacity: 1, cornerRadius: 0,
            visible: true, id: canvas.id + '_highlighter', class: 'e-diagram-highlighter'
        };
        this.svgRenderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, canvas);
    };
    /**
     * Method used to render the node selection rectangle \
     *
     * @returns {void }  Method used to render the node selection rectangle  .\
     *
     * @param {DiagramElement} element - Provide the DiagramElement value.
     * @param {SVGElement } canvas - Provide the SVGElement value.
     * @param {Transforms } transform - Provide the Transforms value.
     * @param {number } isFirst - Provide the boolean value.
     * @private
     */
    DiagramRenderer.prototype.renderSelectionRectangle = function (element, canvas, transform, isFirst) {
        var width = element.actualSize.width || 2;
        var height = element.actualSize.height || 2;
        var x = element.offsetX - width * element.pivot.x;
        var y = element.offsetY - height * element.pivot.y;
        x = (x + transform.tx) * transform.scale;
        y = (y + transform.ty) * transform.scale;
        var options = {
            width: width * transform.scale, height: height * transform.scale,
            x: x, y: y, fill: 'transparent', stroke: '#00cc00', angle: element.rotateAngle,
            pivotX: element.pivot.x, pivotY: element.pivot.y, strokeWidth: isFirst ? 2 : 1,
            dashArray: '', opacity: 1, cornerRadius: 0,
            visible: true, id: element.id + '_highlighter', class: isFirst ? 'e-diagram-first-selection-indicator e-diagram-selection-indicator' : 'e-diagram-selection-indicator'
        };
        var parentSvg = this.getParentSvg(element, 'selector');
        this.svgRenderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);
    };
    /**
     * Method used to render the selection line for connector  \
     *
     * @returns {void } Method used to render the selection line for connector .\
     *
     * @param {PathElement} element - Provide the path element of the diagram .
     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.
     * @param { Transforms } transform - Provide the transform value.
     * @param { boolean } isFirst - Provide the boolean value.
     * @private
     */
    DiagramRenderer.prototype.renderSelectionLine = function (element, canvas, transform, isFirst) {
        var options = this.getBaseAttributes(element, transform);
        options.data = element.absolutePath;
        options.id = options.id + '_highlighter';
        var ariaLabel = element.description ? element.description : element.id;
        if (!this.isSvgMode) {
            options.x = element.flipOffset.x ? element.flipOffset.x : options.x;
            options.y = element.flipOffset.y ? element.flipOffset.y : options.y;
        }
        if (transform) {
            options.x = options.x * transform.scale;
            options.y = options.y * transform.scale;
        }
        options.stroke = '#00cc00';
        options.strokeWidth = isFirst ? 2 : 1;
        options.class = isFirst ? 'e-diagram-first-selection-indicator e-diagram-selection-indicator' : 'e-diagram-selection-indicator';
        var parentSvg = this.getParentSvg(element, 'selector');
        this.svgRenderer.drawPath(canvas, options, this.diagramId, undefined, parentSvg, ariaLabel, transform.scale);
    };
    /**
     * Method used to render the stack highlighter \
     *
     * @returns {void }  Method used to render the stack highlighter  .\
     *
     * @param {DiagramElement} element - Provide the DiagramElement value.
     * @param {SVGElement } canvas - Provide the SVGElement value.
     * @param {Transforms } transform - Provide the Transforms value.
     * @param {boolean} isVertical - Provide the Boolean value.
     * @param {PointModel } position - Provide the PointModel value.
     * @param {boolean } isUml - Provide the boolean value.
     * @param {boolean } isSwimlane - Provide the boolean value.
     * @private
     */
    DiagramRenderer.prototype.renderStackHighlighter = function (element, canvas, transform, isVertical, position, isUml, isSwimlane) {
        var width = element.actualSize.width || 2;
        var x = element.offsetX - width * element.pivot.x;
        var height = element.actualSize.height || 2;
        var y = element.offsetY - height * element.pivot.y;
        x = (x + transform.tx) * transform.scale;
        var data;
        var bounds = element.bounds;
        var newPathString = '';
        y = (y + transform.ty) * transform.scale;
        if (!isVertical) {
            var d = height * transform.scale;
            data = 'M 10 -10 L 0 0 Z M -10 -10 L 0 0 Z M 0 0 L 0 ' + (d) + ' Z M 0  ' + (d) +
                ' L -10  ' + (d + 10) + ' Z L 10  ' + (d + 10) + ' Z';
            if (position.x >= element.offsetX) {
                //879085- swimlane helper guides not rendered properly when zoomed
                x += width * transform.scale;
            }
        }
        else {
            if (isUml) {
                var d = width * transform.scale;
                data = 'M 0 0 L ' + (d + 2) + ' 0 Z';
                var scaleX = -bounds.x;
                var scaleY = -bounds.y;
                var arrayCollection = [];
                scaleX = element.actualSize.width / Number(bounds.width ? bounds.width : 1) * transform.scale;
                scaleY = element.actualSize.height / Number(bounds.height ? bounds.height : 1) * transform.scale;
                var umlData = 'M7,4 L8,4 8,7 11,7 11,8 8,8 8,11 7,11 7,8 4,8 4,7 7,7 z M7.5,0.99999994' +
                    'C3.9160004,1 1,3.9160004 0.99999994,7.5 1,11.084 3.9160004,14 7.5,14 11.084,14 14,11.084 14,7.5 14,' +
                    '3.9160004 11.084,1 7.5,0.99999994 z M7.5,0 C11.636002,0 15,3.3639984 15,7.5 15,11.636002 11.636002,15 7.5,' +
                    '15 3.3640003,15 0,11.636002 0,7.5 0,3.3639984 3.3640003,0 7.5,0 z';
                arrayCollection = processPathData(umlData);
                arrayCollection = splitArrayCollection(arrayCollection);
                newPathString = transformPath(arrayCollection, scaleX + d + 2, scaleY - 8, false, bounds.x, bounds.y, 0, 0);
                if (position.y >= element.offsetY) {
                    y += height;
                }
            }
            else {
                if (isSwimlane) {
                    if (position.y >= element.offsetY) {
                        //879085- swimlane helper guides not rendered properly when zoomed
                        y += height * transform.scale;
                    }
                }
                var d = width * transform.scale;
                data = 'M -10 -10 L 0 0 Z M -10 10 L 0 0 Z M 0 0 L ' + (d) + ' 0 Z M ' + (d) + ' 0 L ' +
                    (d + 10) + ' 10 Z L ' + (d + 10) + ' -10 Z';
            }
        }
        var options = {
            data: data + newPathString,
            width: width * transform.scale, height: height * transform.scale,
            x: x, y: y, fill: 'transparent', stroke: '#8CC63F', angle: element.rotateAngle,
            pivotX: element.pivot.x, pivotY: element.pivot.y, strokeWidth: 1,
            dashArray: '', opacity: 1,
            visible: true, id: canvas.id + '_stack_highlighter', class: 'e-diagram-highlighter'
        };
        this.svgRenderer.drawPath(canvas, options, this.diagramId);
    };
    /**
     * Method used to draw the line \
     *
     * @returns {void }  Method used to draw the line  .\
     *
     * @param {SVGElement} canvas - Provide the SVGElement value.
     * @param {LineAttributes } options - Provide the LineAttributes value.
     * @private
     */
    DiagramRenderer.prototype.drawLine = function (canvas, options) {
        this.svgRenderer.drawLine(canvas, options);
    };
    /**
     * Method used to draw the path \
     *
     * @returns {void }  Method used to draw the path  .\
     *
     * @param {SVGElement} canvas - Provide the canvas value.
     * @param {PathAttributes } options - Provide the PathAttributes value.
     * @private
     */
    DiagramRenderer.prototype.drawPath = function (canvas, options) {
        this.svgRenderer.drawPath(canvas, options, this.diagramId);
    };
    /**
     * Method used to render the resize handle \
     *
     * @returns {void }  Method used to render the resize handle  .\
     *
     * @param {DiagramElement} element - Provide the DiagramElement value.
     * @param {HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.
     * @param {  ThumbsConstraints } constraints - Provide the constraints value  .
     * @param { number} currentZoom - Provide the currentZoom value.
     * @param { SelectorConstraints } selectorConstraints - Provide the selectorConstraints value .
     * @param { Transforms } transform - Provide the transform  value.
     * @param { boolean } canMask - Provide the canMask boolean value.
     * @param { number } enableNode - Provide the enableNode value.
     * @param { boolean } nodeConstraints - Provide the nodeConstraints  value.
     * @param { boolean } isSwimlane - Provide the isSwimlane boolean value.
     * @param { number } handleSize - Provide the handleSize value.
     * @private
     */
    DiagramRenderer.prototype.renderResizeHandle = function (element, canvas, constraints, currentZoom, selectorConstraints, transform, canMask, enableNode, nodeConstraints, isSwimlane, handleSize) {
        var left = element.offsetX - element.actualSize.width * element.pivot.x;
        var top = element.offsetY - element.actualSize.height * element.pivot.y;
        var height = element.actualSize.height;
        var width = element.actualSize.width;
        if (!isSwimlane &&
            (constraints & ThumbsConstraints.Rotate && canDrawThumbs(this.rendererActions) && (!avoidDrawSelector(this.rendererActions)))) {
            this.renderPivotLine(element, canvas, transform, selectorConstraints, canMask);
            this.renderRotateThumb(element, canvas, transform, selectorConstraints, canMask);
        }
        else {
            if (this.touchMove) {
                var rotateThumb = document.getElementById('rotateThumb');
                if (rotateThumb) {
                    rotateThumb.setAttribute('visibility', 'hidden');
                }
            }
        }
        this.renderBorder(element, canvas, transform, enableNode, nodeConstraints, isSwimlane);
        var nodeWidth = element.actualSize.width * currentZoom;
        var nodeHeight = element.actualSize.height * currentZoom;
        if (!nodeConstraints && canDrawThumbs(this.rendererActions) && (!avoidDrawSelector(this.rendererActions))) {
            //Bug 860033: Bpmn text annotation path size not rendered properly while dragging.
            //Added below condition to prevent the resize thumbs for bpmn text annotation.
            if (!element.isTextAnnotation) {
                if (nodeWidth >= 40 && nodeHeight >= 40) {
                    //Hide corners when the size is less than 40
                    if (selectorConstraints & SelectorConstraints.ResizeNorthWest) {
                        this.renderCircularHandle('resizeNorthWest', element, left, top, canvas, canShowCorner(selectorConstraints, 'ResizeNorthWest'), constraints & ThumbsConstraints.ResizeNorthWest, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on top left side direction' }, undefined, 'e-diagram-resize-handle e-northwest', handleSize);
                    }
                    if (selectorConstraints & SelectorConstraints.ResizeNorthEast) {
                        this.renderCircularHandle('resizeNorthEast', element, left + width, top, canvas, canShowCorner(selectorConstraints, 'ResizeNorthEast'), constraints & ThumbsConstraints.ResizeNorthEast, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on top right side direction' }, undefined, 'e-diagram-resize-handle e-northeast', handleSize);
                    }
                    if (selectorConstraints & SelectorConstraints.ResizeSouthWest) {
                        this.renderCircularHandle('resizeSouthWest', element, left, top + height, canvas, canShowCorner(selectorConstraints, 'ResizeSouthWest'), constraints & ThumbsConstraints.ResizeSouthWest, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on bottom left side direction' }, undefined, 'e-diagram-resize-handle e-southwest', handleSize);
                    }
                    if (selectorConstraints & SelectorConstraints.ResizeSouthEast) {
                        this.renderCircularHandle('resizeSouthEast', element, left + width, top + height, canvas, canShowCorner(selectorConstraints, 'ResizeSouthEast'), constraints & ThumbsConstraints.ResizeSouthEast, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on bottom right side direction' }, undefined, 'e-diagram-resize-handle e-southeast', handleSize);
                    }
                }
                if (selectorConstraints & SelectorConstraints.ResizeNorth) {
                    this.renderCircularHandle('resizeNorth', element, left + width / 2, top, canvas, canShowCorner(selectorConstraints, 'ResizeNorth'), constraints & ThumbsConstraints.ResizeNorth, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on top side direction' }, undefined, 'e-diagram-resize-handle e-north', handleSize);
                }
                if (selectorConstraints & SelectorConstraints.ResizeSouth) {
                    this.renderCircularHandle('resizeSouth', element, left + width / 2, top + height, canvas, canShowCorner(selectorConstraints, 'ResizeSouth'), constraints & ThumbsConstraints.ResizeSouth, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on bottom side direction' }, undefined, 'e-diagram-resize-handle e-south', handleSize);
                }
                if (selectorConstraints & SelectorConstraints.ResizeWest) {
                    this.renderCircularHandle('resizeWest', element, left, top + height / 2, canvas, canShowCorner(selectorConstraints, 'ResizeWest'), constraints & ThumbsConstraints.ResizeWest, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on left side direction' }, undefined, 'e-diagram-resize-handle e-west', handleSize);
                }
                if (selectorConstraints & SelectorConstraints.ResizeEast) {
                    this.renderCircularHandle('resizeEast', element, left + width, top + height / 2, canvas, canShowCorner(selectorConstraints, 'ResizeEast'), constraints & ThumbsConstraints.ResizeEast, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on right side direction' }, undefined, 'e-diagram-resize-handle e-east', handleSize);
                }
            }
        }
    };
    /**
     * Method used to render the end point of the handle \
     *
     * @returns {void }  Method used to render the end point of the handle  .\
     *
     * @param {ConnectorModel} selector - Provide the ConnectorModel.
     * @param {HTMLCanvasElement | SVGElement } canvas - Provide the element.
     * @param {  ThumbsConstraints } constraints - Provide the constraints value  .
     * @param { SelectorConstraints} selectorConstraints - Provide the selectorConstraints value.
     * @param { Transforms } transform - Provide the transform value .
     * @param { boolean } connectedSource - Provide the connectedSource boolean value.
     * @param { boolean } connectedTarget - Provide the connectedTarget boolean value.
     * @param { boolean } isSegmentEditing - Provide the isSegmentEditing boolean value.
     * @param { boolean } canShowBezierPoints - Provide the canShowBezierPoints boolean value.
     * @param {number} handleSize - Provide the handleSize value.
     * @private
     */
    DiagramRenderer.prototype.renderEndPointHandle = function (selector, canvas, constraints, selectorConstraints, transform, connectedSource, connectedTarget, isSegmentEditing, canShowBezierPoints, handleSize) {
        var sourcePoint = selector.sourcePoint;
        var targetPoint = selector.targetPoint;
        var wrapper = selector.wrapper;
        var i;
        var segment;
        this.renderCircularHandle('connectorSourceThumb', wrapper, sourcePoint.x, sourcePoint.y, canvas, canShowCorner(selectorConstraints, 'ConnectorSourceThumb'), constraints & ThumbsConstraints.ConnectorSource, transform, connectedSource, undefined, { 'aria-label': 'Thumb to move the source point of the connector' }, undefined, 'e-diagram-endpoint-handle e-sourceend', handleSize);
        this.renderCircularHandle('connectorTargetThumb', wrapper, targetPoint.x, targetPoint.y, canvas, canShowCorner(selectorConstraints, 'ConnectorTargetThumb'), constraints & ThumbsConstraints.ConnectorTarget, transform, connectedTarget, undefined, { 'aria-label': 'Thumb to move the target point of the connector' }, undefined, 'e-diagram-endpoint-handle e-targetend', handleSize);
        if (isSegmentEditing) {
            if ((selector.type === 'Straight') && selector.segments.length > 0) {
                for (i = 0; i < selector.segments.length - 1; i++) {
                    segment = selector.segments[parseInt(i.toString(), 10)];
                    var className = 'e-diagram-straight-segment-handle';
                    this.renderCircularHandle(('segementThumb_' + (i + 1)), wrapper, segment.point.x, segment.point.y, canvas, true, constraints & ThumbsConstraints.ConnectorSource, transform, connectedSource, null, null, i, className, handleSize);
                }
            } //824805-Support to modify bezier connector segment thumb shape and style
            else if ((selector.type === 'Bezier') && selector.segments.length > 0) {
                for (i = 0; i < selector.segments.length - 1; i++) {
                    segment = selector.segments[parseInt(i.toString(), 10)];
                    var className = 'e-diagram-bezier-segment-handle';
                    this.renderBezierHandle(('segementThumb_' + (i + 1)), wrapper, segment.point.x, segment.point.y, canvas, true, selector, transform, connectedSource, null, i, className, handleSize);
                }
            }
            else {
                // (EJ2-57115) - Added below code to check if maxSegmentThumb is zero or not
                if (!selector.maxSegmentThumb) {
                    for (i = 0; i < selector.segments.length; i++) {
                        var seg = selector.segments[parseInt(i.toString(), 10)];
                        this.renderOrthogonalThumbs('orthoThumb_' + (i + 1), wrapper, seg, canvas, canShowCorner(selectorConstraints, 'ConnectorSourceThumb'), transform, selector);
                    }
                }
                else {
                    // (EJ2-57115) - Added below code to check if maxSegmentThumb is non zero then we have ignore the rendering of
                    // first and last segment thumb
                    var start = selector.segments.length <= selector.maxSegmentThumb ? 0 : 1;
                    var end = selector.segments.length <= selector.maxSegmentThumb
                        ? selector.segments.length : selector.segments.length - 1;
                    // (EJ2-57115) - If maxSegmentThumb is greater than or equal to 3 means then set start as second segment(1) and end as last before segment
                    if (selector.maxSegmentThumb >= 3 && selector.segments.length === 3) {
                        start = 1;
                        end = selector.segments.length - 1;
                    }
                    // (EJ2-57115) - If segments length is greater than maxSegmentThumb + 2 means then set start as 2
                    start = selector.segments.length > selector.maxSegmentThumb + 2 ? 2 : start;
                    // (EJ2-57115) - If segments length is greater than maxSegmentThumb + 2 means then set end as last before segment
                    end = selector.segments.length > selector.maxSegmentThumb + 2 ? selector.segments.length - 2 : end;
                    if (selector.segments.length === 1 && selector.segments[0].points.length <= 2) {
                        start = 1;
                        end = selector.segments.length;
                    }
                    for (i = start; i < end; i++) {
                        var seg = selector.segments[parseInt(i.toString(), 10)];
                        this.renderOrthogonalThumbs('orthoThumb_' + (i + 1), wrapper, seg, canvas, canShowCorner(selectorConstraints, 'ConnectorSourceThumb'), transform, selector);
                    }
                }
            }
        }
        if (selector.type === 'Bezier' && canShowBezierPoints) {
            var segmentCount = selector.segments.length - 1;
            var controlPointsVisibility = selector.bezierSettings != null
                ? selector.bezierSettings.controlPointsVisibility : null;
            for (i = 0; i <= segmentCount; i++) {
                var segment_1 = selector.segments[parseInt(i.toString(), 10)];
                var bezierPoint = !Point.isEmptyPoint(segment_1.point1) ? segment_1.point1
                    : segment_1.bezierPoint1;
                if (controlPointsVisibility != null && (i === 0 && canShowControlPoints(controlPointsVisibility, 'Source'))
                    || (i !== 0 && canShowControlPoints(controlPointsVisibility, 'Intermediate'))) {
                    this.renderCircularHandle('bezierPoint_' + (i + 1) + '_1', wrapper, bezierPoint.x, bezierPoint.y, canvas, canShowCorner(selectorConstraints, 'ConnectorSourceThumb'), constraints & ThumbsConstraints.ConnectorSource, transform, undefined, undefined, { 'aria-label': 'Thumb to move the source point of the connector' }, undefined, 'e-diagram-bezier-control-handle e-source', handleSize);
                    if (canShowCorner(selectorConstraints, 'ConnectorSourceThumb')) {
                        this.renderBezierLine('bezierLine_' + (i + 1) + '_1', wrapper, canvas, segment_1.points[0], !Point.isEmptyPoint(segment_1.point1) ? segment_1.point1 : segment_1.bezierPoint1, transform);
                    }
                }
                bezierPoint = !Point.isEmptyPoint(segment_1.point2) ? segment_1.point2 : segment_1.bezierPoint2;
                if (controlPointsVisibility != null && (i === segmentCount && canShowControlPoints(controlPointsVisibility, 'Target'))
                    || (i !== segmentCount && canShowControlPoints(controlPointsVisibility, 'Intermediate'))) {
                    this.renderCircularHandle('bezierPoint_' + (i + 1) + '_2', wrapper, bezierPoint.x, bezierPoint.y, canvas, canShowCorner(selectorConstraints, 'ConnectorTargetThumb'), constraints & ThumbsConstraints.ConnectorTarget, transform, undefined, undefined, { 'aria-label': 'Thumb to move the target point of the connector' }, undefined, 'e-diagram-bezier-control-handle e-target', handleSize);
                    if (canShowCorner(selectorConstraints, 'ConnectorTargetThumb')) {
                        this.renderBezierLine('bezierLine_' + (i + 1) + '_2', wrapper, canvas, segment_1.points[1], !Point.isEmptyPoint(segment_1.point2) ? segment_1.point2 : segment_1.bezierPoint2, transform);
                    }
                }
            }
        }
    };
    /**
     * Method used to render the orthogonal thumb \
     *
     * @returns {void }  Method used to render the orthogonal thumb  .\
     *
     * @param {string} id - Provide the id for the element.
     * @param {DiagramElement } selector - Provide the selector element.
     * @param {  OrthogonalSegment } segment - Provide the segment value  .
     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.
     * @param { boolean } visibility - Provide the visibility value .
     * @param { Transforms } t - Provide the Transforms value.
     * @param { ConnectorModel } connector - Provide the connector value.
     * @private
     */
    DiagramRenderer.prototype.renderOrthogonalThumbs = function (id, selector, segment, canvas, visibility, t, connector) {
        var orientation;
        var visible;
        var length;
        var j = 0;
        var direction;
        // (EJ2-57115) - Added below code to check if maxSegmentThumb is zero or not
        if (!connector.maxSegmentThumb) {
            for (j = 0; j < segment.points.length - 1; j++) {
                length = Point.distancePoints(segment.points[parseInt(j.toString(), 10)], segment.points[j + 1]);
                orientation = (segment.points[parseInt(j.toString(), 10)].y.toFixed(2) === segment.points[j + 1].y.toFixed(2)) ? 'horizontal' : 'vertical';
                //850501-Added below code to check the direction of the segments
                direction = Point.direction(segment.points[parseInt(j.toString(), 10)], segment.points[j + 1]);
                visible = (length >= 50 && segment.allowDrag) ? true : false;
                this.renderOrthogonalThumb((id + '_' + (j + 1)), selector, (((segment.points[parseInt(j.toString(), 10)].x + segment.points[j + 1].x) / 2)), (((segment.points[parseInt(j.toString(), 10)].y + segment.points[j + 1].y) / 2)), canvas, visible, orientation, t, connector, direction);
            }
        }
        else {
            // (EJ2-57115) - Added below code to check if maxSegmentThumb greater then 3 means then we have ignore the rendering of
            // first and last segment thumb
            // Set the start value as 1 if segment points is greater than 3
            var start = segment.points.length < 3 ? 0 : 1;
            // set the end value as segment.points.length - 2 if segment points is greater then 3
            var end = segment.points.length < 3 ? segment.points.length - 1 : segment.points.length - 2;
            start = connector.segments.length === 1 ? start : 0;
            end = connector.segments.length === 1 ? end : segment.points.length - 1;
            for (j = start; j < end; j++) {
                length = Point.distancePoints(segment.points[parseInt(j.toString(), 10)], segment.points[j + 1]);
                orientation = (segment.points[parseInt(j.toString(), 10)].y.toFixed(2) === segment.points[j + 1].y.toFixed(2)) ? 'horizontal' : 'vertical';
                visible = (length >= 50 && segment.allowDrag) ? true : false;
                this.renderOrthogonalThumb((id + '_' + (j + 1)), selector, (((segment.points[parseInt(j.toString(), 10)].x + segment.points[j + 1].x) / 2)), (((segment.points[parseInt(j.toString(), 10)].y + segment.points[j + 1].y) / 2)), canvas, visible, orientation, t, connector, direction);
            }
        }
    };
    /**
     * Method used to render the orthogonal thumb \
     *
     * @returns {void }  Method used to render the orthogonal thumb  .\
     *
     * @param {string} id - Provide the id for the element.
     * @param {DiagramElement } selector - Provide the selector element.
     * @param {  Transforms } x - Provide the x value  .
     * @param { Transforms } y - Provide the y value.
     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.
     * @param { boolean } visible - Provide the visible boolean value.
     * @param { string } orientation - Provide the orientation value.
     * @param { Transforms } t - Provide the Transforms value.
     * @param { ConnectorModel } connector - Provide the connector value.
     * @param { string } direction - Provide the direction of the segment.
     * @private
     */
    DiagramRenderer.prototype.renderOrthogonalThumb = function (id, selector, x, y, canvas, visible, orientation, t, connector, direction) {
        var path;
        var segmentThumbAngle = 0;
        var diagramElement = document.getElementById(this.diagramId);
        var instance = 'ej2_instances';
        var diagram;
        if (diagramElement) {
            diagram = diagramElement["" + instance][0];
        }
        //824805-Support to modify connector segment thumb shape and style based on constraints
        var inheritsegmentThumbShape = (connector.constraints & ConnectorConstraints.InheritSegmentThumbShape);
        var segmentThumbShape = inheritsegmentThumbShape ? diagram.segmentThumbShape : connector.segmentThumbShape;
        //850501-Added below code to modify connector segment thumb size based on constraints
        var inheritSegmentThumbSize = (connector.constraints & ConnectorConstraints.InheritSegmentThumbSize);
        var segmentThumbSize = inheritSegmentThumbSize ? diagram.segmentThumbSize : connector.segmentThumbSize;
        if (orientation === 'horizontal') {
            path = getSegmentThumbShapeHorizontal(segmentThumbShape);
        }
        else {
            path = getSegmentThumbShapeVertical(segmentThumbShape);
        }
        //850501-Added the below code to change the angles of the segmentThumbShape(arrows) based on the direction
        if (segmentThumbShape === 'Arrow' || segmentThumbShape === 'DoubleArrow' || segmentThumbShape === 'OpenArrow') {
            switch (direction) {
                case 'Bottom':
                case 'Right':
                    segmentThumbAngle = 180;
                    break;
                default:
                    segmentThumbAngle = 0;
            }
        }
        else if (segmentThumbShape === 'Fletch' || segmentThumbShape === 'OpenFetch' || segmentThumbShape === 'IndentedArrow' || segmentThumbShape === 'OutdentedArrow') {
            switch (direction) {
                case 'Bottom':
                    segmentThumbAngle = -90;
                    break;
                case 'Top':
                    segmentThumbAngle = 90;
                    break;
                case 'Right':
                    segmentThumbAngle = 180;
                    break;
                default:
                    segmentThumbAngle = 0;
            }
        }
        var options = {
            x: ((x + t.tx) * t.scale) - segmentThumbSize / 2, y: ((y + t.ty) * t.scale) - segmentThumbSize / 2, angle: segmentThumbAngle,
            fill: '#e2e2e2', stroke: 'black', strokeWidth: 1, dashArray: '', data: path,
            width: segmentThumbSize, height: segmentThumbSize, pivotX: 0.5, pivotY: 0.5, opacity: 1, visible: visible, id: id,
            class: 'e-diagram-ortho-segment-handle'
        };
        //850501-Added the below code to adjust size for the segment thumb shape based on the size given
        var absoluteBounds = measurePath(options.data);
        var desiredSize = new Size(options.width, options.height);
        var pathElement = new PathElement();
        options.data = pathElement.updatePath(options.data, absoluteBounds, desiredSize);
        //Bug 914365: Node is not resizable using touch interaction
        //Added below code to update the element if it is already rendered during touch move interaction
        if (this.touchMove) {
            var thumb = document.getElementById(id);
            if (thumb) {
                this.updateSegmentPosition(thumb, options);
            }
            else {
                this.svgRenderer.drawPath(canvas, options, this.diagramId);
            }
        }
        else {
            this.svgRenderer.drawPath(canvas, options, this.diagramId);
        }
    };
    /**
     * Method used to render the pivot line line\
     *
     * @returns {void } Method used to render the pivot line line .\
     *
     * @param {DiagramElement} element - Provide the diagram element value.
     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.
     * @param {  Transforms } transform - Provide the transform value  .
     * @param { SelectorConstraints } selectorConstraints - Provide the selector constraints value.
     * @param { boolean } canMask - Provide the canMask boolean value.
     * @private
     */
    DiagramRenderer.prototype.renderPivotLine = function (element, canvas, transform, selectorConstraints, canMask) {
        var wrapper = element;
        var dashArray = '2,3';
        var visible = (selectorConstraints & SelectorConstraints.Rotate) ? true : false;
        if (canMask) {
            visible = false;
        }
        var options = this.getBaseAttributes(wrapper, transform);
        options.fill = 'None';
        options.stroke = 'black';
        options.strokeWidth = 1;
        options.dashArray = dashArray;
        options.visible = visible;
        var scale = transform.scale;
        options.x *= scale;
        options.y *= scale;
        options.width *= scale;
        options.height *= scale;
        options.id = 'pivotLine';
        options.class = 'e-diagram-pivot-line';
        var startPoint = { x: wrapper.actualSize.width * wrapper.pivot.x * scale, y: -20 };
        var endPoint = { x: wrapper.actualSize.width * wrapper.pivot.x * scale, y: 0 };
        options.startPoint = startPoint;
        options.endPoint = endPoint;
        this.svgRenderer.drawLine(canvas, options);
    };
    /**
     * Method used to render the bezier line for the connector  \
     *
     * @returns {void } Method used to render the bezier line for the connector .\
     *
     * @param {string} id - Provide the id value for the bezier line.
     * @param { DiagramElement } wrapper - Provide the wrapper for the element.
     * @param {  HTMLCanvasElement | SVGElement } canvas - Provide the canvas element  .
     * @param { PointModel } start - Provide the pointmodel value.
     * @param { PointModel } end - Provide the pointmodel value.
     * @param { Transforms } transform - Provide the itransform value .
     * @private
     */
    DiagramRenderer.prototype.renderBezierLine = function (id, wrapper, canvas, start, end, transform) {
        var dashArray = '3,3';
        var options = this.getBaseAttributes(wrapper, transform);
        options.id = id;
        options.stroke = 'black';
        options.strokeWidth = 1;
        options.dashArray = dashArray;
        options.fill = 'None';
        options.class = 'e-diagram-bezier-control-line';
        options.x = 0;
        options.y = 0;
        var scale = transform.scale;
        var x1 = (start.x + transform.tx) * scale;
        var y1 = (start.y + transform.ty) * scale;
        var x2 = (end.x + transform.tx) * scale;
        var y2 = (end.y + transform.ty) * scale;
        var startPoint = { x: x1, y: y1 };
        var endPoint = { x: x2, y: y2 };
        options.startPoint = startPoint;
        options.endPoint = endPoint;
        this.svgRenderer.drawLine(canvas, options);
    };
    /**
     * Method used to render the circular handle for the node element  \
     *
     * @returns {void } Method used to render the circular handle for the node element .\
     *
     * @param {string} id - Provide the id value.
     * @param { DiagramElement } selector - Provide the selector element value.
     * @param { number } cx - Provide cx value  .
     * @param { number } cy - Provide cx value.
     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.
     * @param { boolean } visible - Provide the visible property for the handle .
     * @param { number } enableSelector - Provide the value for the enableSelector .
     * @param { Transforms } t - Provide the transform value .
     * @param { boolean } connected - Provide the connected boolean value .
     * @param { boolean } canMask - Provide the canMask boolean value .
     * @param { Object } ariaLabel - Provide the label properties .
     * @param { number } count - Provide the count value  .
     * @param { string } className - Provide the class name for this element .
     * @param { number } handleSize - Provide the handle size value .
     *
     * @private
     */
    // Feature (EJ2-44346) Provide support to increase the size of the resize thumb
    DiagramRenderer.prototype.renderCircularHandle = function (id, selector, cx, cy, canvas, visible, enableSelector, t, connected, canMask, ariaLabel, count, className, handleSize) {
        var wrapper = selector;
        var newPoint = { x: cx, y: cy };
        if (wrapper.rotateAngle !== 0 || wrapper.parentTransform !== 0) {
            var matrix = identityMatrix();
            rotateMatrix(matrix, wrapper.rotateAngle + wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY);
            newPoint = transformPointByMatrix(matrix, newPoint);
        }
        var options = this.getBaseAttributes(wrapper);
        options.stroke = 'black';
        options.strokeWidth = 1;
        if (count !== undefined) {
            options.id = 'segmentEnd_' + count;
            options.fill = '#e2e2e2';
        }
        else {
            options.fill = connected ? '#8CC63F' : 'white';
        }
        options.cornerRadius = handleSize / 2;
        options.angle = selector.rotateAngle;
        options.id = id;
        options.visible = visible;
        options.class = className;
        options.width = handleSize;
        options.height = handleSize;
        // EJ2-65895 - Added below code to calculate the rect x and y if node pivot is not equal to 0.5
        options.x = (newPoint.x + t.tx) * t.scale;
        options.y = (newPoint.y + t.ty) * t.scale;
        options.x = options.x - options.width / 2;
        options.y = options.y - options.height / 2;
        if (connected) {
            options.class += ' e-connected';
        }
        if (canMask) {
            options.visible = false;
        }
        //Bug 914365: Node is not resizable using touch interaction
        //Added below code to update the element if it is already rendered during touch move interaction
        if (this.touchMove) {
            var handle = document.getElementById(id);
            if (handle) {
                this.updateResizeHandle(handle, options);
            }
            else {
                var parentSvg = this.getParentSvg(selector, 'selector');
                this.svgRenderer.drawRectangle(canvas, options, this.diagramId, true, true, parentSvg, ariaLabel, true, enableSelector);
            }
        }
        else {
            var parentSvg = this.getParentSvg(selector, 'selector');
            this.svgRenderer.drawRectangle(canvas, options, this.diagramId, true, true, parentSvg, ariaLabel, true, enableSelector);
        }
    };
    DiagramRenderer.prototype.updateResizeHandle = function (handle, options) {
        var attr = {
            'id': options.id, 'x': options.x.toString(), 'y': options.y.toString(), 'width': options.width.toString(),
            'height': options.height.toString(), 'visibility': options.visible ? 'visible' : 'hidden',
            'transform': 'rotate(' + options.angle + ','
                + (options.x + options.width / 2) + ',' + (options.y + options.height / 2) + ')',
            'rx': options.cornerRadius || 0, 'ry': options.cornerRadius || 0, 'opacity': options.opacity
        };
        setAttributeSvg(handle, attr);
    };
    //824805-Support to modify bezier connector segmentThumbShape
    /**
     * Method used to render the segment thumb shape for Bezier connector  \
     *
     * @returns {void } Method used to render the segment thumb shape for Bezier connector .\
     *
     * @param {string} id - Provide the id value.
     * @param { DiagramElement } selector - Provide the selector element value.
     * @param { number } cx - Provide cx value  .
     * @param { number } cy - Provide cx value.
     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.
     * @param { boolean } visible - Provide the visible property for the handle .
     * @param { ConnectorModel } connector - Provide the value for the connector .
     * @param { Transforms } t - Provide the transform value .
     * @param { boolean } connected - Provide the connected boolean value .
     * @param { boolean } canMask - Provide the canMask boolean value .
     * @param { number } count - Provide the count value  .
     * @param { string } className - Provide the class name for this element .
     * @param { number } handleSize - Provide the handle size value .
     *
     * @private
     */
    DiagramRenderer.prototype.renderBezierHandle = function (id, selector, cx, cy, canvas, visible, connector, t, connected, canMask, count, className, handleSize) {
        var diagramElement = document.getElementById(this.diagramId);
        var instance = 'ej2_instances';
        var diagram;
        if (diagramElement) {
            diagram = diagramElement["" + instance][0];
        }
        var wrapper = selector;
        var newPoint = { x: cx, y: cy };
        if (wrapper.rotateAngle !== 0 || wrapper.parentTransform !== 0) {
            var matrix = identityMatrix();
            rotateMatrix(matrix, wrapper.rotateAngle + wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY);
            newPoint = transformPointByMatrix(matrix, newPoint);
        }
        var inheritsegmentThumbShape = (connector.constraints & ConnectorConstraints.InheritSegmentThumbShape);
        var segmentThumbShape = inheritsegmentThumbShape ? diagram.segmentThumbShape : connector.segmentThumbShape;
        //850501-Added below code to modify connector segment thumb size based on constraints
        var inheritSegmentThumbSize = (connector.constraints & ConnectorConstraints.InheritSegmentThumbSize);
        var segmentThumbSize = inheritSegmentThumbSize ? diagram.segmentThumbSize : connector.segmentThumbSize;
        var path = getSegmentThumbShapeVertical(segmentThumbShape);
        var options = this.getBaseAttributes(wrapper);
        options.stroke = 'black';
        options.strokeWidth = 1;
        if (count !== undefined) {
            options.id = 'segmentEnd_' + count;
            options.fill = '#e2e2e2';
        }
        else {
            options.fill = connected ? '#8CC63F' : 'white';
        }
        options.angle = selector.rotateAngle;
        options.id = id;
        options.visible = visible;
        options.class = className;
        options.width = segmentThumbSize;
        options.height = segmentThumbSize;
        // EJ2-65895 - Added below code to calculate the rect x and y if node pivot is not equal to 0.5
        options.data = path;
        options.x = ((newPoint.x + t.tx) * t.scale);
        options.y = ((newPoint.y + t.ty) * t.scale);
        options.x = options.x - options.width / 2;
        options.y = options.y - options.height / 2;
        if (connected) {
            options.class += ' e-connected';
        }
        if (canMask) {
            options.visible = false;
        }
        //850501-Added the below code to adjust size for the segment thumb shape based on the size given
        var absoluteBounds = measurePath(options.data);
        var desiredSize = new Size(options.width, options.height);
        var pathElement = new PathElement();
        options.data = pathElement.updatePath(options.data, absoluteBounds, desiredSize);
        //Bug 914365: Node is not resizable using touch interaction
        //Added below code to update the element if it is already rendered during touch move interaction
        if (this.touchMove) {
            var handle = document.getElementById(id);
            if (handle) {
                this.updateSegmentPosition(handle, options);
            }
            else {
                var parentSvg = this.getParentSvg(selector, 'selector');
                this.svgRenderer.drawPath(canvas, options, this.diagramId, true, parentSvg);
            }
        }
        else {
            var parentSvg = this.getParentSvg(selector, 'selector');
            this.svgRenderer.drawPath(canvas, options, this.diagramId, true, parentSvg);
        }
    };
    DiagramRenderer.prototype.updateSegmentPosition = function (handle, options) {
        var attr = {
            'id': options.id, 'transform': 'rotate(' + options.angle + ',' + (options.x + options.width * options.pivotX) + ','
                + (options.y + options.height * options.pivotY) + ')' + 'translate(' + (options.x) + ',' + (options.y) + ')',
            'visibility': options.visible ? 'visible' : 'hidden', 'opacity': options.opacity
        };
        setAttributeSvg(handle, attr);
    };
    /**
     * Method used to render border for the node element  \
     *
     * @returns {void } Method used to render border for the node element .\
     *
     * @param {SelectorModel} selector - Provide the selector model instance.
     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.
     * @param { Transforms } transform - Provide the transform value  .
     * @param { number } enableNode - Provide enableNode boolean value.
     * @param { boolean } isBorderTickness - Provide the thickness value for the node.
     * @param { boolean } isSwimlane - Provide the isSwimlane boolean value .
     * @private
     */
    DiagramRenderer.prototype.renderBorder = function (selector, canvas, transform, enableNode, isBorderTickness, isSwimlane) {
        var wrapper = selector;
        var options = this.getBaseAttributes(wrapper, transform);
        options.x *= transform.scale;
        options.y *= transform.scale;
        options.width *= transform.scale;
        options.height *= transform.scale;
        options.fill = 'transparent';
        options.stroke = '#097F7F';
        options.strokeWidth = 1.2;
        options.gradient = null;
        options.dashArray = '6,3';
        options.class = 'e-diagram-selector';
        if (isSwimlane) {
            options.class += ' e-diagram-lane';
        }
        options.id = 'borderRect';
        options.id = (this.rendererActions & RendererAction.DrawSelectorBorder) ? 'borderRect_symbol' : 'borderRect';
        if (!enableNode) {
            options.class += ' e-disabled';
        }
        if (isBorderTickness) {
            options.class += ' e-thick-border';
        }
        options.cornerRadius = 0;
        var parentSvg = this.getParentSvg(selector, 'selector');
        this.svgRenderer.drawRectangle(canvas, options, this.diagramId, undefined, true, parentSvg);
    };
    /**
     * Method used to render user handle for the node element\
     *
     * @returns {void } Method used to render user handle for the node element .\
     *
     * @param {SelectorModel} selectorItem - Provide the selector model instance.
     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.
     * @param { Transforms } transform - Provide the transform value.
     * @param { HTMLElement } diagramUserHandlelayer - Provide the HTMLElement value.
     * @param { Actions } currentAction - Provide the currentAction value.
     * @param { boolean } inAction - Provide the inAction value.
     * @private
     */
    DiagramRenderer.prototype.renderUserHandler = function (selectorItem, canvas, transform, diagramUserHandlelayer, currentAction, inAction) {
        var wrapper = selectorItem.wrapper;
        var canDraw;
        for (var _i = 0, _a = selectorItem.userHandles; _i < _a.length; _i++) {
            var obj = _a[_i];
            canDraw = true;
            //879279 : Userhandle should be removed on dragging the node/connector in mousemove action
            if ((obj.disableConnectors && selectorItem.connectors.length > 0) ||
                (obj.disableNodes && selectorItem.nodes.length > 0) ||
                (currentAction === 'Drag' && inAction)) {
                canDraw = false;
            }
            var div = document.getElementById(obj.name + '_template_hiddenUserHandle');
            if (div) {
                obj.template = (div.childNodes[0]).cloneNode(true);
            }
            //const newPoint: PointModel;
            var newPoint = getUserHandlePosition(selectorItem, obj, transform);
            newPoint.x = (newPoint.x + transform.tx) * transform.scale;
            newPoint.y = (newPoint.y + transform.ty) * transform.scale;
            if (obj.visible) {
                obj.visible = (selectorItem.constraints & SelectorConstraints.UserHandle) ? true : false;
            }
            if (canDraw) {
                if (obj.pathData) {
                    var data = obj.pathData ? obj.pathData : obj.content;
                    var option = this.getBaseAttributes(wrapper);
                    option.id = obj.name + '_userhandle';
                    option.fill = obj.backgroundColor;
                    option.stroke = obj.borderColor;
                    option.strokeWidth = obj.borderWidth;
                    option.centerX = newPoint.x;
                    option.centerY = newPoint.y;
                    option.radius = obj.size * 0.5;
                    option.class = 'e-diagram-userhandle-circle';
                    option.angle = 0;
                    option.visible = obj.visible;
                    option.opacity = 1;
                    this.svgRenderer.drawCircle(canvas, option, 1, { 'aria-label': obj.name + 'user handle' });
                    var pathPading = 5;
                    var arrayCollection = [];
                    arrayCollection = processPathData(data);
                    arrayCollection = splitArrayCollection(arrayCollection);
                    var pathSize = measurePath(data);
                    //requiredSize/contentSize
                    var scaleX = (obj.size - 0.45 * obj.size) / pathSize.width;
                    var scaleY = (obj.size - 0.45 * obj.size) / pathSize.height;
                    var newData = transformPath(arrayCollection, scaleX, scaleY, true, pathSize.x, pathSize.y, 0, 0);
                    pathSize = measurePath(newData);
                    var options = {
                        x: newPoint.x - pathSize.width / 2,
                        y: newPoint.y - pathSize.height / 2, angle: 0, id: '',
                        class: 'e-diagram-userhandle-path', fill: obj.pathColor,
                        stroke: obj.backgroundColor, strokeWidth: 0.5, dashArray: '', data: newData,
                        width: obj.size - pathPading, height: obj.size - pathPading, pivotX: 0, pivotY: 0, opacity: 1, visible: obj.visible
                    };
                    this.svgRenderer.drawPath(canvas, options, this.diagramId, undefined, undefined, { 'aria-label': obj.name + 'user handle' });
                }
                else if (obj.content) {
                    //const handleContent: DiagramNativeElement;
                    var handleContent = new DiagramNativeElement(obj.name, this.diagramId);
                    handleContent.content = obj.content;
                    handleContent.offsetX = newPoint.x;
                    handleContent.offsetY = newPoint.y;
                    handleContent.id = obj.name + '_shape';
                    handleContent.horizontalAlignment = 'Center';
                    handleContent.verticalAlignment = 'Center';
                    handleContent.visible = obj.visible;
                    handleContent.setOffsetWithRespectToBounds(newPoint.x, newPoint.y, 'Fraction');
                    handleContent.relativeMode = 'Object';
                    handleContent.description = obj.name || 'User handle';
                    handleContent.measure(new Size(obj.size, obj.size));
                    handleContent.arrange(handleContent.desiredSize);
                    this.svgRenderer.drawNativeContent(handleContent, canvas, obj.size, obj.size, this.adornerSvgLayer);
                }
                else if (obj.source) {
                    var element = new ImageElement();
                    var options = this.getBaseAttributes(element, transform);
                    options.width = obj.size;
                    options.height = obj.size;
                    options.x = newPoint.x - (obj.size / 2);
                    options.y = newPoint.y - (obj.size / 2);
                    options.sourceWidth = obj.size;
                    options.sourceHeight = obj.size;
                    options.alignment = element.imageAlign;
                    options.source = obj.source;
                    options.scale = element.imageScale;
                    options.visible = obj.visible;
                    options.description = obj.name || 'User handle';
                    options.id = obj.name + '_';
                    this.renderer.drawImage(canvas, options, this.adornerSvgLayer, false);
                }
                else {
                    //const templateContent: DiagramHtmlElement;
                    var templateContent = new DiagramHtmlElement(obj.name, this.diagramId);
                    templateContent.offsetX = newPoint.x;
                    templateContent.offsetY = newPoint.y;
                    templateContent.id = obj.name + '_shape';
                    templateContent.visible = obj.visible;
                    templateContent.relativeMode = 'Object';
                    templateContent.template = obj.template;
                    templateContent.measure(new Size(obj.size, obj.size));
                    templateContent.arrange(templateContent.desiredSize);
                    this.svgRenderer.drawHTMLContent(templateContent, diagramUserHandlelayer, undefined, true, undefined);
                }
            }
        }
    };
    /**
     * Method used to render rotate thumb of the diagramnode element  \
     *
     * @returns {void } Method used to render rotate thumb of the diagramnode element .\
     *
     * @param {DiagramElement} wrapper - Provide the wrapper  element value.
     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.
     * @param { Transforms } transform - Provide the transform value  .
     * @param { SelectorConstraints } selectorConstraints - Provide the selectorConstraints value.
     * @param { boolean } canMask - Provide the boolean value .
     * @private
     */
    DiagramRenderer.prototype.renderRotateThumb = function (wrapper, canvas, transform, selectorConstraints, canMask) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var element = new PathElement();
        var newPoint;
        var size = new Size();
        size.width = 18;
        size.height = 16;
        var top = wrapper.offsetY - wrapper.actualSize.height * wrapper.pivot.y;
        var left = wrapper.offsetX - wrapper.actualSize.width * wrapper.pivot.x;
        var visible = (selectorConstraints & SelectorConstraints.Rotate) ? true : false;
        if (canMask) {
            visible = false;
        }
        var data = 'M 16.856144362449648 10.238890446662904 L 18.000144362449646 3.437890446662903' +
            'L 15.811144362449646 4.254890446662903 C 14.837144362449646 2.5608904466629028 13.329144362449647 ' +
            ' 1.2598904466629026 11.485144362449645 0.5588904466629026 C 9.375144362449646 - 0.24510955333709716 7.071144362449646 ' +
            ' - 0.18010955333709716 5.010144362449646 0.7438904466629028 C 2.942144362449646 1.6678904466629028 1.365144362449646' +
            ' 3.341890446662903 0.558144362449646 5.452890446662903 C - 0.244855637550354 7.567890446662903 - 0.17985563755035394' +
            ' 9.866890446662904 0.7431443624496461 11.930890446662904 C 1.6681443624496461 13.994890446662904 3.343144362449646' +
            ' 15.575890446662903 5.457144362449647 16.380890446662903 C 6.426144362449647 16.7518904466629 7.450144362449647' +
            ' 16.9348904466629 8.470144362449647 16.9348904466629 C 9.815144362449647 16.9348904466629 11.155144362449647 ' +
            '16.6178904466629 12.367144362449647 15.986890446662901 L 11.351144362449647 14.024890446662901 C 9.767144362449647' +
            ' 14.8468904466629 7.906144362449647 14.953890446662902 6.237144362449647 14.3178904466629 C 4.677144362449647' +
            ' 13.7218904466629 3.444144362449647 12.5558904466629 2.758144362449647 11.028890446662901 C 2.078144362449646 ' +
            '9.501890446662903 2.031144362449646 7.802890446662903 2.622144362449646 6.243890446662903 C 3.216144362449646' +
            ' 4.6798904466629025 4.387144362449646 3.442890446662903 5.914144362449646 2.760890446662903 C 7.437144362449646 ' +
            '2.078890446662903 9.137144362449646 2.0298904466629026 10.700144362449645 2.6258904466629027 C 11.946144362449646 ' +
            '3.100890446662903 12.971144362449646 3.9538904466629026 13.686144362449646 5.049890446662903 L 11.540144362449645 ' +
            '5.850890446662903 L 16.856144362449648 10.238890446662904 Z';
        var pivotX = left + wrapper.pivot.x * wrapper.actualSize.width;
        var pivotY = top;
        pivotX = (pivotX + transform.tx) * transform.scale;
        pivotY = (pivotY + transform.ty) * transform.scale;
        newPoint = { x: pivotX - size.width * 0.5, y: pivotY - 30 - size.height * 0.5 };
        if (wrapper.rotateAngle !== 0 || wrapper.parentTransform !== 0) {
            var matrix = identityMatrix();
            rotateMatrix(matrix, wrapper.rotateAngle + wrapper.parentTransform, (transform.tx + wrapper.offsetX) * transform.scale, (transform.ty + wrapper.offsetY) * transform.scale);
            newPoint = transformPointByMatrix(matrix, newPoint);
        }
        var options = {
            x: newPoint.x,
            y: newPoint.y,
            angle: wrapper.rotateAngle + wrapper.parentTransform,
            fill: '#231f20', stroke: 'black', strokeWidth: 0.5, dashArray: '', data: data,
            width: 20, height: 20, pivotX: 0, pivotY: 0, opacity: 1, visible: visible, id: wrapper.id, class: 'e-diagram-rotate-handle'
        };
        options.id = 'rotateThumb';
        //Bug 914365: Node is not resizable using touch interaction
        //Added below code to update the element if it is already rendered during touch move interaction
        if (this.touchMove) {
            var thumb = document.getElementById('rotateThumb');
            if (thumb) {
                this.updateSegmentPosition(thumb, options);
            }
            else {
                this.svgRenderer.drawPath(canvas, options, this.diagramId, true, undefined, { 'aria-label': 'Thumb to rotate the selected object' });
            }
        }
        else {
            this.svgRenderer.drawPath(canvas, options, this.diagramId, true, undefined, { 'aria-label': 'Thumb to rotate the selected object' });
        }
    };
    /**
     * Method used to render the path element for the diagram  \
     *
     * @returns {void } Method used to render the path element for the diagram .\
     *
     * @param {PathElement} element - Provide the path element of the diagram .
     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.
     * @param { Transforms } transform - Provide the transform value  .
     * @param { SVGSVGElement } parentSvg - Provide the parent SVG element .
     * @param { boolean } fromPalette - Provide the boolean value .
     * @param { boolean } isPreviewNode - Provide the boolean value .
     * @param {object} portCenterPoint - provide the portCenterPoint value.
     * @private
     */
    DiagramRenderer.prototype.renderPathElement = function (element, canvas, transform, parentSvg, fromPalette, isPreviewNode, portCenterPoint) {
        var options = this.getBaseAttributes(element, transform, isPreviewNode);
        options.data = element.absolutePath;
        options.data = element.absolutePath;
        // Feature 826644: Support to add ports to the connector. Added below condition to position port based on its alignment and offset.
        if (element.isPathPort && portCenterPoint) {
            options.x = portCenterPoint[element.id] ? portCenterPoint[element.id].cx : options.x;
            options.y = portCenterPoint[element.id] ? portCenterPoint[element.id].cy : options.y;
            element.bounds.x = options.x;
            element.bounds.y = options.y;
            var diagramElement = document.getElementById(this.diagramId);
            var instance = 'ej2_instances';
            var diagram = void 0;
            if (diagramElement) {
                diagram = diagramElement["" + instance][0];
                if (diagram.eventHandler.currentAction !== 'PortDrag') {
                    element.offsetX = options.x + (element.width / 2);
                    element.offsetY = options.y + (element.height / 2);
                }
            }
        }
        var ariaLabel = element.description ? element.description : element.id;
        if (element.isExport) {
            var pathBounds = element.absoluteBounds;
            //Bug 857388: Connector with bridging is not properly exported.
            //Below we save the arc values of bridge and use it in renderPath method.
            var collection = processPathData(options.data);
            // Get r1 and r2 values for 'A' commands
            var arc = this.findAndStoreArcValues(collection);
            options.arc = arc;
            options.data = updatePath(element, pathBounds, undefined, options);
        }
        this.renderer.drawPath(canvas, options, this.diagramId, undefined, parentSvg, ariaLabel, undefined, this, element);
    };
    // Function to filter 'A' commands and extract r1 and r2 values
    DiagramRenderer.prototype.findAndStoreArcValues = function (arr) {
        var rValues = [];
        arr.forEach(function (obj) {
            if (obj.command === 'A') {
                // Store r1 and r2 values in an object
                var rObj = { r1: obj.r1 / 2, r2: obj.r2 / 2 };
                rValues.push(rObj);
            }
        });
        // Return array of r1 and r2 values
        return rValues;
    };
    /**
     * Method used to update the grid line for the diagram  \
     *
     * @returns {void } Method used to update the grid line for the diagram .\
     *
     * @param {SnapSettingsModel} snapSettings - Provide the snapsetting value of the diagram .
     * @param { SVGSVGElement } gridSvg - Provide the SVG grid  element value.
     * @param { Transforms } t - Provide the transform value  .
     * @param { RulerSettingsModel } rulerSettings - Provide the ruler setting property .
     * @param { RulerModel } hRuler - Provide the horizontal ruler property value .
     * @param { RulerModel } vRuler - Provide the vertical ruler property value .
     * @private
     */
    DiagramRenderer.prototype.renderSvgGridlines = function (snapSettings, gridSvg, t, rulerSettings, hRuler, vRuler) {
        var pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
        var defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        defs.setAttribute('id', this.diagramId + '_grid_pattern_defn');
        if (snapSettings.constraints & SnapConstraints.ShowHorizontalLines ||
            snapSettings.constraints & SnapConstraints.ShowVerticalLines) {
            pattern.setAttribute('id', this.diagramId + '_pattern');
        }
        var hWidth = 0;
        var hHeight = 0;
        var hSegmentwidth = 0;
        var vSegmentwidth = 0;
        var scale = 1;
        var isRulerGrid = false;
        var isLine = snapSettings.gridType === 'Lines';
        var verticalLineIntervals = isLine ?
            snapSettings.verticalGridlines.lineIntervals : snapSettings.verticalGridlines.dotIntervals;
        var horizontalLineIntervals = isLine ?
            snapSettings.horizontalGridlines.lineIntervals : snapSettings.horizontalGridlines.dotIntervals;
        if (rulerSettings.showRulers && rulerSettings.dynamicGrid && hRuler && vRuler) {
            hSegmentwidth = vRuler.updateSegmentWidth(t.scale);
            vSegmentwidth = hRuler.updateSegmentWidth(t.scale);
            snapSettings.horizontalGridlines.scaledIntervals = [hSegmentwidth / hRuler.interval];
            snapSettings.verticalGridlines.scaledIntervals = [vSegmentwidth / vRuler.interval];
            isRulerGrid = true;
        }
        else {
            for (var i = 0; i < verticalLineIntervals.length; i = i + 1) {
                hWidth += verticalLineIntervals[parseInt(i.toString(), 10)];
            }
            for (var i = 0; i < horizontalLineIntervals.length; i = i + 1) {
                hHeight += horizontalLineIntervals[parseInt(i.toString(), 10)];
            }
            scale = this.scaleSnapInterval(snapSettings, t.scale);
        }
        hWidth = isRulerGrid ? vSegmentwidth : hWidth * scale;
        hHeight = isRulerGrid ? hSegmentwidth : hHeight * scale;
        var attr = {
            id: this.diagramId + '_pattern', x: 0, y: 0, width: hWidth,
            height: hHeight, patternUnits: 'userSpaceOnUse'
        };
        setAttributeSvg(pattern, attr);
        this.horizontalSvgGridlines(pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, vRuler, isRulerGrid, isLine, horizontalLineIntervals);
        this.verticalSvgGridlines(pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, hRuler, isRulerGrid, isLine, verticalLineIntervals);
        defs.appendChild(pattern);
        gridSvg.appendChild(defs);
    };
    DiagramRenderer.prototype.horizontalSvgGridlines = function (pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, vRuler, isRulerGrid, isLine, intervals) {
        var space = 0;
        var dashArray = [];
        var hLine;
        if (snapSettings.constraints & SnapConstraints.ShowHorizontalLines) {
            if (snapSettings.horizontalGridlines.lineDashArray) {
                dashArray = this.renderer.parseDashArray(snapSettings.horizontalGridlines.lineDashArray);
            }
            if (rulerSettings.showRulers && rulerSettings.dynamicGrid && vRuler) {
                intervals = this.updateLineIntervals(intervals, rulerSettings, vRuler, hHeight, isLine);
            }
            intervals = getInterval(intervals, isLine);
            for (var i = 0; i < intervals.length; i = i + 2) {
                space = getSpaceValue(intervals, isLine, i, space);
                var spaceY = 0;
                hLine = document.createElementNS('http://www.w3.org/2000/svg', isLine ? 'path' : 'circle');
                var attr = void 0;
                var d = isLine ? space + intervals[parseInt(i.toString(), 10)] / 2 : space;
                d = isRulerGrid ? d : d * scale;
                if (isLine) {
                    if (dashArray.toString() === '') {
                        attr = {
                            'stroke-width': intervals[parseInt(i.toString(), 10)],
                            'd': 'M0,' + (d) + ' L' + hWidth + ',' + (d) + ' Z',
                            'class': intervals[parseInt(i.toString(), 10)] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',
                            'stroke': snapSettings.horizontalGridlines.lineColor
                        };
                    }
                    else {
                        attr = {
                            'stroke-width': intervals[parseInt(i.toString(), 10)], 'stroke': snapSettings.horizontalGridlines.lineColor,
                            'd': 'M0,' + (d) + ' L' + hWidth + ',' + (d) + ' Z',
                            'class': intervals[parseInt(i.toString(), 10)] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',
                            'dashArray': dashArray.toString()
                        };
                    }
                    setAttributeSvg(hLine, attr);
                    pattern.appendChild(hLine);
                    space += intervals[i + 1] + intervals[parseInt(i.toString(), 10)];
                }
                else {
                    this.renderDotGrid(i, pattern, snapSettings, spaceY, d, scale, true);
                    space += intervals[parseInt(i.toString(), 10)];
                }
            }
        }
    };
    DiagramRenderer.prototype.renderDotGrid = function (i, pattern, snapSettings, spacey, d, scale, isHorizontal) {
        var intervals = !isHorizontal ?
            snapSettings.horizontalGridlines.dotIntervals : snapSettings.verticalGridlines.dotIntervals;
        intervals = getInterval(intervals, false);
        var r;
        var hLine;
        //const doubleRadius: boolean;
        var dy;
        var attr;
        for (var j = 1; j < intervals.length; j = j + 2) {
            r = j === intervals.length - 1 ? intervals[0] : intervals[j - 1];
            hLine = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            dy = spacey;
            dy = dy * scale;
            attr = {
                'cx': isHorizontal ? dy : d, 'cy': isHorizontal ? d : dy, 'fill': snapSettings.horizontalGridlines.lineColor, 'r': r
            };
            setAttributeSvg(hLine, attr);
            pattern.appendChild(hLine);
            spacey += intervals[parseInt(j.toString(), 10)] + intervals[j - 1];
        }
    };
    DiagramRenderer.prototype.verticalSvgGridlines = function (pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, hRuler, isRulerGrid, isLine, intervals) {
        var space = 0;
        var dashArray = [];
        var vLine;
        if (snapSettings.constraints & SnapConstraints.ShowVerticalLines) {
            if (snapSettings.verticalGridlines.lineDashArray) {
                dashArray = this.renderer.parseDashArray(snapSettings.verticalGridlines.lineDashArray);
            }
            if (rulerSettings.showRulers && rulerSettings.dynamicGrid && hRuler) {
                intervals = this.updateLineIntervals(intervals, rulerSettings, hRuler, hWidth, isLine);
            }
            var spaceY = 0;
            intervals = getInterval(intervals, isLine);
            for (var i = 0; i < intervals.length; i = i + 2) {
                space = getSpaceValue(intervals, isLine, i, space);
                var d = isLine ? space + intervals[parseInt(i.toString(), 10)] / 2 : space;
                d = isRulerGrid ? d : d * scale;
                vLine = document.createElementNS('http://www.w3.org/2000/svg', isLine ? 'path' : 'circle');
                var attr = void 0;
                if (isLine) {
                    if (dashArray.toString() === '') {
                        attr = {
                            'stroke-width': intervals[parseInt(i.toString(), 10)],
                            'd': 'M' + (d) + ',0 L' + (d) + ',' + hHeight + ' Z',
                            'class': intervals[parseInt(i.toString(), 10)] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',
                            'stroke': snapSettings.verticalGridlines.lineColor
                        };
                    }
                    else {
                        attr = {
                            'stroke-width': intervals[parseInt(i.toString(), 10)],
                            'class': intervals[parseInt(i.toString(), 10)] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',
                            'stroke': snapSettings.verticalGridlines.lineColor,
                            'd': 'M' + (d) + ',0 L' + (d) + ',' + hHeight + ' Z',
                            'dashArray': dashArray.toString()
                        };
                    }
                    setAttributeSvg(vLine, attr);
                    pattern.appendChild(vLine);
                    space += intervals[i + 1] + intervals[parseInt(i.toString(), 10)];
                }
                else {
                    this.renderDotGrid(i, pattern, snapSettings, spaceY, d, scale, false);
                    space += intervals[parseInt(i.toString(), 10)];
                }
            }
        }
    };
    /**
     * Method used to update the grid line for the diagram  \
     *
     * @returns {void } Method used to update the grid line for the diagram .\
     *
     * @param {SnapSettingsModel} snapSettings - Provide the snapsetting value of the diagram .
     * @param { SVGSVGElement } svgGrid - Provide the SVG grid  element value.
     * @param { Transforms } transform - Provide the transform value  .
     * @param { RulerSettingsModel } rulerSettings - Provide the ruler setting property .
     * @param { RulerModel } hRuler - Provide the horizontal ruler property value .
     * @param { RulerModel } vRuler - Provide the vertical ruler property value .
     * @private
     */
    DiagramRenderer.prototype.updateGrid = function (snapSettings, svgGrid, transform, rulerSettings, hRuler, vRuler) {
        var grid = svgGrid.getElementById(this.diagramId + '_grid_rect');
        //let i: number;
        var isRulerGrid = false;
        if (grid) {
            var pattern = svgGrid.getElementById(this.diagramId + '_pattern');
            if (pattern) {
                pattern.parentNode.removeChild(pattern);
            }
            var hSegmentwidth = 0;
            var vSegmentwidth = 0;
            var scale = 1;
            var isLine = snapSettings.gridType === 'Lines';
            var verticalLineIntervals = isLine ?
                snapSettings.verticalGridlines.lineIntervals : snapSettings.verticalGridlines.dotIntervals;
            var horizontalLineIntervals = isLine ?
                snapSettings.horizontalGridlines.lineIntervals : snapSettings.horizontalGridlines.dotIntervals;
            if (rulerSettings.showRulers && rulerSettings.dynamicGrid && vRuler && hRuler) {
                hSegmentwidth = vRuler.updateSegmentWidth(transform.scale);
                vSegmentwidth = hRuler.updateSegmentWidth(transform.scale);
                isRulerGrid = true;
                snapSettings.horizontalGridlines.scaledIntervals = [hSegmentwidth / hRuler.interval];
                snapSettings.verticalGridlines.scaledIntervals = [vSegmentwidth / vRuler.interval];
            }
            else {
                scale = this.scaleSnapInterval(snapSettings, transform.scale);
            }
            var height = 0;
            for (var j = 0; j < horizontalLineIntervals.length; j = j + 1) {
                height += horizontalLineIntervals[parseInt(j.toString(), 10)];
            }
            var width = 0;
            for (var j = 0; j < verticalLineIntervals.length; j = j + 1) {
                width += verticalLineIntervals[parseInt(j.toString(), 10)];
            }
            var attr = {
                x: -transform.tx * transform.scale,
                y: -transform.ty * transform.scale
            };
            setAttributeSvg(grid, attr);
            width = isRulerGrid ? vSegmentwidth : width * scale;
            height = isRulerGrid ? hSegmentwidth : height * scale;
            attr = {
                id: this.diagramId + '_pattern', x: 0, y: 0, width: width,
                height: height, patternUnits: 'userSpaceOnUse'
            };
            pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
            setAttributeSvg(pattern, attr);
            this.horizontalSvgGridlines(pattern, width, height, scale, snapSettings, rulerSettings, vRuler, isRulerGrid, isLine, horizontalLineIntervals);
            this.verticalSvgGridlines(pattern, width, height, scale, snapSettings, rulerSettings, hRuler, isRulerGrid, isLine, verticalLineIntervals);
            var defs = svgGrid.getElementById(this.diagramId + '_grid_pattern_defn');
            if (defs) {
                defs.appendChild(pattern);
            }
        }
    };
    DiagramRenderer.prototype.updateLineIntervals = function (intervals, rulerSettings, ruler, segmentWidth, isLine) {
        var newInterval = [];
        var tickInterval = segmentWidth / ruler.interval;
        var interval = isLine ? ruler.interval : ruler.interval + 1;
        for (var i = 0; i < interval * 2; i++) {
            if (i % 2 === 0) {
                newInterval[parseInt(i.toString(), 10)] = isLine ? ((i === 0) ? 1.25 : 0.25) : 0;
            }
            else {
                newInterval[parseInt(i.toString(), 10)] = isLine ? (tickInterval - newInterval[i - 1]) : tickInterval;
            }
        }
        return newInterval;
    };
    DiagramRenderer.prototype.scaleSnapInterval = function (snapSettings, scale) {
        if (scale >= 2) {
            while (scale >= 2) {
                scale /= 2;
            }
        }
        else if (scale <= 0.5) {
            while (scale <= 0.5) {
                scale *= 2;
            }
        }
        var i;
        snapSettings.horizontalGridlines.scaledIntervals = snapSettings.horizontalGridlines.snapIntervals;
        snapSettings.verticalGridlines.scaledIntervals = snapSettings.verticalGridlines.snapIntervals;
        if (scale !== 1) {
            var gridlines = snapSettings.horizontalGridlines;
            gridlines.scaledIntervals = [];
            for (i = 0; i < gridlines.snapIntervals.length; i++) {
                gridlines.scaledIntervals[parseInt(i.toString(), 10)] = gridlines.snapIntervals[parseInt(i.toString(), 10)] * scale;
            }
            gridlines = snapSettings.verticalGridlines;
            gridlines.scaledIntervals = [];
            for (i = 0; i < gridlines.snapIntervals.length; i++) {
                gridlines.scaledIntervals[parseInt(i.toString(), 10)] = gridlines.snapIntervals[parseInt(i.toString(), 10)] * scale;
            }
        }
        return scale;
    };
    /**
     * Method used to render the text element  \
     *
     * @returns {void }Method used to render the text element  .\
     *
     * @param {TextElement} element - Provide the text element .
     * @param { HTMLCanvasElement | SVGElement} canvas - Provide the canvas element .
     * @param { Transforms } transform - Provide the transform value  .
     * @param { SVGSVGElement } parentSvg - Provide the SVG layer element .
     * @param { boolean } fromPalette - Provide the boolean value .
     * @param { object } centerPoint - Provide the center point value .
     * @private
     */
    DiagramRenderer.prototype.renderTextElement = function (element, canvas, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    transform, parentSvg, fromPalette, centerPoint) {
        var options = this.getBaseAttributes(element, transform);
        if (centerPoint) {
            //Bug 827039: Bezier annotation content alignment is not working properly.
            // Removed -2 cx-2 and cy-2 from the below two line to resolve the alignment issue.
            options.x = centerPoint[element.id] ? centerPoint[element.id].cx : options.x;
            options.y = centerPoint[element.id] ? centerPoint[element.id].cy : options.y;
            // (EJ2-56874) - Set the calculated x and y position to the bezier connector annotation's(text element) bounds x,y position
            element.bounds.x = options.x;
            element.bounds.y = options.y;
            // (EJ2-58802) - Calculate the center point x and y with the element export scale value if element is in export mode
            if (element.isExport) {
                options.x = options.x * Math.min(element.exportScaleValue.x || element.exportScaleValue.y);
                options.y = options.y * Math.min(element.exportScaleValue.x || element.exportScaleValue.y);
            }
        }
        options.cornerRadius = 0;
        options.whiteSpace = whiteSpaceToString(element.style.whiteSpace, element.style.textWrapping);
        options.content = element.content;
        options.breakWord = wordBreakToString(element.style.textWrapping);
        options.textAlign = textAlignToString(element.style.textAlign);
        options.color = element.style.color;
        options.italic = element.style.italic;
        options.bold = element.style.bold;
        options.fontSize = element.style.fontSize;
        options.fontFamily = element.style.fontFamily;
        options.textOverflow = element.style.textOverflow;
        options.textWrapping = element.style.textWrapping;
        options.textDecoration = element.style.textDecoration;
        options.doWrap = element.doWrap;
        options.wrapBounds = element.wrapBounds;
        options.childNodes = element.childNodes;
        options.isHorizontalLane = element.isLaneOrientation;
        options.id = element.id ? element.id : randomId();
        if (element.isLaneOrientation) {
            options.parentOffsetX = this.groupElement.offsetX;
            options.parentOffsetY = this.groupElement.offsetY;
            options.parentWidth = this.groupElement.actualSize.width;
            options.parentHeight = this.groupElement.actualSize.height;
        }
        options.dashArray = '';
        options.strokeWidth = 0;
        options.fill = element.style.fill;
        var ariaLabel = element.description ? element.description : element.content ? element.content : element.id;
        if ((element.style.textWrapping === 'Wrap' || element.style.textWrapping === 'WrapWithOverflow') &&
            this.groupElement && options.height > this.groupElement.actualSize.height &&
            (element.style.textOverflow === 'Clip' || element.style.textOverflow === 'Ellipsis')) {
            options.y = options.y + (options.height - this.groupElement.actualSize.height) / 2;
        }
        this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);
        this.renderer.drawText(canvas, options, parentSvg, ariaLabel, this.diagramId, (element.isExport && Math.min(element.exportScaleValue.x || element.exportScaleValue.y)), this, element);
        if (this.isSvgMode) {
            element.doWrap = false;
        }
    };
    DiagramRenderer.prototype.renderNativeElement = function (element, canvas, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    transform, parentSvg, fromPalette) {
        var templateWidth;
        var templateHeight;
        var nativeSvg = this.getParentSvg(element, undefined, canvas) || parentSvg;
        var nativeLayer = this.getParentElement(element, canvas, nativeSvg).g || canvas;
        var options = this.getBaseAttributes(element, transform);
        options.fill = 'transparent';
        options.cornerRadius = element.cornerRadius;
        options.stroke = 'transparent';
        this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);
        switch (element.scale) {
            case 'None':
                templateWidth = element.contentSize.width;
                templateHeight = element.contentSize.height;
                break;
            case 'Stretch':
                templateWidth = element.actualSize.width;
                templateHeight = element.actualSize.height;
                break;
            case 'Meet':
                if (element.actualSize.width <= element.actualSize.height) {
                    templateWidth = templateHeight = element.actualSize.width;
                }
                else {
                    templateWidth = templateHeight = element.actualSize.height;
                }
                break;
            case 'Slice':
                if (element.actualSize.width >= element.actualSize.height) {
                    templateWidth = templateHeight = element.actualSize.width;
                }
                else {
                    templateWidth = templateHeight = element.actualSize.height;
                }
                break;
        }
        if (this.svgRenderer) {
            this.svgRenderer.drawNativeContent(element, nativeLayer, templateHeight, templateWidth, nativeSvg);
        }
    };
    DiagramRenderer.prototype.renderHTMLElement = function (element, canvas, htmlLayer, transform, parentSvg, fromPalette, indexValue) {
        var options = this.getBaseAttributes(element, transform);
        options.fill = 'transparent';
        options.cornerRadius = element.cornerRadius;
        options.stroke = 'transparent';
        this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);
        if (this.svgRenderer) {
            this.svgRenderer.drawHTMLContent(element, htmlLayer.children[0], transform, isDiagramChild(htmlLayer), indexValue);
        }
    };
    /**
     * Method used to render the image element  \
     *
     * @returns {void }Method used to render the image element  .\
     *
     * @param {ImageElement} element - Provide the image element .
     * @param { HTMLCanvasElement | SVGElement} canvas - Provide the canvas element .
     * @param { Transforms } transform - Provide the transform value  .
     * @param { SVGSVGElement } parentSvg - Provide the SVG layer element .
     * @param { boolean } fromPalette - Provide the boolean value .
     * @private
     */
    DiagramRenderer.prototype.renderImageElement = function (element, canvas, transform, parentSvg, fromPalette) {
        var options = this.getBaseAttributes(element, transform);
        options.cornerRadius = 0;
        this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);
        // let sx: number; let sy: number;
        var imageWidth;
        var imageHeight;
        var sourceWidth;
        var sourceHeight;
        var contentWidth = element.contentSize.width;
        var contentHeight = element.contentSize.height;
        var widthRatio = options.width / contentWidth;
        var heightRatio = options.height / contentHeight;
        var ratio;
        if (element.stretch === 'Stretch') {
            // 909174: Image node is not exported properly Issue Fix
            ratio = Math.min(widthRatio, heightRatio);
            imageWidth = contentWidth * ratio;
            imageHeight = contentHeight * ratio;
        }
        else {
            switch (element.stretch) {
                case 'Meet':
                    ratio = Math.min(widthRatio, heightRatio);
                    imageWidth = contentWidth * ratio;
                    imageHeight = contentHeight * ratio;
                    options.x += Math.abs(options.width - imageWidth) / 2;
                    options.y += Math.abs(options.height - imageHeight) / 2;
                    break;
                case 'Slice':
                    ratio = Math.max(widthRatio, heightRatio);
                    imageWidth = contentWidth * ratio;
                    imageHeight = contentHeight * ratio;
                    sourceWidth = options.width / imageWidth * contentWidth;
                    sourceHeight = options.height / imageHeight * contentHeight;
                    break;
                case 'None':
                    imageWidth = contentWidth;
                    imageHeight = contentHeight;
                    break;
            }
        }
        options.width = imageWidth;
        options.height = imageHeight;
        //Commented for code coverage
        //(options as ImageAttributes).sourceX = sx;
        //(options as ImageAttributes).sourceY = sy;
        options.sourceWidth = sourceWidth;
        options.sourceHeight = sourceHeight;
        options.source = element.source;
        options.alignment = element.imageAlign;
        options.scale = element.imageScale;
        options.description = element.description ? element.description : element.id;
        this.renderer.drawImage(canvas, options, parentSvg, fromPalette, this, element);
    };
    /**
     * Method used to render the container  \
     *
     * @returns {void} Method used to render the container .\
     *
     * @param {Container} group - Provide the container .
     * @param { HTMLCanvasElement | SVGElement} canvas - Provide the canvas element .
     * @param { HTMLElement } htmlLayer - Provide the html layer element  .
     * @param { Transforms } transform - Provide the transform value .
     * @param { SVGSVGElement } parentSvg - Provide the SVG layer element .
     * @param { boolean } createParent - Provide the boolean value .
     * @param { boolean } fromPalette - Provide the boolean value  .
     * @param { number } indexValue - Provide the indexValue value .
     * @param { boolean } isPreviewNode - Provide the boolean value .
     * @param { object } centerPoint - Provide the centerPoint value .
     * @param {object} portCenterPoint - provide the portCenterPoint value.
     * @private
     */
    DiagramRenderer.prototype.renderContainer = function (group, canvas, htmlLayer, transform, parentSvg, createParent, fromPalette, indexValue, isPreviewNode, centerPoint, portCenterPoint) {
        var svgParent = { svg: parentSvg, g: canvas };
        var diagramElement = document.getElementById(this.diagramId);
        var instance = 'ej2_instances';
        var diagram;
        if (diagramElement) {
            diagram = diagramElement["" + instance][0];
        }
        if (this.diagramId) {
            parentSvg = this.getParentSvg(group) || parentSvg;
            if (this.isSvgMode) {
                //const groupElement: HTMLCanvasElement | SVGElement;
                // eslint-disable-next-line max-len
                var groupElement = this.getParentElement(group, canvas, parentSvg, indexValue).g || canvas;
                parentSvg = this.getParentSvg(this.hasNativeParent(group.children)) || parentSvg;
                var svgNativeParent = this.getParentElement(this.hasNativeParent(group.children), groupElement, parentSvg, indexValue);
                svgParent.svg = svgNativeParent.svg || parentSvg;
                svgParent.g = svgNativeParent.g || groupElement;
                if (createParent) {
                    if (parentSvg) {
                        if (!parentSvg.getElementById(svgParent.g.id)) {
                            canvas.appendChild(svgParent.g);
                        }
                    }
                    canvas = svgParent.g;
                }
                else {
                    canvas = svgParent.g;
                }
            }
        }
        this.renderRect(group, canvas, transform, parentSvg);
        this.groupElement = group;
        if (group.hasChildren()) {
            var parentG = void 0;
            var svgParent_1;
            for (var _i = 0, _a = group.children; _i < _a.length; _i++) {
                var child = _a[_i];
                this.groupElement = group;
                parentSvg = this.getParentSvg(this.hasNativeParent(group.children) || child) || parentSvg;
                if (this.isSvgMode) {
                    svgParent_1 = this.getParentElement(this.hasNativeParent(group.children) || child, canvas, parentSvg);
                    parentG = svgParent_1.g || canvas;
                    if (svgParent_1.svg) {
                        parentSvg = svgParent_1.svg;
                    }
                }
                if (!this.isSvgMode) {
                    if (child.relativeMode === 'Object') {
                        child.flip = group.flip;
                        //To update the compensation and adhoc child flip in print and export.
                        if (child.id && (child.id.includes('_0_compensation') || child.id.includes('_0_adhoc'))) {
                            if (group.children[0].flip) {
                                child.flip = group.children[0].flip;
                            }
                        }
                    }
                }
                var parentGElement = parentG;
                this.renderElement(child, parentG || canvas, htmlLayer, transform, parentSvg, true, fromPalette, indexValue, isPreviewNode, centerPoint, portCenterPoint);
                if (group.children && group.children[0] instanceof DiagramNativeElement) {
                    if (child instanceof TextElement || (child.elementActions & ElementAction.ElementIsPort)) {
                        parentGElement = document.getElementById(child.id + '_groupElement');
                    }
                }
                if (child instanceof TextElement && parentGElement) {
                    this.renderFlipTextElement(group, parentGElement, child, child.flip, child.flipMode);
                }
            }
            var selectedNode = void 0;
            if (diagram && diagram.selectedItems && diagram.selectedItems.nodes
                && diagram.selectedItems.nodes.length > 0) {
                selectedNode = diagram.selectedItems.nodes[0];
            }
            var innerNodeContent = void 0;
            var isNodeSelected = false;
            var Node_1;
            var objId = group.id.includes('group_container')
                ? group.id.split('group_container')[0]
                : group.id;
            if (diagram && diagram.selectedItems) {
                Node_1 = diagram.getObject(objId);
            }
            selectedNode = Node_1;
            if (selectedNode && selectedNode.flipMode) {
                isNodeSelected = true;
            }
            var containerId = '';
            if (selectedNode) {
                containerId = selectedNode.children ? selectedNode.id + 'group_container' : selectedNode.id + '_content_groupElement';
            }
            if (diagram instanceof Diagram && diagram.nameTable["" + objId] && diagram.nameTable["" + objId].propName !== 'connectors') {
                if (isNodeSelected && selectedNode) {
                    if (group.children && group.children[0] instanceof DiagramNativeElement) {
                        innerNodeContent = document.getElementById(selectedNode.id + '_content_inner_native_element');
                    }
                    else if (group.children && group.children[0] instanceof DiagramHtmlElement) {
                        innerNodeContent = document.getElementById(selectedNode.id + '_content_html_element');
                        if (!innerNodeContent) {
                            innerNodeContent = document.getElementById(containerId);
                        }
                    }
                    else {
                        innerNodeContent = document.getElementById(containerId);
                    }
                    this.renderFlipElement(group, innerNodeContent, group.flip);
                }
            }
        }
    };
    /**
     * Method used to flip the text element   \
     *
     * @returns {void} Method used to flip the text element.\
     *
     * @param {DiagramElement} element - Provide the node element.
     * @param { HTMLCanvasElement | SVGElement} canvas - Provide the text canvas element.
     * @param { DiagramElement } textElement - Provide the text element.
     * @param { FlipDirection } flip - Provide the node flip direction.
     * @param { FlipMode } flipMode - Provide the node flipMode.
     * @param { boolean } isCanvasMode - Provide the isCanvas mode.
     */
    DiagramRenderer.prototype.renderFlipTextElement = function (element, canvas, textElement, flip, flipMode, isCanvasMode) {
        var attr = {};
        var scaleX = 1;
        var scaleY = 1;
        var posX = 0;
        var posY = 0;
        var offsetX = 0;
        var offsetY = 0;
        if (flip !== FlipDirection.None) {
            var rotateAngle = element.rotateAngle;
            if (element.rotateAngle === 0 && element.id.includes('group_container')) {
                rotateAngle = element.parentTransform;
            }
            // Fetch annotation offset
            var textPos = textElement.getAbsolutePosition(textElement.desiredSize);
            if (!textPos) {
                var size = textElement.desiredSize;
                textPos = { x: 0.5 * size.width, y: 0.5 * size.height };
            }
            if (textPos && textElement.content !== '') {
                // Inverting and translating Annotation
                if (flipMode === 'All' || flipMode === 'LabelAndLabelText') {
                    if (flip === FlipDirection.Horizontal || flip === FlipDirection.Both) {
                        posX = element.bounds.center.x;
                        offsetX = -element.bounds.center.x;
                        scaleX = -1;
                    }
                    if (flip === FlipDirection.Vertical || flip === FlipDirection.Both) {
                        posY = element.bounds.center.y;
                        offsetY = -element.bounds.center.y;
                        scaleY = -1;
                    }
                    if (flip === FlipDirection.Horizontal || flip === FlipDirection.Vertical) {
                        var angle = Math.sin(rotateAngle * Math.PI / 180);
                        //918299 - Issue with Polygon Shape Node Rotation After Grouping and Flipping
                        if (textPos.y !== undefined && !isNaN(textPos.y)) {
                            var textPosY = textPos.y / textElement.desiredSize.height;
                            if (!isNaN(textPosY)) {
                                offsetX += -element.desiredSize.height * angle * (-2 * textPosY + 1);
                            }
                        }
                        if (textPos.x !== undefined && !isNaN(textPos.x)) {
                            var textPosX = textPos.x / textElement.desiredSize.width;
                            if (!isNaN(textPosX)) {
                                offsetY += element.desiredSize.width * angle * (-2 * textPosX + 1);
                            }
                        }
                    }
                    attr = {
                        'transform': 'translate(' + posX + ',' + posY + ') scale(' + scaleX + ','
                            + scaleY + ') translate(' + offsetX + ',' + offsetY + ')'
                    };
                }
                // Inverting Annotation without flipping position
                else if (flipMode === 'LabelText' || flipMode === 'PortAndLabelText') {
                    if (flip === FlipDirection.Horizontal || flip === FlipDirection.Both) {
                        posX = textElement.offsetX;
                        offsetX = -textElement.offsetX;
                        scaleX = -1;
                    }
                    if (flip === FlipDirection.Vertical || flip === FlipDirection.Both) {
                        posY = textElement.offsetY;
                        offsetY = -textElement.offsetY;
                        scaleY = -1;
                    }
                    attr = {
                        'transform': 'translate(' + posX + ',' + posY + ') scale(' + scaleX + ','
                            + scaleY + ') translate(' + offsetX + ',' + offsetY + ')'
                    };
                }
                // Translating Annotation
                else if (flipMode === 'PortAndLabel' || flipMode === 'Label') {
                    var labelPosX = 0;
                    var labelPosY = 0;
                    var labelPos = this.flipLabel(element, textElement, textPos, flip);
                    labelPosX = labelPos.x - textElement.offsetX;
                    labelPosY = labelPos.y - textElement.offsetY;
                    attr = { 'transform': 'translate(' + labelPosX + ',' + labelPosY + ')' };
                }
            }
        }
        else {
            attr = {
                'transform': 'translate(' + 0 + ',' + 0 + ')'
            };
        }
        if (!isCanvasMode) {
            this.setFlipAttributes(element, canvas, attr, scaleX, scaleY, false);
            return {};
        }
        else {
            return attr;
        }
    };
    DiagramRenderer.prototype.renderFlipElement = function (element, canvas, flip, isCanvasMode) {
        var attr = {};
        var scaleX = 1;
        var scaleY = 1;
        var posX = 0;
        var posY = 0;
        var offsetX = 0;
        var offsetY = 0;
        if (flip !== FlipDirection.None) {
            if (flip === FlipDirection.Horizontal || flip === FlipDirection.Both) {
                posX = element.bounds.center.x;
                offsetX = -element.bounds.center.x;
                scaleX = -1;
            }
            if (flip === FlipDirection.Vertical || flip === FlipDirection.Both) {
                posY = element.bounds.center.y;
                offsetY = -element.bounds.center.y;
                scaleY = -1;
            }
            attr = {
                'transform': 'translate(' + posX + ',' + posY + ') scale(' + scaleX + ','
                    + scaleY + ') translate(' + offsetX + ',' + offsetY + ')'
            };
        }
        else {
            attr = {
                'transform': 'translate(' + 0 + ',' + 0 + ')'
            };
        }
        var isHtml = element && element.children &&
            element.children.length && (element.children[0] instanceof DiagramHtmlElement);
        if (!isCanvasMode) {
            this.setFlipAttributes(element, canvas, attr, scaleX, scaleY, isHtml);
            return {};
        }
        else {
            return attr;
        }
    };
    DiagramRenderer.prototype.setFlipAttributes = function (element, canvas, attr, scaleX, scaleY, isHtml) {
        if (attr) {
            if (isHtml) {
                var id = canvas.id.split('_preview');
                var layer = document.getElementById(id[0] + '_html_div') ||
                    (getHTMLLayer(this.diagramId).children[0]);
                canvas = layer.querySelector(('#' + element.id + '_content_html_element'));
                var flipAngle = (element.flip === FlipDirection.None || element.flip === FlipDirection.Both) ? 1 : -1;
                if (canvas) {
                    canvas.style.transform =
                        'scale(' + scaleX + ',' + scaleY + ')' + 'rotate(' + ((flipAngle * element.rotateAngle) + element.parentTransform) + 'deg)';
                }
            }
            else {
                setAttributeSvg(canvas, attr);
            }
        }
    };
    /**
     * Calculates Flipped Position of textElement considering annotation offset
     *
     * @returns {PointModel} - flipped point of textElement current point
     *
     * @param {NodeModel} element - Provide node wrapper element containing the text element.
     * @param {TextElement} textElement - Provide the textElememt to flip.
     * @param {PointModel} labelPos - Provide the annotation offset.
     * @param {FlipDirection} flip - Provide the node flip direction.
     */
    DiagramRenderer.prototype.flipLabel = function (element, textElement, labelPos, flip) {
        var flippedOffset;
        if (flip !== FlipDirection.None) {
            var flippedOffsetX = void 0;
            var flippedOffsetY = void 0;
            // Node's topLeft Position
            var topLeft = {
                x: element.offsetX - element.desiredSize.width / 2,
                y: element.offsetY - element.desiredSize.height / 2
            };
            flippedOffsetX = topLeft.x + (element.desiredSize.width * ((labelPos.x / textElement.desiredSize.width)));
            flippedOffsetY = topLeft.y + (element.desiredSize.height * ((labelPos.y / textElement.desiredSize.height)));
            if (flip === FlipDirection.Both || flip === FlipDirection.Horizontal) {
                flippedOffsetX = topLeft.x + (element.desiredSize.width * (1 - (labelPos.x / textElement.desiredSize.width)));
            }
            if (flip === FlipDirection.Both || flip === FlipDirection.Vertical) {
                flippedOffsetY = topLeft.y + (element.desiredSize.height * (1 - (labelPos.y / textElement.desiredSize.height)));
            }
            // Flipped Position
            flippedOffset = { x: flippedOffsetX, y: flippedOffsetY };
            // FlippedPoint after rotating, with node offset as its pivot
            flippedOffset = rotatePoint(element.rotateAngle + element.parentTransform, element.offsetX, element.offsetY, flippedOffset);
        }
        return flippedOffset;
    };
    /**
     * Method used to check the native parent  \
     *
     * @returns {void} Method used to check the native parent .\
     *
     * @param { DiagramElement[]} children - Provide the diagram element .
     * @param { number} count - Provide the count value .
     * @private
     */
    DiagramRenderer.prototype.hasNativeParent = function (children, count) {
        if (children && children.length > 0 && (count || 0 < 3)) {
            var child = children[0];
            if (child instanceof DiagramNativeElement) {
                return child;
            }
            else if (child.children && child.children.length) {
                this.hasNativeParent(child.children, count++ || 0);
            }
        }
        return undefined;
    };
    /**
     * Method used the draw the reactangle for the diagram  \
     *
     * @returns {void} Method used the draw the reactangle for the diagram .\
     *
     * @param { SVGElement} element - Provide the SVG elements .
     * @param { RectAttributes} canvas - Provide the Canvas element  .
     * @param { RectAttributes} transform - Provide transform value for the node  .
     * @param { RectAttributes} parentSvg -provide the parent SVG  .
     * @param { RectAttributes} isPreviewNode - Provide the preview boolean value  .
     * @private
     */
    DiagramRenderer.prototype.renderRect = function (element, canvas, transform, parentSvg, isPreviewNode) {
        var options = this.getBaseAttributes(element, transform, isPreviewNode);
        options.cornerRadius = element.cornerRadius || 0;
        if (element.isExport) {
            options.cornerRadius *= element.exportScaleValue.x;
        }
        var ariaLabel = element.description ? element.description : element.id;
        this.renderer.drawRectangle(canvas, options, this.diagramId, element.isExport, undefined, parentSvg, ariaLabel, undefined, undefined, this, element);
    };
    /**
     * Method used the draw the reactangle for the diagram  \
     *
     * @returns {void} Method used the draw the reactangle for the diagram .\
     *
     * @param { SVGElement} canvas - Provide the SVG elements .
     * @param { RectAttributes} options - Provide the attributes to draw the rectangle  .
     * @private
     */
    DiagramRenderer.prototype.drawRect = function (canvas, options) {
        options.cornerRadius = 0;
        this.svgRenderer.drawRectangle(canvas, options, this.diagramId);
    };
    /**
     * Will get the base attributes for all the elements  \
     *
     * @returns {BaseAttributes} Will get the base attributes for all the elements .\
     *
     * @param { DiagramElement} element - Provide the diagram elements .
     * @param { Transforms} transform - Provide the transform value for the  elements .
     * @param { boolean} isPreviewNode - Provide the preview boolean value.
     * @private
     */
    DiagramRenderer.prototype.getBaseAttributes = function (element, transform, isPreviewNode) {
        var options = {
            width: element.actualSize.width, height: element.actualSize.height,
            //EJ2-840163-Draw highlighter not rendered properly while hovering ports
            x: element.offsetX - element.actualSize.width * element.pivot.x,
            y: element.offsetY - element.actualSize.height * element.pivot.y,
            fill: element.style.fill, stroke: element.style.strokeColor, angle: element.rotateAngle + element.parentTransform,
            pivotX: element.pivot.x, pivotY: element.pivot.y, strokeWidth: element.style.strokeWidth,
            dashArray: element.style.strokeDashArray || '', opacity: element.style.opacity, shadow: element.shadow,
            gradient: element.style.gradient, visible: element.visible, id: element.id, description: element.description,
            canApplyStyle: element.canApplyStyle, shapeType: element.shapeType
        };
        if (element.rotationReference === 'Page') {
            options.angle = element.rotateAngle;
        }
        if (isPreviewNode) {
            options.x = options.x - .5;
            options.y = options.y - .5;
        }
        if (element.isExport) {
            options.width *= element.exportScaleValue.x;
            options.height *= element.exportScaleValue.y;
            options.x *= element.exportScaleValue.x;
            options.y *= element.exportScaleValue.y;
            options.strokeWidth *= element.exportScaleValue.x;
        }
        if (element.flip) {
            options.flip = element.flip;
            if ((element.flip === FlipDirection.Horizontal || element.flip === FlipDirection.Vertical) &&
                element instanceof ImageElement && !this.isSvgMode) {
                options.isImage = true;
            }
        }
        if (element.flipMode) {
            options.flipMode = element.flipMode;
        }
        if (transform) {
            options.x += transform.tx;
            options.y += transform.ty;
        }
        return options;
    };
    /**
     * Will render the SVG background image  \
     *
     * @returns {void} Will render the SVG background image  .\
     *
     * @param { Transforms} background - Provide the transforms values .
     * @param { boolean} diagramElement - Provide element for the daigram.
     * @param { boolean} x - Provide the rendering mode of the daigram.
     * @param { boolean} y - Provide the rendering mode of the daigram.
     * @param { boolean} width - Provide the rendering mode of the daigram.
     * @param { boolean} height - Provide the rendering mode of the daigram.
     * @private
     */
    DiagramRenderer.renderSvgBackGroundImage = function (background, diagramElement, x, y, width, height) {
        if (background.source) {
            var backgroundLayer = getBackgroundLayerSvg(diagramElement.id);
            var target = backgroundLayer.getElementById(diagramElement.id + '_image');
            if (!target) {
                var bgimageLayer = getBackgroundImageLayer(diagramElement.id);
                target = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                target.setAttribute('id', diagramElement.id + '_image');
                bgimageLayer.appendChild(target);
            }
            var imageObj = new Image();
            imageObj.src = background.source;
            target.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', imageObj.src.toString());
            var scale = background.scale !== 'None' ? background.scale : '';
            var imgAlign = background.align;
            var aspectRatio = imgAlign.charAt(0).toLowerCase() + imgAlign.slice(1);
            if (scale) {
                aspectRatio += ' ' + scale.charAt(0).toLowerCase() + scale.slice(1);
            }
            var attr = {
                'id': diagramElement.id + '_image', 'x': x, 'y': y,
                'width': width, 'height': height,
                'preserveAspectRatio': aspectRatio
            };
            setAttributeSvg(target, attr);
        }
    };
    /**
     * Method used to transform the layer  \
     *
     *  @returns {boolean} Method used to transform the layer  .\
     *  @param { Transforms} transform - Provide the transforms values .
     *  @param { boolean} svgMode - Provide the rendering mode of the daigram.
     *  @private
     */
    DiagramRenderer.prototype.transformLayers = function (transform, svgMode) {
        var tx = transform.tx * transform.scale;
        var ty = transform.ty * transform.scale;
        var domTable = 'domTable';
        if (tx !== this.transform.x || ty !== this.transform.y || (tx === 0 || ty === 0)) {
            //diagram layer
            if (svgMode) {
                if (!window["" + domTable][this.diagramId + '_diagramLayer']) {
                    window["" + domTable][this.diagramId + '_diagramLayer'] =
                        this.diagramSvgLayer.getElementById(this.diagramId + '_diagramLayer');
                }
                var diagramLayer = window["" + domTable][this.diagramId + '_diagramLayer'];
                diagramLayer.setAttribute('transform', 'translate('
                    + (transform.tx * transform.scale) + ',' + (transform.ty * transform.scale) + '),scale('
                    + transform.scale + ')');
            }
            //background
            //gridline
            var gridLayer = getGridLayer(this.diagramId);
            gridLayer.setAttribute('transform', 'translate(' + (transform.tx * transform.scale) + ','
                + (transform.ty * transform.scale) + ')');
            //portslayer
            if (!window["" + domTable][this.diagramId + '_diagramPorts']) {
                window["" + domTable][this.diagramId + '_diagramPorts'] = this.iconSvgLayer.getElementById(this.diagramId + '_diagramPorts');
            }
            var portsLayer = window["" + domTable][this.diagramId + '_diagramPorts'];
            portsLayer.setAttribute('transform', 'translate('
                + (transform.tx * transform.scale) + ',' + (transform.ty * transform.scale) + '),scale('
                + transform.scale + ')');
            //expandlayer
            if (!window["" + domTable][this.diagramId + '_diagramExpander']) {
                window["" + domTable][this.diagramId + '_diagramExpander'] =
                    this.iconSvgLayer.getElementById(this.diagramId + '_diagramExpander');
            }
            var expandLayer = window["" + domTable][this.diagramId + '_diagramExpander'];
            expandLayer.setAttribute('transform', 'translate('
                + (transform.tx * transform.scale) + ',' + (transform.ty * transform.scale) + '),scale('
                + transform.scale + ')');
            //nativelayer
            if (!window["" + domTable][this.diagramId + '_nativeLayer']) {
                window["" + domTable][this.diagramId + '_nativeLayer'] = this.nativeSvgLayer.getElementById(this.diagramId + '_nativeLayer');
            }
            var nativeLayer = window["" + domTable][this.diagramId + '_nativeLayer'];
            nativeLayer.setAttribute('transform', 'translate('
                + (transform.tx * transform.scale) + ',' + (transform.ty * transform.scale) + '),scale('
                + transform.scale + ')');
            //htmlLayer
            var htmlLayer = getHTMLLayer(this.diagramId).children[0];
            htmlLayer.style.transform = 'translate('
                + (transform.tx * transform.scale) + 'px,' + (transform.ty * transform.scale) + 'px)scale('
                + transform.scale + ')';
            this.transform = { x: transform.tx * transform.scale, y: transform.ty * transform.scale };
            return true;
        }
        return false;
    };
    /**
     * Method used to update the nodes in the diagram  \
     *
     *  @returns {void} Method used to update the nodes in the diagram  .\
     *  @param { HTMLCanvasElement} element - Provide the diagram element .
     *  @param { HTMLCanvasElement} diagramElementsLayer - Provide the diagram layer element .
     *  @param { HTMLCanvasElement} htmlLayer -Provide the html element .
     *  @param { HTMLCanvasElement} transform - Provide the transform value .
     *  @param { HTMLCanvasElement} insertIndex - Provide the index value.
     *  @param { object} centerPoint - Provide the center point value.
     *  @param {object} portCenterPoint - provide the portCenterPoint value.
     *  @private
     */
    DiagramRenderer.prototype.updateNode = function (element, diagramElementsLayer, htmlLayer, transform, insertIndex, centerPoint, portCenterPoint) {
        this.renderElement(element, diagramElementsLayer, htmlLayer, transform, this.getParentSvg(element), undefined, undefined, insertIndex, null, centerPoint, portCenterPoint);
    };
    return DiagramRenderer;
}());

var __extends$l = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Overview control allows you to see a preview or an overall view of the entire content of a Diagram.
 * This helps you to look at the overall picture of a large Diagram
 * To navigate, pan, or zoom, on a particular position of the page.
 * ```html
 * <div id='diagram'/>
 * <div id="overview"></div>
 * ```
 * ```typescript
 * let overview: Overview;
 * let diagram: Diagram = new Diagram({
 * width:'1000px', height:'500px' });
 * diagram.appendTo('#diagram');
 * let options: OverviewModel = {};
 * options.sourceID = 'diagram';
 * options.width = '250px';
 * options.height = '500px';
 * overview = new Overview(options);
 * overview.appendTo('#overview');
 * ```
 */
var Overview = /** @class */ (function (_super) {
    __extends$l(Overview, _super);
    function Overview(options, element) {
        var _this = _super.call(this, options, element) || this;
        /** @private */
        _this.mode = 'Canvas';
        /** @private */
        _this.id = 'overview';
        _this.actionName = '';
        _this.startPoint = null;
        _this.currentPoint = null;
        _this.prevPoint = null;
        _this.scale = null;
        _this.inAction = false;
        _this.viewPortRatio = 1;
        _this.horizontalOffset = 0;
        _this.verticalOffset = 0;
        _this.model = {};
        _this.event = true;
        _this.overviewid = 88123;
        _this.model = { width: _this.width, height: _this.height };
        return _this;
    }
    /**
     * Updates the overview control when the objects are changed
     *
     * @param {OverviewModel} newProp - Lists the new values of the changed properties
     * @param {OverviewModel} oldProp - Lists the old values of the changed properties
     */
    Overview.prototype.onPropertyChanged = function (newProp, oldProp) {
        //let objectArray: Object[] = [];
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'sourceID':
                    this.setParent(newProp.sourceID);
                    break;
                case 'width':
                case 'height':
                    this.renderCanvas();
                    this.setParent(this.sourceID);
                    break;
            }
        }
    };
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @returns {string}  Get the properties to be maintained in the persisted state.
     */
    Overview.prototype.getPersistData = function () {
        var keyEntity = ['loaded'];
        return this.addOnPersist(keyEntity);
    };
    /**
     * Initializes the values of private members.
     *
     * @returns {void}  Initializes the values of private members.
     * @private
     */
    Overview.prototype.preRender = function () {
        if (this.element.id === '') {
            var collection = document.getElementsByClassName('e-overview').length;
            this.element.id = 'overview_' + this.overviewid + '_' + collection;
        }
        //EJ2-64637 - Diagram element in the overview disappears on window resize.
        this.id = this.element.id ? this.element.id : this.id;
        this.element.style.background = 'transparent';
        this.unWireEvents();
        this.wireEvents();
        //909178 - Template not rendered in diagram after save and load with overview.
        this.element.classList.add('e-overview');
    };
    Overview.prototype.render = function () {
        this.diagramRenderer = new DiagramRenderer(this.element.id, new SvgRenderer(), false);
        this.renderCanvas();
        this.setParent(this.sourceID);
        this.renderComplete();
    };
    // eslint-disable-next-line @typescript-eslint/ban-types
    Overview.prototype.getSizeValue = function (real) {
        var text;
        if (real.toString().indexOf('px') > 0 || real.toString().indexOf('%') > 0) {
            text = real.toString();
        }
        else {
            text = real.toString() + 'px';
        }
        return text;
    };
    Overview.prototype.renderCanvas = function (options) {
        var canvas = document.getElementById(this.element.id + '_canvas');
        if (!canvas) {
            canvas = createHtmlElement('div', {});
            this.element.appendChild(canvas);
        }
        var attribute = {
            'id': this.element.id + '_canvas', 'class': 'drawing',
            'style': 'position:relative; height:' + this.getSizeValue(this.model.height) + '; width:' +
                this.getSizeValue(this.model.width) +
                ';style:-ms-touch-action: none;touch-action: none;'
        };
        setAttributeHtml(canvas, attribute);
        this.element.setAttribute('tabindex', String(-1));
        this.element.style.overflow = 'hidden';
        this.element.style.height = String(this.model.height);
        this.element.style.width = String(this.model.width);
        this.canvas = canvas;
    };
    Overview.prototype.setParent = function (id) {
        var element = document.getElementById(id);
        var instance = 'ej2_instances';
        if (this.parent) {
            var oldparent = this.parent;
            this.parent = null;
            oldparent.setOverview(null, this.element.id);
            this.removeDocument(this);
        }
        this.parent = this.getDiagram(element, instance);
        if (this.parent) {
            this.parent.setOverview(this);
        }
    };
    Overview.prototype.getDiagram = function (element, instance) {
        var diagram;
        var n = element["" + instance].length;
        for (var i = 0; i < n; i++) {
            if (hasClass(element["" + instance][parseInt(i.toString(), 10)].element, 'e-diagram')) {
                diagram = element["" + instance][parseInt(i.toString(), 10)];
                break;
            }
        }
        return diagram;
    };
    Overview.prototype.unWireEvents = function () {
        var start = Browser.touchStartEvent;
        var move = Browser.touchMoveEvent;
        //const evnt: EventHandler;
        var cancel = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        //const isIE11Pointer: Boolean = Browser.isPointer;
        // const wheelEvent: string = Browser.info.name === 'mozilla' ?
        //     (isIE11Pointer ? 'mousewheel' : 'DOMMouseScroll') : 'mousewheel';
        var stop = Browser.touchEndEvent;
        EventHandler.remove(this.element, start, this.mouseDown);
        EventHandler.remove(this.element, move, this.mouseMove);
        EventHandler.remove(this.element, stop, this.mouseUp);
        EventHandler.remove(this.element, cancel, this.documentMouseUp);
        EventHandler.remove(window, 'resize', this.windowResize);
        var container = document.getElementById(this.sourceID + 'content');
        if (container) {
            EventHandler.remove(container, 'scroll', this.scrolled);
        }
    };
    Overview.prototype.wireEvents = function () {
        var start = Browser.touchStartEvent;
        var stop = Browser.touchEndEvent;
        var move = Browser.touchMoveEvent;
        var cancel = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        //const isIE11Pointer: Boolean = Browser.isPointer;
        // const wheelEvent: string = Browser.info.name === 'mozilla' ?
        //     (isIE11Pointer ? 'mousewheel' : 'DOMMouseScroll') : 'mousewheel';
        EventHandler.add(this.element, start, this.mouseDown, this);
        EventHandler.add(this.element, move, this.mouseMove, this);
        EventHandler.add(this.element, stop, this.mouseUp, this);
        EventHandler.add(this.element, cancel, this.documentMouseUp, this);
        // eslint-disable
        EventHandler.add(window, 'resize', this.windowResize, this);
        // eslint-enable
        var container = document.getElementById(this.sourceID + 'content');
        if (container) {
            EventHandler.add(container, 'scroll', this.scrolled, this);
        }
    };
    /**
     * renderDocument method\
     *
     * @returns {  void }    renderDocument method .\
     * @param {Overview} view - provide the angle value.
     * @private
     */
    Overview.prototype.renderDocument = function (view) {
        view.canvas = this.canvas;
        var g = document.getElementById(this.canvas.id + '_svg');
        if (g) {
            g.parentNode.removeChild(g);
        }
        var attr = {
            id: this.canvas.id + '_svg',
            version: '1.1',
            'class': 'overview_svg'
        };
        var svg = createSvgElement('svg', attr);
        this.svg = svg;
        view.svg = svg;
        view.canvas.appendChild(svg);
        var ovw = document.getElementById(this.element.id);
        var element = ovw;
        var eWidth = element.clientWidth || element.offsetWidth;
        var eHeight = element.clientHeight || element.offsetHeight;
        var bRect = element.getBoundingClientRect();
        // Check for the window resize
        var screenX = (window.screenX < 0) ? window.screenX * -1 : window.screenX;
        var screenY = (window.screenY < 0) ? window.screenY * -1 : window.screenY;
        if (eWidth === 0) {
            var widthValue = Math.floor(((window.innerWidth - screenX) - Math.floor(bRect.left)));
            eWidth = widthValue > 0 ? widthValue : Math.floor(window.innerWidth);
        }
        if (eHeight === 0) {
            var heightValue = Math.floor(((window.innerHeight - screenY) - Math.floor(bRect.top)));
            eHeight = heightValue > 0 ? heightValue : Math.floor(window.innerHeight);
        }
        if (eWidth > 0) {
            svg.setAttribute('width', String(eWidth));
            this.model.height = eHeight;
        }
        if (eHeight > 0) {
            svg.setAttribute('height', String(eHeight));
            this.model.width = eWidth;
        }
        //let attributes: Object;
        if (!view.diagramLayerDiv) {
            view.diagramLayerDiv = createHtmlElement('div', {});
            //const container: HTMLElement = document.getElementById(this.element.id);
            view.diagramLayer = CanvasRenderer.createCanvas(this.element.id + '_diagramLayer', this.model.width, this.model.height);
            view.diagramLayer.style.position = 'absolute';
            view.diagramLayer.style.left = '0px';
            view.diagramLayer.style.top = '0px';
            view.diagramLayerDiv.appendChild(view.diagramLayer);
            view.canvas.appendChild(view.diagramLayerDiv);
        }
        var attributes = {
            'id': this.element.id + '_diagramLayer_div',
            'style': 'width:' + this.model.width + 'px; height:' + this.model.height + 'px;position:absolute;top:0px;left:0px'
        };
        setAttributeHtml(view.diagramLayerDiv, attributes);
        this.renderHtmlLayer(view.canvas);
        this.renderNativeLayer(view.canvas, view);
        this.addOverviewRectPanel(view);
    };
    /**
     * removeDocument method\
     *
     * @returns {  void }    removeDocument method .\
     * @param {Overview} view - provide the angle value.
     * @private
     */
    Overview.prototype.removeDocument = function (view) {
        var svg = document.getElementById(this.canvas.id + '_svg');
        this.canvas.removeChild(svg);
        var htmlLayer = document.getElementById(this.element.id + '_htmlLayer');
        this.canvas.removeChild(htmlLayer);
        var diagramLayer = document.getElementById(this.element.id + '_diagramLayer_div');
        this.canvas.removeChild(diagramLayer);
        view.diagramLayerDiv = null;
        view.diagramLayer = null;
        var domTable = 'domTable';
        window["" + domTable][this.id + 'html_layer'] = null;
    };
    Overview.prototype.renderHtmlLayer = function (canvas) {
        var htmlLayer = createHtmlElement('div', {
            'id': this.element.id + '_htmlLayer', 'class': 'e-html-layer',
            'style': 'pointer-events:none;position:absolute;top:0px;left:0px;'
        });
        var options = {
            'id': this.element.id + '_htmlLayer_div',
            'style': 'position:absolute;top:0px;left:0px;'
        };
        var htmlDiv = createHtmlElement('div', options);
        htmlLayer.appendChild(htmlDiv);
        canvas.appendChild(htmlLayer);
        return htmlLayer;
    };
    Overview.prototype.renderNativeLayer = function (canvas, view) {
        if (!document.getElementById(this.element.id + '_nativeLayer_svg')) {
            var nativeLayerSvg = this.parent.createSvg(this.element.id + '_nativeLayer_svg', this.model.width, this.model.height);
            var nativeLayer = createSvgElement('g', { 'id': this.element.id + '_nativeLayer' });
            nativeLayerSvg.appendChild(nativeLayer);
            view.diagramLayerDiv.appendChild(nativeLayerSvg);
            setAttributeSvg(nativeLayerSvg, { 'class': 'e-native-layer' });
        }
    };
    Overview.prototype.addOverviewRectPanel = function (view) {
        var svg = document.getElementById(this.canvas.id + '_overviewsvg');
        if (svg) {
            svg.parentNode.removeChild(svg);
        }
        var attr = ({
            id: this.canvas.id + '_overviewsvg',
            class: 'overviewsvg',
            version: '1.1',
            'style': 'position:absolute;left:0px;top:0px; aria-label:Specifies overview',
            width: this.model.width,
            height: this.model.height
        });
        svg = createSvgElement('svg', attr);
        view.canvas.appendChild(svg);
        var ovw = createSvgElement('g', { 'id': this.element.id + '_overviewlayer', 'style': 'pointer-events:none' });
        svg.appendChild(ovw);
        var rect = createSvgElement('rect', {
            'fill': 'transparent', 'width': '100%', 'height': '100%', 'class': 'overviewbackrect',
            'id': this.canvas.id + 'overviewbackrect'
        });
        rect.style.pointerEvents = 'none';
        ovw.appendChild(rect);
        //const svgDocument: SVGElement = (ovw);
        var g = createSvgElement('g', { 'id': this.canvas.id + 'overviewhandle', 'style': 'pointer-events:all' });
        ovw.appendChild(g);
        var innerrect = createSvgElement('rect', { 'id': this.canvas.id + 'overviewrect', 'fill': 'transparent' });
        g.appendChild(innerrect);
        this.renderOverviewCorner('left', g);
        this.renderOverviewCorner('right', g);
        this.renderOverviewCorner('top', g);
        this.renderOverviewCorner('bottom', g);
        this.renderOverviewCorner('topleft', g);
        this.renderOverviewCorner('topright', g);
        this.renderOverviewCorner('bottomleft', g);
        this.renderOverviewCorner('bottomright', g);
    };
    Overview.prototype.renderOverviewCorner = function (name, parent) {
        var svg = this.svg;
        var shape;
        if (name === 'top' || name === 'bottom' || name === 'right' || name === 'left') {
            shape = 'rect';
        }
        else {
            shape = 'circle';
        }
        var innerrect = createSvgElement(shape, { 'id': this.canvas.id + 'visible' + name, 'class': 'overview-resizer' });
        parent.appendChild(innerrect);
        var transrect = createSvgElement(shape, {
            'id': this.canvas.id + name, 'class': 'overviewresizer', 'fill': 'transparent'
        });
        parent.appendChild(transrect);
    };
    Overview.prototype.updateOverviewRectangle = function () {
        var difx = this.currentPoint.x - this.prevPoint.x;
        var dify = this.currentPoint.y - this.prevPoint.y;
        var size = new Size();
        size.width = 0;
        size.height = 0;
        var x = 0;
        var y = 0;
        var w;
        var h;
        switch (this.resizeDirection) {
            case 'left':
                size.width -= difx;
                size.height -= difx / this.viewPortRatio;
                x = difx;
                y = difx / this.viewPortRatio;
                y /= 2;
                break;
            case 'right':
                size.width += difx;
                size.height += difx / this.viewPortRatio;
                y = difx / this.viewPortRatio;
                y /= -2;
                break;
            case 'top':
                size.height -= dify;
                size.width -= dify * this.viewPortRatio;
                y = dify;
                x = dify * this.viewPortRatio;
                x /= 2;
                break;
            case 'bottom':
                size.height += dify;
                size.width += dify * this.viewPortRatio;
                x = dify * this.viewPortRatio;
                x /= -2;
                break;
            case 'topleft':
                if (Math.abs(dify) > Math.abs(difx)) {
                    difx = dify * this.viewPortRatio;
                }
                else {
                    dify = difx / this.viewPortRatio;
                }
                size.width -= difx;
                size.height -= dify;
                x = difx;
                y = dify;
                break;
            case 'topright':
                if (Math.abs(dify) > Math.abs(difx)) {
                    difx = -dify * this.viewPortRatio;
                }
                else {
                    dify = -(difx / this.viewPortRatio);
                }
                y = dify;
                size.width += difx;
                size.height -= dify;
                break;
            case 'bottomleft':
                if (Math.abs(dify) > Math.abs(difx)) {
                    difx = -dify * this.viewPortRatio;
                }
                else {
                    dify = -difx / this.viewPortRatio;
                }
                x = difx;
                size.width -= difx;
                size.height += dify;
                break;
            case 'bottomright':
                if (Math.abs(dify) > Math.abs(difx)) {
                    difx = dify * this.viewPortRatio;
                }
                else {
                    dify = difx / this.viewPortRatio;
                }
                size.width += difx;
                size.height += dify;
                break;
        }
        this.updateHelper(x, y, size, w, h);
    };
    Overview.prototype.updateHelper = function (difx, dify, size, width, height) {
        var x;
        var y;
        var bounds;
        var svg = this.element.getElementsByTagName('svg')[2];
        var rect = svg.getElementById('helper');
        if (size) {
            bounds = rect.getBBox();
            x = bounds.x + difx;
            y = bounds.y + dify;
            width = bounds.width + size.width;
            height = bounds.height + size.height;
        }
        else {
            var difx_1;
            if (this.currentPoint.x > this.startPoint.x) {
                difx_1 = this.currentPoint.x - this.prevPoint.x;
            }
            else {
                difx_1 = this.prevPoint.x - this.currentPoint.x;
            }
            var dify_1;
            if (this.currentPoint.y > this.startPoint.y) {
                dify_1 = this.currentPoint.y - this.prevPoint.y;
            }
            else {
                dify_1 = this.prevPoint.y - this.currentPoint.y;
            }
            if (Math.abs(dify_1) > Math.abs(difx_1)) {
                difx_1 = this.viewPortRatio * dify_1;
            }
            else {
                dify_1 = difx_1 / this.viewPortRatio;
            }
            bounds = rect.getBBox();
            x = ((this.startPoint.x > this.currentPoint.x) ?
                bounds.x - difx_1 : bounds.x);
            y = ((this.startPoint.y > this.currentPoint.y) ? bounds.y - dify_1 : bounds.y);
            width = bounds.width + difx_1;
            height = bounds.height + dify_1;
        }
        setAttributeSvg(this.helper, {
            'id': this.helper.id, 'x': x, 'y': y,
            'width': Math.max(0, width), 'height': Math.max(0, height)
        });
    };
    Overview.prototype.updateOverviewrect = function (x, y, width, height) {
        var rect = document.getElementById(this.canvas.id + 'overviewrect');
        var attr = { x: x, y: y, width: Math.max(1, width), height: Math.max(1, height) };
        setAttributeHtml(rect, attr);
        this.updateOverviewCorner('top', x + 8, y + 1, Math.max(0, width - 16), 2);
        this.updateOverviewCorner('bottom', x + 8, y + height + 3, Math.max(0, width - 16), 2);
        this.updateOverviewCorner('left', x - 2, y + 11, 2, Math.max(0, height - 16));
        this.updateOverviewCorner('right', x + width, y + 11, 2, Math.max(0, height - 16));
        this.updateOverviewCorner('topleft', x, y + 3, 5, 5);
        this.updateOverviewCorner('topright', x + width, y + 3, 5, 5);
        this.updateOverviewCorner('bottomleft', x, y + height + 3, 5, 5);
        this.updateOverviewCorner('bottomright', x + width, y + height + 3, 5, 5);
    };
    Overview.prototype.updateOverviewCorner = function (name, x, y, width, height) {
        var attr;
        var transattr;
        var rectname = 'visible' + name;
        var rect = document.getElementById(this.canvas.id + rectname);
        if (name === 'top' || name === 'bottom' || name === 'right' || name === 'left') {
            attr = { x: x, y: y, width: width, height: height, fill: '#ED1C24' };
            transattr = { x: x - 2, y: y - 2, width: width === 2 ? 4 : width, height: height === 2 ? 4 : height };
        }
        else {
            attr = { cx: x, cy: y, 'r': 4, fill: '#ED1C24' };
            transattr = { cx: x, cy: y, 'r': 6, fill: 'transparent' };
        }
        setAttributeHtml(rect, attr);
        var transrect = document.getElementById(this.canvas.id + name);
        setAttributeHtml(transrect, transattr);
    };
    Overview.prototype.translateOverviewRectangle = function () {
        var offwidth = Number(this.model.width);
        var offheight = Number(this.model.height);
        var difx = this.currentPoint.x - this.prevPoint.x;
        var dify = this.currentPoint.y - this.prevPoint.y;
        //const viewPort: Rect;
        //let zoom: number = Math.min(this.parent.scroller.viewPortWidth / offwidth, this.parent.scroller.viewPortHeight / offheight);
        var svg = this.element.getElementsByClassName('overviewsvg')[0];
        var panel = svg.getElementById(this.canvas.id
            + 'overviewrect');
        var bounds = panel.getBBox();
        var x = bounds.x + difx;
        var y = bounds.y + dify;
        var width = bounds.width;
        var height = bounds.height;
        this.updateOverviewrect(x, y, width, height);
        this.updateParentView(this.parent.scroller.currentZoom, x, y, width, height, null);
    };
    Overview.prototype.renderOverviewRect = function (x, y, width, height) {
        var offwidth = Number(this.model.width);
        var offheight = Number(this.model.height);
        //const viewPort: Rect;
        var viewwidth = (width / offwidth) * this.contentWidth;
        var viewheight = (height / offheight) * this.contentHeight;
        var zoom = Math.max(this.parent.scroller.viewPortWidth / viewwidth, this.parent.scroller.viewPortHeight / viewheight);
        if (zoom >= 0.25 && zoom <= 30) {
            var point = { x: 0, y: 0 };
            this.updateParentView(zoom, x, y, width, height, point);
            var bounds = this.scrollOverviewRect(this.parent.scroller.horizontalOffset, this.parent.scroller.verticalOffset, this.parent.scroller.currentZoom, true);
            if (this.helper) {
                var panel = this.element.getElementsByTagName('rect')[10];
                var svgRect = panel.getBBox();
                bounds.x = svgRect.x;
                bounds.y = svgRect.y;
            }
            //Bug 884239: Overview rectangle not updated properly while double-clicking the overview canvas.
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            this.actionName === 'pan' ? this.updateOverviewrect(-bounds.x, -bounds.y, bounds.width, bounds.height) :
                this.updateOverviewrect(bounds.x, bounds.y, bounds.width, bounds.height);
        }
    };
    Overview.prototype.scrollOverviewRect = function (hoffset, voffset, currentZoom, scaled) {
        if (!(this.actionName) || scaled) {
            var offwidth = Number(this.model.width);
            var offheight = Number(this.model.height);
            var scale = Math.min(this.contentWidth / offwidth, this.contentHeight / offheight);
            var bounds = new Rect();
            var x = bounds.x = (hoffset / currentZoom) / scale;
            var y = bounds.y = (voffset / currentZoom) / scale;
            //const viewPort: Rect;
            //Bug 863516: Overview is not synced with diagram content while zoom-out the diagram.
            //Added below code to consider ruler size and scrollbar size while calculating the width and height for the overview rectangle.
            var rulerSize = 0;
            if (this.parent.rulerSettings.showRulers) {
                rulerSize = 25;
            }
            var container = document.getElementById(this.parent.element.id + 'content');
            var wScrollBar = 0;
            var hScrollBar = 0;
            if (container) {
                wScrollBar = container.offsetWidth - container.clientWidth;
                hScrollBar = container.offsetHeight - container.clientHeight;
            }
            var width = bounds.width = ((this.parent.scroller.viewPortWidth - rulerSize - wScrollBar) / currentZoom) / scale;
            var height = bounds.height = ((this.parent.scroller.viewPortHeight - rulerSize - hScrollBar) / currentZoom) / scale;
            //const ratio: number = this.parent.scroller.viewPortWidth / this.parent.scroller.viewPortHeight;
            if (scaled) {
                var rect = new Rect();
                rect.x = x;
                rect.y = y;
                rect.width = width;
                rect.height = height;
                return rect;
            }
            this.updateOverviewrect(-x, -y, width, height);
        }
        return null;
    };
    Overview.prototype.updateParentView = function (zoom, x, y, width, height, focusPoint) {
        var offwidth = Number(this.model.width);
        var offheight = Number(this.model.height);
        var scalex = this.contentWidth / offwidth;
        var scaley = this.contentHeight / offheight;
        var hoffset = x * scalex * zoom;
        var voffset = y * scaley * zoom;
        var delx;
        var dely;
        var bounds = this.parent.scroller.getPageBounds();
        if (zoom !== 1 || this.actionName === 'pan') {
            delx = -hoffset - this.parent.scroller.horizontalOffset;
            dely = -voffset - this.parent.scroller.verticalOffset;
        }
        this.parent.setBlazorDiagramProps(true);
        this.parent.realActions |= RealAction.OverViewAction;
        var canOverview = true;
        if (this.actionName === 'scale' || this.actionName === 'draw') {
            this.parent.scroller.zoom(zoom / this.parent.scroller.currentZoom, delx, dely, focusPoint);
        }
        else {
            if (!isBlazor()) {
                this.parent.pan(delx, dely, focusPoint, canOverview);
            }
            else {
                this.parent.scroller.zoom(1, delx, dely, focusPoint);
            }
        }
    };
    Overview.prototype.updateHtmlLayer = function (view) {
        var htmlLayer = getHTMLLayer(view.element.id);
        var bounds = this.parent.scroller.getPageBounds(true);
        var width = bounds.width;
        var height = bounds.height;
        var w = Math.max(width, this.parent.scroller.viewPortWidth);
        var h = Math.max(height, this.parent.scroller.viewPortHeight / this.parent.scroller.currentZoom);
        var scale = Math.min(Number(this.model.width) / w, Number(this.model.height) / h);
        htmlLayer.style.transform = 'scale(' + scale + ') translate(' + this.parent.scroller.transform.tx + 'px,'
            + (this.parent.scroller.transform.ty) + 'px)';
    };
    /** @private */
    /**
     * updateView method\
     *
     * @returns {  void }    removeDocument method .\
     * @param {Overview} view - provide the angle value.
     * @private
     */
    Overview.prototype.updateView = function (view) {
        //let width: number; let height: number;
        var bounds = this.parent.scroller.getPageBounds();
        // Bug 851571: Overview with html node is not updated properly when we zoom-out the diagram.
        // Below transformWidth calculation is removed.
        var width = bounds.width;
        var height = bounds.height;
        var offwidth = Number(this.model.width);
        var offheight = Number(this.model.height);
        //let scale: number;
        var w = Math.max(width, this.parent.scroller.viewPortWidth);
        // Bug 851571: Overview with html node is not updated properly when we zoom-out the diagram.
        // Removed viewPortHeight/ currentZoom for height calculation.
        var h = Math.max(height, this.parent.scroller.viewPortHeight);
        this.contentWidth = w = Math.max(w, (offwidth / offheight) * h);
        this.contentHeight = h = Math.max(h, (offheight / offwidth) * w);
        var scale = Math.min(offwidth / w, offheight / h);
        var htmlLayer = document.getElementById(this.element.id + '_htmlLayer');
        htmlLayer.style.webkitTransform = 'scale(' + scale + ') translate(' + -bounds.x + 'px,' + (-bounds.y) + 'px)';
        htmlLayer.style.transform = 'scale(' + scale + ') translate(' + ((-(bounds.x))) + 'px,'
            + (((-bounds.y))) + 'px)';
        var ovw = document.getElementById(this.element.id + '_overviewlayer');
        ovw.setAttribute('transform', 'translate(' + (-bounds.x * scale) + ',' + (-bounds.y * scale) + ')');
        this.horizontalOffset = bounds.x * scale;
        this.verticalOffset = bounds.y * scale;
        var canvas = document.getElementById(this.element.id + '_diagramLayer');
        var nativeLayer = getNativeLayer(this.element.id);
        var context = canvas.getContext('2d');
        var widthratio = (Number(this.model.width) / this.contentWidth);
        var heightratio = (Number(this.model.height) / this.contentHeight);
        widthratio = Math.min(widthratio, heightratio);
        var transform = this.parent.scroller.transform;
        var tx = transform.tx;
        var ty = transform.ty;
        nativeLayer.setAttribute('transform', 'translate('
            + (tx * widthratio) + ',' + (ty * heightratio) + '),scale('
            + widthratio + ')');
        context.setTransform(widthratio, 0, 0, widthratio, 0, 0);
        context.fillStyle = 'red';
        this.scrollOverviewRect(this.parent.scroller.horizontalOffset, this.parent.scroller.verticalOffset, this.parent.scroller.currentZoom);
    };
    // region - Event Handlers
    Overview.prototype.scrolled = function (evt) {
        if (this.event) {
            var bounds = this.scrollOverviewRect(this.parent.scroller.horizontalOffset, this.parent.scroller.verticalOffset, this.parent.scroller.currentZoom, true);
            this.updateOverviewrect(-bounds.x, -bounds.y, bounds.width, bounds.height);
            // EJ2-67416 - Added below code to update the overview rect if the diagram and overview is scrolled.
            this.updateView(this);
        }
    };
    Overview.prototype.updateCursor = function (evt) {
        if (hasClass(evt.target, ('overviewresizer'))) {
            switch (evt.target.id) {
                case this.canvas.id + 'left':
                    this.canvas.style.cursor = 'w-resize';
                    break;
                case this.canvas.id + 'right':
                    this.canvas.style.cursor = 'e-resize';
                    break;
                case this.canvas.id + 'top':
                    this.canvas.style.cursor = 'n-resize';
                    break;
                case this.canvas.id + 'bottom':
                    this.canvas.style.cursor = 's-resize';
                    break;
                case this.canvas.id + 'topleft':
                    this.canvas.style.cursor = 'nw-resize';
                    break;
                case this.canvas.id + 'topright':
                    this.canvas.style.cursor = 'ne-resize';
                    break;
                case this.canvas.id + 'bottomleft':
                    this.canvas.style.cursor = 'sw-resize';
                    break;
                case this.canvas.id + 'bottomright':
                    this.canvas.style.cursor = 'se-resize';
                    break;
            }
        }
        else {
            this.canvas.style.cursor = 'default';
        }
    };
    Overview.prototype.mouseMove = function (evt) {
        this.event = false;
        this.updateCursor(evt);
        this.currentPoint = this.mousePosition(evt);
        if (this.actionName) {
            switch (this.actionName) {
                case 'draw':
                    if (!this.inAction && (this.startPoint.x !== this.currentPoint.x || this.startPoint.y !== this.currentPoint.y)) {
                        this.initHelper();
                        this.inAction = true;
                    }
                    if (this.inAction) {
                        this.updateHelper();
                    }
                    break;
                case 'scale':
                    if (!this.inAction) {
                        this.initHelper();
                        this.inAction = true;
                    }
                    this.updateOverviewRectangle();
                    break;
                case 'pan':
                    if ((this.startPoint.x !== this.currentPoint.x || this.startPoint.y === this.currentPoint.y) || this.inAction) {
                        this.inAction = true;
                        this.translateOverviewRectangle();
                    }
                    break;
            }
        }
        this.prevPoint = this.currentPoint;
    };
    Overview.prototype.documentMouseUp = function (evt) {
        this.inAction = false;
        this.actionName = '';
        if (this.helper) {
            this.helper.parentNode.removeChild(this.helper);
            this.helper = null;
        }
        this.event = true;
        document.getElementById(this.canvas.id + 'overviewhandle').style.pointerEvents = 'all';
    };
    Overview.prototype.windowResize = function (evt) {
        var _this = this;
        if (this.resizeTo) {
            clearTimeout(this.resizeTo);
        }
        this.resizeTo = setTimeout(function () {
            var element = document.getElementById(_this.element.id);
            var bRect = element.getBoundingClientRect();
            _this.model.width = bRect.width > 0 ? bRect.width : _this.model.width;
            _this.model.height = bRect.height > 0 ? bRect.height : _this.model.height;
            _this.renderCanvas();
            _this.setParent(_this.sourceID);
        }, 10);
        return false;
    };
    /**
     * mouseDown method\
     *
     * @returns {  void }    mouseDown method .\
     * @param {PointerEvent | TouchEvent} evt - provide the angle value.
     * @private
     */
    Overview.prototype.mouseDown = function (evt) {
        if (evt.target.id === this.canvas.id + '_overviewsvg') {
            this.actionName = 'draw';
        }
        if (evt.target.id === this.canvas.id + 'overviewrect') {
            this.actionName = 'pan';
        }
        if (hasClass(evt.target, 'overviewresizer')) {
            this.actionName = 'scale';
            switch (evt.target.id) {
                case this.canvas.id + 'left':
                    this.resizeDirection = 'left';
                    break;
                case this.canvas.id + 'right':
                    this.resizeDirection = 'right';
                    break;
                case this.canvas.id + 'top':
                    this.resizeDirection = 'top';
                    break;
                case this.canvas.id + 'bottom':
                    this.resizeDirection = 'bottom';
                    break;
                case this.canvas.id + 'topleft':
                    this.resizeDirection = 'topleft';
                    break;
                case this.canvas.id + 'topright':
                    this.resizeDirection = 'topright';
                    break;
                case this.canvas.id + 'bottomleft':
                    this.resizeDirection = 'bottomleft';
                    break;
                case this.canvas.id + 'bottomright':
                    this.resizeDirection = 'bottomright';
                    break;
            }
        }
        this.startPoint = this.prevPoint = this.mousePosition(evt);
        this.viewPortRatio = this.parent.scroller.viewPortWidth / this.parent.scroller.viewPortHeight;
        var overViewHandle = document.getElementById(this.canvas.id + 'overviewhandle');
        overViewHandle.style.pointerEvents = 'none';
    };
    Overview.prototype.mouseUp = function (evt) {
        this.currentPoint = this.mousePosition(evt);
        //let offwidth: number = Number(this.model.width);
        //let offheight: number = Number(this.model.height);
        if (this.actionName) {
            if ((this.startPoint.x !== this.currentPoint.x || this.startPoint.y !== this.currentPoint.y)) {
                if (this.actionName === 'pan') ;
                else {
                    if (this.helper) {
                        var bounds = (this.element.getElementsByTagName('rect')[10]).getBBox();
                        this.resizeDirection = this.resizeDirection || '';
                        var x = bounds.x;
                        var y = bounds.y;
                        var width = bounds.width;
                        var height = bounds.height;
                        var adjust = this.resizeDirection === 'topleft' || this.resizeDirection === 'topright' ||
                            this.resizeDirection === 'bottomleft' || this.resizeDirection === 'bottomright';
                        this.renderOverviewRect(x, y, width, height);
                    }
                }
            }
            else {
                if (evt.target.id === this.canvas.id + '_overviewsvg' || evt.target.id === 'helper') {
                    var svg = this.element.getElementsByTagName('svg')[2];
                    var g = svg.getElementById(this.canvas.id
                        + 'overviewrect');
                    var bounds = g.getBBox();
                    var width = bounds.width;
                    var height = bounds.height;
                    this.inAction = true;
                    this.actionName = 'pan';
                    this.renderOverviewRect(this.currentPoint.x - width / 2, this.currentPoint.y - height / 2, width, height);
                    this.inAction = false;
                }
            }
        }
        if (this.helper) {
            this.helper.parentNode.removeChild(this.helper);
            this.helper = null;
        }
        this.actionName = '';
        this.startPoint = null;
        this.currentPoint = null;
        this.prevPoint = null;
        this.helper = null;
        this.viewPortRatio = 1;
        this.resizeDirection = '';
        this.inAction = false;
        this.event = true;
        document.getElementById(this.canvas.id + 'overviewhandle').style.pointerEvents = 'all';
    };
    Overview.prototype.initHelper = function () {
        var g = this.element.getElementsByTagName('svg')[2];
        //const scale: number = this.parent.scroller.currentZoom;
        var x = this.startPoint.x;
        var y = this.startPoint.y;
        var width = 1;
        var height = 1;
        if (this.actionName === 'scale') {
            var rect = g.
                getElementById(this.canvas.id + 'overviewrect');
            var bounds = rect.getBBox();
            x = bounds.x;
            y = bounds.y;
            width = bounds.width;
            height = bounds.height;
        }
        var selectionRect = createSvgElement('rect', {
            'id': 'helper', x: x, y: y, width: width, height: height,
            'fill': 'transparent', 'stroke': 'gray', 'stroke-dasharray': '2 2', 'shape-rendering': 'crispEdges'
        });
        var overviewLayer = g.getElementById(this.element.id + '_overviewlayer');
        overviewLayer.appendChild(selectionRect);
        this.helper = selectionRect;
    };
    Overview.prototype.mousePosition = function (evt) {
        var touchArg;
        var offsetX;
        var offsetY;
        if (evt.type.indexOf('touch') !== -1) {
            touchArg = evt;
            var pageX = touchArg.changedTouches[0].clientX;
            var pageY = touchArg.changedTouches[0].clientY;
            offsetX = pageX - this.element.offsetLeft;
            offsetY = pageY - this.element.offsetTop;
        }
        else {
            offsetX = evt.clientX;
            offsetY = evt.clientY;
        }
        var boundingRect = this.element.getBoundingClientRect();
        offsetX = offsetX - boundingRect.left;
        offsetY = offsetY - boundingRect.top;
        return { x: offsetX + this.horizontalOffset, y: offsetY + this.verticalOffset };
    };
    // end region - Event handlers
    /**
     *To destroy the overview
     *
     * @returns {void} To destroy the overview
     */
    Overview.prototype.destroy = function () {
        this.unWireEvents();
        this.notify('destroy', {});
        _super.prototype.destroy.call(this);
        if (document.getElementById(this.element.id)) {
            this.element.classList.remove('e-overview');
            var content = document.getElementById(this.element.id + '_canvas');
            if (content) {
                this.element.removeChild(content);
            }
        }
        this.parent.views.splice(this.parent.views.indexOf(this.element.id), 1);
        this.diagramLayerDiv = null;
        this.canvas = null;
        this.parent = null;
    };
    /**
     * Core method to return the component name.
     *
     * @returns {string}  Core method to return the component name.
     * @private
     */
    Overview.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'Overview';
    };
    __decorate$c([
        Property('100%')
    ], Overview.prototype, "width", void 0);
    __decorate$c([
        Property('100%')
    ], Overview.prototype, "height", void 0);
    __decorate$c([
        Property('')
    ], Overview.prototype, "sourceID", void 0);
    __decorate$c([
        Event()
    ], Overview.prototype, "created", void 0);
    return Overview;
}(Component));

/**
 * completeRegion method\
 *
 * @returns {  void }    completeRegion method .\
 * @param {Rect} region - provide the region value.
 * @param {(NodeModel | ConnectorModel)[]} selectedObjects - provide the selectedObjects value.
 * @private
 */
function completeRegion(region, selectedObjects) {
    var collection = [];
    for (var i = 0; i < selectedObjects.length; i++) {
        var obj = selectedObjects[parseInt(i.toString(), 10)];
        if (region.containsRect(obj.wrapper.bounds)) {
            collection.push(obj);
        }
    }
    return collection;
}
/**
 * findNodeByName method \
 *
 * @returns {  boolean } findNodeByName method .\
 * @param {(NodeModel | ConnectorModel)[]} nodes - provide the nodes  value.
 * @param {string} name - provide the orientation  value.
 * @private
 */
function findNodeByName(nodes, name) {
    for (var i = 0; i < nodes.length; i++) {
        if (nodes[parseInt(i.toString(), 10)].id === name) {
            return true;
        }
    }
    return false;
}
/**
 * findNodeByName method \
 *
 * @returns {  string } findNodeByName method .\
 * @param {(NodeModel | ConnectorModel)[]} drawingObject - provide the drawingObject  value.
 * @private
 */
function findObjectType(drawingObject) {
    var type;
    if (drawingObject) {
        if (drawingObject.type) {
            type = 'Connector';
        }
        else if (drawingObject.shape && !drawingObject.type) {
            type = 'Node';
        }
    }
    return type;
}
/**
 * setSwimLaneDefaults method \
 *
 * @returns {  void } setSwimLaneDefaults method .\
 * @param {NodeModel | ConnectorModel} child - provide the child  value.
 * @param {NodeModel | ConnectorModel} node - provide the node  value.
 * @private
 */
function setSwimLaneDefaults(child, node) {
    if (node instanceof Node) {
        if (!child.shape.header) {
            node.shape.hasHeader = false;
        }
    }
}
/**
 * getSpaceValue method \
 *
 * @returns {  number } getSpaceValue method .\
 * @param {number[]} intervals - provide the intervals  value.
 * @param {boolean} isLine - provide the isLine  value.
 * @param {number} i - provide the i  value.
 * @param {number} space - provide the space  value.
 * @private
 */
function getSpaceValue(intervals, isLine, i, space) {
    space = !isLine ? ((intervals[i - 1] !== undefined) ? intervals[i - 1] + space : 0) : space;
    return space;
}
/**
 * getInterval method \
 *
 * @returns {  number[] } getInterval method .\
 * @param {number[]} intervals - provide the intervals  value.
 * @param {boolean} isLine - provide the isLine  value.
 * @private
 */
function getInterval(intervals, isLine) {
    var newInterval = [];
    if (!isLine) {
        for (var k = 0; k < intervals.length; k++) {
            newInterval.push(intervals[parseInt(k.toString(), 10)]);
        }
        newInterval.push(intervals[newInterval.length - 2]);
        newInterval.push(intervals[newInterval.length - 2]);
    }
    else {
        newInterval = intervals;
    }
    return newInterval;
}
/**
 * setPortsEdges method \
 *
 * @returns {  Node } setPortsEdges method .\
 * @param {Node} node - provide the node  value.
 * @private
 */
function setPortsEdges(node) {
    for (var k = 0; k < node.ports.length; k++) {
        node.ports[parseInt(k.toString(), 10)].inEdges = [];
        node.ports[parseInt(k.toString(), 10)].outEdges = [];
    }
    return node;
}
/**
 * setUMLActivityDefaults method \
 *
 * @returns {  void } setUMLActivityDefaults method .\
 * @param {NodeModel | ConnectorModel} child - provide the child  value.
 * @param {NodeModel | ConnectorModel} node - provide the node  value.
 * @private
 */
function setUMLActivityDefaults(child, node) {
    if (node instanceof Node) {
        var shape = child.shape.shape;
        switch (shape) {
            case 'JoinNode':
                if (!child.width) {
                    node.width = 20;
                }
                if (!child.height) {
                    node.height = 90;
                }
                if (!child.style || !child.style.fill) {
                    node.style.fill = 'black';
                }
                break;
            case 'ForkNode':
                if (!child.width) {
                    node.width = 90;
                }
                if (!child.height) {
                    node.height = 20;
                }
                if (!child.style || !child.style.fill) {
                    node.style.fill = 'black';
                }
                break;
            case 'InitialNode':
                if (!child.style || !child.style.fill) {
                    node.style.fill = 'black';
                }
                break;
            case 'FinalNode':
                if (!child.style || !child.style.fill) {
                    node.style.fill = 'black';
                }
                break;
        }
    }
    else {
        var flow = child.shape.flow;
        switch (flow) {
            case 'Object':
                if (!child.style || !child.style.strokeDashArray) {
                    node.style.strokeDashArray = '8 4';
                }
                if (!child.style || !child.style.strokeWidth) {
                    node.style.strokeWidth = 2;
                }
                if (!child.targetDecorator || !child.targetDecorator.shape) {
                    node.targetDecorator.shape = 'OpenArrow';
                }
                break;
            case 'Control':
                if (!child.style || !child.style.strokeWidth) {
                    node.style.strokeWidth = 2;
                }
                if (!child.targetDecorator || !child.targetDecorator.shape) {
                    node.targetDecorator.shape = 'OpenArrow';
                }
                if (!child.sourceDecorator || !child.sourceDecorator.shape) {
                    node.sourceDecorator.shape = 'None';
                }
                break;
        }
    }
}
/* eslint-disable */
/**
 * setConnectorDefaults method \
 *
 * @returns {  void } setConnectorDefaults method .\
 * @param {ConnectorModel} child - provide the child  value.
 * @param {ConnectorModel} node - provide the node  value.
 * @private
 */
function setConnectorDefaults(child, node) {
    switch ((child.shape).type) {
        case 'Bpmn':
            var bpmnFlow = child.shape.flow;
            switch (bpmnFlow) {
                case 'Sequence':
                    if ((((child.shape.sequence) === 'Normal' && child.type !== 'Bezier')) ||
                        ((child.shape.sequence) === 'Default') || ((child.shape.sequence) === 'Conditional')) {
                        if (node.targetDecorator && node.targetDecorator.style) {
                            node.targetDecorator.style.fill = (child.targetDecorator && child.targetDecorator.style
                                && child.targetDecorator.style.fill) || 'black';
                        }
                        if ((child.shape.sequence) === 'Conditional' && node.sourceDecorator) {
                            if (node.sourceDecorator.style) {
                                node.sourceDecorator.style.fill = (child.sourceDecorator && child.sourceDecorator.style &&
                                    child.sourceDecorator.style.fill) || 'white';
                            }
                            node.sourceDecorator.width = (child.sourceDecorator && child.sourceDecorator.width) || 20;
                            node.sourceDecorator.height = (child.sourceDecorator && child.sourceDecorator.width) || 10;
                        }
                    }
                    break;
                case 'Association':
                    if (((child.shape.association) === 'Default') ||
                        ((child.shape.association) === 'Directional') ||
                        ((child.shape.association) === 'BiDirectional')) {
                        if (node.targetDecorator && node.targetDecorator.style) {
                            node.targetDecorator.style.fill = (child.targetDecorator && child.targetDecorator.style &&
                                child.targetDecorator.style.fill) || 'black';
                        }
                        if ((child.shape.association) === 'BiDirectional') {
                            if (node.sourceDecorator && node.sourceDecorator.style) {
                                node.sourceDecorator.style.fill = (child.sourceDecorator && child.sourceDecorator.style &&
                                    child.sourceDecorator.style.fill) || 'white';
                                node.sourceDecorator.width = (child.sourceDecorator && child.sourceDecorator.width) || 5;
                                node.sourceDecorator.height = (child.sourceDecorator && child.sourceDecorator.height) || 10;
                            }
                        }
                    }
                    break;
                case 'Message':
                    if (node.style && !node.style.strokeDashArray) {
                        node.style.strokeDashArray = (child.style && child.style.strokeDashArray) || '4 4';
                    }
                    break;
            }
            break;
        case 'UmlActivity':
            var flow = child.shape.flow;
            switch (flow) {
                case 'Exception':
                    if (((child.shape.association) === 'Directional') ||
                        ((child.shape.association) === 'BiDirectional')) {
                        node.style.strokeDashArray = (child.style && child.style.strokeDashArray) || '2 2';
                    }
                    break;
            }
            break;
        case 'UmlClassifier':
            var hasRelation = false;
            if (child.shape.relationship === 'Association') {
                hasRelation = true;
            }
            else if (child.shape.relationship === 'Inheritance') {
                if (node.targetDecorator && node.targetDecorator.style) {
                    node.targetDecorator.style.fill = (child.targetDecorator && child.targetDecorator.style &&
                        child.targetDecorator.style.fill) || 'white';
                }
                if (node.style) {
                    hasRelation = true;
                    node.style.strokeDashArray = (child.style && child.style.strokeDashArray) || '4 4';
                }
            }
            else if (child.shape.relationship === 'Composition') {
                if (node.sourceDecorator && node.sourceDecorator.style) {
                    node.sourceDecorator.style.fill = (child.sourceDecorator && child.sourceDecorator.style &&
                        child.sourceDecorator.style.fill) || 'black';
                }
                hasRelation = true;
            }
            else if (child.shape.relationship === 'Aggregation' ||
                child.shape.relationship === undefined) {
                if (node.sourceDecorator && node.sourceDecorator.style) {
                    node.sourceDecorator.style.fill = (child.sourceDecorator && child.sourceDecorator.style &&
                        child.sourceDecorator.style.fill) || 'white';
                }
                hasRelation = true;
            }
            else if (child.shape.relationship === 'Dependency') {
                if (node.sourceDecorator && node.sourceDecorator.style) {
                    node.sourceDecorator.style.fill = (child.sourceDecorator && child.sourceDecorator.style &&
                        child.sourceDecorator.style.fill) || 'white';
                }
                hasRelation = true;
                node.style.strokeDashArray = '4 4';
            }
            else if (child.shape.relationship === 'Realization') {
                if (node.sourceDecorator && node.sourceDecorator.style) {
                    node.sourceDecorator.style.fill = (child.sourceDecorator && child.sourceDecorator.style &&
                        child.sourceDecorator.style.fill) || 'white';
                }
                hasRelation = true;
            }
            if (hasRelation) {
                node.style.strokeWidth = (child.style && child.style.strokeWidth) || 2;
            }
            break;
    }
}
/* eslint-enable */
/**
 * findNearestPoint method \
 *
 * @returns {  PointModel } findNearestPoint method .\
 * @param {PointModel} reference - provide the reference  value.
 * @param {PointModel} start - provide the start  value.
 * @param {PointModel} end - provide the end  value.
 * @private
 */
function findNearestPoint(reference, start, end) {
    var shortestPoint;
    var shortest = Point.findLength(start, reference);
    var shortest1 = Point.findLength(end, reference);
    if (shortest > shortest1) {
        shortestPoint = end;
    }
    else {
        shortestPoint = start;
    }
    var angleBWStAndEnd = Point.findAngle(start, end);
    var angleBWStAndRef = Point.findAngle(shortestPoint, reference);
    var r = Point.findLength(shortestPoint, reference);
    var vaAngle = angleBWStAndRef + ((angleBWStAndEnd - angleBWStAndRef) * 2);
    return {
        x: (shortestPoint.x + r * Math.cos(vaAngle * Math.PI / 180)),
        y: (shortestPoint.y + r * Math.sin(vaAngle * Math.PI / 180))
    };
}
/**
 * pointsForBezier method \
 *
 * @returns {   PointModel[] } pointsForBezier method .\
 * @param {ConnectorModel} connector - provide the connector  value.
 * @private
 */
function pointsForBezier(connector) {
    var points = [];
    if (connector.type === 'Bezier') {
        var k = 0;
        for (var i = 0; i < connector.segments.length; i++) {
            var tolerance = 1.5;
            var segment = connector.segments[parseInt(i.toString(), 10)];
            //const pt: PointModel = { x: 0, y: 0 };
            var point1 = !Point.isEmptyPoint(segment.point1) ? segment.point1 : segment.bezierPoint1;
            var point2 = !Point.isEmptyPoint(segment.point2) ? segment.point2 : segment.bezierPoint2;
            var max = Number((connector.distance(point1, segment.points[0]) +
                connector.distance(point2, point1) +
                connector.distance(segment.points[1], point2)) / tolerance);
            for (var j = 0; j < max - 1; j = j + 10) {
                points[parseInt(k.toString(), 10)] =
                    bezierPoints(connector, segment.points[0], !Point.isEmptyPoint(segment.point1) ? segment.point1 : segment.bezierPoint1, !Point.isEmptyPoint(segment.point2) ? segment.point2 : segment.bezierPoint2, segment.points[1], j, max);
                k++;
            }
        }
    }
    return points;
}
/**
 * isDiagramChild method \
 *
 * @returns {  boolean } isDiagramChild method .\
 * @param {HTMLElement} htmlLayer - provide the htmlLayer  value.
 * @private
 */
function isDiagramChild(htmlLayer) {
    var element = htmlLayer.parentElement;
    do {
        if (hasClass(element, 'e-diagram')) {
            return true;
        }
        element = element.parentElement;
    } while (element);
    return false;
}
/**
 * groupHasType method \
 *
 * @returns {  boolean } groupHasType method .\
 * @param {NodeModel} node - provide the node  value.
 * @param {Shapes} type - provide the type  value.
 * @param {{}} nameTable - provide the nameTable  value.
 * @private
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function groupHasType(node, type, nameTable) {
    var contains = false;
    if (node && node.children && node.children.length > 0) {
        var child = void 0;
        var i = 0;
        for (; i < node.children.length; i++) {
            child = nameTable[node.children[parseInt(i.toString(), 10)]];
            if (child.shape.type === type) {
                return true;
            }
            return groupHasType(child, type, nameTable);
        }
    }
    return contains;
}
/**
 * groupHasType method \
 *
 * @returns {  void } groupHasType method .\
 * @param {NodeModel | ConnectorModel} actualNode - provide the actualNode  value.
 * @param { NodeModel | ConnectorModel} plainValue - provide the plainValue  value.
 * @param {object} defaultValue - provide the defaultValue  value.
 * @param {NodeModel | ConnectorModel} property - provide the property  value.
 * @param {string} oldKey - provide the oldKey  value.
 * @private
 */
function updateDefaultValues(actualNode, plainValue, 
// eslint-disable-next-line @typescript-eslint/ban-types
defaultValue, property, oldKey) {
    if (defaultValue && ((actualNode instanceof Connector) || actualNode
        && ((actualNode.shape && actualNode.shape.type !== 'SwimLane') || actualNode.shape === undefined))) {
        // eslint-disable-next-line @typescript-eslint/ban-types
        var keyObj = void 0;
        for (var _i = 0, _a = Object.keys(defaultValue); _i < _a.length; _i++) {
            var key = _a[_i];
            keyObj = defaultValue["" + key];
            if (key === 'shape' && keyObj.type) {
                actualNode.shape = { type: keyObj.type };
            }
            if (keyObj) {
                if (Array.isArray(keyObj) && keyObj.length && keyObj.length > 0 && (oldKey !== 'annotations' && oldKey !== 'ports')) {
                    if (actualNode["" + key].length > 0) {
                        for (var i = 0; i <= actualNode["" + key].length; i++) {
                            updateDefaultValues(actualNode["" + key], plainValue ? plainValue["" + key] : undefined, defaultValue["" + key], (key === 'annotations' || key === 'ports') ? actualNode : undefined, key);
                        }
                    }
                    else {
                        updateDefaultValues(actualNode["" + key], plainValue ? plainValue["" + key] : undefined, defaultValue["" + key], (key === 'annotations' || key === 'ports') ? actualNode : undefined, key);
                    }
                }
                else if (keyObj instanceof Object && plainValue && (oldKey !== 'annotations' && oldKey !== 'ports')) {
                    updateDefaultValues(actualNode["" + key], plainValue["" + key], defaultValue["" + key]);
                }
                else if ((oldKey !== 'annotations' && oldKey !== 'ports')
                    && (plainValue && !plainValue["" + key]) || (!plainValue && actualNode
                    && (actualNode["" + key] || actualNode["" + key] !== undefined))) {
                    actualNode["" + key] = defaultValue["" + key];
                }
                else {
                    var createObject = void 0;
                    if (oldKey === 'annotations' || oldKey === 'ports') {
                        if (oldKey === 'annotations') {
                            if (actualNode["" + key]) {
                                updateDefaultValues(actualNode["" + key], plainValue["" + key], defaultValue["" + key]);
                            }
                            if (!actualNode["" + key]) {
                                if (getObjectType(property) === Connector) {
                                    createObject = new PathAnnotation(property, 'annotations', defaultValue["" + key]);
                                    property.annotations.push(createObject);
                                }
                                else {
                                    createObject = new ShapeAnnotation(property, 'annotations', defaultValue["" + key]);
                                    property.annotations.push(createObject);
                                }
                            }
                        }
                        else {
                            if (actualNode["" + key]) {
                                updateDefaultValues(actualNode["" + key], plainValue["" + key], defaultValue["" + key]);
                            }
                            else {
                                createObject = new PointPort(property, 'ports', defaultValue["" + key]);
                                property.ports.push(createObject);
                            }
                        }
                    }
                }
            }
        }
    }
}
/* tslint:disable:no-string-literal */
/**
 * updateLayoutValue method \
 *
 * @returns {  void } updateLayoutValue method .\
 * @param {TreeInfo} actualNode - provide the actualNode  value.
 * @param { object} defaultValue - provide the defaultValue  value.
 * @param {INode[]} nodes - provide the nodes  value.
 * @param {INode} node - provide the node  value.
 * @private
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function updateLayoutValue(actualNode, defaultValue, nodes, node) {
    // eslint-disable-next-line @typescript-eslint/ban-types
    var keyObj;
    var assistantKey = 'Role';
    if (defaultValue) {
        for (var _i = 0, _a = Object.keys(defaultValue); _i < _a.length; _i++) {
            var key = _a[_i];
            keyObj = defaultValue["" + key];
            if (key === 'getAssistantDetails') {
                //Removed isBlazor code
                if (node.data["" + assistantKey] === defaultValue["" + key]['root']) {
                    var assitants = defaultValue["" + key]['assistants'];
                    for (var i = 0; i < assitants.length; i++) {
                        for (var j = 0; j < nodes.length; j++) {
                            if (nodes[parseInt(j.toString(), 10)].data["" + assistantKey] === assitants[parseInt(i.toString(), 10)]) {
                                actualNode.assistants.push(nodes[parseInt(j.toString(), 10)].id);
                                actualNode.children.splice(0, 1);
                            }
                        }
                    }
                }
            }
            else if (keyObj) {
                actualNode["" + key] = defaultValue["" + key];
            }
        }
    }
    if (!actualNode.hasSubTree && defaultValue.canEnableSubTree) {
        actualNode.orientation = node.layoutInfo.orientation;
        actualNode.type = node.layoutInfo.type;
        if (node.layoutInfo.offset !== actualNode.offset && (node.layoutInfo.offset) !== undefined) {
            actualNode.offset = node.layoutInfo.offset;
        }
    }
    node.layoutInfo.hasSubTree = actualNode.hasSubTree;
}
/* tslint:enable:no-string-literal */
/**
 * isPointOverConnector method \
 *
 * @returns {  boolean } isPointOverConnector method .\
 * @param {ConnectorModel} connector - provide the connector  value.
 * @param { PointModel} reference - provide the reference  value.
 * @private
 */
function isPointOverConnector(connector, reference) {
    //let intermediatePoints: PointModel[];
    var intermediatePoints = connector.type === 'Bezier' ? pointsForBezier(connector) :
        connector.intermediatePoints;
    for (var i = 0; i < intermediatePoints.length - 1; i++) {
        var start = intermediatePoints[parseInt(i.toString(), 10)];
        var end = intermediatePoints[i + 1];
        var rect = Rect.toBounds([start, end]);
        rect.Inflate(connector.hitPadding);
        if (rect.containsPoint(reference)) {
            var intersectinPt = findNearestPoint(reference, start, end);
            var segment1 = { x1: start.x, x2: end.x, y1: start.y, y2: end.y };
            var segment2 = { x1: reference.x, x2: intersectinPt.x, y1: reference.y, y2: intersectinPt.y };
            var intersectDetails = intersect3(segment1, segment2);
            if (intersectDetails.enabled) {
                var distance = Point.findLength(reference, intersectDetails.intersectPt);
                if (Math.abs(distance) < connector.hitPadding) {
                    return true;
                }
            }
            else {
                var rect_1 = Rect.toBounds([reference, reference]);
                rect_1.Inflate(3);
                if (rect_1.containsPoint(start) || rect_1.containsPoint(end)) {
                    return true;
                }
            }
            if (Point.equals(reference, intersectinPt)) {
                return true;
            }
        }
    }
    if (connector.annotations.length > 0 || connector.ports.length > 0) {
        var container = connector.wrapper.children;
        for (var i = 3; i < container.length; i++) {
            var textElement = container[parseInt(i.toString(), 10)];
            if (textElement.bounds.containsPoint(reference)) {
                return true;
            }
        }
    }
    return false;
}
/**
 * intersect3 method \
 *
 * @returns {  Intersection } intersect3 method .\
 * @param {ConnectorModel} lineUtil1 - provide the lineUtil1  value.
 * @param { PointModel} lineUtil2 - provide the lineUtil2  value.
 * @private
 */
function intersect3(lineUtil1, lineUtil2) {
    var point = { x: 0, y: 0 };
    var l1 = lineUtil1;
    var l2 = lineUtil2;
    var d = (l2.y2 - l2.y1) * (l1.x2 - l1.x1) - (l2.x2 - l2.x1) * (l1.y2 - l1.y1);
    var na = (l2.x2 - l2.x1) * (l1.y1 - l2.y1) - (l2.y2 - l2.y1) * (l1.x1 - l2.x1);
    var nb = (l1.x2 - l1.x1) * (l1.y1 - l2.y1) - (l1.y2 - l1.y1) * (l1.x1 - l2.x1);
    /*( EJ2-42102 - Connector segments not update properly ) by sivakumar sekar - condition added to avoid bridging for
     overlapping segments in the connectors and to validate whether the connector is intersecting over the other */
    if (d === 0 || ((lineUtil1.x1 === lineUtil2.x1 || lineUtil1.y1 === lineUtil2.y1) &&
        (lineUtil1.x2 === lineUtil2.x2 || lineUtil1.y2 === lineUtil2.y2) && ((na === 0 || nb === 0) && d > 0))) {
        return { enabled: false, intersectPt: point };
    }
    var ua = na / d;
    var ub = nb / d;
    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
        point.x = l1.x1 + (ua * (l1.x2 - l1.x1));
        point.y = l1.y1 + (ua * (l1.y2 - l1.y1));
        return { enabled: true, intersectPt: point };
    }
    return { enabled: false, intersectPt: point };
}
/**
 * intersect2 method \
 *
 * @returns {  PointModel } intersect2 method .\
 * @param {PointModel} start1 - provide the start1  value.
 * @param { PointModel} end1 - provide the end1  value.
 * @param { PointModel} start2 - provide the start2  value.
 * @param { PointModel} end2 - provide the end2  value.
 * @private
 */
function intersect2(start1, end1, start2, end2) {
    var point = { x: 0, y: 0 };
    var lineUtil1 = getLineSegment(start1.x, start1.y, end1.x, end1.y);
    var lineUtil2 = getLineSegment(start2.x, start2.y, end2.x, end2.y);
    var line3 = intersect3(lineUtil1, lineUtil2);
    if (line3.enabled) {
        return line3.intersectPt;
    }
    else {
        return point;
    }
}
/**
 * getLineSegment method \
 *
 * @returns {  Segment } getLineSegment method .\
 * @param {number} x1 - provide the x1  value.
 * @param { number} y1 - provide the y1  value.
 * @param { number} x2 - provide the x2  value.
 * @param { number} y2 - provide the y2  value.
 * @private
 */
function getLineSegment(x1, y1, x2, y2) {
    return { 'x1': Number(x1) || 0, 'y1': Number(y1) || 0, 'x2': Number(x2) || 0, 'y2': Number(y2) || 0 };
}
/**
 * getPoints method \
 *
 * @returns {  PointModel[] } getPoints method .\
 * @param {number} element - provide the element  value.
 * @param { number} corners - provide the corners  value.
 * @param { number} padding - provide the padding  value.
 * @private
 */
function getPoints(element, corners, padding) {
    var line = [];
    padding = padding || 0;
    var left = { x: corners.topLeft.x - padding, y: corners.topLeft.y };
    var right = { x: corners.topRight.x + padding, y: corners.topRight.y };
    var top = { x: corners.bottomRight.x, y: corners.bottomRight.y - padding };
    var bottom = { x: corners.bottomLeft.x, y: corners.bottomLeft.y + padding };
    line.push(left);
    line.push(right);
    line.push(top);
    line.push(bottom);
    return line;
}
/**
 * getTooltipOffset method \
 *
 * @returns {  PointModel[] } getTooltipOffset method .\
 * @param {number} diagram - provide the diagram  value.
 * @param { number} mousePosition - provide the mousePosition  value.
 * @param { NodeModel | ConnectorModel | PointPortModel} node - provide the node  value.
 * @param { string} type - provide the type  value.
 * @private
 */
function getTooltipOffset(diagram, mousePosition, node, type) {
    //let offset: PointModel;
    var inheritTooltip = (node instanceof Node) ? (node.constraints & NodeConstraints.InheritTooltip)
        : (node instanceof Connector) ? (node.constraints & ConnectorConstraints.InheritTooltip)
            : (node.constraints & PortConstraints.InheritTooltip);
    var objectTooltip = (node instanceof Node) ? (node.constraints & NodeConstraints.Tooltip)
        : (node instanceof Connector) ? (node.constraints & ConnectorConstraints.Tooltip)
            : (node.constraints & PortConstraints.ToolTip);
    var isMouseBased = ((!inheritTooltip && objectTooltip ? node.tooltip.relativeMode
        : diagram.tooltip.relativeMode) === 'Mouse') ? true : false;
    if (type === 'Mouse') {
        isMouseBased = true;
    }
    else if (type === 'Object') {
        isMouseBased = false;
    }
    var offset = tooltipOffset(node, mousePosition, diagram, isMouseBased);
    var rulerSize = getRulerSize(diagram);
    return { x: offset.x + rulerSize.width, y: offset.y + rulerSize.height };
}
/**
 * tooltipOffset method \
 *
 * @returns { PointModel } tooltipOffset method .\
 * @param {NodeModel | ConnectorModel | PointPortModel} node - provide the node  value.
 * @param { PointModel} mousePosition - provide the mousePosition  value.
 * @param { Diagram } diagram - provide the diagram  value.
 * @param { boolean} isMouseBased - provide the isMouseBased  value.
 * @private
 */
function tooltipOffset(node, mousePosition, diagram, isMouseBased) {
    var point = {};
    //let scale: number = diagram.scroller.transform.scale;
    var element = document.getElementById(diagram.element.id);
    var bounds;
    //EJ2-62120-Tooltip support for ports
    if (node instanceof Node || node instanceof Connector) {
        bounds = node.wrapper.bounds;
    }
    else {
        var objects = diagram.findObjectsUnderMouse(mousePosition);
        var obj = diagram.findObjectUnderMouse(objects, 'Select', false);
        var portElement = diagram.findElementUnderMouse(obj, mousePosition, diagram);
        bounds = portElement.bounds;
    }
    var rect = element.getBoundingClientRect();
    /* eslint-enable */
    //let horizontalOffset: number = diagram.scroller.horizontalOffset;
    //let verticalOffset: number = diagram.scroller.verticalOffset;
    switch (diagram.tooltipObject.position) {
        case 'BottomCenter':
            point = offsetPoint(mousePosition, bounds.bottomCenter, diagram, isMouseBased, (rect.width / 2), rect.height);
            break;
        case 'BottomLeft':
        case 'LeftBottom':
            point = offsetPoint(mousePosition, bounds.bottomLeft, diagram, isMouseBased, 0, rect.height);
            break;
        case 'BottomRight':
        case 'RightBottom':
            point = offsetPoint(mousePosition, bounds.bottomRight, diagram, isMouseBased, rect.width, rect.height);
            break;
        case 'LeftCenter':
            point = offsetPoint(mousePosition, bounds.middleLeft, diagram, isMouseBased, 0, (rect.height / 2));
            break;
        case 'LeftTop':
        case 'TopLeft':
            point = offsetPoint(mousePosition, bounds.topLeft, diagram, isMouseBased, 0, 0);
            break;
        case 'RightCenter':
            point = offsetPoint(mousePosition, bounds.middleRight, diagram, isMouseBased, rect.width, (rect.height / 2));
            break;
        case 'RightTop':
        case 'TopRight':
            point = offsetPoint(mousePosition, bounds.topRight, diagram, isMouseBased, rect.width, 0);
            break;
        case 'TopCenter':
            point = offsetPoint(mousePosition, bounds.topCenter, diagram, isMouseBased, (rect.width / 2), 0);
            break;
    }
    return point;
}
/**
 * offsetPoint method \
 *
 * @returns { PointModel } offsetPoint method .\
 * @param { PointModel} mousePosition - provide the mousePosition  value.
 * @param { PointModel } bound - provide the diagram  value.
 * @param { Diagram} diagram - provide the isMouseBased  value.
 * @param { boolean} isMouseBased - provide the isMouseBased  value.
 * @param { number} x - provide the isMouseBased  value.
 * @param { number} y - provide the isMouseBased  value.
 * @private
 */
function offsetPoint(mousePosition, bound, diagram, isMouseBased, x, y) {
    var point = {};
    var scale = diagram.scroller.transform.scale;
    var horizontalOffset = diagram.scroller.horizontalOffset;
    var verticalOffset = diagram.scroller.verticalOffset;
    horizontalOffset = diagram.modifyClientOffset(horizontalOffset, true);
    verticalOffset = diagram.modifyClientOffset(verticalOffset, true);
    point.x = (isMouseBased ? mousePosition.x : bound.x) * scale + horizontalOffset - x;
    point.y = (isMouseBased ? mousePosition.y : bound.y) * scale + verticalOffset - y;
    return point;
}
/**
 * Gets the fixed user handles symbol \
 *
 * @returns { DiagramElement } Gets the fixed user handles symbol .\
 * @param {ConnectorFixedUserHandleModel | NodeFixedUserHandleModel} options - provide the options  value.
 * @param { Canvas} fixedUserHandleContainer - provide the fixedUserHandleContainer  value.
 * @private
 */
function initFixedUserHandlesSymbol(options, fixedUserHandleContainer) {
    //let fixedUserHandleContent: PathElement | DiagramNativeElement;
    var fixedUserHandleContent = new PathElement();
    fixedUserHandleContent.data = options.pathData;
    fixedUserHandleContent.height =
        options.height > 10 ? options.height - (options.padding.bottom + options.padding.top) : options.height;
    fixedUserHandleContent.width =
        options.width > 10 ? options.width - (options.padding.left + options.padding.right) : options.width;
    //Bug 912616: Not able to hide the fixedUserHandle in diagram
    fixedUserHandleContent.visible = options.visibility;
    fixedUserHandleContent.id = fixedUserHandleContainer.id + '_shape';
    fixedUserHandleContent.inversedAlignment = false;
    fixedUserHandleContent.horizontalAlignment = 'Center';
    fixedUserHandleContent.verticalAlignment = 'Center';
    fixedUserHandleContent.style = {
        fill: options.iconStrokeColor, strokeColor: options.iconStrokeColor,
        strokeWidth: options.iconStrokeWidth
    };
    fixedUserHandleContent.setOffsetWithRespectToBounds(0.5, 0.5, 'Fraction');
    fixedUserHandleContent.relativeMode = 'Object';
    fixedUserHandleContent.description = fixedUserHandleContainer.description || '';
    return fixedUserHandleContent;
}
/**
 * sort method \
 *
 * @returns { (NodeModel | ConnectorModel)[] } sort method .\
 * @param {(NodeModel | ConnectorModel)[]} objects - provide the options  value.
 * @param { DistributeOptions} option - provide the fixedUserHandleContainer  value.
 * @private
 */
function sort(objects, option) {
    var i = 0;
    var j = 0;
    var temp;
    for (i = 0; i < objects.length; i++) {
        var b = getBounds(objects[parseInt(i.toString(), 10)].wrapper);
        for (j = i + 1; j < objects.length; j++) {
            var bounds = getBounds(objects[parseInt(j.toString(), 10)].wrapper);
            if (option === 'Top' || option === 'Bottom' || option === 'BottomToTop' || option === 'Middle') {
                if (b.center.y > bounds.center.y) {
                    temp = objects[parseInt(i.toString(), 10)];
                    objects[parseInt(i.toString(), 10)] = objects[parseInt(j.toString(), 10)];
                    objects[parseInt(j.toString(), 10)] = temp;
                }
            }
            else {
                if (b.center.x > bounds.center.x) {
                    temp = objects[parseInt(i.toString(), 10)];
                    objects[parseInt(i.toString(), 10)] = objects[parseInt(j.toString(), 10)];
                    objects[parseInt(j.toString(), 10)] = temp;
                }
            }
        }
    }
    return objects;
}
/**
 * getAnnotationPosition method \
 *
 * @returns {SegmentInfo } getAnnotationPosition method .\
 * @param {PointModel[]} pts - provide the pts  value.
 * @param { PathAnnotation | ConnectorFixedUserHandle} annotation - provide the annotation  value.
 * @param { Rect } bound - provide the bound  value.
 * @private
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function getAnnotationPosition(pts, annotation, bound) {
    //let angle: number;
    //let getloop: SegmentInfo;
    //let point: PointModel;
    var getloop = getOffsetOfConnector(pts, annotation);
    var angle = Point.findAngle(pts[getloop.index], pts[getloop.index + 1]);
    var alignednumber = getAlignedPosition(annotation);
    var point = Point.transform(getloop.point, angle + 45, alignednumber);
    getloop.point = point;
    getloop.angle = angle;
    return getloop;
}
/**
 * getPortsPosition method \
 *
 * @returns {SegmentInfo } getPortsPosition method .\
 * @param {PointModel[]} pts - provide the pts  value.
 * @param { Port} ports - provide the ports  value.
 * @param { Rect } bound - provide the bound  value.
 * @private
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function getPortsPosition(pts, ports, bound) {
    var getloop = getOffsetOfPorts(pts, ports);
    var angle = Point.findAngle(pts[getloop.index], pts[getloop.index + 1]);
    var alignednumber = getAlignedPositionForPorts(ports);
    var point = Point.transform(getloop.point, angle + 45, alignednumber);
    getloop.point = point;
    getloop.angle = angle;
    return getloop;
}
/**
 * getOffsetOfPorts method \
 *
 * @returns {SegmentInfo } getOffsetOfPorts method .\
 * @param {PointModel[]} points - provide the pts  value.
 * @param { PathAnnotation | ConnectorFixedUserHandle} ports - provide the ports  value.
 * @private
 */
function getOffsetOfPorts(points, ports) {
    // eslint-disable-next-line
    var distance = 0;
    var offset = ports.offset;
    var point;
    var angle;
    var pointDistance = [];
    var prevLength;
    var kCount;
    for (var j = 0; j < points.length - 1; j++) {
        distance += Point.distancePoints(points[parseInt(j.toString(), 10)], points[j + 1]);
        pointDistance.push(distance);
    }
    var offsetLength = offset * distance;
    for (var k = 0; k < pointDistance.length; k++) {
        if (pointDistance[parseInt(k.toString(), 10)] >= offsetLength) {
            angle = Point.findAngle(points[parseInt(k.toString(), 10)], points[k + 1]);
            point = Point.transform(points[parseInt(k.toString(), 10)], angle, offsetLength - (prevLength || 0));
            kCount = k;
            return { point: point, index: kCount };
        }
        prevLength = pointDistance[parseInt(k.toString(), 10)];
    }
    return { point: point, index: kCount };
}
/**
 * getAlignedPosition method . To get the port alignment position \
 *
 * @returns {number } getAlignedPosition method .\
 * @param {PointModel[]} ports - provide the annotation value.
 * @private
 */
function getAlignedPositionForPorts(ports) {
    var constant = 0;
    var state = 0;
    switch (ports.alignment) {
        case 'Center':
            state = 0;
            break;
        case 'Before':
            state = -((0) / 2 + constant);
            break;
        case 'After':
            state = ((0) / 2 + constant);
            break;
    }
    return state;
}
/**
 * getOffsetOfConnector method \
 *
 * @returns {SegmentInfo } getOffsetOfConnector method .\
 * @param {PointModel[]} points - provide the pts  value.
 * @param { PathAnnotation | ConnectorFixedUserHandle} annotation - provide the annotation  value.
 * @private
 */
function getOffsetOfConnector(points, annotation) {
    // eslint-disable-next-line
    var length = 0;
    var offset = annotation.offset;
    var point;
    var angle;
    var lengths = [];
    var prevLength;
    var kCount;
    for (var j = 0; j < points.length - 1; j++) {
        length += Point.distancePoints(points[parseInt(j.toString(), 10)], points[j + 1]);
        lengths.push(length);
    }
    var offsetLength = offset * length;
    for (var k = 0; k < lengths.length; k++) {
        if (lengths[parseInt(k.toString(), 10)] >= offsetLength) {
            angle = Point.findAngle(points[parseInt(k.toString(), 10)], points[k + 1]);
            point = Point.transform(points[parseInt(k.toString(), 10)], angle, offsetLength - (prevLength || 0));
            kCount = k;
            return { point: point, index: kCount };
        }
        prevLength = lengths[parseInt(k.toString(), 10)];
    }
    return { point: point, index: kCount };
}
/**
 * getAlignedPosition method \
 *
 * @returns {number } getAlignedPosition method .\
 * @param {PointModel[]} annotation - provide the annotation value.
 * @private
 */
function getAlignedPosition(annotation) {
    var cnst;
    if ((annotation instanceof ConnectorFixedUserHandle)) {
        cnst = 0;
    }
    else {
        cnst = annotation.content === undefined ? 10 : 0;
    }
    var state = 0;
    switch (annotation.alignment) {
        case 'Center':
            state = 0;
            break;
        case 'Before':
            state = -((0) / 2 + cnst);
            break;
        case 'After':
            state = ((0) / 2 + cnst);
            break;
    }
    return state;
}
/**
 * alignLabelOnSegments method \
 *
 * @returns {Alignment } alignLabelOnSegments method .\
 * @param {PathAnnotation | ConnectorFixedUserHandle} obj - provide the obj  value.
 * @param { number } ang - provide the ang  value.
 * @param { PointModel[] } pts - provide the pts  value.
 * @private
 */
function alignLabelOnSegments(obj, ang, pts) {
    //let angle: number = ang % 360;
    ang %= 360;
    var fourty5 = 45;
    var one35 = 135;
    var two25 = 225;
    var three15 = 315;
    var vAlign;
    var hAlign;
    switch (obj.alignment) {
        case 'Before':
            if (ang >= fourty5 && ang <= one35) {
                hAlign = 'right';
                vAlign = obj.offset === 0.5 ? 'center' : 'top';
            }
            else if (ang >= two25 && ang <= three15) {
                hAlign = 'left';
                vAlign = obj.offset === 0.5 ? 'center' : 'bottom';
            }
            else if (ang > fourty5 && ang < two25) {
                vAlign = 'top';
                hAlign = obj.offset === 0.5 ? 'center' : 'right';
            }
            else {
                vAlign = 'bottom';
                hAlign = (obj.offset === 0.5) ? 'center' : 'left';
            }
            break;
        case 'After':
            if (ang >= fourty5 && ang <= one35) {
                hAlign = 'left';
                vAlign = obj.offset === 0.5 ? 'center' : 'top';
            }
            else if (ang >= two25 && ang <= three15) {
                hAlign = 'right';
                vAlign = obj.offset === 0.5 ? 'center' : 'bottom';
            }
            else if (ang > fourty5 && ang < two25) {
                vAlign = 'bottom';
                hAlign = obj.offset === 0.5 ? 'center' : 'right';
            }
            else {
                vAlign = 'top';
                hAlign = obj.offset === 0.5 ? 'center' : 'left';
            }
            break;
        case 'Center':
            hAlign = !isNullOrUndefined(obj.horizontalAlignment) ? obj.horizontalAlignment.toLowerCase() : 'center';
            vAlign = !isNullOrUndefined(obj.verticalAlignment) ? obj.verticalAlignment.toLowerCase() : 'center';
            break;
    }
    if (obj.offset === 0 || obj.offset === 1) {
        //let direction: string;
        var direction = getBezierDirection(pts[0], pts[1]);
        switch (direction) {
            case 'left':
                hAlign = obj.offset === 0 ? 'right' : 'left';
                break;
            case 'right':
                hAlign = obj.offset === 0 ? 'left' : 'right';
                break;
            case 'bottom':
                vAlign = obj.offset === 0 ? 'top' : 'bottom';
                break;
            case 'top':
                vAlign = obj.offset === 0 ? 'bottom' : 'top';
                break;
        }
    }
    return { hAlign: hAlign, vAlign: vAlign };
}
/**
 * getBezierDirection method \
 *
 * @returns {string } getBezierDirection method .\
 * @param {PointModel} src - provide the src  value.
 * @param { PointModel } tar - provide the tar  value.
 * @private
 */
function getBezierDirection(src, tar) {
    if (Math.abs(tar.x - src.x) > Math.abs(tar.y - src.y)) {
        return src.x < tar.x ? 'right' : 'left';
    }
    else {
        return src.y < tar.y ? 'bottom' : 'top';
    }
}
/**
 * removeChildNodes method \
 *
 * @returns {void } removeChildNodes method .\
 * @param {NodeModel} node - provide the node  value.
 * @param { Diagram } diagram - provide the diagram  value.
 * @private
 */
function removeChildNodes(node, diagram) {
    if (node instanceof Node && node.children) {
        for (var i = 0; i < node.children.length; i++) {
            if (diagram.nameTable[node.children[parseInt(i.toString(), 10)]].children) {
                removeChildNodes(node, diagram);
            }
            diagram.removeFromAQuad(diagram.nameTable[node.children[parseInt(i.toString(), 10)]]);
            diagram.removeObjectsFromLayer(diagram.nameTable[node.children[parseInt(i.toString(), 10)]]);
            delete diagram.nameTable[node.children[parseInt(i.toString(), 10)]];
        }
    }
}
/**
 * getChild method \
 *
 * @returns {string[] } getChild method .\
 * @param {Canvas} child - provide the child  value.
 * @param { string[] } children - provide the children  value.
 * @private
 */
function getChild(child, children) {
    if (child && child.children && child.children.length > 0) {
        for (var j = 0; j < child.children.length; j++) {
            var subChild = child.children[parseInt(j.toString(), 10)];
            if (subChild instanceof Canvas) {
                getChild(subChild, children);
            }
        }
    }
    if (children.indexOf(child.id) === -1) {
        children.push(child.id);
    }
    return children;
}
/**
 * getSwimLaneChildren method \
 *
 * @returns {string[] } getSwimLaneChildren method .\
 * @param {NodeModel[]} nodes - provide the nodes  value.
 * @private
 */
function getSwimLaneChildren(nodes) {
    var children = [];
    var node;
    var grid;
    var childTable;
    var child;
    var gridChild = 'childTable';
    for (var i = 0; i < nodes.length; i++) {
        node = nodes[parseInt(i.toString(), 10)];
        if (node.shape.type === 'SwimLane') {
            grid = node.wrapper.children[0];
            childTable = grid["" + gridChild];
            for (var _i = 0, _a = Object.keys(childTable); _i < _a.length; _i++) {
                var key = _a[_i];
                child = childTable["" + key];
                children = getChild(child, children);
            }
        }
    }
    return children;
}
/**
 * removeUnnecessaryNodes method \
 *
 * @returns {void } removeUnnecessaryNodes method .\
 * @param {string[]} children - provide the children  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @private
 */
function removeUnnecessaryNodes(children, diagram) {
    var nodes = diagram.nodes;
    if (nodes) {
        for (var i = 0; i < nodes.length; i++) {
            if (children.indexOf(nodes[parseInt(i.toString(), 10)].id) !== -1) {
                nodes.splice(i, 1);
                i--;
            }
        }
    }
}
/**
 * serialize method \
 *
 * @returns {string } serialize method .\
 * @param {Diagram} model - provide the model  value.
 * @private
 */
function serialize(model) {
    var removeNodes = getSwimLaneChildren(model.nodes);
    var clonedObject = cloneObject(model, model.getCustomProperty);
    clonedObject.selectedItems.nodes = [];
    clonedObject.selectedItems.connectors = [];
    clonedObject.selectedItems.wrapper = null;
    if (model.serializationSettings.preventDefaults) {
        clonedObject = preventDefaults(clonedObject, model);
    }
    // EJ2-913802 Sub process child won't get serialized when it is a child of a lane.
    model.nodes.forEach(function (node) {
        if (node.shape.type === 'SwimLane') {
            var processes_1 = model.commandHandler.findProcesses(node);
            processes_1.forEach(function (processId) {
                clonedObject.nodes.forEach(function (clonedNode) {
                    if (clonedNode.id === processId) {
                        var nodeWrapper = clonedNode.wrapper;
                        clonedNode.offsetX = nodeWrapper.offsetX;
                        clonedNode.offsetY = nodeWrapper.offsetY;
                    }
                });
            });
            if (processes_1.length > 0) {
                removeNodes = removeNodes.filter(function (removeNodeId) { return !processes_1.includes(removeNodeId); });
            }
        }
    });
    removeUnnecessaryNodes(removeNodes, clonedObject);
    return JSON.stringify(clonedObject);
}
/**
 * preventDefaults method \
 *
 * @returns {string } preventDefaults method .\
 * @param {Object} clonedObject - provide the clonedObject  value.
 * @param {object} model - provide the model  value.
 * @param {object} defaultObject - provide the defaultObject  value.
 * @param {boolean} isNodeShape - provide the isNodeShape  value.
 * @private
 */
// eslint-disable-next-line
function preventDefaults(clonedObject, model, defaultObject, isNodeShape) {
    defaultObject = getConstructor(model, defaultObject);
    var properties = [];
    properties = properties.concat(Object.keys(clonedObject));
    for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
        var property = properties_1[_i];
        if (model instanceof Node) {
            isNodeShape = (property === 'shape') ? true : false;
        }
        if (clonedObject["" + property] instanceof Array) {
            preventArrayDefaults(clonedObject, defaultObject, model, property);
        }
        else if ((clonedObject["" + property] instanceof Object) && defaultObject && defaultObject["" + property]) {
            if (property !== 'wrapper') {
                clonedObject["" + property] = preventDefaults(clonedObject["" + property], model["" + property], defaultObject["" + property], isNodeShape);
            }
        }
        else if ((defaultObject && clonedObject["" + property] === defaultObject["" + property]) || clonedObject["" + property] === undefined) {
            if (!(isNodeShape && property === 'type') && !(model instanceof SwimLane && property === 'orientation')) {
                delete clonedObject["" + property];
            }
        }
        if (JSON.stringify(clonedObject["" + property]) === '[]' ||
            JSON.stringify(clonedObject["" + property]) === '{}' ||
            clonedObject["" + property] === undefined) {
            delete clonedObject["" + property];
        }
    }
    defaultObject = undefined;
    properties = undefined;
    return clonedObject;
}
/**
 * preventArrayDefaults method \
 *
 * @returns {void } preventArrayDefaults method .\
 * @param {object} clonedObject - provide the clonedObject  value.
 * @param {object} defaultObject - provide the defaultObject  value.
 * @param {object} model - provide the model  value.
 * @param {string} property - provide the property  value.
 * @private
 */
// eslint-disable-next-line
function preventArrayDefaults(clonedObject, defaultObject, model, property) {
    if (clonedObject["" + property].length === 0) {
        delete clonedObject["" + property];
        // eslint-disable-next-line
    }
    else if (clonedObject[property].every(function (element) { return typeof element === 'number'; })) {
        var i = void 0;
        var isSameArray = true;
        for (i = 0; i < clonedObject["" + property].length; i++) {
            if (isSameArray && clonedObject["" + property][parseInt(i.toString(), 10)] === defaultObject["" + property][parseInt(i.toString(), 10)]) {
                isSameArray = true;
            }
            else {
                isSameArray = false;
            }
        }
        if (isSameArray) {
            delete clonedObject["" + property];
        }
    }
    else {
        var i = void 0;
        // Bug 826717: Unable to select swimlane child nodes after serializing the diagram when we enable preventDefault property.
        // Removed the codition to delete the layers from clonedObject.
        if (clonedObject["" + property] && property !== 'layers') {
            for (i = clonedObject["" + property].length - 1; i >= 0; i--) {
                if (property === 'nodes' || property === 'connectors') {
                    clonedObject["" + property][parseInt(i.toString(), 10)].wrapper = null;
                }
                if (property !== 'dataManager') {
                    clonedObject["" + property][parseInt(i.toString(), 10)] = preventDefaults(clonedObject["" + property][parseInt(i.toString(), 10)], model["" + property][parseInt(i.toString(), 10)], (defaultObject["" + property] !== undefined ? defaultObject["" + property][parseInt(i.toString(), 10)] : []));
                    if (JSON.stringify(clonedObject["" + property][parseInt(i.toString(), 10)]) === '[]' ||
                        JSON.stringify(clonedObject["" + property][parseInt(i.toString(), 10)]) === '{}' ||
                        clonedObject["" + property][parseInt(i.toString(), 10)] === undefined) {
                        clonedObject["" + property].splice(i, 1);
                    }
                }
            }
        }
    }
    clonedObject = undefined;
}
/* eslint-disable */
/**
 * getConstructor method \
 *
 * @returns {object } getConstructor method .\
 * @param {object} model - provide the model  value.
 * @param {object} defaultObject - provide the defaultObject  value.
 * @private
 */
/* tslint:disable */
function getConstructor(model, defaultObject) {
    var obj = [];
    var constructor;
    var getClassName = 'getClassName';
    if (model[getClassName]) {
        //EJ2-59327 - Memory leak occurs in saveDiagram method 
        var parent_1 = new Diagram();
        switch (model[getClassName]()) {
            case 'Diagram':
                constructor = parent_1;
                break;
            case 'Node':
                constructor = new Node(parent_1, '', obj);
                break;
            case 'Path':
                constructor = new Path(parent_1, '', obj);
                break;
            case 'Native':
                constructor = new Native(parent_1, '', obj);
                break;
            case 'Html':
                constructor = new Html(parent_1, '', obj);
                break;
            case 'Image':
                constructor = new Image$1(parent_1, '', obj);
                break;
            case 'Text':
                constructor = new Text(parent_1, '', obj);
                break;
            case 'BasicShape':
                constructor = new BasicShape(parent_1, '', obj);
                break;
            case 'FlowShape':
                constructor = new FlowShape(parent_1, '', obj);
                break;
            case 'BpmnShape':
                constructor = new BpmnShape(parent_1, '', obj);
                break;
            case 'UmlActivityShape':
                constructor = new UmlActivityShape(parent_1, '', obj);
                break;
            case 'UmlClassifierShape':
                constructor = new UmlClassifierShape(parent_1, '', obj);
                break;
            case 'SwimLane':
                constructor = new SwimLane(parent_1, '', obj);
                if (model.header) {
                    constructor.header = new Header(parent_1, '', obj);
                    constructor.header.style.fill = '';
                }
                break;
            case 'ShapeAnnotation':
                constructor = new ShapeAnnotation(parent_1, '', obj);
                break;
            case 'PointPort':
                constructor = new PointPort(parent_1, '', obj);
                break;
            case 'BpmnGateway':
                constructor = new BpmnGateway(parent_1, '', obj);
                break;
            case 'BpmnDataObject':
                constructor = new BpmnDataObject(parent_1, '', obj);
                break;
            case 'BpmnEvent':
                constructor = new BpmnEvent(parent_1, '', obj);
                break;
            case 'BpmnSubEvent':
                constructor = new BpmnSubEvent(parent_1, '', obj);
                break;
            case 'BpmnActivity':
                constructor = new BpmnActivity(parent_1, '', obj);
                break;
            case 'BpmnAnnotation':
                constructor = new BpmnAnnotation(parent_1, '', obj);
                break;
            case 'MethodArguments':
                constructor = new MethodArguments(parent_1, '', obj);
                break;
            case 'UmlClassAttribute':
                constructor = new UmlClassAttribute(parent_1, '', obj);
                break;
            case 'UmlClassMethod':
                constructor = new UmlClassMethod(parent_1, '', obj);
                break;
            case 'UmlClass':
                constructor = new UmlClass(parent_1, '', obj);
                break;
            case 'UmlInterface':
                constructor = new UmlInterface(parent_1, '', obj);
                break;
            case 'UmlEnumerationMember':
                constructor = new UmlEnumerationMember(parent_1, '', obj);
                break;
            case 'UmlEnumeration':
                constructor = new UmlEnumeration(parent_1, '', obj);
                break;
            case 'Lane':
                constructor = new Lane(parent_1, '', obj);
                break;
            case 'Phase':
                constructor = new Phase(parent_1, '', obj);
                break;
            case 'ChildContainer':
                constructor = new ChildContainer();
                break;
            case 'Connector':
                constructor = new Connector(parent_1, '', obj);
                break;
            case 'StraightSegment':
                constructor = new StraightSegment(parent_1, '', obj);
                break;
            case 'BezierSegment':
                constructor = new BezierSegment(parent_1, '', obj);
                break;
            case 'OrthogonalSegment':
                constructor = new OrthogonalSegment(parent_1, '', obj);
                break;
            case 'PathAnnotation':
                constructor = new PathAnnotation(parent_1, '', obj);
                break;
            case 'Stop':
                constructor = new Stop(parent_1, '', obj);
                break;
            case 'Point':
                if (!defaultObject) {
                    constructor = new Point(parent_1, '', obj);
                }
                else {
                    constructor = defaultObject;
                }
                break;
            case 'UserHandle':
                constructor = new UserHandle(parent_1, '', obj);
                break;
            case 'Command':
                constructor = new Command(parent_1, '', obj);
                break;
        }
    }
    else {
        constructor = defaultObject;
    }
    parent = undefined;
    defaultObject = undefined;
    return constructor;
}
/* eslint-enable */
/* eslint-disable */
/** @private */
function deserialize(model, diagram) {
    diagram.enableServerDataBinding(false);
    var blazorAction = diagram.blazorActions;
    diagram.blazorActions = diagram.addConstraints(blazorAction, BlazorAction.ClearObject);
    diagram.clear();
    diagram.blazorActions = diagram.removeConstraints(blazorAction, BlazorAction.ClearObject);
    diagram.protectPropertyChange(true);
    var map = diagram.dataSourceSettings.doBinding;
    var nodeTemp = diagram.setNodeTemplate;
    var getDescription = diagram.getDescription;
    var getCustomProperty = diagram.getCustomProperty;
    var commands = {};
    for (var _i = 0, _a = diagram.commandManager.commands; _i < _a.length; _i++) {
        var command = _a[_i];
        commands[command.name] = { execute: command.execute, canExecute: command.canExecute };
    }
    var arrangeTickHorizontal = diagram.rulerSettings.horizontalRuler.arrangeTick;
    var arrangeTickVertical = diagram.rulerSettings.verticalRuler.arrangeTick;
    var getLayoutInfo = diagram.layout.getLayoutInfo;
    var getBranch = diagram.layout.getBranch;
    var nodeDefaults = diagram.getNodeDefaults;
    var connectorDefaults = diagram.getConnectorDefaults;
    var dataObj;
    if (!(model instanceof Object)) {
        dataObj = JSON.parse(model);
    }
    else {
        dataObj = model;
    }
    dataObj = upgrade(dataObj);
    diagram.contextMenuSettings = dataObj.contextMenuSettings || {};
    diagram.constraints = dataObj.constraints || DiagramConstraints.Default;
    diagram.tool = dataObj.tool || DiagramTools.Default;
    diagram.bridgeDirection = dataObj.bridgeDirection || 'Top';
    diagram.pageSettings = dataObj.pageSettings || {};
    diagram.drawingObject = dataObj.drawingObject || undefined;
    diagram.tooltip = dataObj.tooltip || {};
    diagram.addInfo = dataObj.addInfo || undefined;
    diagram.getDescription = getDescription;
    diagram.scrollSettings = dataObj.scrollSettings || {};
    diagram.commandManager = dataObj.commandManager || {};
    /**
    * EJ2-62846-Exception occurs after save and load when layers are undefined.
    */
    if (dataObj.layers && dataObj.layers.length > 0) {
        sortLayerObjects(dataObj);
    }
    diagram.layers = dataObj.layers || [];
    diagram.rulerSettings.horizontalRuler.arrangeTick = arrangeTickHorizontal;
    diagram.rulerSettings.verticalRuler.arrangeTick = arrangeTickVertical;
    for (var _b = 0, _c = diagram.commandManager.commands; _b < _c.length; _b++) {
        var cmd = _c[_b];
        if (commands[cmd.name]) {
            cmd.execute = commands[cmd.name].execute;
            cmd.canExecute = commands[cmd.name].canExecute;
        }
    }
    diagram.backgroundColor = dataObj.backgroundColor || 'transparent';
    diagram.basicElements = dataObj.basicElements || [];
    // EJ2-66465 - Added below code to empty the segment collection if connector type is bezier
    if (dataObj.connectors) {
        for (var i = 0; i < dataObj.connectors.length; i++) {
            // EJ2-69816 - Added below code to empty the segment collection if connector type is bezier and allowSegmentsReset is true
            if (dataObj.connectors[i].type === 'Bezier' && dataObj.connectors[i].segments.length > 0 && dataObj.connectors[i].bezierSettings && dataObj.connectors[i].bezierSettings.allowSegmentsReset) {
                dataObj.connectors[i].segments = [];
            }
        }
    }
    diagram.connectors = dataObj.connectors || [];
    diagram.dataSourceSettings = dataObj.dataSourceSettings || {};
    diagram.dataSourceSettings.doBinding = map;
    diagram.height = dataObj.height || '100%';
    diagram.setNodeTemplate = nodeTemp;
    diagram.getConnectorDefaults = connectorDefaults;
    diagram.getNodeDefaults = nodeDefaults;
    diagram.getCustomProperty = getCustomProperty;
    diagram.mode = dataObj.mode || 'SVG';
    if (dataObj.nodes) {
        for (var i = 0; i < dataObj.nodes.length; i++) {
            if (dataObj.nodes[i].shape && dataObj.nodes[i].shape.type === 'SwimLane') {
                if (dataObj.nodes[i].wrapper == null) {
                    {
                        dataObj.nodes[i].wrapper = {
                            actualSize: { width: dataObj.nodes[i].width, height: dataObj.nodes[i].height },
                            offsetX: dataObj.nodes[i].offsetX, offsetY: dataObj.nodes[i].offsetY
                        };
                    }
                }
                pasteSwimLane(dataObj.nodes[i], undefined, undefined, undefined, undefined, true);
            }
        }
    }
    diagram.nodes = dataObj.nodes || [];
    changeOldFlipDirectionType(diagram.nodes);
    changeOldFlipDirectionType(diagram.connectors);
    diagram.rulerSettings = dataObj.rulerSettings || {};
    diagram.snapSettings = dataObj.snapSettings || {};
    diagram.width = dataObj.width || '100%';
    diagram.layout = dataObj.layout || {};
    if (dataObj.layout && dataObj.layout.type !== "None") {
        diagram.canLayout = false;
    }
    diagram.layout.getLayoutInfo = getFunction(getLayoutInfo);
    diagram.layout.getBranch = getFunction(getBranch);
    diagram.diagramActions = 0;
    diagram.isLoading = true;
    diagram.protectPropertyChange(false);
    var component;
    for (var i = 0; i < diagram.views.length; i++) {
        component = diagram.views[diagram.views[i]];
        diagram.blazorActions = diagram.addConstraints(blazorAction, BlazorAction.ClearObject);
        component.refresh();
        // Bug 849892: The Overview does not update properly When loading the diagram with the loadDiagram API.
        // For this -> EJ2-69580  issue the overview refresh got prevented which leads to this Bug 849892, so added below condition to reset 
        // the overview.
        if (component instanceof Overview) {
            component.onPropertyChanged({ sourceID: component.sourceID }, {});
        }
        diagram.blazorActions = diagram.removeConstraints(blazorAction, BlazorAction.ClearObject);
        if (component instanceof Diagram) {
            diagram.element.classList.add('e-diagram');
        }
    }
    //881117 - Event to notify after diagram elements are loaded. 
    var args = { name: 'loaded', diagram: diagram };
    diagram.triggerEvent(DiagramEvent.loaded, args);
    if (dataObj.selectedItems) {
        dataObj.selectedItems.nodes = [];
        dataObj.selectedItems.connectors = [];
        //EJ2-61674 Exception occurs when we move the node after save and load
        dataObj.selectedItems.selectedObjects = [];
    }
    diagram.selectedItems = dataObj.selectedItems;
    diagram.enableServerDataBinding(true);
    diagram.canLayout = true;
    diagram.swimlaneChildTable = {};
    diagram.swimlaneZIndexTable = {};
    // EJ2-913802 Sub process child won't get serialized when it is a child of a lane.
    diagram.nodes.forEach(function (node) {
        if (node.shape.type === 'SwimLane') {
            var processes = diagram.commandHandler.findProcesses(node);
            processes.forEach(function (processId) {
                var child = diagram.nameTable[processId];
                if (child && diagram.nameTable[child.processId]) {
                    var targetWrapper = diagram.nameTable[child.processId].wrapper;
                    targetWrapper.children.push(child.wrapper);
                }
            });
        }
    });
    return dataObj;
}
/**
 * To change the string type flip into enum type.\
 *
 * @param {(NodeModel | ConnectorModel)[]} obj - provide the node or connector collection.
 * @private
 */
function changeOldFlipDirectionType(obj) {
    // Filter elements that have `flip` set as a string
    var filteredElements = obj.filter(function (element) { return typeof element.flip === 'string'; });
    // Loop through the filtered elements and update their `flip` property
    for (var _i = 0, filteredElements_1 = filteredElements; _i < filteredElements_1.length; _i++) {
        var element = filteredElements_1[_i];
        switch (element.flip) {
            case 'Horizontal':
                element.flip = FlipDirection.Horizontal;
                break;
            case 'Vertical':
                element.flip = FlipDirection.Vertical;
                break;
            case 'Both':
                element.flip = FlipDirection.Both;
                break;
            case 'None':
                element.flip = FlipDirection.None;
                break;
        }
    }
}
/**
 * EJ2-61537 - Connectors not connected to the node after save and load
 * when we add nodes and connectors at runtime.
 * */
/**
* Sort the nodes and connectors in the layers.
*
* @param {Diagram} dataObj - provide the model value.
* @private
* */
function sortLayerObjects(dataObj) {
    var i, j, k;
    var layers = [];
    for (i = 0; i < dataObj.layers.length; i++) {
        for (j = 0; j < dataObj.layers[i].objects.length; j++) {
            if (dataObj.nodes) {
                for (k = 0; k < dataObj.nodes.length; k++) {
                    if (dataObj.layers[i].objects[j] === dataObj.nodes[k].id) {
                        layers.push(dataObj.layers[i].objects[j]);
                    }
                }
            }
        }
        for (j = 0; j < dataObj.layers[i].objects.length; j++) {
            if (dataObj.connectors) {
                for (k = 0; k < dataObj.connectors.length; k++) {
                    if (dataObj.layers[i].objects[j] === dataObj.connectors[k].id) {
                        layers.push(dataObj.layers[i].objects[j]);
                    }
                }
            }
        }
        dataObj.layers[i].objects = layers;
        layers = [];
    }
}
/* eslint-enable */
/**
 * upgrade method \
 *
 * @returns {Diagram } upgrade method .\
 * @param {Diagram} dataObj - provide the model  value.
 * @private
 */
function upgrade(dataObj) {
    if (dataObj && (dataObj.version === undefined || (dataObj.version < 17.1)) && dataObj.nodes) {
        var nodes = dataObj.nodes;
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
            var node = nodes_1[_i];
            if (node && node.ports && node.ports.length > 0) {
                for (var _a = 0, _b = node.ports; _a < _b.length; _a++) {
                    var port = _b[_a];
                    if (port && port.constraints && port.constraints === PortConstraints.None) {
                        port.constraints = PortConstraints.Default;
                    }
                }
            }
        }
    }
    return dataObj;
}
/**
 * updateStyle method \
 *
 * @returns {void } updateStyle method .\
 * @param {TextStyleModel} changedObject - provide the changedObject  value.
 * @param {DiagramElement} target - provide the target  value.
 * @private
 */
function updateStyle(changedObject, target) {
    //since text style model is the super set of shape style model, we used text style model
    var style = target.style;
    var textElement = target;
    target.canApplyStyle = true;
    for (var _i = 0, _a = Object.keys(changedObject); _i < _a.length; _i++) {
        var key = _a[_i];
        switch (key) {
            case 'fill':
                style.fill = changedObject.fill;
                if (style instanceof StrokeStyle) {
                    /* tslint:disable:no-string-literal */
                    style['fill'] = 'transparent';
                }
                break;
            case 'textOverflow':
                style.textOverflow = changedObject.textOverflow;
                break;
            case 'opacity':
                style.opacity = changedObject.opacity;
                break;
            case 'strokeColor':
                style.strokeColor = changedObject.strokeColor;
                break;
            case 'strokeDashArray':
                style.strokeDashArray = changedObject.strokeDashArray;
                break;
            case 'strokeWidth':
                style.strokeWidth = changedObject.strokeWidth;
                break;
            case 'bold':
                style.bold = changedObject.bold;
                break;
            case 'color':
                style.color = changedObject.color;
                break;
            case 'textWrapping':
                style.textWrapping = changedObject.textWrapping;
                break;
            case 'fontFamily':
                style.fontFamily = changedObject.fontFamily;
                break;
            case 'fontSize':
                style.fontSize = changedObject.fontSize;
                break;
            case 'italic':
                style.italic = changedObject.italic;
                break;
            case 'textAlign':
                style.textAlign = changedObject.textAlign;
                break;
            case 'whiteSpace':
                style.whiteSpace = changedObject.whiteSpace;
                break;
            case 'textDecoration':
                style.textDecoration = changedObject.textDecoration;
                break;
            case 'gradient':
                if (style.gradient) {
                    updateGradient(changedObject.gradient, style.gradient);
                    break;
                }
        }
    }
    if (target instanceof TextElement) {
        textElement.refreshTextElement();
    }
}
/**
 * updateGradient method \
 *
 * @returns {void } updateGradient method .\
 * @param {GradientModel | LinearGradientModel | RadialGradientModel} changedGradient - provide the changedGradient  value.
 * @param {GradientModel | LinearGradientModel | RadialGradientModel} targetGradient - provide the targetGradient  value.
 * @private
 */
function updateGradient(changedGradient, targetGradient) {
    for (var _i = 0, _a = Object.keys(changedGradient); _i < _a.length; _i++) {
        var key = _a[_i];
        switch (key) {
            case 'type':
                targetGradient.type = changedGradient.type;
                break;
            case 'x1':
                targetGradient.x1 = changedGradient.x1;
                break;
            case 'x2':
                targetGradient.x2 = changedGradient.x2;
                break;
            case 'y1':
                targetGradient.y1 = changedGradient.y1;
                break;
            case 'y2':
                targetGradient.y2 = changedGradient.y2;
                break;
            case 'cx':
                targetGradient.cx = changedGradient.cx;
                break;
            case 'cy':
                targetGradient.cy = changedGradient.cy;
                break;
            case 'fx':
                targetGradient.fx = changedGradient.fx;
                break;
            case 'fy':
                targetGradient.fy = changedGradient.fy;
                break;
            case 'r':
                targetGradient.r = changedGradient.r;
                break;
            case 'stops':
                targetGradient.stops = changedGradient.stops;
                break;
        }
    }
}
/* eslint-disable */
/**
 * updateHyperlink method \
 *
 * @returns {void } updateHyperlink method .\
 * @param {HyperlinkModel} changedObject - provide the changedObject  value.
 * @param {DiagramElement} target - provide the target  value.
 * @param {AnnotationModel} actualAnnotation - provide the actualAnnotation  value.
 * @private
 */
function updateHyperlink(changedObject, target, actualAnnotation) {
    var textElement = target;
    var hyperlink = textElement.hyperlink;
    for (var _i = 0, _a = Object.keys(changedObject); _i < _a.length; _i++) {
        var key = _a[_i];
        switch (key) {
            case 'color':
                textElement.style.color = hyperlink.color = changedObject.color;
                break;
            case 'content':
                textElement.content = hyperlink.content = changedObject.content || hyperlink.link;
                break;
            case 'link':
                var labelStyle = actualAnnotation.style;
                textElement.style.color = changedObject.link ? hyperlink.color : labelStyle.color;
                textElement.style.textDecoration = changedObject.link ? hyperlink.textDecoration : actualAnnotation.style.textDecoration;
                textElement.content = changedObject.link ? hyperlink.content || changedObject.link : actualAnnotation.content;
                hyperlink.link = changedObject.link;
                break;
            case 'textDecoration':
                textElement.style.textDecoration = hyperlink.textDecoration = changedObject.textDecoration;
                break;
            case 'hyperlinkOpenState':
                hyperlink.hyperlinkOpenState = changedObject.hyperlinkOpenState;
                break;
        }
    }
}
/* eslint-enable */
/**
 * updateShapeContent method \
 *
 * @returns {void } updateShapeContent method .\
 * @param {DiagramElement} content - provide the content  value.
 * @param {Node} actualObject - provide the actualObject  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @private
 */
function updateShapeContent(content, actualObject, diagram) {
    content.width = actualObject.width;
    content.height = actualObject.height;
    content.minHeight = actualObject.minHeight;
    content.maxHeight = actualObject.maxHeight;
    content.minWidth = actualObject.minWidth;
    content.maxWidth = actualObject.maxWidth;
    content.horizontalAlignment = actualObject.wrapper.children[0].horizontalAlignment;
    content.verticalAlignment = actualObject.wrapper.children[0].verticalAlignment;
    content.relativeMode = actualObject.wrapper.children[0].relativeMode;
    content.visible = actualObject.wrapper.children[0].visible;
    if (actualObject.shape instanceof Text) {
        content.margin = actualObject.shape.margin;
    }
    content.id = actualObject.wrapper.children[0].id;
    content.style = actualObject.style;
    //let view: View;
    for (var _i = 0, _a = diagram.views; _i < _a.length; _i++) {
        var elementId = _a[_i];
        removeElement(actualObject.id + '_groupElement', elementId);
        removeElement(actualObject.id + '_content_groupElement', elementId);
        removeElement(actualObject.id + '_html_element', elementId);
    }
    actualObject.wrapper.children.splice(0, 1);
    actualObject.wrapper.children.splice(0, 0, content);
}
/* eslint-disable */
/**
 * updateShape method \
 *
 * @returns {void } updateShape method .\
 * @param {Node} node - provide the node  value.
 * @param {Node} actualObject - provide the actualObject  value.
 * @param {Node} oldObject - provide the oldObject  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @private
 */
function updateShape(node, actualObject, oldObject, diagram) {
    var content = new DiagramElement();
    //let textStyle: TextStyleModel; let nodeStyle: TextStyleModel;
    switch (node.shape.type) {
        case 'Path':
            var pathContent = new PathElement();
            pathContent.data = actualObject.shape.data;
            content = pathContent;
            updateShapeContent(content, actualObject, diagram);
            break;
        case 'Image':
            var imageContent = new ImageElement();
            imageContent.source = actualObject.shape.source;
            imageContent.imageAlign = actualObject.shape.align;
            imageContent.imageScale = actualObject.shape.scale;
            content = imageContent;
            updateShapeContent(content, actualObject, diagram);
            break;
        case 'Text':
            //issue
            var textContent = new TextElement();
            //  (textContent as TextElement).content = (node.shape as TextModel).content;
            content = textContent;
            updateShapeContent(content, actualObject, diagram);
            break;
        case 'Basic':
            var element = (actualObject.shape.shape === 'Rectangle') ? new DiagramElement() : new PathElement();
            if ((!isBlazor() && actualObject.shape.shape === 'Polygon')) {
                element.data = getPolygonPath(actualObject.shape.points);
            }
            else {
                element.data = getBasicShape(actualObject.shape.shape);
            }
            if ((!isBlazor() && actualObject.shape.shape === 'Rectangle')) {
                element.cornerRadius = actualObject.shape.cornerRadius;
            }
            //EJ2-70880 - Node disappeared after changing shape and type dynamically.
            content = element;
            updateShapeContent(content, actualObject, diagram);
            break;
        case 'Flow':
            /* eslint-disable */
            var flowShapeElement = new PathElement();
            var shape = actualObject.shape.shape;
            flowShapeElement.data = getFlowShape(shape);
            content = flowShapeElement;
            updateShapeContent(content, actualObject, diagram);
            break;
        case 'Native':
            var nativeContent = new DiagramNativeElement(node.id, diagram.element.id);
            nativeContent.content = actualObject.shape.content;
            nativeContent.scale = actualObject.shape.scale;
            content = nativeContent;
            updateShapeContent(content, actualObject, diagram);
            break;
        case 'HTML':
            var htmlContent = new DiagramHtmlElement(actualObject.id, diagram.element.id);
            htmlContent.content = actualObject.shape.content;
            content = htmlContent;
            updateShapeContent(content, actualObject, diagram);
    }
    if (node.shape.type === undefined || node.shape.type === oldObject.shape.type) {
        updateContent(node, actualObject, diagram, oldObject);
    }
    else {
        content.width = actualObject.wrapper.children[0].width;
        content.height = actualObject.wrapper.children[0].height;
        if (actualObject.shape instanceof Text) {
            content.margin = actualObject.shape.margin;
        }
        content.style = actualObject.style;
        actualObject.wrapper.children[0] = content;
    }
}
/* eslint-enable */
/**
 * updateContent method \
 *
 * @returns {void } updateContent method .\
 * @param {Node} newValues - provide the newValues  value.
 * @param {Node} actualObject - provide the actualObject  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {Node} oldObject - provide the oldObject  value.
 * @private
 */
function updateContent(newValues, actualObject, diagram, oldObject) {
    if (Object.keys(newValues.shape).length > 0) {
        if (actualObject.shape.type === 'Path' && newValues.shape.data !== undefined) {
            actualObject.wrapper.children[0].data = newValues.shape.data;
        }
        else if (actualObject.shape.type === 'Text' && newValues.shape.content !== undefined) {
            actualObject.wrapper.children[0].content = newValues.shape.content;
        }
        else if (actualObject.shape.type === 'Image' && newValues.shape.source !== undefined) {
            actualObject.wrapper.children[0].source = newValues.shape.source;
        }
        else if (actualObject.shape.type === 'Native') {
            var nativeElement = void 0;
            for (var i = 0; i < diagram.views.length; i++) {
                nativeElement = getDiagramElement(actualObject.wrapper.children[0].id + '_native_element', diagram.views[parseInt(i.toString(), 10)]);
                if (newValues.shape.content !== undefined && nativeElement) {
                    nativeElement.removeChild(nativeElement.children[0]);
                    actualObject.wrapper.children[0].content = newValues.shape.content;
                    nativeElement.appendChild(getContent(actualObject.wrapper.children[0], false));
                }
            }
            actualObject.wrapper.children[0].scale = newValues.shape.scale ?
                newValues.shape.scale : actualObject.wrapper.children[0].scale;
        }
        else if (actualObject.shape.type === 'HTML') {
            var htmlElement = void 0;
            for (var i = 0; i < diagram.views.length; i++) {
                htmlElement = getDiagramElement(actualObject.wrapper.children[0].id + '_html_element', diagram.views[parseInt(i.toString(), 10)]);
                if (htmlElement) {
                    htmlElement.removeChild(htmlElement.children[0]);
                    actualObject.wrapper.children[0].content = newValues.shape.content;
                    htmlElement.appendChild(getContent(actualObject.wrapper.children[0], true));
                }
            }
        }
        else if (actualObject.shape.type === 'Flow' && (newValues.shape.shape !== undefined)) {
            actualObject.shape.shape = newValues.shape.shape;
            var shapes = actualObject.shape.shape;
            var flowshapedata = getFlowShape(shapes.toString());
            actualObject.wrapper.children[0].data = flowshapedata;
        }
        else if (actualObject.shape.type === 'UmlActivity' &&
            (!isBlazor() && newValues.shape.shape !== undefined)) {
            updateUmlActivityNode(actualObject, newValues);
        }
        else if (newValues.shape.cornerRadius !== undefined) {
            actualObject.wrapper.children[0].cornerRadius = newValues.shape.cornerRadius;
        }
        else if (actualObject.shape.type === 'Basic' && (oldObject && oldObject.shape.shape === 'Rectangle')) {
            var basicshape = new PathElement();
            var basicshapedata = getBasicShape(actualObject.shape.shape);
            basicshape.data = basicshapedata;
            var content = basicshape;
            updateShapeContent(content, actualObject, diagram);
        }
        else if (newValues.shape.shape !== undefined) {
            actualObject.shape.shape = newValues.shape.shape;
            var shapes = actualObject.shape.shape;
            var basicShapeData = getBasicShape(shapes.toString());
            actualObject.wrapper.children[0].data = basicShapeData;
        }
    }
    actualObject.wrapper.children[0].canMeasurePath = true;
}
/**
 * updateUmlActivityNode method \
 *
 * @returns {void } updateUmlActivityNode method .\
 * @param {Node} actualObject - provide the newValues  value.
 * @param {Node} newValues - provide the actualObject  value.
 * @private
 */
function updateUmlActivityNode(actualObject, newValues) {
    if (!isBlazor()) {
        actualObject.shape.shape = newValues.shape.shape;
    }
    else {
        actualObject.shape.umlActivityShape = newValues.shape.umlActivityShape;
    }
    var shapes = !isBlazor() ? actualObject.shape.shape :
        actualObject.shape.umlActivityShape;
    var umlActivityShapeData = getUMLActivityShape(shapes.toString());
    if ((!isBlazor() && actualObject.shape.shape === 'InitialNode')) {
        actualObject.wrapper.children[0].style.fill = 'black';
    }
    else if ((!isBlazor() && (actualObject.shape.shape === 'ForkNode' ||
        actualObject.shape.shape === 'JoinNode'))) {
        actualObject.wrapper.children[0].style.fill = 'black';
    }
    else if ((!isBlazor() && actualObject.shape.shape === 'FinalNode')) {
        if (actualObject instanceof Node) {
            actualObject.wrapper = getUMLFinalNode(actualObject);
        }
    }
    if (umlActivityShapeData) {
        actualObject.wrapper.children[0].data = umlActivityShapeData;
    }
}
/**
 * getUMLFinalNode method \
 *
 * @returns {Canvas } getUMLFinalNode method .\
 * @param {Node} node - provide the newValues  value.
 * @private
 */
function getUMLFinalNode(node) {
    var finalNodeShape = new Canvas();
    finalNodeShape.style.fill = 'transparent';
    //childNode0
    var pathData = 'M 25 50 C 11.21 50 0 38.79 0 25 C 0 11.21 11.21 0 25 0 C 38.78 0 50 11.21 50 25' +
        ' C 50 38.79 38.78 50 25 50';
    var innerFinalNode = new PathElement();
    innerFinalNode.data = pathData;
    innerFinalNode.id = node.id + '_0_finalNode';
    innerFinalNode.horizontalAlignment = 'Center';
    innerFinalNode.verticalAlignment = 'Center';
    innerFinalNode.relativeMode = 'Object';
    innerFinalNode.style.strokeColor = node.style.strokeColor;
    innerFinalNode.style.strokeWidth = node.style.strokeWidth;
    //childNode1
    var outerFinalNode = new PathElement();
    outerFinalNode.data = pathData;
    outerFinalNode.id = node.id + '_1_finalNode';
    outerFinalNode.horizontalAlignment = 'Center';
    outerFinalNode.verticalAlignment = 'Center';
    outerFinalNode.relativeMode = 'Object';
    outerFinalNode.style.fill = node.style.fill;
    outerFinalNode.style.strokeColor = node.style.strokeColor;
    outerFinalNode.style.strokeWidth = node.style.strokeWidth;
    //append child and set style
    finalNodeShape.children = [innerFinalNode, outerFinalNode];
    finalNodeShape.children[0].width = node.width;
    finalNodeShape.children[0].height = node.height;
    finalNodeShape.children[1].height = node.height / 1.5;
    finalNodeShape.children[1].width = node.width / 1.5;
    finalNodeShape.style.strokeWidth = 0;
    finalNodeShape.style.strokeColor = 'transparent';
    return finalNodeShape;
}
/**
 * getUMLActivityShapes method \
 *
 * @returns {DiagramElement } getUMLActivityShapes method .\
 * @param {PathElement} umlActivityShape - provide the umlActivityShape  value.
 * @param {DiagramElement} content - provide the content  value.
 * @param {Node} node - provide the node  value.
 * @private
 */
function getUMLActivityShapes(umlActivityShape, content, node) {
    var shape = node.shape.shape;
    var umlActivityShapeData = getUMLActivityShape(shape);
    umlActivityShape.data = umlActivityShapeData;
    content = umlActivityShape;
    switch (shape) {
        case 'StructuredNode':
            if (node.annotations) {
                for (var i = 0; i < node.annotations.length; i++) {
                    node.annotations[parseInt(i.toString(), 10)].content = '<<' + node.annotations[parseInt(i.toString(), 10)].content + '>>';
                }
            }
            content = umlActivityShape;
            break;
        case 'FinalNode':
            content = getUMLFinalNode(node);
            break;
    }
    return content;
}
/**
 * removeGradient method \
 *
 * @returns {void } removeGradient method .\
 * @param {string} svgId - provide the umlActivityShape  value.
 * @private
 */
function removeGradient(svgId) {
    removeElement(svgId + '_linear');
    removeElement(svgId + '_radial');
}
/**
 * removeItem method \
 *
 * @returns {void } removeItem method .\
 * @param {string[]} array - provide the umlActivityShape  value.
 * @param {string} item - provide the umlActivityShape  value.
 * @private
 */
function removeItem(array, item) {
    var index = array.indexOf(item);
    if (index >= 0) {
        array.splice(index, 1);
    }
}
/**
 * updateConnector method \
 *
 * @returns {void } updateConnector method .\
 * @param {Connector} connector - provide the connector  value.
 * @param {PointModel[]} points - provide the points  value.
 * @param {DiagramAction} diagramActions - provide the diagramActions  value.
 * @private
 */
function updateConnector(connector, points, diagramActions) {
    var anglePoint; //let srcDecorator: DecoratorModel;
    //let targetPoint: PointModel;
    connector.intermediatePoints = points;
    connector.updateSegmentElement(connector, points, connector.wrapper.children[0], diagramActions);
    var srcDecorator = connector.sourceDecorator;
    if (connector.type === 'Bezier') {
        var firstSegment = connector.segments[0];
        var lastSegment = connector.segments[connector.segments.length - 1];
        anglePoint = [!Point.isEmptyPoint(lastSegment.point2) ? lastSegment.point2 : lastSegment.bezierPoint2,
            !Point.isEmptyPoint(firstSegment.point1) ? firstSegment.point1 : firstSegment.bezierPoint1];
    }
    else {
        anglePoint = connector.intermediatePoints;
    }
    points = connector.clipDecorators(connector, points, diagramActions);
    var element = connector.wrapper.children[0];
    element.canMeasurePath = true;
    element = connector.wrapper.children[1];
    connector.updateDecoratorElement(element, points[0], anglePoint[1], srcDecorator);
    //const targetPoint: PointModel = connector.targetPoint;
    var tarDecorator = connector.targetDecorator;
    element = connector.wrapper.children[2];
    connector.updateDecoratorElement(element, points[points.length - 1], anglePoint[anglePoint.length - 2], tarDecorator);
    connector.updateShapeElement(connector);
}
/**
 * getUserHandlePosition method \
 *
 * @returns {PointModel } getUserHandlePosition method .\
 * @param {SelectorModel} selectorItem - provide the connector  value.
 * @param {UserHandleModel} handle - provide the handle  value.
 * @param {Transforms} transform - provide the transform  value.
 * @private
 */
function getUserHandlePosition(selectorItem, handle, transform) {
    var wrapper = selectorItem.wrapper;
    //let positionPoints: PointModel;
    var bounds = wrapper.bounds;
    var offset = handle.offset;
    var size = handle.size / transform.scale;
    var margin = handle.margin;
    var point;
    var left = wrapper.offsetX - wrapper.actualSize.width * wrapper.pivot.x;
    var top = wrapper.offsetY - wrapper.actualSize.height * wrapper.pivot.y;
    point = { x: 0, y: 0 };
    if (selectorItem.nodes.length > 0) {
        switch (handle.side) {
            case 'Top':
                point.x += left + offset * wrapper.actualSize.width;
                point.y += top - (size);
                break;
            case 'Bottom':
                point.x += left + offset * wrapper.actualSize.width;
                point.y += top + wrapper.actualSize.height + (size);
                break;
            case 'Left':
                point.x += left - (size);
                point.y += top + offset * wrapper.actualSize.height;
                break;
            case 'Right':
                point.x += left + wrapper.actualSize.width + (size);
                point.y += top + offset * wrapper.actualSize.height;
                break;
        }
        point.x += ((margin.left - margin.right) / transform.scale) +
            (size / 2) * (handle.horizontalAlignment === 'Center' ? 0 : (handle.horizontalAlignment === 'Right' ? -1 : 1));
        point.y += ((margin.top - margin.bottom) / transform.scale) +
            (size / 2) * (handle.verticalAlignment === 'Center' ? 0 : (handle.verticalAlignment === 'Top' ? -1 : 1));
    }
    else if (selectorItem.connectors.length > 0) {
        var connector = selectorItem.connectors[0];
        var annotation = { offset: offset };
        var connectorOffset = getOffsetOfConnector(connector.intermediatePoints, annotation);
        var index = connectorOffset.index;
        point = connectorOffset.point;
        var getPointloop = getAnnotationPosition(connector.intermediatePoints, annotation);
        //const points: PointModel[] = connector.intermediatePoints;
        //const offsetLength: number;
        var angle = getPointloop.angle;
        var matrix = identityMatrix();
        rotateMatrix(matrix, -angle, connector.intermediatePoints[parseInt(index.toString(), 10)].x, connector.intermediatePoints[parseInt(index.toString(), 10)].y);
        point = transformPointByMatrix(matrix, point);
        point.x += (margin.left - margin.right) +
            (size / 2) * (handle.horizontalAlignment === 'Center' ? 0 : (handle.horizontalAlignment === 'Right' ? -1 : 1));
        point.y += (margin.top - margin.bottom) +
            (size / 2) * (handle.verticalAlignment === 'Center' ? 0 : (handle.verticalAlignment === 'Top' ? -1 : 1));
        matrix = identityMatrix();
        rotateMatrix(matrix, angle, connector.intermediatePoints[parseInt(index.toString(), 10)].x, connector.intermediatePoints[parseInt(index.toString(), 10)].y);
        point = transformPointByMatrix(matrix, point);
    }
    if (wrapper.rotateAngle !== 0 || wrapper.parentTransform !== 0) {
        var matrix = identityMatrix();
        rotateMatrix(matrix, wrapper.rotateAngle + wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY);
        point = transformPointByMatrix(matrix, point);
    }
    return point;
}
/**
 * canResizeCorner method \
 *
 * @returns {SelectorConstraints } canResizeCorner method .\
 * @param {string} selectorConstraints - provide the selectorConstraints  value.
 * @param {string} action - provide the selectorConstraints  value.
 * @param {ThumbsConstraints} thumbsConstraints - provide the thumbsConstraints  value.
 * @param {Selector} selectedItems - provide the selectedItems  value.
 * @private
 */
function canResizeCorner(selectorConstraints, action, thumbsConstraints, selectedItems) {
    if (selectedItems.annotation) {
        if (canResize(selectedItems.annotation)) {
            return true;
        }
    }
    else if ((SelectorConstraints["" + action] & selectorConstraints) && (ThumbsConstraints["" + action] & thumbsConstraints)) {
        return true;
    }
    return false;
}
/**
 * canShowCorner method \
 *
 * @returns {boolean } canShowCorner method .\
 * @param {SelectorConstraints} selectorConstraints - provide the selectorConstraints  value.
 * @param {string} action - provide the thumbsConstraints  value.
 * @private
 */
function canShowCorner(selectorConstraints, action) {
    if (SelectorConstraints["" + action] & selectorConstraints) {
        return true;
    }
    return false;
}
/**
 * canShowControlPoints method \
 *
 * @returns {boolean } canShowControlPoints method .\
 * @param {ControlPointsVisibility} bezierControlPoints - provide the bezierControlPoints value.
 * @param {string} action - provide the value.
 * @private
 */
function canShowControlPoints(bezierControlPoints, action) {
    if (ControlPointsVisibility["" + action] & bezierControlPoints) {
        return true;
    }
    return false;
}
/**
 * checkPortRestriction method \
 *
 * @returns {number } checkPortRestriction method .\
 * @param {PointPortModel} port - provide the port  value.
 * @param {PortVisibility} portVisibility - provide the portVisibility  value.
 * @private
 */
function checkPortRestriction(port, portVisibility) {
    return port.visibility & portVisibility;
}
/**
 * findAnnotation method \
 *
 * @returns {ShapeAnnotationModel | PathAnnotationModel | TextModel } findAnnotation method .\
 * @param { NodeModel | ConnectorModel} node - provide the port  value.
 * @param {string} id - provide the portVisibility  value.
 * @private
 */
function findAnnotation(node, id) {
    var annotation;
    if (node.shape.type === 'Text') {
        annotation = (node.shape);
    }
    else {
        var annotationId = id.split('_');
        id = annotationId[annotationId.length - 1];
        for (var i = 0; i < node.annotations.length; i++) {
            if (id === node.annotations[parseInt(i.toString(), 10)].id) {
                annotation = node.annotations[parseInt(i.toString(), 10)];
            }
        }
    }
    return annotation;
}
/**
 * findPort method \
 *
 * @returns {PointPortModel} findPort method .\
 * @param { NodeModel | ConnectorModel} node - provide the port  value.
 * @param {string} id - provide the portVisibility  value.
 * @private
 */
function findPort(node, id) {
    var port;
    if (id) {
        var portId = id.split('_');
        id = portId[portId.length - 1];
    }
    if (node) {
        node = node;
        for (var i = 0; i < node.ports.length; i++) {
            if (id === node.ports[parseInt(i.toString(), 10)].id) {
                return node.ports[parseInt(i.toString(), 10)];
            }
        }
    }
    return port;
}
/**
 * getInOutConnectPorts method \
 *
 * @returns {PointPortModel} getInOutConnectPorts method .\
 * @param { NodeModel} node - provide the port  value.
 * @param {boolean} isInConnect - provide the portVisibility  value.
 * @private
 */
function getInOutConnectPorts(node, isInConnect) {
    var port = {};
    var i = 0;
    if (node.ports) {
        var ports = node.ports;
        for (i = 0; i < ports.length; i++) {
            if (isInConnect) {
                if ((ports[parseInt(i.toString(), 10)].constraints & PortConstraints.InConnect)) {
                    port = ports[parseInt(i.toString(), 10)];
                }
            }
            else {
                if ((ports[parseInt(i.toString(), 10)].constraints & PortConstraints.OutConnect)) {
                    port = ports[parseInt(i.toString(), 10)];
                }
            }
        }
    }
    return port;
}
/**
 * findObjectIndex method \
 *
 * @returns {PointPortModel} findObjectIndex method .\
 * @param { NodeModel | ConnectorModel} node - provide the node  value.
 * @param {string} id - provide the string  value.
 * @param {boolean} annotation - provide the boolean  value.
 * @private
 */
function findObjectIndex(node, id, annotation) {
    //let index: number;
    var collection = (annotation) ? node.annotations : node.ports;
    for (var i = 0; i < collection.length; i++) {
        if (collection[parseInt(i.toString(), 10)].id === id) {
            return (i).toString();
        }
    }
    return '-1';
}
/**
 * findPortIndex method \
 *
 * @returns {PointPortModel} findPortIndex method .\
 * @param { NodeModel | ConnectorModel} node - provide the node  value.
 * @param {string} id - provide the string  value.
 * @param {boolean} port - provide the boolean  value.
 * @private
 */
function findPortIndex(node, id, port) {
    //let index: number;
    var collection = node.ports;
    for (var i = 0; i < collection.length; i++) {
        if (collection[parseInt(i.toString(), 10)].id === id) {
            return (i).toString();
        }
    }
    return '-1';
}
/**
 * getObjectFromCollection method \
 *
 * @returns {boolean} getObjectFromCollection method .\
 * @param { (NodeModel | ConnectorModel)[] } obj - provide the node  value.
 * @param {string} id - provide the string  value.
 * @private
 */
function getObjectFromCollection(obj, id) {
    var i;
    for (i = 0; i < obj.length; i++) {
        if (id === obj[parseInt(i.toString(), 10)].id) {
            return true;
        }
    }
    return false;
}
/**
 * scaleElement method \
 *
 * @returns {void} scaleElement method .\
 * @param { DiagramElement } element - provide the element  value.
 * @param {number} sw - provide the string  value.
 * @param {number} sh - provide the string  value.
 * @param {DiagramElement} refObject - provide the refObject  value.
 * @private
 */
function scaleElement(element, sw, sh, refObject) {
    if (element.width !== undefined && element.height !== undefined) {
        element.width *= sw;
        element.height *= sh;
    }
    if (element instanceof Container) {
        var matrix = identityMatrix();
        var width = refObject.width || refObject.actualSize.width;
        var height = refObject.height || refObject.actualSize.height;
        if (width !== undefined && height !== undefined) {
            var x = refObject.offsetX - width * refObject.pivot.x;
            var y = refObject.offsetY - height * refObject.pivot.y;
            var refPoint = {
                x: x + width * refObject.pivot.x,
                y: y + height * refObject.pivot.y
            };
            refPoint = rotatePoint(refObject.rotateAngle, refObject.offsetX, refObject.offsetY, refPoint);
            rotateMatrix(matrix, -refObject.rotateAngle, refPoint.x, refPoint.y);
            scaleMatrix(matrix, sw, sh, refPoint.x, refPoint.y);
            rotateMatrix(matrix, refObject.rotateAngle, refPoint.x, refPoint.y);
            for (var _i = 0, _a = element.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child.width !== undefined && child.height !== undefined) {
                    var newPosition = transformPointByMatrix(matrix, { x: child.offsetX, y: child.offsetY });
                    child.offsetX = newPosition.x;
                    child.offsetY = newPosition.y;
                    scaleElement(child, sw, sh, refObject);
                }
            }
        }
    }
}
/**
 * scaleElement method \
 *
 * @returns {void} scaleElement method .\
 * @param { Node } obj - provide the obj  value.
 * @param {number} x - provide the x  value.
 * @param {number} y - provide the y  value.
 * @param {DiagramElement} nameTable - provide the refObject  value.
 * @param {DiagramElement} drop - provide the drop  value.
 * @param {DiagramElement} diagram - provide the diagram  value.
 * @private
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function arrangeChild(obj, x, y, nameTable, drop, diagram) {
    var child = obj.children;
    var node;
    for (var i = 0; i < child.length; i++) {
        node = nameTable[child[parseInt(i.toString(), 10)]];
        if (node) {
            if (node.children) {
                arrangeChild(node, x, y, nameTable, drop, diagram);
            }
            else {
                node.offsetX -= x;
                node.offsetY -= y;
                if (!drop) {
                    //let content: DiagramElement;
                    //let container: Container;
                    nameTable[node.id] = node;
                    var container = node.initContainer();
                    if (!container.children) {
                        container.children = [];
                    }
                    var content = node.init(diagram);
                    container.children.push(content);
                    container.measure(new Size(node.width, node.height));
                    container.arrange(container.desiredSize);
                }
            }
        }
    }
}
/**
 * insertObject method \
 *
 * @returns {void} insertObject method .\
 * @param { NodeModel | ConnectorModel } obj - provide the obj  value.
 * @param { string } key - provide the obj  value.
 * @param { Object[]} collection - provide the x  value.
 * @private
 */
function insertObject(obj, key, collection) {
    if (collection.length === 0) {
        collection.push(obj);
    }
    else if (collection.length === 1) {
        if (collection[0]["" + key] > obj["" + key]) {
            collection.splice(0, 0, obj);
        }
        else {
            collection.push(obj);
        }
    }
    else if (collection.length > 1) {
        var low = 0;
        var high = collection.length - 1;
        var mid = Math.floor((low + high) / 2);
        while (mid !== low) {
            if (collection[parseInt(mid.toString(), 10)]["" + key] < obj["" + key]) {
                low = mid;
                mid = Math.floor((low + high) / 2);
            }
            else if (collection[parseInt(mid.toString(), 10)]["" + key] > obj["" + key]) {
                high = mid;
                mid = Math.floor((low + high) / 2);
            }
            else {
                break;
            }
        }
        if (collection[parseInt(high.toString(), 10)]["" + key] < obj["" + key]) {
            collection.push(obj);
        }
        else if (collection[parseInt(low.toString(), 10)]["" + key] > obj["" + key]) {
            collection.splice(low, 0, obj);
        }
        else if ((collection[parseInt(low.toString(), 10)]["" + key] < obj["" + key]) && collection[parseInt(high.toString(), 10)]["" + key] > obj["" + key]) {
            collection.splice(high, 0, obj);
        }
    }
}
/**
 * getElement method \
 *
 * @returns {Object} getElement method .\
 * @param { DiagramHtmlElement | DiagramNativeElement } element - provide the obj  value.
 * @private
 */
function getElement(element) {
    var diagramElement = document.getElementById(element.diagramId);
    var instance = 'ej2_instances';
    var nodes = diagramElement["" + instance][0].nodes;
    if (nodes === undefined) {
        nodes = getPaletteSymbols(diagramElement["" + instance][0]);
    }
    var length = 'length';
    for (var i = 0; nodes && i < nodes["" + length]; i++) {
        if (nodes[parseInt(i.toString(), 10)].id === element.nodeId) {
            return getAnnotation(nodes[parseInt(i.toString(), 10)], element);
        }
    }
    var connectors = diagramElement["" + instance][0].connectors;
    for (var i = 0; connectors && i < connectors["" + length]; i++) {
        if (connectors[parseInt(i.toString(), 10)].id === element.nodeId) {
            return getAnnotation(connectors[parseInt(i.toString(), 10)], element);
        }
    }
    // eslint-disable-next-line
    var enterObject = diagramElement[instance][0].enterObject;
    if (enterObject && (enterObject['id'] === element.nodeId || enterObject['children'])) {
        if (enterObject['children'] && groupHasType(enterObject, 'HTML', diagramElement["" + instance][0].enterTable)) {
            return diagramElement["" + instance][0].enterTable[element.nodeId];
        }
        else {
            return enterObject;
        }
    }
    return null;
}
/**
 * getAnnotation method \
 *
 * @returns {Object} getAnnotation method .\
 * @param { Object } obj - provide the obj  value.
 * @param {  DiagramHtmlElement | DiagramNativeElement } element - provide the obj  value.
 * @private
 */
function getAnnotation(obj, element) {
    var annotations = obj.annotations;
    var length = 'length';
    var j;
    for (j = 0; annotations && j < annotations["" + length]; j++) {
        if (element.annotationId
            && annotations[parseInt(j.toString(), 10)].id === element.annotationId) {
            return annotations[parseInt(j.toString(), 10)];
        }
    }
    return obj;
}
/**
 * getPaletteSymbols method \
 *
 * @returns {NodeModel[]} getPaletteSymbols method .\
 * @param { Object } symbolPalette - provide the symbolPalette  value.
 * @private
 */
function getPaletteSymbols(symbolPalette) {
    var nodes = [];
    for (var i = 0; i < symbolPalette.palettes.length; i++) {
        var symbols = symbolPalette.palettes[parseInt(i.toString(), 10)].symbols;
        for (var j = 0; j < symbols.length; j++) {
            if (symbols[parseInt(j.toString(), 10)] instanceof Node) {
                nodes.push(symbols[parseInt(j.toString(), 10)]);
            }
        }
    }
    return nodes;
}
/**
 * getCollectionChangeEventArguements method \
 *
 * @returns {IBlazorCollectionChangeEventArgs} getCollectionChangeEventArguements method .\
 * @param { IBlazorCollectionChangeEventArgs } args1 - provide the args1  value.
 * @param { NodeModel | ConnectorModel } obj - provide the obj  value.
 * @param { EventState } state - provide the state  value.
 * @param { ChangeType } type - provide the type  value.
 * @private
 */
function getCollectionChangeEventArguements(args1, obj, state, type) {
    //Removed isBlazor code
    return args1;
}
/**
 * getDropEventArguements method \
 *
 * @returns {IBlazorDropEventArgs} getDropEventArguements method .\
 * @param { MouseEventArgs } args - provide the args1  value.
 * @param { IBlazorDropEventArgs } arg - provide the obj  value.
 * @private
 */
function getDropEventArguements(args, arg) {
    //Removed isBlazor code
    return arg;
}
/**
 * getPoint method \
 *
 * @returns {PointModel} getPoint method .\
 * @param { number } x - provide the x  value.
 * @param { number } y - provide the y  value.
 * @param { number } w - provide the w  value.
 * @param { number } h - provide the y  value.
 * @param { number } angle - provide the y  value.
 * @param { number } offsetX - provide the y  value.
 * @param { number } offsetY - provide the y  value.
 * @param { PointModel } cornerPoint - provide the y  value.
 * @private
 */
function getPoint(x, y, w, h, angle, offsetX, offsetY, cornerPoint) {
    var pivot = { x: 0, y: 0 };
    var trans = identityMatrix();
    rotateMatrix(trans, angle, offsetX, offsetY);
    switch (cornerPoint.x) {
        case 0:
            switch (cornerPoint.y) {
                case 0:
                    pivot = transformPointByMatrix(trans, ({ x: x, y: y }));
                    break;
                case 0.5:
                    pivot = transformPointByMatrix(trans, ({ x: x, y: y + h / 2 }));
                    break;
                case 1:
                    pivot = transformPointByMatrix(trans, ({ x: x, y: y + h }));
                    break;
            }
            break;
        case 0.5:
            switch (cornerPoint.y) {
                case 0:
                    pivot = transformPointByMatrix(trans, ({ x: x + w / 2, y: y }));
                    break;
                case 0.5:
                    pivot = transformPointByMatrix(trans, ({ x: x + w / 2, y: y + h / 2 }));
                    break;
                case 1:
                    pivot = transformPointByMatrix(trans, ({ x: x + w / 2, y: y + h }));
                    break;
            }
            break;
        case 1:
            switch (cornerPoint.y) {
                case 0:
                    pivot = transformPointByMatrix(trans, ({ x: x + w, y: y }));
                    break;
                case 0.5:
                    pivot = transformPointByMatrix(trans, ({ x: x + w, y: y + h / 2 }));
                    break;
                case 1:
                    pivot = transformPointByMatrix(trans, ({ x: x + w, y: y + h }));
                    break;
            }
            break;
    }
    return { x: pivot.x, y: pivot.y };
}
/* eslint-disable */
/**
 * Get the object as Node | Connector \
 *
 * @returns {Object} Get the object as Node | Connector .\
 * @param { number } obj - provide the x  value.
 * @private
 */
var getObjectType = function (obj) {
    if (obj) {
        if (obj.sourceID !== undefined || obj.sourcePoint !== undefined ||
            obj.targetID !== undefined || obj.targetPoint !== undefined ||
            obj.type !== undefined) {
            obj = Connector;
        }
        else {
            obj = Node;
        }
    }
    return obj;
};
/** @private */
var flipConnector = function (connector) {
    if (!connector.sourceID && !connector.targetID) {
        var source = { x: connector.sourcePoint.x, y: connector.sourcePoint.y };
        var target = { x: connector.targetPoint.x, y: connector.targetPoint.y };
        if (connector.flip === FlipDirection.Horizontal) {
            connector.sourcePoint.x = target.x;
            connector.targetPoint.x = source.x;
        }
        else if (connector.flip === FlipDirection.Vertical) {
            connector.sourcePoint.y = target.y;
            connector.targetPoint.y = source.y;
        }
        else if (connector.flip === FlipDirection.Both) {
            connector.sourcePoint = target;
            connector.targetPoint = source;
        }
    }
};
/** @private */
var updatePortEdges = function (portContent, flip, port) {
    var offsetX = port.offset.x;
    var offsetY = port.offset.y;
    if (flip === FlipDirection.Horizontal) {
        offsetX = 1 - port.offset.x;
        offsetY = port.offset.y;
    }
    else if (flip === FlipDirection.Vertical) {
        offsetX = port.offset.x;
        offsetY = 1 - port.offset.y;
    }
    else if (flip === FlipDirection.Both) {
        offsetX = 1 - port.offset.x;
        offsetY = 1 - port.offset.y;
    }
    portContent.setOffsetWithRespectToBounds(offsetX, offsetY, 'Fraction');
    return portContent;
};
/** @private */
var alignElement = function (element, offsetX, offsetY, diagram, flip, isHorizontal, isVertical, isInitialRendering) {
    if (element.hasChildren()) {
        for (var _i = 0, _a = element.children; _i < _a.length; _i++) {
            var child = _a[_i];
            var nodeObj = void 0;
            if (child instanceof Canvas) {
                nodeObj = diagram.nameTable[child.id];
                if (nodeObj) {
                    if (isHorizontal) {
                        nodeObj.flip ^= FlipDirection.Horizontal;
                    }
                    if (isVertical) {
                        nodeObj.flip ^= FlipDirection.Vertical;
                    }
                }
            }
            var childX = ((offsetX - child.offsetX) + offsetX);
            var childY = ((offsetY - child.offsetY) + offsetY);
            if (!(child instanceof TextElement)) {
                if (!(child.elementActions & ElementAction.ElementIsPort)) {
                    if (flip === FlipDirection.Horizontal || isHorizontal) {
                        child.offsetX = childX;
                        if (nodeObj) {
                            nodeObj.offsetX = childX;
                        }
                        child.flipOffset.x = childX - child.desiredSize.width / 2;
                    }
                    if (flip === FlipDirection.Vertical || isVertical) {
                        child.offsetY = childY;
                        if (nodeObj) {
                            nodeObj.offsetY = childY;
                        }
                        child.flipOffset.y = childY - child.desiredSize.height / 2;
                    }
                    else if (flip === FlipDirection.Both) {
                        child.offsetX = childX;
                        child.flipOffset.x = childX - child.desiredSize.width / 2;
                        child.offsetY = childY;
                        child.flipOffset.y = childY - child.desiredSize.height / 2;
                        if (nodeObj) {
                            nodeObj.offsetX = childX;
                            nodeObj.offsetY = childY;
                        }
                    }
                }
            }
            if (!isInitialRendering) {
                if (child instanceof Canvas || child instanceof Container) {
                    if (isHorizontal) {
                        child.flip ^= FlipDirection.Horizontal;
                    }
                    if (isVertical) {
                        child.flip ^= FlipDirection.Vertical;
                    }
                    if (!child.id.includes('group_container') && child.children) {
                        if (isHorizontal) {
                            child.children[0].flip ^= FlipDirection.Horizontal;
                        }
                        if (isVertical) {
                            child.children[0].flip ^= FlipDirection.Vertical;
                        }
                    }
                    alignElement(child, offsetX, offsetY, diagram, flip, isHorizontal, isVertical, isInitialRendering);
                }
            }
            child.measure(new Size(child.bounds.width, child.bounds.height));
            child.arrange(child.desiredSize);
            var node = diagram.nameTable[child.id];
            if (node) {
                diagram.updateConnectorEdges(node);
            }
        }
    }
};
/** @private */
var cloneSelectedObjects = function (diagram) {
    var nodes = diagram.selectedItems.nodes;
    var connectors = diagram.selectedItems.connectors;
    var isProtectedOnChange = 'isProtectedOnChange';
    var isEnableServerDatabind = diagram.allowServerDataBinding;
    var isProtectedOnChangeValue = diagram[isProtectedOnChange];
    diagram.protectPropertyChange(true);
    diagram.allowServerDataBinding = false;
    diagram.selectedItems.nodes = [];
    diagram.selectedItems.connectors = [];
    diagram.allowServerDataBinding = isEnableServerDatabind;
    diagram.protectPropertyChange(isProtectedOnChangeValue);
    var clonedSelectedItems = cloneObject(diagram.selectedItems);
    for (var i = 0; i < nodes.length; i++) {
        diagram.selectedItems.nodes.push(diagram.nameTable[nodes[i].id]);
    }
    for (var i = 0; i < connectors.length; i++) {
        diagram.selectedItems.connectors.push(diagram.nameTable[connectors[i].id]);
    }
    return clonedSelectedItems;
};
/** @private */
var updatePathElement = function (anglePoints, connector) {
    var pathElement = new PathElement();
    var pathseqData;
    for (var j = 0; j < anglePoints.length - 1; j++) {
        pathseqData = findPath(anglePoints[j], anglePoints[j + 1]);
        pathElement.data = pathseqData[0];
        pathElement.id = connector.id + '_' + (connector.shape.sequence);
        //Bug 860251: Bpmn message flow and sequence flow connector child path is not rendered properly.
        //To get the offset of default sequence path.
        var pathOffset = getPathOffset(anglePoints);
        pathElement.offsetX = pathOffset.x;
        pathElement.offsetY = pathOffset.y;
        pathElement.rotateAngle = 45;
        pathElement.transform = Transform.Self;
        break;
    }
    return pathElement;
};
/** @private */
var getPathOffset = function (anglePoints, connector, segmentOffset) {
    var offsetDistance = 10; // Distance from the source point
    var angle;
    var pt;
    var totalLength = 0;
    // Calculate total length of the path
    for (var i_1 = 0; i_1 < anglePoints.length - 1; i_1++) {
        totalLength += findDistance(anglePoints[parseInt(i_1.toString(), 10)], anglePoints[i_1 + 1]);
    }
    var targetLength;
    if (segmentOffset) {
        targetLength = totalLength * segmentOffset;
    }
    else {
        targetLength = (totalLength / 2) > 30 ? offsetDistance : (totalLength / 2);
    }
    // Find the segment where the position lies
    var accumulatedLength = 0;
    for (var i = 0; i < anglePoints.length - 1; i++) {
        var segmentLength = findDistance(anglePoints[parseInt(i.toString(), 10)], anglePoints[i + 1]);
        if (accumulatedLength + segmentLength >= targetLength) {
            var remainingLength = targetLength - accumulatedLength;
            angle = findAngle(anglePoints[i], anglePoints[i + 1]);
            pt = Point.transform(anglePoints[i], angle, remainingLength);
            break;
        }
        accumulatedLength += segmentLength;
    }
    return pt;
};
/** @private */
var checkPort = function (node, element) {
    if (node instanceof Node || node instanceof Connector) {
        for (var i = 0; i < node.ports.length; i++) {
            if (node.ports[i].id === element.id.split('_').splice(1).join('_')) {
                return true;
            }
        }
    }
    return false;
};
/** @private */
var findPath = function (sourcePoint, targetPoint) {
    var beginningpoint = { x: sourcePoint.x, y: sourcePoint.y };
    var distance = findDistance(sourcePoint, targetPoint);
    distance = Math.min(10, distance / 2);
    var angle = findAngle(sourcePoint, targetPoint);
    var transferpt = Point.transform({ x: beginningpoint.x, y: beginningpoint.y }, angle, distance);
    var startpoint = Point.transform({ x: transferpt.x, y: transferpt.y }, angle, -11);
    var endpoint = Point.transform({ x: startpoint.x, y: startpoint.y }, angle, 11 * 2);
    var path = 'M' + startpoint.x + ' ' + startpoint.y + ' L' + endpoint.x + ' ' + endpoint.y;
    return [path, transferpt];
};
/** @private */
var getConnectorDirection = function (src, tar) {
    if (Math.abs(tar.x - src.x) > Math.abs(tar.y - src.y)) {
        return src.x < tar.x ? 'Right' : 'Left';
    }
    else {
        return src.y < tar.y ? 'Bottom' : 'Top';
    }
};
/** @private */
var findDistance = function (point1, point2) {
    return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
};
/* eslint-enable */
/**
 * cloneBlazorObject method \
 *
 * @returns {Object} cloneBlazorObject method .\
 * @param { object } args - provide the args  value.
 * @private
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function cloneBlazorObject(args) {
    //Removed isBlazor code
    return args;
}
/**
 * checkBrowserInfo method \
 *
 * @returns {Object} checkBrowserInfo method .\
 * @private
 */
function checkBrowserInfo() {
    if ((navigator.platform.indexOf('Mac') >= 0 || navigator.platform.indexOf('iPad') >= 0
        || navigator.platform.indexOf('iPhone') >= 0 || navigator.platform.indexOf('MacIntel') >= 0)
        && (Browser.info.name === 'safari' || Browser.info.name === 'webkit')) {
        return true;
    }
    return false;
}
/**
 * canMeasureDecoratorPath method \
 *
 * @returns {boolean} canMeasureDecoratorPath method .\
 * @param { string[] } objects - provide the args  value.
 * @private
 */
function canMeasureDecoratorPath(objects) {
    if (objects.indexOf('shape') !== -1 || objects.indexOf('pathData') !== -1 ||
        objects.indexOf('width') !== -1 || objects.indexOf('height') !== -1) {
        return true;
    }
    return false;
}
/**
 * getPreviewSize method \
 *
 * @returns {Size} getPreviewSize method .\
 * @param { SymbolPaletteModel } sourceElement - provide the args  value.
 * @param { Node } clonedObject - provide the args  value.
 * @param { DiagramElement } wrapper - provide the args  value.
 * @private
 */
function getPreviewSize(sourceElement, clonedObject, wrapper) {
    //let previewWidth: number;
    //let previewHeight: number;
    var previewWidth = getSymbolSize(sourceElement, clonedObject, wrapper, 'width');
    var previewHeight = getSymbolSize(sourceElement, clonedObject, wrapper, 'height');
    return new Size(previewWidth, previewHeight);
}
/**
 * getSymbolSize method \
 *
 * @returns {number} getSymbolSize method .\
 * @param { SymbolPaletteModel } sourceElement - provide the sourceElement  value.
 * @param { Node } clonedObject - provide the clonedObject  value.
 * @param { DiagramElement } wrapper - provide the wrapper  value.
 * @param { string } size - provide the size  value.
 * @private
 */
function getSymbolSize(sourceElement, clonedObject, wrapper, size) {
    var previewSize = 0;
    if (clonedObject.previewSize["" + size] !== undefined) {
        previewSize = clonedObject.previewSize["" + size];
    }
    else if (sourceElement.symbolPreview["" + size] !== undefined) {
        previewSize = sourceElement.symbolPreview["" + size];
    }
    else {
        previewSize = clonedObject["" + size] || wrapper.actualSize["" + size];
    }
    return previewSize;
}
/**
 * findParent method \
 *
 * @returns {string} findParent method .\
 * @param { Node } node - provide the clonedObject  value.
 * @param { Diagram } diagram - provide the diagram  element.
 * @param { string } parent - provide the parent id.
 * @private
 */
function findParentInSwimlane(node, diagram, parent) {
    if (node && node.parentId) {
        node = diagram.nameTable[node.parentId];
        if (node.parentId) {
            parent = findParentInSwimlane(node, diagram, parent);
        }
        else {
            parent = node.id;
        }
    }
    return parent;
}
/**
 * selectionHasConnector method \
 *
 * @returns {boolean} selectionHasConnector method .\
 * @param { Diagram } diagram - provide the diagram  element.
 * @param { selector } selector - provide the selector element.
 * @private
 */
function selectionHasConnector(diagram, selector) {
    if (diagram.selectedItems.connectors.length > 1 && diagram.selectedItems.nodes.length === 0 && selector.rotateAngle !== 0) {
        return true;
    }
    return false;
}
/**
 * To Get connector style based on the arrow type
 * @param {FlowChartData} data - provide the flow chart data.
 * @returns {ArrowStyle} - Connector style
 */
function getConnectorArrowType(data) {
    if (data.arrowType && data.arrowType.trim() !== '') {
        switch (data.arrowType) {
            case 'single-line-arrow':
                return { targetDecorator: 'Arrow', strokeWidth: 1 };
            case 'double-line-arrow':
                return { targetDecorator: 'Arrow', strokeWidth: 2 };
            case 'dotted-arrow':
                return { targetDecorator: 'Arrow', strokeDashArray: '2,2' };
            case 'single-line':
                return { targetDecorator: 'None', strokeWidth: 1 };
            case 'double-line':
                return { targetDecorator: 'None', strokeWidth: 2 };
            case 'dotted':
                return { targetDecorator: 'None', strokeDashArray: '2,2' };
            case 'wiggly-arrow':
                return { targetDecorator: 'None', strokeWidth: 1, opacity: 0 };
            default:
                return { targetDecorator: 'Arrow', strokeWidth: 1 };
        }
    }
    return { targetDecorator: 'Arrow', strokeWidth: 1 };
}

var __extends$m = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Defines the behavior of default IconShapes
 */
var IconShape = /** @class */ (function (_super) {
    __extends$m(IconShape, _super);
    function IconShape() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$d([
        Property('None')
    ], IconShape.prototype, "shape", void 0);
    __decorate$d([
        Property('white')
    ], IconShape.prototype, "fill", void 0);
    __decorate$d([
        Property('Auto')
    ], IconShape.prototype, "horizontalAlignment", void 0);
    __decorate$d([
        Property('Auto')
    ], IconShape.prototype, "verticalAlignment", void 0);
    __decorate$d([
        Property(10)
    ], IconShape.prototype, "width", void 0);
    __decorate$d([
        Property(10)
    ], IconShape.prototype, "height", void 0);
    __decorate$d([
        Complex({ x: 0.5, y: 1 }, Point)
    ], IconShape.prototype, "offset", void 0);
    __decorate$d([
        Property('#1a1a1a')
    ], IconShape.prototype, "borderColor", void 0);
    __decorate$d([
        Property(1)
    ], IconShape.prototype, "borderWidth", void 0);
    __decorate$d([
        Complex({}, Margin)
    ], IconShape.prototype, "margin", void 0);
    __decorate$d([
        Property('')
    ], IconShape.prototype, "pathData", void 0);
    __decorate$d([
        Property('')
    ], IconShape.prototype, "content", void 0);
    __decorate$d([
        Property(0)
    ], IconShape.prototype, "cornerRadius", void 0);
    __decorate$d([
        Complex({ left: 2, right: 2, top: 2, bottom: 2 }, Margin)
    ], IconShape.prototype, "padding", void 0);
    __decorate$d([
        Property('#1a1a1a')
    ], IconShape.prototype, "iconColor", void 0);
    return IconShape;
}(ChildProperty));

var __extends$n = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * StackPanel module is used to arrange its children in a line
 */
var StackPanel = /** @class */ (function (_super) {
    __extends$n(StackPanel, _super);
    function StackPanel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Gets/Sets the orientation of the stack panel
         */
        _this.orientation = 'Vertical';
        /**
         * Not applicable for canvas
         * to avoid the child size updation with respect to parent ser true
         *
         * @private
         */
        _this.measureChildren = undefined;
        /**
         * Sets or gets whether the padding of the element needs to be measured
         *
         * @private
         */
        _this.considerPadding = true;
        return _this;
    }
    /**
     * Measures the minimum space that the panel needs \
     *
     * @returns { Size } Measures the minimum space that the panel needs.\
     * @param {Size} availableSize - provide the id value.
     *
     * @private
     */
    StackPanel.prototype.measure = function (availableSize) {
        var updateSize = this.orientation === 'Horizontal' ? this.updateHorizontalStack : this.updateVerticalStack;
        this.desiredSize = this.measureStackPanel(availableSize, updateSize);
        return this.desiredSize;
    };
    /**
     * Arranges the child elements of the stack panel \
     *
     * @returns { Size } Arranges the child elements of the stack panel.\
     * @param {Size} desiredSize - provide the id value.
     *
     * @private
     */
    StackPanel.prototype.arrange = function (desiredSize) {
        var updateSize = this.orientation === 'Horizontal' ? this.arrangeHorizontalStack : this.arrangeVerticalStack;
        this.actualSize = this.arrangeStackPanel(desiredSize, updateSize);
        this.updateBounds();
        return this.actualSize;
    };
    /**
     * Measures the minimum space that the panel needs \
     *
     * @returns { Size } Measures the minimum space that the panel needs.\
     * @param {Size} availableSize - provide the id value.
     * @param {Function} updateSize - provide the id value.
     *
     * @private
     */
    StackPanel.prototype.measureStackPanel = function (availableSize, updateSize) {
        var desired = undefined;
        if (this.children !== undefined && this.children.length > 0) {
            for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
                var child = _a[_i];
                child.parentTransform = this.rotateAngle + this.parentTransform;
                //Measure children
                if (this.measureChildren) {
                    child.measure(child.desiredSize);
                }
                else {
                    child.measure(availableSize);
                }
                var childSize = child.desiredSize.clone();
                //Consider Child's margin
                this.applyChildMargin(child, childSize);
                //Consider children's rotation
                if (child.rotateAngle !== 0) {
                    childSize = rotateSize(childSize, child.rotateAngle);
                }
                //Measure stack panel
                if (desired === undefined) {
                    desired = childSize;
                }
                else {
                    if (!child.preventContainer) {
                        updateSize(childSize, desired);
                    }
                }
            }
        }
        desired = _super.prototype.validateDesiredSize.call(this, desired, availableSize);
        this.stretchChildren(desired);
        //Considering padding values
        if (this.considerPadding) {
            this.applyPadding(desired);
        }
        return desired;
    };
    StackPanel.prototype.arrangeStackPanel = function (desiredSize, updatePosition) {
        if (this.children !== undefined && this.children.length > 0) {
            var x = void 0;
            var y = void 0;
            x = this.offsetX - desiredSize.width * this.pivot.x + this.padding.left;
            y = this.offsetY - desiredSize.height * this.pivot.y + this.padding.top;
            for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
                var child = _a[_i];
                var childSize = child.desiredSize.clone();
                var rotatedSize = childSize;
                if (this.orientation === 'Vertical') {
                    y += child.margin.top;
                }
                else {
                    x += child.margin.left;
                }
                if (child.rotateAngle !== 0) {
                    rotatedSize = rotateSize(childSize, child.rotateAngle);
                }
                var center = updatePosition(x, y, child, this, desiredSize, rotatedSize);
                _super.prototype.findChildOffsetFromCenter.call(this, child, center);
                child.arrange(childSize, true);
                if (this.orientation === 'Vertical') {
                    y += rotatedSize.height + child.margin.bottom;
                }
                else {
                    x += rotatedSize.width + child.margin.right;
                }
            }
        }
        return desiredSize;
    };
    StackPanel.prototype.updateHorizontalStack = function (child, parent) {
        parent.height = Math.max(child.height, parent.height);
        parent.width += child.width;
    };
    StackPanel.prototype.updateVerticalStack = function (child, parent) {
        parent.width = Math.max(child.width, parent.width);
        parent.height += child.height;
    };
    StackPanel.prototype.arrangeHorizontalStack = function (x, y, child, parent, parenBounds, childBounds) {
        var centerY = 0;
        if (child.verticalAlignment === 'Top') {
            centerY = y + child.margin.top + childBounds.height / 2;
        }
        else if (child.verticalAlignment === 'Bottom') {
            var parentBottom = parent.offsetY + parenBounds.height * (1 - parent.pivot.y);
            centerY = parentBottom - parent.padding.bottom - child.margin.bottom - childBounds.height / 2;
        }
        else {
            centerY = parent.offsetY - parenBounds.height * parent.pivot.y + parenBounds.height / 2;
            if (child.margin.top) {
                centerY = y + child.margin.top + childBounds.height / 2;
            }
        }
        return { x: x + childBounds.width / 2, y: centerY };
    };
    StackPanel.prototype.arrangeVerticalStack = function (x, y, child, parent, parentSize, childSize) {
        var centerX = 0;
        if (child.horizontalAlignment === 'Left') {
            centerX = x + child.margin.left + childSize.width / 2;
        }
        else if (child.horizontalAlignment === 'Right') {
            var parentRight = parent.offsetX + parentSize.width * (1 - parent.pivot.x);
            centerX = parentRight - parent.padding.right - child.margin.right - childSize.width / 2;
        }
        else {
            centerX = parent.offsetX - parentSize.width * parent.pivot.x + parentSize.width / 2;
            if (child.margin.left) {
                centerX = x + child.margin.left + childSize.width / 2;
            }
        }
        return { x: centerX, y: y + childSize.height / 2 };
    };
    StackPanel.prototype.stretchChildren = function (size) {
        if (this.children !== undefined && this.children.length > 0) {
            for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (this.orientation === 'Vertical') {
                    if (child.horizontalAlignment === 'Stretch') {
                        child.desiredSize.width = size.width - (child.margin.left + child.margin.right);
                    }
                }
                else {
                    if (child.verticalAlignment === 'Stretch') {
                        child.desiredSize.height = size.height - (child.margin.top + child.margin.bottom);
                    }
                }
            }
        }
    };
    StackPanel.prototype.applyChildMargin = function (child, size) {
        size.height += child.margin.top + child.margin.bottom;
        size.width += child.margin.left + child.margin.right;
    };
    return StackPanel;
}(Container));

/**
 * These utility methods help to process the data and to convert it to desired dimensions
 */
/**
 * getULMClassifierShapes method \
 *
 * @returns {DiagramElement} getULMClassifierShapes method .\
 * @param { DiagramElement} content - provide the content  value.
 * @param {NodeModel} node - provide the node  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @private
 */
function getULMClassifierShapes(content, node, diagram) {
    var classifier;
    var textWrap = 'NoWrap';
    if (node.shape.classifier === 'Class') {
        classifier = node.shape.classShape;
    }
    else if (node.shape.classifier === 'Enumeration') {
        classifier = node.shape.enumerationShape;
    }
    else if (node.shape.classifier === 'Interface') {
        classifier = node.shape.interfaceShape;
    }
    //let attributeText: string = '';
    node.container = { type: 'Stack', orientation: 'Vertical' };
    node.constraints = (NodeConstraints.Default | NodeConstraints.HideThumbs) &
        ~(NodeConstraints.Rotate | NodeConstraints.Resize);
    node.style = {
        fill: node.style.fill, strokeColor: node.style.strokeColor,
        strokeWidth: 1.5
    };
    node.children = [];
    if (node.maxWidth) {
        textWrap = 'Wrap';
    }
    var newObj = new Node(diagram, 'nodes', {
        id: node.id + '_umlClass_header',
        annotations: [
            {
                id: 'name', content: classifier.name,
                offset: { x: 0.5, y: 0.65 }, margin: { left: 10, right: 10 },
                style: {
                    bold: true, fontSize: 14, color: classifier.style.color, fill: classifier.style.fill,
                    textWrapping: textWrap
                }
            }, {
                content: '<<' + node.shape.classifier + '>>', margin: { left: 10, right: 10 },
                id: 'class', style: {
                    fontSize: classifier.style.fontSize,
                    color: classifier.style.color, fill: classifier.style.fill,
                    textWrapping: textWrap
                }, offset: { x: 0.5, y: 0.3 }, constraints: AnnotationConstraints.ReadOnly
            }
        ],
        constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize),
        verticalAlignment: 'Stretch',
        horizontalAlignment: 'Stretch',
        style: { fill: node.style.fill, strokeColor: (node.style.strokeColor === 'black') ? '#ffffff00' : node.style.strokeColor }
    }, true);
    diagram.initObject(newObj);
    diagram.nodes.push(newObj);
    diagram.UpdateBlazorDiagramModel(newObj, 'Node');
    node.children.push(newObj.id);
    getClassNodes(node, diagram, classifier, textWrap);
    getClassMembers(node, diagram, classifier, textWrap);
    /* eslint-disable */
    node.offsetX = node.offsetX;
    node.offsetY = node.offsetY;
    node.style.fill = node.style.fill;
    node.borderColor = node.borderColor;
    diagram.initObject(node);
    /* eslint-enable */
    return content;
}
/**
 * getClassNodes method \
 *
 * @returns {void} getClassNodes method .\
 * @param { Node} node - provide the node  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {UmlClassModel} classifier - provide the classifier  value.
 * @param {TextWrap} textWrap - provide the textWrap  value.
 * @private
 */
function getClassNodes(node, diagram, classifier, textWrap) {
    if (node.shape.classifier === 'Enumeration') {
        var member = classifier.members;
        if (member && member.length) {
            addSeparator(node, diagram);
            var memberText = '';
            for (var i = 0; i < member.length; i++) {
                var members = member[parseInt(i.toString(), 10)];
                if (members.name !== '') {
                    memberText += members.name;
                }
                if (i !== member.length) {
                    var style = getStyle(node, members);
                    var temp = new Node(diagram, 'nodes', {
                        id: randomId() + '_umlMember',
                        annotations: [
                            {
                                id: 'name', content: memberText, offset: { x: 0, y: 0.5 },
                                style: {
                                    bold: true, fontSize: style.fontSize, color: style.color, fill: style.fill,
                                    textWrapping: textWrap, italic: style.italic, fontFamily: style.fontFamily,
                                    whiteSpace: style.whiteSpace, textAlign: style.textAlign,
                                    textDecoration: style.textDecoration, textOverflow: style.textOverflow
                                },
                                margin: { left: 14, right: 5 }, horizontalAlignment: 'Left'
                            }
                        ], verticalAlignment: 'Stretch', horizontalAlignment: 'Stretch',
                        style: {
                            fill: node.style.fill, strokeColor: (node.style.strokeColor === 'black') ?
                                '#ffffff00' : node.style.strokeColor, textWrapping: textWrap
                        },
                        constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize),
                        minHeight: 25
                    }, true);
                    diagram.initObject(temp);
                    diagram.nodes.push(temp);
                    diagram.UpdateBlazorDiagramModel(temp, 'Node');
                    node.children.push(temp.id);
                    memberText = '';
                    if (members.isSeparator && (i !== member.length - 1)) {
                        addSeparator(node, diagram, members.separatorStyle);
                    }
                    //isSeperator boolean set as false whether it is set as true for last element
                    if (members.isSeparator && (i === member.length - 1)) {
                        members.isSeparator = false;
                    }
                }
            }
        }
    }
    else {
        var attributes = classifier.attributes;
        if (attributes.length) {
            var attributeText = '';
            addSeparator(node, diagram);
            for (var i = 0; i < attributes.length; i++) {
                var text = void 0;
                var attribute = attributes[parseInt(i.toString(), 10)];
                if (attribute.scope && (attribute).scope === 'Public') {
                    text = ' +';
                }
                else if (attribute.scope && attribute.scope === 'Private') {
                    text = '-';
                }
                else if (attribute.scope && attribute.scope === 'Protected') {
                    text = '#';
                }
                else {
                    text = '~';
                }
                if (attribute.name !== '') {
                    if (text) {
                        attributeText += text + ' ' + attribute.name + ' ' + ': ' + attribute.type;
                    }
                }
                if (i !== attributes.length) {
                    var style = getStyle(node, attribute);
                    var temp = new Node(diagram, 'nodes', {
                        id: randomId() + '_umlProperty', style: { fill: node.style.fill,
                            strokeColor: (node.style.strokeColor === 'black') ? '#ffffff00' : node.style.strokeColor },
                        annotations: [
                            {
                                id: 'name', content: attributeText, offset: { x: 0, y: 0.5 },
                                style: {
                                    bold: true, fontSize: style.fontSize, color: style.color, fill: style.fill,
                                    textWrapping: textWrap, italic: style.italic, fontFamily: style.fontFamily,
                                    whiteSpace: style.whiteSpace, textAlign: style.textAlign,
                                    textDecoration: style.textDecoration, textOverflow: style.textOverflow
                                },
                                margin: { left: 14, right: 5 }, horizontalAlignment: 'Left'
                            }
                        ], verticalAlignment: 'Stretch', horizontalAlignment: 'Stretch',
                        constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize),
                        minHeight: 25
                    }, true);
                    diagram.initObject(temp);
                    diagram.nodes.push(temp);
                    diagram.UpdateBlazorDiagramModel(temp, 'Node');
                    node.children.push(temp.id);
                    attributeText = '';
                    if (attribute.isSeparator && (i !== attributes.length - 1)) {
                        addSeparator(node, diagram, attribute.separatorStyle);
                    }
                    //isSeperator boolean set as false whether it is set as true for last element
                    if (attribute.isSeparator && (i === attributes.length - 1)) {
                        attribute.isSeparator = false;
                    }
                }
            }
        }
    }
}
/**
 * getClassNodesChild method - This method is utilized to dynamically add members to a UML node at runtime. \
 *
 * @returns {void} getClassNodesChild method .\
 * @param { Node} node - provide the node  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {UmlClassModel} classifier - provide the classifier  value.
 * @param {TextWrap} textWrap - provide the textWrap  value.
 * @private
 */
function getClassNodesChild(node, diagram, classifier, textWrap) {
    if (node.shape.classifier === 'Enumeration') {
        var member = classifier.members;
        var memberText = '';
        // if there is no members in existing array, then the separator need to be added for new member
        if (member.length === 1) {
            var newIndex = member.length;
            addSeparatorChild(node, diagram, newIndex);
        }
        var count = 0;
        // Need to indentify the index value for newly added member
        for (var i = 0; i < member.length - 1; i++) {
            if (member[parseInt(i.toString(), 10)].isSeparator === true) {
                count++;
            }
        }
        var index = member.length + count + 1;
        //Iterate through an array of members and create each member as a child node to the UML node
        for (var i = 0; i < member.length; i++) {
            var members = member[member.length - 1];
            if (members.name !== '') {
                memberText += members.name;
            }
            if (i !== member.length) {
                var style = getStyle(node, members);
                var temp = new Node(diagram, 'nodes', {
                    id: randomId() + '_umlMember',
                    annotations: [
                        {
                            id: 'name', content: memberText, offset: { x: 0, y: 0.5 },
                            style: {
                                bold: true, fontSize: style.fontSize, color: style.color, fill: style.fill,
                                textWrapping: textWrap, italic: style.italic, fontFamily: style.fontFamily,
                                whiteSpace: style.whiteSpace, textAlign: style.textAlign,
                                textDecoration: style.textDecoration, textOverflow: style.textOverflow
                            },
                            margin: { left: 14, right: 5 }, horizontalAlignment: 'Left'
                        }
                    ], verticalAlignment: 'Stretch', horizontalAlignment: 'Stretch',
                    style: {
                        fill: node.style.fill, strokeColor: (node.style.strokeColor === 'black') ?
                            '#ffffff00' : node.style.strokeColor, textWrapping: textWrap
                    },
                    constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize),
                    minHeight: 25
                }, true);
                temp.parentId = node.id;
                temp.umlIndex = index;
                diagram.add(temp);
                memberText = '';
            }
            break;
        }
    }
}
/**
 * getClassAttributesChild method - This method is utilized to dynamically add attributes to a UML node at runtime.\
 *
 * @returns {void} getClassAttributesChild method .\
 * @param { Node} node - provide the node  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {UmlClassModel} classifier - provide the classifier  value.
 * @param {TextWrap} textWrap - provide the textWrap  value.
 * @private
 */
function getClassAttributesChild(node, diagram, classifier, textWrap) {
    if (classifier.attributes && classifier.attributes.length) {
        var attributes = classifier.attributes;
        var attributeText = '';
        var text = void 0;
        // if there is no attributes in existing array, then the separator need to be added for new attribute
        if (attributes.length === 1) {
            var newIndex = attributes.length;
            addSeparatorChild(node, diagram, newIndex);
        }
        var count = 0;
        // Need to indentify the index value for newly added attribute
        for (var i = 0; i < attributes.length - 1; i++) {
            if (attributes[parseInt(i.toString(), 10)].isSeparator === true) {
                count++;
            }
        }
        var index = attributes.length + count + 1;
        //Iterate through an array of attributes and create each attribute as a child node to the UML node
        for (var i = 0; i < attributes.length; i++) {
            var attribute = attributes[attributes.length - 1];
            if (attribute.scope && (attribute).scope === 'Public') {
                text = ' +';
            }
            else if (attribute.scope && attribute.scope === 'Private') {
                text = '-';
            }
            else if (attribute.scope && attribute.scope === 'Protected') {
                text = '#';
            }
            else {
                text = '~';
            }
            if (attribute.name !== '') {
                if (text) {
                    attributeText += text + ' ' + attribute.name + ' ' + ': ' + attribute.type;
                }
            }
            if (i !== attributes.length) {
                var style = getStyle(node, attribute);
                var temp = new Node(diagram, 'nodes', {
                    id: randomId() + '_umlProperty', style: {
                        fill: node.style.fill,
                        strokeColor: (node.style.strokeColor === 'black') ? '#ffffff00' : node.style.strokeColor
                    },
                    annotations: [
                        {
                            id: 'name', content: attributeText, offset: { x: 0, y: 0.5 },
                            style: {
                                bold: true, fontSize: style.fontSize, color: style.color, fill: style.fill,
                                textWrapping: textWrap, italic: style.italic, fontFamily: style.fontFamily,
                                whiteSpace: style.whiteSpace, textAlign: style.textAlign,
                                textDecoration: style.textDecoration, textOverflow: style.textOverflow
                            },
                            margin: { left: 14, right: 5 }, horizontalAlignment: 'Left'
                        }
                    ], verticalAlignment: 'Stretch', horizontalAlignment: 'Stretch',
                    constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize),
                    minHeight: 25
                }, true);
                temp.parentId = node.id;
                temp.umlIndex = index;
                diagram.add(temp);
                attributeText = '';
            }
            break;
        }
    }
}
/**
 * getClassMembers method \
 *
 * @returns {void} getClassMembers method .\
 * @param { Node} node - provide the node  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {UmlClassModel} classifier - provide the classifier  value.
 * @param {TextWrap} textWrap - provide the textWrap  value.
 * @private
 */
function getClassMembers(node, diagram, classifier, textWrap) {
    if (classifier.methods && classifier.methods.length) {
        var methods = classifier.methods;
        addSeparator(node, diagram);
        var argumentText = '';
        var methodText = '';
        var text = void 0;
        for (var i = 0; i < methods.length; i++) {
            var method = methods[parseInt(i.toString(), 10)];
            if (method.scope && method.scope === 'Public') {
                text = ' +';
            }
            else if (method.scope && method.scope === 'Private') {
                text = '-';
            }
            else if (method.scope && method.scope === 'Protected') {
                text = '#';
            }
            else {
                text = '~';
            }
            if (method.parameters) {
                for (var j = 0; j < method.parameters.length; j++) {
                    if (method.parameters[parseInt(j.toString(), 10)].type) {
                        argumentText += method.parameters[parseInt(j.toString(), 10)].name + ':' + method.parameters[parseInt(j.toString(), 10)].type;
                    }
                    else {
                        argumentText += method.parameters[parseInt(j.toString(), 10)].name;
                    }
                    if (j !== method.parameters.length - 1) {
                        argumentText += ',';
                    }
                }
            }
            if (method.name !== '') {
                if (text) {
                    methodText += text + ' ' + method.name + '(' + argumentText + ')' + ' ' + ':' + ' ' + method.type;
                }
                //893885: Parameter Name in UMLClass with multiple Methods are updated wrongly
                //clear the value stored in parameter variable after each method initiaization
                argumentText = '';
            }
            if (i !== methods.length) {
                var style = getStyle(node, method);
                var temp = new Node(diagram, 'nodes', {
                    id: randomId() + '_umlMethods', verticalAlignment: 'Stretch', horizontalAlignment: 'Stretch',
                    annotations: [
                        {
                            id: 'name', content: methodText, offset: { x: 0, y: 0.5 },
                            style: {
                                bold: true, fontSize: style.fontSize, color: style.color, fill: style.fill,
                                textWrapping: textWrap, italic: style.italic, fontFamily: style.fontFamily,
                                whiteSpace: style.whiteSpace, textAlign: style.textAlign,
                                textDecoration: style.textDecoration, textOverflow: style.textOverflow
                            },
                            margin: { left: 14, right: 5 }, horizontalAlignment: 'Left'
                        }
                    ],
                    style: {
                        fill: node.style.fill, strokeColor: (node.style.strokeColor === 'black') ?
                            '#ffffff00' : node.style.strokeColor
                    }, minHeight: 25,
                    constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize)
                }, true);
                diagram.initObject(temp);
                diagram.nodes.push(temp);
                diagram.UpdateBlazorDiagramModel(temp, 'Node');
                node.children.push(temp.id);
                methodText = '';
                if (method.isSeparator && (i !== methods.length - 1)) {
                    addSeparator(node, diagram, method.separatorStyle);
                }
                //isSeperator boolean set as false whether it is set as true for last element
                if (method.isSeparator && (i === methods.length - 1)) {
                    method.isSeparator = false;
                }
            }
        }
    }
}
/**
 * getClassMembersChild method - This method is utilized to dynamically add methods to a UML node at runtime. \
 *
 * @returns {void} getClassMembersChild method .\
 * @param { Node} node - provide the node  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {UmlClassModel} classifier - provide the classifier  value.
 * @param {TextWrap} textWrap - provide the textWrap  value.
 * @private
 */
function getClassMembersChild(node, diagram, classifier, textWrap) {
    if (classifier.methods && classifier.methods.length) {
        var methods = classifier.methods;
        var argumentText = '';
        var methodText = '';
        var text = void 0;
        var initialIndex = 1;
        var index = void 0;
        var attributeCount = 0;
        var methodCount = 0;
        var shapeModel = node.shape;
        var isClass = shapeModel.classifier === 'Class';
        var isInterface = shapeModel.classifier === 'Interface';
        var umlShape = isClass ? shapeModel.classShape : shapeModel.interfaceShape;
        // Need to indentify the index value for newly added method
        if (methods.length === 1) {
            if (umlShape.attributes.length > 0) {
                attributeCount = umlShape.attributes.filter(function (attr) { return attr.isSeparator; }).length;
                initialIndex = 1 + 1 + umlShape.attributes.length + attributeCount;
                index = initialIndex + 1;
                addSeparatorChild(node, diagram, initialIndex);
            }
            else {
                index = initialIndex + 1;
            }
        }
        // To determine the index value for adding methods, it is essential to take into account the existing attributes
        else {
            attributeCount = umlShape.attributes.filter(function (attr) { return attr.isSeparator; }).length;
            methodCount = umlShape.methods.filter(function (method) { return method.isSeparator; }).length;
            initialIndex = 1 + 1 + umlShape.attributes.length + attributeCount + umlShape.methods.length + methodCount;
            index = initialIndex + 1;
        }
        //Iterate through an array of methods and create each method as a child node to the UML node
        for (var i = 0; i < methods.length; i++) {
            var method = methods[methods.length - 1];
            if (method.scope && method.scope === 'Public') {
                text = ' +';
            }
            else if (method.scope && method.scope === 'Private') {
                text = '-';
            }
            else if (method.scope && method.scope === 'Protected') {
                text = '#';
            }
            else {
                text = '~';
            }
            if (method.parameters) {
                for (var j = 0; j < method.parameters.length; j++) {
                    if (method.parameters[parseInt(j.toString(), 10)].type) {
                        argumentText += method.parameters[parseInt(j.toString(), 10)].name + ':' + method.parameters[parseInt(j.toString(), 10)].type;
                    }
                    else {
                        argumentText += method.parameters[parseInt(j.toString(), 10)].name;
                    }
                    if (j !== method.parameters.length - 1) {
                        argumentText += ',';
                    }
                }
            }
            if (method.name !== '') {
                if (text) {
                    methodText += text + ' ' + method.name + '(' + argumentText + ')' + ' ' + ':' + ' ' + method.type;
                }
            }
            if (i !== methods.length) {
                var style = getStyle(node, method);
                var temp = new Node(diagram, 'nodes', {
                    id: randomId() + '_umlMethods', verticalAlignment: 'Stretch', horizontalAlignment: 'Stretch',
                    annotations: [
                        {
                            id: 'name', content: methodText, offset: { x: 0, y: 0.5 },
                            style: {
                                bold: true, fontSize: style.fontSize, color: style.color, fill: style.fill,
                                textWrapping: textWrap, italic: style.italic, fontFamily: style.fontFamily,
                                whiteSpace: style.whiteSpace, textAlign: style.textAlign,
                                textDecoration: style.textDecoration, textOverflow: style.textOverflow
                            },
                            margin: { left: 14, right: 5 }, horizontalAlignment: 'Left'
                        }
                    ],
                    style: {
                        fill: node.style.fill, strokeColor: (node.style.strokeColor === 'black') ?
                            '#ffffff00' : node.style.strokeColor
                    }, minHeight: 25,
                    constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize)
                }, true);
                temp.parentId = node.id;
                temp.umlIndex = index;
                diagram.add(temp);
                methodText = '';
            }
            break;
        }
    }
}
/**
 * addSeparator method \
 *
 * @returns {void} addSeparator method .\
 * @param { Node} stack - provide the stack  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {SeperatorStyle} SeperatorStyle - provide the Seperator color.
 * @private
 */
function addSeparator(stack, diagram, SeperatorStyle) {
    var lineObject = new Node(diagram, 'nodes', {
        id: randomId() + '_path', height: 1, constraints: NodeConstraints.Default & ~(NodeConstraints.Select),
        verticalAlignment: 'Stretch', horizontalAlignment: 'Stretch',
        style: {
            strokeColor: (stack.style.strokeColor === 'black') ? '#ffffff00' : stack.style.strokeColor,
            fill: SeperatorStyle ? SeperatorStyle.fill : 'white'
        }
    }, true);
    diagram.initObject(lineObject);
    diagram.nodes.push(lineObject);
    stack.children.push(lineObject.id);
}
/**
 * addSeparatorChild method -This method is designed to add a separator for the newly added child type to the UML node. \
 *
 * @returns {void} addSeparator method .\
 * @param { Node} stack - provide the stack  value.
 * @param {Diagram} diagram - provide the diagram  value.
 * @param {number} newIndex - provide the index value.
 * @private
 */
function addSeparatorChild(stack, diagram, newIndex) {
    var lineObject = new Node(diagram, 'nodes', {
        id: randomId() + '_path', height: 1, constraints: NodeConstraints.Default & ~(NodeConstraints.Select),
        verticalAlignment: 'Stretch', horizontalAlignment: 'Stretch',
        style: { strokeColor: (stack.style.strokeColor === 'black') ? '#ffffff00' : stack.style.strokeColor, fill: 'white' }
    }, true);
    lineObject.parentId = stack.id;
    lineObject.umlIndex = newIndex;
    diagram.add(lineObject);
}
/**
 * getStyle method \
 *
 * @returns {TextStyleModel} addSeparator method .\
 * @param { Node} stack - provide the stack  value.
 * @param {UmlClassModel} node - provide the node  value.
 * @private
 */
function getStyle(stack, node) {
    var newStyle = {};
    var style = node.style;
    newStyle.fill = (style.fill !== 'transparent') ? style.fill : stack.style.fill;
    newStyle.color = style.color;
    newStyle.fontFamily = (style.fontFamily !== 'Arial') ? style.fontFamily : stack.style.fontFamily;
    newStyle.italic = style.italic;
    newStyle.bold = style.bold;
    newStyle.whiteSpace = style.whiteSpace;
    newStyle.textAlign = style.textAlign;
    newStyle.textWrapping = style.textWrapping;
    newStyle.textDecoration = style.textDecoration;
    newStyle.textOverflow = style.textOverflow;
    // newStyle.margin = style.mar
    newStyle.fontSize = (style.fontSize !== 12) ? style.fontSize : stack.style.fontSize;
    newStyle.strokeColor = (style.strokeColor !== 'black') ? style.strokeColor : stack.style.strokeColor;
    newStyle.strokeWidth = (style.strokeWidth !== 1) ? style.strokeWidth : stack.style.strokeWidth;
    return newStyle;
}

var __extends$o = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * A collection of JSON objects where each object represents a layer.
 * Layer is a named category of diagram shapes.
 */
var LayoutInfo = /** @class */ (function (_super) {
    __extends$o(LayoutInfo, _super);
    function LayoutInfo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$e([
        Property('Horizontal')
    ], LayoutInfo.prototype, "orientation", void 0);
    __decorate$e([
        Property('Center')
    ], LayoutInfo.prototype, "type", void 0);
    __decorate$e([
        Property(undefined)
    ], LayoutInfo.prototype, "offset", void 0);
    __decorate$e([
        Property(false)
    ], LayoutInfo.prototype, "enableRouting", void 0);
    __decorate$e([
        Property([])
    ], LayoutInfo.prototype, "children", void 0);
    __decorate$e([
        Property('')
    ], LayoutInfo.prototype, "assistants", void 0);
    __decorate$e([
        Property('')
    ], LayoutInfo.prototype, "level", void 0);
    __decorate$e([
        Property('')
    ], LayoutInfo.prototype, "hasSubTree", void 0);
    __decorate$e([
        Property('')
    ], LayoutInfo.prototype, "rows", void 0);
    return LayoutInfo;
}(ChildProperty));

var __extends$p = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var getShapeType = function (obj) {
    if (obj) {
        //Removed isBlazor code
        switch (obj.type) {
            case 'Basic':
                return BasicShape;
            case 'Flow':
                return FlowShape;
            case 'Path':
                return Path;
            case 'Image':
                return Image$1;
            case 'Text':
                return Text;
            case 'Bpmn':
                return BpmnShape;
            case 'Native':
                return Native;
            case 'HTML':
                return Html;
            case 'UmlActivity':
                return UmlActivityShape;
            case 'UmlClassifier':
                return UmlClassifierShape;
            case 'SwimLane':
                return SwimLane;
            default:
                return BasicShape;
        }
    }
    return BasicShape;
};
/**
 * Defines the behavior of default shape
 */
var Shape = /** @class */ (function (_super) {
    __extends$p(Shape, _super);
    function Shape() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$f([
        Property('Basic')
    ], Shape.prototype, "type", void 0);
    return Shape;
}(ChildProperty));
/**
 * Defines the behavior of path shape
 */
var Path = /** @class */ (function (_super) {
    __extends$p(Path, _super);
    function Path() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * getClassName method \
     *
     * @returns { string } toBounds method .\
     *
     * @private
     */
    Path.prototype.getClassName = function () {
        return 'Path';
    };
    __decorate$f([
        Property('Path')
    ], Path.prototype, "type", void 0);
    __decorate$f([
        Property('')
    ], Path.prototype, "data", void 0);
    return Path;
}(Shape));
/**
 * Defines the behavior of Native shape
 */
var Native = /** @class */ (function (_super) {
    __extends$p(Native, _super);
    function Native() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class Native
     *
     * @private
     */
    Native.prototype.getClassName = function () {
        return 'Native';
    };
    __decorate$f([
        Property('Native')
    ], Native.prototype, "type", void 0);
    __decorate$f([
        Property('')
    ], Native.prototype, "content", void 0);
    __decorate$f([
        Property('Stretch')
    ], Native.prototype, "scale", void 0);
    return Native;
}(Shape));
/**
 * Defines the behavior of html shape
 */
var Html = /** @class */ (function (_super) {
    __extends$p(Html, _super);
    function Html() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class Html
     *
     * @private
     */
    Html.prototype.getClassName = function () {
        return 'Html';
    };
    __decorate$f([
        Property('HTML')
    ], Html.prototype, "type", void 0);
    __decorate$f([
        Property('')
    ], Html.prototype, "content", void 0);
    return Html;
}(Shape));
/**
 * Defines the behavior of image shape
 */
var Image$1 = /** @class */ (function (_super) {
    __extends$p(Image, _super);
    function Image() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class Image
     *
     * @private
     */
    Image.prototype.getClassName = function () {
        return 'Image';
    };
    __decorate$f([
        Property('Image')
    ], Image.prototype, "type", void 0);
    __decorate$f([
        Property('')
    ], Image.prototype, "source", void 0);
    __decorate$f([
        Property('None')
    ], Image.prototype, "scale", void 0);
    __decorate$f([
        Property('None')
    ], Image.prototype, "align", void 0);
    return Image;
}(Shape));
/**
 * Defines the behavior of the text shape
 */
var Text = /** @class */ (function (_super) {
    __extends$p(Text, _super);
    function Text() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class Text
     *
     * @private
     */
    Text.prototype.getClassName = function () {
        return 'Text';
    };
    __decorate$f([
        Property('Text')
    ], Text.prototype, "type", void 0);
    __decorate$f([
        Property('')
    ], Text.prototype, "content", void 0);
    __decorate$f([
        Complex({}, Margin)
    ], Text.prototype, "margin", void 0);
    return Text;
}(Shape));
/**
 * Defines the behavior of the basic shape
 */
var BasicShape = /** @class */ (function (_super) {
    __extends$p(BasicShape, _super);
    function BasicShape() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class BasicShape
     *
     * @private
     *
     */
    BasicShape.prototype.getClassName = function () {
        return 'BasicShape';
    };
    __decorate$f([
        Property('Basic')
    ], BasicShape.prototype, "type", void 0);
    __decorate$f([
        Property('Rectangle')
    ], BasicShape.prototype, "shape", void 0);
    __decorate$f([
        Property(0)
    ], BasicShape.prototype, "cornerRadius", void 0);
    __decorate$f([
        Collection([], Point)
    ], BasicShape.prototype, "points", void 0);
    return BasicShape;
}(Shape));
/**
 * Defines the behavior of the flow shape
 */
var FlowShape = /** @class */ (function (_super) {
    __extends$p(FlowShape, _super);
    function FlowShape() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class FlowShape
     *
     * @private
     */
    FlowShape.prototype.getClassName = function () {
        return 'FlowShape';
    };
    __decorate$f([
        Property('Flow')
    ], FlowShape.prototype, "type", void 0);
    __decorate$f([
        Property('Terminator')
    ], FlowShape.prototype, "shape", void 0);
    return FlowShape;
}(Shape));
/**
 * Defines the behavior of the bpmn gateway shape
 */
var BpmnGateway = /** @class */ (function (_super) {
    __extends$p(BpmnGateway, _super);
    function BpmnGateway() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class BpmnGateway
     *
     * @private
     */
    BpmnGateway.prototype.getClassName = function () {
        return 'BpmnGateway';
    };
    __decorate$f([
        Property('None')
    ], BpmnGateway.prototype, "type", void 0);
    return BpmnGateway;
}(ChildProperty));
/**
 * Defines the behavior of the bpmn data object
 */
var BpmnDataObject = /** @class */ (function (_super) {
    __extends$p(BpmnDataObject, _super);
    function BpmnDataObject() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class BpmnDataObject
     *
     * @private
     */
    BpmnDataObject.prototype.getClassName = function () {
        return 'BpmnDataObject';
    };
    __decorate$f([
        Property('None')
    ], BpmnDataObject.prototype, "type", void 0);
    __decorate$f([
        Property(false)
    ], BpmnDataObject.prototype, "collection", void 0);
    return BpmnDataObject;
}(ChildProperty));
/**
 * Defines the behavior of the bpmn task shape
 */
var BpmnTask = /** @class */ (function (_super) {
    __extends$p(BpmnTask, _super);
    function BpmnTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$f([
        Property('None')
    ], BpmnTask.prototype, "type", void 0);
    __decorate$f([
        Property('None')
    ], BpmnTask.prototype, "loop", void 0);
    __decorate$f([
        Property(false)
    ], BpmnTask.prototype, "call", void 0);
    __decorate$f([
        Property(false)
    ], BpmnTask.prototype, "compensation", void 0);
    return BpmnTask;
}(ChildProperty));
/**
 * Defines the behavior of the bpmn Event shape
 */
var BpmnEvent = /** @class */ (function (_super) {
    __extends$p(BpmnEvent, _super);
    function BpmnEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class BpmnEvent
     *
     * @private
     */
    BpmnEvent.prototype.getClassName = function () {
        return 'BpmnEvent';
    };
    __decorate$f([
        Property('Start')
    ], BpmnEvent.prototype, "event", void 0);
    __decorate$f([
        Property('None')
    ], BpmnEvent.prototype, "trigger", void 0);
    return BpmnEvent;
}(ChildProperty));
/**
 * Defines the behavior of the bpmn sub event
 */
var BpmnSubEvent = /** @class */ (function (_super) {
    __extends$p(BpmnSubEvent, _super);
    function BpmnSubEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class BpmnSubEvent
     *
     * @private
     */
    BpmnSubEvent.prototype.getClassName = function () {
        return 'BpmnSubEvent';
    };
    __decorate$f([
        Property('None')
    ], BpmnSubEvent.prototype, "trigger", void 0);
    __decorate$f([
        Property('Start')
    ], BpmnSubEvent.prototype, "event", void 0);
    __decorate$f([
        Property('')
    ], BpmnSubEvent.prototype, "id", void 0);
    __decorate$f([
        Complex({}, Point)
    ], BpmnSubEvent.prototype, "offset", void 0);
    __decorate$f([
        Collection([], ShapeAnnotation)
    ], BpmnSubEvent.prototype, "annotations", void 0);
    __decorate$f([
        Collection([], PointPort)
    ], BpmnSubEvent.prototype, "ports", void 0);
    __decorate$f([
        Property()
    ], BpmnSubEvent.prototype, "width", void 0);
    __decorate$f([
        Property()
    ], BpmnSubEvent.prototype, "height", void 0);
    __decorate$f([
        Complex({}, Margin)
    ], BpmnSubEvent.prototype, "margin", void 0);
    __decorate$f([
        Property('Center')
    ], BpmnSubEvent.prototype, "horizontalAlignment", void 0);
    __decorate$f([
        Property('Center')
    ], BpmnSubEvent.prototype, "verticalAlignment", void 0);
    __decorate$f([
        Property(true)
    ], BpmnSubEvent.prototype, "visible", void 0);
    return BpmnSubEvent;
}(ChildProperty));
/**
 * Defines the behavior of the BpmnTransactionSubProcess
 */
var BpmnTransactionSubProcess = /** @class */ (function (_super) {
    __extends$p(BpmnTransactionSubProcess, _super);
    function BpmnTransactionSubProcess() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$f([
        Complex({ id: 'success', event: 'End', offset: { x: 1, y: 0.5 } }, BpmnSubEvent)
    ], BpmnTransactionSubProcess.prototype, "success", void 0);
    __decorate$f([
        Complex({ id: 'failure', event: 'Intermediate', trigger: 'Error', offset: { x: 0.25, y: 1 } }, BpmnSubEvent)
    ], BpmnTransactionSubProcess.prototype, "failure", void 0);
    __decorate$f([
        Complex({ id: 'cancel', event: 'Intermediate', trigger: 'Cancel', offset: { x: 0.75, y: 1 } }, BpmnSubEvent)
    ], BpmnTransactionSubProcess.prototype, "cancel", void 0);
    return BpmnTransactionSubProcess;
}(ChildProperty));
/**
 * Defines the behavior of the BPMNSubProcess
 */
var BpmnSubProcess = /** @class */ (function (_super) {
    __extends$p(BpmnSubProcess, _super);
    function BpmnSubProcess() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$f([
        Property('None')
    ], BpmnSubProcess.prototype, "type", void 0);
    __decorate$f([
        Property(false)
    ], BpmnSubProcess.prototype, "adhoc", void 0);
    __decorate$f([
        Property('Default')
    ], BpmnSubProcess.prototype, "boundary", void 0);
    __decorate$f([
        Property(false)
    ], BpmnSubProcess.prototype, "compensation", void 0);
    __decorate$f([
        Property('None')
    ], BpmnSubProcess.prototype, "loop", void 0);
    __decorate$f([
        Property(true)
    ], BpmnSubProcess.prototype, "collapsed", void 0);
    __decorate$f([
        Collection([], BpmnSubEvent)
    ], BpmnSubProcess.prototype, "events", void 0);
    __decorate$f([
        Complex({}, BpmnTransactionSubProcess)
    ], BpmnSubProcess.prototype, "transaction", void 0);
    __decorate$f([
        Property(undefined)
    ], BpmnSubProcess.prototype, "processes", void 0);
    return BpmnSubProcess;
}(ChildProperty));
/**
 * Defines the behavior of the bpmn activity shape
 */
var BpmnActivity = /** @class */ (function (_super) {
    __extends$p(BpmnActivity, _super);
    function BpmnActivity() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class BpmnActivity
     *
     * @private
     */
    BpmnActivity.prototype.getClassName = function () {
        return 'BpmnActivity';
    };
    __decorate$f([
        Property('Task')
    ], BpmnActivity.prototype, "activity", void 0);
    __decorate$f([
        Complex({}, BpmnTask)
    ], BpmnActivity.prototype, "task", void 0);
    __decorate$f([
        Complex({}, BpmnSubProcess)
    ], BpmnActivity.prototype, "subProcess", void 0);
    return BpmnActivity;
}(ChildProperty));
/**
 * Defines the behavior of the bpmn annotation
 * @deprecated
 */
var BpmnAnnotation = /** @class */ (function (_super) {
    __extends$p(BpmnAnnotation, _super);
    // tslint:disable-next-line:no-any
    function BpmnAnnotation(parent, propName, defaultValue, isArray) {
        return _super.call(this, parent, propName, defaultValue, isArray) || this;
    }
    /**
     * @private
     * Returns the name of class BpmnAnnotation
     */
    BpmnAnnotation.prototype.getClassName = function () {
        return 'BpmnAnnotation';
    };
    __decorate$f([
        Property('')
    ], BpmnAnnotation.prototype, "text", void 0);
    __decorate$f([
        Property('')
    ], BpmnAnnotation.prototype, "id", void 0);
    __decorate$f([
        Property(0)
    ], BpmnAnnotation.prototype, "angle", void 0);
    __decorate$f([
        Property()
    ], BpmnAnnotation.prototype, "height", void 0);
    __decorate$f([
        Property()
    ], BpmnAnnotation.prototype, "width", void 0);
    __decorate$f([
        Property(0)
    ], BpmnAnnotation.prototype, "length", void 0);
    return BpmnAnnotation;
}(ChildProperty));
var BpmnTextAnnotation = /** @class */ (function (_super) {
    __extends$p(BpmnTextAnnotation, _super);
    function BpmnTextAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$f([
        Property('')
    ], BpmnTextAnnotation.prototype, "textAnnotationTarget", void 0);
    __decorate$f([
        Property('Auto')
    ], BpmnTextAnnotation.prototype, "textAnnotationDirection", void 0);
    return BpmnTextAnnotation;
}(ChildProperty));
/**
 * Defines the behavior of the bpmn shape
 */
var BpmnShape = /** @class */ (function (_super) {
    __extends$p(BpmnShape, _super);
    function BpmnShape() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class BpmnShape
     *
     * @private
     */
    BpmnShape.prototype.getClassName = function () {
        return 'BpmnShape';
    };
    __decorate$f([
        Property('Bpmn')
    ], BpmnShape.prototype, "type", void 0);
    __decorate$f([
        Property('Event')
    ], BpmnShape.prototype, "shape", void 0);
    __decorate$f([
        Complex({}, BpmnEvent)
    ], BpmnShape.prototype, "event", void 0);
    __decorate$f([
        Complex({}, BpmnGateway)
    ], BpmnShape.prototype, "gateway", void 0);
    __decorate$f([
        Complex({}, BpmnDataObject)
    ], BpmnShape.prototype, "dataObject", void 0);
    __decorate$f([
        Complex({}, BpmnActivity)
    ], BpmnShape.prototype, "activity", void 0);
    __decorate$f([
        Complex({}, BpmnAnnotation)
    ], BpmnShape.prototype, "annotation", void 0);
    __decorate$f([
        Collection([], BpmnAnnotation)
    ], BpmnShape.prototype, "annotations", void 0);
    __decorate$f([
        Complex({}, BpmnTextAnnotation)
    ], BpmnShape.prototype, "textAnnotation", void 0);
    return BpmnShape;
}(Shape));
/**
 * Defines the behavior of the UMLActivity shape
 */
var UmlActivityShape = /** @class */ (function (_super) {
    __extends$p(UmlActivityShape, _super);
    function UmlActivityShape() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class UmlActivityShape
     *
     * @private
     */
    UmlActivityShape.prototype.getClassName = function () {
        return 'UmlActivityShape';
    };
    __decorate$f([
        Property('UmlActivity')
    ], UmlActivityShape.prototype, "type", void 0);
    __decorate$f([
        Property('Action')
    ], UmlActivityShape.prototype, "shape", void 0);
    return UmlActivityShape;
}(Shape));
/**
 * Defines the behavior of the uml class method
 */
var MethodArguments = /** @class */ (function (_super) {
    __extends$p(MethodArguments, _super);
    function MethodArguments() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class MethodArguments
     *
     * @private
     */
    MethodArguments.prototype.getClassName = function () {
        return 'MethodArguments';
    };
    __decorate$f([
        Property('')
    ], MethodArguments.prototype, "name", void 0);
    __decorate$f([
        Property('')
    ], MethodArguments.prototype, "type", void 0);
    __decorate$f([
        Complex({}, TextStyle)
    ], MethodArguments.prototype, "style", void 0);
    return MethodArguments;
}(ChildProperty));
/**
 * Defines the behavior of the uml class attributes
 */
var UmlClassAttribute = /** @class */ (function (_super) {
    __extends$p(UmlClassAttribute, _super);
    function UmlClassAttribute() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class UmlClassAttribute
     *
     * @private
     */
    UmlClassAttribute.prototype.getClassName = function () {
        return 'UmlClassAttribute';
    };
    __decorate$f([
        Property('Public')
    ], UmlClassAttribute.prototype, "scope", void 0);
    __decorate$f([
        Property(false)
    ], UmlClassAttribute.prototype, "isSeparator", void 0);
    __decorate$f([
        Complex({ fill: '#F9F9F9', strokeColor: '#CCCCCC' }, ShapeStyle)
    ], UmlClassAttribute.prototype, "separatorStyle", void 0);
    return UmlClassAttribute;
}(MethodArguments));
/**
 * Defines the behavior of the uml class method
 */
var UmlClassMethod = /** @class */ (function (_super) {
    __extends$p(UmlClassMethod, _super);
    function UmlClassMethod() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class UmlClassMethod
     *
     * @private
     */
    UmlClassMethod.prototype.getClassName = function () {
        return 'UmlClassMethod';
    };
    __decorate$f([
        Collection([], MethodArguments)
    ], UmlClassMethod.prototype, "parameters", void 0);
    return UmlClassMethod;
}(UmlClassAttribute));
/**
 * Defines the behavior of the uml class shapes
 */
var UmlClass = /** @class */ (function (_super) {
    __extends$p(UmlClass, _super);
    function UmlClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class UmlClass
     *
     * @private
     */
    UmlClass.prototype.getClassName = function () {
        return 'UmlClass';
    };
    __decorate$f([
        Property('')
    ], UmlClass.prototype, "name", void 0);
    __decorate$f([
        Collection([], UmlClassAttribute)
    ], UmlClass.prototype, "attributes", void 0);
    __decorate$f([
        Collection([], UmlClassMethod)
    ], UmlClass.prototype, "methods", void 0);
    __decorate$f([
        Complex({}, TextStyle)
    ], UmlClass.prototype, "style", void 0);
    return UmlClass;
}(ChildProperty));
/**
 * Defines the behavior of the uml interface shapes
 */
var UmlInterface = /** @class */ (function (_super) {
    __extends$p(UmlInterface, _super);
    function UmlInterface() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class UmlInterface
     *
     * @private
     */
    UmlInterface.prototype.getClassName = function () {
        return 'UmlInterface';
    };
    __decorate$f([
        Property(false)
    ], UmlInterface.prototype, "isSeparator", void 0);
    __decorate$f([
        Complex({ fill: '#F9F9F9', strokeColor: '#CCCCCC' }, ShapeStyle)
    ], UmlInterface.prototype, "separatorStyle", void 0);
    return UmlInterface;
}(UmlClass));
/**
 * Defines the behavior of the uml interface shapes
 */
var UmlEnumerationMember = /** @class */ (function (_super) {
    __extends$p(UmlEnumerationMember, _super);
    function UmlEnumerationMember() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class UmlEnumerationMember
     *
     * @private
     */
    UmlEnumerationMember.prototype.getClassName = function () {
        return 'UmlEnumerationMember';
    };
    __decorate$f([
        Property('')
    ], UmlEnumerationMember.prototype, "name", void 0);
    __decorate$f([
        Property('')
    ], UmlEnumerationMember.prototype, "value", void 0);
    __decorate$f([
        Property(false)
    ], UmlEnumerationMember.prototype, "isSeparator", void 0);
    __decorate$f([
        Complex({ fill: '#F9F9F9', strokeColor: '#CCCCCC' }, ShapeStyle)
    ], UmlEnumerationMember.prototype, "separatorStyle", void 0);
    __decorate$f([
        Complex({}, TextStyle)
    ], UmlEnumerationMember.prototype, "style", void 0);
    return UmlEnumerationMember;
}(ChildProperty));
/**
 * Defines the behavior of the uml interface shapes
 */
var UmlEnumeration = /** @class */ (function (_super) {
    __extends$p(UmlEnumeration, _super);
    function UmlEnumeration() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class UmlEnumeration
     *
     * @private
     */
    UmlEnumeration.prototype.getClassName = function () {
        return 'UmlEnumeration';
    };
    __decorate$f([
        Property('')
    ], UmlEnumeration.prototype, "name", void 0);
    __decorate$f([
        Collection([], UmlEnumerationMember)
    ], UmlEnumeration.prototype, "members", void 0);
    __decorate$f([
        Complex({}, TextStyle)
    ], UmlEnumeration.prototype, "style", void 0);
    return UmlEnumeration;
}(ChildProperty));
/**
 * Defines the behavior of the UMLActivity shape
 */
var UmlClassifierShape = /** @class */ (function (_super) {
    __extends$p(UmlClassifierShape, _super);
    function UmlClassifierShape() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class UmlClassifierShape
     *
     * @private
     */
    UmlClassifierShape.prototype.getClassName = function () {
        return 'UmlClassifierShape';
    };
    __decorate$f([
        Property('UmlClassifier')
    ], UmlClassifierShape.prototype, "type", void 0);
    __decorate$f([
        Complex({}, UmlClass)
    ], UmlClassifierShape.prototype, "classShape", void 0);
    __decorate$f([
        Complex({}, UmlInterface)
    ], UmlClassifierShape.prototype, "interfaceShape", void 0);
    __decorate$f([
        Complex({}, UmlEnumeration)
    ], UmlClassifierShape.prototype, "enumerationShape", void 0);
    __decorate$f([
        Property('Class')
    ], UmlClassifierShape.prototype, "classifier", void 0);
    return UmlClassifierShape;
}(Shape));
/* tslint:disable */
/**
 * Defines the behavior of the UMLActivity shape
 */
var DiagramShape = /** @class */ (function (_super) {
    __extends$p(DiagramShape, _super);
    function DiagramShape() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class UmlClassifierShape
     *
     * @private
     */
    DiagramShape.prototype.getClassName = function () {
        return 'DiagramShape';
    };
    __decorate$f([
        Property('Basic')
    ], DiagramShape.prototype, "type", void 0);
    __decorate$f([
        Property('Rectangle')
    ], DiagramShape.prototype, "basicShape", void 0);
    __decorate$f([
        Property('Terminator')
    ], DiagramShape.prototype, "flowShape", void 0);
    __decorate$f([
        Property('Event')
    ], DiagramShape.prototype, "bpmnShape", void 0);
    __decorate$f([
        Property('Action')
    ], DiagramShape.prototype, "umlActivityShape", void 0);
    __decorate$f([
        Property('')
    ], DiagramShape.prototype, "data", void 0);
    __decorate$f([
        Property('')
    ], DiagramShape.prototype, "content", void 0);
    __decorate$f([
        Property('')
    ], DiagramShape.prototype, "textContent", void 0);
    __decorate$f([
        Property('Stretch')
    ], DiagramShape.prototype, "scale", void 0);
    __decorate$f([
        Property('')
    ], DiagramShape.prototype, "source", void 0);
    __decorate$f([
        Property('None')
    ], DiagramShape.prototype, "align", void 0);
    __decorate$f([
        Complex({}, Margin)
    ], DiagramShape.prototype, "margin", void 0);
    __decorate$f([
        Property(0)
    ], DiagramShape.prototype, "cornerRadius", void 0);
    __decorate$f([
        Collection([], Point)
    ], DiagramShape.prototype, "points", void 0);
    __decorate$f([
        Complex({}, BpmnDataObject)
    ], DiagramShape.prototype, "dataObject", void 0);
    __decorate$f([
        Complex({}, BpmnEvent)
    ], DiagramShape.prototype, "event", void 0);
    __decorate$f([
        Complex({}, BpmnGateway)
    ], DiagramShape.prototype, "gateway", void 0);
    __decorate$f([
        Collection([], BpmnAnnotation)
    ], DiagramShape.prototype, "annotations", void 0);
    __decorate$f([
        Complex({}, BpmnActivity)
    ], DiagramShape.prototype, "activity", void 0);
    __decorate$f([
        Complex({}, BpmnAnnotation)
    ], DiagramShape.prototype, "annotation", void 0);
    __decorate$f([
        Complex({}, UmlEnumeration)
    ], DiagramShape.prototype, "enumerationShape", void 0);
    __decorate$f([
        Property('Class')
    ], DiagramShape.prototype, "classifier", void 0);
    __decorate$f([
        Complex({}, UmlClass)
    ], DiagramShape.prototype, "classShape", void 0);
    __decorate$f([
        Complex({}, UmlInterface)
    ], DiagramShape.prototype, "interfaceShape", void 0);
    return DiagramShape;
}(ChildProperty));
/* tslint:enable */
/**
 * Defines the behavior of nodes
 */
var Node = /** @class */ (function (_super) {
    __extends$p(Node, _super);
    function Node(parent, propName, defaultValue, isArray) {
        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
        /** @private */
        _this.isCanvasUpdate = false;
        /** @private */
        _this.status = 'None';
        /** @private */
        _this.parentId = '';
        /** @private */
        _this.processId = '';
        /** @private */
        _this.umlIndex = -1;
        /** @private */
        _this.outEdges = [];
        /** @private */
        _this.inEdges = [];
        /** @private */
        _this.isHeader = false;
        /** @private */
        _this.isLane = false;
        /** @private */
        _this.isPhase = false;
        /** @private */
        _this.laneGrids = [];
        var nodeDefault;
        if (_this.children && _this.children.length > 0) {
            nodeDefault = defaultValue;
            if (!nodeDefault.style || !nodeDefault.style.fill) {
                _this.style.fill = 'transparent';
            }
            if (!nodeDefault.style || !nodeDefault.style.strokeColor) {
                _this.style.strokeColor = 'transparent';
            }
        }
        if (_this.shape && _this.shape.type === 'UmlActivity') {
            setUMLActivityDefaults(defaultValue, _this);
        }
        if (_this.shape && _this.shape.type === 'SwimLane') {
            setSwimLaneDefaults(defaultValue, _this);
        }
        if (_this.ports && _this.ports.length) {
            setPortsEdges(_this);
        }
        return _this;
    }
    Object.defineProperty(Node.prototype, "actualSize", {
        /** @private */
        get: function () {
            if (this.wrapper !== null) {
                return this.wrapper.actualSize;
            }
            else {
                return new Size(this.width || 0, this.height || 0);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Allows to initialize the UI of a node
     */
    /** @private */
    /* tslint:disable */
    // tslint:disable-next-line:no-any
    Node.prototype.init = function (diagram) {
        var content;
        if (this.shape.type !== 'SwimLane') {
            content = new DiagramElement();
        }
        else {
            content = new GridPanel();
        }
        var textStyle;
        var changedProperties = 'changedProperties';
        var oldProperties = 'oldProperties';
        this.shape["" + changedProperties] = {};
        this.shape["" + oldProperties] = {};
        switch (this.shape.type) {
            case 'Path':
                if ((!isBlazor() && (this.type === 'Freehand'))) {
                    var path = new PathElement();
                    path.data = getFreeHandPath(this.shape.points);
                    content = path;
                }
                else {
                    var pathContent = new PathElement();
                    pathContent.data = this.shape.data;
                    content = pathContent;
                }
                break;
            case 'Image':
                var imageContent = new ImageElement();
                imageContent.source = this.shape.source;
                imageContent.imageAlign = this.shape.align;
                imageContent.imageScale = this.shape.scale;
                content = imageContent;
                break;
            case 'Text':
                var textContent = new TextElement();
                textContent.content = this.shape.content;
                content = textContent;
                textStyle = this.style;
                content.style = textStyle;
                break;
            case 'Basic':
                if ((!isBlazor() && this.shape.shape === 'Rectangle')) {
                    var basicshape = new DiagramElement();
                    content = basicshape;
                    content.cornerRadius = this.shape.cornerRadius;
                }
                else if ((!isBlazor() && this.shape.shape === 'Polygon')) {
                    var path = new PathElement();
                    path.data = getPolygonPath(this.shape.points);
                    content = path;
                }
                else {
                    var basicshape = new PathElement();
                    var basicshapedata = getBasicShape(this.shape.shape);
                    basicshape.data = basicshapedata;
                    content = basicshape;
                }
                break;
            case 'Flow':
                var flowshape = new PathElement();
                var flowshapedata = getFlowShape(this.shape.shape);
                flowshape.data = flowshapedata;
                content = flowshape;
                break;
            case 'UmlActivity':
                var umlactivityshape = new PathElement();
                content = getUMLActivityShapes(umlactivityshape, content, this);
                break;
            case 'Bpmn':
                if (diagram.bpmnModule) {
                    content = diagram.bpmnModule.initBPMNContent(content, this, diagram);
                    this.wrapper.elementActions = this.wrapper.elementActions | ElementAction.ElementIsGroup;
                    var subProcess = this.shape.activity.subProcess;
                    if (subProcess.processes && subProcess.processes.length) {
                        var children = this.shape.activity.subProcess.processes;
                        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                            var i = children_1[_i];
                            if (diagram.nameTable["" + i] && (!diagram.nameTable["" + i].processId || diagram.nameTable["" + i].processId === this.id)) {
                                diagram.nameTable["" + i].processId = this.id;
                                if (subProcess.collapsed) {
                                    diagram.updateElementVisibility(diagram.nameTable["" + i].wrapper, diagram.nameTable["" + i], !subProcess.collapsed);
                                }
                                content.children.push(diagram.nameTable["" + i].wrapper);
                            }
                        }
                    }
                }
                else {
                    console.warn('[WARNING] :: Module "BpmnDiagrams" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
                }
                break;
            case 'Native':
                var nativeContent = new DiagramNativeElement(this.id, diagram.element.id);
                nativeContent.content = this.shape.content;
                nativeContent.scale = this.shape.scale;
                content = nativeContent;
                break;
            case 'HTML':
                var htmlContent = new DiagramHtmlElement(this.id, diagram.element.id, undefined, diagram.nodeTemplate);
                if (this.shape.content && (typeof (this.shape.content) === 'string' || !diagram.isReact)) {
                    htmlContent.content = this.shape.content;
                }
                else if (diagram.nodeTemplate) {
                    htmlContent.isTemplate = true;
                    htmlContent.template = htmlContent.content = getContent(htmlContent, true, this);
                }
                //Task 834121: Content-Security-Policy support for diagram.
                if (this.shape.content && typeof (this.shape.content) === 'function' && diagram.isReact) {
                    htmlContent.isTemplate = true;
                    htmlContent.templateFn = compile(this.shape.content);
                    htmlContent.template = htmlContent.content = getContent(htmlContent, true, this);
                }
                content = htmlContent;
                break;
            case 'UmlClassifier':
                //   let umlClassifierShape: StackPanel = new StackPanel();
                content = getULMClassifierShapes(content, this, diagram);
                break;
            case 'SwimLane':
                this.annotations = [];
                this.ports = [];
                content.cellStyle.fill = 'none';
                content.cellStyle.strokeColor = 'none';
                this.container = { type: 'Grid', orientation: this.shape.orientation };
                content.id = this.id;
                this.container.orientation = this.shape.orientation;
                this.constraints |= NodeConstraints.HideThumbs;
                initSwimLane(content, diagram, this);
                break;
        }
        content.id = this.id + '_content';
        content.relativeMode = 'Object';
        // (EJ2-56444) - Added the below code to check whether node shape type is basic and shape is rectangle.
        // This code added due to while render radial gradient in canvas mode we want to check this type and pass args according to that
        if (this.shape.type === 'Basic' && this.shape.shape === 'Rectangle') {
            content.shapeType = 'Rectangle';
        }
        else {
            content.shapeType = 'Others';
        }
        if (this.width !== undefined) {
            content.width = this.width;
        }
        content.horizontalAlignment = 'Stretch';
        if (this.height !== undefined) {
            content.height = this.height;
        }
        if (this.minHeight !== undefined) {
            content.minHeight = this.minHeight;
        }
        if (this.maxHeight !== undefined) {
            content.maxHeight = this.maxHeight;
        }
        if (this.minWidth !== undefined) {
            content.minWidth = this.minWidth;
        }
        if (this.maxWidth !== undefined) {
            content.maxWidth = this.maxWidth;
        }
        if ((!isBlazor() && this.shape.shape === 'Rectangle' && !this.shape.cornerRadius)) {
            content.isRectElement = true;
        }
        content.verticalAlignment = 'Stretch';
        if ((this.shape instanceof Text)) {
            content.margin = this.shape.margin;
        }
        // 923325: Grey area visible while drawing "Freehand" connector with DragSegmentThumb enabled
        if (canShadow(this) && (this.type !== 'Freehand') && (this.shape.type !== 'Bpmn' || this.shape.shape === 'TextAnnotation')) {
            //941052: Issue with visible property doesn't hide shadows
            if ((this.constraints & NodeConstraints.Shadow) !== 0 && this.visible) {
                content.shadow = this.shadow;
            }
        }
        if ((this.shape.type !== 'Bpmn' || ((!isBlazor() && this.shape.shape === 'Message')) ||
            ((!isBlazor() && this.shape.shape === 'DataSource'))) && ((this.shape.type !== 'UmlActivity' || ((!isBlazor() && this.shape.shape !== 'FinalNode'))))) {
            if (this.shape.type !== 'Text') {
                content.style = this.style;
                this.oldGradientValue = (this.style.gradient) ? cloneObject(this.style.gradient) : null;
            }
        }
        if (!(this.wrapper.elementActions & ElementAction.ElementIsGroup) && this.flip === FlipDirection.Horizontal || this.flip === FlipDirection.Vertical) {
            content.flip = this.flip;
            content.flipMode = this.flipMode;
        }
        return content;
    };
    /* tslint:enable */
    /** @private */
    Node.prototype.initContainer = function () {
        if (!this.id) {
            this.id = randomId();
        }
        // Creates canvas element
        var canvas;
        if (!this.container || this.shape instanceof SwimLane) {
            canvas = this.children ? new Container() : new Canvas();
        }
        else {
            switch (this.container.type) {
                case 'Canvas':
                    canvas = new Canvas();
                    break;
                case 'Stack':
                    canvas = new StackPanel();
                    break;
                case 'Grid':
                    canvas = new GridPanel();
                    canvas.setDefinitions(this.rows, this.columns);
                    break;
            }
        }
        canvas.id = this.id;
        canvas.offsetX = this.offsetX;
        canvas.offsetY = this.offsetY;
        canvas.visible = this.visible;
        canvas.horizontalAlignment = this.horizontalAlignment;
        canvas.verticalAlignment = this.verticalAlignment;
        //903772 - Swimlane Save and Load Issue
        if (this.container && this.shape.type !== 'SwimLane') {
            canvas.width = this.width;
            canvas.height = this.height;
            if (this.container.type === 'Stack') {
                canvas.orientation = this.container.orientation;
            }
        }
        canvas.style.fill = this.backgroundColor;
        canvas.style.strokeColor = this.borderColor;
        canvas.style.strokeWidth = this.borderWidth;
        canvas.rotateAngle = this.rotateAngle;
        canvas.minHeight = this.minHeight;
        canvas.minWidth = this.minWidth;
        canvas.maxHeight = this.maxHeight;
        canvas.maxWidth = this.maxWidth;
        canvas.pivot = this.pivot;
        canvas.margin = this.margin;
        canvas.flip = this.flip;
        canvas.flipMode = this.flipMode;
        this.wrapper = canvas;
        return canvas;
    };
    /** @private */
    Node.prototype.initPorts = function (accessibilityContent, container) {
        for (var i = 0; this.ports !== undefined, i < this.ports.length; i++) {
            this.initPort(accessibilityContent, container, this.ports[parseInt(i.toString(), 10)]);
        }
    };
    /** @private */
    Node.prototype.initPort = function (accessibilityContent, container, port) {
        var canvas = this.wrapper;
        var portWrapper;
        // eslint-disable-next-line prefer-const
        portWrapper = this.initPortWrapper(port, this);
        // tslint:disable-next-line:no-any
        var wrapperContent;
        var contentAccessibility = getFunction(accessibilityContent);
        if (contentAccessibility) {
            wrapperContent = contentAccessibility(portWrapper, this);
        }
        portWrapper.description = wrapperContent ? wrapperContent : portWrapper.id;
        portWrapper.inversedAlignment = canvas.inversedAlignment;
        portWrapper.elementActions = portWrapper.elementActions | ElementAction.ElementIsPort;
        container.children.push(portWrapper);
    };
    Node.prototype.getIconOffet = function (layout, icon) {
        var x;
        var y;
        if (layout.orientation === 'BottomToTop') {
            x = icon.offset.x;
            y = 1 - icon.offset.y;
        }
        else if (layout.orientation === 'LeftToRight') {
            x = icon.offset.y;
            y = icon.offset.x;
        }
        else if (layout.orientation === 'RightToLeft') {
            x = 1 - icon.offset.y;
            y = icon.offset.x;
        }
        else {
            x = icon.offset.x;
            y = icon.offset.y;
        }
        return { x: x, y: y };
    };
    /** @private */
    Node.prototype.initIcons = function (accessibilityContent, layout, container, diagramId) {
        var canvas = this.wrapper;
        var offset;
        var icon = this.isExpanded ? this.expandIcon : this.collapseIcon;
        if (icon.shape !== 'None') {
            var iconContainer = new Canvas();
            iconContainer.float = true;
            var children = [];
            iconContainer.id = this.id + '_icon_content';
            iconContainer.children = children;
            iconContainer.height = icon.height;
            iconContainer.width = icon.width;
            iconContainer.style.strokeColor = 'transparent';
            iconContainer.margin = icon.margin;
            iconContainer.horizontalAlignment = 'Center';
            iconContainer.verticalAlignment = 'Center';
            iconContainer.visible = this.visible;
            iconContainer.cornerRadius = icon.cornerRadius;
            offset = this.getIconOffet(layout, icon);
            iconContainer.setOffsetWithRespectToBounds(offset.x, offset.y, 'Fraction');
            iconContainer.relativeMode = 'Point';
            this.initIconSymbol(icon, iconContainer, accessibilityContent, diagramId);
            // tslint:disable-next-line:no-any
            var wrapperContent = void 0;
            var contentAccessibility = getFunction(accessibilityContent);
            if (contentAccessibility) {
                wrapperContent = contentAccessibility(icon, this);
            }
            iconContainer.description = wrapperContent ? wrapperContent : iconContainer.id;
            iconContainer.inversedAlignment = canvas.inversedAlignment;
            container.children.push(iconContainer);
        }
    };
    // 882378 - Added below code to provide template support for fixedUserHandles in nodes
    /** @private */
    Node.prototype.initFixedUserHandles = function (fixedUserHandle, fixedUserHandleTemplate, diagramId) {
        var fixedUserHandleContainer;
        if (fixedUserHandle.pathData === '' && fixedUserHandleTemplate) {
            fixedUserHandleContainer = new DiagramHtmlElement(this.id, diagramId, undefined, fixedUserHandleTemplate);
            fixedUserHandleContainer.isTemplate = true;
            fixedUserHandleContainer.template = getContent(fixedUserHandleContainer, true, fixedUserHandle);
            fixedUserHandle.id = fixedUserHandle.id || randomId();
            fixedUserHandleContainer.id = this.id + '_' + fixedUserHandle.id;
        }
        else {
            var canvas = this.wrapper;
            fixedUserHandleContainer = new Canvas();
            var children = [];
            fixedUserHandleContainer.children = children;
            fixedUserHandle.id = fixedUserHandle.id || randomId();
            fixedUserHandleContainer.id = this.id + '_' + fixedUserHandle.id;
            var symbolIcon = initFixedUserHandlesSymbol(fixedUserHandle, fixedUserHandleContainer);
            fixedUserHandleContainer.children.push(symbolIcon);
            fixedUserHandleContainer.inversedAlignment = canvas.inversedAlignment;
        }
        fixedUserHandleContainer.float = true;
        fixedUserHandleContainer.height = fixedUserHandle.height;
        fixedUserHandleContainer.width = fixedUserHandle.width;
        fixedUserHandleContainer.style.strokeColor = fixedUserHandle.handleStrokeColor;
        fixedUserHandleContainer.style.fill = fixedUserHandle.fill;
        fixedUserHandleContainer.style.strokeWidth = fixedUserHandle.handleStrokeWidth;
        fixedUserHandleContainer.margin = fixedUserHandle.margin;
        fixedUserHandleContainer.visible = fixedUserHandle.visibility;
        fixedUserHandleContainer.cornerRadius = fixedUserHandle.cornerRadius;
        fixedUserHandleContainer.horizontalAlignment = 'Center';
        fixedUserHandleContainer.verticalAlignment = 'Center';
        var offset = this.getfixedUserHandleOffet(fixedUserHandle);
        fixedUserHandleContainer.setOffsetWithRespectToBounds(offset.x, offset.y, 'Fraction');
        fixedUserHandleContainer.relativeMode = 'Point';
        fixedUserHandleContainer.description = fixedUserHandleContainer.id;
        return fixedUserHandleContainer;
    };
    Node.prototype.getfixedUserHandleOffet = function (fixedUserHandle) {
        //let x: number;
        //let y: number;
        var x = fixedUserHandle.offset.x;
        var y = fixedUserHandle.offset.y;
        return { x: x, y: y };
    };
    /** @private */
    Node.prototype.initAnnotations = function (accessibilityContent, container, diagramId, virtualize, annotationTemplate) {
        var annotation;
        for (var i = 0; this.annotations !== undefined, i < this.annotations.length; i++) {
            annotation = this.initAnnotationWrapper(this.annotations[parseInt(i.toString(), 10)], diagramId, virtualize, i, annotationTemplate);
            // tslint:disable-next-line:no-any
            var wrapperContent = void 0;
            var contentAccessibility = getFunction(accessibilityContent);
            if (contentAccessibility) {
                wrapperContent = contentAccessibility(annotation, this);
            }
            annotation.description = wrapperContent ? wrapperContent : annotation.id;
            annotation.inversedAlignment = container.inversedAlignment;
            container.children.push(annotation);
        }
    };
    /** @private */
    Node.prototype.initPortWrapper = function (ports, Node) {
        ports.id = ports.id || randomId();
        // Creates port element
        var portContent = new PathElement();
        portContent.height = ports.height;
        portContent.width = ports.width;
        portContent.connectionDirection = ports.connectionDirection;
        ports.shape = ports.shape || 'Square';
        var pathdata = (ports.shape === 'Custom') ? ports.pathData : getPortShape(ports.shape);
        portContent.id = this.id + '_' + (ports.id);
        portContent.margin = ports.margin;
        portContent.data = pathdata;
        //EJ2-826617 - For BPMN node port flip is to be defined.
        //EJ2-830012 - Complex-hierarchical tree breaks due to Node undefined
        if (Node) {
            if (Node.shape.type === 'Bpmn') {
                portContent.flip = this.flip;
            }
        }
        var style = ports.style;
        portContent.style = {
            fill: style.fill, strokeColor: style.strokeColor, gradient: null,
            opacity: style.opacity, strokeDashArray: style.strokeDashArray, strokeWidth: style.strokeWidth
        };
        portContent.horizontalAlignment = ports.horizontalAlignment;
        portContent.verticalAlignment = ports.verticalAlignment;
        if (this.flipMode !== 'None' && this.flipMode !== 'Label' && this.flipMode !== 'LabelText' && this.flipMode !== 'LabelAndLabelText') {
            portContent = updatePortEdges(portContent, this.flip, ports);
        }
        else {
            portContent = updatePortEdges(portContent, FlipDirection.None, ports);
        }
        if (this.width !== undefined || this.height !== undefined) {
            portContent.float = true;
        }
        portContent.relativeMode = 'Point';
        portContent.visible = checkPortRestriction(ports, PortVisibility.Visible) &&
            !checkPortRestriction(ports, PortVisibility.Hover) && !checkPortRestriction(ports, PortVisibility.Connect) ? true : false;
        portContent.elementActions = portContent.elementActions | ElementAction.ElementIsPort;
        return portContent;
    };
    /** @private */
    Node.prototype.initAnnotationWrapper = function (annotation, diagramId, virtualize, value, annotationTemplate) {
        annotation.content = annotation.content || '';
        annotation.id = annotation.id || value + 'annotation' || randomId();
        var label = annotation;
        var annotationcontent;
        //Removed isBlazor code
        if (diagramId && (annotation.template || annotation.annotationType === 'Template'
            || (annotationTemplate && annotation.content === ''))) {
            annotationcontent = new DiagramHtmlElement(this.id, diagramId, annotation.id, annotationTemplate);
            // Task 834121: Content-Security-Policy support for diagram
            var diagramElement = document.getElementById(diagramId);
            var instance = 'ej2_instances';
            var diagram = diagramElement["" + instance][0];
            if (annotation.template && typeof annotation.template === 'function' && diagram.isReact) {
                annotationcontent.templateFn = compile(annotation.template);
                annotationcontent.isTemplate = true;
            }
            annotationcontent = getTemplateContent(annotationcontent, annotation, annotationTemplate, diagram);
        }
        else {
            annotationcontent = new TextElement();
            annotationcontent.canMeasure = !virtualize;
            var style = annotation.style;
            var link = annotation.hyperlink.link ? annotation.hyperlink : undefined;
            annotationcontent.style = {
                fill: style.fill, strokeColor: style.strokeColor, strokeWidth: style.strokeWidth,
                bold: style.bold, textWrapping: style.textWrapping,
                color: link ? link.color || annotationcontent.hyperlink.color : style.color, whiteSpace: style.whiteSpace,
                fontFamily: style.fontFamily, fontSize: style.fontSize, italic: style.italic, gradient: null, opacity: style.opacity,
                strokeDashArray: style.strokeDashArray, textAlign: style.textAlign, textOverflow: annotation.style.textOverflow,
                textDecoration: link ? link.textDecoration ||
                    annotationcontent.hyperlink.textDecoration : style.textDecoration
            };
            annotationcontent.hyperlink.link = annotation.hyperlink.link || undefined;
            annotationcontent.hyperlink.hyperlinkOpenState = annotation.hyperlink.hyperlinkOpenState || undefined;
            annotationcontent.hyperlink.content = annotation.hyperlink.content || undefined;
            annotationcontent.hyperlink.textDecoration = annotation.hyperlink.textDecoration || undefined;
            annotationcontent.content = link ? link.content ||
                annotationcontent.hyperlink.link : annotation.content;
        }
        annotationcontent.constraints = annotation.constraints;
        annotationcontent.height = annotation.height;
        annotationcontent.width = annotation.width;
        annotationcontent.visible = annotation.visibility;
        //Bug 855273: Annotation visible property is not working while changing node visibility at runtime
        annotationcontent.annotationVisibility = annotationcontent.visible ? 'Visible' : 'Collapsed';
        annotationcontent.rotateAngle = annotation.rotateAngle;
        annotationcontent.rotationReference = annotation.rotationReference;
        annotationcontent.id = this.id + '_' + annotation.id;
        if (this.width !== undefined && !annotation.template) {
            //910583: Annotation Wrapper updates wrongly after save and load.
            if (annotation.width === undefined) {
                if (annotation.style.textWrapping === 'Wrap' || annotation.style.textWrapping === 'WrapWithOverflow') {
                    annotationcontent.width = this.width;
                }
            }
        }
        annotationcontent.margin = annotation.margin;
        annotationcontent.horizontalAlignment = annotation.horizontalAlignment;
        annotationcontent.verticalAlignment = annotation.verticalAlignment;
        annotationcontent.setOffsetWithRespectToBounds(label.offset.x, label.offset.y, 'Fraction');
        if (this.width !== undefined || this.height !== undefined) {
            annotationcontent.float = true;
        }
        annotationcontent.relativeMode = 'Point';
        return annotationcontent;
    };
    Node.prototype.initIconContainer = function (options, iconContainer) {
        var rect = new DiagramElement();
        rect.id = iconContainer.id + '_rect';
        rect.height = options.height;
        rect.width = options.width;
        rect.visible = iconContainer.visible;
        rect.margin = options.margin;
        rect.cornerRadius = options.cornerRadius;
        rect.style = {
            fill: options.fill, strokeColor: options.borderColor,
            strokeWidth: options.borderWidth
        };
        rect.setOffsetWithRespectToBounds(0.5, 0.5, 'Fraction');
        rect.horizontalAlignment = 'Center';
        rect.verticalAlignment = 'Center';
        rect.relativeMode = 'Object';
        rect.description = rect.description || 'Click here to expand or collapse';
        return rect;
    };
    Node.prototype.initIconSymbol = function (options, iconContainer, accessibilityContent, diagramId) {
        var iconContent;
        iconContainer.children.push(this.initIconContainer(options, iconContainer));
        if (options.shape === 'Template') {
            iconContent = new DiagramNativeElement(this.id, diagramId);
            iconContent.content = options.content;
            iconContent.height = 10;
            iconContent.width = 10;
        }
        else {
            iconContent = new PathElement();
            iconContent.data = getIconShape(options);
            var iconContentBounds = measurePath(iconContent.data);
            iconContent.height =
                iconContentBounds.height < 10 ? iconContentBounds.height : 10 - (options.padding.bottom + options.padding.top);
            iconContent.width =
                iconContentBounds.width < 10 ? iconContentBounds.width : 10 - (options.padding.left + options.padding.right);
        }
        iconContent.id = iconContainer.id + '_shape';
        iconContent.horizontalAlignment = 'Center';
        iconContent.verticalAlignment = 'Center';
        iconContent.visible = iconContainer.visible;
        iconContent.visible = iconContainer.visible;
        iconContent.style = {
            fill: 'black',
            strokeColor: options.iconColor,
            strokeWidth: options.borderWidth
        };
        iconContent.setOffsetWithRespectToBounds(0.5, 0.5, 'Fraction');
        iconContent.relativeMode = 'Object';
        iconContent.description = iconContainer.description || 'Click here to expand or collapse';
        iconContainer.children.push(iconContent);
    };
    /**
     * @private
     *
     * Returns the name of class Node
     */
    Node.prototype.getClassName = function () {
        return 'Node';
    };
    __decorate$f([
        Collection([], ShapeAnnotation)
    ], Node.prototype, "annotations", void 0);
    __decorate$f([
        Property(0)
    ], Node.prototype, "offsetX", void 0);
    __decorate$f([
        Complex({}, LayoutInfo)
    ], Node.prototype, "layoutInfo", void 0);
    __decorate$f([
        Property(0)
    ], Node.prototype, "offsetY", void 0);
    __decorate$f([
        Collection([], PointPort)
    ], Node.prototype, "ports", void 0);
    __decorate$f([
        Property(true)
    ], Node.prototype, "isExpanded", void 0);
    __decorate$f([
        Collection([], NodeFixedUserHandle)
    ], Node.prototype, "fixedUserHandles", void 0);
    __decorate$f([
        Complex({}, IconShape)
    ], Node.prototype, "expandIcon", void 0);
    __decorate$f([
        Complex({}, IconShape)
    ], Node.prototype, "collapseIcon", void 0);
    __decorate$f([
        Complex({ x: 0.5, y: 0.5 }, Point)
    ], Node.prototype, "pivot", void 0);
    __decorate$f([
        Property()
    ], Node.prototype, "width", void 0);
    __decorate$f([
        Property()
    ], Node.prototype, "height", void 0);
    __decorate$f([
        Property()
    ], Node.prototype, "minWidth", void 0);
    __decorate$f([
        Property()
    ], Node.prototype, "minHeight", void 0);
    __decorate$f([
        Property()
    ], Node.prototype, "maxWidth", void 0);
    __decorate$f([
        Property()
    ], Node.prototype, "maxHeight", void 0);
    __decorate$f([
        Property(0)
    ], Node.prototype, "rotateAngle", void 0);
    __decorate$f([
        Complex({ fill: 'white' }, TextStyle)
    ], Node.prototype, "style", void 0);
    __decorate$f([
        Property('transparent')
    ], Node.prototype, "backgroundColor", void 0);
    __decorate$f([
        Property('none')
    ], Node.prototype, "borderColor", void 0);
    __decorate$f([
        Property(0)
    ], Node.prototype, "borderWidth", void 0);
    __decorate$f([
        Property()
    ], Node.prototype, "data", void 0);
    __decorate$f([
        ComplexFactory(getShapeType)
    ], Node.prototype, "shape", void 0);
    __decorate$f([
        Complex({}, SymbolSize)
    ], Node.prototype, "previewSize", void 0);
    __decorate$f([
        Complex({}, SymbolSize)
    ], Node.prototype, "dragSize", void 0);
    __decorate$f([
        Property(null)
    ], Node.prototype, "wrapper", void 0);
    __decorate$f([
        Property(NodeConstraints.Default)
    ], Node.prototype, "constraints", void 0);
    __decorate$f([
        Complex({}, Shadow)
    ], Node.prototype, "shadow", void 0);
    __decorate$f([
        Property()
    ], Node.prototype, "children", void 0);
    __decorate$f([
        Complex({ left: 0, right: 0, top: 0, bottom: 0 }, Margin)
    ], Node.prototype, "padding", void 0);
    __decorate$f([
        Property(null)
    ], Node.prototype, "container", void 0);
    __decorate$f([
        Property('Left')
    ], Node.prototype, "horizontalAlignment", void 0);
    __decorate$f([
        Property('Top')
    ], Node.prototype, "verticalAlignment", void 0);
    __decorate$f([
        Property()
    ], Node.prototype, "rows", void 0);
    __decorate$f([
        Property()
    ], Node.prototype, "columns", void 0);
    __decorate$f([
        Property()
    ], Node.prototype, "rowIndex", void 0);
    __decorate$f([
        Property()
    ], Node.prototype, "columnIndex", void 0);
    __decorate$f([
        Property()
    ], Node.prototype, "rowSpan", void 0);
    __decorate$f([
        Property()
    ], Node.prototype, "columnSpan", void 0);
    __decorate$f([
        Property('')
    ], Node.prototype, "branch", void 0);
    return Node;
}(NodeBase));
/**
 * Defines the behavior of header in swimLane
 */
var Header = /** @class */ (function (_super) {
    __extends$p(Header, _super);
    function Header() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$f([
        Property('')
    ], Header.prototype, "id", void 0);
    __decorate$f([
        Complex({}, Annotation)
    ], Header.prototype, "annotation", void 0);
    __decorate$f([
        Complex({ fill: '#FFFFFF', strokeColor: '#CCCCCC' }, ShapeStyle)
    ], Header.prototype, "style", void 0);
    __decorate$f([
        Property(50)
    ], Header.prototype, "height", void 0);
    __decorate$f([
        Property(50)
    ], Header.prototype, "width", void 0);
    return Header;
}(ChildProperty));
/**
 * Defines the behavior of lane in swimLane
 */
var Lane = /** @class */ (function (_super) {
    __extends$p(Lane, _super);
    function Lane() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class Lane
     *
     * @private
     */
    Lane.prototype.getClassName = function () {
        return 'Lane';
    };
    __decorate$f([
        Property('')
    ], Lane.prototype, "id", void 0);
    __decorate$f([
        Complex({ fill: '#F9F9F9', strokeColor: '#CCCCCC' }, ShapeStyle)
    ], Lane.prototype, "style", void 0);
    __decorate$f([
        Collection([], Node)
    ], Lane.prototype, "children", void 0);
    __decorate$f([
        Property(100)
    ], Lane.prototype, "height", void 0);
    __decorate$f([
        Property(100)
    ], Lane.prototype, "width", void 0);
    __decorate$f([
        Complex({ style: { fill: '#E7F4FF', strokeColor: '#CCCCCC' }, annotation: { content: 'Function' } }, Header)
    ], Lane.prototype, "header", void 0);
    __decorate$f([
        Property(true)
    ], Lane.prototype, "canMove", void 0);
    __decorate$f([
        Property()
    ], Lane.prototype, "addInfo", void 0);
    return Lane;
}(ChildProperty));
/**
 * Defines the behavior of phase in swimLane
 */
var Phase = /** @class */ (function (_super) {
    __extends$p(Phase, _super);
    function Phase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the name of class Phase
     *
     * @private
     */
    Phase.prototype.getClassName = function () {
        return 'Phase';
    };
    __decorate$f([
        Property('')
    ], Phase.prototype, "id", void 0);
    __decorate$f([
        Complex({ fill: '#FFFFFF', strokeColor: '#CCCCCC' }, ShapeStyle)
    ], Phase.prototype, "style", void 0);
    __decorate$f([
        Complex({ annotation: { content: 'Phase' } }, Header)
    ], Phase.prototype, "header", void 0);
    __decorate$f([
        Property(100)
    ], Phase.prototype, "offset", void 0);
    __decorate$f([
        Property()
    ], Phase.prototype, "addInfo", void 0);
    return Phase;
}(ChildProperty));
/**
 * Defines the behavior of swimLane shape
 */
var SwimLane = /** @class */ (function (_super) {
    __extends$p(SwimLane, _super);
    function SwimLane() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Defines space between children and lane
         *
         * @private
         *
         */
        _this.padding = 20;
        /**
         * Defines header by user or not
         *
         * @private
         *
         */
        _this.hasHeader = true;
        return _this;
    }
    /**
     * Returns the name of class Phase
     *
     * @private
     */
    SwimLane.prototype.getClassName = function () {
        return 'SwimLane';
    };
    __decorate$f([
        Property('SwimLane')
    ], SwimLane.prototype, "type", void 0);
    __decorate$f([
        Property(20)
    ], SwimLane.prototype, "phaseSize", void 0);
    __decorate$f([
        Collection([], Phase)
    ], SwimLane.prototype, "phases", void 0);
    __decorate$f([
        Property('Horizontal')
    ], SwimLane.prototype, "orientation", void 0);
    __decorate$f([
        Collection([], Lane)
    ], SwimLane.prototype, "lanes", void 0);
    __decorate$f([
        Complex({ style: { fill: '#E7F4FF', strokeColor: '#CCCCCC' }, annotation: { content: 'Function' } }, Header)
    ], SwimLane.prototype, "header", void 0);
    __decorate$f([
        Property(false)
    ], SwimLane.prototype, "isLane", void 0);
    __decorate$f([
        Property(false)
    ], SwimLane.prototype, "isPhase", void 0);
    return SwimLane;
}(Shape));
/**
 * Defines the behavior of container
 */
var ChildContainer = /** @class */ (function () {
    function ChildContainer() {
    }
    /**
     * Returns the name of class ChildContainer
     *
     * @private
     */
    ChildContainer.prototype.getClassName = function () {
        return 'ChildContainer';
    };
    __decorate$f([
        Property('Canvas')
    ], ChildContainer.prototype, "type", void 0);
    __decorate$f([
        Property('Vertical')
    ], ChildContainer.prototype, "orientation", void 0);
    return ChildContainer;
}());
/**
 * Defines the size and position of selected items and defines the appearance of selector
 */
var Selector = /** @class */ (function (_super) {
    __extends$p(Selector, _super);
    function Selector() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Initializes the UI of the container
     */
    Selector.prototype.init = function (diagram) {
        var container = new Container();
        container.measureChildren = false;
        //const consize: Size = new Size();
        container.children = [];
        if (this.annotation) {
            var object = (this.nodes.length > 0) ? diagram.nameTable[this.nodes[0].id].wrapper :
                diagram.nameTable[this.connectors[0].id].wrapper;
            var wrapper = diagram.getWrapper(object, this.annotation.id);
            container.children.push(wrapper);
        }
        else {
            if (this.nodes || this.connectors) {
                for (var i = 0; i < this.nodes.length; i++) {
                    var node = diagram.nameTable[this.nodes[parseInt(i.toString(), 10)].id];
                    var wrapper = node.wrapper;
                    // this.width = wrapper.actualSize.width;
                    // this.height = wrapper.actualSize.height;
                    // this.rotateAngle = wrapper.rotateAngle;
                    // this.offsetX = wrapper.offsetX;
                    // this.offsetY = wrapper.offsetY;
                    container.children.push(wrapper);
                }
                for (var j = 0; j < this.connectors.length; j++) {
                    var connector = diagram.nameTable[this.connectors[parseInt(j.toString(), 10)].id];
                    var wrapper = connector.wrapper;
                    // this.width = wrapper.actualSize.width; this.height = wrapper.actualSize.height;
                    // this.rotateAngle = wrapper.rotateAngle; this.offsetX = wrapper.offsetX;
                    // this.offsetY = wrapper.offsetY;
                    container.children.push(wrapper);
                }
            }
        }
        var isProtectedOnChange = 'isProtectedOnChange';
        var diagramProtectPropertyChange = diagram["" + isProtectedOnChange];
        diagram.protectPropertyChange(false);
        this.wrapper = container;
        diagram.protectPropertyChange(diagramProtectPropertyChange);
        return container;
    };
    __decorate$f([
        Property(null)
    ], Selector.prototype, "wrapper", void 0);
    __decorate$f([
        Property(14)
    ], Selector.prototype, "handleSize", void 0);
    __decorate$f([
        Collection([], Node)
    ], Selector.prototype, "nodes", void 0);
    __decorate$f([
        Collection([], Connector)
    ], Selector.prototype, "connectors", void 0);
    __decorate$f([
        Property()
    ], Selector.prototype, "width", void 0);
    __decorate$f([
        Property()
    ], Selector.prototype, "height", void 0);
    __decorate$f([
        Property(0)
    ], Selector.prototype, "rotateAngle", void 0);
    __decorate$f([
        Property(0)
    ], Selector.prototype, "offsetX", void 0);
    __decorate$f([
        Property(0)
    ], Selector.prototype, "offsetY", void 0);
    __decorate$f([
        Complex({ x: 0.5, y: 0.5 }, Point)
    ], Selector.prototype, "pivot", void 0);
    __decorate$f([
        Property('CompleteIntersect')
    ], Selector.prototype, "rubberBandSelectionMode", void 0);
    __decorate$f([
        Collection([], UserHandle)
    ], Selector.prototype, "userHandles", void 0);
    __decorate$f([
        Property(SelectorConstraints.All)
    ], Selector.prototype, "constraints", void 0);
    __decorate$f([
        Property()
    ], Selector.prototype, "setTooltipTemplate", void 0);
    __decorate$f([
        Collection([], Node)
    ], Selector.prototype, "selectedObjects", void 0);
    __decorate$f([
        Property(false)
    ], Selector.prototype, "canToggleSelection", void 0);
    return Selector;
}(ChildProperty));

/**
 * Defines the functionalities that need to access DOM
 */
/**
 * removeElementsByClass method \
 *
 * @returns {void} removeElementsByClass method .\
 * @param { string } className - provide the element  value.
 * @param {string} id - provide the string  value.
 * @private
 */
function removeElementsByClass(className, id) {
    var elements;
    if (id && document.getElementById(id).classList.contains(className)) {
        elements = document.getElementById(id).getElementsByClassName(className);
    }
    else {
        elements = document.getElementsByClassName(className);
    }
    while (elements.length > 0) {
        elements[0].parentNode.removeChild(elements[0]);
    }
}
/**
 * findSegmentPoints method \
 *
 * @returns {PointModel[]} findSegmentPoints method .\
 * @param { PathElement } element - provide the element  value.
 * @private
 */
function findSegmentPoints(element) {
    var pts = [];
    var sample;
    var sampleLength;
    var measureWindowElement = 'measureElement';
    window["" + measureWindowElement].style.visibility = 'visible';
    var svg = window["" + measureWindowElement].children[2];
    var pathNode = getChildNode(svg)[0];
    pathNode.setAttributeNS(null, 'd', element.data);
    var pathBounds = element.absoluteBounds; // || pathNode.getBBox();
    var pathData = updatePath(element, pathBounds);
    pathNode.setAttributeNS(null, 'd', pathData);
    var pathLength = pathNode.getTotalLength();
    // 930450: Diagram Taking Too Long to Load Due to Complex Hierarchical Tree Layout with Path Nodes
    var storedPoints = Diagram.prototype.getPathData(pathData);
    if (storedPoints.length === 0) {
        for (sampleLength = 0; sampleLength <= pathLength; sampleLength += 10) {
            sample = pathNode.getPointAtLength(sampleLength);
            pts.push({ x: sample.x, y: sample.y });
        }
        // Push the calculated points into the shared storage
        Diagram.prototype.setPathData(pathData, pts);
    }
    else {
        pts = storedPoints;
    }
    window["" + measureWindowElement].style.visibility = 'hidden';
    return pts;
}
/**
 * getChildNode method \
 *
 * @returns {SVGElement[] | HTMLCollection} findSegmentPoints method .\
 * @param { SVGElement } node - provide the element  value.
 * @private
 */
function getChildNode(node) {
    var child;
    var collection = [];
    if (Browser.info.name === 'msie' || Browser.info.name === 'edge') {
        for (var i = 0; i < node.childNodes.length; i++) {
            child = node.childNodes[parseInt(i.toString(), 10)];
            if (child.nodeType === 1) {
                collection.push(child);
            }
        }
    }
    else {
        collection = node.children;
    }
    return collection;
}
/**
 * translatePoints method \
 *
 * @returns {PointModel[]} translatePoints method .\
 * @param { SVGElement } element - provide the element  value.
 * @param { PointModel[] } points - provide the element  value.
 * @private
 */
function translatePoints(element, points) {
    var translatedPts = [];
    //895069: Update Connector docking position in node after flipping the node
    var left = element.offsetX - element.actualSize.width * element.pivot.x;
    var top = element.offsetY - element.actualSize.height * element.pivot.y;
    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
        var point = points_1[_i];
        var pt1 = void 0;
        var baseX = left + point.x;
        var baseY = top + point.y;
        var flipX = left + element.actualSize.width - point.x;
        var flipY = top + element.actualSize.height - point.y;
        // 895069: Updating the node and connector's docking point for node's fliped position
        switch (element.flip) {
            case FlipDirection.Both:
                pt1 = { x: flipX, y: flipY };
                break;
            case FlipDirection.Horizontal:
                pt1 = { x: flipX, y: baseY };
                break;
            case FlipDirection.Vertical:
                pt1 = { x: baseX, y: flipY };
                break;
            default:
                pt1 = { x: baseX, y: baseY };
                break;
        }
        var matrix = void 0;
        var angle = element.rotateAngle + element.parentTransform;
        if (angle) {
            matrix = identityMatrix();
            rotateMatrix(matrix, angle, element.offsetX, element.offsetY);
        }
        if (matrix) {
            pt1 = transformPointByMatrix(matrix, pt1);
        }
        translatedPts.push(pt1);
    }
    return translatedPts;
}
/**
 * measurePath method \
 *
 * @returns {Rect} measurePath method .\
 * @param { string } data - provide the element  value.
 * @private
 */
function measurePath(data) {
    if (data) {
        var measureWindowElement = 'measureElement';
        window["" + measureWindowElement].style.visibility = 'visible';
        var svg = window["" + measureWindowElement].children[2];
        var element = getChildNode(svg)[0];
        element.setAttribute('d', data);
        var bounds = element.getBBox();
        var svgBounds = new Rect(bounds.x, bounds.y, bounds.width, bounds.height);
        window["" + measureWindowElement].style.visibility = 'hidden';
        return svgBounds;
    }
    return new Rect(0, 0, 0, 0);
}
/**
 * getTextOptions method \
 *
 * @returns {BaseAttributes} getTextOptions method .\
 * @param { TextElement } element - provide the element  value.
 * @param { number } maxWidth - provide the maxWidth  value.
 * @private
 */
function getTextOptions(element, maxWidth) {
    var options = {
        fill: element.style.fill, stroke: element.style.strokeColor, angle: element.rotateAngle + element.parentTransform,
        pivotX: element.pivot.x, pivotY: element.pivot.y, strokeWidth: element.style.strokeWidth,
        dashArray: element.style.strokeDashArray, opacity: element.style.opacity, shadow: element.shadow,
        gradient: element.style.gradient, visible: element.visible, id: element.id, description: element.description,
        width: maxWidth || element.actualSize.width, height: element.actualSize.height,
        x: element.offsetX - element.actualSize.width * element.pivot.x + 0.5,
        y: element.offsetY - element.actualSize.height * element.pivot.y + 0.5
    };
    options.fontSize = element.style.fontSize;
    options.fontFamily = element.style.fontFamily;
    options.textOverflow = element.style.textOverflow;
    options.textDecoration = element.style.textDecoration;
    options.doWrap = element.doWrap;
    options.whiteSpace = whiteSpaceToString(element.style.whiteSpace, element.style.textWrapping);
    options.content = element.content;
    options.textWrapping = element.style.textWrapping;
    options.breakWord = wordBreakToString(element.style.textWrapping);
    options.textAlign = textAlignToString(element.style.textAlign);
    options.color = element.style.color;
    options.italic = element.style.italic;
    options.bold = element.style.bold;
    options.dashArray = '';
    options.strokeWidth = 0;
    options.fill = '';
    return options;
}
/**
 * wrapSvgText method \
 *
 * @returns {SubTextElement[]} wrapSvgText method .\
 * @param { TextAttributes } text - provide the element  value.
 * @param { string } textValue - provide the maxWidth  value.
 * @param { number } laneWidth - provide the maxWidth  value.
 * @private
 */
function wrapSvgText(text, textValue, laneWidth) {
    var childNodes = [];
    var k = 0;
    var txtValue;
    var bounds1;
    var content = textValue || text.content;
    if (text.whiteSpace !== 'nowrap' && text.whiteSpace !== 'pre') {
        if (text.breakWord === 'breakall') {
            txtValue = '';
            txtValue += content[0];
            for (k = 0; k < content.length; k++) {
                bounds1 = bBoxText(txtValue, text);
                if (bounds1 >= text.width && txtValue.length > 0) {
                    childNodes[childNodes.length] = { text: txtValue, x: 0, dy: 0, width: bounds1 };
                    txtValue = '';
                }
                else {
                    txtValue = txtValue + (content[k + 1] || '');
                    if (txtValue.indexOf('\n') > -1) {
                        childNodes[childNodes.length] = { text: txtValue, x: 0, dy: 0, width: bBoxText(txtValue, text) };
                        txtValue = '';
                    }
                    var width = bBoxText(txtValue, text);
                    if (Math.ceil(width) + 2 >= text.width && txtValue.length > 0) {
                        childNodes[childNodes.length] = { text: txtValue, x: 0, dy: 0, width: width };
                        txtValue = '';
                    }
                    if (k === content.length - 1 && txtValue.length > 0) {
                        childNodes[childNodes.length] = { text: txtValue, x: 0, dy: 0, width: width };
                        txtValue = '';
                    }
                }
            }
        }
        else {
            childNodes = wordWrapping(text, textValue, laneWidth);
        }
    }
    else {
        childNodes[childNodes.length] = { text: content, x: 0, dy: 0, width: bBoxText(content, text) };
    }
    return childNodes;
}
/**
 * wordWrapping method \
 *
 * @returns {SubTextElement[]} wordWrapping method .\
 * @param { TextAttributes } text - provide the element  value.
 * @param { string } textValue - provide the maxWidth  value.
 * @param { number } laneWidth - provide the maxWidth  value.
 * @private
 */
function wordWrapping(text, textValue, laneWidth) {
    var childNodes = [];
    var txtValue = '';
    var j = 0;
    var i = 0;
    var wrap = text.whiteSpace !== 'nowrap' ? true : false;
    var content = textValue || text.content;
    var eachLine = content.split('\n');
    var words;
    var newText;
    var existingWidth;
    var existingText;
    for (j = 0; j < eachLine.length; j++) {
        words = text.textWrapping !== 'NoWrap' ? eachLine[parseInt(j.toString(), 10)].split(' ') : (text.textWrapping === 'NoWrap') ? [eachLine[parseInt(j.toString(), 10)]] : eachLine;
        for (i = 0; i < words.length; i++) {
            txtValue += (((i !== 0 || words.length === 1) && wrap && txtValue.length > 0) ? ' ' : '') + words[parseInt(i.toString(), 10)];
            //Bug 885842: Position of annotation inside the node is not aligned center.
            //Extra space is added when we have single word as annotation text and due to this the width of the text is increased.
            if (words[i + 1]) {
                newText = txtValue + ' ' + (words[i + 1]);
            }
            else {
                newText = txtValue;
            }
            var width = bBoxText(newText, text);
            if (Math.floor(width) > (laneWidth || text.width) - 2 && txtValue.length > 0) {
                childNodes[childNodes.length] = {
                    text: txtValue, x: 0, dy: 0,
                    width: newText === txtValue ? width : (txtValue === existingText) ? existingWidth : bBoxText(txtValue, text)
                };
                txtValue = '';
            }
            else {
                if (i === words.length - 1) {
                    childNodes[childNodes.length] = { text: txtValue, x: 0, dy: 0, width: width };
                    txtValue = '';
                }
            }
            existingText = newText;
            existingWidth = width;
        }
    }
    return childNodes;
}
/**
 * wrapSvgTextAlign method \
 *
 * @returns {TextBounds} wrapSvgTextAlign method .\
 * @param { TextAttributes } text - provide the element  value.
 * @param { string } childNodes - provide the maxWidth  value.
 * @private
 */
function wrapSvgTextAlign(text, childNodes) {
    var wrapBounds = { x: 0, width: 0 };
    var k = 0;
    var txtWidth;
    var width;
    for (k = 0; k < childNodes.length; k++) {
        txtWidth = childNodes[parseInt(k.toString(), 10)].width;
        width = txtWidth;
        //EJ2-863489 - Node annotation textAlign "Justify" option is not working correctly
        if (text.textAlign === 'left' || text.textAlign === 'justify') {
            txtWidth = 0;
        }
        else if (text.textAlign === 'center') {
            if (txtWidth > text.width && (text.textOverflow === 'Ellipsis' || text.textOverflow === 'Clip')) {
                txtWidth = 0;
            }
            else {
                txtWidth = -txtWidth / 2;
            }
        }
        else if (text.textAlign === 'right') {
            txtWidth = -txtWidth;
        }
        else {
            txtWidth = childNodes.length > 1 ? 0 : -txtWidth / 2;
        }
        childNodes[parseInt(k.toString(), 10)].dy = text.fontSize * 1.2;
        childNodes[parseInt(k.toString(), 10)].x = txtWidth;
        wrapBounds.x = Math.min(wrapBounds.x, txtWidth);
        wrapBounds.width = Math.max(wrapBounds.width, width);
    }
    return wrapBounds;
}
/**
 * measureHtmlText method \
 *
 * @returns {TextBounds} measureHtmlText method .\
 * @param { TextStyleModel } style - provide the style  value.
 * @param { string } content - provide the content  value.
 * @param { string } width - provide the width  value.
 * @param { string } height - provide the height  value.
 * @param { string } maxWidth - provide the maxWidth  value.
 * @private
 */
function measureHtmlText(style, content, width, height, maxWidth) {
    var bounds = new Size();
    var text = createHtmlElement('span', { 'style': 'display:inline-block; line-height: normal' });
    if (style.bold) {
        text.style.fontWeight = 'bold';
    }
    if (style.italic) {
        text.style.fontStyle = 'italic';
    }
    if (width !== undefined) {
        text.style.width = width.toString() + 'px';
    }
    if (height !== undefined) {
        text.style.height = height.toString() + 'px';
    }
    if (maxWidth !== undefined) {
        text.style.maxWidth = maxWidth.toString() + 'px';
    }
    text.style.fontFamily = style.fontFamily;
    text.style.fontSize = style.fontSize + 'px';
    text.style.color = style.color;
    text.textContent = content;
    text.style.whiteSpace = whiteSpaceToString(style.whiteSpace, style.textWrapping);
    if (maxWidth !== undefined) {
        text.style.wordBreak = 'break-word';
    }
    else {
        text.style.wordBreak = wordBreakToString(style.textWrapping);
    }
    document.body.appendChild(text);
    bounds.width = text.offsetWidth;
    bounds.height = text.offsetHeight;
    document.body.removeChild(text);
    return bounds;
}
/**
 * measureText method \
 *
 * @returns {Size} measureText method .\
 * @param { TextStyleModel } text - provide the text  value.
 * @param { string } style - provide the style  value.
 * @param { string } content - provide the content  value.
 * @param { number } maxWidth - provide the maxWidth  value.
 * @param { string } textValue - provide the textValue  value.
 * @private
 */
function measureText(text, style, content, maxWidth, textValue) {
    var bounds = new Size(0, 0);
    var childNodes;
    var wrapBounds;
    var options = getTextOptions(text, maxWidth);
    text.childNodes = childNodes = wrapSvgText(options, textValue, text.isLaneOrientation ? maxWidth : undefined);
    text.wrapBounds = wrapBounds = wrapSvgTextAlign(options, childNodes);
    bounds.width = wrapBounds.width;
    if (text.wrapBounds.width >= maxWidth && options.textOverflow !== 'Wrap') {
        bounds.width = maxWidth;
    }
    bounds.height = childNodes.length * text.style.fontSize * 1.2;
    return bounds;
}
/**
 * measureImage method \
 *
 * @returns {Size} measureImage method .\
 * @param { string } source - provide the text  value.
 * @param { Size } contentSize - provide the style  value.
 * @param { string } id - provide the content  value.
 * @param { Function } callback - provide the maxWidth  value.
 * @private
 */
// eslint-disable-next-line
function measureImage(source, contentSize, id, callback) {
    var measureWindowElement = 'measureElement';
    window["" + measureWindowElement].style.visibility = 'visible';
    var imageElement = window["" + measureWindowElement].children[1];
    imageElement.setAttribute('src', source);
    var bounds = imageElement.getBoundingClientRect();
    var width = bounds.width;
    var height = bounds.height;
    contentSize = new Size(width, height);
    window["" + measureWindowElement].style.visibility = 'hidden';
    var element = document.createElement('img');
    element.setAttribute('src', source);
    setAttributeHtml(element, { id: id + 'sf-imageNode' });
    element.style.display = 'none';
    document.body.appendChild(element);
    // eslint-disable-next-line
    element.onload = function (event) {
        var loadedImage = event.currentTarget;
        if (callback) {
            callback(id, { width: loadedImage.width, height: loadedImage.height });
        }
    };
    return contentSize;
}
/* eslint-disable */
/**
 * measureNativeContent method \
 *
 * @returns {Rect} measureNativeContent method .\
 * @param { SVGElement } nativeContent - provide the text  value.
 * @private
 */
function measureNativeContent(nativeContent) {
    var measureWindowElement = 'measureElement';
    window[measureWindowElement].style.visibility = 'visible';
    var nativeSVG = window[measureWindowElement].children[2];
    nativeSVG.appendChild(nativeContent);
    var bounds = nativeContent.getBoundingClientRect();
    var svgBounds = nativeSVG.getBoundingClientRect();
    var rect = bounds;
    rect.x = bounds.left - svgBounds.left;
    rect.y = bounds.top - svgBounds.top;
    nativeSVG.removeChild(nativeContent);
    window[measureWindowElement].style.visibility = 'hidden';
    return rect;
}
/**
 * measureNativeSvg method \
 *
 * @returns {Rect} measureNativeSvg method .\
 * @param { SVGElement } nativeContent - provide the text  value.
 * @private
 */
function measureNativeSvg(nativeContent) {
    var measureWindowElement = 'measureElement';
    window[measureWindowElement].style.visibility = 'visible';
    var nativeSVG = window[measureWindowElement].children[2];
    nativeSVG.appendChild(nativeContent);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var svgBounds = nativeSVG.getBoundingClientRect();
    nativeSVG.removeChild(nativeContent);
    window[measureWindowElement].style.visibility = 'hidden';
    return svgBounds;
}
/**
 * updatePath method \
 *
 * @returns {string} updatePath method .\
 * @param { SVGElement } element - provide the element  value.
 * @param { Rect } bounds - provide the bounds  value.
 * @param { PathElement } child - provide the child  value.
 * @param { BaseAttributes } options - provide the options  value.
 * @private
 */
function updatePath(element, bounds, child, options) {
    var initX = 0;
    var initY = 0;
    var scaleX = 0;
    var scaleY = 0;
    var isScale = false;
    var newPathString = '';
    var arrayCollection = [];
    var bBox = bounds;
    if (initX !== bBox.x || initY !== bBox.y) {
        scaleX = initX - Number(bBox.x);
        scaleY = initY - Number(bBox.y);
    }
    if (element.actualSize.width !== bBox.width || element.actualSize.height !== bBox.height || options) {
        scaleX = (options && options.width || element.actualSize.width) / Number(bBox.width ? bBox.width : 1);
        scaleY = (options && options.height || element.actualSize.height) / Number(bBox.height ? bBox.height : 1);
        isScale = true;
    }
    arrayCollection = processPathData(element.data);
    arrayCollection = splitArrayCollection(arrayCollection);
    newPathString = transformPath(arrayCollection, scaleX, scaleY, isScale, bBox.x, bBox.y, initX, initY);
    isScale = false;
    return newPathString;
}
/**
 * getDiagramLayerSvg method \
 *
 * @returns {string} getDiagramLayerSvg method .\
 * @param { string } diagramId - provide the element  value.
 * @private
 */
function getDiagramLayerSvg(diagramId) {
    //let diagramLayerSvg: SVGSVGElement;
    var diagramElement = getDiagramElement(diagramId);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var elementcoll = diagramElement.getElementsByClassName('e-diagram-layer');
    var diagramLayerSvg = elementcoll[0];
    return diagramLayerSvg;
}
/**
 * getDiagramElement method \
 *
 * @returns {HTMLElement} getDiagramElement method .\
 * @param { string } elementId - provide the elementId  value.
 * @param { string } contentId - provide the elementId  value.
 * @private
 */
function getDiagramElement(elementId, contentId) {
    var diagramElement;
    var element;
    if (contentId) {
        element = document.getElementById(contentId);
    }
    if (Browser.info.name === 'msie' || Browser.info.name === 'edge') {
        diagramElement = (element) ? element.querySelector('#' + elementId) : document.getElementById(elementId);
    }
    else {
        diagramElement = (element) ? element.querySelector('#' + CSS.escape(elementId)) : document.getElementById(elementId);
    }
    return diagramElement;
}
/**
 * getDomIndex method \
 *
 * @returns {HTMLElement} getDomIndex method .\
 * @param { string } viewId - provide the elementId  value.
 * @param { string } elementId - provide the elementId  value.
 * @param { string } layer - provide the elementId  value.
 * @private
 */
function getDomIndex(viewId, elementId, layer) {
    var index = undefined;
    var parentElement;
    var postId = '';
    if (layer === 'native') {
        parentElement = getNativeLayer(viewId);
        postId = '_content_groupElement';
    }
    else if (layer === 'html') {
        parentElement = getHTMLLayer(viewId).childNodes[0];
        postId = '_html_element';
    }
    else {
        parentElement = getDiagramLayer(viewId);
        postId = '_groupElement';
    }
    var childElement;
    for (var i = 0; parentElement.childNodes && i < parentElement.childNodes.length; i++) {
        childElement = parentElement.childNodes[i];
        if (childElement && childElement.id === elementId + postId) {
            index = i;
            break;
        }
    }
    return index;
}
/**
 * getAdornerLayerSvg method \
 *
 * @returns {SVGSVGElement} getAdornerLayerSvg method .\
 * @param { string } diagramId - provide the diagramId  value.
 * @private
 */
function getAdornerLayerSvg(diagramId) {
    var adornerLayerSvg = null;
    var diagramElement = getDiagramElement(diagramId);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var elementcoll = diagramElement.getElementsByClassName('e-adorner-layer');
    adornerLayerSvg = elementcoll[0];
    return adornerLayerSvg;
}
/**
 * getSelectorElement method \
 *
 * @returns {SVGSVGElement} getSelectorElement method .\
 * @param { string } diagramId - provide the diagramId  value.
 * @private
 */
function getSelectorElement(diagramId) {
    var adornerLayer = null;
    var adornerSvg = getAdornerLayerSvg(diagramId);
    adornerLayer = adornerSvg.getElementById(diagramId + '_SelectorElement');
    return adornerLayer;
}
/**
 * getAdornerLayer method \
 *
 * @returns {SVGSVGElement} getAdornerLayer method .\
 * @param { string } diagramId - provide the diagramId  value.
 * @private
 */
function getAdornerLayer(diagramId) {
    var adornerLayer = null;
    var diagramAdornerSvg = getAdornerLayerSvg(diagramId);
    adornerLayer = diagramAdornerSvg.getElementById(diagramId + '_diagramAdorner');
    return adornerLayer;
}
/**
 * getUserHandleLayer method \
 *
 * @returns {HTMLElement} getUserHandleLayer method .\
 * @param { string } diagramId - provide the diagramId  value.
 * @private
 */
function getUserHandleLayer(diagramId) {
    var adornerLayer = null;
    var diagramUserHandleLayer = getDiagramElement(diagramId);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var elementcoll = diagramUserHandleLayer.getElementsByClassName('e-userHandle-layer');
    adornerLayer = elementcoll[0];
    return adornerLayer;
}
/**
 * getDiagramLayer method \
 *
 * @returns {HTMLElement} getDiagramLayer method .\
 * @param { string } diagramId - provide the diagramId  value.
 * @private
 */
function getDiagramLayer(diagramId) {
    //let diagramLayer: SVGElement;
    var diagramLayerSvg = getDiagramLayerSvg(diagramId);
    var diagramLayer = diagramLayerSvg.getElementById(diagramId + '_diagramLayer');
    return diagramLayer;
}
/**
 * getPortLayerSvg method \
 *
 * @returns {SVGSVGElement} getPortLayerSvg method .\
 * @param { string } diagramId - provide the diagramId  value.
 * @private
 */
function getPortLayerSvg(diagramId) {
    var adornerLayerSvg = null;
    var diagramElement = getDiagramElement(diagramId);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var elementcoll = diagramElement.getElementsByClassName('e-ports-expand-layer');
    adornerLayerSvg = elementcoll[0];
    return adornerLayerSvg;
}
/**
 * getNativeLayerSvg method \
 *
 * @returns {SVGSVGElement} getNativeLayerSvg method .\
 * @param { string } diagramId - provide the diagramId  value.
 * @private
 */
function getNativeLayerSvg(diagramId) {
    var nativeLayerSvg;
    var diagramElement = getDiagramElement(diagramId);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var elementcoll = diagramElement.getElementsByClassName('e-native-layer');
    nativeLayerSvg = elementcoll[0];
    return nativeLayerSvg;
}
/**
 * getGridLayerSvg method \
 *
 * @returns {SVGSVGElement} getNativeLayerSvg method .\
 * @param { string } diagramId - provide the diagramId  value.
 * @private
 */
function getGridLayerSvg(diagramId) {
    var gridLayerSvg = null;
    var diagramElement = getDiagramElement(diagramId);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var elementcoll = diagramElement.getElementsByClassName('e-grid-layer');
    gridLayerSvg = elementcoll[0];
    return gridLayerSvg;
}
/**
 * getBackgroundLayerSvg method \
 *
 * @returns {SVGSVGElement} getBackgroundLayerSvg method .\
 * @param { string } diagramId - provide the diagramId  value.
 * @private
 */
function getBackgroundLayerSvg(diagramId) {
    var diagramElement = getDiagramElement(diagramId);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var elementcoll = diagramElement.getElementsByClassName('e-background-layer');
    return elementcoll[0].parentNode;
}
/**
 * getBackgroundImageLayer method \
 *
 * @returns {SVGSVGElement} getBackgroundImageLayer method .\
 * @param { string } diagramId - provide the diagramId  value.
 * @private
 */
function getBackgroundImageLayer(diagramId) {
    var imageLayer = null;
    var diagramElement = getDiagramElement(diagramId);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var elementcoll = diagramElement.getElementsByClassName('e-background-image-layer');
    imageLayer = elementcoll[0];
    return imageLayer;
}
/**
 * getBackgroundLayer method \
 *
 * @returns {SVGSVGElement} getBackgroundLayer method .\
 * @param { string } diagramId - provide the diagramId  value.
 * @private
 */
function getBackgroundLayer(diagramId) {
    var imageLayer = null;
    var diagramElement = getDiagramElement(diagramId);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var elementcoll = diagramElement.getElementsByClassName('e-background-layer');
    imageLayer = elementcoll[0];
    return imageLayer;
}
/**
 * getGridLayer method \
 *
 * @returns {SVGSVGElement} getGridLayer method .\
 * @param { string } diagramId - provide the diagramId  value.
 * @private
 */
function getGridLayer(diagramId) {
    var domTable = 'domTable';
    var expandCollapse = null;
    if (!window[domTable][diagramId + '_gridline']) {
        var diagramGridSvg = getGridLayerSvg(diagramId);
        expandCollapse = diagramGridSvg.getElementById(diagramId + '_gridline');
        window[domTable][diagramId + '_gridline'] = expandCollapse;
    }
    else {
        expandCollapse = window[domTable][diagramId + '_gridline'];
    }
    return expandCollapse;
}
// /** @private */
// export function getExpandCollapseLayer(diagramId: string): SVGElement {
//     let expandCollapse: SVGElement = null;
//     let diagramPortSvg: SVGSVGElement = getPortLayerSvg(diagramId);
//     expandCollapse = diagramPortSvg.getElementById(diagramId + '_diagramExpander') as SVGElement;
//     return expandCollapse;
// }
// /** @private */
// export function getPortsLayer(diagramId: string): SVGElement {
//     let expandCollapse: SVGElement = null;
//     let diagramPortSvg: SVGSVGElement = getPortLayerSvg(diagramId);
//     expandCollapse = diagramPortSvg.getElementById(diagramId + '_diagramPorts') as SVGElement;
//     return expandCollapse;
// }
/**
 * getNativeLayer method \
 *
 * @returns {SVGSVGElement} getNativeLayer method .\
 * @param { string } diagramId - provide the diagramId  value.
 * @private
 */
function getNativeLayer(diagramId) {
    var nativeLayer = null;
    var nativeLayerSvg = getNativeLayerSvg(diagramId);
    nativeLayer = nativeLayerSvg.getElementById(diagramId + '_nativeLayer');
    return nativeLayer;
}
/**
 * getHTMLLayer method \
 *
 * @returns {SVGSVGElement} getHTMLLayer method .\
 * @param { string } diagramId - provide the diagramId  value.
 * @private
 */
function getHTMLLayer(diagramId) {
    var htmlLayer = null;
    var domTable = 'domTable';
    if (!window[domTable][diagramId + 'html_layer']) {
        var element = getDiagramElement(diagramId);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var elementcoll = element.getElementsByClassName('e-html-layer');
        htmlLayer = elementcoll[0];
        window[domTable][diagramId + 'html_layer'] = htmlLayer;
    }
    else {
        htmlLayer = window[domTable][diagramId + 'html_layer'];
    }
    return htmlLayer;
}
/* eslint-enable */
/**
 * createHtmlElement method \
 *
 * @returns {SVGSVGElement} createHtmlElement method .\
 * @param { string } elementType - provide the diagramId  value.
 * @param { Object } attribute - provide the diagramId  value.
 * @private
 */
function createHtmlElement(elementType, attribute) {
    var element = createElement(elementType);
    setAttributeHtml(element, attribute);
    return element;
}
/**
 * createSvgElement method \
 *
 * @returns {SVGSVGElement} createSvgElement method .\
 * @param { string } elementType - provide the elementType  value.
 * @param { Object } attribute - provide the attribute  value.
 * @private
 */
function createSvgElement(elementType, attribute) {
    var element = document.createElementNS('http://www.w3.org/2000/svg', elementType);
    setAttributeSvg(element, attribute);
    return element;
}
/** @hidden */
/**
 * parentsUntil method \
 *
 * @returns {SVGSVGElement} parentsUntil method .\
 * @param { Element } elem - provide the elementType  value.
 * @param { string } selector - provide the attribute  value.
 * @param { boolean } isID - provide the attribute  value.
 * @private
 */
function parentsUntil(elem, selector, isID) {
    var parent = elem;
    while (parent) {
        if (isID ? parent.id === selector : hasClass(parent, selector)) {
            break;
        }
        parent = parent.parentNode;
    }
    return parent;
}
/**
 * hasClass method \
 *
 * @returns {SVGSVGElement} hasClass method .\
 * @param { HTMLElement } element - provide the element  value.
 * @param { string } className - provide the className  value.
 * @private
 */
function hasClass(element, className) {
    var eClassName = (typeof element.className === 'object') ? element.className.animVal : element.className;
    return ((' ' + eClassName + ' ').indexOf(' ' + className + ' ') > -1) ? true : false;
}
/**
 * getScrollerWidth method \
 *
 * @returns {number} getScrollerWidth method .\
 * @private
 */
function getScrollerWidth() {
    var outer = createHtmlElement('div', { 'style': 'visibility:hidden; width: 100px' });
    document.body.appendChild(outer);
    var widthNoScroll = outer.getBoundingClientRect().width;
    // force scrollbars
    outer.style.overflow = 'scroll';
    // add innerdiv
    var inner = createHtmlElement('div', { 'style': 'width:100%' });
    outer.appendChild(inner);
    var widthWithScroll = inner.getBoundingClientRect().width;
    // remove divs
    outer.parentNode.removeChild(outer);
    return widthNoScroll - widthWithScroll;
}
/**
 * addTouchPointer method \
 *
 * @returns {ITouches[]} addTouchPointer method .\
 * @param { ITouches[] } touchList - provide the touchList  value.
 * @param { PointerEvent } e - provide the e  value.
 * @param { TouchList } touches - provide the touches  value.
 * @private
 */
function addTouchPointer(touchList, e, touches) {
    touchList = [];
    for (var i = 0, length_1 = touches.length; i < length_1; i++) {
        touchList.push({
            pageX: touches[parseInt(i.toString(), 10)].clientX, pageY: touches[parseInt(i.toString(), 10)].clientY,
            pointerId: null
        });
    }
    return touchList;
}
/**
 * removes the element from dom \
 *
 * @returns {void} removes the element from dom .\
 * @param { ITouches[] } elementId - provide the elementId  value.
 * @param { PointerEvent } contentId - provide the contentId  value.
 * @private
 */
function removeElement(elementId, contentId) {
    var div = getDiagramElement(elementId, contentId);
    if (div) {
        div.parentNode.removeChild(div);
    }
}
/**
 * getContent method   \
 *
 * @returns {void} getContent method .\
 * @param { DiagramHtmlElement | DiagramNativeElement } element - provide the elementId  value.
 * @param { boolean } isHtml - provide the boolean  value.
 * @param { Node | Annotation | PathAnnotation | NodeFixedUserHandle | ConnectorFixedUserHandle } nodeObject - provide the nodeObject  value.
 * @private
 */
function getContent(element, isHtml, nodeObject) {
    var div;
    /* eslint-disable */
    if (isHtml) {
        var attr = { 'style': 'height: 100%; width: 100%' };
        div = createHtmlElement('div', attr);
    }
    else {
        div = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    }
    var node = getElement(element);
    var content = '';
    var sentNode = {};
    var propertyName;
    if (node instanceof Node) {
        sentNode = node;
        if (node.shape.type === 'Native') {
            var svgContent = void 0;
            var div_1 = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            document.body.appendChild(div_1);
            div_1.innerHTML = (node.shape.content);
            /* tslint:disable */
            svgContent = (div_1.getElementsByTagName('svg').length > 0)
                ? div_1.getElementsByTagName('svg')[0].outerHTML :
                div_1.getElementsByTagName('g').length > 0 ? div_1.getElementsByTagName('g')[0].outerHTML : "";
            /* tslint:disable */
            node.shape.content = svgContent;
            /* tslint:disable */
            element.content = svgContent;
            div_1.parentElement.removeChild(div_1);
        }
        //let blazor: string = 'Blazor';
        //Removed isBlazor code
        propertyName = "nodeTemplate";
    }
    else {
        sentNode = node;
        //new
        //Removed isBlazor code
        propertyName = "annotationTemplate";
    }
    var item;
    var diagramElement = document.getElementById(element.diagramId);
    var instance = 'ej2_instances';
    var diagram = diagramElement[instance][0];
    if ((typeof element.content === 'string' || typeof element.content === 'function') && (!element.isTemplate)) {
        var template = document.getElementById(element.content);
        if (template) {
            div.appendChild(template);
        }
        else {
            /* eslint-disable */
            var compiledString = void 0;
            compiledString = compile(element.content);
            for (var _i = 0, _a = compiledString(sentNode, diagram, propertyName, content); _i < _a.length; _i++) {
                item = _a[_i];
                div.appendChild(item);
            }
            //new
            // for (item of compiledString(sentNode, null, null, content, undefined, undefined, isSvg)) {
            //     div.appendChild(item);
            // }
        }
    }
    else if (element.isTemplate) {
        var compiledString = void 0;
        if (diagram.isReact) {
            compiledString = element.getNodeTemplate()(
            /* eslint-enable */
            // eslint-disable-next-line quotes
            cloneObject(nodeObject), diagram, propertyName + "_" + ((propertyName === "nodeTemplate") ? nodeObject.id : element.nodeId + nodeObject.id), undefined, undefined, false, div);
        }
        else if (diagram.isVue || diagram.isVue3) {
            // EJ2-57563 - Added the below code to provide slot template support for Vue and Vue 3
            var templateFn = element.getNodeTemplate();
            if (templateFn) {
                // If other than slot template, this if block gets execute and template get returned.
                compiledString = element.getNodeTemplate()(
                /* eslint-enable */
                // eslint-disable-next-line quotes
                cloneObject(nodeObject), diagram, propertyName + "_" + ((propertyName === "nodeTemplate") ? nodeObject.id : element.nodeId + nodeObject.id), undefined, undefined, false, div);
            }
            else {
                // If we provide slot template means then it enters in this block and returns a template
                if (propertyName === 'nodeTemplate') {
                    compiledString = compile(diagram.nodeTemplate);
                }
                else {
                    compiledString = compile(diagram.annotationTemplate);
                }
                compiledString = compiledString(
                /* eslint-enable */
                // eslint-disable-next-line quotes
                cloneObject(nodeObject), diagram, propertyName + "_" + ((propertyName === "nodeTemplate") ? nodeObject.id : element.nodeId + nodeObject.id), undefined, undefined, false, div);
            }
        }
        else {
            compiledString = element.getNodeTemplate()(
            /* eslint-enable */
            // eslint-disable-next-line quotes
            cloneObject(nodeObject), diagram, propertyName + "_" + ((propertyName === "nodeTemplate") ? nodeObject.id : element.nodeId + nodeObject.id), undefined, undefined, false);
        }
        if (compiledString) {
            for (var i = 0; i < compiledString.length; i++) {
                div.appendChild(compiledString[parseInt(i.toString(), 10)]);
            }
        }
    }
    else {
        if (element.content && element.content.outerHTML) {
            div.appendChild(element.content);
        }
    }
    return element.isTemplate ?
        div : (isHtml ? div.cloneNode(true) : div.cloneNode(true));
}
/* eslint-enable */
/**
 * setAttributeSvg method   \
 *
 * @returns {void} setAttributeSvg method .\
 * @param { SVGElement } svg - provide the svg  value.
 * @param { Object } attributes - provide the boolean  value.
 * @private
 */
function setAttributeSvg(svg, attributes) {
    var keys = Object.keys(attributes);
    for (var i = 0; i < keys.length; i++) {
        // Added below condition to check whether svg is undefined or not
        if (svg && keys[parseInt(i.toString(), 10)] !== 'style') {
            svg.setAttribute(keys[parseInt(i.toString(), 10)], attributes[keys[parseInt(i.toString(), 10)]]);
        }
        else {
            applyStyleAgainstCsp(svg, attributes[keys[parseInt(i.toString(), 10)]]);
        }
    }
}
/**
 * applyStyleAgainstCsp method   \
 *
 * @returns {void} applyStyleAgainstCsp method .\
 * @param { SVGElement } svg - provide the svg  value.
 * @param { string } attributes - provide the boolean  value.
 * @private
 */
function applyStyleAgainstCsp(svg, attributes) {
    var keys = attributes.split(';');
    for (var i = 0; i < keys.length; i++) {
        var attribute = keys[parseInt(i.toString(), 10)].split(':');
        if (attribute.length === 2) {
            svg.style[attribute[0].trim()] = attribute[1].trim();
        }
    }
}
/**
 * setAttributeHtml method   \
 *
 * @returns {void} setAttributeHtml method .\
 * @param { HTMLElement } element - provide the svg  value.
 * @param { Object } attributes - provide the boolean  value.
 * @private
 */
function setAttributeHtml(element, attributes) {
    var keys = Object.keys(attributes);
    for (var i = 0; i < keys.length; i++) {
        if (keys[parseInt(i.toString(), 10)] !== 'style') {
            element.setAttribute(keys[parseInt(i.toString(), 10)], attributes[keys[parseInt(i.toString(), 10)]]);
        }
        else {
            applyStyleAgainstCsp(element, attributes[keys[parseInt(i.toString(), 10)]]);
        }
    }
}
/**
 * createMeasureElements method   \
 *
 * @returns {void} createMeasureElements method .\
 * @private
 */
function createMeasureElements() {
    var measureWindowElement = 'measureElement';
    if (!window["" + measureWindowElement]) {
        var divElement = createHtmlElement('div', {
            id: 'measureElement',
            style: 'visibility:hidden ; height: 0px ; width: 0px; overflow: hidden;'
        });
        var text = createHtmlElement('span', { 'style': 'display:inline-block ; line-height: normal' });
        divElement.appendChild(text);
        //let imageElement: HTMLImageElement;
        var imageElement = createHtmlElement('img', { 'alt': 'measureElementImage', 'src': 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7' });
        divElement.appendChild(imageElement);
        var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
        divElement.appendChild(svg);
        var element = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        element.setAttribute('d', '');
        svg.appendChild(element);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var data = document.createTextNode('');
        var tSpan = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
        svg.appendChild(tSpan);
        window["" + measureWindowElement] = divElement;
        window["" + measureWindowElement].usageCount = 1;
        document.body.appendChild(divElement);
        var measureElementCount = 'measureElementCount';
        if (!window["" + measureElementCount]) {
            window["" + measureElementCount] = 1;
        }
        else {
            window["" + measureElementCount]++;
        }
    }
    else {
        window["" + measureWindowElement].usageCount += 1;
    }
}
/**
 * setChildPosition method   \
 *
 * @returns {number} setChildPosition method .\
 * @param {SubTextElement} temp - provide the temp  value.
 * @param {SubTextElement[]} childNodes - provide the childNodes  value.
 * @param {number} i - provide the i  value.
 * @param {TextAttributes} options - provide the options  value.
 * @private
 */
function setChildPosition(temp, childNodes, i, options) {
    if (childNodes.length >= 1 && temp.x === 0 &&
        (options.textOverflow === 'Clip' || options.textOverflow === 'Ellipsis') &&
        (options.textWrapping === 'Wrap' || options.textWrapping === 'WrapWithOverflow')) {
        temp.x = childNodes[i - 1] ? childNodes[i - 1].x : -(temp.width / 2);
        return temp.x;
    }
    return temp.x;
}
/**
 * getTemplateContent method\
 *
 * @returns {DiagramHtmlElement} getTemplateContent method .\
 * @param {DiagramHtmlElement} annotationcontent - provide the annotationcontent  value.
 * @param {Annotation} annotation - provide the annotation  value.
 * @param {number} annotationTemplate - provide the annotationTemplate  value.
 * @param {Object} diagram - provide the diagram value.
 * @private
 */
function getTemplateContent(
// eslint-disable-next-line @typescript-eslint/ban-types
annotationcontent, annotation, annotationTemplate, diagram) {
    if ((annotationTemplate && !annotation.template) ||
        (annotation.template && typeof annotation.template === 'function' && diagram.isReact)) {
        annotationcontent.isTemplate = true;
        annotationcontent.template = annotationcontent.content = getContent(annotationcontent, true, annotation);
    }
    else {
        annotationcontent.content = annotation.template;
    }
    return annotationcontent;
}
/* eslint-disable */
/** @private */
function createUserHandleTemplates(userHandleTemplate, template, selectedItems, diagramID) {
    var userHandleFn;
    var handle;
    var compiledString;
    var i;
    var div;
    var diagramElement = document.getElementById(diagramID);
    var instance = 'ej2_instances';
    var diagram = diagramElement[instance][0];
    if (userHandleTemplate && template) {
        userHandleFn = templateCompiler(userHandleTemplate);
        for (var _i = 0, _a = selectedItems.userHandles; _i < _a.length; _i++) {
            handle = _a[_i];
            if (userHandleFn) {
                compiledString = userHandleFn(cloneObject(handle), diagram, 'userHandleTemplate' + '_' + handle.name, undefined, undefined, false);
                for (i = 0; i < compiledString.length; i++) {
                    var attr = {
                        'style': 'height: 100%; width: 100%; pointer-events: all',
                        'id': handle.name + '_template_hiddenUserHandle'
                    };
                    div = createHtmlElement('div', attr);
                    div.appendChild(compiledString[i]);
                }
                template[0].appendChild(div);
            }
        }
    } //Removed isBlazor code
}
/* eslint-enable */

/**
 * Implements the basic functionalities
 */
/**
 * Used to generate the random id \
 *
 * @returns { boolean }    Used to generate the random id .\
 *
 * @private
 */
function randomId() {
    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';
    var id = '';
    var num;
    for (var i = 0; i < 5; i++) {
        if (typeof window !== 'undefined' && 'crypto' in window && 'getRandomValues' in crypto) {
            var count = new Uint16Array(1);
            // tslint:disable-next-line:no-any
            var intCrypto = window.msCrypto || window.crypto;
            num = intCrypto.getRandomValues(count)[0] % (chars.length - 1);
        }
        else {
            num = Math.floor(Math.random() * chars.length);
        }
        if (i === 0 && num < 10) {
            i--;
            continue;
        }
        id += chars.substring(num, num + 1);
    }
    return id;
}
/**
 * Used to get the index value \
 *
 * @returns { boolean }    Used to get the index value .\
 * @param {Diagram} comp - provide the Diagram value.
 * @param {string} id - provide the id value.
 *
 * @private
 */
function getIndex(comp, id) {
    if (comp.nodes && comp.nodes.length > 0) {
        for (var i = 0; i < comp.nodes.length; i++) {
            if (comp.nodes[parseInt(i.toString(), 10)].id === id) {
                return i;
            }
        }
    }
    if (comp.connectors && comp.connectors.length > 0) {
        for (var i = 0; i < comp.connectors.length; i++) {
            if (comp.connectors[parseInt(i.toString(), 10)].id === id) {
                return i;
            }
        }
    }
    return null;
}
/**
 * templateCompiler method\
 *
 * @returns { Function }    templateCompiler method .\
 * @param {string} template - provide the template value.
 *
 * @private
 */
function templateCompiler(template) {
    if (template) {
        try {
            if (typeof template !== 'function' && document.querySelectorAll(template).length) {
                return compile(document.querySelector(template).innerHTML.trim());
            }
            else {
                return compile(template);
            }
        }
        catch (e) {
            return compile(template);
        }
    }
    return undefined;
}
/**
 * cornersPointsBeforeRotation method\
 *
 * @returns { Rect }    templateCompiler method .\
 * @param {DiagramElement} ele - provide the template value.
 *
 * @private
 */
function cornersPointsBeforeRotation(ele) {
    var bounds = new Rect();
    var top = ele.offsetY - ele.actualSize.height * ele.pivot.y;
    var bottom = ele.offsetY + ele.actualSize.height * (1 - ele.pivot.y);
    var left = ele.offsetX - ele.actualSize.width * ele.pivot.x;
    var right = ele.offsetX + ele.actualSize.width * (1 - ele.pivot.x);
    var topLeft = { x: left, y: top };
    //const topCenter: PointModel = { x: (left + right) / 2, y: top };
    var topRight = { x: right, y: top };
    //const middleLeft: PointModel = { x: left, y: (top + bottom) / 2 };
    //const middleRight: PointModel = { x: right, y: (top + bottom) / 2 };
    var bottomLeft = { x: left, y: bottom };
    //const bottomCenter: PointModel = { x: (left + right) / 2, y: bottom };
    var bottomRight = { x: right, y: bottom };
    bounds = Rect.toBounds([topLeft, topRight, bottomLeft, bottomRight]);
    return bounds;
}
/**
 * getBounds method\
 *
 * @returns { Rect }    getBounds method .\
 * @param {DiagramElement} element - provide the template value.
 *
 * @private
 */
function getBounds(element) {
    var bounds = new Rect();
    //let corners: Rect;
    var corners = cornersPointsBeforeRotation(element);
    var middleLeft = corners.middleLeft;
    var topCenter = corners.topCenter;
    var bottomCenter = corners.bottomCenter;
    var middleRight = corners.middleRight;
    var topLeft = corners.topLeft;
    var topRight = corners.topRight;
    var bottomLeft = corners.bottomLeft;
    var bottomRight = corners.bottomRight;
    element.corners = {
        topLeft: topLeft, topCenter: topCenter, topRight: topRight, middleLeft: middleLeft,
        middleRight: middleRight, bottomLeft: bottomLeft, bottomCenter: bottomCenter, bottomRight: bottomRight
    };
    if (element.rotateAngle !== 0 || element.parentTransform !== 0) {
        var matrix = identityMatrix();
        rotateMatrix(matrix, element.rotateAngle + element.parentTransform, element.offsetX, element.offsetY);
        element.corners.topLeft = topLeft = transformPointByMatrix(matrix, topLeft);
        element.corners.topCenter = topCenter = transformPointByMatrix(matrix, topCenter);
        element.corners.topRight = topRight = transformPointByMatrix(matrix, topRight);
        element.corners.middleLeft = middleLeft = transformPointByMatrix(matrix, middleLeft);
        element.corners.middleRight = middleRight = transformPointByMatrix(matrix, middleRight);
        element.corners.bottomLeft = bottomLeft = transformPointByMatrix(matrix, bottomLeft);
        element.corners.bottomCenter = bottomCenter = transformPointByMatrix(matrix, bottomCenter);
        element.corners.bottomRight = bottomRight = transformPointByMatrix(matrix, bottomRight);
        //Set corners based on rotate angle
    }
    bounds = Rect.toBounds([topLeft, topRight, bottomLeft, bottomRight]);
    element.corners.left = bounds.left;
    element.corners.right = bounds.right;
    element.corners.top = bounds.top;
    element.corners.bottom = bounds.bottom;
    element.corners.center = bounds.center;
    element.corners.width = bounds.width;
    element.corners.height = bounds.height;
    return bounds;
}
// Removed updateCloneProp method
/**
 * cloneObject method\
 *
 * @returns { Rect }    cloneObject method .\
 * @param {DiagramElement} obj - provide the obj value.
 * @param {DiagramElement} additionalProp - provide the additionalProp value.
 * @param {DiagramElement} key - provide the key value.
 * @param {DiagramElement} cloneBlazorProp - provide the cloneBlazorProp value.
 *
 * @private
 */
function cloneObject(obj, additionalProp, key, cloneBlazorProp) {
    var newObject = {};
    var keys = 'properties';
    var prop = 'propName';
    if (obj) {
        key = obj["" + prop];
        var sourceObject = obj["" + keys] || obj;
        var properties = [];
        properties = properties.concat(Object.keys(sourceObject));
        var customProperties = [];
        properties.push('version');
        if (key) {
            var propAdditional = getFunction(additionalProp);
            if (propAdditional) {
                customProperties = propAdditional(key);
            }
            else {
                customProperties = [];
            }
            properties = properties.concat(customProperties);
        }
        var internalProp = getInternalProperties(key);
        properties = properties.concat(internalProp);
        //Removed blazor code
        for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
            var property = properties_1[_i];
            if (property !== 'historyManager') {
                if (property !== 'wrapper') {
                    //const constructorId: string = 'constructor';
                    //const name: string = 'name';
                    // eslint-disable-next-line no-prototype-builtins
                    var isEventEmmitter = obj["" + property] && obj.hasOwnProperty('observers') ? true : false;
                    if (!isEventEmmitter) {
                        if (obj["" + property] instanceof Array) {
                            newObject["" + property] = cloneArray((internalProp.indexOf(property) === -1 && obj["" + keys]) ? obj["" + keys]["" + property] : obj["" + property], additionalProp, property);
                        }
                        else if (obj["" + property] instanceof Array === false && obj["" + property] instanceof HTMLElement) {
                            newObject["" + property] = obj["" + property].cloneNode(true).innerHTML;
                        }
                        else if (obj["" + property] instanceof Array === false && obj["" + property] instanceof Object) {
                            newObject["" + property] = cloneObject((internalProp.indexOf(property) === -1 && obj["" + keys]) ? obj["" + keys]["" + property] : obj["" + property], undefined, undefined);
                        }
                        else {
                            newObject["" + property] = obj["" + property];
                        }
                    }
                }
                else {
                    if (obj["" + property]) {
                        newObject["" + property] = {
                            actualSize: {
                                width: obj["" + property].actualSize.width, height: obj["" + property].actualSize.height
                            }, offsetX: obj["" + property].offsetX, offsetY: obj["" + property].offsetY
                        };
                    }
                }
            }
        }
    }
    return newObject;
}
/**
 * getInternalProperties method\
 *
 * @returns { string[] }    getInternalProperties method .\
 * @param {string} propName - provide the propName value.
 *
 * @private
 */
function getInternalProperties(propName) {
    switch (propName) {
        case 'nodes':
        case 'children':
            return ['inEdges', 'outEdges', 'parentId', 'processId', 'nodeId', 'umlIndex', 'isPhase', 'isLane'];
        case 'connectors':
            return ['parentId'];
        case 'annotation':
            return ['nodeId'];
        case 'annotations':
            return ['nodeId'];
        case 'shape':
            return ['hasHeader'];
        case 'layers':
            return ['objectZIndex'];
    }
    return [];
}
/**
 * cloneArray method\
 *
 * @returns {  Object[] }    getInternalProperties method .\
 * @param {string} sourceArray - provide the sourceArray value.
 * @param {string} additionalProp - provide the additionalProp value.
 * @param {string} key - provide the key value.
 * @param {string} cloneBlazorProp - provide the cloneBlazorProp value.
 *
 * @private
 */
function cloneArray(sourceArray, additionalProp, key, cloneBlazorProp) {
    var clonedArray;
    if (sourceArray) {
        clonedArray = [];
        for (var i = 0; i < sourceArray.length; i++) {
            if (sourceArray[parseInt(i.toString(), 10)] instanceof Array) {
                clonedArray.push(sourceArray[parseInt(i.toString(), 10)]);
            }
            else if (sourceArray[parseInt(i.toString(), 10)] instanceof Object) {
                clonedArray.push(cloneObject(sourceArray[parseInt(i.toString(), 10)], additionalProp, key));
            }
            else {
                clonedArray.push(sourceArray[parseInt(i.toString(), 10)]);
            }
        }
    }
    return clonedArray;
}
/**
 * extendObject method\
 *
 * @returns {  Object}    getInternalProperties method .\
 * @param {string} options - provide the options value.
 * @param {string} childObject - provide the childObject value.
 *
 * @private
 */
function extendObject(options, childObject) {
    var properties = 'properties';
    if (options) {
        if (!childObject) {
            childObject = { properties: {} };
        }
        //const target: Object = childObject;
        for (var _i = 0, _a = Object.keys(options); _i < _a.length; _i++) {
            var property = _a[_i];
            if (options["" + property] instanceof Array) {
                var extendeArray = extendArray(options["" + property], childObject["" + properties]["" + property]);
                if (!childObject["" + properties]["" + property] || !childObject["" + properties]["" + property].length) {
                    childObject["" + property] = extendeArray;
                }
            }
            else if (options["" + property] instanceof Array === false && options["" + property] instanceof HTMLElement) {
                childObject["" + property] = options["" + property].cloneNode(true).innerHtml;
            }
            else if (options["" + property] instanceof Array === false && options["" + property] instanceof Object) {
                var extendedObject = extendObject(options["" + property], childObject["" + properties]["" + property]);
                if (extendedObject["" + properties] && !Object.keys(extendedObject["" + properties]).length) {
                    delete extendedObject["" + properties];
                }
                childObject["" + property] = extendedObject;
            }
            else {
                childObject["" + property] = childObject["" + properties]["" + property] !== undefined ?
                    childObject["" + property] : options["" + property];
            }
        }
    }
    return childObject;
}
/**
 * extendObject method\
 *
 * @returns {  Object}    getInternalProperties method .\
 * @param {string} sourceArray - provide the sourceArray value.
 * @param {string} childArray - provide the childArray value.
 *
 * @private
 */
function extendArray(sourceArray, childArray) {
    var clonedArray = [];
    var reset = false;
    if (!childArray) {
        childArray = [];
    }
    if (!childArray.length) {
        reset = true;
    }
    for (var i = 0; i < sourceArray.length; i++) {
        if (sourceArray[parseInt(i.toString(), 10)] instanceof Array) {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            var extendedArray = extendArray(sourceArray[parseInt(i.toString(), 10)], childArray[parseInt(i.toString(), 10)]);
            if (reset) {
                clonedArray.push(extendArray);
            }
        }
        else if (sourceArray[parseInt(i.toString(), 10)] instanceof Object) {
            var extendedObject = extendObject(sourceArray[parseInt(i.toString(), 10)], childArray[parseInt(i.toString(), 10)]);
            if (reset) {
                clonedArray.push(extendedObject);
            }
        }
        else {
            clonedArray.push(sourceArray[parseInt(i.toString(), 10)]);
        }
    }
    return clonedArray;
}
/**
 * textAlignToString method\
 *
 * @returns {  Object}    textAlignToString method .\
 * @param {string} value - provide the sourceArray value.
 *
 * @private
 */
function textAlignToString(value) {
    var state = '';
    switch (value) {
        case 'Center':
            state = 'center';
            break;
        case 'Left':
            state = 'left';
            break;
        case 'Right':
            state = 'right';
            break;
        case 'Justify':
            state = 'justify';
            break;
    }
    return state;
}
/**
 * wordBreakToString method\
 *
 * @returns {  string }    wordBreakToString method .\
 * @param {TextWrap | TextDecoration} value - provide the value value.
 *
 * @private
 */
function wordBreakToString(value) {
    var state = '';
    switch (value) {
        case 'Wrap':
            state = 'breakall';
            break;
        case 'NoWrap':
            state = 'keepall';
            break;
        case 'WrapWithOverflow':
            state = 'normal';
            break;
        case 'LineThrough':
            state = 'line-through';
            break;
    }
    return state;
}
/**
 * bBoxText method\
 *
 * @returns { number }    bBoxText method .\
 * @param {string} textContent - provide the textContent value.
 * @param {string} options - provide the options value.
 *
 * @private
 */
function bBoxText(textContent, options) {
    var measureWindowElement = 'measureElement';
    window["" + measureWindowElement].style.visibility = 'visible';
    var svg = window["" + measureWindowElement].children[2];
    var text = getChildNode(svg)[1];
    text.textContent = textContent;
    applyStyleAgainstCsp(text, 'font-size:' + options.fontSize + 'px; font-family:'
        + options.fontFamily + ';font-weight:' + (options.bold ? 'bold' : 'normal'));
    var bBox = text.getBBox().width;
    window["" + measureWindowElement].style.visibility = 'hidden';
    return bBox;
}
/**
 * middleElement method\
 *
 * @returns {  number}    middleElement method .\
 * @param {number} i - provide the textContent value.
 * @param {number} j - provide the options value.
 *
 * @private
 */
function middleElement(i, j) {
    var m = 0;
    m = (i + j) / 2;
    return m;
}
/**
 * overFlow method\
 *
 * @returns {  number}    overFlow method .\
 * @param {number} text - provide the text value.
 * @param {number} options - provide the options value.
 *
 * @private
 */
function overFlow(text, options) {
    var i = 0;
    var j = 0;
    var middle = 0;
    var bounds = 0;
    var temp = '';
    j = text.length;
    var t = 0;
    do {
        if (bounds > 0) {
            i = middle;
        }
        middle = Math.floor(middleElement(i, j));
        temp += text.substr(i, middle);
        bounds = bBoxText(temp, options);
    } while (bounds <= options.width);
    temp = temp.substr(0, i);
    for (t = i; t < j; t++) {
        temp += text[parseInt(t.toString(), 10)];
        bounds = bBoxText(temp, options);
        if (bounds >= options.width) {
            text = text.substr(0, temp.length - 1);
            break;
        }
    }
    if (options.textOverflow === 'Ellipsis') {
        text = text.substr(0, text.length - 3);
        text += '...';
    }
    else {
        text = text.substr(0, text.length);
    }
    return text;
}
/**
 * whiteSpaceToString method\
 *
 * @returns {  number}    whiteSpaceToString method .\
 * @param {number} value - provide the value value.
 * @param {number} wrap - provide the wrap value.
 *
 * @private
 */
function whiteSpaceToString(value, wrap) {
    if (wrap === 'NoWrap' && value === 'PreserveAll') {
        return 'pre';
    }
    var state = '';
    switch (value) {
        case 'CollapseAll':
            state = 'nowrap';
            break;
        case 'CollapseSpace':
            state = 'pre-line';
            break;
        case 'PreserveAll':
            state = 'pre-wrap';
            break;
    }
    return state;
}
/**
 * rotateSize method\
 *
 * @returns {  number}    rotateSize method .\
 * @param {number} size - provide the size value.
 * @param {number} angle - provide the angle value.
 *
 * @private
 */
function rotateSize(size, angle) {
    var matrix = identityMatrix();
    rotateMatrix(matrix, angle, 0, 0);
    var topLeft = transformPointByMatrix(matrix, { x: 0, y: 0 });
    var topRight = transformPointByMatrix(matrix, { x: size.width, y: 0 });
    var bottomLeft = transformPointByMatrix(matrix, { x: 0, y: size.height });
    var bottomRight = transformPointByMatrix(matrix, { x: size.width, y: size.height });
    var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
    var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
    var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
    var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
    return new Size(maxX - minX, maxY - minY);
}
/**
 * rotatePoint method\
 *
 * @returns {  number}    rotateSize method .\
 * @param {number} angle - provide the angle value.
 * @param {number} pivotX - provide the pivotX value.
 * @param {number} pivotY - provide the pivotY value.
 * @param {PointModel} point - provide the point value.
 * @private
 */
function rotatePoint(angle, pivotX, pivotY, point) {
    if (angle !== 0) {
        var matrix = identityMatrix();
        rotateMatrix(matrix, angle, pivotX, pivotY);
        return transformPointByMatrix(matrix, point);
    }
    return point;
}
/**
 * getOffset method\
 *
 * @returns {  number}    getOffset method .\
 * @param {PointModel} topLeft - provide the angle value.
 * @param {DiagramElement} obj - provide the pivotX value.
 * @private
 */
function getOffset(topLeft, obj) {
    var offX = topLeft.x + obj.desiredSize.width * obj.pivot.x;
    var offY = topLeft.y + obj.desiredSize.height * obj.pivot.y;
    return {
        x: offX, y: offY
    };
}
/**
 * getFunction method\
 *
 * @returns {  Function }    getFunction method .\
 * @param {PointModel} value - provide the angle value.
 * @private
 */
function getFunction(value) {
    if (value !== undefined) {
        if (typeof value === 'string') {
            value = getValue(value, window);
        }
    }
    return value;
}

/* eslint-disable no-case-declarations */
/**
 * Canvas Renderer
 */
/** @private */
var CanvasRenderer = /** @class */ (function () {
    function CanvasRenderer() {
    }
    /**
     * Provide the context value for the canvas \
     *
     *  @returns {CanvasRenderingContext2D} Provide the context value for the canvas .\
     *  @param { HTMLCanvasElement} canvas - Return the dashed array values .
     *  @private
     */
    CanvasRenderer.getContext = function (canvas) {
        return canvas.getContext('2d');
    };
    CanvasRenderer.setCanvasSize = function (canvas, width, height) {
        if (canvas) {
            canvas.setAttribute('width', width.toString());
            canvas.setAttribute('height', height.toString());
        }
    };
    /**
     * Draw the gradient for the diagram shapes .\
     *
     *  @returns {SVGElement} Draw the gradient for the diagram shapes.
     *  @param {StyleAttributes} options - Provide the options  for the gradient  element .
     *  @param {SVGElement} ctx - Provide canvas values .
     *  @param {string} x - Provide the x value for the gradient .
     *  @param {string} y - Provide the x value for the gradient .
     *  @private
     */
    CanvasRenderer.prototype.renderGradient = function (options, ctx, x, y) {
        var max;
        var min;
        var grd;
        if (options.gradient.type !== 'None') {
            for (var i = 0; i < options.gradient.stops.length; i++) {
                max = max !== undefined ? options.gradient.stops[parseInt(i.toString(), 10)].offset
                    : Math.max(max, options.gradient.stops[parseInt(i.toString(), 10)].offset);
                min = min !== undefined ? options.gradient.stops[parseInt(i.toString(), 10)].offset
                    : Math.min(min, options.gradient.stops[parseInt(i.toString(), 10)].offset);
            }
            if (options.gradient.type === 'Linear') {
                var linear = options.gradient;
                grd = ctx.createLinearGradient(x + linear.x1, y + linear.y1, x + linear.x2, y + linear.y2);
            }
            else {
                var radial = options.gradient;
                grd = ctx.createRadialGradient(x + radial.fx, y + radial.fy, 0, x + radial.cx, y + radial.cy, radial.r);
            }
            for (var i = 0; i < options.gradient.stops.length; i++) {
                var stop_1 = options.gradient.stops[parseInt(i.toString(), 10)];
                var offset = min < 0 ? (max + stop_1.offset) / (2 * max) : stop_1.offset / max;
                grd.addColorStop(offset, stop_1.color);
            }
            ctx.fillStyle = grd;
        }
        return ctx;
    };
    /**
     * Draw the shawdow  for the rectangle shape in diagram \
     *
     *  @returns {void}  Draw the shawdow  for the rectangle shape in diagram .\
     *
     *  @param { SVGElement} options - Provide the base attributes .
     *  @param { RectAttributes} canvas - Provide the canvas values .
     *  @param { string} collection - Provide the collection value.
     *  @private
     */
    CanvasRenderer.prototype.renderShadow = function (options, canvas, collection) {
        if (collection === void 0) { collection = null; }
        var ctx = CanvasRenderer.getContext(canvas);
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = ctx.fillStyle = options.shadow.color;
        ctx.globalAlpha = options.shadow.opacity;
        var ptModel = { x: 0, y: 0 };
        var point = Point.transform(ptModel, options.shadow.angle, options.shadow.distance);
        var transX = options.x + point.x;
        var transY = options.y + point.y;
        var pivotX = transX + options.width * options.pivotX;
        var pivotY = transY + options.height * options.pivotY;
        this.rotateContext(canvas, options.angle, pivotX, pivotY);
        if (collection) {
            ctx.translate(transX, transY);
            this.renderPath(canvas, options, collection);
            ctx.translate(-transX, -transY);
        }
        else {
            ctx.rect(transX, transY, options.width, options.height);
            ctx.fillRect(transX, transY, options.width, options.height);
        }
        ctx.fill();
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
    };
    /**
     * Create canvas element for the diagram \
     *
     *  @returns {HTMLCanvasElement}    Create canvas element for the diagram .\
     *
     *  @param { SVGElement} id - Provide the id for the canvas.
     *  @param { Object} width - Provide the width for the canvas.
     *  @param { Object} height - Provide the height for the canvas.
     *  @private
     */
    CanvasRenderer.createCanvas = function (id, width, height) {
        var canvasObj = createHtmlElement('canvas', { 'id': id });
        this.setCanvasSize(canvasObj, width, height);
        return canvasObj;
    };
    CanvasRenderer.prototype.setStyle = function (canvas, style) {
        var ctx = CanvasRenderer.getContext(canvas);
        if (style.fill === 'none') {
            style.fill = 'transparent';
        }
        if (style.stroke === 'none') {
            style.stroke = 'transparent';
        }
        ctx.strokeStyle = style.stroke;
        ctx.lineWidth = style.strokeWidth;
        if (style.strokeWidth === 0) {
            ctx.strokeStyle = 'transparent';
        }
        ctx.globalAlpha = style.opacity;
        var dashArray = [];
        if (style.dashArray) {
            dashArray = this.parseDashArray(style.dashArray);
        }
        ctx.setLineDash(dashArray);
        if (style.gradient && style.gradient.type !== 'None') {
            if (style.shapeType === 'Rectangle') {
                this.renderGradient(style, ctx, style.x, style.y);
            }
            else {
                this.renderGradient(style, ctx, 0, 0);
            }
        }
        else {
            ctx.fillStyle = style.fill;
        }
    };
    CanvasRenderer.prototype.rotateContext = function (canvas, angle, x, y) {
        var ctx = CanvasRenderer.getContext(canvas);
        ctx.translate(x, y);
        ctx.rotate(angle * Math.PI / 180);
        ctx.translate(-x, -y);
    };
    CanvasRenderer.prototype.setFontStyle = function (canvas, text) {
        var ctx = CanvasRenderer.getContext(canvas);
        var font = '';
        if (text.italic) {
            font += 'italic ';
        }
        if (text.bold) {
            font += 'bold ';
        }
        font += (text.fontSize) + 'px ';
        font += text.fontFamily;
        ctx.font = font;
    };
    /**
     * Return the dashed array values \
     *
     *  @returns {number[]}  Return the dashed array values .\
     *  @param { SVGElement} dashArray - Return the dashed array values .
     *  @private
     */
    CanvasRenderer.prototype.parseDashArray = function (dashArray) {
        var dashes = [];
        var separator = dashArray.indexOf(' ') !== -1 ? ' ' : ',';
        var splittedDashes = dashArray.split(separator);
        for (var _i = 0, splittedDashes_1 = splittedDashes; _i < splittedDashes_1.length; _i++) {
            var i = splittedDashes_1[_i];
            dashes.push(Number(i));
        }
        return dashes;
    };
    CanvasRenderer.prototype.drawRoundedRect = function (canvas, options) {
        var context = CanvasRenderer.getContext(canvas);
        context.beginPath();
        var x = options.x;
        var y = options.y;
        var w = options.width;
        var h = options.height;
        var mx = x + w / 2;
        var my = y + h / 2;
        context.beginPath();
        this.setStyle(canvas, options);
        context.moveTo(x, my);
        context.quadraticCurveTo(x, y, mx, y);
        context.quadraticCurveTo(x + w, y, x + w, my);
        context.quadraticCurveTo(x + w, y + h, mx, y + h);
        context.quadraticCurveTo(x, y + h, x, my);
        //892454-Fill color not applied for BPMN activity shapes inside the symbol palette.
        context.fill();
        context.stroke();
    };
    //Rendering Part
    /**
     * Draw the Rectangle for the diagram \
     *
     *  @returns {void}  Draw the Rectangle for the diagram .\
     *
     *  @param { SVGElement} canvas - Provide the SVG .
     *  @param { RectAttributes} options - Provide the Rect attributes .
     *  @param { string} diagramId - Provide the diagram id .
     *  @param { boolean} isExport - Provide the isExport .
     *  @param { boolean} isSelector - Provide the selector possobilities .
     *  @param { SVGSVGElement} parentSvg - Provide the parent svg element .
     *  @param { Object} ariaLabel - Provide the Arial label attributes .
     *  @param { boolean} isCircularHandle - Provide the boolean attribute for the circular handle .
     *  @param { number} enableSelector - Provide the selector possobilities .
     *  @param { any } renderer - Provide the renderer value .
     *  @param { any } element - Provide the element value .
     *  @private
     */
    CanvasRenderer.prototype.drawRectangle = function (canvas, options, diagramId, isExport, isSelector, parentSvg, ariaLabel, isCircularHandle, enableSelector, renderer, element) {
        if (options.visible === true) {
            if (options.cornerRadius) {
                if (!isExport && (options.width < 30 || options.height < 30)) {
                    this.drawRoundedRect(canvas, options);
                }
                else {
                    options.data = getRectanglePath(options.cornerRadius, options.height, options.width);
                    this.drawPath(canvas, options, diagramId, isSelector, parentSvg, ariaLabel, undefined, renderer, element);
                }
            }
            else {
                var ctx = CanvasRenderer.getContext(canvas);
                if (options.shadow) {
                    this.renderShadow(options, canvas);
                }
                ctx.save();
                ctx.beginPath();
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var cornerRadius = options.cornerRadius;
                var pivotX = options.x + options.width * options.pivotX;
                var pivotY = options.y + options.height * options.pivotY;
                var angle = options.isImage ? -options.angle : options.angle;
                this.rotateContext(canvas, angle, pivotX, pivotY);
                this.setStyle(canvas, options);
                ctx.rect(options.x, options.y, options.width, options.height);
                ctx.fillRect(options.x, options.y, options.width, options.height);
                ctx.fill();
                ctx.stroke();
                ctx.closePath();
                ctx.restore();
            }
        }
    };
    // public updateSelectionRegion(canvas: HTMLCanvasElement, options: RectAttributes): void {
    //     this.drawRectangle(canvas, options);
    // }
    // public drawLine(canvas: HTMLCanvasElement, options: LineAttributes): void {
    //     let ctx: CanvasRenderingContext2D = CanvasRenderer.getContext(canvas);
    //     ctx.save();
    //     ctx.beginPath();
    //     let pivotX: number = options.x + options.width * options.pivotX;
    //     let pivotY: number = options.y + options.height * options.pivotY;
    //     this.rotateContext(canvas, options.angle, pivotX, pivotY);
    //     this.setStyle(canvas, options as StyleAttributes);
    //     ctx.translate(options.x, options.y);
    //     ctx.moveTo(options.startPoint.x, options.startPoint.y);
    //     ctx.lineTo(options.endPoint.x, options.endPoint.y);
    //     ctx.translate(-options.x, -options.y);
    //     ctx.stroke();
    //     ctx.closePath();
    //     ctx.restore();
    // }
    // public drawCircle(canvas: HTMLCanvasElement, options: CircleAttributes): void {
    //     let ctx: CanvasRenderingContext2D = CanvasRenderer.getContext(canvas);
    //     ctx.save();
    //     ctx.beginPath();
    //     let pivotY: number = options.y + options.height * options.pivotY;
    //     let pivotX: number = options.x + options.width * options.pivotX;
    //     this.setStyle(canvas, options as StyleAttributes);
    //     this.rotateContext(canvas, options.angle, pivotX, pivotY);
    //     ctx.arc(options.centerX, options.centerY, options.radius, 0, 2 * Math.PI);
    //     ctx.fill();
    //     ctx.stroke();
    //     ctx.closePath();
    //     ctx.restore();
    // }
    /**
     * Draw the path element for the diagram\
     *
     *  @returns {void}  Draw the path element for the diagram .\
     *
     *  @param { SVGElement} canvas - Provide the SVG element .
     *  @param { PathAttributes} options - Provide the path element attributes .
     *  @param {string} diagramId - Provide the diagram id .
     *  @param {boolean} isSelector - Provide selector boolean value .
     *  @param {SVGSVGElement} parentSvg - Provide the parent SVG element .
     *  @param {Object} ariaLabel - Provide arial label value .
     *  @param {number} scale - Provide the scale value .
     *  @param {any} renderer - Provide the renderer value .
     *  @param {PathElement} element - Provide the path element value .
     *  @private
     */
    CanvasRenderer.prototype.drawPath = function (canvas, options, diagramId, isSelector, parentSvg, ariaLabel, scale, renderer, element) {
        var collection = [];
        collection = processPathData(options.data);
        collection = pathSegmentCollection(collection);
        if (options.shadow) {
            this.renderShadow(options, canvas, collection);
        }
        var ctx = CanvasRenderer.getContext(canvas);
        ctx.save();
        ctx.beginPath();
        var pivotY = options.y + options.height * options.pivotY;
        var pivotX = options.x + options.width * options.pivotX;
        this.applyFlipAndRotate(ctx, options, canvas, pivotX, pivotY, renderer, element);
        this.setStyle(canvas, options);
        ctx.translate(options.x, options.y);
        this.renderPath(canvas, options, collection);
        ctx.fill();
        ctx.translate(-options.x, -options.y);
        ctx.stroke();
        ctx.restore();
    };
    /**
     * Draw the path element for the diagram\
     *
     *  @returns {void}  Draw the path element for the diagram .\
     *
     *  @param { SVGElement} canvas - Provide the SVG element .
     *  @param {PathAttributes} options - Provide the path element attributes .
     *  @param {Object[]} collection - Provide the parent SVG element .
     *  @private
     */
    CanvasRenderer.prototype.renderPath = function (canvas, options, collection) {
        if (options.visible === true) {
            var arcCount = 0;
            var ctx = CanvasRenderer.getContext(canvas);
            var x0 = void 0;
            var y0 = void 0;
            var x1 = void 0;
            var y1 = void 0;
            var x2 = void 0;
            var y2 = void 0;
            var x = void 0;
            var y = void 0;
            var length_1;
            var i = void 0;
            var segs = collection;
            for (x = 0, y = 0, i = 0, length_1 = segs.length; i < length_1; ++i) {
                var obj = segs[parseInt(i.toString(), 10)];
                var seg = obj;
                var char = seg.command;
                if ('x1' in seg) {
                    x1 = seg.x1;
                }
                if ('x2' in seg) {
                    x2 = seg.x2;
                }
                if ('y1' in seg) {
                    y1 = seg.y1;
                }
                if ('y2' in seg) {
                    y2 = seg.y2;
                }
                if ('x' in seg) {
                    x = seg.x;
                }
                if ('y' in seg) {
                    y = seg.y;
                }
                switch (char) {
                    case 'M':
                        ctx.moveTo(x, y);
                        seg.x = x;
                        seg.y = y;
                        break;
                    case 'L':
                        ctx.lineTo(x, y);
                        seg.x = x;
                        seg.y = y;
                        break;
                    case 'C':
                        ctx.bezierCurveTo(x1, y1, x2, y2, x, y);
                        seg.x = x;
                        seg.y = y;
                        seg.x1 = x1;
                        seg.y1 = y1;
                        seg.x2 = x2;
                        seg.y2 = y2;
                        break;
                    case 'Q':
                        ctx.quadraticCurveTo(x1, y1, x, y);
                        seg.x = x;
                        seg.y = y;
                        seg.x1 = x1;
                        seg.y1 = y1;
                        break;
                    case 'A':
                        // eslint-disable-next-line
                        var curr = { x: x0, y: y0 };
                        var rx = void 0;
                        var ry = void 0;
                        if (options.arc && options.arc.length > 0) {
                            if (seg.r1 === 0) {
                                rx = options.arc[parseInt(arcCount.toString(), 10)].r1;
                            }
                            else {
                                rx = seg.r1;
                            }
                            if (seg.r2 === 0) {
                                ry = options.arc[parseInt(arcCount.toString(), 10)].r2;
                            }
                            else {
                                ry = seg.r2;
                            }
                            arcCount++;
                        }
                        else {
                            rx = seg.r1;
                            ry = seg.r2;
                        }
                        var xAxisRotation = seg.angle * (Math.PI / 180.0);
                        var largeArc = seg.largeArc;
                        var sweep = seg.sweep;
                        var cp = { x: x, y: y };
                        var currp = {
                            x: Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
                            y: -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
                        };
                        var l = Math.pow(currp.x, 2) / Math.pow(rx, 2) + Math.pow(currp.y, 2) / Math.pow(ry, 2);
                        if (l > 1) {
                            rx *= Math.sqrt(l);
                            ry *= Math.sqrt(l);
                        }
                        var k = (Math.pow(ry, 2) * Math.pow(currp.x, 2));
                        var s = (largeArc === sweep ? -1 : 1) * Math.sqrt(((Math.pow(rx, 2) * Math.pow(ry, 2)) - (Math.pow(rx, 2) * Math.pow(currp.y, 2)) - k) /
                            (Math.pow(rx, 2) * Math.pow(currp.y, 2) + Math.pow(ry, 2) * Math.pow(currp.x, 2)));
                        if (isNaN(s)) {
                            s = 0;
                        }
                        var cpp = { x: s * rx * currp.y / ry, y: s * -ry * currp.x / rx };
                        var centp = {
                            x: (curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
                            y: (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
                        };
                        var a1 = this.a([1, 0], [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry]);
                        var u = [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry];
                        var v = [(-currp.x - cpp.x) / rx, (-currp.y - cpp.y) / ry];
                        var ad = this.a(u, v);
                        if (this.r(u, v) <= -1) {
                            ad = Math.PI;
                        }
                        if (this.r(u, v) >= 1) {
                            ad = 0;
                        }
                        var dir = !sweep ? -1.0 : 1.0;
                        var ah = a1 + dir * (ad / 2.0);
                        // eslint-disable-next-line @typescript-eslint/no-unused-vars
                        var halfWay = {
                            x: centp.x + rx * Math.cos(ah),
                            y: centp.y + ry * Math.sin(ah)
                        };
                        seg.centp = centp;
                        seg.xAxisRotation = xAxisRotation;
                        seg.rx = rx;
                        seg.ry = ry;
                        seg.a1 = a1;
                        seg.ad = ad;
                        seg.sweep = sweep;
                        if (ctx != null) {
                            var ra = rx > ry ? rx : ry;
                            var sx = rx > ry ? 1 : rx / ry;
                            var sy = rx > ry ? ry / rx : 1;
                            ctx.save();
                            ctx.translate(centp.x, centp.y);
                            ctx.rotate(xAxisRotation);
                            ctx.scale(sx, sy);
                            ctx.arc(0, 0, ra, a1, a1 + ad, !sweep);
                            ctx.scale(1 / sx, 1 / sy);
                            ctx.rotate(-xAxisRotation);
                            ctx.translate(-centp.x, -centp.y);
                            ctx.restore();
                        }
                        break;
                    case 'Z':
                    case 'z':
                        ctx.closePath();
                        x = x0;
                        y = y0;
                        break;
                }
                x0 = x;
                y0 = y;
            }
        }
    };
    /**
     * Draw the text element for the diagram\
     *
     *  @returns {void}  Draw the text element for the diagram .\
     *
     *  @param { SVGElement} canvas - Provide the SVG element .
     *  @param {TextAttributes} options - Provide the text element attributes .
     *  @param {SVGSVGElement} parentSvg - Provide the parent SVG element .
     *  @param {Object} ariaLabel - Provide the label properties .
     *  @param {string} diagramId - Provide the diagram id .
     *  @param {number} scaleValue - Provide the scale value .
     *  @param {any} renderer - Provide the renderer value .
     *  @param {element} element - Provide the text element value.
     *  @private
     */
    CanvasRenderer.prototype.drawText = function (canvas, options, parentSvg, ariaLabel, diagramId, scaleValue, renderer, element) {
        if (options.content && options.visible === true) {
            var parentNode = renderer.groupElement;
            var ctx = CanvasRenderer.getContext(canvas);
            ctx.save();
            this.setStyle(canvas, options);
            if (scaleValue) {
                options.fontSize *= scaleValue;
            }
            var pivotX = options.x + options.width * options.pivotX;
            var pivotY = options.y + options.height * options.pivotY;
            // 919944: Text Flip and Rotation Not Applied in Exported Image
            this.applyFlipAndRotate(ctx, options, canvas, pivotX, pivotY, renderer, element);
            this.setFontStyle(canvas, options);
            var i = 0;
            var childNodes = [];
            childNodes = options.childNodes;
            var wrapBounds = options.wrapBounds;
            ctx.fillStyle = options.color;
            if (wrapBounds) {
                var position = this.labelAlign(options, wrapBounds, childNodes);
                for (i = 0; i < childNodes.length; i++) {
                    var child = childNodes[parseInt(i.toString(), 10)];
                    child.x = setChildPosition(child, childNodes, i, options);
                    var offsetX = position.x + (scaleValue ? child.x * scaleValue : child.x) - wrapBounds.x;
                    var offsetY = position.y + (scaleValue ? child.dy * scaleValue : child.dy) * i + ((options.fontSize) * 0.8);
                    if (wrapBounds.width > options.width && options.textOverflow !== 'Wrap' && options.textWrapping === 'NoWrap') {
                        child.text = overFlow(child.text, options);
                    }
                    if ((options.textOverflow === 'Clip' || options.textOverflow === 'Ellipsis') && options.textWrapping === 'Wrap') {
                        if (offsetY < parentNode.actualSize.height + parentNode.bounds.y) {
                            if (options.textOverflow === 'Ellipsis' && childNodes[i + 1]) {
                                var temp = childNodes[i + 1];
                                var y = position.y + temp.dy * (i + 1) + ((options.fontSize) * 0.8);
                                if (y > parentNode.actualSize.height + parentNode.bounds.y) {
                                    child.text = child.text.slice(0, child.text.length - 3);
                                    child.text = child.text.concat('...');
                                }
                            }
                            ctx.fillText(child.text, offsetX, offsetY);
                        }
                    }
                    else {
                        ctx.fillText(child.text, offsetX, offsetY);
                    }
                    if (options.textDecoration === 'Underline'
                        || options.textDecoration === 'Overline'
                        || options.textDecoration === 'LineThrough') {
                        var startPointX = offsetX;
                        var startPointY = void 0;
                        var textlength = ctx.measureText(child.text).width;
                        var endPointX = offsetX + textlength;
                        var endPointY = void 0;
                        switch (options.textDecoration) {
                            case 'Underline':
                                startPointY = offsetY + 2;
                                endPointY = offsetY + 2;
                                break;
                            case 'Overline':
                                startPointY = (position.y + child.dy * i);
                                endPointY = (position.y + child.dy * i);
                                break;
                            case 'LineThrough':
                                startPointY = ((offsetY + position.y + child.dy * i) / 2) + 2;
                                endPointY = ((offsetY + position.y + child.dy * i) / 2) + 2;
                        }
                        ctx.beginPath();
                        ctx.moveTo(startPointX, startPointY);
                        ctx.lineTo(endPointX, endPointY);
                        ctx.strokeStyle = options.color;
                        ctx.lineWidth = options.fontSize * .08;
                        ctx.globalAlpha = options.opacity;
                        ctx.stroke();
                    }
                }
            }
            ctx.restore();
        }
    };
    // 919944: Flip position and rotate angle calculation for elements
    CanvasRenderer.prototype.applyFlipAndRotate = function (ctx, options, canvas, pivotX, pivotY, renderer, element) {
        if (options.flip !== FlipDirection.None && renderer && element && !(element.elementActions & ElementAction.ElementIsPort)) {
            var parent_1 = renderer.groupElement;
            var textWrapper = element;
            var transform = void 0;
            if ((element instanceof TextElement && element.position)) {
                transform = renderer.renderFlipTextElement(parent_1, canvas, textWrapper, options.flip, options.flipMode, true);
            }
            else if (element instanceof PathElement || element instanceof ImageElement || (element instanceof TextElement
                && !element.position) || element instanceof DiagramElement) {
                transform = renderer.renderFlipElement(parent_1, canvas, options.flip, true);
            }
            //To set the translate and scale for the diagram elements while print and export.
            if (transform && transform.transform) {
                // Parse and apply the transform directly
                var transformRegex = /(translate|scale|rotate)\(([^)]+)\)/g;
                var match = void 0;
                // eslint-disable-next-line no-cond-assign
                while ((match = transformRegex.exec(transform.transform)) !== null) {
                    var type = match[1]; // translate, scale, rotate
                    var values = match[2].split(',').map(function (v) { return parseFloat(v.trim()); });
                    switch (type) {
                        case 'translate': {
                            var tx = values[0] || 0;
                            var ty = values[1] || 0;
                            ctx.translate(tx, ty);
                            break;
                        }
                        case 'scale': {
                            var sx = values[0] || 1;
                            var sy = values[1] || sx; // Use uniform scaling if sy is not specified
                            ctx.scale(sx, sy);
                            break;
                        }
                    }
                }
            }
        }
        this.rotateContext(canvas, options.angle, pivotX, pivotY);
    };
    CanvasRenderer.prototype.loadImage = function (ctx, obj, canvas, pivotX, pivotY) {
        // 919944: Image Node Flip and Rotation Not Applied in Exported Image
        var image = new Image();
        image.src = obj.source;
        this.image(ctx, image, obj.x, obj.y, obj.width, obj.height, obj);
    };
    /**
     * Draw the image element for the diagram\
     *
     *  @returns {void} Draw the image element for the diagram .
     *  @param { SVGElement | HTMLCanvasElement} canvas - Provide the SVG element .
     *  @param {ImageAttributes} obj - Provide the image attributes .
     *  @param {SVGSVGElement} parentSvg - Provide the parent SVG element .
     *  @param {boolean} fromPalette - Provide the pointer event value .
     *  @param {any} renderer - provide renderer value
     *  @param {ImageElement} element - provide image element
     *  @private
     */
    CanvasRenderer.prototype.drawImage = function (canvas, obj, parentSvg, fromPalette, renderer, element) {
        var _this = this;
        if (obj.visible) {
            var ctx_1 = CanvasRenderer.getContext(canvas);
            ctx_1.save();
            var pivotX_1 = obj.x + obj.width * obj.pivotX;
            var pivotY_1 = obj.y + obj.height * obj.pivotY;
            var imageObj = new Image();
            imageObj.src = obj.source;
            // 919867: Opacity for the image node is not applied to the exported image
            this.setStyle(canvas, obj);
            var id = ctx_1.canvas.id.split('_');
            // eslint-disable-next-line
            var value = id[id.length - 1] === ('diagram' ) ? true : false;
            // eslint-disable-next-line
            /**
             *  Since Clipping portion for node with slice option is not calculated properly
             * if (obj.sourceX !== undefined && obj.sourceY !== undefined && obj.sourceWidth !== undefined
             *  && obj.sourceHeight !== undefined) {
             *  ctx.drawImage(imageObj, obj.sourceX, obj.sourceY, obj.sourceWidth, obj.sourceHeight, obj.x, obj.y, obj.width, obj.height);
             *  } else {
             *             ctx.drawImage(imageObj, obj.x, obj.y, obj.width, obj.height);
             * }
             */
            // 919944: Image Node Flip and Rotation Not Applied in Exported Image
            this.applyFlipAndRotate(ctx_1, obj, canvas, pivotX_1, pivotY_1, renderer, element);
            if (!fromPalette) {
                this.loadImage(ctx_1, obj, canvas, pivotX_1, pivotY_1);
            }
            else {
                imageObj.onload = function () {
                    _this.loadImage(ctx_1, obj, canvas, pivotX_1, pivotY_1);
                };
            }
            ctx_1.restore();
        }
    };
    CanvasRenderer.prototype.image = function (ctx, image, x, y, width, height, alignOptions) {
        ctx.beginPath();
        var srcWidth = image.width;
        var srcHeight = image.height;
        var destinationW = width;
        var destinationH = height;
        var resultWidth = 0;
        var resultHeight = 0;
        if (alignOptions && alignOptions.alignment !== 'None') {
            var xalign = alignOptions.alignment.toLowerCase().substr(1, 3);
            var yalign = alignOptions.alignment.toLowerCase().substr(5, 3);
            if (alignOptions.scale === 'Slice') {
                // eslint-disable-next-line
                var a = function () {
                    resultWidth = destinationW;
                    resultHeight = srcHeight * destinationW / srcWidth;
                };
                // eslint-disable-next-line
                var b = function () {
                    resultWidth = srcWidth * destinationH / srcHeight;
                    resultHeight = destinationH;
                };
                if (destinationW > destinationH) {
                    a();
                    if (destinationH > resultHeight) {
                        b();
                    }
                }
                else if (destinationW === destinationH) {
                    if (srcWidth > srcHeight) {
                        b();
                    }
                    else {
                        a();
                    }
                }
                else {
                    b();
                    if (destinationW > resultWidth) {
                        a();
                    }
                }
                var x1 = this.getSliceOffset(xalign, resultWidth, destinationW, srcWidth);
                var y1 = this.getSliceOffset(yalign, resultHeight, destinationH, srcHeight);
                var sWidth = srcWidth - x1;
                var sHeight = srcHeight - y1;
                var dWidth = resultWidth - (x1 * (resultWidth / srcWidth));
                var dHeight = resultHeight - (y1 * (resultHeight / srcHeight));
                var canvas1 = createHtmlElement('canvas', { 'width': width.toString(), 'height': height.toString() });
                var ctx1 = canvas1.getContext('2d');
                ctx1.drawImage(image, x1, y1, sWidth, sHeight, 0, 0, dWidth, dHeight);
                ctx.drawImage(canvas1, x, y, width, height);
            }
            else if (alignOptions.scale === 'Meet') {
                var srcRatio = (srcHeight / srcWidth);
                var destRatio = (destinationH / destinationW);
                resultWidth = destRatio > srcRatio ? destinationW : destinationH / srcRatio;
                resultHeight = destRatio > srcRatio ? destinationW * srcRatio : destinationH;
                x += this.getMeetOffset(xalign, resultWidth, destinationW);
                y += this.getMeetOffset(yalign, resultHeight, destinationH);
                ctx.drawImage(image, 0, 0, srcWidth, srcHeight, x, y, resultWidth, resultHeight);
            }
            else {
                ctx.drawImage(image, x, y, width, height);
            }
        }
        else {
            ctx.drawImage(image, x, y, width, height);
        }
        ctx.closePath();
    };
    CanvasRenderer.prototype.getSliceOffset = function (arg, res, dest, src) {
        switch (arg) {
            case 'min': return 0;
            case 'mid': return (res - dest) / 2 * src / res;
            case 'max': return (res - dest) * src / res;
            default: return 0;
        }
    };
    CanvasRenderer.prototype.getMeetOffset = function (arg, res, dest) {
        var max = Math.max(res, dest);
        var min = Math.min(res, dest);
        switch (arg) {
            case 'min': return 0;
            case 'mid': return (max - min) / 2;
            case 'max': return max - min;
            default: return 0;
        }
    };
    //end region
    // vector magnitude
    CanvasRenderer.prototype.m = function (v) { return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2)); };
    // ratio between two vectors
    CanvasRenderer.prototype.r = function (u, v) { return (u[0] * v[0] + u[1] * v[1]) / (this.m(u) * this.m(v)); };
    // angle between two vectors
    CanvasRenderer.prototype.a = function (u, v) { return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(this.r(u, v)); };
    // text utility
    /**
     * Draw the SVG label.\
     *
     * @returns {PointModel} Draw the SVG label .
     *  @param {TextAttributes} text - Provide the canvas element .
     *  @param {Object} wrapBounds - Provide the canvas element .
     *  @param {SubTextElement []} childNodes - Provide the canvas element .
     * @private
     */
    CanvasRenderer.prototype.labelAlign = function (text, wrapBounds, childNodes) {
        var bounds = new Size(wrapBounds.width, childNodes.length * (text.fontSize * 1.2));
        var position = { x: 0, y: 0 };
        var labelX = text.x;
        var labelY = text.y;
        var offsetx = text.width * 0.5;
        var offsety = text.height * 0.5;
        var pointx = offsetx;
        var pointy = offsety;
        if (text.textAlign === 'left') {
            pointx = 0;
        }
        else if (text.textAlign === 'center') {
            if (wrapBounds.width > text.width && (text.textOverflow === 'Ellipsis' || text.textOverflow === 'Clip')) {
                if (text.textWrapping === 'NoWrap') {
                    pointx = 0;
                }
                else {
                    pointx = text.width * 0.5;
                }
            }
            else {
                pointx = text.width * 0.5;
            }
        }
        else if (text.textAlign === 'right') {
            pointx = (text.width * 1);
        }
        position.x = labelX + pointx + (wrapBounds ? wrapBounds.x : 0);
        position.y = labelY + pointy - bounds.height / 2;
        return position;
    };
    return CanvasRenderer;
}());

var __extends$q = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Defines the size and appearance of the diagram page
 */
var Background = /** @class */ (function (_super) {
    __extends$q(Background, _super);
    function Background() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$g([
        Property('')
    ], Background.prototype, "source", void 0);
    __decorate$g([
        Property('transparent')
    ], Background.prototype, "color", void 0);
    __decorate$g([
        Property('None')
    ], Background.prototype, "scale", void 0);
    __decorate$g([
        Property('None')
    ], Background.prototype, "align", void 0);
    return Background;
}(ChildProperty));
var FitOptions = /** @class */ (function (_super) {
    __extends$q(FitOptions, _super);
    function FitOptions() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$g([
        Property('Page')
    ], FitOptions.prototype, "mode", void 0);
    __decorate$g([
        Property('PageSettings')
    ], FitOptions.prototype, "region", void 0);
    __decorate$g([
        Complex({ top: 25, bottom: 25, left: 25, right: 25 }, Margin)
    ], FitOptions.prototype, "margin", void 0);
    __decorate$g([
        Property(false)
    ], FitOptions.prototype, "canZoomIn", void 0);
    __decorate$g([
        Property(undefined)
    ], FitOptions.prototype, "customBounds", void 0);
    __decorate$g([
        Property(false)
    ], FitOptions.prototype, "canFit", void 0);
    return FitOptions;
}(ChildProperty));
/**
 * Defines the size and appearance of diagram page
 * ```html
 * <div id='diagram'></div>
 * ```
 * ```typescript
 * let diagram: Diagram = new Diagram({
 * ...
 * pageSettings: {  width: 800, height: 600, orientation: 'Landscape',
 * background: { color: 'blue' }, boundaryConstraints: 'Infinity',
 * multiplePage: true, showPageBreaks: true, },
 * ...
 * });
 * diagram.appendTo('#diagram');
 * ```
 *
 * @default {}
 */
var PageSettings = /** @class */ (function (_super) {
    __extends$q(PageSettings, _super);
    function PageSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$g([
        Property(null)
    ], PageSettings.prototype, "width", void 0);
    __decorate$g([
        Property(null)
    ], PageSettings.prototype, "height", void 0);
    __decorate$g([
        Complex({}, Margin)
    ], PageSettings.prototype, "margin", void 0);
    __decorate$g([
        Property('Landscape')
    ], PageSettings.prototype, "orientation", void 0);
    __decorate$g([
        Property('Infinity')
    ], PageSettings.prototype, "boundaryConstraints", void 0);
    __decorate$g([
        Complex({}, Background)
    ], PageSettings.prototype, "background", void 0);
    __decorate$g([
        Property(false)
    ], PageSettings.prototype, "multiplePage", void 0);
    __decorate$g([
        Property(false)
    ], PageSettings.prototype, "showPageBreaks", void 0);
    __decorate$g([
        Complex({}, FitOptions)
    ], PageSettings.prototype, "fitOptions", void 0);
    return PageSettings;
}(ChildProperty));
/**
 * Diagram ScrollSettings module handles the scroller properties of the diagram
 */
var ScrollSettings = /** @class */ (function (_super) {
    __extends$q(ScrollSettings, _super);
    function ScrollSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$g([
        Property(0)
    ], ScrollSettings.prototype, "horizontalOffset", void 0);
    __decorate$g([
        Property(0)
    ], ScrollSettings.prototype, "verticalOffset", void 0);
    __decorate$g([
        Property(1)
    ], ScrollSettings.prototype, "currentZoom", void 0);
    __decorate$g([
        Property(0)
    ], ScrollSettings.prototype, "viewPortWidth", void 0);
    __decorate$g([
        Property(0)
    ], ScrollSettings.prototype, "viewPortHeight", void 0);
    __decorate$g([
        Property(0.2)
    ], ScrollSettings.prototype, "minZoom", void 0);
    __decorate$g([
        Property(30)
    ], ScrollSettings.prototype, "maxZoom", void 0);
    __decorate$g([
        Property('Diagram')
    ], ScrollSettings.prototype, "scrollLimit", void 0);
    __decorate$g([
        Property()
    ], ScrollSettings.prototype, "scrollableArea", void 0);
    __decorate$g([
        Property(false)
    ], ScrollSettings.prototype, "canAutoScroll", void 0);
    __decorate$g([
        Property(100)
    ], ScrollSettings.prototype, "autoScrollFrequency", void 0);
    __decorate$g([
        Complex({ left: 15, right: 15, top: 15, bottom: 15 }, Margin)
    ], ScrollSettings.prototype, "autoScrollBorder", void 0);
    __decorate$g([
        Complex({ left: 0, right: 0, top: 0, bottom: 0 }, Margin)
    ], ScrollSettings.prototype, "padding", void 0);
    __decorate$g([
        Property(0.2)
    ], ScrollSettings.prototype, "zoomFactor", void 0);
    return ScrollSettings;
}(ChildProperty));

/**
 * ServiceLocator
 *
 * @hidden
 */
var ServiceLocator = /** @class */ (function () {
    function ServiceLocator() {
        this.services = {};
    }
    ServiceLocator.prototype.register = function (name, type) {
        this.services["" + name] = type;
    };
    ServiceLocator.prototype.getService = function (name) {
        return this.services["" + name];
    };
    return ServiceLocator;
}());

var __extends$r = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Provides a visual guidance while dragging or arranging the objects on the Diagram surface
 */
var Gridlines = /** @class */ (function (_super) {
    __extends$r(Gridlines, _super);
    function Gridlines() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$h([
        Property('lightgray')
    ], Gridlines.prototype, "lineColor", void 0);
    __decorate$h([
        Property('')
    ], Gridlines.prototype, "lineDashArray", void 0);
    __decorate$h([
        Property([1.25, 18.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75, 0.25, 19.75])
    ], Gridlines.prototype, "lineIntervals", void 0);
    __decorate$h([
        Property([1, 19, 0.5, 19.5, 0.5, 19.5, 0.5, 19.5, 0.5, 19.5])
    ], Gridlines.prototype, "dotIntervals", void 0);
    __decorate$h([
        Property([20])
    ], Gridlines.prototype, "snapIntervals", void 0);
    return Gridlines;
}(ChildProperty));
/**
 * Defines the gridlines and defines how and when the objects have to be snapped
 *
 * @default {}
 */
var SnapSettings = /** @class */ (function (_super) {
    __extends$r(SnapSettings, _super);
    function SnapSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$h([
        Complex({}, Gridlines)
    ], SnapSettings.prototype, "horizontalGridlines", void 0);
    __decorate$h([
        Complex({}, Gridlines)
    ], SnapSettings.prototype, "verticalGridlines", void 0);
    __decorate$h([
        Property(SnapConstraints.All)
    ], SnapSettings.prototype, "constraints", void 0);
    __decorate$h([
        Property(5)
    ], SnapSettings.prototype, "snapAngle", void 0);
    __decorate$h([
        Property('Lines')
    ], SnapSettings.prototype, "gridType", void 0);
    __decorate$h([
        Property(5)
    ], SnapSettings.prototype, "snapObjectDistance", void 0);
    __decorate$h([
        Property('#07EDE1')
    ], SnapSettings.prototype, "snapLineColor", void 0);
    return SnapSettings;
}(ChildProperty));

var __extends$s = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Defines the properties of both horizontal and vertical guides/rulers to measure the diagram area.
 */
var DiagramRuler = /** @class */ (function (_super) {
    __extends$s(DiagramRuler, _super);
    function DiagramRuler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$i([
        Property(5)
    ], DiagramRuler.prototype, "interval", void 0);
    __decorate$i([
        Property(100)
    ], DiagramRuler.prototype, "segmentWidth", void 0);
    __decorate$i([
        Property('Horizontal')
    ], DiagramRuler.prototype, "orientation", void 0);
    __decorate$i([
        Property('RightOrBottom')
    ], DiagramRuler.prototype, "tickAlignment", void 0);
    __decorate$i([
        Property('red')
    ], DiagramRuler.prototype, "markerColor", void 0);
    __decorate$i([
        Property(25)
    ], DiagramRuler.prototype, "thickness", void 0);
    __decorate$i([
        Property(null)
    ], DiagramRuler.prototype, "arrangeTick", void 0);
    return DiagramRuler;
}(ChildProperty));
/**
 * Defines the ruler settings of diagram
 * ```html
 * <div id='diagram'></div>
 * ```
 * ```typescript
 * let diagram: Diagram = new Diagram({
 * ...
 * rulerSettings: { showRulers: true,
 * horizontalRuler: { segmentWidth: 50,interval: 10 },
 * verticalRuler: {segmentWidth: 200,interval: 20}
 * },
 * ...
 * });
 * diagram.appendTo('#diagram');
 * ```
 *
 * @default {}
 */
var RulerSettings = /** @class */ (function (_super) {
    __extends$s(RulerSettings, _super);
    function RulerSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$i([
        Property(false)
    ], RulerSettings.prototype, "showRulers", void 0);
    __decorate$i([
        Property(true)
    ], RulerSettings.prototype, "dynamicGrid", void 0);
    __decorate$i([
        Complex({ orientation: 'Horizontal' }, DiagramRuler)
    ], RulerSettings.prototype, "horizontalRuler", void 0);
    __decorate$i([
        Complex({ orientation: 'Vertical' }, DiagramRuler)
    ], RulerSettings.prototype, "verticalRuler", void 0);
    return RulerSettings;
}(ChildProperty));

var __extends$t = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * A collection of JSON objects where each object represents a layer.
 * Layer is a named category of diagram shapes.
 */
var DataMappingItems = /** @class */ (function (_super) {
    __extends$t(DataMappingItems, _super);
    function DataMappingItems() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$j([
        Property('')
    ], DataMappingItems.prototype, "property", void 0);
    __decorate$j([
        Property('')
    ], DataMappingItems.prototype, "field", void 0);
    return DataMappingItems;
}(ChildProperty));

var __extends$u = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Configures the data source that is to be bound with diagram
 * ```html
 * <div id='diagram'></div>
 * ```
 * ```typescript
 * let data: object[] = [
 * { Name: "Elizabeth", Role: "Director" },
 * { Name: "Christina", ReportingPerson: "Elizabeth", Role: "Manager" },
 * { Name: "Yoshi", ReportingPerson: "Christina", Role: "Lead" },
 * { Name: "Philip", ReportingPerson: "Christina", Role: "Lead" },
 * { Name: "Yang", ReportingPerson: "Elizabeth", Role: "Manager" },
 * { Name: "Roland", ReportingPerson: "Yang", Role: "Lead" },
 * { Name: "Yvonne", ReportingPerson: "Yang", Role: "Lead" }
 * ];
 * let items: DataManager = new DataManager(data as JSON[]);
 * let diagram: Diagram = new Diagram({
 * ...
 * layout: {
 *             type: 'OrganizationalChart'
 * },
 * dataSourceSettings: {
 * id: 'Name', parentId: 'ReportingPerson', dataManager: items,
 * }
 * ...
 * });
 * diagram.appendTo('#diagram');
 * ```
 */
var CrudAction = /** @class */ (function (_super) {
    __extends$u(CrudAction, _super);
    function CrudAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$k([
        Property('')
    ], CrudAction.prototype, "read", void 0);
    __decorate$k([
        Property('')
    ], CrudAction.prototype, "create", void 0);
    __decorate$k([
        Property('')
    ], CrudAction.prototype, "update", void 0);
    __decorate$k([
        Property('')
    ], CrudAction.prototype, "destroy", void 0);
    __decorate$k([
        Property()
    ], CrudAction.prototype, "customFields", void 0);
    return CrudAction;
}(ChildProperty));
var ConnectionDataSource = /** @class */ (function (_super) {
    __extends$u(ConnectionDataSource, _super);
    function ConnectionDataSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$k([
        Property('')
    ], ConnectionDataSource.prototype, "id", void 0);
    __decorate$k([
        Property('')
    ], ConnectionDataSource.prototype, "sourceID", void 0);
    __decorate$k([
        Property('')
    ], ConnectionDataSource.prototype, "targetID", void 0);
    __decorate$k([
        Property(null)
    ], ConnectionDataSource.prototype, "sourcePointX", void 0);
    __decorate$k([
        Property(null)
    ], ConnectionDataSource.prototype, "sourcePointY", void 0);
    __decorate$k([
        Property(null)
    ], ConnectionDataSource.prototype, "targetPointX", void 0);
    __decorate$k([
        Property(null)
    ], ConnectionDataSource.prototype, "targetPointY", void 0);
    __decorate$k([
        Property(null)
    ], ConnectionDataSource.prototype, "dataManager", void 0);
    __decorate$k([
        Complex({}, CrudAction)
    ], ConnectionDataSource.prototype, "crudAction", void 0);
    return ConnectionDataSource;
}(ChildProperty));
var DataSource = /** @class */ (function (_super) {
    __extends$u(DataSource, _super);
    function DataSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$k([
        Property('')
    ], DataSource.prototype, "id", void 0);
    __decorate$k([
        Property(null)
    ], DataSource.prototype, "dataManager", void 0);
    __decorate$k([
        Property(null)
    ], DataSource.prototype, "dataSource", void 0);
    __decorate$k([
        Property('')
    ], DataSource.prototype, "root", void 0);
    __decorate$k([
        Property('')
    ], DataSource.prototype, "parentId", void 0);
    __decorate$k([
        Property()
    ], DataSource.prototype, "doBinding", void 0);
    __decorate$k([
        Collection([], DataMappingItems)
    ], DataSource.prototype, "dataMapSettings", void 0);
    __decorate$k([
        Complex({}, CrudAction)
    ], DataSource.prototype, "crudAction", void 0);
    __decorate$k([
        Complex({}, ConnectionDataSource)
    ], DataSource.prototype, "connectionDataSource", void 0);
    return DataSource;
}(ChildProperty));

var __extends$v = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Defines the configuration settings for flowchart automatic layout
 */
var FlowchartLayoutSettings = /** @class */ (function (_super) {
    __extends$v(FlowchartLayoutSettings, _super);
    function FlowchartLayoutSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$l([
        Property('LeftInFlow')
    ], FlowchartLayoutSettings.prototype, "yesBranchDirection", void 0);
    __decorate$l([
        Property('RightInFlow')
    ], FlowchartLayoutSettings.prototype, "noBranchDirection", void 0);
    __decorate$l([
        Property(['Yes', 'True'])
    ], FlowchartLayoutSettings.prototype, "yesBranchValues", void 0);
    __decorate$l([
        Property(['No', 'False'])
    ], FlowchartLayoutSettings.prototype, "noBranchValues", void 0);
    return FlowchartLayoutSettings;
}(ChildProperty));
/**
 * Defines the behavior of the automatic layouts
 */
var Layout = /** @class */ (function (_super) {
    __extends$v(Layout, _super);
    function Layout() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$l([
        Property('')
    ], Layout.prototype, "fixedNode", void 0);
    __decorate$l([
        Property(30)
    ], Layout.prototype, "horizontalSpacing", void 0);
    __decorate$l([
        Property('SamePoint')
    ], Layout.prototype, "connectionPointOrigin", void 0);
    __decorate$l([
        Property('Nonlinear')
    ], Layout.prototype, "arrangement", void 0);
    __decorate$l([
        Property(30)
    ], Layout.prototype, "verticalSpacing", void 0);
    __decorate$l([
        Property(30)
    ], Layout.prototype, "maxIteration", void 0);
    __decorate$l([
        Property(40)
    ], Layout.prototype, "springFactor", void 0);
    __decorate$l([
        Property(50)
    ], Layout.prototype, "springLength", void 0);
    __decorate$l([
        Complex({ left: 50, top: 50, right: 0, bottom: 0 }, Margin)
    ], Layout.prototype, "margin", void 0);
    __decorate$l([
        Property('Auto')
    ], Layout.prototype, "horizontalAlignment", void 0);
    __decorate$l([
        Property('Auto')
    ], Layout.prototype, "verticalAlignment", void 0);
    __decorate$l([
        Property('TopToBottom')
    ], Layout.prototype, "orientation", void 0);
    __decorate$l([
        Property('Auto')
    ], Layout.prototype, "connectionDirection", void 0);
    __decorate$l([
        Property('Default')
    ], Layout.prototype, "connectorSegments", void 0);
    __decorate$l([
        Property('None')
    ], Layout.prototype, "type", void 0);
    __decorate$l([
        Property()
    ], Layout.prototype, "getLayoutInfo", void 0);
    __decorate$l([
        Property()
    ], Layout.prototype, "layoutInfo", void 0);
    __decorate$l([
        Property()
    ], Layout.prototype, "getBranch", void 0);
    __decorate$l([
        Property()
    ], Layout.prototype, "bounds", void 0);
    __decorate$l([
        Property(true)
    ], Layout.prototype, "enableAnimation", void 0);
    __decorate$l([
        Property(false)
    ], Layout.prototype, "enableRouting", void 0);
    __decorate$l([
        Property('')
    ], Layout.prototype, "root", void 0);
    __decorate$l([
        Complex({}, FlowchartLayoutSettings)
    ], Layout.prototype, "flowchartLayoutSettings", void 0);
    return Layout;
}(ChildProperty));

var __extends$w = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Multiple segments editing for Connector
 */
var ConnectorEditing = /** @class */ (function (_super) {
    __extends$w(ConnectorEditing, _super);
    function ConnectorEditing(commandHandler, endPoint) {
        var _this = _super.call(this, commandHandler, true) || this;
        _this.oldValue = null;
        _this.endPoint = endPoint;
        return _this;
    }
    /**
     * mouseDown method\
     *
     * @returns {  void }    mouseDown method .\
     * @param {MouseEventArgs} args - provide the args value.
     * @private
     */
    ConnectorEditing.prototype.mouseDown = function (args) {
        var connectors;
        var edit = true;
        if (args.source && args.source.connectors) {
            connectors = args.source.connectors[0];
        }
        if (args.info && args.actualObject) {
            edit = args.info.ctrlKey && args.actualObject.type !== 'Orthogonal';
        }
        if (connectors && edit) {
            this.inAction = true;
            this.undoElement = cloneObject(args.source);
            _super.prototype.mouseDown.call(this, args);
            // 927583: Segment points cannot be dragged when the pointer is in the outer part of the segmentThumb
            var inheritSegmentThumbSize = (connectors.constraints & ConnectorConstraints.InheritSegmentThumbSize);
            var segmentThumbSize = inheritSegmentThumbSize ?
                this.commandHandler.diagram.segmentThumbSize : connectors.segmentThumbSize;
            var padding = (segmentThumbSize > 20) && connectors.type !== 'Straight' ? segmentThumbSize / 2 : 10;
            padding = padding / this.commandHandler.diagram.scrollSettings.currentZoom;
            // Sets the selected segment
            for (var i = 0; i < connectors.segments.length; i++) {
                var segment = connectors.segments[parseInt(i.toString(), 10)];
                if (this.endPoint === 'OrthoThumb') {
                    for (var j = 0; j < segment.points.length - 1; j++) {
                        var segPoint = { x: 0, y: 0 };
                        segPoint.x = ((segment.points[parseInt(j.toString(), 10)].x + segment.points[j + 1].x) / 2);
                        segPoint.y = ((segment.points[parseInt(j.toString(), 10)].y + segment.points[j + 1].y) / 2);
                        if (contains(this.currentPosition, segPoint, padding)) {
                            this.selectedSegment = segment;
                            this.segmentIndex = j;
                        }
                    }
                }
                else {
                    if (contains(this.currentPosition, segment.point, padding)) {
                        this.selectedSegment = segment;
                    }
                }
            }
        }
    };
    /**
     * mouseMove method\
     *
     * @returns {  void }    mouseMove method .\
     * @param {MouseEventArgs} args - provide the args value.
     * @private
     */
    ConnectorEditing.prototype.mouseMove = function (args) {
        _super.prototype.mouseMove.call(this, args);
        this.currentPosition = args.position;
        if (this.currentPosition && this.prevPosition) {
            var diffY = this.currentPosition.y - this.prevPosition.y;
            var diffX = this.currentPosition.x - this.prevPosition.x;
            this.currentPosition = this.commandHandler.snapConnectorEnd(this.currentPosition);
            var connector = void 0;
            var newValue = void 0;
            var isSame = false;
            if (args.source && args.source.connectors) {
                connector = args.source.connectors[0];
            }
            if (Point.equals(this.startPosition, this.prevPosition)) {
                isSame = true;
            }
            if (this.oldValue === null) {
                this.oldValue = cloneObject(this.selectedSegment);
            }
            var arg = {
                source: connector, state: 'Start', oldValue: this.oldValue, newValue: this.oldValue,
                segment: this.selectedSegment, cancel: false
            };
            //EJ2-66217 - Support to add event for segment points editing in connector.
            arg = {
                source: cloneBlazorObject(connector), state: 'Start', oldValue: cloneBlazorObject(this.oldValue),
                newValue: cloneBlazorObject(this.oldValue),
                segment: cloneBlazorObject(this.selectedSegment), cancel: false
            };
            if (isSame && !isBlazor()) {
                this.commandHandler.triggerEvent(DiagramEvent.segmentChange, arg);
            }
            // When cancel is set to true at state Start, the segment change will be prevented.
            if (arg.cancel) {
                this.commandHandler.diagram.resetTool();
            }
            if ((this.inAction && this.selectedSegment !== undefined && this.endPoint !== undefined)
                && (diffX !== 0 || diffY !== 0) && !arg.cancel) {
                if (this.endPoint === 'OrthoThumb') {
                    this.blocked = !this.dragOrthogonalSegment(connector, this.selectedSegment, this.currentPosition, this.segmentIndex);
                    if (this.oldValue.length === null && this.oldValue.direction === null) {
                        this.oldValue = cloneObject(this.selectedSegment);
                    }
                    newValue = cloneObject(this.selectedSegment);
                }
                else {
                    var tx = this.currentPosition.x - this.selectedSegment.point.x;
                    var ty = this.currentPosition.y - this.selectedSegment.point.y;
                    var index = connector.segments.indexOf(this.selectedSegment);
                    this.blocked = !this.commandHandler.dragControlPoint(connector, tx, ty, false, index);
                    newValue = cloneObject(this.selectedSegment);
                }
                this.commandHandler.updateSelector();
                this.currentPosition = args.position;
                var arg1 = {
                    source: cloneBlazorObject(connector), state: 'Progress', oldValue: cloneBlazorObject(this.oldValue),
                    newValue: cloneBlazorObject(newValue),
                    segment: cloneBlazorObject(this.selectedSegment), cancel: false
                };
                this.commandHandler.triggerEvent(DiagramEvent.segmentChange, arg1);
            }
        }
        this.prevPosition = this.currentPosition;
        return !this.blocked;
    };
    /**
     * mouseUp method\
     *
     * @returns {  void }    mouseUp method .\
     * @param {MouseEventArgs} args - provide the args value.
     * @private
     */
    ConnectorEditing.prototype.mouseUp = function (args) {
        var connector;
        var oldValues;
        if (args.source && args.source.connectors) {
            connector = args.source.connectors[0];
            oldValues = { segments: connector.segments };
        }
        if (args && args.source && args.info && args.info.ctrlKey && args.info.shiftKey && connector.type === 'Straight') {
            this.addOrRemoveSegment(connector, this.currentPosition);
        }
        else {
            if (this.endPoint === 'OrthoThumb' && this.selectedSegment) {
                var index = connector.segments.indexOf(this.selectedSegment);
                var prev = connector.segments[index - 1];
                var next = connector.segments[index + 1];
                if (index === connector.segments.length - 2
                    && this.updateLastSegment(connector, this.selectedSegment)) {
                    connector.segments.splice(connector.segments.length - 2, 1);
                }
                else {
                    //Bug 853404: Exception occurs while adjusting the connector segment.
                    if (prev && Math.abs(prev.length) < 5 && prev.length > 0) {
                        if (index !== 1) {
                            this.removePrevSegment(connector, index);
                        }
                    }
                    else if (next) {
                        var len = Point.distancePoints(next.points[0], next.points[1]);
                        var length_1 = ((next.length || next.length === 0) ? next.length : len);
                        if ((Math.abs(length_1) <= 5)) {
                            this.removeNextSegment(connector, index);
                        }
                    }
                }
                this.commandHandler.updateEndPoint(connector, oldValues);
                // EJ2-65063 - While mouseUp set the selectedSegmentIndex as zero.
                connector.selectedSegmentIndex = 0;
            }
        }
        if (this.undoElement) {
            //let obj: SelectorModel;
            var obj = cloneObject(args.source);
            var entry = {
                type: 'SegmentChanged', redoObject: obj, undoObject: this.undoElement, category: 'Internal'
            };
            this.commandHandler.addHistoryEntry(entry);
        }
        if (connector.isBezierEditing) {
            connector.isBezierEditing = false;
        }
        if (this.prevPosition !== this.startPosition) {
            var arg = {
                source: cloneBlazorObject(connector), state: 'Completed', oldValue: cloneBlazorObject(this.oldValue),
                newValue: cloneObject(this.selectedSegment), cancel: false, segment: cloneBlazorObject(this.selectedSegment)
            };
            this.commandHandler.triggerEvent(DiagramEvent.segmentChange, arg);
        }
        _super.prototype.mouseUp.call(this, args);
    };
    ConnectorEditing.prototype.removePrevSegment = function (connector, index) {
        var first = connector.segments[index - 2];
        var next = connector.segments[index + 1];
        //Bug 905092: Exception through while dragging segment and reverted back to its original position.
        //Added next condition to check the next segment is not null.
        if (next) {
            var length_2 = (next.length || next.length === 0) ? next.length : Point.distancePoints(next.points[0], next.points[1]);
            if (!(length_2 <= 5)) {
                var removeSegments = connector.segments.slice(index - 1, index + 1);
                var args = {
                    element: connector, removeSegments: removeSegments, type: 'Removal', cancel: false
                };
                //Removed isBlazor code
                this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);
                if (!args.cancel) {
                    var last = connector.segments[index + 1];
                    connector.segments.splice(index - 1, 2);
                    var segment = this.selectedSegment;
                    if (segment.direction === 'Left' || segment.direction === 'Right') {
                        first.points[first.points.length - 1].x = last.points[0].x;
                        last.points[0].y = first.points[first.points.length - 1].y;
                    }
                    else {
                        first.points[first.points.length - 1].y = last.points[0].y;
                        last.points[0].x = first.points[first.points.length - 1].x;
                    }
                    if (segment.length || segment.length === 0) {
                        this.findSegmentDirection(first);
                    }
                    this.findSegmentDirection(last);
                }
            }
        }
    };
    ConnectorEditing.prototype.findSegmentDirection = function (segment) {
        if (segment.direction && (segment.length || segment.length === 0)) {
            segment.length = Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);
            segment.direction = Point.direction(segment.points[0], segment.points[segment.points.length - 1]);
        }
    };
    ConnectorEditing.prototype.removeNextSegment = function (connector, index) {
        var segment = this.selectedSegment;
        var first = connector.segments[index - 1];
        var last = connector.segments[index + 2];
        var next = connector.segments[index + 1];
        // eslint-disable-next-line
        var removeSegments;
        var args;
        if (next.length || next.length === 0) {
            removeSegments = connector.segments.slice(index, 2);
            args = {
                element: connector, removeSegments: removeSegments, type: 'Removal', cancel: false
            };
            args = {
                element: cloneBlazorObject(connector), removeSegments: cloneBlazorObject(removeSegments),
                type: 'Removal', cancel: false
            };
            //Removed isBlazor code
            this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);
            if (!args.cancel) {
                connector.segments.splice(index, 2);
                if (segment.direction === 'Top' || segment.direction === 'Bottom') {
                    last.points[0].y = segment.points[0].y;
                    first.points[first.points.length - 1].x = last.points[0].x;
                }
                else {
                    last.points[0].x = segment.points[0].x;
                    first.points[first.points.length - 1].y = last.points[0].y;
                }
            }
        }
        else {
            removeSegments = connector.segments.slice(index + 1, 1);
            args = {
                element: connector, removeSegments: removeSegments, type: 'Removal', cancel: false
            };
            //Removed isBlazor code
            this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);
            if (!args.cancel) {
                connector.segments.splice(index + 1, 1);
                if (segment.direction === 'Top' || segment.direction === 'Bottom') {
                    first.points[first.points.length - 1].x = next.points[next.points.length - 1].x;
                }
                else {
                    first.points[first.points.length - 1].y = next.points[next.points.length - 1].y;
                }
                this.findSegmentDirection(first);
                segment.length = segment.direction = null;
            }
        }
        if (first && last && !args.cancel) {
            first.length = Point.distancePoints(first.points[0], last.points[0]);
            first.direction = Point.direction(first.points[0], last.points[0]);
            if (last.length || last.length === 0) {
                last.length = Point.distancePoints(first.points[first.points.length - 1], last.points[last.points.length - 1]);
                var point1 = first.points;
                var point2 = last.points;
                last.direction = Point.direction(point1[point1.length - 1], point2[point2.length - 1]);
            }
        }
    };
    /**
     * addOrRemoveSegment method Used to add or remove intermediate segments to the straight connector. \
     *
     * @returns {void} addOrRemoveSegment method Used to add or remove intermediate segments to the straight connector.
     * @param {ConnectorModel} connector - provide the connector value in which segment to be added/removed.
     * @param {PointModel} point - provide the mouse clicked position as a point of the segment
     * @param {CommandHandler} commandHandler - provide the CommandHandler value that defines the behavior of commands
     * @private
     */
    ConnectorEditing.prototype.addOrRemoveSegment = function (connector, point, commandHandler) {
        var updateSeg;
        var segmentIndex;
        var segmentsChanged = [];
        var oldValues = { segments: connector.segments };
        for (var i = 0; i < connector.segments.length; i++) {
            var segment = (connector.segments)[parseInt(i.toString(), 10)];
            if (contains(point, segment.point, connector.hitPadding)) {
                segmentIndex = i;
                updateSeg = true;
                //848696-Trigger SegmentCollectionChange Event for straight connector
                segmentsChanged.push(segment);
                var args = {
                    element: connector, removeSegments: segmentsChanged, type: 'Removal', cancel: false
                };
                if (commandHandler) {
                    commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);
                }
            }
        }
        //827745-support to edit Segment for Straight connector at runtime
        if (!this.commandHandler) {
            this.commandHandler = commandHandler;
        }
        if (updateSeg && segmentIndex !== undefined) {
            if (connector.segments && connector.segments[parseInt(segmentIndex.toString(), 10)] && connector.segments[parseInt(segmentIndex.toString(), 10)].type === 'Straight') {
                var segment = connector.segments[parseInt(segmentIndex.toString(), 10)];
                var previous = connector.segments[segmentIndex + 1];
                if (previous) {
                    connector.segments.splice(segmentIndex, 1);
                    previous.points[0] = segment.points[0];
                }
            }
        }
        else {
            this.commandHandler.enableServerDataBinding(false);
            var index = this.findIndex(connector, point);
            if (connector.segments && connector.segments[parseInt(index.toString(), 10)] && connector.segments[parseInt(index.toString(), 10)].type === 'Straight') {
                var segment = connector.segments[parseInt(index.toString(), 10)];
                var newseg = new StraightSegment(connector, 'segments', { type: 'Straight', point: point }, true);
                newseg.points[0] = segment.points[0];
                newseg.points[1] = point;
                segment.points[0] = point;
                connector.segments.splice(index, 0, newseg);
                updateSeg = true;
                //848696-Trigger SegmentCollectionchange Event for straight connector
                segmentsChanged.push(segment);
                var args = {
                    element: connector, addSegments: segmentsChanged, type: 'Addition', cancel: false
                };
                this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);
            }
            this.commandHandler.enableServerDataBinding(true);
        }
        if (updateSeg) {
            this.commandHandler.updateEndPoint(connector, oldValues);
        }
    };
    ConnectorEditing.prototype.findIndex = function (connector, point) {
        var intersectingSegs = [];
        for (var i = 0; i < connector.segments.length; i++) {
            var segment = connector.segments[parseInt(i.toString(), 10)];
            var rect = Rect.toBounds([segment.points[0], segment.points[1]]);
            rect.Inflate(connector.hitPadding);
            if (rect.containsPoint(point)) {
                intersectingSegs.push(segment);
            }
        }
        if (intersectingSegs.length === 1) {
            return connector.segments.indexOf(intersectingSegs[0]);
        }
        else {
            var ratio = void 0;
            var min = void 0;
            var index = void 0;
            var seg = void 0;
            var v = void 0;
            var h = void 0;
            for (var i = 0; i < intersectingSegs.length; i++) {
                seg = intersectingSegs[parseInt(i.toString(), 10)];
                v = (point.y - seg.points[0].y) / (seg.points[1].y - point.y);
                h = (point.x - seg.points[0].x) / (seg.points[1].x - point.x);
                ratio = Math.abs(v - h);
                if (i === 0) {
                    min = ratio;
                    index = 0;
                }
                if (ratio < min) {
                    min = ratio;
                    index = i;
                }
            }
            return connector.segments.indexOf(intersectingSegs[parseInt(index.toString(), 10)]);
        }
    };
    ConnectorEditing.prototype.dragOrthogonalSegment = function (obj, segment, point, segmentIndex) {
        var segmentPoint = { x: 0, y: 0 };
        var oldValues = { segments: obj.segments };
        segmentPoint.x = ((segment.points[parseInt(segmentIndex.toString(), 10)].x + segment.points[segmentIndex + 1].x) / 2);
        segmentPoint.y = ((segment.points[parseInt(segmentIndex.toString(), 10)].y + segment.points[segmentIndex + 1].y) / 2);
        var ty = point.y - segmentPoint.y;
        var tx = point.x - segmentPoint.x;
        var index = obj.segments.indexOf(segment);
        var update = false;
        //const orientation: string = (segment.points[0].y.toFixed(2) === segment.points[1].y.toFixed(2)) ? 'horizontal' : 'vertical';
        //const prevSegment: OrthogonalSegmentModel; const nextSegment: OrthogonalSegmentModel;
        // EJ2-65063 - If the allowNodeOverlap is set as true means then we set the segment index which is going to drag in selectedSegmentIndex property
        if (obj.allowNodeOverlap) {
            obj.selectedSegmentIndex = index ? index : segmentIndex;
        }
        if (index !== -1) {
            if (index === 0 && obj.segments.length === 1 && segment.points.length === 2) {
                index = this.addSegments(obj, segment, tx, ty, index);
                update = true;
            }
            else if (index === obj.segments.length - 1 && (segment.direction === null || segment.length === null)) {
                index = this.addTerminalSegment(obj, segment, tx, ty, segmentIndex);
                update = true;
            }
            else if (index === 0) {
                index = this.insertFirstSegment(obj, segment, tx, ty, index);
                update = true;
            }
            if (index) {
                if (update) {
                    this.selectedSegment = segment = obj.segments[parseInt(index.toString(), 10)];
                    this.segmentIndex = 0;
                }
                this.updateAdjacentSegments(obj, index, tx, ty);
                this.commandHandler.updateEndPoint(obj, oldValues);
            }
        }
        return true;
    };
    ConnectorEditing.prototype.addSegments = function (obj, segment, tx, ty, coll) {
        var index;
        var segments = []; //let len: number;
        var length = Point.distancePoints(segment.points[0], segment.points[1]);
        var segmentDirection = Point.direction(segment.points[0], segment.points[1]);
        segments.push(new OrthogonalSegment(obj, 'segments', { type: 'Orthogonal', direction: segmentDirection, length: length / 4 }, true));
        var direction = (segment.points[0].y === segment.points[1].y) ? ((ty > 0) ? 'Bottom' : 'Top') : ((tx > 0) ? 'Right' : 'Left');
        var len = (segment.points[0].x === segment.points[1].x) ? ty : tx;
        segments.push(new OrthogonalSegment(obj, 'segments', { type: 'Orthogonal', direction: direction, length: len }, true));
        segments.push(new OrthogonalSegment(obj, 'segments', { type: 'Orthogonal', direction: segmentDirection, length: length / 2 }, true));
        var args = {
            element: obj, addSegments: segments, type: 'Addition', cancel: false
        };
        //Removed isBlazor code
        this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);
        if (!args.cancel) {
            obj.segments = segments.concat(obj.segments);
            index = coll + 2;
        }
        return index;
    };
    // eslint-disable-next-line
    ConnectorEditing.prototype.insertFirstSegment = function (obj, segment, tx, ty, coll) {
        var direction;
        var length;
        var segments = [];
        var segValues;
        var index;
        var insertseg;
        if (obj.sourcePortID && segment.length && obj.segments[0].points.length > 2) {
            var prev = void 0;
            for (var i = 0; i < segment.points.length - 1; i++) {
                var len = Point.distancePoints(segment.points[parseInt(i.toString(), 10)], segment.points[i + 1]);
                var dir = Point.direction(segment.points[parseInt(i.toString(), 10)], segment.points[i + 1]);
                insertseg = new OrthogonalSegment(obj, 'segments', { type: 'Orthogonal', direction: dir, length: len }, true);
                if (insertseg.length === 0) {
                    if (prev && (prev.direction === 'Top' || prev.direction === 'Bottom')) {
                        insertseg.direction = tx > 0 ? 'Right' : 'Left';
                    }
                    else {
                        insertseg.direction = ty > 0 ? 'Bottom' : 'Top';
                    }
                }
                prev = insertseg;
                segments.push(insertseg);
            }
        }
        else {
            segValues = { type: 'Orthogonal', direction: segment.direction, length: segment.length / 3 };
            segments.push(new OrthogonalSegment(obj, 'segments', segValues, true));
            if (segment.direction === 'Bottom' || segment.direction === 'Top') {
                length = Math.abs(tx);
                direction = tx > 0 ? 'Right' : 'Left';
            }
            else {
                length = Math.abs(ty);
                direction = ty > 0 ? 'Bottom' : 'Top';
            }
            insertseg = new OrthogonalSegment(obj, 'segments', { type: 'Orthogonal', direction: direction, length: length }, true);
            segments.push(insertseg);
        }
        var args = {
            element: obj, addSegments: segments, type: 'Addition', cancel: false
        };
        //Removed isBlazor code
        this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);
        if (!args.cancel) {
            if (obj.sourcePortID && segment.length && obj.segments[0].points.length > 2) {
                obj.segments.splice(0, 1);
                index = 1;
            }
            else {
                var nextseg = obj.segments[1];
                if (nextseg && nextseg.length) {
                    nextseg.length = (direction !== nextseg.direction) ? nextseg.length + length : nextseg.length - length;
                }
                index = 2;
                segment.length = 2 * segment.length / 3;
            }
            obj.segments = segments.concat(obj.segments);
        }
        return index;
    };
    ConnectorEditing.prototype.updateAdjacentSegments = function (obj, index, tx, ty) {
        var current = obj.segments[parseInt(index.toString(), 10)];
        var endPoint = current.points[current.points.length - 1];
        var startPoint = current.points[0];
        var isNextUpdate = true;
        if (current.type === 'Orthogonal') {
            current.points[0] = startPoint;
            current.points[current.points.length - 1] = endPoint;
            var prev = obj.segments[index - 1];
            if (prev) {
                isNextUpdate = this.updatePreviousSegment(tx, ty, obj, index);
            }
            if (obj.segments.length - 1 > index && isNextUpdate) {
                var nextSegment = obj.segments[index + 1];
                this.updateNextSegment(obj, current, nextSegment, tx, ty);
            }
        }
    };
    ConnectorEditing.prototype.addTerminalSegment = function (connector, segment, tx, ty, segmentIndex) {
        //const oldValues: Connector = { segments: connector.segments } as Connector;
        var index = connector.segments.indexOf(segment);
        var first;
        var insertseg;
        var len;
        var dir;
        var segments = [];
        var removeSegment = connector.segments.pop();
        var last = connector.segments[connector.segments.length - 1];
        first = (last && last.type === 'Orthogonal') ? last : null;
        for (var i = 0; i < segment.points.length - 2; i++) {
            len = Point.distancePoints(segment.points[parseInt(i.toString(), 10)], segment.points[i + 1]);
            dir = Point.direction(segment.points[parseInt(i.toString(), 10)], segment.points[i + 1]);
            insertseg = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal', length: len, direction: dir }, true);
            segments.push(insertseg);
            first = insertseg;
        }
        var sec = segmentIndex;
        if (segment.points.length === 2 || sec === segment.points.length - 2) {
            if (first) {
                first.length += 5;
            }
            if (sec !== undefined) {
                //let newseg: OrthogonalSegment;
                len = 2 * Point.distancePoints(segment.points[segment.points.length - 2], segment.points[segment.points.length - 1]) / 3;
                dir = Point.direction(segment.points[segment.points.length - 2], segment.points[segment.points.length - 1]);
                var newseg = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal', length: len, direction: dir });
                segments.push(newseg);
            }
        }
        var lastseg = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);
        segments.push(lastseg);
        var args = {
            element: connector, addSegments: segments, type: 'Addition', cancel: false
        };
        var args1 = {
            element: cloneBlazorObject(connector), addSegments: cloneBlazorObject(segments),
            type: 'Addition', cancel: args.cancel
        };
        //Removed isBlazor code
        this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args1);
        if (!args1.cancel) {
            connector.segments = connector.segments.concat(segments);
            index = index + segmentIndex;
        }
        else {
            connector.segments.push(removeSegment);
        }
        this.commandHandler.updateEndPoint(connector);
        return index;
    };
    // eslint-disable-next-line
    ConnectorEditing.prototype.updatePortSegment = function (prev, connector, index, tx, ty) {
        if (index === 1 && prev.points.length === 2 && prev.length < 0) {
            var source = connector.sourceWrapper.corners;
            var current = connector.segments[parseInt(index.toString(), 10)];
            var next = connector.segments[index + 1];
            var newseg = void 0;
            var segment = [];
            newseg = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal', length: 13, direction: prev.direction });
            segment.push(newseg);
            var len = void 0;
            if (current.direction === 'Left') {
                len = (current.points[0].x - (source.middleLeft.x - 20));
            }
            else if (current.direction === 'Right') {
                len = ((source.middleRight.x + 20) - current.points[0].x);
            }
            else if (current.direction === 'Bottom') {
                len = ((source.bottomCenter.y + 20) - current.points[0].y);
            }
            else {
                len = (current.points[0].y - (source.topCenter.y - 20));
            }
            //const dir: Direction = current.direction;
            newseg = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal', length: len, direction: current.direction });
            segment.push(newseg);
            current.length = current.length - len;
            if (next && next.length && next.direction) {
                if (next.direction === prev.direction) {
                    next.length -= 13;
                }
                else if (next.direction === getOppositeDirection(prev.direction)) {
                    next.length += 13;
                }
            }
            connector.segments = segment.concat(connector.segments);
            this.selectedSegment = connector.segments[3];
        }
    };
    ConnectorEditing.prototype.updatePreviousSegment = function (tx, ty, connector, index) {
        var current = connector.segments[parseInt(index.toString(), 10)];
        var prev = connector.segments[index - 1];
        //const firstSegment: boolean = (index === 1) ? true : false;
        prev.points[prev.points.length - 1] = current.points[0];
        var isSourceNode = (connector.sourceID && connector.sourcePortID === '') ? false : true;
        var isNextUpdate = true;
        if (prev.type === 'Orthogonal') {
            if (prev.direction === 'Bottom') {
                prev.length += ty;
            }
            else if (prev.direction === 'Top') {
                prev.length -= ty;
            }
            else if (prev.direction === 'Right') {
                prev.length += tx;
            }
            else {
                prev.length -= tx;
            }
            // EJ2-65063 - Added the below condition !allowNodeOverlap to prevent the segment to split into two segments while intersect with source node.
            if (connector.sourcePortID !== '' && prev.length < 0 && !connector.allowNodeOverlap) {
                this.updatePortSegment(prev, connector, index, tx, ty);
            }
            else if (connector.sourceID && connector.sourcePortID === '' && prev.length < 0 && index === 1) {
                isNextUpdate = false;
                this.updateFirstSegment(connector, current);
            }
            if (isSourceNode) {
                this.changeSegmentDirection(prev, connector);
            }
        }
        return isNextUpdate;
    };
    ConnectorEditing.prototype.changeSegmentDirection = function (segment, connector) {
        if (!connector.maxSegmentThumb) {
            if (segment.length < 0) {
                segment.direction = getOppositeDirection(segment.direction);
                segment.length *= -1;
            }
        }
    };
    ConnectorEditing.prototype.updateNextSegment = function (obj, current, next, tx, ty) {
        next.points[0] = current.points[current.points.length - 1];
        if (next && next.type === 'Orthogonal') {
            if (next.length || next.length === 0) {
                if (next.direction === 'Left' || next.direction === 'Right') {
                    if (tx !== 0) {
                        next.length = (next.direction === 'Right') ? next.length - tx : next.length + tx;
                        if (next.length || next.length === 0) {
                            this.changeSegmentDirection(next, obj);
                        }
                    }
                }
                else {
                    if (ty !== 0) {
                        next.length = (next.direction === 'Bottom') ? next.length - ty : next.length + ty;
                        if (next.length || next.length === 0) {
                            this.changeSegmentDirection(next, obj);
                        }
                    }
                }
            }
        }
    };
    ConnectorEditing.prototype.updateFirstSegment = function (connector, selectedSegment) {
        var index = connector.segments.indexOf(selectedSegment);
        var insertfirst = false;
        var current = connector.segments[parseInt(index.toString(), 10)];
        var prev = connector.segments[index - 1];
        var sourcePoint;
        var oldValues = { segments: connector.segments };
        if (prev.length < 0 && connector.sourceID) {
            var sourceNode = connector.sourceWrapper.corners;
            var segments = [];
            var segValues = void 0;
            var removeCurrentPrev = false;
            this.changeSegmentDirection(current, connector);
            var next = connector.segments[index + 1];
            var nextNext = connector.segments[index + 2];
            if (next) {
                this.changeSegmentDirection(next, connector);
            }
            if (nextNext) {
                this.changeSegmentDirection(nextNext, connector);
            }
            switch (prev.direction) {
                case 'Top':
                case 'Bottom':
                    sourcePoint = (current.length > 0 && current.direction === 'Left') ? sourceNode.middleLeft : sourceNode.middleRight;
                    if (current.length > sourceNode.width / 2) {
                        if (Math.abs(prev.length) < sourceNode.height / 2) {
                            prev.length = Point.distancePoints(sourceNode.center, prev.points[prev.points.length - 1]);
                            current.points[0].x = sourcePoint.x;
                            current.length = Point.distancePoints(current.points[0], current.points[current.points.length - 1]);
                            current.length -= 20;
                            insertfirst = true;
                        }
                    }
                    else {
                        if (next && next.direction && next.length) {
                            next.points[0].y = sourcePoint.y;
                            next.points[0].x = next.points[next.points.length - 1].x = (current.direction === 'Right') ?
                                sourcePoint.x + 20 : sourcePoint.x - 20;
                        }
                        insertfirst = true;
                        removeCurrentPrev = true;
                    }
                    break;
                case 'Left':
                case 'Right':
                    sourcePoint = (current.length > 0 && current.direction === 'Top') ? sourceNode.topCenter : sourceNode.bottomCenter;
                    if (current.length > sourceNode.height / 2) {
                        if (Math.abs(prev.length) < sourceNode.width / 2) {
                            prev.length = Point.distancePoints(sourceNode.center, prev.points[prev.points.length - 1]);
                            current.points[0].y = sourcePoint.y;
                            current.length = Point.distancePoints(current.points[0], current.points[current.points.length - 1]);
                            current.length -= 20;
                            insertfirst = true;
                        }
                    }
                    else {
                        if (next && next.direction && next.length) {
                            next.points[0].x = sourcePoint.x;
                            next.points[0].y = next.points[next.points.length - 1].y = (current.direction === 'Bottom') ?
                                sourcePoint.y + 20 : sourcePoint.y - 20;
                        }
                        insertfirst = true;
                        removeCurrentPrev = true;
                    }
                    break;
            }
            this.changeSegmentDirection(prev, connector);
            this.changeSegmentDirection(current, connector);
            if (insertfirst) {
                segValues = { type: 'Orthogonal', direction: current.direction, length: 20 };
                segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));
                if (removeCurrentPrev) {
                    if (next && next.direction && next.length) {
                        next.length = Point.distancePoints(next.points[0], next.points[next.points.length - 1]);
                    }
                    if (nextNext && nextNext.direction && nextNext.length) {
                        nextNext.length = Point.distancePoints(next.points[next.points.length - 1], nextNext.points[nextNext.points.length - 1]);
                    }
                    connector.segments.splice(index - 1, 2);
                }
                connector.segments = segments.concat(connector.segments);
            }
            this.selectedSegment = ((removeCurrentPrev) ? connector.segments[index - 1] :
                connector.segments[index + 1]);
            this.commandHandler.updateEndPoint(connector, oldValues);
        }
    };
    ConnectorEditing.prototype.updateLastSegment = function (connector, selectedSegment) {
        if (connector.targetID && connector.targetPortID === '') {
            var line1Start = void 0;
            var line1End = void 0;
            var line2Start = void 0;
            var line2End = void 0;
            var corners = connector.targetWrapper.corners;
            var firstSegPoint = selectedSegment.points[0];
            var lastSegPoint = selectedSegment.points[selectedSegment.points.length - 1];
            if (selectedSegment.direction === 'Right' || selectedSegment.direction === 'Left') {
                line1Start = { x: firstSegPoint.x, y: firstSegPoint.y };
                line1End = {
                    x: (selectedSegment.direction === 'Left') ? lastSegPoint.x - corners.width / 2 : lastSegPoint.x + corners.width / 2,
                    y: lastSegPoint.y
                };
                line2Start = { x: corners.center.x, y: corners.center.y - corners.height };
                line2End = { x: corners.center.x, y: corners.center.y + corners.height };
            }
            else {
                line1Start = { x: firstSegPoint.x, y: firstSegPoint.y };
                line1End = {
                    x: lastSegPoint.x,
                    y: (selectedSegment.direction === 'Bottom') ? lastSegPoint.y + corners.height / 2 : lastSegPoint.y - corners.height / 2
                };
                line2Start = { x: corners.center.x - corners.width, y: corners.center.y };
                line2End = { x: corners.center.x + corners.width, y: corners.center.y };
            }
            var line1 = { x1: line1Start.x, y1: line1Start.y, x2: line1End.x, y2: line1End.y };
            var line2 = { x1: line2Start.x, y1: line2Start.y, x2: line2End.x, y2: line2End.y };
            return (intersect3(line1, line2).enabled);
        }
        return false;
    };
    /**
     *To destroy the module
     *
     * @returns {void} To destroy the module
     */
    ConnectorEditing.prototype.destroy = function () {
        /**
         * Destroys the connector editing module
         */
    };
    /**
     * Get module name.
     */
    /**
     * Get module name.\
     *
     * @returns {  string  }    Get module name.\
     */
    ConnectorEditing.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'ConnectorEditingTool';
    };
    return ConnectorEditing;
}(ToolBase));

/* eslint-disable jsdoc/require-returns */
/**
 * This module handles the mouse and touch events
 */
var DiagramEventHandler = /** @class */ (function () {
    /** @private */
    function DiagramEventHandler(diagram, commandHandler) {
        this.currentAction = 'None';
        this.previousAction = 'None';
        this.previousTarget = null;
        /** @private */
        this.touchArgs = undefined;
        /**   @private  */
        this.focus = false;
        this.isBlocked = false;
        this.isMouseDown = false;
        this.inAction = false;
        this.doingAutoScroll = false;
        this.diagram = null;
        this.objectFinder = null;
        this.tool = null;
        this.eventArgs = null;
        this.previousElement = null;
        this.isKeyUp = true;
        this.keyCount = 0;
        this.isNudgeKey = false;
        this.commandObj = {};
        this.keyArgs = {};
        this.diagram = diagram;
        this.objectFinder = new ObjectFinder();
        this.commandHandler = commandHandler;
    }
    Object.defineProperty(DiagramEventHandler.prototype, "action", {
        get: function () {
            return this.currentAction;
        },
        set: function (action) {
            if (action !== this.currentAction) {
                if (this.currentAction === 'PortDraw') {
                    this.diagram.tool &= ~DiagramTools.DrawOnce;
                    //EJ2-70550 - Connector disconnected from source and target while dragging mutliple selected element
                    if (this.diagram.currentDrawingObject) {
                        this.diagram.currentDrawingObject = null;
                    }
                    if (this.tool) {
                        this.tool.mouseUp({ position: this.currentPosition });
                    }
                    this.tool = null;
                }
                if (action === 'Rotate' || action === 'LabelRotate') {
                    this.diagram.diagramCanvas.classList.add('e-diagram-rotate');
                }
                else if (this.currentAction === 'Rotate' || this.currentAction === 'LabelRotate') {
                    this.diagram.diagramCanvas.classList.remove('e-diagram-rotate');
                }
                this.currentAction = action;
                //Ej2-26204 - Exception occurs when remove method called without mouse Interaction
                if (this.currentAction !== 'None' && this.currentAction !== 'Select' &&
                    !(this.diagram.diagramActions & DiagramAction.TextEdit) &&
                    !(this.currentPosition && this.commandHandler.isUserHandle(this.currentPosition)) && !(this.currentAction === 'FixedUserHandle')) {
                    this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.ToolAction;
                }
                else {
                    this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.ToolAction;
                }
                this.diagram.setCursor(this.diagram.getCursor(action, this.inAction));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiagramEventHandler.prototype, "blocked", {
        get: function () {
            return this.isBlocked;
        },
        set: function (blocked) {
            this.isBlocked = blocked;
            if (this.blocked) {
                this.diagram.setCursor('not-allowed');
            }
            else {
                this.diagram.setCursor(this.diagram.getCursor(this.action, this.inAction));
            }
        },
        enumerable: true,
        configurable: true
    });
    /** @private */
    DiagramEventHandler.prototype.getMousePosition = function (e) {
        var touchArg;
        var offsetX;
        var offsetY;
        if (e.type.indexOf('touch') !== -1) {
            touchArg = e;
            offsetX = touchArg.changedTouches[0].clientX;
            offsetY = touchArg.changedTouches[0].clientY;
        }
        else {
            offsetX = e.clientX;
            offsetY = e.clientY;
        }
        offsetX = this.diagram.modifyClientOffset(offsetX);
        offsetY = this.diagram.modifyClientOffset(offsetY);
        var position = new Size();
        position = getRulerSize(this.diagram);
        var boundingRect = this.diagram.element.getBoundingClientRect();
        this.diagram.modifyBounds(boundingRect);
        offsetX = offsetX + this.diagram.diagramCanvas.scrollLeft - boundingRect.left - position.width;
        offsetY = offsetY + this.diagram.diagramCanvas.scrollTop - boundingRect.top - position.height;
        offsetX /= this.diagram.scroller.transform.scale;
        offsetY /= this.diagram.scroller.transform.scale;
        offsetX -= this.diagram.scroller.transform.tx;
        offsetY -= this.diagram.scroller.transform.ty;
        return { x: offsetX, y: offsetY };
    };
    /**
     * @private
     */
    DiagramEventHandler.prototype.windowResize = function (evt) {
        var _this = this;
        if (this.resizeTo) {
            clearTimeout(this.resizeTo);
        }
        this.resizeTo = setTimeout(function () {
            _this.updateViewPortSize(_this.diagram.element);
        }, 300);
        return false;
    };
    /**
     * @private
     */
    DiagramEventHandler.prototype.updateViewPortSize = function (element) {
        var container = document.getElementById(element.id);
        if (container) {
            var bounds = container.getBoundingClientRect();
            this.diagram.modifyBounds(bounds);
            this.diagram.scroller.setViewPortSize(bounds.width, bounds.height);
            var position = new Size();
            position = getRulerSize(this.diagram);
            var width = this.diagram.getSizeValue(this.diagram.width, position.width);
            var height = this.diagram.getSizeValue(this.diagram.height, position.height);
            this.diagram.diagramCanvas.style.width = width;
            this.diagram.diagramCanvas.style.height = height;
            this.diagram.scroller.setSize();
            this.diagram.transformLayers();
            if (this.diagram.rulerSettings.showRulers) {
                updateRuler(this.diagram);
            }
            if (this.diagram.views.length > 1) {
                //884316 - updating overview after window resize
                for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {
                    var temp = _a[_i];
                    var view = this.diagram.views["" + temp];
                    if ((view instanceof Overview)) {
                        //Calling onproperty change method to update overview.
                        view.onPropertyChanged({ sourceID: view.sourceID }, {});
                    }
                }
            }
        }
    };
    /** @private */
    DiagramEventHandler.prototype.canHideResizers = function () {
        return ((this.tool instanceof MoveTool || this.tool instanceof RotateTool) && this.isMouseDown);
    };
    /** @private */
    DiagramEventHandler.prototype.updateCursor = function () {
        if ((this.diagram.selectedItems.nodes.length === 1 || this.diagram.selectedItems.connectors.length === 1)) {
            var list = [];
            list = list.concat(this.diagram.selectedItems.nodes, this.diagram.selectedItems.connectors);
            // Bug fix - EJ2-44495 -Node does not gets selected on slight movement of mouse when drag constraints disabled for node
            this.blocked = (this.eventArgs && this.eventArgs.source && !canMove(this.eventArgs.source)) ? false :
                (this.isMouseDown && list.length === 1 && this.tool instanceof SelectTool && !canMove(list[0]));
        }
    };
    DiagramEventHandler.prototype.isForeignObject = function (target, isTextBox) {
        var foreignobject = target;
        if (foreignobject) {
            while (foreignobject.parentNode !== null) {
                if (typeof foreignobject.className === 'string' &&
                    ((!isTextBox && foreignobject.className.indexOf('foreign-object') !== -1) ||
                        (isTextBox && foreignobject.className.indexOf('e-diagram-text-edit') !== -1))) {
                    return foreignobject;
                }
                else {
                    foreignobject = foreignobject.parentNode;
                }
            }
        }
        return null;
    };
    DiagramEventHandler.prototype.isMetaKey = function (evt) {
        //EJ2-55887 - added the beow code to perform pinch zoom in mac os and windows while pinch zoom all browser return ctrl key as true.
        if (evt.type === 'mousewheel') {
            return evt.ctrlKey;
        }
        else {
            return navigator.platform.match('Mac') ? evt.metaKey : evt.ctrlKey;
        }
    };
    DiagramEventHandler.prototype.renderUmlHighLighter = function (args) {
        this.diagram.commandHandler.removeStackHighlighter();
        var node = this.diagram.selectedItems.nodes[0];
        if (node && node.container && node.container.type === 'Stack' && node.shape.type === 'UmlClassifier') {
            var bound = node.wrapper.bounds;
            if (!bound.containsPoint(this.currentPosition)) {
                // eslint-disable-next-line max-len
                var objects = this.diagram.findObjectsUnderMouse({ x: this.currentPosition.x - 20, y: this.currentPosition.y });
                var target = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);
                if (target && target.parentId && (target.parentId === node.id)) {
                    // eslint-disable-next-line max-len
                    var isVertical = this.diagram.nameTable[target.parentId].container.orientation === 'Vertical';
                    renderStackHighlighter(target.wrapper, isVertical, args.position, this.diagram, true);
                }
            }
        }
    };
    DiagramEventHandler.prototype.isDeleteKey = function (key, value) {
        return (navigator.platform.match('Mac') && key === 'Backspace' && value === 'delete');
    };
    DiagramEventHandler.prototype.isMouseOnScrollBar = function (evt) {
        var x = evt.offsetX;
        var y = evt.offsetY;
        var diagramCanvas = this.diagram.diagramCanvas;
        var height = diagramCanvas.offsetHeight;
        var width = diagramCanvas.offsetWidth;
        var topLeft;
        var topRight;
        var bottomLeft;
        var bottomRight;
        var bounds;
        if (height < diagramCanvas.scrollHeight) {
            //default scrollbar width in browser is '17pixels'.
            topLeft = { x: (width - 17), y: 0 };
            topRight = { x: width, y: 0 };
            bottomLeft = { x: (width - 17), y: height };
            bottomRight = { x: width, y: height };
            bounds = Rect.toBounds([topLeft, topRight, bottomLeft, bottomRight]);
            // EJ2-64563-Added below code to calculate the bounds x and y value if vertical offset != 0
            if (this.diagram.scroller.verticalOffset !== 0) {
                bounds.x = bounds.x - this.diagram.scroller.horizontalOffset;
                bounds.y = bounds.y - this.diagram.scroller.verticalOffset;
            }
            if (bounds.containsPoint({ x: x, y: y })) {
                return true;
            }
        }
        if (width < diagramCanvas.scrollWidth) {
            topLeft = { x: 0, y: (height - 17) };
            topRight = { x: width, y: (height - 17) };
            bottomLeft = { x: 0, y: height };
            bottomRight = { x: width, y: height };
            bounds = Rect.toBounds([topLeft, topRight, bottomLeft, bottomRight]);
            // EJ2-64563-Added below code to calculate the bounds x and y value if horizontal offset != 0
            if (this.diagram.scroller.horizontalOffset !== 0) {
                bounds.x = bounds.x - this.diagram.scroller.horizontalOffset;
                bounds.y = bounds.y - this.diagram.scroller.verticalOffset;
            }
            if (bounds.containsPoint({ x: x, y: y })) {
                return true;
            }
        }
        return false;
    };
    /**   @private  */
    DiagramEventHandler.prototype.updateVirtualization = function () {
        var _this = this;
        var delay = 50;
        //let removeObjectInterval: Object;
        var removeObjectInterval = setInterval(function (args) {
            _this.diagram.removeVirtualObjects(removeObjectInterval);
        }, delay);
        setTimeout(function () {
            _this.diagram.deleteVirtualObject = true;
        }, delay);
    };
    DiagramEventHandler.prototype.checkPreviousAction = function () {
        if (this.action !== this.previousAction && this.diagram.selectedItems.userHandles.length) {
            for (var i = 0; i < this.diagram.selectedItems.userHandles.length; i++) {
                if (this.previousAction && this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)]) {
                    this.checkUserHandleEvent(DiagramEvent.onUserHandleMouseLeave);
                    this.previousAction = 'None';
                }
            }
        }
        if (this.action !== this.previousAction) {
            // If the mouse leaves the fixed user handle, the tooltip is closed
            this.checkFixedUserHandleEvent(DiagramEvent.onFixedUserHandleMouseLeave, this.targetItem, this.previousTarget);
            this.previousTarget = null;
            this.targetItem = null;
        }
    };
    DiagramEventHandler.prototype.checkUserHandleEvent = function (eventName) {
        if (this.diagram.selectedItems && this.diagram.selectedItems.userHandles.length > 0) {
            var currentAction = (eventName === DiagramEvent.onUserHandleMouseLeave) ? this.previousAction : this.action;
            var arg = { element: undefined };
            for (var i = 0; i < this.diagram.selectedItems.userHandles.length; i++) {
                if ((currentAction === this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)].name) ||
                    (eventName === DiagramEvent.onUserHandleMouseUp && currentAction === 'Select')) {
                    arg.element = this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)];
                    this.userHandle(eventName, i, arg, null);
                }
            }
        }
    };
    DiagramEventHandler.prototype.userHandle = function (eventName, i, arg, targetItem) {
        if (eventName === DiagramEvent.onUserHandleMouseEnter || eventName === DiagramEvent.onFixedUserHandleMouseEnter) {
            this.previousAction = this.action;
            // EJ2-32213- Added the below code to check whether the userhandle has tooltip content.
            // If userhandle has tooltip content then we open the tooltip based on the userhandle shape
            if (arg.element.tooltip && arg.element.tooltip.openOn === 'Auto' && arg.element.tooltip.content !== '') {
                updateTooltip(this.diagram, arg.element);
                var targetEle = void 0;
                if (arg.element.pathData) {
                    if (eventName === DiagramEvent.onUserHandleMouseEnter) {
                        targetEle = document.getElementById(this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)].name + '_userhandle');
                    }
                    else if (eventName === DiagramEvent.onFixedUserHandleMouseEnter) {
                        targetEle = document.getElementById(targetItem.id + '_' + targetItem.fixedUserHandles[parseInt(i.toString(), 10)].id + '_groupElement');
                    }
                }
                else if (arg.element.source) {
                    targetEle = document.getElementById(this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)].name + '_image');
                }
                else if (arg.element.content) {
                    targetEle = document.getElementById(this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)].name + '_shape_native_element');
                }
                else {
                    targetEle = document.getElementById(this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)].name + '_shape_html_element');
                }
                //892828: Flickering of tooltip while hovering userhandle
                if (arg.element.tooltip.openOn === 'Auto' && (arg.element !== this.isUserHandleHover)) {
                    this.isUserHandleHover = arg.element;
                    this.diagram.tooltipObject.open(targetEle);
                }
            }
            this.diagram.triggerEvent(eventName, arg);
        }
        if (eventName === DiagramEvent.onUserHandleMouseDown) {
            this.userHandleObject = this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)].name;
            this.diagram.triggerEvent(eventName, arg);
        }
        else if (eventName === DiagramEvent.onFixedUserHandleMouseDown) {
            this.diagram.triggerEvent(eventName, arg);
        }
        if (eventName === DiagramEvent.onUserHandleMouseUp) {
            var element = document.getElementById(this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)].name + '_userhandle');
            if (this.commandHandler.isUserHandle(this.currentPosition)
                && element && element.id === this.userHandleObject + '_userhandle') {
                //EJ2-838423 -onUserHandleMouseUp event triggers multiple times
                this.diagram.triggerEvent(eventName, arg);
            }
        }
        else if (eventName === DiagramEvent.onFixedUserHandleMouseUp) {
            this.diagram.triggerEvent(eventName, arg);
        }
        if (eventName === DiagramEvent.onUserHandleMouseLeave || eventName === DiagramEvent.onFixedUserHandleMouseLeave) {
            if (this.diagram.tooltipObject && this.diagram.tooltipObject.openOn !== 'Custom') {
                this.isUserHandleHover = null;
                this.diagram.tooltipObject.close();
            }
            this.diagram.triggerEvent(eventName, arg);
        }
    };
    // In the method, verify the fixed user handle and manage the opening and closing of the tooltip according to mouse events
    DiagramEventHandler.prototype.checkFixedUserHandleEvent = function (eventName, targetItem, wrapper) {
        if (targetItem && targetItem.fixedUserHandles.length > 0) {
            var arg = { element: undefined };
            var userid = void 0;
            var currentAction = void 0;
            for (var i = 0; i < targetItem.fixedUserHandles.length; i++) {
                userid = targetItem.fixedUserHandles[parseInt(i.toString(), 10)].id;
                if (wrapper && wrapper.id && (wrapper.id.indexOf(userid) > -1)) {
                    currentAction = userid;
                    this.previousTarget = wrapper;
                    this.targetItem = targetItem;
                }
                if (currentAction === targetItem.fixedUserHandles[parseInt(i.toString(), 10)].id) {
                    arg.element = targetItem.fixedUserHandles[parseInt(i.toString(), 10)];
                    this.userHandle(eventName, i, arg, targetItem);
                }
            }
        }
    };
    DiagramEventHandler.prototype.mouseDown = function (evt) {
        var _this = this;
        //Bug 913785: Tooltip for node is not showing when touch and hold on node in mobile device.
        if (evt.type === 'touchstart') {
            this.timeOutTapHold = setTimeout(function () {
                if (_this.action === 'Select' || _this.action === 'Drag') {
                    _this.mouseMove(evt, undefined);
                }
            }, 500);
        }
        // EJ2-57541 - Added the below code to check whether diagram tool is instance of node drawing tool or connector drawing tool.
        // If node or connector drawing tool means then we have returned without perform any operation.
        // 923532: Event 'Completed' state not triggered with multiple button click Action
        if ((this.inAction === true && ((this.tool) instanceof NodeDrawingTool || this.tool instanceof ConnectorDrawingTool)) ||
            (this.inAction === true && (evt.buttons && (evt.buttons & (evt.buttons - 1)) !== 0))) {
            return;
        }
        this.focus = true;
        //let touches: TouchList;
        var touches = evt.touches;
        var isSymblDragging = document.getElementsByClassName('e-dragclone')[0] ? true : false;
        if (this.isMouseOnScrollBar(evt) && !isSymblDragging) {
            this.isScrolling = true;
            evt.preventDefault();
            return;
        }
        // commanded by gowtham- unwanted cloning of selectedItems
        // if (isBlazor()) {
        //     this.commandHandler.oldSelectedObjects = cloneObject(this.diagram.selectedItems);
        // }
        this.checkFixedUserHandleEvent(DiagramEvent.onFixedUserHandleMouseDown, this.targetItem, this.previousTarget);
        this.checkUserHandleEvent(DiagramEvent.onUserHandleMouseDown);
        if (!this.checkEditBoxAsTarget(evt) && (canUserInteract(this.diagram)) ||
            (canZoomPan(this.diagram) && !defaultTool(this.diagram))) {
            if (this.action === 'Select' || this.action === 'Drag') {
                this.diagram.updatePortVisibility(this.hoverElement, PortVisibility.Hover, true);
            }
            if (((this.tool instanceof PolygonDrawingTool || this.tool instanceof PolyLineDrawingTool)
                && (evt.button === 2 || evt.buttons === 2))) {
                // eslint-disable-next-line
                var arg = {
                    element: cloneBlazorObject(this.diagram), position: cloneBlazorObject(this.currentPosition),
                    count: evt.buttons, actualObject: cloneBlazorObject(this.eventArgs.actualObject),
                    button: (evt.button === 0) ? 'Left' : (evt.button === 1) ? 'Middle' : 'Right'
                };
                this.inAction = false;
                this.tool.mouseUp(this.eventArgs);
            }
            else if (((this.inAction === true) && this.isMouseDown === true &&
                (this.tool instanceof PolygonDrawingTool || this.tool instanceof PolyLineDrawingTool))) {
                this.isMouseDown = true;
                this.eventArgs = {};
                this.getMouseEventArgs(this.currentPosition, this.eventArgs);
                this.eventArgs.position = this.currentPosition;
                this.tool.mouseDown(this.eventArgs);
            }
            else {
                this.isMouseDown = true;
                this.currentPosition = this.prevPosition = this.getMousePosition(evt);
                this.eventArgs = {};
                if (this.diagram.textEditing && !this.isMouseOnScrollBar(evt)) {
                    this.diagram.endEdit();
                    this.diagram.textEditing = false;
                    // EJ2-57743 - Added below code to refresh the diagram layer after the annotation gets edited in canvas mode.
                    if (this.diagram.mode === 'Canvas' && this.diagram.scroller.currentZoom !== 1) {
                        this.diagram.refreshDiagramLayer();
                    }
                }
                var targetObject = this.getTargetElement();
                this.action = this.diagram.findActionToBeDone(targetObject.obj, targetObject.sourceElement, this.currentPosition, targetObject.target);
                //work around - correct it
                var ctrlKey = this.isMetaKey(evt);
                if (ctrlKey && evt.shiftKey && this.diagram.connectorEditingToolModule) {
                    this.action = 'SegmentEnd';
                    //Bug 892496: Unable to unselect selected node using CTRL+Click when zoompan is enabled.
                    //Added this condition whether single select or multi select is enabled in diagram tool.
                }
                else if ((ctrlKey || evt.shiftKey) && (canSingleSelect(this.diagram) || canMultiSelect(this.diagram))) {
                    this.action = 'Select';
                }
                this.tool = this.diagram.getTool(this.action);
                if (!this.tool) {
                    this.action = 'Select';
                    this.tool = this.diagram.getTool(this.action);
                }
                this.getMouseEventArgs(this.currentPosition, this.eventArgs);
                if (ctrlKey || evt.shiftKey) {
                    var info = (ctrlKey && evt.shiftKey) ? { ctrlKey: ctrlKey, shiftKey: evt.shiftKey } : { ctrlKey: true };
                    this.eventArgs.info = info;
                }
                this.eventArgs.position = this.currentPosition;
                //834641 -  Support to unselect the diagram element that is already selected
                var prevSelectedNode = this.diagram.selectedItems.nodes;
                this.tool.mouseDown(this.eventArgs);
                if (this.diagram.selectedItems.canToggleSelection && prevSelectedNode
                    && this.diagram.selectedItems.nodes && this.tool instanceof MoveTool) {
                    for (var i = 0; i < prevSelectedNode.length; i++) {
                        if (prevSelectedNode[parseInt(i.toString(), 10)].id
                            !== this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].id) {
                            this.isSwimlaneSelected = true;
                        }
                    }
                }
                this.initialEventArgs = { source: this.eventArgs.source, sourceWrapper: this.eventArgs.sourceWrapper };
                this.initialEventArgs.position = this.currentPosition;
                this.initialEventArgs.info = this.eventArgs.info;
                this.inAction = false;
                if (evt.type === 'touchstart') {
                    if (touches && touches.length >= 2) {
                        this.touchStartList = addTouchPointer(this.touchStartList, evt, touches);
                    }
                    if (!touches) {
                        evt.preventDefault();
                    }
                }
            }
        }
        if (!this.isForeignObject(evt.target) && !this.isForeignObject(evt.target, true) && (!touches)) {
            evt.preventDefault();
        }
    };
    /**   @private  */
    DiagramEventHandler.prototype.mouseMoveExtend = function (e, obj) {
        if (this.tool instanceof PolygonDrawingTool || this.tool instanceof PolyLineDrawingTool) {
            this.tool.mouseMove(this.eventArgs);
        }
        if (this.diagram.scrollSettings.canAutoScroll) {
            this.checkAutoScroll(e);
        }
        else {
            if (!this.blocked) {
                (this.tool.mouseMove(this.eventArgs));
            }
        }
        if (this.eventArgs.target) {
            this.hoverElement = this.eventArgs.target;
        }
        var isNode = (this.eventArgs.target instanceof Node || this.eventArgs.target instanceof Connector)
            && (obj instanceof Node || obj instanceof Connector) ? false : true;
        if (this.tool instanceof ConnectTool) {
            this.diagram.updatePortVisibility((this.hoverElement instanceof Node || this.hoverElement instanceof Connector)
                ? this.hoverElement : this.hoverNode, PortVisibility.Connect | PortVisibility.Hover, isNode);
        }
        if (this.hoverElement instanceof Node
            && this.hoverNode instanceof Node && this.hoverNode && this.hoverNode.id !== this.hoverElement.id) {
            this.diagram.updatePortVisibility(this.hoverNode, PortVisibility.Connect | PortVisibility.Hover, true);
        }
        if (this.hoverElement instanceof Connector && (this.hoverElement.ports.length > 0)) {
            this.diagram.updatePortVisibility(this.hoverElement, PortVisibility.Connect | PortVisibility.Hover, true);
        }
        // 890089: Unintended Port Visibility Issue Fix
        // Updating port visibility based on the previous hoverElement
        if (this.previousElement instanceof Node && this.hoverElement && (this.previousElement.id !== this.hoverElement.id)) {
            this.diagram.updatePortVisibility(this.previousElement, PortVisibility.Connect | PortVisibility.Hover, true);
        }
        this.previousElement = this.hoverElement;
        // Updating tooltip content on mouse relative mode
        if (this.diagram.tooltip.content !== '') {
            this.hoverElement = null;
        }
        this.hoverNode = isNode ? null : obj;
    };
    /** @private */
    DiagramEventHandler.prototype.checkAction = function (obj) {
        if (this.action === 'LabelSelect' && this.eventArgs.sourceWrapper &&
            (this.eventArgs.sourceWrapper instanceof TextElement || this.eventArgs.sourceWrapper instanceof DiagramHtmlElement)) {
            var annotation = this.commandHandler.findTarget(this.eventArgs.sourceWrapper, this.eventArgs.source);
            if (!isSelected(this.diagram, annotation, false, this.eventArgs.sourceWrapper) && canMove(annotation)) {
                this.action = 'LabelDrag';
                this.tool = this.getTool(this.action);
                this.tool.mouseDown(this.initialEventArgs);
            }
        }
        else if (canMove(obj) && canSelect(obj) && this.initialEventArgs &&
            this.initialEventArgs.source && this.action === 'Select') {
            if (!isSelected(this.diagram, this.eventArgs.source, false) &&
                this.eventArgs.source instanceof Selector) {
                this.getMouseEventArgs(this.currentPosition, this.eventArgs);
            }
            if (!(obj instanceof Connector) || (obj instanceof Connector &&
                !(contains(this.currentPosition, obj.sourcePoint, obj.hitPadding) ||
                    contains(this.currentPosition, obj.targetPoint, obj.hitPadding)))) {
                this.action = 'Drag';
            }
            this.tool = this.getTool(this.action);
            this.tool.mouseDown(this.initialEventArgs);
        }
    };
    DiagramEventHandler.prototype.isSwimlaneElements = function (obj) {
        if (obj && (obj.isLane || obj.isPhase || obj.isHeader)) {
            return false;
        }
        else {
            return true;
        }
    };
    //To decide whether to show tooltip on touch long press
    DiagramEventHandler.prototype.canShowTouchTooltip = function (evt) {
        if (evt.type === 'touchstart') {
            if ((this.diagram.tool & DiagramTools.SingleSelect) && (this.diagram.tool & DiagramTools.ZoomPan)) {
                this.isMouseDown = false;
                return true;
            }
        }
        return false;
    };
    /* tslint:disable */
    /** @private */
    DiagramEventHandler.prototype.mouseMove = function (e, touches) {
        this.focus = true;
        //Bug 914365: Node is not resizable using touch interaction
        if (e.type === 'touchmove') {
            this.touchArgs = { target: e.target, type: 'touchmove' };
        }
        if (this.isScrolling) {
            e.preventDefault();
            return;
        }
        if (canUserInteract(this.diagram) || (canZoomPan(this.diagram) && !defaultTool(this.diagram))) {
            this.currentPosition = this.getMousePosition(e);
            var objects = this.diagram.findObjectsUnderMouse(this.currentPosition);
            var obj = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);
            drawRulerMarkers(this.diagram, this.currentPosition);
            var force = false;
            var target = void 0;
            if (e.type === 'touchmove') {
                touches = e.touches;
                if (touches && touches.length > 1) {
                    this.touchMoveList = addTouchPointer(this.touchMoveList, e, touches);
                    if (this.action !== 'PinchZoom') {
                        force = true;
                    }
                }
            }
            if (Point.equals(this.currentPosition, this.prevPosition) === false || this.inAction || this.canShowTouchTooltip(e)) {
                if (this.isMouseDown === false || force) {
                    this.eventArgs = {};
                    var sourceElement = null;
                    var tooltipTarget = void 0;
                    if (obj !== null) {
                        sourceElement = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram);
                        //834842-Exception/error occurs when hovering on the connector
                        //tooltiptarget to be found only if the source element is not null
                        if (sourceElement) {
                            tooltipTarget = this.commandHandler.findTarget(sourceElement, obj);
                        }
                        //908569: Node Tooltip Flickers when hovering on Annotation
                        //If the annotation does not have tooltip content, set the tooltip target as an object
                        if (tooltipTarget instanceof ShapeAnnotation || tooltipTarget instanceof PathAnnotation) {
                            if (!(tooltipTarget.tooltip && tooltipTarget.tooltip.content !== '')) {
                                tooltipTarget = obj;
                            }
                        }
                        if (tooltipTarget !== this.hoverElement) {
                            var content_1 = this.getContent();
                            if (this.hoverElement && this.hoverElement.tooltip.openOn === 'Auto' && content_1 !== '') {
                                this.elementLeave();
                            }
                            this.diagram.updatePortVisibility(this.hoverElement, PortVisibility.Hover, true);
                            if (obj instanceof Node) {
                                this.hoverNode = obj;
                            }
                            var canResetElement = true;
                            if (!this.isSwimlaneElements(obj)
                                && (this.hoverElement && this.isSwimlaneElements(this.hoverElement))) {
                                canResetElement = false;
                            }
                            this.hoverElement = canResetElement ? obj : this.hoverElement;
                            //EJ2-62120 - Provide tooltip support for ports - to set hoverelement as PathElement if hovered on ports in Node
                            var portElement = null;
                            var portTarget = void 0;
                            portElement = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram);
                            if (portElement instanceof PathElement) {
                                portTarget = this.commandHandler.findTarget(portElement, obj);
                                if ((portTarget instanceof PointPort || portTarget instanceof PathPort)
                                    && this.hoverElement.constraints & PortConstraints.ToolTip) {
                                    this.hoverElement = portTarget;
                                }
                            }
                            //839511: Tooltip support for annotation - to set hoverelement as TextElement if hovered on annotation in Node/Connector
                            var annotationTarget = void 0;
                            if (portElement instanceof TextElement) {
                                annotationTarget = this.commandHandler.findTarget(portElement, obj);
                                if ((annotationTarget instanceof ShapeAnnotation || annotationTarget instanceof PathAnnotation)
                                    && annotationTarget.constraints & AnnotationConstraints.Tooltip) {
                                    this.hoverElement = annotationTarget;
                                }
                            }
                            if (canResetElement) {
                                this.elementEnter(this.currentPosition, false);
                            }
                            else {
                                this.hoverElement = obj;
                            }
                        }
                        // EJ2-66418 - set tooltip relativeMode as mouse
                        // Updating the tooltip position based on Mouse move
                        else if (this.hoverElement) {
                            if (this.hoverElement === tooltipTarget && this.hoverElement.tooltip.content && this.diagram.tooltipObject !== undefined && this.hoverElement.tooltip.relativeMode === 'Mouse') {
                                this.setTooltipOffset(this.currentPosition);
                            }
                        }
                        if (sourceElement) {
                            target = this.commandHandler.findTarget(sourceElement, obj);
                        }
                    }
                    this.action = this.diagram.findActionToBeDone(obj, sourceElement, this.currentPosition, target);
                    this.checkFixedUserHandleEvent(DiagramEvent.onFixedUserHandleMouseEnter, obj, sourceElement);
                    this.checkUserHandleEvent(DiagramEvent.onUserHandleMouseEnter);
                    this.checkPreviousAction();
                    this.getMouseEventArgs(this.currentPosition, this.eventArgs);
                    this.tool = this.getTool(this.action);
                    this.mouseEvents();
                    if (this.tool instanceof ConnectorDrawingTool ||
                        this.tool instanceof PolyLineDrawingTool ||
                        this.tool instanceof PolygonDrawingTool) {
                        this.tool.mouseMove(this.eventArgs);
                    }
                    else if (touches && this.tool instanceof ZoomPanTool) {
                        this.tool.mouseDown(this.eventArgs);
                    }
                    this.updateCursor();
                    this.renderUmlHighLighter(this.eventArgs);
                    var isNode = false;
                    if (!(this.hoverElement && (!(this.tool instanceof ZoomPanTool))
                        && (obj instanceof Node && this.isSwimlaneElements(obj)) &&
                        (this.diagram.selectedItems.nodes.length === 0 || !isSelected(this.diagram, this.hoverElement)))
                        && (!(this.hoverElement instanceof Connector))) {
                        isNode = true;
                    }
                    if (!(this.hoverElement && (!(this.tool instanceof ZoomPanTool))
                        && (obj instanceof Connector) &&
                        (this.diagram.selectedItems.connectors.length === 0 || !isSelected(this.diagram, this.hoverElement)))
                        && (!(this.hoverElement instanceof Node))) {
                        isNode = true;
                    }
                    this.diagram.updatePortVisibility(this.hoverElement, PortVisibility.Hover, isNode);
                    var content = this.getContent();
                    if (obj === null && this.hoverElement && this.hoverElement.tooltip.openOn === 'Auto' && content) {
                        this.hoverElement = null;
                        this.elementLeave();
                    }
                    force = false;
                }
                else {
                    this.eventArgs.position = this.currentPosition;
                    if (this.action === 'Drag' && !isSelected(this.diagram, this.eventArgs.source, false) &&
                        this.eventArgs.source instanceof Selector) {
                        this.getMouseEventArgs(this.currentPosition, this.eventArgs);
                    }
                    this.mouseEvents();
                    if (e.ctrlKey || e.shiftKey) {
                        var info = (e.ctrlKey && e.shiftKey) ? { ctrlKey: e.ctrlKey, shiftKey: e.shiftKey } : { ctrlKey: true };
                        this.eventArgs.info = info;
                    }
                    this.checkAction(obj);
                    var padding = this.getConnectorPadding(this.eventArgs);
                    this.getMouseEventArgs(this.currentPosition, this.eventArgs, this.eventArgs.source, padding);
                    this.updateCursor();
                    this.inAction = true;
                    this.initialEventArgs = null;
                    if (this.action === 'Drag' || this.action === 'Rotate') {
                        this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.Interactions;
                    }
                    //Bug 863516: Overview is not synced with diagram content while zoom-out the diagram.
                    //Checking page bounds before and after dragging node, and updating the overview rect if the page bounds modified after the drag.
                    var preDragBounds = this.diagram.scroller.getPageBounds();
                    this.mouseMoveExtend(e, obj);
                    var postDragBounds = this.diagram.scroller.getPageBounds();
                    if (obj && (preDragBounds.width !== postDragBounds.width ||
                        preDragBounds.height !== postDragBounds.height ||
                        preDragBounds.x !== postDragBounds.x ||
                        preDragBounds.y !== postDragBounds.y)) {
                        if (this.diagram.views && this.diagram.views.overview) {
                            var overview = this.diagram.views.overview;
                            overview.updateView(overview);
                        }
                    }
                }
                this.prevPosition = this.currentPosition;
                if (!this.isForeignObject(e.target, true)) {
                    e.preventDefault();
                }
            }
        }
    };
    /* tslint:enable */
    DiagramEventHandler.prototype.getContent = function () {
        var isPrivateTooltip = ((this.hoverElement instanceof Node)
            && this.hoverElement.constraints & NodeConstraints.Tooltip) ||
            ((this.hoverElement instanceof Connector) && this.hoverElement.constraints & ConnectorConstraints.Tooltip)
            || ((this.hoverElement instanceof PointPort || this.hoverElement instanceof PathPort)
                && this.hoverElement.constraints & PortConstraints.ToolTip) ||
            ((this.hoverElement instanceof ShapeAnnotation || this.hoverElement instanceof PathAnnotation)
                && this.hoverElement.constraints & AnnotationConstraints.Tooltip);
        var node = this.hoverElement;
        var childNode;
        if (node instanceof Node && node.children && node.children.length > 0) {
            childNode = this.findIntersectChild(node);
        }
        var content = isPrivateTooltip ? this.hoverElement.tooltip.content :
            this.diagram.tooltip.content;
        content = childNode ? childNode.tooltip.content : content;
        return content;
    };
    DiagramEventHandler.prototype.findIntersectChild = function (node) {
        var childNode;
        var rect = new Rect(this.currentPosition.x, this.currentPosition.y, 8, 8);
        for (var i = 0; i < node.children.length; i++) {
            childNode = this.diagram.getObject(node.children[parseInt(i.toString(), 10)]);
            if (childNode.wrapper.outerBounds.intersects(rect)) {
                return childNode;
            }
        }
        return null;
    };
    DiagramEventHandler.prototype.checkAutoScroll = function (e) {
        var autoScrollPosition = this.startAutoScroll(e);
        if (!autoScrollPosition && this.doingAutoScroll) {
            this.doingAutoScroll = false;
            clearInterval(this.timeOutValue);
        }
        else if (autoScrollPosition) {
            if ((this.tool instanceof NodeDrawingTool || this.tool instanceof ConnectorDrawingTool
                || this.tool instanceof MoveTool || this.tool instanceof ResizeTool
                || this.tool instanceof SelectTool || this.tool instanceof ConnectTool) && this.inAction) {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                var diagram_1 = this;
                var delay_1 = this.diagram.scrollSettings.autoScrollFrequency;
                if (delay_1 < 10 || isNaN(delay_1)) {
                    delay_1 = 100;
                }
                if (this.diagram.scrollSettings.canAutoScroll && autoScrollPosition && !this.doingAutoScroll) {
                    this.doingAutoScroll = true;
                    this.timeOutValue = setInterval(function (args) {
                        diagram_1.doAutoScroll(autoScrollPosition, e, delay_1);
                    }, delay_1);
                }
            }
        }
        else {
            this.blocked = !(this.tool.mouseMove(this.eventArgs));
        }
    };
    /* tslint:disable */
    /** @private */
    DiagramEventHandler.prototype.mouseUp = function (evt) {
        clearTimeout(this.timeOutTapHold);
        //Bug 914365: Node is not resizable using touch interaction
        this.touchArgs = undefined;
        this.diagram.diagramRenderer.touchMove = undefined;
        //EJ2-849817-Dropping nodes in swimlane does not consider as child in angular
        if (this.eventArgs && this.eventArgs.target && this.eventArgs.target !== this.hoverNode
            && this.eventArgs.target !== this.lastObjectUnderMouse) {
            this.hoverNode = this.eventArgs.target;
            this.lastObjectUnderMouse = this.eventArgs.target;
        }
        //Bug 881512: Wrapping of the connector annotation at run time not working properly.
        //To wrap the connector annotation text after the node rotated or dragged.
        var updateAnnotation = false;
        if (this.tool instanceof MoveTool || this.tool instanceof RotateTool) {
            updateAnnotation = true;
        }
        this.checkFixedUserHandleEvent(DiagramEvent.onFixedUserHandleMouseUp, this.targetItem, this.previousTarget);
        this.checkUserHandleEvent(DiagramEvent.onUserHandleMouseUp);
        if (this.diagram.mode === 'SVG' && canVitualize(this.diagram)) {
            this.updateVirtualization();
        }
        var prevSelectedNodes = this.diagram.selectedItems.nodes;
        var prevSelectedConnectors = this.diagram.selectedItems.connectors;
        var unSelectLaneObj;
        this.diagram.previousSelectedObject = null;
        this.diagram.diagramRenderer.rendererActions =
            this.diagram.removeConstraints(this.diagram.diagramRenderer.rendererActions, RendererAction.DrawSelectorBorder);
        var touches = evt.touches;
        if (this.isScrolling) {
            this.isScrolling = false;
            evt.preventDefault();
            return;
        }
        if (!this.checkEditBoxAsTarget(evt) && (canUserInteract(this.diagram))
            || (canZoomPan(this.diagram) && !defaultTool(this.diagram))) {
            if (this.tool && (!(this.tool instanceof PolygonDrawingTool || this.tool instanceof PolyLineDrawingTool) ||
                ((this.tool instanceof PolygonDrawingTool || this.tool instanceof PolyLineDrawingTool)
                    && evt.detail === 2))) {
                if (!this.isForeignObject(evt.target) && this.isMouseDown) {
                    document.getElementById(this.diagram.element.id + 'content').focus();
                }
                if (!this.inAction && evt.which !== 3) {
                    if (this.action === 'Drag') {
                        this.action = 'Select';
                        var oldSelectedValue = (this.diagram.selectedItems.nodes.concat(this.diagram.selectedItems.connectors));
                        var objects = this.diagram.findObjectsUnderMouse(this.currentPosition);
                        var obj = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);
                        var isMultipleSelect = true;
                        if ((!evt.ctrlKey && this.isMouseDown
                            && (this.diagram.selectedItems.nodes.length + this.diagram.selectedItems.connectors.length) > 1)
                            && evt.which === 1 && !canPreventClearSelection(this.diagram.diagramActions)) {
                            isMultipleSelect = false;
                            this.commandHandler.clearSelection();
                        }
                        if (!isSelected(this.diagram, obj) || (!isMultipleSelect)) {
                            this.commandHandler.selectObjects([obj], undefined, oldSelectedValue);
                            //834641 - Support to unselect the diagram element that is already selected
                            if (this.diagram.selectedItems.canToggleSelection) {
                                var selectedObj = this.diagram.selectedItems.nodes;
                                if (selectedObj) {
                                    if (selectedObj[0].parentObj instanceof Lane) {
                                        unSelectLaneObj = true;
                                    }
                                }
                                else if (this.diagram.selectedItems.connectors.length > 0) {
                                    unSelectLaneObj = true;
                                }
                            }
                        }
                    }
                }
                var avoidDropChildren = false;
                var history_1 = this.updateContainerProperties();
                var isGroupAction = void 0;
                this.addUmlNode();
                this.inAction = false;
                this.isMouseDown = false;
                //912163- Restricting node selection
                if (this.diagram.selectedObject.helperObject) {
                    isGroupAction = this.updateContainerBounds();
                }
                if (this.tool && (this.tool.prevPosition || this.tool instanceof LabelTool)) {
                    this.eventArgs.position = this.currentPosition;
                    var padding = this.getConnectorPadding(this.eventArgs);
                    this.getMouseEventArgs(this.currentPosition, this.eventArgs, this.eventArgs.source, padding);
                    var ctrlKey = this.isMetaKey(evt);
                    if (ctrlKey || evt.shiftKey) {
                        var info = (ctrlKey && evt.shiftKey) ? { ctrlKey: ctrlKey, shiftKey: evt.shiftKey } :
                            { ctrlKey: true };
                        this.eventArgs.info = info;
                    }
                    if (this.diagram.diagramActions & DiagramAction.Interactions) {
                        this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.Interactions;
                    }
                    this.eventArgs.clickCount = evt.detail;
                    if (this.diagram.selectedObject.helperObject && (this.tool instanceof MoveTool || this.tool instanceof ResizeTool)) {
                        if (this.diagram.selectedObject.actualObject &&
                            this.diagram.selectedObject.actualObject.parentId !== '') {
                            var parentNode = this.diagram.getObject(this.diagram.selectedObject.actualObject.parentId);
                            if (parentNode && parentNode.isLane) {
                                this.commandHandler.isContainer = true;
                            }
                        }
                        avoidDropChildren = this.diagram.lineRoutingModule
                            && this.diagram.nameTable['helper'] && this.eventArgs.target && this.eventArgs.target.isLane
                            && ((this.eventArgs.source instanceof Selector && this.eventArgs.source.nodes.length > 0
                                && this.eventArgs.source.nodes[0].parentId === '') || (this.eventArgs.source.parentId === ''));
                        if (avoidDropChildren) {
                            this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.PreventLaneContainerUpdate;
                        }
                        this.tool.mouseUp(this.eventArgs, history_1.isPreventHistory);
                    }
                    else {
                        //834641 - Support to unselect the diagram element that is already selected
                        if (this.diagram.selectedItems.canToggleSelection) {
                            var isGroupObj = void 0;
                            var isMultiSelect = void 0;
                            if (this.diagram.selectedItems.nodes.length > 0) {
                                for (var i = 0; i < this.diagram.selectedItems.nodes.length; i++) {
                                    var swimlane = (this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].isLane
                                        || this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].isPhase);
                                    if (!swimlane) {
                                        if ((!(this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].parentObj instanceof Lane
                                            || this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].parentObj instanceof Phase))) {
                                            isGroupObj = this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].parentId !== '' ? true : false;
                                        }
                                    }
                                }
                            }
                            var currSelectedNodes = this.diagram.selectedItems.nodes;
                            for (var i = 0; i < prevSelectedNodes.length; i++) {
                                if ((prevSelectedNodes.length > 1 && currSelectedNodes[0].id
                                    === prevSelectedNodes[parseInt(i.toString(), 10)].id) || prevSelectedConnectors.length > 0) {
                                    isMultiSelect = true;
                                }
                            }
                            if (!this.isSwimlaneSelected && !unSelectLaneObj && !isMultiSelect && this.tool instanceof MoveTool &&
                                this.currentAction === 'Select' && (!isGroupObj || this.diagram.selectedItems.connectors.length > 0)) {
                                this.commandHandler.clearSelection(true);
                            }
                        }
                        this.isSwimlaneSelected = false;
                        this.tool.mouseUp(this.eventArgs);
                        if (this.diagram.checkMenu && (window.navigator.userAgent.indexOf('Linux') !== -1 || window.navigator.userAgent.indexOf('X11') !== -1)) {
                            if (!evt.pageY && (evt instanceof TouchEvent) && evt.changedTouches) {
                                window.getSelection().removeAllRanges();
                                this.diagram.contextMenuModule.contextMenu.open(evt.changedTouches[0].pageY, evt.changedTouches[0].pageX, this.diagram.element);
                                evt.preventDefault();
                            }
                            else {
                                this.diagram.contextMenuModule.contextMenu.open(evt.pageY, evt.pageX, this.diagram.element);
                            }
                            this.diagram.checkMenu = false;
                        }
                    }
                    if (history_1.hasStack) {
                        this.diagram.endGroupAction();
                    }
                }
                if (isGroupAction) {
                    this.diagram.endGroupAction();
                }
                this.updateContainerBounds(true);
                if (this.eventArgs.clickCount !== 2) {
                    this.commandHandler.updateSelectedNodeProperties(this.eventArgs.source);
                    if (avoidDropChildren) {
                        this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.PreventLaneContainerUpdate;
                        var nodes = this.eventArgs.source instanceof Selector
                            ? this.eventArgs.source.nodes : [this.eventArgs.source];
                        if (nodes) {
                            for (var i = 0; i < nodes.length; i++) {
                                if (!nodes[parseInt(i.toString(), 10)].container) {
                                    this.commandHandler.dropChildToContainer(this.eventArgs.target, nodes[parseInt(i.toString(), 10)]);
                                    this.commandHandler.renderContainerHelper(nodes[parseInt(i.toString(), 10)]);
                                }
                            }
                        }
                    }
                }
                if (this.diagram.selectedObject && this.diagram.selectedObject.helperObject) {
                    //Bug 884946: Undo redo not working for swimlane child node's label edit.
                    //committed to remove the diagram actions public method when actual object is inside swimlane.
                    var isInsideLane = this.isSwimlaneChild(this.diagram.selectedObject.actualObject);
                    //isSwimlaneChildHelper is used to check whether the helper object is child's helper of lane's helper. if it is lane's helper then we should not remove the DiagramAction.PublicMethod from diagram actions.
                    //If we remove the DiagramAction.PublicMethod from diagram actions then undo redo will not work properly after dropping child from diagram to swimlane.
                    var isSwimlaneChildHelper = this.diagram.selectedObject.actualObject &&
                        this.diagram.selectedObject.actualObject.width === this.diagram.selectedObject.helperObject.width &&
                        this.diagram.selectedObject.actualObject.height === this.diagram.selectedObject.helperObject.height;
                    this.diagram.remove(this.diagram.selectedObject.helperObject);
                    if (this.commandHandler.isTargetSubProcess(this.diagram.selectedObject.actualObject) && this.diagram.selectedObject.actualObject.parentId === '') {
                        this.swapProcessChildInDom(this.diagram.element.id + '_diagramLayer', this.diagram.selectedObject.actualObject);
                    }
                    this.diagram.selectedObject = { helperObject: undefined, actualObject: undefined };
                    // EJ2-42605 - Annotation undo redo not working properly if the line routing is enabled committed by sivakumar sekar
                    // committed to remove the diagram actions public method when line routing is enabled
                    // eslint-disable-next-line
                    if ((this.diagram.diagramActions & DiagramAction.PublicMethod) && (this.diagram.constraints & DiagramConstraints.LineRouting) || (isInsideLane && isSwimlaneChildHelper)) {
                        this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.PublicMethod;
                    }
                }
                this.blocked = false;
                if (this.hoverElement) {
                    var portVisibility = PortVisibility.Connect;
                    if (isSelected(this.diagram, this.hoverElement)) {
                        portVisibility |= PortVisibility.Hover;
                    }
                    this.diagram.updatePortVisibility(this.hoverElement, portVisibility, true);
                    this.hoverElement = null;
                }
                this.touchStartList = null;
                this.touchMoveList = null;
                if (!(this.tool instanceof TextDrawingTool)) {
                    this.tool = null;
                }
            }
            if (!touches) {
                evt.preventDefault();
            }
            this.diagram.currentDrawingObject = undefined;
            var selector = this.diagram.selectedItems;
            var disbleRenderSelector = false;
            if (this.commandHandler.isUserHandle(this.currentPosition)) {
                if (this.isForeignObject(evt.target)) {
                    disbleRenderSelector = true;
                }
            }
            if (!this.inAction && selector.wrapper && selector.userHandles.length > 0 && !disbleRenderSelector) {
                this.diagram.renderSelector(true);
            }
            if (!this.inAction && !this.diagram.currentSymbol && this.eventArgs) {
                /**
                 *
                 * EJ2-45543 Provide Event support to notify the port click
                 */
                var targetObject = this.getTargetElement();
                //909624: click event for fixed user handle notifies node as its element.
                var arg = {
                    element: (targetObject.target instanceof PointPort || targetObject.target instanceof PathPort ||
                        targetObject.target instanceof UserHandle || targetObject.target instanceof NodeFixedUserHandle ||
                        targetObject.target instanceof ConnectorFixedUserHandle)
                        ? targetObject.target : cloneBlazorObject(this.eventArgs.source) || cloneBlazorObject(this.diagram),
                    position: cloneBlazorObject(this.eventArgs.position), count: evt.detail,
                    actualObject: cloneBlazorObject(this.eventArgs.actualObject),
                    button: (evt.button === 0) ? 'Left' : (evt.button === 1) ? 'Middle' : 'Right'
                };
                //Removed isBlazor code
                if (this.diagram.tool !== DiagramTools.ZoomPan) {
                    this.diagram.triggerEvent(DiagramEvent.click, arg);
                }
            }
            this.eventArgs = {};
        }
        this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.PreventLaneContainerUpdate;
        if (updateAnnotation) {
            this.updateAnnotation(this.diagram.selectedItems);
        }
        // 920132: Node Interactions Cause Previously Deleted Nodes to Reappear
        this.previousElement = null;
        this.eventArgs = {};
        this.diagram.commandHandler.removeStackHighlighter(); // end the corresponding tool
    };
    //To check whether the node is child of swimlane or not.
    DiagramEventHandler.prototype.isSwimlaneChild = function (node) {
        if (node.shape && node.shape.type !== 'SwimLane') {
            var parent_1 = this.diagram.nameTable[node.parentId];
            if (!parent_1) {
                return false;
            }
            var swimlane = parent_1.parentId ? this.diagram.nameTable[parent_1.parentId] : parent_1;
            return swimlane && swimlane.shape && swimlane.shape.type === 'SwimLane';
        }
        else {
            return false;
        }
    };
    // To wrap connector annotation text based on the connector length.
    DiagramEventHandler.prototype.updateAnnotation = function (selectedItems) {
        var nodes = selectedItems.nodes;
        if (nodes.length > 0) {
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[parseInt(i.toString(), 10)];
                this.diagram.updateConnectorEdges(node);
            }
        }
    };
    // Adding child node of sub process in the diagram layer after the subprocess dropped out from swimlane to diagram.
    DiagramEventHandler.prototype.swapProcessChildInDom = function (diagramLayerId, node) {
        var diagramLayer = document.getElementById(diagramLayerId);
        if (node.shape.activity.subProcess.processes) {
            for (var i = 0; i < node.shape.activity.subProcess.processes.length; i++) {
                var child = document.getElementById(node.shape.activity.subProcess.processes[parseInt(i.toString(), 10)] + '_groupElement');
                if (child) {
                    diagramLayer.appendChild(child);
                }
            }
        }
    };
    /**
     * return the clicked element such as node/connector/port/diagram
     */
    DiagramEventHandler.prototype.getTargetElement = function () {
        var target;
        var objects = this.objectFinder.findObjectsUnderMouse(this.currentPosition, this.diagram, this.eventArgs, null, this.action);
        var obj = this.objectFinder.findObjectUnderMouse(this.diagram, objects, this.action, this.inAction, this.eventArgs, this.currentPosition);
        //909623: click the user handle of a node, click event triggered. the element is diagram instead of fixed user handle.
        if (this.previousAction !== 'None' && this.diagram.selectedItems.userHandles) {
            for (var i = 0; i < this.diagram.selectedItems.userHandles.length; i++) {
                var userHandle = this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)];
                if (this.previousAction === userHandle.name) {
                    target = userHandle;
                }
            }
        }
        var sourceElement = null;
        if (obj !== null) {
            sourceElement = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram);
            if (sourceElement) {
                target = this.commandHandler.findTarget(sourceElement, obj);
            }
        }
        var targetObject = {
            'obj': obj,
            'sourceElement': sourceElement,
            'target': target
        };
        return targetObject;
    };
    /* tslint:enable */
    DiagramEventHandler.prototype.getConnectorPadding = function (eventArgs) {
        var padding;
        var targetObject = eventArgs.source;
        if (targetObject && (targetObject instanceof Selector) && targetObject.connectors.length) {
            var selectedConnector = targetObject.connectors[0];
            padding = (selectedConnector.constraints & ConnectorConstraints.ConnectToNearByPort) ? selectedConnector.connectionPadding : 0;
        }
        else if (targetObject && (targetObject instanceof Connector) && this.action === 'PortDraw' && (this.tool instanceof ConnectorDrawingTool)) {
            if (targetObject.constraints & ConnectorConstraints.ConnectToNearByPort) {
                padding = targetObject.connectionPadding;
            }
        }
        return padding || 0;
    };
    DiagramEventHandler.prototype.addSwimLaneObject = function (selectedNode) {
        var swimlaneNode;
        var targetNode;
        var shape;
        var value;
        var canInsert;
        var index = 0;
        var offset;
        var actualShape = selectedNode.shape;
        var objects = this.objectFinder.findObjectsUnderMouse(this.currentPosition, this.diagram, this.eventArgs, null, this.action);
        if (!targetNode) {
            targetNode = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);
        }
        this.diagram.clearSelectorLayer();
        if (targetNode && !(targetNode.isLane || targetNode.isPhase || targetNode.isHeader)) {
            for (var i = 0; i < objects.length; i++) {
                var laneNode = this.diagram.nameTable[objects[parseInt(i.toString(), 10)].id];
                if (laneNode.isLane || laneNode.isPhase || laneNode.isHeader) {
                    targetNode = laneNode;
                }
            }
        }
        if (targetNode && (actualShape.isPhase || (actualShape.isLane && targetNode.isLane))) {
            var id = targetNode.parentId;
            swimlaneNode = this.diagram.nameTable["" + id];
        }
        var orientationSwap = null;
        if (swimlaneNode) {
            shape = swimlaneNode.shape;
            canInsert = (actualShape.isLane) ? actualShape.orientation === shape.orientation :
                actualShape.orientation !== shape.orientation;
            if (actualShape.isLane && actualShape.orientation !== shape.orientation) {
                canInsert = true;
                orientationSwap = actualShape.orientation === 'Horizontal' ? 'height' : 'width';
            }
        }
        if (canInsert && targetNode) {
            if (shape && shape.header && shape.hasHeader && shape.orientation === 'Horizontal') {
                index = 1;
            }
            if (shape.phases.length > 0) {
                index += 1;
            }
            if (actualShape.isPhase) {
                if (shape.orientation === 'Horizontal') {
                    offset = this.currentPosition.x - swimlaneNode.wrapper.bounds.x;
                }
                else {
                    offset = this.currentPosition.y - (swimlaneNode.wrapper.bounds.y +
                        (shape.hasHeader ? shape.header.height : 0));
                }
                var phases = { id: randomId(), offset: offset, header: { annotation: {
                            content: actualShape.phases[0].header === undefined ? 'Phase' : actualShape.phases[0].header.annotation.content,
                            style: actualShape.phases[0].header === undefined ? {} : actualShape.phases[0].header.annotation.style
                        } },
                    //882239 - Fill color not applied properly while adding phase at runtime
                    style: actualShape.phases[0] === undefined ? {} : actualShape.phases[0].style };
                this.diagram.addPhases(swimlaneNode, [phases]);
            }
            else {
                //const laneHeight: number = actualShape.lanes[0].header.height;
                var lane = {
                    id: randomId(), style: actualShape.lanes[0].style,
                    //Bug 912452: Disable canMove for lane symbol won't work when its tried to swap after its addition to swimlane
                    //Added canMove property to lane symbol which is dropped from symbol palette.
                    canMove: actualShape.lanes[0].canMove,
                    header: {
                        annotation: {
                            content: actualShape.lanes[0].header.annotation.content,
                            style: actualShape.lanes[0].header.annotation.style
                        },
                        style: actualShape.lanes[0].header.style
                    }
                };
                var orientation_1 = (actualShape.orientation === 'Horizontal') ? true : false;
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                orientation_1 ? lane.height = actualShape.lanes[0].height : lane.width = actualShape.lanes[0].width;
                if (shape.orientation === 'Horizontal') {
                    value = targetNode.rowIndex ? targetNode.rowIndex :
                        this.diagram.nameTable[targetNode.parentId].rowIndex;
                    if (targetNode.wrapper.offsetY < this.currentPosition.y) {
                        value += 1;
                    }
                }
                else {
                    value = targetNode.columnIndex ? targetNode.columnIndex :
                        this.diagram.nameTable[targetNode.parentId].columnIndex;
                    if (this.currentPosition.x < targetNode.wrapper.bounds.center.x) {
                        value -= 1;
                    }
                }
                if (shape.lanes.length > (value)) {
                    lane.header.width = shape.lanes[parseInt(value.toString(), 10)].header.width;
                    lane.header.height = shape.lanes[parseInt(value.toString(), 10)].header.height;
                }
                else {
                    //EJ2-64457 - Not able to add lane in the existing vertical swimlane.
                    var ind = void 0;
                    if (shape.orientation === 'Horizontal') {
                        ind = targetNode.rowIndex < 3 ? 0 : value - index - 1;
                    }
                    else {
                        ind = value - 1;
                    }
                    lane.header.width = shape.lanes[parseInt(ind.toString(), 10)].header.width;
                    lane.header.height = shape.lanes[parseInt(ind.toString(), 10)].header.height;
                }
                //Bug 879093: Incorrect helperguide for vertical and horizontal swim lanes.
                //With below code, we swap the height and width property of lane based on orientationSwap value.
                if (orientationSwap) {
                    if (orientationSwap === 'height') {
                        lane.width = lane.height;
                        delete lane.height;
                    }
                    else {
                        lane.height = lane.width;
                        delete lane.width;
                    }
                }
                this.diagram.addLanes(swimlaneNode, [lane], shape.orientation === 'Horizontal' ? value - index : value);
            }
            this.commandHandler.select(swimlaneNode);
        }
        else if (actualShape.isLane) {
            var swimLaneobj = {
                id: randomId(), width: selectedNode.width, height: selectedNode.height, addInfo: selectedNode.addInfo,
                shape: {
                    type: 'SwimLane',
                    header: {
                        //864525-Issue in updating swimlane header properties dynamically
                        annotation: {
                            content: actualShape.header === undefined ? 'Header' : actualShape.header.annotation.content,
                            style: actualShape.header === undefined ? {} : actualShape.header.annotation.style
                        },
                        height: 50,
                        style: actualShape.header ? actualShape.header.style : actualShape.lanes[0].header.style
                    },
                    phases: [{
                            id: randomId(),
                            //864555-Issue in updating swimlane phase properties dynamically
                            header: {
                                annotation: {
                                    content: actualShape.phases === undefined ? 'Phase' : actualShape.phases[0].header === undefined
                                        ? 'Phase' : actualShape.phases[0].header.annotation.content,
                                    style: actualShape.phases === undefined ? {} : actualShape.phases[0].header === undefined
                                        ? {} : actualShape.phases[0].header.annotation.style
                                },
                                style: actualShape.phases === undefined ? {} : actualShape.phases[0].header === undefined
                                    ? {} : actualShape.phases[0].header.style
                            },
                            style: actualShape.phases === undefined ? {} : actualShape.phases[0].style
                        }],
                    lanes: [{
                            id: randomId(), height: selectedNode.height, width: selectedNode.width, style: actualShape.lanes[0].style,
                            //Bug 912452: Disable canMove for lane symbol won't work when its tried to swap after its addition to swimlane
                            //Added canMove property to lane symbol which is dropped from symbol palette.
                            canMove: actualShape.lanes[0].canMove,
                            header: {
                                annotation: {
                                    content: actualShape.lanes[0].header.annotation.content,
                                    style: actualShape.lanes[0].header.annotation.style
                                },
                                style: actualShape.lanes[0].header.style
                            }
                        }], orientation: actualShape.orientation
                }
            };
            if (actualShape.orientation === 'Vertical') {
                swimLaneobj.width += 20;
            }
            swimLaneobj.offsetX = this.currentPosition.x + (swimLaneobj.width / 2);
            swimLaneobj.offsetY = this.currentPosition.y + (swimLaneobj.height / 2);
            //Bug 853721: Grid lines remain hidden when lane fill is set to transparent.
            // Added below code to set swimlane style for dropped swimlane.
            swimLaneobj.style = selectedNode.style;
            this.diagram.add(swimLaneobj);
        }
    };
    /** @private */
    DiagramEventHandler.prototype.mouseLeave = function (evt) {
        //Define what has to happen on mouse leave
        if (this.tool && this.inAction) {
            this.tool.mouseLeave(this.eventArgs);
        }
        if (this.diagram.selectedObject.helperObject) {
            this.updateContainerProperties();
            var isGroupAction = this.updateContainerBounds();
            if (isGroupAction) {
                this.diagram.endGroupAction();
            }
        }
        if (this.eventArgs && this.eventArgs.source) {
            this.diagram.updatePortVisibility(this.eventArgs.source, PortVisibility.Hover, true);
            this.hoverElement = null;
        }
        if (this.eventArgs && !this.eventArgs.source && this.hoverElement) {
            this.hoverElement = null;
        }
        if (this.tool instanceof ConnectTool && this.eventArgs && this.eventArgs.target && this.eventArgs.target instanceof Node) {
            this.diagram.updatePortVisibility(this.eventArgs.target, PortVisibility.Hover | PortVisibility.Connect, true);
            this.hoverElement = null;
        }
        var selector = this.diagram.selectedItems;
        if (selector && selector.wrapper) {
            if (!(selectionHasConnector(this.diagram, selector))) {
                this.diagram.renderSelector(true);
            }
        }
        if (this.diagram.diagramActions & DiagramAction.Interactions || this.diagram.diagramActions & DiagramAction.ToolAction) {
            this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.ToolAction;
        }
        this.isMouseDown = false;
        this.focus = false;
        this.touchStartList = null;
        this.touchMoveList = null;
        this.elementLeave();
        this.commandHandler.removeSnap();
        this.inAction = false;
        this.eventArgs = {};
        if (this.diagram.selectedObject && this.diagram.selectedObject.helperObject) {
            this.diagram.remove(this.diagram.selectedObject.helperObject);
            this.diagram.selectedObject = { helperObject: undefined, actualObject: undefined };
        }
        this.tool = null;
        removeRulerMarkers();
        if (this.action === 'Rotate') {
            this.diagram.diagramCanvas.classList.remove('e-diagram-rotate');
        }
        evt.preventDefault();
    };
    /** @private */
    DiagramEventHandler.prototype.mouseWheel = function (evt) {
        this.diagram.blazorActions |= BlazorAction.interaction;
        // EJ2-64831 - Need to provide support to override the mousewheel event
        var arg = {
            event: evt,
            cancel: false
        };
        this.diagram.triggerEvent(DiagramEvent.mouseWheel, arg);
        if (!arg.cancel) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var up = (evt.wheelDelta > 0 || -40 * evt.detail > 0) ? true : false;
            var mousePosition = this.getMousePosition(evt);
            this.diagram.tooltipObject.close();
            var ctrlKey = this.isMetaKey(evt);
            if (ctrlKey) {
                // SF-362356 - Command below line to implement smooth scroll in diagram.
                // this.diagram.zoom(up ? (1.2) : 1 / (1.2), mousePosition);
                // EJ2-59803 - Added the below code to get the zoom factor value from scroll settings and
                // set it to zoomFactor args in zoomTo method.
                var zoomFactor = this.diagram.scrollSettings.zoomFactor;
                if (up) {
                    this.diagram.zoomTo({ type: 'ZoomIn', zoomFactor: zoomFactor, focusPoint: mousePosition });
                }
                else {
                    this.diagram.zoomTo({ type: 'ZoomOut', zoomFactor: zoomFactor, focusPoint: mousePosition });
                }
                evt.preventDefault();
            }
            else {
                var horizontalOffset = this.diagram.scroller.horizontalOffset;
                var verticalOffset = this.diagram.scroller.verticalOffset;
                var change = up ? 10 : -10;
                if (this.tool && (this.tool instanceof PolygonDrawingTool || this.tool instanceof PolyLineDrawingTool)) {
                    this.eventArgs = {};
                    this.getMouseEventArgs(mousePosition, this.eventArgs);
                    this.eventArgs.position = mousePosition;
                    this.tool.mouseWheel(this.eventArgs);
                }
                this.diagram.scrollActions |= ScrollActions.Interaction;
                var canMouseWheel = true;
                if (evt.isTrusted) {
                    // Bug 829925: Scroll bar flickers on scrolling the diagram using touchpad.
                    // Added the below condition to check whether the mouse wheel is from trackpad or not.
                    var isTrackpadScroll = false;
                    // 878719: Resolve ESLint errors
                    // eslint-disable-next-line no-compare-neg-zero
                    if ((Math.abs(evt.deltaY) < 100 && Math.abs(evt.deltaX) === -0) ||
                        // 878719: Resolve ESLint errors
                        // eslint-disable-next-line no-compare-neg-zero
                        (Math.abs(evt.deltaX) < 100 && Math.abs(evt.deltaY) === -0)) {
                        isTrackpadScroll = true;
                    }
                    //Bug 892441: Infinite scroll not working in vertical axis of diagram.
                    //Due to the prevention of zoom method trigger in vertical scroll, the infinite scroll is not working in vertical axis.
                    //So added the below condition to check macOS and allowed the zoom method trigger in vertical scroll for non-MacOs.
                    var isMacOS = false;
                    if (evt.deltaX !== 0 || evt.deltaY !== 0) {
                        // Perform macOS detection
                        isMacOS = navigator.userAgent.includes('Macintosh');
                    }
                    //898867: Diagram scrolling is not smooth while scrolling with Track Pad in Mac.
                    if (isMacOS) {
                        var isHorizontalScroll = Math.abs(evt.deltaX) > Math.abs(evt.deltaY);
                        if (isHorizontalScroll) {
                            // eslint-disable-next-line no-compare-neg-zero
                            if (evt.shiftKey || (evt.deltaX && evt.deltaX !== -0 && (isTrackpadScroll || !isMacOS))) {
                                this.diagram.scroller.zoom(1, change, 0, mousePosition, canMouseWheel, undefined, isTrackpadScroll);
                            }
                        }
                        else {
                            // eslint-disable-next-line no-compare-neg-zero
                            if ((evt.deltaY && evt.deltaY !== -0 && (isTrackpadScroll || !isMacOS))) {
                                this.diagram.scroller.zoom(1, 0, change, mousePosition, canMouseWheel, undefined, isTrackpadScroll);
                            }
                        }
                    }
                    //Bug 837940: In mac, scrollbar flickers on horizontal and vertical scroll using trackpad.
                    else {
                        // 878719: Resolve ESLint errors
                        // eslint-disable-next-line no-compare-neg-zero
                        if (evt.shiftKey || (evt.deltaX && evt.deltaX !== -0 && (isTrackpadScroll || !isMacOS))) {
                            this.diagram.scroller.zoom(1, change, 0, mousePosition, canMouseWheel, undefined, isTrackpadScroll);
                        }
                        // eslint-disable-next-line no-compare-neg-zero
                        else if ((evt.deltaY && evt.deltaY !== -0 && (isTrackpadScroll || !isMacOS))) {
                            this.diagram.scroller.zoom(1, 0, change, mousePosition, canMouseWheel, undefined, isTrackpadScroll);
                        }
                    }
                }
                else {
                    // 878719: Resolve ESLint errors
                    // eslint-disable-next-line no-compare-neg-zero
                    if (evt.shiftKey || (evt.deltaX && evt.deltaX !== -0)) {
                        this.diagram.scroller.zoom(1, change, 0, mousePosition, canMouseWheel);
                    }
                    else {
                        this.diagram.scroller.zoom(1, 0, change, mousePosition, canMouseWheel);
                    }
                }
                this.diagram.scrollActions &= ~ScrollActions.Interaction;
                if (horizontalOffset !== this.diagram.scroller.horizontalOffset
                    || verticalOffset !== this.diagram.scroller.verticalOffset) {
                    evt.preventDefault();
                }
            }
            if (this.diagram.textEditing) {
                this.diagram.isTriggerEvent = true;
                if (this.diagram.activeLabel.parentId) {
                    var node = this.diagram.getObject(this.diagram.activeLabel.parentId);
                    this.diagram.startTextEdit(node, this.diagram.activeLabel.id);
                }
                this.diagram.isTriggerEvent = false;
            }
            this.diagram.blazorActions = this.diagram.blazorActions & ~BlazorAction.interaction;
        }
    };
    /** @private */
    DiagramEventHandler.prototype.keyDown = function (evt) {
        if (evt.fromMouseEvents) {
            if (evt.ctrlKey) {
                this.keyArgs.keyModifiers = 1;
            }
            if (evt.shiftKey) {
                this.keyArgs.keyModifiers = 4;
            }
            if (evt.shiftKey && evt.ctrlKey) {
                this.keyArgs.keyModifiers = 5;
            }
        }
        if (!(this.diagram.diagramActions & DiagramAction.TextEdit) &&
            !(this.checkEditBoxAsTarget(evt)) || (evt.key === 'Escape' || evt.keyCode === 27)) {
            var inAction = 'inAction';
            var command = void 0;
            var keycode = evt.keyCode ? evt.keyCode : evt.which;
            var key = evt.key;
            if (key === 'ArrowDown' || key === 'ArrowUp' || key === 'ArrowLeft' || key === 'ArrowRight') {
                this.isNudgeKey = true;
            }
            var ctrlKey = this.isMetaKey(evt);
            if (this.diagram.commandManager && this.diagram.commands) {
                var commands = this.diagram.commands;
                for (var _i = 0, _a = Object.keys(commands); _i < _a.length; _i++) {
                    var i_1 = _a[_i];
                    command = this.diagram.commands["" + i_1];
                    if (command && (command.gesture.keyModifiers || command.gesture.key)) {
                        //Added the split method to split the Number string from the enum while clicking the number keys
                        if ((keycode === command.gesture.key || (Keys[command.gesture.key] && key === Keys[command.gesture.key] || key === Keys[command.gesture.key].split('Number')[1])
                            || this.isDeleteKey(key, i_1))
                            && (((!command.gesture.keyModifiers) && (!evt.altKey) && (!evt.shiftKey) && (!ctrlKey)) ||
                                (command.gesture.keyModifiers && (ctrlKey || evt.altKey || evt.shiftKey) &&
                                    (this.altKeyPressed(command.gesture.keyModifiers) && evt.altKey) ||
                                    (this.shiftKeyPressed(command.gesture.keyModifiers) && evt.shiftKey) ||
                                    //added the comparision condition of keyargs to execute the condition onclicking the Ctrl + Shift key
                                    (this.ctrlKeyPressed(command.gesture.keyModifiers) && ctrlKey)
                                        && (this.keyArgs.keyModifiers === command.gesture.keyModifiers)))) {
                            var canExecute = getFunction(command.canExecute);
                            if (isBlazor() || (canExecute &&
                                canExecute({
                                    'keyDownEventArgs': KeyboardEvent,
                                    parameter: command.parameter
                                }))) {
                                evt.preventDefault();
                                if (evt.key === 'Escape') {
                                    if (this.checkEditBoxAsTarget(evt)) {
                                        document.getElementById(this.diagram.diagramCanvas.id).focus();
                                    }
                                    else if (this.diagram.currentSymbol) {
                                        var selectedSymbols = 'selectedSymbols';
                                        var source = 'sourceElement';
                                        var intDestroy = 'intDestroy';
                                        this.diagram.removeFromAQuad(this.diagram.currentSymbol);
                                        this.diagram.removeObjectsFromLayer(this.diagram.nameTable[this.diagram.currentSymbol.id]);
                                        this.diagram.removeElements(this.diagram.currentSymbol);
                                        var currentObj = this.diagram.currentSymbol;
                                        if (((currentObj) instanceof Node
                                            && (currentObj.shape.type === 'Bpmn')
                                            && currentObj.shape.shape === 'TextAnnotation')) {
                                            this.diagram.removeDependentConnector(currentObj);
                                        }
                                        removeChildNodes(this.diagram.currentSymbol, this.diagram);
                                        delete this.diagram.nameTable[this.diagram.currentSymbol.id];
                                        var sourceElement = this.diagram.droppable["" + source];
                                        sourceElement.draggable["" + intDestroy]();
                                        var element_1 = this.diagram.droppable["" + selectedSymbols];
                                        element_1.parentNode.removeChild(element_1);
                                        var diagramActions = this.diagram.diagramActions;
                                        this.diagram.diagramActions =
                                            this.diagram.addConstraints(diagramActions, DiagramAction.PreventClearSelection);
                                        this.tool.mouseUp(this.eventArgs);
                                        this.diagram.diagramRenderer.rendererActions = this.diagram.removeConstraints(this.diagram.diagramRenderer.rendererActions, RendererAction.DrawSelectorBorder);
                                        if (this.diagram.previousSelectedObject) {
                                            this.diagram.select(this.diagram.previousSelectedObject);
                                        }
                                        this.action = 'Select';
                                        this.diagram.previousSelectedObject = null;
                                        this.diagram.currentSymbol = null;
                                        this.diagram.diagramActions =
                                            this.diagram.removeConstraints(diagramActions, DiagramAction.PreventClearSelection);
                                        this.isMouseDown = false;
                                    }
                                    else if (this.inAction && this.diagram.drawingObject && this.tool && this.tool["" + inAction]) {
                                        this.tool.mouseUp(this.eventArgs);
                                        this.tool = null;
                                        this.isMouseDown = false;
                                    }
                                }
                                if (command.execute) {
                                    this.commandObj = command;
                                    if (this.diagram.tool !== DiagramTools.ZoomPan) {
                                        // if (i === 'nudgeUp' || i === 'nudgeRight' || i === 'nudgeDown' || i === 'nudgeLeft') {
                                        //     command.execute()
                                        // } else {
                                        var execute = getFunction(command.execute);
                                        // Bug 832880: Need to improve performance while nudging multiple nodes.
                                        if (this.isNudgeKey) {
                                            if (!this.isKeyUp) {
                                                this.keyArgs.oldValue = { offsetX: this.diagram.selectedItems.offsetX,
                                                    offsetY: this.diagram.selectedItems.offsetY };
                                                this.keyCount++;
                                                if (this.keyCount > 4) {
                                                    // 914747: Position change event not triggered for Keyboard nudge commands
                                                    execute({ 'keyDownEventArgs': KeyboardEvent, parameter: command.parameter, type: 'KEYDOWN' });
                                                    this.keyCount = 0;
                                                    this.keyArgs.newValue = { offsetX: this.diagram.selectedItems.offsetX,
                                                        offsetY: this.diagram.selectedItems.offsetY };
                                                    this.diagram.triggerEvent(DiagramEvent.positionChange, this.keyArgs);
                                                }
                                            }
                                            this.isKeyUp = false;
                                        }
                                        else {
                                            execute({ 'keyDownEventArgs': KeyboardEvent, parameter: command.parameter });
                                        }
                                    }
                                    // }
                                }
                                //Removed isBlazor code
                                break;
                            }
                        }
                    }
                }
            }
        }
        // eslint-disable-next-line
        var selectedObject = (this.diagram.selectedItems.nodes.length) ?
            this.diagram.selectedItems.nodes : this.diagram.selectedItems.connectors;
        var element = cloneBlazorObject(this.diagram.selectedItems);
        this.keyArgs = {
            element: element,
            key: evt.key, keyCode: evt.keyCode ? evt.keyCode : evt.which
        };
        this.getKeyModifier(this.keyArgs, evt);
        if ((this.diagram.diagramActions & DiagramAction.TextEdit)) {
            this.getlabel(this.keyArgs, evt);
        }
        this.diagram.triggerEvent(DiagramEvent.keyDown, this.keyArgs);
    };
    DiagramEventHandler.prototype.getlabel = function (args, evt) {
        var label = this.diagram.activeLabel;
        args.target = this.diagram.element.id + '_editBox';
        var node = this.diagram.nameTable[label.parentId];
        if (document.getElementById(this.diagram.element.id + '_editBox')) {
            args.text = document.getElementById(this.diagram.element.id + '_editBox').value;
            for (var i = 0; i < node.annotations.length; i++) {
                if (node.annotations[parseInt(i.toString(), 10)].id === label.id) {
                    args.label = node.annotations[parseInt(i.toString(), 10)];
                    break;
                }
            }
        }
    };
    DiagramEventHandler.prototype.getKeyModifier = function (args, evt) {
        args.keyModifiers = KeyModifiers.None;
        if (evt.ctrlKey) {
            args.keyModifiers |= KeyModifiers.Control;
        }
        if (evt.shiftKey) {
            args.keyModifiers |= KeyModifiers.Shift;
        }
        if (evt.altKey) {
            args.keyModifiers |= KeyModifiers.Alt;
        }
        if (this.isMetaKey(evt)) {
            args.keyModifiers |= KeyModifiers.Meta;
        }
    };
    DiagramEventHandler.prototype.keyUp = function (evt) {
        var element = cloneBlazorObject(this.diagram.selectedItems);
        this.keyArgs = {
            element: element, key: evt.key, keyCode: evt.keyCode ? evt.keyCode : evt.which,
            oldValue: { offsetX: element.offsetX, offsetY: element.offsetY },
            newValue: { offsetX: element.offsetX, offsetY: element.offsetY }
        };
        var selectedObject = (this.diagram.selectedItems.nodes.length) ?
            this.diagram.selectedItems.nodes : this.diagram.selectedItems.connectors;
        this.getKeyModifier(this.keyArgs, evt);
        if ((this.diagram.diagramActions & DiagramAction.TextEdit)) {
            this.getlabel(this.keyArgs, evt);
        }
        this.diagram.triggerEvent(DiagramEvent.keyUp, this.keyArgs);
        // this.isKeyUp = true;
        // Bug 832880: Need to improve performance while nudging multiple nodes.
        if (!this.isKeyUp && this.isNudgeKey) {
            //Bug 860080: Navigation not working in keyboard interaction SB sample.
            //To execute the command manager execute method below as we restricted keydown for arrow keys.
            var execute = getFunction(this.commandObj.execute);
            execute({ 'keyDownEventArgs': KeyboardEvent, parameter: this.commandObj.parameter, type: 'KEYUP' });
            // 914747: Position change event not triggered for Keyboard nudge commands
            this.keyArgs.newValue = { offsetX: this.diagram.selectedItems.offsetX, offsetY: this.diagram.selectedItems.offsetY };
            this.diagram.triggerEvent(DiagramEvent.positionChange, this.keyArgs);
            this.isNudgeKey = false;
            this.keyCount = 0;
        }
    };
    DiagramEventHandler.prototype.startAutoScroll = function (e) {
        var position = this.getMousePosition(e);
        position.x *= this.diagram.scroller.currentZoom;
        position.y *= this.diagram.scroller.currentZoom;
        var rulerSize = getRulerSize(this.diagram);
        var movingPosition;
        var autoScrollBorder = this.diagram.scrollSettings.autoScrollBorder;
        if (Browser.info.name === 'mozilla') {
            if (this.diagram.scroller.viewPortWidth === 0) {
                var bounds = document.getElementById(this.diagram.element.id).getBoundingClientRect();
                if (bounds.width !== this.diagram.scroller.viewPortWidth) {
                    this.diagram.scroller.setViewPortSize(bounds.width, bounds.height);
                }
            }
        }
        if (this.diagram.scrollSettings.canAutoScroll) {
            if (position.x + this.diagram.scroller.horizontalOffset + autoScrollBorder.right + rulerSize.width >=
                this.diagram.scroller.viewPortWidth - 18) {
                movingPosition = 'right';
            }
            else if (position.x + this.diagram.scroller.horizontalOffset < autoScrollBorder.left) {
                movingPosition = 'left';
            }
            else if (position.y + this.diagram.scroller.verticalOffset + autoScrollBorder.bottom + rulerSize.height >
                this.diagram.scroller.viewPortHeight - 18) {
                movingPosition = 'bottom';
            }
            else if (position.y + this.diagram.scroller.verticalOffset < autoScrollBorder.top) {
                movingPosition = 'top';
            }
        }
        return movingPosition;
    };
    DiagramEventHandler.prototype.doAutoScroll = function (option, e, delay, autoScroll) {
        var position = option;
        var canAutoScroll = true;
        if ((this.tool instanceof NodeDrawingTool || this.tool instanceof ConnectorDrawingTool
            || this.tool instanceof MoveTool || this.tool instanceof ResizeTool
            || this.tool instanceof SelectTool || this.tool instanceof ConnectTool) && this.inAction) {
            var pos = this.getMousePosition(e);
            var autoScrollBorder = this.diagram.scrollSettings.autoScrollBorder;
            var left = 0;
            var top_1 = 0;
            var canUpdate = false;
            var corner = '';
            var point = { x: pos.x, y: pos.y };
            // EJ2-61979 - Added below code to check whether we resize the node around four corners
            if (this.tool instanceof ResizeTool && (this.tool.corner === 'ResizeSouthEast' || this.tool.corner === 'ResizeSouthWest' ||
                this.tool.corner === 'ResizeNorthWest' || this.tool.corner === 'ResizeNorthEast')) {
                canUpdate = true;
                corner = this.tool.corner;
            }
            switch (position) {
                case 'right':
                    point.x = pos.x + 10;
                    left = 10;
                    // EJ2-61979 - If node gets resized on southeast or northeast corner means then update the y position along with x position
                    if (canUpdate) {
                        if (corner === 'ResizeSouthEast') {
                            point.y = pos.y + 10;
                            top_1 = 10;
                        }
                        else {
                            point.y = pos.y - 10;
                            top_1 = -10;
                        }
                    }
                    break;
                case 'left':
                    point.x = pos.x - 10;
                    left = -10;
                    // EJ2-61979 - If node gets resized on northwest or southwest corner means then update the y position along with x position
                    if (canUpdate) {
                        if (corner === 'ResizeNorthWest') {
                            point.y = pos.y - 10;
                            top_1 = -10;
                        }
                        else {
                            point.y = pos.y + 10;
                            top_1 = 10;
                        }
                    }
                    break;
                case 'bottom':
                    point.y = pos.y + 10;
                    top_1 = 10;
                    // EJ2-61979 - If node gets resized on southeast or southwest corner means then update the x position along with y position
                    if (canUpdate) {
                        if (corner === 'ResizeSouthEast') {
                            point.x = pos.x + 10;
                            left = 10;
                        }
                        else {
                            point.x = pos.x - 10;
                            left = -10;
                        }
                    }
                    break;
                case 'top':
                    point.y = pos.y - 10;
                    top_1 = -10;
                    // EJ2-61979 - If node gets resized on northeast or northwest corner means then update the x position along with y position
                    if (canUpdate) {
                        if (corner === 'ResizeNorthEast') {
                            point.x = pos.x + 10;
                            left = 10;
                        }
                        else {
                            point.x = pos.x - 10;
                            left = -10;
                        }
                    }
                    break;
            }
            this.eventArgs.position = { x: point.x, y: point.y };
            this.currentPosition = this.eventArgs.position;
            var objects = this.objectFinder.findObjectsUnderMouse(this.currentPosition, this.diagram, this.eventArgs, null, this.action);
            this.eventArgs.target = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);
            this.tool.mouseMove(this.eventArgs);
            this.diagram.scrollActions |= ScrollActions.Interaction;
            this.diagram.scroller.zoom(1, -left, -top_1, pos, canAutoScroll);
            this.diagram.scrollActions &= ~ScrollActions.Interaction;
        }
    };
    DiagramEventHandler.prototype.mouseEvents = function () {
        var target = this.diagram.findObjectsUnderMouse(this.currentPosition);
        for (var i = 0; i < target.length; i++) {
            if (this.eventArgs.actualObject === target[parseInt(i.toString(), 10)]) {
                target.splice(i, 1);
            }
        }
        var arg = {
            targets: {}
        };
        if (!isBlazor()) {
            arg = {
                targets: cloneBlazorObject(target),
                element: cloneBlazorObject((this.eventArgs.source === this.eventArgs.actualObject) ? undefined : this.eventArgs.source),
                actualObject: cloneBlazorObject(this.eventArgs.actualObject)
            };
        }
        //Removed isBlazor code
        if (this.lastObjectUnderMouse && this.diagram.mouseLeave
            && (!this.eventArgs.actualObject || (this.lastObjectUnderMouse !== this.eventArgs.actualObject))) {
            var arg_1 = {
                targets: undefined, element: cloneBlazorObject(this.lastObjectUnderMouse), actualObject: undefined
            };
            //Removed isBlazor code
            this.diagram.triggerEvent(DiagramEvent.mouseLeave, arg_1);
            this.lastObjectUnderMouse = null;
        }
        if (!this.lastObjectUnderMouse && this.eventArgs.source || (this.lastObjectUnderMouse !== this.eventArgs.actualObject)) {
            this.lastObjectUnderMouse = this.eventArgs.actualObject;
            if (this.eventArgs.actualObject !== undefined) {
                this.diagram.triggerEvent(DiagramEvent.mouseEnter, arg);
            }
        }
        if (this.eventArgs.actualObject) {
            this.diagram.triggerEvent(DiagramEvent.mouseOver, arg);
        }
    };
    DiagramEventHandler.prototype.elementEnter = function (mousePosition, elementOver) {
        if (!elementOver) {
            var isPrivateTooltip = ((this.hoverElement instanceof Node)
                && this.hoverElement.constraints & NodeConstraints.Tooltip)
                || ((this.hoverElement instanceof Connector)
                    && this.hoverElement.constraints & ConnectorConstraints.Tooltip)
                || ((this.hoverElement instanceof PointPort || this.hoverElement instanceof PathPort)
                    && this.hoverElement.constraints & PortConstraints.ToolTip)
                || ((this.hoverElement instanceof ShapeAnnotation || this.hoverElement instanceof PathAnnotation)
                    && this.hoverElement.constraints & AnnotationConstraints.Tooltip);
            var content = this.getContent();
            var children = void 0;
            if (this.hoverElement && this.hoverElement.children && this.hoverElement.children.length > 0) {
                // EJ2-56981 - Below method is used to check if the mouse pointer position and group children node gets intersect or not
                children = this.findIntersectChild(this.hoverElement);
            }
            if (this.hoverElement.tooltip.openOn === 'Auto' && content !== '') {
                // EJ2-56981 - If children returned means then update tooltip for child node else update tooltip for group node.
                if (children) {
                    updateTooltip(this.diagram, children);
                }
                else {
                    updateTooltip(this.diagram, isPrivateTooltip ? this.hoverElement : undefined);
                }
            }
            // EJ2-66418 - set tooltip relativeMode as mouse
            // Calculating offset position for relativeMode Mouse
            if (this.hoverElement.tooltip.content) {
                if (this.hoverElement.tooltip.relativeMode === 'Mouse') {
                    this.setTooltipOffset(mousePosition);
                }
                else {
                    this.diagram.tooltipObject.offsetX = 0;
                    this.diagram.tooltipObject.offsetY = 0;
                }
            }
            var objects = this.diagram.findObjectsUnderMouse(this.currentPosition);
            var obj = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);
            //848980 - Null exception occurs while hovering the ports
            if (obj !== null) {
                var targetEle = void 0;
                //840454 - support to provide isSticky property for tooltip in diagram control
                if (this.hoverElement.tooltip.isSticky) {
                    this.diagram.tooltipObject.isSticky = true;
                }
                if (obj instanceof Node && obj.children && obj.children.length > 0) {
                    // EJ2-56981 - If children returned means then update tooltip for child node else update tooltip for group node.
                    obj = children ? children : obj;
                }
                //EJ2-62120 - check if the Node has Ports and hoverElement is Port as mousepointer hovered over Port
                if (obj.ports && (this.hoverElement instanceof PointPort || this.hoverElement instanceof PathPort)) {
                    //executed to set target as port
                    targetEle = document.getElementById(obj.id + '_' + this.hoverElement.id);
                }
                else if (obj.annotations
                    && (this.hoverElement instanceof ShapeAnnotation || this.hoverElement instanceof PathAnnotation)) {
                    //executed to set target as annotation
                    targetEle = document.getElementById(obj.id + '_' + this.hoverElement.id);
                }
                else {
                    //executed to set target as Node or Connector
                    var idName = (obj.shape && ((obj.shape) instanceof Native)) ? '_content_native_element' : '_groupElement';
                    targetEle = document.getElementById(obj.id + idName);
                }
                if (this.hoverElement.tooltip.openOn === 'Auto' && content !== '') {
                    this.diagram.tooltipObject.close();
                    this.diagram.tooltipObject.openOn = this.hoverElement.tooltip.openOn;
                    //Removed isBlazor code
                    this.diagram.tooltipObject.dataBind();
                }
                if (canEnableToolTip(this.hoverElement, this.diagram) && this.hoverElement.tooltip.openOn === 'Auto') {
                    this.diagram.tooltipObject.target = this.hoverElement.id;
                    if (this.hoverElement.tooltip.relativeMode === 'Mouse') {
                        this.diagram.tooltipObject.open(this.diagram.element);
                    }
                    else {
                        this.diagram.tooltipObject.open(targetEle);
                    }
                }
            }
        }
    };
    DiagramEventHandler.prototype.elementLeave = function () {
        if (this.diagram.tooltipObject && !this.diagram.tooltipObject.isSticky && this.diagram.tooltipObject.openOn !== 'Custom') {
            this.diagram.tooltipObject.close();
        }
    };
    // EJ2-66418 - set tooltip relativeMode as mouse
    // Calculating offset position for relativeMode Mouse
    DiagramEventHandler.prototype.setTooltipOffset = function (mousePosition) {
        var point = this.updatePointBasedOnScale(mousePosition);
        var offset = getTooltipOffset(this.diagram, point, this.hoverElement);
        this.diagram.tooltipObject.offsetX = offset.x;
        this.diagram.tooltipObject.offsetY = offset.y;
    };
    DiagramEventHandler.prototype.updatePointBasedOnScale = function (mousePosition) {
        var scale = this.diagram.scaleValue;
        var point = { x: mousePosition.x * scale, y: mousePosition.y * scale };
        return point;
    };
    DiagramEventHandler.prototype.altKeyPressed = function (keyModifier) {
        if (keyModifier & KeyModifiers.Alt) {
            return true;
        }
        return false;
    };
    DiagramEventHandler.prototype.ctrlKeyPressed = function (keyModifier) {
        if (keyModifier & KeyModifiers.Control) {
            return true;
        }
        return false;
    };
    DiagramEventHandler.prototype.shiftKeyPressed = function (keyModifier) {
        if (keyModifier & KeyModifiers.Shift) {
            return true;
        }
        return false;
    };
    /** @private */
    DiagramEventHandler.prototype.scrolled = function (evt) {
        this.diagram.updateScrollOffset();
        //Removed isBlazor code
    };
    DiagramEventHandler.prototype.isMobileOrIPadDevice = function () {
        var userAgent = navigator.userAgent || navigator.vendor || window.opera;
        //Bug 931502: Unable to complete polyline drawing on ipad safari browser.
        // Check for iPads on iOS 13+ (Safari reports as Mac desktop)
        if (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) {
            return 'iOS (iPad)';
        }
        // Check for iOS devices (iPhone, iPad, iPod)
        if (/iPhone|iPad|iPod/.test(userAgent) && !window.MSStream) {
            return 'iOS';
        }
        // Check for Android devices
        if (/android/i.test(userAgent)) {
            return 'Android';
        }
        // Check for other mobile devices (general fallback)
        if (/Mobile|Tablet/.test(userAgent)) {
            return 'Mobile';
        }
        return 'Desktop';
    };
    /** @private */
    DiagramEventHandler.prototype.doubleClick = function (evt) {
        if (canUserInteract(this.diagram)) {
            //Bug 916653: Issue with drawing Polyline in iPad.
            //Added below code to check for mobile and ipad device.
            var isMobileOrIPad = this.isMobileOrIPadDevice();
            var curTool = this.diagram.tool;
            if ((isMobileOrIPad !== 'Desktop') && (this.tool && (this.tool instanceof PolygonDrawingTool || this.tool instanceof PolyLineDrawingTool))) {
                this.diagram.tool = 0;
            }
            var annotation = void 0;
            var objects = this.diagram.findObjectsUnderMouse(this.currentPosition);
            var obj = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);
            if (obj !== null && canUserInteract(this.diagram)) {
                annotation = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram);
                if (this.tool && (this.tool instanceof PolygonDrawingTool || this.tool instanceof PolyLineDrawingTool)) {
                    var arg_2 = {
                        source: cloneBlazorObject(obj),
                        position: this.currentPosition, count: evt.detail
                    };
                    this.diagram.tool = curTool;
                    this.tool.mouseUp(this.eventArgs);
                    this.isMouseDown = false;
                    this.eventArgs = {};
                    this.tool = null;
                    evt.preventDefault();
                }
                else {
                    var layer = this.diagram.commandHandler.getObjectLayer(obj.id);
                    if (layer && !layer.lock && layer.visible) {
                        if (!(this.diagram.diagramActions & DiagramAction.TextEdit)) {
                            var id = '';
                            this.diagram.startTextEdit(obj, id || (annotation instanceof TextElement ?
                                (annotation.id).split(obj.id + '_')[1] : undefined));
                        }
                    }
                }
            }
            var arg = {
                source: cloneBlazorObject(obj) || cloneBlazorObject(this.diagram),
                position: this.currentPosition, count: evt.detail
            };
            //Removed isBlazor code
            this.diagram.triggerEvent(DiagramEvent.doubleClick, arg);
        }
    };
    /**
     * @private
     */
    DiagramEventHandler.prototype.itemClick = function (actualTarget, diagram) {
        var obj = actualTarget;
        if (checkParentAsContainer(this.diagram, obj, true)) {
            return obj;
        }
        return null;
    };
    /**
     * @private
     */
    DiagramEventHandler.prototype.inputChange = function (evt) {
        var minWidth = 90;
        var maxWidth;
        var minHeight = 12;
        var fontsize;
        var textWrapper;
        var node;
        var height;
        var width;
        var textBounds;
        var transforms;
        var scale;
        var editTextBox = document.getElementById(this.diagram.element.id + '_editBox');
        var editTextBoxDiv = document.getElementById(this.diagram.element.id + '_editTextBoxDiv');
        var text = (editTextBox.value);
        var line = text.split('\n');
        node = (this.diagram.selectedItems.nodes[0]) ? this.diagram.selectedItems.nodes[0] : this.diagram.selectedItems.connectors[0];
        if ((!node && this.tool instanceof TextDrawingTool) || (node && node.shape.type === 'SwimLane')) {
            node = this.diagram.nameTable[this.diagram.activeLabel.parentId];
        }
        if (node && ((node.shape.type !== 'Text' && node.annotations.length > 0) || (node.shape.type === 'Text'))) {
            textWrapper = this.diagram.getWrapper(node.wrapper, this.diagram.activeLabel.id);
            maxWidth = node.wrapper.bounds.width < textWrapper.bounds.width ? node.wrapper.bounds.width : textWrapper.bounds.width;
            maxWidth = maxWidth > minWidth ? maxWidth : minWidth;
            textBounds = measureHtmlText(textWrapper.style, text, undefined, undefined, maxWidth);
            fontsize = Number((editTextBox.style.fontSize).split('px')[0]);
            if (line.length > 1 && line[line.length - 1] === '') {
                textBounds.height = textBounds.height + fontsize;
            }
            transforms = this.diagram.scroller.transform;
            scale = canZoomTextEdit(this.diagram) ? transforms.scale : 1;
            width = textBounds.width;
            width = ((minWidth > width) ? minWidth : width) * scale;
            height = ((minHeight > textBounds.height) ? minHeight : textBounds.height) * scale;
            editTextBoxDiv.style.left = ((((textWrapper.bounds.center.x + transforms.tx) * transforms.scale) - width / 2) - 2.5) + 'px';
            editTextBoxDiv.style.top = ((((textWrapper.bounds.center.y + transforms.ty) * transforms.scale) - height / 2) - 3) + 'px';
            editTextBoxDiv.style.width = width + 'px';
            editTextBoxDiv.style.height = height + 'px';
            editTextBox.style.minHeight = minHeight + 'px';
            editTextBox.style.minWidth = minWidth + 'px';
            editTextBox.style.width = width + 'px';
            editTextBox.style.height = height + 'px';
        }
    };
    /**
     * @private
     */
    DiagramEventHandler.prototype.isAddTextNode = function (node, focusOut) {
        if (this.tool instanceof TextDrawingTool || focusOut) {
            this.tool = null;
            if (node && (!(canContinuousDraw(this.diagram)))) {
                this.diagram.drawingObject = undefined;
                this.diagram.currentDrawingObject = undefined;
            }
            if (getObjectFromCollection(this.diagram.nodes, node.id) ||
                getObjectFromCollection(this.diagram.connectors, node.id)) {
                return false;
            }
            return true;
        }
        return false;
    };
    DiagramEventHandler.prototype.checkEditBoxAsTarget = function (evt) {
        if ((evt.target && evt.target.id === this.diagram.element.id + '_editBox')) {
            return true;
        }
        return false;
    };
    DiagramEventHandler.prototype.getMouseEventArgs = function (position, args, source, padding) {
        args.position = position;
        var obj;
        var objects;
        if (!source) {
            if (this.action === 'Drag' || this.action === 'ConnectorSourceEnd' || this.action === 'SegmentEnd' ||
                this.action === 'OrthoThumb' || this.action === 'BezierSourceThumb' || this.action === 'BezierTargetThumb' ||
                this.action === 'ConnectorTargetEnd' || this.action.indexOf('Rotate') !== -1 || this.action.indexOf('Resize') !== -1) {
                obj = this.diagram.selectedItems;
                if (!this.diagram.currentSymbol && this.action === 'Drag' && obj && this.diagram.selectedItems.nodes.length > 0 &&
                    this.diagram.selectedItems.nodes[0].shape.type === 'SwimLane') {
                    objects = this.diagram.findObjectsUnderMouse(this.currentPosition);
                    obj = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);
                }
            }
            else {
                objects = this.diagram.findObjectsUnderMouse(this.currentPosition);
                obj = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);
            }
        }
        else {
            objects = this.diagram.findObjectsUnderMouse(this.currentPosition, source);
            obj = this.diagram.findTargetObjectUnderMouse(objects, this.action, this.inAction, args.position, source);
        }
        if (obj && obj.isHeader) {
            obj = this.diagram.nameTable[obj.parentId];
            this.eventArgs.actualObject = obj;
        }
        var wrapper;
        if (obj) {
            wrapper = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram, padding);
            var currentConnector = void 0;
            var nearNode = void 0;
            var i = void 0;
            if ((wrapper && obj.ports && obj.ports.length
                && !checkPort(obj, wrapper) || !wrapper || !obj) && objects && objects.length
                && (source instanceof Selector)) {
                currentConnector = source.connectors[0];
                for (i = objects.length - 1; i >= 0; i--) {
                    nearNode = objects[parseInt(i.toString(), 10)];
                    if ((nearNode instanceof Node || nearNode instanceof Connector) && currentConnector
                        && currentConnector.connectionPadding) {
                        obj = nearNode;
                        wrapper = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram, padding);
                        if (((currentConnector.constraints & ConnectorConstraints.ConnectToNearByPort) && obj &&
                            obj.ports && obj.ports.length && checkPort(obj, wrapper))) {
                            break;
                        }
                        if ((nearNode instanceof Node || nearNode instanceof Connector) && currentConnector
                            && currentConnector.connectionPadding && nearNode.wrapper.outerBounds.containsPoint(this.currentPosition)
                            && (currentConnector.constraints & ConnectorConstraints.ConnectToNearByNode)
                            && !(currentConnector.constraints & ConnectorConstraints.ConnectToNearByPort)) {
                            obj = nearNode;
                            wrapper = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram, 0);
                            break;
                        }
                    }
                }
            }
        }
        if (!source) {
            args.source = obj;
            args.sourceWrapper = wrapper;
        }
        else {
            args.target = obj;
            args.targetWrapper = wrapper;
        }
        args.actualObject = this.eventArgs.actualObject;
        if (args.source instanceof Selector && args.actualObject === undefined &&
            (args.source.nodes.length > 0 || args.source.connectors.length > 0)) {
            args.actualObject = args.source.nodes.length > 0 ? this.diagram.nameTable[args.source.nodes[0].id]
                : this.diagram.nameTable[args.source.connectors[0].id];
        }
        args.startTouches = this.touchStartList;
        args.moveTouches = this.touchMoveList;
        return args;
    };
    /** @private */
    DiagramEventHandler.prototype.resetTool = function () {
        this.action = 'Select';
        this.hoverElement = null;
        this.hoverNode = null;
        this.tool = this.diagram.getTool(this.action);
        this.updateCursor();
    };
    /** @private */
    DiagramEventHandler.prototype.updateTool = function () {
        // 912436: Update Tool at runtime
        if (!this.currentPosition) {
            this.action = 'Select';
        }
        else {
            var objects = this.diagram.findObjectsUnderMouse(this.currentPosition);
            var obj = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);
            var sourceElement = null;
            var target = void 0;
            if (obj !== null) {
                sourceElement = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram);
            }
            if (sourceElement) {
                target = this.commandHandler.findTarget(sourceElement, obj);
            }
            this.action = this.diagram.findActionToBeDone(obj, sourceElement, this.currentPosition, target);
        }
    };
    /** @private */
    DiagramEventHandler.prototype.getTool = function (action) {
        switch (action) {
            case 'Select':
                return new SelectTool(this.commandHandler, true);
            case 'Drag':
                return new MoveTool(this.commandHandler);
            case 'Rotate':
                return new RotateTool(this.commandHandler);
            case 'LayoutAnimation':
                return new ExpandTool(this.commandHandler);
            case 'FixedUserHandle':
                return new FixedUserHandleTool(this.commandHandler, true);
            case 'Hyperlink':
                return new LabelTool(this.commandHandler);
            case 'ResizeSouthEast':
            case 'ResizeSouthWest':
            case 'ResizeNorthEast':
            case 'ResizeNorthWest':
            case 'ResizeSouth':
            case 'ResizeNorth':
            case 'ResizeWest':
            case 'ResizeEast':
                return new ResizeTool(this.commandHandler, action);
            case 'ConnectorSourceEnd':
            case 'ConnectorTargetEnd':
            case 'BezierSourceThumb':
            case 'BezierTargetThumb':
                return new ConnectTool(this.commandHandler, action);
            case 'SegmentEnd':
            case 'OrthoThumb':
                return new ConnectorEditing(this.commandHandler, action);
            case 'Draw':
                var shape = 'shape';
                var type = findObjectType(this.diagram.drawingObject);
                if (type === 'Node' && this.diagram.drawingObject.shape.type === 'Text') {
                    return new TextDrawingTool(this.commandHandler);
                }
                else if (type === 'Connector' && this.diagram.drawingObject.type === 'Freehand') {
                    return new FreeHandTool(this.commandHandler);
                }
                else if (type === 'Node' && (this.diagram.drawingObject.shape["" + shape] === 'Polygon') &&
                    !(this.diagram.drawingObject.shape.points)) {
                    return new PolygonDrawingTool(this.commandHandler);
                }
                else if (type === 'Node' ||
                    (type === 'Node' && this.diagram.drawingObject.shape["" + shape] === 'Polygon' &&
                        (this.diagram.drawingObject.shape.points))) {
                    return new NodeDrawingTool(this.commandHandler, this.diagram.drawingObject);
                }
                else if (type === 'Connector' && this.diagram.drawingObject.type === 'Polyline') {
                    return new PolyLineDrawingTool(this.commandHandler);
                }
                else if (type === 'Connector') {
                    return new ConnectorDrawingTool(this.commandHandler, 'ConnectorSourceEnd', this.diagram.drawingObject);
                }
                break;
            case 'Pan':
                return new ZoomPanTool(this.commandHandler, false);
            case 'PinchZoom':
                return new ZoomPanTool(this.commandHandler, true);
            case 'PortDrag':
                return new MoveTool(this.commandHandler, 'Port');
            case 'PortDraw':
                return new ConnectorDrawingTool(this.commandHandler, 'ConnectorSourceEnd', this.diagram.drawingObject);
            case 'LabelSelect':
                return new SelectTool(this.commandHandler, true, 'LabelSelect');
            case 'LabelDrag':
                return new LabelDragTool(this.commandHandler);
            case 'LabelResizeSouthEast':
            case 'LabelResizeSouthWest':
            case 'LabelResizeNorthEast':
            case 'LabelResizeNorthWest':
            case 'LabelResizeSouth':
            case 'LabelResizeNorth':
            case 'LabelResizeWest':
            case 'LabelResizeEast':
                return new LabelResizeTool(this.commandHandler, action);
            case 'LabelRotate':
                return new LabelRotateTool(this.commandHandler);
            //for coverage
            // case 'Custom':
            //     return this.diagram.getTool(action);
        }
        return null;
    };
    /** @private */
    DiagramEventHandler.prototype.getCursor = function (action) {
        var object = (this.diagram.selectedItems.annotation) ?
            this.diagram.selectedItems.wrapper.children[0] : this.diagram.selectedItems;
        var rotateAngle = (this.diagram.selectedItems.annotation) ?
            (object.rotateAngle + object.parentTransform) : object.rotateAngle;
        return getCursor(action, rotateAngle);
    };
    //start region - interface betweend diagram and interaction
    /** @private */
    DiagramEventHandler.prototype.findElementUnderMouse = function (obj, position, diagram, padding) {
        return this.objectFinder.findElementUnderSelectedItem(obj, position, diagram, padding);
    };
    /** @private */
    DiagramEventHandler.prototype.findObjectsUnderMouse = function (position, source) {
        return this.objectFinder.findObjectsUnderMouse(position, this.diagram, this.eventArgs, source);
    };
    /** @private */
    DiagramEventHandler.prototype.findObjectUnderMouse = function (objects, action, inAction) {
        return this.objectFinder.findObjectUnderMouse(this.diagram, objects, action, inAction, this.eventArgs, this.currentPosition);
    };
    /** @private */
    DiagramEventHandler.prototype.findTargetUnderMouse = function (objects, action, inAction, position, source) {
        return this.objectFinder.findObjectUnderMouse(this.diagram, objects, action, inAction, this.eventArgs, position, source);
    };
    /** @private */
    DiagramEventHandler.prototype.findActionToBeDone = function (obj, wrapper, position, target) {
        return findToolToActivate(obj, wrapper, this.currentPosition, this.diagram, this.touchStartList, this.touchMoveList, target);
    };
    DiagramEventHandler.prototype.updateContainerBounds = function (isAfterMouseUp) {
        var isGroupAction = false;
        if (this.diagram.selectedObject.helperObject && this.diagram.selectedObject.actualObject) {
            var obj = this.diagram.selectedObject.actualObject;
            var nodes = this.diagram.selectedObject.actualObject instanceof Selector ? obj.nodes : [obj];
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[parseInt(i.toString(), 10)];
                var boundsUpdate = (this.tool instanceof ResizeTool) ? true : false;
                var parentNode = this.diagram.nameTable[node.parentId];
                if (isAfterMouseUp) {
                    removeChildInContainer(this.diagram, node, this.currentPosition, boundsUpdate);
                }
                else {
                    if (!parentNode || (parentNode && parentNode.shape.type !== 'SwimLane')) {
                        this.diagram.updateDiagramObject(node);
                    }
                    isGroupAction = updateCanvasBounds(this.diagram, node, this.currentPosition, boundsUpdate);
                    this.diagram.updateSelector();
                    if (node.isLane || node.isPhase) {
                        this.diagram.clearSelection();
                        this.commandHandler.selectObjects([node]);
                    }
                }
            }
        }
        return isGroupAction;
    };
    // tslint:disable-next-line:max-func-body-length
    DiagramEventHandler.prototype.updateContainerProperties = function () {
        var helperObject;
        var isChangeProperties = false;
        var hasStack;
        var connectors;
        var hasGroup = false;
        var obj;
        var history = { hasStack: false, isPreventHistory: false };
        if (this.diagram.selectedObject.helperObject) {
            var objects = this.diagram.findObjectsUnderMouse(this.currentPosition);
            var target = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);
            helperObject = this.diagram.selectedObject.helperObject;
            obj = this.diagram.selectedObject.actualObject;
            if (obj instanceof Node) {
                if (obj.shape.type === 'SwimLane') {
                    connectors = getConnectors(this.diagram, obj.wrapper.children[0]);
                }
                if (obj.shape.type !== 'SwimLane' && obj.parentId &&
                    this.diagram.getObject(obj.parentId).shape.type === 'SwimLane') {
                    if (target instanceof Node && this.diagram.getObject(target.parentId) &&
                        this.diagram.getObject(target.parentId).shape.type !== 'SwimLane') {
                        target = this.diagram.getObject(target.parentId);
                    }
                }
                if (this.currentAction === 'Drag' && obj.container && obj.container.type === 'Canvas' && obj.parentId &&
                    this.diagram.getObject(obj.parentId).shape.type === 'SwimLane' && target &&
                    target.container && target.container.type === 'Canvas' && target.isLane &&
                    obj.isLane && target.parentId === obj.parentId) {
                    if (target !== obj) {
                        laneInterChanged(this.diagram, obj, target, this.currentPosition);
                    }
                    history.isPreventHistory = true;
                }
                else {
                    var parentNode = this.diagram.nameTable[obj.parentId];
                    if (!parentNode || (parentNode && parentNode.shape.type !== 'SwimLane')) {
                        if (parentNode && parentNode.isLane && (obj.constraints & NodeConstraints.AllowMovingOutsideLane)) {
                            // 915151: Node Becomes Unmovable After Deleting the First Phase
                            var swimlane = this.diagram.getObject(parentNode.parentId);
                            var x = void 0;
                            var y = void 0;
                            if (swimlane.shape.orientation === 'Vertical') {
                                x = swimlane.wrapper.bounds.x + swimlane.shape.phaseSize;
                                y = swimlane.wrapper.bounds.y + swimlane.shape.header.height;
                            }
                            else {
                                var header = swimlane.shape.header.height +
                                    swimlane.shape.phaseSize;
                                x = swimlane.wrapper.bounds.x;
                                y = swimlane.wrapper.bounds.y + header;
                            }
                            var width = swimlane.wrapper.bounds.bottomRight.x - x;
                            var height = swimlane.wrapper.bounds.bottomRight.y - y;
                            var swimlaneBounds = new Rect(x, y, width, height);
                            if (swimlaneBounds.containsPoint(this.currentPosition)) {
                                obj.offsetX = helperObject.offsetX;
                                obj.offsetY = helperObject.offsetY;
                                obj.width = helperObject.width;
                                obj.height = helperObject.height;
                                obj.rotateAngle = helperObject.rotateAngle;
                            }
                        }
                        else {
                            // 902192: Diagram node resized wrongly while dragging with multiple selection Inside a swimlane Issue Fix
                            if (this.diagram.selectedItems.nodes.length === 1) {
                                // Single node move with helper
                                obj.offsetX = helperObject.offsetX;
                                obj.offsetY = helperObject.offsetY;
                                if (obj && obj.shape && obj.shape.type !== 'UmlClassifier') {
                                    obj.width = helperObject.width;
                                    obj.height = helperObject.height;
                                }
                                obj.rotateAngle = helperObject.rotateAngle;
                            }
                            else if (this.diagram.selectedItems.nodes.length > 1) {
                                // Multi selected node move with helper
                                var offsetX = (helperObject.offsetX - this.diagram.selectedItems.offsetX);
                                var offsetY = (helperObject.offsetY - this.diagram.selectedItems.offsetY);
                                var rotateAngle = (helperObject.rotateAngle - this.diagram.selectedItems.rotateAngle);
                                for (var i = 0; i < this.diagram.selectedItems.nodes.length; i++) {
                                    this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].offsetX += offsetX;
                                    this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].offsetY += offsetY;
                                    this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].rotateAngle += rotateAngle;
                                }
                            }
                        }
                    }
                    var undoElement = void 0;
                    if (parentNode && parentNode.container && parentNode.container.type === 'Stack') {
                        this.diagram.startGroupAction();
                        hasGroup = true;
                    }
                    if (!target && parentNode && parentNode.container && parentNode.container.type === 'Stack' && this.action === 'Drag') {
                        var index = parentNode.wrapper.children.indexOf(obj.wrapper);
                        undoElement = { targetIndex: undefined, target: undefined, sourceIndex: index, source: cloneObject(obj) };
                        if (index > -1) {
                            var children = parentNode.children;
                            children.splice(children.indexOf(obj.id), 1);
                            this.diagram.nameTable[obj.id].parentId = '';
                            hasStack = true;
                            parentNode.wrapper.children.splice(index, 1);
                        }
                    }
                    moveChildInStack(obj, target, this.diagram, this.action);
                    parentNode = checkParentAsContainer(this.diagram, obj) ? this.diagram.nameTable[obj.parentId] :
                        (this.diagram.nameTable[obj.parentId] || obj);
                    if (parentNode && parentNode.container && parentNode.container.type === 'Canvas') {
                        parentNode.wrapper.maxWidth = parentNode.maxWidth = parentNode.wrapper.actualSize.width;
                        parentNode.wrapper.maxHeight = parentNode.maxHeight = parentNode.wrapper.actualSize.height;
                        isChangeProperties = true;
                    }
                    if (checkParentAsContainer(this.diagram, obj, true) && parentNode && parentNode.container.type === 'Canvas') {
                        if (this.diagram.selectedItems.nodes.length > 1) {
                            // 902192: Diagram node resized wrongly while dragging with multiple selection Inside a swimlane Issue Fix
                            for (var i = 0; i < this.diagram.selectedItems.nodes.length; i++) {
                                checkChildNodeInContainer(this.diagram, this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)]);
                            }
                        }
                        else {
                            checkChildNodeInContainer(this.diagram, obj);
                        }
                    }
                    else {
                        history = this.updateContainerPropertiesExtend(parentNode, obj, connectors, helperObject, history);
                    }
                    if ((this.diagram.lineRoutingModule && (this.diagram.constraints & DiagramConstraints.LineRouting))
                        && (!checkParentAsContainer(this.diagram, obj, true))) {
                        if (obj.children) {
                            this.diagram.realActions |= RealAction.EnableGroupAction;
                        }
                        this.diagram.nodePropertyChange(obj, {}, {
                            width: obj.width, height: obj.height,
                            offsetX: obj.offsetX, offsetY: obj.offsetY
                        });
                        if (obj.children) {
                            this.diagram.realActions &= ~RealAction.EnableGroupAction;
                        }
                    }
                    if (obj.shape.lanes) {
                        this.updateLaneChildNode(obj);
                    }
                    if (isChangeProperties) {
                        parentNode.maxWidth = parentNode.wrapper.maxWidth = undefined;
                        parentNode.maxHeight = parentNode.wrapper.maxHeight = undefined;
                    }
                    if (hasStack) {
                        this.diagram.nodePropertyChange(parentNode, {}, {
                            offsetX: parentNode.offsetX, offsetY: parentNode.offsetY, width: parentNode.width, height: parentNode.height,
                            rotateAngle: parentNode.rotateAngle
                        });
                        var entry = {
                            redoObject: { sourceIndex: undefined, source: undoElement.source },
                            type: 'StackChildPositionChanged', undoObject: undoElement, category: 'Internal'
                        };
                        if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {
                            this.diagram.addHistoryEntry(entry);
                        }
                    }
                    if (obj && obj.container && (obj.container.type === 'Stack' ||
                        (obj.container.type === 'Canvas' && obj.parentId === ''))) {
                        if (obj && obj.shape && obj.shape.type === 'UmlClassifier') {
                            obj.wrapper.measureChildren = true;
                        }
                        this.diagram.nodePropertyChange(obj, {}, {
                            offsetX: obj.offsetX, offsetY: obj.offsetY, width: obj.width, height: obj.height, rotateAngle: obj.rotateAngle
                        });
                        if (obj && obj.shape && obj.shape.type === 'UmlClassifier') {
                            obj.wrapper.measureChildren = false;
                        }
                    }
                }
                updateConnectorsProperties(connectors, this.diagram);
                history.hasStack = hasGroup;
            }
            // Bug:914714 Drag Drop Multi selected nodes between lanes.
            else if (obj instanceof Selector) {
                var offsetX = (helperObject.offsetX - obj.offsetX);
                var offsetY = (helperObject.offsetY - obj.offsetY);
                var rotateAngle = (helperObject.rotateAngle - obj.rotateAngle);
                var width = (helperObject.width - obj.width);
                var height = (helperObject.height - obj.height);
                var scaleWidth = helperObject.width / obj.width;
                var scaleHeight = helperObject.height / obj.height;
                //929543: To resize the multiselected child nodes.
                if (this.tool.corner) {
                    var pivot = this.tool.getPivot(this.tool.corner);
                    for (var i = 0; i < obj.nodes.length; i++) {
                        var node = obj.nodes[parseInt(i.toString(), 10)];
                        var element = node.wrapper;
                        var refWrapper = obj.wrapper;
                        var x = refWrapper.offsetX - refWrapper.actualSize.width * refWrapper.pivot.x;
                        var y = refWrapper.offsetY - refWrapper.actualSize.height * refWrapper.pivot.y;
                        var refPoint = getPoint(x, y, refWrapper.actualSize.width, refWrapper.actualSize.height, refWrapper.rotateAngle, refWrapper.offsetX, refWrapper.offsetY, pivot);
                        this.diagram.commandHandler.scaleObject(scaleWidth, scaleHeight, refPoint, node, element, obj);
                    }
                }
                else {
                    for (var i = 0; i < obj.nodes.length; i++) {
                        var node = obj.nodes[parseInt(i.toString(), 10)];
                        var parentNode = this.diagram.nameTable[node.parentId];
                        if (parentNode && parentNode.shape.type !== 'SwimLane' && checkParentAsContainer(this.diagram, node, true)
                            && parentNode.container.type === 'Canvas') {
                            node.offsetX += offsetX;
                            node.offsetY += offsetY;
                            if (node && node.shape && node.shape.type !== 'UmlClassifier') {
                                node.width += width;
                                node.height += height;
                            }
                            node.rotateAngle += rotateAngle;
                            checkChildNodeInContainer(this.diagram, node);
                        }
                    }
                }
            }
        }
        if (obj && (obj.isPhase || obj.isLane ||
            (obj.shape && obj.shape.type === 'SwimLane'))) {
            this.diagram.updateDiagramElementQuad();
        }
        return history;
    };
    DiagramEventHandler.prototype.updateLaneChildNode = function (obj) {
        for (var i = 0; i < (obj.shape.lanes.length); i++) {
            if (obj.shape.lanes[parseInt(i.toString(), 10)].children
                && obj.shape.lanes[parseInt(i.toString(), 10)].children.length > 0) {
                for (var j = 0; j < obj.shape.lanes[parseInt(i.toString(), 10)].children.length; j++) {
                    var id = obj.shape.lanes[parseInt(i.toString(), 10)].children[parseInt(j.toString(), 10)].id;
                    var childNode = this.diagram.nameTable["" + id];
                    //828489 - Exception occurs while dragging swimlane after adding shape & undo action is performed
                    if (childNode) {
                        childNode.offsetX = childNode.wrapper.offsetX;
                        childNode.offsetY = childNode.wrapper.offsetY;
                    }
                }
            }
        }
    };
    DiagramEventHandler.prototype.updateContainerPropertiesExtend = function (parentNode, obj, connectors, helperObject, history) {
        if (this.currentAction === 'ResizeEast' || this.currentAction === 'ResizeSouth' || obj.shape.type === 'SwimLane') {
            var undoObj = cloneObject(obj);
            var isUpdateRow = false;
            if (parentNode && parentNode.container && parentNode.container.type === 'Grid') {
                var shape = parentNode.shape.type === 'SwimLane' ? true : false;
                var container = (shape ? parentNode.wrapper.children[0] : parentNode.wrapper);
                var padding = shape ? parentNode.shape.padding : undefined;
                var x = parentNode.wrapper.bounds.x;
                var y = parentNode.wrapper.bounds.y;
                if (obj.columnIndex !== undefined && (parentNode.container.orientation === 'Horizontal' &&
                    ((shape && obj.isPhase) || (!shape && obj.rowIndex === 1))) ||
                    (parentNode.container.orientation === 'Vertical' &&
                        ((!shape && obj.rowIndex > 0 && obj.columnIndex > 0) || (shape && obj.isLane)))) {
                    if (parentNode.container.orientation === 'Horizontal' && obj.isPhase && obj.wrapper.width > obj.maxWidth) {
                        obj.maxWidth = obj.wrapper.width;
                        obj.wrapper.maxWidth = obj.wrapper.width;
                    }
                    var colWidthDiff = helperObject.wrapper.actualSize.width - obj.wrapper.actualSize.width;
                    // 910832 - Lane height updating to negative values wrongly during resizing
                    container.updateColumnWidth(obj.columnIndex, helperObject.width, true, padding);
                    updateSwimLaneObject(this.diagram, obj, parentNode, helperObject, colWidthDiff);
                    if (obj.isPhase) {
                        var id = parentNode.shape.phases[obj.columnIndex].header.id;
                        var node = this.diagram.nameTable["" + id];
                        if (node.maxWidth < helperObject.width) {
                            node.maxWidth = helperObject.width;
                            node.wrapper.maxWidth = helperObject.width;
                        }
                    }
                    if (parentNode.shape.type === 'SwimLane') {
                        parentNode.width = (parentNode.width) ? container.width : parentNode.width;
                        updateHeaderMaxWidth(this.diagram, parentNode);
                        parentNode.wrapper.width = parentNode.width;
                        connectors = getConnectors(this.diagram, container, obj.rowIndex);
                    }
                }
                else if (obj.rowIndex !== undefined) {
                    isUpdateRow = true;
                    var rowHeightDiff = helperObject.wrapper.actualSize.height - obj.wrapper.actualSize.height;
                    // 910832 - Lane height updating to negative values wrongly during resizing
                    container.updateRowHeight(obj.rowIndex, helperObject.height, true, padding);
                    updateSwimLaneObject(this.diagram, obj, parentNode, helperObject, undefined, rowHeightDiff);
                    if (parentNode.shape.type === 'SwimLane') {
                        parentNode.height = (parentNode.height) ? container.height : parentNode.height;
                        parentNode.wrapper.height = parentNode.height;
                        connectors = getConnectors(this.diagram, container, obj.rowIndex);
                    }
                }
                if (parentNode.shape.type === 'SwimLane') {
                    history.isPreventHistory = true;
                }
                this.diagram.nodePropertyChange(parentNode, {}, {
                    offsetX: parentNode.offsetX, offsetY: parentNode.offsetY,
                    rotateAngle: parentNode.rotateAngle
                });
                this.diagram.drag(parentNode, x - parentNode.wrapper.bounds.x, y - parentNode.wrapper.bounds.y);
            }
            else {
                if (obj && obj.shape && obj.shape.type === 'UmlClassifier') {
                    obj.wrapper.measureChildren = true;
                }
                this.diagram.nodePropertyChange(obj, {}, {
                    offsetX: obj.offsetX, offsetY: obj.offsetY, width: obj.width, height: obj.height, rotateAngle: obj.rotateAngle
                });
                obj.wrapper.measureChildren = false;
            }
            obj.wrapper.measure(new Size(obj.wrapper.width, obj.wrapper.height));
            obj.wrapper.arrange(obj.wrapper.desiredSize);
            if (this.currentAction === 'ResizeEast' || this.currentAction === 'ResizeSouth') {
                var redoObject = cloneObject(obj);
                var entry = {
                    category: 'Internal',
                    type: (isUpdateRow) ? 'RowHeightChanged' : 'ColumnWidthChanged',
                    undoObject: undoObj, redoObject: redoObject
                };
                this.diagram.addHistoryEntry(entry);
            }
        }
        updateConnectorsProperties(connectors, this.diagram);
        return history;
    };
    DiagramEventHandler.prototype.addUmlNode = function () {
        var node = this.diagram.selectedItems.nodes[0];
        var objects = this.diagram.findObjectsUnderMouse({ x: this.currentPosition.x + 20, y: this.currentPosition.y });
        var target = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);
        var attribute;
        var method;
        if (!target) {
            objects = this.diagram.findObjectsUnderMouse({ x: this.currentPosition.x - 20, y: this.currentPosition.y });
            target = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);
        }
        if (node && node.container && node.container.type === 'Stack' && target && target.parentId
            && target.parentId === node.id) {
            var innerNode = target;
            var adornerSvg = getAdornerLayerSvg(this.diagram.element.id);
            var highlighter = adornerSvg.getElementById(adornerSvg.id + '_stack_highlighter');
            if (highlighter) {
                var index = node.wrapper.children.indexOf(target.wrapper) + 1;
                this.diagram.enableServerDataBinding(false);
                var temp = new Node(this.diagram, 'nodes', {
                    style: {
                        fill: node.style.fill,
                        strokeColor: (node.style.strokeColor === 'black') ? '#ffffff00' : node.style.strokeColor
                    },
                    annotations: target.annotations, verticalAlignment: 'Stretch', horizontalAlignment: 'Stretch',
                    constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize),
                    minHeight: 25
                }, true);
                temp.annotations[0].content = ' + Name : Type';
                var id = innerNode.id.split('_');
                temp.id = randomId() + temp.id;
                temp.parentId = node.id;
                temp.zIndex = -1;
                temp.umlIndex = index;
                this.diagram.startGroupAction();
                var child = { name: 'Name', type: 'Type' };
                //While dynamically adding nodes at runtime using the isSeparator highlighter, make sure to include the newly added nodes in the existing arrays of the UML node for the respective child types.
                if (node.shape.classifier === 'Class') {
                    if (target.id.includes('_umlProperty') && node.shape.classShape.attributes.length > 0) {
                        attribute = new UmlClassAttribute(node, '', child);
                        node.shape.classShape.attributes.push(attribute);
                    }
                    else if (target.id.includes('_umlMethods') && node.shape.classShape.methods.length > 0) {
                        method = new UmlClassMethod(node, '', child);
                        node.shape.classShape.methods.push(method);
                    }
                }
                if (node.shape.classifier === 'Interface') {
                    if (target.id.includes('_umlProperty') && node.shape.interfaceShape.attributes.length > 0) {
                        attribute = new UmlClassAttribute(node, '', child);
                        node.shape.classShape.attributes.push(attribute);
                    }
                    else if (target.id.includes('_umlMethods') && node.shape.interfaceShape.methods.length > 0) {
                        method = new UmlClassMethod(node, '', child);
                        node.shape.interfaceShape.methods.push(method);
                    }
                }
                if (node.shape.classifier === 'Enumeration') {
                    if (target.id.includes('_umlMember') && node.shape.enumerationShape.members.length > 0) {
                        var member = new UmlEnumerationMember(node, '', child);
                        node.shape.enumerationShape.members.push(member);
                    }
                }
                var redoElement = {
                    sourceIndex: node.wrapper.children.indexOf(temp.wrapper), source: temp,
                    target: undefined, targetIndex: undefined
                };
                this.diagram.enableServerDataBinding(true);
                this.diagram.add(temp);
                this.diagram.updateConnectorEdges(node);
                this.diagram.clearSelection();
                this.diagram.select([this.diagram.nameTable[temp.id]]);
                this.diagram.endGroupAction();
                this.diagram.startTextEdit();
            }
        }
    };
    return DiagramEventHandler;
}());
/** @private */
var ObjectFinder = /** @class */ (function () {
    function ObjectFinder() {
    }
    /** @private */
    ObjectFinder.prototype.findObjectsUnderMouse = function (pt, diagram, eventArgs, source, actions) {
        // finds the collection of the object that is under the mouse;
        var actualTarget = [];
        if (source && source instanceof Selector) {
            if (source.nodes.length + source.connectors.length === 1) {
                source = (source.nodes[0] || source.connectors[0]);
                if (source.children && source.children.length === 0) {
                    eventArgs.actualObject = source;
                }
            }
        }
        var container;
        var bounds;
        var child;
        var matrix;
        var endPadding = (source && (source instanceof Connector) &&
            ((source.constraints & ConnectorConstraints.ConnectToNearByNode) ||
                (source.constraints & ConnectorConstraints.ConnectToNearByPort)) && source.connectionPadding) || 0;
        var objArray = diagram.spatialSearch.findObjects(new Rect(pt.x - 50 - endPadding, pt.y - 50 - endPadding, 100 + endPadding, 100 + endPadding));
        var layerObjTable = {};
        var layerTarger;
        for (var _i = 0, objArray_1 = objArray; _i < objArray_1.length; _i++) {
            var obj = objArray_1[_i];
            var point = pt;
            bounds = obj.wrapper.outerBounds;
            var pointInBounds = (obj.rotateAngle) ? false : bounds.containsPoint(point, endPadding);
            if ((obj !== source || diagram.currentDrawingObject instanceof Connector) &&
                (obj instanceof Connector) ? obj !== diagram.currentDrawingObject :  obj.wrapper.visible) {
                var layer = diagram.commandHandler.getObjectLayer(obj.id);
                if (layer && !layer.lock && layer.visible) {
                    layerTarger = layerObjTable[layer.zIndex] = layerObjTable[layer.zIndex] || [];
                    if (obj.rotateAngle) {
                        container = obj.wrapper;
                        bounds = cornersPointsBeforeRotation(container);
                        for (var _a = 0, _b = container.children; _a < _b.length; _a++) {
                            child = _b[_a];
                            matrix = identityMatrix();
                            rotateMatrix(matrix, -(child.rotateAngle + child.parentTransform), child.offsetX, child.offsetY);
                            point = transformPointByMatrix(matrix, pt);
                            if (cornersPointsBeforeRotation(child).containsPoint(point, endPadding)) {
                                pointInBounds = true;
                            }
                        }
                    }
                    if (!source || (isSelected(diagram, obj) === false)) {
                        if (canEnablePointerEvents(obj)) {
                            if ((obj instanceof Connector) ? isPointOverConnector(obj, pt) : pointInBounds) {
                                var padding = (obj instanceof Connector) ? obj.hitPadding || 0 : 0; //let element: DiagramElement;
                                var element = this.findElementUnderMouse(obj, pt, diagram, endPadding || padding);
                                if (element && obj.id !== 'helper') {
                                    insertObject(obj, 'zIndex', layerTarger);
                                }
                            }
                        }
                    }
                }
            }
        }
        for (var _c = 0, _d = diagram.layers; _c < _d.length; _c++) {
            var layer = _d[_c];
            actualTarget = actualTarget.concat(layerObjTable[layer.zIndex] || []);
            for (var _e = 0, actualTarget_1 = actualTarget; _e < actualTarget_1.length; _e++) {
                var obj = actualTarget_1[_e];
                var eventHandler = 'eventHandler';
                if (obj.shape.type === 'Bpmn' && obj.processId && (!(diagram["" + eventHandler].tool instanceof MoveTool) ||
                    (diagram["" + eventHandler].tool instanceof MoveTool) && canAllowDrop(obj))) {
                    var index = actualTarget.indexOf(diagram.nameTable[obj.processId]);
                    if (index > -1) {
                        actualTarget.splice(index, 1);
                    }
                }
                if (obj.shape.type === 'UmlClassifier' && obj.container && obj.container.type === 'Stack') {
                    var index = actualTarget.indexOf(diagram.nameTable[diagram.nameTable[obj.id].wrapper.children[0].id]);
                    if (index > -1) {
                        actualTarget.splice(index, 1);
                    }
                }
            }
        }
        for (var i = 0; i < actualTarget.length; i++) {
            var parentObj = diagram.nameTable[actualTarget[parseInt(i.toString(), 10)].parentId];
            if (parentObj) {
                var portElement = this.findElementUnderMouse(parentObj, pt, diagram);
                for (var j = 0; j < parentObj.ports.length; j++) {
                    if (portElement && portElement.id.match('_' + parentObj.ports[parseInt(j.toString(), 10)].id + '$')) {
                        var port = parentObj.ports[parseInt(j.toString(), 10)];
                        if (canDrag(port) || canDraw(port)) {
                            return actualTarget;
                        }
                    }
                }
            }
            while (parentObj) {
                var index = actualTarget.indexOf(parentObj);
                if (index !== -1) {
                    actualTarget.splice(index, 1);
                }
                else {
                    break;
                }
                parentObj = diagram.nameTable[parentObj.parentId];
            }
        }
        this.checkSwimlane(actualTarget, diagram);
        if (eventArgs && !eventArgs.source) {
            for (var i = 0; i < actualTarget.length; i++) {
                var parentNode = diagram.nameTable[actualTarget[parseInt(i.toString(), 10)].parentId];
                if (parentNode && parentNode.shape.type === 'SwimLane') {
                    for (var j = 0; j < actualTarget.length; j++) {
                        var connector = actualTarget[parseInt(j.toString(), 10)];
                        if (connector instanceof Connector) {
                            actualTarget.splice(i, 1);
                        }
                    }
                }
            }
        }
        return actualTarget;
    };
    /** @private */
    ObjectFinder.prototype.checkSwimlane = function (actualTarget, diagram) {
        var isNode;
        for (var m = 0; m < actualTarget.length; m++) {
            var obj = actualTarget[parseInt(m.toString(), 10)];
            var parentNode = void 0;
            var node = void 0;
            if (obj instanceof Node) {
                parentNode = actualTarget[parseInt(m.toString(), 10)].parentId;
                node = obj;
            }
            if (parentNode === '') {
                if (node.shape.type !== 'SwimLane') {
                    isNode = true;
                }
                else {
                    isNode = false;
                }
            }
            var parent_2 = diagram.nameTable["" + parentNode];
            if (parent_2 && parent_2.isLane && diagram.nameTable[parent_2.parentId].zIndex > obj.zIndex) {
                actualTarget[parseInt(m.toString(), 10)] = parent_2;
            }
            if (m > 0 && isNode && node && (node.isLane || node.isPhase || node.isHeader)) {
                if (actualTarget[parseInt(m.toString(), 10)].zIndex < actualTarget[m - 1].zIndex) {
                    var swap = actualTarget[parseInt(m.toString(), 10)];
                    actualTarget[parseInt(m.toString(), 10)] = actualTarget[m - 1];
                    actualTarget[m - 1] = swap;
                }
            }
        }
        if (actualTarget.length >= 2) {
            var parent_3 = '';
            for (var i = actualTarget.length - 1; i >= 0; i--) {
                if (actualTarget[parseInt(i.toString(), 10)].parentId) {
                    var parent1 = findParentInSwimlane(actualTarget[parseInt(i.toString(), 10)], diagram, parent_3);
                    var parent2 = findParentInSwimlane(actualTarget[i - 1], diagram, parent_3);
                    var parentNode1 = diagram.nameTable["" + parent1];
                    var parentNode2 = diagram.nameTable["" + parent2];
                    if (parentNode2 && parent1 !== parent2 && parentNode1.zIndex < parentNode2.zIndex) {
                        actualTarget.splice(i, 1);
                    }
                }
            }
        }
    };
    /** @private */
    ObjectFinder.prototype.isTarget = function (actualTarget, diagram, action) {
        var connector = diagram.selectedItems.connectors[0];
        var node;
        node = action === 'ConnectorSourceEnd' ? diagram.nameTable[connector.targetID] :
            node = diagram.nameTable[connector.sourceID];
        if (node && !(node.processId && !actualTarget.processId
            || node.processId !== actualTarget.processId)) {
            if (node.processId !== actualTarget.processId) {
                actualTarget = null;
            }
            if (actualTarget && actualTarget.parentId &&
                diagram.nameTable[actualTarget.parentId].shape.type === 'UmlClassifier') {
                actualTarget = diagram.nameTable[actualTarget.parentId];
            }
        }
        if (action === 'ConnectorSourceEnd' && connector.targetID) {
            var targetNode = diagram.nameTable[connector.targetID];
            if (targetNode && targetNode.shape && (targetNode.shape.shape === 'TextAnnotation')) {
                var id = connector.id.split('_');
                if (((targetNode.shape.type === 'Bpmn') && actualTarget.shape.type !== 'Bpmn') || (id[0] === actualTarget.id) ||
                    actualTarget.shape.shape === 'TextAnnotation') {
                    actualTarget = null;
                }
                if (actualTarget && actualTarget.parentId &&
                    diagram.nameTable[actualTarget.parentId].shape.type === 'UmlClassifier') {
                    actualTarget = diagram.nameTable[actualTarget.parentId];
                }
            }
        }
        //908151: The connector automatically connects to the subprocess
        //909560: prevent child connector connecting to its own parent group
        //937174: Drag and drop subprocess and add children try to connect with connector throw exception
        if (actualTarget && ((node && actualTarget.id === node.processId) ||
            ((action === 'ConnectorSourceEnd' || action === 'ConnectorTargetEnd') && actualTarget.id === connector.parentId))) {
            actualTarget = null;
        }
        return actualTarget;
    };
    /* tslint:disable */
    /** @private */
    ObjectFinder.prototype.findObjectUnderMouse = function (diagram, objects, action, inAction, eventArg, position, source) {
        //we will get the wrapper object here
        //we have to choose the object to be interacted with from the given wrapper
        //Find the object that is under mouse
        var eventHandler = 'eventHandler';
        var endPoint = 'endPoint';
        var inPort;
        var outPort;
        var actualTarget = null;
        if (objects.length !== 0) {
            if (source && source instanceof Selector) {
                if (source.nodes.length + source.connectors.length === 1) {
                    source = (source.nodes[0] || source.connectors[0]);
                }
            }
            if ((action === 'ConnectorSourceEnd' && source || action === 'PortDraw') ||
                ((canDrawOnce(diagram) || canContinuousDraw(diagram)) && getObjectType(diagram.drawingObject) === Connector)) {
                var connector = diagram.selectedItems.connectors[0];
                for (var i = objects.length - 1; i >= 0; i--) {
                    outPort = getInOutConnectPorts(objects[parseInt(i.toString(), 10)], false);
                    inPort = getInOutConnectPorts(objects[parseInt(i.toString(), 10)], true);
                    var tool = diagram["" + eventHandler].tool;
                    var portElement = this.findTargetElement(objects[parseInt(i.toString(), 10)].wrapper, position, diagram, undefined);
                    if (action === 'Draw' && portElement && (objects[parseInt(i.toString(), 10)] instanceof Node || objects[parseInt(i.toString(), 10)] instanceof Connector) && !checkPort(objects[parseInt(i.toString(), 10)], portElement)) {
                        if (((tool && tool["" + endPoint] === 'ConnectorSourceEnd') && !canOutConnect(objects[parseInt(i.toString(), 10)])) ||
                            ((tool && tool["" + endPoint] === 'ConnectorTargetEnd') && !canInConnect(objects[parseInt(i.toString(), 10)]))) {
                            return actualTarget;
                        }
                    }
                    // eslint-disable-next-line max-len
                    if ((objects[parseInt(i.toString(), 10)] instanceof Node) || (objects[parseInt(i.toString(), 10)] instanceof Connector) && ((canOutConnect(objects[parseInt(i.toString(), 10)]) || (canPortOutConnect(outPort)) || canInConnect(objects[parseInt(i.toString(), 10)]) || (canPortInConnect(inPort))) ||
                        (action === 'PortDraw' && (tool instanceof ConnectTool) && tool["" + endPoint] === 'ConnectorTargetEnd' &&
                            (canInConnect(objects[parseInt(i.toString(), 10)]) || (canPortInConnect(inPort)))))) {
                        actualTarget = objects[parseInt(i.toString(), 10)];
                        if (connector) {
                            actualTarget = this.isTarget(actualTarget, diagram, action);
                        }
                        eventArg.actualObject = actualTarget;
                        return actualTarget;
                    }
                }
            }
            else if (action === 'ConnectorTargetEnd' && source) {
                for (var i = objects.length - 1; i >= 0; i--) {
                    inPort = getInOutConnectPorts(objects[parseInt(i.toString(), 10)], true);
                    if ((objects[parseInt(i.toString(), 10)] instanceof Node || objects[parseInt(i.toString(), 10)] instanceof Connector)
                        && (canInConnect(objects[parseInt(i.toString(), 10)]) || (canPortInConnect(inPort)))) {
                        actualTarget = objects[parseInt(i.toString(), 10)];
                        actualTarget = this.isTarget(actualTarget, diagram, action);
                        eventArg.actualObject = actualTarget;
                        return actualTarget;
                    }
                }
            }
            else if (source && (action === 'Drag' || (diagram["" + eventHandler].tool instanceof MoveTool))) {
                var index = 0;
                for (var i = 0; i < objects.length; i++) {
                    var temp = objects[parseInt(i.toString(), 10)];
                    if (source !== temp && (temp instanceof Connector ||
                        !position || temp.wrapper.bounds.containsPoint(position))) {
                        if (canAllowDrop(temp)) {
                            if (!actualTarget) {
                                actualTarget = temp;
                                index = actualTarget.zIndex;
                            }
                            else {
                                actualTarget = index >= temp.zIndex ? actualTarget : temp;
                                index = Math.max(index, temp.zIndex);
                            }
                        }
                    }
                }
                if (actualTarget && actualTarget.shape.type === 'Bpmn') {
                    if (diagram.selectedItems.nodes.length > 0 && diagram.selectedItems.nodes[0].shape.type === 'Bpmn') {
                        // eslint-disable-next-line no-self-assign
                        actualTarget = actualTarget;
                    }
                    else {
                        actualTarget = null;
                    }
                }
                if (actualTarget) {
                    eventArg.actualObject = actualTarget;
                }
                return actualTarget;
            }
            else if ((action === 'Select' || action === 'Pan') && diagram["" + eventHandler].tool) {
                for (var i = objects.length - 1; i >= 0; i--) {
                    if (objects[parseInt(i.toString(), 10)] instanceof Connector) {
                        var objj1 = objects[i - 1];
                        if (objects[i - 1] instanceof Node && objj1.ports) {
                            var portElement = this.findTargetElement(objj1.wrapper, position, diagram, undefined);
                            if ((portElement && (portElement.id.match('_icon_content_shape$') || portElement.id.match('_icon_content_rect$')))) {
                                return objj1;
                            }
                            for (var j = 0; j < objj1.ports.length; j++) {
                                if (portElement && portElement.id.match('_' + objj1.ports[parseInt(j.toString(), 10)].id + '$')) {
                                    if (canDraw(objj1.ports[parseInt(j.toString(), 10)])) {
                                        return objj1;
                                    }
                                }
                            }
                        }
                    }
                }
                actualTarget = objects[objects.length - 1];
                eventArg.actualObject = actualTarget;
                if (!diagram["" + eventHandler].itemClick(actualTarget, true)) {
                    if (actualTarget.parentId) {
                        var obj = actualTarget;
                        var selected = isSelected(diagram, obj);
                        while (obj) {
                            if (isSelected(diagram, obj) && !selected) {
                                break;
                            }
                            actualTarget = obj;
                            // 912178-Tooltip for node is not shown when grouped at runtime
                            if (obj.tooltip.content !== '') {
                                break;
                            }
                            obj = diagram.nameTable[obj.parentId];
                        }
                    }
                }
            }
            else if (action === 'Pan' || action === 'LayoutAnimation') {
                for (var i = objects.length - 1; i >= 0; i--) {
                    if (objects[parseInt(i.toString(), 10)] instanceof Node || objects[parseInt(i.toString(), 10)] instanceof Connector) {
                        var portElement = this.findTargetElement(objects[parseInt(i.toString(), 10)].wrapper, position, diagram, undefined);
                        if ((action === 'Pan') || ((portElement && (portElement.id.match('_icon_content_shape$') || portElement.id.match('_icon_content_rect$'))))) {
                            return objects[parseInt(i.toString(), 10)];
                        }
                    }
                }
            }
            else {
                actualTarget = objects[objects.length - 1];
                if (eventArg && actualTarget) {
                    eventArg.actualObject = actualTarget;
                }
            }
        }
        return actualTarget;
    };
    /* tslint:enable */
    /** @private */
    ObjectFinder.prototype.findElementUnderSelectedItem = function (obj, position, diagram, padding) {
        //rewrite this for multiple selection
        if (obj instanceof Selector) {
            if (obj.nodes.length === 1 && (!obj.connectors || !obj.connectors.length)) {
                return this.findElementUnderMouse(obj.nodes[0], position, diagram);
            }
            else if ((!obj.nodes || obj.nodes.length) && obj.connectors.length === 1) {
                return this.findElementUnderMouse(obj.connectors[0], position, diagram);
            }
        }
        else {
            return this.findElementUnderMouse(obj, position, diagram, padding);
        }
        return null;
    };
    ObjectFinder.prototype.findElementUnderMouse = function (obj, position, diagram, padding) {
        return this.findTargetElement(obj.wrapper, position, diagram, padding);
    };
    /** @private */
    ObjectFinder.prototype.findTargetElement = function (container, position, diagram, padding) {
        for (var i = container.children.length - 1; i >= 0; i--) {
            var element = container.children[parseInt(i.toString(), 10)];
            //Checking whether the annotation is visible or not
            if (element && element.outerBounds.containsPoint(position, padding || 0)) {
                if (element.visible) {
                    if (element instanceof Container) {
                        var target = this.findTargetElement(element, position, diagram);
                        if (target) {
                            return target;
                        }
                    }
                    //EJ2-69047 - Node selection is improper while adding annotation for multiple nodes
                    //Checked textOverflow property to avoid the selection of text element with clip and ellipsis;
                    var textOverflow = (element.style.textOverflow === 'Clip' || element.style.textOverflow === 'Ellipsis');
                    if (element.bounds.containsPoint(position, padding || 0) && !textOverflow) {
                        return element;
                    }
                    else if (container.bounds.containsPoint(position, padding || 0) && textOverflow) {
                        // 913240 - Tooltip for annotation not visible while text overflow sets to Clip or Ellipsis
                        return element;
                    }
                }
                //(EJ2-840331)Double click on node annotation will open the edit of invisible annotation
                else if (element instanceof PathElement && container && container.id) {
                    var getNode = void 0;
                    if (container.id.includes('group_container')) {
                        var getId = container.id.slice(0, -15);
                        getNode = diagram.getObject(getId);
                    }
                    else {
                        getNode = diagram.getObject(container.id);
                    }
                    var port = findPort(getNode, element.id);
                    // 913000: Connector not connected to port when visibility hidden
                    if (port) {
                        return element;
                    }
                }
            }
        }
        if (container.bounds.containsPoint(position, padding) && container.style.fill !== 'none') {
            return container;
        }
        return null;
    };
    return ObjectFinder;
}());

var __extends$x = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * A collection of JSON objects where each object represents a layer.
 * Layer is a named category of diagram shapes.
 */
var Layer = /** @class */ (function (_super) {
    __extends$x(Layer, _super);
    // tslint:disable-next-line:no-any
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function Layer(parent, propName, defaultValue, isArray) {
        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;
        /**  @private   */
        _this.objectZIndex = -1;
        /**   @private  */
        _this.zIndexTable = {};
        _this.objects = [];
        return _this;
    }
    __decorate$m([
        Property('')
    ], Layer.prototype, "id", void 0);
    __decorate$m([
        Property(true)
    ], Layer.prototype, "visible", void 0);
    __decorate$m([
        Property(false)
    ], Layer.prototype, "lock", void 0);
    __decorate$m([
        Property()
    ], Layer.prototype, "objects", void 0);
    __decorate$m([
        Property()
    ], Layer.prototype, "addInfo", void 0);
    __decorate$m([
        Property(-1)
    ], Layer.prototype, "zIndex", void 0);
    return Layer;
}(ChildProperty));

var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$1 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/**
 * Defines the behavior of commands
 */
var CommandHandler = /** @class */ (function () {
    function CommandHandler(diagram) {
        /**   @private  */
        this.clipboardData = {};
        // private newNodeObject: Object[] = [];
        // private newConnectorObject: Object[] = [];
        /**   @private  */
        this.diagramObject = {};
        /**   @private  */
        this.newSelectedObjects = {};
        /**   @private  */
        this.oldSelectedObjects = {};
        /**   @private  */
        this.changedNodeZIndexes = {};
        /**   @private  */
        this.connectorsTable = [];
        /** @private */
        this.PreventConnectorSplit = false;
        /**   @private  */
        this.processTable = {};
        /** @private */
        this.isContainer = false;
        /** @private */
        this.canUpdateTemplate = false;
        /** @private */
        this.cloningInProgress = false;
        this.childTable = {};
        this.objectStore = [];
        this.parentTable = {};
        this.blazor = 'Blazor';
        this.blazorInterop = 'sfBlazor';
        this.cloneGroupChildCollection = [];
        this.diagram = diagram;
    }
    Object.defineProperty(CommandHandler.prototype, "snappingModule", {
        /**   @private  */
        get: function () {
            return this.diagram.snappingModule;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommandHandler.prototype, "layoutAnimateModule", {
        /**   @private  */
        get: function () {
            return this.diagram.layoutAnimateModule;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * startTransaction method\
     *
     * @returns {  void }    startTransaction method .\
     * @param {boolean} protectChange - provide the options value.
     * @private
     */
    CommandHandler.prototype.startTransaction = function (protectChange) {
        this.state = { element: this.diagram.selectedItems, backup: null };
        if (protectChange) {
            this.diagram.protectPropertyChange(true);
        }
        getAdornerLayer(this.diagram.element.id).style.pointerEvents = 'none';
    };
    /**
     * endTransaction method\
     *
     * @returns {  void }    endTransaction method .\
     * @param {boolean} protectChange - provide the options value.
     * @private
     */
    CommandHandler.prototype.endTransaction = function (protectChange) {
        this.state = null;
        if (protectChange) {
            this.diagram.protectPropertyChange(false);
        }
        getAdornerLayer(this.diagram.element.id).style.pointerEvents = 'all';
    };
    /**
     * setFocus method\
     *
     * @returns {  void }    setFocus method .\
     * @private
     */
    CommandHandler.prototype.setFocus = function () {
        document.getElementById(this.diagram.element.id).focus();
    };
    /**
     * showTooltip method\
     *
     * @returns {  void }    showTooltip method .\
     * @param {IElement} node - provide the options value.
     * @param {PointModel} position - provide the position value.
     * @param {string | HTMLElement} content - provide the content value.
     * @param {string} toolName - provide the toolName value.
     * @param {boolean} isTooltipVisible - provide the isTooltipVisible value.
     * @private
     */
    CommandHandler.prototype.showTooltip = function (node, position, content, toolName, isTooltipVisible) {
        var _this = this;
        var targetId;
        var targetEle;
        var isNative = false;
        if (node instanceof Selector) {
            if ((node.nodes.length === 1) && node.connectors.length === 0) {
                targetId = node.nodes[0].id;
                if (node.nodes[0].shape && node.nodes[0].shape instanceof Native) {
                    isNative = true;
                }
            }
            else if ((node.nodes.length === 0) && node.connectors.length === 1) {
                targetId = node.connectors[0].id;
            }
            else {
                targetEle = document.getElementById(this.diagram.element.id + '_SelectorElement');
            }
        }
        else if (node instanceof Node) {
            targetId = node.id;
            if (node.shape && (node.shape instanceof Native)) {
                isNative = true;
            }
        }
        else {
            targetId = node.id;
        }
        if (isNullOrUndefined(targetEle) && !isNullOrUndefined(targetId)) {
            var idName = isNative ? '_content_native_element' : '_groupElement';
            targetEle = document.getElementById(targetId + idName);
        }
        if (isTooltipVisible) {
            this.diagram.tooltipObject.position = 'BottomCenter';
            this.diagram.tooltipObject.animation = { open: { delay: 0, duration: 0 } };
            this.diagram.tooltipObject.openDelay = 0;
            this.diagram.tooltipObject.closeDelay = 0;
        }
        if (this.diagram.selectedItems.setTooltipTemplate) {
            var template = void 0;
            var setTooltipTemplate = getFunction(this.diagram.selectedItems.setTooltipTemplate);
            if (setTooltipTemplate) {
                template = setTooltipTemplate(node, this.diagram);
            }
            if (template instanceof HTMLElement) {
                content = template.cloneNode(true);
            }
            else {
                content = template ? template : content;
            }
        }
        //840454- support to provide isSticky property for tooltip in diagram control
        this.diagram.tooltipObject.isSticky = false;
        if (node.tooltip) {
            this.diagram.tooltipObject.openOn = node.tooltip.openOn;
        }
        // Task 834121: Content-Security-Policy support for diagram
        if (typeof content === 'string') {
            this.diagram.tooltipObject.content = initializeCSPTemplate(function () {
                return content;
            });
        }
        else {
            this.diagram.tooltipObject.content = content;
        }
        this.diagram.tooltipObject.offsetX = 0;
        this.diagram.tooltipObject.offsetY = 0;
        this.diagram.tooltipObject.refresh(targetEle);
        if (isTooltipVisible) {
            setTimeout(function () {
                _this.diagram.tooltipObject.open(targetEle);
            }, 1);
        }
    };
    /**
     * Split the connector, when the node is dropped onto it and establish connection with that dropped node.
     *
     * @returns {  void }   connectorSplit  method .\
     * @param {NodeModel}  droppedObject - Provide the dropped node id
     * @param {ConnectorModel} targetConnector - Provide the connector id
     * @private
     */
    CommandHandler.prototype.connectorSplit = function (droppedObject, targetConnector) {
        var droppedNodeId = droppedObject.id;
        var existingConnector = cloneObject(targetConnector);
        var connectorIndex = this.diagram.connectors.indexOf(targetConnector);
        var nodeIndex = this.diagram.nodes.indexOf(droppedObject);
        var droppedNode = cloneObject(droppedObject);
        var connectorOldChanges = {};
        var nodeOldChanges = {};
        var nodeOldProperty = {
            offsetX: droppedNode.offsetX,
            offsetY: droppedNode.offsetY
        };
        var connectorOldProperty = {
            sourceID: existingConnector.sourceID,
            sourcePoint: existingConnector.sourcePoint,
            sourcePortID: existingConnector.sourcePortID,
            targetID: existingConnector.targetID,
            targetPoint: existingConnector.targetPoint,
            targetPortID: existingConnector.targetPortID
        };
        connectorOldChanges[parseInt(connectorIndex.toString(), 10)] = connectorOldProperty;
        nodeOldChanges[parseInt(nodeIndex.toString(), 10)] = nodeOldProperty;
        var connectorNewChanges = {};
        var nodeNewChanges = {};
        var nodeNewProperty = {};
        var connectorNewProperty = {};
        //Split the connector based on the dropped node
        if (existingConnector.sourceID !== '' && existingConnector.targetID !== '') {
            connectorNewProperty.targetID = this.ConnectorTargetChange(targetConnector, droppedNodeId);
        }
        else if (existingConnector.sourceID !== '' && existingConnector.targetID === '') {
            this.nodeOffsetChange(nodeNewProperty, droppedNode, targetConnector.targetPoint);
            connectorNewProperty.targetID = this.ConnectorTargetChange(targetConnector, droppedNodeId);
        }
        else if ((existingConnector.sourceID === '' && existingConnector.targetID === '') || (existingConnector.sourceID === '' && existingConnector.targetID !== '')) {
            this.nodeOffsetChange(nodeNewProperty, droppedNode, targetConnector.sourcePoint);
            connectorNewProperty.sourceID = this.ConnectorSourceChange(targetConnector, droppedNodeId);
        }
        connectorNewChanges[parseInt(connectorIndex.toString(), 10)] = connectorNewProperty;
        nodeNewChanges[parseInt(nodeIndex.toString(), 10)] = nodeNewProperty;
        this.diagram.nodePropertyChange(droppedObject, nodeOldProperty, nodeNewProperty);
        this.diagram.updateSelector();
        this.diagram.connectorPropertyChange(targetConnector, connectorOldProperty, connectorNewProperty);
        //Check Whether the connector connects with the node
        if (existingConnector.sourceID !== '' && existingConnector.targetID !== '') {
            var newConnector = {
                id: 'connector ' + droppedNodeId,
                constraints: ConnectorConstraints.Default | ConnectorConstraints.AllowDrop,
                sourceID: droppedNodeId
            };
            // 28029: Update new connectors source and target end type and styles
            newConnector.type = existingConnector.type;
            newConnector.style = existingConnector.style;
            newConnector.sourceDecorator = existingConnector.sourceDecorator;
            newConnector.targetDecorator = existingConnector.targetDecorator;
            newConnector.targetID = existingConnector.targetID;
            //Check whether the connector connects with the ports
            if (existingConnector.targetPortID !== '') {
                newConnector.targetPortID = existingConnector.targetPortID;
            }
            this.diagram.add(newConnector);
        }
        var entry = {
            type: 'PropertyChanged', redoObject: { nodes: nodeNewChanges }, undoObject: { nodes: nodeOldChanges },
            category: 'Internal'
        };
        this.diagram.addHistoryEntry(entry);
        var entry1 = {
            type: 'PropertyChanged', redoObject: { connectors: connectorNewChanges }, undoObject: { connectors: connectorOldChanges },
            category: 'Internal'
        };
        this.diagram.addHistoryEntry(entry1);
    };
    CommandHandler.prototype.nodeOffsetChange = function (propertyChangeArg, node, nodeNewOffset) {
        propertyChangeArg.offsetX = node.offsetX = nodeNewOffset.x;
        propertyChangeArg.offsetY = node.offsetY = nodeNewOffset.y;
    };
    CommandHandler.prototype.ConnectorTargetChange = function (connector, newTarget) {
        connector.targetID = newTarget;
        return newTarget;
    };
    CommandHandler.prototype.ConnectorSourceChange = function (connector, newTarget) {
        connector.sourceID = newTarget;
        return newTarget;
    };
    /**
     * closeTooltip method\
     *
     * @returns {  void }    closeTooltip method .\
     * @private
     */
    CommandHandler.prototype.closeTooltip = function () {
        this.diagram.tooltipObject.close();
    };
    /**
     * canEnableDefaultTooltip method\
     *
     * @returns {  boolean }    canEnableDefaultTooltip method .\
     * @private
     */
    CommandHandler.prototype.canEnableDefaultTooltip = function () {
        if (this.diagram.selectedItems.constraints & SelectorConstraints.ToolTip) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * updateSelector method\
     *
     * @returns {  void }    updateSelector method .\
     * @private
     */
    CommandHandler.prototype.updateSelector = function () {
        this.diagram.updateSelector();
    };
    // /**
    //  * updateConnectorValue method\
    //  *
    //  * @returns {  void }    updateConnectorValue method .\
    //  * @param {IBlazorConnectionChangeEventArgs} args - provide the options value.
    //  * @private
    //  */
    // public updateConnectorValue(args: IBlazorConnectionChangeEventArgs): void {
    //     //remove Blazor code
    // }
    /**
     * triggerEvent method\
     *
     * @returns {  Promise<void | object | IBlazorConnectionChangeEventArgs> }    triggerEvent method .\
     * @param {DiagramEvent} event - provide the options value.
     * @param {Object} args - provide the args value.
     * @private
     */
    CommandHandler.prototype.triggerEvent = function (event, args) {
        return __awaiter$1(this, void 0, void 0, function () {
            var temparg;
            return __generator$1(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(event === DiagramEvent.drop || event === DiagramEvent.positionChange ||
                            event === DiagramEvent.connectionChange)) return [3 /*break*/, 3];
                        if (this.diagram.currentSymbol) {
                            return [2 /*return*/];
                        }
                        if (event === DiagramEvent.drop) {
                            args.source = cloneBlazorObject(this.diagram);
                        }
                        if (!(this.diagram.currentDrawingObject instanceof Connector && event !== DiagramEvent.positionChange)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.diagram.triggerEvent(event, args)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        if (this.diagram.currentDrawingObject && event !== DiagramEvent.positionChange) {
                            return [2 /*return*/];
                        }
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this.diagram.triggerEvent(event, args)];
                    case 4:
                        temparg = _a.sent();
                        return [2 /*return*/, temparg];
                }
            });
        });
    };
    /**
     * dragOverElement method\
     *
     * @returns { void }    dragOverElement method .\
     * @param {MouseEventArgs} args - provide the options value.
     * @param {PointModel} currentPosition - provide the args value.
     * @private
     */
    CommandHandler.prototype.dragOverElement = function (args, currentPosition) {
        if (this.diagram.currentSymbol) {
            var dragOverArg = {
                element: cloneBlazorObject(args.source), target: cloneBlazorObject(args.target),
                mousePosition: cloneBlazorObject(currentPosition), diagram: cloneBlazorObject(this.diagram)
            };
            this.triggerEvent(DiagramEvent.dragOver, dragOverArg);
        }
    };
    /**
     * disConnect method\
     *
     * @returns { IConnectionChangeEventArgs | IBlazorConnectionChangeEventArgs }    disConnect method .\
     * @param {IElement} obj - provide the obj value.
     * @param {string} endPoint - provide the endPoint value.
     * @param {boolean} canCancel - provide the canCancel value.
     * @private
     */
    CommandHandler.prototype.disConnect = function (obj, endPoint, canCancel) {
        var oldChanges = {};
        var newChanges = {};
        var returnargs;
        var selectorModel;
        var connector;
        if (obj instanceof Selector) {
            selectorModel = obj;
            connector = selectorModel.connectors[0];
        }
        else if (obj instanceof Connector && this.diagram.currentDrawingObject) {
            connector = this.diagram.currentDrawingObject;
        }
        if (obj && connector && (hasSingleConnection(this.diagram) || this.diagram.currentDrawingObject)) {
            if (endPoint && (endPoint === 'ConnectorSourceEnd' || endPoint === 'ConnectorTargetEnd')) {
                var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';
                var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';
                if (connector["" + nodeEndId]) { //connector.sourceID || connector.targetID
                    oldChanges["" + nodeEndId] = connector["" + nodeEndId];
                    connector["" + nodeEndId] = '';
                    newChanges["" + nodeEndId] = connector["" + nodeEndId];
                    if (connector.sourcePortID || connector.targetPortID) {
                        oldChanges["" + portEndId] = connector["" + portEndId];
                        connector["" + portEndId] = '';
                        newChanges["" + portEndId] = connector["" + portEndId];
                    }
                    returnargs = this.connectionEventChange(connector, oldChanges, newChanges, endPoint, canCancel);
                }
            }
            else if ((endPoint !== 'OrthoThumb' && endPoint !== 'SegmentEnd') && (connector.sourceID || connector.targetID)) {
                oldChanges = {
                    sourceID: connector.sourceID, sourcePortID: connector.sourcePortID,
                    targetID: connector.targetID, targetPortID: connector.targetPortID
                };
                connector.sourceID = '';
                connector.sourcePortID = '';
                connector.targetID = '';
                connector.targetPortID = '';
                newChanges = {
                    sourceID: connector.sourceID, sourcePortID: connector.sourcePortID,
                    targetID: connector.targetID, targetPortID: connector.targetPortID
                };
                var arg = {
                    connector: cloneBlazorObject(connector), oldValue: oldChanges,
                    newValue: newChanges, cancel: false, state: 'Changing', connectorEnd: endPoint
                };
                this.triggerEvent(DiagramEvent.connectionChange, arg);
                if (arg.cancel) {
                    connector.sourceID = oldChanges.sourceID;
                    connector.sourcePortID = oldChanges.sourcePortID;
                    connector.targetID = oldChanges.targetID;
                    connector.targetPortID = oldChanges.targetPortID;
                }
                else {
                    this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);
                    this.diagram.updateDiagramObject(connector);
                    arg = {
                        connector: connector, oldValue: oldChanges,
                        newValue: newChanges, cancel: false, state: 'Changed', connectorEnd: endPoint
                    };
                    this.triggerEvent(DiagramEvent.connectionChange, arg);
                }
            }
        }
        return returnargs;
    };
    CommandHandler.prototype.connectionEventChange = function (connector, oldChanges, newChanges, endPoint, canCancel) {
        var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';
        var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';
        var connectedNode;
        if (this.enableCloneObject) {
            connectedNode = this.diagram.nameTable[newChanges["" + nodeEndId]];
            var nodeObject = cloneObject(connectedNode);
            this.diagram.insertValue(nodeObject, true);
        }
        var returnargs;
        var arg = {
            cancel: false, state: 'Changing', connectorEnd: endPoint,
            connector: cloneBlazorObject(connector), oldValue: { nodeId: oldChanges["" + nodeEndId], portId: oldChanges["" + portEndId] },
            newValue: { nodeId: newChanges["" + nodeEndId], portId: newChanges["" + portEndId] }
        };
        this.triggerEvent(DiagramEvent.connectionChange, arg);
        if (arg.cancel) {
            connector["" + nodeEndId] = oldChanges["" + nodeEndId];
            connector["" + portEndId] = oldChanges["" + portEndId];
            newChanges = oldChanges;
        }
        this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);
        this.diagram.updateDiagramObject(connector);
        arg = {
            connector: cloneBlazorObject(connector), oldValue: { nodeId: oldChanges["" + nodeEndId], portId: oldChanges["" + portEndId] },
            newValue: {
                nodeId: newChanges["" + nodeEndId],
                portId: newChanges["" + portEndId]
            },
            cancel: false, state: 'Changing', connectorEnd: endPoint
        };
        if (this.enableCloneObject) {
            if (connectedNode === undefined) {
                connectedNode = this.diagram.nameTable[oldChanges["" + nodeEndId]];
                var nodeObject = cloneObject(connectedNode);
                this.diagram.insertValue(nodeObject, true);
            }
        }
        if (this.diagram.bpmnModule) {
            if (connector.isBpmnAnnotationConnector) {
                var textAnnotationNode = this.diagram.nameTable[connector.targetID];
                textAnnotationNode.shape.textAnnotation.textAnnotationTarget = connector.sourceID;
            }
        }
        return returnargs;
    };
    // /**
    //  * insertBlazorObject method\
    //  *
    //  * @returns { void }    insertBlazorObject method .\
    //  * @param {IElement} object - provide the object value.
    //  * @param {boolean} isNode - provide the isNode value.
    //  * @private
    //  */
    // public insertBlazorObject(object: SelectorModel | Node | Connector, isNode?: boolean): void {
    // }
    // /**
    //  * updatePropertiesToBlazor method\
    //  *
    //  * @returns { void }    updatePropertiesToBlazor method .\
    //  * @param {MouseEventArgs} args - provide the args value.
    //  * @param {PointModel} labelDrag - provide the labelDrag value.
    //  * @private
    //  */
    // public updatePropertiesToBlazor(args: MouseEventArgs, labelDrag: boolean): void {
    //     this.enableCloneObject(false);
    //     this.ismouseEvents(false);
    //     // this.getBlazorOldValues(args, labelDrag);
    //     // this.updateBlazorSelector();
    // }
    // /**
    //  * insertSelectedObjects method\
    //  *
    //  * @returns { void }    insertSelectedObjects method .\
    //  * @private
    //  */
    // public insertSelectedObjects(): void {
    //     // this.oldSelectedObjects = cloneSelectedObjects(this.diagram);
    // }
    /**
     * findTarget method\
     *
     * @returns { NodeModel | PointPortModel | ShapeAnnotationModel | PathAnnotationModel }    findTarget method .\
     * @param {DiagramElement} element - provide the element value.
     * @param {IElement} argsTarget - provide the argsTarget value.
     * @param {boolean} source - provide the source value.
     * @param {boolean} connection - provide the connection value.
     * @private
     */
    CommandHandler.prototype.findTarget = function (element, argsTarget, source, connection) {
        if (argsTarget instanceof Node) {
            if (element && element.id === argsTarget.id + '_content') {
                return argsTarget;
            }
            if (source && argsTarget.shape.type === 'Bpmn' && ((!isBlazor() && argsTarget.shape.shape === 'Activity'))) {
                if (argsTarget.shape.activity.subProcess.type === 'Transaction') {
                    var transaction = argsTarget.shape.activity.subProcess.transaction;
                    if (transaction.success.visible && element.id.indexOf(argsTarget.id + '_success') === 0) {
                        return transaction.success;
                    }
                    if (transaction.cancel.visible && element.id.indexOf(argsTarget.id + '_cancel') === 0) {
                        return transaction.cancel;
                    }
                    if (transaction.failure.visible && element.id.indexOf(argsTarget.id + '_failure') === 0) {
                        return transaction.failure;
                    }
                }
            }
            if (element instanceof PathElement || element instanceof DiagramHtmlElement) {
                var nodePort = this.findMatch(argsTarget.ports, argsTarget.id, element.id);
                if (nodePort) {
                    return nodePort;
                }
                var nodeFixedUserHandle = this.findMatch(argsTarget.fixedUserHandles, argsTarget.id, element.id);
                if (nodeFixedUserHandle) {
                    return nodeFixedUserHandle;
                }
            }
        }
        // Feature 826644: Support to add ports to the connector.
        // Added below condition to find the target connector port.
        if (argsTarget instanceof Connector) {
            if (element && element.id === argsTarget.id + '_path') {
                return argsTarget;
            }
            if (element instanceof PathElement || element instanceof DiagramHtmlElement) {
                var connectorPort = this.findMatch(argsTarget.ports, argsTarget.id, element.id);
                if (connectorPort) {
                    return connectorPort;
                }
                var connectorFixedUserHandle = this.findMatch(argsTarget.fixedUserHandles, argsTarget.id, element.id);
                if (connectorFixedUserHandle) {
                    return connectorFixedUserHandle;
                }
            }
        }
        if (!connection) {
            var annotation = void 0;
            for (var i = 0; i < argsTarget.annotations.length; i++) {
                annotation = argsTarget.annotations[parseInt(i.toString(), 10)];
                if (element.id === argsTarget.id + '_' + annotation.id) {
                    return annotation;
                }
            }
        }
        return argsTarget;
    };
    CommandHandler.prototype.findMatch = function (items, targetID, elementID) {
        for (var i = 0; i < items.length; i++) {
            var item = items[parseInt(i.toString(), 10)];
            if (elementID === targetID + '_' + item.id || elementID === targetID + '_' + item.id + '_shape') {
                return item;
            }
        }
    };
    /**
     * canDisconnect method\
     *
     * @returns { boolean }    canDisconnect method .\
     * @param {string} endPoint - provide the endPoint value.
     * @param {MouseEventArgs} args - provide the args value.
     * @param {string} targetPortId - provide the targetPortId value.
     * @param {string} targetNodeId - provide the targetNodeId value.
     * @private
     */
    CommandHandler.prototype.canDisconnect = function (endPoint, args, targetPortId, targetNodeId) {
        var selector;
        var connect;
        if (args.source instanceof Selector) {
            selector = args.source;
            connect = selector.connectors[0];
        }
        else if (args.source instanceof Connector && this.diagram.currentDrawingObject) {
            connect = this.diagram.currentDrawingObject;
        }
        var targetObject = this.findTarget(args.targetWrapper, args.target, endPoint === 'ConnectorSourceEnd', true);
        var nodeEnd = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';
        var portEnd = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';
        if (connect["" + nodeEnd] !== targetNodeId || connect["" + portEnd] !== targetPortId) {
            return true;
        }
        return false;
    };
    /* tslint:disable */
    /**
     * connect method\
     *
     * @returns { IConnectionChangeEventArgs | IBlazorConnectionChangeEventArgs }    connect method .\
     * @param {string} endPoint - provide the endPoint value.
     * @param {MouseEventArgs} args - provide the args value.
     * @param {boolean} canCancel - provide the canCancel value.
     * @private
     */
    CommandHandler.prototype.connect = function (endPoint, args, canCancel) {
        var newChanges = {};
        var oldChanges = {};
        var oldNodeId;
        var oldPortId;
        var selectorModel;
        var connector;
        var returnargs;
        if (args.source instanceof Selector) {
            selectorModel = args.source;
            connector = selectorModel.connectors[0];
        }
        else if (args.source instanceof Connector && this.diagram.currentDrawingObject) {
            connector = this.diagram.currentDrawingObject;
        }
        var target = this.findTarget((args.targetWrapper || args.sourceWrapper), (args.target || args.actualObject), endPoint === 'ConnectorSourceEnd', true);
        var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';
        var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';
        if (target instanceof Node) {
            oldChanges["" + nodeEndId] = connector["" + nodeEndId];
            connector["" + nodeEndId] = target.id;
            newChanges["" + nodeEndId] = connector["" + nodeEndId];
            oldChanges["" + portEndId] = connector["" + portEndId];
            returnargs = this.connectionEventChange(connector, oldChanges, newChanges, endPoint, canCancel);
        }
        else if (target instanceof Port || target instanceof BpmnSubEvent) {
            oldNodeId = connector["" + nodeEndId];
            oldPortId = connector["" + portEndId];
            connector["" + portEndId] = target.id;
            connector["" + nodeEndId] = (args.target && args.target.id || args.actualObject.id);
            newChanges["" + nodeEndId] = connector["" + nodeEndId];
            newChanges["" + portEndId] = connector["" + portEndId];
            var arg = {
                connector: cloneBlazorObject(connector), oldValue: { nodeId: oldNodeId, portId: oldPortId },
                newValue: { nodeId: newChanges["" + nodeEndId], portId: newChanges["" + portEndId] },
                cancel: false, state: 'Changing', connectorEnd: endPoint
            };
            {
                this.triggerEvent(DiagramEvent.connectionChange, arg);
            }
            if (arg.cancel) {
                connector["" + nodeEndId] = oldNodeId;
                connector["" + portEndId] = oldPortId;
                newChanges["" + nodeEndId] = oldNodeId;
                newChanges["" + portEndId] = oldPortId;
            }
            else {
                this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);
                this.diagram.updateDiagramObject(connector);
                arg = {
                    connector: cloneBlazorObject(connector), oldValue: { nodeId: oldNodeId, portId: oldPortId },
                    newValue: { nodeId: newChanges["" + nodeEndId], portId: newChanges["" + portEndId] }, cancel: false,
                    state: 'Changing', connectorEnd: endPoint
                };
            }
        }
        this.renderHighlighter(args, undefined, endPoint === 'ConnectorSourceEnd');
        return returnargs;
    };
    /* tslint:enable */
    /** @private */
    /**
     * cut method\
     *
     * @returns { void }    cut method .\
     * @private
     */
    CommandHandler.prototype.cut = function () {
        this.clipboardData.pasteIndex = 0;
        if (this.diagram.undoRedoModule) {
            this.diagram.historyManager.startGroupAction();
        }
        this.clipboardData.clipObject = this.copyObjects();
        if (this.diagram.undoRedoModule) {
            this.diagram.historyManager.endGroupAction();
        }
        if (this.diagram.mode !== 'SVG') {
            this.diagram.refreshDiagramLayer();
        }
    };
    // private UpdateBlazorDiagramModelLayers(layer: Layer, isRemove: boolean): void {
    // comment blazor code
    // }
    /**
     * addLayer method\
     *
     * @returns { void }    addLayer method .\
     * @param {LayerModel} layer - provide the endPoint value.
     * @param {Object[]} objects - provide the args value.
     * @param {boolean} isServerUpdate - provide the canCancel value.
     * @private
     */
    CommandHandler.prototype.addLayer = function (layer, objects, isServerUpdate) {
        layer.id = layer.id || randomId();
        layer.zIndex = this.diagram.layers.length;
        var isEnableServerDatabind = this.diagram.allowServerDataBinding;
        this.diagram.enableServerDataBinding(false);
        layer = new Layer(this.diagram, 'layers', layer, true);
        this.diagram.enableServerDataBinding(isEnableServerDatabind);
        layer.objectZIndex = -1;
        layer.zIndexTable = {};
        this.diagram.layers.push(layer);
        // if (isServerUpdate) {
        //     this.UpdateBlazorDiagramModelLayers(layer as Layer, false);
        // }
        this.diagram.layerZIndexTable[layer.zIndex] = layer.id;
        this.diagram.activeLayer = layer;
        var layers = layer.objects;
        if (objects) {
            for (var i = 0; i < objects.length; i++) {
                this.diagram.add(objects[parseInt(i.toString(), 10)]);
            }
        }
    };
    /**
     * getObjectLayer method\
     *
     * @returns { LayerModel }    getObjectLayer method .\
     * @param {string} objectName - provide the endPoint value.
     * @private
     */
    CommandHandler.prototype.getObjectLayer = function (objectName) {
        var layers = this.diagram.layers;
        if (layers.length > 1) {
            for (var i = 0; i < layers.length; i++) {
                var objIndex = layers[parseInt(i.toString(), 10)].objects.indexOf(objectName);
                if (objIndex > -1) {
                    return layers[parseInt(i.toString(), 10)];
                }
            }
        }
        return this.diagram.activeLayer;
    };
    /**
     * getLayer method\
     *
     * @returns { LayerModel }    getLayer method .\
     * @param {string} layerName - provide the endPoint value.
     * @private
     */
    CommandHandler.prototype.getLayer = function (layerName) {
        var layers = this.diagram.layers;
        for (var i = 0; i < layers.length; i++) {
            if (layers[parseInt(i.toString(), 10)].id === layerName) {
                return layers[parseInt(i.toString(), 10)];
            }
        }
        return undefined;
    };
    /**
     * removeLayer method\
     *
     * @returns { void }    removeLayer method .\
     * @param {string} layerId - provide the endPoint value.
     * @param {boolean} isServerUpdate - provide the endPoint value.
     * @private
     */
    CommandHandler.prototype.removeLayer = function (layerId, isServerUpdate) {
        var layers = this.getLayer(layerId);
        if (layers) {
            var index = this.diagram.layers.indexOf(layers);
            var layerObject = layers.objects;
            for (var i = layerObject.length - 1; i >= 0; i--) {
                this.diagram.unSelect(this.diagram.nameTable[layerObject[parseInt(i.toString(), 10)]]);
                this.diagram.remove(this.diagram.nameTable[layerObject[parseInt(i.toString(), 10)]]);
                if (layers.id !== 'default_layer') {
                    if (this.diagram.activeLayer.id === layerId) {
                        this.diagram.activeLayer = this.diagram.layers[this.diagram.layers.length - 1];
                    }
                }
            }
            // if (isServerUpdate) {
            //     this.UpdateBlazorDiagramModelLayers(this.diagram.layers[parseInt(index.toString(), 10)] as Layer, true);
            // }
            delete this.diagram.layerZIndexTable[layers.zIndex];
            this.diagram.layers.splice(index, 1);
            if (this.diagram.mode !== 'SVG') {
                this.diagram.refreshDiagramLayer();
            }
        }
    };
    /**
     * moveObjects method\
     *
     * @returns { void }    moveObjects method .\
     * @param {string[]]} objects - provide the objects value.
     * @param {string} targetLayer - provide the targetLayer value.
     * @private
     */
    CommandHandler.prototype.moveObjects = function (objects, targetLayer) {
        this.diagram.startGroupAction();
        var connectorObjectsDetails = {};
        var childNodes = [];
        for (var i = 0; i < objects.length; i++) {
            var obj = this.diagram.nameTable[objects[parseInt(i.toString(), 10)]];
            if (obj instanceof Node) {
                var detail = { inEdges: obj.inEdges, outEdges: obj.outEdges };
                connectorObjectsDetails["" + obj.id] = cloneObject(detail);
            }
            else if (obj instanceof Connector) {
                var detail = {
                    sourceID: obj.sourceID, targetID: obj.targetID,
                    sourcePortID: obj.sourcePortID, targetPortID: obj.targetPortID
                };
                connectorObjectsDetails["" + obj.id] = cloneObject(detail);
            }
        }
        var layer = this.getLayer(targetLayer) || this.diagram.activeLayer;
        this.diagram.setActiveLayer(layer.id);
        var targerNodes;
        for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {
            var i = objects_1[_i];
            var layer_1 = this.getObjectLayer(i);
            var index = layer_1.objects.indexOf(i);
            if (index > -1) {
                targerNodes = this.diagram.nameTable["" + i];
                childNodes = [];
                if (targerNodes.children) {
                    for (var _a = 0, _b = targerNodes.children; _a < _b.length; _a++) {
                        var node = _b[_a];
                        childNodes.push(this.diagram.nameTable["" + node]);
                    }
                }
                this.diagram.unSelect(targerNodes);
                //875087 - Restrict removing dependent connectors when moveing between layers
                this.diagram.deleteDependentConnector = false;
                this.diagram.remove(this.diagram.nameTable["" + i]);
                this.diagram.deleteDependentConnector = true;
                if (childNodes.length > 0) {
                    var addedObj = void 0;
                    for (var _c = 0, childNodes_1 = childNodes; _c < childNodes_1.length; _c++) {
                        var node = childNodes_1[_c];
                        addedObj = this.diagram.add(node);
                        this.setConnectorDetails(addedObj || node, connectorObjectsDetails);
                        targerNodes.children.push(addedObj.id);
                    }
                    addedObj = this.diagram.add(targerNodes);
                    this.setConnectorDetails(addedObj || targerNodes, connectorObjectsDetails);
                }
                else {
                    var addedObj = this.diagram.add(targerNodes);
                    this.setConnectorDetails(addedObj || targerNodes, connectorObjectsDetails);
                }
                if (targerNodes.parentId) {
                    var parentId = targerNodes.parentId;
                    var group = this.diagram.nameTable["" + parentId];
                    this.diagram.addChildToGroup(group, targerNodes.id);
                }
            }
        }
        this.diagram.endGroupAction();
    };
    CommandHandler.prototype.setConnectorDetails = function (obj, connectorObjectsDetails) {
        var details = connectorObjectsDetails[obj.id];
        if (obj instanceof Node) {
            if (details) {
                if (details.inEdges && details.inEdges.length > 0) {
                    for (var i = 0; i < details.inEdges.length; i++) {
                        var con = this.diagram.nameTable[details.inEdges[parseInt(i.toString(), 10)]];
                        con.targetID = obj.id;
                    }
                }
                if (details.outEdges && details.outEdges.length > 0) {
                    for (var i = 0; i < details.outEdges.length; i++) {
                        var con = this.diagram.nameTable[details.outEdges[parseInt(i.toString(), 10)]];
                        con.sourceID = obj.id;
                    }
                }
            }
        }
        else if (obj instanceof Connector) {
            if (details) {
                obj.sourceID = details.sourceID;
                obj.targetID = details.targetID;
                obj.sourcePortID = details.sourcePortID;
                obj.targetPortID = details.targetPortID;
            }
        }
    };
    /**
     * cloneLayer method\
     *
     * @returns { void }    cloneLayer method .\
     * @param {string[]} layerName - provide the objects value.
     * @private
     */
    CommandHandler.prototype.cloneLayer = function (layerName) {
        var layers = this.diagram.layers;
        var layer = this.getLayer(layerName);
        if (layer) {
            var cloneObject_1 = [];
            var newlayer = {
                id: layerName + '_' + randomId(), objects: [], visible: true, lock: false
            };
            this.addLayer(newlayer, null, true);
            newlayer.zIndex = this.diagram.layers.length - 1;
            var multiSelect = cloneObject_1.length !== 1;
            for (var _i = 0, _a = layer.objects; _i < _a.length; _i++) {
                var obj = _a[_i];
                cloneObject_1.push(this.diagram.nameTable["" + obj]);
            }
            this.paste(cloneObject_1);
        }
    };
    /**
     * copy method\
     *
     * @returns { void }    copy method .\
     * @private
     */
    CommandHandler.prototype.copy = function () {
        this.clipboardData.pasteIndex = 1;
        this.clipboardData.clipObject = this.copyObjects();
        return this.clipboardData.clipObject;
    };
    /**
     * copyObjects method\
     *
     * @returns { Object[] }    copyObjects method .\
     * @private
     */
    CommandHandler.prototype.copyObjects = function () {
        var selectedItems = [];
        var obj = [];
        this.clipboardData.childTable = {};
        if (this.diagram.selectedItems.connectors.length > 0) {
            //908602 - Issue in Cut connectors
            selectedItems = selectedItems.concat(this.diagram.selectedItems.connectors);
            for (var j = 0; j < selectedItems.length; j++) {
                var element = void 0;
                //To copy text annotation node while copying the text annotation connector.
                if (this.diagram.bpmnModule &&
                    selectedItems[parseInt(j.toString(), 10)].isBpmnAnnotationConnector) {
                    element = cloneObject((this.diagram.nameTable[selectedItems[parseInt(j.toString(), 10)].targetID]));
                }
                else {
                    element = cloneObject((selectedItems[parseInt(j.toString(), 10)]));
                }
                obj.push(element);
            }
        }
        if (this.diagram.selectedItems.nodes.length > 0) {
            selectedItems = selectedItems.concat(this.diagram.selectedItems.nodes);
            for (var j = 0; j < this.diagram.selectedItems.nodes.length; j++) {
                if (!this.diagram.selectedItems.nodes[parseInt(j.toString(), 10)].isPhase) {
                    var node = cloneObject(this.diagram.selectedItems.nodes[parseInt(j.toString(), 10)]);
                    // Bug-913795: Pasting lane selected through rubber band selection results in multiple swimlane to be pasted
                    // Filter lane nodes-in the collection kept for clipboard data.
                    var laneNodes = obj.filter(function (node) { return node.isLane; });
                    // Flag-to check if same lane representing node already pushed in collection
                    var isCopiedLane = false;
                    // Check if same lane representing node is already pushed in collection
                    if (node.isLane) {
                        for (var _i = 0, laneNodes_1 = laneNodes; _i < laneNodes_1.length; _i++) {
                            var laneNode = laneNodes_1[_i];
                            if (checkSameLaneNodes(laneNode, node, this.diagram)) {
                                isCopiedLane = true;
                                break;
                            }
                        }
                    }
                    if (!((node.isLane || node.isHeader) && this.checkSwimlaneInSelection(node, obj))) {
                        // Restricting-child node push if parent lane node pushed & same lane nodes push
                        if (!(isParentNodeSelected(node, this.diagram) || isCopiedLane)) {
                            if (node.wrapper && (node.offsetX !== node.wrapper.offsetX)) {
                                node.offsetX = node.wrapper.offsetX;
                            }
                            if (node.wrapper && (node.offsetY !== node.wrapper.offsetY)) {
                                node.offsetY = node.wrapper.offsetY;
                            }
                            this.copyProcesses(node);
                            obj.push(cloneObject(node));
                            var matrix = identityMatrix();
                            rotateMatrix(matrix, -node.rotateAngle, node.offsetX, node.offsetY);
                            if (node.children) {
                                var childTable = this.clipboardData.childTable;
                                var tempNode = void 0;
                                var elements = [];
                                var nodes = this.getAllDescendants(node, elements, true);
                                for (var i = 0; i < nodes.length; i++) {
                                    tempNode = this.diagram.nameTable[nodes[parseInt(i.toString(), 10)].id];
                                    var clonedObject = childTable[tempNode.id] = cloneObject(tempNode);
                                    var newOffset = transformPointByMatrix(matrix, { x: clonedObject.wrapper.offsetX, y: clonedObject.wrapper.offsetY });
                                    if (tempNode instanceof Node) {
                                        clonedObject.offsetX = newOffset.x;
                                        clonedObject.offsetY = newOffset.y;
                                        clonedObject.rotateAngle -= node.rotateAngle;
                                    }
                                }
                                this.clipboardData.childTable = childTable;
                            }
                            // Adding the clonned connectors of swim lane in child table
                            if (node.shape.type === 'SwimLane') {
                                var swimlane = this.diagram.getObject(this.diagram.selectedItems.nodes[parseInt(j.toString(), 10)].id);
                                var childTable = this.clipboardData.childTable;
                                var connectorsList = getConnectors(this.diagram, swimlane.wrapper.children[0]);
                                for (var i = 0; i < connectorsList.length; i++) {
                                    var connector = this.diagram.getObject(connectorsList[parseInt(i.toString(), 10)]);
                                    childTable[connector.id] = cloneObject(connector);
                                    childTable[connector.id].parentSwimlaneId = node.id;
                                }
                            }
                            // Adding the clonned LANE of swim lane in child table
                            if (node && node.isLane) {
                                var childTable = this.clipboardData.childTable;
                                var swimlane = this.diagram.getObject(node.parentId);
                                var lane = findLane(node, this.diagram);
                                childTable[node.id] = cloneObject(lane);
                                childTable[node.id].width = swimlane.wrapper.actualSize.width;
                            }
                        }
                    }
                }
            }
        }
        this.sortByZIndex(obj, 'zIndex');
        //892957: Remove duplicate elements while copy, paste the swimlane
        if (this.diagram.selectedItems.nodes.some(function (node) {
            return node.shape.type === 'SwimLane';
        })) {
            obj = this.removeDuplicateObjects(obj);
        }
        if (this.clipboardData.pasteIndex === 0) {
            this.startGroupAction();
            for (var _a = 0, selectedItems_1 = selectedItems; _a < selectedItems_1.length; _a++) {
                var item = selectedItems_1[_a];
                if (this.diagram.nameTable[item.id]) {
                    this.diagram.remove(item);
                }
            }
            this.endGroupAction();
        }
        return obj;
    };
    /**
     * findProcesses method\
     *
     * @returns { string[] } findProcesses method .\
     * @param {Node} node - provide the laneNode  value.
     * @private
     */
    CommandHandler.prototype.findProcesses = function (node) {
        var processes = [];
        var lanes = node.shape.lanes;
        lanes.forEach(function (lane) {
            lane.children.forEach(function (child) {
                var activity = child.shape.activity;
                if (activity && activity.subProcess.processes) {
                    activity.subProcess.processes.forEach(function (process) {
                        processes.push(process);
                    });
                }
            });
        });
        return processes;
    };
    //892957: To remove duplicate objects
    CommandHandler.prototype.removeDuplicateObjects = function (objects) {
        var uniqueObjects = {};
        for (var i = 0; i < objects.length; i++) {
            uniqueObjects[objects[parseInt(i.toString(), 10)].id] = objects[parseInt(i.toString(), 10)];
        }
        var result = [];
        //To remove objects with same id
        for (var key in uniqueObjects) {
            if (Object.prototype.hasOwnProperty.call(uniqueObjects, key)) {
                result.push(uniqueObjects["" + key]);
            }
        }
        var _loop_1 = function (i) {
            if (result[parseInt(i.toString(), 10)].parentId) {
                var lane_1 = this_1.diagram.getObject(result[parseInt(i.toString(), 10)].parentId);
                if (lane_1 && lane_1.isLane && lane_1.parentId &&
                    result.some(function (obj) { return obj.id === lane_1.parentId; })) {
                    result.splice(i, 1);
                    i--;
                }
            }
            out_i_1 = i;
        };
        var this_1 = this, out_i_1;
        //To remove the nodes which is child node of copied swimlane
        for (var i = 0; i < result.length; i++) {
            _loop_1(i);
            i = out_i_1;
        }
        // Get the keys from childTable
        var childTableKeys = Object.keys(this.clipboardData.childTable);
        // Filter the array to remove objects with ids matching the keys in childTable except lane
        var filteredArray = result.filter(function (item) {
            return (childTableKeys.indexOf(item.id) === -1 || item.isLane);
        });
        return filteredArray;
    };
    //To check if the swimlane is selected along with its child lane
    CommandHandler.prototype.checkSwimlaneInSelection = function (node, obj) {
        return this.diagram.selectedItems.nodes.some(function (item) { return item.id === node.parentId; });
    };
    CommandHandler.prototype.copyProcesses = function (node) {
        if (node.shape.type === 'Bpmn' && node.shape.activity &&
            node.shape.activity.subProcess.processes &&
            node.shape.activity.subProcess.processes.length > 0) {
            var processes = node.shape.activity.subProcess.processes;
            for (var _i = 0, processes_1 = processes; _i < processes_1.length; _i++) {
                var i = processes_1[_i];
                this.processTable["" + i] = (cloneObject(this.diagram.nameTable["" + i]));
                if (this.processTable["" + i].shape.activity.subProcess.processes &&
                    this.processTable["" + i].shape.activity.subProcess.processes.length > 0) {
                    this.copyProcesses(this.processTable["" + i]);
                }
            }
            this.clipboardData.processTable = this.processTable;
        }
    };
    /**
     * group method\
     *
     * @returns { void }    group method .\
     * @private
     */
    CommandHandler.prototype.group = function () {
        var _this = this;
        this.oldSelectedObjects = cloneSelectedObjects(this.diagram);
        var propName = 'isProtectedOnChange';
        var protectedChange = this.diagram["" + propName];
        this.diagram.protectPropertyChange(true);
        this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.Group;
        var selectedItems = [];
        var obj = {};
        //let group: Node | Connector;
        obj.id = 'group' + randomId();
        obj = new Node(this.diagram, 'nodes', obj, true);
        obj.children = [];
        selectedItems = this.diagram.selectedItems.nodes;
        selectedItems = selectedItems.concat(this.diagram.selectedItems.connectors);
        var connectors = this.diagram.connectors;
        connectors.forEach(function (connector) {
            var sourceNode = _this.diagram.nameTable[connector.sourceID];
            var targetNode = _this.diagram.nameTable[connector.targetID];
            var isSourceNode = (sourceNode && sourceNode.processId &&
                isSelected(_this.diagram, _this.diagram.nameTable[sourceNode.processId]));
            var isTargetNode = (targetNode && targetNode.processId &&
                isSelected(_this.diagram, _this.diagram.nameTable[targetNode.processId]));
            var isAlreadySelected = selectedItems.some(function (item) { return item.id === connector.id; });
            if (!isAlreadySelected && (isSourceNode || isTargetNode)) {
                selectedItems.push(connector);
            }
        });
        var order = selectedItems.sort(function (a, b) {
            return a.zIndex - b.zIndex;
        });
        for (var i = 0; i < order.length; i++) {
            if (!order[parseInt(i.toString(), 10)].parentId) {
                obj.children.push(order[parseInt(i.toString(), 10)].id);
            }
        }
        //867606 - Exception throws while grouping the existing group nodes.
        if (obj.children.length > 0) {
            var group = this.diagram.add(obj);
            if (group) {
                this.select(group);
            }
            // 939249: Duplicate Ports Added to Group After Grouping and Undoing.
            obj.annotations = group.annotations;
            obj.ports = group.ports;
            obj.style = group.style;
            var entry = { type: 'Group', undoObject: obj, redoObject: obj, category: 'Internal' };
            this.addHistoryEntry(entry);
            this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.Group;
            this.diagram.protectPropertyChange(protectedChange);
            // this.updateBlazorSelector();
        }
    };
    /**
     * unGroup method\
     *
     * @returns {  void }    unGroup method .\
     * @param {NodeModel} obj - provide the angle value.
     * @private
     */
    CommandHandler.prototype.unGroup = function (obj) {
        var propName = 'isProtectedOnChange';
        var protectedChange = this.diagram["" + propName];
        this.diagram.protectPropertyChange(true);
        this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.Group;
        var selectedItems = [];
        if (obj) {
            selectedItems.push(obj);
        }
        else {
            selectedItems = this.diagram.selectedItems.nodes;
        }
        this.diagram.startGroupAction();
        for (var i = 0; i < selectedItems.length; i++) {
            var node = selectedItems[parseInt(i.toString(), 10)];
            var undoObject = cloneObject(node);
            var childCollection = [];
            for (var k = 0; k < node.children.length; k++) {
                childCollection.push(node.children[parseInt(k.toString(), 10)]);
            }
            if (node.children) {
                if (node.ports && node.ports.length > 0) {
                    this.diagram.removePorts(node, node.ports);
                }
                if (node.annotations && node.annotations.length > 0 && (!isBlazor())) {
                    this.diagram.removeLabels(node, node.annotations);
                }
                var parentNode = this.diagram.nameTable[node.parentId];
                for (var j = node.children.length - 1; j >= 0; j--) {
                    (this.diagram.nameTable[node.children[parseInt(j.toString(), 10)]]).parentId = '';
                    var childNode = node.children[parseInt(j.toString(), 10)];
                    this.diagram.deleteChild(this.diagram.nameTable[node.children[parseInt(j.toString(), 10)]], node);
                    if (node.parentId && childNode) {
                        this.diagram.addChild(parentNode, childNode);
                    }
                }
                this.resetDependentConnectors(node.inEdges, true);
                this.resetDependentConnectors(node.outEdges, false);
                var entry = {
                    type: 'UnGroup', undoObject: undoObject,
                    redoObject: undoObject, category: 'Internal'
                };
                if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {
                    this.addHistoryEntry(entry);
                }
                if (node.parentId) {
                    this.diagram.deleteChild(node, parentNode);
                }
            }
            this.diagram.removeNode(node, childCollection);
            this.clearSelection();
        }
        this.diagram.endGroupAction();
        this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.Group;
        this.diagram.protectPropertyChange(protectedChange);
    };
    CommandHandler.prototype.resetDependentConnectors = function (edges, isInEdges) {
        for (var i = 0; i < edges.length; i++) {
            var newConnector = this.diagram.nameTable[edges[parseInt(i.toString(), 10)]];
            var undoObject = cloneObject(newConnector);
            var newProp = void 0;
            if (isInEdges) {
                newConnector.targetID = '';
                newConnector.targetPortID = '';
                newProp = { targetID: newConnector.targetID, targetPortID: newConnector.targetPortID };
            }
            else {
                newConnector.sourceID = '';
                newConnector.sourcePortID = '';
                newProp = { sourceID: newConnector.sourceID, sourcePortID: newConnector.sourcePortID };
            }
            this.diagram.connectorPropertyChange(newConnector, {}, newProp);
            var entry = {
                type: 'ConnectionChanged', undoObject: { connectors: [undoObject], nodes: [] },
                redoObject: { connectors: [cloneObject(newConnector)], nodes: [] }, category: 'Internal'
            };
            if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {
                this.addHistoryEntry(entry);
            }
        }
    };
    /**
     * paste method\
     *
     * @returns { void }    paste method .\
     * @param {(NodeModel | ConnectorModel)[]} obj - provide the objects value.
     * @private
     */
    CommandHandler.prototype.paste = function (obj) {
        if (obj || this.clipboardData.clipObject) {
            this.diagram.protectPropertyChange(true);
            var copiedItems = obj ? this.getNewObject(obj) :
                this.clipboardData.clipObject;
            if (copiedItems) {
                var multiSelect = copiedItems.length !== 1;
                var groupAction = false;
                var objectTable = {};
                var keyTable = {};
                if (this.clipboardData.pasteIndex !== 0) {
                    this.clearSelection();
                }
                if (this.diagram.undoRedoModule) {
                    groupAction = true;
                    this.diagram.historyManager.startGroupAction();
                }
                for (var _i = 0, copiedItems_1 = copiedItems; _i < copiedItems_1.length; _i++) {
                    var copy = copiedItems_1[_i];
                    objectTable[copy.id] = copy;
                }
                var copiedObject = [];
                if (multiSelect) {
                    // This bool is also consider to prevent selection change event is triggered after every object clone
                    this.diagram.isServerUpdate = true;
                }
                for (var j = 0; j < copiedItems.length; j++) {
                    var copy = copiedItems[parseInt(j.toString(), 10)];
                    //EJ2-841227-Copy paste of child node from group node
                    if (copy.parentId) {
                        var parentObj = this.diagram.getObject(copy.parentId);
                        if (parentObj.shape.type !== 'SwimLane' && copy.parentId) {
                            copy.parentId = '';
                        }
                    }
                    if (getObjectType(copy) === Connector) {
                        var clonedObj = cloneObject(copy);
                        var nodeId = clonedObj.sourceID;
                        clonedObj.sourceID = '';
                        if (objectTable["" + nodeId] && keyTable["" + nodeId]) {
                            clonedObj.sourceID = keyTable["" + nodeId];
                        }
                        nodeId = clonedObj.targetID;
                        clonedObj.targetID = '';
                        if (objectTable["" + nodeId] && keyTable["" + nodeId]) {
                            clonedObj.targetID = keyTable["" + nodeId];
                        }
                        //To check if the connector is cloned already for text annotation node.
                        var allowClone = true;
                        if (clonedObj.targetID) {
                            var targetNode = this.diagram.nameTable[clonedObj.targetID];
                            if (targetNode.shape.shape === 'TextAnnotation' && targetNode.inEdges && targetNode.inEdges.length > 0) {
                                allowClone = false;
                            }
                        }
                        if (allowClone) {
                            var newObj = this.cloneConnector(clonedObj, multiSelect);
                            copiedObject.push(newObj);
                            keyTable[copy.id] = newObj.id;
                        }
                    }
                    else {
                        // Ej2-909148-BPMN -- BPMN Subprocess Issues with Node Misplacement During Copy/Paste and Undo/Redo
                        if (copy.shape && copy.shape.type === 'Bpmn') {
                            copy.processId = '';
                        }
                        //To indicate the node cloning which helps to avoid alignment of child nodes with flip.
                        this.cloningInProgress = true;
                        var newNode = this.cloneNode(copy, multiSelect);
                        this.cloningInProgress = false;
                        copiedObject.push(newNode);
                        //bpmn text annotations will not be pasted
                        if (newNode) {
                            keyTable[copy.id] = newNode.id;
                            var edges = copy.inEdges;
                            if (edges) {
                                for (var _a = 0, edges_1 = edges; _a < edges_1.length; _a++) {
                                    var edge = edges_1[_a];
                                    if (objectTable["" + edge] && keyTable["" + edge]) {
                                        var newConnector = this.diagram.nameTable[keyTable["" + edge]];
                                        newConnector.targetID = keyTable[copy.id];
                                        this.diagram.connectorPropertyChange(newConnector, { targetID: '', targetPortID: '' }, { targetID: newConnector.targetID, targetPortID: newConnector.targetPortID });
                                    }
                                }
                            }
                            edges = copy.outEdges;
                            if (edges) {
                                for (var _b = 0, edges_2 = edges; _b < edges_2.length; _b++) {
                                    var edge = edges_2[_b];
                                    if (objectTable["" + edge] && keyTable["" + edge]) {
                                        var newConnector = this.diagram.nameTable[keyTable["" + edge]];
                                        newConnector.sourceID = keyTable[copy.id];
                                        this.diagram.connectorPropertyChange(newConnector, { sourceID: '', sourcePortID: '' }, { sourceID: newConnector.sourceID, sourcePortID: newConnector.sourcePortID });
                                    }
                                }
                            }
                        }
                    }
                }
                if (multiSelect) {
                    this.diagram.isServerUpdate = false;
                    // this.diagram.UpdateBlazorDiagramModelCollection(copiedItems[0] as Node, copiedObject);
                    // this.getBlazorOldValues();
                    this.diagram.select(copiedObject, true);
                }
                if (groupAction === true) {
                    this.diagram.historyManager.endGroupAction();
                    groupAction = false;
                }
                if (this.diagram.mode !== 'SVG') {
                    this.diagram.refreshDiagramLayer();
                }
                this.clipboardData.pasteIndex++;
                this.diagram.protectPropertyChange(false);
            }
        }
    };
    CommandHandler.prototype.getNewObject = function (obj) {
        var newObj;
        var newobjs = [];
        this.clipboardData.pasteIndex = 1;
        for (var i = 0; i < obj.length; i++) {
            newObj = cloneObject(obj[parseInt(i.toString(), 10)]);
            newobjs.push(newObj);
        }
        return newobjs;
    };
    CommandHandler.prototype.cloneConnector = function (connector, multiSelect) {
        //let newConnector: Node | Connector;
        var cloneObject$1 = cloneObject(connector);
        this.translateObject(cloneObject$1);
        cloneObject$1.zIndex = Number.MIN_VALUE;
        var newConnector = this.diagram.add(cloneObject$1);
        if (!this.diagram.isServerUpdate) {
            this.selectObjects([newConnector], multiSelect);
        }
        return newConnector;
    };
    CommandHandler.prototype.cloneNode = function (node, multiSelect, children, groupnodeID) {
        var newNode;
        var connectorsTable = {};
        var cloneObject$1 = cloneObject(node);
        var process;
        var temp = this.diagram.nameTable[node.parentId];
        if (node.shape && node.shape.type === 'Bpmn' && node.shape.activity &&
            node.shape.activity.subProcess.processes
            && node.shape.activity.subProcess.processes.length) {
            process = cloneObject$1.shape.activity.subProcess.processes;
            cloneObject$1.zIndex = Number.MIN_VALUE;
            cloneObject$1.shape.activity.subProcess.processes = undefined;
        }
        if (node.shape && node.shape.type === 'SwimLane') {
            pasteSwimLane(node, this.diagram, this.clipboardData);
        }
        else if (temp && temp.shape.type === 'SwimLane') {
            pasteSwimLane(cloneObject(temp), this.diagram, this.clipboardData, node, true);
        }
        else if (node.children && node.children.length && (!children || !children.length)) {
            newNode = this.cloneGroup(node, multiSelect);
        }
        else {
            this.translateObject(cloneObject$1, groupnodeID);
            cloneObject$1.zIndex = Number.MIN_VALUE;
            if (children) {
                cloneObject$1.children = children;
            }
            if (cloneObject$1.shape && cloneObject$1.shape.shape === 'TextAnnotation') {
                cloneObject$1.isTextAnnotationCopied = true;
            }
            newNode = this.diagram.add(cloneObject$1);
        }
        for (var _i = 0, _a = Object.keys(connectorsTable); _i < _a.length; _i++) {
            var i = _a[_i];
            this.diagram.add(connectorsTable["" + i]);
        }
        if (process && process.length) {
            newNode.shape.activity.subProcess.processes = process;
            this.cloneSubProcesses(newNode);
        }
        if (newNode && !this.diagram.isServerUpdate) {
            this.selectObjects([newNode], multiSelect);
        }
        return newNode;
    };
    CommandHandler.prototype.cloneSubProcesses = function (node) {
        var connector = [];
        var temp = {};
        if (node.shape.type === 'Bpmn' && node.shape.activity &&
            node.shape.activity.subProcess.processes
            && node.shape.activity.subProcess.processes.length) {
            var process = node.shape.activity.subProcess.processes;
            for (var g = 0; g < process.length; g++) {
                var child = this.diagram.nameTable[process[parseInt(g.toString(), 10)]]
                    || this.clipboardData.processTable[process[parseInt(g.toString(), 10)]];
                for (var _i = 0, _a = child.outEdges; _i < _a.length; _i++) {
                    var j = _a[_i];
                    if (connector.indexOf(j) < 0) {
                        connector.push(j);
                    }
                }
                for (var _b = 0, _c = child.inEdges; _b < _c.length; _b++) {
                    var j = _c[_b];
                    if (connector.indexOf(j) < 0) {
                        connector.push(j);
                    }
                }
                var innerChild = cloneObject(this.clipboardData.processTable[process[parseInt(g.toString(), 10)]]);
                innerChild.processId = node.id;
                var newNode = this.cloneNode(innerChild, false);
                temp[process[parseInt(g.toString(), 10)]] = newNode.id;
                process[parseInt(g.toString(), 10)] = newNode.id;
                this.diagram.addProcess(newNode, node.id);
                for (var _d = 0, connector_1 = connector; _d < connector_1.length; _d++) {
                    var i = connector_1[_d];
                    var node_1 = this.diagram.nameTable["" + i] || this.diagram.connectorTable["" + i];
                    var clonedNode = cloneObject(node_1);
                    if (temp[clonedNode.sourceID] && temp[clonedNode.targetID]) {
                        clonedNode.zIndex = -1;
                        clonedNode.id += randomId();
                        clonedNode.sourceID = temp[clonedNode.sourceID];
                        clonedNode.targetID = temp[clonedNode.targetID];
                        connector.splice(connector.indexOf(i), 1);
                        //937235: Copy paste subprocess with connector, the connector disappears.
                        clonedNode.zIndex = Number.MIN_VALUE;
                        this.diagram.add(clonedNode);
                    }
                }
            }
        }
    };
    CommandHandler.prototype.cloneGroup = function (obj, multiSelect) {
        var sourceId;
        var targetId;
        var newChildren = [];
        var children = [];
        var connectorObj = [];
        var newObj;
        var oldID = [];
        children = children.concat(obj.children);
        var id = randomId();
        var objectCollection = [];
        this.diagram.blazorActions |= BlazorAction.GroupClipboardInProcess;
        if (this.clipboardData.childTable || obj.children.length > 0) {
            for (var i = 0; i < children.length; i++) {
                var childObj = void 0;
                if (this.clipboardData.childTable) {
                    childObj = this.clipboardData.childTable[children[parseInt(i.toString(), 10)]];
                    // EJ2-905181 - Added to consider copy paste and clone the new group node.
                    if (!childObj) {
                        childObj = this.diagram.nameTable[children[parseInt(i.toString(), 10)]];
                    }
                }
                else {
                    childObj = this.diagram.nameTable[children[parseInt(i.toString(), 10)]];
                }
                childObj.parentId = '';
                if (childObj) {
                    if (getObjectType(childObj) === Connector) {
                        connectorObj.push(childObj);
                    }
                    else {
                        newObj = this.cloneNode(childObj, multiSelect, undefined, id);
                        oldID.push(childObj.id);
                        newChildren.push(newObj.id);
                        objectCollection.push(newObj);
                    }
                }
            }
        }
        for (var k = 0; k < connectorObj.length; k++) {
            if (connectorObj[parseInt(k.toString(), 10)].sourceID || connectorObj[parseInt(k.toString(), 10)].targetID) {
                for (var j = 0; j < oldID.length; j++) {
                    if (connectorObj[parseInt(k.toString(), 10)].sourceID === (oldID[parseInt(j.toString(), 10)])) {
                        sourceId = connectorObj[parseInt(k.toString(), 10)].sourceID;
                        connectorObj[parseInt(k.toString(), 10)].sourceID += id;
                    }
                    if (connectorObj[parseInt(k.toString(), 10)].targetID === (oldID[parseInt(j.toString(), 10)])) {
                        targetId = connectorObj[parseInt(k.toString(), 10)].targetID;
                        connectorObj[parseInt(k.toString(), 10)].targetID += id;
                    }
                }
            }
            newObj = this.cloneConnector(connectorObj[parseInt(k.toString(), 10)], multiSelect);
            //EJ2-839982 - When we copy paste the group node multiple times, the connector is not rendered properly
            connectorObj[parseInt(k.toString(), 10)].sourceID = sourceId;
            connectorObj[parseInt(k.toString(), 10)].targetID = targetId;
            newChildren.push(newObj.id);
            objectCollection.push(newObj);
        }
        var parentObj = this.cloneNode(obj, multiSelect, newChildren);
        objectCollection.push(parentObj);
        if (parentObj && parentObj.container && parentObj.shape && parentObj.shape.type === 'UmlClassifier') {
            this.diagram.updateDiagramObject(parentObj);
            parentObj.wrapper.measure(new Size());
        }
        this.diagram.blazorActions &= ~BlazorAction.GroupClipboardInProcess;
        if (!this.diagram.isServerUpdate) {
            this.diagram.UpdateBlazorDiagramModelCollection(undefined, objectCollection, undefined, true);
        }
        else {
            this.cloneGroupChildCollection = objectCollection;
        }
        return parentObj;
    };
    /**
     * translateObject method\
     *
     * @returns { Object[] }    translateObject method .\
     * @param {Node | Connector} obj - provide the objects value.
     * @param {string} groupnodeID - provide the objects value.
     * @private
     */
    CommandHandler.prototype.translateObject = function (obj, groupnodeID) {
        obj.id += groupnodeID || randomId();
        var diff = this.clipboardData.pasteIndex * 10;
        if (getObjectType(obj) === Connector) {
            obj.sourcePoint = {
                x: obj.sourcePoint.x + diff, y: obj.sourcePoint.y + diff
            };
            obj.targetPoint = {
                x: obj.targetPoint.x + diff, y: obj.targetPoint.y + diff
            };
            if (obj.type === 'Bezier') {
                var segments = obj.segments;
                for (var i = 0; i < segments.length; i++) {
                    if (!Point.isEmptyPoint(segments[parseInt(i.toString(), 10)].point1)) {
                        segments[parseInt(i.toString(), 10)].point1 = {
                            x: segments[parseInt(i.toString(), 10)].point1.x + diff, y: segments[parseInt(i.toString(), 10)].point1.y + diff
                        };
                    }
                    if (!Point.isEmptyPoint(segments[parseInt(i.toString(), 10)].point2)) {
                        segments[parseInt(i.toString(), 10)].point2 = {
                            x: segments[parseInt(i.toString(), 10)].point2.x + diff, y: segments[parseInt(i.toString(), 10)].point2.y + diff
                        };
                    }
                }
            }
            if (obj.type === 'Straight' || obj.type === 'Bezier') {
                if (obj.segments && obj.segments.length > 0) {
                    var segments = obj.segments;
                    for (var i = 0; i < segments.length - 1; i++) {
                        segments[parseInt(i.toString(), 10)].point.x += diff;
                        segments[parseInt(i.toString(), 10)].point.y += diff;
                    }
                }
            }
        }
        else {
            obj.offsetX += diff;
            obj.offsetY += diff;
        }
    };
    /**
     * drawObject method\
     *
     * @returns { Node | Connector }    drawObject method .\
     * @param {Node | Connector} obj - provide the objects value.
     * @private
     */
    CommandHandler.prototype.drawObject = function (obj) {
        var newObj;
        //let cloneObject: Node | Connector;
        if (obj && obj.shape) {
            if (obj.shape.type === 'Text') {
                obj.width = this.diagram.drawingObject.width ? this.diagram.drawingObject.width : 50;
                obj.height = this.diagram.drawingObject.height ? this.diagram.drawingObject.height : 20;
            }
        }
        var cloneObject$1 = cloneObject(this.diagram.drawingObject);
        for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
            var prop = _a[_i];
            cloneObject$1["" + prop] = obj["" + prop];
        }
        if (getObjectType(this.diagram.drawingObject) === Node || (getObjectType(this.diagram.drawingObject) === Connector && this.diagram.drawingObject.type === 'Freehand' && obj.type !== 'Bezier')) {
            newObj = new Node(this.diagram, 'nodes', cloneObject$1, true);
            newObj.id = (this.diagram.drawingObject.id || 'node') + randomId();
        }
        else {
            newObj = new Connector(this.diagram, 'connectors', cloneObject$1, true);
            newObj.id = (this.diagram.drawingObject ? (this.diagram.drawingObject.id ? this.diagram.drawingObject.id : 'connector')
                : 'connector') + randomId();
        }
        this.diagram.initObject(newObj);
        this.diagram.updateDiagramObject(newObj);
        this.diagram.currentDrawingObject = newObj;
        return newObj;
    };
    /**
     * addObjectToDiagram method\
     *
     * @returns { void }    addObjectToDiagram method .\
     * @param {Node | Connector} obj - provide the objects value.
     * @private
     */
    CommandHandler.prototype.addObjectToDiagram = function (obj) {
        //let newObj: Node | Connector;
        this.diagram.removeFromAQuad(obj);
        this.diagram.removeObjectsFromLayer(this.diagram.nameTable[obj.id]);
        delete this.diagram.nameTable[obj.id];
        //EJ2-62652 - Added below code to empty the segment collection if connector type is bezier
        if (obj instanceof Connector && obj.type === 'Bezier' && obj.segments.length > 0
            && (this.diagram.drawingObject && this.diagram.drawingObject.type === 'Bezier')) {
            obj.segments = [];
        }
        var newObj = this.diagram.add(obj);
        if (this.diagram.mode !== 'SVG') {
            this.diagram.refreshDiagramLayer();
        }
        this.selectObjects([newObj]);
        if (obj && (!(canContinuousDraw(this.diagram)))) {
            this.diagram.tool &= ~DiagramTools.DrawOnce;
            this.diagram.currentDrawingObject = undefined;
        }
    };
    /**
     * addObjectToDiagram method\
     *
     * @returns { void }    addObjectToDiagram method .\
     * @param {boolean} enable - provide the objects value.
     * @private
     */
    CommandHandler.prototype.enableServerDataBinding = function (enable) {
        this.diagram.enableServerDataBinding(enable);
    };
    /**
     * addText method\
     *
     * @returns { void }    addText method .\
     * @param {boolean} obj - provide the objects value.
     * @param {PointModel} currentPosition - provide the objects value.
     * @private
     */
    CommandHandler.prototype.addText = function (obj, currentPosition) {
        var annotation = this.diagram.findElementUnderMouse(obj, currentPosition, this.diagram);
        this.diagram.startTextEdit(obj, annotation instanceof TextElement ? (annotation.id).split('_')[1] : undefined);
    };
    /**
     * isUserHandle method\
     *
     * @returns { boolean }    isUserHandle method .\
     * @param {PointModel} position - provide the objects value.
     * @private
     */
    CommandHandler.prototype.isUserHandle = function (position) {
        var handle = this.diagram.selectedItems;
        if (handle.wrapper && canShowCorner(handle.constraints, 'UserHandle')) {
            for (var _i = 0, _a = handle.userHandles; _i < _a.length; _i++) {
                var obj = _a[_i];
                if (obj.visible) {
                    var paddedBounds = getUserHandlePosition(handle, obj, this.diagram.scroller.transform);
                    if (contains(position, paddedBounds, obj.size / (2 * this.diagram.scroller.transform.scale))) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    /**
     * selectObjects method\
     *
     * @returns { Promise<void> }    selectObjects method .\
     * @param {(NodeModel | ConnectorModel | AnnotationModel)[]} obj - provide the objects value.
     * @param {boolean} multipleSelection - provide the objects value.
     * @param {(NodeModel | ConnectorModel| AnnotationModel)[]} oldValue - provide the objects value.
     * @private
     */
    CommandHandler.prototype.selectObjects = function (obj, multipleSelection, oldValue) {
        return __awaiter$1(this, void 0, void 0, function () {
            var arg, swimlaneNode, laneId, j, i, parentId, select, oldSelectedItems, canDoMultipleSelection, canDoSingleSelection, i, newObj, i_1, parentNode;
            return __generator$1(this, function (_a) {
                arg = {
                    oldValue: oldValue ? oldValue : this.getSelectedObject(),
                    newValue: obj, cause: this.diagram.diagramActions,
                    state: 'Changing', type: 'Addition', cancel: false
                };
                // EJ2-57157 - Added to consider the lane header at selection change when selecting a lane.
                if (obj.length > 0 && (obj[0] && obj[0].isLane)) {
                    swimlaneNode = this.diagram.getObject(obj[0].parentId);
                    obj[0].shape.header = [];
                    laneId = '';
                    for (j = 0; j < obj.length; j++) {
                        for (i = 0; i < swimlaneNode.shape.lanes.length; i++) {
                            parentId = obj[0].id.split(obj[0].parentId);
                            laneId = parentId[1].slice(0, -1);
                            if (laneId === swimlaneNode.shape.lanes[parseInt(i.toString(), 10)].id) {
                                obj[0].shape.header.push(swimlaneNode.shape.lanes[parseInt(i.toString(), 10)].header);
                            }
                        }
                    }
                }
                this.diagram.enableServerDataBinding(false);
                select = true;
                if (!isBlazor()) {
                    this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);
                }
                else {
                    this.oldSelectedObjects = cloneSelectedObjects(this.diagram);
                }
                oldSelectedItems = this.diagram.selectedItems.annotation ?
                    [this.diagram.selectedItems.annotation] :
                    (this.diagram.selectedItems.nodes.concat(this.diagram.selectedItems.connectors));
                canDoMultipleSelection = canMultiSelect(this.diagram);
                canDoSingleSelection = canSingleSelect(this.diagram);
                if (canDoSingleSelection || canDoMultipleSelection) {
                    if (!canDoMultipleSelection && ((obj.length > 1) || (multipleSelection && obj.length === 1))) {
                        if (obj.length === 1) {
                            this.clearSelection();
                        }
                        else {
                            return [2 /*return*/];
                        }
                    }
                    if (!(canDoSingleSelection || canDoMultipleSelection) && obj.length === 1
                        && (!multipleSelection || !hasSelection(this.diagram))) {
                        this.clearSelection();
                        return [2 /*return*/];
                    }
                }
                if (!arg.cancel) {
                    for (i = 0; i < obj.length; i++) {
                        newObj = obj[parseInt(i.toString(), 10)];
                        if (newObj) {
                            select = true;
                            if (!hasSelection(this.diagram)) {
                                this.select(newObj, i > 0 || multipleSelection, true);
                            }
                            else {
                                if ((i > 0 || multipleSelection) && newObj.children && !newObj.parentId) {
                                    for (i_1 = 0; i_1 < this.diagram.selectedItems.nodes.length; i_1++) {
                                        parentNode = this.diagram.nameTable[this.diagram.selectedItems.nodes[parseInt(i_1.toString(), 10)].parentId];
                                        if (parentNode) {
                                            parentNode = this.findParent(parentNode);
                                            if (parentNode) {
                                                if (newObj.id === parentNode.id) {
                                                    this.selectGroup(newObj);
                                                }
                                            }
                                        }
                                    }
                                }
                                this.selectProcesses(newObj);
                                select = this.selectBpmnSubProcesses(newObj);
                                if (select) {
                                    this.select(newObj, i > 0 || multipleSelection, true);
                                }
                            }
                        }
                    }
                    if (oldValue === undefined) {
                        oldValue = oldSelectedItems;
                    }
                    arg = {
                        oldValue: oldValue ? oldValue : [],
                        newValue: this.getSelectedObject(),
                        cause: this.diagram.diagramActions, state: 'Changed', type: 'Addition', cancel: false
                    };
                    this.diagram.renderSelector(multipleSelection || (obj && obj.length > 1));
                    // this.updateBlazorSelectorModel(oldValue);
                    if (!isBlazor()) {
                        this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);
                    }
                    this.diagram.enableServerDataBinding(true);
                }
                return [2 /*return*/];
            });
        });
    };
    // /**
    //  * updateBlazorSelector method\
    //  *
    //  * @returns { void }    updateBlazorSelector method .\
    //  * @private
    //  */
    // public updateBlazorSelector(): void {
    //     //remove blazor code
    // }
    /**
     * findParent method\
     *
     * @returns { Node }    findParent method .\
     * @param {Node} node - provide the objects value.
     * @private
     */
    CommandHandler.prototype.findParent = function (node) {
        if (node.parentId) {
            node = this.diagram.nameTable[node.parentId];
            this.findParent(node);
        }
        return node;
    };
    CommandHandler.prototype.selectProcesses = function (newObj) {
        if (this.hasProcesses(newObj)) {
            var processes = (newObj).shape.activity.subProcess.processes;
            for (var i = 0; i < processes.length; i++) {
                var innerChild = this.diagram.nameTable[processes[parseInt(i.toString(), 10)]];
                if (this.hasProcesses(innerChild)) {
                    this.selectObjects([innerChild], true);
                }
                this.unSelect(innerChild);
            }
        }
    };
    CommandHandler.prototype.selectGroup = function (newObj) {
        for (var j = 0; j < newObj.children.length; j++) {
            var innerChild = this.diagram.nameTable[newObj.children[parseInt(j.toString(), 10)]];
            if (innerChild.children) {
                this.selectGroup(innerChild);
            }
            this.unSelect(this.diagram.nameTable[newObj.children[parseInt(j.toString(), 10)]]);
        }
    };
    CommandHandler.prototype.selectBpmnSubProcesses = function (node) {
        var select = true;
        var parent;
        if (node.processId) {
            if (isSelected(this.diagram, this.diagram.nameTable[node.processId])) {
                select = false;
            }
            else {
                select = this.selectBpmnSubProcesses(this.diagram.nameTable[node.processId]);
            }
        }
        else if (node instanceof Connector) {
            if (node.sourceID && this.diagram.nameTable[node.sourceID] &&
                this.diagram.nameTable[node.sourceID].processId) {
                parent = this.diagram.nameTable[node.sourceID].processId;
            }
            if (node.targetID && this.diagram.nameTable[node.targetID] &&
                this.diagram.nameTable[node.targetID].processId) {
                parent = this.diagram.nameTable[node.targetID].processId;
            }
            if (parent) {
                if (isSelected(this.diagram, this.diagram.nameTable["" + parent])) {
                    return false;
                }
                else {
                    select = this.selectBpmnSubProcesses(this.diagram.nameTable["" + parent]);
                }
            }
        }
        else if (node.parentId && this.diagram.nameTable[node.parentId] &&
            this.diagram.nameTable[node.parentId].shape.type === 'UmlClassifier') {
            if (isSelected(this.diagram, this.diagram.nameTable[node.parentId])) {
                select = false;
            }
        }
        return select;
    };
    CommandHandler.prototype.hasProcesses = function (node) {
        if (node) {
            if ((node.shape.type === 'Bpmn') && node.shape.activity &&
                node.shape.activity.subProcess.processes &&
                node.shape.activity.subProcess.processes.length > 0) {
                return true;
            }
        }
        return false;
    };
    /**
     * select method\
     *
     * @returns { void }    select method .\
     * @param {NodeModel | ConnectorModel} obj - provide the objects value.
     * @param {boolean} multipleSelection - provide the objects value.
     * @param {boolean} preventUpdate - provide the objects value.
     * @private
     */
    CommandHandler.prototype.select = function (obj, multipleSelection, preventUpdate) {
        var hasLayer = this.getObjectLayer(obj.id);
        if ((canSelect(obj) && !(obj instanceof Selector) && !isSelected(this.diagram, obj))
            && (hasLayer && !hasLayer.lock && hasLayer.visible) && obj.wrapper.visible) {
            multipleSelection = hasSelection(this.diagram) ? multipleSelection : false;
            if (!multipleSelection) {
                this.clearSelection();
            }
            this.diagram.enableServerDataBinding(false);
            var selectorModel = this.diagram.selectedItems;
            var convert = obj;
            if (convert instanceof Node) {
                if (obj.isHeader) {
                    var node = this.diagram.nameTable[obj.parentId];
                    selectorModel.nodes.push(node);
                }
                else {
                    selectorModel.nodes.push(obj);
                }
            }
            else {
                selectorModel.connectors.push(obj);
            }
            // EJ2-56919 - Push the newly selected objects in selectedObjects collection
            selectorModel.selectedObjects.push(obj);
            if (!multipleSelection) {
                selectorModel.init(this.diagram);
                if (selectorModel.nodes.length === 1 && selectorModel.connectors.length === 0) {
                    var wrapper = gridSelection(this.diagram, selectorModel);
                    if (wrapper) {
                        selectorModel.wrapper.children[0] = wrapper;
                    }
                    selectorModel.rotateAngle = selectorModel.nodes[0].rotateAngle;
                    selectorModel.wrapper.rotateAngle = selectorModel.nodes[0].rotateAngle;
                    selectorModel.wrapper.pivot = selectorModel.nodes[0].pivot;
                }
            }
            else {
                selectorModel.wrapper.rotateAngle = selectorModel.rotateAngle = 0;
                selectorModel.wrapper.children.push(obj.wrapper);
            }
            if (!preventUpdate) {
                this.diagram.renderSelector(multipleSelection);
            }
            this.diagram.enableServerDataBinding(true);
        }
    };
    // private getObjectCollectionId(isNode: boolean, clearSelection?: boolean): string[] {
    //     const id: string[] = [];
    //     let i: number = 0;
    //     const selectedObject: (NodeModel | ConnectorModel)[] = isNode ? this.diagram.selectedItems.nodes
    //         : this.diagram.selectedItems.connectors;
    //     while (!clearSelection && i < selectedObject.length) {
    //         id[parseInt(i.toString(), 10)] = selectedObject[parseInt(i.toString(), 10)].id;
    //         i++;
    //     }
    //     return id;
    // }
    // private updateBlazorSelectorModel(oldItemsCollection: (NodeModel | ConnectorModel)[], clearSelection?: boolean): void {
    // remove blazor code
    // }
    /**
     * labelSelect method\
     *
     * @returns { void }    labelSelect method .\
     * @param {NodeModel | ConnectorModel | AnnotationModel} obj - provide the objects value.
     * @param {DiagramElement} textWrapper - provide the objects value.
     * @private
     */
    CommandHandler.prototype.labelSelect = function (obj, textWrapper, oldValue) {
        this.oldSelectedObjects = cloneSelectedObjects(this.diagram);
        var annotation = this.findTarget(textWrapper, obj);
        // Prepare the event arguments
        var eventArgs = {
            oldValue: oldValue ? oldValue : this.getSelectedObject(),
            newValue: [annotation],
            cause: this.diagram.diagramActions,
            state: 'Changing', type: 'Addition', cancel: false
        };
        // Trigger the selectionChange event with the updated newValue
        if (!isBlazor()) {
            this.diagram.triggerEvent(DiagramEvent.selectionChange, eventArgs);
        }
        else {
            this.oldSelectedObjects = cloneSelectedObjects(this.diagram);
        }
        if (!eventArgs.cancel) {
            var selectorModel = (this.diagram.selectedItems);
            var isEnableServerDatabind = this.diagram.allowServerDataBinding;
            this.diagram.allowServerDataBinding = false;
            selectorModel.nodes = selectorModel.connectors = [];
            this.diagram.allowServerDataBinding = isEnableServerDatabind;
            if (obj instanceof Node) {
                selectorModel.nodes[0] = obj;
            }
            else {
                selectorModel.connectors[0] = obj;
            }
            selectorModel.annotation = annotation;
            selectorModel.init(this.diagram);
            this.diagram.renderSelector(false);
            eventArgs = {
                oldValue: oldValue ? oldValue : [],
                newValue: [selectorModel.annotation],
                cause: this.diagram.diagramActions, state: 'Changed', type: 'Addition', cancel: false
            };
            if (!isBlazor()) {
                this.diagram.triggerEvent(DiagramEvent.selectionChange, eventArgs);
            }
        }
    };
    /**
     * unSelect method\
     *
     * @returns { void }    unSelect method .\
     * @param {NodeModel | ConnectorModel} obj - provide the objects value.
     * @private
     */
    CommandHandler.prototype.unSelect = function (obj) {
        var items = (this.diagram.selectedItems.nodes.concat(this.diagram.selectedItems.connectors));
        var selectedObjects = items.filter(function (items) {
            return items.id !== obj.id;
        });
        var arg = {
            oldValue: items, newValue: selectedObjects, cause: this.diagram.diagramActions,
            state: 'Changing', type: 'Removal', cancel: false
        };
        if (!this.diagram.currentSymbol) {
            if (!isBlazor()) {
                this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);
            }
        }
        if (isSelected(this.diagram, obj)) {
            var selectormodel = this.diagram.selectedItems;
            var index = void 0;
            if (obj instanceof Node) {
                index = selectormodel.nodes.indexOf(obj, 0);
                selectormodel.nodes.splice(index, 1);
            }
            else {
                index = selectormodel.connectors.indexOf(obj, 0);
                selectormodel.connectors.splice(index, 1);
            }
            index = selectormodel.selectedObjects.indexOf(obj, 0);
            selectormodel.selectedObjects.splice(index, 1);
            arg = {
                oldValue: items, newValue: selectedObjects, cause: this.diagram.diagramActions,
                state: 'Changed', type: 'Removal', cancel: false
            };
            // this.updateBlazorSelectorModel(objArray);
            arg = {
                oldValue: cloneBlazorObject(items), newValue: selectedObjects, cause: this.diagram.diagramActions,
                state: 'Changed', type: 'Removal', cancel: arg.cancel
            };
            if (!arg.cancel) {
                index = selectormodel.wrapper.children.indexOf(obj.wrapper, 0);
                selectormodel.wrapper.children.splice(index, 1);
                this.diagram.updateSelector();
                if (!this.diagram.currentSymbol) {
                    this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);
                }
            }
        }
    };
    /**
     * getChildElements method\
     *
     * @returns { string[] }    getChildElements method .\
     * @param {DiagramElement[]} child - provide the objects value.
     * @private
     */
    // public getChildElements(child: DiagramElement[]): string[] {
    //     const children: string[] = [];
    //     for (let i: number = 0; i < child.length; i++) {
    //         const childNode: DiagramElement = child[parseInt(i.toString(), 10)];
    //         if ((childNode as Container).children && (childNode as Container).children.length > 0) {
    //             // children.concat(this.getChildElements((childNode as Container).children));
    //         } else {
    //             children.push(childNode.id);
    //             if (childNode instanceof TextElement) {
    //                 children.push(childNode.id + '_text');
    //             }
    //         }
    //     }
    //     return children;
    // }
    /**
     * moveSvgNode method\
     *
     * @returns { void }    moveSvgNode method .\
     * @param {string} nodeId - provide the objects value.
     * @param {string} targetID - provide the objects value.
     * @private
     */
    CommandHandler.prototype.moveSvgNode = function (nodeId, targetID) {
        //Bug 921994: Z-index order changes are not reflected at the UI level with Undo Redo commands.
        var node = this.diagram.nameTable["" + targetID];
        if (node.shape.type === 'Native' || node.shape.type === 'HTML') {
            this.updateNativeNodeIndex(nodeId, targetID);
        }
        else {
            var diagramDiv = getDiagramElement(targetID + '_groupElement', this.diagram.element.id);
            var backNode = getDiagramElement(nodeId + '_groupElement', this.diagram.element.id);
            diagramDiv.parentNode.insertBefore(backNode, diagramDiv);
        }
    };
    CommandHandler.prototype.moveAfterSvgNode = function (nodeId, targetID) {
        //Bug 921994: Z-index order changes are not reflected at the UI level with Undo Redo commands.
        var node = this.diagram.nameTable["" + targetID];
        if (node && (node.shape.type === 'HTML' || node.shape.type === 'Native')) {
            for (var i = 0; i < this.diagram.views.length; i++) {
                var id = node.shape.type === 'HTML' ? '_html_element' : '_content_groupElement';
                var backNode = getDiagramElement(nodeId + id, this.diagram.views[parseInt(i.toString(), 10)]);
                var diagramDiv = targetID ? getDiagramElement(targetID + id, this.diagram.views[parseInt(i.toString(), 10)])
                    : backNode.parentElement.firstChild;
                if (backNode && diagramDiv) {
                    if (backNode.parentNode.id === diagramDiv.parentNode.id) {
                        diagramDiv.insertAdjacentElement('afterend', backNode);
                    }
                }
            }
        }
        else {
            var diagramDiv = getDiagramElement(targetID + '_groupElement', this.diagram.element.id);
            var backNode = getDiagramElement(nodeId + '_groupElement', this.diagram.element.id);
            diagramDiv.insertAdjacentElement('afterend', backNode);
        }
    };
    /**
     * sendLayerBackward method\
     *
     * @returns { void }    sendLayerBackward method .\
     * @param {string} layerName - provide the objects value.
     * @private
     */
    CommandHandler.prototype.sendLayerBackward = function (layerName) {
        var layer = this.getLayer(layerName);
        if (layer && layer.zIndex !== 0) {
            var index = layer.zIndex;
            if (this.diagram.mode === 'SVG') {
                var currentLayerObject = layer.objects;
                var targetObject = this.getLayer(this.diagram.layerZIndexTable[index - 1]).objects[0];
                if (targetObject) {
                    for (var _i = 0, currentLayerObject_1 = currentLayerObject; _i < currentLayerObject_1.length; _i++) {
                        var obj = currentLayerObject_1[_i];
                        this.moveSvgNode(obj, targetObject);
                    }
                }
            }
            var targetLayer = this.getLayer(this.diagram.layerZIndexTable[index - 1]);
            targetLayer.zIndex = targetLayer.zIndex + 1;
            layer.zIndex = layer.zIndex - 1;
            var temp = this.diagram.layerZIndexTable[parseInt(index.toString(), 10)];
            this.diagram.layerZIndexTable[parseInt(index.toString(), 10)] = this.diagram.layerZIndexTable[index - 1];
            this.diagram.layerZIndexTable[index - 1] = temp;
            if (this.diagram.mode === 'Canvas') {
                this.diagram.refreshDiagramLayer();
            }
        }
    };
    /**
     * bringLayerForward method\
     *
     * @returns { void }    bringLayerForward method .\
     * @param {string} layerName - provide the objects value.
     * @private
     */
    CommandHandler.prototype.bringLayerForward = function (layerName) {
        var layer = this.getLayer(layerName);
        if (layer && layer.zIndex < this.diagram.layers.length - 1) {
            var index = layer.zIndex;
            var targetLayer = this.getLayer(this.diagram.layerZIndexTable[index + 1]);
            if (this.diagram.mode === 'SVG') {
                var currentLayerObject = layer.objects[0];
                var targetLayerObjects = targetLayer.objects;
                for (var _i = 0, targetLayerObjects_1 = targetLayerObjects; _i < targetLayerObjects_1.length; _i++) {
                    var obj = targetLayerObjects_1[_i];
                    if (obj) {
                        this.moveSvgNode(obj, currentLayerObject);
                    }
                }
            }
            targetLayer.zIndex = targetLayer.zIndex - 1;
            layer.zIndex = layer.zIndex + 1;
            var temp = this.diagram.layerZIndexTable[parseInt(index.toString(), 10)];
            this.diagram.layerZIndexTable[parseInt(index.toString(), 10)] = this.diagram.layerZIndexTable[index + 1];
            this.diagram.layerZIndexTable[index + 1] = temp;
            if (this.diagram.mode === 'Canvas') {
                this.diagram.refreshDiagramLayer();
            }
        }
    };
    /**
     * sendToBack method\
     *
     * @returns { void }    sendToBack method .\
     * @param {NodeModel | ConnectorModel} object - provide the objects value.
     * @private
     */
    CommandHandler.prototype.sendToBack = function (object) {
        this.diagram.protectPropertyChange(true);
        if (hasSelection(this.diagram) || object) {
            // EJ2-57772 - Added the below code to iterate all the selected nodes / connectors in the diagram and
            // perform send to back operation
            var selectedItems = this.diagram.selectedItems;
            var objects = [];
            if (object && object.id) {
                objects.push(object);
            }
            else {
                objects = objects.concat(selectedItems.nodes);
                objects = objects.concat(selectedItems.connectors);
            }
            var objectId = (object && object.id);
            var undoObject = cloneObject(this.diagram.selectedItems);
            objects = objects.slice().sort(function (a, b) { return a.zIndex - b.zIndex; });
            for (var i = objects.length - 1; i >= 0; i--) {
                var clonedObject = cloneObject(objects[parseInt(i.toString(), 10)]);
                objectId = objects[parseInt(i.toString(), 10)].id;
                var index = this.diagram.nameTable["" + objectId].zIndex;
                var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectId));
                this.updateLayerZindexTable(layerNum);
                var zIndexTable = this.diagram.layers[parseInt(layerNum.toString(), 10)].zIndexTable;
                var layerObjects = this.diagram.layers[parseInt(layerNum.toString(), 10)].objects;
                var minZindex = null;
                var targetId = '';
                for (var i_2 = 0; i_2 < layerObjects.length; i_2++) {
                    var obj = this.diagram.nameTable[layerObjects[parseInt(i_2.toString(), 10)]];
                    if (minZindex === null || obj.zIndex < minZindex) {
                        minZindex = obj.zIndex;
                        targetId = obj.id;
                    }
                }
                var tempTable = JSON.parse(JSON.stringify(zIndexTable));
                var tempIndex = 0;
                //Checks whether the selected node is the only node in the node array.
                //Checks whether it is not a group and the nodes behind it are not its children.
                if (this.diagram.nodes.length !== 1 && (this.diagram.nameTable["" + objectId].children === undefined ||
                    this.checkObjectBehind(objectId, zIndexTable, index))) {
                    var obj = this.diagram.nameTable["" + objectId];
                    if (obj.zIndex > minZindex && obj.shape.type !== 'SwimLane') {
                        var clonedNode = cloneObject(obj);
                        var childMaxZindex = null;
                        var childCount = null;
                        if (obj.children) {
                            childMaxZindex = this.findMaxZIndex(obj);
                            childCount = childMaxZindex - obj.zIndex;
                            obj.zIndex = minZindex - 1 - childCount;
                            this.updateGroupZindex(obj, 'SendToBack', minZindex);
                        }
                        else {
                            obj.zIndex = minZindex - 1;
                        }
                        this.triggerOrderCommand(clonedNode, obj, obj);
                    }
                    else if (obj.shape.type === 'SwimLane') {
                        tempIndex = this.swapZIndexObjects(index, zIndexTable, objectId, tempTable);
                    }
                    // for (let i: number = index; i > 0; i--) {
                    //     if (zIndexTable[parseInt(i.toString(), 10)]) {
                    //         //When there are empty records in the zindex table
                    //         if (!zIndexTable[i - 1]) {
                    //             zIndexTable[i - 1] = zIndexTable[parseInt(i.toString(), 10)];
                    //             this.diagram.nameTable[zIndexTable[i - 1]].zIndex = i;
                    //             delete zIndexTable[parseInt(i.toString(), 10)];
                    //         } else {
                    //             //bringing the objects forward
                    //             let clonedNode = cloneObject( this.diagram.nameTable[zIndexTable[parseInt((i-1).toString(), 10)]]);
                    //             zIndexTable[parseInt(i.toString(), 10)] = zIndexTable[i - 1];
                    //             this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]].zIndex = i;
                    //             this.triggerOrderCommand(clonedNode, this.diagram.nameTable[zIndexTable[parseInt((i-1).toString(), 10)]], this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]]);
                    //         }
                    //     }
                    // }
                    // for (let i: number = index; i > 0; i--) {
                    //     if (zIndexTable[parseInt(i.toString(), 10)]) {
                    //         this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]].zIndex = i;
                    //     }
                    // }
                    // if (obj.shape.type !== 'SwimLane') {
                    //     zIndexTable[0] = this.diagram.nameTable[`${objectId}`].id;
                    //     this.diagram.nameTable[`${objectId}`].zIndex = 0;
                    //     this.triggerOrderCommand(clonedObject, objects[parseInt(i.toString(), 10)], objects[parseInt(i.toString(), 10)]);
                    // } else {
                    //     tempIndex = this.swapZIndexObjects(index, zIndexTable, objectId, tempTable);
                    // }
                    if (this.diagram.mode === 'SVG') {
                        var obj_1 = this.diagram.nameTable["" + objectId];
                        var i_3 = obj_1.shape.type !== 'SwimLane' ? minZindex : tempIndex;
                        // if (i !== tempIndex) {
                        //     i = (obj.children && obj.children.length > 0) ? index : 1;
                        // }
                        var target = zIndexTable[parseInt(i_3.toString(), 10)];
                        // EJ2-49326 - (CR issue fix) An exception raised when send the swimlane back to the normal node.
                        while (!target && i_3 < index) {
                            target = zIndexTable[++i_3];
                        }
                        // EJ2-46656 - CR issue fix
                        target = this.resetTargetNode(objectId, target, i_3, zIndexTable);
                        //EJ2-69654 - Send to back command not working when there is single node in layer
                        if (target) {
                            target = this.diagram.nameTable["" + target].parentId ? this.checkParentExist(target) : target;
                            this.moveSvgNode(objectId, target);
                        }
                        this.updateNativeNodeIndex(objectId);
                        this.updateLayerZindexTable(layerNum);
                    }
                    else {
                        this.diagram.refreshCanvasLayers();
                        this.updateLayerZindexTable(layerNum);
                    }
                }
            }
            var redoObject = cloneObject(this.diagram.selectedItems);
            var entry = { type: 'SendToBack', category: 'Internal', undoObject: undoObject, redoObject: redoObject };
            if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {
                this.addHistoryEntry(entry);
            }
        }
        this.diagram.protectPropertyChange(false);
    };
    CommandHandler.prototype.findMaxZIndex = function (parent) {
        var _this = this;
        var childMaxZindex = null;
        // Recursive function to find the maximum zIndex among all children
        var findMax = function (parent) {
            for (var m = 0; m < parent.children.length; m++) {
                var child = _this.diagram.nameTable[parent.children[parseInt(m.toString(), 10)]];
                // Update the maximum zIndex found
                if (childMaxZindex === null || child.zIndex > childMaxZindex) {
                    childMaxZindex = child.zIndex;
                }
                // Recurse if the child has its own children
                if (child.children) {
                    findMax(child);
                }
            }
        };
        findMax(parent);
        return childMaxZindex; // Return the maximum zIndex found
    };
    CommandHandler.prototype.updateGroupZindex = function (parent, command, index) {
        var _this = this;
        var newIndex;
        if (newIndex === undefined) {
            newIndex = parent.zIndex + 1; // Assign index if it is undefined
        }
        // Recursive function to update zIndex
        var updateGroupindex = function (parent) {
            for (var n = 0; n < parent.children.length; n++) {
                var child = _this.diagram.nameTable[parent.children[parseInt(n.toString(), 10)]]; // Use the correct index without parsing to int
                if (child.children) {
                    child.zIndex = newIndex++; // Update zIndex for children with children (group)
                    updateGroupindex(child); // Recursively update child group
                }
                else {
                    child.zIndex = newIndex++; // Update zIndex for individual children
                }
            }
        };
        updateGroupindex(parent); // Start the update process from the parent
    };
    CommandHandler.prototype.updateLayersZindexTable = function (layerIndex) {
        this.updateLayerZindexTable(layerIndex);
    };
    CommandHandler.prototype.updateLayerZindexTable = function (layerIndex) {
        var layer = this.diagram.layers[parseInt(layerIndex.toString(), 10)];
        layer.zIndexTable = {};
        for (var i = 0; i < layer.objects.length; i++) {
            var obj = this.diagram.nameTable[layer.objects[parseInt(i.toString(), 10)]];
            layer.zIndexTable[obj.zIndex] = obj.id;
        }
    };
    CommandHandler.prototype.swapZIndexObjects = function (index, zIndexTable, objectId, tempTable) {
        var tempIndex = 0;
        var childCount = 0;
        var childIndex = -1;
        var j = 1;
        // Get the swimlane's Children count
        for (var i = 0; i <= index; i++) {
            if (zIndexTable[parseInt(i.toString(), 10)]
                && this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]].parentId === objectId) {
                // Get the swimlane's first children position from z index table
                if (childIndex === -1) {
                    childIndex = i;
                }
                childCount++;
            }
        }
        // Swap the swimlane children to the top of the z index table
        for (var i = 0; i <= index; i++) {
            if (zIndexTable[parseInt(i.toString(), 10)] && j <= childCount) {
                while (!zIndexTable[parseInt(childIndex.toString(), 10)]) {
                    childIndex++;
                }
                zIndexTable[parseInt(i.toString(), 10)] = zIndexTable[parseInt(childIndex.toString(), 10)];
                this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]].zIndex = i;
                childIndex++;
                j++;
            }
        }
        var k = 0;
        // Get the Z index from ZindexTable in the child's count position. In that position we want to put the swimlane
        for (var i = 0; i < childCount; i++) {
            while (!zIndexTable[parseInt(k.toString(), 10)]) {
                k++;
            }
            tempIndex = this.diagram.nameTable[zIndexTable[parseInt(k.toString(), 10)]].zIndex;
            k++;
        }
        tempIndex = tempIndex + 1;
        // Check if there is a object in the z index table or not
        while (!zIndexTable[parseInt(tempIndex.toString(), 10)]) {
            ++tempIndex;
        }
        k = 0;
        // Place the swimlane at the next position of the swimlane's last children.
        zIndexTable[parseInt(tempIndex.toString(), 10)] = this.diagram.nameTable["" + objectId].id;
        this.diagram.nameTable["" + objectId].zIndex = tempIndex;
        tempIndex = tempIndex + 1;
        // Now swap the intersect nodes at next position of the swimlane.
        for (var i = tempIndex; i <= index; i++) {
            if (zIndexTable[parseInt(i.toString(), 10)]) {
                while (!tempTable[parseInt(k.toString(), 10)]) {
                    k++;
                }
                zIndexTable[parseInt(i.toString(), 10)] = tempTable[parseInt(k.toString(), 10)];
                this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]].zIndex = i;
                k++;
            }
        }
        return tempIndex;
    };
    CommandHandler.prototype.resetTargetNode = function (objectId, target, i, zIndexTable) {
        if (this.diagram.nameTable["" + objectId].shape.type === 'SwimLane'
            && this.diagram.nameTable["" + target].parentId !== undefined && this.diagram.nameTable["" + target].parentId !== '' && this.diagram.nameTable[this.diagram.nameTable["" + target].parentId].isLane) {
            i = i + 1;
            if (zIndexTable[parseInt(i.toString(), 10)]) {
                target = zIndexTable[parseInt(i.toString(), 10)];
                return target = this.resetTargetNode(objectId, target, i, zIndexTable);
            }
            else {
                return target;
            }
        }
        else {
            return target;
        }
    };
    // private getZIndexObjects(): void {
    //     // const element: (NodeModel | ConnectorModel)[] = [];
    //     // let i: number; let j: number;
    //     // for (i = 0; i < this.diagram.nodes.length; i++) {
    //     //     element.push(this.diagram.nodes[parseInt(i.toString(), 10)]);
    //     // }
    //     // for (j = 0; j < this.diagram.connectors.length; j++) {
    //     //     element.push(this.diagram.connectors[parseInt(j.toString(), 10)]);
    //     // }
    //     // this.updateBlazorZIndex(element);
    // }
    // private updateBlazorZIndex(element: (NodeModel | ConnectorModel)[]): void {
    //     // const blazorInterop: string = 'sfBlazor';
    //     // const blazor: string = 'Blazor';
    //     // let diagramobject: object = {};
    //     // const nodeObject: NodeModel[] = [];
    //     // const connectorObject: ConnectorModel[] = [];
    //     // let k: number;
    //     // if (element && element.length > 0) {
    //     //     for (k = 0; k < element.length; k++) {
    //     //         const elementObject: (NodeModel | ConnectorModel) = element[parseInt(k.toString(), 10)];
    //     //         if (elementObject instanceof Node) {
    //     //             nodeObject.push(this.getBlazorObject(elementObject));
    //     //         } else if (elementObject instanceof Connector) {
    //     //             connectorObject.push(this.getBlazorObject(elementObject));
    //     //         }
    //     //     }
    //     // }
    //     // diagramobject = {
    //     //     nodes: nodeObject,
    //     //     connectors: connectorObject
    //     // };
    //     // if (window && window[`${blazor}`]) {
    //     //     const obj: object = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': diagramobject };
    //     //     window[`${blazorInterop}`].updateBlazorProperties(obj, this.diagram);
    //     // }
    // }
    // private getBlazorObject(objectName: (NodeModel | ConnectorModel)): any {
    //     // const object: object = {
    //     //     sfIndex: getIndex(this.diagram, objectName.id),
    //     //     zIndex: objectName.zIndex
    //     // };
    //     // return object;
    // }
    //Checks whether the target is a child node.
    CommandHandler.prototype.checkParentExist = function (target) {
        var objBehind = target;
        while (this.diagram.nameTable["" + objBehind].parentId) {
            objBehind = this.diagram.nameTable["" + objBehind].parentId;
        }
        return objBehind;
    };
    //Checks whether the selected node is not a parent of another node.
    CommandHandler.prototype.checkObjectBehind = function (objectId, zIndexTable, index) {
        // for (let i: number = 0; i < index; i++) {
        //     const z: string = zIndexTable[parseInt(i.toString(), 10)];
        //     if (this.diagram.nameTable[`${z}`] && objectId !== this.diagram.nameTable[`${z}`].parentId) {
        //         return true;
        //     }
        // }
        return true;
    };
    /**
     * bringToFront method\
     *
     * @returns {  void  }    bringToFront method .\
     *  @param {NodeModel | ConnectorModel } obj - Provide the nodeArray element .
     * @private
     */
    CommandHandler.prototype.bringToFront = function (obj) {
        this.diagram.protectPropertyChange(true);
        if (hasSelection(this.diagram) || obj) {
            // EJ2-57772 - Added the below code to iterate all the selected nodes / connectors in the diagram and
            // perform bring to front operation
            var objectName = (obj && obj.id);
            var selectedItems = this.diagram.selectedItems;
            var objects = [];
            if (obj && obj.id) {
                objects.push(obj);
            }
            else {
                objects = objects.concat(selectedItems.nodes);
                objects = objects.concat(selectedItems.connectors);
            }
            var undoObject = cloneObject(this.diagram.selectedItems);
            objects = objects.slice().sort(function (a, b) { return a.zIndex - b.zIndex; });
            for (var i = 0; i < objects.length; i++) {
                var clonedObject = cloneObject(objects[parseInt(i.toString(), 10)]);
                objectName = objects[parseInt(i.toString(), 10)].id;
                var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectName));
                this.updateLayerZindexTable(layerNum);
                var zIndexTable = this.diagram.layers[parseInt(layerNum.toString(), 10)].zIndexTable;
                var layerObjects = this.diagram.layers[parseInt(layerNum.toString(), 10)].objects;
                var maxZindex = null;
                for (var i_4 = 0; i_4 < layerObjects.length; i_4++) {
                    var obj_2 = this.diagram.nameTable[layerObjects[parseInt(i_4.toString(), 10)]];
                    if (maxZindex === null || obj_2.zIndex > maxZindex) {
                        maxZindex = obj_2.zIndex;
                    }
                }
                var tempTable = JSON.parse(JSON.stringify(zIndexTable));
                var tempIndex = 0;
                //find the maximum zIndex of the tabel
                var tabelLength = Number(Object.keys(zIndexTable).sort(function (a, b) { return Number(a) - Number(b); }).reverse()[0]);
                var index = this.diagram.nameTable["" + objectName].zIndex;
                var oldzIndexTable = [];
                var length_1 = 0;
                for (var i_5 = 0; i_5 <= tabelLength; i_5++) {
                    oldzIndexTable.push(zIndexTable[parseInt(i_5.toString(), 10)]);
                }
                var object = this.diagram.nameTable["" + objectName];
                if (object.shape.type === 'SwimLane') {
                    for (var i_6 = tabelLength; i_6 >= index; i_6--) {
                        if (zIndexTable[parseInt(i_6.toString(), 10)]
                            && !(this.diagram.nameTable[zIndexTable[parseInt(i_6.toString(), 10)]].parentId === objectName)) {
                            length_1 = i_6;
                            tabelLength = length_1;
                            break;
                        }
                    }
                }
                var obj_3 = this.diagram.nameTable["" + objectName];
                if (obj_3.zIndex < maxZindex && obj_3.shape.type !== 'SwimLane') {
                    var clonedNode = cloneObject(obj_3);
                    var childMaxZindex = null;
                    if (obj_3.children) {
                        childMaxZindex = this.findMaxZIndex(obj_3);
                        if (childMaxZindex < maxZindex) {
                            obj_3.zIndex = maxZindex + 1;
                            this.updateGroupZindex(obj_3, 'BringToFront', maxZindex);
                        }
                    }
                    else {
                        obj_3.zIndex = maxZindex + 1;
                    }
                    this.triggerOrderCommand(clonedNode, obj_3, obj_3);
                }
                // for (let i: number = index; i < tabelLength; i++) {
                //     //When there are empty records in the zindex table
                //     if (zIndexTable[parseInt(i.toString(), 10)]) {
                //         if (!zIndexTable[i + 1]) {
                //             zIndexTable[i + 1] = zIndexTable[parseInt(i.toString(), 10)];
                //             this.diagram.nameTable[zIndexTable[i + 1]].zIndex = i;
                //             delete zIndexTable[parseInt(i.toString(), 10)];
                //         } else {
                //             //bringing the objects backward
                //             let clonedNode = cloneObject(this.diagram.nameTable[zIndexTable[parseInt((i+1).toString(), 10)]]);
                //             zIndexTable[parseInt(i.toString(), 10)] = zIndexTable[i + 1];
                //             this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]].zIndex = i;
                //             this.triggerOrderCommand(clonedNode, this.diagram.nameTable[zIndexTable[parseInt((i+1).toString(), 10)]], this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]]);
                //         }
                //     }
                // }
                // for (let i: number = index; i < tabelLength; i++) {
                //     if (zIndexTable[parseInt(i.toString(), 10)]) {
                //         this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]].zIndex = i;
                //     }
                // }
                // if (object.shape.type !== 'SwimLane') {
                //     zIndexTable[parseInt(tabelLength.toString(), 10)] = this.diagram.nameTable[`${objectName}`].id;
                //     this.diagram.nameTable[`${objectName}`].zIndex = tabelLength;
                //     this.triggerOrderCommand(clonedObject, objects[parseInt(i.toString(), 10)], objects[parseInt(i.toString(), 10)]);
                // }
                else if (obj_3.shape.type === 'SwimLane') {
                    var childCount = 0;
                    var childIndex = -1;
                    var tempIndex_1 = 0;
                    var laneIndex = 0;
                    var cloneTable = JSON.parse(JSON.stringify(zIndexTable));
                    for (var i_7 = 0; i_7 <= index; i_7++) {
                        if (zIndexTable[parseInt(i_7.toString(), 10)]
                            && this.diagram.nameTable[zIndexTable[parseInt(i_7.toString(), 10)]].parentId === objectName) {
                            if (childIndex === -1) {
                                childIndex = i_7;
                                tempIndex_1 = i_7;
                                break;
                            }
                        }
                    }
                    for (var i_8 = 0; i_8 <= tabelLength; i_8++) {
                        if (tempTable[parseInt(i_8.toString(), 10)] && tempTable[parseInt(i_8.toString(), 10)] !== objectName
                            && this.diagram.nameTable[tempTable[parseInt(i_8.toString(), 10)]].parentId !== objectName) {
                            var node = this.diagram.nameTable[tempTable[parseInt(i_8.toString(), 10)]];
                            var swimlaneObject = this.diagram.nameTable["" + objectName];
                            if (node.zIndex >= swimlaneObject.zIndex) {
                                childCount++;
                            }
                        }
                    }
                    var k = childIndex;
                    for (var i_9 = 0; i_9 <= childCount; i_9++) {
                        while (!zIndexTable[parseInt(k.toString(), 10)]) {
                            k++;
                        }
                        laneIndex = this.diagram.nameTable[zIndexTable[parseInt(k.toString(), 10)]].zIndex;
                        k++;
                    }
                    for (var i_10 = laneIndex; i_10 <= tabelLength; i_10++) {
                        while (!cloneTable[parseInt(childIndex.toString(), 10)]) {
                            childIndex++;
                        }
                        while (!zIndexTable[parseInt(i_10.toString(), 10)]) {
                            i_10++;
                        }
                        zIndexTable[parseInt(i_10.toString(), 10)] = cloneTable[parseInt(childIndex.toString(), 10)];
                        this.diagram.nameTable[zIndexTable[parseInt(i_10.toString(), 10)]].zIndex = i_10;
                        childIndex++;
                    }
                    zIndexTable[parseInt(tabelLength.toString(), 10)] = this.diagram.nameTable["" + objectName].id;
                    this.diagram.nameTable["" + objectName].zIndex = tabelLength;
                    k = index + 1;
                    var j = tempIndex_1;
                    for (var i_11 = 0; i_11 < childCount; i_11++) {
                        while (!tempTable[parseInt(k.toString(), 10)]) {
                            k++;
                        }
                        while (this.diagram.nameTable[tempTable[parseInt(k.toString(), 10)]].parentId === objectName) {
                            k++;
                        }
                        while (!zIndexTable[parseInt(j.toString(), 10)]) {
                            j++;
                        }
                        zIndexTable[parseInt(j.toString(), 10)] = tempTable[parseInt(k.toString(), 10)];
                        this.diagram.nameTable[zIndexTable[parseInt(j.toString(), 10)]].zIndex = j;
                        k++;
                        j++;
                    }
                }
                if (this.diagram.mode === 'SVG') {
                    // const diagramLayer: SVGGElement = this.diagram.diagramLayer as SVGGElement;
                    // //const child: string[] = this.getChildElements(this.diagram.nameTable[objectName].wrapper.children);
                    // //const targerNodes: Object = [];
                    // let element: HTMLElement = getDiagramElement(objectName + '_groupElement', this.diagram.element.id);
                    // const nodes: NodeModel[] = this.diagram.selectedItems.nodes;
                    // if (nodes.length > 0 && (nodes[0].shape.type === 'Native' || nodes[0].shape.type === 'HTML')) {
                    //     element.parentNode.removeChild(element);
                    //     for (let j: number = 0; j < this.diagram.views.length; j++) {
                    //         element = getDiagramElement(
                    //             objectName + (nodes[0].shape.type === 'HTML' ? '_html_element' : '_content_groupElement'),
                    //             this.diagram.views[parseInt(j.toString(), 10)]);
                    //         const lastChildNode: HTMLElement = element.parentNode.lastChild as HTMLElement;
                    //         lastChildNode.parentNode.insertBefore(element, lastChildNode.nextSibling);
                    //     }
                    //     const htmlLayer: HTMLElement = getHTMLLayer(this.diagram.element.id);
                    //     this.diagram.diagramRenderer.renderElement(this.diagram.nameTable[`${objectName}`].wrapper, diagramLayer, htmlLayer);
                    // } else {
                    //     Object.keys(zIndexTable).forEach((key: string) => {
                    //         const zIndexValue: string = zIndexTable[`${key}`];
                    //         if ((zIndexValue !== objectName) && (this.diagram.nameTable[`${zIndexValue}`].parentId) !== objectName) {
                    //             //EJ2-42101 - SendToBack and BringToFront not working for connector with group node
                    //             //Added @Dheepshiva to restrict the objects with lower zIndex
                    //             if (zIndexValue !== undefined &&
                    //                 (oldzIndexTable.indexOf(objectName) < oldzIndexTable.indexOf(zIndexValue))) {
                    //                 const objectNode: Node | Connector = this.diagram.nameTable[`${objectName}`];
                    //                 const zIndexNode: Node | Connector = this.diagram.nameTable[`${zIndexValue}`];
                    //                 if (objectNode.parentId === '' && zIndexNode.parentId === '' && zIndexNode.parentId === undefined
                    //                     && objectNode.parentId !== zIndexNode.id) {
                    //                     this.moveSvgNode(zIndexValue, objectName);
                    //                     this.updateNativeNodeIndex(objectName);
                    //                 } else {
                    //                     if (this.checkGroupNode(objectName, zIndexValue, this.diagram.nameTable)) {
                    //                         this.moveSvgNode(zIndexValue, objectName);
                    //                         this.updateNativeNodeIndex(objectName);
                    //                     }
                    //                 }
                    //             }
                    //         }
                    //     });
                    //     this.updateLayerZindexTable(layerNum);
                    // }
                    var obj_4 = this.diagram.nameTable["" + objectName];
                    var i_12 = obj_4.shape.type !== 'SwimLane' ? maxZindex : tempIndex;
                    // if (i !== tempIndex) {
                    //     i = (obj.children && obj.children.length > 0) ? index : 1;
                    // }
                    var target = zIndexTable[parseInt(i_12.toString(), 10)];
                    // EJ2-49326 - (CR issue fix) An exception raised when send the swimlane back to the normal node.
                    // while (!target && i > index) {
                    //     target = zIndexTable[++i];
                    // }
                    // EJ2-46656 - CR issue fix
                    target = this.resetTargetNode(objectName, target, i_12, zIndexTable);
                    //EJ2-69654 - Send to back command not working when there is single node in layer
                    if (target) {
                        target = this.diagram.nameTable["" + target].parentId ? this.checkParentExist(target) : target;
                        this.moveAfterSvgNode(objectName, target);
                    }
                    var diagramLayer = this.diagram.diagramLayer;
                    var element = getDiagramElement(objectName + '_groupElement', this.diagram.element.id);
                    var nodes = this.diagram.selectedItems.nodes;
                    if (nodes.length > 0 && (nodes[0].shape.type === 'Native' || nodes[0].shape.type === 'HTML')) {
                        element.parentNode.removeChild(element);
                        for (var j = 0; j < this.diagram.views.length; j++) {
                            element = getDiagramElement(objectName + (nodes[0].shape.type === 'HTML' ? '_html_element' : '_content_groupElement'), this.diagram.views[parseInt(j.toString(), 10)]);
                            var lastChildNode = element.parentNode.lastChild;
                            lastChildNode.parentNode.insertBefore(element, lastChildNode.nextSibling);
                        }
                        var htmlLayer = getHTMLLayer(this.diagram.element.id);
                        this.diagram.diagramRenderer.renderElement(this.diagram.nameTable["" + objectName].wrapper, diagramLayer, htmlLayer);
                    }
                    this.updateLayerZindexTable(layerNum);
                }
                else {
                    this.diagram.refreshCanvasLayers();
                    this.updateLayerZindexTable(layerNum);
                }
            }
            var redoObject = cloneObject(this.diagram.selectedItems);
            var entry = { type: 'BringToFront', category: 'Internal', undoObject: undoObject, redoObject: redoObject };
            if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {
                this.addHistoryEntry(entry);
            }
        }
        this.diagram.protectPropertyChange(false);
    };
    // private findGreatestZIndex (parent: Node, layerObjects: string[]): number {
    //     const layerObj: NodeModel[] = this.diagram.nodes.filter((node: any) => layerObjects.indexOf(node.id) !== -1);
    //     // Get zIndex values of nodes excluding children of the parent
    //     const zIndexes: number[] = layerObj.filter((node: any) => node.parentId === '' && node.id !== parent.id).map((node: NodeModel) => (node as Node).zIndex);
    //     // Sort zIndexes in descending order
    //     zIndexes.sort((a: number, b: number) => b - a);
    //     // Find the greatest zIndex excluding children
    //     if (zIndexes.length > 0){
    //         return zIndexes[0];
    //     }
    //     return null;
    // }
    // private findLowestZIndex (parent: Node, layerObjects: string[]): number {
    //     const layerObj: NodeModel[] = this.diagram.nodes.filter((node: any) => layerObjects.indexOf(node.id) !== -1);
    //     // Get zIndex values of nodes excluding children of the parent
    //     const zIndexes: number[] = layerObj.filter((node: any) => node.parentId === '' && node.id !== parent.id).map((node: NodeModel) => (node as Node).zIndex);
    //     // Sort zIndexes in ascending order
    //     zIndexes.sort((a: number, b: number) => a - b);
    //     // Find the lowest zIndex excluding children
    //     if (zIndexes.length > 0){
    //         return zIndexes[0];
    //     }
    //     return null;
    // }
    CommandHandler.prototype.triggerOrderCommand = function (oldObj, newObj, obj) {
        var clonedObject = cloneObject(oldObj);
        // EJ2-61653 - Added below code to get only changed values (zIndex) and passed as an argument to property change event
        var oldValue = {
            zIndex: clonedObject.zIndex
        };
        var newValue = {
            zIndex: newObj.zIndex
        };
        var arg = {
            element: obj, cause: this.diagram.diagramActions, diagramAction: this.diagram.getDiagramAction(this.diagram.diagramActions),
            oldValue: oldValue, newValue: newValue
        };
        this.diagram.triggerEvent(DiagramEvent.propertyChange, arg);
    };
    CommandHandler.prototype.checkGroupNode = function (selectedNodeName, layerObject, nameTable) {
        return nameTable["" + layerObject].parentId === nameTable["" + selectedNodeName].parentId;
    };
    /**
     * sortByZIndex method\
     *
     * @returns {  Object[] }    sortByZIndex method .\
     *  @param { Object[] } nodeArray - Provide the nodeArray element .
     *  @param { string } sortID - Provide the sortID element .
     * @private
     */
    CommandHandler.prototype.sortByZIndex = function (nodeArray, sortID, command) {
        if (command === 'BringForward') {
            var id_1 = sortID ? sortID : 'zIndex';
            nodeArray = nodeArray.sort(function (a, b) {
                return b["" + id_1] - a["" + id_1];
            });
        }
        else {
            var id_2 = sortID ? sortID : 'zIndex';
            nodeArray = nodeArray.sort(function (a, b) {
                return a["" + id_2] - b["" + id_2];
            });
        }
        return nodeArray;
    };
    /**
     * orderCommands method\
     *
     * @returns {  void }    orderCommands method .\
     *  @param { boolean } isRedo - Provide the previousObject element .
     *  @param { Selector } selector - Provide the previousObject element .
     *  @param { EntryType } action - Provide the previousObject element .
     * @private
     */
    CommandHandler.prototype.orderCommands = function (isRedo, selector, action) {
        var _this = this;
        var selectedObject = selector.nodes;
        selectedObject = selectedObject.concat(selector.connectors);
        if (isRedo) {
            var selectedItems = selector.selectedObjects;
            // sort the selected items by zIndex
            selectedItems = selectedItems.slice().sort(function (a, b) { return a.zIndex - b.zIndex; });
            if (action === 'SendBackward') {
                for (var i = 0; i < selectedItems.length; i++) {
                    this.sendBackward(selectedItems[parseInt(i.toString(), 10)]);
                }
            }
            else if (action === 'SendForward') {
                for (var i = selectedItems.length - 1; i >= 0; i--) {
                    this.sendForward(selectedItems[parseInt(i.toString(), 10)]);
                }
            }
            else if (action === 'BringToFront') {
                for (var i = 0; i < selectedItems.length; i++) {
                    this.bringToFront(selectedItems[parseInt(i.toString(), 10)]);
                }
            }
            else if (action === 'SendToBack') {
                for (var i = selectedItems.length - 1; i >= 0; i--) {
                    this.sendToBack(selectedItems[parseInt(i.toString(), 10)]);
                }
            }
        }
        else {
            // Get the first selected object's layer and zIndex information
            var firstObject = selectedObject[0];
            var layer = this.getObjectLayer(firstObject.id);
            var layerIndex = layer.zIndex;
            var zIndexTable = layer.zIndexTable;
            var objectId = void 0;
            // Handle actions for sendBackward or sendToBack
            if (action === 'SendBackward' || action === 'SendToBack') {
                // Sort objects by their zIndex
                selectedObject = selectedObject.slice().sort(function (a, b) { return a.zIndex - b.zIndex; });
                for (var i = 0; i < selectedObject.length; i++) {
                    var undoObject = selectedObject[parseInt(i.toString(), 10)];
                    var node = this.diagram.nameTable[selectedObject[parseInt(i.toString(), 10)].id];
                    node.zIndex = undoObject.zIndex; // Update each object's zIndex in selectedObject
                    this.diagram.layers[parseInt(layerIndex.toString(), 10)].zIndexTable[undoObject.zIndex] = undoObject.id;
                    objectId = undoObject.id;
                    if (action === 'SendToBack') {
                        if (selectedObject[0].shape.type === 'SwimLane') {
                            this.bringToFront(selectedObject[0]);
                        }
                        if (node.children) {
                            this.updateGroupZindex(node, '', null);
                        }
                        this.updateLayerZindexTable(layer.zIndex);
                    }
                    if (this.diagram.mode === 'SVG') {
                        // Get the selected object's layer and zIndex information
                        var object = this.diagram.nameTable["" + objectId];
                        var objectIndex = object.zIndex;
                        var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectId));
                        var layerObjects = this.diagram.layers[parseInt(layerNum.toString(), 10)].objects;
                        var previousZindex = null;
                        var _loop_2 = function (m) {
                            var obj_5 = this_2.diagram.nameTable[layerObjects[parseInt(m.toString(), 10)]];
                            // Check if the current object is not a child of the selected object.
                            var isChildOfSelectedObject = true;
                            selector.selectedObjects.forEach(function (seletedObject) {
                                isChildOfSelectedObject = _this.notChildOfSelectedNode(obj_5, seletedObject);
                            });
                            // Find the previous zIndex
                            if (isChildOfSelectedObject && obj_5.zIndex < objectIndex &&
                                (previousZindex === null || obj_5.zIndex > previousZindex)) {
                                previousZindex = obj_5.zIndex;
                            }
                        };
                        var this_2 = this;
                        for (var m = 0; m < layerObjects.length; m++) {
                            _loop_2(m);
                        }
                        var tempIndex = 0;
                        var obj = this.diagram.nameTable["" + objectId];
                        // Determine the target index for the movement
                        var targetIndex = obj.shape.type !== 'SwimLane' ? previousZindex : tempIndex;
                        var target = void 0;
                        // Find the target using target index
                        if (!isNullOrUndefined(targetIndex)) {
                            target = zIndexTable[parseInt(targetIndex.toString(), 10)];
                        }
                        if (target) {
                            target = this.diagram.nameTable["" + target].parentId ? this.checkParentExist(target) : target;
                            if (action === 'SendBackward') {
                                // eslint-disable-next-line max-len
                                if ((object.parentId && this.notChildOfSelectedNode(object, this.diagram.nameTable["" + target])) || object.parentId === '') {
                                    this.moveAfterSvgNode(objectId, target);
                                }
                            }
                            else if (action === 'SendToBack') {
                                if (selectedObject[0].shape.type !== 'SwimLane') {
                                    this.moveAfterSvgNode(objectId, target);
                                }
                            }
                        }
                    }
                    else {
                        this.diagram.refreshCanvasLayers();
                    }
                }
            }
            // Handle actions for SendForward or BringToFront
            else if (action === 'SendForward' || action === 'BringToFront') {
                // Sort objects by their zIndex
                selectedObject = selectedObject.slice().sort(function (a, b) { return a.zIndex - b.zIndex; });
                for (var i = 0; i < selectedObject.length; i++) {
                    var undoObject = selectedObject[parseInt(i.toString(), 10)];
                    var node = this.diagram.nameTable[selectedObject[parseInt(i.toString(), 10)].id];
                    node.zIndex = undoObject.zIndex;
                    this.diagram.layers[parseInt(layerIndex.toString(), 10)].zIndexTable[undoObject.zIndex] = undoObject.id;
                    objectId = undoObject.id;
                    if (action === 'BringToFront') {
                        if (selectedObject[0].shape.type === 'SwimLane') {
                            this.sendToBack(selectedObject[0]);
                        }
                        if (node.children) {
                            this.updateGroupZindex(node, '', null);
                        }
                        this.updateLayerZindexTable(layer.zIndex);
                    }
                    if (this.diagram.mode === 'SVG') {
                        // Get the selected object's layer and zIndex information
                        var object = this.diagram.nameTable["" + objectId];
                        var objectIndex = object.zIndex;
                        var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectId));
                        var layerObjects = this.diagram.layers[parseInt(layerNum.toString(), 10)].objects;
                        var nextZindex = null;
                        var _loop_3 = function (n) {
                            var obj_6 = this_3.diagram.nameTable[layerObjects[parseInt(n.toString(), 10)]];
                            // Check if the current object is not a child of the selected object.
                            var isChildOfSelectedObject = true;
                            selector.selectedObjects.forEach(function (seletedObject) {
                                isChildOfSelectedObject = _this.notChildOfSelectedNode(obj_6, seletedObject);
                            });
                            var isSelectedObject = selector.selectedObjects.some(function (object) {
                                return object.id === obj_6.id;
                            });
                            // Find the next zIndex
                            if (!isSelectedObject && isChildOfSelectedObject && obj_6.zIndex > objectIndex &&
                                (nextZindex === null || obj_6.zIndex < nextZindex)) {
                                nextZindex = obj_6.zIndex;
                            }
                        };
                        var this_3 = this;
                        for (var n = layerObjects.length - 1; n >= 0; n--) {
                            _loop_3(n);
                        }
                        var tempIndex = 0;
                        var obj = this.diagram.nameTable["" + objectId];
                        // Determine the target index for the movement
                        var targetIndex = obj.shape.type !== 'SwimLane' ? nextZindex : tempIndex;
                        var target = void 0;
                        // Find the target using target index
                        if (!isNullOrUndefined(targetIndex)) {
                            target = zIndexTable[parseInt(targetIndex.toString(), 10)];
                        }
                        if (target) {
                            target = this.diagram.nameTable["" + target].parentId ? this.checkParentExist(target) : target;
                            if (action === 'SendForward') {
                                if (object.parentId === '') {
                                    this.moveSvgNode(objectId, target);
                                }
                            }
                            else if (action === 'BringToFront') {
                                if (selectedObject[0].shape.type !== 'SwimLane') {
                                    this.moveSvgNode(objectId, target);
                                }
                            }
                        }
                    }
                    else {
                        this.diagram.refreshCanvasLayers();
                    }
                }
            }
        }
    };
    // private moveSBObject: (targetId: string) => void = function (targetId: string): void {
    //     if (targetId) {
    //         this.moveBackUndoNode(targetId);
    //     }
    // };
    // //The below method is for undo process for sendBackward command
    // private moveBackUndoNode: (targetId: string) => void = function (targetId: string): void {
    //     const originalZIndexTable: object = {};  // New variable to store original zIndex values
    //     // Store original zIndex values
    //     for (let i: number = 0; i < this.diagram.nodes.length; i++) {
    //         const node1: NodeModel = this.diagram.nodes[parseInt(i.toString(), 10)];
    //         originalZIndexTable[node1.id] = node1.zIndex;
    //     }
    //     for (let j: number = 0; j < this.diagram.connectors.length; j++) {
    //         const connector: ConnectorModel = this.diagram.connectors[parseInt(j.toString(), 10)];
    //         originalZIndexTable[connector.id] = connector.zIndex;
    //     }
    //     const sortedNodeIds: string[] = Object.keys(originalZIndexTable).sort((a: string, b: string) => originalZIndexTable[`${a}`] - originalZIndexTable[`${b}`]);
    //     const currentIndex: number = sortedNodeIds.indexOf(targetId);
    //     //This method moves the node/connector based on their zindex
    //     if (currentIndex !== -1) {
    //         if (currentIndex === sortedNodeIds.length - 1) {
    //             const nextNodeId: string = sortedNodeIds[currentIndex - 1];
    //             this.swapDomOrder(nextNodeId, targetId);
    //         }
    //         else {
    //             const nextNodeId: string = sortedNodeIds[currentIndex + 1];
    //             let backNode: HTMLElement;
    //             if (nextNodeId) {
    //                 const node: NodeModel = this.diagram.getObject(targetId);
    //                 if (node.shape.type === 'Native' || node.shape.type === 'HTML') {
    //                     this.updateNativeNodeIndex(targetId, nextNodeId);
    //                 } else {
    //                     const diagramDiv: HTMLElement = getDiagramElement(targetId + '_groupElement', this.diagram.element.id);
    //                     backNode = getDiagramElement(nextNodeId + '_groupElement', this.diagram.element.id);
    //                     const target: Node = this.diagram.getObject(targetId);
    //                     const newnode: Node = this.diagram.getObject(nextNodeId);
    //                     if (newnode.parentId && newnode.parentId !== target.parentId) {
    //                         backNode = getDiagramElement(newnode.parentId + '_groupElement', this.diagram.element.id);
    //                     }
    //                     if (target.parentId !== newnode.id) {
    //                         diagramDiv.parentNode.insertBefore(diagramDiv, backNode);
    //                     }
    //                 }
    //             }
    //         }
    //     }
    // };
    // private moveFBObject: (targetId: string) => void = function (targetId: string): void {
    //     if (targetId) {
    //         this.moveForwardUndoNode(targetId);
    //     }
    // };
    // //The below method is for undo process for moveForward command
    // private moveForwardUndoNode: (targetID: string) => void = function (targetID: string): void {
    //     const originalZIndexTable: object = {};  // New variable to store original zIndex values
    //     // Store original zIndex values
    //     for (let i: number = 0; i < this.diagram.nodes.length; i++) {
    //         const node1: NodeModel = this.diagram.nodes[parseInt(i.toString(), 10)];
    //         originalZIndexTable[node1.id] = node1.zIndex;
    //     }
    //     for (let j: number = 0; j < this.diagram.connectors.length; j++) {
    //         const connector: ConnectorModel = this.diagram.connectors[parseInt(j.toString(), 10)];
    //         originalZIndexTable[connector.id] = connector.zIndex;
    //     }
    //     const sortedNodeIds: string[] = Object.keys(originalZIndexTable).sort((a: string, b: string) => originalZIndexTable[`${a}`] - originalZIndexTable[`${b}`]);
    //     const currentIndex: number = sortedNodeIds.indexOf(targetID);
    //     //This method moves the node/connector based on their zindex
    //     if (currentIndex !== -1) {
    //         if (currentIndex === sortedNodeIds.length - 1) {
    //             const nextNodeId: string = sortedNodeIds[currentIndex - 1];
    //             this.swapDomOrder(nextNodeId, targetID);
    //         }
    //         else {
    //             const nextNodeId: string = sortedNodeIds[currentIndex + 1];
    //             if (nextNodeId) {
    //                 const node: NodeModel = this.diagram.getObject(targetID);
    //                 if (node.shape.type === 'Native' || node.shape.type === 'HTML') {
    //                     this.updateNativeNodeIndex(targetID, nextNodeId);
    //                 } else {
    //                     const diagramDiv: HTMLElement = getDiagramElement(targetID + '_groupElement', this.diagram.element.id);
    //                     const backNode: HTMLElement = getDiagramElement(nextNodeId + '_groupElement', this.diagram.element.id);
    //                     diagramDiv.parentNode.insertBefore(diagramDiv, backNode);
    //                 }
    //             }
    //         }
    //     }
    // };
    // private swapDomOrder(nextNodeId: string, targetId: string): void {
    //     if (nextNodeId) {
    //         //Bug 921994: Z-index order changes are not reflected at the UI level with Undo Redo commands.
    //         const node: NodeModel = this.diagram.getObject(targetId);
    //         if (node.shape.type === 'Native' || node.shape.type === 'HTML') {
    //             this.updateNativeNodeIndex(targetId, nextNodeId);
    //             this.updateNativeNodeIndex(nextNodeId, targetId);
    //         } else {
    //             const diagramDiv: HTMLElement = getDiagramElement(targetId + '_groupElement', this.diagram.element.id);
    //             const backNode: HTMLElement = getDiagramElement(nextNodeId + '_groupElement', this.diagram.element.id);
    //             diagramDiv.parentNode.insertBefore(diagramDiv, backNode);
    //             diagramDiv.parentNode.insertBefore(backNode, diagramDiv);
    //         }
    //     }
    // }
    // private moveObject(sourceId: string, targetId: string): void {
    //     if (targetId) {
    //         this.moveSvgNode(sourceId, targetId);
    //         this.updateNativeNodeIndex(sourceId, targetId);
    //     }
    // }
    /**
     * sendForward method\
     *
     * @returns {  void }    sendForward method .\
     *  @param {  NodeModel | ConnectorModel } obj - Provide the previousObject element .
     * @private
     */
    CommandHandler.prototype.sendForward = function (obj) {
        var _this = this;
        this.diagram.protectPropertyChange(true);
        if (hasSelection(this.diagram) || obj) {
            var selectedItems = this.diagram.selectedItems;
            var objects = [];
            if (obj && obj.id) {
                objects.push(obj);
            }
            else {
                objects = objects.concat(selectedItems.nodes);
                objects = objects.concat(selectedItems.connectors);
            }
            this.sortByZIndex(objects);
            var nodeId = (obj && obj.id);
            var undoObject_1 = cloneObject(this.diagram.selectedItems);
            this.diagram.startGroupAction();
            var changeNodeZIndexesArray_1 = [];
            var _loop_4 = function (s) {
                var clonedObject = cloneObject(objects[parseInt(s.toString(), 10)]);
                nodeId = objects[parseInt(s.toString(), 10)].id;
                var layerIndex = this_4.diagram.layers.indexOf(this_4.getObjectLayer(nodeId));
                var originalNameTable = cloneObject(this_4.diagram.nameTable);
                var zIndexTable = this_4.diagram.layers[parseInt(layerIndex.toString(), 10)].zIndexTable;
                //const tabelLength: number = Object.keys(zIndexTable).length;
                var index = this_4.diagram.nameTable["" + nodeId];
                var intersectArray = [];
                var temp = this_4.diagram.spatialSearch.findObjects(index.wrapper.bounds);
                if (temp.length > 2) {
                    temp = this_4.sortByZIndex(temp, undefined, 'BringForward');
                }
                var _loop_5 = function (i) {
                    if (index.id !== i.id) {
                        var currentLayer = this_4.getObjectLayer(i.id).zIndex;
                        var isSelectedObject = this_4.diagram.selectedItems.selectedObjects.some(function (object) {
                            return object.id === i.id;
                        });
                        if ((this_4.diagram.selectedItems.selectedObjects || !isSelectedObject) && layerIndex === currentLayer &&
                            (Number(this_4.diagram.nameTable["" + nodeId].zIndex) < Number(i.zIndex)) &&
                            i.parentId === '' && index.wrapper.bounds.intersects(i.wrapper.bounds)) {
                            intersectArray.push(i);
                        }
                    }
                };
                for (var _i = 0, temp_1 = temp; _i < temp_1.length; _i++) {
                    var i = temp_1[_i];
                    _loop_5(i);
                }
                for (var i = intersectArray.length - 1; i >= 0; i--) {
                    var child = this_4.diagram.nameTable[intersectArray[parseInt(i.toString(), 10)].id];
                    if (child.parentId === nodeId) {
                        intersectArray.splice(i, 1);
                    }
                }
                if (intersectArray.length > 0) {
                    var node = this_4.diagram.nameTable[intersectArray[intersectArray.length - 1].id];
                    if (node.parentId) {
                        var parentId = '';
                        var parent_1 = findParentInSwimlane(node, this_4.diagram, parentId);
                        var obj_7 = this_4.diagram.nameTable["" + parent_1];
                        if (obj_7.id !== nodeId) {
                            intersectArray[0] = obj_7;
                        }
                    }
                    var originalZIndexTable = {}; // New variable to store original zIndex values
                    // Store original zIndex values for nodes
                    for (var i = 0; i < this_4.diagram.nodes.length; i++) {
                        var node1 = this_4.diagram.nodes[parseInt(i.toString(), 10)];
                        originalZIndexTable[node1.id] = node1.zIndex;
                    }
                    // Store original zIndex values for connectors
                    for (var j = 0; j < this_4.diagram.connectors.length; j++) {
                        var connector = this_4.diagram.connectors[parseInt(j.toString(), 10)];
                        originalZIndexTable[connector.id] = connector.zIndex;
                    }
                    var overlapObject = intersectArray[0].zIndex;
                    var temp_2 = zIndexTable[parseInt(overlapObject.toString(), 10)];
                    //To store the zindex values as key value pair
                    var zIndex_1 = {};
                    intersectArray.forEach(function (item) {
                        zIndex_1[item.id] = item.zIndex;
                    });
                    // To store the intersecting zindex value
                    var greaterItems_1 = [];
                    if (index) {
                        var tempIndex_2 = index.zIndex;
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-nochec
                        if (Object.keys(zIndex_1).length > 0) {
                            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                            // @ts-ignore
                            Object.values(zIndex_1).forEach(function (val) {
                                if (val >= tempIndex_2) {
                                    greaterItems_1.push(val);
                                }
                            });
                            if (greaterItems_1.length !== 0) {
                                this_4.updateZIndexBySendForward(index, greaterItems_1, layerIndex);
                            }
                        }
                    }
                    var changedNodeZIndexesArray_1 = [];
                    Object.keys(this_4.changedNodeZIndexes).forEach(function (nodeId) {
                        var originalZIndex = originalNameTable["" + nodeId] ? originalNameTable["" + nodeId].zIndex : null;
                        var changedZIndex = _this.changedNodeZIndexes["" + nodeId];
                        //By comparing with changedNodeZIndexes to store the changed elements in undo
                        if (originalZIndex !== changedZIndex) {
                            var node_2 = cloneObject(originalNameTable["" + nodeId]);
                            changedNodeZIndexesArray_1.push(node_2);
                        }
                    });
                    this_4.updateLayerZindexTable(layerIndex);
                    changedNodeZIndexesArray_1.forEach(function (object) {
                        if (!(undoObject_1.nodes.some(function (node) { return node.id === object.id; }))) {
                            var clonedNode = cloneObject(object);
                            undoObject_1.nodes.push(clonedNode);
                        }
                    });
                    if (this_4.diagram.mode === 'SVG') {
                        var nodeIdToUpdate = intersectArray[intersectArray.length - 1].id;
                        // if (element && !(element.shape.type === 'HTML'
                        //     || element.shape.type === 'Native')) {
                        // this.moveForwardSvgNode(nodeId);
                        this_4.moveAfterSvgNode(nodeId, nodeIdToUpdate);
                        // }
                        this_4.updateNativeNodeIndex(nodeIdToUpdate, nodeId);
                    }
                    else {
                        this_4.diagram.refreshCanvasLayers();
                    }
                    Object.keys(this_4.changedNodeZIndexes).forEach(function (nodeId) {
                        var originalZIndex = originalNameTable["" + nodeId] ? originalNameTable["" + nodeId].zIndex : null;
                        var changedZIndex = _this.changedNodeZIndexes["" + nodeId];
                        //By comparing with changedNodeZIndexes to store the changed elements in redo
                        if (originalZIndex !== changedZIndex) {
                            var node_3 = cloneObject(_this.diagram.nameTable["" + nodeId]);
                            changeNodeZIndexesArray_1.push(node_3);
                        }
                    });
                }
            };
            var this_4 = this;
            for (var s = objects.length - 1; s >= 0; s--) {
                _loop_4(s);
            }
            var redoObject_1 = cloneObject(this.diagram.selectedItems);
            changeNodeZIndexesArray_1.forEach(function (object) {
                if (!(redoObject_1.nodes.some(function (node) { return node.id === object.id; }))) {
                    var clonedNode = cloneObject(object);
                    redoObject_1.nodes.push(clonedNode);
                }
            });
            var historyEntry = {
                type: 'SendForward', category: 'Internal',
                undoObject: undoObject_1, redoObject: redoObject_1
            };
            if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {
                this.addHistoryEntry(historyEntry);
            }
            this.diagram.endGroupAction();
        }
        this.diagram.protectPropertyChange(false);
    };
    //This method changes all the zindex values based on the selected node/connector
    CommandHandler.prototype.updateZIndexBySendForward = function (selectedNode, greaterItems, layerNum) {
        var clonedNode = cloneObject(selectedNode);
        var nextHigherIndex = Math.min.apply(Math, greaterItems);
        var objId = this.diagram.layers[parseInt(layerNum.toString(), 10)].
            zIndexTable[parseInt(nextHigherIndex.toString(), 10)];
        if (this.diagram.nameTable["" + objId].children) {
            nextHigherIndex = this.findGreatestChildZIndex(this.diagram.nameTable["" + objId]);
        }
        var highIndex;
        var layerObjects = this.diagram.layers[parseInt(layerNum.toString(), 10)].objects;
        var objects = this.diagram.nodes.filter(function (node) {
            return layerObjects.indexOf(node.id) !== -1;
        });
        var connectors = this.diagram.connectors.filter(function (connector) {
            return layerObjects.indexOf(connector.id) !== -1;
        });
        connectors.forEach(function (connector) {
            objects.push(connector);
        });
        var frontNode = objects.filter(function (x) { return x.zIndex === nextHigherIndex && x.id !== selectedNode.id; });
        if (selectedNode.children) {
            selectedNode.zIndex = nextHigherIndex + 1;
            this.updateGroupZindex(selectedNode, 'BringForward', selectedNode.zIndex);
            highIndex = this.findGreatestChildZIndex(selectedNode);
        }
        else {
            selectedNode.zIndex = nextHigherIndex + 1;
            highIndex = selectedNode.zIndex;
        }
        this.triggerOrderCommand(clonedNode, selectedNode, selectedNode);
        var sortedObjects = objects.slice().sort(function (a, b) { return a.zIndex - b.zIndex; });
        var notChildOfSelectedNode = true;
        for (var i = 0; i < sortedObjects.length; i++) {
            var node = sortedObjects[parseInt(i.toString(), 10)];
            if (selectedNode.children) {
                notChildOfSelectedNode = this.notChildOfSelectedNode(node, selectedNode);
            }
            if (node.zIndex > nextHigherIndex && node !== selectedNode && node.parentId !== selectedNode.id &&
                notChildOfSelectedNode && frontNode && frontNode.length > 0 && node.parentId !== frontNode[0].id) {
                var clonedNode_1 = cloneObject(node);
                if (node.zIndex <= highIndex + 1) {
                    node.zIndex = highIndex + 1;
                    highIndex++;
                    this.triggerOrderCommand(clonedNode_1, node, node);
                }
                else {
                    break;
                }
            }
            var originalZIndex = node.zIndex;
            //changedNodeZIndexes store the zindex values with node id as key value pair
            // eslint-disable-next-line no-prototype-builtins
            if (this.changedNodeZIndexes.hasOwnProperty(node.id)) {
                this.changedNodeZIndexes[node.id] = originalZIndex;
            }
            else {
                this.changedNodeZIndexes[node.id] = originalZIndex;
            }
        }
    };
    // private arrangeZIndexForLowerNodes(index: number, parent: Node, objects: NodeModel[]): void {
    //     const lesserIndexNodes: NodeModel[] = objects.filter((x: NodeModel) => x.zIndex <= index && (x as Node).parentId !== parent.id);
    //     lesserIndexNodes.sort((a: NodeModel, b: NodeModel) => b.zIndex - a.zIndex);
    //     for (let i: number = 0; i < lesserIndexNodes.length; i++){
    //         lesserIndexNodes[parseInt(i.toString(), 10)].zIndex = index - (i + 1);
    //     }
    // }
    CommandHandler.prototype.findGreatestChildZIndex = function (parent) {
        var _this = this;
        var highestZIndex = parent.zIndex;
        var findGreatestZIndex = function (parent) {
            for (var i = 0; i < parent.children.length; i++) {
                var child = _this.diagram.nameTable[parent.children[parseInt(i.toString(), 10)]];
                if (child.children) {
                    findGreatestZIndex(child);
                }
                else {
                    if (child.zIndex > highestZIndex) {
                        highestZIndex = child.zIndex; // Update zIndex for individual children
                    }
                }
            }
        };
        findGreatestZIndex(parent);
        return highestZIndex;
    };
    // check current node is not a children of selected node
    CommandHandler.prototype.notChildOfSelectedNode = function (node, selectedNode) {
        var _this = this;
        var notChildOfSelectedNode = true;
        var isNotChild = function (node, selectedNode) {
            for (var i = 0; i < selectedNode.children.length; i++) {
                var child = _this.diagram.nameTable[selectedNode.children[parseInt(i.toString(), 10)]];
                if (child.id === node.id) {
                    notChildOfSelectedNode = false;
                    return notChildOfSelectedNode;
                }
                if (child.children) {
                    isNotChild(node, child);
                }
            }
            return notChildOfSelectedNode;
        };
        if (selectedNode.children) {
            isNotChild(node, selectedNode);
        }
        return notChildOfSelectedNode;
    };
    // /**
    //  * moveForwardSvgNode method\
    //  *
    //  * @returns { void }    moveForwardSvgNode method .\
    //  * @param {string} targetID - provide the objects value.
    //  * @private
    //  */
    // public moveForwardSvgNode(targetID: string): void {
    //     const sortedNodeIds: string[] = Object.keys(this.changedNodeZIndexes).sort((a: string, b: string) => this.changedNodeZIndexes[`${a}`] - this.changedNodeZIndexes[`${b}`]);
    //     const currentIndex: number = sortedNodeIds.indexOf(targetID);
    //     if (currentIndex !== -1) {
    //         //This logic moves the node/connector based on their zindex
    //         if (currentIndex === sortedNodeIds.length - 1) {
    //             const nextNodeId: string = sortedNodeIds[currentIndex - 1];
    //             if (nextNodeId) {
    //                 const diagramDiv: HTMLElement = getDiagramElement(targetID + '_groupElement', this.diagram.element.id);
    //                 const backNode: HTMLElement = getDiagramElement(nextNodeId + '_groupElement', this.diagram.element.id);
    //                 diagramDiv.parentNode.insertBefore(diagramDiv, backNode);
    //                 diagramDiv.parentNode.insertBefore(backNode, diagramDiv);
    //             }
    //         }
    //         else {
    //             const nextNodeId: string = sortedNodeIds[currentIndex + 1];
    //             if (nextNodeId) {
    //                 const diagramDiv: HTMLElement = getDiagramElement(targetID + '_groupElement', this.diagram.element.id);
    //                 const backNode: HTMLElement = getDiagramElement(nextNodeId + '_groupElement', this.diagram.element.id);
    //                 diagramDiv.parentNode.insertBefore(diagramDiv, backNode);
    //             }
    //         }
    //     }
    // }
    /**
     * sendBackward method\
     *
     * @returns {  void }    sendBackward method .\
     *  @param {  NodeModel | ConnectorModel } obj - Provide the previousObject element .
     * @private
     */
    CommandHandler.prototype.sendBackward = function (obj) {
        var _this = this;
        this.diagram.protectPropertyChange(true);
        if (hasSelection(this.diagram) || obj) {
            var selectedItems = this.diagram.selectedItems;
            var objects = [];
            if (obj && obj.id) {
                objects.push(obj);
            }
            else {
                objects = objects.concat(selectedItems.nodes);
                objects = objects.concat(selectedItems.connectors);
            }
            this.sortByZIndex(objects);
            var objectId = (obj && obj.id);
            var undoObject_2 = cloneObject(this.diagram.selectedItems);
            this.diagram.startGroupAction();
            var changeNodeZIndexesArray_2 = [];
            var _loop_6 = function (s) {
                var clonedObject = cloneObject(objects[parseInt(s.toString(), 10)]);
                objectId = objects[parseInt(s.toString(), 10)].id;
                var layerNum = this_5.diagram.layers.indexOf(this_5.getObjectLayer(objectId));
                var originalNameTable = cloneObject(this_5.diagram.nameTable);
                var zIndexTable = this_5.diagram.layers[parseInt(layerNum.toString(), 10)].zIndexTable;
                //const tabelLength: number = Object.keys(zIndexTable).length;
                var node = this_5.diagram.nameTable["" + objectId];
                var intersectArray = [];
                var temp = this_5.diagram.spatialSearch.findObjects(node.wrapper.bounds);
                if (temp.length > 2) {
                    temp = this_5.sortByZIndex(temp);
                }
                var _loop_7 = function (i) {
                    if (node.id !== i.id) {
                        var currentLayer = this_5.getObjectLayer(i.id).zIndex;
                        var isSelectedObject = this_5.diagram.selectedItems.selectedObjects.some(function (object) {
                            return object.id === i.id;
                        });
                        if ((this_5.diagram.selectedItems.selectedObjects || !isSelectedObject) && layerNum === currentLayer &&
                            (Number(this_5.diagram.nameTable["" + objectId].zIndex) > Number(i.zIndex)) &&
                            i.parentId === '' && node.wrapper.bounds.intersects(i.wrapper.bounds)) {
                            intersectArray.push(i);
                        }
                    }
                };
                for (var _i = 0, temp_3 = temp; _i < temp_3.length; _i++) {
                    var i = temp_3[_i];
                    _loop_7(i);
                }
                for (var i = intersectArray.length - 1; i >= 0; i--) {
                    var child = this_5.diagram.nameTable[intersectArray[parseInt(i.toString(), 10)].id];
                    if (child.parentId === objectId) {
                        intersectArray.splice(i, 1);
                    }
                }
                if (intersectArray.length > 0) {
                    var child = this_5.diagram.nameTable[intersectArray[intersectArray.length - 1].id];
                    if (child.parentId) {
                        var parentId = '';
                        var parent_2 = findParentInSwimlane(child, this_5.diagram, parentId);
                        var obj_8 = this_5.diagram.nameTable["" + parent_2];
                        if (objectId !== obj_8.id) {
                            intersectArray[intersectArray.length - 1] = obj_8;
                        }
                    }
                    var originalZIndexTable = {}; // New variable to store original zIndex values
                    // Store original zIndex values for nodes
                    for (var i = 0; i < this_5.diagram.nodes.length; i++) {
                        var node1 = this_5.diagram.nodes[parseInt(i.toString(), 10)];
                        originalZIndexTable[node1.id] = node1.zIndex;
                    }
                    // Store original zIndex values for connectors
                    for (var j = 0; j < this_5.diagram.connectors.length; j++) {
                        var connector = this_5.diagram.connectors[parseInt(j.toString(), 10)];
                        originalZIndexTable[connector.id] = connector.zIndex;
                    }
                    var overlapObject = intersectArray[intersectArray.length - 1].zIndex;
                    var temp_4 = zIndexTable[parseInt(overlapObject.toString(), 10)];
                    var zIndex_2 = {};
                    intersectArray.forEach(function (item) {
                        zIndex_2[item.id] = item.zIndex;
                    });
                    var lesserItems_1 = [];
                    if (node) {
                        var tempIndex_3 = node.zIndex;
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-nochec
                        if (Object.keys(zIndex_2).length > 0) {
                            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                            // @ts-ignore
                            Object.values(zIndex_2).forEach(function (val) {
                                if (val <= tempIndex_3) {
                                    lesserItems_1.push(val);
                                }
                            });
                            if (lesserItems_1.length !== 0) {
                                this_5.updateZIndexBySendBackward(node, lesserItems_1, layerNum);
                            }
                        }
                    }
                    var changedNodeZIndexesArray_2 = [];
                    Object.keys(this_5.changedNodeZIndexes).forEach(function (nodeId) {
                        var originalZIndex = originalNameTable["" + nodeId] ? originalNameTable["" + nodeId].zIndex : null;
                        var changedZIndex = _this.changedNodeZIndexes["" + nodeId];
                        //By comparing with changedNodeZIndexes to store the changed elements in undo
                        if (originalZIndex !== changedZIndex) {
                            var node_4 = cloneObject(originalNameTable["" + nodeId]);
                            changedNodeZIndexesArray_2.push(node_4);
                        }
                    });
                    this_5.updateLayerZindexTable(layerNum);
                    changedNodeZIndexesArray_2.forEach(function (object) {
                        if (!(undoObject_2.nodes.some(function (node) { return node.id === object.id; }))) {
                            var clonedNode = cloneObject(object);
                            undoObject_2.nodes.push(clonedNode);
                        }
                    });
                    if (this_5.diagram.mode === 'SVG') {
                        var nodeIdToUpdate = intersectArray[intersectArray.length - 1].id;
                        var element = intersectArray[intersectArray.length - 1];
                        if (element && !(element.shape.type === 'HTML'
                            || element.shape.type === 'Native')) {
                            // this.moveBackSvgNode(objectId);
                            this_5.moveSvgNode(objectId, nodeIdToUpdate);
                        }
                        var node_5 = this_5.diagram.nameTable["" + nodeIdToUpdate];
                        if (node_5.children && node_5.children.length > 0) {
                            this_5.updateNativeNodeIndex(objectId);
                        }
                        else {
                            this_5.updateNativeNodeIndex(objectId, nodeIdToUpdate);
                        }
                    }
                    else {
                        this_5.diagram.refreshCanvasLayers();
                    }
                    Object.keys(this_5.changedNodeZIndexes).forEach(function (nodeId) {
                        var originalZIndex = originalNameTable["" + nodeId] ? originalNameTable["" + nodeId].zIndex : null;
                        var changedZIndex = _this.changedNodeZIndexes["" + nodeId];
                        //By comparing with changedNodeZIndexes to store the changed elements in redo
                        if (originalZIndex !== changedZIndex) {
                            var node_6 = cloneObject(_this.diagram.nameTable["" + nodeId]);
                            changeNodeZIndexesArray_2.push(node_6);
                        }
                    });
                }
            };
            var this_5 = this;
            for (var s = 0; s < objects.length; s++) {
                _loop_6(s);
            }
            var redoObject_2 = cloneObject(this.diagram.selectedItems);
            changeNodeZIndexesArray_2.forEach(function (object) {
                if (!(redoObject_2.nodes.some(function (node) { return node.id === object.id; }))) {
                    var clonedNode = cloneObject(object);
                    redoObject_2.nodes.push(clonedNode);
                }
            });
            var entry = { type: 'SendBackward', category: 'Internal', undoObject: undoObject_2, redoObject: redoObject_2 };
            if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {
                this.addHistoryEntry(entry);
            }
            this.diagram.endGroupAction();
        }
        this.diagram.protectPropertyChange(false);
    };
    //This method changes all the zindex values based on the selected node/connector
    CommandHandler.prototype.updateZIndexBySendBackward = function (selectedNode, lesserItems, layerNum) {
        var clonedNode = cloneObject(selectedNode);
        var previousLowerIndex = Math.max.apply(Math, lesserItems);
        var layerObjects = this.diagram.layers[parseInt(layerNum.toString(), 10)].objects;
        var objects = this.diagram.nodes.filter(function (node) {
            return layerObjects.indexOf(node.id) !== -1;
        });
        var connectors = this.diagram.connectors.filter(function (connector) {
            return layerObjects.indexOf(connector.id) !== -1;
        });
        connectors.forEach(function (connector) {
            objects.push(connector);
        });
        var backNode = objects.filter(function (x) { return x.zIndex === previousLowerIndex && x.id !== selectedNode.id; });
        var childMaxZindex;
        var childCount;
        var lowIndex;
        if (selectedNode.children) {
            childMaxZindex = this.findMaxZIndex(selectedNode);
            childCount = childMaxZindex - selectedNode.zIndex;
            selectedNode.zIndex = previousLowerIndex - 1 - childCount;
            this.updateGroupZindex(selectedNode, 'SendBackward', selectedNode.zIndex);
            lowIndex = this.findLowestChildZIndex(selectedNode);
        }
        else {
            selectedNode.zIndex = previousLowerIndex - 1;
            lowIndex = selectedNode.zIndex;
        }
        this.triggerOrderCommand(clonedNode, selectedNode, selectedNode);
        var sortedObjects = objects.slice().sort(function (a, b) { return b.zIndex - a.zIndex; });
        var notChildOfSelectedNode = true;
        for (var i = 0; i < sortedObjects.length; i++) {
            var node = sortedObjects[parseInt(i.toString(), 10)];
            if (selectedNode.children) {
                notChildOfSelectedNode = this.notChildOfSelectedNode(node, selectedNode);
            }
            if (node.zIndex < previousLowerIndex && node !== selectedNode && node.parentId !== selectedNode.id &&
                notChildOfSelectedNode && backNode && backNode.length > 0 && node.parentId !== backNode[0].id) {
                var clonedNode_2 = cloneObject(node);
                if (node.zIndex >= lowIndex - 1) {
                    node.zIndex = lowIndex - 1;
                    lowIndex--;
                    this.triggerOrderCommand(clonedNode_2, node, node);
                }
                else {
                    break;
                }
            }
            var originalZIndex = node.zIndex;
            // eslint-disable-next-line no-prototype-builtins
            if (this.changedNodeZIndexes.hasOwnProperty(node.id)) {
                this.changedNodeZIndexes["" + node.id] = originalZIndex;
            }
            else {
                this.changedNodeZIndexes["" + node.id] = originalZIndex;
            }
        }
    };
    CommandHandler.prototype.findLowestChildZIndex = function (parent) {
        var lowestZIndex = parent.zIndex;
        for (var i = 0; i < parent.children.length; i++) {
            var child = this.diagram.nameTable[parent.children[parseInt(i.toString(), 10)]];
            if (child.zIndex < lowestZIndex) {
                lowestZIndex = child.zIndex;
            }
        }
        return lowestZIndex;
    };
    // /**
    //  * moveBackSvgNode method\
    //  *
    //  * @returns { void }    moveBackSvgNode method .\
    //  * @param {string} targetID - provide the objects value.
    //  * @private
    //  */
    // public moveBackSvgNode(targetID: string): void {
    //     const sortedNodeIds: string[] = Object.keys(this.changedNodeZIndexes).sort((a: string, b: string) => this.changedNodeZIndexes[`${a}`] - this.changedNodeZIndexes[`${b}`]);
    //     const currentIndex: number = sortedNodeIds.indexOf(targetID);
    //     //This logic moves the node/connector based on their zindex
    //     if (currentIndex !== -1) {
    //         const nextNodeId: string = sortedNodeIds[currentIndex + 1];
    //         if (nextNodeId) {
    //             const diagramDiv: HTMLElement = getDiagramElement(targetID + '_groupElement', this.diagram.element.id);
    //             const backNode: HTMLElement = getDiagramElement(nextNodeId + '_groupElement', this.diagram.element.id);
    //             diagramDiv.parentNode.insertBefore(diagramDiv, backNode);
    //         }
    //     }
    // }
    /**
     * updateNativeNodeIndex method\
     *
     * @returns {  void }    updateNativeNodeIndex method .\
     *  @param { string } nodeId - Provide the previousObject element .
     *  @param { string } targetID - Provide the previousObject element .
     * @private
     */
    CommandHandler.prototype.updateNativeNodeIndex = function (nodeId, targetID) {
        var node = this.diagram.selectedItems.nodes[0] || this.diagram.getObject(targetID);
        for (var i = 0; i < this.diagram.views.length; i++) {
            if (node && (node.shape.type === 'HTML'
                || node.shape.type === 'Native')) {
                var id = node.shape.type === 'HTML' ? '_html_element' : '_content_groupElement';
                var backNode = getDiagramElement(nodeId + id, this.diagram.views[parseInt(i.toString(), 10)]);
                var diagramDiv = targetID ? getDiagramElement(targetID + id, this.diagram.views[parseInt(i.toString(), 10)])
                    : backNode.parentElement.firstChild;
                if (backNode && diagramDiv) {
                    if (backNode.parentNode.id === diagramDiv.parentNode.id) {
                        diagramDiv.parentNode.insertBefore(backNode, diagramDiv);
                    }
                }
            }
        }
    };
    /**
     * initSelectorWrapper method\
     *
     * @returns {  void }    initSelectorWrapper method .\
     * @private
     */
    CommandHandler.prototype.initSelectorWrapper = function () {
        var selectorModel = this.diagram.selectedItems;
        selectorModel.init(this.diagram);
        if (selectorModel.nodes.length === 1 && selectorModel.connectors.length === 0) {
            selectorModel.rotateAngle = selectorModel.nodes[0].rotateAngle;
            selectorModel.wrapper.rotateAngle = selectorModel.nodes[0].rotateAngle;
            selectorModel.wrapper.pivot = selectorModel.nodes[0].pivot;
        }
    };
    /**
     * doRubberBandSelection method\
     *
     * @returns {  void }    doRubberBandSelection method .\
     *  @param { Rect } region - Provide the previousObject element .
     * @private
     */
    CommandHandler.prototype.doRubberBandSelection = function (region) {
        this.clearSelectionRectangle();
        var selArray = [];
        var rubberArray = [];
        selArray = this.diagram.getNodesConnectors(selArray);
        if (this.diagram.selectedItems.rubberBandSelectionMode === 'CompleteIntersect') {
            rubberArray = completeRegion(region, selArray);
        }
        else {
            rubberArray = this.diagram.spatialSearch.findObjects(region);
        }
        if (rubberArray.length) {
            this.selectObjects(rubberArray, true);
        }
    };
    CommandHandler.prototype.clearSelectionRectangle = function () {
        var adornerSvg = getAdornerLayerSvg(this.diagram.element.id);
        var element = adornerSvg.getElementById(this.diagram.element.id + '_diagramAdorner_selected_region');
        if (element) {
            remove(element);
        }
    };
    /**
     * dragConnectorEnds method\
     *
     * @returns {  void }    dragConnectorEnds method .\
     *  @param { string } endPoint - Provide the previousObject element .
     *  @param { IElement } obj - Provide the previousObject element .
     *  @param { PointModel } point - Provide the point element .
     *  @param { BezierSegmentModel } segment - Provide the segment element .
     *  @param { IElement } target - Provide the target element .
     *  @param { string } targetPortId - Provide the targetPortId element .
     * @private
     */
    CommandHandler.prototype.dragConnectorEnds = function (endPoint, obj, point, segment, target, targetPortId) {
        var selectorModel;
        var connector; //let node: Node;
        var tx; //let segmentPoint: PointModel;
        var ty; //let index: number;
        var checkBezierThumb = false;
        if (obj instanceof Selector) {
            selectorModel = obj;
            connector = selectorModel.connectors[0];
        }
        else if (obj instanceof Connector && this.diagram.currentDrawingObject) {
            this.clearSelection();
            connector = this.diagram.currentDrawingObject;
        }
        if (endPoint === 'BezierSourceThumb' || endPoint === 'BezierTargetThumb') {
            checkBezierThumb = true;
            connector.isBezierEditing = true;
        }
        if (endPoint === 'ConnectorSourceEnd' || endPoint === 'BezierSourceThumb') {
            tx = point.x - (checkBezierThumb ? segment.bezierPoint1.x : connector.sourcePoint.x);
            ty = point.y - (checkBezierThumb ? segment.bezierPoint1.y : connector.sourcePoint.y);
            return this.dragSourceEnd(connector, tx, ty, null, point, endPoint, undefined, target, targetPortId, undefined, segment);
        }
        else {
            tx = point.x - (checkBezierThumb ? segment.bezierPoint2.x : connector.targetPoint.x);
            ty = point.y - (checkBezierThumb ? segment.bezierPoint2.y : connector.targetPoint.y);
            return this.dragTargetEnd(connector, tx, ty, null, point, endPoint, undefined, segment);
        }
    };
    /**
     * getSelectedObject method\
     *
     * @returns {  void }    getSelectedObject method .\
     * @private
     */
    CommandHandler.prototype.getSelectedObject = function () {
        var selectormodel = this.diagram.selectedItems;
        if (selectormodel.annotation) {
            return [selectormodel.annotation];
        }
        else {
            return (selectormodel.nodes).concat(selectormodel.connectors);
        }
    };
    // /**
    //  * updateBlazorProperties method\
    //  *
    //  * @returns {  void }    updateBlazorProperties method .\
    //  *  @param { boolean } isObjectInteraction - Provide the previousObject element .
    //  * @private
    //  */
    // public updateBlazorProperties(isObjectInteraction?: boolean): void {
    // const blazorInterop: string = 'sfBlazor';
    // const blazor: string = 'Blazor';
    // if (!isObjectInteraction) {
    //     if (window && window[`${blazor}`]) {
    //         const obj: object = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': this.diagramObject };
    //         // window[`${blazorInterop}`].updateBlazorProperties(obj, this.diagram);
    //     }
    // } else {
    //     if (window && window[`${blazor}`] && JSON.stringify(this.deepDiffer.diagramObject) !== '{}') {
    //         const obj: object = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': this.deepDiffer.diagramObject };
    //         if (!this.diagram.isLoading) {
    //             // window[`${blazorInterop}`].updateBlazorProperties(obj, this.diagram);
    //         }
    //     }
    // }
    // //this.diagram.enableServerDataBinding(true);
    // this.deepDiffer.newNodeObject = [];
    // this.deepDiffer.newConnectorObject = [];
    // this.diagramObject = [];
    // this.diagram.oldNodeObjects = [];
    // this.diagram.oldConnectorObjects = [];
    // }
    // /**
    //  * enableCloneObject method\
    //  *
    //  * @returns {  void }    enableCloneObject method .\
    //  *  @param { boolean } value - Provide the previousObject element .
    //  * @private
    //  */
    CommandHandler.prototype.enableCloneObject = function (value) {
        // if ((!this.diagram.lineRoutingModule || !(this.diagram.constraints & DiagramConstraints.LineRouting))) {
        //     this.diagram.canEnableBlazorObject = value;
        // }
    };
    // /**
    //  * ismouseEvents method\
    //  *
    //  * @returns {  void }    ismouseEvents method .\
    //  *  @param { boolean } value - Provide the previousObject element .
    //  * @private
    //  */
    // public ismouseEvents(value: boolean): void {
    //     // if (value) {
    //     //     this.diagram.blazorActions = this.diagram.addConstraints(this.diagram.blazorActions, BlazorAction.interaction);
    //     // } else {
    //     //     this.diagram.blazorActions = this.diagram.removeConstraints(this.diagram.blazorActions, BlazorAction.interaction);
    //     // }
    // }
    // /**
    //  * updateLayerObject method\
    //  *
    //  * @returns {  void }    updateLayerObject method .\
    //  *  @param { object } oldDiagram - Provide the previousObject element .
    //  *  @param { boolean } temp - Provide the temp element .
    //  * @private
    //  */
    // public updateLayerObject(oldDiagram: object, temp?: boolean): void {
    // comment blazor code
    // }
    // /* tslint:enable:no-string-literal */
    // /**
    //  * getDiagramOldValues method\
    //  *
    //  * @returns {  void }    getDiagramOldValues method .\
    //  *  @param { object } oldDiagram - Provide the previousObject element .
    //  *  @param { string[] } attribute - Provide the previousObject element .
    //  * @private
    //  */
    // public getDiagramOldValues(oldDiagram: object, attribute: string[]): void {
    //     const newDiagram: object = {};
    //     for (let i: number = 0; i < attribute.length; i++) {
    //         newDiagram[attribute[parseInt(i.toString(), 10)]] = cloneObject(this.diagram[attribute[parseInt(i.toString(), 10)]]);
    //     }
    //     const newObject: Object = cloneObject(newDiagram);
    //     const result: object = this.deepDiffer.map(newObject, oldDiagram);
    //     const diffValue: object = this.deepDiffer.frameObject({}, result);
    //     let diff: object = this.deepDiffer.removeEmptyValues(diffValue);
    //     diff = this.deepDiffer.changeSegments(diff, newObject);
    //     this.diagramObject = diff;
    //     if (!(this.diagram.blazorActions & BlazorAction.ClearObject)) {
    //         // this.updateBlazorProperties();
    //     }
    // }
    /* tslint:disable */
    /**
     * getBlazorOldValues method\
     *
     * @returns {  void }    getBlazorOldValues method .\
     *  @param { MouseEventArgs } args - Provide the previousObject element .
     *  @param { boolean } labelDrag - Provide the previousObject element .
     * @private
     */
    CommandHandler.prototype.getBlazorOldValues = function (args, labelDrag) {
        //comment blazor code
    };
    // /**
    //  * getObjectChanges method\
    //  *
    //  * @returns {  void }    getObjectChanges method .\
    //  *  @param { Object[] } previousObject - Provide the previousObject element .
    //  *  @param { Object[] } currentObject - Provide the previousObject element .
    //  *  @param { Object[] } previousObject - Provide the previousObject element .
    //  * @private
    //  */
    // public getObjectChanges(previousObject: Object[], currentObject: Object[], changedNodes: Object[]): void {
    // }
    /**
     * clearObjectSelection method\
     *
     * @returns {  void }    clearObjectSelection method .\
     *  @param { (NodeModel | ConnectorModel) } mouseDownElement - Provide the triggerAction element .
     * @private
     */
    // Bug fix - EJ2-44495 -Node does not gets selected on slight movement of mouse when drag constraints disabled for node
    CommandHandler.prototype.clearObjectSelection = function (mouseDownElement) {
        var selectedItems = this.diagram.selectedItems;
        var list = [];
        list = list.concat(selectedItems.nodes, selectedItems.connectors);
        if (list.indexOf(mouseDownElement) === -1) {
            this.clearSelection((list.length > 0) ? true : false);
            this.selectObjects([mouseDownElement], true);
        }
    };
    /**
     * clearSelection method\
     *
     * @returns {  void }    clearSelection method .\
     *  @param { boolean } triggerAction - Provide the triggerAction element .
     *  @param { boolean } isTriggered - Provide the isTriggered element .
     * @private
     */
    CommandHandler.prototype.clearSelection = function (triggerAction, isTriggered) {
        return __awaiter$1(this, void 0, void 0, function () {
            var enableServerDataBinding, selectormodel, arrayNodes, arg;
            return __generator$1(this, function (_a) {
                enableServerDataBinding = this.diagram.allowServerDataBinding;
                this.diagram.enableServerDataBinding(false);
                if (hasSelection(this.diagram)) {
                    selectormodel = this.diagram.selectedItems;
                    arrayNodes = this.getSelectedObject();
                    if (this.diagram.currentSymbol) {
                        this.diagram.previousSelectedObject = arrayNodes;
                    }
                    arg = {
                        oldValue: arrayNodes, newValue: [], cause: this.diagram.diagramActions,
                        state: 'Changing', type: 'Removal', cancel: false
                    };
                    // this.updateBlazorSelectorModel(arrayNodes, true);
                    if (triggerAction) {
                        if (!isBlazor()) {
                            this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);
                        }
                    }
                    if (!arg.cancel) {
                        selectormodel.offsetX = 0;
                        selectormodel.offsetY = 0;
                        selectormodel.width = 0;
                        selectormodel.height = 0;
                        selectormodel.rotateAngle = 0;
                        selectormodel.nodes = [];
                        selectormodel.connectors = [];
                        selectormodel.wrapper = null;
                        selectormodel.annotation = undefined;
                        // EJ2-56919 - While clear selection empty the selectedObjects collection
                        selectormodel.selectedObjects = [];
                        this.diagram.clearSelectorLayer();
                        if (triggerAction) {
                            arg = {
                                oldValue: cloneBlazorObject(arrayNodes), newValue: [], cause: this.diagram.diagramActions,
                                state: 'Changed', type: 'Removal', cancel: false
                            };
                            if (!isBlazor()) {
                                this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);
                            }
                        }
                    }
                    // this.updateBlazorSelector();
                    this.diagram.enableServerDataBinding(enableServerDataBinding);
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * clearSelectedItems method\
     *
     * @returns {  void }    clearSelectedItems method .\
     * @private
     */
    CommandHandler.prototype.clearSelectedItems = function () {
        var selectedNodes = this.diagram.selectedItems.nodes ? this.diagram.selectedItems.nodes.length : 0;
        var selectedConnectors = this.diagram.selectedItems.connectors ? this.diagram.selectedItems.connectors.length : 0;
        this.clearSelection((selectedNodes + selectedConnectors) > 0 ? true : false);
    };
    /**
     * removeStackHighlighter method\
     *
     * @returns {  void }    removeStackHighlighter method .\
     * @private
     */
    CommandHandler.prototype.removeStackHighlighter = function () {
        var adornerSvg = getAdornerLayerSvg(this.diagram.element.id);
        var highlighter = adornerSvg.getElementById(adornerSvg.id + '_stack_highlighter');
        if (highlighter) {
            highlighter.parentNode.removeChild(highlighter);
        }
    };
    /**
     * @param {End} args - provide the args  value.
     * @param {IElement} target - provide the target  value.
     * @private
     */
    CommandHandler.prototype.renderStackHighlighter = function (args, target) {
        var source = this.diagram.selectedItems.nodes[0];
        var symbolDrag;
        var node;
        var selectorModel;
        if (!target) {
            var objects = this.diagram.findObjectsUnderMouse(args.position);
            target = this.diagram.findObjectUnderMouse(objects, 'Drag', true);
            if (target && !(target.isLane || target.isPhase || target.isHeader)) {
                for (var i = 0; i < objects.length; i++) {
                    var laneNode = this.diagram.nameTable[objects[parseInt(i.toString(), 10)].id];
                    if (!laneNode.isLane || laneNode.isPhase || laneNode.isHeader) {
                        target = laneNode;
                        this.diagram.parentObject = target;
                    }
                }
            }
        }
        if (source && target && target.isLane && source.shape && !source.shape.isPhase) {
            node = this.diagram.nameTable[target.parentId];
            if (this.diagram.currentSymbol && node.shape.type === 'SwimLane') {
                symbolDrag = true;
            }
            if ((source && !source.parentId && source.shape.type !== 'SwimLane') ||
                (source && source.parentId && this.diagram.nameTable[source.parentId] && this.diagram.nameTable[source.parentId].isLane &&
                    (source.parentId !== target.parentId && source.parentId !== target.id))) {
                selectorModel = this.diagram.selectedItems;
                var canvas = gridSelection(this.diagram, selectorModel, target.id, true);
                //Bug 904547: Snapping of nodes inside the swimlane is not proper.
                //Instead of assigning the canvas to the selectorModel children, pass them to render selector to highlight the swimlane.
                this.diagram.renderSelector(false, true, canvas);
                selectorModel.wrapper.children[0] = selectorModel.nodes[0].wrapper;
            }
        }
        if (source && target && target.parentId && source.shape && source.shape.isPhase) {
            var node_7 = this.diagram.nameTable[target.parentId];
            if (node_7.shape.type === 'SwimLane') {
                //Bug 904547: Snapping of nodes inside the swimlane is not proper.
                //Instead of assigning the canvas to the selectorModel children, pass them to render selector to highlight the swimlane.
                var canvas = this.diagram.nameTable[target.parentId].wrapper;
                this.diagram.renderSelector(false, true, canvas);
            }
        }
        if ((symbolDrag && this.diagram.currentSymbol.shape.isLane) || (source && target &&
            source.parentId && target.parentId && !source.isPhase && (source.parentId === target.parentId)
            && (source.id !== target.id) && node &&
            (node.container && (node.container.type === 'Stack' || node.container.type === 'Grid')))) {
            var canvas = void 0;
            var value = node.container.orientation === 'Vertical';
            var isVertical = node.container === 'Stack' ? value : !value;
            if (node.container.type === 'Grid' && target.isLane &&
                (((node.shape.orientation === 'Horizontal' && target.rowIndex !== source.rowIndex) ||
                    (node.shape.orientation === 'Vertical' && target.columnIndex !== source.columnIndex))
                    || (this.diagram.currentSymbol &&
                        this.diagram.currentSymbol.shape.orientation === node.container.orientation))) {
                selectorModel = this.diagram.selectedItems;
                if ((source.isLane && canLaneInterchange(source, this.diagram)) || !source.isLane) {
                    canvas = gridSelection(this.diagram, selectorModel, target.id, symbolDrag);
                }
            }
            var wrapper = node.container.type === 'Stack' ? target.wrapper : canvas;
            if (wrapper) {
                renderStackHighlighter(wrapper, isVertical, args.position, this.diagram, false, true);
            }
        }
    };
    /** @private */
    CommandHandler.prototype.insertBlazorConnector = function (obj) {
        if (obj instanceof Selector) {
            for (var i = 0; i < obj.connectors.length; i++) {
                this.diagram.insertBlazorConnector(obj.connectors[parseInt(i.toString(), 10)]);
            }
        }
        else {
            this.diagram.insertBlazorConnector(obj);
        }
    };
    /** @private */
    CommandHandler.prototype.drag = function (obj, tx, ty) {
        var tempNode;
        var elements = [];
        // EJ2-846953: The below code is added to set current action to drag when we drag objects dynamically using method.
        // It is used to prevent the updateGroupSize method call for group node while dragging it.
        if (!this.diagram.rotateUsingButton && obj.shape && obj.shape.type !== 'SwimLane') {
            this.diagram.eventHandler.currentAction = 'Drag';
        }
        if (canMove(obj) && this.checkBoundaryConstraints(tx, ty, obj.wrapper.bounds) && canPageEditable(this.diagram)) {
            if (obj instanceof Node) {
                var oldValues = { offsetX: obj.offsetX, offsetY: obj.offsetY };
                obj.offsetX += tx;
                obj.offsetY += ty;
                if (obj.children && !(obj.container)) {
                    if (!(checkParentAsContainer(this.diagram, obj, true))) {
                        this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.isGroupDragging;
                    }
                    var nodes = this.getAllDescendants(obj, elements);
                    for (var i = 0; i < nodes.length; i++) {
                        tempNode = (this.diagram.nameTable[nodes[parseInt(i.toString(), 10)].id]);
                        this.drag(tempNode, tx, ty);
                    }
                    this.updateInnerParentProperties(obj);
                    this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.isGroupDragging;
                }
                if (checkParentAsContainer(this.diagram, obj, true)) {
                    checkChildNodeInContainer(this.diagram, obj);
                }
                else {
                    if (obj && obj.shape && obj.shape.type === 'UmlClassifier') {
                        obj.wrapper.measureChildren = true;
                    }
                    this.diagram.nodePropertyChange(obj, oldValues, { offsetX: obj.offsetX, offsetY: obj.offsetY }, undefined, undefined, false);
                    obj.wrapper.measureChildren = false;
                }
                if (obj.shape.type === 'SwimLane' && !this.diagram.currentSymbol) {
                    var grid = obj.wrapper.children[0];
                    var connectors = getConnectors(this.diagram, grid);
                    updateConnectorsProperties(connectors, this.diagram);
                }
            }
            else {
                var connector = obj;
                // 909588: Property change new & old value are same upon connector drag
                var oldConnector = cloneObject(obj);
                var oldValues = { sourcePoint: oldConnector.sourcePoint, targetPoint: oldConnector.targetPoint };
                var update = connector.type === 'Bezier' ? true : false;
                var hasEnds = false;
                if (!connector.sourceWrapper) {
                    this.dragSourceEnd(connector, tx, ty, true, null, '', update);
                }
                else {
                    hasEnds = true;
                }
                if (!connector.targetWrapper) {
                    this.dragTargetEnd(connector, tx, ty, true, null, '', update);
                }
                else {
                    hasEnds = true;
                }
                var canDragPoints = false;
                if (obj instanceof Connector) {
                    canDragPoints = true;
                }
                if (!hasEnds || canDragPoints) {
                    this.dragControlPoint(connector, tx, ty, true);
                    var conn = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };
                    this.diagram.connectorPropertyChange(connector, oldValues, conn);
                }
            }
        }
        //886700: undo and redo changes not reflected properly in overview after rotate and resize
        for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {
            var temp = _a[_i];
            // eslint-disable-next-line security/detect-object-injection
            var view = this.diagram.views[temp];
            if (view instanceof Overview) {
                this.diagram.refreshCanvasDiagramLayer(view);
            }
        }
    };
    /**   @private  */
    CommandHandler.prototype.connectorSegmentChange = function (actualObject, existingInnerBounds, isRotate) {
        var tx;
        var ty;
        var segmentChange = true;
        if (existingInnerBounds.equals(existingInnerBounds, actualObject.wrapper.bounds) === false) {
            if (actualObject.outEdges.length > 0) {
                for (var k = 0; k < actualObject.outEdges.length; k++) {
                    var connector = this.diagram.nameTable[actualObject.outEdges[parseInt(k.toString(), 10)]];
                    if (connector.targetID !== '') {
                        segmentChange = this.isSelected(this.diagram.nameTable[connector.targetID]) ? false : true;
                    }
                    else {
                        segmentChange = this.isSelected(this.diagram.nameTable[connector.id]) ? false : true;
                    }
                    if (connector.type === 'Orthogonal' && connector.segments && connector.segments.length > 1) {
                        if (!isRotate) {
                            if (segmentChange) {
                                switch (connector.segments[0].direction) {
                                    case 'Bottom':
                                        tx = actualObject.wrapper.bounds.bottomCenter.x - existingInnerBounds.bottomCenter.x;
                                        ty = actualObject.wrapper.bounds.bottomCenter.y - existingInnerBounds.bottomCenter.y;
                                        break;
                                    case 'Top':
                                        tx = actualObject.wrapper.bounds.topCenter.x - existingInnerBounds.topCenter.x;
                                        ty = actualObject.wrapper.bounds.topCenter.y - existingInnerBounds.topCenter.y;
                                        break;
                                    case 'Left':
                                        tx = actualObject.wrapper.bounds.middleLeft.x - existingInnerBounds.middleLeft.x;
                                        ty = actualObject.wrapper.bounds.middleLeft.y - existingInnerBounds.middleLeft.y;
                                        break;
                                    case 'Right':
                                        tx = actualObject.wrapper.bounds.middleRight.x - existingInnerBounds.middleRight.x;
                                        ty = actualObject.wrapper.bounds.middleRight.y - existingInnerBounds.middleRight.y;
                                        break;
                                }
                                this.dragSourceEnd(connector, tx, ty, true, null, 'ConnectorSourceEnd', undefined, undefined, undefined, (actualObject.parentId &&
                                    (this.diagram.diagramActions & DiagramAction.isGroupDragging)) ? false : true);
                            }
                        }
                        else {
                            var firstSegment = connector.segments[0];
                            var secondSegment = connector.segments[1];
                            var cornerPoints = swapBounds(actualObject.wrapper, actualObject.wrapper.corners, actualObject.wrapper.bounds);
                            var sourcePoint = findPoint(cornerPoints, firstSegment.direction);
                            sourcePoint = getIntersection(connector, connector.sourceWrapper, sourcePoint, { x: connector.sourceWrapper.offsetX, y: connector.sourceWrapper.offsetY }, false);
                            var source = {
                                corners: undefined, point: sourcePoint, margin: undefined, direction: firstSegment.direction
                            };
                            var target = {
                                corners: undefined, point: secondSegment.points[1], margin: undefined, direction: undefined
                            };
                            var intermediatePoints = orthoConnection2Segment(source, target);
                            firstSegment.length = Point.distancePoints(intermediatePoints[0], intermediatePoints[1]);
                            if (secondSegment.direction && secondSegment.length) {
                                secondSegment.length = Point.distancePoints(intermediatePoints[1], intermediatePoints[2]);
                            }
                        }
                    }
                }
            }
        }
    };
    /** @private */
    CommandHandler.prototype.updateEndPoint = function (connector, oldChanges) {
        var conn = {
            sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint,
            sourceID: connector.sourceID ? connector.sourceID : undefined,
            targetID: connector.targetID ? connector.targetID : undefined,
            sourcePortID: connector.sourcePortID ? connector.sourcePortID : undefined,
            targetPortID: connector.targetPortID ? connector.targetPortID : undefined,
            segments: connector.segments ? connector.segments : undefined
        };
        var newValue = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };
        if (connector.sourceID) {
            newValue.sourceID = connector.sourceID;
        }
        if (connector.targetID) {
            newValue.targetID = connector.targetID;
        }
        if (connector.sourcePortID) {
            newValue.sourcePortID = connector.sourcePortID;
        }
        if (connector.targetPortID) {
            newValue.targetPortID = connector.targetPortID;
        }
        if (connector.segments) {
            newValue.segments = connector.segments;
        }
        this.diagram.connectorPropertyChange(connector, oldChanges ? oldChanges : {}, newValue);
        // this.diagram.refreshDiagramLayer();
        this.diagram.updateSelector();
    };
    /**
     * @param obj
     * @param tx
     * @param ty
     * @param preventUpdate
     * @param point
     * @param endPoint
     * @param update
     * @param target
     * @param targetPortId
     * @param isDragSource
     * @param segment
     * @private
     */
    CommandHandler.prototype.dragSourceEnd = function (obj, tx, ty, preventUpdate, point, endPoint, update, target, targetPortId, isDragSource, segment) {
        var connector = this.diagram.nameTable[obj.id];
        var oldChanges = {};
        var checkBoundaryConstraints = this.checkBoundaryConstraints(tx, ty, connector.wrapper.bounds);
        if (canDragSourceEnd(connector) && checkBoundaryConstraints
            && (endPoint !== 'BezierSourceThumb') && canPageEditable(this.diagram)) {
            oldChanges = { sourcePoint: connector.sourcePoint };
            oldChanges = cloneObject(oldChanges);
            connector.sourcePoint.x += tx;
            connector.sourcePoint.y += ty;
            if (endPoint === 'ConnectorSourceEnd' && connector.type === 'Orthogonal') {
                this.changeSegmentLength(connector, target, targetPortId, isDragSource);
            }
            if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default' && connector.shape.flow === 'Sequence') {
                this.updatePathElementOffset(connector);
            }
        }
        if (connector.type === 'Bezier') {
            oldChanges = { sourcePoint: connector.sourcePoint };
            if (segment) {
                this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorSourceEnd' : endPoint, tx, ty, segment, point, !update);
            }
            else {
                for (var i = 0; i < obj.segments.length; i++) {
                    this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorSourceEnd' : endPoint, tx, ty, obj.segments[parseInt(i.toString(), 10)], point, !update);
                }
            }
        }
        if (!preventUpdate) {
            this.updateEndPoint(connector, oldChanges);
        }
        if (!(this.diagram.realActions & RealAction.AnimationClick)) {
            this.diagram.refreshCanvasLayers();
        }
        return checkBoundaryConstraints;
    };
    /**
     * Update Path Element offset
     */
    CommandHandler.prototype.updatePathElementOffset = function (connector) {
        connector.wrapper.children.splice(3, 1);
        var pathElement = new PathElement();
        var anglePoints = connector.intermediatePoints;
        pathElement = updatePathElement(anglePoints, connector);
        connector.wrapper.children.splice(3, 0, pathElement);
    };
    /**
     * Upadte the connector segments when change the source node
     */
    CommandHandler.prototype.changeSegmentLength = function (connector, target, targetPortId, isDragSource) {
        // EJ2-65063 - Added below code to check condition if connector segment length can be changed or not.
        // If inconnect and outconnect removed from node constraints
        var canChangeSegment = target ? this.canConnect(connector, target) : true;
        if (connector.segments && connector.segments[0].direction !== null
            && ((!target && connector.sourceID === '') || isDragSource) && canChangeSegment) {
            var first = connector.segments[0];
            var second = connector.segments[1];
            var node = this.diagram.nameTable[connector.sourceID];
            var secPoint = void 0;
            first.points[0] = connector.sourcePoint;
            if (first.direction === 'Top' || first.direction === 'Bottom') {
                first.points[first.points.length - 1].x = connector.sourcePoint.x;
                second.points[0].y = first.points[first.points.length - 1].y;
            }
            else {
                first.points[first.points.length - 1].y = connector.sourcePoint.y;
                second.points[0].x = first.points[first.points.length - 1].x;
            }
            if (first.direction && (first.length || first.length === 0)) {
                first.length = Point.distancePoints(first.points[0], first.points[first.points.length - 1]);
            }
            if (second.direction && (second.length || second.length === 0)) {
                second.length = Point.distancePoints(first.points[first.points.length - 1], second.points[second.points.length - 1]);
                second.direction = Point.direction(first.points[first.points.length - 1], second.points[second.points.length - 1]);
            }
            if (connector.sourcePortID !== '' && first.length < 10) {
                if (connector.segments.length > 2) {
                    var next = connector.segments[2];
                    var nextDirection = Point.direction(next.points[0], next.points[1]);
                    if (first.direction === getOppositeDirection(nextDirection)) {
                        if (first.direction === 'Right') {
                            next.points[0].x = first.points[first.points.length - 1].x = node.wrapper.corners.middleRight.x + 20;
                        }
                        else if (first.direction === 'Left') {
                            next.points[0].x = first.points[first.points.length - 1].x = node.wrapper.corners.middleLeft.x - 20;
                        }
                        else if (first.direction === 'Top') {
                            next.points[0].y = first.points[first.points.length - 1].y = node.wrapper.corners.topCenter.y - 20;
                        }
                        else {
                            next.points[0].y = first.points[first.points.length - 1].y = node.wrapper.corners.bottomCenter.y + 20;
                        }
                        if (next.direction && next.length) {
                            next.length = Point.distancePoints(next.points[0], next.points[next.points.length - 1]);
                        }
                        first.length = Point.distancePoints(first.points[0], first.points[first.points.length - 1]);
                    }
                    else if (first.direction === nextDirection && next.direction && next.length) {
                        if (first.direction === 'Top' || first.direction === 'Bottom') {
                            next.points[0] = first.points[0];
                            next.points[next.points.length - 1].x = next.points[0].x;
                        }
                        else {
                            next.points[0] = first.points[0];
                            next.points[next.points.length - 1].y = next.points[0].y;
                        }
                        next.length = Point.distancePoints(next.points[0], next.points[next.points.length - 1]);
                        connector.segments.splice(0, 2);
                    }
                    else {
                        first.length = 20;
                    }
                }
                else {
                    first.length = 20;
                }
            }
            else if (first.length < 1) {
                if (connector.sourceID !== '') {
                    if (second.direction === 'Right') {
                        secPoint = node.wrapper.corners.middleRight;
                        second.points[second.points.length - 1].y = secPoint.y;
                    }
                    else if (second.direction === 'Left') {
                        secPoint = node.wrapper.corners.middleLeft;
                        second.points[second.points.length - 1].y = secPoint.y;
                    }
                    else if (second.direction === 'Top') {
                        secPoint = node.wrapper.corners.topCenter;
                        second.points[second.points.length - 1].x = secPoint.x;
                    }
                    else {
                        secPoint = node.wrapper.corners.bottomCenter;
                        second.points[second.points.length - 1].x = secPoint.x;
                    }
                    second.length = Point.distancePoints(secPoint, second.points[second.points.length - 1]);
                    if (connector.segments.length > 2) {
                        var next = connector.segments[2];
                        if (next.direction && next.length) {
                            next.length = Point.distancePoints(second.points[second.points.length - 1], next.points[next.points.length - 1]);
                        }
                    }
                    connector.segments.splice(0, 1);
                }
                else {
                    connector.segments.splice(0, 1);
                }
            }
        }
        else {
            if (target && !targetPortId && connector.sourceID !== target.id &&
                connector.segments && connector.segments[0].direction !== null
                && target && target instanceof Node && canChangeSegment) {
                this.changeSourceEndToNode(connector, target);
            }
            if (target && targetPortId && connector.sourcePortID !== targetPortId &&
                connector.segments && connector.segments[0].direction !== null
                && target && target instanceof Node && canChangeSegment) {
                this.changeSourceEndToPort(connector, target, targetPortId);
            }
        }
    };
    // EJ2-65063 - Added below method to check if target has inConnect or outConnect. If it does not have inconnect and outconnect means then return false
    CommandHandler.prototype.canConnect = function (connector, target) {
        if (canInConnect(target) && canOutConnect(target)) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Change the connector endPoint to port
     */
    CommandHandler.prototype.changeSourceEndToPort = function (connector, target, targetPortId) {
        var port = this.diagram.getWrapper(target.wrapper, targetPortId);
        var point = { x: port.offsetX, y: port.offsetY };
        var direction = getPortDirection(point, cornersPointsBeforeRotation(target.wrapper), target.wrapper.bounds);
        var firstSegment = connector.segments[0];
        var secondSegment = connector.segments[1];
        if (firstSegment.direction !== direction) {
            var segments = [];
            var segValues = {};
            if (firstSegment.direction === getOppositeDirection(direction)) {
                segValues = {};
                var segValues1 = void 0;
                if (direction === 'Top' || direction === 'Bottom') {
                    segValues1 = (direction === 'Top') ? {
                        type: 'Orthogonal', isTerminal: true, direction: direction,
                        length: Math.abs(firstSegment.points[0].y - point.y)
                    } :
                        {
                            type: 'Orthogonal', isTerminal: true, direction: direction,
                            length: Math.abs(point.y - firstSegment.points[0].y)
                        };
                    segValues = (firstSegment.points[0].x > point.x) ?
                        { type: 'Orthogonal', isTerminal: true, direction: 'Right', length: (firstSegment.points[0].x - point.x) } :
                        { type: 'Orthogonal', isTerminal: true, direction: 'Left', length: (point.x - firstSegment.points[0].x) };
                }
                else {
                    segValues1 = (direction === 'Right') ? {
                        type: 'Orthogonal', isTerminal: true, direction: direction,
                        length: Math.abs(firstSegment.points[0].x - point.x)
                    } :
                        {
                            type: 'Orthogonal', isTerminal: true, direction: direction,
                            length: Math.abs(point.x - firstSegment.points[0].x)
                        };
                    segValues = (firstSegment.points[0].y > point.y) ?
                        { type: 'Orthogonal', direction: 'Top', isTerminal: true, length: (firstSegment.points[0].y - point.y) } :
                        { type: 'Orthogonal', direction: 'Bottom', isTerminal: true, length: (point.y - firstSegment.points[0].y) };
                }
                segments.push(new OrthogonalSegment(connector, 'segments', segValues1, true));
                segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));
            }
            else {
                segValues = { type: 'Orthogonal', direction: direction, length: 20, isTerminal: true };
                segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));
            }
            if (firstSegment.direction !== getOppositeDirection(direction)) {
                if (direction === 'Top' || direction === 'Bottom') {
                    firstSegment.points[0].x = point.x;
                    firstSegment.points[0].y = firstSegment.points[firstSegment.points.length - 1].y = (direction === 'Top') ?
                        point.y - 20 : point.y + 20;
                }
                else {
                    firstSegment.points[0].y = point.y;
                    firstSegment.points[0].x = firstSegment.points[firstSegment.points.length - 1].x = (direction === 'Right') ?
                        point.x + 20 : point.x - 20;
                }
                firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);
                secondSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], secondSegment.points[secondSegment.points.length - 1]);
            }
            connector.segments = segments.concat(connector.segments);
        }
        else {
            firstSegment.points[0] = point;
            if (direction === 'Top' || direction === 'Bottom') {
                firstSegment.points[firstSegment.points.length - 1].x = point.x;
            }
            else {
                firstSegment.points[firstSegment.points.length - 1].y = point.y;
            }
            firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);
            secondSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], secondSegment.points[secondSegment.points.length - 1]);
        }
    };
    /**
     * @param connector
     * @param changeTerminal
     * @private
Remove terinal segment in initial
     */
    CommandHandler.prototype.removeTerminalSegment = function (connector, changeTerminal) {
        for (var i = 0; i < connector.segments.length - 2; i++) {
            var segment = connector.segments[0];
            if (segment.isTerminal) {
                if (changeTerminal) {
                    segment.isTerminal = false;
                }
                else {
                    connector.segments.splice(i, 1);
                    i--;
                }
            }
        }
    };
    /**
     * Change the connector endPoint from point to node
     */
    CommandHandler.prototype.changeSourceEndToNode = function (connector, target) {
        this.removeTerminalSegment(connector);
        var sourceWrapper = target.wrapper.children[0].corners;
        var sourcePoint;
        var sourcePoint2;
        var firstSegment = connector.segments[0];
        var nextSegment = connector.segments[1];
        var segments = [];
        if (firstSegment.direction === 'Right' || firstSegment.direction === 'Left') {
            sourcePoint = (firstSegment.direction === 'Left') ? sourceWrapper.middleLeft : sourceWrapper.middleRight;
            if (firstSegment.length > sourceWrapper.width || ((firstSegment.direction === 'Left' &&
                sourcePoint.x >= firstSegment.points[0].x) || (firstSegment.direction === 'Right' &&
                sourcePoint.x <= firstSegment.points[0].x))) {
                firstSegment.points[0].y = firstSegment.points[firstSegment.points.length - 1].y = sourcePoint.y;
                firstSegment.points[0].x = sourcePoint.x;
                firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);
                nextSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], nextSegment.points[nextSegment.points.length - 1]);
            }
            else {
                var direction = void 0;
                if (nextSegment.direction) {
                    direction = nextSegment.direction;
                }
                else {
                    direction = Point.direction(nextSegment.points[0], nextSegment.points[nextSegment.points.length - 1]);
                }
                sourcePoint2 = (direction === 'Bottom') ? sourceWrapper.bottomCenter : sourceWrapper.topCenter;
                if (nextSegment.length && nextSegment.direction) {
                    nextSegment.length =
                        (direction === 'Top') ? firstSegment.points[firstSegment.points.length - 1].y - (sourcePoint2.y + 20) :
                            (sourcePoint2.y + 20) - firstSegment.points[firstSegment.points.length - 1].y;
                }
                firstSegment.length = firstSegment.points[firstSegment.points.length - 1].x - sourcePoint2.x;
                firstSegment.direction = (firstSegment.length > 0) ? 'Right' : 'Left';
                var segValues = { type: 'Orthogonal', direction: direction, length: 20 };
                segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));
                connector.segments = segments.concat(connector.segments);
            }
        }
        else {
            sourcePoint = (firstSegment.direction === 'Bottom') ? sourceWrapper.bottomCenter : sourceWrapper.topCenter;
            if (firstSegment.length > sourceWrapper.height || ((firstSegment.direction === 'Top' &&
                sourcePoint.y >= firstSegment.points[0].y) ||
                (firstSegment.direction === 'Bottom' && sourcePoint.y <= firstSegment.points[0].y))) {
                firstSegment.points[0].x = firstSegment.points[firstSegment.points.length - 1].x = sourcePoint.x;
                firstSegment.points[0].y = sourcePoint.y;
                firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);
                nextSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], nextSegment.points[nextSegment.points.length - 1]);
            }
            else {
                sourcePoint2 = (nextSegment.direction === 'Left') ? sourceWrapper.middleLeft : sourceWrapper.middleRight;
                var direction = void 0;
                if (nextSegment.direction) {
                    direction = nextSegment.direction;
                }
                else {
                    direction = Point.direction(nextSegment.points[0], nextSegment.points[nextSegment.points.length - 1]);
                }
                if (nextSegment.length && nextSegment.direction) {
                    nextSegment.length =
                        (direction === 'Left') ? firstSegment.points[firstSegment.points.length - 1].x - (sourcePoint2.x + 20) :
                            (sourcePoint2.x + 20) - firstSegment.points[firstSegment.points.length - 1].x;
                }
                firstSegment.length = firstSegment.points[firstSegment.points.length - 1].y - sourcePoint2.y;
                firstSegment.direction = (firstSegment.length > 0) ? 'Bottom' : 'Top';
                var segValues = { type: 'Orthogonal', direction: direction, length: 20 };
                segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));
                connector.segments = segments.concat(connector.segments);
            }
        }
    };
    //Translate the bezier points during the interaction
    CommandHandler.prototype.translateBezierPoints = function (connector, value, tx, ty, seg, point, update) {
        var index = (connector.segments.indexOf(seg));
        var segment = connector.segments[parseInt(index.toString(), 10)];
        var prevSegment = index > 0 ? connector.segments[index - 1] : null;
        var startPoint = prevSegment !== null ? prevSegment.point : connector.sourcePoint;
        var endPoint = index === connector.segments.length - 1 ? connector.targetPoint : segment.point;
        if (segment) {
            if (value === 'BezierSourceThumb' && (segment.vector1.angle || segment.vector1.distance)) {
                var oldDistance = segment.vector1.distance;
                var oldAngle = segment.vector1.angle;
                segment.vector1 = {
                    distance: connector.distance(startPoint, point),
                    angle: Point.findAngle(startPoint, point)
                };
                var deltaLength = segment.vector1.distance - oldDistance;
                var deltaAngle = segment.vector1.angle - oldAngle;
                this.translateSubsequentSegment(connector, seg, true, deltaLength, deltaAngle);
            }
            else if (value === 'BezierTargetThumb' && (segment.vector2.angle || segment.vector2.distance)) {
                var oldDistance = segment.vector2.distance;
                var oldAngle = segment.vector2.angle;
                segment.vector2 = {
                    distance: connector.distance(endPoint, point),
                    angle: Point.findAngle(endPoint, point)
                };
                var deltaLength = segment.vector2.distance - oldDistance;
                var deltaAngle = segment.vector2.angle - oldAngle;
                this.translateSubsequentSegment(connector, seg, false, deltaLength, deltaAngle);
            }
            else if ((value === 'ConnectorSourceEnd' && !connector.sourceID || value === 'ConnectorTargetEnd' && !connector.targetID)
                && update && isEmptyVector(segment.vector1) && isEmptyVector(segment.vector2)) {
                if (Point.isEmptyPoint(segment.point1)) {
                    segment.bezierPoint1 = getBezierPoints(connector.sourcePoint, connector.targetPoint);
                }
                if (Point.isEmptyPoint(segment.point2)) {
                    segment.bezierPoint2 = getBezierPoints(connector.targetPoint, connector.sourcePoint);
                }
            }
            else if (value === 'BezierSourceThumb' || (value === 'ConnectorSourceEnd' && !update && isEmptyVector(segment.vector1))) {
                segment.bezierPoint1.x += tx;
                segment.bezierPoint1.y += ty;
                if ((!Point.isEmptyPoint(segment.point1)) || (update)) {
                    segment.point1 = { x: segment.bezierPoint1.x, y: segment.bezierPoint1.y };
                }
                // 927005: Segment next to the target end of the connector always resets
                if ((tx !== 0 || ty !== 0) && (seg.isInternalSegment === true)) {
                    seg.isInternalSegment = false;
                }
            }
            else if (value === 'BezierTargetThumb' || (value === 'ConnectorTargetEnd' && !update && isEmptyVector(segment.vector2))) {
                segment.bezierPoint2.x += tx;
                segment.bezierPoint2.y += ty;
                if ((!Point.isEmptyPoint(segment.point2)) || (update)) {
                    segment.point2 = { x: segment.bezierPoint2.x, y: segment.bezierPoint2.y };
                }
                // 927005: Segment next to the target end of the connector always resets
                if ((tx !== 0 || ty !== 0) && (seg.isInternalSegment === true)) {
                    seg.isInternalSegment = false;
                }
            }
        }
    };
    CommandHandler.prototype.translateSubsequentSegment = function (connector, seg, isSourceEnd, deltaLength, deltaAngle) {
        var index = (connector.segments.indexOf(seg));
        var segment = connector.segments[parseInt(index.toString(), 10)];
        if (!(connector.bezierSettings.smoothness & BezierSmoothness.SymmetricAngle)) {
            deltaAngle = null;
        }
        if (!(connector.bezierSettings.smoothness & BezierSmoothness.SymmetricDistance)) {
            deltaLength = null;
        }
        if (deltaLength == null && deltaAngle == null) {
            return;
        }
        if (isSourceEnd) {
            if (index !== 0) {
                this.updatePreviousBezierSegment(connector, index, deltaLength, deltaAngle);
            }
        }
        else {
            if (index !== connector.segments.length - 1) {
                this.updateNextBezierSegment(connector, index, deltaLength, deltaAngle);
            }
        }
    };
    CommandHandler.prototype.updatePreviousBezierSegment = function (connector, index, deltaLength, deltaAngle) {
        var segment = connector.segments[index - 1];
        var newDistance = segment.vector2.distance + deltaLength;
        var newAngle = (segment.vector2.angle + deltaAngle) % 360;
        if (newAngle < 0) {
            newAngle += 360;
        }
        segment.vector2 = { distance: newDistance, angle: newAngle };
    };
    CommandHandler.prototype.updateNextBezierSegment = function (connector, index, deltaLength, deltaAngle) {
        var segment = connector.segments[index + 1];
        var newDistance = segment.vector1.distance + deltaLength;
        var newAngle = (segment.vector1.angle + deltaAngle) % 360;
        if (newAngle < 0) {
            newAngle += 360;
        }
        segment.vector1 = { distance: newDistance, angle: newAngle };
    };
    /**
     * dragTargetEnd method \
     *
     * @returns { void }     dragTargetEnd method .\
     * @param {ConnectorModel} obj - provide the obj value.
     * @param {number} tx - provide the tx value.
     * @param {number} ty - provide the ty value.
     * @param {boolean} preventUpdate - provide the preventUpdate value.
     * @param {PointModel} point - provide the point value.
     * @param {string} endPoint - provide the endPoint value.
     * @param {boolean} update - provide the update value.
     * @param {OrthogonalSegmentModel | BezierSegmentModel | StraightSegmentModel} segment - provide the segment value.
     *
     * @private
     */
    CommandHandler.prototype.dragTargetEnd = function (obj, tx, ty, preventUpdate, point, endPoint, update, segment) {
        var connector = this.diagram.nameTable[obj.id];
        var oldChanges;
        var boundaryConstraints = this.checkBoundaryConstraints(tx, ty, connector.wrapper.bounds);
        if (canDragTargetEnd(connector) && endPoint !== 'BezierTargetThumb'
            && boundaryConstraints && canPageEditable(this.diagram)) {
            oldChanges = { targetPoint: connector.targetPoint };
            oldChanges = cloneObject(oldChanges);
            connector.targetPoint.x += tx;
            connector.targetPoint.y += ty;
            if (endPoint === 'ConnectorTargetEnd' && connector.type === 'Orthogonal' &&
                connector.segments && connector.segments.length > 0) {
                var prev = connector.segments[connector.segments.length - 2];
                if (prev && connector.segments[connector.segments.length - 1].points.length === 2) {
                    if (prev.direction === 'Left' || prev.direction === 'Right') {
                        prev.points[prev.points.length - 1].x = connector.targetPoint.x;
                    }
                    else {
                        prev.points[prev.points.length - 1].y = connector.targetPoint.y;
                    }
                    prev.length = Point.distancePoints(prev.points[0], prev.points[prev.points.length - 1]);
                    prev.direction = Point.direction(prev.points[0], prev.points[prev.points.length - 1]);
                }
            }
            if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default' && connector.shape.flow === 'Sequence') {
                this.updatePathElementOffset(connector);
            }
        }
        if (connector.type === 'Bezier') {
            oldChanges = { targetPoint: connector.targetPoint };
            if (segment) {
                this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorTargetEnd' : endPoint, tx, ty, segment, point, !update);
            }
            else {
                for (var i = 0; i < obj.segments.length; i++) {
                    this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorTargetEnd' : endPoint, tx, ty, obj.segments[parseInt(i.toString(), 10)], point, !update);
                }
            }
        }
        if (!preventUpdate) {
            this.updateEndPoint(connector, oldChanges);
        }
        if (!(this.diagram.realActions & RealAction.AnimationClick)) {
            this.diagram.refreshCanvasLayers();
        }
        return boundaryConstraints;
    };
    /**
     * dragControlPoint method \
     *
     * @returns { void }     dragControlPoint method .\
     * @param {ConnectorModel} obj - provide the obj value.
     * @param {number} tx - provide the tx value.
     * @param {number} ty - provide the ty value.
     * @param {boolean} preventUpdate - provide the preventUpdate value.
     * @param {number} segmentNumber - provide the segmentNumber value.
     *
     * @private
     */
    CommandHandler.prototype.dragControlPoint = function (obj, tx, ty, preventUpdate, segmentNumber) {
        var connector = this.diagram.nameTable[obj.id];
        if ((connector.type === 'Straight' || connector.type === 'Bezier') && connector.segments.length > 0) {
            if (segmentNumber !== undefined && connector.segments[parseInt(segmentNumber.toString(), 10)]) {
                if (connector.type === 'Bezier') {
                    var seg = connector.segments[parseInt(segmentNumber.toString(), 10)];
                    var isInternalSegment = seg.isInternalSegment;
                    if (!isInternalSegment || connector.bezierSettings === null || connector.bezierSettings.segmentEditOrientation === 'FreeForm') {
                        seg.point.x += tx;
                        seg.point.y += ty;
                    }
                    else {
                        if (seg.orientation === 'Horizontal') {
                            seg.point.x += tx;
                        }
                        else {
                            seg.point.y += ty;
                        }
                        this.updateDirectionalBezierCurve(connector);
                    }
                    if (isInternalSegment) {
                        connector.isBezierEditing = true;
                    }
                }
                else {
                    connector.segments[parseInt(segmentNumber.toString(), 10)].point.x += tx;
                    connector.segments[parseInt(segmentNumber.toString(), 10)].point.y += ty;
                }
            }
            else {
                for (var i = 0; i < connector.segments.length - 1; i++) {
                    connector.segments[parseInt(i.toString(), 10)].point.x += tx;
                    connector.segments[parseInt(i.toString(), 10)].point.y += ty;
                }
            }
            if (!preventUpdate) {
                this.updateEndPoint(connector);
            }
        }
        return true;
    };
    CommandHandler.prototype.updateDirectionalBezierCurve = function (connector) {
        var pts = [];
        pts.push(connector.sourcePoint);
        for (var i = 0; i < connector.segments.length - 1; i++) {
            var seg = connector.segments[parseInt(i.toString(), 10)];
            if (seg.orientation === 'Horizontal') {
                pts.push({ x: seg.point.x, y: pts[pts.length - 1].y });
            }
            else {
                pts.push({ x: pts[pts.length - 1].x, y: seg.point.y });
            }
            if (i === connector.segments.length - 2) {
                if (seg.orientation === 'Horizontal') {
                    pts.push({ x: seg.point.x, y: connector.targetPoint.y });
                }
                else {
                    pts.push({ x: connector.targetPoint.x, y: seg.point.y });
                }
            }
        }
        pts.push(connector.targetPoint);
        var start = pts[0];
        var end = pts[pts.length - 1];
        if (connector.segments.length > 1) {
            var mid1 = pts[1];
            var mid2 = pts[2];
            var center1 = { x: (mid1.x + mid2.x) * 0.5, y: (mid1.y + mid2.y) * 0.5 };
            var segment1 = connector.segments[0];
            segment1.vector1.angle = findAngle(start, mid1);
            segment1.vector1.distance = Point.findLength(start, mid1) * 0.5;
            segment1.vector2.angle = findAngle(center1, mid1);
            segment1.vector2.distance = Point.findLength(center1, mid1) * 0.5;
            segment1.point = center1;
            var segment2 = connector.segments[1];
            segment2.vector1.angle = findAngle(center1, mid2);
            segment2.vector1.distance = Point.findLength(center1, mid2) * 0.5;
            if (connector.segments.length > 2) {
                var mid3 = pts[3];
                var center2 = { x: (mid2.x + mid3.x) * 0.5, y: (mid2.y + mid3.y) * 0.5 };
                segment2.vector2.angle = findAngle(center2, mid2);
                segment2.vector2.distance = Point.findLength(center2, mid2) * 0.5;
                segment2.point = center2;
                var segment3 = connector.segments[2];
                segment3.vector1.angle = findAngle(center2, mid3);
                segment3.vector1.distance = Point.findLength(center2, mid3) * 0.5;
                if (connector.segments.length > 3) {
                    var mid4 = pts[4];
                    var center3 = { x: (mid3.x + mid4.x) * 0.5, y: (mid3.y + mid4.y) * 0.5 };
                    segment3.vector2.angle = findAngle(center3, mid3);
                    segment3.vector2.distance = Point.findLength(center3, mid3) * 0.5;
                    segment3.point = center3;
                    var segment4 = connector.segments[3];
                    segment4.vector1.angle = findAngle(center3, mid4);
                    segment4.vector1.distance = Point.findLength(center3, mid4) * 0.5;
                    segment4.vector2.angle = findAngle(end, mid4);
                    segment4.vector2.distance = Point.findLength(end, mid4) * 0.5;
                }
                else {
                    segment3.vector2.angle = findAngle(end, mid3);
                    segment3.vector2.distance = Point.findLength(end, mid3) * 0.5;
                }
            }
            else {
                segment2.vector2.angle = findAngle(end, mid2);
                segment2.vector2.distance = Point.findLength(end, mid2) * 0.5;
            }
        }
    };
    // /**
    //  * rotatePropertyChnage method \
    //  *
    //  * @returns { void }     rotatePropertyChnage method .\
    //  * @param {number} angle - provide the obj value.
    //  *
    //  * @private
    //  */
    // public rotatePropertyChnage(angle: number): void {
    //     const selectedItems: SelectorModel = this.diagram.selectedItems;
    //     let objects: (NodeModel | ConnectorModel)[] = [];
    //     objects = objects.concat(selectedItems.nodes);
    //     objects = objects.concat(selectedItems.connectors);
    //     const pivotValue: PointModel = { x: selectedItems.offsetX, y: selectedItems.offsetY };
    //     this.rotateObjects(selectedItems, objects, angle - selectedItems.rotateAngle, pivotValue);
    //     selectedItems.wrapper.rotateAngle = selectedItems.rotateAngle = angle;
    //     this.diagram.updateSelector();
    // }
    /**
     * rotateObjects method \
     *
     * @returns { void }     rotateObjects method .\
     * @param {NodeModel | SelectorModel} parent - provide the parent value.
     * @param {(NodeModel | ConnectorModel)[]} objects - provide the objects value.
     * @param {number} angle - provide the angle value.
     * @param {PointModel} pivot - provide the pivot value.
     * @param {boolean} includeParent - provide the includeParent value.
     *
     * @private
     */
    CommandHandler.prototype.rotateObjects = function (parent, objects, angle, pivot, includeParent) {
        pivot = pivot || {};
        var matrix = identityMatrix();
        rotateMatrix(matrix, angle, pivot.x, pivot.y);
        var oldValues;
        for (var _i = 0, objects_2 = objects; _i < objects_2.length; _i++) {
            var obj = objects_2[_i];
            if (obj instanceof Node) {
                if (canRotate(obj) && canPageEditable(this.diagram)) {
                    if (includeParent !== false || parent !== obj) {
                        //918299 - Flip and rotation of the group node now work properly by calculating the wrapper offset instead of the individual offset
                        oldValues = { offsetX: obj.wrapper.offsetX, offsetY: obj.wrapper.offsetY, rotateAngle: obj.rotateAngle };
                        //909137 - Undo Operation Improper After Rotating Node Counterclockwise. Remove the below line and add the angle to same line.
                        obj.rotateAngle = ((obj.rotateAngle + angle) + 360) % 360;
                        var newOffset = transformPointByMatrix(matrix, { x: obj.wrapper.offsetX, y: obj.wrapper.offsetY });
                        obj.offsetX = newOffset.x;
                        obj.offsetY = newOffset.y;
                        //909355: When rotating a node, the old value in the property change event argument is undefined. pass the old valuse as parameter
                        this.diagram.nodePropertyChange(obj, oldValues, { offsetX: obj.offsetX, offsetY: obj.offsetY, rotateAngle: obj.rotateAngle });
                    }
                    if (obj.processId) {
                        var parent_3 = this.diagram.nameTable[obj.processId];
                        var bound = this.diagram.bpmnModule.getChildrenBound(parent_3, obj.id, this.diagram);
                        this.diagram.bpmnModule.updateSubProcessess(bound, obj, this.diagram);
                    }
                    if (obj.children && obj.children.length && !obj.container) {
                        this.getChildren(obj, objects);
                    }
                }
            }
            else {
                this.rotatePoints(obj, angle, pivot || { x: obj.wrapper.offsetX, y: obj.wrapper.offsetY });
            }
            this.diagram.updateDiagramObject(obj);
        }
        this.diagram.refreshCanvasLayers();
        this.diagram.updateSelector();
    };
    /**
     * snapConnectorEnd method \
     *
     * @returns { PointModel }     snapConnectorEnd method .\
     * @param {PointModel} currentPosition - provide the parent value.
     *
     * @private
     */
    CommandHandler.prototype.snapConnectorEnd = function (currentPosition) {
        if ((this.diagram.snapSettings.constraints & SnapConstraints.SnapToLines)
            && this.snappingModule) {
            this.diagram.snappingModule.snapConnectorEnd(currentPosition);
        }
        return currentPosition;
    };
    /**
     * snapAngle method \
     *
     * @returns { number }     snapAngle method .\
     * @param {number} angle - provide the parent value.
     *
     * @private
     */
    CommandHandler.prototype.snapAngle = function (angle) {
        if ((this.diagram.snapSettings.constraints & SnapConstraints.SnapToLines)
            && this.snappingModule) {
            return this.snappingModule.snapAngle(this.diagram, angle);
        }
        else {
            return 0;
        }
    };
    /**
     * rotatePoints method \
     *
     * @returns { number }     rotatePoints method .\
     * @param {Connector} conn - provide the parent value.
     * @param {number} angle - provide the parent value.
     * @param {PointModel} pivot - provide the parent value.
     *
     * @private
     */
    CommandHandler.prototype.rotatePoints = function (conn, angle, pivot) {
        if (!conn.sourceWrapper || !conn.targetWrapper) {
            var matrix = identityMatrix();
            rotateMatrix(matrix, angle, pivot.x, pivot.y);
            conn.sourcePoint = transformPointByMatrix(matrix, conn.sourcePoint);
            conn.targetPoint = transformPointByMatrix(matrix, conn.targetPoint);
            if (conn.shape.type === 'Bpmn' && conn.shape.sequence === 'Default' && conn.shape.flow === 'Sequence') {
                this.updatePathElementOffset(conn);
            }
            var newProp = { sourcePoint: conn.sourcePoint, targetPoint: conn.targetPoint };
            this.diagram.connectorPropertyChange(conn, {}, newProp);
            if (conn.segments && conn.segments.length > 0) {
                this.diagram.protectPropertyChange(true);
                var connector = conn;
                connector.segments = [];
                this.diagram.connectorPropertyChange(connector, {}, { segments: connector.segments });
                this.diagram.protectPropertyChange(false);
            }
        }
    };
    CommandHandler.prototype.updateInnerParentProperties = function (tempNode) {
        var elements = [];
        var protect = 'isProtectedOnChange';
        var protectChange = this.diagram["" + protect];
        this.diagram.protectPropertyChange(true);
        var innerParents = this.getAllDescendants(tempNode, elements, false, true);
        for (var i = 0; i < innerParents.length; i++) {
            var obj = this.diagram.nameTable[innerParents[parseInt(i.toString(), 10)].id];
            obj.offsetX = obj.wrapper.offsetX;
            obj.offsetY = obj.wrapper.offsetY;
            obj.width = obj.wrapper.width;
            obj.height = obj.wrapper.height;
        }
        this.diagram.protectPropertyChange(protectChange);
    };
    /**
     * scale method \
     *
     * @returns { boolean }     scale method .\
     * @param {NodeModel | ConnectorModel} obj - provide the parent value.
     * @param {number} sw - provide the parent value.
     * @param {number} sh - provide the parent value.
     * @param {number} pivot - provide the parent value.
     * @param {number} refObject - provide the parent value.
     * @param {boolean} isOutsideBoundary - provide the parent value.
     *
     * @private
     */
    // eslint-disable-next-line max-len
    CommandHandler.prototype.scale = function (obj, sw, sh, pivot, refObject, isOutsideBoundary) {
        var node = this.diagram.nameTable[obj.id];
        var tempNode = node;
        var elements = [];
        var element = node.wrapper;
        if (!refObject) {
            refObject = obj;
        }
        var refWrapper = refObject.wrapper;
        var x = refWrapper.offsetX - refWrapper.actualSize.width * refWrapper.pivot.x;
        var y = refWrapper.offsetY - refWrapper.actualSize.height * refWrapper.pivot.y;
        var refPoint = getPoint(x, y, refWrapper.actualSize.width, refWrapper.actualSize.height, refWrapper.rotateAngle, refWrapper.offsetX, refWrapper.offsetY, pivot);
        if (element.actualSize.width !== undefined && element.actualSize.height !== undefined && canPageEditable(this.diagram)) {
            if (tempNode.children && !(tempNode.container)) {
                var nodes = this.getAllDescendants(tempNode, elements);
                for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                    var temp = nodes_1[_i];
                    this.scaleObject(sw, sh, refPoint, temp, element, refObject);
                }
                obj.wrapper.measure(new Size());
                obj.wrapper.arrange(obj.wrapper.desiredSize);
                this.diagram.updateGroupOffset(node);
                this.updateInnerParentProperties(tempNode);
            }
            else {
                this.scaleObject(sw, sh, refPoint, node, element, refObject);
            }
            var bounds = getBounds(obj.wrapper);
            var checkBoundaryConstraints = this.checkBoundaryConstraints(undefined, undefined, bounds);
            if (!checkBoundaryConstraints && isOutsideBoundary) {
                this.scale(obj, 1 / sw, 1 / sh, pivot, undefined, true);
                return false;
            }
            this.diagram.updateDiagramObject(obj);
        }
        return true;
    };
    /** @private */
    CommandHandler.prototype.getAllDescendants = function (node, nodes, includeParent, innerParent) {
        var temp = node;
        var parentNodes = [];
        for (var i = 0; i < temp.children.length; i++) {
            node = (this.diagram.nameTable[temp.children[parseInt(i.toString(), 10)]]);
            if (node) {
                if (!node.children) {
                    nodes.push(node);
                }
                else {
                    if (includeParent) {
                        nodes.push(node);
                    }
                    if (innerParent) {
                        parentNodes.push(node);
                    }
                    nodes = this.getAllDescendants(node, nodes);
                }
            }
        }
        return (innerParent) ? parentNodes : nodes;
    };
    /**
     * getChildren method \
     *
     * @returns { (NodeModel | ConnectorModel)[]): (NodeModel | ConnectorModel)[] }     getChildren method .\
     * @param {NodeModel} node - provide the sw value.
     * @param {(NodeModel | ConnectorModel)[]} nodes - provide the sw value.
     *
     * @private
     */
    CommandHandler.prototype.getChildren = function (node, nodes) {
        var temp = node;
        if (node.children && node.children.length) {
            for (var i = 0; i < temp.children.length; i++) {
                node = (this.diagram.nameTable[temp.children[parseInt(i.toString(), 10)]]);
                if (node) {
                    nodes.push(node);
                }
            }
        }
        return nodes;
    };
    /**
     * scaleObject method \
     *
     * @returns { NodeModel }     scaleObject method .\
     * @param {string} id - provide the sw value.
     *
     * @private
     */
    CommandHandler.prototype.cloneChild = function (id) {
        var node = this.diagram.nameTable["" + id];
        return node;
    };
    /**
     * scaleObject method \
     *
     * @returns { void }     scaleObject method .\
     * @param {End} sw - provide the sw value.
     * @param {End} sh - provide the sh value.
     * @param {PointModel} pivot - provide the pivot value.
     * @param {IElement} obj - provide the pivot value.
     * @param {DiagramElement} element - provide the element value.
     * @param {IElement} refObject - provide the refObject value.
     *
     * @private
     */
    CommandHandler.prototype.scaleObject = function (sw, sh, pivot, obj, element, refObject, canUpdate) {
        sw = sw < 0 ? 1 : sw;
        sh = sh < 0 ? 1 : sh;
        var oldValues = {};
        if (sw !== 1 || sh !== 1) {
            var width = void 0;
            var height = void 0;
            if (obj instanceof Node) {
                var node = obj;
                var isResize = void 0;
                var bound = void 0;
                oldValues = {
                    width: obj.wrapper.actualSize.width, height: obj.wrapper.actualSize.height,
                    offsetX: obj.wrapper.offsetX, offsetY: obj.wrapper.offsetY,
                    margin: { top: node.margin.top, left: node.margin.left }
                };
                if (node.shape.type === 'Bpmn' && node.shape.activity.subProcess.processes
                    && node.shape.activity.subProcess.processes.length > 0) {
                    bound = this.diagram.bpmnModule.getChildrenBound(node, node.id, this.diagram);
                    isResize = node.wrapper.bounds.containsRect(bound);
                }
                width = node.wrapper.actualSize.width * sw;
                height = node.wrapper.actualSize.height * sh;
                var hasAspectRatio = (node.constraints & NodeConstraints.AspectRatio) === NodeConstraints.AspectRatio;
                var hasMinWidth = node.minWidth !== undefined && node.minWidth !== 0;
                var hasMaxWidth = node.maxWidth !== undefined && node.maxWidth !== 0;
                var hasMinHeight = node.minHeight !== undefined && node.minHeight !== 0;
                var hasMaxHeight = node.maxHeight !== undefined && node.maxHeight !== 0;
                if (hasAspectRatio) {
                    var actualSize = node.wrapper.actualSize;
                    if (hasMinWidth && hasMinHeight) {
                        if ((height / node.minHeight) < (width / node.minWidth)) {
                            if (height < node.minHeight) {
                                height = node.minHeight;
                                width = node.minHeight * (actualSize.width / actualSize.height);
                            }
                        }
                        else {
                            if (width < node.minWidth) {
                                width = node.minWidth;
                                height = node.minWidth * (actualSize.height / actualSize.width);
                            }
                        }
                    }
                    else if (hasMinWidth) {
                        if (width < node.minWidth) {
                            width = node.minWidth;
                            height = node.minWidth * (actualSize.height / actualSize.width);
                        }
                    }
                    else if (hasMinHeight) {
                        if (height < node.minHeight) {
                            height = node.minHeight;
                            width = node.minHeight * (actualSize.width / actualSize.height);
                        }
                    }
                    if (hasMaxWidth && hasMaxHeight) {
                        if ((height / node.maxHeight) > (width / node.maxWidth)) {
                            if (height > node.maxHeight) {
                                height = node.maxHeight;
                                width = node.maxHeight * (actualSize.width / actualSize.height);
                            }
                        }
                        else {
                            if (width > node.maxWidth) {
                                width = node.maxWidth;
                                height = node.maxWidth * (actualSize.height / actualSize.width);
                            }
                        }
                    }
                    else if (hasMaxWidth) {
                        if (width > node.maxWidth) {
                            width = node.maxWidth;
                            height = node.maxWidth * (actualSize.height / actualSize.width);
                        }
                    }
                    else if (hasMaxHeight) {
                        if (height > node.maxHeight) {
                            height = node.maxHeight;
                            width = node.maxHeight * (actualSize.width / actualSize.height);
                        }
                    }
                }
                else {
                    if (hasMaxWidth) {
                        width = Math.min(node.maxWidth, width);
                    }
                    if (hasMinWidth) {
                        width = Math.max(node.minWidth, width);
                    }
                    if (hasMinHeight) {
                        height = Math.max(node.minHeight, height);
                    }
                    if (hasMaxHeight) {
                        height = Math.min(node.maxHeight, height);
                    }
                }
                if (isResize) {
                    width = Math.max(width, (bound.right - node.wrapper.bounds.x));
                    height = Math.max(height, (bound.bottom - node.wrapper.bounds.y));
                }
                sw = width / node.actualSize.width;
                sh = height / node.actualSize.height;
            }
            var matrix = identityMatrix(); // let refWrapper: DiagramElement;
            if (!refObject) {
                refObject = obj;
            }
            var refWrapper = refObject.wrapper;
            rotateMatrix(matrix, -refWrapper.rotateAngle, pivot.x, pivot.y);
            scaleMatrix(matrix, sw, sh, pivot.x, pivot.y);
            rotateMatrix(matrix, refWrapper.rotateAngle, pivot.x, pivot.y);
            if (obj instanceof Node) {
                var node = obj; //let left: number; let top: number;
                var newPosition = transformPointByMatrix(matrix, { x: node.wrapper.offsetX, y: node.wrapper.offsetY });
                var oldleft = node.wrapper.offsetX - node.wrapper.actualSize.width * node.pivot.x;
                var oldtop = node.wrapper.offsetY - node.wrapper.actualSize.height * node.pivot.y;
                if (width > 0) {
                    if (node.processId) {
                        var parent_4 = this.diagram.nameTable[node.processId];
                        if (!parent_4.maxWidth || ((node.margin.left + width) < parent_4.maxWidth)) {
                            node.width = width;
                            node.offsetX = newPosition.x;
                        }
                    }
                    else {
                        node.width = width;
                        node.offsetX = newPosition.x;
                    }
                }
                if (height > 0) {
                    if (node.processId) {
                        var parent_5 = this.diagram.nameTable[node.processId];
                        if (!parent_5.maxHeight || ((node.margin.top + height) < parent_5.maxHeight)) {
                            node.height = height;
                            node.offsetY = newPosition.y;
                        }
                    }
                    else {
                        node.height = height;
                        node.offsetY = newPosition.y;
                    }
                }
                var left = node.wrapper.offsetX - node.wrapper.actualSize.width * node.pivot.x;
                var top_1 = node.wrapper.offsetY - node.wrapper.actualSize.height * node.pivot.y;
                var parent_6 = this.diagram.nameTable[node.processId];
                // 931096: In subprocess, BPMN shape nodes positions changed after undo and redo
                if (parent_6) {
                    left = node.offsetX - node.width * node.pivot.x;
                    top_1 = node.offsetY - node.height * node.pivot.y;
                }
                if (parent_6 && ((node.margin.top + (top_1 - oldtop)) <= 0 ||
                    (node.margin.left + (left - oldleft) <= 0))) {
                    if (this.diagram.eventHandler.currentAction !== 'Drag') {
                        this.diagram.nodePropertyChange(obj, {}, {
                            margin: { top: node.margin.top, left: node.margin.left }
                        });
                    }
                    else {
                        this.diagram.nodePropertyChange(obj, {}, {
                            width: node.width, height: node.height, margin: { top: node.margin.top, left: node.margin.left }
                        });
                    }
                }
                else {
                    if (checkParentAsContainer(this.diagram, obj, true)) {
                        checkChildNodeInContainer(this.diagram, obj);
                    }
                    else {
                        if (!canUpdate) {
                            this.diagram.nodePropertyChange(obj, oldValues, {
                                width: node.width, height: node.height, offsetX: node.offsetX, offsetY: node.offsetY,
                                margin: { top: node.margin.top + (top_1 - oldtop), left: node.margin.left + (left - oldleft) }
                            });
                        }
                    }
                }
            }
            else {
                var connector = obj;
                var oldValues_1 = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };
                if (!connector.sourceWrapper || !connector.targetWrapper) {
                    this.scaleConnector(connector, matrix, oldValues_1, sw, sh, pivot);
                }
            }
            var parentNode = this.diagram.nameTable[obj.processId];
            if (parentNode) {
                var parent_7 = parentNode.wrapper.bounds;
                var child = obj.wrapper.bounds;
                var bound = this.diagram.bpmnModule.getChildrenBound(parentNode, obj.id, this.diagram);
                this.diagram.bpmnModule.updateSubProcessess(bound, obj, this.diagram);
            }
        }
    };
    CommandHandler.prototype.scaleConnector = function (connector, matrix, oldValues, sw, sh, pivot) {
        connector.sourcePoint = transformPointByMatrix(matrix, connector.sourcePoint);
        connector.targetPoint = transformPointByMatrix(matrix, connector.targetPoint);
        if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default' && connector.shape.flow === 'Sequence') {
            this.updatePathElementOffset(connector);
        }
        var newProp = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };
        this.diagram.connectorPropertyChange(connector, oldValues, newProp);
        var selector = this.diagram.selectedItems;
        if (selectionHasConnector(this.diagram, selector)) {
            var clonedSelectedItems = cloneObject(this.diagram.selectedItems);
            var nodeModel = {
                offsetX: clonedSelectedItems.offsetX, offsetY: clonedSelectedItems.offsetY,
                height: clonedSelectedItems.height, width: clonedSelectedItems.width,
                rotateAngle: clonedSelectedItems.rotateAngle
            };
            var obj = new Node(this.diagram, 'nodes', nodeModel, true);
            obj.wrapper = clonedSelectedItems.wrapper;
            obj.wrapper.rotateAngle = selector.rotateAngle;
            this.scaleObject(sw, sh, pivot, obj, obj.wrapper, obj, true);
            selector.wrapper.actualSize.width = obj.width;
            selector.wrapper.actualSize.height = obj.height;
            selector.wrapper.offsetX = obj.offsetX;
            selector.wrapper.offsetY = obj.offsetY;
            var child = this.diagram.selectedItems.connectors[0];
            if (child.id !== connector.id) {
                this.measureSelector(selector);
            }
        }
    };
    CommandHandler.prototype.measureSelector = function (selector) {
        var desiredBounds = undefined;
        //Measuring the children
        var clonedSelectedItems = cloneObject(this.diagram.selectedItems);
        var objects = [];
        var bounds;
        objects = clonedSelectedItems.connectors;
        var pivot = { x: this.diagram.selectedItems.offsetX, y: this.diagram.selectedItems.offsetY };
        for (var i = 0; i < objects.length; i++) {
            var matrix_1 = identityMatrix();
            rotateMatrix(matrix_1, -selector.rotateAngle, pivot.x, pivot.y);
            objects[parseInt(i.toString(), 10)].sourcePoint
                = transformPointByMatrix(matrix_1, objects[parseInt(i.toString(), 10)].sourcePoint);
            objects[parseInt(i.toString(), 10)].targetPoint
                = transformPointByMatrix(matrix_1, objects[parseInt(i.toString(), 10)].targetPoint);
            var p1 = {
                x: objects[parseInt(i.toString(), 10)].sourcePoint.x,
                y: objects[parseInt(i.toString(), 10)].sourcePoint.y
            };
            var p2 = {
                x: objects[parseInt(i.toString(), 10)].targetPoint.x,
                y: objects[parseInt(i.toString(), 10)].targetPoint.y
            };
            bounds = (this.calculateBounds(p1, p2));
            if (desiredBounds === undefined) {
                desiredBounds = bounds;
            }
            else {
                desiredBounds.uniteRect(bounds);
            }
        }
        var offsetPt = {};
        if (desiredBounds !== undefined) {
            offsetPt = {
                x: desiredBounds.x + desiredBounds.width * selector.wrapper.pivot.x,
                y: desiredBounds.y + desiredBounds.height * selector.wrapper.pivot.y
            };
        }
        var nodeModel = {
            offsetX: offsetPt.x, offsetY: offsetPt.y,
            height: desiredBounds.height, width: desiredBounds.width, rotateAngle: 0
        };
        var obj = new Node(this.diagram, 'nodes', nodeModel, true);
        var matrix = identityMatrix();
        rotateMatrix(matrix, selector.rotateAngle, pivot.x, pivot.y);
        obj.rotateAngle += selector.rotateAngle;
        obj.rotateAngle = (obj.rotateAngle + 360) % 360;
        var newOffset = transformPointByMatrix(matrix, { x: obj.offsetX, y: obj.offsetY });
        obj.offsetX = newOffset.x;
        obj.offsetY = newOffset.y;
        selector.wrapper.actualSize.width = desiredBounds.width;
        selector.wrapper.actualSize.height = desiredBounds.height;
        selector.wrapper.offsetX = obj.offsetX;
        selector.wrapper.offsetY = obj.offsetY;
        var selectorEle = getSelectorElement(this.diagram.element.id);
        // EJ2-69511 - Added handleSize parameter to avoid exception when we perform multiselect of connectors, rotate and resize it.
        this.diagram.diagramRenderer.renderResizeHandle(selector.wrapper, selectorEle, selector.thumbsConstraints, this.diagram.scroller.currentZoom, selector.constraints, this.diagram.scroller.transform, false, canMove(selector), null, null, selector.handleSize);
    };
    CommandHandler.prototype.calculateBounds = function (p1, p2) {
        var left = Math.min(p1.x, p2.x);
        var right = Math.max(p1.x, p2.x);
        var top = Math.min(p1.y, p2.y);
        var bottom = Math.max(p1.y, p2.y);
        var width = right - left;
        var height = bottom - top;
        var rect = new Rect(left, top, width, height);
        return rect;
    };
    /**
     * portDrag method \
     *
     * @returns { void }     portDrag method .\
     * @param { NodeModel | ConnectorModel} obj - provide the obj value.
     * @param {DiagramElement} portElement - provide the portElement value.
     * @param {number} tx - provide the tx value.
     * @param {number} ty - provide the tx value.
     *
     * @private
     */
    CommandHandler.prototype.portDrag = function (obj, portElement, tx, ty) {
        var oldValues;
        var changedvalues;
        var port = this.findTarget(portElement, obj);
        var bounds = getBounds(obj.wrapper);
        if (port && canDrag(port, this.diagram)) {
            // Feature 826644: Support to add ports to the connector. Added below condition to check connector port.
            if (obj instanceof Node) {
                oldValues = this.getPortChanges(obj, port);
                port.offset.x += (tx / bounds.width);
                port.offset.y += (ty / bounds.height);
                changedvalues = this.getPortChanges(obj, port);
                this.diagram.nodePropertyChange(obj, oldValues, changedvalues);
            }
            else {
                oldValues = this.getConnectorPortChanges(obj, port);
                this.updatePortOffset(obj, port, tx, ty);
                port.alignment = 'Center';
                changedvalues = this.getConnectorPortChanges(obj, port);
                this.diagram.connectorPropertyChange(obj, oldValues, changedvalues);
            }
            this.diagram.updateDiagramObject(obj);
        }
    };
    /** @private */
    CommandHandler.prototype.labelDrag = function (obj, textElement, tx, ty) {
        //let changedvalues: Object;
        //let label: ShapeAnnotationModel | PathAnnotationModel;
        // eslint-disable-next-line max-len
        var label = this.findTarget(textElement, obj);
        var bounds = cornersPointsBeforeRotation(obj.wrapper);
        var oldValues = this.getAnnotationChanges(obj, label);
        var oldValue = this.getSelectedObject();
        if (label instanceof ShapeAnnotation) {
            label.offset.x += (tx / bounds.width);
            label.offset.y += (ty / bounds.height);
        }
        else {
            this.updatePathAnnotationOffset(obj, label, tx, ty);
            if (label instanceof PathAnnotation) {
                label.alignment = 'Center';
            }
        }
        var changedvalues = this.getAnnotationChanges(obj, label);
        if (obj instanceof Node) {
            this.diagram.nodePropertyChange(obj, oldValues, changedvalues);
        }
        else {
            this.diagram.connectorPropertyChange(obj, oldValues, changedvalues);
        }
        this.diagram.updateDiagramObject(obj);
        if (!isSelected(this.diagram, label, false, textElement)) {
            this.labelSelect(obj, textElement, oldValue);
        }
        //909175: Label interaction not reflected properly in overview
        for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {
            var temp = _a[_i];
            // eslint-disable-next-line security/detect-object-injection
            var view = this.diagram.views[temp];
            if (!(view instanceof Diagram)) {
                this.diagram.refreshCanvasDiagramLayer(view);
            }
        }
    };
    CommandHandler.prototype.updatePathAnnotationOffset = function (object, label, tx, ty, newPosition, size) {
        var textWrapper = this.diagram.getWrapper(object.wrapper, label.id);
        var offsetX = textWrapper.offsetX;
        var offsetY = textWrapper.offsetY;
        var offset;
        var intermediatePoints = object.intermediatePoints;
        var prev;
        var pointLength = 0;
        var totalLength = 0;
        var intersectingOffset;
        var currentPosition;
        switch (label.verticalAlignment) {
            case 'Center':
                if (label.horizontalAlignment === 'Center') {
                    currentPosition = (newPosition) ? newPosition : { x: offsetX + tx, y: offsetY + ty };
                }
                else if (label.horizontalAlignment === 'Right') {
                    currentPosition = (newPosition) ? newPosition : { x: offsetX + (textWrapper.actualSize.width) / 2 + tx, y: offsetY + ty };
                }
                else if (label.horizontalAlignment === 'Left') {
                    currentPosition = (newPosition) ? newPosition : { x: offsetX - (textWrapper.actualSize.width) / 2 + tx, y: offsetY + ty };
                }
                break;
            case 'Top':
                if (label.horizontalAlignment === 'Center') {
                    currentPosition = (newPosition) ? newPosition : { x: offsetX + tx, y: offsetY - (textWrapper.actualSize.height) / 2 + ty };
                }
                else if (label.horizontalAlignment === 'Right') {
                    currentPosition = (newPosition) ? newPosition :
                        { x: offsetX + (textWrapper.actualSize.width) / 2 + tx, y: offsetY - (textWrapper.actualSize.height) / 2 + ty };
                }
                else if (label.horizontalAlignment === 'Left') {
                    currentPosition = (newPosition) ? newPosition :
                        { x: offsetX - (textWrapper.actualSize.width) / 2 + tx, y: offsetY - (textWrapper.actualSize.height) / 2 + ty };
                }
                break;
            case 'Bottom':
                if (label.horizontalAlignment === 'Center') {
                    currentPosition = (newPosition) ? newPosition : { x: offsetX + tx, y: offsetY + (textWrapper.actualSize.height) / 2 + ty };
                }
                else if (label.horizontalAlignment === 'Right') {
                    currentPosition = (newPosition) ? newPosition :
                        { x: offsetX + (textWrapper.actualSize.width) / 2 + tx, y: offsetY + (textWrapper.actualSize.height) / 2 + ty };
                }
                else if (label.horizontalAlignment === 'Left') {
                    currentPosition = (newPosition) ? newPosition :
                        { x: offsetX - (textWrapper.actualSize.width) / 2 + tx, y: offsetY + (textWrapper.actualSize.height) / 2 + ty };
                }
                break;
        }
        var intersetingPts = this.getInterceptWithSegment(currentPosition, intermediatePoints);
        var newOffset = intermediatePoints[intermediatePoints.length - 1];
        totalLength = Point.getLengthFromListOfPoints(intermediatePoints);
        if (intersetingPts.length > 0) {
            label.dragLimit = label.dragLimit ? label.dragLimit : {};
            if (label.dragLimit.top || label.dragLimit.bottom || label.dragLimit.left || label.dragLimit.right) {
                var minDistance = { minDistance: null };
                newOffset = this.getRelativeOffset(currentPosition, intermediatePoints, minDistance);
                var distance = { minDistance: null };
                intersectingOffset = this.getRelativeOffset(currentPosition, intersetingPts, distance);
                if (minDistance != null && distance.minDistance < minDistance.minDistance) {
                    newOffset = intersectingOffset;
                }
                else {
                    var connectorOffset = getOffsetOfConnector(object.intermediatePoints, label);
                    newOffset = connectorOffset.point;
                }
            }
            else {
                intersectingOffset = intersetingPts[intersetingPts.length - 1];
                newOffset = intersectingOffset;
            }
            if (newOffset) {
                var p = void 0;
                var bounds = void 0;
                for (p = 0; p < intermediatePoints.length; p++) {
                    if (prev != null) {
                        bounds = Rect.toBounds([prev, intermediatePoints[parseInt(p.toString(), 10)]]);
                        if (bounds.containsPoint(newOffset)) {
                            pointLength += Point.findLength(prev, newOffset);
                            break;
                        }
                        else {
                            pointLength += Point.findLength(prev, intermediatePoints[parseInt(p.toString(), 10)]);
                        }
                    }
                    prev = intermediatePoints[parseInt(p.toString(), 10)];
                }
                offset = { x: pointLength / totalLength, y: 0 };
            }
            this.updateLabelMargin(object, label, offset, currentPosition, size, tx, ty);
        }
        else {
            this.updateLabelMargin(object, label, null, currentPosition, size, tx, ty);
        }
    };
    // Feature 826644: Support to add ports to the connector.
    // Added below method to update the port offset when we drag the port.
    CommandHandler.prototype.updatePortOffset = function (object, port, tx, ty, newPosition, size) {
        var textWrapper = this.diagram.getWrapper(object.wrapper, port.id);
        var offsetX = textWrapper.offsetX;
        var offsetY = textWrapper.offsetY;
        var offset;
        var intermediatePoints = object.intermediatePoints;
        var prev;
        var pointLength = 0;
        var totalLength = 0;
        var intersectingOffset;
        var currentPosition;
        switch (port.verticalAlignment) {
            case 'Center':
                if (port.horizontalAlignment === 'Center') {
                    currentPosition = (newPosition) ? newPosition : { x: offsetX + tx, y: offsetY + ty };
                }
                else if (port.horizontalAlignment === 'Right') {
                    currentPosition = (newPosition) ? newPosition : { x: offsetX + (textWrapper.actualSize.width) / 2 + tx, y: offsetY + ty };
                }
                else if (port.horizontalAlignment === 'Left') {
                    currentPosition = (newPosition) ? newPosition : { x: offsetX - (textWrapper.actualSize.width) / 2 + tx, y: offsetY + ty };
                }
                break;
            case 'Top':
                if (port.horizontalAlignment === 'Center') {
                    currentPosition = (newPosition) ? newPosition : { x: offsetX + tx, y: offsetY - (textWrapper.actualSize.height) / 2 + ty };
                }
                else if (port.horizontalAlignment === 'Right') {
                    currentPosition = (newPosition) ? newPosition :
                        { x: offsetX + (textWrapper.actualSize.width) / 2 + tx, y: offsetY - (textWrapper.actualSize.height) / 2 + ty };
                }
                else if (port.horizontalAlignment === 'Left') {
                    currentPosition = (newPosition) ? newPosition :
                        { x: offsetX - (textWrapper.actualSize.width) / 2 + tx, y: offsetY - (textWrapper.actualSize.height) / 2 + ty };
                }
                break;
            case 'Bottom':
                if (port.horizontalAlignment === 'Center') {
                    currentPosition = (newPosition) ? newPosition : { x: offsetX + tx, y: offsetY + (textWrapper.actualSize.height) / 2 + ty };
                }
                else if (port.horizontalAlignment === 'Right') {
                    currentPosition = (newPosition) ? newPosition :
                        { x: offsetX + (textWrapper.actualSize.width) / 2 + tx, y: offsetY + (textWrapper.actualSize.height) / 2 + ty };
                }
                else if (port.horizontalAlignment === 'Left') {
                    currentPosition = (newPosition) ? newPosition :
                        { x: offsetX - (textWrapper.actualSize.width) / 2 + tx, y: offsetY + (textWrapper.actualSize.height) / 2 + ty };
                }
                break;
        }
        var intersectingPoints = this.getInterceptWithSegment(currentPosition, intermediatePoints);
        var newOffset = intermediatePoints[intermediatePoints.length - 1];
        totalLength = Point.getLengthFromListOfPoints(intermediatePoints);
        if (intersectingPoints.length > 0) {
            intersectingOffset = intersectingPoints[intersectingPoints.length - 1];
            newOffset = intersectingOffset;
            if (newOffset) {
                var p = void 0;
                var bounds = void 0;
                for (p = 0; p < intermediatePoints.length; p++) {
                    if (prev != null) {
                        bounds = Rect.toBounds([prev, intermediatePoints[parseInt(p.toString(), 10)]]);
                        if (bounds.containsPoint(newOffset)) {
                            pointLength += Point.findLength(prev, newOffset);
                            break;
                        }
                        else {
                            pointLength += Point.findLength(prev, intermediatePoints[parseInt(p.toString(), 10)]);
                        }
                    }
                    prev = intermediatePoints[parseInt(p.toString(), 10)];
                }
                offset = { x: pointLength / totalLength, y: 0 };
            }
            this.updateLabelMargin(object, port, offset, currentPosition, size, tx, ty);
        }
        else {
            this.updateLabelMargin(object, port, null, currentPosition, size, tx, ty);
        }
    };
    CommandHandler.prototype.getRelativeOffset = function (currentPosition, points, minDistance) {
        var newOffset;
        var distance;
        var pt;
        var i;
        for (i = 0; i < points.length; i++) {
            pt = points[parseInt(i.toString(), 10)];
            distance = Math.round(Math.sqrt(Math.pow((currentPosition.x - pt.x), 2) +
                Math.pow((currentPosition.y - pt.y), 2)));
            if (minDistance.minDistance === null ||
                Math.min(Math.abs(minDistance.minDistance), Math.abs(distance)) === Math.abs(distance)) {
                newOffset = pt;
                minDistance.minDistance = distance;
            }
        }
        return newOffset;
    };
    CommandHandler.prototype.dragLimitValue = function (label, point, tempPt, contentDimension) {
        var x = false;
        var y = false;
        if ((tempPt.x >= (point.x - label.dragLimit.left - (contentDimension.width / 2))) &&
            (tempPt.x <= point.x + label.dragLimit.right + (contentDimension.width / 2))) {
            x = true;
        }
        if ((tempPt.y >= (point.y - label.dragLimit.top - (contentDimension.height / 2))) &&
            (tempPt.y <= point.y + label.dragLimit.bottom + (contentDimension.height / 2))) {
            y = true;
        }
        return { x: x, y: y };
    };
    /* eslint-disable */
    CommandHandler.prototype.updateLabelMargin = function (node, label, offset, tempPt, size, tx, ty) {
        offset = offset ? offset : { x: label.offset, y: 0 };
        if (label && offset && offset.x > 0 && offset.x < 1) {
            //let point: PointModel;
            var length_2 = Point.getLengthFromListOfPoints(node.intermediatePoints);
            var point = this.getPointAtLength(length_2 * offset.x, node.intermediatePoints, 0);
            var curZoomfactor = this.diagram.scrollSettings.currentZoom;
            var dragLimit = label.dragLimit ? label.dragLimit : { left: 0, right: 0, top: 0, bottom: 0 };
            if (dragLimit.top || dragLimit.bottom || dragLimit.left || dragLimit.right) {
                var labelBounds = this.diagram.getWrapper(node.wrapper, label.id);
                var contentDimension = new Rect(0, 0, 0, 0);
                var annotationWrtapper = this.diagram.getWrapper(node.wrapper, label.id);
                contentDimension.x = ((annotationWrtapper).offsetX / curZoomfactor) + tx;
                contentDimension.y = (annotationWrtapper.offsetY / curZoomfactor) + ty;
                contentDimension.width = annotationWrtapper.bounds.width / curZoomfactor;
                contentDimension.height = annotationWrtapper.bounds.height / curZoomfactor;
                var draggableBounds = new Rect(point.x - (dragLimit.left || 0) - contentDimension.width / 2, point.y - (dragLimit.top || 0) - contentDimension.height / 2, (dragLimit.left || 0) + (dragLimit.right || 0) + contentDimension.width, (dragLimit.top || 0) + (dragLimit.bottom || 0) + contentDimension.height);
                if (draggableBounds.containsPoint(tempPt)) {
                    tempPt = tempPt;
                }
                else {
                    var lineIntersects = void 0;
                    var line1 = [point, tempPt];
                    lineIntersects = this.boundsInterSects(line1, draggableBounds, false);
                    for (var _i = 0, lineIntersects_1 = lineIntersects; _i < lineIntersects_1.length; _i++) {
                        var i = lineIntersects_1[_i];
                        var ptt = i;
                        tempPt = ptt;
                    }
                }
                var cursorLimit = this.dragLimitValue(label, point, tempPt, contentDimension);
                label.margin = {
                    left: cursorLimit.x ? tempPt.x - point.x : label.margin.left,
                    top: cursorLimit.y ? tempPt.y - point.y : label.margin.top, right: 0, bottom: 0
                };
            }
            else {
                label.margin = { left: tempPt.x - point.x, top: tempPt.y - point.y, right: 0, bottom: 0 };
            }
            label.offset = offset.x;
            if (size) {
                label.width = size.width;
                label.height = size.height;
            }
        }
    };
    CommandHandler.prototype.boundsInterSects = function (polyLine, bounds, self) {
        var intersects;
        if (bounds) {
            var polyLine2 = [
                { x: bounds.x, y: bounds.y },
                { x: bounds.x + bounds.width, y: bounds.y },
                { x: bounds.x + bounds.width, y: bounds.y + bounds.height },
                { x: bounds.x, y: bounds.y + bounds.height },
                { x: bounds.x, y: bounds.y }
            ];
            intersects = this.intersect(polyLine, polyLine2, self);
        }
        return intersects;
    };
    /** @private */
    CommandHandler.prototype.intersect = function (polyLine1, polyLine2, self) {
        var intersect = [];
        for (var i = 0; i < polyLine1.length - 1; i++) {
            for (var j = 0; j < polyLine2.length - 1; j++) {
                var p = intersect2(polyLine1[i], polyLine1[i + 1], polyLine2[j], polyLine2[j + 1]);
                if (p.x !== 0 && p.y !== 0) {
                    intersect.push(p);
                }
            }
        }
        return intersect;
    };
    /**
     * @private
     */
    CommandHandler.prototype.getPointAtLength = function (length, points, angle) {
        var run = 0;
        var pre;
        var found = { x: 0, y: 0 };
        var pt;
        for (var i = 0; i < points.length; i++) {
            pt = points[i];
            if (!pre) {
                pre = pt;
                continue;
            }
            else {
                var l = Point.findLength(pre, pt);
                var r = void 0;
                var deg = void 0;
                var x = void 0;
                var y = void 0;
                if (run + l >= length) {
                    r = length - run;
                    deg = Point.findAngle(pre, pt);
                    x = r * Math.cos(deg * Math.PI / 180);
                    y = r * Math.sin(deg * Math.PI / 180);
                    found = { x: pre.x + x, y: pre.y + y };
                    break;
                }
                else {
                    run += l;
                }
            }
            pre = pt;
        }
        return found;
    };
    CommandHandler.prototype.getInterceptWithSegment = function (currentPosition, conPoints) {
        var intercepts = [];
        var imgLine = [];
        var segemnt = [];
        var tarAngle;
        var srcAngle; //let maxLength: number;
        var maxLength = Point.findLength({ x: 0, y: 0 }, { x: this.diagram.scroller.viewPortWidth, y: this.diagram.scroller.viewPortHeight });
        for (var i = 1; i < conPoints.length; i++) {
            segemnt = [conPoints[i - 1], conPoints[i]];
            imgLine = [];
            srcAngle = Math.round(Point.findAngle(segemnt[0], segemnt[1]) % 360);
            tarAngle = Math.round(Point.findAngle(segemnt[1], segemnt[0]) % 360);
            var angleAdd = (srcAngle > 0 && srcAngle <= 90) || (srcAngle > 180 && srcAngle <= 270) ? 90 : -90;
            imgLine.push(Point.transform(currentPosition, srcAngle + angleAdd, maxLength));
            imgLine.push(Point.transform(currentPosition, tarAngle + angleAdd, maxLength));
            var lineUtil1 = { x1: segemnt[0].x, y1: segemnt[0].y, x2: segemnt[1].x, y2: segemnt[1].y };
            var lineUtil2 = { x1: imgLine[0].x, y1: imgLine[0].y, x2: imgLine[1].x, y2: imgLine[1].y };
            var line3 = intersect3(lineUtil1, lineUtil2);
            if (line3.enabled) {
                intercepts.push(line3.intersectPt);
            }
        }
        return intercepts;
    };
    /** @private */
    CommandHandler.prototype.getAnnotationChanges = function (object, label) {
        var index = findObjectIndex(object, label.id, true);
        var annotations = {};
        annotations[index] = {
            width: label.width, height: label.height, offset: (object instanceof Node) ? ({
                x: label.offset.x,
                y: label.offset.y
            }) : label.offset,
            rotateAngle: label.rotateAngle,
            margin: { left: label.margin.left, right: label.margin.right, top: label.margin.top, bottom: label.margin.bottom },
            horizontalAlignment: label.horizontalAlignment, verticalAlignment: label.verticalAlignment,
            alignment: ((object instanceof Connector) ? label.alignment : undefined)
        };
        return { annotations: annotations };
    };
    // Feature 826644: Support to add ports to the connector. Added below method to get port values before and after drag.
    /** @private */
    CommandHandler.prototype.getConnectorPortChanges = function (object, label) {
        var index = findPortIndex(object, label.id);
        var ports = {};
        ports[index] = {
            width: label.width, height: label.height, offset: label.offset,
            margin: { left: label.margin.left, right: label.margin.right, top: label.margin.top, bottom: label.margin.bottom },
            horizontalAlignment: label.horizontalAlignment, verticalAlignment: label.verticalAlignment,
            alignment: ((object instanceof Connector) ? label.alignment : undefined)
        };
        return { ports: ports };
    };
    /** @private */
    CommandHandler.prototype.getPortChanges = function (object, port) {
        var index = findObjectIndex(object, port.id, false);
        var ports = {};
        ports[index] = { offset: port.offset };
        return { ports: ports };
    };
    /** @private */
    CommandHandler.prototype.labelRotate = function (object, label, currentPosition, selector) {
        var oldValues;
        var changedvalues;
        oldValues = this.getAnnotationChanges(object, label);
        var matrix = identityMatrix();
        var rotateAngle = label.rotateAngle;
        var labelWrapper = this.diagram.getWrapper(object.wrapper, label.id);
        var angle = findAngle({ x: labelWrapper.offsetX, y: labelWrapper.offsetY }, currentPosition) + 90;
        var snapAngle = this.snapAngle(angle);
        angle = snapAngle !== 0 ? snapAngle : angle;
        if (label instanceof PathAnnotation && label.segmentAngle) {
            var getPointloop = getAnnotationPosition(object.intermediatePoints, label, object.wrapper.bounds);
            angle -= getPointloop.angle;
        }
        angle = (angle + 360) % 360;
        label.rotateAngle += angle - (label.rotateAngle + labelWrapper.parentTransform);
        if (label instanceof PathAnnotation) {
            label.alignment = 'Center';
        }
        selector.wrapper.rotateAngle = selector.rotateAngle = label.rotateAngle;
        changedvalues = this.getAnnotationChanges(object, label);
        if (object instanceof Node) {
            this.diagram.nodePropertyChange(object, oldValues, changedvalues);
        }
        else {
            this.diagram.connectorPropertyChange(object, oldValues, changedvalues);
        }
        this.diagram.updateDiagramObject(object);
        //909175: Label interaction not reflected properly in overview
        for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {
            var temp = _a[_i];
            var view = this.diagram.views[temp];
            if (!(view instanceof Diagram)) {
                this.diagram.refreshCanvasDiagramLayer(view);
            }
        }
    };
    /** @private */
    CommandHandler.prototype.labelResize = function (node, label, deltaWidth, deltaHeight, pivot, selector) {
        var oldValues;
        var changedvalues;
        var rotateAngle;
        oldValues = this.getAnnotationChanges(node, label);
        var textElement = selector.wrapper.children[0];
        if ((deltaWidth && deltaWidth !== 1) || (deltaHeight && deltaHeight !== 1)) {
            var newMat = identityMatrix();
            var matrix = identityMatrix();
            rotateMatrix(newMat, -node.rotateAngle, node.offsetX, node.offsetY);
            rotateAngle = ((textElement.rotateAngle + ((node instanceof Node) ? node.rotateAngle : 0)) + 360) % 360;
            rotateMatrix(matrix, -rotateAngle, pivot.x, pivot.y);
            scaleMatrix(matrix, deltaWidth, deltaHeight, pivot.x, pivot.y);
            rotateMatrix(matrix, rotateAngle, pivot.x, pivot.y);
            var newPosition = transformPointByMatrix(matrix, { x: textElement.offsetX, y: textElement.offsetY });
            var height = textElement.actualSize.height * deltaHeight;
            var width = textElement.actualSize.width * deltaWidth;
            var shape = this.findTarget(textElement, node);
            if (shape instanceof PathAnnotation) {
                newPosition.y += (shape.verticalAlignment === 'Top') ? (-height / 2) : ((shape.verticalAlignment === 'Bottom') ? (height / 2) : 0);
                newPosition.x += (shape.horizontalAlignment === 'Left') ? (-width / 2) : ((shape.horizontalAlignment === 'Right') ? (width / 2) : 0);
            }
            if (shape instanceof PathAnnotation) {
                this.updatePathAnnotationOffset(node, label, 0, 0, newPosition, new Size(width, height));
            }
            else {
                var bounds = cornersPointsBeforeRotation(node.wrapper);
                newPosition = transformPointByMatrix(newMat, newPosition);
                newPosition.x = newPosition.x - textElement.margin.left + textElement.margin.right;
                newPosition.y = newPosition.y - textElement.margin.top + textElement.margin.bottom;
                newPosition.y += (shape.verticalAlignment === 'Top') ? (-height / 2) : ((shape.verticalAlignment === 'Bottom') ? (height / 2) : 0);
                newPosition.x += (shape.horizontalAlignment === 'Left') ? (-width / 2) : ((shape.horizontalAlignment === 'Right') ? (width / 2) : 0);
                var offsetx = bounds.width / (newPosition.x - bounds.x);
                var offsety = bounds.height / (newPosition.y - bounds.y);
                if (width > 1) {
                    shape.width = width;
                    shape.offset.x = 1 / offsetx;
                }
                if (height > 1) {
                    shape.height = height;
                    shape.offset.y = 1 / offsety;
                }
            }
        }
        if (label instanceof PathAnnotation) {
            label.alignment = 'Center';
        }
        changedvalues = this.getAnnotationChanges(node, label);
        if (node instanceof Node) {
            this.diagram.nodePropertyChange(node, oldValues, changedvalues);
        }
        else {
            this.diagram.connectorPropertyChange(node, oldValues, changedvalues);
        }
        this.diagram.updateDiagramObject(node);
        //909175: Label interaction not reflected properly in overview
        for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {
            var temp = _a[_i];
            var view = this.diagram.views[temp];
            if (!(view instanceof Diagram)) {
                this.diagram.refreshCanvasDiagramLayer(view);
            }
        }
    };
    /** @private */
    CommandHandler.prototype.getSubProcess = function (source) {
        var selector = { nodes: [], connectors: [] };
        var process;
        if (source instanceof Node) {
            process = source.processId;
        }
        else if (source && source.nodes && (source.nodes.length)
            && source.nodes[0].processId) {
            process = source.nodes[0].processId;
        }
        if (process) {
            selector.nodes.push(cloneObject(this.diagram.nameTable[process]));
            return selector;
        }
        return selector;
    };
    /**   @private  */
    CommandHandler.prototype.checkBoundaryConstraints = function (tx, ty, nodeBounds, isInitialRendering) {
        var pageSettings = this.diagram.pageSettings;
        var boundaryConstraints = this.diagram.pageSettings.boundaryConstraints;
        var scroller = this.diagram.scroller;
        if (boundaryConstraints === 'Page' || boundaryConstraints === 'Diagram') {
            var selectorBounds = !nodeBounds ? this.diagram.selectedItems.wrapper.bounds : undefined;
            var width = boundaryConstraints === 'Page' ? pageSettings.width : scroller.viewPortWidth;
            var height = boundaryConstraints === 'Page' ? pageSettings.height : scroller.viewPortHeight;
            var bounds = nodeBounds;
            var right = (nodeBounds ? bounds.right : selectorBounds.right) + (tx || 0);
            var left = (nodeBounds ? bounds.left : selectorBounds.left) + (tx || 0);
            var top_2 = (nodeBounds ? bounds.top : selectorBounds.top) + (ty || 0);
            var bottom = (nodeBounds ? bounds.bottom : selectorBounds.bottom) + (ty || 0);
            //Bug 906963: Layout is not rendered when boundaryConstraints set to "Page/Diagram"
            if (right <= width && left >= 0
                && bottom <= height && top_2 >= 0 || (this.diagram.layout.type !== 'None' && isInitialRendering)) {
                return true;
            }
            return false;
        }
        return true;
    };
    //interfaces
    /** @private */
    CommandHandler.prototype.dragSelectedObjects = function (tx, ty) {
        var _this = this;
        var obj = this.diagram.selectedItems;
        if (this.state && !this.state.backup) {
            this.state.backup = {};
            this.state.backup.offsetX = obj.offsetX;
            this.state.backup.offsetY = obj.offsetY;
        }
        obj = renderContainerHelper(this.diagram, obj) || obj;
        //Bug 905527: Multiselecting and dragging Swimlane updates incorrectly
        //Added below condition to check if swimlane is selected and not the symbol symbol from the symbol palette
        //Also check if the selected swimlane is not the only object selected
        var swimLaneInSelection = this.diagram.selectedItems.nodes.filter(function (node) { return node.shape.type === 'SwimLane'; });
        var conCollection = [];
        if (swimLaneInSelection.length > 0 && !this.diagram.currentSymbol) {
            if (this.diagram.selectedItems.nodes.length + this.diagram.selectedItems.connectors.length > 1) {
                var filterObjects = this.diagram.selectedItems.nodes.filter(function (node) { return (node.parentId === '' || _this.diagram.nameTable[node.parentId].shape.type !== 'SwimLane'); });
                if (filterObjects.length > 0) {
                    for (var i = 0; i < filterObjects.length; i++) {
                        if ((this.diagram.nameTable[filterObjects[parseInt(i.toString(), 10)].parentId] &&
                            this.diagram.nameTable[filterObjects[parseInt(i.toString(), 10)].parentId].isLane)
                            || filterObjects[parseInt(i.toString(), 10)].shape.type === 'SwimLane') {
                            filterObjects.splice(i, 1);
                            i--;
                        }
                    }
                    //"obj" -  The current object being processed in the array.
                    //"index" - The index of the current object in the array.
                    //"self" - The reference to the entire array being processed by the filter function.
                    var uniqueSwimlane = swimLaneInSelection.filter(function (obj, index, self) {
                        return index === self.findIndex(function (item) { return item.id === obj.id; });
                    });
                    //Bug 913796: Multiselect swimlane with outside node, drag, rotate is not proper
                    //Added below code to get connectors connected inside swimlane and update the properties.
                    for (var i = 0; i < uniqueSwimlane.length; i++) {
                        conCollection = conCollection.concat(getConnectors(this.diagram, uniqueSwimlane[i].wrapper.children[0]));
                    }
                    if (filterObjects.length > 0 || uniqueSwimlane.length > 1 || this.diagram.selectedItems.connectors.length > 0) {
                        filterObjects = filterObjects.concat(uniqueSwimlane);
                        // Clear the nodes array without losing the reference
                        this.diagram.selectedItems.nodes.splice(0, this.diagram.selectedItems.nodes.length);
                        // Push objects from filterObjects into the nodes array
                        filterObjects.forEach(function (node) {
                            _this.diagram.selectedItems.nodes.push(node);
                        });
                        obj = this.diagram.selectedItems;
                        this.diagram.selectedObject.helperObject = undefined;
                    }
                }
            }
        }
        if (this.checkBoundaryConstraints(tx, ty)) {
            this.diagram.diagramActions = this.diagram.diagramActions | (DiagramAction.PreventZIndexOnDragging | DiagramAction.DragUsingMouse);
            var actualObject = this.diagram.selectedObject.actualObject;
            if ((actualObject && actualObject instanceof Node && actualObject.isLane &&
                canLaneInterchange(actualObject, this.diagram)) || (!actualObject || !actualObject.isLane)) {
                this.diagram.drag(obj, tx, ty);
                updateConnectorsProperties(conCollection, this.diagram);
            }
            this.diagram.diagramActions = this.diagram.diagramActions & ~(DiagramAction.PreventZIndexOnDragging | DiagramAction.DragUsingMouse);
            this.diagram.refreshCanvasLayers();
            //Bug 872140: Dragging HTML nodes in a diagram leaves shadows on the overview
            this.checkHtmlObjectDrag(obj);
            return true;
        }
        return false;
    };
    // Checks if any HTML object is being dragged and reset the canvas to clear the shadow of the HTML node border.
    CommandHandler.prototype.checkHtmlObjectDrag = function (obj) {
        var isHtmlObjDragged = false;
        if (this.diagram.views && this.diagram.views.length > 1) {
            if (obj instanceof Selector) {
                isHtmlObjDragged = obj.nodes.some(function (node) { return node.shape && node.shape.type === 'HTML'; });
            }
            else if (obj.shape && obj.shape.type === 'HTML') {
                isHtmlObjDragged = true;
            }
            if (isHtmlObjDragged) {
                this.resetOverviewCanvas();
            }
        }
    };
    //Resetting Overview canvas  
    CommandHandler.prototype.resetOverviewCanvas = function () {
        for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {
            var temp = _a[_i];
            var view = this.diagram.views[temp];
            if (!(view instanceof Diagram)) {
                var rect = document.getElementById(view.canvas.id + 'overviewrect');
                var x = Number(rect.getAttribute('x'));
                var y = Number(rect.getAttribute('y'));
                var width = Number(rect.getAttribute('width'));
                var height = Number(rect.getAttribute('height'));
                var attr = { x: x, y: y, width: Math.max(1, width), height: Math.max(1, height) };
                setAttributeHtml(rect, attr);
            }
        }
    };
    /** @private */
    CommandHandler.prototype.scaleSelectedItems = function (sx, sy, pivot) {
        var obj = this.diagram.selectedItems;
        if (this.state && !this.state.backup) {
            this.state.backup = {};
            this.state.backup.offsetX = obj.offsetX;
            this.state.backup.offsetY = obj.offsetY;
            this.state.backup.width = obj.width;
            this.state.backup.height = obj.height;
            this.state.backup.pivot = pivot;
        }
        obj = renderContainerHelper(this.diagram, obj) || obj;
        return this.diagram.scale(obj, sx, sy, pivot);
    };
    /** @private */
    CommandHandler.prototype.rotateSelectedItems = function (angle) {
        var obj = this.diagram.selectedItems;
        if (this.state && !this.state.backup) {
            this.state.backup = {};
            this.state.backup.angle = obj.rotateAngle;
        }
        obj = renderContainerHelper(this.diagram, obj) || obj;
        return this.diagram.rotate(obj, angle, undefined, true);
    };
    /** @private */
    CommandHandler.prototype.hasSelection = function () {
        return hasSelection(this.diagram);
    };
    /** @private */
    CommandHandler.prototype.isSelected = function (element) {
        return isSelected(this.diagram, element);
    };
    /**
     * initExpand is used for layout expand and collapse interaction
     */
    CommandHandler.prototype.initExpand = function (args) {
        var propName = 'isProtectedOnChange';
        var protectedChange = this.diagram[propName];
        this.diagram.protectPropertyChange(true);
        var node = (args.target || args.source);
        var oldValues = { isExpanded: node.isExpanded };
        node.isExpanded = !node.isExpanded;
        this.diagram.preventNodesUpdate = true;
        this.diagram.diagramActions |= DiagramAction.PreventIconsUpdate;
        this.diagram.nodePropertyChange(node, oldValues, { isExpanded: node.isExpanded });
        this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.PreventIconsUpdate;
        this.diagram.preventNodesUpdate = false;
        for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {
            var temp = _a[_i];
            var view = this.diagram.views[temp];
            if (!(view instanceof Diagram)) {
                this.diagram.refreshCanvasDiagramLayer(view);
            }
        }
        this.diagram.protectPropertyChange(protectedChange);
    };
    /** @private */
    CommandHandler.prototype.expandNode = function (node, diagram, canLayout) {
        //let objects: ILayout;
        var preventNodesUpdate = this.diagram.preventNodesUpdate;
        var expand = node.isExpanded;
        this.diagram.preventNodesUpdate = true;
        //Bug 883244: After expand and collapse the compex hierarchical layout, the connector are not rendered properly.
        // Removed the preventConnectorsUpdate property to update the connector properly while performing expand and collapse.
        // this.diagram.preventConnectorsUpdate = true;
        this.expandCollapse(node, expand, this.diagram, undefined);
        node.isExpanded = expand;
        var fixedNode = this.diagram.layout.fixedNode;
        this.diagram.layout.fixedNode = node.id;
        if ((this.diagram.diagramActions != DiagramAction.Render) && this.diagram.layoutAnimateModule && this.diagram.layout.enableAnimation && this.diagram.organizationalChartModule) {
            this.diagram.organizationalChartModule.isAnimation = true;
        }
        this.diagram.blazorActions |= BlazorAction.expandNode;
        var objects = {};
        if (!canLayout) {
            if (this.layoutAnimateModule && this.layoutAnimateModule.setIntervalObject.length > 0) {
                this.layoutAnimateModule.stopCurrentAnimation(this.objectStore[0], diagram, node);
                this.objectStore = [];
            }
            objects = this.diagram.doLayout();
            this.objectStore.push(objects);
        }
        this.canUpdateTemplate = false;
        this.diagram.blazorActions &= ~BlazorAction.expandNode;
        this.diagram.preventNodesUpdate = preventNodesUpdate;
        // this.diagram.preventConnectorsUpdate = false;
        if (this.diagram.layoutAnimateModule && this.diagram.organizationalChartModule && !canLayout) {
            this.diagram.allowServerDataBinding = false;
            this.layoutAnimateModule.expand(this.diagram.layout.enableAnimation, objects, node, this.diagram);
        }
        else {
            var arg = {
                element: cloneBlazorObject(cloneObject(node)), state: (node.isExpanded) ? true : false
            };
            this.triggerEvent(DiagramEvent.expandStateChange, arg);
            //Bug 873119: Diagram throws error when setting isExpanded property as false with LineRouting injected.
            if (this.diagram.lineRoutingModule && this.diagram.constraints & DiagramConstraints.LineRouting && this.diagram.layout.type !== 'ComplexHierarchicalTree') {
                this.diagram.resetSegments();
            }
        }
        this.diagram.layout.fixedNode = fixedNode === '' ? '' : this.diagram.layout.fixedNode;
        return objects;
    };
    CommandHandler.prototype.getparentexpand = function (target, diagram, visibility, connector) {
        var boolean;
        for (var i = 0; i < target.inEdges.length; i++) {
            var newConnector = diagram.nameTable[target.inEdges[i]];
            var previousNode = diagram.nameTable[newConnector.sourceID];
            if (previousNode.isExpanded && !visibility && previousNode.id !== connector.sourceID && newConnector.visible) {
                return false;
            }
            else {
                boolean = true;
            }
        }
        return boolean;
    };
    /**
     * Setinterval and Clear interval for layout animation
     */
    /** @private */
    CommandHandler.prototype.expandCollapse = function (source, visibility, diagram, visitedNodes) {
        //937703 - Check if the node has already been visited
        if (!visitedNodes || visitedNodes.length === 0) {
            visitedNodes = [];
        }
        if (visitedNodes.some(function (node) { return node.id === source.id; })) {
            return; // Avoid infinite loop by returning early
        }
        // Mark the current node as visited
        visitedNodes.push(source);
        for (var i = 0; i < source.outEdges.length; i++) {
            var connector = diagram.nameTable[source.outEdges[i]];
            var target = diagram.nameTable[connector.targetID];
            var value = this.getparentexpand(target, diagram, visibility, connector);
            connector.visible = visibility;
            var oldValues = {
                visible: target.visible,
                style: { opacity: target.wrapper.style.opacity }
            };
            var newValues = {
                visible: target.visible,
                style: { opacity: target.wrapper.style.opacity }
            };
            if (value) {
                if (target.isExpanded) {
                    this.expandCollapse(target, visibility, diagram, visitedNodes);
                }
                target.visible = visibility;
                target.style.opacity = (this.diagram.layoutAnimateModule &&
                    this.diagram.layout.enableAnimation && visibility) ? 0.1 : target.style.opacity;
                diagram.nodePropertyChange(target, oldValues, newValues);
            }
            diagram.connectorPropertyChange(connector, oldValues, newValues);
        }
    };
    /**
     * @private
     */
    CommandHandler.prototype.updateNodeDimension = function (obj, rect) {
        if (obj instanceof Node) {
            obj.offsetX = rect.x + rect.width / 2;
            obj.offsetY = rect.y + rect.height / 2;
            obj.width = rect.width;
            obj.height = rect.height;
            obj.wrapper.children[0].canMeasurePath = true;
            this.diagram.nodePropertyChange(obj, {}, {
                width: rect.width, height: rect.height, offsetX: obj.offsetX,
                offsetY: obj.offsetY
            });
            if (this.diagram.mode !== 'SVG') {
                this.diagram.refreshDiagramLayer();
            }
        }
    };
    /**
     * @private
     */
    CommandHandler.prototype.updateConnectorPoints = function (obj, rect) {
        if (obj instanceof Connector && obj.type !== 'Bezier') {
            this.diagram.connectorPropertyChange(obj, {}, {
                targetPoint: obj.targetPoint
            });
            this.diagram.updateDiagramObject(obj);
        }
        else {
            this.diagram.connectorPropertyChange(obj, {}, { segments: obj.segments });
            this.diagram.updateDiagramObject(obj);
        }
    };
    /**
     * @private
     */
    CommandHandler.prototype.updateSelectedNodeProperties = function (object) {
        if (this.diagram.lineRoutingModule && (this.diagram.constraints & DiagramConstraints.LineRouting)) {
            this.diagram.protectPropertyChange(true);
            var objects = [];
            var connectors = [];
            var actualObject = this.diagram.selectedObject.actualObject;
            var helperObject = this.diagram.selectedObject.helperObject;
            //EJ2-908138 - Redo not working after move and undo the multi nodes while  line routing enabled
            var undoElement = actualObject instanceof Selector ? cloneObject(actualObject) : undefined;
            if (helperObject && actualObject) {
                var offsetX = (helperObject.offsetX - actualObject.offsetX);
                var offsetY = (helperObject.offsetY - actualObject.offsetY);
                var width = (helperObject.width - actualObject.width);
                var height = (helperObject.height - actualObject.height);
                var rotateAngle = (helperObject.rotateAngle - actualObject.rotateAngle);
                if (this.diagram.selectedItems.nodes.length + this.diagram.selectedItems.connectors.length > 0) {
                    this.diagram.selectedItems.wrapper.rotateAngle = this.diagram.selectedItems.rotateAngle = helperObject.rotateAngle;
                }
                if (actualObject instanceof Node &&
                    actualObject.shape.type !== 'SwimLane' && !actualObject.isLane && !actualObject.isPhase && !actualObject.isHeader &&
                    !checkParentAsContainer(this.diagram, actualObject)) {
                    if (actualObject.offsetX !== actualObject.wrapper.offsetX || actualObject.offsetY !== actualObject.wrapper.offsetY ||
                        actualObject.width !== actualObject.wrapper.width || actualObject.height !== actualObject.wrapper.height ||
                        actualObject.rotateAngle !== actualObject.wrapper.rotateAngle) {
                        actualObject.offsetX += offsetX;
                        actualObject.offsetY += offsetY;
                        actualObject.width += width;
                        actualObject.height += height;
                        actualObject.rotateAngle += rotateAngle;
                        this.diagram.nodePropertyChange(actualObject, {}, {
                            offsetX: actualObject.offsetX, offsetY: actualObject.offsetY,
                            width: actualObject.width, height: actualObject.height, rotateAngle: actualObject.rotateAngle
                        }, false, true);
                    }
                    objects = this.diagram.spatialSearch.findObjects(actualObject.wrapper.outerBounds);
                }
                else if (actualObject instanceof Selector) {
                    //929543: To resize the multiselected nodes properly
                    var scaleWidth = helperObject.width / actualObject.width;
                    var scaleHeight = helperObject.height / actualObject.height;
                    var pivot = this.diagram.eventHandler.tool.getPivot(this.diagram.eventHandler.tool.corner);
                    if (this.diagram.eventHandler.tool.corner) {
                        for (var i = 0; i < actualObject.nodes.length; i++) {
                            var node = actualObject.nodes[parseInt(i.toString(), 10)];
                            var element = node.wrapper;
                            var refWrapper = actualObject.wrapper;
                            var x = refWrapper.offsetX - refWrapper.actualSize.width * refWrapper.pivot.x;
                            var y = refWrapper.offsetY - refWrapper.actualSize.height * refWrapper.pivot.y;
                            var refPoint = getPoint(x, y, refWrapper.actualSize.width, refWrapper.actualSize.height, refWrapper.rotateAngle, refWrapper.offsetX, refWrapper.offsetY, pivot);
                            this.diagram.commandHandler.scaleObject(scaleWidth, scaleHeight, refPoint, node, element, actualObject);
                        }
                    }
                    else {
                        for (var i = 0; i < actualObject.nodes.length; i++) {
                            var node = actualObject.nodes[i];
                            if (node instanceof Node && node.shape.type !== 'SwimLane' &&
                                !checkParentAsContainer(this.diagram, node) &&
                                !node.isLane
                                && !node.isPhase && !node.isHeader) {
                                node.offsetX += offsetX;
                                node.offsetY += offsetY;
                                node.width += width;
                                node.height += height;
                                node.rotateAngle += rotateAngle;
                                this.diagram.nodePropertyChange(node, {}, {
                                    offsetX: node.offsetX, offsetY: node.offsetY,
                                    width: node.width, height: node.height, rotateAngle: node.rotateAngle
                                });
                                objects = objects.concat(this.diagram.spatialSearch.findObjects(actualObject.wrapper.outerBounds));
                            }
                        }
                    }
                }
            }
            else {
                if (object instanceof Connector) {
                    objects.push(object);
                }
                else if (object instanceof Selector && object.connectors.length) {
                    objects = objects.concat(object.connectors);
                }
                //EJ2-909180 - Line routing does not take place when drag and drop from symbol Palatte
                if (object instanceof Selector) {
                    if (this.diagram.nodes.indexOf(object.nodes[0]) !== -1) {
                        var node = actualObject || object.nodes[0];
                        if (node instanceof Node && node.shape.type !== 'SwimLane' && !checkParentAsContainer(this.diagram, node)
                            && !node.isLane && !node.isPhase && !node.isHeader) {
                            objects = objects.concat(this.diagram.spatialSearch.findObjects(node.wrapper.outerBounds));
                        }
                    }
                }
            }
            for (var i = 0; i < objects.length; i++) {
                if (objects[i] instanceof Connector && connectors.indexOf(objects[i].id) === -1) {
                    connectors.push(objects[i].id);
                }
            }
            if (connectors.length > 0 || this.diagram.routedConnectors.length > 0) {
                this.diagram.lineRoutingModule.renderVirtualRegion(this.diagram, true);
            }
            this.diagram.lineRoutingModule.skipObstacleCheck = true;
            for (var i = 0; i < this.diagram.routedConnectors.length; i++) {
                var connector = this.diagram.nameTable[this.diagram.routedConnectors[i]];
                this.ReRouteConnector(connector);
            }
            this.diagram.lineRoutingModule.skipObstacleCheck = false;
            for (var i = 0; i < connectors.length; i++) {
                var connector = this.diagram.nameTable[connectors[i]];
                if (this.diagram.routedConnectors.indexOf(connector.id) === -1) {
                    this.ReRouteConnector(connector);
                }
            }
            this.diagram.routedConnectors = [];
            //EJ2-908138 - Redo not working after move and undo the multi nodes while  line routing enabled
            //EJ2-925499 - Undo/Redo not working after move multiselected nodes inside swimlane while line routing enabled
            if (helperObject && actualObject && undoElement && this.diagram.eventHandler.currentAction === 'Drag') {
                var canAddHistory = false;
                var nameTable = this.diagram.nameTable;
                for (var i = 0; i < actualObject.nodes.length; i++) {
                    if (!(nameTable[actualObject.nodes[i].parentId] && nameTable[actualObject.nodes[i].parentId].isLane)) {
                        canAddHistory = true;
                    }
                }
                if (canAddHistory) {
                    var obj = cloneObject(actualObject);
                    this.diagram.startGroupAction();
                    var entry = {
                        type: 'PositionChanged',
                        redoObject: cloneObject(obj), undoObject: undoElement, category: 'Internal'
                    };
                    this.diagram.addHistoryEntry(entry);
                    this.diagram.endGroupAction();
                }
            }
            this.updateSelector();
            this.diagram.protectPropertyChange(false);
        }
    };
    /** @private */
    CommandHandler.prototype.drawSelectionRectangle = function (x, y, width, height) {
        this.diagram.drawSelectionRectangle(x, y, width, height);
    };
    /** @private */
    CommandHandler.prototype.ReRouteConnector = function (connector) {
        if (connector instanceof Connector && connector.type === 'Orthogonal') {
            // EJ2-65876 - Exception occurs on line routing injection module
            //Bug 850195: Exception occurs due to line routing constraints enabled
            if (connector.sourceID && connector.targetID && connector.sourceID != connector.targetID && this.diagram.layout.type !== 'ComplexHierarchicalTree') {
                //EJ2-69573 - Excecption occurs when calling doLayout method with the lineRouting module 
                var sourceNode = this.diagram.getObject(connector.sourceID);
                var targetNode = this.diagram.getObject(connector.targetID);
                var connectorLengthX = targetNode.offsetX > sourceNode.offsetX
                    ? targetNode.wrapper.outerBounds.middleLeft.x - sourceNode.wrapper.outerBounds.middleRight.x
                    : sourceNode.wrapper.outerBounds.middleLeft.x - targetNode.wrapper.outerBounds.middleRight.x;
                var connectorLengthY = targetNode.offsetY > sourceNode.offsetY
                    ? targetNode.wrapper.outerBounds.topCenter.y - sourceNode.wrapper.outerBounds.bottomCenter.y
                    : sourceNode.wrapper.outerBounds.topCenter.y - targetNode.wrapper.outerBounds.bottomCenter.y;
                if (connectorLengthX > 30 || connectorLengthY > 30) {
                    this.diagram.lineRoutingModule.refreshConnectorSegments(this.diagram, connector, true);
                }
            }
        }
    };
    /** @private */
    CommandHandler.prototype.startGroupAction = function () {
        this.diagram.startGroupAction();
    };
    /** @private */
    CommandHandler.prototype.endGroupAction = function () {
        this.diagram.endGroupAction();
    };
    /** @private */
    CommandHandler.prototype.removeChildFromBPmn = function (child, newTarget, oldTarget) {
        var obj = this.diagram.nameTable[child.id] || child.nodes[0];
        if (oldTarget) {
            if ((obj) && obj.processId && obj.processId === oldTarget.wrapper.id) {
                var node = cloneObject(obj);
                node.processId = obj.processId;
                // 908136: Node goes behind the subprocess and the connector connected to it is destroyed Issue Fix by commenting these lines
                // let edges: string[] = [];
                // edges = edges.concat((obj as Node).outEdges, (obj as Node).inEdges);
                // for (let i: number = edges.length - 1; i >= 0; i--) {
                //     const connector: ConnectorModel = this.diagram.nameTable[edges[i]];
                //     if (connector) {
                //         this.diagram.remove(connector);
                //     }
                // }
                var nodeCollection = (this.diagram.nameTable[obj.processId].shape.activity.subProcess.processes) || [];
                nodeCollection.splice(nodeCollection.indexOf((obj).id), 1);
                this.diagram.bpmnModule.removeChildFromBPMN(this.diagram.nameTable[obj.processId].wrapper, (obj).id, this.diagram);
                this.diagram.nameTable[(obj).id].processId = '';
                obj.offsetX = obj.wrapper.offsetX;
                obj.offsetY = obj.wrapper.offsetY;
                //909153: Removed the history entries as we have positionchange entry in mouseup
            }
        }
    };
    /** @private */
    CommandHandler.prototype.isDroppable = function (source, targetNodes) {
        var node = this.diagram.nameTable[source.id] || source.nodes[0];
        if (node instanceof Node) {
            if ((!isBlazor() && node.shape.shape === 'TextAnnotation')
            // ||(isBlazor() && (node.shape as DiagramShape).bpmnShape === 'TextAnnotation')
            ) {
                return true;
            }
            //848061 - Enabling BPMN Group Nodes to Function Like Subprocess Nodes
            if (targetNodes.shape.shape === 'Group') {
                targetNodes.shape.activity.subProcess.collapsed = false;
            }
            if (node && node.shape.type === 'Bpmn') {
                //905238 - Exception thrown while dropping BPMN shapes over a BPMN connector
                if ((node.processId === targetNodes.id) || (node.id === targetNodes.processId) ||
                    targetNodes.shape.type === 'Bpmn' && !(targetNodes instanceof Connector)
                        && targetNodes.shape.activity && targetNodes.shape.activity.subProcess
                        && targetNodes.shape.activity.subProcess.collapsed) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };
    /**
     * @private
     */
    CommandHandler.prototype.renderHighlighter = function (args, connectHighlighter, source) {
        var bounds = new Rect();
        if ((args.target instanceof Node || args.target instanceof Connector) || (connectHighlighter && (args.source instanceof Node || args.source instanceof Connector))) {
            var tgt = connectHighlighter ? args.source : args.target;
            var tgtWrap = connectHighlighter ? args.sourceWrapper : args.targetWrapper;
            var target = this.findTarget(tgtWrap, tgt, source, true);
            var element = void 0;
            if (target instanceof BpmnSubEvent) {
                var portId = target.id;
                var node = args.target;
                var parent_8 = node.wrapper.children[0].children[0].children[2];
                for (var _i = 0, _a = parent_8.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    if (child.id === node.id + '_' + portId) {
                        element = child.children[0];
                        break;
                    }
                }
            }
            else {
                element = (target instanceof Node) ?
                    target.wrapper : connectHighlighter ? args.sourceWrapper : args.targetWrapper;
            }
            if (element && !(target instanceof Connector)) {
                this.diagram.renderHighlighter(element);
            }
        }
    };
    //additional events
    /** @private */
    CommandHandler.prototype.mouseOver = function (source, target, position) {
        //mouse over
        //returns whether the source can move over the target or not
        return true;
    };
    /**
     * @private
     */
    CommandHandler.prototype.snapPoint = function (startPoint, endPoint, tx, ty) {
        var obj = this.diagram.selectedItems;
        var point;
        var towardsLeft = endPoint.x < startPoint.x;
        var towardsTop = endPoint.y < startPoint.y;
        point = { x: tx, y: ty };
        var snappedPoint = point;
        if (this.snappingModule && (((obj.nodes.length > 0) && (obj.nodes[0].constraints & NodeConstraints.Drag)) || ((obj.connectors.length > 0) && (obj.connectors[0].constraints & ConnectorConstraints.Drag)))) {
            snappedPoint = this.diagram.snappingModule.snapPoint(this.diagram, obj, towardsLeft, towardsTop, point, startPoint, endPoint);
        }
        return snappedPoint;
    };
    /**
     * @private
     */
    CommandHandler.prototype.removeSnap = function () {
        if ((this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject) && this.snappingModule) {
            this.snappingModule.removeGuidelines(this.diagram);
        }
    };
    /** @private */
    /**Bug(EJ2-62725): Exception occurs when drag and drop the connector inside the swimlane */
    CommandHandler.prototype.dropAnnotation = function (source, target) {
        if (source instanceof Node || source instanceof Selector) {
            var node = (source instanceof Node) ? source : source.nodes[0];
            if (this.diagram.bpmnModule && target.shape.type === 'Bpmn'
                && ((!isBlazor() && node.shape.shape === 'TextAnnotation')
                //  ||(isBlazor() && (node.shape as DiagramShape).bpmnShape === 'TextAnnotation')
                )) {
                var hasTarget = 'hasTarget';
                node[hasTarget] = target.id;
                node.shape.annotation.nodeId = target.id;
                if (!this.diagram.currentSymbol) {
                    this.diagram.addTextAnnotation(node.shape.annotation, target);
                    node.shape.annotation.nodeId = '';
                    this.diagram.remove(node);
                }
                this.diagram.refreshDiagramLayer();
            }
        }
    };
    /** @private */
    CommandHandler.prototype.drop = function (source, target, position) {
        //drop
        if (this.diagram.bpmnModule) {
            var nodesToProcess = (source instanceof Node) ? [source] : source.nodes;
            for (var i = 0; i < nodesToProcess.length; i++) {
                var node = nodesToProcess[i];
                //905238 - Exception thrown while dropping BPMN shapes over a BPMN connector
                if (node && node.shape.type === 'Bpmn' && target instanceof Node && target.shape.type === 'Bpmn'
                    && !(target instanceof Connector)) {
                    this.diagram.bpmnModule.dropBPMNchild(target, node, this.diagram);
                }
            }
            this.diagram.refreshDiagramLayer();
        }
    };
    /** @private */
    CommandHandler.prototype.addHistoryEntry = function (entry) {
        this.diagram.addHistoryEntry(entry);
    };
    /** @private */
    CommandHandler.prototype.align = function (objects, option, type) {
        if (objects.length > 0) {
            var i = 0;
            objects[0] = this.diagram.nameTable[objects[0].id] || objects[0];
            var bounds = (type === 'Object') ? getBounds(objects[0].wrapper) : this.diagram.selectedItems.wrapper.bounds;
            var undoObj = { nodes: [], connectors: [] };
            var redoObj = { nodes: [], connectors: [] };
            for (i = ((type === 'Object') ? (i + 1) : i); i < objects.length; i++) {
                var tx = 0;
                var ty = 0;
                objects[i] = this.diagram.nameTable[objects[i].id] || objects[i];
                var objectBounds = getBounds(objects[i].wrapper);
                if (option === 'Left') {
                    tx = bounds.left + objectBounds.width / 2 - objectBounds.center.x;
                }
                else if (option === 'Right') {
                    tx = bounds.right - objectBounds.width / 2 - objectBounds.center.x;
                }
                else if (option === 'Top') {
                    ty = bounds.top + objectBounds.height / 2 - objectBounds.center.y;
                }
                else if (option === 'Bottom') {
                    ty = bounds.bottom - objectBounds.height / 2 - objectBounds.center.y;
                }
                else if (option === 'Center') {
                    tx = bounds.center.x - objectBounds.center.x;
                }
                else if (option === 'Middle') {
                    ty = bounds.center.y - objectBounds.center.y;
                }
                undoObj = this.storeObject(undoObj, objects[i]);
                this.drag(objects[i], tx, ty);
                this.diagram.updateSelector();
                redoObj = this.storeObject(redoObj, objects[i]);
            }
            undoObj = cloneObject(undoObj);
            redoObj = cloneObject(redoObj);
            var entry = {
                type: 'Align', category: 'Internal',
                undoObject: cloneObject(undoObj), redoObject: cloneObject(redoObj)
            };
            this.addHistoryEntry(entry);
        }
    };
    /**
     * distribute method \
     *
     * @returns { void }     distribute method .\
     * @param {(NodeModel | ConnectorModel)[]} objects - provide the source value.
     * @param {SizingOptions} option - provide the target value.
     *
     * @private
     */
    CommandHandler.prototype.distribute = function (objects, option) {
        if (objects.length > 0) {
            var i = 0;
            //const j: number = 0;
            //const rect: Rect = new Rect();
            //const b: Rect[] = [];
            //let temp: NodeModel | ConnectorModel;
            var right = 0;
            var left = 0;
            var top_3 = 0;
            var bottom = 0;
            var center = 0;
            var middle = 0;
            var btt = 0;
            var rtl = 0;
            //const sum: number = 0;
            var undoSelectorObj = { nodes: [], connectors: [] };
            var redoSelectorObj = { nodes: [], connectors: [] };
            for (i = 0; i < objects.length; i++) {
                objects[i] = this.diagram.nameTable[objects[i].id] || objects[i];
            }
            objects = sort(objects, option);
            for (i = 1; i < objects.length; i++) {
                right = right + objects[i].wrapper.bounds.topRight.x - objects[i - 1].wrapper.bounds.topRight.x;
                left = left + objects[i].wrapper.bounds.topLeft.x - objects[i - 1].wrapper.bounds.topLeft.x;
                top_3 = top_3 + objects[i].wrapper.bounds.topRight.y - objects[i - 1].wrapper.bounds.topRight.y;
                bottom = bottom + objects[i].wrapper.bounds.bottomRight.y - objects[i - 1].wrapper.bounds.bottomRight.y;
                center = center + objects[i].wrapper.bounds.center.x - objects[i - 1].wrapper.bounds.center.x;
                middle = middle + objects[i].wrapper.bounds.center.y - objects[i - 1].wrapper.bounds.center.y;
                btt = btt + objects[i].wrapper.bounds.topRight.y - objects[i - 1].wrapper.bounds.bottomRight.y;
                rtl = rtl + objects[i].wrapper.bounds.middleLeft.x - objects[i - 1].wrapper.bounds.middleRight.x;
            }
            for (i = 1; i < objects.length - 1; i++) {
                var tx = 0;
                var ty = 0;
                var prev = getBounds(objects[i - 1].wrapper);
                var current = getBounds(objects[i].wrapper);
                if (option === 'Center') {
                    tx = prev.center.x - current.center.x + (center / (objects.length - 1));
                }
                else if (option === 'RightToLeft') {
                    // 926115: Distribute command RightToLeft option works incorrectly
                    tx = prev.middleRight.x - current.middleLeft.x + (rtl / (objects.length - 1));
                }
                else if (option === 'Right') {
                    tx = prev.topRight.x - current.topRight.x + (right / (objects.length - 1));
                }
                else if (option === 'Left') {
                    tx = prev.topLeft.x - current.topLeft.x + (left / (objects.length - 1));
                }
                else if (option === 'Middle') {
                    ty = prev.center.y - current.center.y + (middle / (objects.length - 1));
                }
                else if (option === 'Top') {
                    ty = prev.topRight.y - current.topRight.y + (top_3 / (objects.length - 1));
                }
                else if (option === 'Bottom') {
                    ty = prev.bottomRight.y - current.bottomRight.y + (bottom / (objects.length - 1));
                }
                else if (option === 'BottomToTop') {
                    ty = prev.bottomRight.y - current.topRight.y + (btt / (objects.length - 1));
                }
                undoSelectorObj = this.storeObject(undoSelectorObj, objects[i]);
                this.drag(objects[i], tx, ty);
                this.diagram.updateSelector();
                redoSelectorObj = this.storeObject(redoSelectorObj, objects[i]);
            }
            undoSelectorObj = cloneObject(undoSelectorObj);
            redoSelectorObj = cloneObject(redoSelectorObj);
            var entry = {
                type: 'Distribute', category: 'Internal',
                undoObject: cloneObject(undoSelectorObj), redoObject: cloneObject(redoSelectorObj)
            };
            this.addHistoryEntry(entry);
        }
    };
    /* eslint-enable */
    /**
     * sameSize method \
     *
     * @returns { void }     sameSize method .\
     * @param {(NodeModel | ConnectorModel)[]} objects - provide the source value.
     * @param {SizingOptions} option - provide the target value.
     *
     * @private
     */
    CommandHandler.prototype.sameSize = function (objects, option) {
        if (objects.length > 0) {
            var i = 0;
            //let pivot: PointModel;
            var pivot = { x: 0.5, y: 0.5 };
            objects[0] = this.diagram.nameTable[objects[0].id] || objects[0];
            var bounds = getBounds(objects[0].wrapper);
            var undoObject = { nodes: [], connectors: [] };
            var redoObject = { nodes: [], connectors: [] };
            for (i = 1; i < objects.length; i++) {
                objects[parseInt(i.toString(), 10)] = this.diagram.nameTable[objects[parseInt(i.toString(), 10)].id] || objects[0];
                var rect = getBounds(objects[parseInt(i.toString(), 10)].wrapper);
                var sw = 1;
                var sh = 1;
                if (option === 'Width') {
                    sw = bounds.width / rect.width;
                }
                else if (option === 'Height') {
                    sh = bounds.height / rect.height;
                }
                else if (option === 'Size') {
                    sw = bounds.width / rect.width;
                    sh = bounds.height / rect.height;
                }
                undoObject = this.storeObject(undoObject, objects[parseInt(i.toString(), 10)]);
                this.scale(objects[parseInt(i.toString(), 10)], sw, sh, pivot);
                redoObject = this.storeObject(redoObject, objects[parseInt(i.toString(), 10)]);
            }
            this.diagram.updateSelector();
            undoObject = cloneObject(undoObject);
            redoObject = cloneObject(redoObject);
            var entry = {
                type: 'Sizing', category: 'Internal',
                undoObject: cloneObject(undoObject), redoObject: cloneObject(redoObject)
            };
            this.addHistoryEntry(entry);
        }
    };
    CommandHandler.prototype.storeObject = function (selectorObject, obj) {
        if (obj instanceof Node) {
            selectorObject.nodes.push(cloneObject(obj));
        }
        else {
            selectorObject.connectors.push(cloneObject(obj));
        }
        return selectorObject;
    };
    /**
     * updatePanState method \
     *
     * @returns { any }     updatePanState method .\
     * @param {number} eventCheck - provide the eventCheck value.
     *
     * @private
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CommandHandler.prototype.updatePanState = function (eventCheck) {
        if (eventCheck) {
            this.diagram.realActions = this.diagram.realActions | RealAction.PanInProgress;
        }
        else {
            this.diagram.dataBind();
            var diagramScrollSettings = this.diagram.scrollSettings;
            this.diagram.realActions = this.diagram.realActions & ~RealAction.PanInProgress;
            var Values = {
                VerticalOffset: diagramScrollSettings.verticalOffset, HorizontalOffset: diagramScrollSettings.horizontalOffset,
                ViewportHeight: diagramScrollSettings.viewPortHeight, ViewportWidth: diagramScrollSettings.viewPortWidth,
                CurrentZoom: diagramScrollSettings.currentZoom
            };
            var arg = {
                oldValue: Values,
                newValue: Values, source: this.diagram, panState: 'Completed'
            };
            this.triggerEvent(DiagramEvent.scrollChange, arg);
        }
    };
    /**
     * dataBinding method \
     *
     * @returns { void }     dataBinding method .\
     *
     * @private
     */
    CommandHandler.prototype.dataBinding = function () {
        this.diagram.dataBind();
    };
    CommandHandler.prototype.setBlazorDiagramProps = function (arg) {
        this.diagram.setBlazorDiagramProps(arg);
    };
    /**
     * scroll method \
     *
     * @returns { void }     scroll method .\
     * @param {number} scrollX - provide the source value.
     * @param {number} scrollY - provide the target value.
     * @param {PointModel} focusPoint - provide the layoutOrientation value.
     *
     * @private
     */
    CommandHandler.prototype.scroll = function (scrollX, scrollY, focusPoint) {
        var panx = canPanX(this.diagram);
        var pany = canPanY(this.diagram);
        var canPan = true;
        this.diagram.pan((scrollX = panx ? scrollX : 0) * this.diagram.scroller.currentZoom, (scrollY = pany ? scrollY : 0) * this.diagram.scroller.currentZoom, focusPoint, canPan);
    };
    /**
     * drawHighlighter method \
     *
     * @returns { NodeModel | ConnectorModel }     drawHighlighter method .\
     * @param {IElement} element - provide the element value.
     *
     * @private
     */
    CommandHandler.prototype.drawHighlighter = function (element) {
        this.diagram.renderHighlighter(element.wrapper);
    };
    /**
     * removeHighlighter method \
     *
     * @returns { void }     removeHighlighter method .\
     *
     * @private
     */
    CommandHandler.prototype.removeHighlighter = function () {
        this.diagram.clearHighlighter();
    };
    /**
     * renderContainerHelper method \
     *
     * @returns { NodeModel | ConnectorModel }     renderContainerHelper method .\
     * @param {NodeModel | SelectorModel | ConnectorModel} node - provide the parent value.
     *
     * @private
     */
    CommandHandler.prototype.renderContainerHelper = function (node) {
        return renderContainerHelper(this.diagram, node);
    };
    /**
     * isParentAsContainer method \
     *
     * @returns { boolean }     isParentAsContainer method .\
     * @param {NodeModel} node - provide the parent value.
     * @param {boolean} isChild - provide the target value.
     *
     * @private
     */
    CommandHandler.prototype.isParentAsContainer = function (node, isChild) {
        return checkParentAsContainer(this.diagram, node, isChild);
    };
    /**
     * @returns { boolean } isParentAsContainer method .\
     * @param {NodeModel} node - provide the target Node value.
     * @private
     */
    CommandHandler.prototype.isTargetSubProcess = function (node) {
        if (node && node.shape && node.shape.type === 'Bpmn' && node.shape.activity && node.shape.activity.activity === 'SubProcess') {
            return true;
        }
        return false;
    };
    /**
     * dropChildToContainer method \
     *
     * @returns { void }     dropChildToContainer method .\
     * @param {NodeModel} parent - provide the parent value.
     * @param {NodeModel} node - provide the target value.
     *
     * @private
     */
    CommandHandler.prototype.dropChildToContainer = function (parent, node) {
        if (!(this.diagram.diagramActions & DiagramAction.PreventLaneContainerUpdate)) {
            addChildToContainer(this.diagram, parent, node);
            if (node.hasTextAnnotation) {
                for (var i = 0; i < node.outEdges.length; i++) {
                    var con = this.diagram.nameTable[node.outEdges[parseInt(i.toString(), 10)]];
                    if (con.isBpmnAnnotationConnector) {
                        var annotationNode = this.diagram.nameTable[con.targetID];
                        addChildToContainer(this.diagram, parent, annotationNode);
                    }
                }
            }
        }
    };
    /**
     * @returns { void }     updateLaneChildrenZindex method .\
     * @param {NodeModel} node - provide the node value.
     * @param {IElement} target - provide the target value.
     * @private
     */
    CommandHandler.prototype.updateLaneChildrenZindex = function (node, target) {
        var lowerIndexobject = this.findLeastIndexObject(node, target);
        var swimlane = this.diagram.nameTable[target.parentId];
        if (swimlane && swimlane.zIndex > lowerIndexobject.zIndex) {
            var layerIndex = this.diagram.layers.indexOf(this.diagram.getActiveLayer());
            var layerZIndexTable = this.diagram.layers[parseInt(layerIndex.toString(), 10)].zIndexTable;
            var tempTable = JSON.parse(JSON.stringify(layerZIndexTable));
            var startIndex = lowerIndexobject.zIndex;
            var endIndex = swimlane.zIndex;
            for (var i = endIndex; i >= startIndex; i--) {
                if (startIndex !== i) {
                    if (!layerZIndexTable[i - 1]) {
                        layerZIndexTable[i - 1] = layerZIndexTable[parseInt(i.toString(), 10)];
                        this.diagram.nameTable[layerZIndexTable[i - 1]].zIndex = i;
                        delete layerZIndexTable[parseInt(i.toString(), 10)];
                    }
                    else {
                        //bringing the objects forward
                        layerZIndexTable[parseInt(i.toString(), 10)] = layerZIndexTable[i - 1];
                        this.diagram.nameTable[layerZIndexTable[parseInt(i.toString(), 10)]].zIndex = i;
                    }
                }
                else {
                    var tempIndex = this.swapZIndexObjects(endIndex, layerZIndexTable, swimlane.id, tempTable);
                }
            }
            if (this.diagram.mode === 'SVG') {
                this.moveSvgNode(target.parentId, lowerIndexobject.id);
                this.updateNativeNodeIndex(target.parentId, lowerIndexobject.id);
            }
            else {
                this.diagram.refreshCanvasLayers();
            }
        }
    };
    CommandHandler.prototype.findLeastIndexConnector = function (edges, target, index) {
        for (var i = 0; i < edges.length; i++) {
            var connector = this.diagram.nameTable[edges[parseInt(i.toString(), 10)]];
            if (index.zIndex > connector.zIndex) {
                index = connector;
            }
        }
        return index;
    };
    CommandHandler.prototype.findLeastIndexObject = function (node, target) {
        var lowerIndexobject = node;
        if (node instanceof Node) {
            lowerIndexobject = this.findLeastIndexConnector(node.inEdges, target, lowerIndexobject);
            lowerIndexobject = this.findLeastIndexConnector(node.outEdges, target, lowerIndexobject);
        }
        return lowerIndexobject;
    };
    /**
     * checkSelection method \
     *
     * @returns { void }     checkSelection method .\
     * @param {SelectorModel} selector - provide the source value.
     * @param {string} corner - provide the target value.
     *
     * @private
     */
    CommandHandler.prototype.checkSelection = function (selector, corner) {
        var node; // let wrapper: GridPanel; let child: Container; let index: number; let shape: SwimLaneModel;
        if (selector.nodes.length === 1 && selector.connectors.length === 0) {
            if (checkParentAsContainer(this.diagram, selector.nodes[0], true)) {
                node = (selector.nodes[0].shape === 'SwimLane') ? selector.nodes[0] :
                    this.diagram.nameTable[selector.nodes[0].parentId];
                var child = selector.nodes[0];
                if (node.shape.type === 'SwimLane') {
                    var orientation_1 = (node.shape.orientation === 'Horizontal') ? true : false;
                    if ((child.isPhase && ((orientation_1 && corner === 'ResizeSouth') || (!orientation_1 && corner === 'ResizeEast'))) ||
                        (child.isLane && ((orientation_1 && corner === 'ResizeEast') || (!orientation_1 && corner === 'ResizeSouth')))) {
                        swimLaneSelection(this.diagram, node, corner);
                    }
                }
                else if (node.container.type === 'Grid') {
                    if (((node.container.orientation === 'Horizontal' && child.rowIndex === 1) ||
                        (node.container.orientation === 'Vertical' && child.rowIndex > 0 && child.columnIndex > 0))) {
                        if (corner === 'ResizeSouth') {
                            for (var i = 0; i < this.diagram.nodes.length; i++) {
                                var obj = this.diagram.nodes[parseInt(i.toString(), 10)];
                                if (obj.rowIndex === node.rows.length - 1 && obj.columnIndex === 0) {
                                    this.select(obj);
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        if (corner === 'ResizeEast') {
                            for (var i = 0; i < this.diagram.nodes.length; i++) {
                                var obj = this.diagram.nodes[parseInt(i.toString(), 10)];
                                if (obj.rowIndex === 1 && obj.columnIndex === node.columns.length - 1) {
                                    this.select(obj);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            else {
                swimLaneSelection(this.diagram, selector.nodes[0], corner);
            }
        }
    };
    /**
     * zoom method \
     *
     * @returns { void }     zoom method .\
     * @param {number} scale - provide the source value.
     * @param {number} scrollX - provide the target value.
     * @param {number} scrollY - provide the layoutOrientation value.
     * @param {PointModel} focusPoint - provide the layoutOrientation value.
     *
     * @private
     */
    CommandHandler.prototype.zoom = function (scale, scrollX, scrollY, focusPoint) {
        this.diagram.scroller.zoom(scale, scrollX * this.diagram.scroller.currentZoom, scrollY * this.diagram.scroller.currentZoom, focusPoint);
    };
    return CommandHandler;
}());

/**
 */
var DiagramScroller = /** @class */ (function () {
    function DiagramScroller(diagram) {
        /** @private */
        this.transform = { tx: 0, ty: 0, scale: 1 };
        /**   @private  */
        this.oldCollectionObjects = [];
        /**   @private  */
        this.removeCollection = [];
        this.vPortWidth = 0;
        this.vPortHeight = 0;
        this.currentZoomFActor = 1;
        this.hOffset = 0;
        this.vOffset = 0;
        this.scrolled = false;
        this.hScrollSize = 0;
        this.vScrollSize = 0;
        this.diagram = diagram;
        this.objects = [];
        this.transform = diagram.scroller ? diagram.scroller.transform : { tx: 0, ty: 0, scale: 1 };
        this.vPortWidth = diagram.scrollSettings.viewPortWidth;
        this.vPortHeight = diagram.scrollSettings.viewPortHeight;
        this.currentZoomFActor = diagram.scrollSettings.currentZoom;
        this.hOffset = diagram.scrollSettings.horizontalOffset;
        this.vOffset = diagram.scrollSettings.verticalOffset;
    }
    Object.defineProperty(DiagramScroller.prototype, "viewPortHeight", {
        /**
         * verticalOffset method \
         *
         * @returns { number }     verticalOffset method .\
         *
         * @private
         */
        get: function () {
            return this.vPortHeight;
        },
        /**
         * verticalOffset method \
         *
         * @returns { void }     verticalOffset method .\
         * @param {number} offset - provide the hOffset value.
         *
         * @private
         */
        set: function (offset) {
            this.vPortHeight = offset;
            this.diagram.scrollSettings.viewPortHeight = offset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiagramScroller.prototype, "currentZoom", {
        /**
         * verticalOffset method \
         *
         * @returns { number }     verticalOffset method .\
         *
         * @private
         */
        get: function () {
            return this.currentZoomFActor || 1;
        },
        /**
         * verticalOffset method \
         *
         * @returns { void }     verticalOffset method .\
         * @param {number} offset - provide the hOffset value.
         *
         * @private
         */
        set: function (offset) {
            this.currentZoomFActor = offset;
            this.diagram.scrollSettings.currentZoom = offset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiagramScroller.prototype, "viewPortWidth", {
        /**
         * verticalOffset method \
         *
         * @returns { number }     verticalOffset method .\
         *
         * @private
         */
        get: function () {
            return this.vPortWidth;
        },
        /**
         * verticalOffset method \
         *
         * @returns { void }     verticalOffset method .\
         * @param {number} offset - provide the hOffset value.
         *
         * @private
         */
        set: function (offset) {
            this.vPortWidth = offset;
            this.diagram.scrollSettings.viewPortWidth = offset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiagramScroller.prototype, "horizontalOffset", {
        /**
         * verticalOffset method \
         *
         * @returns { number }     verticalOffset method .\
         *
         * @private
         */
        get: function () {
            return this.hOffset;
        },
        /**
         * verticalOffset method \
         *
         * @returns { void }     verticalOffset method .\
         * @param {number} offset - provide the hOffset value.
         *
         * @private
         */
        set: function (offset) {
            this.hOffset = offset;
            if (Math.abs(this.hOffset - this.diagram.scrollSettings.horizontalOffset) > 1) {
                this.diagram.realActions = this.diagram.realActions | RealAction.hScrollbarMoved;
                this.scrolled = true;
            }
            this.diagram.scrollSettings.horizontalOffset = offset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiagramScroller.prototype, "verticalOffset", {
        /**
         * verticalOffset method \
         *
         * @returns { number }     verticalOffset method .\
         *
         * @private
         */
        get: function () {
            return this.vOffset;
        },
        /**
         * verticalOffset method \
         *
         * @returns { void }     verticalOffset method .\
         * @param {number} offset - provide the hOffset value.
         *
         * @private
         */
        set: function (offset) {
            this.vOffset = offset;
            if (Math.abs(this.vOffset - this.diagram.scrollSettings.verticalOffset) > 1) {
                this.diagram.realActions = this.diagram.realActions | RealAction.vScrollbarMoved;
                this.scrolled = true;
            }
            this.diagram.scrollSettings.verticalOffset = offset;
        },
        enumerable: true,
        configurable: true
    });
    // Method added to get bounds value if diagram is loaded from negative axis.
    // SF-359118 implemented for this ticket requirement.
    DiagramScroller.prototype.getBounds = function () {
        var pageBounds;
        var postion = this.diagram.spatialSearch.getPageBounds(0, 0);
        if ((postion.x < 0 || postion.y < 0) && !this.diagram.pageSettings.multiplePage) {
            pageBounds = this.getPageBounds(undefined, undefined, true, true);
        }
        else {
            pageBounds = this.getPageBounds(undefined, undefined, true);
        }
        return pageBounds;
    };
    /**
     * updateScrollOffsets method \
     *
     * @returns { void }     updateScrollOffsets method .\
     * @param {number} hOffset - provide the hOffset value.
     * @param {number} vOffset - provide the vOffset value.
     *
     * @private
     */
    DiagramScroller.prototype.updateScrollOffsets = function (hOffset, vOffset) {
        var offsetX = 0;
        var offsetY = 0;
        var pageBounds = this.getBounds();
        pageBounds.x *= this.currentZoom;
        pageBounds.y *= this.currentZoom;
        pageBounds.width *= this.currentZoom;
        pageBounds.height *= this.currentZoom;
        offsetX = Math.max(0, hOffset - pageBounds.left);
        offsetY = Math.max(0, vOffset - pageBounds.top);
        if (hOffset !== undefined && vOffset !== undefined) {
            this.horizontalOffset = offsetX;
            this.verticalOffset = offsetY;
            this.diagram.setOffset(offsetX, offsetY);
        }
        else {
            this.diagram.setOffset(-this.horizontalOffset - pageBounds.x, -this.verticalOffset - pageBounds.y);
        }
        this.transform = {
            tx: Math.max(this.horizontalOffset, -pageBounds.left) / this.currentZoom, ty: Math.max(this.verticalOffset, -pageBounds.top) / this.currentZoom,
            scale: this.currentZoom
        };
    };
    /**
     * setScrollOffset method \
     *
     * @returns { void }     setScrollOffset method .\
     * @param {number} hOffset - provide the hOffset value.
     * @param {number} vOffset - provide the vOffset value.
     *
     * @private
     */
    DiagramScroller.prototype.setScrollOffset = function (hOffset, vOffset) {
        this.scrolled = false;
        var pageBounds = this.getBounds();
        pageBounds.x *= this.currentZoom;
        pageBounds.y *= this.currentZoom;
        pageBounds.width *= this.currentZoom;
        pageBounds.height *= this.currentZoom;
        var x = -pageBounds.left;
        var y = -pageBounds.top;
        var set = false;
        var viewWidth = this.viewPortWidth * this.currentZoom;
        var viewHeight = this.viewPortHeight * this.currentZoom;
        var newX = x - hOffset;
        if (newX !== this.horizontalOffset) {
            if (x < this.horizontalOffset) {
                if (this.horizontalOffset > newX) {
                    this.horizontalOffset -= hOffset;
                }
                else {
                    this.horizontalOffset = newX;
                }
                set = true;
            }
            var right = Math.max(pageBounds.right + this.vScrollSize, viewWidth);
            if (!set && right < -newX + this.viewPortWidth) {
                var actualRight = -newX + viewWidth - this.vScrollSize;
                var currentRight = -this.horizontalOffset + viewWidth - this.vScrollSize;
                if (actualRight < currentRight) {
                    //define
                    this.horizontalOffset = newX;
                }
                else {
                    if (actualRight - pageBounds.right > actualRight - currentRight) {
                        this.horizontalOffset = newX;
                    }
                    else {
                        this.horizontalOffset = -(pageBounds.right + this.vScrollSize - viewWidth);
                    }
                }
                set = true;
            }
            if (!set) {
                this.horizontalOffset = x - hOffset;
            }
        }
        set = false;
        //vertical offset
        var newY = y - vOffset;
        if (newY !== this.verticalOffset) {
            if (y < this.verticalOffset) {
                if (this.verticalOffset > newY) {
                    this.verticalOffset -= vOffset;
                }
                else {
                    this.verticalOffset = newY;
                }
                set = true;
            }
            var bottom = Math.max(pageBounds.bottom + this.hScrollSize, viewHeight);
            if (!set && bottom < -newY + viewHeight) {
                var actualBottom = -newY + viewHeight - this.hScrollSize;
                var currentBottom = -this.verticalOffset + viewHeight - this.hScrollSize;
                if (actualBottom < currentBottom) {
                    //define
                    this.verticalOffset = newY;
                }
                else {
                    if (actualBottom - pageBounds.bottom > actualBottom - currentBottom) {
                        this.verticalOffset = newY;
                    }
                    else {
                        this.verticalOffset = -(pageBounds.bottom + this.hScrollSize - viewHeight);
                    }
                }
                set = true;
            }
            if (!set) {
                this.verticalOffset = y - vOffset;
            }
        }
        this.transform = {
            tx: Math.max(this.horizontalOffset, -pageBounds.left) / this.currentZoom, ty: Math.max(this.verticalOffset, -pageBounds.top) / this.currentZoom,
            scale: this.currentZoom
        };
        this.setSize();
    };
    /**
     * getObjects \
     *
     * @returns { string[] }     To get page pageBounds.\
     * @param {string[]} coll1 - provide the source value.
     * @param {string[]} coll2 - provide the source value.
     * @private
     */
    DiagramScroller.prototype.getObjects = function (coll1, coll2) {
        var objects = [];
        for (var i = 0; i < coll1.length; i++) {
            var isExist = false;
            for (var j = 0; j < coll2.length; j++) {
                if (coll1[parseInt(i.toString(), 10)] === coll2[parseInt(j.toString(), 10)]) {
                    isExist = true;
                    break;
                }
            }
            if (!isExist) {
                objects.push(coll1[parseInt(i.toString(), 10)]);
            }
        }
        return objects;
    };
    /**
     * virtualizeElements \
     *
     * @returns { void }     To get page pageBounds.\
     *
     * @private
     */
    DiagramScroller.prototype.virtualizeElements = function () {
        var viewWidth = this.viewPortWidth / this.currentZoom;
        var viewHeight = this.viewPortHeight / this.currentZoom;
        var oObjects = this.diagram.spatialSearch.findObjects(new Rect(-this.horizontalOffset / this.currentZoom, -this.verticalOffset / this.currentZoom, viewWidth, viewHeight));
        var oObjectsID = [];
        var renderOrder = [];
        for (var j = 0; j < oObjects.length; j++) {
            var bpmnShape = oObjects[parseInt(j.toString(), 10)].shape;
            if (bpmnShape.type === 'Bpmn' && bpmnShape && bpmnShape.activity && bpmnShape.activity.subProcess && bpmnShape.activity.subProcess.processes && bpmnShape.activity.subProcess.processes.length > 0) {
                for (var k = 0; k < bpmnShape.activity.subProcess.processes.length; k++) {
                    renderOrder.push(bpmnShape.activity.subProcess.processes[parseInt(k.toString(), 10)]);
                }
                renderOrder.push(oObjects[parseInt(j.toString(), 10)].id);
            }
            else if (oObjects[parseInt(j.toString(), 10)].processId === '' || oObjects[parseInt(j.toString(), 10)].processId === undefined) {
                renderOrder.push(oObjects[parseInt(j.toString(), 10)].id);
            }
        }
        oObjectsID = renderOrder;
        var zindexOrder = [];
        for (var j = 0; j < oObjects.length; j++) {
            var items = oObjects[parseInt(j.toString(), 10)].shape;
            if (items.type === 'Bpmn' && items && items.activity && items.activity.subProcess && items.activity.subProcess.processes && items.activity.subProcess.processes.length > 0) {
                zindexOrder.push(oObjects[parseInt(j.toString(), 10)].id);
                for (var t = 0; t < items.activity.subProcess.processes.length; t++) {
                    zindexOrder.push(items.activity.subProcess.processes[parseInt(t.toString(), 10)]);
                }
            }
            else if (oObjects[parseInt(j.toString(), 10)].processId === '' || oObjects[parseInt(j.toString(), 10)].processId === undefined) {
                zindexOrder.push(oObjects[parseInt(j.toString(), 10)].id);
            }
        }
        for (var j = 0; j < oObjects.length; j++) {
            for (var k = 0; k < zindexOrder.length; k++) {
                if (oObjects[parseInt(j.toString(), 10)].id === zindexOrder[parseInt(k.toString(), 10)]) {
                    oObjects[parseInt(j.toString(), 10)].zIndex = k;
                    break;
                }
            }
        }
        var newObjects = this.getObjects(oObjectsID, this.oldCollectionObjects);
        if (this.oldCollectionObjects.length === 0) {
            this.oldCollectionObjects = oObjectsID;
        }
        var removeObjects = this.getObjects(this.oldCollectionObjects, oObjectsID);
        this.diagram.updateVirtualObjects(newObjects, false, removeObjects);
        this.oldCollectionObjects = oObjectsID;
    };
    /**
     * setSize \
     *
     * @returns { void }     To get page pageBounds.\
     * @param {PointModel} newOffset - provide the newOffset value.
     *
     * @private
     */
    DiagramScroller.prototype.setSize = function (newOffset) {
        var pageBounds = this.getPageBounds(undefined, undefined, true);
        pageBounds.x *= this.currentZoom;
        pageBounds.y *= this.currentZoom;
        pageBounds.width *= this.currentZoom;
        pageBounds.height *= this.currentZoom;
        var x = Math.min(pageBounds.x, -this.horizontalOffset);
        var y = Math.min(pageBounds.y, -this.verticalOffset);
        var difX = -this.horizontalOffset + this.viewPortWidth - pageBounds.right;
        var difY = -this.verticalOffset + this.viewPortHeight - pageBounds.bottom;
        var hScrollSize = this.scrollerWidth;
        var vScrollSize = this.scrollerWidth;
        if (-this.verticalOffset <= pageBounds.y && -this.verticalOffset + this.viewPortHeight >= pageBounds.bottom) {
            vScrollSize = 0;
        }
        if (-this.horizontalOffset <= pageBounds.x && -this.horizontalOffset + this.viewPortWidth >= pageBounds.right) {
            hScrollSize = 0;
        }
        this.hScrollSize = hScrollSize;
        this.vScrollSize = vScrollSize;
        var oldWidth = this.diagramWidth;
        var oldHeight = this.diagramHeight;
        this.diagramWidth = Math.max(pageBounds.right, -this.horizontalOffset + this.viewPortWidth - vScrollSize) - x;
        this.diagramHeight = Math.max(pageBounds.bottom, -this.verticalOffset + this.viewPortHeight - hScrollSize) - y;
        if ((oldWidth !== this.diagramWidth || oldHeight !== this.diagramHeight) && this.diagram.scrollSettings.scrollLimit !== 'Diagram') {
            this.diagram.setSize(this.diagramWidth, this.diagramHeight);
        }
        if (this.diagram.scrollSettings.scrollLimit === 'Diagram') {
            if ((oldWidth !== this.diagramWidth || oldHeight !== this.diagramHeight || this.currentZoom !== 1)
                && ((!this.diagram.diagramActions || !newOffset) || (this.diagram.diagramActions && newOffset &&
                    ((this.verticalOffset !== 0 || this.verticalOffset === newOffset.y) &&
                        (this.horizontalOffset !== 0 || this.horizontalOffset === newOffset.x))))) {
                if ((this.diagram.scrollActions & ScrollActions.Interaction) && newOffset) {
                    this.transform = {
                        tx: Math.max(newOffset.x, -(pageBounds.left / this.currentZoom)) / this.currentZoom,
                        ty: Math.max(newOffset.y, -(pageBounds.top / this.currentZoom)) / this.currentZoom,
                        scale: this.currentZoom
                    };
                    this.horizontalOffset = newOffset.x;
                    this.verticalOffset = newOffset.y;
                }
                this.diagram.setSize(this.diagramWidth, this.diagramHeight);
                if ((!(this.diagram.scrollActions & ScrollActions.PropertyChange)) && newOffset) {
                    this.horizontalOffset = newOffset.x;
                    this.verticalOffset = newOffset.y;
                    this.transform = {
                        tx: Math.max(newOffset.x, -pageBounds.left) / this.currentZoom,
                        ty: Math.max(newOffset.y, -pageBounds.top) / this.currentZoom,
                        scale: this.currentZoom
                    };
                }
            }
            else if (newOffset && oldWidth === this.diagramWidth && oldHeight === this.diagramHeight &&
                ((this.diagram.diagramCanvas.scrollHeight > this.viewPortHeight &&
                    newOffset.y < 0 && this.horizontalOffset === newOffset.x && this.verticalOffset === 0) ||
                    (this.diagram.diagramCanvas.scrollWidth > this.viewPortWidth &&
                        newOffset.x < 0 && this.verticalOffset === newOffset.y && this.horizontalOffset === 0))) {
                this.verticalOffset = newOffset.y;
                this.horizontalOffset = newOffset.x;
                this.transform = {
                    tx: Math.max(newOffset.x, -pageBounds.left) / this.currentZoom,
                    ty: Math.max(newOffset.y, -pageBounds.top) / this.currentZoom,
                    scale: this.currentZoom
                };
            }
        }
        this.diagram.transformLayers();
        this.diagram.element.style.overflow = 'hidden';
    };
    /**
     * setViewPortSize \
     *
     * @returns { void }     To get page pageBounds.\
     * @param {number} width - provide the factor value.
     * @param {number} height - provide the factor value.
     *
     * @private
     */
    DiagramScroller.prototype.setViewPortSize = function (width, height) {
        this.viewPortWidth = width;
        this.viewPortHeight = height;
    };
    /**
     * To get page pageBounds \
     *
     * @returns { Rect }     To get page pageBounds.\
     * @param {boolean} boundingRect - provide the factor value.
     * @param {DiagramRegions} region - provide the factor value.
     * @param {boolean} hasPadding - provide the factor value.
     * @param {boolean} isnegativeRegion - provide the isnegativeRegion value.
     *
     * @private
     */
    DiagramScroller.prototype.getPageBounds = function (boundingRect, region, hasPadding, isnegativeRegion) {
        var rect = new Rect();
        var pageBounds;
        if (region !== 'Content' && !isnegativeRegion && this.diagram.pageSettings.width !== null && this.diagram.pageSettings.height !== null) {
            var width = this.diagram.pageSettings.width;
            var height = this.diagram.pageSettings.height;
            var negwidth = 0;
            var negheight = 0;
            if (this.diagram.pageSettings.multiplePage) {
                rect = this.diagram.spatialSearch.getPageBounds(0, 0);
                if (rect.right > width) {
                    var x = Math.ceil(rect.right / width);
                    width = width * x;
                }
                if (rect.bottom > height) {
                    var x = Math.ceil(rect.bottom / height);
                    height = height * x;
                }
                if (rect.left < 0 && Math.abs(rect.left) > negwidth) {
                    var x = Math.ceil(Math.abs(rect.left) / this.diagram.pageSettings.width);
                    negwidth = this.diagram.pageSettings.width * x;
                }
                if (rect.top < 0 && Math.abs(rect.top) > negheight) {
                    var x = Math.ceil(Math.abs(rect.top) / this.diagram.pageSettings.height);
                    negheight = this.diagram.pageSettings.height * x;
                }
            }
            pageBounds = new Rect((-negwidth), (-negheight), width + negwidth, height + negheight);
        }
        else {
            var origin_1 = boundingRect ? undefined : 0;
            pageBounds = this.diagram.spatialSearch.getPageBounds(origin_1, origin_1);
        }
        if (hasPadding) {
            var scrollpadding = this.diagram.scrollSettings.padding;
            pageBounds.x -= scrollpadding.left;
            pageBounds.y -= scrollpadding.top;
            pageBounds.width += (scrollpadding.left + scrollpadding.right);
            pageBounds.height += (scrollpadding.top + scrollpadding.bottom);
        }
        return pageBounds;
    };
    /**
     * To get page break when PageBreak is set as true \
     *
     * @returns { Segment[] }     To get page break when PageBreak is set as true.\
     * @param {Rect} pageBounds - provide the factor value.
     *
     * @private
     */
    DiagramScroller.prototype.getPageBreak = function (pageBounds) {
        var i = 0;
        var j = 0;
        var v = -1;
        var collection = [];
        var x1 = 0;
        var x2 = 0;
        var y1 = 0;
        var y2 = 0;
        var left = this.diagram.pageSettings.margin.left;
        var right = this.diagram.pageSettings.margin.right;
        var top = this.diagram.pageSettings.margin.top;
        var bottom = this.diagram.pageSettings.margin.bottom;
        var widthCount = 1;
        var heightCount = 1;
        var segment = { x1: x1, y1: y1, x2: x2, y2: y2 };
        while (pageBounds.width > i) {
            i = i + (this.diagram.pageSettings.width ? this.diagram.pageSettings.width : pageBounds.width);
            if (i === this.diagram.pageSettings.width) {
                segment = {
                    x1: pageBounds.left + left, y1: pageBounds.top + top,
                    x2: pageBounds.left + left, y2: pageBounds.bottom - bottom
                };
                collection[++v] = segment;
            }
            if (i < pageBounds.width) {
                x1 = pageBounds.topLeft.x + this.diagram.pageSettings.width * widthCount;
                y1 = pageBounds.topLeft.y + top;
                x2 = pageBounds.bottomLeft.x + this.diagram.pageSettings.width * widthCount;
                y2 = pageBounds.bottomLeft.y - bottom;
                segment = { x1: x1, y1: y1, x2: x2, y2: y2 };
                collection[++v] = segment;
                widthCount++;
            }
            if (pageBounds.width === i) {
                segment = {
                    x1: pageBounds.right - right, y1: pageBounds.top + top,
                    x2: pageBounds.right - right, y2: pageBounds.bottom - bottom
                };
                collection[++v] = segment;
            }
        }
        while (pageBounds.height > j) {
            j = j + (this.diagram.pageSettings.height ? this.diagram.pageSettings.height : pageBounds.height);
            if (j === this.diagram.pageSettings.height) {
                segment = {
                    x1: pageBounds.left + left, y1: pageBounds.top + top,
                    x2: pageBounds.right - right, y2: pageBounds.top + top
                };
                collection[++v] = segment;
            }
            if (j < pageBounds.height) {
                x1 = pageBounds.topLeft.x + left;
                y1 = pageBounds.topLeft.y + this.diagram.pageSettings.height * heightCount;
                x2 = pageBounds.topRight.x - right;
                y2 = pageBounds.topRight.y + this.diagram.pageSettings.height * heightCount;
                segment = { x1: x1, y1: y1, x2: x2, y2: y2 };
                collection[++v] = segment;
                heightCount++;
            }
            if (pageBounds.height === j) {
                segment = {
                    x1: pageBounds.left + left, y1: pageBounds.bottom - bottom,
                    x2: pageBounds.right - right, y2: pageBounds.bottom - bottom
                };
                collection[++v] = segment;
            }
        }
        return collection;
    };
    /**
     * zoom method \
     *
     * @returns { void }     zoom method .\
     * @param {number} factor - provide the factor value.
     * @param {number} deltaX - provide the bounds value.
     * @param {number} deltaY - provide the bounds value.
     * @param {PointModel} focusPoint - provide the bounds value.
     * @param {boolean} isInteractiveZoomPan - provide the isInteractiveZoomPan value.
     * @param {boolean} isBringIntoView - provide the isBringIntoView value.
     * @param {boolean} isTrackpadScroll - provide the isTrackpadScroll value.
     * @param {boolean} canZoomOut - provide the canZoomOut value.
     *
     * @private
     */
    DiagramScroller.prototype.zoom = function (factor, deltaX, deltaY, focusPoint, isInteractiveZoomPan, isBringIntoView, isTrackpadScroll, canZoomOut) {
        if (canZoom(this.diagram) && factor !== 1 || (canPan(this.diagram) && factor === 1)) {
            var matrix = identityMatrix();
            scaleMatrix(matrix, this.currentZoom, this.currentZoom);
            translateMatrix(matrix, this.horizontalOffset, this.verticalOffset);
            focusPoint = focusPoint || {
                x: (this.viewPortWidth / 2 - this.horizontalOffset) / this.currentZoom,
                y: (this.viewPortHeight / 2 - this.verticalOffset) / this.currentZoom
            };
            focusPoint = transformPointByMatrix(matrix, focusPoint);
            //Bug 853566: Fit to page is not working when zoom value less than minZoom.
            // Removed minZoom calculation to call fitToPage even if currentZoom less than minZoom.
            if ((this.currentZoom * factor) <= this.diagram.scrollSettings.maxZoom &&
                ((this.currentZoom * factor) >= this.diagram.scrollSettings.minZoom || (canZoomOut || factor >= 1))) {
                this.currentZoom *= factor;
                var pageBounds = this.getPageBounds(undefined, undefined, true);
                pageBounds.x *= this.currentZoom;
                pageBounds.y *= this.currentZoom;
                //target Matrix
                var targetMatrix = identityMatrix();
                scaleMatrix(targetMatrix, factor, factor, focusPoint.x, focusPoint.y);
                translateMatrix(targetMatrix, deltaX || 0, deltaY || 0);
                multiplyMatrix(matrix, targetMatrix);
                var newOffset = transformPointByMatrix(matrix, { x: 0, y: 0 });
                if (factor === 1) {
                    // EJ2-69238 - add true as an extra parameter to calcuate the horizontal and vertical offset
                    newOffset = this.applyScrollLimit(newOffset.x, newOffset.y, isInteractiveZoomPan, isBringIntoView, isTrackpadScroll);
                }
                // Bug 829925: Scroll bar flickers on scrolling the diagram using touchpad.
                // The below condition is used to avoid the flickering of the scroll bar on scrolling the diagram using trackpad.
                isTrackpadScroll = (-(pageBounds.y) >= newOffset.y && -(pageBounds.x) >= newOffset.x && isTrackpadScroll);
                if ((this.diagram.scrollActions & ScrollActions.PropertyChange ||
                    !(this.diagram.scrollActions & ScrollActions.Interaction)) ||
                    this.diagram.scrollSettings.scrollLimit !== 'Diagram' || isTrackpadScroll) {
                    this.transform = {
                        tx: Math.max(newOffset.x, -pageBounds.left) / this.currentZoom,
                        ty: Math.max(newOffset.y, -pageBounds.top) / this.currentZoom,
                        scale: this.currentZoom
                    };
                    this.horizontalOffset = newOffset.x;
                    this.verticalOffset = newOffset.y;
                }
                this.setSize(newOffset);
                if (this.diagram.mode !== 'SVG' && canVitualize(this.diagram)) {
                    this.diagram.scroller.virtualizeElements();
                }
                if (this.diagram.mode !== 'SVG' && !canVitualize(this.diagram)) {
                    this.diagram.refreshDiagramLayer();
                }
                this.diagram.setOffset(-this.horizontalOffset - pageBounds.x, -this.verticalOffset - pageBounds.y);
                updateRuler(this.diagram);
                //Bug 863516: Overview is not synced with diagram content while zoom-out the diagram.
                //Updating overview after the page scrolled or zoomed.
                if (this.diagram.views && this.diagram.views.overview) {
                    var overview = this.diagram.views.overview;
                    var bounds = overview.scrollOverviewRect(overview.parent.scroller.horizontalOffset, overview.parent.scroller.verticalOffset, overview.parent.scroller.currentZoom, true);
                    overview.updateOverviewrect(-bounds.x, -bounds.y, bounds.width, bounds.height);
                    overview.updateView(overview);
                }
            }
        }
    };
    /**
     * fitToPage method \
     *
     * @returns { void }     fitToPage method .\
     * @param {IFitOptions} options - provide the bounds value.
     *
     * @private
     */
    DiagramScroller.prototype.fitToPage = function (options) {
        options = options || {};
        var mode = options.mode;
        var region = options.region;
        var margin = options.margin || {};
        var canZoomIn = options.canZoomIn;
        var customBounds = options.customBounds;
        // Allows fitToPage when the currentZoom less than minZoom.
        var canZoomOut = options.canZoomOut;
        margin.bottom = margin.bottom || 25;
        margin.top = margin.top || 25;
        margin.left = margin.left || 25;
        margin.right = margin.right || 25;
        var bounds = customBounds;
        var factor;
        var deltaX = -this.horizontalOffset;
        var deltaY = -this.verticalOffset;
        region = region ? region : 'PageSettings';
        //fit mode
        if ((region === 'PageSettings' && this.diagram.pageSettings.width && this.diagram.pageSettings.height)
            || (this.diagram.nodes.length > 0 || this.diagram.connectors.length > 0)) {
            mode = mode ? mode : 'Page';
            if (region !== 'CustomBounds') {
                bounds = this.getPageBounds(true, region, true);
            }
            var scale = { x: 0, y: 0 };
            //Bug 853566: Fit to page is not working when zoom value less than minZoom.
            // Resetting margin value if the margin value is greater than the viewport size to avoid scale value in negative.
            if ((margin.left + margin.right) > this.viewPortWidth) {
                if (this.viewPortWidth <= 100) {
                    margin.left = 5;
                    margin.right = 5;
                }
                else {
                    margin.left = 25;
                    margin.right = 25;
                }
            }
            if ((margin.top + margin.bottom) > this.viewPortHeight) {
                if (this.viewPortHeight <= 100) {
                    margin.top = 5;
                    margin.bottom = 5;
                }
                else {
                    margin.top = 25;
                    margin.bottom = 25;
                }
            }
            scale.x = (this.viewPortWidth - (margin.left + margin.right)) / (bounds.width);
            scale.y = (this.viewPortHeight - (margin.top + margin.bottom)) / (bounds.height);
            if (!canZoomIn && (((bounds.width - this.horizontalOffset) < this.viewPortWidth) &&
                (bounds.height - this.verticalOffset) < this.viewPortHeight)) {
                scale.x = Math.min(this.currentZoom, scale.x);
                scale.y = Math.min(this.currentZoom, scale.y);
            }
            var zoomFactor = void 0;
            var centerX = void 0;
            var centerY = void 0;
            switch (mode) {
                case 'Width':
                    zoomFactor = scale.x;
                    factor = zoomFactor / this.currentZoom;
                    centerX = (this.viewPortWidth - (bounds.width) * zoomFactor) / 2 - bounds.x * zoomFactor;
                    deltaX += centerX + (margin.left - margin.right) / 2 * zoomFactor;
                    deltaY -= -this.verticalOffset * factor;
                    deltaY = region !== 'CustomBounds' ? deltaY : deltaY - this.verticalOffset * factor;
                    break;
                case 'Height':
                    zoomFactor = scale.y;
                    factor = (zoomFactor / this.currentZoom);
                    centerX = ((this.viewPortWidth - (bounds.width) * zoomFactor) / 2) - bounds.x * zoomFactor;
                    centerY = ((this.viewPortHeight - (bounds.height) * zoomFactor) / 2) - bounds.y * zoomFactor;
                    deltaX += centerX + (margin.left - margin.right) / 2 * zoomFactor;
                    deltaY += centerY + (margin.top - margin.bottom) / 2 * zoomFactor;
                    break;
                case 'Page':
                    zoomFactor = Math.min(scale.x, scale.y);
                    factor = (zoomFactor / this.currentZoom);
                    centerX = (this.viewPortWidth - (bounds.width) * zoomFactor) / 2 - bounds.x * zoomFactor;
                    centerY = (this.viewPortHeight - (bounds.height) * zoomFactor) / 2 - bounds.y * zoomFactor;
                    deltaX += centerX + (margin.left - margin.right) / 2 * zoomFactor;
                    deltaY += centerY + (margin.top - margin.bottom) / 2 * zoomFactor;
                    break;
            }
            /**
             * EJ2-62912 - fit to page is not working properly when call it multiple times.
             */
            this.zoom(factor, deltaX, deltaY, { x: 0, y: 0 }, true, undefined, undefined, canZoomOut);
        }
        else {
            factor = 1 / this.currentZoom;
            this.zoom(factor, deltaX, deltaY, { x: 0, y: 0 }, true, undefined, undefined, canZoomOut);
        }
    };
    /**
     * bringIntoView method \
     *
     * @returns { void }     bringIntoView method .\
     * @param {Rect} rect - provide the bounds value.
     * @param {boolean} isBringIntoView - provide the isBringIntoView value.
     *
     * @private
     */
    DiagramScroller.prototype.bringIntoView = function (rect, isBringIntoView) {
        // EJ2-68130-Bringintoview shows the object outside the viewport
        var x = 0;
        var y = 0;
        var scale = this.currentZoom;
        var bounds = rect;
        var hoffset = -this.horizontalOffset;
        var voffset = -this.verticalOffset;
        bounds = new Rect(bounds.x * scale, bounds.y * scale, bounds.width * scale, bounds.height * scale);
        var view = new Rect(hoffset, voffset, this.viewPortWidth, this.viewPortHeight);
        //To prevent nodes from being cut off in the horizontal and vertical scrollbars when calling the "bring into view" function, a padding value is added.
        var nodePadding = 20;
        if (!(view.containsRect(bounds))) {
            if (bounds.right > (-hoffset + this.viewPortWidth)) {
                x = bounds.right - this.viewPortWidth;
                x += nodePadding;
            }
            if (bounds.x < -hoffset) {
                x = bounds.x;
            }
            if (bounds.bottom > (-voffset + this.viewPortHeight)) {
                y = bounds.bottom - this.viewPortHeight;
                y += nodePadding;
            }
            if (bounds.y < -voffset) {
                y = bounds.y;
            }
            this.zoom(1, -this.horizontalOffset - x, -this.verticalOffset - y, null, undefined, isBringIntoView);
        }
    };
    /**
     * bringToCenter method \
     *
     * @returns { void }     bringToCenter method .\
     * @param {Rect} bounds - provide the bounds value.
     *
     * @private
     */
    DiagramScroller.prototype.bringToCenter = function (bounds) {
        var scale = this.currentZoom;
        var actualbounds = new Rect(bounds.x * scale, bounds.y * scale, bounds.width * scale, bounds.height * scale);
        var hoffset = actualbounds.x + actualbounds.width / 2 - this.viewPortWidth / 2;
        var voffset = actualbounds.y + actualbounds.height / 2 - this.viewPortHeight / 2;
        /**
         * In applyScrollLimit method the sign of deltaX and deltaY
         * will be changed ,so here we change the sign.
         * similarly for bringIntoView.
         */
        hoffset *= -1;
        voffset *= -1;
        this.zoom(1, -this.horizontalOffset - hoffset, -this.verticalOffset - voffset, null);
    };
    DiagramScroller.prototype.applyScrollLimit = function (hOffset, vOffset, isInteractiveZoomPan, isBringIntoView, isTrackpadScroll) {
        /**
         * EJ2-60980- ScrollOffset is not updated properly in runtime.
         * EJ2-62524 - panning is not working properly in diagram.
         * isInteractiveZoomPan is undefined while setting scrollOffset at runtime.
         */
        if (this.diagram.scrollSettings.scrollLimit === 'Infinity') {
            if (isInteractiveZoomPan === undefined && !isBringIntoView) {
                hOffset = -hOffset;
                vOffset = -vOffset;
            }
        }
        if (this.diagram.scrollSettings.scrollLimit !== 'Infinity') {
            var bounds = void 0;
            if (this.diagram.scrollSettings.scrollLimit === 'Limited') {
                var scrollableBounds = this.diagram.scrollSettings.scrollableArea;
                bounds = new Rect(scrollableBounds.x, scrollableBounds.y, scrollableBounds.width, scrollableBounds.height);
            }
            // Bug 829925: Scroll bar flickers on scrolling the diagram using touchpad.
            // Added below code to get the page bounds based on the scroll.
            bounds = bounds || (isTrackpadScroll ? this.getPageBounds(false, undefined, true) : this.getPageBounds(true, undefined, true));
            // 939223: Unable to Pan to the Extreme End of the Diagram When Scroll Padding is Applied
            var eventHandler = 'eventHandler';
            if (this.diagram["" + eventHandler].currentAction === 'Pan' && this.diagram["" + eventHandler].inAction) {
                bounds = this.getPageBounds(false, undefined, true);
            }
            bounds.x *= this.currentZoom;
            bounds.y *= this.currentZoom;
            bounds.width *= this.currentZoom;
            bounds.height *= this.currentZoom;
            if (isInteractiveZoomPan !== undefined) {
                hOffset *= -1;
                vOffset *= -1;
            }
            // EJ2-69238 - Added below code to multiple the horizontal and vertical offset to bring the node in viewport
            if (isBringIntoView) {
                hOffset *= -1;
                vOffset *= -1;
            }
            var allowedRight = Math.max(bounds.right, this.viewPortWidth);
            if (!isBringIntoView && !(hOffset <= bounds.x && (hOffset + this.viewPortWidth >= bounds.right ||
                hOffset >= bounds.right - this.viewPortWidth)
                || hOffset >= bounds.x && (hOffset + this.viewPortWidth <= allowedRight))) {
                //not allowed case
                if (hOffset >= bounds.x) {
                    hOffset = Math.max(bounds.x, Math.min(hOffset, hOffset - (hOffset + this.viewPortWidth - this.vScrollSize - allowedRight)));
                }
                else {
                    var allowed = bounds.right - this.viewPortWidth;
                    hOffset = Math.min(allowed, bounds.x);
                }
            }
            var allowedBottom = Math.max(bounds.bottom, this.viewPortHeight);
            // EJ2-69238 - Added below code to restrict the min value calculation for vertical offset in bringIntoview scenarion.
            if (!isBringIntoView && !(vOffset <= bounds.y && vOffset + this.viewPortHeight >= bounds.bottom
                || vOffset >= bounds.y && vOffset + this.viewPortHeight <= allowedBottom)) {
                //not allowed case
                if (vOffset >= bounds.y) {
                    vOffset = Math.max(bounds.y, Math.min(vOffset, vOffset - (vOffset + this.viewPortHeight - this.hScrollSize - allowedBottom)));
                }
                else {
                    var allowed = bounds.bottom - this.viewPortHeight;
                    vOffset = Math.min(bounds.y, allowed);
                }
            }
            hOffset *= -1;
            vOffset *= -1;
        }
        return { x: hOffset, y: vOffset };
    };
    return DiagramScroller;
}());

/**
 * Quad helps to maintain a set of objects that are contained within the particular region
 */
/** @private */
var Quad = /** @class */ (function () {
    /**
     *  Constructor for creating the Quad class
     *
     * @param {number} left The symbol palette model.
     * @param {number} top The symbol palette element.
     * @param {number} width The symbol palette element.
     * @param {number} height The symbol palette element.
     * @param {SpatialSearch} spatialSearching The symbol palette element.
     * @private
     */
    function Quad(left, top, width, height, spatialSearching) {
        this.objects = [];
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
        this.spatialSearch = spatialSearching;
    }
    /**
     * findQuads method\
     *
     * @returns {  void}    findQuads method .\
     * @param {Rect} currentViewPort - provide the options value.
     * @param {Quad[]} quads - provide the options value.
     * @private
     */
    Quad.prototype.findQuads = function (currentViewPort, quads) {
        if (this.first != null && this.first.isIntersect(currentViewPort)) {
            this.first.findQuads(currentViewPort, quads);
        }
        if (this.second != null && this.second.isIntersect(currentViewPort)) {
            this.second.findQuads(currentViewPort, quads);
        }
        if (this.third != null && this.third.isIntersect(currentViewPort)) {
            this.third.findQuads(currentViewPort, quads);
        }
        if (this.fourth != null && this.fourth.isIntersect(currentViewPort)) {
            this.fourth.findQuads(currentViewPort, quads);
        }
        if (this.objects.length > 0) {
            quads.push(this);
        }
    };
    Quad.prototype.isIntersect = function (t) {
        if (this.left + this.width < t.left || this.top + this.height < t.top || this.left > t.right || this.top > t.bottom) {
            return false;
        }
        return true;
    };
    /**
     * selectQuad method\
     *
     * @returns {  Quad }    selectQuad method .\
     * @private
     */
    Quad.prototype.selectQuad = function () {
        var target = null;
        // eslint-disable-next-line
        var current = this;
        var quadSet;
        while (current != null) {
            quadSet = current.getQuad(target);
            current = quadSet.source;
            target = quadSet.target || target;
        }
        return target;
    };
    Quad.prototype.getQuad = function (target) {
        var halfWidth = this.width / 2;
        var halfHeight = this.height / 2;
        if (halfWidth >= 1000 && halfHeight >= 1000) {
            var xCenter = this.left + halfWidth;
            var yCenter = this.top + halfHeight;
            if (this.spatialSearch.childRight <= xCenter) {
                if (this.spatialSearch.childBottom <= yCenter) {
                    if (!this.first) {
                        var newQuad = new Quad(this.left, this.top, halfWidth, halfHeight, this.spatialSearch);
                        newQuad.parent = this;
                        this.first = newQuad;
                    }
                    return { source: this.first };
                }
                if (this.spatialSearch.childTop >= yCenter) {
                    if (!this.third) {
                        var newQuad = new Quad(this.left, yCenter, halfWidth, halfHeight, this.spatialSearch);
                        newQuad.parent = this;
                        this.third = newQuad;
                    }
                    return { source: this.third };
                }
            }
            else if (this.spatialSearch.childLeft >= xCenter) {
                if (this.spatialSearch.childBottom <= yCenter) {
                    if (!this.second) {
                        var newQuad = new Quad(xCenter, this.top, halfWidth, halfHeight, this.spatialSearch);
                        newQuad.parent = this;
                        this.second = newQuad;
                    }
                    return { source: this.second };
                }
                if (this.spatialSearch.childTop >= yCenter) {
                    if (!this.fourth) {
                        var newQuad = new Quad(xCenter, yCenter, halfWidth, halfHeight, this.spatialSearch);
                        newQuad.parent = this;
                        this.fourth = newQuad;
                    }
                    return { source: this.fourth };
                }
            }
        }
        this.objects.push(this.spatialSearch.childNode);
        return { target: this };
    };
    /**
     * isContained method\
     *
     * @returns {  boolean }    isContained method .\
     * @private
     */
    Quad.prototype.isContained = function () {
        if (this.spatialSearch.childLeft >= this.left && this.spatialSearch.childRight <= this.left + this.width &&
            this.spatialSearch.childTop >= this.top && this.spatialSearch.childBottom <= this.top + this.height) {
            return true;
        }
        return false;
    };
    /**
     * addIntoAQuad method\
     *
     * @returns {  Quad }    addIntoAQuad method .\
     * @param {IGroupable} node - provide the options value.
     * @private
     */
    Quad.prototype.addIntoAQuad = function (node) {
        var quadAddition = {};
        this.spatialSearch.setCurrentNode(node);
        var quad = null;
        while (!quadAddition.isAdded) {
            quadAddition = this.spatialSearch.parentQuad.add(quad);
            quad = quadAddition.quad;
        }
        return quad;
    };
    Quad.prototype.add = function (quad) {
        quad = null;
        if (this.isContained()) {
            quad = this.selectQuad();
            return { isAdded: true, quad: quad };
        }
        else {
            var newParent = void 0;
            var isempty = this.objects.length === 0 && !this.first && !this.second && !this.third &&
                !this.fourth;
            var newWidth = this.width * 2;
            var newHeight = this.height * 2;
            if (this.spatialSearch.childLeft < this.left) {
                if (this.spatialSearch.childTop < this.top) {
                    newParent = new Quad(this.left - this.width, this.top - this.height, newWidth, newHeight, this.spatialSearch);
                    if (!isempty) {
                        newParent.fourth = this;
                    }
                }
                else {
                    newParent = new Quad(this.left - this.width, this.top, newWidth, newHeight, this.spatialSearch);
                    if (!isempty) {
                        newParent.second = this;
                    }
                }
            }
            else if (this.spatialSearch.childTop < this.top) {
                newParent = new Quad(this.left, this.top - this.height, newWidth, newHeight, this.spatialSearch);
                if (!isempty) {
                    newParent.third = this;
                }
            }
            else {
                newParent = new Quad(this.left, this.top, newWidth, newHeight, this.spatialSearch);
                if (!isempty) {
                    newParent.first = this;
                }
            }
            this.parent = newParent;
            this.spatialSearch.parentQuad = newParent;
            return { isAdded: false, quad: quad };
            //newParent.AddIntoaQuad(node);
        }
    };
    return Quad;
}());

/**
 * Spatial search module helps to effectively find the objects over diagram
 */
var SpatialSearch = /** @class */ (function () {
    /**
     *  Constructor for creating the spatial search
     *
     * @param {number} objectTable The objectTable.
     * @private
     */
    function SpatialSearch(objectTable) {
        this.quadSize = 500;
        this.objectTable = objectTable;
        this.parentQuad = new Quad(0, 0, this.quadSize * 2, this.quadSize * 2, this);
        this.pageLeft = Number.MAX_VALUE;
        this.pageRight = -Number.MAX_VALUE;
        this.pageTop = Number.MAX_VALUE;
        this.pageBottom = -Number.MAX_VALUE;
        this.quadTable = {};
    }
    /**
     * removeFromAQuad method\
     *
     * @returns {void}    removeFromAQuad method .\
     * @param {IGroupable} node - provide the options value.
     * @private
     */
    SpatialSearch.prototype.removeFromAQuad = function (node) {
        if (this.quadTable[node.id]) {
            var quad = this.quadTable[node.id];
            var index = this.objectIndex(quad.objects, node);
            if (index !== -1) {
                quad.objects.splice(index, 1);
                this.update(quad);
                delete this.quadTable[node.id];
            }
        }
    };
    SpatialSearch.prototype.update = function (quad) {
        //EJ2-841966-Nodes disappears while enabling virtualization constrai
        if (quad.parent && quad.objects.length === 0 && quad.first == null && quad.second == null
            && quad.third == null && quad.fourth == null) {
            var parent_1 = quad.parent;
            if (parent_1.first === quad) {
                parent_1.first = null;
            }
            else if (parent_1.second === quad) {
                parent_1.second = null;
            }
            else if (parent_1.third === quad) {
                parent_1.third = null;
            }
            else if (parent_1.fourth === quad) {
                parent_1.fourth = null;
            }
            this.update(quad.parent);
        }
        else {
            if (quad === this.parentQuad && !quad.first && !quad.second && !quad.third && !quad.fourth) {
                quad.left = 0;
                quad.width = 1000;
                quad.top = 0;
                quad.height = 1000;
            }
            return;
        }
    };
    SpatialSearch.prototype.addIntoAQuad = function (node) {
        var quad = this.parentQuad.addIntoAQuad(node);
        this.quadTable[node.id] = quad;
    };
    SpatialSearch.prototype.objectIndex = function (objects, node) {
        for (var i = 0; i < objects.length; i++) {
            if ((objects[parseInt(i.toString(), 10)]).id === node.id) {
                return i;
            }
        }
        return -1;
    };
    SpatialSearch.prototype.updateQuad = function (node) {
        this.setCurrentNode(node);
        var nodBounds = node.outerBounds;
        if (!(!isNaN(nodBounds.x) && !isNaN(nodBounds.y) &&
            !isNaN(nodBounds.width) && !isNaN(nodBounds.height))) {
            return false;
        }
        //nodBounds = new Rect(nodBounds.X.Valid(), nodBounds.Y.Valid(), nodBounds.Width.Valid(), nodBounds.Height.Valid());
        if (this.quadTable[node.id]) {
            var quad = this.quadTable[node.id];
            if (!quad.isContained()) {
                this.removeFromAQuad(node);
                this.addIntoAQuad(node);
            }
        }
        else {
            this.addIntoAQuad(node);
        }
        if (this.isWithinPageBounds(nodBounds) &&
            this.leftElement !== node &&
            this.topElement !== node &&
            this.rightElement !== node &&
            this.bottomElement !== node) ;
        else {
            var modified = false;
            if (this.pageLeft !== this.childLeft || node !== this.leftElement) {
                if (this.pageLeft >= this.childLeft) {
                    this.pageLeft = this.childLeft;
                    this.leftElement = node;
                    modified = true;
                }
                else if (node === this.leftElement) {
                    this.pageLeft = Number.MAX_VALUE;
                    this.findLeft(this.parentQuad);
                    modified = true;
                }
            }
            if (this.pageTop !== this.childTop || node !== this.topElement) {
                if (this.pageTop >= this.childTop) {
                    this.pageTop = this.childTop;
                    this.topElement = node;
                    modified = true;
                }
                else if (node === this.topElement) {
                    this.pageTop = Number.MAX_VALUE;
                    this.findTop(this.parentQuad);
                    modified = true;
                }
            }
            if (this.pageBottom !== this.childBottom || node !== this.bottomElement) {
                if (this.pageBottom <= this.childBottom) {
                    modified = true;
                    this.pageBottom = this.childBottom;
                    this.bottomElement = node;
                }
                else if (node === this.bottomElement) {
                    this.pageBottom = -Number.MAX_VALUE;
                    this.findBottom(this.parentQuad);
                    modified = true;
                }
            }
            if (this.pageRight !== this.childRight || node !== this.rightElement) {
                if (this.pageRight <= this.childRight) {
                    this.pageRight = this.childRight;
                    this.rightElement = node;
                    modified = true;
                }
                else if (node === this.rightElement) {
                    this.pageRight = -Number.MAX_VALUE;
                    this.findRight(this.parentQuad);
                    modified = true;
                }
            }
            return modified;
        }
        this.setCurrentNode(null);
        return false;
    };
    SpatialSearch.prototype.isWithinPageBounds = function (node) {
        if (node.left >= this.pageLeft && node.right <= this.pageRight && node.top >= this.pageTop
            && node.bottom <= this.pageBottom) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * findQuads method\
     *
     * @returns {  Quad[] }    findQuads method .\
     * @param {Rect} region - provide the options value.
     * @private
     */
    SpatialSearch.prototype.findQuads = function (region) {
        var quads = [];
        this.parentQuad.findQuads(region, quads);
        return quads;
    };
    /**
     * findObjects method\
     *
     * @returns {  IGroupable[] }    findObjects method .\
     * @param {Rect} region - provide the options value.
     * @private
     */
    SpatialSearch.prototype.findObjects = function (region) {
        var quads = this.findQuads(region);
        var objects = [];
        for (var _i = 0, quads_1 = quads; _i < quads_1.length; _i++) {
            var quad = quads_1[_i];
            for (var _a = 0, _b = quad.objects; _a < _b.length; _a++) {
                var obj = _b[_a];
                if (obj.outerBounds.intersects(region)) {
                    objects.push(this.objectTable[obj.id]);
                }
            }
        }
        return objects;
    };
    /**
     * updateBounds method\
     *
     * @returns { boolean }    updateBounds method .\
     * @param {IGroupable} node - provide the options value.
     * @param {boolean} isSwimLane - provide boolean if its swimlane container
     * @private
     */
    SpatialSearch.prototype.updateBounds = function (node, isSwimLane) {
        var modified = false;
        //879088: Swimalane exception when drag and dropped from palette
        if (isSwimLane) {
            if (this.topElement && node.id === this.topElement.id) {
                modified = this.updateTop();
            }
            if (this.leftElement && node.id === this.leftElement.id) {
                modified = this.updateLeft();
            }
            if (this.rightElement && node.id === this.rightElement.id) {
                modified = this.updateRight();
            }
            if (this.bottomElement && node.id === this.bottomElement.id) {
                modified = this.updateBottom();
            }
        }
        else {
            if (node === this.topElement) {
                modified = this.updateTop();
            }
            if (node === this.leftElement) {
                modified = this.updateLeft();
            }
            if (node === this.rightElement) {
                modified = this.updateRight();
            }
            if (node === this.bottomElement) {
                modified = this.updateBottom();
            }
        }
        return modified;
    };
    SpatialSearch.prototype.updateTop = function () {
        this.pageTop = Number.MAX_VALUE;
        this.topElement = null;
        this.findTop(this.parentQuad);
        return true;
    };
    SpatialSearch.prototype.updateBottom = function () {
        this.pageBottom = -Number.MAX_VALUE;
        this.bottomElement = null;
        this.findBottom(this.parentQuad);
        return true;
    };
    SpatialSearch.prototype.updateLeft = function () {
        this.pageLeft = Number.MAX_VALUE;
        this.leftElement = null;
        this.findLeft(this.parentQuad);
        return true;
    };
    SpatialSearch.prototype.updateRight = function () {
        this.pageRight = -Number.MAX_VALUE;
        this.rightElement = null;
        this.findRight(this.parentQuad);
        return true;
    };
    SpatialSearch.prototype.findBottom = function (quad) {
        //if (quad.Quads.Count === 4)
        {
            if (quad.third || quad.fourth) {
                if (quad.third) {
                    this.findBottom(quad.third);
                }
                if (quad.fourth) {
                    this.findBottom(quad.fourth);
                }
            }
            else {
                if (quad.second) {
                    this.findBottom(quad.second);
                }
                if (quad.first) {
                    this.findBottom(quad.first);
                }
            }
        }
        for (var _i = 0, _a = quad.objects; _i < _a.length; _i++) {
            var node = _a[_i];
            if (this.pageBottom <= node.outerBounds.bottom) {
                this.pageBottom = node.outerBounds.bottom;
                this.bottomElement = node;
            }
        }
    };
    SpatialSearch.prototype.findRight = function (quad) {
        //if (quad.Quads.Count === 4)
        {
            if (quad.second || quad.fourth) {
                if (quad.second) {
                    this.findRight(quad.second);
                }
                if (quad.fourth) {
                    this.findRight(quad.fourth);
                }
            }
            // EJ2-65880 - Exception occurs on dragging outside the canvas
            {
                if (quad.first) {
                    this.findRight(quad.first);
                }
                if (quad.third) {
                    this.findRight(quad.third);
                }
            }
        }
        for (var _i = 0, _a = quad.objects; _i < _a.length; _i++) {
            var node = _a[_i];
            if (this.pageRight <= node.outerBounds.right) {
                this.pageRight = node.outerBounds.right;
                this.rightElement = node;
            }
        }
    };
    SpatialSearch.prototype.findLeft = function (quad) {
        //if (quad.Quads.Count === 4)
        {
            if (quad.first || quad.third) {
                if (quad.first) {
                    this.findLeft(quad.first);
                }
                if (quad.third) {
                    this.findLeft(quad.third);
                }
            }
            else {
                if (quad.second) {
                    this.findLeft(quad.second);
                }
                if (quad.fourth) {
                    this.findLeft(quad.fourth);
                }
            }
        }
        for (var _i = 0, _a = quad.objects; _i < _a.length; _i++) {
            var node = _a[_i];
            if (this.pageLeft >= node.outerBounds.left) {
                this.pageLeft = node.outerBounds.left;
                this.leftElement = node;
            }
        }
    };
    SpatialSearch.prototype.findTop = function (quad) {
        //if (quad.Quads.Count === 4)
        {
            if (quad.first || quad.second) {
                if (quad.first) {
                    this.findTop(quad.first);
                }
                if (quad.second) {
                    this.findTop(quad.second);
                }
            }
            else {
                if (quad.third) {
                    this.findTop(quad.third);
                }
                if (quad.fourth) {
                    this.findTop(quad.fourth);
                }
            }
        }
        for (var _i = 0, _a = quad.objects; _i < _a.length; _i++) {
            var node = _a[_i];
            if (this.pageTop >= node.outerBounds.top) {
                this.pageTop = node.outerBounds.top;
                this.topElement = node;
            }
        }
    };
    /**
     * setCurrentNode method\
     *
     * @returns { void }    setCurrentNode method .\
     * @param {IGroupable} node - provide the options value.
     * @private
     */
    SpatialSearch.prototype.setCurrentNode = function (node) {
        this.childNode = node;
        if (node) {
            var r = node.outerBounds;
            this.childLeft = Number(r.left);
            this.childTop = Number(r.top);
            this.childRight = Number(r.right);
            this.childBottom = Number(r.bottom);
        }
        else {
            this.childLeft = Number.MAX_VALUE;
            this.childTop = Number.MAX_VALUE;
            this.childRight = -Number.MAX_VALUE;
            this.childBottom = -Number.MAX_VALUE;
        }
    };
    /**
     * getPageBounds method\
     *
     * @returns { Rect }    getPageBounds method .\
     * @param {number} originX - provide the options value.
     * @param {number} originY - provide the options value.
     * @private
     */
    SpatialSearch.prototype.getPageBounds = function (originX, originY) {
        if (this.pageLeft === Number.MAX_VALUE) {
            return new Rect(0, 0, 0, 0);
        }
        var left = originX !== undefined ? Math.min(this.pageLeft, 0) : this.pageLeft;
        var top = originY !== undefined ? Math.min(this.pageTop, 0) : this.pageTop;
        return new Rect(Math.round(left), Math.round(top), Math.round(this.pageRight - left), Math.round(this.pageBottom - top));
    };
    /**
     * getQuad method\
     *
     * @returns { Quad }    getQuad method .\
     * @param {IGroupable} node - provide the options value.
     * @private
     */
    SpatialSearch.prototype.getQuad = function (node) {
        return this.quadTable[node.id];
    };
    return SpatialSearch;
}());

var __extends$y = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Defines the serialization settings of diagram
 * ```html
 * <div id='diagram'></div>
 * ```
 * ```typescript
 * let diagram: Diagram = new Diagram({
 * ...
 * serializationSettings: { preventDefaults: true },
 * ...
 * });
 * diagram.appendTo('#diagram');
 * ```
 *
 * @default {}
 */
var SerializationSettings = /** @class */ (function (_super) {
    __extends$y(SerializationSettings, _super);
    function SerializationSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$n([
        Property(false)
    ], SerializationSettings.prototype, "preventDefaults", void 0);
    return SerializationSettings;
}(ChildProperty));

var __extends$z = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * A collection of JSON objects where each object represents a layer.
 * Layer is a named category of diagram shapes.
 */
var CustomCursorAction = /** @class */ (function (_super) {
    __extends$z(CustomCursorAction, _super);
    function CustomCursorAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$o([
        Property('')
    ], CustomCursorAction.prototype, "action", void 0);
    __decorate$o([
        Property('')
    ], CustomCursorAction.prototype, "cursor", void 0);
    return CustomCursorAction;
}(ChildProperty));

/**
 * Line Routing
 */
var LineRouting = /** @class */ (function () {
    /**
     * Constructor for the line routing module
     *
     * @private
     */
    function LineRouting() {
        this.size = 20;
        this.intermediatePoints = [];
        this.gridCollection = [];
        this.startArray = [];
        this.targetGridCollection = [];
        this.sourceGridCollection = [];
        this.considerWalkable = [];
        this.skipObstacleCheck = false;
        //constructs the line routing module
    }
    /**
     * lineRouting method \
     *
     * @returns { void }     lineRouting method .\
     * @param {Diagram} diagram - provide the source value.
     *
     * @private
     */
    LineRouting.prototype.lineRouting = function (diagram) {
        var length = diagram.connectors.length;
        this.renderVirtualRegion(diagram);
        if (length > 0) {
            for (var k = 0; k < length; k++) {
                var connector = diagram.connectors[parseInt(k.toString(), 10)];
                if (connector.type === 'Orthogonal' && connector.visible) {
                    this.refreshConnectorSegments(diagram, connector, true);
                }
            }
        }
    };
    /** @private */
    /**
     * renderVirtualRegion method \
     *
     * @returns { void }     renderVirtualRegion method .\
     * @param {Diagram} diagram - provide the source value.
     * @param {boolean} isUpdate - provide the target value.
     *
     * @private
     */
    LineRouting.prototype.renderVirtualRegion = function (diagram, isUpdate) {
        /* tslint:disable */
        var extraBounds = this.size;
        if (diagram.spatialSearch['pageTop'] < 0 || diagram.spatialSearch['pageLeft'] < 0) {
            extraBounds = this.size + (this.size / 2);
        }
        var right = diagram.spatialSearch['pageRight'] + extraBounds;
        var bottom = diagram.spatialSearch['pageBottom'] + extraBounds;
        var left = diagram.spatialSearch['pageLeft'] - extraBounds;
        var top = diagram.spatialSearch['pageTop'] - extraBounds;
        left = left < 0 ? left - 20 : 0;
        top = top < 0 ? top - 20 : 0;
        /* tslint:enable */
        if ((isUpdate && (this.width !== (right - left) || this.height !== (bottom - top) ||
            this.diagramStartX !== left || this.diagramStartY !== top)) || isUpdate === undefined) {
            this.width = right - left;
            this.height = bottom - top;
            this.diagramStartX = left;
            this.diagramStartY = top;
            this.gridCollection = [];
            this.noOfRows = this.width / this.size;
            this.noOfCols = this.height / this.size;
            var size = this.size;
            var x = this.diagramStartX < 0 ? this.diagramStartX : 0;
            var y = this.diagramStartY < 0 ? this.diagramStartY : 0;
            for (var i = 0; i < this.noOfCols; i++) {
                for (var j = 0; j < this.noOfRows; j++) {
                    if (i === 0) {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        this.gridCollection.push([0]);
                    }
                    var grid = {
                        x: x, y: y, width: size, height: size, gridX: j,
                        gridY: i, walkable: true, tested: undefined, nodeId: []
                    };
                    this.gridCollection[parseInt(j.toString(), 10)][parseInt(i.toString(), 10)] = grid;
                    x += size;
                }
                x = this.diagramStartX < 0 ? this.diagramStartX : 0;
                y += size;
            }
        }
        var nodes = this.findNodes(diagram.nodes);
        this.updateNodesInVirtualRegion(nodes);
    };
    LineRouting.prototype.findNodes = function (nodes) {
        var objects = [];
        var node;
        for (var i = 0; i < nodes.length; i++) {
            node = nodes[parseInt(i.toString(), 10)];
            if (node.shape.type !== 'SwimLane' && !node.isLane && !node.isPhase && !node.isHeader && node.visible) {
                objects.push(node);
            }
        }
        return objects;
    };
    LineRouting.prototype.updateNodesInVirtualRegion = function (diagramNodes) {
        var size = this.size;
        var x = this.diagramStartX < 0 ? this.diagramStartX : 0;
        var y = this.diagramStartY < 0 ? this.diagramStartY : 0;
        for (var i = 0; i < this.noOfCols; i++) {
            for (var j = 0; j < this.noOfRows; j++) {
                var grid = this.gridCollection[parseInt(j.toString(), 10)][parseInt(i.toString(), 10)];
                var rectangle = new Rect(x, y, this.size, this.size);
                var isContains = void 0;
                var k = void 0;
                grid.walkable = true;
                grid.tested = undefined;
                grid.nodeId = [];
                for (k = 0; k < diagramNodes.length; k++) {
                    if (diagramNodes[parseInt(k.toString(), 10)].wrapper.bounds) {
                        isContains = this.intersectRect(rectangle, diagramNodes[parseInt(k.toString(), 10)].wrapper.bounds);
                    }
                    if (isContains) {
                        grid.nodeId.push(diagramNodes[parseInt(k.toString(), 10)].id);
                        grid.walkable = false;
                        if (diagramNodes[parseInt(k.toString(), 10)].parentId !== '') {
                            grid.parentNodeId = diagramNodes[parseInt(k.toString(), 10)].parentId;
                        }
                    }
                }
                x += size;
            }
            x = this.diagramStartX < 0 ? this.diagramStartX : 0;
            y += size;
        }
    };
    LineRouting.prototype.intersectRect = function (r1, r2) {
        return !(r2.left >= r1.right || r2.right <= r1.left ||
            r2.top >= r1.bottom || r2.bottom <= r1.top);
    };
    LineRouting.prototype.findEndPoint = function (connector, isSource, isPortBounds) {
        var endPoint;
        var portDirection;
        // EJ2-65876 - Exception occurs on line routing injection module
        if ((isSource && connector.sourcePortID !== '' && connector.sourcePortWrapper) || (!isSource && connector.targetPortID !== '' && connector.targetPortWrapper)) {
            endPoint = (isSource) ? { x: connector.sourcePortWrapper.offsetX, y: connector.sourcePortWrapper.offsetY } :
                { x: connector.targetPortWrapper.offsetX, y: connector.targetPortWrapper.offsetY };
            portDirection = getPortDirection(endPoint, undefined, (isSource) ? connector.sourceWrapper.bounds : connector.targetWrapper.bounds);
            var bounds = (isSource) ? connector.sourcePortWrapper.bounds : connector.targetPortWrapper.bounds;
            if (isPortBounds) {
                if (portDirection === 'Top') {
                    endPoint = { x: bounds.topCenter.x, y: bounds.topCenter.y };
                }
                else if (portDirection === 'Left') {
                    endPoint = { x: bounds.middleLeft.x, y: bounds.middleLeft.y };
                }
                else if (portDirection === 'Right') {
                    endPoint = { x: bounds.middleRight.x, y: bounds.middleRight.y };
                }
                else {
                    endPoint = { x: bounds.bottomCenter.x, y: bounds.bottomCenter.y };
                }
            }
            else {
                endPoint = { x: bounds.center.x, y: bounds.center.y };
            }
        }
        else {
            if ((isSource && this.startNode) || (!isSource && this.targetNode)) {
                endPoint = (isSource) ? { x: this.startNode.wrapper.offsetX, y: this.startNode.wrapper.offsetY } :
                    { x: this.targetNode.wrapper.offsetX, y: this.targetNode.wrapper.offsetY };
            }
            else {
                endPoint = (isSource) ? { x: connector.sourcePoint.x, y: connector.sourcePoint.y } :
                    { x: connector.targetPoint.x, y: connector.targetPoint.y };
            }
        }
        return endPoint;
    };
    /**
     * Gets the grids that intersect with the line segment defined by the start and end points.
     * @param {PointModel} startPoint - The starting point of the line segment.
     * @param {PointModel} endPoint - The ending point of the line segment.
     * @returns {VirtualBoundaries[]} An array of VirtualBoundaries that intersect with the line segment.
     * @private
     */
    LineRouting.prototype.getGridsIntersect = function (startPoint, endPoint) {
        var grids = [];
        var minX = Math.min(startPoint.x, endPoint.x);
        var minY = Math.min(startPoint.y, endPoint.y);
        var maxX = Math.max(startPoint.x, endPoint.x);
        var maxY = Math.max(startPoint.y, endPoint.y);
        var gridSize = this.size;
        var minGridX = Math.floor((minX - this.diagramStartX) / gridSize);
        var minGridY = Math.floor((minY - this.diagramStartY) / gridSize);
        var maxGridX = Math.floor((maxX - this.diagramStartX) / gridSize);
        var maxGridY = Math.floor((maxY - this.diagramStartY) / gridSize);
        var isHorizontal = maxX - minX > maxY - minY;
        if (isHorizontal) {
            for (var x = minGridX; x <= maxGridX; x++) {
                var grid = this.gridCollection[parseInt(x.toString(), 10)][parseInt(minGridY.toString(), 10)];
                if (grid && grids.indexOf(grid) === -1) {
                    grids.push(grid);
                }
            }
        }
        else {
            for (var y = minGridY; y <= maxGridY; y++) {
                var grid = this.gridCollection[parseInt(minGridX.toString(), 10)][parseInt(y.toString(), 10)];
                if (grid && grids.indexOf(grid) === -1) {
                    grids.push(grid);
                }
            }
        }
        return grids;
    };
    /**
     * Checks if the path between the start and end points is walkable.
     * @param {PointModel} startPoint - The starting point of the path.
     * @param {PointModel} endPoint - The ending point of the path.
     * @param {Diagram} diagram - The diagram instance.
     * @param {Connector} [connector] - The connector to check for obstacles.
     * @returns {boolean} True if the path is walkable, otherwise false.
     * @private
     */
    LineRouting.prototype.isPathWalkable = function (startPoint, endPoint, diagram, connector) {
        var minX = Math.min(startPoint.x, endPoint.x);
        var minY = Math.min(startPoint.y, endPoint.y);
        var maxX = Math.max(startPoint.x, endPoint.x);
        var maxY = Math.max(startPoint.y, endPoint.y);
        var grids = this.getGridsIntersect(startPoint, endPoint);
        for (var i = 0; i < grids.length; i++) {
            var grid = grids[parseInt(i.toString(), 10)];
            // Exclude grids that contain the source or target node
            if (connector && (grid.nodeId.indexOf(connector.sourceID) !== -1 || grid.nodeId.indexOf(connector.targetID) !== -1)) {
                continue;
            }
            if (!grid.walkable) {
                var isHorizontal = maxX - minX > maxY - minY;
                for (var _i = 0, _a = grid.nodeId; _i < _a.length; _i++) {
                    var nodeId = _a[_i];
                    var node = diagram.nameTable["" + nodeId];
                    if (node) {
                        var bounds = node.wrapper.bounds;
                        var padding = 5;
                        if (isHorizontal) {
                            if (bounds.top - padding < minY && bounds.bottom + padding > maxY) {
                                return false;
                            }
                        }
                        else {
                            if (bounds.left - padding < minX && bounds.right + padding > maxX) {
                                return false;
                            }
                        }
                    }
                }
            }
        }
        return true;
    };
    LineRouting.prototype.checkObstaclesIntersect = function (segmentPoints, connector, diagram) {
        for (var i = 1; i < segmentPoints.length; i++) {
            var start = segmentPoints[i - 1];
            var end = segmentPoints[parseInt(i.toString(), 10)];
            if (!this.isPathWalkable(start, end, diagram, connector)) {
                return false;
            }
        }
        return true;
    };
    /**
     * refreshConnectorSegments method \
     *
     * @returns { void }     refreshConnectorSegments method .\
     * @param {Diagram} diagram - provide the diagram value.
     * @param {Connector} connector - provide the connector value.
     * @param {boolean} isUpdate - provide the diagram value.
     * @param {boolean} isEnableRouting - provide enableRouting value.
     *
     * @private
     */
    LineRouting.prototype.refreshConnectorSegments = function (diagram, connector, isUpdate, isEnableRouting) {
        if (!connector.sourceID || !connector.targetID || connector.sourceID === connector.targetID) {
            return;
        }
        if (!this.skipObstacleCheck && connector.intermediatePoints
            && this.checkObstaclesIntersect(connector.intermediatePoints, connector, diagram)) {
            if (diagram.avoidLineOverlappingModule && isUpdate) {
                diagram.avoidLineOverlappingModule.addConnector(connector);
                diagram.avoidLineOverlappingModule.refreshModifiedConnectors(diagram);
            }
            return;
        }
        var sourceId = connector.sourceID;
        var targetId = connector.targetID;
        var sourcePortID = connector.sourcePortID;
        var targetPortID = connector.targetPortID;
        var startPoint;
        var targetPoint;
        var sourcePortDirection;
        var targetPortDirection;
        var grid;
        var sourceTop;
        var sourceBottom;
        var isBreak;
        var sourceLeft;
        var sourceRight;
        var targetRight;
        var targetTop;
        var targetBottom;
        var targetLeft;
        if (canEnableRouting(connector, diagram) || isEnableRouting) {
            this.startNode = diagram.nameTable["" + sourceId];
            this.targetNode = diagram.nameTable["" + targetId];
            this.intermediatePoints = [];
            this.startArray = [];
            this.targetGridCollection = [];
            this.sourceGridCollection = [];
            this.startGrid = undefined;
            this.targetGrid = undefined;
            for (var i = 0; i < this.noOfCols; i++) {
                for (var j = 0; j < this.noOfRows; j++) {
                    this.gridCollection[parseInt(j.toString(), 10)][parseInt(i.toString(), 10)].tested
                        = this.gridCollection[parseInt(j.toString(), 10)][parseInt(i.toString(), 10)].parent = undefined;
                    this.gridCollection[parseInt(j.toString(), 10)][parseInt(i.toString(), 10)].previousDistance
                        = this.gridCollection[parseInt(j.toString(), 10)][parseInt(i.toString(), 10)].afterDistance = undefined;
                    this.gridCollection[parseInt(j.toString(), 10)][parseInt(i.toString(), 10)].totalDistance = undefined;
                }
            }
            // Set the source point and target point
            startPoint = this.findEndPoint(connector, true);
            targetPoint = this.findEndPoint(connector, false);
            // Find the start grid and target grid
            for (var i = 0; i < this.noOfRows; i++) {
                for (var j = 0; j < this.noOfCols; j++) {
                    grid = this.gridCollection[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)];
                    var rectangle = new Rect(grid.x, grid.y, grid.width, grid.height);
                    if (rectangle.containsPoint(startPoint) && !this.startGrid &&
                        (grid.nodeId.indexOf(sourceId) !== -1 || sourceId === '')) {
                        this.startGrid = (sourcePortID && this.startGrid &&
                            ( sourcePortDirection === 'Top')) ? this.startGrid : grid;
                    }
                    if (rectangle.containsPoint(targetPoint) && !this.targetGrid &&
                        (grid.nodeId.indexOf(targetId) !== -1 || targetId === '')) {
                        this.targetGrid = (targetPortID && this.targetGrid &&
                            ( targetPortDirection === 'Top')) ? this.targetGrid : grid;
                    }
                    if (!sourcePortID && this.startNode) {
                        var bounds = this.startNode.wrapper.bounds;
                        if (rectangle.containsPoint(bounds.topCenter) && !sourceTop) {
                            sourceTop = grid;
                        }
                        if (rectangle.containsPoint(bounds.middleLeft) && !sourceLeft) {
                            sourceLeft = grid;
                        }
                        if (rectangle.containsPoint(bounds.middleRight) && !sourceRight) {
                            sourceRight = grid;
                        }
                        if (rectangle.containsPoint(bounds.bottomCenter) && !sourceBottom) {
                            sourceBottom = grid;
                        }
                    }
                    if (!targetPortID && this.targetNode) {
                        var bounds = this.targetNode.wrapper.bounds;
                        if (rectangle.containsPoint(bounds.topCenter) && !targetTop) {
                            targetTop = grid;
                        }
                        if (rectangle.containsPoint(bounds.middleLeft) && !targetLeft) {
                            targetLeft = grid;
                        }
                        if (rectangle.containsPoint(bounds.middleRight) && !targetRight) {
                            targetRight = grid;
                        }
                        if (rectangle.containsPoint({ x: bounds.bottomCenter.x, y: bounds.bottomCenter.y }) && !targetBottom) {
                            targetBottom = grid;
                        }
                    }
                }
            }
            this.findEdgeBoundary(sourcePortID, sourceLeft, sourceRight, sourceTop, sourceBottom, true);
            this.findEdgeBoundary(targetPortID, targetLeft, targetRight, targetTop, targetBottom, false);
            this.startGrid.totalDistance = 0;
            this.startGrid.previousDistance = 0;
            this.intermediatePoints.push({ x: this.startGrid.gridX, y: this.startGrid.gridY });
            this.startArray.push(this.startGrid);
            if (connector && targetLeft && targetRight && targetTop && targetBottom) {
                this.checkObstacles(connector, diagram, targetLeft, targetRight, targetTop, targetBottom);
            }
            // eslint-disable-next-line no-labels
            renderPathElement: while (this.startArray.length > 0) {
                var startGridNode = this.startArray.pop();
                //890444:Exception thrown while drag and drop shapes on top of each other repeatedly with Line Routing
                if (startGridNode) {
                    for (var i = 0; i < this.targetGridCollection.length; i++) {
                        var target = this.targetGridCollection[parseInt(i.toString(), 10)];
                        if (startGridNode) {
                            if (startGridNode.gridX === target.gridX && startGridNode.gridY === target.gridY) {
                                this.getIntermediatePoints(startGridNode);
                                this.optimizeIntermediatePoints();
                                if (startGridNode.nodeId && startGridNode.nodeId.length > 1) {
                                    connector.segments = [];
                                }
                                isBreak = this.updateConnectorSegments(diagram, this.intermediatePoints, this.gridCollection, connector, isUpdate);
                                if (!isBreak) {
                                    this.targetGridCollection.splice(this.targetGridCollection.indexOf(target), 1);
                                    startGridNode = this.startArray.pop();
                                }
                                else {
                                    this.considerWalkable = [];
                                    // eslint-disable-next-line no-labels
                                    break renderPathElement;
                                }
                            }
                        }
                    }
                    if (startGridNode) {
                        this.findPath(startGridNode);
                    }
                }
            }
        }
    };
    LineRouting.prototype.checkChildNodes = function (grid, isSource) {
        var check = false;
        var reject = false;
        if (grid.nodeId.length >= 1 && !isSource) {
            for (var i = 0; i < grid.nodeId.length; i++) {
                var id = grid.nodeId[parseInt(i.toString(), 10)];
                for (var j = 0; j < grid.nodeId.length; j++) {
                    if (this.targetNode.parentId === grid.nodeId[parseInt(j.toString(), 10)]) {
                        reject = true;
                    }
                }
                if (!reject && this.targetNode.id === id) {
                    check = true;
                }
                else {
                    check = false;
                }
            }
        }
        else {
            if (grid.nodeId.length === 1) {
                check = true;
            }
        }
        return check;
    };
    LineRouting.prototype.findEdgeBoundary = function (portID, left, right, top, bottom, isSource) {
        var grid;
        var collection = (isSource) ? this.sourceGridCollection : this.targetGridCollection;
        if (!portID && ((isSource) ? this.startNode : this.targetNode)) {
            for (var i = left.gridX; i <= right.gridX; i++) {
                grid = this.gridCollection[parseInt(i.toString(), 10)][left.gridY];
                if ((this.checkChildNodes(grid, isSource) && (i === left.gridX || i === right.gridX)) ||
                    (i !== left.gridX && i !== right.gridX)) {
                    collection.push(grid);
                }
            }
            for (var i = top.gridY; i <= bottom.gridY; i++) {
                grid = this.gridCollection[top.gridX][parseInt(i.toString(), 10)];
                if (((this.checkChildNodes(grid, isSource) && (i === top.gridY || i === bottom.gridY)) ||
                    (i !== top.gridY && i !== bottom.gridY)) && collection.indexOf(grid) === -1) {
                    collection.push(grid);
                }
            }
        }
        else {
            collection.push((isSource) ? this.startGrid : this.targetGrid);
        }
    };
    LineRouting.prototype.checkObstacles = function (connector, diagram, targetLeft, targetRight, targetTop, targetBottom) {
        var neigbours = this.findNearestNeigbours(this.startGrid, this.gridCollection, true);
        if (neigbours.length === 0) {
            if (connector.sourcePortID !== '') {
                var endPoint = { x: connector.sourcePortWrapper.offsetX, y: connector.sourcePortWrapper.offsetY };
                var portDirection = getPortDirection(endPoint, undefined, connector.sourceWrapper.bounds);
                if (portDirection === 'Top') {
                    this.resetGridColl(this.startGrid, 'top', true);
                }
                else if (portDirection === 'Right') {
                    this.resetGridColl(this.startGrid, 'right', true);
                }
                else if (portDirection === 'Bottom') {
                    this.resetGridColl(this.startGrid, 'bottom', true);
                }
                else {
                    this.resetGridColl(this.startGrid, 'left', true);
                }
            }
            else {
                this.resetGridColl(this.startGrid, 'top', true);
                this.resetGridColl(this.startGrid, 'right', true);
                this.resetGridColl(this.startGrid, 'bottom', true);
                this.resetGridColl(this.startGrid, 'left', true);
            }
        }
        neigbours = this.findNearestNeigbours(this.targetGrid, this.gridCollection, false);
        if (neigbours.length === 0) {
            if (connector.targetPortID !== '') {
                var endPoint = { x: connector.targetPortWrapper.offsetX, y: connector.targetPortWrapper.offsetY };
                var portDirection = getPortDirection(endPoint, undefined, connector.targetWrapper.bounds);
                if (portDirection === 'Top') {
                    this.resetGridColl(this.targetGrid, 'top', true);
                }
                else if (portDirection === 'Right') {
                    this.resetGridColl(this.targetGrid, 'right', true);
                }
                else if (portDirection === 'Bottom') {
                    this.resetGridColl(this.targetGrid, 'bottom', true);
                }
                else {
                    this.resetGridColl(this.targetGrid, 'left', true);
                }
            }
            else {
                this.resetGridColl(this.targetGrid, 'top', false);
                this.resetGridColl(this.targetGrid, 'right', false);
                this.resetGridColl(this.targetGrid, 'bottom', false);
                this.resetGridColl(this.targetGrid, 'left', false);
            }
        }
        if (this.targetGridCollection.length > 1 && this.targetGridCollection[0].nodeId.length > 1) {
            for (var i = 0; i <= 1; i++) {
                var gridX = this.targetGridCollection[parseInt(i.toString(), 10)].gridX;
                var gridY = this.targetGridCollection[parseInt(i.toString(), 10)].gridY;
                var gridNodes = this.targetGridCollection[parseInt(i.toString(), 10)].nodeId;
                var targetNode = void 0;
                for (var k = 0; k < gridNodes.length; k++) {
                    if (this.targetNode.id !== gridNodes[parseInt(k.toString(), 10)]) {
                        targetNode = gridNodes[parseInt(k.toString(), 10)];
                        break;
                    }
                }
                var targetNodewrapper = void 0;
                var overLapNode = void 0;
                var contains = void 0;
                if (diagram.nameTable[this.targetNode.id]) {
                    targetNodewrapper = diagram.nameTable[this.targetNode.id].wrapper;
                }
                if (diagram.nameTable["" + targetNode]) {
                    overLapNode = diagram.nameTable["" + targetNode].wrapper;
                }
                if (targetNodewrapper && overLapNode) {
                    contains = this.contains(overLapNode.bounds, targetNodewrapper.bounds);
                }
                var reject = void 0;
                for (var j = 0; j < gridNodes.length; j++) {
                    if (this.targetNode.parentId === gridNodes[parseInt(j.toString(), 10)]) {
                        reject = true;
                    }
                }
                if (!this.gridCollection[parseInt(gridX.toString(), 10)][parseInt(gridY.toString(), 10)].walkable && contains && !reject) {
                    var grid = void 0;
                    var diff = void 0;
                    grid = this.getEndvalue(targetLeft, 'left');
                    diff = targetLeft.gridX - grid.gridX;
                    this.changeValue(targetLeft, diff, 'left');
                    grid = this.getEndvalue(targetRight, 'right');
                    diff = grid.gridX - targetRight.gridX;
                    this.changeValue(targetRight, diff, 'right');
                    grid = this.getEndvalue(targetTop, 'top');
                    diff = targetTop.gridY - grid.gridY;
                    this.changeValue(targetTop, diff, 'top');
                    grid = this.getEndvalue(targetBottom, 'bottom');
                    diff = targetBottom.gridY - grid.gridY;
                    this.changeValue(targetBottom, diff, 'top');
                }
            }
        }
    };
    LineRouting.prototype.contains = function (rect1, rect2) {
        return rect1.left <= rect2.left && rect1.right >= rect2.right && rect1.top <= rect2.top && rect1.bottom >= rect2.bottom;
    };
    LineRouting.prototype.getEndvalue = function (target, direction) {
        if (!this.gridCollection[target.gridX][target.gridY].walkable) {
            if (direction === 'left') {
                return this.getEndvalue(this.gridCollection[target.gridX - 1][target.gridY], direction);
            }
            if (direction === 'right') {
                return this.getEndvalue(this.gridCollection[target.gridX + 1][target.gridY], direction);
            }
            if (direction === 'top') {
                return this.getEndvalue(this.gridCollection[target.gridX][target.gridY - 1], direction);
            }
            if (direction === 'bottom') {
                return this.getEndvalue(this.gridCollection[target.gridX][target.gridY + 1], direction);
            }
        }
        else {
            return target;
        }
        return target;
    };
    LineRouting.prototype.changeValue = function (targetLeft, diff, direction) {
        if (!targetLeft.walkable) {
            this.considerWalkable.push(targetLeft);
        }
        var grid;
        for (var i = 0; i <= diff; i++) {
            if (direction === 'left') {
                grid = this.gridCollection[targetLeft.gridX - i][targetLeft.gridY];
            }
            else if (direction === 'right') {
                grid = this.gridCollection[targetLeft.gridX + i][targetLeft.gridY];
            }
            else if (direction === 'top') {
                grid = this.gridCollection[targetLeft.gridX][targetLeft.gridY - i];
            }
            else if (direction === 'bottom') {
                grid = this.gridCollection[targetLeft.gridX][targetLeft.gridY + i];
            }
            if (!grid.walkable) {
                this.considerWalkable.push(grid);
            }
        }
    };
    // Get all the intermediated points from target grid
    LineRouting.prototype.getIntermediatePoints = function (target) {
        var distance;
        this.intermediatePoints = [];
        while (target) {
            this.intermediatePoints.push({ x: target.gridX, y: target.gridY });
            target = target.parent;
        }
        this.intermediatePoints.reverse();
        //890444: Exception thrown while drag and drop shapes on top of each other repeatedly with Line Routing
        if (this.intermediatePoints.length >= 1 && this.intermediatePoints[0] !== undefined
            && this.intermediatePoints[1] !== undefined) {
            if (this.intermediatePoints[0].x === this.intermediatePoints[1].x) {
                if (this.intermediatePoints[0].y < this.intermediatePoints[1].y) {
                    distance = this.neigbour(this.startGrid, 'bottom', undefined, true);
                    this.intermediatePoints[0].y += distance - 1;
                }
                else {
                    distance = this.neigbour(this.startGrid, 'top', undefined, true);
                    this.intermediatePoints[0].y -= distance - 1;
                }
            }
            else {
                if (this.intermediatePoints[0].x < this.intermediatePoints[1].x) {
                    distance = this.neigbour(this.startGrid, 'right', undefined, true);
                    this.intermediatePoints[0].x += distance - 1;
                }
                else {
                    distance = this.neigbour(this.startGrid, 'left', undefined, true);
                    this.intermediatePoints[0].x -= distance - 1;
                }
            }
        }
    };
    LineRouting.prototype.optimizeIntermediatePoints = function () {
        this.intermediatePoints = this.removePointsInSameLine(this.intermediatePoints);
        this.intermediatePoints = this.getValidPoints(this.intermediatePoints);
    };
    LineRouting.prototype.removePointsInSameLine = function (points) {
        if (points.length < 3) {
            return points;
        }
        var result = [points[0]];
        for (var i = 1; i < points.length - 1; i++) {
            var prevPoint = result[result.length - 1];
            var currentPoint = points[parseInt(i.toString(), 10)];
            var nextPoint = points[i + 1];
            if (!this.arePointsInSameLine(prevPoint, currentPoint, nextPoint)) {
                result.push(currentPoint);
            }
        }
        result.push(points[points.length - 1]);
        return result;
    };
    LineRouting.prototype.arePointsInSameLine = function (point1, point2, point3) {
        return (point2.x - point1.x) * (point3.y - point1.y) === (point3.x - point1.x) * (point2.y - point1.y);
    };
    LineRouting.prototype.getValidPoints = function (points) {
        if (points.length < 4) {
            return points;
        }
        var i = 1;
        while (i < points.length - 3) {
            var lineStart1 = points[parseInt(i.toString(), 10)];
            var lineEnd1 = points[i + 1];
            var lineStart2 = points[i + 2];
            var lineEnd2 = points[i + 3];
            if (lineStart1.x === lineEnd1.x) {
                if ((lineEnd1.y < lineStart1.y && lineEnd2.y < lineStart2.y)
                    || (lineEnd1.y > lineStart1.y && lineEnd2.y > lineStart2.y)) {
                    var dx = lineStart1.x < lineStart2.x ? 1 : -1;
                    var dy = lineEnd1.y < lineStart1.y ? -1 : 1;
                    var neigbourGridX = lineStart1.x + dx;
                    var neigbourGridY = lineStart1.y;
                    var isValid = false;
                    while (neigbourGridX !== lineEnd2.x || neigbourGridY !== lineEnd2.y) {
                        if (!this.isWalkable(neigbourGridX, neigbourGridY)) {
                            isValid = false;
                            break;
                        }
                        else {
                            isValid = true;
                        }
                        if (neigbourGridX !== lineStart2.x) {
                            neigbourGridX += dx;
                        }
                        else {
                            neigbourGridY += dy;
                        }
                    }
                    if (isValid) {
                        lineStart1.x = lineStart2.x;
                        points.splice(i + 1, 2);
                        continue;
                    }
                }
            }
            else if (lineStart1.y === lineEnd1.y) {
                if ((lineEnd1.x < lineStart1.x && lineEnd2.x < lineStart2.x)
                    || (lineEnd1.x > lineStart1.x && lineEnd2.x > lineStart2.x)) {
                    var dy1 = lineStart1.y < lineStart2.y ? 1 : -1;
                    var dx1 = lineEnd1.x < lineStart1.x ? -1 : 1;
                    var neigbourGridY1 = lineStart1.y + dy1;
                    var neigbourGridX1 = lineStart1.x;
                    var isValid1 = false;
                    while (neigbourGridX1 !== lineEnd2.x || neigbourGridY1 !== lineEnd2.y) {
                        if (!this.isWalkable(neigbourGridX1, neigbourGridY1)) {
                            isValid1 = false;
                            break;
                        }
                        else {
                            isValid1 = true;
                        }
                        if (neigbourGridY1 !== lineStart2.y) {
                            neigbourGridY1 += dy1;
                        }
                        else {
                            neigbourGridX1 += dx1;
                        }
                    }
                    if (isValid1) {
                        lineStart1.y = lineStart2.y;
                        points.splice(i + 1, 2);
                        continue;
                    }
                }
            }
            i++;
        }
        return points;
    };
    // Connector rendering
    /* tslint:disable */
    LineRouting.prototype.updateConnectorSegments = function (diagram, intermediatePoints, gridCollection, connector, isUpdate) {
        var segments = [];
        var seg;
        var targetPoint;
        var pointX;
        var pointY;
        var node;
        var points = [];
        var direction;
        var length;
        var currentdirection;
        var prevDirection;
        var targetWrapper = connector.targetWrapper;
        var sourceWrapper = connector.sourceWrapper;
        var sourcePoint = this.findEndPoint(connector, true);
        if (connector.targetPortID !== '' || !connector.targetWrapper) {
            targetPoint = this.findEndPoint(connector, false, true);
        }
        for (var i = 0; i < intermediatePoints.length; i++) {
            node = gridCollection[intermediatePoints[parseInt(i.toString(), 10)].x][intermediatePoints[parseInt(i.toString(), 10)].y];
            if (node) {
                pointX = node.x + node.width / 2;
                pointY = node.y + node.height / 2;
                points.push({ x: pointX, y: pointY });
                if (i >= 1 && points.length > 1) {
                    if (points[points.length - 2].x !== points[points.length - 1].x) {
                        currentdirection = (points[points.length - 2].x > points[points.length - 1].x) ? 'Left' : 'Right';
                    }
                    else {
                        currentdirection = (points[points.length - 2].y > points[points.length - 1].y) ? 'Top' : 'Bottom';
                    }
                }
                if (i >= 2 && prevDirection === currentdirection && points.length > 1) {
                    points.splice(points.length - 2, 1);
                }
                prevDirection = currentdirection;
            }
        }
        if (points && points.length > 1) {
            for (var j = 0; j < points.length - 1; j++) {
                var currentPoint = points[parseInt(j.toString(), 10)];
                var nextPoint = points[j + 1];
                if (currentPoint.x !== nextPoint.x) {
                    if (j === 0 && connector.sourcePortID === '' && sourceWrapper) {
                        sourcePoint = (currentPoint.x > nextPoint.x)
                            ? sourceWrapper.bounds.middleLeft : sourceWrapper.bounds.middleRight;
                    }
                    if (j === points.length - 2 && connector.targetPortID === '' && targetWrapper) {
                        targetPoint = (currentPoint.x > nextPoint.x)
                            ? targetWrapper.bounds.middleRight : targetWrapper.bounds.middleLeft;
                    }
                    if (j === 0 && sourcePoint) {
                        currentPoint.x = sourcePoint.x;
                        currentPoint.y = nextPoint.y = sourcePoint.y;
                        //Bug:849859 -set node bounds as source point if intersected point exists inside the node
                        if (connector.sourcePortID === '') {
                            var newDirection = currentPoint.x > nextPoint.x ? 'Left' : 'Right';
                            var refPoint = findPoint(sourceWrapper.bounds, getOppositeDirection(newDirection));
                            sourcePoint = getIntersection(connector, sourceWrapper, sourcePoint, refPoint, false);
                        }
                        currentPoint.x = sourcePoint.x;
                    }
                    if (j === points.length - 2 && targetPoint) {
                        if (j > 0 && connector.targetDecorator &&
                            ((targetPoint.x - nextPoint.x) < 0) &&
                            (Math.abs(targetPoint.x - currentPoint.x) < connector.targetDecorator.width + 1)) {
                            currentPoint.x = points[j - 1].x -= this.size / 2;
                        }
                        if (j > 0 && connector.targetDecorator &&
                            ((targetPoint.x - nextPoint.x) > 0) &&
                            (Math.abs(targetPoint.x - currentPoint.x) < connector.targetDecorator.width + 1)) {
                            currentPoint.x = points[j - 1].x += this.size / 2;
                        }
                        nextPoint.x = targetPoint.x;
                        currentPoint.y = nextPoint.y = targetPoint.y;
                    }
                }
                else {
                    //EJ2-855805 - Connector target decorator is not proper in complexhierarchical layout when we call doLayout with line-routing
                    if (j === 0 && connector.sourcePortID === '' && sourceWrapper) {
                        sourcePoint = (currentPoint.y > nextPoint.y)
                            ? sourceWrapper.bounds.topCenter : sourceWrapper.bounds.bottomCenter;
                    }
                    if (j === points.length - 2 && connector.targetPortID === '' && targetWrapper) {
                        targetPoint = (currentPoint.y > nextPoint.y)
                            ? targetWrapper.bounds.bottomCenter : targetWrapper.bounds.topCenter;
                    }
                    if (j === 0 && sourcePoint) {
                        currentPoint.y = sourcePoint.y;
                        currentPoint.x = nextPoint.x = sourcePoint.x;
                        //Bug:849859 -set node bounds as source point if intersected point exists inside the node
                        if (connector.sourcePortID === '') {
                            var newDirection1 = currentPoint.y > nextPoint.y ? 'Top' : 'Bottom';
                            var refPoint = findPoint(sourceWrapper.bounds, getOppositeDirection(newDirection1));
                            sourcePoint = getIntersection(connector, sourceWrapper, sourcePoint, refPoint, false);
                        }
                        currentPoint.y = sourcePoint.y;
                    }
                    if (j === points.length - 2 && targetPoint) {
                        if (j > 0 && connector.targetDecorator &&
                            ((targetPoint.y - nextPoint.y) < 0) &&
                            (Math.abs(targetPoint.y - currentPoint.y) < connector.targetDecorator.height + 1)) {
                            currentPoint.y = points[j - 1].y -= this.size / 2;
                        }
                        if (j > 0 && connector.targetDecorator &&
                            ((targetPoint.y - nextPoint.y) > 0) &&
                            (Math.abs(targetPoint.y - currentPoint.y) < connector.targetDecorator.height + 1)) {
                            currentPoint.y = points[j - 1].y += this.size / 2;
                        }
                        nextPoint.y = targetPoint.y;
                        currentPoint.x = nextPoint.x = targetPoint.x;
                    }
                }
            }
            if (diagram.avoidLineOverlappingModule && isUpdate) {
                diagram.avoidLineOverlappingModule.addConnector(connector, points);
                var modifiedConnectors = diagram.avoidLineOverlappingModule.getModifiedConnector();
                if (modifiedConnectors.has(connector)) {
                    segments = diagram.avoidLineOverlappingModule.getModifiedConnectorSegments(connector);
                    modifiedConnectors.delete(connector);
                }
                if (modifiedConnectors.size > 0) {
                    diagram.avoidLineOverlappingModule.refreshModifiedConnectors(diagram);
                }
            }
            if (segments.length === 0) {
                for (var j = 0; j < points.length - 1; j++) {
                    var currentPoint = points[parseInt(j.toString(), 10)];
                    var nextPoint = points[j + 1];
                    if (currentPoint.x !== nextPoint.x) {
                        if (currentPoint.x > nextPoint.x) {
                            direction = 'Left';
                            length = currentPoint.x - nextPoint.x;
                        }
                        else {
                            direction = 'Right';
                            length = nextPoint.x - currentPoint.x;
                        }
                    }
                    else {
                        if (currentPoint.y > nextPoint.y) {
                            direction = 'Top';
                            length = currentPoint.y - nextPoint.y;
                        }
                        else {
                            direction = 'Bottom';
                            length = nextPoint.y - currentPoint.y;
                        }
                    }
                    seg = { type: 'Orthogonal', length: length, direction: direction };
                    segments.push(seg);
                }
            }
        }
        if (segments && segments.length > 0) {
            var lastSeg = segments[segments.length - 1];
            if (segments.length === 1) {
                lastSeg.length -= 20;
            }
            if (lastSeg.length < 10 && segments.length === 2) {
                segments.pop();
                if (segments.length > 0) {
                    segments[0].length -= 20;
                    lastSeg = segments[0];
                }
            }
            if (connector.targetDecorator &&
                ((lastSeg.direction === 'Top' || lastSeg.direction === 'Bottom') && lastSeg.length > connector.targetDecorator.height + 1) ||
                ((lastSeg.direction === 'Right' || lastSeg.direction === 'Left') && lastSeg.length > connector.targetDecorator.width + 1)) {
                if (isUpdate || !diagram.avoidLineOverlappingModule) {
                    connector.segments = segments;
                }
                if (isUpdate) {
                    diagram.connectorPropertyChange(connector, {}, { type: 'Orthogonal', segments: segments });
                }
                return true;
            }
        }
        return false;
    };
    /* tslint:enable */
    // Shortest path
    LineRouting.prototype.findPath = function (startGrid) {
        var intermediatePoint;
        var collection = [];
        var neigbours = this.findNearestNeigbours(startGrid, this.gridCollection, true);
        for (var i = 0; i < neigbours.length; i++) {
            intermediatePoint = this.findIntermediatePoints(neigbours[parseInt(i.toString(), 10)].gridX, neigbours[parseInt(i.toString(), 10)].gridY, startGrid.gridX, startGrid.gridY, this.targetGrid.gridX, this.targetGrid.gridY);
            if (intermediatePoint !== null) {
                var grid = this.gridCollection[intermediatePoint.x][intermediatePoint.y];
                var h = this.octile(Math.abs(intermediatePoint.x - startGrid.gridX), Math.abs(intermediatePoint.y - startGrid.gridY));
                if (startGrid.parent && startGrid.parent.parent) {
                    if (grid.gridX !== startGrid.parent.gridX && grid.gridY !== startGrid.parent.gridY) {
                        h += 0.1;
                    }
                }
                var l = startGrid.previousDistance + h;
                if ((!grid.previousDistance || grid.previousDistance > l) &&
                    (!(intermediatePoint.x === startGrid.gridX && intermediatePoint.y === startGrid.gridY))) {
                    collection.push(intermediatePoint);
                    grid.previousDistance = l;
                    grid.afterDistance = grid.afterDistance || this.manhattan(Math.abs(intermediatePoint.x - this.targetGrid.gridX), Math.abs(intermediatePoint.y - this.targetGrid.gridY));
                    grid.totalDistance = grid.previousDistance + grid.afterDistance;
                    grid.parent = startGrid;
                }
            }
        }
        if (collection.length > 0) {
            for (var i = 0; i < collection.length; i++) {
                var grid = this.gridCollection[collection[parseInt(i.toString(), 10)].x][collection[parseInt(i.toString(), 10)].y];
                if (this.startArray.indexOf(grid) === -1) {
                    this.startArray.push(grid);
                }
            }
        }
        this.sorting(this.startArray);
    };
    // sorting the array based on total distance between source and target node
    LineRouting.prototype.sorting = function (array) {
        var done = false;
        while (!done) {
            done = true;
            for (var i = 1; i < array.length; i += 1) {
                if (array[i - 1].totalDistance < array[parseInt(i.toString(), 10)].totalDistance) {
                    done = false;
                    var tmp = array[i - 1];
                    array[i - 1] = array[parseInt(i.toString(), 10)];
                    array[parseInt(i.toString(), 10)] = tmp;
                }
            }
        }
        return array;
    };
    LineRouting.prototype.octile = function (t, e) {
        var r = Math.SQRT2 - 1;
        return e > t ? r * t + e : r * e + t;
    };
    LineRouting.prototype.manhattan = function (t, e) {
        return t + e;
    };
    // Find the nearest neigbour from the current boundaries, the neigbour is use to find next intermdiate point.
    LineRouting.prototype.findNearestNeigbours = function (startGrid, gridCollection, isSource) {
        var neigbours = [];
        var parent = startGrid.parent;
        if (parent) {
            var dx = (startGrid.gridX - parent.gridX) / Math.max(Math.abs(startGrid.gridX - parent.gridX), 1);
            var dy = (startGrid.gridY - parent.gridY) / Math.max(Math.abs(startGrid.gridY - parent.gridY), 1);
            if (dx !== 0) {
                if (this.isWalkable(startGrid.gridX, startGrid.gridY - 1, true) &&
                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX][startGrid.gridY - 1]) === -1) {
                    neigbours.push(gridCollection[startGrid.gridX][startGrid.gridY - 1]);
                }
                if (this.isWalkable(startGrid.gridX, startGrid.gridY + 1, true) &&
                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX][startGrid.gridY + 1])) {
                    neigbours.push(gridCollection[startGrid.gridX][startGrid.gridY + 1]);
                }
                if (this.isWalkable(startGrid.gridX + dx, startGrid.gridY, true) &&
                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX + dx][startGrid.gridY]) === -1) {
                    neigbours.push(gridCollection[startGrid.gridX + dx][startGrid.gridY]);
                }
            }
            else if (dy !== 0) {
                if (this.isWalkable(startGrid.gridX - 1, startGrid.gridY, true) &&
                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX - 1][startGrid.gridY]) === -1) {
                    neigbours.push(gridCollection[startGrid.gridX - 1][startGrid.gridY]);
                }
                if (this.isWalkable(startGrid.gridX + 1, startGrid.gridY, true) &&
                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX + 1][startGrid.gridY]) === -1) {
                    neigbours.push(gridCollection[startGrid.gridX + 1][startGrid.gridY]);
                }
                if (this.isWalkable(startGrid.gridX, startGrid.gridY + dy, true) &&
                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX][startGrid.gridY + dy]) === -1) {
                    neigbours.push(gridCollection[startGrid.gridX][startGrid.gridY + dy]);
                }
            }
        }
        else {
            this.neigbour(startGrid, 'top', neigbours, isSource);
            this.neigbour(startGrid, 'right', neigbours, isSource);
            this.neigbour(startGrid, 'bottom', neigbours, isSource);
            this.neigbour(startGrid, 'left', neigbours, isSource);
        }
        return neigbours;
    };
    LineRouting.prototype.neigbour = function (startGrid, direction, neigbours, isSource) {
        var i = 1;
        var nearGrid;
        while (i > 0) {
            var x = (direction === 'top' || direction === 'bottom') ?
                (startGrid.gridX) : ((direction === 'left') ? startGrid.gridX - i : startGrid.gridX + i);
            var y = (direction === 'right' || direction === 'left') ?
                (startGrid.gridY) : ((direction === 'top') ? startGrid.gridY - i : startGrid.gridY + i);
            nearGrid = this.gridCollection[parseInt(x.toString(), 10)][parseInt(y.toString(), 10)];
            if (nearGrid && ((isSource && this.sourceGridCollection.indexOf(nearGrid) === -1)
                || (!isSource && this.targetGridCollection.indexOf(nearGrid) === -1))) {
                if (neigbours && this.isWalkable(x, y)) {
                    neigbours.push(nearGrid);
                }
                return i;
            }
            if (x > 0 && y > 0) {
                i++;
            }
            else {
                break;
            }
        }
        return null;
    };
    LineRouting.prototype.resetGridColl = function (grid, direction, isSource) {
        var i = 1;
        var nearGrid;
        while (i > 0) {
            var x = (direction === 'top' || direction === 'bottom') ?
                (grid.gridX) : ((direction === 'left') ? grid.gridX - i : grid.gridX + i);
            var y = (direction === 'right' || direction === 'left') ?
                (grid.gridY) : ((direction === 'top') ? grid.gridY - i : grid.gridY + i);
            nearGrid = this.gridCollection[parseInt(x.toString(), 10)][parseInt(y.toString(), 10)];
            if (nearGrid && ((isSource && this.sourceGridCollection.indexOf(nearGrid) === -1) ||
                (!isSource && this.targetGridCollection.indexOf(nearGrid) === -1))) {
                if (this.isWalkable(x, y)) {
                    break;
                }
                else {
                    var grid_1 = this.gridCollection[parseInt(x.toString(), 10)][parseInt(y.toString(), 10)];
                    this.considerWalkable.push(grid_1);
                }
            }
            if (x > 0 && y > 0) {
                if (direction === 'top' || direction === 'left') {
                    i--;
                }
                else {
                    i++;
                }
            }
            else {
                break;
            }
        }
        return null;
    };
    LineRouting.prototype.isWalkable = function (x, y, isparent) {
        if (x >= 0 && x < this.noOfRows && y >= 0 && y < this.noOfCols) {
            var grid = this.gridCollection[parseInt(x.toString(), 10)][parseInt(y.toString(), 10)];
            if (grid && (grid.walkable || ((grid.nodeId.length === 1 || (grid.nodeId.length === 2 && grid.parentNodeId
                || (this.considerWalkable.indexOf(grid) !== -1))) &&
                (this.sourceGridCollection.indexOf(grid) !== -1 || this.targetGridCollection.indexOf(grid) !== -1 ||
                    this.considerWalkable.indexOf(grid) !== -1)))) {
                if ((isparent && !grid.parent) || !isparent) {
                    return true;
                }
            }
        }
        return false;
    };
    LineRouting.prototype.findIntermediatePoints = function (neigbourGridX, neigbourGridY, startGridX, startGridY, endGridX, endGridY) {
        var dx = neigbourGridX - startGridX;
        var dy = neigbourGridY - startGridY;
        var gridX = neigbourGridX;
        var gridY = neigbourGridY;
        for (var i = 0; i < this.targetGridCollection.length; i++) {
            if (neigbourGridX === this.targetGridCollection[parseInt(i.toString(), 10)].gridX
                && neigbourGridY === this.targetGridCollection[parseInt(i.toString(), 10)].gridY) {
                return { x: neigbourGridX, y: neigbourGridY };
            }
        }
        if (!this.isWalkable(neigbourGridX, neigbourGridY)) {
            return null;
        }
        var neigbourGrid = this.gridCollection[parseInt(neigbourGridX.toString(), 10)][parseInt(neigbourGridY.toString(), 10)];
        if (neigbourGrid.tested) {
            return { x: neigbourGridX, y: neigbourGridY };
        }
        neigbourGrid.tested = true;
        if (dx !== 0) {
            dx = (dx > 0) ? 1 : -1;
            if ((this.isWalkable(gridX, gridY - 1) && !this.isWalkable(gridX - dx, gridY - 1)) ||
                (this.isWalkable(gridX, gridY + 1) && !this.isWalkable(gridX - dx, gridY + 1))) {
                return { x: neigbourGridX, y: neigbourGridY };
            }
        }
        if (dy !== 0) {
            dy = (dy > 0) ? 1 : -1;
            if ((this.isWalkable(gridX - 1, gridY) && !this.isWalkable(gridX - 1, gridY - dy)) ||
                (this.isWalkable(gridX + 1, gridY) && !this.isWalkable(gridX + 1, gridY - dy))) {
                return { x: neigbourGridX, y: neigbourGridY };
            }
            if (this.findIntermediatePoints(gridX + 1, gridY, gridX, gridY, endGridX, endGridY) ||
                this.findIntermediatePoints(gridX - 1, gridY, gridX, gridY, endGridX, endGridY)) {
                return { x: neigbourGridX, y: neigbourGridY };
            }
        }
        return this.findIntermediatePoints(gridX + dx, gridY + dy, gridX, gridY, endGridX, endGridY);
    };
    /**
     *To destroy the line routing
     *
     * @returns {void} To destroy the line routing
     */
    LineRouting.prototype.destroy = function () {
        /**
         * Destroys the line routing module
         */
    };
    /**
     * Core method to return the component name.
     *
     * @returns {string}  Core method to return the component name.
     * @private
     */
    LineRouting.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'LineRouting';
    };
    return LineRouting;
}());

var __extends$A = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Represents the diagram settings
 * ```html
 * <div id='diagram'></div>
 * ```
 * ```typescript
 * let diagram: Diagram = new Diagram({
 * ...
 * diagramSettings: { inversedAlignment: true },
 * ...
 * });
 * diagram.appendTo('#diagram');
 * ```
 *
 * @default {}
 */
var DiagramSettings = /** @class */ (function (_super) {
    __extends$A(DiagramSettings, _super);
    function DiagramSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$p([
        Property(true)
    ], DiagramSettings.prototype, "inversedAlignment", void 0);
    return DiagramSettings;
}(ChildProperty));

var __extends$B = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$2 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/**
 * Represents the Diagram control
 * ```html
 * <div id='diagram'/>
 * ```
 * ```typescript
 * let diagram: Diagram = new Diagram({
 * width:'1000px', height:'500px' });
 * diagram.appendTo('#diagram');
 * ```
 */
var Diagram = /** @class */ (function (_super) {
    __extends$B(Diagram, _super);
    /**
     * Constructor for creating the widget
     */
    function Diagram(options, element) {
        var _this = _super.call(this, options, element) || this;
        /** @private */
        _this.version = 17.1;
        /** @private */
        _this.checkMenu = false;
        /** @private */
        _this.isServerUpdate = false;
        /** @private */
        _this.oldNodeObjects = [];
        /** @private */
        _this.oldDiagramObject = {};
        /** @private */
        _this.oldConnectorObjects = [];
        /** @private */
        _this.canEnableBlazorObject = false;
        /** @private */
        _this.connectorTable = {};
        /** @private */
        _this.groupTable = {};
        /** @private */
        _this.scrollActions = ScrollActions.None;
        /** @private */
        _this.blazorActions = BlazorAction.Default;
        /** @private */
        _this.activeLabel = { id: '', parentId: '', isGroup: false, text: undefined };
        /** @private */
        _this.textEditing = false;
        /** @private */
        _this.isTriggerEvent = false;
        /** @private */
        _this.preventNodesUpdate = false;
        /** @private */
        _this.preventConnectorsUpdate = false;
        /** @private */
        _this.callBlazorModel = true;
        /** @private */
        _this.selectionConnectorsList = [];
        /** @private */
        _this.deleteVirtualObject = false;
        _this.canLayout = true;
        _this.cancelPositionChange = false;
        _this.isRefreshed = false;
        /** @private */
        _this.swimlaneChildTable = {};
        /** @private */
        _this.swimlaneZIndexTable = {};
        /** @private */
        _this.canExpand = false;
        _this.changedConnectorCollection = [];
        _this.changedNodesCollection = [];
        _this.previousNodeCollection = [];
        _this.previousConnectorCollection = [];
        _this.crudDeleteNodes = [];
        _this.previousSelectedObjects = [];
        // Group update to server when BlazorAction is isGroupAction;
        _this.blazorAddorRemoveCollection = [];
        _this.blazorRemoveIndexCollection = [];
        _this.diagramid = 88123;
        _this.portCenterPoint = [];
        /** @private */
        _this.selectedObject = { helperObject: undefined, actualObject: undefined };
        /** @private */
        _this.deleteDependentConnector = true;
        /** @private */
        _this.scaleValue = 1;
        _this.routedConnectors = [];
        /** @private */
        _this.pathDataStorage = new Map();
        // To check current action is undo or redo
        _this.isUndo = false;
        _this.mermaidNodeBaseCollection = [];
        _this.bangShape = 'M0 0 a15.470625686645507,15.470625686645507 1 0,0 25.78437614440918,-3.7200001525878905 a15.470625686645507,15.470625686645507 1 0,0 25.78437614440918,0 a15.470625686645507,15.470625686645507 1 0,0 25.78437614440918,0 a15.470625686645507,15.470625686645507 1 0,0 25.78437614440918,3.7200001525878905 a15.470625686645507,15.470625686645507 1 0,0 15.470625686645507,12.276000503540038 a12.376500549316406,12.376500549316406 1 0,0 0,12.648000518798828 a15.470625686645507,15.470625686645507 1 0,0 -15.470625686645507,12.276000503540038 a15.470625686645507,15.470625686645507 1 0,0 -25.78437614440918,5.580000228881835 a15.470625686645507,15.470625686645507 1 0,0 -25.78437614440918,0 a15.470625686645507,15.470625686645507 1 0,0 -25.78437614440918,0 a15.470625686645507,15.470625686645507 1 0,0 -25.78437614440918,-5.580000228881835 a15.470625686645507,15.470625686645507 1 0,0 -10.313750457763673,-12.276000503540038 a12.376500549316406,12.376500549316406 1 0,0 0,-12.648000518798828 a15.470625686645507,15.470625686645507 1 0,0 10.313750457763673,-12.276000503540038 H0 V0 Z';
        _this.cloudShape = 'M0 0 a16.18875045776367,16.18875045776367 0 0,1 26.981250762939453,-10.792500305175782 a37.77375106811523,37.77375106811523 1 0,1 43.17000122070313,-10.792500305175782 a26.981250762939453,26.981250762939453 1 0,1 37.77375106811523,21.585000610351564 a16.18875045776367,16.18875045776367 1 0,1 16.18875045776367,13.020000534057615 a21.585000610351564,21.585000610351564 1 0,1 -16.18875045776367,24.180000991821288 a26.981250762939453,16.18875045776367 1 0,1 -26.981250762939453,16.18875045776367 a37.77375106811523,37.77375106811523 1 0,1 -53.962501525878906,0 a16.18875045776367,16.18875045776367 1 0,1 -26.981250762939453,-16.18875045776367 a16.18875045776367,16.18875045776367 1 0,1 -10.792500305175782,-13.020000534057615 a21.585000610351564,21.585000610351564 1 0,1 10.792500305175782,-24.180000991821288 H0 V0 Z';
        _this.renderTimer = null;
        var child;
        var node;
        //Removed isBlazor code
        _this.ignoreCollectionWatch = true;
        for (var i = 0; options && options.nodes && i < options.nodes.length; i++) {
            child = options.nodes[parseInt(i.toString(), 10)];
            node = _this.nodes[parseInt(i.toString(), 10)];
            if (child.children && child.children.length > 0) {
                if (!child.style || !child.style.fill) {
                    node.style.fill = 'transparent';
                }
                if (!child.style || !child.style.strokeColor) {
                    node.style.strokeColor = 'transparent';
                }
            }
            if (child.shape && child.shape.type === 'UmlActivity') {
                setUMLActivityDefaults(child, node);
            }
            if (child.shape && child.shape.type === 'SwimLane') {
                setSwimLaneDefaults(child, node);
            }
            // Removed isBlazor code
            if (_this.nodeDefaults) {
                updateDefaultValues(node, child, _this.nodeDefaults);
            }
            _this.updateAnnotationText(node.annotations);
        }
        if (options && options.connectors) {
            for (var i = 0; options && options.connectors && i < options.connectors.length; i++) {
                child = options.connectors[parseInt(i.toString(), 10)];
                node = _this.connectors[parseInt(i.toString(), 10)];
                //Removed isBlazor code
                if (_this.connectorDefaults) {
                    updateDefaultValues(node, child, _this.connectorDefaults);
                }
                _this.updateAnnotationText(node.annotations);
            }
        }
        for (var i = 0; options && options.connectors && i < options.connectors.length; i++) {
            var defaultConnector = options.connectors[parseInt(i.toString(), 10)];
            var connector = _this.connectors[parseInt(i.toString(), 10)];
            if (defaultConnector.shape && defaultConnector.shape.type !== 'None') {
                setConnectorDefaults(defaultConnector, connector);
            }
            //Removed isBlazor code
        }
        return _this;
    }
    Diagram.prototype.updateAnnotationText = function (annotations) {
        //Removed isBlazor code
    };
    Diagram.prototype.clearCollection = function (isConnector) {
        var collection = [];
        var obj;
        for (var _i = 0, _a = Object.keys(this.nameTable); _i < _a.length; _i++) {
            var key = _a[_i];
            obj = this.nameTable["" + key];
            if (obj && ((isConnector && obj instanceof Connector) || (!isConnector && obj instanceof Node))) {
                collection.push(obj);
            }
        }
        this.clearObjects(collection);
    };
    /**
     * Updates the diagram control when the objects are changed by comparing new and old property values.
     *
     * @param {DiagramModel} newProp - A object that lists the new values of the changed properties.
     * @param {DiagramModel} oldProp - A object that lists the old values of the changed properties.
     */
    /* tslint:disable */
    Diagram.prototype.onPropertyChanged = function (newProp, oldProp) {
        var _this = this;
        // Model Changed
        // Bug 842506: After multiple group node rotations, the undo functionality is not working.
        // Below condition is used to restrict onPropertyChange when we rotate group node using button at runtime.
        if (!this.rotateUsingButton) {
            var isPropertyChanged = true;
            var refreshLayout = false;
            var refereshColelction = false;
            var bpmnAnnotationConnector = void 0;
            if (this.diagramActions & DiagramAction.Render) {
                for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
                    var prop = _a[_i];
                    switch (prop) {
                        case 'width':
                        case 'height':
                            this.element.style.width = this.getSizeValue(this.width);
                            this.element.style.height = this.getSizeValue(this.height);
                            this.eventHandler.updateViewPortSize(this.element);
                            for (var _b = 0, _c = this.views; _b < _c.length; _b++) {
                                var view = _c[_b];
                                var temp = this.views["" + view];
                                if (!(temp instanceof Diagram)) {
                                    temp.updateView(temp);
                                }
                            }
                            break;
                        case 'nodes':
                            if (newProp.nodes.length > 0 && oldProp.nodes.length === 0) {
                                this.clearCollection();
                                refereshColelction = true;
                            }
                            else {
                                for (var _d = 0, _e = Object.keys(newProp.nodes); _d < _e.length; _d++) {
                                    var key = _e[_d];
                                    var index = Number(key);
                                    var actualObject = this.nodes[parseInt(index.toString(), 10)];
                                    var changedProp = newProp.nodes[parseInt(index.toString(), 10)];
                                    if (newProp.nodes[parseInt(index.toString(), 10)].style
                                        && newProp.nodes[parseInt(index.toString(), 10)].style.gradient) {
                                        this.updateGradient(newProp.nodes[parseInt(index.toString(), 10)], oldProp.nodes[parseInt(index.toString(), 10)], this.nodes[parseInt(index.toString(), 10)]);
                                        this.nodes[parseInt(index.toString(), 10)].oldGradientValue
                                            = cloneObject(newProp.nodes[parseInt(index.toString(), 10)].style.gradient);
                                    }
                                    refreshLayout = refreshLayout || changedProp.excludeFromLayout !== undefined;
                                    /* eslint-disable */
                                    if (newProp.nodes[index] && newProp.nodes[index].shape
                                        && newProp.nodes[index].shape.textAnnotation
                                        && newProp.nodes[index].shape.textAnnotation.textAnnotationTarget !== '') {
                                        bpmnAnnotationConnector = cloneObject(this.nameTable[actualObject.inEdges[0]]);
                                    }
                                    /* eslint-enable */
                                    this.nodePropertyChange(actualObject, oldProp.nodes[parseInt(index.toString(), 10)], changedProp, undefined, true, true);
                                    var args = {
                                        element: cloneBlazorObject(actualObject), cause: this.diagramActions,
                                        diagramAction: this.getDiagramAction(this.diagramActions),
                                        oldValue: cloneBlazorObject(oldProp.nodes[parseInt(index.toString(), 10)]),
                                        newValue: cloneBlazorObject(newProp.nodes[parseInt(index.toString(), 10)])
                                    };
                                    // Removed isBlazor code
                                    this.triggerEvent(DiagramEvent.propertyChange, args);
                                    if (isPropertyChanged) {
                                        isPropertyChanged = false;
                                    }
                                }
                                if (this.mode === 'Canvas') {
                                    this.refreshDiagramLayer();
                                }
                            }
                            break;
                        case 'connectors':
                            if (newProp.connectors.length > 0 && oldProp.connectors.length === 0) {
                                this.clearCollection(true);
                                refereshColelction = true;
                            }
                            else {
                                for (var _f = 0, _g = Object.keys(newProp.connectors); _f < _g.length; _f++) {
                                    var key = _g[_f];
                                    var index = Number(key);
                                    var actualObject = this.connectors[parseInt(index.toString(), 10)];
                                    var changedProp = newProp.connectors[parseInt(index.toString(), 10)];
                                    // 927220: Improper Connector State After Undo When Connecting via Button
                                    var changedPoints = {
                                        sourcePoint: { x: actualObject.sourcePoint.x, y: actualObject.sourcePoint.y },
                                        targetPoint: { x: actualObject.targetPoint.x, y: actualObject.targetPoint.y }
                                    };
                                    if (changedProp && (changedProp.sourceDecorator || changedProp.targetDecorator)) {
                                        this.diagramActions |= DiagramAction.DecoratorPropertyChange;
                                    }
                                    this.connectorPropertyChange(actualObject, oldProp.connectors[parseInt(index.toString(), 10)], changedProp, true, true);
                                    // 927220: Improper Connector State After Undo When Connecting via Button
                                    if (newProp.connectors[parseInt(index.toString(), 10)].sourceID &&
                                        !newProp.connectors[parseInt(index.toString(), 10)].sourcePoint) {
                                        oldProp.connectors[parseInt(index.toString(), 10)].sourcePoint = {
                                            x: changedPoints.sourcePoint.x,
                                            y: changedPoints.sourcePoint.y
                                        };
                                        newProp.connectors[parseInt(index.toString(), 10)].sourcePoint = {
                                            x: actualObject.sourcePoint.x,
                                            y: actualObject.sourcePoint.y
                                        };
                                    }
                                    if (newProp.connectors[parseInt(index.toString(), 10)].targetID &&
                                        !newProp.connectors[parseInt(index.toString(), 10)].targetPoint) {
                                        oldProp.connectors[parseInt(index.toString(), 10)].targetPoint = {
                                            x: changedPoints.targetPoint.x,
                                            y: changedPoints.targetPoint.y
                                        };
                                        newProp.connectors[parseInt(index.toString(), 10)].targetPoint = {
                                            x: actualObject.targetPoint.x,
                                            y: actualObject.targetPoint.y
                                        };
                                    }
                                    if (changedProp && (changedProp.sourceDecorator || changedProp.targetDecorator)) {
                                        this.diagramActions = this.diagramActions & ~DiagramAction.DecoratorPropertyChange;
                                    }
                                    var args = {
                                        element: cloneBlazorObject(actualObject), cause: this.diagramActions,
                                        diagramAction: this.getDiagramAction(this.diagramActions),
                                        oldValue: cloneBlazorObject(oldProp.connectors[parseInt(index.toString(), 10)]),
                                        newValue: cloneBlazorObject(newProp.connectors[parseInt(index.toString(), 10)])
                                    };
                                    // Removed isBlazor code
                                    this.triggerEvent(DiagramEvent.propertyChange, args);
                                    if (actualObject && actualObject.parentId && this.nameTable[actualObject.parentId].shape.type === 'UmlClassifier') {
                                        this.updateConnectorEdges(this.nameTable[actualObject.parentId] || actualObject);
                                    }
                                    if (isPropertyChanged) {
                                        isPropertyChanged = false;
                                    }
                                }
                                this.updateBridging();
                                if (this.mode === 'Canvas') {
                                    this.refreshDiagramLayer();
                                }
                            }
                            break;
                        case 'bridgeDirection':
                            this.updateBridging();
                            if (this.mode === 'Canvas') {
                                this.refreshDiagramLayer();
                            }
                            break;
                        case 'backgroundColor':
                            this.intOffPageBackground();
                            break;
                        case 'pageSettings':
                            this.validatePageSize();
                            this.updatePage();
                            break;
                        case 'selectedItems':
                            if (newProp.selectedItems.userHandles && this.selectedItems.wrapper && this.selectedItems.userHandles) {
                                if (this.selectedItems.userHandles.length > 0) {
                                    this.renderSelector(true);
                                    break;
                                }
                            }
                            if (newProp.selectedItems.constraints) {
                                this.renderSelector(true);
                                break;
                            }
                            break;
                        case 'snapSettings':
                            this.updateSnapSettings(newProp);
                            break;
                        case 'commandManager':
                            this.initCommands();
                            break;
                        case 'layout':
                            refreshLayout = true;
                            break;
                        case 'segmentThumbShape':
                            this.updateSelector();
                            break;
                        case 'dataSourceSettings':
                            this.clear();
                            if (this.layout.type === 'None') {
                                refereshColelction = true;
                            }
                            else {
                                //EJ2-837322- Duplicate nodes and connectors are created after reset for layout type 'None'
                                this.initObjects();
                                refreshLayout = true;
                            }
                            break;
                        case 'tooltip':
                            initTooltip(this);
                            break;
                        case 'rulerSettings':
                            this.updateRulerSettings(newProp);
                            break;
                        case 'layers':
                            this.updateLayer(newProp);
                            break;
                        case 'scrollSettings':
                            this.scrollActions |= ScrollActions.PropertyChange;
                            this.updateScrollSettings(newProp);
                            this.scrollActions &= ~ScrollActions.PropertyChange;
                            this.scrollSettings.horizontalOffset = -this.scroller.horizontalOffset || 0;
                            this.scrollSettings.verticalOffset = -this.scroller.verticalOffset || 0;
                            break;
                        case 'locale':
                            if (newProp.locale !== oldProp.locale) {
                                // 927339: Diagram Layout Rendering correctly When Locale is Set by removing the line
                                _super.prototype.refresh.call(this);
                            }
                            break;
                        case 'contextMenuSettings':
                            if (newProp.contextMenuSettings.showCustomMenuOnly !== undefined) {
                                this.contextMenuSettings.showCustomMenuOnly = newProp.contextMenuSettings.showCustomMenuOnly;
                            }
                            if (newProp.contextMenuSettings.show !== undefined) {
                                this.contextMenuSettings.show = newProp.contextMenuSettings.show;
                            }
                            if (newProp.contextMenuSettings.items) {
                                var items = newProp.contextMenuSettings.items;
                                for (var _h = 0, _j = Object.keys(items); _h < _j.length; _h++) {
                                    var key = _j[_h];
                                    var index = Number(key);
                                    this.contextMenuSettings.items[parseInt(index.toString(), 10)] = items[parseInt(index.toString(), 10)];
                                }
                                if (this.contextMenuModule) {
                                    this.contextMenuModule.refreshItems();
                                }
                                else {
                                    console.warn('[WARNING] :: Module "DiagramContextMenu" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
                                }
                            }
                            break;
                        case 'serializationSettings':
                            if (newProp.serializationSettings.preventDefaults !== undefined) {
                                this.serializationSettings.preventDefaults = newProp.serializationSettings.preventDefaults;
                            }
                            break;
                        case 'tool':
                            // 912436: Mouse cursor flickers when entering the diagram canvas after the tool is changed at runtime
                            this.eventHandler.updateTool();
                            break;
                    }
                }
                if (refreshLayout && !refereshColelction) {
                    if (oldProp.layout && oldProp.layout.connectionPointOrigin === 'DifferentPoint' && newProp.layout.connectionPointOrigin === 'SamePoint'
                        || (oldProp.layout && newProp.layout && !newProp.layout.enableRouting && oldProp.layout.enableRouting)) {
                        for (var i = 0; i < this.nodes.length; i++) {
                            var node = this.nodes[parseInt(i.toString(), 10)];
                            if ((node.ports && node.ports.length > 0)) {
                                var ports = [];
                                for (var j = node.ports.length - 1; j >= 0; j--) {
                                    if (node.ports[parseInt(j.toString(), 10)].id.split('_')[1] === 'LineDistribution') {
                                        ports.push(node.ports[parseInt(j.toString(), 10)]);
                                    }
                                }
                                this.removePorts(node, ports);
                            }
                        }
                        for (var j = 0; j < this.connectors.length; j++) {
                            var connector = this.connectors[parseInt(j.toString(), 10)];
                            var sourcePortid = connector.sourcePortID;
                            var targetPortId = connector.targetPortID;
                            //const oldSegment: OrthogonalSegmentModel = (connector.segments as OrthogonalSegmentModel);
                            connector.sourcePortID = '';
                            connector.targetPortID = '';
                            connector.sourcePortWrapper = undefined;
                            connector.targetPortWrapper = undefined;
                            connector.segments = [];
                            this.connectorPropertyChange(connector, {
                                sourcePortID: sourcePortid, targetPortID: targetPortId
                            }, { sourcePortID: '', targetPortID: '' });
                        }
                    }
                    this.doLayout();
                    this.renderReactTemplates();
                }
                if (isPropertyChanged && this.propertyChange) {
                    var args = {
                        element: cloneBlazorObject(this), cause: this.diagramActions,
                        diagramAction: this.getDiagramAction(this.diagramActions),
                        oldValue: cloneBlazorObject(oldProp), newValue: cloneBlazorObject(newProp)
                    };
                    // Removed isBlazor code
                    this.triggerEvent(DiagramEvent.propertyChange, args);
                }
                /**Feature(EJ2-60228): Need to add Object ID in the history change event argument*/
                if (!refereshColelction && (this.canLogChange()) && (this.modelChanged(newProp, oldProp))) {
                    var propertyObjects = [];
                    var nodeObjects = [];
                    var connObjects = [];
                    var nodeIndex = void 0;
                    if (newProp.nodes && Object.keys(newProp.nodes).length > 0) {
                        for (var _k = 0, _l = Object.keys(newProp.nodes); _k < _l.length; _k++) {
                            var key = _l[_k];
                            nodeIndex = parseInt(key, 10);
                            nodeObjects.push(this.nodes[parseInt(nodeIndex.toString(), 10)].id);
                        }
                    }
                    if (newProp.connectors && Object.keys(newProp.connectors).length > 0) {
                        for (var _m = 0, _o = Object.keys(newProp.connectors); _m < _o.length; _m++) {
                            var key = _o[_m];
                            var connIndex = parseInt(key, 10);
                            connObjects.push(this.connectors[parseInt(connIndex.toString(), 10)].id);
                        }
                    }
                    propertyObjects = nodeObjects.concat(connObjects);
                    //To prevent history entry for text annotation connector while dragging node.
                    var textCon = connObjects.filter(function (id) { return _this.nameTable["" + id].isBpmnAnnotationConnector; });
                    /* eslint-disable */
                    if (textCon.length === 0) {
                        //historyEntry to store BPMNtextAnnotation connector positionchange.
                        if (newProp.nodes && newProp.nodes[nodeIndex] && newProp.nodes[nodeIndex].shape
                            && newProp.nodes[nodeIndex].shape.textAnnotation
                            && newProp.nodes[nodeIndex].shape.textAnnotation.textAnnotationTarget !== '') {
                            var obj = this.nameTable[this.nodes[parseInt(nodeIndex.toString(), 10)].inEdges[0]];
                            this.startGroupAction();
                            var connectorEntry = { type: 'ConnectionChanged', undoObject: bpmnAnnotationConnector, redoObject: cloneObject(obj), category: 'Internal' };
                            var entry = { type: 'PropertyChanged', undoObject: oldProp, redoObject: newProp, category: 'Internal' };
                            if (this.historyManager) {
                                this.addHistoryEntry(connectorEntry);
                                this.addHistoryEntry(entry, propertyObjects);
                            }
                            this.endGroupAction();
                        }
                        else {
                            var entry = { type: 'PropertyChanged', undoObject: oldProp, redoObject: newProp, category: 'Internal' };
                            if (this.historyManager) {
                                this.addHistoryEntry(entry, propertyObjects);
                            }
                        }
                    }
                }
                this.resetDiagramActions();
                if (refereshColelction) {
                    this.initObjects(true);
                    this.refreshDiagramLayer();
                    if (refreshLayout) {
                        this.doLayout();
                    }
                }
                var scrollAlone = ((Object.keys(newProp).length === 1) && newProp.scrollSettings !== undefined);
                if (!refereshColelction) {
                    for (var _p = 0, _q = this.views; _p < _q.length; _p++) {
                        var temp = _q[_p];
                        var view = this.views["" + temp];
                        if (!(view instanceof Diagram)) {
                            if (newProp.scrollSettings && newProp.scrollSettings.currentZoom !== oldProp.scrollSettings.currentZoom) ;
                            if (!scrollAlone) {
                                this.refreshCanvasDiagramLayer(view);
                            }
                        }
                    }
                }
            }
        }
        else {
            this.rotateUsingButton = false;
        }
    };
    /* tslint:enable */
    Diagram.prototype.updateSnapSettings = function (newProp) {
        if (newProp.snapSettings.constraints !== undefined || newProp.snapSettings.horizontalGridlines ||
            newProp.snapSettings.verticalGridlines || newProp.snapSettings.gridType) {
            this.diagramRenderer.updateGrid(this.snapSettings, getGridLayerSvg(this.element.id), this.scroller.transform, this.rulerSettings, this.hRuler, this.vRuler);
        }
    };
    // This private method has been specially provided to update only the node old gradient value in oldProperty.
    // This issue belong to core team but we fixed in our end.
    // https://syncfusion.atlassian.net/browse/EJ2-49232
    Diagram.prototype.updateGradient = function (newProp, oldProp, nodeObj) {
        if (nodeObj.oldGradientValue) {
            var linearNode = nodeObj;
            var radialNode = nodeObj;
            var linearProp = oldProp.style.gradient;
            var radialProp = oldProp.style.gradient;
            for (var _i = 0, _a = Object.keys(newProp.style.gradient); _i < _a.length; _i++) {
                var key = _a[_i];
                switch (key) {
                    case 'type':
                        if (linearNode.type) {
                            linearProp.type = linearNode.type;
                        }
                        break;
                    case 'x1':
                        if (linearNode.x1) {
                            linearProp.x1 = linearNode.x1;
                        }
                        break;
                    case 'x2':
                        if (linearNode.x2) {
                            linearProp.x2 = linearNode.x2;
                        }
                        break;
                    case 'y1':
                        if (linearNode.y1) {
                            linearProp.y1 = linearNode.y1;
                        }
                        break;
                    case 'y2':
                        if (linearNode.y2) {
                            linearProp.y2 = linearNode.y2;
                        }
                        break;
                    case 'cx':
                        if (radialNode.cx) {
                            radialProp.cx = radialNode.cx;
                        }
                        break;
                    case 'cy':
                        if (radialNode.cy) {
                            radialProp.cy = radialNode.cy;
                        }
                        break;
                    case 'fx':
                        if (radialNode.fx) {
                            radialProp.fx = radialNode.fx;
                        }
                        break;
                    case 'fy':
                        if (radialNode.fy) {
                            radialProp.fy = radialNode.fy;
                        }
                        break;
                    case 'r':
                        if (radialNode.r) {
                            radialProp.r = radialNode.r;
                        }
                        break;
                    case 'stops':
                        if (nodeObj.oldGradientValue.stops) {
                            var stops = (Object.values(cloneObject(nodeObj.oldGradientValue.stops)));
                            stops.pop();
                            oldProp.style.gradient.stops = stops;
                        }
                        break;
                }
            }
        }
    };
    Diagram.prototype.updateRulerSettings = function (newProp) {
        if (newProp.rulerSettings.dynamicGrid !== undefined) {
            this.diagramRenderer.updateGrid(this.snapSettings, getGridLayerSvg(this.element.id), this.scroller.transform, this.rulerSettings, this.hRuler, this.vRuler);
        }
        if (newProp.rulerSettings.showRulers !== undefined) {
            this.intOffPageBackground();
            this.scroller.setSize();
            this.renderRulers();
        }
        else if (newProp.rulerSettings.horizontalRuler !== undefined ||
            newProp.rulerSettings.verticalRuler !== undefined) {
            if (newProp.rulerSettings.horizontalRuler.thickness !== undefined ||
                newProp.rulerSettings.verticalRuler.thickness !== undefined) {
                removeRulerElements(this);
                this.intOffPageBackground();
                this.scroller.setSize();
                this.renderRulers();
            }
            else {
                updateRuler(this);
            }
        }
        this.diagramRenderer.updateGrid(this.snapSettings, getGridLayerSvg(this.element.id), this.scroller.transform, this.rulerSettings, this.hRuler, this.vRuler);
    };
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @returns {string}
     */
    Diagram.prototype.getPersistData = function () {
        var keyEntity = ['loaded'];
        return this.addOnPersist(keyEntity);
    };
    /**
     * Initialize nodes, connectors and renderer
     */
    Diagram.prototype.preRender = function () {
        this.initializePrivateVariables();
        this.isProtectedOnChange = true;
        this.serviceLocator = new ServiceLocator;
        this.initializeServices();
        this.setCulture();
        var measureWindowElement = 'measureElement';
        if (window["" + measureWindowElement]) {
            window["" + measureWindowElement] = null;
        }
        this.initDiagram();
        this.initViews();
        this.unWireEvents();
        this.wireEvents();
        this.element.classList.add('e-diagram');
    };
    Diagram.prototype.initializePrivateVariables = function () {
        if (this.element.id === '') {
            var collection = document.getElementsByClassName('e-diagram').length;
            this.element.id = 'diagram_' + this.diagramid + '_' + collection;
        }
        this.defaultLocale = {
            Copy: 'Copy',
            Cut: 'Cut',
            Paste: 'Paste',
            Undo: 'Undo',
            Redo: 'Redo',
            SelectAll: 'Select All',
            Grouping: 'Grouping',
            Group: 'Group',
            UnGroup: 'Un Group',
            Order: 'Order',
            BringToFront: 'Bring To Front',
            MoveForward: 'Move Forward',
            SendToBack: 'Send To Back',
            SendBackward: 'Send Backward'
        };
        this.layerZIndex = -1;
        this.layerZIndexTable = {};
        //878837 : initialize parameter for passing container as a parameter
        if (this.swimlaneChildTable === undefined && this.swimlaneZIndexTable === undefined) {
            this.swimlaneChildTable = {};
            this.swimlaneZIndexTable = {};
        }
        this.nameTable = {};
        this.pathTable = {};
        this.groupTable = {};
        this.commands = {};
        if (!this.isLoading) {
            this.views = [];
        }
        this.commandHandler = new CommandHandler(this);
        this.eventHandler = new DiagramEventHandler(this, this.commandHandler);
        this.spatialSearch = new SpatialSearch(this.nameTable);
        this.scroller = new DiagramScroller(this);
    };
    Diagram.prototype.initializeServices = function () {
        this.serviceLocator.register('localization', this.localeObj = new L10n(this.getModuleName(), this.defaultLocale, this.locale));
    };
    /**
     * Method to set culture for chart
     */
    Diagram.prototype.setCulture = function () {
        this.localeObj = new L10n(this.getModuleName(), this.defaultLocale, this.locale);
    };
    /* tslint:disable */
    /**
     * Renders the diagram control with nodes and connectors
     */
    Diagram.prototype.render = function () {
        if (this.refreshing && this.dataSourceSettings.dataSource && !this.isLoading) {
            this.nodes = [];
            this.connectors = [];
        }
        //830544-Support to add load event to notify before rendering of diagram
        if (!this.refreshing) {
            var loadEventData = {
                diagram: this, name: 'load'
            };
            this.trigger('load', loadEventData);
        }
        // Bug 832897: Need to improve performance while rendering layout with large number of nodes.
        this.isRefreshed = false;
        this.ignoreCollectionWatch = true;
        var domTable = 'domTable';
        window["" + domTable] = {};
        var collapsedNode = [];
        //Removed isBlazor code.
        if (this.dataSourceSettings.crudAction.read) {
            this.renderInitialCrud();
        }
        this.initHistory();
        this.diagramRenderer = new DiagramRenderer(this.element.id, new SvgRenderer(), this.mode === 'SVG');
        this.initLayers();
        this.initializeDiagramLayers();
        this.diagramRenderer.setLayers();
        this.initObjects(true);
        // Removed isBlazor code.
        var nodes = this.nodes;
        for (var i = 0; i < nodes.length; i++) {
            if (!nodes[parseInt(i.toString(), 10)].isExpanded) {
                collapsedNode.push(nodes[parseInt(i.toString(), 10)]);
            }
        }
        if (collapsedNode.length) {
            for (var i = collapsedNode.length - 1; i >= 0; i--) {
                if (i === 0) {
                    this.commandHandler.expandNode(collapsedNode[parseInt(i.toString(), 10)], this, false);
                }
                else {
                    this.commandHandler.expandNode(collapsedNode[parseInt(i.toString(), 10)], this, true);
                }
            }
        }
        if (this.canLayout) {
            this.doLayout();
        }
        if (this.lineRoutingModule) {
            //Removed isBlazor code.
            // EJ2-65876 - Exception occurs on line routing injection module
            //934719 - Line Routing is never executed during initial rendering
            this.lineRoutingModule.lineRouting(this);
            // Removed isBlazor code.
        }
        else if (this.constraints & DiagramConstraints.LineRouting) {
            console.warn('[WARNING] :: Module "LineRouting" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
        }
        this.validatePageSize();
        this.renderPageBreaks();
        this.diagramRenderer.renderSvgGridlines(this.snapSettings, getGridLayerSvg(this.element.id), this.scroller.transform, this.rulerSettings, this.hRuler, this.vRuler);
        this.commandHandler.initSelectorWrapper();
        /**
         * Used to render context menu
         */
        this.notify('initial-load', {});
        /**
         * Used to load context menu
         */
        this.trigger('load');
        this.scroller.setSize();
        this.scroller.updateScrollOffsets();
        // Bug 832897: Need to improve performance while rendering layout with large number of nodes.
        // If diagram not refreshed, then we will refresh the diagram.
        if (!this.isRefreshed) {
            this.refreshDiagramLayer();
        }
        //Bug 855677: After Serialization, Subprocess Node Dragging Faces Problems After Removing Child Node.
        //Removed refreshDiagramLayer() method in this line as it causes the subprocess child node to be rendered twice in wrapper which causes the issue.
        if (this.scrollSettings.verticalOffset > 0 || this.scrollSettings.horizontalOffset > 0) {
            this.updateScrollOffset();
        }
        /**
         * Used to end the context menu rendering
         */
        if (Browser.isDevice) {
            this.tool = DiagramTools.ZoomPan | DiagramTools.SingleSelect;
        }
        this.notify('initial-end', {});
        this.isProtectedOnChange = false;
        this.tooltipObject = initTooltip(this);
        this.diagramActions = DiagramAction.Render;
        this.initCommands();
        var hiddenUserHandleTemplate = document.getElementsByClassName(this.element.id + '_hiddenUserHandleTemplate');
        createUserHandleTemplates(this.userHandleTemplate, hiddenUserHandleTemplate, this.selectedItems, this.element.id);
        //Removed isBlazor code.
        this.isLoading = false;
        this.refreshRoutingConnectors();
        this.renderComplete();
        this.updateFitToPage();
        if (this.refreshing) {
            this.renderReactTemplates();
        }
    };
    /* tslint:enable */
    Diagram.prototype.updateFitToPage = function () {
        if (this.pageSettings && this.pageSettings.fitOptions && this.pageSettings.fitOptions.canFit) {
            this.fitToPage(this.pageSettings.fitOptions);
        }
    };
    Diagram.prototype.updateTemplate = function () {
        //Removed blazor code
    };
    //Call back function to the node template
    // private measureNode(node: NodeModel): void {
    //     if (node.shape.type === 'Native' && isBlazor()) {
    //         node.wrapper.measure(new Size(node.width, node.height));
    //         node.wrapper.arrange(node.wrapper.desiredSize);
    //     }
    // }
    Diagram.prototype.renderInitialCrud = function () {
        /* eslint-disable */
        var tempObj = this;
        /* eslint-enable */
        if (tempObj.dataSourceSettings.crudAction.read) {
            var callback = new Fetch(tempObj.dataSourceSettings.crudAction.read, 'GET');
            callback.onSuccess = function (data) {
                if (tempObj.dataSourceSettings.dataManager) {
                    tempObj.dataSourceSettings.dataManager = JSON.parse(data);
                }
                else {
                    tempObj.dataSourceSettings.dataSource = JSON.parse(data);
                }
                tempObj.dataBind();
            };
            callback.send().then();
        }
        if (tempObj.dataSourceSettings.connectionDataSource.crudAction.read) {
            var callback = new Fetch(tempObj.dataSourceSettings.connectionDataSource.crudAction.read, 'GET');
            callback.onSuccess = function (data) {
                tempObj.dataSourceSettings.connectionDataSource.dataManager = JSON.parse(data);
                tempObj.dataBind();
            };
            callback.send().then();
        }
    };
    /**
     * Retrieves the module name associated with the diagram.
     *
     * @returns {string}  Retrieves the module name associated with the diagram.
     */
    Diagram.prototype.getModuleName = function () {
        return 'diagram';
    };
    /**
     *
     * Returns the name of class Diagram
     * @returns {string}  Returns the module name of the diagram
     * @private
     */
    Diagram.prototype.getClassName = function () {
        return 'Diagram';
    };
    /* tslint:disable */
    /**
     * To provide the array of modules needed for control rendering
     *
     * @returns {ModuleDeclaration[]} To provide the array of modules needed for control rendering .\
     * @private
     */
    Diagram.prototype.requiredModules = function () {
        var modules = [];
        modules.push({
            member: 'Bpmn',
            args: []
        });
        modules.push({
            member: 'Bridging',
            args: []
        });
        modules.push({
            member: 'ConnectorEditingTool',
            args: []
        });
        //Removed isBlazor code
        if (this.constraints & DiagramConstraints.UndoRedo) {
            modules.push({
                member: 'UndoRedo',
                args: []
            });
        }
        if (this.layout.type === 'OrganizationalChart' || this.layout.type === 'HierarchicalTree' ||
            this.layout.enableAnimation) {
            modules.push({
                member: 'LayoutAnimate',
                args: []
            });
        }
        if (this.snapSettings.constraints) {
            modules.push({
                member: 'Snapping',
                args: [this]
            });
        }
        modules.push({
            member: 'Ej1Serialization',
            args: [this]
        });
        modules.push({
            member: 'PrintandExport',
            args: [this]
        });
        if (this.contextMenuSettings.show) {
            modules.push({
                member: 'contextMenu',
                args: [this, this.serviceLocator]
            });
        }
        if (this.layout.type === 'OrganizationalChart' || this.layout.type === 'HierarchicalTree') {
            modules.push({
                member: 'OrganizationalChart',
                args: [this]
            });
        }
        if (this.layout.type === 'ComplexHierarchicalTree') {
            modules.push({
                member: 'ComplexHierarchicalTree',
                args: []
            });
        }
        if (this.layout.type === 'MindMap') {
            modules.push({
                member: 'MindMapChart',
                args: []
            });
        }
        if (this.layout.type === 'RadialTree') {
            modules.push({
                member: 'RadialTree',
                args: []
            });
        }
        if (this.layout.type === 'SymmetricalLayout') {
            modules.push({
                member: 'SymmetricalLayout',
                args: []
            });
        }
        if (this.layout.type === 'Flowchart') {
            modules.push({
                member: 'FlowchartLayout',
                args: []
            });
        }
        if (this.dataSourceSettings.dataManager || this.dataSourceSettings.dataSource ||
            this.dataSourceSettings.crudAction.read || this.dataSourceSettings.connectionDataSource.crudAction.read) {
            modules.push({
                member: 'DataBinding',
                args: []
            });
        }
        if (this.constraints & DiagramConstraints.LineRouting) {
            modules.push({
                member: 'LineRouting',
                args: []
            });
        }
        if (this.constraints & DiagramConstraints.AvoidLineOverlapping) {
            modules.push({
                member: 'AvoidLineOverlapping',
                args: [this]
            });
        }
        if ((this.layout && (this.layout.type === 'ComplexHierarchicalTree' || this.layout.type === 'HierarchicalTree')) || (this.layout.arrangement === 'Linear' || (this.layout.enableRouting))) {
            modules.push({
                member: 'LineDistribution',
                args: []
            });
        }
        return modules;
    };
    /* tslint:enable */
    Diagram.prototype.removeUserHandlesTemplate = function () {
        if (this.selectedItems.userHandles.length) {
            for (var i = 0; i < this.selectedItems.userHandles.length; i++) {
                for (var _i = 0, _a = this.views; _i < _a.length; _i++) {
                    var elementId = _a[_i];
                    removeElement(this.selectedItems.userHandles[parseInt(i.toString(), 10)].name + '_template_hiddenUserHandle', elementId);
                }
            }
        }
    };
    /**
     *Destroys the diagram, freeing up its resources.
     *
     * @returns {void} Destroys the diagram, freeing up its resources.
     */
    Diagram.prototype.destroy = function () {
        clearInterval(this.renderTimer);
        this.renderTimer = null;
        if (this.hRuler && this.vRuler) {
            this.hRuler.destroy();
            this.vRuler.destroy();
        }
        this.tooltipObject.destroy();
        this.droppable.destroy();
        this.unWireEvents();
        this.notify('destroy', {});
        _super.prototype.destroy.call(this);
        this.removeUserHandlesTemplate();
        this.clearTemplate();
        if (document.getElementById(this.element.id)) {
            this.element.classList.remove('e-diagram');
            var tooltipelement = document.getElementsByClassName('e-diagram-tooltip');
            while (tooltipelement.length > 0) {
                tooltipelement[0].parentNode.removeChild(tooltipelement[0]);
            }
            var content = document.getElementById(this.element.id + 'content');
            if (content) {
                this.element.removeChild(content);
            }
            var measureWindowElement = 'measureElement';
            if (window["" + measureWindowElement]) {
                window["" + measureWindowElement].usageCount -= 1;
                var measureElementCount = 'measureElementCount';
                window["" + measureElementCount]--;
                if (window["" + measureElementCount] === 0) {
                    window["" + measureWindowElement].parentNode.removeChild(window["" + measureWindowElement]);
                    window["" + measureWindowElement] = null;
                }
            }
        }
        var domTable = 'domTable';
        window["" + domTable] = {};
        for (var i = 0; i < this.layers.length; i++) {
            var currentLayer = this.layers[parseInt(i.toString(), 10)];
            currentLayer.zIndexTable = {};
        }
        this.diagramActions = undefined;
    };
    //Wires the mouse events with diagram control
    Diagram.prototype.wireEvents = function () {
        var startEvent = Browser.touchStartEvent;
        var stopEvent = Browser.touchEndEvent;
        var moveEvent = Browser.touchMoveEvent;
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        var isIE11Pointer = Browser.isPointer;
        var wheelEvent = Browser.info.name === 'mozilla' ?
            (isIE11Pointer ? 'mousewheel' : 'DOMMouseScroll') : 'mousewheel';
        EventHandler.add(this.diagramCanvas, startEvent, this.eventHandler.mouseDown, this.eventHandler);
        EventHandler.add(this.diagramCanvas, moveEvent, this.eventHandler.mouseMove, this.eventHandler);
        EventHandler.add(this.diagramCanvas, stopEvent, this.eventHandler.mouseUp, this.eventHandler);
        EventHandler.add(this.diagramCanvas, cancelEvent, this.eventHandler.mouseLeave, this.eventHandler);
        EventHandler.add(this.diagramCanvas, 'keydown', this.eventHandler.keyDown, this.eventHandler);
        EventHandler.add(this.diagramCanvas, 'keyup', this.eventHandler.keyUp, this.eventHandler);
        EventHandler.add(this.diagramCanvas, 'dblclick', this.eventHandler.doubleClick, this.eventHandler);
        EventHandler.add(this.diagramCanvas, 'scroll', this.eventHandler.scrolled, this.eventHandler);
        EventHandler.add(this.diagramCanvas, wheelEvent, this.eventHandler.mouseWheel, this.eventHandler);
        EventHandler.add(window, 'resize', this.eventHandler.windowResize, this.eventHandler);
        this.initDroppables();
    };
    //Unwires the mouse events from diagram control
    Diagram.prototype.unWireEvents = function () {
        var startEvent = Browser.touchStartEvent;
        var moveEvent = Browser.touchMoveEvent;
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        var isIE11Pointer = Browser.isPointer;
        var wheelEvent = Browser.info.name === 'mozilla' ?
            (isIE11Pointer ? 'mousewheel' : 'DOMMouseScroll') : 'mousewheel';
        var stopEvent = Browser.touchEndEvent;
        EventHandler.remove(this.diagramCanvas, startEvent, this.eventHandler.mouseDown);
        EventHandler.remove(this.diagramCanvas, moveEvent, this.eventHandler.mouseMove);
        EventHandler.remove(this.diagramCanvas, stopEvent, this.eventHandler.mouseUp);
        EventHandler.remove(this.diagramCanvas, cancelEvent, this.eventHandler.mouseLeave);
        EventHandler.remove(this.diagramCanvas, 'keydown', this.eventHandler.keyDown);
        EventHandler.remove(this.diagramCanvas, 'keyup', this.eventHandler.keyUp);
        EventHandler.remove(this.diagramCanvas, 'dblclick', this.eventHandler.doubleClick);
        EventHandler.remove(this.diagramCanvas, 'scroll', this.eventHandler.scrolled);
        EventHandler.remove(this.diagramCanvas, wheelEvent, this.eventHandler.mouseWheel);
        EventHandler.remove(window, 'resize', this.eventHandler.windowResize);
    };
    //public methods - start region
    /**
     * Select a specified collection of nodes and connectors in the diagram. You can specify whether to clear the existing selection and provide an old value if needed. \
     *
     * @returns { void } Select a specified collection of nodes and connectors in the diagram. You can specify whether to clear the existing selection and provide an old value if needed.\
     * @param {NodeModel | ConnectorModel} objects - An array containing the collection of nodes and connectors to be selected.
     * @param {boolean} multipleSelection - Determines whether the existing selection should be cleared (default is false).
     * @param {NodeModel | ConnectorModel} oldValue - Defines the old value
     *
     */
    Diagram.prototype.select = function (objects, multipleSelection, oldValue) {
        //Removed isBlazor code.
        if (objects != null) {
            this.commandHandler.selectObjects(objects, multipleSelection, oldValue);
        }
    };
    /**
     * Returns the diagram action as a string representation.
     * @returns { string }
     * @param { DiagramAction } diagramAction - The diagram action to be converted to a string.
     */
    //Feature (EJ2-18451) : For all client side events, cause argument data type should be string instead of flag enum and value should be easier to understand.
    Diagram.prototype.getDiagramAction = function (diagramAction) {
        var action;
        if (diagramAction === 2 && DiagramAction.Render) {
            action = 'Render';
        }
        else if (diagramAction & DiagramAction.UndoRedo) {
            action = 'UndoRedo';
        }
        else if (diagramAction & DiagramAction.PublicMethod) {
            action = 'PublicMethod';
        }
        else if (diagramAction & DiagramAction.ToolAction) {
            action = 'ToolAction';
        }
        else if (diagramAction & DiagramAction.TextEdit) {
            action = 'TextEdit';
        }
        else if (diagramAction & DiagramAction.Group) {
            action = 'Group';
        }
        else if (diagramAction & DiagramAction.Interactions) {
            action = 'Interactions';
        }
        else if (diagramAction & DiagramAction.PreventHistory) {
            action = 'PreventHistory';
        }
        else if (diagramAction & DiagramAction.DecoratorPropertyChange) {
            action = 'DecoratorPropertyChange';
        }
        else if (diagramAction & DiagramAction.PreventZIndexOnDragging) {
            action = 'PreventZIndexOnDragging';
        }
        else if (diagramAction & DiagramAction.isGroupDragging) {
            action = 'isGroupDragging';
        }
        else if (diagramAction & DiagramAction.DragUsingMouse) {
            action = 'DragUsingMouse';
        }
        return action;
    };
    /**
     *  Select all objects, including nodes and connectors, in the diagram. \
     *
     * @returns { void }  Select all objects, including nodes and connectors, in the diagram.\
     *
     */
    Diagram.prototype.selectAll = function () {
        var selectedItems = [];
        selectedItems = this.getObjectsOfLayer(this.activeLayer.objects);
        this.select(selectedItems);
    };
    /**
     * Remove a specific object from the current selection in the diagram. \
     *
     * @returns { void } Remove a specific object from the current selection in the diagram.\
     * @param {NodeModel | ConnectorModel} obj -  The object to remove from the selection.
     *
     */
    Diagram.prototype.unSelect = function (obj) {
        //Removed isBlazor code.
        if (obj && isSelected(this, obj)) {
            this.commandHandler.unSelect(obj);
            // this.commandHandler.updateBlazorSelector();
        }
    };
    /**
     * Removes all elements from the selection list, clearing the current selection.\
     *
     * @returns { void } Removes all elements from the selection list, clearing the current selection.\
     *
     */
    Diagram.prototype.clearSelection = function () {
        this.commandHandler.clearSelection(true);
    };
    /**
     *  Updates the dimensions of the diagram viewport. \
     *
     * @returns { void }  Updates the dimensions of the diagram viewport.\
     *
     */
    Diagram.prototype.updateViewPort = function () {
        var attribute = this.getZoomingAttribute();
        this.updateBlazorDiagramProperties(attribute);
        this.eventHandler.updateViewPortSize(this.element);
        this.updateBlazorDiagramProperties(attribute, true);
    };
    Diagram.prototype.cutCommand = function () {
        this.cut();
    };
    /**
     *  Removes the selected nodes and connectors from the diagram and moves them to the diagram clipboard for cutting. \
     *
     * @returns { void }  Removes the selected nodes and connectors from the diagram and moves them to the diagram clipboard for cutting. \
     *
     */
    Diagram.prototype.cut = function () {
        this.commandHandler.cut();
    };
    /**
     *   Adds a process into the sub-process. \
     *
     * @returns { void }  Adds a process into the sub-process. \
     * @param {NodeModel | ConnectorModel} process - A NodeModel representing the process to be added.
     * @param {boolean} parentId - A string representing the parent ID where the process will be added.
     *
     */
    Diagram.prototype.addProcess = function (process, parentId) {
        if (this.bpmnModule) {
            this.bpmnModule.addProcess(process, parentId, this);
        }
    };
    /**
     *  Removes a process from the BPMN sub-process. \
     *
     * @returns { void }  Removes a process from the BPMN sub-process.\
     * @param {string} id - The ID of the process to be removed.
     *
     */
    Diagram.prototype.removeProcess = function (id) {
        if (this.bpmnModule) {
            this.bpmnModule.removeProcess(id, this);
        }
    };
    Diagram.prototype.pasteCommand = function () {
        this.paste();
    };
    /**
     * Adds the given objects or the objects in the diagram clipboard to the diagram control. \
     *
     * @returns { void }  Adds the given objects or the objects in the diagram clipboard to the diagram control. \
     * @param {NodeModel[] | ConnectorModel[]} obj - An array of nodes or connectors objects to be added to diagram.
     * @deprecated
     *
     */
    Diagram.prototype.paste = function (obj) {
        this.commandHandler.paste(obj);
    };
    /**
     *  Fits the diagram to the page with respect to mode and region. \
     *
     * @returns { void }  Fits the diagram to the page with respect to mode and region.\
     * @param {IFitOptions} options - specify the options for fitting the diagram to the page.
     */
    Diagram.prototype.fitToPage = function (options) {
        var attribute = this.getZoomingAttribute();
        this.updateBlazorDiagramProperties(attribute);
        this.scroller.fitToPage(options);
        this.updateBlazorDiagramProperties(attribute, true);
    };
    /**
     * Brings the specified bounds into view within the diagram's viewport. \
     *
     * @returns { void }  Brings the specified bounds into view within the diagram's viewport.\
     * @param {Rect} bound - Representing the bounds to be brought into view.
     *
     */
    Diagram.prototype.bringIntoView = function (bound) {
        var attribute = this.getZoomingAttribute();
        this.updateBlazorDiagramProperties(attribute);
        // EJ2-69238 - add true as an extra parameter to calcuate the horizontal and vertical offset
        this.scroller.bringIntoView(bound, true);
        this.updateBlazorDiagramProperties(attribute, true);
    };
    /**
     * Brings the specified bounds to the center of the viewport. \
     *
     * @returns { void }  Brings the specified bounds to the center of the viewport.\
     * @param {Rect} bound - representing the bounds to be centered in the viewport.
     *
     */
    Diagram.prototype.bringToCenter = function (bound) {
        var attribute = this.getZoomingAttribute();
        this.updateBlazorDiagramProperties(attribute);
        this.scroller.bringToCenter(bound);
        this.updateBlazorDiagramProperties(attribute, true);
    };
    Diagram.prototype.copyCommand = function () {
        this.copy();
    };
    /**
     * Copies the selected nodes and connectors from the diagram to the diagram clipboard for copying. \
     *
     * @returns { Object } Copies the selected nodes and connectors from the diagram to the diagram clipboard for copying.\
     *
     */
    Diagram.prototype.copy = function () {
        var obj = this.commandHandler.copy();
        return obj;
    };
    /**
     *  Groups the selected nodes and connectors in the diagram. \
     *
     * @returns { void }   Groups the selected nodes and connectors in the diagram.\
     *
     */
    Diagram.prototype.group = function () {
        var selectedItems = [];
        selectedItems = this.selectedItems.nodes;
        selectedItems = selectedItems.concat(this.selectedItems.connectors);
        if (selectedItems.length > 1) {
            this.callBlazorModel = false;
            this.insertBlazorDiagramObjects(this.selectedItems);
            this.commandHandler.group();
            this.callBlazorModel = true;
            this.commandHandler.getBlazorOldValues();
        }
    };
    /**
     *  UnGroup the selected nodes and connectors in diagram \
     *
     * @returns { void }   UnGroup the selected nodes and connectors in diagram.\
     *
     */
    Diagram.prototype.unGroup = function () {
        this.callBlazorModel = false;
        this.insertBlazorDiagramObjects(this.selectedItems);
        this.commandHandler.unGroup();
        this.callBlazorModel = true;
        this.commandHandler.getBlazorOldValues();
    };
    /**
     *  Use this method to move the currently selected nodes or connectors to the back of the drawing order. This effectively places them behind other elements in the diagram. \
     *
     * @returns { void }   Use this method to move the currently selected nodes or connectors to the back of the drawing order. This effectively places them behind other elements in the diagram.\
     *
     */
    Diagram.prototype.sendToBack = function () {
        this.commandHandler.sendToBack();
    };
    /**
     * Specify which layer in the diagram should be considered the active layer. The active layer is the one where new elements will be added and where user interactions are primarily focused. \
     *
     * @returns { void } Specify which layer in the diagram should be considered the active layer. The active layer is the one where new elements will be added and where user interactions are primarily focused. \
     * @param {string} layerName - The name of the layer to set as the active layer.
     *
     */
    Diagram.prototype.setActiveLayer = function (layerName) {
        var layer = this.commandHandler.getLayer(layerName);
        this.activeLayer = layer;
    };
    /**
     * add the layer into diagram\
     *
     * @returns { void } Adds the specified layer to the diagram control along with its associated objects.\
     * @param {LayerModel} layer - representing the layer to be added to the diagram.
     * @param {Object[]} layerObject -  An optional array of objects associated with the layer.
     * @blazorArgsType layer|DiagramLayer
     * @deprecated
     *
     */
    Diagram.prototype.addLayer = function (layer, layerObject) {
        this.commandHandler.addLayer(layer, layerObject);
    };
    /**
     * remove the layer from diagram \
     *
     * @returns { void } remove the layer from diagram.\
     * @param {string} layerId - provide the bound value.
     * @deprecated
     *
     */
    Diagram.prototype.removeLayer = function (layerId) {
        this.commandHandler.removeLayer(layerId, isBlazor());
    };
    // /* eslint-enable */
    /**
     *Moves objects from one layer to another layer within the diagram. \
     *
     * @returns { void } Moves objects from one layer to another layer within the diagram. \
     * @param {string[]} objects - An array of object IDs represented as strings to be moved.
     * @param {string} targetLayer - The ID of the target layer to which the objects should be moved.
     */
    Diagram.prototype.moveObjects = function (objects, targetLayer) {
        var oldValues = cloneObject(this.layers);
        this.enableServerDataBinding(false);
        this.commandHandler.moveObjects(objects, targetLayer);
        //     const result: object = this.commandHandler.deepDiffer.map(oldValues, cloneObject(this.layers));
        //     const diffValue: object = this.commandHandler.deepDiffer.frameObject({}, result);
        //     this.oldDiagramObject = { layers: diffValue };
        //     // this.commandHandler.updateBlazorProperties();
    };
    /* tslint:disable */
    Diagram.prototype.layerObjectUpdate = function () {
        //Removed isBlazor code.
    };
    /* tslint:enable */
    /**
     * Use this method to change the order of layers in the diagram. This moves the specified layer behind the layer that comes after it in the layer order. \
     *
     * @returns { void } Use this method to change the order of layers in the diagram. This moves the specified layer behind the layer that comes after it in the layer order.\
     * @param {string} layerName - The name of the layer to be moved.
     * @param {string} targetLayer - define the objects id of string array
     *
     */
    Diagram.prototype.sendLayerBackward = function (layerName) {
        this.layerObjectUpdate();
        this.commandHandler.sendLayerBackward(layerName);
        // comment blazor code
        // this.commandHandler.updateLayerObject(this.oldDiagramObject, true);
    };
    /**
     * Moves the specified layer forward in the drawing order. \
     *
     * @returns { void } Moves the specified layer forward in the drawing order.\
     * @param {string} layerName - A string representing the name of the layer to be moved forward.
     *
     */
    Diagram.prototype.bringLayerForward = function (layerName) {
        this.layerObjectUpdate();
        this.commandHandler.bringLayerForward(layerName);
        // comment blazor code
        // this.commandHandler.updateLayerObject(this.oldDiagramObject);
    };
    /**
     * Clones a layer along with its objects.\
     *
     * @returns { void } Clones a layer along with its objects.\
     * @param {string} layerName - A string representing the name of the layer to be cloned.
     *
     */
    Diagram.prototype.cloneLayer = function (layerName) {
        this.commandHandler.cloneLayer(layerName);
    };
    /**
     *Brings the selected nodes or connectors to the front of the drawing order. \
     *
     * @returns { void } Brings the selected nodes or connectors to the front of the drawing order. \
     *
     */
    Diagram.prototype.bringToFront = function () {
        this.commandHandler.bringToFront();
    };
    /**
     *Sends the selected nodes or connectors forward in the visual order.  \
     *
     * @returns { void } Sends the selected nodes or connectors forward in the visual order. \
     *
     */
    Diagram.prototype.moveForward = function () {
        this.commandHandler.sendForward();
    };
    /**
     *Sends the selected nodes or connectors one step backward in the z-order.\
     *
     * @returns { void } Sends the selected nodes or connectors one step backward in the z-order.\
     *
     */
    Diagram.prototype.sendBackward = function () {
        this.commandHandler.sendBackward();
    };
    /**
     *gets the node or connector having the given name \
     *
     * @returns { void } gets the node or connector having the given name.\
     * @param {string} name - define the name of the layer
     *
     */
    Diagram.prototype.getObject = function (name) {
        return this.nameTable["" + name];
    };
    /**
     *Retrieves the node object for the given node ID.  \
     *
     * @returns { void } Retrieves the node object for the given node ID. \
     * @param {string} id - The ID of the node for which the node object is to be retrieved.
     *
     */
    Diagram.prototype.getNodeObject = function (id) {
        return cloneObject(this.nameTable["" + id]);
    };
    /**
     *Retrieves the connector object for the given node ID. \
     *
     * @returns { void } Retrieves the connector object for the given node ID.\
     * @param {string} id - The ID of the node for which the connector object is to be retrieved.
     *
     */
    Diagram.prototype.getConnectorObject = function (id) {
        return cloneObject(this.nameTable["" + id]);
    };
    /**
     * Retrieves the active layer. \
     *
     * @returns { void } Retrieves the active layer.\
     *
     */
    Diagram.prototype.getActiveLayer = function () {
        return this.activeLayer;
    };
    Diagram.prototype.nudgeCommand = function (direction, x, y) {
        if (typeof direction !== 'object' && (this.selectedItems.nodes.length || this.selectedItems.connectors.length) > 0) {
            var type = void 0;
            if (x.type && x.type === 'KEYDOWN') {
                type = x.type;
            }
            this.nudge(direction, undefined, undefined, type);
        }
    };
    /**
     * Moves the selected objects towards the given direction by a specified distance.
     *
     * @returns { void }  Moves the selected objects towards the given direction by a specified distance.  \
     * @param {NudgeDirection} direction -  Defines the direction in which the objects should be moved.
     * @param {number} x - The horizontal distance by which the selected objects should be moved.
     * @param {number} y -  The vertical distance by which the selected objects should be moved.
     * @param {string} type -  A string that defines the type of nudge action.
     */
    Diagram.prototype.nudge = function (direction, x, y, type) {
        var tx = 0;
        var ty = 0;
        var negativeDirection;
        if (direction === 'Left' || direction === 'Right') {
            negativeDirection = (direction === 'Left');
            tx = (negativeDirection ? -1 : 1) * (x ? x : 1);
        }
        else {
            negativeDirection = (direction === 'Up');
            ty = (negativeDirection ? -1 : 1) * (y ? y : 1);
        }
        if (type === 'KEYDOWN') {
            tx *= 5;
            ty *= 5;
        }
        var obj = this.selectedItems;
        var annotation = this.selectedItems.wrapper.children[0];
        if (annotation instanceof TextElement) {
            this.commandHandler.labelDrag(obj.nodes[0], annotation, tx, ty);
        }
        else {
            var undoObject = cloneObject(this.selectedItems);
            this.protectPropertyChange(true);
            this.drag(obj, tx, ty);
            this.protectPropertyChange(false);
            var entry = {
                type: 'PositionChanged',
                redoObject: cloneObject(this.selectedItems), undoObject: undoObject, category: 'Internal'
            };
            this.addHistoryEntry(entry);
        }
        this.refreshCanvasLayers();
    };
    Diagram.prototype.insertBlazorDiagramObjects = function (actualObject) {
        //Removed isBlazor code
    };
    /**
     * Drags the given object (nodes, connectors, or selector) by the specified horizontal and vertical distances.
     *
     * @returns { void }  Drags the given object (nodes, connectors, or selector) by the specified horizontal and vertical distances.\
     * @param {NodeModel | ConnectorModel | SelectorModel} obj - representing the nodes, connectors, or selector to be dragged.
     * @param {number} tx - A number representing the horizontal distance by which the given objects should be moved.
     * @param {number} ty - A number representing the vertical distance by which the given objects should be moved.
     */
    Diagram.prototype.drag = function (obj, tx, ty) {
        this.insertBlazorDiagramObjects(obj);
        //Removed isBlazor code
        if (this.bpmnModule && (obj instanceof Node)) {
            var updated = this.bpmnModule.updateAnnotationDrag(obj, this, tx, ty);
            if (updated) {
                return;
            }
        }
        if (obj instanceof Selector) {
            this.preventConnectorsUpdate = true;
            if (obj.nodes && obj.nodes.length) {
                for (var _i = 0, _a = obj.nodes; _i < _a.length; _i++) {
                    var node = _a[_i];
                    this.callBlazorModel = false;
                    this.drag(node, tx, ty);
                    if (node.parentId) {
                        var parent_1 = this.nameTable[node.parentId];
                        if (parent_1.isLane) {
                            // 909151 - Connector not updating while dragging multiple selection.
                            if (obj.nodes.length > 1) {
                                this.preventConnectorsUpdate = false;
                            }
                            var swimlane = this.nameTable[parent_1.parentId];
                            updateLaneBoundsAfterAddChild(parent_1, swimlane, node, this);
                        }
                    }
                }
                this.callBlazorModel = true;
            }
            if (obj.connectors && obj.connectors.length) {
                this.callBlazorModel = false;
                for (var _b = 0, _c = obj.connectors; _b < _c.length; _b++) {
                    var conn = _c[_b];
                    this.drag(conn, tx, ty);
                    if (this.selectionConnectorsList.indexOf(conn) === -1) {
                        this.selectionConnectorsList.push(conn);
                    }
                }
                this.callBlazorModel = true;
            }
            this.updateSelector();
            if ((this.diagramActions & DiagramAction.DragUsingMouse)) {
                this.updatePage();
            }
        }
        else {
            if (obj instanceof Node) {
                if (this.bpmnModule) {
                    this.bpmnModule.updateAnnotationDrag(obj, this, tx, ty);
                }
            }
            this.commandHandler.drag(obj, tx, ty);
        }
        if (obj instanceof Selector) {
            this.preventConnectorsUpdate = false;
            for (var _d = 0, _e = this.selectionConnectorsList; _d < _e.length; _d++) {
                var connectors = _e[_d];
                this.updateConnectorProperties(this.nameTable[connectors.id]);
                if (connectors.shape.type === 'Bpmn' && connectors.shape.sequence === 'Default' && connectors.shape.flow === 'Sequence') {
                    this.commandHandler.updatePathElementOffset(connectors);
                }
            }
            this.selectionConnectorsList = [];
        }
        // Bug 832880: Need to improve performance while nudging multiple nodes.
        // Removed one if condition here to improve performance.
        if (this.callBlazorModel && (!(this.blazorActions & BlazorAction.interaction)) &&
            (!(this.blazorActions & BlazorAction.GroupClipboardInProcess))) {
            this.commandHandler.getBlazorOldValues();
        }
    };
    Diagram.prototype.disableStackContainerPadding = function (wrapper, disable) {
        if (wrapper instanceof StackPanel) {
            wrapper.considerPadding = disable;
        }
        if (wrapper.children) {
            for (var _i = 0, _a = wrapper.children; _i < _a.length; _i++) {
                var child = _a[_i];
                this.disableStackContainerPadding(child, false);
            }
        }
    };
    /**
     * Use this method to scale one or more objects in the diagram by specifying the horizontal and vertical scaling ratios. You can also provide a pivot point as a reference for scaling.
     *
     * @returns { void } Use this method to scale one or more objects in the diagram by specifying the horizontal and vertical scaling ratios. You can also provide a pivot point as a reference for scaling.\
     * @param {NodeModel | ConnectorModel | SelectorModel} obj - The objects to be resized.
     * @param {number} sx - The horizontal scaling ratio.
     * @param {number} sy - The vertical scaling ratio.
     * @param {PointModel} pivot - The reference point with respect to which the objects will be resized.
     */
    Diagram.prototype.scale = function (obj, sx, sy, pivot) {
        this.disableStackContainerPadding(obj.wrapper, false);
        this.insertBlazorDiagramObjects(obj);
        var checkBoundaryConstraints = true;
        if (obj.id) {
            obj = this.nameTable[obj.id] || obj;
        }
        if (obj instanceof Selector) {
            if (obj.nodes && obj.nodes.length) {
                this.callBlazorModel = false;
                for (var _i = 0, _a = obj.nodes; _i < _a.length; _i++) {
                    var node = _a[_i];
                    checkBoundaryConstraints = this.commandHandler.scale(node, sx, sy, pivot, obj);
                    if (!this.commandHandler.checkBoundaryConstraints(undefined, undefined, obj.wrapper.bounds)) {
                        this.commandHandler.scale(node, 1 / sx, 1 / sy, pivot, obj);
                    }
                }
                this.callBlazorModel = true;
            }
            if (obj.connectors && obj.connectors.length) {
                this.callBlazorModel = false;
                for (var _b = 0, _c = obj.connectors; _b < _c.length; _b++) {
                    var conn = _c[_b];
                    this.commandHandler.scale(conn, sx, sy, pivot, obj);
                    if (!this.commandHandler.checkBoundaryConstraints(undefined, undefined, obj.wrapper.bounds)) {
                        this.commandHandler.scale(conn, 1 / sx, 1 / sy, pivot, obj);
                    }
                }
                this.callBlazorModel = true;
            }
            var selector = this.selectedItems;
            if (!(selectionHasConnector(this, selector))) {
                this.updateSelector();
            }
            this.refreshCanvasLayers();
        }
        else {
            this.commandHandler.scale(obj, sx, sy, pivot, (obj.children ? obj : undefined));
        }
        if (this.callBlazorModel && (!(this.blazorActions & BlazorAction.interaction)) &&
            (!(this.blazorActions & BlazorAction.GroupClipboardInProcess))) {
            this.commandHandler.getBlazorOldValues();
        }
        this.disableStackContainerPadding(obj.wrapper, true);
        return checkBoundaryConstraints;
    };
    /**
     * Rotates the specified nodes, connectors, or selector by the given angle.
     *
     * @returns { void } Rotates the specified nodes, connectors, or selector by the given angle.\
     * @param {NodeModel | ConnectorModel | SelectorModel} obj - The objects to be rotated
     * @param {number} angle - The angle by which the objects should be rotated (in degrees).
     * @param {PointModel} pivot - The reference point with respect to which the objects will be rotated.
     * @param {boolean} rotateUsingHandle - Whether to rotate using the handle.
     */
    Diagram.prototype.rotate = function (obj, angle, pivot, rotateUsingHandle) {
        // Bug 842506: After multiple group node rotations, the undo functionality is not working.
        // Added below condition to store the current obj to add it as undo element in rotation changed entry.
        var undoObject;
        var childTable = [];
        if (!rotateUsingHandle) {
            undoObject = cloneObject(obj);
            if (undoObject.nodes && undoObject.nodes.length > 0 && undoObject.nodes[0].children) {
                var elements = [];
                if (!this.fromUndo) {
                    this.rotateUsingButton = true;
                }
                var nodes = this.commandHandler.getAllDescendants(undoObject.nodes[0], elements);
                for (var i = 0; i < nodes.length; i++) {
                    var node = this.commandHandler.cloneChild(nodes[parseInt(i.toString(), 10)].id);
                    childTable[nodes[parseInt(i.toString(), 10)].id] = cloneObject(node);
                }
            }
            if (angle < 0) {
                angle = (angle + 360) % 360;
            }
        }
        this.insertBlazorDiagramObjects(obj);
        var checkBoundaryConstraints;
        if (obj.id) {
            obj = this.nameTable[obj.id] || obj;
        }
        if (obj) {
            pivot = pivot || { x: obj.wrapper.offsetX, y: obj.wrapper.offsetY };
            if (obj instanceof Selector) {
                this.callBlazorModel = false;
                obj.rotateAngle += angle;
                obj.wrapper.rotateAngle += angle;
                var bounds = getBounds(obj.wrapper);
                checkBoundaryConstraints = this.commandHandler.checkBoundaryConstraints(undefined, undefined, bounds);
                if (!checkBoundaryConstraints) {
                    obj.rotateAngle -= angle;
                    obj.wrapper.rotateAngle -= angle;
                    return checkBoundaryConstraints;
                }
                var objects = [];
                objects = objects.concat(obj.nodes);
                objects = objects.concat(obj.connectors);
                this.commandHandler.rotateObjects(obj, objects, angle, pivot);
                this.callBlazorModel = true;
            }
            else {
                this.commandHandler.rotateObjects(obj, [obj], angle, pivot);
            }
        }
        if (this.callBlazorModel && (!(this.blazorActions & BlazorAction.interaction))) {
            this.commandHandler.getBlazorOldValues();
        }
        if (!rotateUsingHandle && !this.fromUndo) {
            // To add history entry for group node rotation.
            if (undoObject.nodes && undoObject.nodes.length > 0 && undoObject.nodes[0].children) {
                var entry = {
                    type: 'RotationChanged', redoObject: cloneObject(obj), undoObject: cloneObject(undoObject), category: 'Internal',
                    childTable: childTable
                };
                this.commandHandler.addHistoryEntry(entry);
                this.commandHandler.updateSelector();
            }
        }
        return checkBoundaryConstraints;
    };
    /**
     * Moves the source point of the given connector by the specified horizontal and vertical distances.
     *
     * @returns { void }  Moves the source point of the given connector by the specified horizontal and vertical distances.\
     * @param {ConnectorModel} obj - representing the connector whose source point needs to be moved.
     * @param {number} tx - A number representing the horizontal distance by which the source point should be moved.
     * @param {number} ty - A number representing the vertical distance by which the source point should be moved.
     */
    Diagram.prototype.dragSourceEnd = function (obj, tx, ty) {
        this.insertBlazorDiagramObjects(obj);
        this.commandHandler.dragSourceEnd(obj, tx, ty);
        if (this.callBlazorModel) {
            this.commandHandler.getBlazorOldValues();
        }
    };
    /**
     * Moves the target point of the given connector by the specified horizontal and vertical distances.
     *
     * @returns { void }   Moves the target point of the given connector by the specified horizontal and vertical distances.\
     * @param {ConnectorModel} obj - representing the connector whose target point needs to be moved.
     * @param {number} tx - A number representing the horizontal distance by which the target point should be moved.
     * @param {number} ty - A number representing the vertical distance by which the target point should be moved.
     */
    Diagram.prototype.dragTargetEnd = function (obj, tx, ty) {
        this.insertBlazorDiagramObjects(obj);
        this.commandHandler.dragTargetEnd(obj, tx, ty);
        if (this.callBlazorModel) {
            this.commandHandler.getBlazorOldValues();
        }
    };
    /**
     * Finds all the objects that are under the given mouse position based on specified criteria.
     *
     * @returns { void }   Finds all the objects that are under the given mouse position based on specified criteria.\
     * @param {PointModel} position - The PointModel that defines the position. The objects under this position will be found.
     * @param {IElement} source - Representing the source object. The objects under this source will be found.
     */
    Diagram.prototype.findObjectsUnderMouse = function (position, source) {
        return this.eventHandler.findObjectsUnderMouse(position, source);
    };
    /**
     * Finds the object that is under the given mouse position based on specified criteria.
     *
     * @returns { void }   Finds the object that is under the given mouse position based on specified criteria. \
     * @param {NodeModel[] | ConnectorModel[]}objects - A collection of NodeModel or ConnectorModel objects, from which the target object has to be found.
     * @param {Actions} action - Defines the action used to find the relevant object.
     * @param {boolean} inAction - A boolean indicating the active state of the action.
     */
    Diagram.prototype.findObjectUnderMouse = function (objects, action, inAction) {
        return this.eventHandler.findObjectUnderMouse(objects, action, inAction);
    };
    /**
     * Finds the object that is under the given active object (source) based on specified criteria.
     *
     * @returns { void } Finds the object that is under the given active object (source) based on specified criteria.\
     * @param {NodeModel[] | ConnectorModel[]} objects - A collection of node or connector objects, from which the target object has to be found.
     * @param {Actions} action - defines the action used to find the relevant object.
     * @param {boolean} inAction - A boolean indicating the active state of the action.
     * @param {PointModel} position - The PointModel that defines the position
     * @param {IElement} source - Representing the source element.
     */
    Diagram.prototype.findTargetObjectUnderMouse = function (objects, action, inAction, position, source) {
        return this.eventHandler.findTargetUnderMouse(objects, action, inAction, position, source);
    };
    /**
     * Finds the child element of the given object at the given position based on specified criteria.
     *
     * @returns { void } Finds the child element of the given object at the given position based on specified criteria.\
     * @param {IElement} obj - representing the object, the child element of which has to be found.
     * @param {PointModel} position - defines the position. The child element under this position will be found.
     * @param {Diagram} diagram - defines the diagram value.
     * @param {number} padding - A number representing the padding for the search area around the position.
     */
    Diagram.prototype.findElementUnderMouse = function (obj, position, diagram, padding) {
        return this.eventHandler.findElementUnderMouse(obj, position, diagram, padding);
    };
    /**
     * Defines the action to be done, when the mouse hovers the given element of the given object
     *
     * @returns { void } Defines the action to be done, when the mouse hovers the given element of the given object .\
     * @param {NodeModel | ConnectorModel} obj - Defines the object under mouse
     * @param {DiagramElement} wrapper - Defines the target element of the object under mouse
     * @param {PointModel} position - Defines the current mouse position
     * @param { NodeModel | PointPortModel | ShapeAnnotationModel | PathAnnotationModel} target - Defines the target
     * @private
     */
    Diagram.prototype.findActionToBeDone = function (obj, wrapper, position, target) {
        return this.eventHandler.findActionToBeDone(obj, wrapper, position, target);
    };
    // Feature 826644: Support to add ports to the connector. Added below method to update connector port on property change.
    Diagram.prototype.updateConnectorPort = function (connector) {
        if (connector.ports.length) {
            var portContent = void 0;
            for (var _i = 0, _a = connector.ports; _i < _a.length; _i++) {
                var port = _a[_i];
                portContent = this.getWrapper(connector.wrapper, port.id);
                connector.initPortWrapper(port, connector.intermediatePoints, connector.wrapper.bounds, portContent);
            }
        }
        connector.wrapper.measure(new Size(connector.wrapper.width, connector.wrapper.height));
        connector.wrapper.arrange(connector.wrapper.desiredSize);
    };
    /**
     * Returns the tool that handles the given action.
     *
     * @returns { ToolBase } Returns the tool that handles the given action. \
     * @param {string} action - A string that defines the action that is going to be performed.
     */
    Diagram.prototype.getTool = function (action) {
        var tool;
        var getCustomTool = getFunction(this.getCustomTool);
        if (getCustomTool) {
            tool = getCustomTool(action);
            if (tool) {
                return tool;
            }
        }
        return this.eventHandler.getTool(action);
    };
    /**
     * Defines the cursor that corresponds to the given action.
     *
     * @returns { string } Defines the cursor that corresponds to the given action. \
     * @param {string} action - The action for which the cursor is defined.
     * @param {boolean} active - Indicates whether the action is active.
     */
    Diagram.prototype.getCursor = function (action, active) {
        var cursor;
        var getCustomCursor = getFunction(this.getCustomCursor);
        if (getCustomCursor) {
            cursor = getCustomCursor(action, active);
            if (cursor) {
                return cursor;
            }
        }
        if (this.customCursor.length) {
            for (var i = 0; i < this.customCursor.length; i++) {
                if (this.customCursor[parseInt(i.toString(), 10)].action === action) {
                    return this.customCursor[parseInt(i.toString(), 10)].cursor;
                }
            }
        }
        return this.eventHandler.getCursor(action);
    };
    /**
     * Initializes the undo redo actions
     *
     * @returns { void } Initializes the undo redo actions \
     * @private
     */
    Diagram.prototype.initHistory = function () {
        if (this.undoRedoModule) {
            this.undoRedoModule.initHistory(this);
        }
    };
    /**
     * Adds a history entry for a change in the diagram control to the track.
     *
     * @returns { void } Adds a history entry for a change in the diagram control to the track. \
     * @param {HistoryEntry} entry - The history entry that describes a change in the diagram.
     * @param {string[]} sourceId - An optional array of source IDs associated with the change.
     */
    Diagram.prototype.addHistoryEntry = function (entry, sourceId) {
        if (this.undoRedoModule && (this.constraints & DiagramConstraints.UndoRedo)
            && (!this.currentSymbol || this.checkCurrentSymbol(this.currentSymbol, entry))) {
            if (entry.undoObject && entry.undoObject.id === 'helper') {
                return;
            }
            var added = this.undoRedoModule.addHistoryEntry(entry, this);
            if (entry.type !== 'StartGroup' && entry.type !== 'EndGroup' && added) {
                this.historyChangeTrigger(entry, 'CustomAction', sourceId);
            }
        }
    };
    Diagram.prototype.checkCurrentSymbol = function (currentSymbol, entry) {
        var check = false;
        if (entry.undoObject && entry.redoObject) {
            var undoObjects = entry.undoObject;
            var redoObject = entry.undoObject;
            if (redoObject.id && undoObjects.id && redoObject.id !== currentSymbol.id && undoObjects.id !== currentSymbol.id) {
                return check = true;
            }
            else {
                return check;
            }
        }
        return check;
    };
    /**
     * Adds the given custom change in the diagram control to the track
     *
     * @returns { void } Adds the given custom change in the diagram control to the track \
     * @param {HistoryEntry} entry - Defines the entry/information about a change in diagram
     */
    Diagram.prototype.addCustomHistoryEntry = function (entry) {
        //Removed isBlazor code
    };
    /* eslint-disable */
    /** @private */
    Diagram.prototype.historyChangeTrigger = function (entry, action, sourceId) {
        var change = {};
        /* eslint-enable */
        var oldValue = 'oldValue';
        var newValue = 'newValue';
        var type = 'type';
        var source = [];
        if (entry.category === 'Internal') {
            if (entry && entry.redoObject && ((entry.redoObject.nodes) instanceof Array) &&
                ((entry.redoObject.connectors) instanceof Array)) {
                source = entry.redoObject.nodes.concat(entry.redoObject.connectors);
            }
            else {
                if (entry.redoObject) {
                    source.push(entry.redoObject);
                }
            }
            change["" + type] = entry.type;
            //Removed isBlazor code
            switch (entry.type) {
                case 'PositionChanged':
                    // 909584 - History change event args value is not updated properly
                    if (action === 'Undo') {
                        change["" + oldValue] = {
                            offsetX: entry.redoObject.offsetX,
                            offsetY: entry.redoObject.offsetY
                        };
                        change["" + newValue] = {
                            offsetX: entry.undoObject.offsetX,
                            offsetY: entry.undoObject.offsetY
                        };
                    }
                    else {
                        change["" + oldValue] = {
                            offsetX: entry.undoObject.offsetX,
                            offsetY: entry.undoObject.offsetY
                        };
                        change["" + newValue] = {
                            offsetX: entry.redoObject.offsetX,
                            offsetY: entry.redoObject.offsetY
                        };
                    }
                    break;
                case 'RotationChanged':
                    if (action === 'Undo') {
                        change["" + oldValue] = { rotateAngle: entry.redoObject.rotateAngle };
                        change["" + newValue] = { rotateAngle: entry.undoObject.rotateAngle };
                    }
                    else {
                        change["" + oldValue] = { rotateAngle: entry.undoObject.rotateAngle };
                        change["" + newValue] = { rotateAngle: entry.redoObject.rotateAngle };
                    }
                    break;
                case 'SizeChanged':
                    if (action === 'Undo') {
                        change["" + oldValue] = {
                            offsetX: entry.redoObject.offsetX, offsetY: entry.redoObject.offsetY,
                            width: entry.redoObject.width, height: entry.redoObject.height
                        };
                        change["" + newValue] = {
                            offsetX: entry.undoObject.offsetX, offsetY: entry.undoObject.offsetY,
                            width: entry.undoObject.width, height: entry.undoObject.height
                        };
                    }
                    else {
                        change["" + oldValue] = {
                            offsetX: entry.undoObject.offsetX, offsetY: entry.undoObject.offsetY,
                            width: entry.undoObject.width, height: entry.undoObject.height
                        };
                        change["" + newValue] = {
                            offsetX: entry.redoObject.offsetX, offsetY: entry.redoObject.offsetY,
                            width: entry.redoObject.width, height: entry.redoObject.height
                        };
                    }
                    break;
                case 'CollectionChanged':
                    change[entry.changeType] = source;
                    break;
                case 'ConnectionChanged':
                    if (action === 'Undo') {
                        change["" + oldValue] = {
                            offsetX: entry.redoObject.offsetX,
                            offsetY: entry.redoObject.offsetY
                        };
                        change["" + newValue] = {
                            offsetX: entry.undoObject.offsetX,
                            offsetY: entry.undoObject.offsetY
                        };
                    }
                    else {
                        change["" + oldValue] = {
                            offsetX: entry.undoObject.offsetX,
                            offsetY: entry.undoObject.offsetY
                        };
                        change["" + newValue] = {
                            offsetX: entry.redoObject.offsetX,
                            offsetY: entry.redoObject.offsetY
                        };
                    }
                    break;
            }
            /**Feature(EJ2-60228): Need to add Object ID in the history change event argument*/
            var nodeSourceId = [];
            var connectorSourceId = [];
            if (sourceId === undefined && entry.type === 'PropertyChanged') {
                for (var i = 0; i < Object.keys(entry.undoObject).length; i++) {
                    if (Object.keys(entry.undoObject)[parseInt(i.toString(), 10)] === 'nodes') {
                        for (var _i = 0, _a = Object.keys(entry.undoObject.nodes); _i < _a.length; _i++) {
                            var key = _a[_i];
                            var undoIndex = parseInt(key, 10);
                            nodeSourceId.push(this.nodes[parseInt(undoIndex.toString(), 10)].id);
                        }
                    }
                }
                for (var i = 0; i < Object.keys(entry.undoObject).length; i++) {
                    if (Object.keys(entry.undoObject)[parseInt(i.toString(), 10)] === 'connectors') {
                        for (var _b = 0, _c = Object.keys(entry.undoObject.connectors); _b < _c.length; _b++) {
                            var key = _c[_b];
                            var undoIndex = parseInt(key, 10);
                            connectorSourceId.push(this.connectors[parseInt(undoIndex.toString(), 10)].id);
                        }
                    }
                }
                sourceId = nodeSourceId.concat(connectorSourceId);
            }
            var arg = {
                cause: entry.category, source: cloneBlazorObject(source), change: cloneBlazorObject(change),
                action: action, sourceId: sourceId
            };
            //Removed isBlazor code
            if (source.length) {
                this.triggerEvent(DiagramEvent.historyChange, arg);
            }
        }
    };
    /**
     * Use this method to start a group action, allowing multiple actions to be treated as a single unit during undo/redo operations. This is useful when you want to group related actions together.
     *
     * @returns { void } Use this method to start a group action, allowing multiple actions to be treated as a single unit during undo/redo operations. This is useful when you want to group related actions together. \
     */
    Diagram.prototype.startGroupAction = function () {
        var entry = { type: 'StartGroup', category: 'Internal' };
        if (!(this.diagramActions & DiagramAction.UndoRedo)) {
            this.addHistoryEntry(entry);
        }
    };
    /**
     * Closes the grouping of actions that will be undone/restored as a whole.
     *
     * @returns { void } Closes the grouping of actions that will be undone/restored as a whole.\
     */
    Diagram.prototype.endGroupAction = function () {
        var entry = { type: 'EndGroup', category: 'Internal' };
        if (!(this.diagramActions & DiagramAction.UndoRedo)) {
            this.addHistoryEntry(entry);
        }
    };
    /**
     * Restores the last action that was performed.
     *
     * @returns { void } Restores the last action that was performed. \
     */
    Diagram.prototype.undo = function () {
        this.canEnableBlazorObject = true;
        this.callBlazorModel = false;
        if (this.undoRedoModule && (this.constraints & DiagramConstraints.UndoRedo)) {
            this.isUndo = true;
            this.undoRedoModule.undo(this);
            this.isUndo = false;
        }
        else if (this.constraints & DiagramConstraints.UndoRedo) {
            console.warn('[WARNING] :: Module "UndoRedo" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
        }
        this.commandHandler.getBlazorOldValues();
        this.callBlazorModel = true;
        this.canEnableBlazorObject = false;
    };
    /**
     * Reverse an undo action, essentially restoring the state of the component to a previous state after an undo operation has been performed.
     *
     * @returns { void } Reverse an undo action, essentially restoring the state of the component to a previous state after an undo operation has been performed.\
     */
    Diagram.prototype.redo = function () {
        this.canEnableBlazorObject = true;
        this.callBlazorModel = false;
        if (this.undoRedoModule && (this.constraints & DiagramConstraints.UndoRedo)) {
            this.undoRedoModule.redo(this);
        }
        else if (this.constraints & DiagramConstraints.UndoRedo) {
            console.warn('[WARNING] :: Module "UndoRedo" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
        }
        this.commandHandler.getBlazorOldValues();
        this.callBlazorModel = true;
        this.canEnableBlazorObject = false;
    };
    Diagram.prototype.getBlazorDiagramObjects = function (objects) {
        if (objects) {
            for (var j = 0; j < objects.length; j++) {
                this.insertBlazorDiagramObjects(objects[parseInt(j.toString(), 10)]);
            }
        }
        else {
            this.insertBlazorDiagramObjects(this.selectedItems);
        }
        this.callBlazorModel = false;
        this.canEnableBlazorObject = true;
    };
    /**
     * Aligns a group of objects with reference to the first object in the group.
     *
     * @returns { void } Aligns a group of objects with reference to the first object in the group.\
     * @param {AlignmentOptions}option - Defining the factor by which the objects have to be aligned.
     * @param {NodeModel[] | ConnectorModel[]} objects - A collection of node or connector objects to be aligned.
     * @param {AlignmentMode} type - Defines the type to be aligned
     */
    Diagram.prototype.align = function (option, objects, type) {
        this.getBlazorDiagramObjects(objects);
        if (!objects) {
            objects = [];
            objects = objects.concat(this.selectedItems.nodes, this.selectedItems.connectors);
        }
        this.diagramActions = this.diagramActions | DiagramAction.PublicMethod;
        this.commandHandler.align(objects, option, (type ? type : 'Object'));
        this.commandHandler.getBlazorOldValues();
        this.callBlazorModel = true;
        this.canEnableBlazorObject = false;
    };
    /**
     * Arranges a group of objects with equal intervals within the group.
     *
     * @returns { void } Arranges a group of objects with equal intervals within the group.\
     * @param {NodeModel[] | ConnectorModel[]} option - Objects that have to be equally spaced within the group.
     * @param {DistributeOptions} objects - Object defining the factor to distribute the shapes.
     */
    Diagram.prototype.distribute = function (option, objects) {
        this.getBlazorDiagramObjects(objects);
        if (!objects) {
            objects = [];
            objects = objects.concat(this.selectedItems.nodes, this.selectedItems.connectors);
        }
        this.diagramActions = this.diagramActions | DiagramAction.PublicMethod;
        this.commandHandler.distribute(objects, option);
        this.commandHandler.getBlazorOldValues();
        this.canEnableBlazorObject = false;
        this.callBlazorModel = true;
    };
    /**
     * Scales the specified objects to match the size of the first object in the group.
     *
     * @returns { void } Scales the specified objects to match the size of the first object in the group.\
     * @param {SizingOptions} option - Specifies whether the objects should be horizontally scaled, vertically scaled, or both.
     * @param {NodeModel[] | ConnectorModel[]}objects - The collection of objects to be scaled.
     */
    Diagram.prototype.sameSize = function (option, objects) {
        this.getBlazorDiagramObjects(objects);
        if (!objects) {
            objects = [];
            objects = objects.concat(this.selectedItems.nodes, this.selectedItems.connectors);
        }
        this.diagramActions = this.diagramActions | DiagramAction.PublicMethod;
        this.commandHandler.sameSize(objects, option);
        this.commandHandler.getBlazorOldValues();
        this.canEnableBlazorObject = false;
        this.callBlazorModel = true;
    };
    Diagram.prototype.updateBlazorDiagramProperties = function (attribute, canCall) {
    };
    Diagram.prototype.getZoomingAttribute = function () {
        var attribute = [];
        attribute.push('scrollSettings');
        attribute.push('snapSettings');
        return attribute;
    };
    /**
     * Scales the diagram control based on the provided zoom factor. You can optionally specify a focused point around which the diagram will be zoomed.
     *
     * @returns { void } Scales the diagram control based on the provided zoom factor. You can optionally specify a focused point around which the diagram will be zoomed.\
     * @param {number} factor - Defines the factor by which the diagram is zoomed.
     * @param {PointModel} focusedPoint - Defines the point with respect to which the diagram will be zoomed.
     */
    Diagram.prototype.zoom = function (factor, focusedPoint) {
        var attribute = this.getZoomingAttribute();
        this.updateBlazorDiagramProperties(attribute);
        this.scroller.zoom(factor, 0, 0, focusedPoint);
        if (!(this.blazorActions & BlazorAction.interaction)) {
            this.updateBlazorDiagramProperties(attribute, true);
        }
    };
    /**
     * Scales the diagram control based on the provided options, which include the desired zoom factor, focus point, and zoom type.
     *
     * @returns { void }  Scales the diagram control based on the provided options, which include the desired zoom factor, focus point, and zoom type.\
     * @param {ZoomOptions} options - An object specifying the zoom factor, focus point, and zoom type.
     *
     */
    Diagram.prototype.zoomTo = function (options) {
        var attribute = this.getZoomingAttribute();
        this.updateBlazorDiagramProperties(attribute);
        var factor = options.zoomFactor ? options.zoomFactor : 0.2;
        factor = options.type === 'ZoomOut' ? 1 / (1 + factor) : (1 + factor);
        this.scroller.zoom(factor, 0, 0, options.focusPoint);
        this.updateBlazorDiagramProperties(attribute, true);
    };
    /**
     * Pans the diagram control to the given horizontal and vertical offsets.
     *
     * @returns { void } Pans the diagram control to the given horizontal and vertical offsets.\
     * @param {number} horizontalOffset - The horizontal distance to which the diagram should be scrolled.
     * @param {number} verticalOffset - The vertical distance to which the diagram should be scrolled.
     * @param {PointModel} focusedPoint - representing the focused point during panning.
     * @param {boolean} isInteractiveZoomPan - A boolean indicating whether the panning is interactive zoom pan.
     */
    Diagram.prototype.pan = function (horizontalOffset, verticalOffset, focusedPoint, isInteractiveZoomPan) {
        var attribute = this.getZoomingAttribute();
        this.updateBlazorDiagramProperties(attribute);
        this.setCursor('grabbing');
        this.scroller.zoom(1, horizontalOffset, verticalOffset, focusedPoint, isInteractiveZoomPan);
        this.updateBlazorDiagramProperties(attribute, true);
    };
    /**
     * Resets the zoom and scroller offsets to their default values.
     *
     * @returns { void } Resets the zoom and scroller offsets to their default values.\
     */
    Diagram.prototype.reset = function () {
        var attribute = this.getZoomingAttribute();
        this.updateBlazorDiagramProperties(attribute);
        this.scroller.zoom(1 / this.scroller.currentZoom, -this.scroller.horizontalOffset, -this.scroller.verticalOffset, { x: 0, y: 0 });
        this.updateBlazorDiagramProperties(attribute, true);
    };
    /**
     * Resets the segments of the connectors to their default state. This removes any custom segments and restores the connectors to their original configuration.
     *
     * @returns { void } Resets the segments of the connectors to their default state. This removes any custom segments and restores the connectors to their original configuration. \
     */
    Diagram.prototype.resetSegments = function () {
        //Removed isBlazor code
        if (this.constraints & DiagramConstraints.LineRouting && this.lineRoutingModule) {
            this.lineRoutingModule.lineRouting(this);
        }
        else {
            this.protectPropertyChange(true);
            var connector = void 0;
            for (var i = 0; i < this.connectors.length; i++) {
                connector = this.connectors[parseInt(i.toString(), 10)];
                connector.segments = [];
                this.connectorPropertyChange(connector, {}, { segments: connector.segments });
                if (this.avoidLineOverlappingModule) {
                    this.avoidLineOverlappingModule.removeConnector(connector);
                }
            }
            this.protectPropertyChange(false);
        }
        //Removed isBlazor code
    };
    /**
     * setBlazorDiagramProps method
     *
     * @returns {void} setBlazorDiagramProps method .\
     * @param {boolean} arg - provide the eventName value.
     * @private
     */
    Diagram.prototype.setBlazorDiagramProps = function (arg) {
        var attribute = this.getZoomingAttribute();
        if (arg) {
            this.updateBlazorDiagramProperties(attribute);
        }
        else {
            this.updateBlazorDiagramProperties(attribute, true);
        }
    };
    /**
     * getDirection method
     *
     * @returns { Promise<void | object> } getDirection method .\
     * @param {DiagramEvent} eventName - provide the eventName value.
     * @param {Object} args - provide the args value.
     * @private
     */
    Diagram.prototype.triggerEvent = function (eventName, args) {
        return __awaiter$2(this, void 0, void 0, function () {
            var eventArgs;
            return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (args) {
                            this.updateEventValue(args);
                        }
                        return [4 /*yield*/, this.trigger(DiagramEvent["" + eventName], args)];
                    case 1:
                        eventArgs = _a.sent();
                        //Removed isBlazor code.
                        return [2 /*return*/, eventArgs];
                }
            });
        });
    };
    Diagram.prototype.updateEventValue = function (args) {
        var element = args.element;
        if (args.element && element instanceof Selector && (element.nodes.length + element.connectors.length === 1)) {
            args.element = (element.nodes.length === 1) ? element.nodes[0] : element.connectors[0];
        }
    };
    /**
     * Adds the specified node to a lane within a swimlane.
     *
     * @returns { void }     Adds the specified node to a lane within a swimlane. \
     * @param {NodeModel} node - representing the node to be added to the lane.
     * @param {string} swimLane - A string representing the ID of the swimlane containing the lane.
     * @param {string} lane - A string representing the ID of the lane where the node will be added.
     * @deprecated
     */
    Diagram.prototype.addNodeToLane = function (node, swimLane, lane) {
        if (this.nameTable["" + swimLane]) {
            var swimlaneNode = this.nameTable["" + swimLane];
            this.protectPropertyChange(true);
            if (this.undoRedoModule) {
                this.historyManager.startGroupAction();
            }
            if (!this.nameTable[node.id]) {
                node.offsetX = swimlaneNode.wrapper.bounds.width + swimlaneNode.wrapper.bounds.x;
                node.offsetY = swimlaneNode.wrapper.bounds.height + swimlaneNode.wrapper.bounds.y;
                node = this.add(node);
            }
            node.parentId = '';
            if (!swimlaneNode.shape.phases.length) {
                var laneId = swimLane + lane + '0';
                if (this.nameTable["" + laneId]) {
                    //Bug 913801: Adding an existing node into a lane as child won't be interactive.
                    //Added below method call to update the zIndex of newly added child node.
                    this.commandHandler.updateLaneChildrenZindex(node, this.nameTable["" + laneId]);
                    addChildToContainer(this, this.nameTable["" + laneId], node, undefined, true);
                    updateLaneBoundsAfterAddChild(this.nameTable["" + laneId], swimlaneNode, node, this);
                }
            }
            else {
                for (var i = 0; i < swimlaneNode.shape.phases.length; i++) {
                    var laneId = swimLane + lane + i;
                    if (this.nameTable["" + laneId] && this.nameTable["" + laneId].isLane) {
                        var laneNode = this.nameTable["" + laneId].wrapper.bounds;
                        var focusPoint = {
                            x: laneNode.x +
                                (laneNode.x - swimlaneNode.wrapper.bounds.x + node.margin.left + (node.wrapper.bounds.width / 2)),
                            y: laneNode.y + swimlaneNode.wrapper.bounds.y - node.margin.top
                        };
                        if (swimlaneNode.shape.orientation === 'Horizontal') {
                            focusPoint.y = laneNode.y;
                        }
                        else {
                            focusPoint.x = laneNode.x;
                            var laneHeaderId = this.nameTable["" + laneId].parentId +
                                swimlaneNode.shape.lanes[0].id + '_0_header';
                            focusPoint.y = laneNode.y +
                                (swimlaneNode.wrapper.bounds.y - this.nameTable["" + laneHeaderId].wrapper.bounds.height +
                                    node.margin.top + (node.wrapper.bounds.height / 2));
                        }
                        if ((laneId === swimLane + lane + (swimlaneNode.shape.phases.length - 1)) ||
                            laneNode.containsPoint(focusPoint)) {
                            //Bug 913801: Adding an existing node into a lane as child won't be interactive.
                            //Added below method call to update the zIndex of newly added child node.
                            this.commandHandler.updateLaneChildrenZindex(node, this.nameTable["" + laneId]);
                            addChildToContainer(this, this.nameTable["" + laneId], node, undefined, true);
                            updateLaneBoundsAfterAddChild(this.nameTable["" + laneId], swimlaneNode, node, this);
                            break;
                        }
                    }
                }
            }
            if (this.undoRedoModule) {
                this.historyManager.endGroupAction();
            }
            this.protectPropertyChange(false);
        }
        this.updateDiagramElementQuad();
    };
    /**
     * Displays a tooltip for the specified diagram object.
     *
     * @param {NodeModel | ConnectorModel} obj - The object for which the tooltip will be shown.
     */
    Diagram.prototype.showTooltip = function (obj) {
        if (obj && obj.id && !obj.wrapper) {
            obj = this.nameTable[obj.id];
        }
        var bounds = getBounds(obj.wrapper);
        var position = { x: 0, y: 0 };
        var content = obj.tooltip.content ?
            obj.tooltip.content : 'X:' + Math.round(bounds.x) + ' ' + 'Y:' + Math.round(bounds.y);
        if (obj && obj.tooltip.openOn === 'Custom') {
            if (obj instanceof Node) {
                position = { x: obj.offsetX + (obj.width / 2), y: obj.offsetY + (obj.height / 2) };
            }
            else {
                position = { x: obj.targetPoint.x, y: obj.targetPoint.x };
            }
            this.commandHandler.showTooltip(obj, position, content, 'SelectTool', true);
        }
    };
    /**
     * Hides the tooltip for the corresponding diagram object.
     *
     * @param {NodeModel | ConnectorModel} obj - The node or connector object for which the tooltip should be hidden.
     */
    Diagram.prototype.hideTooltip = function (obj) {
        if (obj && obj.tooltip.openOn === 'Custom') {
            this.tooltipObject.close();
        }
    };
    /**
     * Adds the specified node to the diagram control.
     *
     * @returns { Node }     Adds the specified node to the diagram control.\
     * @param {NodeModel} obj - representing the node to be added to the diagram.
     * @param {boolean} group - A boolean value indicating whether the node should be added to a group.
     * @blazorArgsType obj|DiagramNode
     */
    Diagram.prototype.addNode = function (obj, group) {
        return this.add(obj, group);
    };
    /**
     * Adds the specified diagram object to the specified group node.
     *
     * @returns { void }     Adds the specified diagram object to the specified group node.\
     * @param {NodeModel} group - The group node to which the diagram object will be added.
     * @param {string | NodeModel | ConnectorModel} child - The diagram object to be added to the group.
     * @blazorArgsType obj|DiagramNode
     */
    Diagram.prototype.addChildToGroup = function (group, child) {
        var severDataBind = this.allowServerDataBinding;
        this.enableServerDataBinding(false);
        var propChange = this.isProtectedOnChange;
        this.protectPropertyChange(true);
        group = this.getObject(group.id);
        //Removed isBlazor code
        var isHistoryAdded = (!(this.diagramActions & DiagramAction.UndoRedo) && !(this.diagramActions & DiagramAction.Group) &&
            !(this.diagramActions & DiagramAction.PreventHistory));
        if (isHistoryAdded) {
            this.startGroupAction();
        }
        var id = this.addChild(group, child);
        if (isHistoryAdded) {
            var childTable = {};
            childTable["" + id] = cloneObject(this.getObject(id));
            var entry = {
                type: 'AddChildToGroupNode', changeType: 'Insert', undoObject: cloneObject(group),
                redoObject: cloneObject(group), category: 'Internal', objectId: id, childTable: childTable
            };
            this.addHistoryEntry(entry);
            this.endGroupAction();
        }
        //880811- Adding child to group node using addChildToGroup method is not working properly.
        var element = this.nameTable[child] ? this.nameTable[child] : child;
        var childElementToMove = document.getElementById(element.id + '_groupElement');
        var targetGroupElement = document.getElementById(group.id + '_groupElement');
        if (targetGroupElement && childElementToMove) {
            targetGroupElement.appendChild(childElementToMove);
        }
        this.protectPropertyChange(propChange);
        this.enableServerDataBinding(severDataBind);
        this.updateSelector();
        //Removed isBlazor code.
    };
    /**
     * Removes the specified diagram object from the specified group node.
     *
     * @returns { void }     Removes the specified diagram object from the specified group node.\
     * @param {NodeModel} group - The group node to which the diagram object will be removed.
     * @param {string | NodeModel | ConnectorModel} child - The diagram object to be removed from the group.
     */
    Diagram.prototype.removeChildFromGroup = function (group, child) {
        var severDataBind = this.allowServerDataBinding;
        this.enableServerDataBinding(false);
        var propChange = this.isProtectedOnChange;
        this.protectPropertyChange(true);
        group = this.getObject(group.id);
        var undoGroup = cloneObject(group);
        var isHistoryAdded = (!(this.diagramActions & DiagramAction.UndoRedo) && !(this.diagramActions & DiagramAction.Group) &&
            !(this.diagramActions & DiagramAction.PreventHistory));
        if (isHistoryAdded) {
            this.startGroupAction();
        }
        var id = this.removeChild(group, child);
        if (isHistoryAdded) {
            var childTable = {};
            childTable["" + id] = cloneObject(this.getObject(id));
            var entry = {
                type: 'RemoveChildFromGroupNode', changeType: 'Remove', undoObject: cloneObject(undoGroup),
                redoObject: cloneObject(group), category: 'Internal', objectId: id, childTable: childTable
            };
            this.addHistoryEntry(entry);
            this.endGroupAction();
        }
        //880811 - diagram elements not updated properly while grouping nodes at runtime
        var element = this.nameTable[child] ? this.nameTable[child] : child;
        var elementZindex = element.zIndex;
        var layerNum = this.layers.indexOf(this.commandHandler.getObjectLayer(element.id));
        var insertBeforeObj = this.layers[parseInt(layerNum.toString(), 10)].objects[elementZindex + 1];
        var insertBeforeElement = document.getElementById(insertBeforeObj + '_groupElement');
        var childElementToMove = document.getElementById(element.id + '_groupElement');
        var targetGroupElement = document.getElementById(group.id + '_groupElement');
        if (targetGroupElement && childElementToMove) {
            if (insertBeforeObj && insertBeforeElement) {
                if (targetGroupElement.contains(insertBeforeElement)) {
                    targetGroupElement.insertBefore(childElementToMove, insertBeforeElement);
                }
                else if (targetGroupElement.parentNode.contains(insertBeforeElement) && insertBeforeElement.parentElement
                    === targetGroupElement.parentElement) {
                    targetGroupElement.parentNode.insertBefore(childElementToMove, insertBeforeElement);
                }
                else {
                    targetGroupElement.parentNode.appendChild(childElementToMove);
                }
            }
            else {
                targetGroupElement.parentNode.appendChild(childElementToMove);
            }
        }
        this.protectPropertyChange(propChange);
        this.enableServerDataBinding(severDataBind);
        this.updateSelector();
    };
    /**
     * Retrieves the history stack values for either undo or redo actions.
     *
     * @returns { void } Retrieves the history stack values for either undo or redo actions.\
     * @param {boolean} isUndoStack - If `true`, retrieves the undo stack values; if `false`, retrieves the redo stack values.
     */
    Diagram.prototype.getHistoryStack = function (isUndoStack) {
        //let temp: HistoryEntry[];
        var historyEntry = [];
        var temp = isUndoStack ? this.historyManager.undoStack : this.historyManager.redoStack;
        if (this.historyManager.stackLimit !== undefined) {
            for (var i = temp.length - 1; i >= 0; i--) {
                historyEntry.push(temp[parseInt(i.toString(), 10)]);
                if (historyEntry.length > this.historyManager.stackLimit) {
                    return historyEntry;
                }
            }
        }
        else {
            historyEntry = temp;
        }
        return historyEntry;
    };
    /* tslint:disable */
    /**
     * Returns the edges connected to the given node.
     *
     * @returns { string[] } Returns the edges connected to the given node. \
     * @deprecated
     * @param {Object} args - An object containing information about the node for which edges are to be retrieved.
     */
    Diagram.prototype.getEdges = function (args) {
        return args['outEdge'] ? this.nameTable[args['id']].outEdges : this.nameTable[args['id']].inEdges;
    };
    /* tslint:enable */
    /**
     * Returns the parent id for the node
     *
     * @returns { string }Returns the parent id for the node .\
     * @deprecated
     * @param {string} id - returns the parent id
     */
    Diagram.prototype.getParentId = function (id) {
        return this.nameTable["" + id].parentId;
    };
    /**
     * Adds the given connector to diagram control
     * @returns { Connector } Adds the given connector to diagram control .\
     *
     * @param {ConnectorModel} obj - Defines the connector that has to be added to diagram
     * @blazorArgsType obj|DiagramConnector
     */
    Diagram.prototype.addConnector = function (obj) {
        return this.add(obj);
    };
    /* eslint-disable */
    /** @private */
    Diagram.prototype.UpdateBlazorDiagramModelCollection = function (obj, copiedObject, multiSelectDelete, isBlazorGroupUpdate) {
        /* eslint-enable */
        //Removed isBlazor code
    };
    /**
     *  UpdateBlazorDiagramModel method
     *
     * @returns { void }  UpdateBlazorDiagramModel method .\
     * @param {Node | Connector | ShapeAnnotation | PathAnnotation} obj - provide the obj value.
     * @param {string} objectType - provide the objectType value.
     * @param {number} removalIndex - provide the removalIndex value.
     * @param {number} annotationNodeIndex - provide the annotationNodeIndex value.
     *
     * @private
     */
    Diagram.prototype.UpdateBlazorDiagramModel = function (obj, objectType, removalIndex, annotationNodeIndex) {
        //Removed isBlazor code
    };
    // eslint-disable-next-line max-len
    Diagram.prototype.UpdateBlazorLabelOrPortObjects = function (obj, objectType, removalIndex, nodeIndex) {
        //Removed isBlazor code
    };
    /**
     *  addBlazorDiagramObjects method
     *
     * @returns { void }  addBlazorDiagramObjects method .\
     *
     * @private
     */
    Diagram.prototype.addBlazorDiagramObjects = function () {
        //Removed isBlazor code
    };
    Diagram.prototype.removeNodeEdges = function (elementId, id, isOutEdges) {
        var node = this.nameTable["" + elementId];
        var edges = isOutEdges ? node.outEdges : node.inEdges;
        if (edges.length > 0) {
            for (var i = 0; i < edges.length; i++) {
                if (edges[parseInt(i.toString(), 10)] === id) {
                    edges.splice(i, 1);
                }
            }
        }
    };
    /**
     *  insertBlazorConnector method
     *
     * @returns { void }  insertBlazorConnector method .\
     * @param {Connector} obj - provide the nodeId value.
     *
     * @private
     */
    Diagram.prototype.insertBlazorConnector = function (obj) {
        //Removed isBlazor code
    };
    /* tslint:disable */
    /**
     * Adds the provided object, which can be a node, group, or connector, onto the diagram canvas.
     *
     * @returns { Node | Connector }     Adds the provided object, which can be a node, group, or connector, onto the diagram canvas.\
     * @param {NodeModel | ConnectorModel} obj - Specifies the object to be added to the diagram.
     * @param {boolean} group - If a group object is passed, set it to true.
     */
    Diagram.prototype.add = function (obj, group) {
        var newObj;
        var propertyChangeValue = this.isProtectedOnChange;
        this.protectPropertyChange(true);
        var isTextAnnotationNode = false;
        if (obj) {
            obj = cloneObject(obj);
            var args = void 0;
            args = {
                element: obj, cause: this.diagramActions, diagramAction: this.getDiagramAction(this.diagramActions), state: 'Changing', type: 'Addition', cancel: false
            };
            if (this.parentObject) {
                args.parentId = this.parentObject.id;
            }
            //Removed isBlazor code
            if (obj.id !== 'helper' && !(this.diagramActions & DiagramAction.PreventCollectionChangeOnDragOver)) {
                this.triggerEvent(DiagramEvent.collectionChange, args);
            }
            if (args.cancel && this.drawingObject) {
                this.removeElements(args.element);
                this.tooltipObject.close();
                var sourceNodee = this.getObject(args.element.sourceID);
                var isOutEdgee = void 0;
                if (getObjectType(args.element) === Connector) {
                    if (args.element.sourceID) {
                        this.removeNodeEdges(args.element.sourceID, args.element.id, true);
                        if (sourceNodee.ports.length > 0) {
                            for (var i = 0; i < sourceNodee.ports.length; i++) {
                                var port = sourceNodee.ports[parseInt(i.toString(), 10)];
                                if (port.id === args.element.sourcePortID) {
                                    if (port.outEdges.length > 0) {
                                        isOutEdgee = false;
                                    }
                                    else {
                                        isOutEdgee = true;
                                    }
                                }
                            }
                            this.removePortEdges(sourceNodee, args.element.sourcePortID, args.element.id, isOutEdgee);
                        }
                    }
                    if (args.element.targetID) {
                        this.removeNodeEdges(args.element.targetID, args.element.id, false);
                    }
                }
            }
            this.diagramActions = this.diagramActions | DiagramAction.PublicMethod;
            obj.id = obj.id || randomId();
            var layers = this.activeLayer;
            // Bug 890792: Exception thrown when adding a node at runtime in the unit test case.
            // The issue arises only when the diagram is not appended to the DOM. In such cases, the diagram will not be rendered, and the activeLayer property is undefined.
            // Check if activeLayer is defined. If activeLayer is defined, then proceed with the operation.
            if (!args.cancel && layers && !layers.lock) {
                if (layers.objects.indexOf(obj.id) < 0 && !layers.lock) {
                    if (!layers.visible) {
                        layers.visible = true;
                        this.dataBind();
                    }
                    layers.objects.push(obj.id);
                }
                if (getObjectType(obj) === Connector) {
                    newObj = new Connector(this, 'connectors', obj, true);
                    newObj.status = 'New';
                    if (this.nameTable[newObj.targetID] && this.nameTable[newObj.targetID].shape.shape === 'TextAnnotation') {
                        newObj.isBpmnAnnotationConnector = true;
                        newObj.constraints = newObj.constraints & ~ConnectorConstraints.Delete;
                    }
                    updateDefaultValues(newObj, obj, this.connectorDefaults);
                    this.connectors.push(newObj);
                    this.initObject(newObj);
                    //Removed isBlazor code
                    if (obj.visible === false) {
                        this.updateElementVisibility(newObj.wrapper, newObj, obj.visible);
                    }
                    this.updateEdges(newObj);
                    this.insertBlazorConnector(newObj);
                }
                else {
                    newObj = new Node(this, 'nodes', obj, true);
                    updateDefaultValues(newObj, obj, this.nodeDefaults);
                    newObj.parentId = (obj.parentId) ? obj.parentId : newObj.parentId;
                    newObj.umlIndex = obj.umlIndex;
                    newObj.status = 'New';
                    isTextAnnotationNode = newObj.shape.shape === 'TextAnnotation';
                    if (isTextAnnotationNode && !obj.isTextAnnotationCopied) {
                        newObj.inEdges = obj.inEdges ? obj.inEdges : newObj.inEdges;
                    }
                    this.nodes.push(newObj);
                    this.initObject(newObj, layers, undefined, group);
                    if (isTextAnnotationNode) {
                        if (this.bpmnModule) {
                            for (var i = 0; i < this.bpmnModule.bpmnTextAnnotationConnector.length; i++) {
                                if (this.bpmnModule.bpmnTextAnnotationConnector[parseInt(i.toString(), 10)].wrapper === null) {
                                    this.initConnectors(this.bpmnModule.bpmnTextAnnotationConnector[parseInt(i.toString(), 10)], undefined, true);
                                }
                            }
                        }
                    }
                    //Removed isBlazor code
                    this.updateTemplate();
                    if (this.bpmnModule) {
                        if (newObj.shape.activity && newObj.shape.activity.subProcess.processes &&
                            newObj.shape.activity.subProcess.processes.length) {
                            this.bpmnModule.updateDocks(newObj, this);
                        }
                    }
                    if (this.lineRoutingModule && (this.constraints & DiagramConstraints.LineRouting)) {
                        var objects = this.spatialSearch.findObjects(newObj.wrapper.outerBounds);
                        for (var i = 0; i < objects.length; i++) {
                            var object = objects[parseInt(i.toString(), 10)];
                            if (object instanceof Connector) {
                                this.connectorPropertyChange(object, {}, {
                                    sourceID: object.sourceID, targetID: object.targetID, sourcePortID: object.sourcePortID,
                                    targetPortID: object.targetPortID, sourcePoint: object.sourcePoint, targetPoint: object.targetPoint
                                });
                            }
                        }
                    }
                    else if (this.constraints & DiagramConstraints.LineRouting) {
                        console.warn('[WARNING] :: Module "LineRouting" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
                    }
                    if (newObj.umlIndex > -1 && obj.parentId && this.nameTable[obj.parentId] &&
                        this.nameTable[obj.parentId].shape.type === 'UmlClassifier') {
                        var parent_2 = this.nameTable[obj.parentId];
                        parent_2.children.splice(newObj.umlIndex, 0, newObj.id);
                        parent_2.wrapper.children.splice(newObj.umlIndex, 0, newObj.wrapper);
                        parent_2.wrapper.measure(new Size());
                        parent_2.wrapper.arrange(parent_2.wrapper.desiredSize);
                        this.updateDiagramObject(parent_2);
                    }
                }
                args = {
                    element: newObj, cause: this.diagramActions, diagramAction: this.getDiagramAction(this.diagramActions), state: 'Changed', type: 'Addition', cancel: false
                };
                if (this.parentObject) {
                    args.parentId = this.parentObject.id;
                }
                //Removed isBlazor code
                if (obj.id !== 'helper' && !(this.diagramActions & DiagramAction.PreventCollectionChangeOnDragOver)) {
                    this.triggerEvent(DiagramEvent.collectionChange, args);
                }
                if (!(this.diagramActions & DiagramAction.UndoRedo) && !(this.diagramActions & DiagramAction.Group) &&
                    !(this.diagramActions & DiagramAction.PreventHistory)) {
                    var entry = {
                        type: 'CollectionChanged', changeType: 'Insert', undoObject: cloneObject(obj),
                        redoObject: cloneObject(obj), category: 'Internal'
                    };
                    this.addHistoryEntry(entry);
                }
                this.parentObject = undefined;
                if (this.mode === 'SVG') {
                    this.updateSvgNodes(newObj);
                    this.updateTextElementValue(newObj);
                    this.updateDiagramObject(newObj);
                    if (isTextAnnotationNode) {
                        var con = this.nameTable[newObj.inEdges[0]];
                        this.updateDiagramObject(con);
                    }
                    if (newObj.shape.activity && newObj.shape.activity.subProcess.processes &&
                        newObj.shape.activity.subProcess.processes.length) {
                        this.updateProcesses(newObj);
                    }
                    this.updateBridging();
                }
            }
        }
        this.protectPropertyChange(propertyChangeValue);
        this.resetDiagramActions(DiagramAction.PublicMethod);
        if (newObj && this.layers.length > 1) {
            this.moveNode(newObj);
        }
        // Bug 890792: Exception thrown when adding a node at runtime in the unit test case.
        // The issue arises only when the diagram is not appended to the DOM. In such cases, the diagram will not be rendered, and the views property is undefined.
        // Check if views is defined before iterating. If views is defined, then refresh the canvas for each view.
        if (this.views) {
            for (var _i = 0, _a = this.views; _i < _a.length; _i++) {
                var temp = _a[_i];
                var view = this.views["" + temp];
                if (!(view instanceof Diagram)) {
                    this.refreshCanvasDiagramLayer(view);
                }
            }
        }
        this.renderReactTemplates();
        return newObj;
    };
    /**
     * AddElements method allows us to add diagram elements such as nodes and connectors as a collection into the diagram canvas.
     * @returns {void} -AddElements method.
     * @param { NodeModel[] | ConnectorModel[]} obj -Specifies the colelction object to be added to the diagram.
     * @public method
     **/
    Diagram.prototype.addElements = function (obj) {
        for (var i = 0; i < obj.length; i++) {
            this.add(obj[parseInt(i.toString(), 10)]);
        }
        // 930450: Diagram Taking Too Long to Load Due to Complex Hierarchical Tree Layout with Path Nodes
        if (this.pathDataStorage) {
            this.pathDataStorage.clear();
        }
    };
    /**
     * getPathdata from path data storage to access the path elements points
     * @returns {PointModel[]} - Ruturns points of the path data
     * @param {string} key - Path data as key
     *
     * @private
     */
    Diagram.prototype.getPathData = function (key) {
        // 930450: Diagram Taking Too Long to Load Due to Complex Hierarchical Tree Layout with Path Nodes
        if (!this.pathDataStorage) {
            this.pathDataStorage = new Map();
        }
        if (!this.pathDataStorage.has(key)) {
            return [];
        }
        return this.pathDataStorage.get(key);
    };
    /**
     * setPathdata to path data storage to access the path elements points
     * @returns {void} - Set Path data method
     * @param {string} key - Path data as key
     * @param {PointModel[]} data - Path data's points
     *
     * @private
     */
    Diagram.prototype.setPathData = function (key, data) {
        // 930450: Diagram Taking Too Long to Load Due to Complex Hierarchical Tree Layout with Path Nodes
        var existingData = this.pathDataStorage.get(key) || [];
        // Push data only if existingData is empty
        if (existingData.length === 0) {
            this.pathDataStorage.set(key, data);
        }
    };
    /* tslint:enable */
    Diagram.prototype.updateSvgNodes = function (node) {
        if (node.children) {
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var j = _a[_i];
                if (this.nameTable["" + j] && this.nameTable["" + j].parentId) {
                    var child = getDiagramElement(j + '_groupElement', this.element.id);
                    if (child) {
                        child.parentNode.removeChild(child);
                    }
                }
            }
        }
    };
    /**
     *  updateProcesses method
     *
     * @returns { void }  updateProcesses method .\
     * @param {(Node | Connector)} node - provide the nodeId value.
     *
     * @private
     */
    Diagram.prototype.updateProcesses = function (node) {
        if (this.bpmnModule && node && node.shape && node.shape.activity &&
            node.shape.activity.subProcess.processes &&
            node.shape.activity.subProcess.processes.length) {
            var processes = node.shape.activity.subProcess.processes;
            this.moveSvgNode(node.id);
            for (var _i = 0, processes_1 = processes; _i < processes_1.length; _i++) {
                var j = processes_1[_i];
                this.moveSvgNode(j);
                var edges = [];
                edges = edges.concat(this.nameTable["" + j].outEdges, this.nameTable["" + j].inEdges);
                for (var i = edges.length - 1; i >= 0; i--) {
                    this.moveSvgNode(edges[parseInt(i.toString(), 10)]);
                }
            }
            for (var _a = 0, processes_2 = processes; _a < processes_2.length; _a++) {
                var j = processes_2[_a];
                if (this.nameTable["" + j].shape.activity.subProcess.processes &&
                    this.nameTable["" + j].shape.activity.subProcess.processes.length) {
                    this.updateProcesses(this.nameTable["" + j]);
                }
            }
        }
        else {
            this.moveSvgNode(node.id);
        }
    };
    /**
     *  moveSvgNode method
     *
     * @returns { void }  moveSvgNode method .\
     * @param {string} nodeId - provide the nodeId value.
     *
     * @private
     */
    Diagram.prototype.moveSvgNode = function (nodeId) {
        var child = getDiagramElement(nodeId + '_groupElement', this.element.id);
        var parent = child.parentElement;
        child.parentNode.removeChild(child);
        parent.appendChild(child);
    };
    /**
     * Adds the given annotation to the specified node.
     *
     * @returns { void } Adds the given annotation to the specified node.\
     * @param {BpmnAnnotationModel} annotation - Object representing the annotation to be added.
     * @param {NodeModel} node - object representing the node to which the annotation will be added.
     * @deprecated
     */
    Diagram.prototype.addTextAnnotation = function (annotation, node) {
        if (this.bpmnModule) {
            this.getBPMNTextAnnotation(node, this, annotation, true);
        }
    };
    //Splice the InEdge and OutEdge of the for the node with respect to corresponding connectors that is deleting
    Diagram.prototype.spliceConnectorEdges = function (connector, isSource) {
        //let node: Node;
        var edges = [];
        //let isInEdge: boolean;
        var node = isSource ? this.nameTable[connector.sourceID] : this.nameTable[connector.targetID];
        if (node) {
            edges = isSource ? node.outEdges : node.inEdges;
            for (var i = edges.length - 1; i >= 0; i--) {
                if (edges[parseInt(i.toString(), 10)] === connector.id) {
                    edges.splice(i, 1);
                }
            }
            for (var j = 0; node.ports && j < node.ports.length; j++) {
                var isInEdge = isSource ? false : true;
                this.removePortEdges(node, node.ports[parseInt(j.toString(), 10)].id, connector.id, isInEdge);
            }
        }
    };
    /**
     * Remove the dependent connectors if the node is deleted
     * @returns { void } Remove the dependent connectors if the node is deleted .\
     * @param {Node} obj - provide the node value.
     *
     * @private
     */
    Diagram.prototype.removeDependentConnector = function (obj) {
        if (obj) {
            var connector = void 0;
            var edges = [];
            edges = edges.concat(obj.outEdges, obj.inEdges);
            for (var i = edges.length - 1; i >= 0; i--) {
                connector = this.nameTable[edges[parseInt(i.toString(), 10)]];
                if (connector) {
                    this.connectorTable[connector.id] = cloneObject(connector);
                    //To check for text annotation connector and remove the dependent text annotation node.
                    if (connector.isBpmnAnnotationConnector) {
                        var targetNode = this.nameTable[connector.targetID];
                        this.removeObjectsFromLayer(connector);
                        var index = this.connectors.indexOf(connector);
                        if (index !== -1) {
                            this.connectors.splice(index, 1);
                        }
                        this.removeElements(connector);
                        this.removeFromAQuad(connector);
                        delete this.nameTable[connector.id];
                        var sourceNode = this.nameTable[connector.sourceID];
                        if (sourceNode) {
                            var index_1 = sourceNode.outEdges.indexOf(connector.id);
                            if (index_1 !== -1) {
                                sourceNode.outEdges.splice(index_1, 1);
                            }
                        }
                        if (obj.id !== connector.targetID) {
                            this.remove(targetNode);
                        }
                    }
                    else {
                        this.remove(connector);
                    }
                }
            }
        }
    };
    /**
     * Remove the dependent connectors if the node is deleted
     * @returns { void } Remove the dependent connectors if the node is deleted .\
     * @param {(NodeModel | ConnectorModel)} obj - provide the node value.
     *
     * @private
     */
    Diagram.prototype.removeObjectsFromLayer = function (obj) {
        if (obj.children) {
            for (var i = 0; i < obj.children.length; i++) {
                var object = this.nameTable[obj.children[parseInt(i.toString(), 10)]];
                if (object) {
                    this.removeObjectsFromLayer(object);
                }
            }
        }
        var layer = this.layers.indexOf(this.commandHandler.getObjectLayer(obj.id));
        var objects = this.layers[parseInt(layer.toString(), 10)].objects;
        var objIndex = objects.indexOf(obj.id);
        if (objIndex > -1) {
            this.commandHandler.updateLayersZindexTable(layer);
            if (isSelected(this, obj)) {
                this.unSelect(obj);
            }
            this.layers[parseInt(layer.toString(), 10)].objects.splice(objIndex, 1);
            delete this.layers[parseInt(layer.toString(), 10)].zIndexTable[this.nameTable[obj.id].zIndex];
        }
    };
    /**
     * removeElements method \
     *
     * @returns { string }     removeElements method .\
     * @param {NodeModel | ConnectorModel} currentObj - provide the currentObj value.
     *
     * @private
     */
    Diagram.prototype.removeElements = function (currentObj) {
        if (this.mode === 'SVG' || (this.mode === 'Canvas' && currentObj.shape.type === 'Native')) {
            var removeElement_1 = getDiagramElement(currentObj.id + '_groupElement', this.element.id);
            var object = currentObj;
            if ((object).ports && (object).ports.length > 0) {
                for (var i = 0; i < (object).ports.length; i++) {
                    var port = (object).ports[parseInt(i.toString(), 10)];
                    var removePort = getDiagramElement(object.id + '_' + port.id + '_groupElement', this.element.id);
                    if (removePort) {
                        removePort.parentNode.removeChild(removePort);
                    }
                }
            }
            if (removeElement_1) {
                removeElement_1.parentNode.removeChild(removeElement_1);
            }
        }
        this.refreshCanvasLayers();
        if (currentObj.wrapper) {
            var children = currentObj.wrapper.children;
            var element = void 0;
            if (children) {
                for (var i = 0; i < children.length; i++) {
                    if (children[parseInt(i.toString(), 10)] instanceof DiagramNativeElement || ((children[parseInt(i.toString(), 10)].id) && (children[parseInt(i.toString(), 10)].id).indexOf('icon_content') > 0)) {
                        if ((children[parseInt(i.toString(), 10)].id).indexOf('icon_content') > 0 && this.mode === 'SVG') {
                            element = getDiagramElement(children[parseInt(i.toString(), 10)].id + '_shape_groupElement', this.element.id);
                            if (element) {
                                element.parentNode.removeChild(element);
                            }
                            element = getDiagramElement(children[parseInt(i.toString(), 10)].id + '_rect_groupElement', this.element.id);
                            if (element) {
                                element.parentNode.removeChild(element);
                            }
                        }
                        for (var _i = 0, _a = this.views; _i < _a.length; _i++) {
                            var elementId = _a[_i];
                            removeElement(children[parseInt(i.toString(), 10)].id + '_groupElement', elementId);
                            var nodeIndex = this.scroller.removeCollection.indexOf(currentObj.id);
                            this.scroller.removeCollection.splice(nodeIndex, 1);
                        }
                    }
                    else if (children[parseInt(i.toString(), 10)] instanceof DiagramHtmlElement) {
                        for (var _b = 0, _c = this.views; _b < _c.length; _b++) {
                            var elementId = _c[_b];
                            removeElement(currentObj.id + '_html_element', elementId);
                            removeElement(children[parseInt(i.toString(), 10)].id + '_html_element', elementId);
                            //EJ2-63598 - Added below code to check whether platform is Angular or not.
                            // If angular then we do not remove the node html element wrapper to retain the HTML element in it.
                            var canUpdate = true;
                            var parent_3 = this.nameTable[currentObj.parentId];
                            //893691: HTML Template nodes are not visible after Zooming with Virtualisation
                            if (((this.isAngular || this.isReact) || this.isVue) &&
                                ((parent_3 && parent_3.isLane) || (this.constraints & DiagramConstraints.Virtualization))) {
                                canUpdate = false;
                            }
                            if (canUpdate) {
                                this.clearTemplate(['nodeTemplate' + '_' + currentObj.id]);
                                if (children[parseInt(i.toString(), 10)].annotationId) {
                                    this.clearTemplate(['annotationTemplate' + '_' + currentObj.id +
                                            (children[parseInt(i.toString(), 10)].annotationId)]);
                                }
                            }
                        }
                    }
                    removeGradient(children[parseInt(i.toString(), 10)].id);
                }
            }
        }
    };
    Diagram.prototype.removeCommand = function () {
        this.remove();
    };
    /**
     * Removes the specified object from the diagram.
     *
     * @param {NodeModel | ConnectorModel} obj - The node or connector object to be removed from the diagram.
     */
    /* tslint:disable */
    Diagram.prototype.remove = function (obj) {
        var selectedItems = [];
        selectedItems = selectedItems.concat(this.selectedItems.nodes, this.selectedItems.connectors);
        var args;
        var groupAction = false;
        if (obj) {
            obj = this.nameTable[obj.id];
            this.insertBlazorConnector(obj);
            if (obj && (canDelete(obj) || (this.diagramActions & DiagramAction.Clear))) {
                args = {
                    element: obj, cause: this.diagramActions, diagramAction: this.getDiagramAction(this.diagramActions),
                    state: 'Changing', type: 'Removal', cancel: false
                };
                //Removed isBlazor code
                if (!(this.diagramActions & DiagramAction.Clear) && (obj.id !== 'helper')) {
                    this.triggerEvent(DiagramEvent.collectionChange, args);
                }
                if (!args.cancel) {
                    if (canDelete(obj)) {
                        if (obj && obj.shape && obj.shape.type === 'SwimLane') {
                            removeSwimLane(this, obj);
                        }
                    }
                    if ((!(this.diagramActions & DiagramAction.UndoRedo)) && !(this.diagramActions & DiagramAction.PreventHistory) &&
                        (obj instanceof Node || obj instanceof Connector)) {
                        var entry = {
                            type: 'CollectionChanged', changeType: 'Remove', undoObject: cloneObject(obj),
                            redoObject: cloneObject(obj), category: 'Internal'
                        };
                        if (!(this.diagramActions & DiagramAction.Clear)) {
                            if (obj.children && !obj.isLane && !obj.isPhase && obj.children.length > 0 && this.undoRedoModule && this.layout.type === 'None') {
                                this.historyManager.startGroupAction();
                                groupAction = true;
                            }
                        }
                        //875087 - Restrict removing dependent connectors when moveing between layers
                        if ((obj instanceof Node || obj instanceof Connector) && this.deleteDependentConnector) {
                            this.removeDependentConnector(obj);
                        }
                        if (!obj.isLane && !obj.isPhase) {
                            if (!(this.diagramActions & DiagramAction.Clear) && !this.isStackChild(obj)) {
                                this.addHistoryEntry(entry);
                            }
                        }
                    }
                    if (obj.shape.shape === 'TextAnnotation') {
                        this.removeDependentConnector(obj);
                    }
                    if (obj.children && !obj.isLane && !obj.isPhase &&
                        (!(this.diagramActions & DiagramAction.UndoRedo) || !isBlazor())) {
                        this.deleteGroup(obj);
                    }
                    if (obj.parentId) {
                        this.deleteChild(obj, undefined, true);
                        if (this.nameTable[obj.parentId] && this.nameTable[obj.parentId].shape.type === 'UmlClassifier') {
                            this.updateDiagramObject(this.nameTable[obj.parentId]);
                            this.updateConnectorEdges(this.nameTable[obj.parentId]);
                        }
                    }
                    var index = void 0;
                    this.diagramActions = this.diagramActions | DiagramAction.PublicMethod;
                    var currentObj = this.nameTable[obj.id];
                    if (currentObj instanceof Node) {
                        if (currentObj.shape.type === 'Bpmn' && this.bpmnModule) {
                            this.bpmnModule.removeBpmnProcesses(currentObj, this);
                        }
                        if (currentObj.isLane || currentObj.isPhase || currentObj.shape.type === 'SwimLane') {
                            var swimLaneNode = (currentObj.isLane || currentObj.isPhase) ?
                                this.nameTable[currentObj.parentId] : this.nameTable[currentObj.id];
                            var grid = swimLaneNode.wrapper.children[0];
                            if (currentObj.isLane) {
                                removeLane(this, currentObj, swimLaneNode);
                            }
                            else if (currentObj.isPhase) {
                                removePhase(this, currentObj, swimLaneNode);
                            }
                        }
                        index = this.nodes.indexOf(currentObj);
                        // Removed isBlazor code
                        if (index !== -1) {
                            this.crudDeleteNodes.push(this.nameTable[currentObj.id]);
                            this.nodes.splice(index, 1);
                            this.updateNodeEdges(currentObj);
                        }
                    }
                    else {
                        index = this.connectors.indexOf(currentObj);
                        //Removed isBlazor code
                        if (index !== -1) {
                            this.crudDeleteNodes.push(this.nameTable[currentObj.id]);
                            this.connectors.splice(index, 1);
                        }
                        this.updateEdges(currentObj);
                        this.spliceConnectorEdges(obj, true);
                        this.spliceConnectorEdges(obj, false);
                    }
                    if ((!this.isServerUpdate) && !(this.blazorActions & BlazorAction.GroupClipboardInProcess)) {
                        this.commandHandler.getBlazorOldValues();
                    }
                    if (groupAction) {
                        this.historyManager.endGroupAction();
                    }
                    if (isSelected(this, currentObj)) {
                        this.unSelect(currentObj);
                    }
                    if (!currentObj.isPhase) {
                        this.removeObjectsFromLayer(obj);
                        if (this.currentDrawingObject) {
                            this.currentDrawingObject.wrapper = undefined;
                        }
                        delete this.nameTable[obj.id];
                        if (selectedItems.length > 0 && selectedItems[0].id === currentObj.id && currentObj.parentId) {
                            var parentnode = this.nameTable[currentObj.parentId];
                            if (parentnode && parentnode.isLane && this.nameTable[parentnode.parentId].shape.type === 'SwimLane') {
                                var swimLaneNode = this.nameTable[parentnode.parentId];
                                removeLaneChildNode(this, swimLaneNode, parentnode, currentObj);
                            }
                        }
                        this.removeElements(currentObj);
                        this.updateBridging();
                        if (this.mode !== 'SVG') {
                            this.refreshDiagramLayer();
                        }
                        if (!(this.diagramActions & DiagramAction.Clear)) {
                            this.removeFromAQuad(currentObj);
                            args = {
                                element: obj, cause: this.diagramActions, diagramAction: this.getDiagramAction(this.diagramActions),
                                state: 'Changed', type: 'Removal', cancel: false
                            };
                            //Removed isBlazor code
                            if (obj.id !== 'helper') {
                                this.triggerEvent(DiagramEvent.collectionChange, args);
                            }
                            this.resetTool();
                        }
                    }
                }
            }
        }
        else if (selectedItems.length > 0) {
            if (this.undoRedoModule) {
                this.historyManager.startGroupAction();
                this.blazorActions |= BlazorAction.GroupingInProgress;
                groupAction = true;
            }
            //Removed isBlazor code
            for (var i = 0; i < selectedItems.length; i++) {
                var node = selectedItems[parseInt(i.toString(), 10)];
                var parent_4 = this.nameTable[node.parentId];
                if (this.nameTable[selectedItems[parseInt(i.toString(), 10)].id]) {
                    //Removed isBlazor code
                    // 912905: Multi-selecting and deleting swimlane objects causes the diagram to break
                    if (parent_4 && parent_4.shape instanceof SwimLane && !node.isPhase) {
                        if (node.isLane) {
                            var parentHeader = parent_4.shape.header.id ? parent_4.shape.header.height : 0;
                            if ((this.selectedItems.wrapper.bounds.x <= parent_4.wrapper.bounds.x &&
                                this.selectedItems.wrapper.bounds.width >= parent_4.wrapper.bounds.width &&
                                parent_4.shape.orientation === 'Horizontal') ||
                                (this.selectedItems.wrapper.bounds.y <= parent_4.wrapper.bounds.y + parentHeader &&
                                    this.selectedItems.wrapper.bounds.height >= parent_4.wrapper.bounds.height - parentHeader &&
                                    parent_4.shape.orientation === 'Vertical')) {
                                if (canDelete(parent_4) || parent_4.shape.lanes.length > 1) {
                                    this.remove(selectedItems[parseInt(i.toString(), 10)]);
                                }
                            }
                        }
                    }
                    else {
                        this.remove(selectedItems[parseInt(i.toString(), 10)]);
                    }
                    //Removed isBlazor code
                }
            }
            if (groupAction) {
                this.blazorActions &= ~BlazorAction.GroupingInProgress;
                this.isServerUpdate = true;
                this.commandHandler.getBlazorOldValues();
                this.UpdateBlazorDiagramModelCollection(undefined, undefined, undefined, true);
                this.historyManager.endGroupAction();
                this.isServerUpdate = false;
            }
            this.clearSelection();
        }
        if (!(obj && (canDelete(obj) || (this.diagramActions & DiagramAction.Clear)))) {
            if ((!(this.diagramActions & DiagramAction.UndoRedo)) && !(this.diagramActions & DiagramAction.PreventHistory) &&
                (obj instanceof Node || obj instanceof Connector)) {
                var entry = {
                    type: 'ConnectionChanged', undoObject: cloneObject(obj),
                    redoObject: cloneObject(obj), category: 'Internal'
                };
                if (!obj.isLane && !obj.isPhase) {
                    if (!(this.diagramActions & DiagramAction.Clear) && !this.isStackChild(obj)) {
                        this.addHistoryEntry(entry);
                    }
                }
            }
        }
        this.tooltipObject.close();
        if (obj && obj.id !== 'helper' && this.lineRoutingModule && (this.constraints & DiagramConstraints.LineRouting) &&
            (obj instanceof Node) && (this.layout.type !== 'ComplexHierarchicalTree')) {
            var INFLATE_MARGIN = 40;
            var nodeBounds = getBounds(obj.wrapper);
            nodeBounds.Inflate(INFLATE_MARGIN);
            var nearbyObjects = this.spatialSearch.findObjects(nodeBounds);
            this.lineRoutingModule.renderVirtualRegion(this, true);
            for (var _i = 0, nearbyObjects_1 = nearbyObjects; _i < nearbyObjects_1.length; _i++) {
                var item = nearbyObjects_1[_i];
                if (item instanceof Connector && item.type === 'Orthogonal') {
                    this.lineRoutingModule.refreshConnectorSegments(this, item, true);
                }
            }
        }
    };
    /* tslint:enable */
    Diagram.prototype.isStackChild = function (obj) {
        var isstack;
        var parent = this.nameTable[obj.parentId];
        if (obj && obj.parentId && parent.container &&
            (parent.container.type === 'Stack' &&
                this.nameTable[obj.parentId].shape.type !== 'UmlClassifier')) {
            isstack = true;
            var redoElement = {
                sourceIndex: parent.wrapper.children.indexOf(obj.wrapper), source: obj,
                target: undefined, targetIndex: undefined
            };
            var entry = {
                type: 'StackChildPositionChanged', redoObject: {
                    sourceIndex: undefined, source: obj,
                    target: undefined, targetIndex: undefined
                },
                undoObject: redoElement,
                category: 'Internal'
            };
            if (!(this.diagramActions & DiagramAction.UndoRedo)) {
                this.addHistoryEntry(entry);
            }
        }
        return isstack;
    };
    /** @private */
    Diagram.prototype.deleteChild = function (node, parentNode, allowChildInSwimlane) {
        var id;
        parentNode = parentNode ? this.nameTable[parentNode.id] : this.nameTable[node.parentId];
        if (typeof node === 'string') {
            id = node;
        }
        else {
            id = node.id;
        }
        if (parentNode && parentNode.children) {
            for (var i = 0; i < parentNode.children.length; i++) {
                if (parentNode.children[parseInt(i.toString(), 10)] === id) {
                    parentNode.children.splice(i, 1);
                    for (var j = 0; j < parentNode.wrapper.children.length; j++) {
                        if (parentNode.wrapper.children[parseInt(j.toString(), 10)].id === id) {
                            parentNode.wrapper.children.splice(j, 1);
                        }
                    }
                    // Bug 841849: Swimlane child are not positioned properly and throw exception after deleting and then undoing.
                    // Added below condition to skip the child deletion inside swimlane when we add phase at runtime and delete swimlane.
                    if (!allowChildInSwimlane) {
                        // EJ2-57179 - Below lines added to remove the childs to swimlane after Redo.
                        var swimlaneNode = this.getObject(parentNode.parentId);
                        if (swimlaneNode && swimlaneNode.shape instanceof SwimLane) {
                            for (var h = 0; h < swimlaneNode.shape.lanes.length; h++) {
                                var laneId = node.parentId.split(swimlaneNode.id);
                                if (swimlaneNode.shape.lanes[parseInt(h.toString(), 10)].id
                                    === laneId[1].slice(0, -1)) {
                                    for (var y = 0; y < swimlaneNode.shape.lanes[parseInt(h.toString(), 10)].children.length; y++) {
                                        if (node.id ===
                                            swimlaneNode.shape.lanes[parseInt(h.toString(), 10)].children[parseInt(y.toString(), 10)].id) {
                                            swimlaneNode.shape.lanes[parseInt(h.toString(), 10)].children.splice(y, 1);
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            parentNode.wrapper.measure(new Size());
            parentNode.wrapper.arrange(parentNode.wrapper.desiredSize);
        }
    };
    /**
     * addChild method \
     *
     * @returns { string }     addChild method .\
     * @param {NodeModel} node - provide the node value.
     * @param {string | NodeModel | ConnectorModel} child - provide the child value.
     * @param {number} index - provide the layoutOrientation value.
     *
     * @private
     */
    Diagram.prototype.addChild = function (node, child, index) {
        var id;
        var parentNode = this.nameTable[node.id];
        if (!parentNode.children) {
            parentNode.children = [];
        }
        if (parentNode.children) {
            if (typeof child === 'string') {
                if (this.nameTable["" + child]) {
                    id = child;
                }
            }
            else {
                id = child.id = child.id || randomId();
                this.add(child);
            }
            if (id && (!child.umlIndex || child.umlIndex === -1)) {
                var childNode = this.nameTable["" + id];
                childNode.parentId = parentNode.id;
                if (parentNode.container && parentNode.container.type === 'Stack') {
                    this.updateStackProperty(parentNode, childNode);
                }
                if (index) {
                    parentNode.children.splice(index, 0, id);
                    parentNode.wrapper.children.splice(index, 0, childNode.wrapper);
                }
                else {
                    parentNode.children.push(id);
                    parentNode.wrapper.children.push(childNode.wrapper);
                    // SF-362880 - Below lines added for adding the childs to swimlane after Undo.
                    var swimlane = this.getObject(node.parentId);
                    var childAlreadyInCollection = false;
                    if (swimlane && swimlane.shape instanceof SwimLane) {
                        for (var h = 0; h < swimlane.shape.lanes.length; h++) {
                            var lane = findLane(parentNode, this);
                            if (swimlane.shape.lanes[parseInt(h.toString(), 10)].id === lane.id) {
                                //Bug 876330: After performing cut operations followed by an undo, lanes and nodes in the swimlane are not rendered properly.
                                // To avoid adding the child node multiple times in the collection.
                                for (var i = 0; i < swimlane.shape.lanes[parseInt(h.toString(), 10)].children.length; i++) {
                                    if (swimlane.shape.lanes[parseInt(h.toString(), 10)].children[parseInt(i.toString(), 10)].id === childNode.id) {
                                        childAlreadyInCollection = true;
                                        break;
                                    }
                                }
                                if (!childAlreadyInCollection) {
                                    swimlane.shape.lanes[parseInt(h.toString(), 10)].children.push(childNode);
                                }
                                break;
                            }
                        }
                    }
                }
                parentNode.wrapper.measure(new Size());
                parentNode.wrapper.arrange(parentNode.wrapper.desiredSize);
                if (!parentNode.isLane) {
                    this.nameTable[node.id].width = parentNode.wrapper.actualSize.width;
                    this.nameTable[node.id].height = parentNode.wrapper.actualSize.height;
                    this.nameTable[node.id].offsetX = parentNode.wrapper.offsetX;
                    this.nameTable[node.id].offsetY = parentNode.wrapper.offsetY;
                }
                if (parentNode.container !== undefined) {
                    childNode.offsetX = childNode.wrapper.offsetX;
                    childNode.offsetY = childNode.wrapper.offsetY;
                }
                if (!parentNode.parentId ||
                    (this.nameTable[parentNode.parentId] &&
                        this.nameTable[parentNode.parentId].shape.type !== 'SwimLane')) {
                    this.updateDiagramObject(parentNode);
                }
            }
        }
        return id;
    };
    /**
     * removeChild method \
     *
     * @returns { string }     removeChild method .\
     * @param {NodeModel} node - provide the node value.
     * @param {string | NodeModel | ConnectorModel} child - provide the child value.
     *
     * @private
     */
    Diagram.prototype.removeChild = function (node, child) {
        var id;
        var parentNode = this.nameTable[node.id];
        if (!parentNode.children) {
            parentNode.children = [];
        }
        if (parentNode.children) {
            if (typeof child === 'string') {
                if (this.nameTable["" + child]) {
                    id = child;
                }
            }
            else {
                id = child.id = child.id || randomId();
            }
            if (id && (!child.umlIndex || child.umlIndex === -1)) {
                var childNode = this.nameTable["" + id];
                childNode.parentId = '';
                if (parentNode.container && parentNode.container.type === 'Stack') {
                    this.updateStackProperty(parentNode, childNode);
                }
                for (var i = 0; i < parentNode.children.length; i++) {
                    if (parentNode.children[parseInt(i.toString(), 10)] === id) {
                        parentNode.children.splice(i, 1);
                        for (var j = 0; j < parentNode.wrapper.children.length; j++) {
                            if (parentNode.wrapper.children[parseInt(j.toString(), 10)] === childNode.wrapper) {
                                parentNode.wrapper.children.splice(j, 1);
                            }
                        }
                    }
                }
                parentNode.wrapper.measure(new Size());
                parentNode.wrapper.arrange(parentNode.wrapper.desiredSize);
                if (!parentNode.isLane) {
                    this.nameTable[node.id].width = parentNode.wrapper.actualSize.width;
                    this.nameTable[node.id].height = parentNode.wrapper.actualSize.height;
                    this.nameTable[node.id].offsetX = parentNode.wrapper.offsetX;
                    this.nameTable[node.id].offsetY = parentNode.wrapper.offsetY;
                }
                if (!parentNode.parentId ||
                    (this.nameTable[parentNode.parentId] &&
                        this.nameTable[parentNode.parentId].shape.type !== 'SwimLane')) {
                    this.updateDiagramObject(parentNode);
                }
            }
        }
        return id;
    };
    /**
     * Clears all nodes and objects in the diagram, effectively resetting the diagram to an empty state.
     *
     * @returns { void }     Clears all nodes and objects in the diagram, effectively resetting the diagram to an empty state.\
     * @deprecated
     */
    Diagram.prototype.clear = function () {
        this.clearObjects();
        this.clearLayers();
    };
    //Bug 872106: Layer object in diagram doesnot removed in clear method
    Diagram.prototype.clearLayers = function () {
        var layerCount = this.layers.length;
        for (var i = layerCount - 1; i >= 0; i--) {
            this.removeLayer(this.layers[parseInt(i.toString(), 10)].id);
        }
        //Create default layer
        var defaultLayer = {
            id: 'default_layer', visible: true, lock: false, objects: [], zIndex: 0,
            objectZIndex: -1, zIndexTable: {}
        };
        this.commandHandler.addLayer(defaultLayer, null, true);
        this.setActiveLayer(this.layers[this.layers.length - 1].id);
    };
    Diagram.prototype.clearObjects = function (collection) {
        var objects = [];
        if (!collection) {
            objects = objects.concat(this.nodes);
            objects = objects.concat(this.connectors);
        }
        else {
            objects = collection;
        }
        this.diagramActions = this.diagramActions | DiagramAction.Clear;
        // Removed isBlazor code
        for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {
            var obj = objects_1[_i];
            if (this.nameTable[obj.id]) {
                this.remove(obj);
            }
        }
        this.diagramActions = this.diagramActions & ~DiagramAction.Clear;
        this.spatialSearch = new SpatialSearch(this.nameTable);
        this.initHistory();
    };
    Diagram.prototype.startEditCommad = function () {
        var laneHeader;
        var node = (this.selectedItems.nodes[0]) ? this.selectedItems.nodes[0] : undefined;
        if (node && node instanceof Node) {
            if (node.isLane && node.parentId) {
                var swimlane = this.nameTable[node.parentId];
                var lanes = swimlane.shape.lanes;
                var canvasId = (node.id.slice(swimlane.id.length));
                var currentParentId = canvasId.substring(0, canvasId.length - 1);
                for (var i = 0; i < lanes.length; i++) {
                    if (node.isLane && currentParentId === lanes[parseInt(i.toString(), 10)].id) {
                        laneHeader = this.nameTable[lanes[parseInt(i.toString(), 10)].header.id];
                    }
                }
            }
            else if (node.shape.type === 'SwimLane' && node.shape.header && node.shape.hasHeader) {
                var id = node.wrapper.children[0].rows[0].cells[0].children[0].id;
                laneHeader = this.nameTable["" + id];
            }
        }
        this.startTextEdit(laneHeader);
    };
    /* tslint:disable */
    /**
     * Initiate the editing mode for a specific annotation within a node or connector.
     *
     * @returns { void }  Initiate the editing mode for a specific annotation within a node or connector. \
     * @param {NodeModel | ConnectorModel} node - The node or connector containing the annotation to be edited.
     * @param {string} id - The ID of the annotation to be edited within the node or connector.
     */
    Diagram.prototype.startTextEdit = function (node, id) {
        if ((!canZoomPan(this) && !canMultiSelect(this)) || canSingleSelect(this)) {
            this.textEditing = true;
            var transform = this.scroller.transform;
            var scale = canZoomTextEdit(this) ? transform.scale : 1;
            var minWidth = 90;
            var text = void 0;
            var bounds = void 0;
            var attributes = void 0;
            var x = void 0;
            var y = void 0;
            var textWrapper = void 0;
            if (!node) {
                node = (this.selectedItems.nodes[0]) ? this.selectedItems.nodes[0] : this.selectedItems.connectors[0];
            }
            if (node) {
                //Removed isBlazor code
                //893031: Exception throws while double click on UML Classifier connector
                //Added the condition that the node is not an instance of a connector
                if (node.shape && node.shape.type === 'UmlClassifier' && !(node instanceof Connector)) {
                    node = this.nameTable[node.children[0]];
                }
                var bpmnAnnotation = false;
                if (!textWrapper) {
                    if (node.shape.type !== 'Text' && node.annotations.length === 0) {
                        if (!(node.constraints & NodeConstraints.ReadOnly)) {
                            this.activeLabel.isGroup = true;
                            this.startGroupAction();
                            this.addLabels(node, [{ id: randomId(), content: '' }]);
                        }
                    }
                    if (!id && ((node.shape.type !== 'Text' && node.annotations.length > 0) || (node.shape.type === 'Text'))) {
                        //(EJ2-840331)-Double click on node annotation will open the edit of invisible annotation
                        if (node.shape.type === 'Text') {
                            id = (node.wrapper.children[0].id).split('_')[1];
                        }
                        else {
                            for (var i = node.annotations.length - 1; i >= 0; i--) {
                                if (node.annotations[parseInt(i.toString(), 10)].visibility) {
                                    id = node.annotations[parseInt(i.toString(), 10)].id;
                                }
                            }
                        }
                    }
                    if (id) {
                        textWrapper = this.getWrapper(node.wrapper, id);
                    }
                }
                else {
                    bpmnAnnotation = true;
                }
                if (node && textWrapper && !(textWrapper instanceof DiagramHtmlElement) &&
                    (!enableReadOnly(textWrapper, node) || bpmnAnnotation)) {
                    var style = (textWrapper.style);
                    var maxWidth = void 0;
                    maxWidth = textWrapper.bounds.width < node.wrapper.bounds.width ? textWrapper.bounds.width : node.wrapper.bounds.width;
                    maxWidth = minWidth > maxWidth ? minWidth : maxWidth;
                    var textEditing = document.getElementById(this.element.id + '_editTextBoxDiv');
                    var textArea = document.getElementById(this.element.id + '_editBox');
                    text = textArea ? textArea.value : textWrapper.content;
                    this.activeLabel.text = text;
                    if (!textEditing && !textArea) {
                        textEditing = createHtmlElement('div', {});
                        textArea = createHtmlElement('textarea', {});
                        this.diagramCanvas.appendChild(textEditing);
                        textEditing.appendChild(textArea);
                        textArea.appendChild(document.createTextNode(text));
                    }
                    bounds = measureHtmlText(textWrapper.style, text, undefined, undefined, maxWidth);
                    if (bounds.isEmpty()) {
                        if (node.shape.type !== 'Text') {
                            bounds = new Size(findAnnotation(node, (textWrapper.id).split(node.id + '_')[1]).width || 50, textWrapper.style.fontSize);
                        }
                        else {
                            bounds = new Size((node.width > 50) ? 50 : node.width, textWrapper.style.fontSize);
                        }
                    }
                    if (node.parentId && this.nameTable[node.parentId].shape.type === 'UmlClassifier') {
                        bounds.width = node.wrapper.bounds.width - 20;
                        x = ((((node.wrapper.bounds.center.x + transform.tx) * transform.scale) - (bounds.width / 2) * scale) - 2.5);
                        y = ((((node.wrapper.bounds.center.y + transform.ty) * transform.scale) - (bounds.height / 2) * scale) - 3);
                        textWrapper.style.textAlign = 'Left';
                    }
                    else {
                        bounds.width = Math.max(bounds.width, 50);
                        x = ((((textWrapper.bounds.center.x + transform.tx) * transform.scale) - (bounds.width / 2) * scale) - 2.5);
                        y = ((((textWrapper.bounds.center.y + transform.ty) * transform.scale) - (bounds.height / 2) * scale) - 3);
                    }
                    attributes = {
                        'id': this.element.id + '_editTextBoxDiv', 'style': 'position: absolute' + ';left:' + x + 'px;top:' +
                            y + 'px;width:' + ((bounds.width + 1) * scale) + 'px;height:' + (bounds.height * scale) +
                            'px; containerName:' + node.id + ';'
                    };
                    setAttributeHtml(textEditing, attributes);
                    //879137 - aria-label missing in annotation textEdit mode.
                    attributes = {
                        'aria-label': text, 'id': this.element.id + '_editBox', 'style': 'width:' + ((bounds.width + 1) * scale) +
                            'px;height:' + (bounds.height * scale) + 'px;resize: none;outline: none;overflow: hidden;' +
                            ';font-family:' + style.fontFamily +
                            ';font-size:' + (style.fontSize * scale) + 'px;text-align:' +
                            (textWrapper.style.textAlign.toLocaleLowerCase()) + ';', 'class': 'e-diagram-text-edit'
                    };
                    setAttributeHtml(textArea, attributes);
                    textArea.style.fontWeight = (style.bold) ? 'bold' : '';
                    textArea.style.fontStyle = (style.italic) ? 'italic' : '';
                    textArea.style.lineHeight = (style.fontSize * 1.2 + 'px;').toString();
                    textArea.style.textDecoration = (style.textDecoration) ? style.textDecoration : '';
                    this.activeLabel.parentId = node.id;
                    this.activeLabel.id = id;
                    textWrapper.visible = false;
                    this.updateDiagramObject(node);
                    this.diagramActions = this.diagramActions | DiagramAction.TextEdit;
                    if (!this.isTriggerEvent) {
                        EventHandler.add(textArea, 'input', this.eventHandler.inputChange, this.eventHandler);
                        EventHandler.add(textArea, 'focusout', this.focusOutEdit, this);
                        textArea.select();
                    }
                }
            }
        }
    };
    Diagram.prototype.updateConnectorfixedUserHandles = function (connector) {
        if (connector.fixedUserHandles.length) {
            var fixedUserHandleWrapper = void 0;
            for (var _i = 0, _a = connector.fixedUserHandles; _i < _a.length; _i++) {
                var fixedUserHandle = _a[_i];
                fixedUserHandleWrapper = this.getWrapper(connector.wrapper, fixedUserHandle.id);
                connector.updateAnnotation(fixedUserHandle, connector.intermediatePoints, connector.wrapper.bounds, fixedUserHandleWrapper);
            }
        }
        connector.wrapper.measure(new Size(connector.wrapper.width, connector.wrapper.height));
        connector.wrapper.arrange(connector.wrapper.desiredSize);
    };
    /* tslint:enable */
    Diagram.prototype.updateNodeExpand = function (node, visibility) {
        for (var i = 0; i < node.outEdges.length; i++) {
            var connector = this.nameTable[node.outEdges[parseInt(i.toString(), 10)]];
            var target = this.nameTable[connector.targetID];
            connector.visible = visibility;
            if (target) {
                if (!visibility) {
                    this.updateElementVisibility(connector.wrapper, connector, false);
                    target.isExpanded = visibility;
                }
                this.updateNodeExpand(target, target.isExpanded);
                target.visible = visibility;
                if (!visibility) {
                    this.updateElementVisibility(target.wrapper, target, false);
                }
            }
        }
    };
    Diagram.prototype.updateConnectorAnnotation = function (connector) {
        if (connector.annotations.length) {
            var annotationWrapper = void 0;
            for (var _i = 0, _a = connector.annotations; _i < _a.length; _i++) {
                var annotation = _a[_i];
                annotationWrapper = this.getWrapper(connector.wrapper, annotation.id);
                connector.updateAnnotation(annotation, connector.intermediatePoints, connector.wrapper.bounds, annotationWrapper, (this.diagramActions & DiagramAction.Interactions));
            }
        }
        connector.wrapper.measure(new Size(connector.wrapper.width, connector.wrapper.height));
        connector.wrapper.arrange(connector.wrapper.desiredSize);
    };
    Diagram.prototype.removeChildrenFromLayout = function (nodes) {
        var nodesCollection = [];
        var node;
        var parentId = 'parentId';
        var processId = 'processId';
        for (var i = 0; i < nodes.length; i++) {
            node = nodes[parseInt(i.toString(), 10)];
            if (!node["" + parentId] && !node["" + processId]) {
                nodesCollection.push(node);
            }
        }
        return nodesCollection;
    };
    /* tslint:disable */
    /**
     * Automatically updates the diagram objects based on the type of the layout.
     * @returns { ILayout | boolean }  Automatically updates the diagram objects based on the type of the layout.\
     */
    Diagram.prototype.doLayout = function () {
        var update = false;
        var layout;
        var canDoOverlap = (this.layout.type === 'ComplexHierarchicalTree' || this.layout.type === 'HierarchicalTree');
        var propChange = this.isProtectedOnChange;
        this.protectPropertyChange(true);
        var nodes = this.removeChildrenFromLayout(this.nodes);
        var canEnableRouting = this.layout.enableRouting && this.layout.type === 'ComplexHierarchicalTree';
        var viewPort = { x: this.scroller.viewPortWidth, y: this.scroller.viewPortHeight };
        if (this.layout.type !== 'None') {
            if (this.organizationalChartModule || this.mindMapChartModule || this.radialTreeModule || this.symmetricalLayoutModule
                || this.complexHierarchicalTreeModule || this.flowchartLayoutModule) {
                // Trigger the layoutUpdated event with the state set to 'Started' and the current layout type.
                var args = { state: 'Started', type: this.layout.type };
                this.triggerEvent(DiagramEvent.layoutUpdated, args);
            }
            //Bug 862601: Connectors are not rendered properly with lineRouting and lineDistribution enables during doLayout process.
            //Removed initLineDistribution method call here and added it below after the complex hierarchical tree doLayout process.
            if (this.organizationalChartModule) {
                layout = this.organizationalChartModule.updateLayout(nodes, this.nameTable, this.layout, viewPort, this.dataSourceSettings.id, this.diagramActions);
                update = true;
                if (this.canDistribute(canEnableRouting, canDoOverlap)) {
                    this.lineDistributionModule.initLineDistribution(this.layout, this);
                }
                if (this.layoutAnimateModule && layout.rootNode && !this.diagramActions) {
                    this.updateNodeExpand(layout.rootNode, layout.rootNode.isExpanded);
                }
                // EJ2-58221 - added to render the layout properly based on parent node isExpanded property.
                else if (!this.layoutAnimateModule && layout.rootNode && !layout.rootNode.isExpanded && !this.canExpand) {
                    this.updateNodeExpand(layout.rootNode, layout.rootNode.isExpanded);
                }
            }
            else if (this.mindMapChartModule) {
                if (nodes && nodes.length > 0) {
                    this.mindMapChartModule.updateLayout(nodes, this.nameTable, this.layout, viewPort, this.dataSourceSettings.id, this.dataSourceSettings.root);
                }
                update = true;
            }
            else if (this.radialTreeModule) {
                this.radialTreeModule.updateLayout(nodes, this.nameTable, this.layout, viewPort);
                update = true;
            }
            else if (this.symmetricalLayoutModule) {
                this.symmetricalLayoutModule.maxIteration = this.layout.maxIteration;
                this.symmetricalLayoutModule.springLength = this.layout.springLength;
                this.symmetricalLayoutModule.springFactor = this.layout.springFactor;
                this.symmetricalLayoutModule.updateLayout(nodes, this.connectors, this.symmetricalLayoutModule, this.nameTable, this.layout, viewPort);
                update = true;
            }
            else if (this.complexHierarchicalTreeModule) {
                //Bug 862601: Connectors are not rendered properly with lineRouting and lineDistribution enables during doLayout process.
                //As the initLineDistribution method call removed from above and added below doLayout, we need to set diagram value and clear obstacle collection
                // of connectors.
                if (this.canDistribute(canEnableRouting, canDoOverlap)) {
                    this.lineDistributionModule.diagram = this;
                    var obstacleCollection_1 = 'obstaclePointCollection';
                    this.connectors.forEach(function (connector) {
                        connector["" + obstacleCollection_1] = [];
                    });
                }
                var nodes_1 = this.complexHierarchicalTreeModule.getLayoutNodesCollection(this.nodes);
                if (nodes_1.length > 0) {
                    // eslint-disable-next-line max-len
                    this.complexHierarchicalTreeModule.doLayout(nodes_1, this.nameTable, this.layout, viewPort, this);
                }
                update = true;
                //initLineDistribution method call after doLayout.
                if (this.canDistribute(canEnableRouting, canDoOverlap)) {
                    this.lineDistributionModule.initLineDistribution(this.layout, this);
                }
            }
            else if (this.flowchartLayoutModule) {
                this.flowchartLayoutModule.updateLayout(this.nodes, this);
                update = true;
            }
            else {
                var moduleName = this.layout.type === 'OrganizationalChart' ? 'HierarchicalTree' : this.layout.type;
                console.warn('[WARNING] :: Module ' + moduleName + ' is not available in Diagram component! You either misspelled the module name or forgot to load it.');
            }
            if (update) {
                this.preventDiagramUpdate = true;
                var connectors = {};
                var updatedNodes = nodes;
                // BLAZ-22230 - Added condition to check if canUpdateTemplate is false means then we can update the template for blazor
                //Removed isBlazor code
                for (var _i = 0, updatedNodes_1 = updatedNodes; _i < updatedNodes_1.length; _i++) {
                    var obj = updatedNodes_1[_i];
                    var node = obj;
                    if (!this.preventNodesUpdate && (!this.diagramActions || !(this.diagramActions & DiagramAction.PreventIconsUpdate))) {
                        this.updateIcon(node);
                        this.updateDefaultLayoutIcons(node);
                    }
                    this.preventNodesUpdate = true;
                    this.nodePropertyChange(node, {}, { offsetX: node.offsetX, offsetY: node.offsetY }, true);
                    this.preventNodesUpdate = false;
                    node.wrapper.measure(new Size(node.wrapper.width, node.wrapper.height));
                    node.wrapper.arrange(node.wrapper.desiredSize);
                    this.updateDiagramObject(node, true);
                    if (node.inEdges.length > 0) {
                        for (var j = 0; j < node.inEdges.length; j++) {
                            var connector = this.nameTable[node.inEdges[parseInt(j.toString(), 10)]];
                            connectors[connector.id] = connector;
                        }
                    }
                    if (node.outEdges.length > 0) {
                        for (var k = 0; k < node.outEdges.length; k++) {
                            var connection = this.nameTable[node.outEdges[parseInt(k.toString(), 10)]];
                            connectors[connection.id] = connection;
                        }
                    }
                }
                for (var _a = 0, _b = Object.keys(connectors); _a < _b.length; _a++) {
                    var conn = _b[_a];
                    if (canEnableRouting) {
                        this.lineDistributionModule.resetConnectorSegments(this.nameTable["" + conn]);
                    }
                    var connector = connectors["" + conn];
                    var points = this.getPoints(connector);
                    if (canEnableRouting) {
                        this.lineDistributionModule.resetRoutingSegments(connector, this, points);
                    }
                    updateConnector(connector, points);
                    if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default' && connector.shape.flow === 'Sequence') {
                        this.commandHandler.updatePathElementOffset(connector);
                    }
                    connector.wrapper.measure(new Size(undefined, undefined));
                    connector.wrapper.arrange(connector.wrapper.desiredSize);
                    this.updateConnectorAnnotation(connector);
                    this.updateConnectorfixedUserHandles(connector);
                    this.updateQuad(connector);
                    this.updateDiagramObject(connector, true);
                }
                if (canEnableRouting || this.layout.connectionPointOrigin === 'DifferentPoint' && this.lineDistributionModule && canDoOverlap) {
                    this.lineDistributionModule.distributeLines(this.layout, this);
                }
                this.refreshFlowChartConnectors();
                this.preventDiagramUpdate = false;
                this.updatePage();
                if ((!(this.diagramActions & DiagramAction.Render)) || this.mode === 'Canvas') {
                    this.refreshDiagramLayer();
                    this.isRefreshed = true;
                }
            }
            if (!propChange) {
                this.protectPropertyChange(propChange);
            }
        }
        if (update) {
            this.updateDiagramElementQuad();
        }
        if ((this.diagramActions & DiagramAction.Render) && this.layout.enableRouting) {
            this.refreshRoutingConnectors();
        }
        if (update) {
            // Trigger the layoutUpdated event with the state set to 'Completed' and the current layout type.
            var args = { state: 'Completed', type: this.layout.type };
            this.triggerEvent(DiagramEvent.layoutUpdated, args);
        }
        return ((this.blazorActions & BlazorAction.expandNode) ? layout : true);
    };
    //Bug 877799: Optimize the routing segment distance while using enableRouting in layout.
    //Stored the routingConnectors in resetRoutingSegments method and then Refresh the routing connectors after layout completion.
    Diagram.prototype.refreshRoutingConnectors = function () {
        this.isProtectedOnChange = true;
        if (this.routingConnectors) {
            for (var i = 0; i < this.routingConnectors.length; i++) {
                var connector = this.routingConnectors[parseInt(i.toString(), 10)];
                var sourceNode = this.nameTable[connector.sourceID];
                var targetNode = this.nameTable[connector.targetID];
                var lineRouting = new LineRouting();
                if (sourceNode.visible && targetNode.visible) {
                    lineRouting.renderVirtualRegion(this, true);
                    lineRouting.refreshConnectorSegments(this, connector, false, true);
                    var points = this.getPoints(connector);
                    updateConnector(connector, points);
                    connector.wrapper.measure(new Size(undefined, undefined));
                    connector.wrapper.arrange(connector.wrapper.desiredSize);
                    this.updateDiagramObject(connector, true);
                    this.routingConnectors.splice(i, 1);
                    i--;
                }
            }
        }
        this.isProtectedOnChange = false;
    };
    //To update new connector points in flowchart layout
    Diagram.prototype.refreshFlowChartConnectors = function () {
        if (this.flowchartLayoutModule) {
            this.flowchartLayoutModule.reRouteFlowChartConnectors(this.layout.flowChartData, this);
            for (var i = 0; i < this.connectors.length; i++) {
                var connector = this.connectors[parseInt(i.toString(), 10)];
                var points = this.getPoints(connector);
                updateConnector(connector, points);
                connector.wrapper.measure(new Size(undefined, undefined));
                connector.wrapper.arrange(connector.wrapper.desiredSize);
                this.updateConnectorAnnotation(connector);
                this.updateConnectorfixedUserHandles(connector);
                this.updateQuad(connector);
                this.updateDiagramObject(connector, true);
            }
        }
    };
    //Checks if line distribution is enabled.
    Diagram.prototype.canDistribute = function (canEnableRouting, canDoOverlap) {
        if ((canEnableRouting && this.lineDistributionModule) || (this.layout.connectionPointOrigin === 'DifferentPoint' && this.lineDistributionModule && canDoOverlap) || (this.layout.arrangement === 'Linear' && this.lineDistributionModule)) {
            return true;
        }
        else {
            if ((canEnableRouting) || (this.layout.connectionPointOrigin === 'DifferentPoint' && canDoOverlap) || (this.layout.arrangement === 'Linear')) {
                console.warn('[WARNING] :: Module "LineDistribution" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
            }
            return false;
        }
    };
    /* tslint:enable */
    /**
     * Serializes the diagram control as a string.
     * @returns { string }     Serializes the diagram control as a string. \
     */
    Diagram.prototype.saveDiagram = function () {
        var children = [];
        var node;
        var grid;
        var childTable;
        var child;
        var gridChild = 'childTable';
        for (var i = 0; i < this.nodes.length; i++) {
            node = this.nodes[parseInt(i.toString(), 10)];
            if (node.shape.type === 'SwimLane') {
                grid = node.wrapper.children[0];
                childTable = grid["" + gridChild];
                for (var _i = 0, _a = Object.keys(childTable); _i < _a.length; _i++) {
                    var key = _a[_i];
                    child = childTable["" + key];
                    children = getChild(child, children);
                }
                for (var i_1 = 0; i_1 < children.length; i_1++) {
                    if (this.nameTable[children[parseInt(i_1.toString(), 10)]]) {
                        this.swimlaneChildTable[children[parseInt(i_1.toString(), 10)]]
                            = this.nameTable[children[parseInt(i_1.toString(), 10)]].zIndex;
                    }
                }
                this.swimlaneZIndexTable[node.id] = node.zIndex;
            }
        }
        return serialize(this);
    };
    /**
     * Converts the given string into a Diagram Control.
     *
     * @returns { Object } Converts the given string into a Diagram Control. \
     * @param {string} data - The string representing the diagram model JSON to be loaded.
     * @param {boolean} isEJ1Data - A boolean indicating whether the JSON data is EJ1 data.
     */
    Diagram.prototype.loadDiagram = function (data, isEJ1Data) {
        if (isEJ1Data && this.ej1SerializationModule) {
            var ejDiagram = JSON.parse(data);
            data = this.ej1SerializationModule.getSerializedData(ejDiagram);
        }
        else if (isEJ1Data) {
            console.warn('[WARNING] :: Module "Ej1Serialization" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
        }
        return deserialize(data, this);
    };
    /**
     * Exports the current diagram to a string in Mermaid format.
     * This method converts the current state of the diagram into Mermaid syntax, allowing it to be saved or shared.
     * @returns {string} - A string containing the Mermaid text representation of the current diagram.
     */
    Diagram.prototype.saveDiagramAsMermaid = function () {
        var mermaidData = '';
        if (this.layout && this.layout.type === 'Flowchart') {
            mermaidData = this.saveFlowDiagramInMermaidFormat();
        }
        else {
            mermaidData = this.saveMindmapDiagramInMermaidFormat();
        }
        return mermaidData;
    };
    /**
     * Converts the diagram to Mermaid format and saves it.
     * If the diagram has a 'MindMap' layout, it will generate a Mermaid mind map.
     * @returns {string} - The Mermaid formatted string representing the diagram.
     */
    Diagram.prototype.saveMindmapDiagramInMermaidFormat = function () {
        var mermaidData = '';
        var dataSourceCollection = [];
        if (this.layout && this.layout.type === 'MindMap') {
            dataSourceCollection.push('mindmap');
            if (this.nodes.length > 0) {
                var rootNode = this.nodes.filter(function (node) { return node.inEdges.length === 0; })[0];
                var content = this.convertMindmapToMermaid(rootNode, 0);
                dataSourceCollection.push(content);
                var outConnectors = rootNode.outEdges;
                this.updateTextDataSource(dataSourceCollection, outConnectors, 1);
                dataSourceCollection = dataSourceCollection.filter(function (data) { return data.trim() !== ''; });
                mermaidData = dataSourceCollection.join('\n');
            }
        }
        return mermaidData;
    };
    /**
     * Creates a text data source for sub-level children in a Mermaid diagram.
     * @param {string[]} dataSource - The data source to be updated.
     * @param {string[]} outEdges - The out edges of the current node.
     * @param {number} level - The level of the current node.
     * @returns {void} - Creates a text data source for sub-level children in a Mermaid diagram.
     */
    Diagram.prototype.updateTextDataSource = function (dataSource, outEdges, level) {
        var count = 0;
        while (count < outEdges.length) {
            var connector = this.getObject(outEdges[parseInt(count.toString(), 10)]);
            var targetNode = this.getObject(connector.targetID);
            var content = this.convertMindmapToMermaid(targetNode, level);
            dataSource.push(content);
            var childOutConnectors = targetNode.outEdges;
            if (childOutConnectors.length > 0) {
                this.updateTextDataSource(dataSource, childOutConnectors, level + 1);
            }
            count++;
        }
    };
    /**
     * Returns the text data source for the specified node in Mermaid format.
     * @param {NodeModel} node - The node for which the Mermaid data is to be generated.
     * @param {number} level - The level of the node in the diagram.
     * @returns {string} - The text data source for the specified node in Mermaid format.
     */
    Diagram.prototype.convertMindmapToMermaid = function (node, level) {
        var nodeId = node.id;
        var spaceCount = (level + 1) * 2;
        var spaces = ' '.repeat(spaceCount);
        var annotationContent = node.annotations.length > 0
            ? node.annotations[0].content.replace(/\n/g, ' ')
            : '';
        var content = spaces + annotationContent;
        var spaceWithNodeId = spaces + nodeId;
        if (node.shape && node.shape.type === 'Basic') {
            var basicShape = node.shape;
            if (basicShape.shape === 'Rectangle') {
                content = spaceWithNodeId + '[' + annotationContent + ']';
            }
            else if (basicShape.shape === 'Ellipse') {
                content = spaceWithNodeId + '((' + annotationContent + '))';
            }
            else if (basicShape.shape === 'Hexagon') {
                content = spaceWithNodeId + '{{' + annotationContent + '}}';
            }
        }
        else if (node.shape && node.shape.type === 'Flow') {
            var flowShape = node.shape;
            if (flowShape.shape === 'Terminator') {
                content = spaceWithNodeId + '(' + annotationContent + ')';
            }
        }
        else if (node.shape && node.shape.type === 'Path') {
            var pathShape = node.shape;
            if (pathShape.data === this.bangShape) {
                content = spaceWithNodeId + '))' + annotationContent + '((';
            }
            else if (pathShape.data === this.cloudShape) {
                content = spaceWithNodeId + ')' + annotationContent + '(';
            }
        }
        return content;
    };
    /**
     * Converts the flowchart diagram to Mermaid format.
     * @returns {string} - The exported flowchart diagram as Mermaid data.
     */
    Diagram.prototype.saveFlowDiagramInMermaidFormat = function () {
        var _this = this;
        var existingIds = [];
        var mermaidCode = 'graph TD\n';
        var graph = { nodes: this.nodes, edges: this.connectors };
        // Create a map of node labels for easy access
        // accumulator - The object that stores the node ID and label pairs.
        var nodeLabels = graph.nodes.reduce(function (accumulator, node) {
            accumulator[node.id] = node.annotations.length ? node.annotations[0].content : '';
            return accumulator;
        }, {});
        // Iterate through edges to create connections and node definitions
        graph.edges.forEach(function (edge) {
            var fromNodeId = edge.sourceID;
            var toNodeId = edge.targetID;
            var fromNodeLabel = nodeLabels["" + fromNodeId];
            var toNodeLabel = nodeLabels["" + toNodeId];
            var fromNode = _this.nameTable["" + fromNodeId];
            var toNode = _this.nameTable["" + toNodeId];
            var fromNodeShape = _this.getNodeShape(fromNode);
            var toNodeShape = _this.getNodeShape(toNode);
            var condition = (edge.annotations[0] && edge.annotations[0].content !== '') ? '|' + edge.annotations[0].content + '|' : '';
            if (existingIds.indexOf(fromNodeId) === -1) {
                existingIds.push(fromNodeId);
            }
            else {
                fromNodeShape = '';
            }
            if (existingIds.indexOf(toNodeId) === -1) {
                existingIds.push(toNodeId);
            }
            else {
                toNodeShape = '';
            }
            var arrow = _this.arrowType(edge);
            mermaidCode += "    " + fromNodeId + fromNodeShape + " " + arrow + condition + " " + toNodeId + toNodeShape + "\n";
        });
        // Add styles for each node
        graph.nodes.forEach(function (node) {
            var nodeId = node.id;
            var fill = node.style.fill;
            var stroke = node.style.strokeColor;
            var strokeWidth = node.style.strokeWidth + "px";
            mermaidCode += "    style " + nodeId + " fill:" + fill + ",stroke:" + stroke + ",stroke-width:" + strokeWidth + ";\n";
        });
        return mermaidCode;
    };
    // Method to get the arrow type from connector
    Diagram.prototype.arrowType = function (edge) {
        var decoratorShape = edge.targetDecorator.shape;
        var strokeDash = edge.style.strokeDashArray;
        var strokeWidth = edge.style.strokeWidth;
        var opacity = edge.style.opacity;
        var arrow = '';
        if (opacity < 1) {
            arrow = '~~~';
        }
        else if (strokeDash !== '') {
            arrow = '-.->';
        }
        else if (decoratorShape === 'Arrow') {
            arrow = strokeWidth > 1 ? '==>' : '-->';
        }
        else if (decoratorShape === 'None') {
            arrow = '---';
        }
        else {
            arrow = '-->';
        }
        return arrow;
    };
    // Method to get the node shape
    Diagram.prototype.getNodeShape = function (node) {
        var label = node.annotations.length > 0 ? node.annotations[0].content : '';
        var shape = node.shape.shape;
        if (shape) {
            switch (shape) {
                case 'Terminator':
                    return '([' + label + '])';
                case 'Process':
                    return '[' + label + ']';
                case 'Decision':
                    return '{' + label + '}';
                case 'Parallelogram':
                    return '[/' + label + '/]';
                case 'Ellipse':
                    return '((' + label + '))';
                case 'PreDefinedProcess':
                    return '[[' + label + ']]';
                default:
                    return '[' + label + ']';
            }
        }
        else {
            var data = node.shape.data;
            if (data === 'M 0 0 A 1 1 0 0 0 7 0 A 1 1 0 0 0 0 0 M -1 0 A 1 1 0 0 0 8 0 A 1 1 0 0 0 -1 0') {
                return '(((' + label + ')))';
            }
            else if (data === 'M 0 0 L 1 -1 L 5 -1 L 6 0 L 0 0') {
                return '[/' + label + '\\]';
            }
            else if (data === 'M 0 1 L 0 6 C 2 7 4 7 6 6 L 6 1 C 5 0 1 0 0 1 C 1 2 5 2 6 1') {
                return '[(' + label + ')]';
            }
            else if (data === 'M 0 0 L 12 0 L 14 2 L 2 2 L 0 0') {
                return '[\\' + label + '\\]';
            }
            else if (data === 'M 0 0 L 5 0 L 4 1 L 1 1 L 0 0') {
                return '[\\' + label + '/]';
            }
            else if (data === 'M 0 0 L 2 -2 L 11 -2 L 13 0 L 11 2 L 2 2 L 0 0') {
                return '{{' + label + '}}';
            }
            else {
                return '>' + label + ']';
            }
        }
    };
    /** Loads a diagram from a string containing Mermaid syntax.
     * This method parses the provided Mermaid text data and updates the current diagram accordingly.
     * Currently, only Mindmap and Flowchart diagrams can be loaded.
     * To render the diagram properly, you should set the `Layout.type` to either `MindMap` or `FlowChart`, and ensure that the respective modules are injected.
     * @param {string} data - The Mermaid text data representing the diagram to be loaded.
     * @returns {void} - No return value. The method updates the diagram in place.
     */
    Diagram.prototype.loadDiagramFromMermaid = function (data) {
        if (this.layout && this.layout.type === 'Flowchart' && this.flowchartLayoutModule) {
            //Task 896394: To load the mermaid data as flowchart
            this.convertMermaidToFlowChart(data);
        }
        else if (this.layout && this.layout.type === 'MindMap' && this.mindMapChartModule) {
            //Task 900266: To load the mermaid data as mindmap
            this.convertMermaidToMindmap(data);
        }
        else {
            console.warn('[WARNING] :: Module "FlowchartLayout" or "MindMap" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
        }
    };
    /**
     * Counts the number of leading spaces in the specified string.
     * @param {string} word The string to check for leading spaces.
     * @returns { number } The number of leading spaces.
     */
    Diagram.prototype.countLeadingSpaces = function (word) {
        var i = 0;
        var length = word.length;
        // Loop through the string to count leading spaces
        while (i < length && word.charAt(i) === ' ') {
            i++;
        }
        // Return the number of leading spaces
        return i;
    };
    Diagram.prototype.convertMermaidToMindmap = function (data) {
        if (data && this.layout && this.layout.type === 'MindMap' && this.mindMapChartModule) {
            var dataSource = data.split(/\r?\n/).filter(function (s) { return s.trim().length > 0; });
            this.clear();
            this.mermaidNodeBaseCollection = [];
            var dataStack = [];
            var previousItem = { text: '', children: [], currentLevel: 0, branch: 'Left' };
            var spaceAndItsLevels = [];
            var startLevel = 1;
            var haveBackticks = false;
            var isEndBackticks = false;
            var canCreateMindMap = false;
            if (dataSource.length > 0) {
                var _loop_1 = function (index) {
                    var word = dataSource[parseInt(index.toString(), 10)];
                    var level = 0;
                    var text = '';
                    var leadingWhiteSpace = this_1.countLeadingSpaces(word);
                    var isStartBackticks = word.includes('"`');
                    isEndBackticks = word.includes('`"');
                    haveBackticks = isStartBackticks ? true : haveBackticks;
                    canCreateMindMap = (!haveBackticks && !canCreateMindMap) ? leadingWhiteSpace === 0 && index > 0 : canCreateMindMap;
                    if (haveBackticks && isEndBackticks && !isStartBackticks) {
                        previousItem.text += '\n' + word;
                        haveBackticks = false;
                        return "continue";
                    }
                    if (!isStartBackticks && haveBackticks) {
                        previousItem.text += '\n' + word;
                        return "continue";
                    }
                    haveBackticks = isEndBackticks ? false : haveBackticks;
                    if (word.length > 0 && ((/\s/.test(word[0]) && index > 0) || (leadingWhiteSpace === 0))) {
                        var spaceIndex = spaceAndItsLevels.findIndex(function (space) {
                            return space.space === leadingWhiteSpace.toString();
                        });
                        if (spaceIndex !== -1) {
                            for (var i = spaceAndItsLevels.length - 1; i >= 0; i--) {
                                var currentSpace = spaceAndItsLevels[parseInt(i.toString(), 10)];
                                var currentKey = parseFloat(currentSpace.space);
                                if (currentKey > leadingWhiteSpace) {
                                    spaceAndItsLevels.splice(i, 1); // Remove the element at index i
                                }
                                else if (currentKey < leadingWhiteSpace) {
                                    spaceAndItsLevels.push({ space: leadingWhiteSpace.toString(), level: currentSpace.level + 1 });
                                    level = currentSpace.level + 1;
                                    break;
                                }
                                else if (currentKey === leadingWhiteSpace) {
                                    level = currentSpace.level;
                                    break;
                                }
                            }
                        }
                        else {
                            if (spaceAndItsLevels.length === 0) {
                                spaceAndItsLevels.push({ space: leadingWhiteSpace.toString(), level: startLevel });
                                level = startLevel;
                            }
                            else {
                                for (var i = spaceAndItsLevels.length - 1; i >= 0; i--) {
                                    var currentElement = spaceAndItsLevels[parseInt(i.toString(), 10)];
                                    var currentKey = parseFloat(currentElement.space);
                                    if (currentKey > leadingWhiteSpace) {
                                        spaceAndItsLevels.splice(i, 1); // Remove the element at index i
                                    }
                                    else {
                                        var lastElement = spaceAndItsLevels[spaceAndItsLevels.length - 1];
                                        spaceAndItsLevels.push({ space: leadingWhiteSpace.toString(), level: lastElement.level + 1 });
                                        break;
                                    }
                                }
                                level = spaceAndItsLevels[spaceAndItsLevels.length - 1].level;
                            }
                        }
                        text = word.trim().replace(/^[+-]/, '');
                    }
                    var currentItem = {
                        text: text,
                        branch: undefined,
                        children: [],
                        currentLevel: index === 0 ? 0 : level - 1
                    };
                    if (dataStack.length > 0) {
                        while (dataStack.length >= level) {
                            if (dataStack.length === 0) {
                                break;
                            }
                            dataStack.pop();
                        }
                        if (dataStack.length > 0) {
                            dataStack[dataStack.length - 1].children.push(currentItem);
                        }
                    }
                    dataStack.push(currentItem);
                    previousItem = currentItem;
                };
                var this_1 = this;
                for (var index = 0; index < dataSource.length; index++) {
                    _loop_1(index);
                }
                // Create dataSource
                var hierarchyDataSource = dataStack[0];
                if (hierarchyDataSource.text === 'mindmap' || canCreateMindMap) {
                    if (canCreateMindMap) {
                        var nodeDetails = this.getNodeDetails(hierarchyDataSource);
                        var nodeObj = {
                            id: nodeDetails.nodeId,
                            shape: nodeDetails.nodeShapeData,
                            annotations: [
                                { content: nodeDetails.annotationContent }
                            ]
                        };
                        this.mermaidNodeBaseCollection.push(nodeObj);
                        this.createDataSource(hierarchyDataSource.children, hierarchyDataSource, nodeObj.id);
                    }
                    else {
                        var hierarchyData = hierarchyDataSource.children[0];
                        var nodeData = this.getNodeDetails(hierarchyData);
                        var node = {
                            id: nodeData.nodeId,
                            shape: nodeData.nodeShapeData,
                            annotations: [
                                { content: nodeData.annotationContent }
                            ]
                        };
                        this.mermaidNodeBaseCollection.push(node);
                        this.createDataSource(hierarchyData.children, hierarchyData, node.id);
                    }
                    this.addElements(this.mermaidNodeBaseCollection);
                    this.doLayout();
                }
            }
        }
    };
    /**
     * Creates a data source for the Mermaid diagram based on the provided hierarchy data.
     * @param { HierarchyData[] } data The list of hierarchy data to process.
     * @param { HierarchyData } parent The parent hierarchy data.
     * @param { string } parentId The ID of the parent node.
     * @returns { void }
     */
    Diagram.prototype.createDataSource = function (data, parent, parentId) {
        var index = 0;
        while (index < data.length) {
            var child = data[parseInt(index.toString(), 10)];
            var nodeData = this.getNodeDetails(child);
            var node = {
                id: nodeData.nodeId,
                shape: nodeData.nodeShapeData,
                annotations: [
                    { content: nodeData.annotationContent }
                ]
            };
            var connector = {
                sourceID: parentId,
                targetID: node.id
            };
            this.mermaidNodeBaseCollection.push(node);
            this.mermaidNodeBaseCollection.push(connector);
            this.createDataSource(child.children, child, node.id);
            index++;
        }
    };
    /**
     * Retrieves the node details based on the provided hierarchy data for a mermaid diagram.
     * @param { HierarchyData } hierarchyData The hierarchy data.
     * @returns { NodeData } The node details.
     */
    Diagram.prototype.getNodeDetails = function (hierarchyData) {
        var pattern = /^(.*?)\s*([\\[\\(\\{][\s\S]*?[\]\\)\\}]|[)\\(][\s\S]*|[)\\{][\s\S]*|[)\\(][^{}()\\[\]]*$)/;
        var annotationContent = hierarchyData.text;
        var match = annotationContent.match(pattern);
        var nodeId = randomId();
        var annotationText = hierarchyData.text;
        var shape = { type: 'Basic', shape: 'Rectangle' };
        if (match) {
            nodeId = match[1] ? match[1] : nodeId;
            var content = match[2].trim().replace(/["`]/g, '');
            var firstCharacter = content.charAt(0);
            if (firstCharacter === '[') {
                annotationText = content.slice(1, -1);
            }
            else if (firstCharacter === '(') {
                if (content.startsWith('((')) {
                    annotationText = content.slice(2, -1);
                }
                else {
                    annotationText = content.slice(1, -1);
                }
                shape = content.startsWith('((') ?
                    { type: 'Basic', shape: 'Ellipse' } :
                    { type: 'Flow', shape: 'Terminator' };
            }
            else if (firstCharacter === ')') {
                if (content.startsWith('))')) {
                    annotationText = content.slice(2, -2);
                }
                else {
                    annotationText = content.slice(1, -1);
                }
                shape = content.startsWith('))') ?
                    { type: 'Path', data: this.bangShape } :
                    { type: 'Path', data: this.cloudShape };
            }
            else if (firstCharacter === '{') {
                annotationText = content.slice(2, -1);
                shape = { type: 'Basic', shape: 'Hexagon' };
            }
        }
        return {
            nodeId: nodeId,
            annotationContent: annotationText,
            nodeShapeData: shape
        };
    };
    /**
     * To convert the Mermaid data to flowchart diagram
     * @param {string} data - The Mermaid data to be converted to a flowchart diagram.
     * @returns {void}
     */
    Diagram.prototype.convertMermaidToFlowChart = function (data) {
        var dataCollection = [];
        this.clear();
        var lines = data.trim().split('\n');
        for (var i = 1; i < lines.length; i++) {
            var line = lines[parseInt(i.toString(), 10)];
            line = line.trim();
            if (line !== '') {
                if (line.startsWith('style')) {
                    this.parseStyle(line, dataCollection);
                }
                else {
                    var lineSplit = this.getLineSplitting(line);
                    var parts = [lineSplit[0], lineSplit[1]];
                    var data_1 = this.getNodeData(parts, dataCollection, lineSplit[2]);
                    if (data_1.length > 0) {
                        var lastItem = data_1[data_1.length - 1];
                        lastItem.arrowType = lineSplit[2];
                        if (lineSplit[3] !== '') {
                            if (lastItem.label && lastItem.label.some(function (str) { return str.trim().length > 0; })) {
                                lastItem.label.push(lineSplit[3]);
                            }
                            else {
                                lastItem.label = [];
                                lastItem.label[lastItem.parentId.length - 1] = lineSplit[3];
                            }
                        }
                    }
                    data_1.filter(function (flowData) {
                        return flowData.parentId && flowData.parentId.length === 0;
                    }).forEach(function (node) {
                        node.parentId = null;
                    });
                    dataCollection = dataCollection.concat(data_1);
                }
            }
        }
        this.createFlowChart(dataCollection);
        this.doLayout();
        this.clearHistory();
    };
    /**
     * To convert the dataCollection into flowchart nodes and connectors
     * @param { FlowChartData[] } dataCollection - The data collection to be converted to flowchart nodes and connectors.
     * @returns {void}
     */
    Diagram.prototype.createFlowChart = function (dataCollection) {
        var flowchartNodesAndConnectors = [];
        for (var n = 0; n < dataCollection.length; n++) {
            var data = dataCollection[parseInt(n.toString(), 10)];
            var node = {
                id: data.id,
                shape: data.shape,
                annotations: [{ content: data.name }],
                style: { fill: data.color, strokeColor: data.stroke, strokeWidth: data.strokeWidth }
            };
            flowchartNodesAndConnectors.push(node);
        }
        for (var c = 0; c < dataCollection.length; c++) {
            var data = dataCollection[parseInt(c.toString(), 10)];
            var connectorStyle = getConnectorArrowType(data);
            if (data.parentId && data.parentId.length > 1) {
                for (var i = 0; i < data.parentId.length; i++) {
                    var connector = {
                        id: randomId(),
                        sourceID: data.parentId[parseInt(i.toString(), 10)],
                        targetID: data.id,
                        annotations: [{ content: data.label ? data.label[parseInt(i.toString(), 10)] : '' }],
                        style: {
                            strokeWidth: connectorStyle.strokeWidth ? connectorStyle.strokeWidth : 1,
                            strokeDashArray: connectorStyle.strokeDashArray ? connectorStyle.strokeDashArray : '',
                            opacity: connectorStyle.opacity !== undefined ? connectorStyle.opacity : 1
                        },
                        targetDecorator: { shape: connectorStyle.targetDecorator }
                    };
                    flowchartNodesAndConnectors.push(connector);
                }
            }
            else if (data.parentId && data.parentId.length === 1) {
                var connector = {
                    id: randomId(),
                    sourceID: data.parentId[0],
                    targetID: data.id,
                    annotations: [{ content: data.label ? data.label[0] : '' }],
                    style: {
                        strokeWidth: connectorStyle.strokeWidth ? connectorStyle.strokeWidth : 1,
                        strokeDashArray: connectorStyle.strokeDashArray ? connectorStyle.strokeDashArray : '',
                        opacity: connectorStyle.opacity !== undefined ? connectorStyle.opacity : 1
                    },
                    targetDecorator: { shape: connectorStyle.targetDecorator }
                };
                flowchartNodesAndConnectors.push(connector);
            }
        }
        this.addElements(flowchartNodesAndConnectors);
    };
    /**
     * Splits the line based on arrow
     * @param { string } line - line to split
     * @returns { string[] } - Splitted line
     */
    Diagram.prototype.getLineSplitting = function (line) {
        var leftPart;
        var rightPart;
        var arrowName;
        var arrowText = '';
        // RegEx to split the line based on arrow
        var regex = /^(.*?)\s*(-->|---|--\s*.*?\s*-->|~~~|==>|===|==\s*.*?\s*==>|\s*-\.\s*->|\s*-\.\s*-|\s*-\.\s*.*?\s*\.\s*->|\s*-\..*?\.\s*->)(.*)$/;
        var match = line.match(regex);
        if (match) {
            leftPart = match[1].trim();
            var arrow = match[2].trim();
            rightPart = match[3].trim();
            // Detect and extract arrow text
            var arrowRegex = /(-\.|\\-\\-|==|--|~~)(.*?)(\1>|\.->|==>|\\->|~~>)/;
            var arrowTextMatch = arrow.match(arrowRegex);
            var arrowDetails = void 0;
            var arrowType = '';
            if (arrowTextMatch) {
                var text = arrowTextMatch[2].trim() || null;
                var arrowType_1 = arrowTextMatch[1] + arrowTextMatch[3];
                arrowDetails = {
                    text: text,
                    arrowType: arrowType_1
                };
            }
            else {
                arrowDetails = {
                    text: null,
                    arrowType: arrow
                };
            }
            arrowText = arrowDetails.text !== null ? arrowDetails.text : '';
            arrowType = arrowDetails.arrowType;
            // Identify arrow type
            if (arrowType.includes('-->')) {
                arrowName = 'single-line-arrow';
            }
            else if (arrowType.includes('---')) {
                arrowName = 'single-line';
            }
            else if (arrowType.includes('==>')) {
                arrowName = 'double-line-arrow';
            }
            else if (arrowType.includes('==')) {
                arrowName = 'double-line';
            }
            else if (arrowType.includes('~~~')) {
                arrowName = 'wiggly-arrow';
            }
            else if (arrowType.includes('-.->') || arrowType.includes('.->')) {
                arrowName = 'dotted-arrow';
            }
            else if (arrowType.includes('-.-') || arrowType.includes('.-')) {
                arrowName = 'dotted';
            }
            else {
                arrowName = 'single-line-arrow';
            }
        }
        return [leftPart, rightPart, arrowName, arrowText];
    };
    /**
     * To parse the style of the node
     * @param { string } line - line to parse
     * @param { FlowChartData[] } dataCollection - data collection
     * @returns { void }
     */
    Diagram.prototype.parseStyle = function (line, dataCollection) {
        var styleRegex = /^style\s+(\w+)\s+fill:([^,]+),stroke:([^,]+),stroke-width:(\d+)px;/;
        if (line.startsWith('style')) {
            var match = line.match(styleRegex);
            if (match) {
                var id = match[1];
                var fill = match[2];
                var stroke = match[3];
                var strokeWidth = parseInt(match[4], 10);
                var data_2 = {
                    id: id,
                    fill: fill,
                    stroke: stroke,
                    strokeWidth: strokeWidth
                };
                var matchData = dataCollection.filter(function (x) { return x.id === data_2.id; });
                matchData[0].color = data_2.fill;
                matchData[0].stroke = data_2.stroke;
                matchData[0].strokeWidth = data_2.strokeWidth;
            }
        }
    };
    /**
     * @param {string[]} lines - The lines to be processed.
     * @param {FlowChartData[]} dataCollection - The data collection to be updated.
     * @param {string} arrowType - The type of arrow.
     * @returns { void }
     */
    Diagram.prototype.getNodeData = function (lines, dataCollection, arrowType) {
        var dataArray = [];
        var firstId = null;
        var secondId = null;
        var isExistCount = 0;
        var connectorLabel = '';
        var _loop_2 = function (i) {
            var line1 = lines[parseInt(i.toString(), 10)];
            var text = this_2.splitNested(line1);
            if (text[0].includes('|')) {
                // Extract content outside the '|'
                var match = text[0].match(/\|([^|]*)\|/);
                if (match) {
                    connectorLabel = match[1];
                }
                var parts = text[0].split('|');
                if (parts.length >= 3) {
                    text[0] = parts[2].trim();
                }
            }
            var id = text[0].trim();
            if (i === 0) {
                firstId = id;
            }
            else {
                secondId = id;
            }
            var exsist = dataCollection.find(function (data) { return data.id === id; });
            if (!exsist) {
                var labelShape = text.length > 1 ? text[1] : text[0];
                var shape = this_2.getShape(labelShape);
                var label = labelShape.replace(/[\\[\]\\(\\)\\{\\}\\{\\}\\/>]/g, '');
                var data = {
                    id: id,
                    name: label,
                    shape: shape,
                    color: 'white',
                    parentId: []
                };
                dataArray.push(data);
            }
            else {
                isExistCount++;
            }
        };
        var this_2 = this;
        for (var i = 0; i < lines.length; i++) {
            _loop_2(i);
        }
        if (dataArray.length) {
            var lastItem = dataArray[dataArray.length - 1];
            if (lastItem.id !== firstId) {
                lastItem.parentId.push(firstId);
                if (lastItem.label) {
                    lastItem.label.push(connectorLabel);
                }
                else {
                    lastItem.label = [connectorLabel];
                }
            }
            else {
                var data = dataCollection.find(function (data) { return data.id === secondId; });
                if (data.parentId) {
                    data.parentId.push(firstId);
                }
                else {
                    data.parentId = [firstId];
                }
                if (data.label) {
                    data.label.push(connectorLabel);
                }
                else {
                    data.label = [connectorLabel];
                }
            }
        }
        else if (isExistCount === 2) {
            var filteredData = dataCollection.filter(function (flowData) { return flowData.id === secondId; })[0];
            filteredData.parentId = filteredData.parentId || [];
            filteredData.parentId.push(firstId);
            filteredData.label = filteredData.label || [];
            filteredData.label[filteredData.parentId.length - 1] = connectorLabel;
        }
        if (arrowType) {
            var filteredData = dataCollection.filter(function (flowData) { return flowData.id === secondId; })[0];
            if (filteredData) {
                filteredData.arrowType = arrowType;
            }
        }
        return dataArray;
    };
    /**
     * To split the text based on the nested brackets
     * @param {string} text - The text to be split based on nested brackets.
     * @returns {string[]} An array of strings split based on the nested brackets.
     */
    Diagram.prototype.splitNested = function (text) {
        var result = [];
        var current = '';
        var level = 0;
        var delimiter = '';
        for (var _i = 0, text_1 = text; _i < text_1.length; _i++) {
            var char = text_1[_i];
            if (char === '[' || char === '{' || char === '(' || char === '>') {
                if (level === 0) {
                    if (current.trim().length > 0) {
                        result.push(current.trim());
                    }
                    current = char; // Include the delimiter in the current part
                    delimiter = char;
                    level++;
                }
                else {
                    current += char;
                    level++;
                }
            }
            else if (char === ']' || char === '}' || char === ')') {
                if (level === 1 && char === delimiter) {
                    current += char; // Include the delimiter in the current part
                    result.push(current.trim());
                    current = '';
                    level--;
                }
                else if (level > 1) {
                    current += char;
                    level--;
                }
                else {
                    current += char;
                }
            }
            else {
                current += char;
            }
        }
        if (current.trim().length > 0) {
            result.push(current.trim());
        }
        return result;
    };
    // Get shape based on the bracket
    Diagram.prototype.getShape = function (text) {
        var shape = {};
        if (text.startsWith('(((')) {
            shape = { type: 'Path', data: 'M 0 0 A 1 1 0 0 0 7 0 A 1 1 0 0 0 0 0 M -1 0 A 1 1 0 0 0 8 0 A 1 1 0 0 0 -1 0' };
        }
        else if (text.startsWith('((')) {
            shape = { shape: 'Ellipse', type: 'Basic' };
        }
        else if (text.startsWith('([')) {
            shape = { type: 'Flow', shape: 'Terminator' };
        }
        else if (text.startsWith('(')) {
            shape = { type: 'Flow', shape: 'Process' };
        }
        else if (text.startsWith('[[')) {
            shape = { type: 'Flow', shape: 'PreDefinedProcess' };
        }
        else if (text.startsWith('[/')) {
            if (text.endsWith('/]')) {
                shape = { type: 'Basic', shape: 'Parallelogram' };
            }
            else {
                shape = { type: 'Path', data: 'M 0 0 L 1 -1 L 5 -1 L 6 0 L 0 0' };
            }
        }
        else if (text.startsWith('[(')) {
            shape = { type: 'Path', data: 'M 0 1 L 0 6 C 2 7 4 7 6 6 L 6 1 C 5 0 1 0 0 1 C 1 2 5 2 6 1' };
        }
        else if (text.startsWith('[\\')) {
            if (text.endsWith('\\]')) {
                shape = { type: 'Path', data: 'M 0 0 L 12 0 L 14 2 L 2 2 L 0 0' };
            }
            else {
                shape = { type: 'Path', data: 'M 0 0 L 5 0 L 4 1 L 1 1 L 0 0' };
            }
        }
        else if (text.startsWith('[')) {
            shape = { type: 'Basic', shape: 'Rectangle' };
        }
        else if (text.startsWith('{{')) {
            shape = { type: 'Path', data: 'M 0 0 L 2 -2 L 11 -2 L 13 0 L 11 2 L 2 2 L 0 0' };
        }
        else if (text.startsWith('{')) {
            shape = { type: 'Flow', shape: 'Decision' };
        }
        else if (text.startsWith('>')) {
            shape = { type: 'Path', data: 'M 0 0 L 8 0 L 8 2 L 0 2 L 2 1 L 0 0' };
        }
        return shape;
    };
    /**
     * To  get the html diagram content
     *
     * @returns { string }     getDirection method .\
     * @param {StyleSheetList} styleSheets - defines the collection of style files to be considered while exporting.
     */
    Diagram.prototype.getDiagramContent = function (styleSheets) {
        if (this.printandExportModule) {
            var data = this.printandExportModule.getDiagramContent(styleSheets);
            return data;
        }
        else {
            console.warn('[WARNING] :: Module "PrintAndExport" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
            return '';
        }
    };
    /**
     * Exports a diagram as a image.
     *
     * @returns { void } Exports a diagram as a image.\
     * @param {string} image - A string representing the image content to be exported.
     * @param {IExportOptions} options -An object defining the properties of the image export.
     */
    Diagram.prototype.exportImage = function (image, options) {
        if (this.printandExportModule) {
            this.printandExportModule.exportImages(image, options);
        }
        else {
            console.warn('[WARNING] :: Module "PrintAndExport" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
        }
    };
    /**
     * Prints the native or HTML nodes of the diagram as an image.
     *
     * @returns { void } Prints the native or HTML nodes of the diagram as an image. \
     * @param {string} image - A string that defines the image content to be printed.
     * @param {IExportOptions} options - An IExportOptions object that defines the properties of the image and printing options.
     */
    Diagram.prototype.printImage = function (image, options) {
        if (this.printandExportModule) {
            options.printOptions = true;
            this.printandExportModule.exportImages(image, options);
        }
        else {
            console.warn('[WARNING] :: Module "PrintAndExport" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
        }
    };
    /**
     * Define a limit on the number of history entries that the diagram's history manager can store. This can help manage memory usage and control the undo/redo history size. Or
     * Sets the limit for the history entries in the diagram.
     *
     * @returns { void }  Define a limit on the number of history entries that the diagram's history manager can store. This can help manage memory usage and control the undo/redo history size. Or Sets the limit for the history entries in the diagram.
     * @param {number} stackLimit - The limit for the history manager's stack.
     */
    Diagram.prototype.setStackLimit = function (stackLimit) {
        if (this.undoRedoModule && stackLimit) {
            this.historyManager.stackLimit = stackLimit;
            this.undoRedoModule.applyLimit(this.historyManager.currentEntry, stackLimit, this, true);
        }
    };
    /**
     * Clears the history of the diagram, removing all the recorded actions from the undo and redo history.
     * @returns { void } Clears the history of the diagram, removing all the recorded actions from the undo and redo history.\
     */
    Diagram.prototype.clearHistory = function () {
        if (this.undoRedoModule) {
            this.undoRedoModule.clearHistory(this);
        }
    };
    /**
     * Retrieves the bounding rectangle that encloses the entire diagram.
     * @returns { void } TRetrieves the bounding rectangle that encloses the entire diagram. \
     */
    Diagram.prototype.getDiagramBounds = function () {
        if (this.printandExportModule) {
            var bounds = this.printandExportModule.getDiagramBounds('', {});
            bounds.width = bounds.width > this.scrollSettings.viewPortWidth ?
                bounds.width + (bounds.x > 0 ? bounds.x : 0) : this.scrollSettings.viewPortWidth;
            bounds.height = bounds.height > this.scrollSettings.viewPortHeight ?
                bounds.height + (bounds.y > 0 ? bounds.y : 0) : this.scrollSettings.viewPortHeight;
            bounds.x = bounds.x > 0 ? 0 : bounds.x;
            bounds.y = bounds.y > 0 ? 0 : bounds.y;
            return bounds;
        }
        else {
            console.warn('[WARNING] :: Module "PrintAndExport" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
            return new Rect();
        }
    };
    /**
     * Exports the diagram as an image or SVG element based on the specified options.
     *
     * @returns { void } Exports the diagram as an image or SVG element based on the specified options.\
     * @param {IExportOptions} options - An object defining how the diagram image should be exported.
     */
    Diagram.prototype.exportDiagram = function (options) {
        if (this.printandExportModule) {
            var data = this.printandExportModule.exportDiagram(options);
            return data;
        }
        else {
            console.warn('[WARNING] :: Module "PrintAndExport" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
            return '';
        }
    };
    /**
     * Prints the diagram.
     *
     * @returns { void }     Prints the diagram.\
     * @param {IPrintOptions} optons - An IPrintOptions object that defines how the diagram is to be printed.
     */
    Diagram.prototype.print = function (options) {
        if (this.printandExportModule) {
            this.printandExportModule.print(options);
        }
        else {
            console.warn('[WARNING] :: Module "PrintAndExport" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
        }
    };
    /**
     * Adds ports to a node or connector at runtime. \
     *
     * @returns { void }    Adds ports to a node or connector at runtime.\
     * @param { Node | ConnectorModel} obj - object representing the node or connector to which ports will be added.
     * @param {ShapeAnnotationModel[] | PathAnnotationModel[]} ports - objects representing the ports to be added.
     * @blazorArgsType obj|DiagramNode
     */
    Diagram.prototype.addPorts = function (obj, ports) {
        this.protectPropertyChange(true);
        var exist = false;
        //Removed isBlazor code
        obj = this.nameTable[obj.id] || obj;
        var newObj;
        if (ports.length > 1) {
            this.startGroupAction();
        }
        var _loop_3 = function (i) {
            //907755 - Issue in add/remove port on runtime
            exist = obj.ports.some(function (port) { return port.id === ports[parseInt(i.toString(), 10)].id; });
            if (exist) {
                return "continue";
            }
            if (obj instanceof Node) {
                newObj = new PointPort(obj, 'ports', ports[parseInt(i.toString(), 10)], true);
                obj.ports.push(newObj);
            }
            else if (obj instanceof Connector) {
                newObj = new PathPort(obj, 'ports', ports[parseInt(i.toString(), 10)], true);
                obj.ports.push(newObj);
            }
            //Removed isBlazor code
            if (obj.children) {
                // 907773: Add port to Group at runtime Issue Fix
                var container = obj.wrapper;
                for (var k = 0; k < container.children.length; k++) {
                    var wrapper = container.children[parseInt(k.toString(), 10)];
                    if ((wrapper.id).match(container.id)) {
                        obj.initPort(this_3.getDescription, wrapper, newObj);
                        break;
                    }
                }
            }
            else {
                var canvas = obj.wrapper;
                if (obj instanceof Node) {
                    canvas.children.push(obj.initPortWrapper(obj.ports[obj.ports.length - 1]));
                }
                else if (obj instanceof Connector) {
                    var points = obj.type === 'Bezier' ? obj.intermediatePoints : obj.getConnectorPoints(obj.type);
                    points = obj.clipDecorators(obj, points);
                    var bounds = Rect.toBounds(points);
                    // eslint-disable-next-line max-len
                    canvas.children.push(obj.initPort(obj.ports[obj.ports.length - 1], points, bounds, undefined));
                }
            }
            if (!(this_3.diagramActions & DiagramAction.UndoRedo) && !(this_3.diagramActions & DiagramAction.Group)) {
                var entry = {
                    type: 'PortCollectionChanged', changeType: 'Insert', undoObject: cloneObject(newObj),
                    redoObject: cloneObject(obj), category: 'Internal'
                };
                this_3.addHistoryEntry(entry);
            }
        };
        var this_3 = this;
        for (var i = 0; i < ports.length; i++) {
            _loop_3(i);
        }
        if (ports.length > 1) {
            this.endGroupAction();
        }
        //Removed isBlazor code
        obj.wrapper.measure(new Size(obj.width, obj.height));
        obj.wrapper.arrange(obj.wrapper.desiredSize);
        this.updateDiagramObject(obj);
        this.protectPropertyChange(false);
    };
    /**
     * Adds constraints at run time. \
     *
     * @returns { void }Add constraints at run time .\
     * @param {number} constraintsType - The source value for constraints.
     * @param {number} constraintsValue - The target value for constraints.
     *
     */
    Diagram.prototype.addConstraints = function (constraintsType, constraintsValue) {
        return constraintsType | constraintsValue;
    };
    /**
     * Remove constraints at run time. \
     *
     * @returns { void }Remove constraints at run time.\
     * @param {number} constraintsType - The type of constraints to be removed.
     * @param {number} constraintsValue - The value of constraints to be removed.
     *
     */
    Diagram.prototype.removeConstraints = function (constraintsType, constraintsValue) {
        return constraintsType & ~constraintsValue;
    };
    /**
     * Add labels in node at the run time in the blazor platform  \
     *
     * @returns { void } Add labels in node at the run time in the blazor platform  \
     * @param {NodeModel} obj - provide the obj value.
     * @param {ShapeAnnotationModel[]} labels - provide the labels value.
     *
     */
    Diagram.prototype.addNodeLabels = function (obj, labels) {
        this.addLabels(obj, labels);
    };
    /**
     * Adds labels to a connector at runtime in the Blazor platform.\
     *
     * @returns { void } Adds labels to a connector at runtime in the Blazor platform.\
     * @param {ConnectorModel} obj - The connector to which labels will be added.
     * @param {PathAnnotationModel[]} labels - An array of labels to add to the connector.
     *
     */
    Diagram.prototype.addConnectorLabels = function (obj, labels) {
        this.addLabels(obj, labels);
    };
    /**
     * Adds labels to a node or connector at runtime. \
     *
     * @returns { void } Adds labels to a node or connector at runtime.\
     * @param {NodeModel | ConnectorModel} obj - The node or connector to which labels will be added.
     * @param {ShapeAnnotationModel[] | PathAnnotation[] | PathAnnotationModel[]} labels - An array of label objects to be added.
     *
     */
    Diagram.prototype.addLabels = function (obj, labels) {
        this.protectPropertyChange(true);
        //Removed isBlazor code
        obj = this.nameTable[obj.id] || obj;
        var canvas = obj.wrapper;
        var newObj;
        if (labels.length > 1) {
            this.startGroupAction();
        }
        for (var i = 0; i < labels.length; i++) {
            if (obj instanceof Node) {
                newObj = new ShapeAnnotation(obj, 'annotations', labels[parseInt(i.toString(), 10)], true);
                obj.annotations.push(newObj);
                //Removed isBlazor code
                if (obj.children) {
                    var node = obj;
                    for (var i_2 = 0; i_2 < node.wrapper.children.length; i_2++) {
                        if (node.wrapper.children[parseInt(i_2.toString(), 10)].id === node.id + 'group_container') {
                            var container = node.wrapper.children[parseInt(i_2.toString(), 10)];
                            container.children.push(obj.initAnnotationWrapper(obj.annotations[obj.annotations.length - 1], this.element.id));
                        }
                    }
                }
                else {
                    canvas.children.push(obj.initAnnotationWrapper(obj.annotations[obj.annotations.length - 1], this.element.id));
                }
            }
            else if (obj instanceof Connector) {
                newObj = new PathAnnotation(obj, 'annotations', labels[parseInt(i.toString(), 10)], true);
                obj.annotations.push(newObj);
                //Removed isBlazor code
                var segment = canvas.children[0];
                var bounds = new Rect(segment.offsetX - segment.width / 2, segment.offsetY - segment.height / 2, segment.width, segment.height);
                canvas.children.push(obj.getAnnotationElement(obj.annotations[obj.annotations.length - 1], obj.intermediatePoints, bounds, this.getDescription, this.element.id));
            }
            if (!(this.diagramActions & DiagramAction.UndoRedo) && !(this.diagramActions & DiagramAction.Group)) {
                var entry = {
                    type: 'LabelCollectionChanged', changeType: 'Insert', undoObject: cloneObject(newObj),
                    redoObject: cloneObject(obj), category: 'Internal'
                };
                this.addHistoryEntry(entry);
            }
        }
        if (labels.length > 1) {
            this.endGroupAction();
        }
        //Removed isBlazor code
        obj.wrapper.measure(new Size(canvas.width, canvas.height));
        obj.wrapper.arrange(canvas.desiredSize);
        this.updateDiagramObject(obj);
        this.protectPropertyChange(false);
        //EJ2-908488 - Added for Update annotations in overview
        this.refreshCanvasLayers();
    };
    /**
     *addChildToUmlNode - Add methods, members and attributes into a UML class runtime. \
     *
     * @returns { void } Add.
     * @param {NodeModel} node - Specifies the existing UmlClass node in the diagram to which you intend to add child elements.
     * @param {UmlClassMethodModel | UmlClassAttributeModel | UmlEnumerationMemberModel} child - Specify the child elements, such as attributes, members, or methods, to be added to the UML class.
     * @param {UmlClassChildType} umlChildType - Specify the enum that you intend to add to the UML class.
     *
     */
    Diagram.prototype.addChildToUmlNode = function (node, child, umlChildType) {
        var classifier;
        var method;
        var attribute;
        var member;
        var textWrap = 'NoWrap';
        //Members and attributes are exclusively added to the classShape and interfaceShape within the UML node
        if (node.shape.classifier === 'Class' || node.shape.classifier === 'Interface') {
            if (umlChildType === 'Method') {
                method = new UmlClassMethod(node, '', child);
                if (node.shape.classifier === 'Class') {
                    node.shape.classShape.methods.push(method);
                    classifier = node.shape.classShape;
                }
                else if (node.shape.classifier === 'Interface') {
                    node.shape.interfaceShape.methods.push(method);
                    classifier = node.shape.interfaceShape;
                }
                //this method triggers for adding methods at runtime
                getClassMembersChild(node, this, classifier, textWrap);
            }
            else if (umlChildType === 'Attribute') {
                attribute = new UmlClassAttribute(node, '', child);
                if (node.shape.classifier === 'Class') {
                    node.shape.classShape.attributes.push(attribute);
                    classifier = node.shape.classShape;
                }
                else if (node.shape.classifier === 'Interface') {
                    node.shape.interfaceShape.attributes.push(attribute);
                    classifier = node.shape.interfaceShape;
                }
                //this method triggers for adding attributes at runtime
                getClassAttributesChild(node, this, classifier, textWrap);
            }
        }
        else if (node.shape.classifier === 'Enumeration' && umlChildType === 'Member') {
            member = new UmlEnumerationMember(node, '', child);
            node.shape.enumerationShape.members.push(member);
            classifier = node.shape.enumerationShape;
            //this method triggers for adding members at runtime
            getClassNodesChild(node, this, classifier, textWrap);
        }
        //The clearSelection methods is invoked to update the newly added child type dynamically at runtime
        this.clearSelection();
        this.updateSelector();
    };
    /**
     * Dynamically add lanes to a swimlane at runtime. You can specify the swimlane (node), the lanes to be added (lane), and an optional index to determine where the lanes should be inserted. \
     *
     * @returns { void } Dynamically add lanes to a swimlane at runtime. You can specify the swimlane (node), the lanes to be added (lane), and an optional index to determine where the lanes should be inserted.\
     * @param {NodeModel} node - The swimlane to which lanes will be added.
     * @param {LaneModel[]} lane -An array of LaneModel objects representing the lanes to be added.
     * @param {number} index - The index at which the lanes should be inserted.
     *
     */
    Diagram.prototype.addLanes = function (node, lane, index) {
        node = this.nameTable[node.id] || node;
        for (var i = 0; i < lane.length; i++) {
            addLane(this, node, lane[parseInt(i.toString(), 10)], index);
            if (index !== undefined) {
                index += 1;
            }
        }
        this.updateDiagramElementQuad();
    };
    /**
     * Adds phases to a swimlane at runtime.  \
     *
     * @returns { void } Adds phases to a swimlane at runtime. \
     * @param {NodeModel} node - object representing the swimlane to which phases will be added.
     * @param {PhaseModel[]} phases - objects representing the phases to be added.
     *
     */
    Diagram.prototype.addPhases = function (node, phases) {
        node = this.nameTable[node.id] || node;
        for (var i = 0; i < phases.length; i++) {
            //897967-Exception thrown when adding Phases at runtime and perform undo Action
            this.protectPropertyChange(true);
            addPhase(this, node, phases[parseInt(i.toString(), 10)]);
            this.protectPropertyChange(false);
        }
        this.updateDiagramElementQuad();
    };
    /**
     *Removes a dynamic lane from a swimlane at runtime. \
     *
     * @returns { void } Removes a dynamic lane from a swimlane at runtime.\
     * @param {NodeModel} node - representing the swimlane to remove the lane from.
     * @param {LaneModel} lane - representing the dynamic lane to be removed.
     *
     */
    Diagram.prototype.removeLane = function (node, lane) {
        if (lane) {
            // 912168- Undoing removed lane throws exception Issue Fix
            var laneHead = this.nameTable[lane.header.id];
            this.diagramActions = this.diagramActions | DiagramAction.PublicMethod;
            removeLane(this, laneHead, node, undefined);
            this.updateDiagramElementQuad();
        }
    };
    /**
     *Removes a phase from a swimlane at runtime.\
     *
     * @returns { void } Removes a phase from a swimlane at runtime.\
     * @param {NodeModel} node - representing the swimlane to remove the phase from.
     * @param {PhaseModel} phase - representing the phase to be removed.
     *
     */
    Diagram.prototype.removePhase = function (node, phase) {
        var id = phase.header.id;
        var phaseObj = this.nameTable["" + id];
        removePhase(this, phaseObj, node);
        this.updateDiagramElementQuad();
    };
    //827745-support to edit Segment for Straight connector at runtime.
    /**
     * Used to add or remove intermediate segments to the straight connector.
     *
     * @returns { void }  Used to add or remove intermediate segments to the straight connector.
     * @param {IEditSegmentOptions} editOptions - An object containing various options for adding/removing segments.
     *
     */
    Diagram.prototype.editSegment = function (editOptions) {
        if (editOptions.connector.type === 'Straight') {
            var connector = editOptions.connector;
            var mode = editOptions && editOptions.SegmentEditing ? editOptions.SegmentEditing : 'Toggle';
            var point = editOptions.point;
            var hasPoint = void 0;
            var allowEdit = void 0;
            for (var i = 0; i < connector.segments.length; i++) {
                var segment = (connector.segments)[parseInt(i.toString(), 10)];
                if (contains(point, segment.point, connector.hitPadding)) {
                    hasPoint = true;
                    break;
                }
            }
            if ((hasPoint && mode === 'Remove') || (!hasPoint && mode === 'Add')) {
                allowEdit = true;
            }
            if ((connector.type === 'Straight') && (allowEdit || mode === 'Toggle')) {
                this.connectorEditingToolModule.addOrRemoveSegment(connector, point, this.commandHandler);
            }
        }
    };
    Diagram.prototype.removelabelExtension = function (obj, labels, j, wrapper) {
        for (var i = 0; i < wrapper.children.length; i++) {
            var canvas = wrapper.children[parseInt(i.toString(), 10)];
            if ((canvas instanceof TextElement) || (canvas instanceof DiagramHtmlElement)) {
                if (canvas.id.match('_' + labels[parseInt(j.toString(), 10)].id + '$')) {
                    for (var k = 0; k < obj.annotations.length; k++) {
                        if (canvas.id.match('_' + obj.annotations[parseInt(k.toString(), 10)].id + '$')) {
                            if (!(this.diagramActions & DiagramAction.UndoRedo)) {
                                var entry = {
                                    type: 'LabelCollectionChanged', changeType: 'Remove', undoObject: cloneObject(obj.annotations[parseInt(k.toString(), 10)]),
                                    redoObject: cloneObject(obj), category: 'Internal'
                                };
                                this.addHistoryEntry(entry);
                            }
                            obj.annotations.splice(k, 1);
                        }
                    }
                    wrapper.children.splice(i, 1);
                    if (this.mode === 'SVG') {
                        var element = getDiagramElement(canvas.id, this.element.id);
                        if (element) {
                            var element_1 = getDiagramElement(canvas.id, this.element.id);
                            element_1.parentNode.removeChild(element_1);
                        }
                        var textElement = getDiagramElement(canvas.id + '_text', this.element.id);
                        if (textElement) {
                            element = getDiagramElement(canvas.id + '_text', this.element.id);
                            element.parentNode.removeChild(element);
                        }
                        var htmlElement = getDiagramElement(canvas.id + '_html_element', this.element.id);
                        if (htmlElement) {
                            htmlElement.parentNode.removeChild(htmlElement);
                        }
                    }
                    else {
                        this.refreshCanvasLayers();
                    }
                }
            }
        }
    };
    /**
     * Removes labels from a node or connector at runtime. \
     *
     * @returns { string }    Removes labels from a node or connector at runtime. \
     * @param { Node | ConnectorModel} obj - Representing the node or connector to remove labels from.
     * @param {ShapeAnnotationModel[] | PathAnnotationModel[]} labels - objects representing the labels to be removed.
     *
     */
    Diagram.prototype.removeLabels = function (obj, labels) {
        //Removed isBlazor code
        obj = this.nameTable[obj.id] || obj;
        // Removed isBlazor code
        if (labels.length > 1) {
            this.startGroupAction();
        }
        for (var j = labels.length - 1; j >= 0; j--) {
            if (obj.children && obj.children.length > 0) {
                //Bug 886881: Exception throws while ungrouping a group node with annotations.
                //Added the condition to check the wrapper id is same as the obj id to remove the group node label alone while unGroup.
                var groupWrapper = obj.wrapper.children.filter(function (wrapper) { return wrapper.id === obj.id + 'group_container'; });
                if (groupWrapper && groupWrapper.length > 0) {
                    this.removelabelExtension(obj, labels, j, groupWrapper[0]);
                }
            }
            else {
                this.removelabelExtension(obj, labels, j, obj.wrapper);
            }
        }
        if (labels.length > 1) {
            this.endGroupAction();
        }
        //EJ2-908488 - Added for Update annotations in overview
        this.refreshCanvasLayers();
    };
    Diagram.prototype.removePortsExtenion = function (obj, ports, j, wrapper) {
        for (var i = 0; i < wrapper.children.length; i++) {
            var canvas = wrapper.children[parseInt(i.toString(), 10)];
            if (canvas instanceof PathElement) {
                if (canvas.id.match('_' + ports[parseInt(j.toString(), 10)].id + '$')) {
                    for (var k = 0; k < obj.ports.length; k++) {
                        if (canvas.id.match('_' + obj.ports[parseInt(k.toString(), 10)].id + '$')) {
                            if (!(this.diagramActions & DiagramAction.UndoRedo)) {
                                var entry = {
                                    type: 'PortCollectionChanged', changeType: 'Remove', undoObject: cloneObject(obj.ports[parseInt(k.toString(), 10)]),
                                    redoObject: cloneObject(obj), category: 'Internal'
                                };
                                this.addHistoryEntry(entry);
                            }
                            obj.ports.splice(k, 1);
                        }
                    }
                    wrapper.children.splice(i, 1);
                    if (this.mode === 'SVG') {
                        var element = getDiagramElement(canvas.id, this.element.id);
                        // 905159: undo redo the multi-node after the group and ungrouping the multi nodes Issue fix
                        if (element) {
                            element.parentNode.removeChild(element);
                        }
                    }
                    else {
                        this.refreshCanvasLayers();
                    }
                }
            }
        }
    };
    /**
     * Removes Ports at run time. \
     *
     * @returns { void } Removes Ports at run time.\
     * @param {Node} obj - The node or connector to remove ports from.
     * @param {PointPortModel[]} ports - An array of ports to be removed.
     *
     */
    Diagram.prototype.removePorts = function (obj, ports) {
        //Removed isBlazor code
        obj = this.nameTable[obj.id] || obj;
        var portLength = ports.length;
        //Removed isBlazor code
        if (portLength > 1) {
            this.startGroupAction();
        }
        for (var j = ports.length - 1; j >= 0; j--) {
            if (obj.children && obj.children.length > 0) {
                for (var k = 0; k < obj.wrapper.children.length; k++) {
                    //EJ2-66928 Bug- added for ungroup Issue to only remove the grouping ports and not to remove ports of the children nodes
                    var wrapper = obj.wrapper.children[parseInt(k.toString(), 10)];
                    if ((wrapper.id).match(obj.wrapper.id)) {
                        this.removePortsExtenion(obj, ports, j, obj.wrapper.children[parseInt(k.toString(), 10)]);
                    }
                }
            }
            else {
                this.removePortsExtenion(obj, ports, j, obj.wrapper);
            }
        }
        if (portLength > 1) {
            this.endGroupAction();
        }
    };
    //public methods - end region
    /**
     * getSizeValue method \
     *
     * @returns { string }     getSizeValue method .\
     * @param {string | number} real - provide the real value.
     * @param {string | number} rulerSize - provide the rulerSize value.
     *
     * @private
     */
    Diagram.prototype.getSizeValue = function (real, rulerSize) {
        var value;
        if (real.toString().indexOf('px') > 0) {
            value = real.toString();
        }
        else if (real.toString().indexOf('%') > 0) {
            value = rulerSize !== undefined ? '100%' : real.toString();
        }
        else {
            value = real.toString() + 'px';
        }
        if (rulerSize) {
            var position = getRulerSize(this);
            value = 'calc(' + value + ' - ' + rulerSize + 'px)';
        }
        return value;
    };
    Diagram.prototype.renderRulers = function () {
        if (this.rulerSettings.showRulers) {
            renderOverlapElement(this);
            renderRuler(this, true);
            renderRuler(this, false);
        }
        else {
            removeRulerElements(this);
        }
    };
    Diagram.prototype.intOffPageBackground = function () {
        var position = new Size();
        position = getRulerSize(this);
        var element = document.getElementById(this.element.id + 'content');
        //Task 913515: Handle null properties for diagram and barcode properties-phase1
        if (!this.width) {
            this.width = '100%';
        }
        if (!this.height) {
            this.height = '100%';
        }
        var width = this.getSizeValue(this.width, position.width);
        var height = this.getSizeValue(this.height, position.height);
        var style = this.rulerSettings.showRulers ?
            'width:' + width + '; height:' + height + ';' +
                'top:' + position.height + 'px;left:' + position.width + 'px;' +
                'overflow: scroll;position:absolute;overflow:auto;' :
            'width:' + width + '; height:' + height + ';position:absolute;' +
                ' left:0px;  top:0px;overflow: auto;';
        var attr = {
            'id': this.element.id + 'content',
            'tabindex': '0',
            'style': style
        };
        if (!element) {
            this.diagramCanvas = createHtmlElement('div', attr);
            this.element.appendChild(this.diagramCanvas);
        }
        else {
            this.diagramCanvas = element;
            applyStyleAgainstCsp(this.diagramCanvas, style);
        }
        this.diagramCanvas.style.background = this.backgroundColor;
    };
    Diagram.prototype.initDiagram = function () {
        this.intOffPageBackground();
        setAttributeHtml(this.element, {
            style: 'width:' + this.getSizeValue(this.width) + '; height:'
                + this.getSizeValue(this.height) + ';position:relative;overflow:hidden;'
        });
    };
    Diagram.prototype.renderHiddenUserHandleTemplateLayer = function (bounds) {
        //let element: HTMLElement;
        var attributes = {
            'class': this.element.id + '_hiddenUserHandleTemplate',
            'style': 'width:' + bounds.width + 'px; height:' + bounds.height + 'px;' + 'visibility:hidden ;  overflow: hidden;'
        };
        var element = createHtmlElement('div', attributes);
        this.element.appendChild(element);
    };
    Diagram.prototype.renderBackgroundLayer = function (bounds, commonStyle) {
        var bgLayer = this.createSvg(this.element.id + '_backgroundLayer_svg', bounds.width, bounds.height);
        applyStyleAgainstCsp(bgLayer, commonStyle);
        var backgroundImage = createSvgElement('g', {
            'id': this.element.id + '_backgroundImageLayer',
            'class': 'e-background-image-layer'
        });
        bgLayer.appendChild(backgroundImage);
        var attr = { 'id': this.element.id + '_backgroundLayer', 'class': 'e-background-layer' };
        var background = createSvgElement('g', attr);
        bgLayer.appendChild(background);
        this.diagramCanvas.appendChild(bgLayer);
    };
    Diagram.prototype.renderGridLayer = function (bounds, commonStyle) {
        var svgGridSvg = this.createSvg(this.element.id + '_gridline_svg', bounds.width, bounds.height);
        svgGridSvg.setAttribute('class', 'e-grid-layer');
        var svgGrid = createSvgElement('g', { 'id': this.element.id + '_gridline' });
        var rect = createSvgElement('rect', {
            'id': this.element.id + '_grid_rect', 'x': '0', 'y': '0', 'width': '100%', 'height': '100%'
        });
        if (checkBrowserInfo()) {
            //EJ2-832888-To remove the black grid lines appearing in the safari browser.
            var url = new URL(window.location.href);
            // Check if the URL contains a query string
            if (url.search !== '') {
                rect.setAttribute('fill', 'url(#' + this.element.id + '_pattern)');
            }
            else {
                rect.setAttribute('fill', 'url(' + location.protocol + '//' + location.host + location.pathname +
                    '#' + this.element.id + '_pattern)');
            }
        }
        else {
            rect.setAttribute('fill', 'url(#' + this.element.id + '_pattern)');
        }
        svgGrid.appendChild(rect);
        svgGridSvg.appendChild(svgGrid);
        this.diagramCanvas.appendChild(svgGridSvg);
        setAttributeSvg(svgGridSvg, { 'style': commonStyle });
    };
    Diagram.prototype.renderDiagramLayer = function (bounds, commonStyle) {
        var attributes = {
            'id': this.element.id + '_diagramLayer_div',
            'style': 'width:' + bounds.width + 'px; height:' + bounds.height + 'px;' + commonStyle
        };
        this.diagramLayerDiv = createHtmlElement('div', attributes);
        if (this.mode === 'SVG') {
            var diagramSvg = this.createSvg(this.element.id + '_diagramLayer_svg', bounds.width, bounds.height);
            diagramSvg.style['pointer-events'] = 'none';
            diagramSvg.setAttribute('class', 'e-diagram-layer');
            var diagramLayer = createSvgElement('g', { 'id': this.element.id + '_diagramLayer' });
            var transformationLayer = createSvgElement('g', {});
            this.diagramLayer = diagramLayer;
            diagramSvg.style['pointer-events'] = 'all';
            transformationLayer.appendChild(diagramLayer);
            diagramSvg.appendChild(transformationLayer);
            this.diagramLayerDiv.appendChild(diagramSvg);
        }
        else {
            this.diagramLayer = CanvasRenderer.createCanvas(this.element.id + '_diagram', bounds.width, bounds.height);
            applyStyleAgainstCsp(this.diagramLayer, 'position:absolute;left:0px;top:0px;');
            this.diagramLayerDiv.appendChild(this.diagramLayer);
        }
        this.diagramCanvas.appendChild(this.diagramLayerDiv);
    };
    Diagram.prototype.initLayers = function () {
        var commonStyle = 'position:absolute;top:0px;left:0px;overflow:hidden;pointer-events:none;';
        var container = document.getElementById(this.element.id);
        var bounds = container.getBoundingClientRect();
        //Task 918932: Provide diagram control in powerapps- phase2
        this.setScaleFromElement(bounds, container);
        this.modifyBounds(bounds);
        var scrollerSize = getScrollerWidth();
        this.scroller.scrollerWidth = scrollerSize;
        this.scroller.setViewPortSize(bounds.width, bounds.height);
        this.renderRulers();
        var measureWindowElement = 'measureElement';
        if (window["" + measureWindowElement]) {
            window["" + measureWindowElement] = null;
            var measureElements = document.getElementById('measureElement');
            measureElements.remove();
        }
        createMeasureElements();
        // this.renderBackgroundImageLayer(bounds, commonStyle);
        this.renderBackgroundLayer(bounds, commonStyle);
        this.renderGridLayer(bounds, commonStyle);
        this.renderDiagramLayer(bounds, commonStyle);
        this.renderHTMLLayer(bounds, commonStyle);
        this.renderPortsExpandLayer(bounds, commonStyle);
        this.renderNativeLayer(bounds, commonStyle);
        this.renderAdornerLayer(bounds, commonStyle);
        this.renderHiddenUserHandleTemplateLayer(bounds);
    };
    /**
     * @private
     * @param { ClientRect } bounds - provide the bounds value
     * @param { HTMLElement } container - provide the container value
     * @returns { void }
     *
     */
    Diagram.prototype.setScaleFromElement = function (bounds, container) {
        var width = bounds.width / container.clientWidth;
        this.scaleValue = width;
    };
    /**
     * @private
     * @returns { void }
     * @param { any } bounds - provide the bounds value
     */
    Diagram.prototype.modifyBounds = function (bounds) {
        var scale = this.scaleValue;
        bounds.x = bounds.x / scale;
        bounds.y = bounds.y / scale;
        bounds.width = bounds.width / scale;
        bounds.height = bounds.height / scale;
    };
    /**
     * @private
     * @returns { number } - Returns offset value
     * @param { number } offset - provide the offset value
     * @param { boolean } isTooltipOffset - provide the isTooltipOffset value
     *
     */
    Diagram.prototype.modifyClientOffset = function (offset, isTooltipOffset) {
        var scale = this.scaleValue;
        var value = 0;
        if (isTooltipOffset) {
            value = offset * scale;
        }
        else {
            value = offset / scale;
        }
        return value;
    };
    Diagram.prototype.renderAdornerLayer = function (bounds, commonStyle) {
        var divElement = createHtmlElement('div', {
            'id': this.element.id + '_diagramAdornerLayer',
            'style': 'width:' + bounds.width + 'px;height:' + bounds.height + 'px;' + commonStyle
        });
        var element = createHtmlElement('div', {
            'id': this.element.id + '_diagramUserHandleLayer',
            'style': 'width:' + bounds.width + 'px;height:' + bounds.height + 'px;' + commonStyle
        });
        element.setAttribute('class', 'e-userHandle-layer');
        divElement.appendChild(element);
        var svgAdornerSvg = this.createSvg(this.element.id + '_diagramAdorner_svg', bounds.width, bounds.height);
        svgAdornerSvg.setAttribute('class', 'e-adorner-layer');
        svgAdornerSvg.style['pointer-events'] = 'none';
        this.adornerLayer = createSvgElement('g', { 'id': this.element.id + '_diagramAdorner' });
        this.adornerLayer.style[' pointer-events'] = 'all';
        svgAdornerSvg.appendChild(this.adornerLayer);
        divElement.appendChild(svgAdornerSvg);
        this.diagramCanvas.appendChild(divElement);
        var svgSelector = createSvgElement('g', { 'id': this.element.id + '_SelectorElement' });
        this.adornerLayer.appendChild(svgSelector);
        setAttributeSvg(svgAdornerSvg, { style: 'pointer-events:none;' });
    };
    Diagram.prototype.renderPortsExpandLayer = function (bounds, commonStyle) {
        var svgPortsSvg = this.createSvg(this.element.id + '_diagramPorts_svg', bounds.width, bounds.height);
        svgPortsSvg.setAttribute('class', 'e-ports-expand-layer');
        var svgPortsLayer = createSvgElement('g', {
            'id': this.element.id + '_diagramPorts',
            'class': 'e-ports-layer',
            'style': 'pointer-events: all;'
        });
        svgPortsSvg.appendChild(svgPortsLayer);
        var svgExpandLayer = createSvgElement('g', {
            'id': this.element.id + '_diagramExpander',
            'class': 'e-expand-layer',
            'style': 'pointer-events: all;'
        });
        svgPortsSvg.appendChild(svgExpandLayer);
        this.diagramCanvas.appendChild(svgPortsSvg);
        setAttributeSvg(svgPortsSvg, { 'style': commonStyle });
    };
    Diagram.prototype.renderHTMLLayer = function (bounds, commonStyle) {
        this.htmlLayer = createHtmlElement('div', {
            'id': this.element.id + '_htmlLayer',
            'style': 'width:' + bounds.width + 'px; height:' + bounds.height + 'px;position:absolute;top:0px;' +
                'left:0px;overflow:hidden;pointer-events:none;',
            'class': 'e-html-layer'
        });
        var htmlLayerDiv = createHtmlElement('div', {
            'id': this.element.id + '_htmlLayer_div',
            'style': 'position:absolute;top:0px;left:0px;pointer-events:all;'
        });
        this.htmlLayer.appendChild(htmlLayerDiv);
        this.diagramCanvas.appendChild(this.htmlLayer);
    };
    Diagram.prototype.renderNativeLayer = function (bounds, commonStyle) {
        var nativeLayerSvg = this.createSvg(this.element.id + '_nativeLayer_svg', bounds.width, bounds.height);
        var nativeLayer = createSvgElement('g', { 'id': this.element.id + '_nativeLayer', 'style': 'pointer-events:all;' });
        nativeLayerSvg.appendChild(nativeLayer);
        this.diagramLayerDiv.appendChild(nativeLayerSvg);
        setAttributeSvg(nativeLayerSvg, { 'class': 'e-native-layer', 'style': commonStyle });
    };
    /**
     * createSvg method \
     *
     * @returns { void }     createSvg method .\
     * @param {string} id - provide the source value.
     * @param {string | number} width - provide the source value.
     * @param {string | number} height - provide the source value.
     *
     * @private
     */
    Diagram.prototype.createSvg = function (id, width, height) {
        var svgObj = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        setAttributeSvg(svgObj, { 'id': id, 'width': width, 'height': height });
        return svgObj;
    };
    Diagram.prototype.updateBazorShape = function () {
        for (var i = 0; i < this.nodes.length; i++) {
            var node = this.nodes[parseInt(i.toString(), 10)];
            switch (node.shape.type) {
                case 'Bpmn':
                    node.shape.bpmnShape =
                        node.shape.shape;
                    break;
                case 'UmlActivity':
                    node.shape.umlActivityShape =
                        node.shape.shape;
                    break;
                case 'Flow':
                    node.shape.flowShape =
                        node.shape.shape;
                    break;
                case 'Basic':
                    node.shape.basicShape =
                        node.shape.shape;
                    break;
                case 'Text':
                    node.shape.textContent =
                        node.shape.content;
                    break;
            }
        }
    };
    Diagram.prototype.initObjects = function (isLoad) {
        this.updateBazorShape();
        if (!this.isLoading) {
            this.initData();
        }
        this.initLayerObjects();
        this.updateBridging(isLoad);
    };
    /**
     * initLayerObjects method \
     *
     * @returns { void }     initLayerObjects method .\
     *
     * @private
     */
    Diagram.prototype.initLayerObjects = function () {
        var hasLayers = this.layers.length > 1; //const set: boolean = false;
        var connectors = [];
        //Removed isBlazor code
        var tempTabel = {};
        var bpmnTable = {};
        var groups = [];
        //Removed isBlazor code
        for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {
            var obj = _a[_i];
            obj.id = obj.id || randomId();
            this.addToLayer(obj, hasLayers);
            tempTabel[obj.id] = obj;
        }
        for (var _b = 0, _c = this.connectors; _b < _c.length; _b++) {
            var obj = _c[_b];
            obj.id = obj.id || randomId();
            this.addToLayer(obj, hasLayers);
            tempTabel[obj.id] = obj;
        }
        for (var _d = 0, _e = this.layers; _d < _e.length; _d++) {
            var layer = _e[_d];
            for (var _f = 0, _g = layer.objects; _f < _g.length; _f++) {
                var obj = _g[_f];
                if (tempTabel["" + obj]) {
                    if (!(tempTabel["" + obj] instanceof Connector)) {
                        if (tempTabel["" + obj].children) {
                            groups.push(obj);
                        }
                        else if ((tempTabel["" + obj].shape instanceof BpmnShape) &&
                            tempTabel["" + obj].shape.activity.subProcess.processes &&
                            tempTabel["" + obj].shape.activity.subProcess.processes.length > 0) {
                            bpmnTable[tempTabel["" + obj].id] = obj;
                        }
                        else {
                            this.initNodes(tempTabel["" + obj], layer);
                        }
                    }
                    else {
                        var connector = tempTabel["" + obj];
                        if (connector.sourceID && connector.targetID) {
                            var sourceNode = tempTabel[connector.sourceID];
                            var targetNode = tempTabel[connector.targetID];
                            var flag = true;
                            if (this.isLoading && ((sourceNode && sourceNode.children && sourceNode.children.length > 0) ||
                                (targetNode && targetNode.children && targetNode.children.length > 0))) {
                                flag = false;
                            }
                            if ((sourceNode && sourceNode.wrapper && targetNode && targetNode.wrapper) && flag) {
                                this.initConnectors(tempTabel["" + obj], layer);
                            }
                            else {
                                connectors.push(tempTabel["" + obj]);
                            }
                        }
                        else {
                            // 908150: Connector not rendered properly when one end is a group and other end is an endpoint
                            var sourceNode = tempTabel[connector.sourceID];
                            var targetNode = tempTabel[connector.targetID];
                            if ((sourceNode && sourceNode.children && sourceNode.children.length > 0) ||
                                (targetNode && targetNode.children && targetNode.children.length > 0)) {
                                connectors.push(tempTabel["" + obj]);
                            }
                            else {
                                this.initConnectors(tempTabel["" + obj], layer);
                            }
                        }
                    }
                }
            }
            // 930450: Diagram Taking Too Long to Load Due to Complex Hierarchical Tree Layout with Path Nodes
            if (this.pathDataStorage) {
                this.pathDataStorage.clear();
            }
            if (this.bpmnModule) {
                for (var _h = 0, _j = this.bpmnModule.bpmnTextAnnotationConnector; _h < _j.length; _h++) {
                    var obj = _j[_h];
                    this.initConnectors(obj, undefined, true);
                }
            }
        }
        for (var _k = 0, _l = Object.keys(bpmnTable); _k < _l.length; _k++) {
            var obj = _l[_k];
            this.initObject(tempTabel["" + obj]);
            this.bpmnModule.updateDocks(tempTabel["" + obj], this);
        }
        var alignedGroups = this.alignGroup(groups, tempTabel);
        for (var _m = 0, alignedGroups_1 = alignedGroups; _m < alignedGroups_1.length; _m++) {
            var obj = alignedGroups_1[_m];
            var layer = this.commandHandler.getObjectLayer(obj);
            this.initNodes(tempTabel["" + obj], layer);
        }
        for (var _o = 0, connectors_1 = connectors; _o < connectors_1.length; _o++) {
            var connector = connectors_1[_o];
            var layer = this.commandHandler.getObjectLayer(connector.id);
            this.initConnectors(connector, layer);
        }
        //Removed isBlazor code
    };
    Diagram.prototype.alignGroup = function (parents, tempTabel) {
        var newList = [];
        var parentist = [];
        var child;
        var childNode;
        var i;
        var j;
        for (i = 0; i < parents.length; i++) {
            child = parents[parseInt(i.toString(), 10)];
            childNode = tempTabel["" + child];
            var node = void 0;
            if (childNode && childNode.children.length) {
                for (j = 0; j < childNode.children.length; j++) {
                    node = childNode.children[parseInt(j.toString(), 10)];
                    if (parents.indexOf(node) > -1 && (newList.indexOf(node) === -1) &&
                        (parentist.indexOf(node) === -1)) {
                        newList.splice(0, 0, node);
                    }
                }
            }
            if (newList.indexOf(child) === -1) {
                parentist.push(child);
            }
        }
        newList = newList.concat(parentist);
        return newList;
    };
    Diagram.prototype.addToLayer = function (obj, hasLayers) {
        var layer;
        if (hasLayers) {
            layer = this.commandHandler.getObjectLayer(obj.id);
        }
        if (!hasLayers || !layer) {
            if (this.activeLayer.objects.indexOf(obj.id) === -1) {
                this.activeLayer.objects.push(obj.id);
            }
        }
        if ((obj instanceof Node || obj instanceof Connector) &&
            (obj.shape.type !== 'SwimLane' || (obj.children && obj.children.length > 0))) {
            if (obj.parentId) {
                var zIndex = this.swimlaneZIndexTable[obj.parentId];
                //EJ2-69247 - Unable to select node in swimlane after save and load
                var childzIndex = this.swimlaneChildTable[obj.id];
                if ((zIndex && zIndex !== -1) || ((childzIndex && childzIndex !== -1))) {
                    obj.zIndex = this.swimlaneChildTable[obj.id];
                }
            }
            if (obj instanceof Connector && (obj.sourceID && obj.targetID)) {
                //EJ2-69577 - We have removed findNodeInLane method to improve the performance.
                if (this.activeLayer.objects.indexOf(obj.sourceID) !== -1 &&
                    this.activeLayer.objects.indexOf(obj.targetID) !== -1) {
                    this.setZIndex(layer || this.activeLayer, obj);
                }
            }
            else {
                this.setZIndex(layer || this.activeLayer, obj);
            }
        }
    };
    Diagram.prototype.updateLayer = function (newProp) {
        for (var _i = 0, _a = Object.keys(newProp.layers); _i < _a.length; _i++) {
            var key = _a[_i];
            var layerObject = this.layers["" + key].objects;
            for (var _b = 0, layerObject_1 = layerObject; _b < layerObject_1.length; _b++) {
                var obj = layerObject_1[_b];
                var node = this.nameTable["" + obj];
                if (newProp.layers["" + key].visible !== undefined) {
                    this.updateElementVisibility(node.wrapper, node, newProp.layers["" + key].visible);
                }
                else if (newProp.layers["" + key].lock === true) {
                    this.unSelect(node);
                }
            }
            if (newProp.layers["" + key].lock !== undefined) {
                this.layers["" + key].lock = newProp.layers["" + key].lock;
            }
        }
        if (this.mode !== 'SVG') {
            this.refreshDiagramLayer();
        }
    };
    Diagram.prototype.updateScrollSettings = function (newProp) {
        var hPan = (-this.scroller.horizontalOffset + newProp.scrollSettings.horizontalOffset || 0);
        var vPan = (-this.scroller.verticalOffset + newProp.scrollSettings.verticalOffset || 0);
        var oldValue = {
            VerticalOffset: this.scrollSettings.verticalOffset, HorizontalOffset: this.scrollSettings.horizontalOffset,
            ViewportHeight: this.scrollSettings.viewPortHeight, ViewportWidth: this.scrollSettings.viewPortWidth,
            CurrentZoom: this.scroller.currentZoom
        };
        if (hPan !== 0 || vPan !== 0) {
            this.pan(hPan, vPan);
        }
        var newValue = {
            VerticalOffset: this.scrollSettings.verticalOffset, HorizontalOffset: this.scrollSettings.horizontalOffset,
            ViewportHeight: this.scrollSettings.viewPortHeight, ViewportWidth: this.scrollSettings.viewPortWidth,
            CurrentZoom: this.scroller.currentZoom
        };
        var panStatus = 'Start';
        if (this.realActions & RealAction.PanInProgress) {
            panStatus = 'Progress';
        }
        var arg = {
            oldValue: oldValue,
            newValue: newValue, source: this,
            panState: panStatus
        };
        //Removed isBlazor code
        this.triggerEvent(DiagramEvent.scrollChange, arg);
        this.commandHandler.updatePanState(true);
        if (this.mode === 'Canvas' && (this.constraints & DiagramConstraints.Virtualization)) {
            this.refreshDiagramLayer();
        }
    };
    Diagram.prototype.initData = function () {
        var dataSourceSettings = this.dataSourceSettings.dataManager || this.dataSourceSettings.dataSource;
        var adapter = 'adaptorName';
        if (this.dataBindingModule && !(this.realActions & RealAction.PreventDataInit)) {
            if (dataSourceSettings && this.dataSourceSettings.connectionDataSource.dataManager) {
                var dataManager = this.dataSourceSettings.dataManager || this.dataSourceSettings.dataSource;
                this.nodes = this.generateData(dataManager, true);
                this.connectors = this.generateData(this.dataSourceSettings.connectionDataSource.dataManager, false);
            }
            else if (dataSourceSettings && dataSourceSettings.dataSource &&
                (dataSourceSettings.dataSource.url || (dataSourceSettings["" + adapter] === 'BlazorAdaptor' &&
                    !dataSourceSettings.dataSource.url))) {
                this.dataBindingModule.initSource(this.dataSourceSettings, this);
            }
            else {
                this.dataBindingModule.initData(this.dataSourceSettings, this);
            }
        }
        else if (dataSourceSettings && !this.dataBindingModule) {
            console.warn('[WARNING] :: Module "DataBinding" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
        }
    };
    Diagram.prototype.generateData = function (dataSource, isNode) {
        var nodes = [];
        var i;
        for (i = 0; i < dataSource.length; i++) {
            var row = dataSource[parseInt(i.toString(), 10)];
            var node = isNode ? this.makeData(row, true) : this.makeData(row, false);
            if (node && node.id && (!findNodeByName(nodes, node.id))) {
                nodes.push(node);
            }
        }
        return (nodes);
    };
    Diagram.prototype.makeData = function (row, isNode) {
        var i;
        var fields = isNode ? this.dataSourceSettings : this.dataSourceSettings.connectionDataSource;
        var data = {};
        data.id = row[fields.id] ? row[fields.id] : randomId();
        if (fields.sourceID) {
            data.sourceID = row[fields.sourceID];
        }
        if (fields.targetID) {
            data.targetID = row[fields.targetID];
        }
        if (row[fields.sourcePointX] && row[fields.sourcePointY]) {
            data.sourcePoint = { 'x': Number(row[fields.sourcePointX]), 'y': Number(row[fields.sourcePointY]) };
        }
        if (row[fields.targetPointX] && row[fields.targetPointY]) {
            data.targetPoint = { 'x': Number(row[fields.targetPointX]), 'y': Number(row[fields.targetPointY]) };
        }
        if (fields.crudAction.customFields && fields.crudAction.customFields.length > 0) {
            for (i = 0; i < fields.crudAction.customFields.length; i++) {
                data[fields.crudAction.customFields[parseInt(i.toString(), 10)]]
                    = row[fields.crudAction.customFields[parseInt(i.toString(), 10)]];
            }
        }
        return data;
    };
    Diagram.prototype.initNodes = function (obj, layer) {
        this.preventDiagramUpdate = true;
        this.initObject(obj, layer);
        this.preventDiagramUpdate = false;
    };
    Diagram.prototype.initConnectors = function (obj, layer, independentObj) {
        this.preventDiagramUpdate = true;
        this.initObject(obj, layer, independentObj);
        this.updateEdges(obj);
        this.preventDiagramUpdate = false;
    };
    Diagram.prototype.setZIndex = function (layer, obj) {
        //should be changed
        var currentLayer = layer;
        if ((obj).zIndex === Number.MIN_VALUE) {
            while (currentLayer.zIndexTable[currentLayer.objectZIndex + 1]) {
                layer.objectZIndex++;
            }
            // obj.zIndex = ++currentLayer.objectZIndex;
            this.setIndex(layer, obj);
        }
        else {
            var index = (obj.zIndex !== null ? obj.zIndex : currentLayer.objectZIndex + 1);
            if (currentLayer.zIndexTable[parseInt(index.toString(), 10)]) {
                var tabelLength = Object.keys(currentLayer.zIndexTable).length;
                for (var i = 0; i < tabelLength; i++) {
                    if (i === index) {
                        for (var j_1 = tabelLength; j_1 > index; j_1--) {
                            currentLayer.zIndexTable[parseInt(j_1.toString(), 10)] = currentLayer.zIndexTable[j_1 - 1];
                            if (this.nameTable[currentLayer.zIndexTable[parseInt(j_1.toString(), 10)]]) {
                                this.nameTable[currentLayer.zIndexTable[parseInt(j_1.toString(), 10)]].zIndex = j_1;
                            }
                        }
                        currentLayer.zIndexTable[parseInt(i.toString(), 10)] = obj.id;
                    }
                }
            }
        }
    };
    Diagram.prototype.setIndex = function (layer, obj) {
        var _this = this;
        // Helper function to assign object zIndex and increment the objectZIndex of layer
        var assignZIndex = function (element) {
            element.zIndex = ++layer.objectZIndex;
            if ((element.shape.type === 'Bpmn' && element.shape.activity &&
                element.shape.activity.subProcess && element.shape.activity.subProcess.processes &&
                element.shape.activity.subProcess.processes.length)) {
                var processArray = element.shape.activity.subProcess.processes;
                processArray.forEach(function (processId) {
                    var processess = _this.nameTable["" + processId];
                    if (processess) {
                        processess.zIndex = ++layer.objectZIndex;
                    }
                });
            }
        };
        // Function to handle updating zIndex for child elements
        var updateChildIndex = function (childId) {
            // Find if the child is a node or a connector
            var childNode = _this.nodes.find(function (node) { return node.id === childId; });
            var childConnector = _this.connectors.find(function (connector) { return connector.id === childId; });
            if (childNode) {
                if (childNode.children && childNode.children.length > 0) {
                    // Recursively update the z-index for children of group nodes
                    _this.setIndex(layer, childNode);
                }
                else {
                    // Assign zIndex to non-group child node
                    assignZIndex(childNode);
                }
            }
            else if (childConnector) {
                // Assign zIndex to child connector
                assignZIndex(childConnector);
            }
        };
        // check object is present in current layer
        var currentLayerObject = layer.objects.find(function (object) { return object === obj.id; });
        if (currentLayerObject) {
            if (obj instanceof Node) {
                // Assign zIndex to group or standalone node
                assignZIndex(obj);
                if (obj.children && obj.children.length > 0) {
                    // Update zIndex for each child if there are children
                    for (var k = 0; k < obj.children.length; k++) {
                        updateChildIndex(obj.children[parseInt(k.toString(), 10)]);
                    }
                }
            }
            else {
                // Assign zIndex to a connector
                assignZIndex(obj);
            }
        }
    };
    Diagram.prototype.initializeDiagramLayers = function () {
        //const tempLayers: LayerModel[] = this.layers;
        for (var i = 0; i < this.layers.length; i++) {
            if (this.layers[parseInt(i.toString(), 10)].zIndex !== -1) {
                var temp = this.layers[parseInt(i.toString(), 10)];
                this.layers[parseInt(i.toString(), 10)] = this.layers[this.layers[parseInt(i.toString(), 10)].zIndex];
                this.layers[temp.zIndex] = temp;
            }
        }
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            layer.zIndex = layer.zIndex !== -1 ? layer.zIndex : this.layers.indexOf(layer);
            this.layerZIndexTable[layer.zIndex] = layer.id;
        }
        for (var i = 0; i < this.layers.length; i++) {
            for (var j = i + 1; j < this.layers.length; j++) {
                if (this.layers[parseInt(i.toString(), 10)].zIndex > this.layers[parseInt(j.toString(), 10)].zIndex) {
                    var temp = this.layers[parseInt(i.toString(), 10)];
                    this.layers[parseInt(i.toString(), 10)] = this.layers[parseInt(j.toString(), 10)];
                    this.layers[parseInt(j.toString(), 10)] = temp;
                }
            }
        }
        if (this.layers.length === 0) {
            var defaultLayer = {
                id: 'default_layer', visible: true, lock: false, objects: [], zIndex: 0,
                objectZIndex: -1, zIndexTable: {}
            };
            this.commandHandler.addLayer(defaultLayer, null, true);
        }
        this.setActiveLayer(this.layers[this.layers.length - 1].id);
    };
    /**
     * resetTool method \
     *
     * @returns { void }     resetTool method .\
     *
     * @private
     */
    Diagram.prototype.resetTool = function () {
        this.eventHandler.resetTool();
    };
    Diagram.prototype.initObjectExtend = function (obj, layer, independentObj) {
        if (independentObj) {
            var checkBoundaryConstraints = this.commandHandler.checkBoundaryConstraints(undefined, undefined, obj.wrapper.bounds, true);
            //EJ2-71853 - Need to improve performance of diagram while rendering large number of nodes and connectors.
            // Removed the for loop which is iterating through the zindex table and removing the object from the table as it is not covered in any scenario.
            //EJ2-840575 - Order commands not working between Swimlane and other nodes while drag and drop from the palette
            if (obj.shape.type === 'SwimLane') {
                for (var i = 0, a = Object.keys(layer.zIndexTable); i < a.length; i++) {
                    if (layer.zIndexTable[a[parseInt(i.toString(), 10)]] &&
                        layer.zIndexTable[a[parseInt(i.toString(), 10)]] === obj.id) {
                        delete layer.zIndexTable[a[parseInt(i.toString(), 10)]];
                    }
                }
            }
            layer.zIndexTable[obj.zIndex] = obj.id;
            if (!checkBoundaryConstraints) {
                var node = obj instanceof Node ? this.nodes : this.connectors;
                for (var i = 0; i <= node.length; i++) {
                    if (node[parseInt(i.toString(), 10)] && obj.id
                        === node[parseInt(i.toString(), 10)].id) {
                        node.splice(i, 1);
                    }
                }
                delete layer.zIndexTable[obj.zIndex];
            }
        }
    };
    /* tslint:disable */
    /**
     * initObject method \
     *
     * @returns { void }     initObject method .\
     * @param {End} obj - provide the obj value.
     * @param {End} layer - provide the layer value.
     * @param {LayoutOrientation} independentObj - provide the independentObj value.
     * @param {boolean} group - provide the independentObj value.
     *
     * @private
     */
    Diagram.prototype.initObject = function (obj, layer, independentObj, group) {
        if (independentObj === void 0) { independentObj = true; }
        if (obj !== undefined) {
            if (independentObj) {
                if (!layer) {
                    this.addToLayer(obj, false);
                    layer = this.activeLayer;
                }
                //Move the common properties like zindex and id to an abstract class
                if ((obj instanceof Node || obj instanceof Connector) &&
                    (obj.shape.type !== 'SwimLane' || (obj.children && obj.children.length > 0))) {
                    this.setZIndex(layer, obj);
                }
            }
            if (obj instanceof Node) {
                if (independentObj) {
                    // 939249: Duplicate Ports Added to Group After Grouping and Undoing.
                    if (obj.id !== 'helper' && !(this.diagramActions & DiagramAction.UndoRedo)) {
                        var getDefaults = getFunction(this.getNodeDefaults);
                        if (getDefaults) {
                            var defaults = getDefaults(obj, this);
                            if (defaults && defaults.ports) {
                                for (var i = 0; i < defaults.ports.length; i++) {
                                    defaults.ports[parseInt(i.toString(), 10)].inEdges = [];
                                    defaults.ports[parseInt(i.toString(), 10)].outEdges = [];
                                }
                            }
                            if (defaults && defaults !== obj) {
                                extendObject(defaults, obj);
                            }
                        }
                    }
                    this.initNode(obj, this.element.id);
                }
            }
            else if (obj instanceof Connector) {
                var getDefaults = getFunction(this.getConnectorDefaults);
                if (getDefaults) {
                    var defaults = getDefaults(obj, this);
                    if (defaults && defaults !== obj) {
                        extendObject(defaults, obj);
                    }
                    if (obj.segments.length) {
                        if (obj.type !== obj.segments[0].type) {
                            obj.segments = [];
                        }
                    }
                }
                var sourceNode = this.nameTable[obj.sourceID];
                var targetNode = this.nameTable[obj.targetID];
                var port = this.getConnectedPort(sourceNode, obj, true);
                var targetPort = this.getConnectedPort(targetNode, obj);
                var outPort = this.findInOutConnectPorts(sourceNode, false);
                var inPort = this.findInOutConnectPorts(targetNode, true);
                if ((sourceNode !== undefined && canOutConnect(sourceNode)) || (obj.sourcePortID !== ''
                    && canPortOutConnect(outPort))) {
                    obj.sourceWrapper = this.getEndNodeWrapper(sourceNode, obj, true);
                    if (obj.sourcePortID) {
                        // eslint-disable-next-line max-len
                        if (port && port.constraints && !(port.constraints & PortConstraints.None) && (port.constraints & PortConstraints.OutConnect)) {
                            obj.sourcePortWrapper = this.getWrapper(sourceNode.wrapper, obj.sourcePortID);
                        }
                    }
                }
                if ((targetNode !== undefined && canInConnect(targetNode)) || (obj.targetPortID !== ''
                    && canPortInConnect(inPort))) {
                    obj.targetWrapper = this.getEndNodeWrapper(targetNode, obj, false);
                    if (obj.targetPortID) {
                        // eslint-disable-next-line max-len
                        if (targetPort && targetPort.constraints && !(targetPort.constraints & PortConstraints.None) && (targetPort.constraints & PortConstraints.InConnect)) {
                            obj.targetPortWrapper = this.getWrapper(targetNode.wrapper, obj.targetPortID);
                        }
                    }
                }
                if (!independentObj) {
                    var points = obj.getConnectorPoints(obj.type);
                    updateConnector(obj, points);
                }
                if (independentObj) {
                    obj.init(this);
                }
                for (var k = 0; k < obj.wrapper.children.length; k++) {
                    if (this.pathTable[obj.wrapper.children[parseInt(k.toString(), 10)].data]) {
                        obj.wrapper.children[parseInt(k.toString(), 10)].absoluteBounds =
                            this.pathTable[obj.wrapper.children[parseInt(k.toString(), 10)].data].absoluteBounds;
                    }
                }
                obj.wrapper.measure(new Size(undefined, undefined));
                obj.wrapper.arrange(obj.wrapper.desiredSize);
                if (obj instanceof Connector && obj.type === 'Bezier') {
                    this.updateConnectorAnnotation(obj);
                    this.updateConnectorfixedUserHandles(obj);
                }
                for (var j = 0; j < obj.wrapper.children.length; j++) {
                    this.pathTable[obj.wrapper.children[parseInt(j.toString(), 10)].data] = {};
                    this.pathTable[obj.wrapper.children[parseInt(j.toString(), 10)].data].absoluteBounds =
                        obj.wrapper.children[parseInt(j.toString(), 10)].absoluteBounds;
                }
            }
            if (obj instanceof Node && obj.children && obj.container) {
                for (var i = 0; i < obj.children.length; i++) {
                    this.nameTable[obj.children[parseInt(i.toString(), 10)]].offsetX
                        = this.nameTable[obj.children[parseInt(i.toString(), 10)]].wrapper.offsetX;
                    this.nameTable[obj.children[parseInt(i.toString(), 10)]].offsetY
                        = this.nameTable[obj.children[parseInt(i.toString(), 10)]].wrapper.offsetY;
                }
            }
            // 908606: The nodes goes outside the subprocess while node rotation  Issue Fix
            if (obj instanceof Node && obj.shape &&
                obj.shape.shape === 'Activity' && obj.shape.activity.activity === 'SubProcess') {
                if (obj.shape.activity.subProcess.processes) {
                    var children = obj.shape.activity.subProcess.processes;
                    for (var i = 0; i < children.length; i++) {
                        if (this.nameTable[children[parseInt(i.toString(), 10)]]) {
                            this.nameTable[children[parseInt(i.toString(), 10)]].offsetX
                                = this.nameTable[children[parseInt(i.toString(), 10)]].wrapper.offsetX;
                            this.nameTable[children[parseInt(i.toString(), 10)]].offsetY
                                = this.nameTable[children[parseInt(i.toString(), 10)]].wrapper.offsetY;
                        }
                    }
                }
            }
            this.initObjectExtend(obj, layer, independentObj);
            this.nameTable[obj.id] = obj;
            if (!this.refreshing) {
                //To create text annotation node if we define shape annotations in parent node.
                if (obj.shape.annotations && obj.shape.annotations.length > 0) {
                    for (var i = 0; i < obj.shape.annotations.length
                        && obj.shape.annotations[parseInt(i.toString(), 10)].text; i++) {
                        this.getBPMNTextAnnotation(obj, this, obj.shape.annotations[parseInt(i.toString(), 10)], false);
                    }
                }
            }
            if (obj instanceof Node && obj.children) {
                this.preventNodesUpdate = true;
                this.preventConnectorsUpdate = true;
                if (!group && !obj.container) {
                    this.updateGroupOffset(obj, true);
                }
                this.groupTable[obj.id] = obj.children;
                for (var i = 0; i < obj.children.length; i++) {
                    var node = (this.nameTable[obj.children[parseInt(i.toString(), 10)]]);
                    if (node) {
                        node.parentId = obj.id;
                    }
                }
                // 941671: Undo not functioning correctly after Group, Rotate, and Ungroup Actions in Diagram
                if (!this.isLoading && obj.rotateAngle && !obj.container && !this.isUndo) {
                    this.commandHandler.rotateObjects(obj, [obj], obj.rotateAngle, { x: obj.offsetX, y: obj.offsetY }, false);
                }
                this.preventNodesUpdate = false;
                this.preventConnectorsUpdate = false;
            }
            if (this['enterObject'] === undefined) {
                this.updateQuad(obj);
            }
        }
        if (obj.visible === false) {
            this.updateElementVisibility(obj.wrapper, obj, false);
        }
    };
    /* tslint:enable */
    Diagram.prototype.getConnectedPort = function (node, connector, isSource) {
        if (node && node.ports) {
            for (var _i = 0, _a = node.ports; _i < _a.length; _i++) {
                var port = _a[_i];
                if (port.id === connector.sourcePortID && isSource) {
                    return port;
                }
                else if (port.id === connector.targetPortID && !isSource) {
                    return port;
                }
            }
        }
        return null;
    };
    Diagram.prototype.scaleObject = function (obj, size, isWidth) {
        var actualSize = isWidth ? obj.wrapper.actualSize.width : obj.wrapper.actualSize.height;
        var sw = (isWidth) ? 1 + ((size - actualSize) / actualSize) : 1;
        var sh = (isWidth) ? 1 : 1 + ((size - actualSize) / actualSize);
        //const groupOffsetX: number = obj.offsetX; const groupOffsetY: number = obj.offsetY;
        this.realActions |= RealAction.PreventDrag;
        this.scale(obj, sw, sh, { x: 0.5, y: 0.5 });
        this.realActions &= ~RealAction.PreventDrag;
    };
    Diagram.prototype.updateDefaultLayoutIcons = function (node) {
        if (this.layout.type === 'OrganizationalChart' || this.layout.type === 'HierarchicalTree' ||
            this.layout.type === 'ComplexHierarchicalTree') {
            {
                this.updateDefaultLayoutIcon(node, node.expandIcon);
                this.updateDefaultLayoutIcon(node, node.collapseIcon);
            }
        }
    };
    Diagram.prototype.updateDefaultLayoutIcon = function (node, icon) {
        if (icon.shape !== 'None') {
            if (icon.horizontalAlignment === 'Auto' && icon.verticalAlignment === 'Auto' &&
                icon.offset.x === .5 && icon.offset.y === 1) {
                var iconWrapper = this.getWrapper(node.wrapper, 'icon_content');
                var offsetX = void 0;
                var offsetY = void 0;
                if (this.layout.orientation === 'TopToBottom' || this.layout.orientation === 'BottomToTop') {
                    offsetX = .5;
                    offsetY = this.layout.orientation === 'TopToBottom' ? 1 : 0;
                }
                else if (this.layout.orientation === 'RightToLeft' || this.layout.orientation === 'LeftToRight') {
                    offsetX = this.layout.orientation === 'LeftToRight' ? 1 : 0;
                    offsetY = .5;
                }
                iconWrapper.setOffsetWithRespectToBounds(offsetX, offsetY, 'Fraction');
                iconWrapper.horizontalAlignment = 'Center';
                iconWrapper.verticalAlignment = 'Center';
                node.wrapper.measure(new Size(node.wrapper.width, node.wrapper.height));
                node.wrapper.arrange(node.wrapper.desiredSize);
            }
        }
    };
    /**
     * updateGroupOffset method \
     *
     * @returns { void }     updateGroupOffset method .\
     * @param {NodeModel | ConnectorModel} node - provide the source value.
     * @param {boolean} isUpdateSize - provide the target value.
     *
     * @private
     */
    Diagram.prototype.updateGroupOffset = function (node, isUpdateSize) {
        if ((node.children && node.children.length > 0 && (!node.container)) || (node.processId)) {
            var node1 = this.nameTable[node.id];
            if (!(this.realActions & RealAction.PreventScale) && !(this.realActions & RealAction.PreventDrag)) {
                if (node1.offsetX && ((this.realActions & RealAction.EnableGroupAction) ||
                    ((!(this.diagramActions & DiagramAction.UndoRedo)) && (!(this.diagramActions & DiagramAction.ToolAction)
                        && !(this.diagramActions & DiagramAction.PublicMethod))))) {
                    this.realActions |= RealAction.PreventScale;
                    var diffX = (node1.offsetX - node.wrapper.offsetX);
                    node1.offsetX = node.wrapper.offsetX;
                    var diffY = (node1.offsetY - node.wrapper.offsetY);
                    node1.offsetY = node.wrapper.offsetY;
                    if ((diffX + diffY) !== 0) {
                        this.drag(node1, diffX, diffY);
                    }
                    this.realActions &= ~RealAction.PreventScale;
                }
                else {
                    //Removed isBlazor code
                    node1.offsetX = node.wrapper.offsetX;
                }
                if (node1.offsetY && ((this.realActions & RealAction.EnableGroupAction) ||
                    ((!(this.diagramActions & DiagramAction.UndoRedo)) && (!(this.diagramActions & DiagramAction.ToolAction)
                        && !(this.diagramActions & DiagramAction.PublicMethod))))) {
                    this.realActions |= RealAction.PreventScale;
                    var diffY = (node1.offsetY - node.wrapper.offsetY);
                    node1.offsetY = node.wrapper.offsetY;
                    this.drag(node1, 0, diffY);
                    this.realActions &= ~RealAction.PreventScale;
                }
                else {
                    //Removed isBlazor code
                    node1.offsetY = node.wrapper.offsetY;
                }
                if (this.diagramActions) {
                    //Removed isBlazor code
                    node1.width = node.wrapper.actualSize.width;
                    node1.height = node.wrapper.actualSize.height;
                }
            }
        }
        if ((node) && node.annotations && node.annotations.length > 0) {
            node.wrapper.children.forEach(function (wrapperChild) {
                if (wrapperChild instanceof Canvas) {
                    wrapperChild.children.forEach(function (child) {
                        if (child && child instanceof TextElement) {
                            child.refreshTextElement();
                        }
                    });
                }
            });
            node.wrapper.measure(new Size(node.width, node.height), node.id, this.onLoadImageSize.bind(this));
            node.wrapper.arrange(node.wrapper.desiredSize);
        }
        if (isUpdateSize) {
            if ((node.children && node.children.length > 0)) {
                if (this.nameTable[node.id].width !== undefined) {
                    this.scaleObject(node, this.nameTable[node.id].width, true);
                }
                else {
                    //Removed isBlazor code
                    this.nameTable[node.id].width = node.wrapper.actualSize.width;
                }
                if (this.nameTable[node.id].height !== undefined) {
                    this.scaleObject(node, this.nameTable[node.id].height, false);
                }
                else {
                    //Removed isBlazor code
                    this.nameTable[node.id].height = node.wrapper.actualSize.height;
                }
            }
        }
        //Removed Blazor code
    };
    /* eslint-disable */
    Diagram.prototype.initNode = function (obj, diagramId, group) {
        var canvas = obj.initContainer();
        var portContainer = new Canvas();
        var content;
        if (!this.diagramSettings.inversedAlignment) {
            canvas.inversedAlignment = false;
        }
        if (!canvas.children) {
            canvas.children = [];
        }
        if (obj.children) {
            canvas.measureChildren = false;
            portContainer.id = obj.id + 'group_container';
            // Bug 853721: Grid lines remain hidden when lane fill is set to transparent.
            // Added below code to set swimlane fill while dragging from palette to diagram.
            if (obj.shape && obj.shape.type === 'SwimLane') {
                portContainer.style.fill = obj.style.fill;
            }
            else {
                portContainer.style.fill = 'none';
            }
            portContainer.style.strokeColor = 'none';
            portContainer.horizontalAlignment = 'Stretch';
            portContainer.verticalAlignment = 'Stretch';
            //EJ2-865476 - Issue with Pivot Point in group node during resizing
            portContainer.pivot = obj.pivot;
            canvas.style = obj.style;
            canvas.padding.left = obj.padding.left;
            canvas.padding.right = obj.padding.right;
            canvas.padding.top = obj.padding.top;
            canvas.padding.bottom = obj.padding.bottom;
            portContainer.children = [];
            portContainer.preventContainer = true;
            if (obj.container) {
                portContainer.relativeMode = 'Object';
            }
            if (obj.container && (obj.container.type === 'Grid')) {
                for (var i = 0; i < obj.children.length; i++) {
                    var childCollection = new Canvas();
                    var child = this.nameTable[obj.children[i]];
                    childCollection.children = [];
                    childCollection.children.push(child.wrapper);
                    if (child) {
                        canvas.addObject(child.wrapper, child.rowIndex, child.columnIndex, child.rowSpan, child.columnSpan);
                    }
                }
            }
            else {
                for (var i = 0; i < obj.children.length; i++) {
                    if (this.nameTable[obj.children[i]]) {
                        var child = this.nameTable[obj.children[i]];
                        this.updateStackProperty(obj, child, i);
                        canvas.children.push(child.wrapper);
                        canvas.elementActions = canvas.elementActions | ElementAction.ElementIsGroup;
                        child.wrapper.flip = child.wrapper.flip ^=
                            obj.wrapper.flip;
                    }
                }
            }
            if (isNullOrUndefined(obj.container) ||
                (obj.container && (obj.container.type !== 'Grid'))) {
                canvas.children.push(portContainer);
            }
        }
        else {
            var setNodeTemplate = getFunction(this.setNodeTemplate);
            if (setNodeTemplate && obj.id !== 'helper') {
                content = setNodeTemplate(obj, this);
            }
            if (!content) {
                content = obj.init(this);
            }
            canvas.children.push(content);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var wrapperContent;
        wrapperContent = getFunction(this.getDescription);
        if (wrapperContent) {
            (obj.children ? canvas : content).description = wrapperContent;
        }
        else {
            (obj.children ? canvas : content).description = obj.annotations.length ? obj.annotations[0].content : obj.id;
        }
        var container = obj.children ? portContainer : canvas;
        obj.initAnnotations(this.getDescription, container, this.element.id, canVitualize(this) ? true : false, this.annotationTemplate);
        obj.initPorts(this.getDescription, container);
        obj.initIcons(this.getDescription, this.layout, container, diagramId);
        for (var i = 0; obj.fixedUserHandles !== undefined, i < obj.fixedUserHandles.length; i++) {
            var fixedUserHandles = obj.initFixedUserHandles(obj.fixedUserHandles[i], this.fixedUserHandleTemplate, this.element.id);
            container.children.push(fixedUserHandles);
        }
        if (obj.shape.type === 'SwimLane' && obj.wrapper && obj.wrapper.children.length > 0 &&
            obj.wrapper.children[0] instanceof GridPanel) {
            this.setZIndex(this.activeLayer, obj);
            if (this.connectors.length > 0) {
                for (var i = 0; i < this.connectors.length; i++) {
                    var obj_1 = this.connectors[i];
                    if ((obj_1.sourceID && obj_1.targetID) && (this.activeLayer.objects.indexOf(obj_1.sourceID) === -1 &&
                        this.activeLayer.objects.indexOf(obj_1.targetID) === -1)) {
                        this.setZIndex(this.activeLayer, obj_1);
                    }
                }
            }
            swimLaneMeasureAndArrange(obj);
            arrangeChildNodesInSwimLane(this, obj);
            this.updateDiagramElementQuad();
        }
        else {
            canvas.measure(new Size(obj.width, obj.height), obj.id, this.onLoadImageSize.bind(this));
            if (canvas instanceof GridPanel) {
                canvas.arrange(canvas.desiredSize, true);
            }
            else {
                canvas.arrange(canvas.desiredSize);
            }
        }
        if (obj.wrapper.flip !== FlipDirection.None) {
            if (obj.children && obj.children.length > 0) {
                for (var i = 0; i < obj.children.length; i++) {
                    var node = this.nameTable[obj.children[i]];
                    if (node) {
                        if (!this.refreshing && !this.commandHandler.cloningInProgress && !(this.diagramActions & DiagramAction.UndoRedo)) {
                            node.flip ^= obj.flip;
                            node.flipMode = obj.flipMode;
                        }
                        if (node.flipMode !== 'None' && node.flipMode !== 'Label' && node.flipMode !== 'LabelText' && node.flipMode !== 'LabelAndLabelText') {
                            this.updatePorts(node, node.flip);
                        }
                        else {
                            this.updatePorts(node, FlipDirection.None);
                        }
                        this.applyWrapperFlip(node);
                        node.wrapper.measure(new Size(node.wrapper.bounds.width, node.wrapper.bounds.height), node.id, this.onLoadImageSize.bind(this));
                        node.wrapper.arrange(node.wrapper.desiredSize);
                    }
                }
                var groupWrapperCanvas = obj.wrapper.children[obj.wrapper.children.length - 1];
                groupWrapperCanvas.flip = obj.wrapper.flip;
                groupWrapperCanvas.flipMode = obj.wrapper.flipMode;
                for (var j = 0; j < groupWrapperCanvas.children.length; j++) {
                    var wrapperChild = groupWrapperCanvas.children[j];
                    if (wrapperChild instanceof TextElement) {
                        if (obj.flipMode !== 'Port' && obj.flipMode !== 'None') {
                            wrapperChild.flip = obj.wrapper.flip;
                            wrapperChild.flipMode = obj.wrapper.flipMode;
                        }
                    }
                }
                if (!this.refreshing && !this.commandHandler.cloningInProgress && !(this.diagramActions & DiagramAction.UndoRedo)) {
                    alignElement(obj.wrapper, obj.wrapper.offsetX, obj.wrapper.offsetY, this, obj.wrapper.flip, undefined, undefined, true);
                }
            }
            else {
                //To apply flip and flip mode for the text elements of node.
                this.applyWrapperFlip(obj);
            }
        }
        if (obj.shape.type === 'Bpmn') {
            if (obj.shape.shape === 'TextAnnotation') {
                var isbpmnTextConnector = false;
                for (var i = 0; i < this.connectors.length; i++) {
                    if (this.connectors[parseInt(i.toString(), 10)].id === (obj.id + "_connector")) {
                        this.connectors[parseInt(i.toString(), 10)].isBpmnAnnotationConnector = true;
                        isbpmnTextConnector = true;
                        break;
                    }
                }
                if (!isbpmnTextConnector) {
                    this.addBpmnAnnotationConnector(obj, canvas);
                }
            }
        }
        if (obj instanceof Node && obj.container && (obj.width < canvas.outerBounds.width || obj.height < canvas.outerBounds.height) &&
            canvas.bounds.x <= canvas.outerBounds.x && canvas.bounds.y <= canvas.outerBounds.y) {
            obj.width = canvas.width = canvas.outerBounds.width;
            obj.height = canvas.height = canvas.outerBounds.height;
            canvas.measure(new Size(obj.width, obj.height));
            canvas.arrange(canvas.desiredSize);
        }
        if (obj.container && obj.container.type === 'Grid' && obj.children && obj.children.length > 0) {
            this.updateChildPosition(obj);
        }
    };
    Diagram.prototype.applyWrapperFlip = function (obj) {
        obj.wrapper.flip = obj.flip;
        obj.wrapper.flipMode = obj.flipMode;
        obj.wrapper.children[0].flip = obj.flip;
        obj.wrapper.children[0].flipMode = obj.flipMode;
        for (var i = 0; i < obj.wrapper.children.length; i++) {
            var wrapperChild = obj.wrapper.children[i];
            if (wrapperChild instanceof Canvas) {
                //To update the flip and flipmode for the node wrapper childs.
                this.applyWrapperCanvasFlip(wrapperChild, obj);
            }
            else {
                wrapperChild.flip = obj.flip;
                wrapperChild.flipMode = obj.flipMode;
            }
        }
    };
    Diagram.prototype.applyWrapperCanvasFlip = function (wrapper, obj) {
        for (var i = 0; i < wrapper.children.length; i++) {
            var wrapperChild = wrapper.children[parseInt(i.toString(), 10)];
            if (wrapperChild instanceof Canvas) {
                this.applyWrapperCanvasFlip(wrapperChild, obj);
            }
            else if (obj.flipMode !== 'None') {
                wrapperChild.flip = obj.flip;
                wrapperChild.flipMode = obj.flipMode;
            }
        }
    };
    Diagram.prototype.addBpmnAnnotationConnector = function (node, wrapper) {
        if (node.parentObj instanceof Diagram || node.parentObj instanceof Lane) {
            var bpmnAnnotation = node.shape;
            var direction = bpmnAnnotation.textAnnotation.textAnnotationDirection;
            var hasTarget = (bpmnAnnotation.textAnnotation.textAnnotationTarget !== '' && this.nameTable[bpmnAnnotation.textAnnotation.textAnnotationTarget]);
            var targetNode = hasTarget ? this.nameTable[bpmnAnnotation.textAnnotation.textAnnotationTarget] : null;
            var targetWrapper = targetNode != null ? targetNode.wrapper : null;
            var port = node.ports[0];
            var sourcePoint = { x: 0, y: 0 };
            switch (direction) {
                case 'Left':
                    port.offset = { x: 0, y: 0.5 };
                    sourcePoint.x = wrapper.bounds.left - 40;
                    sourcePoint.y = wrapper.bounds.bottom + 30;
                    break;
                case 'Right':
                    port.offset = { x: 1, y: 0.5 };
                    sourcePoint.x = wrapper.bounds.right + 40;
                    sourcePoint.y = wrapper.bounds.bottom + 30;
                    break;
                case 'Top':
                    port.offset = { x: 0.5, y: 0 };
                    sourcePoint.x = wrapper.bounds.right + 30;
                    sourcePoint.y = wrapper.bounds.top - 40;
                    break;
                case 'Bottom':
                    port.offset = { x: 0.5, y: 1 };
                    sourcePoint.x = wrapper.bounds.right + 30;
                    sourcePoint.y = wrapper.bounds.bottom + 40;
                    break;
                default:
                    port.offset = { x: 0, y: 0.5 };
                    sourcePoint.x = wrapper.bounds.left - 40;
                    sourcePoint.y = wrapper.bounds.bottom + 30;
                    if (hasTarget && wrapper != null && targetWrapper != null) {
                        if (wrapper.bounds.left > targetWrapper.bounds.right) {
                            port.offset = { x: 0, y: 0.5 };
                        }
                        else if (wrapper.bounds.right < targetWrapper.bounds.left) {
                            port.offset = { x: 1, y: 0.5 };
                        }
                        else if (wrapper.bounds.bottom > targetWrapper.bounds.top) {
                            port.offset = { x: 0.5, y: 0 };
                        }
                        else if (wrapper.bounds.top < targetWrapper.bounds.bottom) {
                            port.offset = { x: 0.5, y: 1 };
                        }
                    }
                    break;
            }
            var connector = new Connector(this, 'connectors', {
                id: node.id + "_connector",
                targetID: node.id,
                targetPortID: port.id,
                type: 'Straight',
                shape: {
                    type: "Bpmn", flow: 'Association'
                },
                constraints: ConnectorConstraints.Default & ~(ConnectorConstraints.DragTargetEnd | ConnectorConstraints.Delete),
                isBpmnAnnotationConnector: true,
            }, true);
            if (hasTarget) {
                connector.sourceID = bpmnAnnotation.textAnnotation.textAnnotationTarget;
            }
            else {
                connector.sourcePoint = sourcePoint;
            }
            var oldProtectOnChange = this.isProtectedOnChange;
            this.isProtectedOnChange = true;
            node.constraints |= NodeConstraints.InConnect;
            this.connectors.push(connector);
            if (!(this.bpmnModule).bpmnTextAnnotationConnector) {
                (this.bpmnModule).bpmnTextAnnotationConnector = [];
            }
            (this.bpmnModule).bpmnTextAnnotationConnector.push(connector);
            var shadowSet = (node.constraints & NodeConstraints.Shadow) !== 0;
            var allowMovingSet = (node.constraints & NodeConstraints.AllowMovingOutsideLane) !== 0;
            node.constraints = NodeConstraints.Default & ~(NodeConstraints.OutConnect | NodeConstraints.InConnect);
            if (shadowSet) {
                node.constraints |= NodeConstraints.Shadow;
            }
            if (allowMovingSet) {
                node.constraints |= NodeConstraints.AllowMovingOutsideLane;
            }
            this.isProtectedOnChange = oldProtectOnChange;
        }
    };
    /** @private */
    Diagram.prototype.getBPMNTextAnnotation = function (node, diagram, annotation, isDynamic) {
        // create new text annotation node
        var obj = {
            id: annotation.id || randomId(),
            height: annotation.height || 100,
            width: annotation.width || 100,
            annotations: [{ id: (annotation.id ? annotation.id : randomId()) + annotation.text, content: annotation.text }],
            offsetX: node.offsetX + annotation.length *
                Math.cos(annotation.angle * (Math.PI / 180)),
            offsetY: node.offsetY + annotation.length *
                Math.sin(annotation.angle * (Math.PI / 180)),
            shape: { type: 'Bpmn', shape: 'TextAnnotation', textAnnotation: { textAnnotationDirection: 'Auto', textAnnotationTarget: node.id } },
            constraints: NodeConstraints.Default & ~(NodeConstraints.OutConnect | NodeConstraints.InConnect)
        };
        var parentBounds = node.wrapper.bounds;
        var position = { x: obj.offsetX, y: obj.offsetY };
        var direction = getPortDirection(position, parentBounds, parentBounds);
        var segment;
        switch (direction) {
            case 'Right':
                segment = {
                    x1: parentBounds.right, y1: parentBounds.top,
                    x2: parentBounds.right, y2: parentBounds.bottom
                };
                break;
            case 'Left':
                segment = {
                    x1: parentBounds.left, y1: parentBounds.top,
                    x2: parentBounds.left, y2: parentBounds.bottom
                };
                break;
            case 'Bottom':
                segment = {
                    x1: parentBounds.right, y1: parentBounds.bottom,
                    x2: parentBounds.left, y2: parentBounds.bottom
                };
                break;
            case 'Top':
                segment = {
                    x1: parentBounds.right, y1: parentBounds.top,
                    x2: parentBounds.left, y2: parentBounds.top
                };
                break;
        }
        var center = parentBounds.center;
        var endPoint = Point.transform(position, annotation.angle, Math.max(parentBounds.width, parentBounds.height));
        var point = getIntersectionPoints(segment, [center, endPoint], false, center);
        if (annotation.length !== undefined && annotation.angle !== undefined && point) {
            point = Point.transform(point, annotation.angle, annotation.length);
            obj.offsetX = point.x;
            obj.offsetY = point.y;
        }
        if (direction === 'Right') {
            obj.offsetX += obj.width / 2;
        }
        else if (direction === 'Left') {
            obj.offsetX -= obj.width / 2;
        }
        else if (direction === 'Bottom') {
            obj.offsetY += obj.height / 2;
        }
        else {
            obj.offsetY -= obj.height / 2;
        }
        if (isDynamic) {
            this.add(obj);
        }
        else {
            var bpmnTextNode = new Node(this, 'nodes', obj, true);
            diagram.initObject(bpmnTextNode, undefined, undefined, true);
            diagram.nodes.push(bpmnTextNode);
        }
    };
    /* eslint-enable */
    /**
     * updateDiagramElementQuad method \
     *
     * @returns { void }     updateDiagramElementQuad method .\
     *
     * @private
     */
    Diagram.prototype.updateDiagramElementQuad = function () {
        for (var i = 0; i < this.nodes.length; i++) {
            if (this.nodes[parseInt(i.toString(), 10)].wrapper && (this.nodes[parseInt(i.toString(), 10)].wrapper instanceof Container)) {
                this.updateQuad(this.nodes[parseInt(i.toString(), 10)]);
            }
        }
    };
    Diagram.prototype.onLoadImageSize = function (id, size) {
        var obj = this.getObject(id);
        var image = document.getElementById(id + 'sf-imageNode');
        if (image) {
            image.parentNode.removeChild(image);
        }
        this.nodePropertyChange(obj, {}, { width: size.width, height: size.height });
        var args = { element: cloneObject(obj), size: size };
        this.triggerEvent(DiagramEvent.onImageLoad, args);
    };
    Diagram.prototype.updateChildPosition = function (obj) {
        for (var i = 0; i < obj.children.length; i++) {
            var child = this.getObject(obj.children[parseInt(i.toString(), 10)]);
            child.offsetX = child.wrapper.offsetX;
            child.offsetY = child.wrapper.offsetY;
            if (child.children && child.children.length > 0) {
                this.updateChildPosition(child);
            }
        }
    };
    Diagram.prototype.canExecute = function () {
        return true;
    };
    Diagram.prototype.updateStackProperty = function (obj, child, index) {
        if (obj.container && obj.container.type === 'Stack') {
            if (!child.width) {
                child.wrapper.horizontalAlignment = 'Stretch';
                child.horizontalAlignment = 'Stretch';
            }
            if (!child.height) {
                child.verticalAlignment = 'Stretch';
                child.wrapper.verticalAlignment = 'Stretch';
            }
            if (index && obj.shape.type === 'UmlClassifier') {
                child.umlIndex = index;
            }
        }
    };
    Diagram.prototype.initViews = function () {
        if (!this.isLoading) {
            this.views.push(this.element.id);
            this.views[this.element.id] = this;
        }
    };
    Diagram.prototype.initCommands = function () {
        var newCommands = this.commandManager.commands;
        var commands = {
            'copy': {
                execute: this.copyCommand.bind(this), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.C, keyModifiers: KeyModifiers.Control }
            },
            'paste': {
                execute: this.pasteCommand.bind(this), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.V, keyModifiers: KeyModifiers.Control }
            },
            'cut': {
                execute: this.cutCommand.bind(this), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.X, keyModifiers: KeyModifiers.Control }
            },
            'delete': {
                execute: this.removeCommand.bind(this), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.Delete }
            },
            'selectAll': {
                execute: this.selectAll.bind(this), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.A, keyModifiers: KeyModifiers.Control }
            },
            'undo': {
                execute: this.undo.bind(this), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.Z, keyModifiers: KeyModifiers.Control }
            },
            'redo': {
                execute: this.redo.bind(this), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.Y, keyModifiers: KeyModifiers.Control }
            },
            'nudgeUp': {
                execute: this.nudgeCommand.bind(this, 'Up'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.Up },
                parameter: 'up'
            },
            'nudgeRight': {
                execute: this.nudgeCommand.bind(this, 'Right'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.Right },
                parameter: 'right'
            },
            'nudgeDown': {
                execute: this.nudgeCommand.bind(this, 'Down'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.Down },
                parameter: 'down'
            },
            'nudgeLeft': {
                execute: this.nudgeCommand.bind(this, 'Left'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.Left },
                parameter: 'left'
            },
            'startEdit': {
                execute: this.startEditCommad.bind(this),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.F2 }
            },
            'endEdit': {
                execute: this.endEditCommand.bind(this),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.Escape }
            },
            //EJ2-866418-keyboard shortcut keys
            'focusToNextItem': {
                execute: this.navigateItems.bind(this, true),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.Tab }
            },
            'focusToPreviousItem': {
                execute: this.navigateItems.bind(this, false), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.Tab, keyModifiers: KeyModifiers.Shift }
            },
            'selectFocusedItem': {
                execute: this.startEditCommad.bind(this),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.Enter }
            },
            'bold': {
                execute: this.fontStyleCommand.bind(this, 'bold'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.B, keyModifiers: KeyModifiers.Control }
            },
            'italic': {
                execute: this.fontStyleCommand.bind(this, 'italic'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.I, keyModifiers: KeyModifiers.Control }
            },
            'underline': {
                execute: this.fontStyleCommand.bind(this, 'underline'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.U, keyModifiers: KeyModifiers.Control }
            },
            'duplicate': {
                execute: this.duplicateCommand.bind(this), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.D, keyModifiers: KeyModifiers.Control }
            },
            'group': {
                execute: this.groupCommand.bind(this, 'group'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.G, keyModifiers: KeyModifiers.Control }
            },
            'ungroup': {
                execute: this.groupCommand.bind(this, 'ungroup'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.U, keyModifiers: KeyModifiers.Control | KeyModifiers.Shift }
            },
            'rotateClockwise': {
                execute: this.rotateCommand.bind(this, 'clockwise'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.R, keyModifiers: KeyModifiers.Control }
            },
            'rotateAntiClockwise': {
                execute: this.rotateCommand.bind(this, 'antiClockwise'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.L, keyModifiers: KeyModifiers.Control }
            },
            'flipHorizontal': {
                execute: this.flipCommand.bind(this, 'horizontal'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.H, keyModifiers: KeyModifiers.Control }
            },
            'flipVertical': {
                execute: this.flipCommand.bind(this, 'vertical'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.J, keyModifiers: KeyModifiers.Control }
            },
            'pointerTool': {
                execute: this.toolCommand.bind(this, 'pointer'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.Number1, keyModifiers: KeyModifiers.Control }
            },
            'textTool': {
                execute: this.toolCommand.bind(this, 'text'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.Number2, keyModifiers: KeyModifiers.Control }
            },
            'connectTool': {
                execute: this.toolCommand.bind(this, 'connect'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.Number3, keyModifiers: KeyModifiers.Control }
            },
            'freeForm': {
                execute: this.toolCommand.bind(this, 'freeForm'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.Number5, keyModifiers: KeyModifiers.Control }
            },
            'lineTool': {
                execute: this.toolCommand.bind(this, 'line'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.Number6, keyModifiers: KeyModifiers.Control }
            },
            'rectangleTool': {
                execute: this.toolCommand.bind(this, 'rectangle'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.Number8, keyModifiers: KeyModifiers.Control }
            },
            'ellipseTool': {
                execute: this.toolCommand.bind(this, 'ellipse'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.Number9, keyModifiers: KeyModifiers.Control }
            },
            'zoomIn': {
                execute: this.zoomCommand.bind(this, 'zoomIn'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.Plus, keyModifiers: KeyModifiers.Control }
            },
            'zoomOut': {
                execute: this.zoomCommand.bind(this, 'zoomOut'), canExecute: this.canExecute.bind(this),
                gesture: { key: Keys.Minus, keyModifiers: KeyModifiers.Control }
            },
            'shiftUp': {
                execute: this.shiftCommand.bind(this, 'Up'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.Up, keyModifiers: KeyModifiers.Shift }
            },
            'shiftDown': {
                execute: this.shiftCommand.bind(this, 'Down'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.Down, keyModifiers: KeyModifiers.Shift }
            },
            'shiftLeft': {
                execute: this.shiftCommand.bind(this, 'Left'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.Left, keyModifiers: KeyModifiers.Shift }
            },
            'shiftRight': {
                execute: this.shiftCommand.bind(this, 'Right'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.Right, keyModifiers: KeyModifiers.Shift }
            },
            'alignTextCenter': {
                execute: this.alignCommand.bind(this, 'center'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.C, keyModifiers: KeyModifiers.Control | KeyModifiers.Shift }
            },
            'alignTextLeft': {
                execute: this.alignCommand.bind(this, 'right'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.L, keyModifiers: KeyModifiers.Control | KeyModifiers.Shift }
            },
            'alignTextRight': {
                execute: this.alignCommand.bind(this, 'left'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.R, keyModifiers: KeyModifiers.Control | KeyModifiers.Shift }
            },
            'alignTextTop': {
                execute: this.alignCommand.bind(this, 'top'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.E, keyModifiers: KeyModifiers.Control | KeyModifiers.Shift }
            },
            'alignTextCenterVertical': {
                execute: this.alignCommand.bind(this, 'centerVertical'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.M, keyModifiers: KeyModifiers.Control | KeyModifiers.Shift }
            },
            'alignTextBottom': {
                execute: this.alignCommand.bind(this, 'bottom'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.V, keyModifiers: KeyModifiers.Control | KeyModifiers.Shift }
            },
            'alignJustify': {
                execute: this.alignCommand.bind(this, 'justify'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.J, keyModifiers: KeyModifiers.Control | KeyModifiers.Shift }
            },
            'sendToBack': {
                execute: this.orderCommand.bind(this, 'sendToBack'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.B, keyModifiers: KeyModifiers.Control | KeyModifiers.Shift }
            },
            'bringToFront': {
                execute: this.orderCommand.bind(this, 'bringToFront'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.F, keyModifiers: KeyModifiers.Control | KeyModifiers.Shift }
            },
            'sendBackward': {
                execute: this.orderCommand.bind(this, 'sendBackward'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.BracketLeft, keyModifiers: KeyModifiers.Control }
            },
            'bringForward': {
                execute: this.orderCommand.bind(this, 'bringForward'),
                canExecute: this.canExecute.bind(this), gesture: { key: Keys.BracketRight, keyModifiers: KeyModifiers.Control }
            }
        };
        this.initCommandManager(newCommands, commands);
    };
    Diagram.prototype.overrideCommands = function (newCommand, commands) {
        var command;
        for (var _i = 0, _a = Object.keys(commands); _i < _a.length; _i++) {
            var key = _a[_i];
            command = commands["" + key];
            if (newCommand.gesture.key === command.gesture.key && newCommand.gesture.keyModifiers === command.gesture.keyModifiers) {
                delete commands["" + key];
                break;
            }
        }
    };
    Diagram.prototype.initCommandManager = function (newCommands, commands) {
        var i = 0;
        if (newCommands) {
            for (i = 0; i < newCommands.length; i++) {
                if (commands[newCommands[parseInt(i.toString(), 10)].name] && newCommands[parseInt(i.toString(), 10)]) {
                    if (newCommands[parseInt(i.toString(), 10)].canExecute) {
                        commands[newCommands[parseInt(i.toString(), 10)].name].canExecute
                            = newCommands[parseInt(i.toString(), 10)].canExecute;
                    }
                    if (newCommands[parseInt(i.toString(), 10)].execute) {
                        commands[newCommands[parseInt(i.toString(), 10)].name].execute
                            = newCommands[parseInt(i.toString(), 10)].execute;
                    }
                    if (newCommands[parseInt(i.toString(), 10)].gesture.key
                        || newCommands[parseInt(i.toString(), 10)].gesture.keyModifiers) {
                        commands[newCommands[parseInt(i.toString(), 10)].name].gesture
                            = newCommands[parseInt(i.toString(), 10)].gesture;
                    }
                    if (newCommands[parseInt(i.toString(), 10)].parameter !== '') {
                        commands[newCommands[parseInt(i.toString(), 10)].name].parameter
                            = newCommands[parseInt(i.toString(), 10)].parameter;
                    }
                }
                else {
                    this.overrideCommands(newCommands[parseInt(i.toString(), 10)], commands);
                    commands[newCommands[parseInt(i.toString(), 10)].name] = {
                        execute: newCommands[parseInt(i.toString(), 10)].execute,
                        canExecute: newCommands[parseInt(i.toString(), 10)].canExecute,
                        gesture: newCommands[parseInt(i.toString(), 10)].gesture,
                        parameter: newCommands[parseInt(i.toString(), 10)].parameter
                    };
                }
            }
        }
        this.commands = commands;
    };
    /**
     * updateNodeEdges method \
     *
     * @returns { void }     updateNodeEdges method .\
     * @param {Node} node - provide the source value.
     *
     * @private
     */
    Diagram.prototype.updateNodeEdges = function (node) {
        for (var _i = 0, _a = node.inEdges; _i < _a.length; _i++) {
            var edge = _a[_i];
            if (this.nameTable["" + edge]) {
                this.nameTable["" + edge].targetID = '';
            }
        }
        for (var _b = 0, _c = node.outEdges; _b < _c.length; _b++) {
            var edge = _c[_b];
            if (this.nameTable["" + edge]) {
                this.nameTable["" + edge].sourceID = '';
            }
        }
        node.inEdges = [];
        node.outEdges = [];
    };
    /**
     * updateIconVisibility method \
     *
     * @returns { void }     updateIconVisibility method .\
     * @param {Node} node - provide the source value.
     * @param {boolean} visibility - provide the source value.
     *
     * @private
     */
    Diagram.prototype.updateIconVisibility = function (node, visibility) {
        for (var i = 0; i < node.wrapper.children.length; i++) {
            var child = node.wrapper.children[parseInt(i.toString(), 10)];
            if (child.id) {
                var id = child.id.split(node.id)[1];
                if (id && id.match('^_icon')) {
                    child.visible = visibility;
                    this.updateDiagramContainerVisibility(child, visibility);
                }
            }
        }
    };
    /**
     * updateEdges method \
     *
     * @returns { void }     updateEdges method .\
     * @param {Connector} obj - provide the source value.
     *
     * @private
     */
    Diagram.prototype.updateEdges = function (obj) {
        if (obj.sourceID !== undefined && obj.sourceID !== '') {
            var object = this.nameTable[obj.sourceID];
            if (object && object.outEdges && object.outEdges.length === 0) {
                object.outEdges = [];
            }
            if (object && object.outEdges && object.outEdges.indexOf(obj.id) === -1) {
                object.outEdges.push(obj.id);
            }
            this.updatePortEdges(object, obj, false);
        }
        if (obj.targetID !== undefined && obj.targetID !== '') {
            var node = this.nameTable[obj.targetID];
            if (node && node.inEdges && node.inEdges.length === 0) {
                node.inEdges = [];
            }
            if (node && node.inEdges && node.inEdges.indexOf(obj.id) === -1) {
                node.inEdges.push(obj.id);
            }
            this.updatePortEdges(node, obj, true);
            if (node && node.visible && node.outEdges) {
                var value = node.outEdges.length === 0 ? false : true;
                this.updateIconVisibility(node, value);
            }
        }
    };
    /**
     * updatePortEdges method \
     *
     * @returns { void }     updatePortEdges method .\
     * @param {NodeModel} node - provide the source value.
     * @param {ConnectorModel} obj - provide the target value.
     * @param {boolean} isInEdges - provide the layoutOrientation value.
     *
     * @private
     */
    Diagram.prototype.updatePortEdges = function (node, obj, isInEdges) {
        if (node) {
            for (var i = 0; i < node.ports.length; i++) {
                var port = node.ports[parseInt(i.toString(), 10)];
                var portId = (isInEdges) ? obj.targetPortID : obj.sourcePortID;
                if (port.id === portId) {
                    var portEdges = (isInEdges) ? port.inEdges : port.outEdges;
                    if (portEdges.indexOf(obj.id) === -1) {
                        portEdges.push(obj.id);
                    }
                }
            }
        }
    };
    /**
     * refreshDiagram method \
     *
     * @returns { void }     refreshDiagram method .\
     *
     * @private
     */
    Diagram.prototype.refreshDiagram = function () {
        this.initLayerObjects();
        this.doLayout();
        this.updateBridging();
        this.scroller.setSize();
        this.addBlazorDiagramObjects();
        //Removed isBlazor code
        this.updateFitToPage();
    };
    Diagram.prototype.updateCanupdateStyle = function (element, value) {
        for (var j = 0; j < element.length; j++) {
            if (element[parseInt(j.toString(), 10)].children) {
                this.updateCanupdateStyle(element[parseInt(j.toString(), 10)].children, value);
            }
            element[parseInt(j.toString(), 10)].canApplyStyle = value;
        }
    };
    Diagram.prototype.getZindexPosition = function (obj, viewId) {
        var objects = [];
        var index = undefined;
        objects = objects.concat(this.nodes);
        objects = objects.concat(this.connectors);
        var type;
        var greaterIndex;
        if (obj.children) {
            greaterIndex = this.commandHandler.findMaxZIndex(obj);
        }
        else {
            greaterIndex = obj.zIndex;
        }
        if (obj.zIndex !== Number.MIN_VALUE) {
            for (var i = 0; i < objects.length; i++) {
                if (objects[parseInt(i.toString(), 10)].zIndex > greaterIndex) {
                    if (obj.shape.type === 'HTML' || obj.shape.type === 'Native') {
                        type = obj.shape.type === 'HTML' ? 'html' : 'native';
                    }
                    index = getDomIndex(viewId, objects[parseInt(i.toString(), 10)].id, type);
                    break;
                }
            }
        }
        return index;
    };
    /**
     *updateDiagramObject method \
     *
     * @returns { void } updateDiagramObject method .\
     * @param { (NodeModel | ConnectorModel) } obj - provide the obj value.
     * @param { boolean } canIgnoreIndex - provide the canIgnoreIndex value.
     * @param { boolean } isUpdateObject - provide the isUpdateObject value.
     *
     * @private
     */
    Diagram.prototype.updateDiagramObject = function (obj, canIgnoreIndex, isUpdateObject) {
        var view;
        var domTable = 'domTable';
        for (var _i = 0, _a = this.views; _i < _a.length; _i++) {
            var temp = _a[_i];
            view = this.views["" + temp];
            if (this.diagramActions) {
                if (view.mode === 'SVG') {
                    var hasLayers = this.layers.length > 1;
                    var layer = void 0;
                    if (hasLayers) {
                        layer = this.commandHandler.getObjectLayer(obj.id);
                    }
                    if ((layer === undefined || (layer && layer.visible)) || isUpdateObject) {
                        var htmlLayer = getHTMLLayer(this.element.id);
                        if (!window["" + domTable][view.element.id + '_diagramLayer']) {
                            window["" + domTable][view.element.id + '_diagramLayer'] =
                                document.getElementById(view.element.id + '_diagramLayer');
                        }
                        var diagramElementsLayer = window["" + domTable][view.element.id + '_diagramLayer'];
                        if (this.diagramActions & DiagramAction.Interactions) {
                            this.updateCanupdateStyle(obj.wrapper.children, true);
                        }
                        var centerPoint = this.getMidPoint(obj);
                        this.diagramRenderer.updateNode(obj.wrapper, diagramElementsLayer, htmlLayer, undefined, canIgnoreIndex ? undefined : this.getZindexPosition(obj, view.element.id), centerPoint, this.portCenterPoint);
                        this.updateCanupdateStyle(obj.wrapper.children, true);
                    }
                }
            }
        }
    };
    //Method used to apply margin for Bezier Curve points.
    Diagram.prototype.applyMarginBezier = function (obj, centerPoint) {
        centerPoint.cx = centerPoint.cx + obj.margin.left;
        centerPoint.cx = centerPoint.cx - obj.margin.right;
        centerPoint.cy = centerPoint.cy + obj.margin.top;
        centerPoint.cy = centerPoint.cy - obj.margin.bottom;
    };
    //Method used to get mid point of Bezier Curve
    Diagram.prototype.getMidPoint = function (obj) {
        var finalPoint;
        if (obj instanceof Connector && obj.type === 'Bezier') {
            finalPoint = [];
            var totalPoints = this.getBezierPoints(obj);
            var totalLength = Point.getLengthFromListOfPoints(totalPoints);
            // Bug 905077: Fixed improper positioning of multiple annotations for Bezier connectors.
            // Iterated through annotations and ports to correctly determine their positions.
            for (var i = 0; i < obj.annotations.length; i++) {
                var centerPoint = obj.annotations[parseInt(i.toString(), 10)].offset;
                var absoluteLength = centerPoint * totalLength;
                var position = this.commandHandler.getPointAtLength(absoluteLength, totalPoints, 0);
                var annotationPosition = { cx: position.x, cy: position.y };
                // EJ2-64114 -Horizontal and Vertical alignment not applied properly for the bezier connector annotation
                for (var j = 0; j < obj.wrapper.children.length; j++) {
                    if (obj.wrapper && obj.wrapper.children[parseInt(j.toString(), 10)] instanceof TextElement) {
                        if (obj.wrapper.children[parseInt(j.toString(), 10)].id === obj.id + '_' + obj.annotations[parseInt(i.toString(), 10)].id) {
                            this.applyMarginBezier(obj.wrapper.children[parseInt(j.toString(), 10)], annotationPosition);
                            finalPoint[obj.id + '_' + obj.annotations[parseInt(i.toString(), 10)].id] =
                                this.applyAlignment(obj.wrapper.children[parseInt(j.toString(), 10)], annotationPosition, obj.annotations[parseInt(i.toString(), 10)].displacement);
                        }
                    }
                }
            }
            // Bug 835525: Connector Port feature. Below code is used to get the port position for bezier connector.
            for (var i = 0; i < obj.ports.length; i++) {
                var portOffset = obj.ports[parseInt(i.toString(), 10)].offset;
                var length_1 = portOffset * totalLength;
                var portPosition = this.commandHandler.getPointAtLength(length_1, totalPoints, 0);
                var portPoint = { cx: portPosition.x, cy: portPosition.y };
                for (var j = 0; j < obj.wrapper.children.length; j++) {
                    if (obj.wrapper && obj.wrapper.children[parseInt(j.toString(), 10)] instanceof PathElement &&
                        obj.wrapper.children[parseInt(j.toString(), 10)].isPathPort) {
                        if (obj.wrapper.children[parseInt(j.toString(), 10)].id === obj.id + '_' + obj.ports[parseInt(i.toString(), 10)].id) {
                            this.applyMarginBezier(obj.wrapper.children[parseInt(j.toString(), 10)], portPoint);
                            this.portCenterPoint[obj.id + '_' + obj.ports[parseInt(i.toString(), 10)].id] =
                                this.applyAlignment(obj.wrapper.children[parseInt(j.toString(), 10)], portPoint, obj.ports[parseInt(i.toString(), 10)].displacement);
                        }
                    }
                }
            }
        }
        return finalPoint;
    };
    /**
     * Apply alignment to bezier port
     * @returns {PointModel} return the port alignment points
     * @param {PathElement | TextElement} child - provide the obj value.
     * @param {any} finalPoint - provide final point value.
     * @param {PointModel} displacement - provide displacement value.
     */
    Diagram.prototype.applyAlignment = function (child, finalPoint, displacement) {
        switch (child.horizontalAlignment) {
            case 'Auto':
            case 'Left':
                finalPoint.cx = child.inversedAlignment ? finalPoint.cx : (finalPoint.cx - child.desiredSize.width);
                finalPoint.cx += displacement.x;
                break;
            case 'Stretch':
            case 'Center':
                finalPoint.cx -= child.desiredSize.width * child.pivot.x;
                break;
            case 'Right':
                finalPoint.cx = child.inversedAlignment ? (finalPoint.cx - child.desiredSize.width) : finalPoint.cx;
                finalPoint.cx -= displacement.x;
                break;
        }
        switch (child.verticalAlignment) {
            case 'Auto':
            case 'Top':
                finalPoint.cy = child.inversedAlignment ? finalPoint.cy : (finalPoint.cy - child.desiredSize.height);
                finalPoint.cy += displacement.y;
                break;
            case 'Stretch':
            case 'Center':
                finalPoint.cy -= child.desiredSize.height * child.pivot.y;
                break;
            case 'Bottom':
                finalPoint.cy = child.inversedAlignment ? (finalPoint.cy - child.desiredSize.height) : finalPoint.cy;
                finalPoint.cy -= displacement.y;
                break;
        }
        return finalPoint;
    };
    //(EJ2-62683) Method used to get total points in bezier connector
    Diagram.prototype.getBezierPoints = function (obj) {
        var points = [];
        var i;
        var source = { x: obj.sourcePoint.x, y: obj.sourcePoint.y };
        points.push(source);
        for (i = 0; i < obj.segments.length; i++) {
            var total = obj.segments[parseInt(i.toString(), 10)].getPoints(obj.segments[parseInt(i.toString(), 10)], source);
            // 878719: Resolve ESLint errors
            // eslint-disable-next-line prefer-spread
            points.push.apply(points, total);
            source = points[points.length - 1];
        }
        return points;
    };
    /**
     *updateGridContainer method \
     *
     * @returns { void } updateGridContainer method .\
     * @param { GridPanel } grid - provide the objectArray value.
     *
     * @private
     */
    Diagram.prototype.updateGridContainer = function (grid) {
        var view;
        var htmlLayer = getHTMLLayer(this.element.id);
        for (var _i = 0, _a = this.views; _i < _a.length; _i++) {
            var temp = _a[_i];
            view = this.views["" + temp];
            if (view.mode === 'SVG' && this.diagramActions) {
                var diagramElementsLayer = document.getElementById(view.element.id + '_diagramLayer');
                this.diagramRenderer.updateNode(grid, diagramElementsLayer, htmlLayer, undefined);
            }
            else {
                this.refreshCanvasDiagramLayer(view);
            }
        }
    };
    /**
     *Retrieves the node or connector with the given id. \
     *
     * @returns { (NodeModel | ConnectorModel)[] } Retrieves the node or connector with the given id.\
     * @param { string[] } objectArray - The id of the node or connector to be retrieved.
     *
     * @private
     */
    Diagram.prototype.getObjectsOfLayer = function (objectArray) {
        var nodeArray = [];
        for (var _i = 0, objectArray_1 = objectArray; _i < objectArray_1.length; _i++) {
            var obj = objectArray_1[_i];
            if (this.nameTable["" + obj]) {
                nodeArray.push(this.nameTable["" + obj]);
            }
        }
        return nodeArray;
    };
    /**
     *refreshDiagramLayer method \
     *
     * @returns { void } refreshDiagramLayer method .\
     *
     * @private
     */
    Diagram.prototype.refreshDiagramLayer = function () {
        var view;
        for (var _i = 0, _a = this.views; _i < _a.length; _i++) {
            var temp = _a[_i];
            view = this.views["" + temp];
            switch (view.mode) {
                case 'SVG':
                    this.refreshSvgDiagramLayer(view);
                    break;
                case 'Canvas':
                    this.refreshCanvasLayers(view);
                    break;
            }
        }
    };
    /**
     *refreshCanvasLayers method \
     *
     * @returns { void } refreshCanvasLayers method .\
     * @param { View } view - provide the view value.
     *
     * @private
     */
    Diagram.prototype.refreshCanvasLayers = function (view) {
        if (!view) {
            for (var _i = 0, _a = this.views; _i < _a.length; _i++) {
                var temp = _a[_i];
                var view_1 = this.views["" + temp];
                this.refreshCanvasDiagramLayer(view_1);
            }
        }
        else {
            this.refreshCanvasDiagramLayer(view);
        }
    };
    Diagram.prototype.renderBasicElement = function (view) {
        var htmlLayer = getHTMLLayer(view.element.id);
        for (var i = 0; i < this.basicElements.length; i++) {
            var element = this.basicElements[parseInt(i.toString(), 10)];
            if (element instanceof Container) {
                element.prevRotateAngle = 0;
            }
            element.measure(new Size(element.width, element.height));
            element.arrange(element.desiredSize);
            view.diagramRenderer.renderElement(element, view.diagramLayer, htmlLayer);
        }
    };
    Diagram.prototype.refreshElements = function (view) {
        var isOverView = false;
        if (!this.isDestroyed) {
            this.clearCanvas(view);
            if (view instanceof Diagram) {
                view.diagramLayer.getContext('2d').setTransform(view.scroller.currentZoom, 0, 0, view.scroller.currentZoom, 0, 0);
                view.diagramLayer.getContext('2d').scale(1.5, 1.5);
            }
            else {
                isOverView = true;
                var element = document.getElementById(view.element.id + '_nativeLayer');
                if (element.children.length > 0) {
                    view.updateView(view);
                }
            }
            var htmlLayer = getHTMLLayer(view.element.id);
            //const bounds: Rect = this.spatialSearch.getPageBounds();
            this.renderDiagramElements(view.diagramLayer, view.diagramRenderer, htmlLayer, undefined, undefined, isOverView);
            for (var i = 0; i < this.basicElements.length; i++) {
                var element = this.basicElements[parseInt(i.toString(), 10)];
                element.measure(new Size(element.width, element.height));
                element.arrange(element.desiredSize);
                view.diagramRenderer.renderElement(element, view.diagramLayer, htmlLayer);
            }
            if (view instanceof Diagram) {
                view.diagramLayer.style.transform = 'scale(' + (2 / 3) + ')';
                view.diagramLayer.style.transformOrigin = '0 0';
            }
            this.renderTimer = null;
        }
    };
    /**
     *refreshCanvasDiagramLayer method \
     *
     * @returns { void } refreshCanvasDiagramLayer method .\
     * @param { View } view - provide the view value.
     *
     * @private
     */
    Diagram.prototype.refreshCanvasDiagramLayer = function (view) {
        var _this = this;
        if (view.mode !== 'SVG' && !this.isDestroyed) {
            if (this.basicElements.length > 0) {
                this.renderBasicElement(view);
            }
            if ((!this.diagramActions || (this.diagramActions & DiagramAction.Render) === 0)
                || (DiagramAction.ToolAction & this.diagramActions) || canVitualize(this) || (this.scroller.currentZoom !== 1)) {
                this.refreshElements(view);
            }
            else if (!this.renderTimer) {
                this.renderTimer = setTimeout(function () {
                    _this.refreshElements(view);
                }, 40);
            }
        }
    };
    /**
     *updatePortVisibility method \
     *
     * @returns { void } updatePortVisibility method .\
     * @param { Node } obj - provide the node value.
     * @param { PortVisibility } portVisibility - provide the portVisibility value.
     * @param { Boolean } inverse - provide the inverse value.
     *
     * @private
     */
    Diagram.prototype.updatePortVisibility = function (obj, portVisibility, inverse) {
        var portElement;
        var drawingObject = !(this.drawingObject && this.drawingObject.shape) ? true : false;
        if ((obj instanceof Node || obj instanceof Connector) && drawingObject && canMove(obj)) {
            var ports = obj.ports;
            var changed = false;
            for (var i = 0; i < ports.length; i++) {
                portElement = this.getWrapper(obj.wrapper, ports[parseInt(i.toString(), 10)].id);
                if ((portVisibility & PortVisibility.Hover || portVisibility & PortVisibility.Connect)) {
                    if (checkPortRestriction(ports[parseInt(i.toString(), 10)], portVisibility)) {
                        portElement.visible = !inverse;
                        changed = true;
                    }
                }
            }
            if (changed) {
                this.updateDiagramObject(obj);
            }
            //EJ2-59672 - Added the below code to render the ports while hovering over the node
            if (this.mode === 'Canvas') {
                this.refreshCanvasLayers();
            }
        }
    };
    /**
     *refreshSvgDiagramLayer method \
     *
     * @returns { void } refreshSvgDiagramLayer method .\
     * @param { View } view - provide the object value.
     *
     * @private
     */
    Diagram.prototype.refreshSvgDiagramLayer = function (view) {
        var element;
        var diagramElementsLayer = document.getElementById(view.element.id + '_diagramLayer');
        var htmlLayer = getHTMLLayer(view.element.id);
        if (!canVitualize(this)) {
            for (var i = 0; i < this.basicElements.length; i++) {
                element = this.basicElements[parseInt(i.toString(), 10)];
                element.measure(new Size(element.width, element.height));
                element.arrange(element.desiredSize, (!(this.diagramActions & DiagramAction.Render) ? true : false));
                this.diagramRenderer.renderElement(element, diagramElementsLayer, htmlLayer);
            }
            this.renderDiagramElements(diagramElementsLayer, this.diagramRenderer, htmlLayer);
        }
        else {
            this.scroller.virtualizeElements();
        }
    };
    /**
     *removeVirtualObjects method \
     *
     * @returns { void } removeVirtualObjects method .\
     * @param { Object } clearIntervalVal - provide the object value.
     *
     * @private
     */
    Diagram.prototype.removeVirtualObjects = function (clearIntervalVal) {
        if (this.deleteVirtualObject) {
            for (var i = 0; i < this.scroller.removeCollection.length; i++) {
                var obj = this.nameTable[this.scroller.removeCollection[parseInt(i.toString(), 10)]];
                //EJ2-840437 - Exception occurs When Removing connector with Virtualization Enabled
                if (obj !== undefined) {
                    this.removeElements(obj);
                }
            }
            this.deleteVirtualObject = false;
        }
        clearInterval(clearIntervalVal);
    };
    /**
     *updateTextElementValue method \
     *
     * @returns { void } updateTextElementValue method .\
     * @param {  NodeModel | ConnectorModel } object - provide the object value.
     *
     * @private
     */
    Diagram.prototype.updateTextElementValue = function (object) {
        for (var j = 0; j < object.wrapper.children.length; j++) {
            var element = object.wrapper.children[parseInt(j.toString(), 10)];
            if (element instanceof TextElement) {
                element.canMeasure = true;
                //866384-Annotation Alignment is wrong when virtualisation constraints enabled
                var viewPortHeight = this.scroller.viewPortHeight;
                var viewPortWidth = this.scroller.viewPortWidth;
                var measureText = false;
                if (object.offsetX < viewPortWidth && object.offsetY < viewPortHeight) {
                    measureText = true;
                }
                if (measureText && canVitualize(this) && element.actualSize.height === undefined
                    && element.actualSize.width === undefined) {
                    object.wrapper.measure(new Size(object.width, object.height), object.id, this.onLoadImageSize.bind(this));
                    object.wrapper.arrange(object.wrapper.desiredSize);
                }
                element.measure(new Size(object.width, object.height));
                element.arrange(element.desiredSize);
            }
        }
    };
    /**
     *updateVirtualObjects method \
     *
     * @returns { void } updateVirtualObjects method .\
     * @param { string[] } collection - provide the collection value.
     * @param { boolean } remove - provide the remove value.
     * @param { string[] } tCollection - provide the htmlLayer value.
     *
     * @private
     */
    Diagram.prototype.updateVirtualObjects = function (collection, remove, tCollection) {
        var diagramElementsLayer = document.getElementById(this.element.id + '_diagramLayer');
        var htmlLayer = getHTMLLayer(this.element.id);
        if (this.mode === 'SVG') {
            for (var i = 0; i < collection.length; i++) {
                var index = this.scroller.removeCollection.indexOf(collection[parseInt(i.toString(), 10)]);
                if (index >= 0) {
                    this.scroller.removeCollection.splice(index, 1);
                }
                var object = this.nameTable[collection[parseInt(i.toString(), 10)]];
                this.updateTextElementValue(object);
                this.diagramRenderer.renderElement(object.wrapper, diagramElementsLayer, htmlLayer, undefined, undefined, undefined, undefined, object.zIndex);
            }
            for (var k = 0; k < tCollection.length; k++) {
                this.scroller.removeCollection.push(tCollection[parseInt(k.toString(), 10)]);
            }
            if (this.scroller.currentZoom !== 1) {
                this.eventHandler.updateVirtualization();
            }
        }
        else if (this.diagramActions) {
            this.refreshDiagramLayer();
        }
    };
    /**
     *renderDiagramElements method \
     *
     * @returns { void } renderDiagramElements method .\
     * @param { HTMLCanvasElement | SVGElement} canvas - provide the canvas value.
     * @param { DiagramRenderer } renderer - provide the renderer value.
     * @param { HTMLElement } htmlLayer - provide the htmlLayer value.
     * @param {boolean } transform - provide the transform value.
     * @param {boolean } fromExport - provide the fromExport value.
     * @param { boolean } isOverView - provide the isOverView value.
     *
     * @private
     */
    Diagram.prototype.renderDiagramElements = function (canvas, renderer, htmlLayer, transform, fromExport, isOverView) {
        if (transform === void 0) { transform = true; }
        var pageBounds = this.scroller.getPageBounds();
        pageBounds.x *= this.scroller.currentZoom;
        pageBounds.y *= this.scroller.currentZoom;
        pageBounds.width *= this.scroller.currentZoom;
        pageBounds.height *= this.scroller.currentZoom;
        var difX = -this.scroller.horizontalOffset - pageBounds.x;
        var difY = -this.scroller.verticalOffset - pageBounds.y;
        var getCenterPoint;
        for (var _i = 0, _a = Object.keys(this.layerZIndexTable); _i < _a.length; _i++) {
            var layerId = _a[_i];
            var layer = this.commandHandler.getLayer(this.layerZIndexTable["" + layerId]);
            var left = void 0;
            var top_1 = void 0;
            if (this.mode === 'Canvas' && canVitualize(this) && !this.diagramActions) {
                this.scroller.virtualizeElements();
            }
            var id = (this.mode === 'Canvas' && canVitualize(this) &&
                this.scroller.oldCollectionObjects.length > 0) ?
                this.scroller.oldCollectionObjects : undefined;
            // Sort layer objects to arrange nodes with negative zIndex values at the beginning of the array.
            // Due to the new implementation with order commands, the zIndex of a node may become negative.
            // Therefore, we need to sort the zIndex values, with the least negative values coming first, followed by positive values.
            var layerObjects = Object.keys(id || layer.zIndexTable);
            layerObjects.sort(function (a, b) { return parseInt("" + a, 10) - parseInt("" + b, 10); });
            for (var _b = 0, layerObjects_1 = layerObjects; _b < layerObjects_1.length; _b++) {
                var node = layerObjects_1[_b];
                var renderNode = id ? this.nameTable[id["" + node]] : this.nameTable[layer.zIndexTable["" + node]];
                if (renderNode && !(renderNode.parentId) && layer.visible &&
                    (!(renderNode.processId) || this.refreshing)) {
                    //EJ2-68738 - Overview content not updated properly on zoom out the diagram
                    var transformValue = void 0;
                    //828826 - In canvas mode diagram transform values are not updated properly while Zoom out action
                    if (this.scroller.currentZoom < 1 && this.mode === 'SVG') {
                        transformValue = {
                            tx: (-pageBounds.x) / this.scroller.currentZoom,
                            ty: (-pageBounds.y) / this.scroller.currentZoom,
                            scale: this.scroller.transform.scale
                        };
                    }
                    else {
                        transformValue = {
                            tx: this.scroller.transform.tx,
                            ty: this.scroller.transform.ty,
                            scale: this.scroller.transform.scale
                        };
                    }
                    // Bug 880945: Overview is not updated properly with 4k monitor.
                    //To render the overview elements based on the pageBounds.
                    if (isOverView) {
                        transformValue = {
                            tx: (-pageBounds.x) / this.scroller.currentZoom,
                            ty: (-pageBounds.y) / this.scroller.currentZoom,
                            scale: this.scroller.transform.scale
                        };
                    }
                    if (canVitualize(this)) {
                        if (this.scroller.currentZoom < 1) {
                            if (pageBounds.x < 0 || this.scroller.horizontalOffset < 0) {
                                var verticalValue = this.scroller.verticalOffset < 0 ? this.scroller.verticalOffset : 0;
                                left = (difX > 0 ? difX : 0) + 'px';
                                top_1 = ((this.realActions & RealAction.vScrollbarMoved) ? 0 : -verticalValue) + 'px';
                            }
                            else {
                                left = 0 + 'px';
                                top_1 = 0 + 'px';
                            }
                            if (this.realActions & RealAction.hScrollbarMoved) {
                                this.realActions = this.realActions & ~RealAction.hScrollbarMoved;
                            }
                            if (this.realActions & RealAction.vScrollbarMoved) {
                                this.realActions = this.realActions & ~RealAction.vScrollbarMoved;
                            }
                        }
                        else {
                            left = (pageBounds.x < 0 ? difX : -this.scroller.horizontalOffset) + 'px';
                            top_1 = (pageBounds.y < 0 ? difY : -this.scroller.verticalOffset) + 'px';
                        }
                        this.diagramLayer.style.left = left;
                        this.diagramLayer.style.top = top_1;
                        //EJ2-69578 - Overview is not updated properly when we enable virtualization.
                        transformValue.tx = (-pageBounds.x) / transformValue.scale;
                        transformValue.ty = (-pageBounds.y) / transformValue.scale;
                    }
                    var status_1 = true;
                    if (fromExport) {
                        status_1 = false;
                    }
                    this.updateTextElementValue(renderNode);
                    if (this.refreshing) {
                        if (renderNode.shape.activity && renderNode.shape.activity.subProcess
                            && renderNode.shape.activity.subProcess.processes) {
                            for (var i = 0; i < renderNode.shape.activity.subProcess.processes.length; i++) {
                                var process = renderNode.shape.activity.subProcess.processes[parseInt(i.toString(), 10)];
                                renderNode.wrapper.children.push(this.nameTable["" + process].wrapper);
                            }
                            renderNode.wrapper.measure(new Size(renderNode.wrapper.bounds.width, renderNode.wrapper.bounds.height));
                            renderNode.wrapper.arrange(renderNode.wrapper.desiredSize);
                        }
                    }
                    if (renderNode instanceof Connector && renderNode.type === 'Bezier') {
                        getCenterPoint = this.getMidPoint(renderNode);
                        // (EJ2-58802) - Added the below code to add the transform x and y values to center point value in canvas mode
                        if (this.mode === 'Canvas' && transform) {
                            getCenterPoint.cx += transformValue.tx;
                            getCenterPoint.cy += transformValue.ty;
                        }
                    }
                    else {
                        getCenterPoint = null;
                    }
                    renderer.renderElement(renderNode.wrapper, canvas, htmlLayer, (!renderer.isSvgMode && transform) ? transformValue : undefined, undefined, undefined, status_1 && (!this.diagramActions || isOverView), undefined, undefined, getCenterPoint, this.portCenterPoint);
                }
            }
        }
    };
    /**
     *updateBridging method \
     *
     * @returns { void } updateBridging method .\
     * @param {string} isLoad - provide the isLoad value.
     *
     * @private
     */
    Diagram.prototype.updateBridging = function (isLoad) {
        if (this.bridgingModule) {
            for (var i = 0; i < this.connectors.length; i++) {
                var connector = this.connectors[parseInt(i.toString(), 10)];
                this.bridgingModule.updateBridging(connector, this);
                var canvas = this.connectors[parseInt(i.toString(), 10)].wrapper;
                if (canvas && canvas.children && canvas.children.length > 0) {
                    var pathSegment = canvas.children[0];
                    var data = pathSegment.data;
                    if (connector.isBezierEditing && this.selectedItems.connectors[0].id === connector.id || connector.type !== 'Bezier') {
                        connector.getSegmentElement(connector, pathSegment, this.layout.type === 'ComplexHierarchicalTree' || this.layout.type === 'HierarchicalTree' ?
                            this.layout.orientation : undefined, undefined, false);
                    }
                    if (pathSegment.data !== data) {
                        canvas.measure(new Size());
                        canvas.arrange(canvas.desiredSize);
                        if (this.mode === 'SVG' && !isLoad) {
                            this.updateDiagramObject(connector);
                        }
                    }
                }
            }
        }
        else if (this.constraints & DiagramConstraints.Bridging) {
            console.warn('[WARNING] :: Module "ConnectorBridging" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
        }
    };
    /**
     *setCursor method \
     *
     * @returns { void } setCursor method .\
     * @param {string} cursor - provide the width value.
     *
     * @private
     */
    Diagram.prototype.setCursor = function (cursor) {
        this.diagramRenderer.setCursor(this.diagramCanvas, cursor);
    };
    /**
     *clearCanvas method \
     *
     * @returns { void } clearCanvas method .\
     * @param {View} view - provide the width value.
     *
     * @private
     */
    Diagram.prototype.clearCanvas = function (view) {
        //let width: number;
        //let height: number;
        var width = view.contentWidth || view.diagramLayer.width / this.scroller.currentZoom;
        var height = view.contentHeight || view.diagramLayer.height / this.scroller.currentZoom;
        if (view.mode !== 'SVG') {
            var ctx = CanvasRenderer.getContext(view.diagramLayer);
            ctx.clearRect(0, 0, width, height);
        }
    };
    /**
     *updateScrollOffset method \
     *
     * @returns { void } updateScrollOffset method .\
     *
     * @private
     */
    Diagram.prototype.updateScrollOffset = function () {
        this.scroller.setScrollOffset(this.diagramCanvas.scrollLeft, this.diagramCanvas.scrollTop);
        updateRuler(this);
        if (canVitualize(this)) {
            this.scroller.virtualizeElements();
        }
    };
    /**
     *setOffset method \
     *
     * @returns { void } setOffset method .\
     * @param {number} offsetX - provide the width value.
     * @param {number} offsetY - provide the height value.
     *
     * @private
     */
    Diagram.prototype.setOffset = function (offsetX, offsetY) {
        var domTable = 'domTable';
        if (!window["" + domTable][this.element.id + 'content']) {
            window["" + domTable][this.element.id + 'content'] = document.getElementById(this.element.id + 'content');
        }
        var container = window["" + domTable][this.element.id + 'content'];
        if (container) {
            container.scrollLeft = offsetX;
            container.scrollTop = offsetY;
        }
    };
    /**
     *setSize method \
     *
     * @returns { void } setSize method .\
     * @param {number} width - provide the width value.
     * @param {number} height - provide the height value.
     *
     * @private
     */
    Diagram.prototype.setSize = function (width, height) {
        if (this.diagramLayer && !this.preventDiagramUpdate) {
            var position = getRulerSize(this);
            width -= position.width;
            height -= position.height;
            var bounds = this.spatialSearch.getPageBounds();
            bounds.x *= this.scroller.currentZoom;
            bounds.y *= this.scroller.currentZoom;
            bounds.width *= this.scroller.currentZoom;
            bounds.height *= this.scroller.currentZoom;
            var factor = this.mode === 'SVG' ? 1 : 1.5;
            var diagramLayer = this.mode === 'SVG' ?
                getDiagramLayerSvg(this.element.id) : this.diagramLayer;
            var w = (this.mode === 'Canvas' &&
                (this.constraints & DiagramConstraints.Virtualization)) ? this.scroller.viewPortWidth : width;
            var h = (this.mode === 'Canvas' &&
                (this.constraints & DiagramConstraints.Virtualization)) ? this.scroller.viewPortHeight : height;
            diagramLayer.setAttribute('width', (factor * w).toString());
            diagramLayer.setAttribute('height', (factor * h).toString());
            var hiddenUserHandleTemplate = document.getElementById(this.element.id + '_diagramUserHandleLayer');
            if (hiddenUserHandleTemplate) {
                hiddenUserHandleTemplate.style.width = width + 'px';
                hiddenUserHandleTemplate.style.height = height + 'px';
            }
            var attr = { 'width': width.toString(), 'height': height.toString() };
            this.diagramLayerDiv.style.width = width + 'px';
            this.diagramLayerDiv.style.height = height + 'px';
            setAttributeSvg(getNativeLayerSvg(this.element.id), attr);
            setAttributeSvg(getPortLayerSvg(this.element.id), attr);
            var adornerSVG = getAdornerLayerSvg(this.element.id);
            setAttributeSvg(adornerSVG, attr);
            adornerSVG.parentNode.style.width = width + 'px';
            adornerSVG.parentNode.style.height = height + 'px';
            var gridLayer = getGridLayerSvg(this.element.id);
            setAttributeSvg(gridLayer, attr);
            this.diagramRenderer.updateGrid(this.snapSettings, gridLayer, this.scroller.transform, this.rulerSettings, this.hRuler, this.vRuler);
            setAttributeSvg(getBackgroundLayerSvg(this.element.id), attr);
            this.htmlLayer.style.width = width + 'px';
            this.htmlLayer.style.height = height + 'px';
            if (this.mode !== 'SVG' && !(canVitualize(this))) {
                this.refreshDiagramLayer();
            }
            if (this.mode === 'SVG' && canVitualize(this)) {
                this.scroller.virtualizeElements();
            }
        }
    };
    /**
     *transformLayers method \
     *
     * @returns { void } Defines how to remove the Page breaks .\
     *
     * @private
     */
    Diagram.prototype.transformLayers = function () {
        var bounds = this.spatialSearch.getPageBounds();
        bounds.x *= this.scroller.currentZoom;
        bounds.y *= this.scroller.currentZoom;
        bounds.width *= this.scroller.currentZoom;
        bounds.height *= this.scroller.currentZoom;
        this.diagramRenderer.updateGrid(this.snapSettings, getGridLayerSvg(this.element.id), this.scroller.transform, this.rulerSettings, this.hRuler, this.vRuler);
        this.diagramRenderer.transformLayers(this.scroller.transform, this.mode === 'SVG');
        if (!(this.diagramActions & DiagramAction.DragUsingMouse)) {
            this.updateSelector();
        }
        this.renderPageBreaks(bounds);
    };
    /**
     *Defines how to remove the Page breaks \
     *
     * @returns { void } Defines how to remove the Page breaks .\
     *
     * @private
     */
    Diagram.prototype.removePageBreaks = function () {
        if (this.diagramLayer) {
            var line = getBackgroundLayer(this.element.id);
            if (line && line.childNodes) {
                var length_2 = line.childNodes.length;
                for (var i = 0; i < length_2; i++) {
                    line.removeChild(line.childNodes[0]);
                }
            }
        }
    };
    /**
     * Defines how the page breaks has been rendered \
     *
     * @returns { void } Defines how the page breaks has been rendered .\
     * @param {Rect} bounds - provide the overview value.
     *
     * @private
     */
    Diagram.prototype.renderPageBreaks = function (bounds) {
        this.removePageBreaks();
        var backgroundLayer = getBackgroundLayer(this.element.id);
        if (backgroundLayer) {
            var i = 0;
            bounds = this.scroller.getPageBounds(true);
            var x = (this.scroller.transform.tx + bounds.x) * this.scroller.currentZoom;
            var y = (this.scroller.transform.ty + bounds.y) * this.scroller.currentZoom;
            var height = bounds.height * this.scroller.currentZoom;
            var width = bounds.width * this.scroller.currentZoom;
            DiagramRenderer.renderSvgBackGroundImage(this.pageSettings.background, this.element, x, y, width, height);
            var options = {
                id: backgroundLayer.id + 'rect', x: x,
                y: y,
                height: height,
                width: width, angle: 0, stroke: '', strokeWidth: 1,
                fill: this.pageSettings.background.color, opacity: 1,
                pivotX: 0, pivotY: 0, visible: true, dashArray: '0'
            };
            this.diagramRenderer.drawRect(backgroundLayer, options);
            if (this.pageSettings.showPageBreaks) {
                var collection = this.scroller.getPageBreak(bounds);
                for (i = 0; i < collection.length; i++) {
                    this.diagramRenderer.drawLine(backgroundLayer, {
                        class: 'e-diagram-page-break',
                        fill: 'none', stroke: '#aaaaaa', strokeWidth: 1, dashArray: '10 10',
                        opacity: 2, x: 0, y: 0, width: 0, height: 0, angle: 0, pivotX: 0, pivotY: 0, visible: true,
                        startPoint: {
                            x: (collection[parseInt(i.toString(), 10)].x1 + this.scroller.transform.tx) * this.scroller.currentZoom,
                            y: (collection[parseInt(i.toString(), 10)].y1 + this.scroller.transform.ty) * this.scroller.currentZoom
                        },
                        endPoint: {
                            x: (collection[parseInt(i.toString(), 10)].x2 + this.scroller.transform.tx) * this.scroller.currentZoom,
                            y: (collection[parseInt(i.toString(), 10)].y2 + this.scroller.transform.ty) * this.scroller.currentZoom
                        }, id: collection[parseInt(i.toString(), 10)].y1 === collection[parseInt(i.toString(), 10)].y2 ? 'HorizontalLines' : 'VerticalLines'
                    });
                }
            }
        }
    };
    Diagram.prototype.validatePageSize = function () {
        var temp = 0;
        if (this.pageSettings.orientation === 'Portrait') {
            if (this.pageSettings.width > this.pageSettings.height) {
                temp = this.pageSettings.height;
                this.pageSettings.height = this.pageSettings.width;
                this.pageSettings.width = temp;
            }
        }
        else {
            if (this.pageSettings.height > this.pageSettings.width) {
                temp = this.pageSettings.width;
                this.pageSettings.width = this.pageSettings.height;
                this.pageSettings.height = temp;
            }
        }
    };
    /**
     * setOverview method \
     *
     * @returns { void }     setOverview method .\
     * @param {View} overview - provide the overview value.
     * @param {string} id - provide the boolean value.
     *
     * @private
     */
    Diagram.prototype.setOverview = function (overview, id) {
        if (overview) {
            if (overview) {
                this.views.push(overview.id);
                this.views[overview.id] = overview;
                overview.renderDocument(overview);
                overview.diagramRenderer.setLayers();
                overview.updateView(overview);
                this.renderNodes(overview);
            }
        }
        else {
            for (var i = 0; i < this.views.length; i++) {
                if (this.views[parseInt(i.toString(), 10)] === id) {
                    overview = (this.views["" + id]);
                }
            }
            this.views["" + id] = undefined;
            var index = this.views.indexOf(id);
            this.views.splice(index, 1);
        }
    };
    Diagram.prototype.renderNodes = function (overview) {
        if (overview) {
            var renderer = new DiagramRenderer(overview.id, new SvgRenderer(), false);
            var g = document.getElementById(overview.element.id + '_diagramLayer');
            var htmlLayer = getHTMLLayer(overview.element.id);
            this.renderDiagramElements(g, overview.diagramRenderer || renderer, htmlLayer, undefined, undefined, true);
        }
    };
    Diagram.prototype.updateThumbConstraints = function (node, selectorModel, canInitialize) {
        var length = node.length;
        for (var i = 0; i < length; i++) {
            var obj = node[parseInt(i.toString(), 10)];
            var hideRotate = false;
            var hideResize = false;
            var thumbConstraints = selectorModel.thumbsConstraints;
            var isInsideSwimlane = false;
            if (this.nameTable[obj.parentId]) {
                var lane = this.nameTable[obj.parentId];
                isInsideSwimlane = lane.isLane;
            }
            if (obj instanceof Node) {
                //Bug 913796: Multiselect swimlane with outside node, drag, rotate is not proper.
                //Hided rotate thumb for swimlane
                hideRotate = (obj.shape.type === 'Bpmn' && (obj.shape.shape === 'Activity' &&
                    (obj.shape.activity.subProcess.collapsed === false))) || obj.shape.type === 'SwimLane' || isInsideSwimlane;
                // hideResize = (obj.shape.type === 'Bpmn' && (obj.shape as BpmnShapeModel).shape === 'TextAnnotation');
                if (!canRotate(obj) || !(thumbConstraints & ThumbsConstraints.Rotate) || hideRotate) {
                    thumbConstraints = thumbConstraints & ~ThumbsConstraints.Rotate;
                }
                if (!canResize(obj, 'SouthEast') || !(thumbConstraints & ThumbsConstraints.ResizeSouthEast) || hideResize) {
                    thumbConstraints = thumbConstraints & ~ThumbsConstraints.ResizeSouthEast;
                }
                if (!canResize(obj, 'NorthWest') || !(thumbConstraints & ThumbsConstraints.ResizeNorthWest) || hideResize) {
                    thumbConstraints = thumbConstraints & ~ThumbsConstraints.ResizeNorthWest;
                }
                if (!canResize(obj, 'East') || !(thumbConstraints & ThumbsConstraints.ResizeEast) || hideResize) {
                    thumbConstraints = thumbConstraints & ~ThumbsConstraints.ResizeEast;
                }
                if (!canResize(obj, 'West') || !(thumbConstraints & ThumbsConstraints.ResizeWest) || hideResize) {
                    thumbConstraints = thumbConstraints & ~ThumbsConstraints.ResizeWest;
                }
                if (!canResize(obj, 'North') || !(thumbConstraints & ThumbsConstraints.ResizeNorth) || hideResize) {
                    thumbConstraints = thumbConstraints & ~ThumbsConstraints.ResizeNorth;
                }
                if (!canResize(obj, 'South') || !(thumbConstraints & ThumbsConstraints.ResizeSouth) || hideResize) {
                    thumbConstraints = thumbConstraints & ~ThumbsConstraints.ResizeSouth;
                }
                if (!canResize(obj, 'NorthEast') || !(thumbConstraints & ThumbsConstraints.ResizeNorthEast) || hideResize) {
                    thumbConstraints = thumbConstraints & ~ThumbsConstraints.ResizeNorthEast;
                }
                if (!canResize(obj, 'SouthWest') || !(thumbConstraints & ThumbsConstraints.ResizeSouthWest) || hideResize) {
                    thumbConstraints = thumbConstraints & ~ThumbsConstraints.ResizeSouthWest;
                }
            }
            else if (obj instanceof Connector) {
                if (!canInitialize) {
                    thumbConstraints = thumbConstraints | ThumbsConstraints.Default;
                }
                if (canDragSourceEnd(obj)) {
                    thumbConstraints = thumbConstraints | ThumbsConstraints.ConnectorSource;
                }
                else {
                    thumbConstraints = thumbConstraints & ~ThumbsConstraints.ConnectorSource;
                }
                if (canDragTargetEnd(obj)) {
                    thumbConstraints = thumbConstraints | ThumbsConstraints.ConnectorTarget;
                }
                else {
                    thumbConstraints = thumbConstraints & ~ThumbsConstraints.ConnectorTarget;
                }
            }
            else {
                if (!canInitialize) {
                    thumbConstraints = thumbConstraints | ThumbsConstraints.Default;
                }
                if (!canResize(obj)) {
                    thumbConstraints = thumbConstraints & ~(ThumbsConstraints.ResizeSouthEast | ThumbsConstraints.ResizeSouthWest |
                        ThumbsConstraints.ResizeSouth | ThumbsConstraints.ResizeEast | ThumbsConstraints.ResizeWest |
                        ThumbsConstraints.ResizeNorth | ThumbsConstraints.ResizeNorthEast | ThumbsConstraints.ResizeNorthWest);
                }
                if (!canRotate(obj)) {
                    thumbConstraints = thumbConstraints & ~ThumbsConstraints.Rotate;
                }
            }
            selectorModel.thumbsConstraints = thumbConstraints;
        }
    };
    /**
     * renderSelector method \
     *
     * @returns { void }     renderSelector method .\
     * @param {boolean} multipleSelection - provide the multipleSelection value.
     * @param {boolean} isSwimLane - provide the boolean value.
     * @param { Canvas } canvas - provide the lane or swimlane canvas
     *
     * @private
     */
    Diagram.prototype.renderSelector = function (multipleSelection, isSwimLane, canvas) {
        var isProtectedOnChangeValue = this.isProtectedOnChange;
        //Removed isBlazor code
        var size = new Size();
        var selectorModel = this.selectedItems;
        var selectorConstraints = selectorModel.constraints;
        var rendererActions = this.diagramRenderer.rendererActions;
        var innertemplate = document.getElementsByClassName('blazor-inner-template');
        this.diagramRenderer.rendererActions = this.currentSymbol ?
            this.addConstraints(rendererActions, RendererAction.DrawSelectorBorder) :
            this.removeConstraints(rendererActions, RendererAction.DrawSelectorBorder);
        this.clearSelectorLayer();
        if (this.commandHandler.hasSelection()) {
            if (selectorModel.nodes.length === 1 && selectorModel.connectors.length === 0) {
                selectorModel.rotateAngle = selectorModel.nodes[0].rotateAngle;
                selectorModel.pivot = selectorModel.nodes[0].pivot;
            }
            selectorModel.wrapper.measure(size);
            selectorModel.wrapper.arrange(selectorModel.wrapper.desiredSize);
            selectorModel.width = selectorModel.wrapper.actualSize.width;
            selectorModel.height = selectorModel.wrapper.actualSize.height;
            selectorModel.offsetX = selectorModel.wrapper.offsetX;
            selectorModel.offsetY = selectorModel.wrapper.offsetY;
            if (selectorModel.rotateAngle !== 0) {
                for (var _i = 0, _a = selectorModel.nodes; _i < _a.length; _i++) {
                    var obj = _a[_i];
                    obj.offsetX = obj.wrapper.offsetX;
                    obj.offsetY = obj.wrapper.offsetY;
                }
                for (var _b = 0, _c = selectorModel.connectors; _b < _c.length; _b++) {
                    var conn = _c[_b];
                    //update connections
                }
            }
            var bounds = this.spatialSearch.getPageBounds();
            //let selectorElement: (SVGElement | HTMLCanvasElement);
            var selectorElement = getSelectorElement(this.element.id);
            //let diagramUserHandlelayer: (SVGElement | HTMLElement);
            var diagramUserHandlelayer = getUserHandleLayer(this.element.id);
            selectorModel.thumbsConstraints = ThumbsConstraints.Default;
            if (selectorModel.annotation) {
                this.updateThumbConstraints([selectorModel.annotation], selectorModel);
            }
            else {
                this.updateThumbConstraints(selectorModel.nodes, selectorModel);
                this.updateThumbConstraints(selectorModel.connectors, selectorModel, true);
            }
            if (selectorModel.annotation) {
                this.renderSelectorForAnnotation(selectorModel, selectorElement);
            }
            else if (selectorModel.nodes.length + selectorModel.connectors.length === 1 || this.nameTable['helper']) {
                if (selectorModel.nodes[0] instanceof Node) {
                    var node = selectorModel.nodes[0];
                    if (checkParentAsContainer(this, node)) {
                        if (!isSwimLane && (node.shape.type !== 'UmlClassifier' && !(node.parentId &&
                            this.nameTable[node.parentId]
                            && this.nameTable[node.parentId].shape.type === 'UmlClassifier'))) {
                            selectorModel.thumbsConstraints &= ~ThumbsConstraints.Rotate;
                        }
                    }
                    var constraints = isSwimLane ? true : ((node.constraints & NodeConstraints.HideThumbs) ? true : false);
                    var swimlane = (node.shape.type === 'SwimLane' || node.isLane || node.isPhase || isSwimLane) ? true : false;
                    this.diagramRenderer.renderResizeHandle(isSwimLane ? canvas : selectorModel.wrapper.children[0], selectorElement, selectorModel.thumbsConstraints, this.scroller.currentZoom, selectorModel.constraints, this.scroller.transform, undefined, canMove(node), constraints, swimlane, selectorModel.handleSize);
                }
                else if (selectorModel.connectors[0] instanceof Connector && canDrawThumbs(this.diagramRenderer.rendererActions)) {
                    var connector = selectorModel.connectors[0];
                    this.diagramRenderer.renderEndPointHandle(connector, selectorElement, selectorModel.thumbsConstraints, selectorModel.constraints, this.scroller.transform, connector.sourceWrapper !== undefined, connector.targetWrapper !== undefined, (this.connectorEditingToolModule && canDragSegmentThumb(connector)) ? true : false, this.connectorEditingToolModule ? true : false, selectorModel.handleSize);
                }
            }
            else {
                this.diagramRenderer.renderResizeHandle(selectorModel.wrapper, selectorElement, selectorModel.thumbsConstraints, this.scroller.currentZoom, selectorModel.constraints, this.scroller.transform, undefined, canMove(selectorModel), null, null, selectorModel.handleSize);
            }
            if (!(selectorModel.annotation) && !this.currentSymbol) {
                this.diagramRenderer.renderUserHandler(selectorModel, selectorElement, this.scroller.transform, diagramUserHandlelayer, this.eventHandler.currentAction, this.eventHandler.inAction);
                //Removed isBlazor code
            }
        }
        // EJ2-56919 - Add below code to render the selection rectangle for node if selected objects length is greater than one
        if (this.selectedItems.selectedObjects.length > 1) {
            this.updateSelectionRectangle();
        }
        this.isProtectedOnChange = isProtectedOnChangeValue;
    };
    Diagram.prototype.updateSelectionRectangle = function () {
        var selectorElement = getSelectorElement(this.element.id);
        var isFirst = false;
        for (var i = 0; i < this.selectedItems.selectedObjects.length; i++) {
            // EJ2-56919 - For first selected object we need to set stroke as 2, so check below condition as i is zero or not
            // For first element we passed isFirst argument(last arg) as true in both render selection line and rectangle method
            isFirst = i === 0 ? true : false;
            if (getObjectType(this.selectedItems.selectedObjects[parseInt(i.toString(), 10)]) === Connector) {
                // EJ2-56919 - If selected object type is connector means then render selection line for connector
                this.diagramRenderer.renderSelectionLine(this.selectedItems.selectedObjects[parseInt(i.toString(), 10)].wrapper.children[0], selectorElement, this.scroller.transform, isFirst);
            }
            else {
                // EJ2-56919 - If selected object type is node means then render selection rectangle for node
                this.diagramRenderer.renderSelectionRectangle(this.selectedItems.selectedObjects[parseInt(i.toString(), 10)].wrapper, selectorElement, this.scroller.transform, isFirst);
            }
        }
    };
    /**
     * updateSelector method \
     *
     * @returns { void }     updateSelector method .\
     *
     * @private
     */
    Diagram.prototype.updateSelector = function () {
        var severDataBind = this.allowServerDataBinding;
        this.enableServerDataBinding(false);
        var size = new Size();
        var selector = this.selectedItems;
        var selectorConstraints = selector.constraints;
        var innertemplate = document.getElementsByClassName('blazor-inner-template');
        if (!(this.diagramActions & DiagramAction.ToolAction) && this.selectedItems.nodes.length === 1) {
            this.selectedItems.rotateAngle = this.selectedItems.nodes[0].rotateAngle;
            this.selectedItems.wrapper.rotateAngle = this.selectedItems.nodes[0].rotateAngle;
        }
        if (this.selectedItems !== undefined) {
            this.clearSelectorLayer();
            if (selector.wrapper !== null && selector.wrapper.children && selector.wrapper.children.length) {
                var canUpdate = true;
                var canRender = true;
                if (selectionHasConnector(this, selector)) {
                    var eventHandler = 'eventHandler';
                    var rotate = this["" + eventHandler].action;
                    var isRotate = rotate.includes('Rotate');
                    var isSelect = rotate.includes('None') || rotate.includes('Select') || rotate.includes('Drag');
                    if (isRotate || isSelect) {
                        canRender = false;
                    }
                    if (!isSelect) {
                        canUpdate = false;
                    }
                }
                if (canUpdate) {
                    selector.wrapper.measure(size);
                    selector.wrapper.arrange(selector.wrapper.desiredSize);
                }
                if (selector.rotateAngle !== 0 || selector.rotateAngle !== selector.wrapper.prevRotateAngle) {
                    for (var _i = 0, _a = selector.nodes; _i < _a.length; _i++) {
                        var obj = _a[_i];
                        obj.offsetX = obj.wrapper.offsetX;
                        obj.offsetY = obj.wrapper.offsetY;
                    }
                }
                selector.width = selector.wrapper.actualSize.width;
                selector.height = selector.wrapper.actualSize.height;
                selector.offsetX = selector.wrapper.offsetX;
                selector.offsetY = selector.wrapper.offsetY;
                //let selectorEle: (SVGElement | HTMLCanvasElement);
                var selectorEle = getSelectorElement(this.element.id);
                //let diagramUserHandlelayer: (SVGElement | HTMLElement);
                var diagramUserHandlelayer = getUserHandleLayer(this.element.id);
                var canHideResizers = this.eventHandler.canHideResizers();
                selector.thumbsConstraints = ThumbsConstraints.Default;
                if (selector.annotation) {
                    this.updateThumbConstraints([selector.annotation], selector);
                }
                else {
                    this.updateThumbConstraints(selector.nodes, selector);
                    this.updateThumbConstraints(selector.connectors, selector, true);
                }
                if ((this.selectedItems.constraints & SelectorConstraints.UserHandle) && (!(selector.annotation)) && !this.currentSymbol) {
                    this.diagramRenderer.renderUserHandler(selector, selectorEle, this.scroller.transform, diagramUserHandlelayer, this.eventHandler.currentAction, this.eventHandler.inAction);
                    //Removed isBlazor code
                }
                if (selector.annotation) {
                    this.renderSelectorForAnnotation(selector, selectorEle);
                }
                else if (selector.nodes.length + selector.connectors.length === 1) {
                    if (selector.connectors[0] instanceof Connector && canDrawThumbs(this.diagramRenderer.rendererActions)) {
                        var connector = selector.connectors[0];
                        this.diagramRenderer.renderEndPointHandle(connector, selectorEle, selector.thumbsConstraints, selectorConstraints, this.scroller.transform, connector.sourceWrapper !== undefined, connector.targetWrapper !== undefined, (this.connectorEditingToolModule && canDragSegmentThumb(connector)) ? true : false, this.connectorEditingToolModule ? true : false, selector.handleSize);
                    }
                    else if (selector.nodes[0] instanceof Node) {
                        var stackPanel = selector.nodes[0];
                        if (checkParentAsContainer(this, selector.nodes[0])) {
                            if (stackPanel.shape.type !== 'UmlClassifier' && !(stackPanel.parentId &&
                                this.nameTable[stackPanel.parentId]
                                && this.nameTable[stackPanel.parentId].shape.type === 'UmlClassifier')) {
                                selector.thumbsConstraints &= ~ThumbsConstraints.Rotate;
                            }
                        }
                        var swimlane = (stackPanel.shape.type === 'SwimLane' || stackPanel.isLane ||
                            stackPanel.isPhase) ? true : false;
                        this.diagramRenderer.renderResizeHandle(selector.wrapper.children[0], selectorEle, selector.thumbsConstraints, this.scroller.currentZoom, selector.constraints, this.scroller.transform, canHideResizers, canMove(selector.nodes[0]), (selector.nodes[0].constraints & NodeConstraints.HideThumbs) ? true : false, swimlane, selector.handleSize);
                    }
                }
                else {
                    if (this.diagramActions & DiagramAction.Interactions) {
                        this.diagramRenderer.rendererActions = this.diagramRenderer.rendererActions | RendererAction.PreventRenderSelector;
                    }
                    if (!(selectionHasConnector(this, selector) && canRender)) {
                        this.diagramRenderer.renderResizeHandle(selector.wrapper, selectorEle, selector.thumbsConstraints, this.scroller.currentZoom, selector.constraints, this.scroller.transform, canHideResizers, canMove(selector), null, null, selector.handleSize);
                    }
                    this.diagramRenderer.rendererActions = this.diagramRenderer.rendererActions & ~RendererAction.PreventRenderSelector;
                }
            }
        }
        // EJ2-56919 - Add below code to render selection rectangle for node if selected objects length is greater than one
        if (this.selectedItems.selectedObjects.length > 1) {
            this.updateSelectionRectangle();
        }
        this.enableServerDataBinding(severDataBind);
    };
    /**
     * renderSelectorForAnnotation method \
     *
     * @returns { void }     renderSelectorForAnnotation method .\
     * @param {Selector} selectorModel - provide the x value.
     * @param {(SVGElement | HTMLCanvasElement)} selectorElement - provide the y value.
     *
     * @private
     */
    //(EJ2-66036)- Annotation interaction not rendered properly
    Diagram.prototype.renderSelectorForAnnotation = function (selectorModel, selectorElement) {
        this.diagramRenderer.renderResizeHandle(selectorModel.wrapper.children[0], selectorElement, selectorModel.thumbsConstraints, this.scroller.currentZoom, selectorModel.constraints, this.scroller.transform, undefined, canMove(selectorModel.annotation), undefined, undefined, selectorModel.handleSize);
    };
    /**
     * drawSelectionRectangle method \
     *
     * @returns { void }     drawSelectionRectangle method .\
     * @param {number} x - provide the x value.
     * @param {number} y - provide the y value.
     * @param {number} width - provide the width value.
     * @param {number} height - provide the height value.
     *
     * @private
     */
    Diagram.prototype.drawSelectionRectangle = function (x, y, width, height) {
        this.clearSelectorLayer();
        this.diagramRenderer.drawSelectionRectangle(x, y, width, height, this.adornerLayer, this.scroller.transform);
    };
    /**
     * renderHighlighter method \
     *
     * @returns { void }     renderHighlighter method .\
     * @param {DiagramElement} element - provide the node value.
     *
     * @private
     */
    Diagram.prototype.renderHighlighter = function (element) {
        var adornerSvg = getAdornerLayerSvg(this.element.id);
        this.diagramRenderer.renderHighlighter(element, adornerSvg, this.scroller.transform);
    };
    /**
     * clearHighlighter method \
     *
     * @returns { void }     clearHighlighter method .\
     *
     * @private
     */
    Diagram.prototype.clearHighlighter = function () {
        var adornerSvg = getAdornerLayerSvg(this.element.id);
        var highlighter = adornerSvg.getElementById(adornerSvg.id + '_highlighter');
        if (highlighter) {
            highlighter.parentNode.removeChild(highlighter);
        }
    };
    /**
     * getNodesConnectors method \
     *
     * @returns { (NodeModel | ConnectorModel)[] }     getNodesConnectors method .\
     * @param {(NodeModel | ConnectorModel)[]} selectedItems - provide the node value.
     *
     * @private
     */
    Diagram.prototype.getNodesConnectors = function (selectedItems) {
        for (var i = 0; i < this.nodes.length; i++) {
            var node = this.nodes[parseInt(i.toString(), 10)];
            selectedItems.push(node);
        }
        for (var i = 0; i < this.connectors.length; i++) {
            var conn = this.connectors[parseInt(i.toString(), 10)];
            selectedItems.push(conn);
        }
        return selectedItems;
    };
    /**
     * clearSelectorLayer method \
     *
     * @returns { void }     clearSelectorLayer method .\
     *
     * @private
     */
    Diagram.prototype.clearSelectorLayer = function () {
        var adornerSvg = getAdornerLayerSvg(this.element.id);
        var innertemplate = document.getElementsByClassName('blazor-inner-template');
        var i;
        if (!this.currentSymbol) {
            var selectionRect = adornerSvg.getElementById(this.adornerLayer.id + '_selected_region');
            if (selectionRect) {
                selectionRect.parentNode.removeChild(selectionRect);
            }
            this.clearHighlighter();
            var childNodes = getSelectorElement(this.element.id).childNodes;
            var child = void 0;
            //Bug 914365: Node is not resizable using touch interaction
            //Added below code to get the target which we are dragging using touch interaction
            var handleId = this.eventHandler.touchArgs ? this.eventHandler.touchArgs.target.id : undefined;
            if (handleId && handleId.includes('bezierLine')) {
                handleId = undefined;
            }
            for (var i_3 = childNodes.length; i_3 > 0; i_3--) {
                //Added below code to prevent the removal of target element from DOM while doing touch move interaction
                if (this.eventHandler && this.eventHandler.touchArgs && this.eventHandler.touchArgs.type === 'touchmove') {
                    this.diagramRenderer.touchMove = true;
                    if (!(handleId && handleId === childNodes[i_3 - 1].id)) {
                        child = childNodes[i_3 - 1];
                        child.parentNode.removeChild(child);
                    }
                }
                else {
                    child = childNodes[i_3 - 1];
                    child.parentNode.removeChild(child);
                }
            }
            //Removed isBlazor code
            if (!isBlazor()) {
                var templates = getUserHandleLayer(this.element.id).childNodes;
                for (i = templates.length; i > 0; i--) {
                    templates[i - 1].parentNode.removeChild(templates[i - 1]);
                }
            }
        }
        else {
            var symbolBorder = adornerSvg.getElementById('borderRect_symbol');
            if (symbolBorder) {
                symbolBorder.parentNode.removeChild(symbolBorder);
            }
        }
    };
    /**
     * getWrapper method \
     *
     * @returns { void }     getWrapper method .\
     * @param {Container} nodes - provide the node value.
     * @param {string} id - provide the childernCollection value.
     *
     * @private
     */
    Diagram.prototype.getWrapper = function (nodes, id) {
        var wrapper;
        id = nodes.id + '_' + id;
        var container = nodes instanceof Canvas ? nodes : this.getPortContainer(this.nameTable[nodes.id]);
        for (var i = 0; i < container.children.length; i++) {
            if (id === container.children[parseInt(i.toString(), 10)].id) {
                wrapper = container.children[parseInt(i.toString(), 10)];
            }
        }
        return wrapper;
    };
    /**
     * DiagramElement method \
     *
     * @returns { void }     getEndNodeWrapper method .\
     * @param {NodeModel | ConnectorModel} node - provide the node value.
     * @param {ConnectorModel} connector - provide the childernCollection value.
     * @param {boolean} source - provide the childernCollection value.
     *
     * @private
     */
    Diagram.prototype.getEndNodeWrapper = function (node, connector, source) {
        if (node.shape.type === 'Bpmn' && node.wrapper.children[0] instanceof Canvas) {
            if ((!isBlazor() && node.shape.shape === 'Activity')) {
                if (source && node.shape.activity.subProcess.type === 'Transaction'
                    && connector.sourcePortID) {
                    var portId = connector.sourcePortID;
                    var parent_5 = node.wrapper.children[0].children[0].children[2];
                    if (parent_5.children) {
                        for (var _i = 0, _a = parent_5.children; _i < _a.length; _i++) {
                            var child = _a[_i];
                            if (child.visible && child.id === node.id + '_' + portId) {
                                return child.children[0];
                            }
                        }
                    }
                }
                return node.wrapper.children[0].children[0].children[0];
            }
            if (node.shape.shape === 'Group') {
                return node.wrapper.children[0];
            }
            return node.wrapper.children[0].children[0];
        }
        if (!this.containsMargin(node.wrapper.children[0])) {
            if (!node.children) {
                return node.wrapper.children[0];
            }
        }
        return node.wrapper;
    };
    Diagram.prototype.containsMargin = function (node) {
        return node.margin && (node.margin.left !== 0 || node.margin.top !== 0 || node.margin.right !== 0 || node.margin.bottom !== 0);
    };
    Diagram.prototype.focusOutEdit = function () {
        this.endEdit();
        // EJ2-57743 - Added below code to refresh the diagram layer after the annotation gets edited in canvas mode.
        if (this.mode === 'Canvas' && this.scroller.currentZoom !== 1) {
            this.refreshDiagramLayer();
        }
    };
    Diagram.prototype.endEditCommand = function () {
        this.endEdit();
        this.textEditing = false;
        // EJ2-57743 - Added below code to refresh the diagram layer after the annotation gets edited in canvas mode.
        if (this.mode === 'Canvas' && this.scroller.currentZoom !== 1) {
            this.refreshDiagramLayer();
        }
    };
    // EJ2-866418-keyboard shortcut keys method starting
    //Change the text style of nodes,swimlane,textnode
    Diagram.prototype.fontStyleCommand = function (format) {
        for (var i = 0; i < this.selectedItems.nodes.length; i++) {
            var node = this.selectedItems.nodes[parseInt(i.toString(), 10)];
            if (node.shape.type === 'SwimLane') {
                if (node.shape.hasHeader) {
                    this.applyStyleText(format, node.shape.header.annotation);
                }
            }
            if (node.isLane) {
                var laneHeader = this.getObject(node.shape.header[0].id);
                this.applyStyle(format, laneHeader.annotations);
            }
            if (node.shape.type === 'Text') {
                var textNode = node;
                this.applyStyleText(format, textNode);
            }
            if (node.annotations.length > 0) {
                var annotationLength = node.annotations;
                this.applyStyle(format, annotationLength);
            }
        }
        for (var i = 0; i < this.selectedItems.connectors.length; i++) {
            if (this.selectedItems.connectors[parseInt(i.toString(), 10)].annotations.length > 0) {
                var annotationLength = this.selectedItems.connectors[parseInt(i.toString(), 10)].annotations;
                this.applyStyle(format, annotationLength);
            }
        }
    };
    Diagram.prototype.applyStyle = function (format, annotationLength) {
        for (var j = 0; j < annotationLength.length; j++) {
            switch (format) {
                case 'bold':
                    annotationLength[parseInt(j.toString(), 10)].style.bold = !annotationLength[parseInt(j.toString(), 10)].style.bold;
                    break;
                case 'italic':
                    annotationLength[parseInt(j.toString(), 10)].style.italic = !annotationLength[parseInt(j.toString(), 10)].style.italic;
                    break;
                case 'underline':
                    if (annotationLength[parseInt(j.toString(), 10)].style.textDecoration === 'None') {
                        annotationLength[parseInt(j.toString(), 10)].style.textDecoration = 'Underline';
                    }
                    else if (annotationLength[parseInt(j.toString(), 10)].style.textDecoration === 'Underline') {
                        annotationLength[parseInt(j.toString(), 10)].style.textDecoration = 'None';
                    }
                    break;
            }
        }
        this.dataBind();
    };
    Diagram.prototype.applyStyleText = function (format, textNode) {
        switch (format) {
            case 'bold':
                textNode.style.bold = !textNode.style.bold;
                break;
            case 'italic':
                textNode.style.italic = !textNode.style.italic;
                break;
            case 'underline':
                if (textNode.style.textDecoration === 'None') {
                    textNode.style.textDecoration = 'Underline';
                }
                else if (textNode.style.textDecoration === 'Underline') {
                    textNode.style.textDecoration = 'None';
                }
                break;
        }
        this.dataBind();
    };
    //To duplicate the elements on clicking Ctrl+D
    Diagram.prototype.duplicateCommand = function () {
        var selectedItems = [];
        selectedItems = selectedItems.concat(this.selectedItems.nodes, this.selectedItems.connectors);
        this.copy();
        this.paste();
    };
    //To group and ungroup the elements
    Diagram.prototype.groupCommand = function (group) {
        switch (group) {
            case 'group':
                this.group();
                break;
            case 'ungroup':
                this.unGroup();
                break;
        }
    };
    //To rotate clockwise and anti-clockwise the elements
    Diagram.prototype.rotateCommand = function (rotateValue) {
        var selectedItems = this.selectedItems;
        switch (rotateValue) {
            case 'clockwise':
                this.rotate(selectedItems, 90);
                break;
            case 'antiClockwise':
                this.rotate(selectedItems, -90);
                break;
        }
    };
    //To flip horizontally and vertically the elements
    Diagram.prototype.flipCommand = function (flipValue) {
        var selectedItems = [];
        selectedItems = selectedItems.concat(this.selectedItems.nodes, this.selectedItems.connectors);
        for (var i = 0; i < selectedItems.length; i++) {
            switch (flipValue) {
                case 'horizontal':
                    selectedItems[parseInt(i.toString(), 10)].flip = FlipDirection.Horizontal;
                    break;
                case 'vertical':
                    selectedItems[parseInt(i.toString(), 10)].flip = FlipDirection.Vertical;
                    break;
            }
        }
        this.dataBind();
    };
    //To exceute the tool commands
    Diagram.prototype.toolCommand = function (tool) {
        switch (tool) {
            case 'pointer': {
                this.tool = DiagramTools.Default;
                this.dataBind();
                break;
            }
            case 'text': {
                var textnode = {
                    shape: { type: 'Text' }
                };
                this.drawingObject = textnode;
                this.tool = DiagramTools.DrawOnce;
                this.dataBind();
                break;
            }
            case 'connect': {
                var connectors = {
                    id: 'connector1',
                    type: 'Straight'
                };
                this.drawingObject = connectors;
                this.tool = DiagramTools.DrawOnce;
                this.dataBind();
                break;
            }
            case 'freeForm': {
                var freeform = { id: 'connector1', type: 'Freehand' };
                this.drawingObject = freeform;
                this.tool = DiagramTools.DrawOnce;
                this.dataBind();
                break;
            }
            case 'line': {
                var polyline = { id: 'connector1', type: 'Polyline' };
                this.drawingObject = polyline;
                this.tool = DiagramTools.DrawOnce;
                this.dataBind();
                break;
            }
            case 'rectangle': {
                var drawingshape = { type: 'Basic', shape: 'Rectangle' };
                var basicNode = {
                    shape: drawingshape
                };
                this.drawingObject = basicNode;
                this.tool = DiagramTools.DrawOnce;
                this.dataBind();
                break;
            }
            case 'ellipse': {
                var drawingNode = { type: 'Basic', shape: 'Ellipse' };
                var ellipseNode = {
                    shape: drawingNode
                };
                this.drawingObject = ellipseNode;
                this.tool = DiagramTools.DrawOnce;
                this.dataBind();
                break;
            }
        }
    };
    //To zoomin and zoom-out the diagram
    Diagram.prototype.zoomCommand = function (zoomValue) {
        switch (zoomValue) {
            case 'zoomIn':
                this.zoomTo({ type: 'ZoomIn', zoomFactor: 0.2 });
                break;
            case 'zoomOut':
                this.zoomTo({ type: 'ZoomOut', zoomFactor: 0.2 });
                break;
        }
    };
    //To move the diagram elements five pixel based on the arrow keys
    Diagram.prototype.shiftCommand = function (direction) {
        for (var i = 0; i < this.selectedItems.nodes.length; i++) {
            var pixel = 5;
            if (direction === 'Up') {
                this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetY
                    = this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetY - pixel;
            }
            else if (direction === 'Down') {
                this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetY
                    = this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetY + pixel;
            }
            else if (direction === 'Left') {
                this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetX
                    = this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetX - pixel;
            }
            else if (direction === 'Right') {
                this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetX
                    = this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetX + pixel;
            }
        }
        for (var i = 0; i < this.selectedItems.connectors.length; i++) {
            var connector = this.selectedItems;
            if (direction === 'Up') {
                this.drag(connector, 0, -5);
            }
            else if (direction === 'Down') {
                this.drag(connector, 0, 5);
            }
            else if (direction === 'Left') {
                this.drag(connector, -5, 0);
            }
            else if (direction === 'Right') {
                this.drag(connector, 5, 0);
            }
        }
    };
    //To execute the text align
    Diagram.prototype.alignCommand = function (alignDirection) {
        if (this.selectedItems.nodes.length > 0) {
            for (var i = 0; i < this.selectedItems.nodes.length; i++) {
                this.updateNodesAndConnectorAnnotation(this.selectedItems.nodes[parseInt(i.toString(), 10)], alignDirection);
            }
        }
    };
    Diagram.prototype.updateNodesAndConnectorAnnotation = function (object, alignDirection) {
        var annotation;
        for (var i = 0; i < object.annotations.length; i++) {
            annotation = object.annotations[parseInt(i.toString(), 10)];
            switch (alignDirection) {
                case 'left':
                    annotation.horizontalAlignment = 'Left';
                    break;
                case 'center':
                    annotation.horizontalAlignment = 'Center';
                    break;
                case 'right':
                    annotation.horizontalAlignment = 'Right';
                    break;
                case 'justify':
                    annotation.style.textAlign = 'Justify';
                    break;
                case 'top':
                    annotation.verticalAlignment = 'Top';
                    break;
                case 'centerVertical':
                    annotation.verticalAlignment = 'Center';
                    break;
                case 'bottom':
                    annotation.verticalAlignment = 'Bottom';
                    break;
            }
            this.dataBind();
        }
    };
    //To execute ordercommands using keyboard shortcuts
    Diagram.prototype.orderCommand = function (orderCommand) {
        switch (orderCommand) {
            case 'sendToBack':
                this.sendToBack();
                break;
            case 'bringToFront':
                this.bringToFront();
                break;
            case 'sendBackward':
                this.sendBackward();
                break;
            case 'bringForward':
                this.moveForward();
                break;
        }
    };
    //To execute the selection of elements on clicking tab key
    Diagram.prototype.navigateItems = function (tabCommand) {
        var currentSelectedNodeIndex = 0;
        var lastZIndex = this.activeLayer.objectZIndex;
        var selectedItems = [];
        var selectables = [];
        selectedItems = selectedItems.concat(this.selectedItems.nodes, this.selectedItems.connectors);
        selectables = selectables.concat(this.nodes, this.connectors);
        if (selectedItems.length > 0) {
            currentSelectedNodeIndex = selectedItems[0].zIndex + (tabCommand ? 1 : -1);
        }
        else {
            currentSelectedNodeIndex = tabCommand ? 0 : lastZIndex;
        }
        if (currentSelectedNodeIndex < 0) {
            currentSelectedNodeIndex = lastZIndex;
        }
        else if (currentSelectedNodeIndex > lastZIndex) {
            currentSelectedNodeIndex = 0;
        }
        var isSelected = false;
        do {
            for (var i = 0; i < selectables.length; i++) {
                var nextObject = selectables[parseInt(i.toString(), 10)];
                if (currentSelectedNodeIndex === nextObject.zIndex) {
                    this.clearSelection();
                    this.select([nextObject]);
                    isSelected = true;
                    break; // Exit the loop once a node or connector is selected
                }
            }
            if (!isSelected) {
                if (tabCommand) {
                    currentSelectedNodeIndex++; // If no selection has been made, increment currentSelectedNodeIndex for Tab command
                }
                else {
                    currentSelectedNodeIndex--; // If no selection has been made, decrement currentSelectedNodeIndex for shift + Tab
                }
            }
        } while (!isSelected);
    };
    /**
     * @private
     */
    /* tslint:disable */
    Diagram.prototype.endEdit = function () {
        return __awaiter$2(this, void 0, void 0, function () {
            var oldValues, changedvalues, annotations, textArea, text, element, node, annotation, args, textWrapper, index, deleteNode, contentModified, index, changesAnnotation, nodeIndex, oldnodes, newnodes, clonedObject, selectedNode, swimLaneNode, laneHeader, phaseHeader, collection, j;
            return __generator$2(this, function (_a) {
                if (this.diagramActions & DiagramAction.TextEdit) {
                    oldValues = void 0;
                    changedvalues = void 0;
                    annotations = {};
                    this.enableServerDataBinding(false);
                    textArea = document.getElementById(this.element.id + '_editBox');
                    if (!isBlazor()) {
                        text = textArea.value;
                        EventHandler.remove(textArea, 'input', this.eventHandler.inputChange);
                        EventHandler.remove(textArea, 'focusout', this.focusOutEdit);
                        element = document.getElementById(this.element.id + '_editTextBoxDiv');
                        node = void 0;
                        node = this.nameTable[this.activeLabel.parentId];
                        annotation = findAnnotation(node, this.activeLabel.id);
                        args = { oldValue: this.activeLabel.text, newValue: text, cancel: false, element: node, annotation: annotation };
                        //Removed isBlazor code
                        element.parentNode.removeChild(element);
                        textWrapper = void 0;
                        if (annotation && !(annotation instanceof Text)) {
                            index = findObjectIndex(node, annotation.id, true);
                            annotations["" + index] = { content: annotation.content };
                            oldValues = { annotations: annotations };
                        }
                        else {
                            //Removed isBlazor code
                            oldValues = { shape: { content: node.shape.content } };
                        }
                        deleteNode = false;
                        if (this.eventHandler['currentAction'] === 'Draw') {
                            deleteNode = this.eventHandler.isAddTextNode(node, true);
                        }
                        if (!deleteNode && (element.textContent !== text || text !== this.activeLabel.text)) {
                            //Removed isBlaor code
                            this.triggerEvent(DiagramEvent.textEdit, args);
                        }
                        if (!textWrapper) {
                            textWrapper = this.getWrapper(node.wrapper, this.activeLabel.id);
                        }
                        contentModified = false;
                        if (annotation.content !== text && !args.cancel) {
                            contentModified = true;
                            if (!this.activeLabel.isGroup) {
                                this.startGroupAction();
                            }
                            if (node.parentId && this.nameTable[node.parentId].shape.type === 'UmlClassifier'
                                && text.indexOf('+') === -1 && text.indexOf('-') === -1 && text.indexOf('#') === -1
                                && text.indexOf('~') === -1 && node.id.indexOf('_umlClass_header') === -1) {
                                text = ' + ' + text;
                            }
                            if (node.isLane || node.isPhase) {
                                this.protectPropertyChange(true);
                            }
                            if (!(annotation instanceof Text)) {
                                index = findObjectIndex(node, annotation.id, true);
                                changesAnnotation = {};
                                changesAnnotation["" + index] = { content: text };
                                changedvalues = { annotations: changesAnnotation };
                            }
                            else {
                                //Removed isBlazor code
                                changedvalues = { shape: { content: text } };
                            }
                            nodeIndex = this.getIndex(node, node.id);
                            if (nodeIndex) {
                                oldnodes = {};
                                oldnodes["" + nodeIndex] = oldValues;
                                newnodes = {};
                                newnodes["" + nodeIndex] = changedvalues;
                                if (getObjectType(node) === Node) {
                                    this.onPropertyChanged({ nodes: newnodes }, { nodes: oldnodes });
                                }
                                else {
                                    this.onPropertyChanged({ connectors: newnodes }, { connectors: oldnodes });
                                }
                            }
                            this.protectPropertyChange(true);
                            //Removed isBlazor code
                            annotation.content = text;
                            this.protectPropertyChange(false);
                            this.updateSelector();
                            if (node.isLane || node.isPhase) {
                                this.protectPropertyChange(false);
                            }
                        }
                        if (deleteNode) {
                            this.removeObjectsFromLayer(node);
                            this.removeFromAQuad(node);
                            delete this.nameTable[this.activeLabel.parentId];
                            if (text !== '') {
                                this.clearSelection();
                                clonedObject = cloneObject(node);
                                node = this.add(clonedObject);
                                this.updateDiagramObject(node);
                                this.commandHandler.oldSelectedObjects = cloneSelectedObjects(this);
                                this.commandHandler.select(this.nameTable[node.id]);
                                // this.commandHandler.updateBlazorSelector();
                            }
                        }
                        if (this.selectedItems.nodes.length) {
                            selectedNode = this.nameTable[this.activeLabel.parentId];
                            swimLaneNode = this.nameTable[selectedNode.parentId];
                            if ((swimLaneNode && swimLaneNode.shape.type === 'SwimLane') || (selectedNode.shape.type === 'SwimLane')) {
                                laneHeader = 'LaneHeaderParent';
                                phaseHeader = 'PhaseHeaderParent';
                                if ((selectedNode.shape.type === 'SwimLane')) {
                                    swimLaneNode = this.nameTable[this.activeLabel.parentId];
                                    selectedNode = node;
                                }
                                if ((selectedNode.isLane || selectedNode.isPhase)) {
                                    collection = selectedNode.isLane ?
                                        swimLaneNode.shape.lanes : swimLaneNode.shape.phases;
                                    for (j = 0; j < collection.length; j++) {
                                        if (collection[parseInt(j.toString(), 10)].id === (selectedNode["" + laneHeader] || selectedNode["" + phaseHeader])) {
                                            collection[parseInt(j.toString(), 10)].header.annotation.content = selectedNode.annotations[0].content;
                                        }
                                    }
                                }
                                else if (selectedNode.isHeader && swimLaneNode.shape.hasHeader) {
                                    swimLaneNode.shape.header.annotation.content = selectedNode.annotations[0].content;
                                }
                            }
                            this.dataBind();
                        }
                        textWrapper.visible = true;
                        this.updateDiagramObject(node);
                        this.diagramActions = this.diagramActions & ~DiagramAction.TextEdit;
                        if (this.activeLabel.isGroup || contentModified) {
                            this.endGroupAction();
                        }
                        this.activeLabel = { id: '', parentId: '', isGroup: false, text: undefined };
                        this.commandHandler.getBlazorOldValues();
                        //Removed isBlazor code
                        this.enableServerDataBinding(true);
                    }
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * getIndex method \
     *
     * @returns { void }     getIndex method .\
     * @param {NodeModel | ConnectorModel} node - provide the node value.
     * @param {string} id - provide the childernCollection value.
     *
     * @private
     */
    Diagram.prototype.getIndex = function (node, id) {
        //let index: number;
        var collection = (getObjectType(node) === Node) ? this.nodes : this.connectors;
        for (var i = 0; i < collection.length; i++) {
            if (collection[parseInt(i.toString(), 10)].id.toString() === id.toString()) {
                return i.toString();
            }
        }
        return null;
    };
    /* tslint:enable */
    //Removed getBlazorTextEditArgs method
    /**
     * canLogChange method \
     *
     * @returns { void }     canLogChange method .\
     *
     * @private
     */
    Diagram.prototype.canLogChange = function () {
        if ((this.diagramActions & DiagramAction.Render) && (!(this.diagramActions & DiagramAction.ToolAction)) &&
            (!(this.diagramActions & DiagramAction.UndoRedo)) && (!(this.diagramActions & DiagramAction.PublicMethod))) {
            return true;
        }
        else {
            return false;
        }
    };
    Diagram.prototype.modelChanged = function (newProp, oldProp) {
        if (newProp.connectors || oldProp.connectors || newProp.nodes || oldProp.connectors
            || newProp.pageSettings || oldProp.pageSettings || newProp.bridgeDirection || oldProp.bridgeDirection) {
            return true;
        }
        return false;
    };
    Diagram.prototype.resetDiagramActions = function (action) {
        var isAction = action ? true : false;
        if (this.diagramActions & DiagramAction.UndoRedo && (!isAction || (action === DiagramAction.UndoRedo))) {
            this.diagramActions = this.diagramActions & ~DiagramAction.UndoRedo;
        }
        if (this.diagramActions & DiagramAction.PublicMethod && (!isAction || action === DiagramAction.PublicMethod)) {
            this.diagramActions = this.diagramActions & ~DiagramAction.PublicMethod;
        }
    };
    /**
     * removeNode method \
     *
     * @returns { void }     removeNode method .\
     * @param {NodeModel} node - provide the node value.
     * @param {NodeModel} childrenCollection - provide the childrenCollection value.
     *
     * @private
     */
    Diagram.prototype.removeNode = function (node, childrenCollection) {
        this.removeObjectsFromLayer(node);
        this.removeFromAQuad(this.nameTable[node.id]);
        var groupElement = document.getElementById(node.id + '_groupElement');
        delete this.nameTable[node.id];
        if (node.children) {
            delete this.groupTable[node.id];
        }
        //Removed isBlazor code
        this.nodes.splice(this.nodes.indexOf(node), 1);
        if (groupElement && groupElement.children && groupElement.children.length > 0) {
            var beforeElement = undefined;
            for (var j = groupElement.children.length - 1; j >= 0; j--) {
                var childElement = groupElement.children[parseInt(j.toString(), 10)];
                //EJ2-863636 - Nodes Removed from Diagram upon Ungrouping
                if (childrenCollection.length > 0 && childrenCollection.indexOf(childElement.id.split('_groupElement')[0]) !== -1) {
                    if (!beforeElement) {
                        groupElement.parentNode.insertBefore(childElement, groupElement);
                    }
                    else {
                        groupElement.parentNode.insertBefore(childElement, beforeElement);
                    }
                    beforeElement = childElement;
                }
            }
        }
        if (groupElement) {
            groupElement.parentNode.removeChild(groupElement);
        }
    };
    /**
     * deleteGroup method \
     *
     * @returns { void }     deleteGroup method .\
     * @param {NodeModel} node - provide the source value.
     *
     * @private
     */
    Diagram.prototype.deleteGroup = function (node) {
        var elements = [];
        var tempNode = [];
        if (node.children) {
            tempNode = this.commandHandler.getChildren(node, elements);
        }
        this.UpdateBlazorDiagramModelCollection(node);
        for (var _i = 0, tempNode_1 = tempNode; _i < tempNode_1.length; _i++) {
            var nodes = tempNode_1[_i];
            if (nodes && this.nameTable[nodes.id]) {
                this.remove(nodes);
            }
        }
    };
    //helper methods - end region
    //property changes - start region
    /** @private */
    /**
     * updateObject method \
     *
     * @returns { void }     updateObject method .\
     * @param {Node | Connector} actualObject - provide the source value.
     * @param {Node | Connector} oldObject - provide the target value.
     * @param {Node | Connector} changedProp - provide the layoutOrientation value.
     *
     * @private
     */
    Diagram.prototype.updateObject = function (actualObject, oldObject, changedProp) {
        if (!(this.diagramActions & DiagramAction.ToolAction)) {
            var bound = actualObject.wrapper.children[0].bounds;
            var checkBoundaryConstraints = this.commandHandler.checkBoundaryConstraints(undefined, undefined, bound, true);
            if (!checkBoundaryConstraints) {
                if (actualObject instanceof Node) {
                    var oldNode = oldObject;
                    for (var _i = 0, _a = Object.keys(changedProp); _i < _a.length; _i++) {
                        var key = _a[_i];
                        switch (key) {
                            case 'width':
                                actualObject.width = oldNode.width;
                                break;
                            case 'height':
                                actualObject.height = oldNode.height;
                                break;
                            case 'offsetX':
                                actualObject.offsetX = oldNode.offsetX;
                                break;
                            case 'offsetY':
                                actualObject.offsetY = oldNode.offsetY;
                                break;
                            case 'rotateAngle':
                                actualObject.rotateAngle = oldNode.rotateAngle;
                                break;
                        }
                    }
                    this.nodePropertyChange(actualObject, changedProp, oldObject);
                }
                else {
                    for (var _b = 0, _c = Object.keys(changedProp); _b < _c.length; _b++) {
                        var key = _c[_b];
                        var oldConnector = oldObject;
                        var actualSourcePoint = actualObject.sourcePoint;
                        var actualTargetPoint = actualObject.targetPoint;
                        switch (key) {
                            case 'sourcePoint':
                                actualSourcePoint.x = oldConnector.sourcePoint.x || actualSourcePoint.x;
                                actualSourcePoint.y = oldConnector.sourcePoint.y || actualSourcePoint.y;
                                break;
                            case 'targetPoint':
                                actualTargetPoint.x = oldConnector.targetPoint.x || actualTargetPoint.x;
                                actualTargetPoint.y = oldConnector.targetPoint.y || actualTargetPoint.y;
                        }
                    }
                    this.connectorPropertyChange(actualObject, changedProp, oldObject);
                }
            }
        }
    };
    Diagram.prototype.nodePropertyChangeExtend = function (actualObject, oldObject, node, update) {
        if (node.style !== undefined && actualObject.shape.type !== 'Bpmn') {
            updateStyle(node.style, actualObject.wrapper.children[0]);
            update = true;
        }
        if (node.shadow !== undefined) {
            this.updateShadow(actualObject.shadow, node.shadow);
            update = true;
        }
        if (node.constraints !== undefined) {
            if ((oldObject.constraints & NodeConstraints.Select) &&
                (!(node.constraints & NodeConstraints.Select)) && isSelected(this, actualObject)) {
                this.clearSelection();
            }
            else {
                this.updateThumbConstraints(this.selectedItems.nodes, this.selectedItems);
                this.updateSelector();
                update = true;
            }
        }
        this.updateTextAnnotationInSwimlane(actualObject, node);
        this.swimLaneNodePropertyChange(actualObject, oldObject, node, update);
        return update;
    };
    //To update text annotation node inside swimlane while dragging the text annotation parent.
    Diagram.prototype.updateTextAnnotationInSwimlane = function (actualObject, node) {
        if (actualObject.hasTextAnnotation && this.isPositionUndo) {
            for (var i = 0; i < actualObject.outEdges.length; i++) {
                var con = this.nameTable[actualObject.outEdges[parseInt(i.toString(), 10)]];
                if (con.isBpmnAnnotationConnector) {
                    var textNode = this.nameTable[con.targetID];
                    this.isProtectedOnChange = true;
                    if (actualObject.laneMargin && textNode) {
                        var dx = actualObject.margin.left - actualObject.laneMargin.left;
                        var dy = actualObject.margin.top - actualObject.laneMargin.top;
                        textNode.margin.left += dx;
                        textNode.margin.top += dy;
                        textNode.offsetX += dx;
                        textNode.offsetY += dy;
                        textNode.wrapper.offsetX += dx;
                        textNode.wrapper.offsetY += dy;
                        textNode.wrapper.measure(new Size(textNode.wrapper.width, textNode.wrapper.height));
                        textNode.wrapper.arrange(textNode.wrapper.desiredSize);
                        this.updateDiagramObject(textNode);
                    }
                    this.isProtectedOnChange = false;
                }
            }
        }
    };
    /* tslint:disable */
    Diagram.prototype.swimLaneNodePropertyChange = function (actualObject, oldObject, node, update) {
        if (actualObject.shape.type === 'SwimLane' && !this.currentSymbol) {
            if (oldObject.shape) {
                var shape = node.shape;
                var actualShape = actualObject.shape;
                var orientation_1 = (actualShape.orientation === 'Horizontal') ? true : false;
                var padding = actualShape.padding;
                var oldShape = oldObject.shape;
                var grid = actualObject.wrapper.children[0];
                var oldObjects = void 0;
                var newObjects = void 0;
                var id = void 0;
                if (oldShape.lanes || oldShape.phases) {
                    if (oldShape.lanes) {
                        for (var _i = 0, _a = Object.keys(shape.lanes); _i < _a.length; _i++) {
                            var count = _a[_i];
                            var indexValue = Number(count);
                            var lane = oldShape.lanes[parseInt(indexValue.toString(), 10)];
                            var laneIndex = void 0;
                            var newLane = shape.lanes[parseInt(indexValue.toString(), 10)];
                            if (newLane && newLane.header) {
                                id = actualShape.lanes[parseInt(indexValue.toString(), 10)].header.id;
                                oldObjects = lane.header;
                                newObjects = newLane.header;
                                // EJ2-913790  Save Load for header font change won't be as saved
                                if (newObjects.annotation && newObjects.annotation.content) {
                                    this.nameTable["" + id].annotations[0].content = newObjects.annotation.content;
                                }
                                if (newObjects.annotation && newObjects.annotation.style) {
                                    this.nameTable["" + id].annotations[0].style = newObjects.annotation.style;
                                }
                                this.nodePropertyChange(this.nameTable["" + id], oldObjects, newObjects);
                            }
                            if (lane.children) {
                                for (var _b = 0, _c = Object.keys(lane.children); _b < _c.length; _b++) {
                                    var childNodeIndex = _c[_b];
                                    id = actualShape.lanes[parseInt(indexValue.toString(), 10)].children[Number(childNodeIndex)].id;
                                    var node_1 = this.nameTable["" + id];
                                    oldObjects = lane.children[Number(childNodeIndex)];
                                    newObjects = newLane.children[Number(childNodeIndex)];
                                    this.nodePropertyChange(node_1, oldObjects, newObjects);
                                }
                            }
                            if (lane.width && !orientation_1) {
                                laneIndex = (actualShape.phases && actualShape.phaseSize) ? indexValue + 1 : indexValue;
                                grid.updateColumnWidth(laneIndex, newLane.width, true, padding);
                                this.updateDiagramElementQuad();
                            }
                            if (lane.height && orientation_1) {
                                laneIndex = (actualShape.header && actualShape.hasHeader) ? indexValue + 1 : indexValue;
                                laneIndex += (actualShape.phases && actualShape.phaseSize) ? 1 : 0;
                                grid.updateRowHeight(laneIndex, newLane.height, true, padding);
                                this.updateDiagramElementQuad();
                            }
                        }
                    }
                    if (shape.phases) {
                        for (var _d = 0, _e = Object.keys(shape.phases); _d < _e.length; _d++) {
                            var key = _e[_d];
                            var indexValue = Number(key);
                            var phase = shape.phases[parseInt(indexValue.toString(), 10)];
                            var size = void 0;
                            var rowIndex = (actualShape.header && actualShape.hasHeader) ? 1 : 0;
                            if (phase && phase.header) {
                                id = actualShape.phases[parseInt(indexValue.toString(), 10)].header.id;
                                oldObjects = oldShape.phases[parseInt(indexValue.toString(), 10)].header;
                                newObjects = phase.header;
                                // EJ2-913790  Save Load for header font change won't be as saved
                                if (newObjects.annotation && newObjects.annotation.content) {
                                    this.nameTable["" + id].annotations[0].content = newObjects.annotation.content;
                                }
                                if (newObjects.annotation && newObjects.annotation.style) {
                                    this.nameTable["" + id].annotations[0].style = newObjects.annotation.style;
                                }
                                this.nodePropertyChange(this.nameTable["" + id], oldObjects, newObjects);
                            }
                            if (phase.offset) {
                                if (indexValue === 0) {
                                    size = phase.offset;
                                }
                                else {
                                    var previousPhase = actualShape.phases[indexValue - 1];
                                    size = phase.offset - previousPhase.offset;
                                    if (size <= 0) {
                                        size = phase.offset;
                                    }
                                }
                                if (orientation_1) {
                                    grid.updateColumnWidth(indexValue, size, true, padding);
                                    updatePhaseMaxWidth(actualObject, this, grid.rows[parseInt(rowIndex.toString(), 10)].cells[parseInt(indexValue.toString(), 10)], indexValue);
                                }
                                else {
                                    grid.updateRowHeight(rowIndex + indexValue, size, true, padding);
                                }
                            }
                        }
                    }
                }
                if (shape.phaseSize !== undefined && actualShape.phases.length) {
                    if (shape.phaseSize === 0 || oldShape.phaseSize === 0) {
                        if (oldShape.phaseSize) {
                            if (orientation_1) {
                                grid.removeRow((actualShape.header && actualShape.hasHeader) ? 1 : 0);
                                actualObject.height = actualObject.wrapper.height = grid.height;
                            }
                            else {
                                if (actualShape.header && actualShape.hasHeader) {
                                    grid.rows[0].cells[1].children = grid.rows[0].cells[0].children;
                                    grid.rows[0].cells[1].columnSpan = grid.rows[0].cells[0].columnSpan - 1;
                                    grid.rows[0].cells[0].children = [];
                                }
                                grid.removeColumn(0);
                            }
                        }
                        else {
                            if (orientation_1) {
                                var rowDef = new RowDefinition();
                                rowDef.height = shape.phaseSize;
                                grid.addRow((actualShape.header && actualShape.hasHeader) ? 1 : 0, rowDef, true);
                                actualObject.height = actualObject.wrapper.height += shape.phaseSize;
                            }
                            else {
                                var colDef = new ColumnDefinition();
                                colDef.width = shape.phaseSize;
                                grid.addColumn(0, colDef, true);
                                if (actualShape.header && actualShape.hasHeader) {
                                    grid.rows[0].cells[0].children = grid.rows[0].cells[1].children;
                                    grid.rows[0].cells[1].children = [];
                                    grid.rows[0].cells[1].columnSpan = 1;
                                    grid.rows[0].cells[1].minWidth = undefined;
                                    grid.rows[0].cells[0].columnSpan = actualShape.lanes.length + 1;
                                }
                            }
                            for (var k = 0; k < actualShape.phases.length; k++) {
                                if (actualShape.phases[parseInt(k.toString(), 10)].id === '') {
                                    actualShape.phases[parseInt(k.toString(), 10)].id = randomId();
                                }
                                phaseDefine(grid, this, actualObject, (actualShape.header && actualShape.hasHeader) ? 1 : 0, orientation_1, k);
                            }
                        }
                    }
                    else {
                        if (orientation_1) {
                            grid.updateRowHeight((actualShape.header && actualShape.hasHeader) ? 1 : 0, shape.phaseSize, false);
                        }
                        else {
                            grid.updateColumnWidth(0, shape.phaseSize, false);
                        }
                    }
                }
                if (actualShape.header && actualShape.hasHeader && oldShape.header) {
                    var id_1 = grid.rows[0].cells[0].children[0].id;
                    var headerNode = this.nameTable["" + id_1];
                    this.nodePropertyChange(headerNode, (oldShape.header), shape.header);
                }
                actualObject.height = actualObject.wrapper.height = grid.height;
                actualObject.width = actualObject.wrapper.width = grid.width;
            }
            else if (oldObject.constraints) {
                var oldSelectConstraints = (oldObject.constraints & NodeConstraints.Select);
                var newSelectConstraints = (node.constraints & NodeConstraints.Select);
                if (oldSelectConstraints !== newSelectConstraints) {
                    var shape = actualObject.shape;
                    // Header - constraints
                    var headerNode = this.nameTable[actualObject.id + shape.header.id];
                    headerNode.constraints = (!newSelectConstraints) ? headerNode.constraints & ~NodeConstraints.Select :
                        headerNode.constraints | NodeConstraints.Select;
                    // Phase - Constraints
                    var phaseNode = void 0;
                    if (shape.phaseSize > 0) {
                        for (var i = 0; i < shape.phases.length; i++) {
                            phaseNode = this.nameTable[actualObject.id + shape.phases[parseInt(i.toString(), 10)].id + '_header'];
                            phaseNode.constraints = (!newSelectConstraints) ? phaseNode.constraints & ~NodeConstraints.Select :
                                phaseNode.constraints | NodeConstraints.Select;
                        }
                    }
                    // Header - Constraints
                    var laneNode = void 0;
                    var laneHeader = void 0;
                    var value = shape.phases.length || 1;
                    for (var i = 0; i < shape.lanes.length; i++) {
                        for (var l = 0; l < value; l++) {
                            laneNode = this.nameTable[actualObject.id + shape.lanes[parseInt(i.toString(), 10)].id + l];
                            laneNode.constraints = (!newSelectConstraints) ? laneNode.constraints & ~NodeConstraints.Select :
                                laneNode.constraints | NodeConstraints.Select;
                            if (l === 0) {
                                laneHeader = this.nameTable[actualObject.id + shape.lanes[parseInt(i.toString(), 10)].id + '_' + l + '_header'];
                                laneHeader.constraints = (!newSelectConstraints) ? laneHeader.constraints & ~NodeConstraints.Select :
                                    laneHeader.constraints | NodeConstraints.Select;
                            }
                        }
                    }
                }
            }
            update = true;
        }
        return update;
    };
    /** @private */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Diagram.prototype.insertValue = function (oldNodeObject, isNode) {
        if (!(this.blazorActions & BlazorAction.GroupClipboardInProcess)) {
            var value = void 0;
            var oldObjects = isNode ? this.oldNodeObjects : this.oldConnectorObjects;
            for (var i = 0; i < oldObjects.length; i++) {
                if (oldObjects[parseInt(i.toString(), 10)].id === oldNodeObject.id) {
                    value = true;
                }
            }
            if (!value) {
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                isNode ? (this.oldNodeObjects.push(oldNodeObject)) : this.oldConnectorObjects.push(oldNodeObject);
            }
        }
    };
    /* tslint:disable */
    /** @private */
    // eslint-disable-next-line max-len
    Diagram.prototype.nodePropertyChange = function (actualObject, oldObject, node, isLayout, rotate, propertyChange) {
        if (this.canEnableBlazorObject && actualObject.id !== 'helper') {
            var node_2 = cloneObject(actualObject);
            this.insertValue(node_2, true);
        }
        var existingBounds = actualObject.wrapper.outerBounds;
        var existingInnerBounds = actualObject.wrapper.bounds;
        var updateConnector = false;
        var update;
        var oldBpmnOffsetX = 0;
        var newBpmnOffsetX = 0;
        var oldBpmnOffsetY = 0;
        var newBpmnOffsetY = 0;
        var sizeChanged = false;
        var offsetChanged = false;
        var angleChanged = false;
        if (node.width !== undefined) {
            if (!actualObject.children) {
                actualObject.wrapper.children[0].width = node.width;
                update = true;
                updateConnector = true;
            }
            else if (!actualObject.container) {
                this.scaleObject(actualObject, node.width, true);
            }
            else {
                actualObject.wrapper.width = node.width;
            }
            sizeChanged = true;
        }
        if (node.height !== undefined) {
            if (!actualObject.children) {
                actualObject.wrapper.children[0].height = node.height;
                update = true;
                updateConnector = true;
            }
            else if (!actualObject.container) {
                this.scaleObject(actualObject, node.height, false);
            }
            else {
                actualObject.wrapper.height = node.height;
            }
            sizeChanged = true;
        }
        update = this.nodePropertyChangeExtend(actualObject, oldObject, node, update);
        if (node.constraints !== undefined && canShadow(oldObject) !== canShadow(node)) {
            actualObject.wrapper.children[0].shadow = canShadow(actualObject) ? actualObject.shadow : null;
        }
        if (node.offsetX !== undefined) {
            oldBpmnOffsetX = oldObject.offsetX;
            newBpmnOffsetX = node.offsetX;
            if (actualObject.wrapper.flip !== FlipDirection.None) {
                if (actualObject.offsetX !== actualObject.wrapper.offsetX && oldObject.offsetX !== undefined) {
                    var offsetX_1 = node.offsetX - oldObject.offsetX;
                    actualObject.wrapper.offsetX = actualObject.wrapper.offsetX + offsetX_1;
                    this.updateFlipOffset(actualObject.wrapper, offsetX_1, 0, actualObject.wrapper.flip);
                }
                //EJ2-895070: Flipping and moving the node are not working properly
                else {
                    actualObject.wrapper.offsetX = node.offsetX;
                }
            }
            else {
                actualObject.wrapper.offsetX = node.offsetX;
            }
            update = true;
            updateConnector = true;
            offsetChanged = true;
        }
        if (node.offsetY !== undefined) {
            oldBpmnOffsetY = oldObject.offsetY;
            newBpmnOffsetY = node.offsetY;
            if (actualObject.wrapper.flip !== FlipDirection.None) {
                if (actualObject.offsetY !== actualObject.wrapper.offsetY && oldObject.offsetY !== undefined) {
                    var offsetY_1 = node.offsetY - oldObject.offsetY;
                    actualObject.wrapper.offsetY = actualObject.wrapper.offsetY + offsetY_1;
                    this.updateFlipOffset(actualObject.wrapper, 0, offsetY_1, actualObject.wrapper.flip);
                }
                //EJ2-895070: Flipping and moving the node are not working properly
                else {
                    actualObject.wrapper.offsetY = node.offsetY;
                }
            }
            else {
                actualObject.wrapper.offsetY = node.offsetY;
            }
            update = true;
            updateConnector = true;
            offsetChanged = true;
        }
        if (node.padding !== undefined) {
            actualObject.wrapper.padding.left = node.padding.left !== undefined ? node.padding.left : actualObject.wrapper.padding.left;
            actualObject.wrapper.padding.right = node.padding.right !== undefined ? node.padding.right : actualObject.wrapper.padding.right;
            actualObject.wrapper.padding.top = node.padding.top !== undefined ? node.padding.top : actualObject.wrapper.padding.top;
            actualObject.wrapper.padding.bottom = node.padding.bottom !== undefined ? node.padding.bottom
                : actualObject.wrapper.padding.bottom;
            update = true;
        }
        if (node.pivot !== undefined) {
            actualObject.wrapper.pivot = node.pivot;
            update = true;
        }
        if (node.minWidth !== undefined) {
            actualObject.wrapper.minWidth = actualObject.wrapper.children[0].minWidth = node.minWidth;
            update = true;
            updateConnector = true;
            sizeChanged = true;
        }
        if (node.minHeight !== undefined) {
            actualObject.wrapper.minHeight = actualObject.wrapper.children[0].minHeight = node.minHeight;
            update = true;
            updateConnector = true;
            sizeChanged = true;
        }
        if (node.maxWidth !== undefined) {
            actualObject.wrapper.maxWidth = node.maxWidth;
            update = true;
            updateConnector = true;
            sizeChanged = true;
        }
        if (node.maxHeight !== undefined) {
            actualObject.wrapper.maxHeight = node.maxHeight;
            update = true;
            updateConnector = true;
            sizeChanged = true;
        }
        if (node.flip !== undefined) {
            var horizontal = ((node.flip & FlipDirection.Horizontal) ^
                (actualObject.wrapper.flip & FlipDirection.Horizontal)) === FlipDirection.Horizontal;
            var vertical = ((node.flip & FlipDirection.Vertical) ^
                (actualObject.wrapper.flip & FlipDirection.Vertical)) === FlipDirection.Vertical;
            if (horizontal) {
                actualObject.wrapper.flip ^= FlipDirection.Horizontal;
            }
            if (vertical) {
                actualObject.wrapper.flip ^= FlipDirection.Vertical;
            }
            update = true;
            updateConnector = true;
            alignElement(actualObject.wrapper, actualObject.offsetX, actualObject.offsetY, this, undefined, horizontal, vertical);
            //To update the port and text wrapper element flip
            this.updateWrapperChildFlip(actualObject);
        }
        if (node.flipMode !== undefined) {
            var changeFlipMode = '';
            changeFlipMode = actualObject.wrapper.flipMode = node.flipMode;
            update = true;
            updateConnector = true;
            //To update the port and text wrapper element flip mode
            this.updateWrapperChildFlip(actualObject, changeFlipMode);
        }
        if (node.rotateAngle !== undefined && (actualObject.constraints & NodeConstraints.Rotate)) {
            if (actualObject.children && rotate) {
                // eslint-disable-next-line max-len
                this.commandHandler.rotateObjects(actualObject, [actualObject], actualObject.rotateAngle - actualObject.wrapper.rotateAngle, { x: actualObject.offsetX, y: actualObject.offsetY }, false);
            }
            actualObject.wrapper.rotateAngle = node.rotateAngle;
            update = true;
            updateConnector = true;
            angleChanged = true;
        }
        if (node.backgroundColor !== undefined) {
            actualObject.wrapper.style.fill = node.backgroundColor;
        }
        if (node.visible !== undefined) {
            this.updateElementVisibility(actualObject.wrapper, actualObject, actualObject.visible);
        }
        if (node.shape !== undefined && actualObject.shape.type !== 'Bpmn') {
            update = true;
            updateShape(node, actualObject, oldObject, this);
            updateConnector = true;
        }
        if (node.margin) {
            update = true;
            this.updateMargin(actualObject, node);
            updateConnector = true;
            offsetChanged = true;
        }
        if ((((node.shape !== undefined && (node.shape.type === undefined)) || node.width !== undefined || node.height !== undefined ||
            node.style !== undefined) && actualObject.shape.type === 'Bpmn' && this.bpmnModule)) {
            update = true;
            updateConnector = true;
            this.bpmnModule.updateBPMN(node, oldObject, actualObject, this);
        }
        if (actualObject.shape.type === 'UmlActivity' && ((!isBlazor() && actualObject.shape.shape === 'FinalNode'))) {
            update = true;
            updateConnector = true;
            this.updateUMLActivity(node, oldObject, actualObject, this);
        }
        if ((actualObject.shape && actualObject.shape.type === 'UmlClassifier') || (actualObject.parentId &&
            this.nameTable[actualObject.parentId] && this.nameTable[actualObject.parentId].shape.type === 'UmlClassifier')) {
            update = true;
            updateConnector = true;
        }
        if (node.ports !== undefined) {
            for (var _i = 0, _a = Object.keys(node.ports); _i < _a.length; _i++) {
                var key = _a[_i];
                var index = Number(key);
                update = true;
                var changedObject = node.ports["" + key];
                var actualPort = actualObject.ports[parseInt(index.toString(), 10)];
                this.updatePort(changedObject, actualPort, actualObject.wrapper);
                if (actualObject.flip !== FlipDirection.None) {
                    if (actualObject.flipMode === 'Port' || actualObject.flipMode === 'PortAndLabel' || actualObject.flipMode === 'PortAndLabelText' || actualObject.flipMode === 'All') {
                        this.updatePorts(actualObject, actualObject.flip);
                    }
                }
                updateConnector = true;
            }
        }
        if (node.annotation !== undefined || node.annotations !== undefined || node.width !== undefined) {
            for (var _b = 0, _c = Object.keys(node.annotations || actualObject.annotations); _b < _c.length; _b++) {
                var key = _c[_b];
                var index = Number(key);
                update = true;
                var changedObject = void 0;
                if (node.annotation) {
                    changedObject = node.annotation;
                }
                else {
                    changedObject = node.annotations ? node.annotations["" + key] : actualObject.annotations;
                }
                var actualAnnotation = actualObject.annotations[parseInt(index.toString(), 10)];
                if (actualAnnotation) {
                    var updateSize = actualObject.width ? true : false;
                    this.updateAnnotation(changedObject, actualAnnotation, actualObject.wrapper, actualObject, updateSize);
                    var swimLaneNode = this.nameTable[actualObject.parentId];
                    if ((swimLaneNode && swimLaneNode.shape.type === 'SwimLane')) {
                        var laneHeader = 'LaneHeaderParent';
                        var phaseHeader = 'PhaseHeaderParent';
                        if ((actualObject.isLane || actualObject.isPhase)) {
                            var collection = actualObject.isLane ?
                                swimLaneNode.shape.lanes : swimLaneNode.shape.phases;
                            for (var j_2 = 0; j_2 < collection.length; j_2++) {
                                if (collection[parseInt(j_2.toString(), 10)].id === (actualObject["" + laneHeader] || actualObject["" + phaseHeader])) {
                                    collection[parseInt(j_2.toString(), 10)].header.annotation.content = actualObject.annotations[0].content;
                                    collection[parseInt(j_2.toString(), 10)].header.annotation.style = actualObject.annotations[0].style;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
        if (node.expandIcon !== undefined || node.collapseIcon !== undefined || node.isExpanded !== undefined) {
            this.updateIcon(actualObject);
            this.updateDefaultLayoutIcons(actualObject);
            if (node.isExpanded !== undefined) {
                this.canExpand = true;
                //EJ2-844814 - Expand and collapse not working properly at runtime
                this.diagramActions |= DiagramAction.PreventIconsUpdate;
                this.commandHandler.expandNode(actualObject, this);
                this.diagramActions = this.diagramActions & ~DiagramAction.PreventIconsUpdate;
            }
            update = true;
            this.canExpand = false;
        }
        if (node.fixedUserHandles !== undefined) {
            var index = void 0;
            var changedObject = void 0;
            var actualfixedUserHandle = void 0;
            for (var _d = 0, _e = Object.keys(node.fixedUserHandles); _d < _e.length; _d++) {
                var key = _e[_d];
                index = Number(key);
                update = true;
                if (node.fixedUserHandles[parseInt(index.toString(), 10)]) {
                    changedObject = node.fixedUserHandles[parseInt(index.toString(), 10)];
                }
                actualfixedUserHandle = actualObject.fixedUserHandles[parseInt(index.toString(), 10)];
                if (actualfixedUserHandle) {
                    this.updateNodefixedUserHandle(changedObject, actualfixedUserHandle, actualObject.wrapper, actualObject);
                }
            }
        }
        if (node.tooltip !== undefined) {
            this.updateTooltip(actualObject, node);
        }
        if (update) {
            if (this.bpmnModule !== undefined && (offsetChanged || sizeChanged) && !angleChanged) {
                // eslint-disable-next-line max-len
                this.updateBpmnAnnotationPosition(oldBpmnOffsetX, oldBpmnOffsetY, newBpmnOffsetX, newBpmnOffsetY, actualObject, actualObject.wrapper, actualObject.shape, actualObject.shape.shape === 'TextAnnotation', oldObject, sizeChanged, this.sizeUndo);
            }
            if (this.checkSelectedItem(actualObject) && actualObject.wrapper.children[0] instanceof TextElement) {
                actualObject.wrapper.children[0].refreshTextElement();
            }
            actualObject.wrapper.measure(new Size(actualObject.wrapper.bounds.width, actualObject.wrapper.bounds.height), actualObject.id, this.onLoadImageSize.bind(this));
            actualObject.wrapper.arrange(actualObject.wrapper.desiredSize);
            this.updateObject(actualObject, oldObject, node);
            if (actualObject.shape.type === 'SwimLane' && !this.currentSymbol && !(this.diagramActions & DiagramAction.ToolAction)) {
                updateHeaderMaxWidth(this, actualObject);
                var grid = actualObject.wrapper.children[0];
                var shape = actualObject.shape;
                var column = grid.columnDefinitions().length;
                if (shape.orientation === 'Horizontal') {
                    var index = (shape.header && shape.hasHeader) ? 1 : 0;
                    updatePhaseMaxWidth(actualObject, this, grid.rows[parseInt(index.toString(), 10)].cells[column - 1], column - 1);
                }
                actualObject.wrapper.measure(new Size(actualObject.wrapper.bounds.width, actualObject.wrapper.bounds.height));
                actualObject.wrapper.arrange(actualObject.wrapper.desiredSize);
            }
            if ((!(this.diagramActions & DiagramAction.ToolAction)) || (this.diagramActions & DiagramAction.UndoRedo)) {
                if (this.checkSelectedItem(actualObject)) {
                    this.updateSelector();
                }
            }
            if (existingBounds.equals(existingBounds, actualObject.wrapper.outerBounds) === false) {
                this.updateQuad(actualObject);
                // EJ2-57436 - Added the below code to check if node has parent id or not.
                // If node has parentId means then send the parent node to updatequad method to add the parent node in negative quadrant
                if (actualObject.parentId && this.nameTable[actualObject.parentId]) {
                    var parentNode = this.nameTable[actualObject.parentId];
                    this.updateQuad(parentNode);
                }
            }
            if (!isLayout) {
                // eslint-disable-next-line max-len
                this.commandHandler.connectorSegmentChange(actualObject, existingInnerBounds, (node.rotateAngle !== undefined) ? true : false);
                // if (updateConnector) {
                //     this.updateConnectorEdges(actualObject);
                // }
            }
            else {
                if (actualObject && actualObject.visible && actualObject.outEdges) {
                    this.updateIconVisibility(actualObject, (actualObject.outEdges.length === 0 ? false : true));
                }
            }
            if (this.bpmnModule !== undefined) {
                this.bpmnModule.updateDocks(actualObject, this);
            }
            if ((!node.annotations || !actualObject.processId) && node.flip === undefined) {
                this.updateGroupOffset(actualObject);
            }
            // if (existingBounds.equals(existingBounds, actualObject.wrapper.outerBounds) === false) { this.updateQuad(actualObject); }
            // EJ2-42005 - The parent of the actualObject is not measured and arranged when a node or connector is selected.
            // The condition restricts the measure and arrange of the actualObject whenever a node or connector is selected.
            // Commented @Dheepshiva
            // let objects: (NodeModel | ConnectorModel)[] = [];
            // objects = objects.concat(this.selectedItems.nodes, this.selectedItems.connectors);
            // if (objects.length === 0) {
            if (actualObject.parentId && this.nameTable[actualObject.parentId]) {
                var parent_6 = this.nameTable[actualObject.parentId];
                parent_6.wrapper.measure(new Size(parent_6.wrapper.width, actualObject.wrapper.height));
                parent_6.wrapper.arrange(parent_6.wrapper.desiredSize);
                parent_6.offsetX = parent_6.wrapper.offsetX;
                parent_6.offsetY = parent_6.wrapper.offsetY;
            }
            // }
            if (existingInnerBounds.equals(existingInnerBounds, actualObject.wrapper.bounds) === false) {
                if (this.eventHandler.currentAction !== 'Drag') {
                    this.updateGroupSize(actualObject);
                }
                if (actualObject.children) {
                    this.updateGroupOffset(actualObject);
                }
            }
            if (actualObject.shape.type === 'SwimLane' && !this.currentSymbol && (this.diagramActions & DiagramAction.Render)) {
                var connectors = getConnectors(this, actualObject.wrapper.children[0]);
                updateConnectorsProperties(connectors, this);
            }
            if (!this.preventNodesUpdate) {
                if (!canVitualize(this) || (canVitualize(this) && this.scroller.oldCollectionObjects.indexOf(actualObject.id) > -1)) {
                    if (this.diagramActions & DiagramAction.PreventZIndexOnDragging) {
                        this.updateDiagramObject(actualObject, true);
                    }
                    else {
                        this.updateDiagramObject(actualObject);
                    }
                    if (actualObject.parentId) {
                        var parent_7 = this.nameTable[actualObject.parentId];
                        if (parent_7.shape.type !== 'BPMN') {
                            if (this.diagramActions & DiagramAction.PreventZIndexOnDragging) {
                                this.updateDiagramObject(parent_7, true);
                            }
                            else {
                                this.updateDiagramObject(parent_7);
                            }
                        }
                    }
                }
                if (!isLayout && updateConnector) {
                    if (this.lineRoutingModule && this.diagramActions && (this.constraints & DiagramConstraints.LineRouting) && actualObject.id !== 'helper') {
                        if (!(this.diagramActions & DiagramAction.ToolAction)) {
                            this.lineRoutingModule.renderVirtualRegion(this, true);
                        }
                    }
                    else if (this.diagramActions && (this.constraints & DiagramConstraints.LineRouting) && actualObject.id !== 'helper') {
                        console.warn('[WARNING] :: Module "LineRouting" is not available in Diagram component! You either misspelled the module name or forgot to load it.');
                    }
                    this.updateConnectorEdges(actualObject);
                    if (actualObject.id !== 'helper' && !(this.diagramActions & DiagramAction.ToolAction)) {
                        var objects = this.spatialSearch.findObjects(actualObject.wrapper.outerBounds);
                        for (var i_4 = 0; i_4 < objects.length; i_4++) {
                            var object = objects[parseInt(i_4.toString(), 10)];
                            if (object instanceof Connector) {
                                this.connectorPropertyChange(objects[parseInt(i_4.toString(), 10)], {}, {
                                    sourceID: object.sourceID,
                                    targetID: object.targetID,
                                    sourcePortID: object.sourcePortID,
                                    targetPortID: object.targetPortID,
                                    sourcePoint: object.sourcePoint,
                                    targetPoint: object.targetPoint
                                });
                            }
                        }
                    }
                }
            }
            if (actualObject.status !== 'New' && this.diagramActions) {
                actualObject.status = 'Update';
            }
        }
        if (!propertyChange) {
            var element = actualObject;
            var args = {
                element: element, cause: this.diagramActions, diagramAction: this.getDiagramAction(this.diagramActions),
                oldValue: oldObject, newValue: node
            };
            //Removed isBlazor code
            this.triggerEvent(DiagramEvent.propertyChange, args);
        }
    };
    Diagram.prototype.updateWrapperChildFlip = function (actualObject, changeFlipMode) {
        if (actualObject && actualObject.children && actualObject.children.length > 0) {
            for (var i = 0; i < actualObject.children.length; i++) {
                var child = actualObject.children[parseInt(i.toString(), 10)];
                var updateNode = this.nameTable["" + child];
                var modifiedFlipMode = '';
                if (!changeFlipMode) {
                    modifiedFlipMode = updateNode.flipMode;
                }
                else {
                    modifiedFlipMode = changeFlipMode;
                    updateNode.wrapper.flipMode = modifiedFlipMode;
                    updateNode.flipMode = modifiedFlipMode;
                }
                if (modifiedFlipMode === 'None' || modifiedFlipMode === 'Label' || modifiedFlipMode === 'LabelText' || modifiedFlipMode === 'LabelAndLabelText') {
                    this.updatePorts(updateNode, FlipDirection.None);
                }
                else {
                    this.updatePorts(updateNode, updateNode.wrapper.flip);
                }
                //To update the wrapper of node with flip and flip mode.
                this.updateWrapperFlip(updateNode.wrapper, updateNode);
            }
        }
        changeFlipMode = actualObject.flipMode;
        if (changeFlipMode === 'None' || changeFlipMode === 'Label' || changeFlipMode === 'LabelText' || changeFlipMode === 'LabelAndLabelText') {
            this.updatePorts(actualObject, FlipDirection.None);
        }
        else {
            this.updatePorts(actualObject, actualObject.wrapper.flip);
        }
        var wrapperCanvas;
        if (actualObject.children) {
            wrapperCanvas = actualObject.wrapper.children[actualObject.wrapper.children.length - 1];
        }
        else {
            wrapperCanvas = actualObject.wrapper;
        }
        wrapperCanvas.flip = actualObject.wrapper.flip;
        wrapperCanvas.flipMode = actualObject.flipMode;
        //To update the wrapper of node with flip and flip mode.
        this.updateWrapperFlip(wrapperCanvas, actualObject);
    };
    Diagram.prototype.updateWrapperFlip = function (wrapperCanvas, obj) {
        for (var k = 0; k < wrapperCanvas.children.length; k++) {
            var wrapperChild = wrapperCanvas.children[parseInt(k.toString(), 10)];
            if (wrapperChild instanceof TextElement) {
                if (obj.flipMode !== 'None' && obj.flipMode !== 'Port') {
                    wrapperChild.flip = obj.wrapper.flip;
                    wrapperChild.flipMode = obj.flipMode;
                }
                else {
                    wrapperChild.flip = FlipDirection.None;
                }
            }
            else if (wrapperChild instanceof Canvas) {
                this.applyWrapperCanvasFlip(wrapperChild, obj);
            }
        }
    };
    //Get resize handle name based on the old and new size properties of node.
    Diagram.prototype.getResizeHandle = function (oldX, oldY, oldWidth, oldHeight, newX, newY, newWidth, newHeight) {
        var dx = newX - oldX;
        var dy = newY - oldY;
        var dw = newWidth - oldWidth;
        var dh = newHeight - oldHeight;
        if (dh === 0 && ((dx > 0 && dw > 0) || (dx < 0 && dw < 0))) {
            return 'ResizeEast';
        }
        if (dh === 0 && ((dx > 0 && dw < 0) || (dx < 0 && dw > 0))) {
            return 'ResizeWest';
        }
        // **North & South Handles (Height Change Only)**
        if (dw === 0 && ((dy > 0 && dh < 0) || (dy < 0 && dh > 0))) {
            return 'ResizeNorth';
        }
        if (dw === 0 && ((dy > 0 && dh > 0) || (dy < 0 && dh < 0))) {
            return 'ResizeSouth';
        }
        // **Diagonal Resizing (Both Width & Height Change)**
        if (((dx > 0 && dw > 0) || (dx < 0 && dw < 0)) && ((dy > 0 && dh > 0) || (dy < 0 && dh < 0))) {
            return 'ResizeSouthEast'; // Bottom-right
        }
        if (((dx > 0 && dw < 0) || (dx < 0 && dw > 0)) && ((dy > 0 && dh > 0) || (dy < 0 && dh < 0))) {
            return 'ResizeSouthWest'; // Bottom-left
        }
        if (((dx > 0 && dw > 0) || (dx < 0 && dw < 0)) && ((dy > 0 && dh < 0) || (dy < 0 && dh > 0))) {
            return 'ResizeNorthEast'; // Top-right
        }
        if (((dx > 0 && dw < 0) || (dx < 0 && dw > 0)) && ((dy > 0 && dh < 0) || (dy < 0 && dh > 0))) {
            return 'ResizeNorthWest'; // Top-left
        }
        return null;
    };
    /**
     * To get new offset used to calculate the text annotation offset while resizing the parent node.
     * getTextAnnotationOffset method \
     *
     * @param {Node} actualObject - The current state of the parent node being resized.
     * @param {NodeModel} textAnnotation - The text annotation attached to the parent node.
     * @param {Node} oldObject - The previous state of the parent node before resizing.
     * @param {number} oldBpmnOffsetX - The previous X offset.
     * @param {number} oldBpmnOffsetY - The previous Y offset.
     * @returns { PointModel }    - Returns new offset
     *
     * @private
     */
    Diagram.prototype.getTextAnnotationOffset = function (actualObject, textAnnotation, oldObject, oldBpmnOffsetX, oldBpmnOffsetY) {
        var sx = actualObject.width - oldObject.width;
        var sy = actualObject.height - oldObject.height;
        var side = this.getTextAnnotationQuadrant(actualObject, textAnnotation);
        var resizeSide = this.getResizeHandle(oldObject.offsetX, oldObject.offsetY, oldObject.width, oldObject.height, actualObject.offsetX, actualObject.offsetY, actualObject.width, actualObject.height);
        var dx = 0;
        var dy = 0;
        var needsXAdjustment = function (side) {
            if (resizeSide === 'ResizeEast' || resizeSide === 'ResizeNorthEast' || resizeSide === 'ResizeSouthEast') {
                return side.includes('East');
            }
            if (resizeSide === 'ResizeWest' || resizeSide === 'ResizeNorthWest' || resizeSide === 'ResizeSouthWest') {
                return side.includes('West');
            }
            return false;
        };
        var needsYAdjustment = function (side) {
            if (resizeSide === 'ResizeSouth' || resizeSide === 'ResizeSouthWest' || resizeSide === 'ResizeSouthEast') {
                return side.includes('South');
            }
            if (resizeSide === 'ResizeNorth' || resizeSide === 'ResizeNorthWest' || resizeSide === 'ResizeNorthEast') {
                return side.includes('North');
            }
            return false;
        };
        if (needsXAdjustment(side)) {
            dx = (resizeSide.includes('West') ? -sx : sx);
        }
        if (needsYAdjustment(side)) {
            dy = (resizeSide.includes('North') ? -sy : sy);
        }
        return { x: oldBpmnOffsetX + dx, y: oldBpmnOffsetY + dy };
    };
    //To get which side the text annotation node is placed based on its parent node
    Diagram.prototype.getTextAnnotationQuadrant = function (parent, textAnnotation) {
        var left = parent.wrapper.bounds.left;
        var right = parent.wrapper.bounds.right;
        var top = parent.wrapper.bounds.top;
        var bottom = parent.wrapper.bounds.bottom;
        var textX = textAnnotation.wrapper.bounds.center.x;
        var textY = textAnnotation.wrapper.bounds.center.y;
        // Check if exactly aligned with any edge
        if (textX >= left && textX <= right) {
            if (textY < top) {
                return 'North';
            }
            if (textY > bottom) {
                return 'South';
            }
        }
        if (textY >= top && textY <= bottom) {
            if (textX < left) {
                return 'West';
            }
            if (textX > right) {
                return 'East';
            }
        }
        // Quadrants
        if (textX < left && textY < top) {
            return 'NorthWest';
        }
        if (textX > right && textY < top) {
            return 'NorthEast';
        }
        if (textX < left && textY > bottom) {
            return 'SouthWest';
        }
        if (textX > right && textY > bottom) {
            return 'SouthEast';
        }
        return '';
    };
    //To update text annotation position while dragging the text annotation's parent node.
    Diagram.prototype.updateBpmnAnnotationPosition = function (oldX, oldY, newX, newY, node, wrapper, shape, isTextAnnotation, oldObject, sizeChanged, isUndo) {
        var x = newX > oldX ? Math.abs(newX - oldX) : Math.abs(oldX - newX);
        var y = newY > oldY ? Math.abs(newY - oldY) : Math.abs(oldY - newY);
        var laneX;
        var laneY;
        if ((x === 0 && y === 0) || (Number.isNaN(x) && Number.isNaN(y))) {
            if (node.laneMargin) {
                laneX = node.margin.left - node.laneMargin.left;
                laneY = node.margin.top - node.laneMargin.top;
            }
        }
        var width = node.width;
        var height = node.height;
        var bounds = new Rect(0, 0, 0, 0);
        if (width !== 0 && height !== 0) {
            bounds = new Rect((newX !== 0 ? newX : node.offsetX) - width / 2, (newY !== 0 ? newY : node.offsetY) - height / 2, width, height);
        }
        //To update text annotation position
        if (isTextAnnotation) {
            var bpmnAnnotation = shape;
            var hasTarget = bpmnAnnotation.textAnnotation.textAnnotationTarget !== '' && this.nameTable[bpmnAnnotation.textAnnotation.textAnnotationTarget];
            var selectedNode = this.selectedItems.nodes ? this.selectedItems.nodes[0] : undefined;
            var isTextNodeSelected = selectedNode && selectedNode.shape && selectedNode.shape.shape === 'TextAnnotation';
            if (hasTarget) {
                //To check whether the text annotation inside the swimlane
                if (node.parentId === '' || isTextNodeSelected) {
                    if (bpmnAnnotation.textAnnotation.textAnnotationDirection === 'Auto') {
                        if (wrapper.children[0] instanceof Canvas && wrapper.children[0].children[0] instanceof PathElement) {
                            var diagramCanvas = wrapper.children[0];
                            var parentElement = document.getElementById(diagramCanvas.id + '_groupElement');
                            var elementToRemove = document.getElementById(diagramCanvas.children[0].id + '_groupElement');
                            parentElement.removeChild(elementToRemove);
                            diagramCanvas.children.splice(0, 1);
                            this.isProtectedOnChange = true;
                            this.bpmnModule.setAnnotationPath(bounds, diagramCanvas, node, bpmnAnnotation, bpmnAnnotation.textAnnotation.textAnnotationDirection, this);
                            this.isProtectedOnChange = false;
                        }
                    }
                }
                else {
                    this.isPositionUndo = true;
                    this.updateTextAnnotationInSwimlane(node, node);
                    this.isPositionUndo = false;
                }
            }
            else { //To update text annotation connector source point.
                if (node.inEdges.length > 0) {
                    var connectorID = node.inEdges[0];
                    var connector = this.nameTable["" + connectorID];
                    if (connector && connector.isBpmnAnnotationConnector) {
                        connector.sourcePoint =
                            {
                                x: newX > oldX ? connector.sourcePoint.x + x : connector.sourcePoint.x - x,
                                y: newY > oldY ? connector.sourcePoint.y + y : connector.sourcePoint.y - y
                            };
                    }
                }
            }
            var newValue = { ports: [{ offset: node.ports[0].offset }] };
            //To update port offset of text annotation node
            this.nodePropertyChange(node, {}, newValue);
        }
        else {
            for (var _i = 0, _a = node.outEdges; _i < _a.length; _i++) {
                var id = _a[_i];
                var connector = this.nameTable["" + id];
                if (connector && connector.isBpmnAnnotationConnector) {
                    var targetNode = this.nameTable[connector.targetID];
                    var textAnnotationTargetId = targetNode.shape.textAnnotation.textAnnotationTarget;
                    var textAnnotationTarget = this.nameTable["" + textAnnotationTargetId];
                    if (sizeChanged && !isUndo) {
                        var newResizeOffset = this.getTextAnnotationOffset(node, targetNode, oldObject, oldX, oldY);
                        newX = newResizeOffset.x;
                        newY = newResizeOffset.y;
                        x = newX > oldX ? Math.abs(newX - oldX) : Math.abs(oldX - newX);
                        y = newY > oldY ? Math.abs(newY - oldY) : Math.abs(oldY - newY);
                    }
                    if (targetNode.shape.shape === 'TextAnnotation' && !isSelected(this, targetNode)
                        && isSelected(this, textAnnotationTarget)) {
                        var oldValue = void 0;
                        var newValue = void 0;
                        if (node.isResized) {
                            oldValue = { margin: { left: targetNode.margin.left, top: targetNode.margin.top } };
                            var resizeOffset = node.resizeDif[targetNode.id];
                            if (resizeOffset) {
                                targetNode.margin.left += resizeOffset.x;
                                targetNode.margin.top += resizeOffset.y;
                                newValue = { margin: { left: targetNode.margin.left, top: targetNode.margin.top } };
                            }
                        }
                        else if (laneX !== undefined && laneY !== undefined) {
                            if (targetNode.parentId) {
                                oldValue = { margin: { left: targetNode.margin.left, top: targetNode.margin.top } };
                                targetNode.margin.left += laneX;
                                targetNode.margin.top += laneY;
                                newValue = { margin: { left: targetNode.margin.left, top: targetNode.margin.top } };
                            }
                            else {
                                oldValue = { offsetX: targetNode.offsetX, offsetY: targetNode.offsetY };
                                targetNode.offsetX += laneX;
                                targetNode.offsetY += laneY;
                                newValue = { offsetX: targetNode.offsetX, offsetY: targetNode.offsetY };
                            }
                        }
                        else {
                            oldValue = { offsetX: targetNode.offsetX, offsetY: targetNode.offsetY };
                            targetNode.offsetX = newX > oldX ? targetNode.offsetX + x : targetNode.offsetX - x;
                            targetNode.offsetY = newY > oldY ? targetNode.offsetY + y : targetNode.offsetY - y;
                            newValue = { offsetX: targetNode.offsetX, offsetY: targetNode.offsetY };
                        }
                        this.nodePropertyChange(targetNode, oldValue, newValue);
                    }
                }
            }
        }
    };
    Diagram.prototype.updatePorts = function (actualObject, flip) {
        if (actualObject && actualObject.ports.length > 0) {
            for (var _i = 0, _a = Object.keys(actualObject.ports); _i < _a.length; _i++) {
                var key = _a[_i];
                var index = Number(key);
                var actualPort = actualObject.ports[parseInt(index.toString(), 10)];
                var portWrapper = this.getWrapper(actualObject.wrapper, actualPort.id);
                portWrapper = updatePortEdges(portWrapper, flip, actualPort);
                portWrapper.relativeMode = 'Point';
                if (actualObject.wrapper.measureChildren === undefined) {
                    actualObject.wrapper.measureChildren = false;
                }
                portWrapper.measure(new Size(portWrapper.width, portWrapper.height));
                portWrapper.arrange(portWrapper.desiredSize);
            }
        }
    };
    Diagram.prototype.updateFlipOffset = function (element, diffX, diffY, flip) {
        if (element.hasChildren()) {
            for (var _i = 0, _a = element.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (flip === FlipDirection.Horizontal || flip === FlipDirection.Both) {
                    child.flipOffset.x = child.flipOffset.x + diffX;
                }
                if (flip === FlipDirection.Vertical || flip === FlipDirection.Both) {
                    child.flipOffset.y = child.flipOffset.y + diffY;
                }
                if (child instanceof Canvas || child instanceof Container) {
                    this.updateFlipOffset(child, diffX, diffY, flip);
                }
            }
        }
    };
    Diagram.prototype.updateUMLActivity = function (changedProp, oldObject, actualObject, diagram) {
        var sizeChanged = changedProp.width !== undefined || changedProp.height !== undefined;
        if (sizeChanged) {
            var innerFinalNode = actualObject.wrapper.children[0].children[0];
            innerFinalNode.width = changedProp.width;
            innerFinalNode.height = changedProp.height;
            var outerFinalNode = actualObject.wrapper.children[0].children[1];
            outerFinalNode.width = changedProp.width / 1.5;
            outerFinalNode.height = changedProp.height / 1.5;
        }
    };
    Diagram.prototype.updateConnectorProperties = function (connector) {
        if (this.preventConnectorsUpdate) {
            var index = this.selectionConnectorsList.indexOf(connector);
            if (index === -1 && connector) {
                this.selectionConnectorsList.push(connector);
            }
        }
        else {
            var conn = {
                sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint, sourceID: connector.sourceID,
                targetID: connector.targetID, sourcePortID: connector.sourcePortID, targetPortID: connector.targetPortID
            };
            this.connectorPropertyChange(connector, {}, conn, undefined, true);
        }
    };
    /**
     * updateConnectorEdges method \
     *
     * @returns { void }     Updates the connectorPropertyChange of the diagram container .\
     * @param {Node} actualObject - provide the actualObject value.
     *
     * @private
     */
    Diagram.prototype.updateConnectorEdges = function (actualObject) {
        if (actualObject.inEdges.length > 0) {
            for (var j = 0; j < actualObject.inEdges.length; j++) {
                this.updateConnectorProperties(this.nameTable[actualObject.inEdges[parseInt(j.toString(), 10)]]);
            }
        }
        if (actualObject.outEdges.length > 0) {
            for (var k = 0; k < actualObject.outEdges.length; k++) {
                this.updateConnectorProperties(this.nameTable[actualObject.outEdges[parseInt(k.toString(), 10)]]);
            }
        }
        // Bug: 909563 - Max Call Stack exception upon dragging group's child connector end point
        if (!(actualObject instanceof Connector) && actualObject.parentId && this.nameTable[actualObject.parentId]) {
            this.updateConnectorEdges(this.nameTable[actualObject.parentId]);
        }
    };
    /* tslint:enable */
    Diagram.prototype.connectorProprtyChangeExtend = function (actualObject, oldProp, newProp, updateSelector) {
        if (newProp.type !== undefined && newProp.type !== oldProp.type) {
            if (actualObject.segments.length > 0 && newProp.segments === undefined) {
                actualObject.segments = [];
            }
        }
        if ((newProp.shape !== undefined) && actualObject.shape !== undefined &&
            actualObject.shape && actualObject.shape.type === 'Bpmn' && this.bpmnModule) {
            this.bpmnModule.updateBPMNConnector(actualObject, oldProp, newProp, this);
        }
        if (actualObject.constraints !== undefined) {
            this.updateThumbConstraints(this.selectedItems.connectors, this.selectedItems);
            return updateSelector = true;
        }
        return updateSelector;
    };
    /* tslint:disable */
    /**
     * Updates the connectorPropertyChange of the diagram container \
     *
     * @returns { void }     Updates the connectorPropertyChange of the diagram container .\
     * @param {DiagramElement} actualObject - provide the actualObject value.
     * @param {boolean} oldProp - provide the oldProp value.
     * @param {boolean} newProp - provide the newProp value.
     * @param {boolean} disableBridging - provide the disableBridging value.
     * @param {boolean} propertyChange - provide the propertyChange value.
     *
     * @private
     */
    Diagram.prototype.connectorPropertyChange = function (actualObject, oldProp, newProp, disableBridging, propertyChange) {
        if (this.canEnableBlazorObject) {
            var node = cloneObject(actualObject);
            this.insertValue(node, false);
        }
        var existingBounds = actualObject.wrapper.bounds;
        var updateSelector = false;
        var points = [];
        updateSelector = this.connectorProprtyChangeExtend(actualObject, oldProp, newProp, updateSelector);
        var inPort;
        var outPort;
        var source;
        var target;
        if (newProp.visible !== undefined) {
            this.updateElementVisibility(actualObject.wrapper, actualObject, actualObject.visible);
        }
        if (newProp.sourcePoint !== undefined || newProp.targetPoint !== undefined
            || newProp.sourceID !== undefined || newProp.targetID !== undefined || newProp.targetPadding !== undefined ||
            newProp.sourcePortID !== undefined || newProp.targetPortID !== undefined || newProp.sourcePadding !== undefined ||
            newProp.type !== undefined || newProp.segments !== undefined || newProp.flip !== undefined) {
            if ((newProp.sourceID !== undefined && newProp.sourceID !== oldProp.sourceID) || newProp.sourcePortID) {
                var sourceNode = this.nameTable[actualObject.sourceID];
                outPort = this.findInOutConnectPorts(sourceNode, false);
                if (!sourceNode || (canOutConnect(sourceNode) || (actualObject.sourcePortID !== '' && canPortOutConnect(outPort)))) {
                    actualObject.sourceWrapper = sourceNode ? this.getEndNodeWrapper(sourceNode, actualObject, true) : undefined;
                    if (actualObject.sourcePortID && newProp.sourcePortID === undefined) {
                        actualObject.sourcePortWrapper = sourceNode ? this.getWrapper(sourceNode.wrapper, actualObject.sourcePortID) : undefined;
                    }
                    this.removePortEdges(this.nameTable[oldProp.sourceID] || sourceNode, oldProp.sourcePortID || actualObject.sourcePortID, actualObject.id, false);
                }
                if (newProp.sourceID !== undefined && oldProp.sourceID !== undefined && oldProp.sourceID !== '') {
                    var oldSource = this.nameTable[oldProp.sourceID];
                    if (oldSource !== undefined && oldSource.outEdges && oldSource.outEdges.indexOf(actualObject.id) !== -1) {
                        removeItem(oldSource.outEdges, actualObject.id);
                    }
                }
                this.updateEdges(actualObject);
            }
            if (newProp.targetID !== undefined && newProp.targetID !== oldProp.targetID) {
                var targetNode = this.nameTable[newProp.targetID];
                inPort = this.findInOutConnectPorts(targetNode, true);
                if (!targetNode || (canInConnect(targetNode) || (actualObject.targetPortID !== '' && canPortInConnect(inPort)))) {
                    actualObject.targetWrapper = targetNode ? this.getEndNodeWrapper(targetNode, actualObject, false) : undefined;
                    if (actualObject.targetPortID && newProp.targetPortID === undefined) {
                        actualObject.targetPortWrapper = targetNode ? this.getWrapper(targetNode.wrapper, actualObject.targetPortID) : undefined;
                    }
                    this.removePortEdges(this.nameTable[oldProp.targetID] || targetNode, oldProp.targetPortID || actualObject.targetPortID, actualObject.id, true);
                }
                if (oldProp !== undefined && oldProp.targetID !== undefined && oldProp.targetID !== '') {
                    var oldTarget = this.nameTable[oldProp.targetID];
                    if (oldTarget !== undefined && oldTarget.inEdges && oldTarget.inEdges.indexOf(actualObject.id) !== -1) {
                        removeItem(oldTarget.inEdges, actualObject.id);
                    }
                }
                this.updateEdges(actualObject);
            }
            if (newProp.sourcePortID !== undefined && newProp.sourcePortID !== oldProp.sourcePortID) {
                if (actualObject.sourceID && this.nameTable[actualObject.sourceID]) {
                    source = this.nameTable[actualObject.sourceID].wrapper;
                }
                var sourceNode = this.nameTable[actualObject.sourceID];
                if (!sourceNode || (canOutConnect(sourceNode) || (actualObject.sourcePortID !== '' && canPortOutConnect(outPort)))) {
                    actualObject.sourcePortWrapper = source ? this.getWrapper(source, newProp.sourcePortID) : undefined;
                }
                else if (actualObject.sourcePortID === '' && !canOutConnect(sourceNode)) {
                    actualObject.sourcePortWrapper = undefined;
                }
            }
            if (newProp.targetPortID !== undefined && newProp.targetPortID !== oldProp.targetPortID) {
                var targetNode = this.nameTable[actualObject.targetID];
                if (actualObject.targetID && this.nameTable[actualObject.targetID]) {
                    target = this.nameTable[actualObject.targetID].wrapper;
                }
                if (!targetNode || (canInConnect(targetNode) || (actualObject.targetPortID !== '' && canPortInConnect(inPort)))) {
                    actualObject.targetPortWrapper = target ? this.getWrapper(target, newProp.targetPortID) : undefined;
                }
                else if (actualObject.targetPortID === '' && !canInConnect(targetNode)) {
                    actualObject.targetPortWrapper = undefined;
                }
            }
            if (newProp.flip !== undefined) {
                actualObject.flip = newProp.flip;
                flipConnector(actualObject);
            }
            //EJ2-867479 - Performance issue in complexhierarchical layout due to linerouting injection
            if (actualObject.type === 'Orthogonal' && this.lineRoutingModule && this.diagramActions &&
                (this.constraints & DiagramConstraints.LineRouting) && !(this.diagramActions & DiagramAction.ToolAction) && this.layout.type !== 'ComplexHierarchicalTree') {
                this.lineRoutingModule.renderVirtualRegion(this, true);
                // EJ2-65876 - Exception occurs on line routing injection module
                if (actualObject.sourceID !== actualObject.targetID && actualObject.segments.length > 1) {
                    //EJ2-69573 - Excecption occurs when calling doLayout method with the lineRouting module
                    this.lineRoutingModule.refreshConnectorSegments(this, actualObject, false);
                }
            }
            points = this.getPoints(actualObject);
        } //Add prop change for zindex, alignments and margin
        if (newProp.style !== undefined) {
            updateStyle(newProp.style, actualObject.wrapper.children[0]);
        }
        if (points.length > 0 || newProp.sourceDecorator !== undefined || (newProp.targetDecorator !== undefined
            && (canMeasureDecoratorPath(Object.keys(newProp.targetDecorator)))) || newProp.cornerRadius !== undefined) {
            updateConnector(actualObject, points.length > 0 ? points : actualObject.intermediatePoints, this.diagramActions);
            if (newProp.type !== undefined) {
                updateSelector = true;
            }
            if (points.length > 0) {
                actualObject.wrapper.measure(new Size(actualObject.wrapper.width, actualObject.wrapper.height));
                actualObject.wrapper.arrange(actualObject.wrapper.desiredSize);
                // eslint-disable-next-line max-len
                this.updateConnectorAnnotation(actualObject);
                this.updateConnectorPort(actualObject);
                this.updateConnectorfixedUserHandles(actualObject);
                this.updateObject(actualObject, oldProp, newProp);
            } //work-around to update intersected connector bridging
        }
        if ((newProp.sourcePoint || newProp.targetPoint || newProp.segments)
            && this.diagramActions === DiagramAction.Render) {
            updateSelector = true;
        }
        if (actualObject.shape.type === 'Bpmn' && actualObject.shape.sequence === 'Default' && actualObject.shape.flow === 'Sequence') {
            this.commandHandler.updatePathElementOffset(actualObject);
        }
        // eslint-disable-next-line max-len
        if (!disableBridging) {
            this.updateBridging();
        }
        this.updateAnnotations(newProp, actualObject);
        this.updateConnectorPorts(newProp, actualObject);
        this.updatefixedUserHandle(newProp, actualObject);
        actualObject.wrapper.measure(new Size(actualObject.wrapper.width, actualObject.wrapper.height));
        actualObject.wrapper.arrange(actualObject.wrapper.desiredSize);
        if (existingBounds.equals(existingBounds, actualObject.wrapper.bounds) === false) {
            this.updateQuad(actualObject);
            if (this.eventHandler.currentAction !== 'Drag') {
                this.updateGroupSize(actualObject);
            }
        }
        if (updateSelector === true && this.checkSelectedItem(actualObject) && (!(this.diagramActions & DiagramAction.ToolAction)
            || (this.diagramActions & DiagramAction.UndoRedo))) {
            this.updateSelector();
        }
        if (!this.preventConnectorsUpdate) {
            if (!canVitualize(this) || (canVitualize(this) && this.scroller.oldCollectionObjects.indexOf(actualObject.id) > -1)) {
                if (this.diagramActions & DiagramAction.PreventZIndexOnDragging) {
                    this.updateDiagramObject(actualObject, true);
                }
                else {
                    this.updateDiagramObject(actualObject);
                }
            }
        }
        this.updateConnectorEdges(actualObject);
        if (this.diagramActions && actualObject.status !== 'New') {
            actualObject.status = 'Update';
        }
        this.triggerPropertyChange(propertyChange, actualObject, oldProp, newProp);
    };
    /* tslint:enable */
    /**
     * getDirection methods \
     *
     * @returns { void }  getDirection methods .\
     * @param {NodeModel} node - provide the node value.
     * @param {string} portId - provide the portId value.
     * @param {string} item - provide the item value.
     * @param {number} isInEdges - provide the isInEdges value.
     *
     * @private
     */
    Diagram.prototype.removePortEdges = function (node, portId, item, isInEdges) {
        if (node) {
            for (var i = 0; i < node.ports.length; i++) {
                var port = node.ports[parseInt(i.toString(), 10)];
                if (port.id === portId) {
                    var portEdge = (isInEdges) ? port.inEdges : port.outEdges;
                    removeItem(portEdge, item);
                }
            }
        }
    };
    //Removed blazor getpropertyChangeArgs method
    // Feature 826644: Support to add ports to the connector. Added below method to update connector ports
    // on connector property change.
    Diagram.prototype.updateConnectorPorts = function (newProp, actualObject) {
        if (newProp.ports !== undefined) {
            for (var _i = 0, _a = Object.keys(newProp.ports); _i < _a.length; _i++) {
                var key = _a[_i];
                var index = Number(key);
                var changedObject = newProp.ports["" + key];
                var actualPort = actualObject.ports[parseInt(index.toString(), 10)];
                this.updatePort(changedObject, actualPort, actualObject.wrapper, actualObject);
            }
        }
    };
    Diagram.prototype.triggerPropertyChange = function (propertyChange, actualObject, oldProp, newProp) {
        if (!propertyChange) {
            var element = actualObject;
            var args = {
                element: cloneBlazorObject(element), cause: this.diagramActions, diagramAction: this.getDiagramAction(this.diagramActions),
                oldValue: cloneBlazorObject(oldProp), newValue: cloneBlazorObject(newProp)
            };
            //Removed isBlazor code
            this.triggerEvent(DiagramEvent.propertyChange, args);
        }
    };
    Diagram.prototype.findInOutConnectPorts = function (node, isInconnect) {
        var port = {};
        if (node) {
            port = getInOutConnectPorts(node, isInconnect);
        }
        return port;
    };
    Diagram.prototype.getPoints = function (actualObject, points) {
        //let pts: PointModel[];
        //871158: Connector splitting point change with line distribution module injection
        var lineDistributionModule = (this.lineDistributionModule && this.layout.connectionPointOrigin === 'DifferentPoint') ? true : false;
        var pts = actualObject.getConnectorPoints(actualObject.type, points, this.layout.type === 'ComplexHierarchicalTree' || this.layout.type === 'HierarchicalTree' ?
            this.layout.orientation : undefined, lineDistributionModule);
        return pts;
    };
    /**
     * update the  opacity  and visibility for the node  once the layout animation starts \
     *
     * @returns { void }  update the  opacity  and visibility for the node  once the layout animation starts .\
     * @param {Container} element - provide the element value.
     * @param {boolean} visible - provide the visible value.
     * @param {number} opacity - provide the opacity value.
     *
     * @private
     */
    Diagram.prototype.updateNodeProperty = function (element, visible, opacity) {
        if (visible === undefined) {
            this.updateElementVisibility(element, this.nameTable[element.id], visible);
        }
        else {
            element.style.opacity = opacity;
            for (var i = 0; i < element.children.length; i++) {
                if (element.children[parseInt(i.toString(), 10)] instanceof Container) {
                    this.updateNodeProperty(element.children[parseInt(i.toString(), 10)], undefined, opacity);
                }
                element.children[parseInt(i.toString(), 10)].style.opacity = opacity;
            }
        }
    };
    /**
     * checkSelected Item for Connector \
     *
     * @returns { void }  checkSelected Item for Connector .\
     * @param {Connector | Node} actualObject - provide the element value.
     *
     * @private
     */
    Diagram.prototype.checkSelectedItem = function (actualObject) {
        var selectorModel = this.selectedItems;
        var isSelected = false;
        var selItems = [];
        selItems = selItems.concat(selectorModel.nodes, selectorModel.connectors);
        if (selItems.length > 0) {
            if (actualObject.id === selItems[selItems.length - 1].id) {
                isSelected = true;
            }
        }
        return isSelected;
    };
    /**
     * Updates the visibility of the diagram container \
     *
     * @returns { void }     Updates the visibility of the diagram container .\
     * @param {DiagramElement} element - provide the element value.
     * @param {boolean} visible - provide the target value.
     *
     * @private
     */
    Diagram.prototype.updateDiagramContainerVisibility = function (element, visible) {
        if (element instanceof Container) {
            for (var i = 0; i < element.children.length; i++) {
                this.updateDiagramContainerVisibility(element.children[parseInt(i.toString(), 10)], visible);
            }
        }
        element.visible = visible;
    };
    /**
     * Updates the visibility of the node/connector \
     *
     * @returns { void }  Updates the visibility of the node/connector .\
     * @param {Container} element - provide the element value.
     * @param {Connector | Node} obj - provide the obj value.
     * @param {boolean} visible - provide the visible value.
     *
     * @private
     */
    Diagram.prototype.updateElementVisibility = function (element, obj, visible) {
        if (visible !== undefined) {
            element.visible = visible;
            if (obj instanceof Node) {
                //content
                if (!obj.children) {
                    element.children[0].visible = visible;
                    this.updateDiagramContainerVisibility(element.children[0], visible);
                    if (obj.shape.type === 'Bpmn' && this.bpmnModule) {
                        this.bpmnModule.updateElementVisibility(obj, visible, this);
                    }
                }
                else {
                    for (var _i = 0, _a = obj.children; _i < _a.length; _i++) {
                        var child = _a[_i];
                        this.updateElementVisibility(this.nameTable["" + child].wrapper, this.nameTable["" + child], visible);
                    }
                }
                if ((obj.shape.type === 'Bpmn') && obj.shape.shape === 'TextAnnotation' && this.diagramActions) {
                    var connector = this.nameTable[obj.inEdges[0]];
                    var oldValue = connector.visible;
                    connector.visible = visible;
                    this.connectorPropertyChange(connector, { visible: oldValue }, { visible: visible });
                }
                //ports
                if (obj.ports) {
                    for (var _b = 0, _c = obj.ports; _b < _c.length; _b++) {
                        var port = _c[_b];
                        if (port.visibility & PortVisibility.Visible) {
                            var wrapper = this.getWrapper(element, port.id);
                            wrapper.visible = visible;
                        }
                    }
                }
                if (obj.annotations) {
                    for (var _d = 0, _e = obj.annotations; _d < _e.length; _d++) {
                        var annotation = _e[_d];
                        var wrapper = this.getWrapper(element, annotation.id);
                        if (visible) {
                            wrapper.visible = wrapper.annotationVisibility === 'Visible' ? true : false;
                        }
                        else {
                            wrapper.visible = visible;
                        }
                    }
                }
            }
            else {
                //path and decorators
                //942121: Visibility of BPMN flow connector not correctly applied
                if (obj.shape.type === 'Bpmn') {
                    for (var i = 0; i < 4; i++) {
                        element.children[parseInt(i.toString(), 10)].visible = visible;
                    }
                }
                else {
                    for (var i = 0; i < 3; i++) {
                        element.children[parseInt(i.toString(), 10)].visible = visible;
                    }
                }
            }
            if (obj.annotations) {
                //annotations
                for (var _f = 0, _g = obj.annotations; _f < _g.length; _f++) {
                    var annotation = _g[_f];
                    var wrapper = this.getWrapper(element, annotation.id);
                    //Bug 855273: Annotation visible property is not working while changing node visibility at runtime.
                    if (visible) {
                        wrapper.visible = wrapper.annotationVisibility === 'Visible' ? true : false;
                    }
                    else {
                        wrapper.visible = visible;
                    }
                }
            }
            if (obj.expandIcon || obj.collapseIcon) {
                var wrapper = this.getWrapper(element, 'icon_content');
                if (wrapper) {
                    for (var i = 0; i < wrapper.children.length; i++) {
                        wrapper.children[parseInt(i.toString(), 10)].visible = visible;
                    }
                    wrapper.visible = visible;
                }
                if (obj && obj.visible && obj.outEdges) {
                    this.updateIconVisibility(obj, (obj.outEdges.length === 0 ? false : true));
                }
            }
            if (visible === false) {
                this.unSelect(this.nameTable[element.id]);
            }
            if ((obj instanceof Node && !this.preventNodesUpdate) || (obj instanceof Connector && !this.preventConnectorsUpdate)) {
                //Avoid calling updateDiagramObject method during rendering
                if (this.diagramActions) {
                    this.updateDiagramObject(this.nameTable[element.id], undefined, true);
                }
            }
        }
    };
    Diagram.prototype.updateAnnotations = function (newProp, actualObject) {
        if (newProp.annotations !== undefined) {
            for (var _i = 0, _a = Object.keys(newProp.annotations); _i < _a.length; _i++) {
                var key = _a[_i];
                var index = Number(key);
                var changedObject = newProp.annotations["" + key];
                var actualAnnotation = actualObject.annotations[parseInt(index.toString(), 10)];
                this.updateAnnotation(changedObject, actualAnnotation, actualObject.wrapper, actualObject);
            }
        }
    };
    Diagram.prototype.updatefixedUserHandle = function (newProp, actualObject) {
        if (newProp.fixedUserHandles !== undefined) {
            var index = void 0;
            var changedObject = void 0;
            var actualAnnotation = void 0;
            for (var _i = 0, _a = Object.keys(newProp.fixedUserHandles); _i < _a.length; _i++) {
                var key = _a[_i];
                index = Number(key);
                changedObject = newProp.fixedUserHandles["" + key];
                actualAnnotation = actualObject.fixedUserHandles[parseInt(index.toString(), 10)];
                this.updateConnectorfixedUserHandle(changedObject, actualAnnotation, actualObject.wrapper, actualObject);
            }
        }
    };
    /**
     * updateConnectorfixedUserHandle method \
     *
     * @returns { void }  updateConnectorfixedUserHandle method .\
     * @param {ConnectorFixedUserHandleModel} changedObject - provide the changedObject value.
     * @param {ConnectorFixedUserHandleModel} actualfixedUserHandle - provide the actualfixedUserHandle value.
     * @param {Container} nodes - provide the nodes value.
     * @param {Object} actualObject - provide the actualObject value.
     * @param {boolean} canUpdateSize - provide the canUpdateSize value.
     *
     * @private
     */
    Diagram.prototype.updateConnectorfixedUserHandle = function (changedObject, actualfixedUserHandle, nodes, actualObject, canUpdateSize) {
        var isMeasure = false;
        var fixedUserHandleWrapper = this.getWrapper(nodes, actualfixedUserHandle.id);
        if (fixedUserHandleWrapper !== undefined) {
            if (changedObject.width !== undefined) {
                fixedUserHandleWrapper.width = changedObject.width;
                isMeasure = true;
            }
            if (changedObject.height !== undefined) {
                fixedUserHandleWrapper.height = changedObject.height;
                isMeasure = true;
            }
            if (actualfixedUserHandle instanceof ConnectorFixedUserHandle &&
                (changedObject.offset !== undefined)) {
                actualObject.updateAnnotation(actualfixedUserHandle, actualObject.intermediatePoints, actualObject.wrapper.bounds, fixedUserHandleWrapper);
            }
            if ((actualfixedUserHandle instanceof ConnectorFixedUserHandle) && changedObject.displacement) {
                if (changedObject.displacement.x !== undefined ||
                    changedObject.displacement.y !== undefined) {
                    isMeasure = true;
                }
            }
            if (changedObject.fill !== undefined) {
                fixedUserHandleWrapper.style.fill = changedObject.fill;
            }
            if (changedObject.handleStrokeColor !== undefined) {
                fixedUserHandleWrapper.style.strokeColor = changedObject.handleStrokeColor;
            }
            if (changedObject.handleStrokeWidth !== undefined) {
                fixedUserHandleWrapper.style.strokeWidth = changedObject.handleStrokeWidth;
            }
            if (changedObject.visibility !== undefined) {
                fixedUserHandleWrapper.visible = changedObject.visibility;
            }
            if (changedObject.cornerRadius !== undefined) {
                fixedUserHandleWrapper.cornerRadius = changedObject.cornerRadius;
            }
            this.updatefixedUserHandleContent(changedObject, isMeasure, fixedUserHandleWrapper, actualObject, actualfixedUserHandle, nodes);
            if (isMeasure === true) {
                fixedUserHandleWrapper.measure(new Size(fixedUserHandleWrapper.width, fixedUserHandleWrapper.height));
                fixedUserHandleWrapper.arrange(fixedUserHandleWrapper.desiredSize);
            }
        }
    };
    /**
     * updateAnnotation method \
     *
     * @returns { void }  updateAnnotation method .\
     * @param {AnnotationModel} changedObject - provide the changedObject value.
     * @param {ShapeAnnotationModel} actualAnnotation - provide the actualAnnotation value.
     * @param {Container} nodes - provide the nodes value.
     * @param {Object} actualObject - provide the actualObject value.
     * @param {boolean} canUpdateSize - provide the canUpdateSize value.
     *
     * @private
     */
    Diagram.prototype.updateAnnotation = function (changedObject, actualAnnotation, nodes, actualObject, canUpdateSize) {
        var isMeasure = false;
        // eslint-disable-next-line max-len
        var annotationWrapper = this.getWrapper(nodes, actualAnnotation.id);
        if (annotationWrapper !== undefined) {
            if (changedObject.width !== undefined && changedObject.height !== undefined) {
                annotationWrapper.width = changedObject.width;
                annotationWrapper.height = changedObject.height;
                isMeasure = true;
            }
            if (changedObject.rotateAngle !== undefined) {
                annotationWrapper.rotateAngle = changedObject.rotateAngle;
            }
            if (canUpdateSize && !(annotationWrapper instanceof DiagramHtmlElement)) {
                annotationWrapper.refreshTextElement();
            }
            if (actualAnnotation instanceof PathAnnotation && changedObject.segmentAngle !== undefined) {
                annotationWrapper.rotateAngle = actualAnnotation.rotateAngle;
            }
            if ((changedObject).rotationReference !== undefined) {
                annotationWrapper.rotationReference = changedObject.rotationReference;
            }
            if (actualAnnotation instanceof ShapeAnnotation &&
                changedObject.offset !== undefined) {
                var offset = changedObject.offset;
                isMeasure = true;
                var offsetX = offset.x !== undefined ? offset.x :
                    actualAnnotation.offset.x;
                var offsetY = offset.y !== undefined ? offset.y :
                    actualAnnotation.offset.y;
                annotationWrapper.setOffsetWithRespectToBounds(offsetX, offsetY, 'Fraction');
                annotationWrapper.relativeMode = 'Point';
                //911103- Text alignment for connectors not updated properly for connectors annotation at run time
            }
            else if (actualAnnotation instanceof PathAnnotation &&
                (changedObject.offset !== undefined ||
                    changedObject.segmentAngle !== undefined ||
                    changedObject.alignment !== undefined)) {
                actualObject.updateAnnotation(actualAnnotation, actualObject.intermediatePoints, actualObject.wrapper.bounds, annotationWrapper);
            }
            if ((actualAnnotation instanceof PathAnnotation) && changedObject.displacement) {
                if (changedObject.displacement.x !== undefined ||
                    changedObject.displacement.y !== undefined) {
                    isMeasure = true;
                    actualObject.updateAnnotation(actualAnnotation, actualObject.intermediatePoints, actualObject.wrapper.bounds, annotationWrapper);
                }
            }
            if (changedObject.margin !== undefined) {
                isMeasure = true;
                if (changedObject.margin.bottom !== undefined) {
                    annotationWrapper.margin.bottom = changedObject.margin.bottom;
                }
                if (changedObject.margin.top !== undefined) {
                    annotationWrapper.margin.top = changedObject.margin.top;
                }
                if (changedObject.margin.left !== undefined) {
                    annotationWrapper.margin.left = changedObject.margin.left;
                }
                if (changedObject.margin.right !== undefined) {
                    annotationWrapper.margin.right = changedObject.margin.right;
                }
            }
            if (isMeasure || canUpdateSize) {
                annotationWrapper.width = (actualAnnotation.width || actualObject.width);
                if (actualAnnotation.template) {
                    annotationWrapper.width = (annotationWrapper.width || annotationWrapper.actualSize.width);
                    annotationWrapper.height = (actualAnnotation.height || actualObject.height ||
                        annotationWrapper.actualSize.height);
                }
            }
            if (changedObject.horizontalAlignment !== undefined) {
                annotationWrapper.horizontalAlignment = changedObject.horizontalAlignment;
                isMeasure = true;
            }
            if (changedObject.verticalAlignment !== undefined) {
                annotationWrapper.verticalAlignment = changedObject.verticalAlignment;
                isMeasure = true;
            }
            if (changedObject.visibility !== undefined) {
                annotationWrapper.visible = (nodes.visible && changedObject.visibility) ? true : false;
                annotationWrapper.annotationVisibility = annotationWrapper.visible ? 'Visible' : 'Collapsed';
            }
            if (changedObject.constraints !== undefined) {
                var updateSelector = false;
                if ((annotationWrapper.constraints & AnnotationConstraints.Select) &&
                    (!(changedObject.constraints & AnnotationConstraints.Select)) &&
                    isSelected(this, actualObject, false, annotationWrapper)) ;
                annotationWrapper.constraints = changedObject.constraints;
                if (updateSelector) {
                    this.clearSelection();
                }
            }
            if (changedObject.style !== undefined) {
                updateStyle(changedObject.style, annotationWrapper);
            }
            if (changedObject.hyperlink !== undefined) {
                updateHyperlink(changedObject.hyperlink, annotationWrapper, actualAnnotation);
            }
            this.updateAnnotationContent(changedObject, isMeasure, annotationWrapper, actualObject, actualAnnotation, nodes);
            if (isMeasure === true) {
                annotationWrapper.measure(new Size(annotationWrapper.width, annotationWrapper.height));
                annotationWrapper.arrange(annotationWrapper.desiredSize);
            }
            if (!(annotationWrapper instanceof DiagramHtmlElement)) {
                annotationWrapper.refreshTextElement();
            }
            // this.refresh(); this.refreshDiagramLayer();
        }
    };
    Diagram.prototype.updatefixedUserHandleContent = function (changedObject, isMeasure, fixedUserHandleWrapper, actualObject, fixedUserHandleAnnotation, nodes) {
        if (changedObject !== undefined) {
            this.updateConnectorfixedUserHandleWrapper(fixedUserHandleWrapper, actualObject, fixedUserHandleAnnotation, nodes);
        }
    };
    Diagram.prototype.updateConnectorfixedUserHandleWrapper = function (fixedUserHandleWrapper, actualObject, actualAnnotation, nodes) {
        for (var _i = 0, _a = this.views; _i < _a.length; _i++) {
            var elementId = _a[_i];
            removeElement(fixedUserHandleWrapper.id + '_groupElement', elementId);
            removeElement(fixedUserHandleWrapper.id + '_html_element', elementId);
        }
        if (actualObject instanceof Connector) {
            var canvas = actualObject.wrapper;
            var segment = canvas.children[0];
            var bounds = new Rect(segment.offsetX - segment.width / 2, segment.offsetY - segment.height / 2, segment.width, segment.height);
            fixedUserHandleWrapper =
                actualObject.getFixedUserHandle(actualObject.fixedUserHandles[actualObject.fixedUserHandles.length - 1], actualObject.intermediatePoints, bounds, undefined, undefined);
        }
        for (var i = 0; i < nodes.children.length; i++) {
            if (fixedUserHandleWrapper.id === nodes.children[parseInt(i.toString(), 10)].id) {
                nodes.children.splice(i, 1, fixedUserHandleWrapper);
            }
        }
    };
    Diagram.prototype.updateAnnotationContent = function (changedObject, isMeasure, annotationWrapper, actualObject, actualAnnotation, nodes) {
        if (changedObject.content !== undefined) {
            if (annotationWrapper) {
                if (actualObject.shape.type === 'UmlActivity' &&
                    ((!isBlazor() && actualObject.shape.shape === 'StructuredNode'))) {
                    annotationWrapper.content = '<<' + changedObject.content + '>>';
                }
                else {
                    annotationWrapper.content = changedObject.content;
                }
            }
            if (annotationWrapper instanceof DiagramHtmlElement) {
                this.updateAnnotationWrapper(annotationWrapper, actualObject, actualAnnotation, nodes);
            }
        }
        if (changedObject.template !== undefined) {
            annotationWrapper.content = changedObject.template;
            this.updateAnnotationWrapper(annotationWrapper, actualObject, actualAnnotation, nodes);
        }
    };
    Diagram.prototype.updateAnnotationWrapper = function (annotationWrapper, actualObject, actualAnnotation, nodes) {
        for (var _i = 0, _a = this.views; _i < _a.length; _i++) {
            var elementId = _a[_i];
            removeElement(annotationWrapper.id + '_groupElement', elementId);
            removeElement(annotationWrapper.id + '_html_element', elementId);
        }
        if (actualObject instanceof Node) {
            annotationWrapper =
                actualObject.initAnnotationWrapper(actualAnnotation, this.element.id);
        }
        else if (actualObject instanceof Connector) {
            var canvas = actualObject.wrapper;
            var segment = canvas.children[0];
            var bounds = new Rect(segment.offsetX - segment.width / 2, segment.offsetY - segment.height / 2, segment.width, segment.height);
            annotationWrapper =
                actualObject.getAnnotationElement(actualObject.annotations[actualObject.annotations.length - 1], actualObject.intermediatePoints, bounds, this.getDescription, this.element.id);
        }
        for (var i = 0; i < nodes.children.length; i++) {
            if (annotationWrapper.id === nodes.children[parseInt(i.toString(), 10)].id) {
                nodes.children.splice(i, 1, annotationWrapper);
            }
        }
    };
    /**
     * updateNodefixedUserHandle method \
     *
     * @returns { void }  updateNodefixedUserHandle method .\
     * @param {NodeFixedUserHandleModel} changedObject - provide the changedObject value.
     * @param {NodeFixedUserHandleModel} actualfixedUserHandle - provide the actualfixedUserHandle value.
     * @param {Container} nodes - provide the changedObject value.
     * @param {Object} actualObject - provide the changedObject value.
     *
     * @private
     */
    Diagram.prototype.updateNodefixedUserHandle = function (changedObject, actualfixedUserHandle, nodes, actualObject) {
        //let fixedUserHandleWrapper: Canvas;
        var isMeasure = false;
        var fixedUserHandleWrapper = this.getWrapper(nodes, actualfixedUserHandle.id);
        if (fixedUserHandleWrapper !== undefined) {
            if (changedObject.width !== undefined) {
                fixedUserHandleWrapper.actualSize.width = changedObject.width;
                isMeasure = true;
            }
            if (changedObject.height !== undefined) {
                fixedUserHandleWrapper.height = changedObject.height;
                isMeasure = true;
            }
            if (actualfixedUserHandle instanceof NodeFixedUserHandle &&
                changedObject.offset !== undefined) {
                var offset = changedObject.offset;
                isMeasure = true;
                var offsetX = offset.x !== undefined ? offset.x :
                    actualfixedUserHandle.offset.x;
                var offsetY = offset.y !== undefined ? offset.y :
                    actualfixedUserHandle.offset.y;
                fixedUserHandleWrapper.setOffsetWithRespectToBounds(offsetX, offsetY, 'Fraction');
                fixedUserHandleWrapper.relativeMode = 'Point';
            }
            if (changedObject.margin !== undefined) {
                isMeasure = true;
                if (changedObject.margin.bottom !== undefined) {
                    fixedUserHandleWrapper.margin.bottom = changedObject.margin.bottom;
                }
                if (changedObject.margin.top !== undefined) {
                    fixedUserHandleWrapper.margin.top = changedObject.margin.top;
                }
                if (changedObject.margin.left !== undefined) {
                    fixedUserHandleWrapper.margin.left = changedObject.margin.left;
                }
                if (changedObject.margin.right !== undefined) {
                    fixedUserHandleWrapper.margin.right = changedObject.margin.right;
                }
            }
            if (changedObject.visibility !== undefined) {
                fixedUserHandleWrapper.visible = changedObject.visibility;
            }
            if (changedObject.fill !== undefined) {
                fixedUserHandleWrapper.style.fill = changedObject.fill;
            }
            if (changedObject.handleStrokeColor !== undefined) {
                fixedUserHandleWrapper.style.strokeColor = changedObject.handleStrokeColor;
            }
            if (changedObject.handleStrokeWidth !== undefined) {
                fixedUserHandleWrapper.style.strokeWidth = changedObject.handleStrokeWidth;
            }
            if (changedObject.cornerRadius !== undefined) {
                fixedUserHandleWrapper.cornerRadius = changedObject.cornerRadius;
            }
            this.updatefixedUserHandleWrapper(fixedUserHandleWrapper, actualObject, actualfixedUserHandle, nodes);
            if (isMeasure === true) {
                fixedUserHandleWrapper.measure(new Size(fixedUserHandleWrapper.width, fixedUserHandleWrapper.height));
                fixedUserHandleWrapper.arrange(fixedUserHandleWrapper.desiredSize);
            }
        }
    };
    Diagram.prototype.updatefixedUserHandleWrapper = function (fixedUserHandleWrapper, actualObject, actualAnnotation, nodes) {
        for (var _i = 0, _a = this.views; _i < _a.length; _i++) {
            var elementId = _a[_i];
            removeElement(fixedUserHandleWrapper.id + '_groupElement', elementId);
            removeElement(fixedUserHandleWrapper.id + '_html_element', elementId);
        }
        if (actualObject instanceof Node) {
            fixedUserHandleWrapper = actualObject.initFixedUserHandles(actualAnnotation, undefined, undefined);
        }
        for (var i = 0; i < nodes.children.length; i++) {
            if (fixedUserHandleWrapper.id === nodes.children[parseInt(i.toString(), 10)].id) {
                nodes.children.splice(i, 1, fixedUserHandleWrapper);
            }
        }
    };
    /**
     * updatePort method \
     *
     * @returns { void }  updatePort method .\
     * @param {PointPortModel} changedObject - provide the changedObject value.
     * @param {PointPortModel} actualPort - provide the changedObject value.
     * @param {Container} nodes - provide the changedObject value.
     * @param {Connector} actualObject - The actual connector object to be used.
     * @private
     */
    Diagram.prototype.updatePort = function (changedObject, actualPort, nodes, actualObject) {
        var isMeasure = false;
        var portWrapper = this.getWrapper(nodes, actualPort.id);
        if (portWrapper !== undefined) {
            if (changedObject.offset !== undefined) {
                isMeasure = true;
                if (!actualObject) {
                    var offsetX = changedObject.offset.x !== undefined ? changedObject.offset.x :
                        actualPort.offset.x;
                    var offsetY = changedObject.offset.y !== undefined ? changedObject.offset.y :
                        actualPort.offset.y;
                    portWrapper.setOffsetWithRespectToBounds(offsetX, offsetY, 'Fraction');
                    portWrapper.relativeMode = 'Point';
                }
                else {
                    if (changedObject.offset !== undefined) {
                        actualObject.updateAnnotation(actualPort, actualObject.intermediatePoints, actualObject.wrapper.bounds, portWrapper);
                    }
                }
            }
            if (changedObject.width !== undefined) {
                isMeasure = true;
                portWrapper.width = changedObject.width;
            }
            if (changedObject.height !== undefined) {
                isMeasure = true;
                portWrapper.height = changedObject.height;
            }
            if (changedObject.connectionDirection !== undefined) {
                portWrapper.connectionDirection = changedObject.connectionDirection;
            }
            if (changedObject.visibility !== undefined) {
                portWrapper.visible = (nodes.visible && checkPortRestriction(actualPort, PortVisibility.Visible)) ? true : false;
            }
            if (changedObject.margin !== undefined) {
                isMeasure = true;
                if (changedObject.margin.bottom !== undefined) {
                    portWrapper.margin.bottom = changedObject.margin.bottom;
                }
                if (changedObject.margin.top !== undefined) {
                    portWrapper.margin.top = changedObject.margin.top;
                }
                if (changedObject.margin.right !== undefined) {
                    portWrapper.margin.right = changedObject.margin.right;
                }
                if (changedObject.margin.left !== undefined) {
                    portWrapper.margin.left = changedObject.margin.left;
                }
            }
            if (changedObject.horizontalAlignment !== undefined) {
                isMeasure = true;
                portWrapper.horizontalAlignment = changedObject.horizontalAlignment;
            }
            if (changedObject.verticalAlignment !== undefined) {
                isMeasure = true;
                portWrapper.verticalAlignment = changedObject.verticalAlignment;
            }
            if (changedObject.style !== undefined) {
                if (changedObject.style.fill !== undefined) {
                    portWrapper.style.fill = changedObject.style.fill;
                }
                if (changedObject.style.opacity !== undefined) {
                    portWrapper.style.opacity = changedObject.style.opacity;
                }
                if (changedObject.style.strokeColor !== undefined) {
                    portWrapper.style.strokeColor = changedObject.style.strokeColor;
                }
                if (changedObject.style.strokeWidth !== undefined) {
                    portWrapper.style.strokeWidth = changedObject.style.strokeWidth;
                }
                if (changedObject.style.strokeDashArray !== undefined) {
                    portWrapper.style.strokeDashArray = changedObject.style.strokeDashArray;
                }
            }
            if (changedObject.shape !== undefined) {
                if (portWrapper) {
                    var pathdata = getPortShape(changedObject.shape);
                    portWrapper.data = pathdata;
                    portWrapper.canMeasurePath = true;
                }
            }
            if (changedObject.pathData !== undefined) {
                portWrapper.data = String(changedObject.pathData);
                isMeasure = true;
            }
            if (isMeasure === true) {
                portWrapper.measure(new Size(portWrapper.width, portWrapper.height));
                portWrapper.arrange(portWrapper.desiredSize);
            }
            //this.refresh(); this.refreshDiagramLayer();
        }
    };
    /**
     * updateIcon method \
     *
     * @returns { void }  updateIcon method .\
     * @param {Node} actualObject - provide the obj value.
     *
     * @private
     */
    Diagram.prototype.updateIcon = function (actualObject) {
        var iconContainer = this.getWrapper(actualObject.wrapper, 'icon_content');
        var diagramId = (this.diagramActions & DiagramAction.Render) ? this.element.id : undefined;
        if (iconContainer) {
            if (this.mode === 'SVG') {
                var icon = getDiagramElement(actualObject.wrapper.id + '_icon_content', diagramId);
                if (icon) {
                    var iconRect = getDiagramElement(icon.id + '_rect', diagramId);
                    var iconShape = getDiagramElement(icon.id + '_shape', diagramId);
                    var nativeContent = getDiagramElement(iconShape.id + '_native_element', diagramId);
                    if (nativeContent) {
                        nativeContent.parentNode.removeChild(nativeContent);
                    }
                    iconShape.parentNode.removeChild(iconShape);
                    iconRect.parentNode.removeChild(iconRect);
                    icon.parentNode.removeChild(icon);
                }
            }
            var index = actualObject.wrapper.children.indexOf(iconContainer);
            actualObject.wrapper.children.splice(index, 1);
        }
        var portContainer = this.getPortContainer(actualObject);
        actualObject.initIcons(this.getDescription, this.layout, portContainer, this.element.id);
    };
    Diagram.prototype.getPortContainer = function (actualObject) {
        if (actualObject.children) {
            for (var i = 0; i < actualObject.wrapper.children.length; i++) {
                if (actualObject.wrapper.children[parseInt(i.toString(), 10)].id === actualObject.id + 'group_container') {
                    return actualObject.wrapper.children[parseInt(i.toString(), 10)];
                }
            }
        }
        return actualObject.wrapper;
    };
    Diagram.prototype.updateTooltip = function (actualObject, node) {
        if (node.tooltip.content !== undefined) {
            actualObject.tooltip.content = node.tooltip.content;
        }
        if (node.tooltip.position !== undefined) {
            actualObject.tooltip.position = node.tooltip.position;
        }
        if (node.tooltip.height !== undefined) {
            actualObject.tooltip.height = node.tooltip.height;
        }
        if (node.tooltip.width !== undefined) {
            actualObject.tooltip.width = node.tooltip.width;
        }
        if (node.tooltip.showTipPointer !== undefined) {
            actualObject.tooltip.showTipPointer = node.tooltip.showTipPointer;
        }
        if (node.tooltip.relativeMode !== undefined) {
            actualObject.tooltip.relativeMode = node.tooltip.relativeMode;
        }
    };
    /**
     * updateQuad method \
     *
     * @returns { void }  updateQuad method .\
     * @param {IElement} obj - provide the obj value.
     *
     * @private
     */
    Diagram.prototype.updateQuad = function (obj) {
        var modified = this.spatialSearch.updateQuad(obj.wrapper);
        if (modified && !this.preventDiagramUpdate) {
            this.updatePage();
        }
    };
    /**
     * removeFromAQuad method \
     *
     * @returns { void }  removeFromAQuad method .\
     * @param {IElement} obj - provide the node value.
     *
     * @private
     */
    Diagram.prototype.removeFromAQuad = function (obj) {
        if (obj.children) {
            var child = void 0;
            var children = obj.children;
            for (var i = 0; i < children.length; i++) {
                child = this.nameTable[children[parseInt(i.toString(), 10)]];
                if (child) {
                    this.removeFromAQuad(child);
                }
            }
        }
        this.spatialSearch.removeFromAQuad(obj.wrapper);
        var isSwimLane = obj.shape.type === 'SwimLane' ? true : false;
        var modified = this.spatialSearch.updateBounds(obj.wrapper, isSwimLane);
        if (modified && !this.preventDiagramUpdate) {
            this.updatePage();
        }
    };
    /**
     * updateGroupSize method \
     *
     * @returns { void }  updateGroupSize method .\
     * @param {NodeModel | ConnectorModel} node - provide the node value.
     *
     * @private
     */
    Diagram.prototype.updateGroupSize = function (node) {
        var tempNode;
        if (node.parentId) {
            tempNode = this.nameTable[node.parentId];
            if (tempNode) {
                if (tempNode.parentId) {
                    this.updateGroupSize(tempNode);
                }
                else {
                    tempNode.wrapper.measure(new Size());
                    tempNode.wrapper.arrange(tempNode.wrapper.desiredSize);
                    this.updateGroupOffset(tempNode);
                    this.updateDiagramObject(tempNode);
                }
            }
        }
    };
    Diagram.prototype.updatePage = function () {
        if ((this.diagramActions & DiagramAction.Render) &&
            !(this.diagramActions & DiagramAction.DragUsingMouse)) {
            this.scroller.updateScrollOffsets();
            this.scroller.setSize();
            //updating overview
            for (var _i = 0, _a = this.views; _i < _a.length; _i++) {
                var temp = _a[_i];
                var view = this.views["" + temp];
                if (!(view instanceof Diagram)) {
                    view.updateView(view);
                }
            }
        }
        if (this.diagramActions & DiagramAction.DragUsingMouse) {
            this.renderPageBreaks();
            // EJ2-826378 - Scroller not updated properly when dragging a node outside the viewport.
            // We need to update the scroller while dragging.
            // If pageSize is defined, we don't need to update the scrollbar.
            // If pageSize is not defined, we need to update the scrollbar because the content is treated as page bounds, and if the content goes beyond the viewport, the scrollbar should be updated.
            if (!(this.pageSettings.width && this.pageSettings.height) || this.pageSettings.multiplePage) {
                this.scroller.updateScrollOffsets();
                this.scroller.setSize();
            }
        }
    };
    /**
     * protectPropertyChange method \
     *
     * @returns { void }  protectPropertyChange method .\
     * @param {boolean} enable - provide the enable value.
     *
     * @private
     */
    Diagram.prototype.protectPropertyChange = function (enable) {
        this.isProtectedOnChange = enable;
    };
    /**
     * getProtectPropertyChangeValue method \
     *
     * @returns { boolean }  getProtectPropertyChangeValue method .\
     *
     * @private
     */
    Diagram.prototype.getProtectPropertyChangeValue = function () {
        return this.isProtectedOnChange;
    };
    /**
     * enableServerDataBinding method \
     *
     * @returns { void }  enableServerDataBinding method .\
     * @param {boolean} enable - provide the node value.
     *
     * @private
     */
    Diagram.prototype.enableServerDataBinding = function (enable) {
        //Removed isBlazor code
    };
    /**
     * updateShadow method \
     *
     * @returns { void }  updateShadow method .\
     * @param {ShadowModel} nodeShadow - provide the node value.
     * @param {ShadowModel} changedShadow - provide the Node value.
     *
     * @private
     */
    Diagram.prototype.updateShadow = function (nodeShadow, changedShadow) {
        if (changedShadow.angle !== undefined) {
            nodeShadow.angle = changedShadow.angle;
        }
        if (changedShadow.color !== undefined) {
            nodeShadow.color = changedShadow.color;
        }
        if (changedShadow.distance !== undefined) {
            nodeShadow.distance = changedShadow.distance;
        }
        if (changedShadow.opacity !== undefined) {
            nodeShadow.opacity = changedShadow.opacity;
        }
    };
    /**
     * updateMargin method \
     *
     * @returns { void }  updateMargin method .\
     * @param {Node} node - provide the node value.
     * @param {Node} changes - provide the Node value.
     *
     * @private
     */
    Diagram.prototype.updateMargin = function (node, changes) {
        if (changes.margin.top !== undefined) {
            node.margin.top = changes.margin.top;
        }
        if (changes.margin.bottom !== undefined) {
            node.margin.bottom = changes.margin.bottom;
        }
        if (changes.margin.left !== undefined) {
            node.margin.left = changes.margin.left;
        }
        if (changes.margin.right !== undefined) {
            node.margin.right = changes.margin.right;
        }
    };
    Diagram.prototype.removePreviewChildren = function (preview) {
        if (preview.children && preview.children.length &&
            preview.shape && preview.shape.type === 'SwimLane') {
            for (var z = 0; z < preview.children.length; z++) {
                var previewChildId = preview.children[parseInt(z.toString(), 10)];
                var previewIndex_1 = this.nodes.indexOf(this.nameTable["" + previewChildId]);
                if (previewIndex_1 >= 0) {
                    this.nodes.splice(previewIndex_1, 1);
                }
                delete this.nameTable["" + previewChildId];
            }
            var previewIndex = this.nodes.indexOf(this.nameTable[this.currentSymbol.id]);
            if (previewIndex >= 0) {
                this.nodes.splice(previewIndex, 1);
            }
        }
    };
    Diagram.prototype.selectDragedNode = function (newObj, args, selectedSymbol) {
        this.currentSymbol = newObj;
        if (this.mode !== 'SVG') {
            this.refreshDiagramLayer();
        }
        this.commandHandler.oldSelectedObjects = cloneSelectedObjects(this);
        this.commandHandler.select(newObj);
        // this.commandHandler.updateBlazorSelector();
        this.eventHandler.mouseDown(args.event);
        this.eventHandler.mouseMove(args.event, args);
        this.preventDiagramUpdate = false;
        this.updatePage();
        selectedSymbol.style.opacity = '0';
    };
    //property changes - end region
    /* tslint:disable */
    Diagram.prototype.initDroppables = function () {
        var _this = this;
        // initiates droppable event
        var childTable = {};
        var entryTable = {};
        var header;
        var lane;
        var selectedSymbols = 'selectedSymbols';
        this.droppable = new Droppable(this.element);
        var dragLeft = 5;
        // this.droppable.accept = '.e-dragclone';
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.droppable.over = function (args) {
            //Bug 855292: Swimlane dragging from palette jumps out of viewport when multiple page is set as true.
            // Added below code to prevent the negative x value of swimlane bounds when multiple page and ruler is enabled to prevent swimlane jump.
            if (_this.rulerSettings.showRulers) {
                var vRuler = document.getElementById(_this.element.id + '_vRuler');
                var vRulerWidth = parseFloat(vRuler.style.width);
                dragLeft = vRulerWidth + 1;
            }
            //EJ2-59341- SelectionChange OldValue argument is null
            if (_this.previousSelectedObjects.length === 0 && !_this.currentSymbol) {
                _this.previousSelectedObjects = _this.commandHandler.getSelectedObject();
            }
            _this.commandHandler.PreventConnectorSplit = true;
            if (!_this.currentSymbol) {
                var dragDataHelper = null;
                if (!args.dragData && args.name === 'drag') {
                    var helper = document.getElementsByClassName('e-dragclone')[0];
                    if (helper) {
                        dragDataHelper = helper;
                    }
                }
                if (args.dragData || dragDataHelper) {
                    var newObj = void 0;
                    var isHorizontal = void 0;
                    document.getElementById(_this.element.id + 'content').focus();
                    var position = _this.eventHandler.getMousePosition(args.event);
                    var clonedObject = void 0;
                    var selectedSymbol = dragDataHelper || args.dragData.helper;
                    var paletteId = selectedSymbol.getAttribute('paletteId');
                    var nodeDragSize = void 0;
                    var nodePreviewSize = void 0;
                    var paletteDragSize = void 0;
                    var preview = void 0;
                    if (!paletteId && args.dragData) {
                        var arg = {
                            source: null, element: newObj, cancel: false,
                            diagram: _this,
                            dragData: args.dragData.draggedElement.ej2_instances[0].dragData,
                            dragItem: newObj
                        };
                        _this.triggerEvent(DiagramEvent.dragEnter, arg);
                        var newNode = void 0;
                        var newConnector = void 0;
                        // EJ2-61664 - Check whether dragItem is returned from dragEnter event or not.
                        // If it does not returned means then we do not change the treeview object as node
                        if (arg.dragItem) {
                            if (arg.dragItem.sourcePoint && arg.dragItem.targetPoint) {
                                newConnector = new Connector(_this, 'connectors', arg.dragItem, true);
                            }
                            else {
                                newNode = new Node(_this, 'nodes', arg.dragItem, true);
                            }
                            newObj = newNode ? newNode : newConnector;
                            _this.initObject(newObj, undefined, undefined, true);
                            _this['enterObject'] = newObj;
                            _this['enterTable'] = entryTable;
                            if (newObj instanceof Node) {
                                newNode.offsetX = position.x + 5 + (newNode.width) * newNode.pivot.x;
                                newNode.offsetY = position.y + (newNode.height) * newNode.pivot.y;
                            }
                            else if (newObj instanceof Connector) {
                                var newObjBounds = Rect.toBounds([newObj.sourcePoint, newObj.targetPoint]);
                                var diffx = position.x - newObjBounds.left;
                                var diffy = position.y - newObjBounds.top;
                                newObj.sourcePoint.x += diffx;
                                newObj.sourcePoint.y += diffy;
                                newObj.targetPoint.x += diffx;
                                newObj.targetPoint.y += diffy;
                            }
                            _this.preventDiagramUpdate = true;
                            _this.currentSymbol = newObj;
                            if (_this.mode !== 'SVG') {
                                _this.refreshDiagramLayer();
                            }
                            _this.selectDragedNode(newObj, args, selectedSymbol);
                            delete _this['enterObject'];
                            delete _this['enterTable'];
                            _this.droppable["" + selectedSymbols] = selectedSymbol;
                            _this.allowServerDataBinding = true;
                        }
                    }
                    if (paletteId) {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        var sourceElement = document.getElementById(paletteId).ej2_instances[0];
                        var source = 'sourceElement';
                        _this.droppable["" + source] = sourceElement;
                        var childtable = 'childTable';
                        if (sourceElement) {
                            var obj = sourceElement["" + selectedSymbols];
                            _this.allowServerDataBinding = false;
                            clonedObject = cloneObject(sourceElement["" + selectedSymbols]);
                            childTable = sourceElement["" + childtable];
                            var wrapper = obj.wrapper.children[0].children[0];
                            preview = getPreviewSize(sourceElement, clonedObject, wrapper);
                            if (sourceElement["" + selectedSymbols] instanceof Node) {
                                if (obj.shape.shape === 'TextAnnotation') {
                                    // eslint-disable-next-line max-len
                                    clonedObject.offsetX = position.x + 11 + (preview.width) * clonedObject.pivot.x;
                                    // eslint-disable-next-line max-len
                                    clonedObject.offsetY = position.y + 11 + (preview.height) * clonedObject.pivot.y;
                                }
                                else {
                                    // eslint-disable-next-line max-len
                                    clonedObject.offsetX = position.x + 5 + (preview.width) * clonedObject.pivot.x;
                                    // eslint-disable-next-line max-len
                                    clonedObject.offsetY = position.y + (preview.height) * clonedObject.pivot.y;
                                }
                                var newNode = new Node(_this, 'nodes', clonedObject, true);
                                if (newNode.shape.type === 'Bpmn' && newNode.shape.activity.subProcess.processes
                                    && newNode.shape.activity.subProcess.processes.length) {
                                    newNode.shape.activity.subProcess.processes = [];
                                }
                                nodeDragSize = newNode.dragSize;
                                nodePreviewSize = newNode.previewSize;
                                paletteDragSize = sourceElement['symbolDragSize'];
                                var palettePreview = sourceElement['symbolPreview'];
                                // eslint-disable-next-line max-len
                                newNode.width = nodeDragSize.width || paletteDragSize.width || nodePreviewSize.width || palettePreview.width || newNode.width;
                                // eslint-disable-next-line max-len
                                newNode.height = nodeDragSize.height || paletteDragSize.height || nodePreviewSize.height || palettePreview.height || newNode.height;
                                if (newNode.shape.type === 'SwimLane') {
                                    _this.diagramActions |= DiagramAction.PreventHistory;
                                    if (newNode.shape.isLane) {
                                        newNode.children = [];
                                        header = {
                                            id: 'header' + randomId()
                                        };
                                        if (newNode.shape.orientation === 'Horizontal') {
                                            header.width = newNode.shape.lanes[0].header.width;
                                            header.height = newNode.shape.lanes[0].height;
                                        }
                                        else {
                                            header.width = newNode.shape.lanes[0].width;
                                            header.height = newNode.shape.lanes[0].header.height;
                                        }
                                        header.style = newNode.shape.lanes[0].header.style;
                                        header.offsetX = position.x + dragLeft + header.width / 2;
                                        header.offsetY = position.y + header.height / 2;
                                        _this.diagramActions |= DiagramAction.PreventCollectionChangeOnDragOver;
                                        header = _this.add(header);
                                        lane = {
                                            id: 'body' + randomId()
                                        };
                                        if (newNode.shape.orientation === 'Horizontal') {
                                            lane.width = newNode.shape.lanes[0].width - header.width;
                                            lane.height = newNode.shape.lanes[0].height;
                                            // eslint-disable-next-line max-len
                                            lane.offsetX = position.x + dragLeft + (newNode.shape.lanes[0].header.width + (lane.width / 2));
                                            lane.offsetY = position.y + lane.height / 2;
                                        }
                                        else {
                                            lane.width = newNode.shape.lanes[0].width;
                                            lane.height = newNode.shape.lanes[0].height - header.height;
                                            lane.offsetX = position.x + dragLeft + lane.width / 2;
                                            // eslint-disable-next-line max-len
                                            lane.offsetY = position.y + (newNode.shape.lanes[0].header.height + (lane.height / 2));
                                        }
                                        lane.style = newNode.shape.lanes[0].style;
                                        lane = _this.add(lane);
                                        var group = {
                                            id: 'group' + randomId(),
                                            children: [header.id, lane.id]
                                        };
                                        group.shape = newNode.shape;
                                        group.width = newNode.shape.lanes[0].width;
                                        group.height = newNode.shape.lanes[0].height;
                                        group.previewSize = newNode.previewSize;
                                        group.dragSize = newNode.dragSize;
                                        group.addInfo = newNode.addInfo;
                                        newNode = _this.add(group);
                                        _this.diagramActions &= ~DiagramAction.PreventCollectionChangeOnDragOver;
                                    }
                                    _this.diagramActions &= ~DiagramAction.PreventHistory;
                                }
                                if (newNode.shape.isPhase) {
                                    isHorizontal = (newNode.shape.orientation === 'Horizontal') ? true : false;
                                    if (isHorizontal) {
                                        newNode.offsetX = position.x + dragLeft + (newNode.width || wrapper.actualSize.width) / 2;
                                        newNode.offsetY = position.y;
                                        newNode.shape.data =
                                            'M' + 20 + ',' + (newNode.height / 2) + ' L' + (newNode.width - 20) + ',' +
                                                (newNode.height / 2) + 'z';
                                        newNode.height = 1;
                                    }
                                    else {
                                        newNode.offsetX = position.x + 5;
                                        newNode.offsetY = position.y + (newNode.height || wrapper.actualSize.height) / 2;
                                        newNode.shape.data =
                                            'M' + (newNode.width / 2) + ',' + 20 + ' L' + (newNode.width / 2) +
                                                ',' + (newNode.height - 20) + 'z';
                                        newNode.width = 1;
                                    }
                                }
                                if (newNode.shape.type === 'UmlClassifier') {
                                    //When dragging a node from the palette to the diagram, set the children, width, and height values to undefined to avoid incorrect values.
                                    newNode.children = newNode.width = newNode.height = undefined;
                                    clonedObject.children = undefined;
                                    //An empty child type is added during drag enter for every node if no child types are specified in the palette.
                                    if (newNode.shape.classifier === 'Class') {
                                        if (newNode.shape.classShape.methods.length <= 0
                                            && newNode.shape.classShape.attributes.length <= 0) {
                                            newNode.shape.classShape.attributes = [
                                                { name: 'Name', type: 'Type', style: {} }
                                            ];
                                        }
                                    }
                                    if (newNode.shape.classifier === 'Enumeration') {
                                        if (newNode.shape.enumerationShape.members.length <= 0) {
                                            newNode.shape.enumerationShape.members = [
                                                {
                                                    name: 'Name'
                                                }
                                            ];
                                        }
                                    }
                                    if (newNode.shape.classifier === 'Interface') {
                                        if (newNode.shape.interfaceShape.methods.length <= 0
                                            && newNode.shape.interfaceShape.attributes.length <= 0) {
                                            newNode.shape.interfaceShape.attributes = [
                                                { name: 'Name', type: 'Type', style: {} }
                                            ];
                                        }
                                    }
                                }
                                newObj = newNode;
                                if (clonedObject.children) {
                                    var parentNode = clonedObject;
                                    var tempTable = {};
                                    entryTable = _this.getChildren(parentNode, tempTable, childTable);
                                    arrangeChild(parentNode, -parentNode.offsetX, -parentNode.offsetY, entryTable, true, _this);
                                }
                            }
                            else if (sourceElement["" + selectedSymbols] instanceof Connector) {
                                newObj = new Connector(_this, 'connectors', clonedObject, true);
                                var bounds = Rect.toBounds([newObj.sourcePoint, newObj.targetPoint]);
                                var tx = position.x - bounds.left;
                                var ty = position.y - bounds.top;
                                newObj.sourcePoint.x += tx;
                                newObj.sourcePoint.y += ty;
                                newObj.targetPoint.x += tx;
                                newObj.targetPoint.y += ty;
                            }
                            if (!newObj.shape.isLane) {
                                newObj.id += randomId();
                            }
                            var arg = {
                                source: sourceElement, element: newObj, cancel: false,
                                diagram: _this, dragData: null, dragItem: newObj
                            };
                            //Removed isBlazor code
                            _this['enterObject'] = newObj;
                            _this['enterTable'] = entryTable;
                            _this.triggerEvent(DiagramEvent.dragEnter, arg);
                            if ((newObj instanceof Node) && newObj.shape.type === 'SwimLane' && newObj.shape.isLane) {
                                var swimLaneObj = arg.element;
                                var laneObj = swimLaneObj.shape.lanes[0];
                                //let child1: NodeModel; let child2: NodeModel;
                                isHorizontal = (swimLaneObj.shape.orientation === 'Horizontal') ? true : false;
                                var child1 = _this.nameTable[newObj.children[0]];
                                var child2 = _this.nameTable[newObj.children[1]];
                                nodeDragSize = newObj.dragSize;
                                nodePreviewSize = newObj.previewSize;
                                paletteDragSize = sourceElement['symbolDragSize'];
                                laneObj.width = nodeDragSize.width || paletteDragSize.width || nodePreviewSize.width || laneObj.width;
                                laneObj.height = nodeDragSize.height || paletteDragSize.height || nodePreviewSize.height || laneObj.height;
                                if (isHorizontal) {
                                    header.width = laneObj.header.width;
                                    header.height = laneObj.height;
                                    lane.width = laneObj.width - header.width;
                                    lane.height = laneObj.height;
                                    lane.offsetX = position.x + dragLeft + (laneObj.header.width + (child2.width / 2));
                                    lane.offsetY = position.y + child2.height / 2;
                                }
                                else {
                                    header.width = laneObj.width;
                                    header.height = laneObj.header.height;
                                    lane.width = laneObj.width;
                                    lane.height = laneObj.height - header.height;
                                    lane.offsetX = position.x + dragLeft + child2.width / 2;
                                    lane.offsetY = position.y + (laneObj.header.height + (child2.height / 2));
                                }
                                header.offsetX = position.x + dragLeft + child1.width / 2;
                                header.offsetY = position.y + child1.height / 2;
                                newObj.width = laneObj.width;
                                newObj.height = laneObj.height;
                            }
                            if ((newObj instanceof Node) && newObj.shape.isPhase) {
                                if (isHorizontal) {
                                    newObj.height = 1;
                                }
                                else {
                                    newObj.width = 1;
                                }
                            }
                            if (!_this.activeLayer.lock && !arg.cancel) {
                                _this.preventDiagramUpdate = true;
                                if (newObj.children) {
                                    _this.findChild(newObj, entryTable);
                                }
                                _this.preventDiagramUpdate = true;
                                if (newObj.zIndex !== Number.MIN_VALUE) {
                                    newObj.zIndex = Number.MIN_VALUE;
                                }
                                _this.initObject(newObj, undefined, undefined, true);
                                if (_this.bpmnModule) {
                                    for (var i = 0; i < _this.bpmnModule.bpmnTextAnnotationConnector.length; i++) {
                                        if (_this.bpmnModule.bpmnTextAnnotationConnector[parseInt(i.toString(), 10)].wrapper === null) {
                                            _this.initConnectors(_this.bpmnModule.bpmnTextAnnotationConnector[parseInt(i.toString(), 10)], undefined, true);
                                        }
                                    }
                                }
                                _this.selectDragedNode(newObj, args, selectedSymbol);
                            }
                            delete _this['enterObject'];
                            delete _this['enterTable'];
                        }
                        _this.droppable["" + selectedSymbols] = selectedSymbol;
                        _this.allowServerDataBinding = true;
                    }
                }
            }
            else {
                if (args.event.touches && args.event.touches.length) {
                    _this.eventHandler.mouseMove(args.event, args.event.touches);
                }
            }
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.droppable.drop = function (args) { return __awaiter$2(_this, void 0, void 0, function () {
            var source, value, isPhase, orientation_2, isConnector, arg, id, clonedObject, nodeId, newObj, arg, clonedObject, id, selectedSymbols, draggableElement, i;
            return __generator$2(this, function (_a) {
                this.allowServerDataBinding = false;
                source = 'sourceElement';
                if (this.currentSymbol) {
                    isPhase = false;
                    isConnector = (this.currentSymbol instanceof Connector) ? true : false;
                    if (args.event.touches) {
                        this.eventHandler.mouseUp(args.event);
                    }
                    arg = {
                        source: this.droppable["" + source],
                        element: this.currentSymbol,
                        //EJ2-895314: Connector splits while dropping node on diagram, even after moving node away from connector highlighter
                        target: this.eventHandler['hoverNode'] ||
                            (this.findObjectsUnderMouse(this.eventHandler.getMousePosition(args.event))[0]) || this,
                        cancel: false,
                        position: { x: this.currentSymbol.wrapper.offsetX, y: this.currentSymbol.wrapper.offsetY }
                    };
                    // Removed isBlazor code
                    this.commandHandler.PreventConnectorSplit = false;
                    this.triggerEvent(DiagramEvent.drop, arg);
                    id = 'id';
                    clonedObject = cloneObject(this.currentSymbol);
                    clonedObject['hasTarget'] = this.currentSymbol['hasTarget'];
                    this.removeFromAQuad(this.currentSymbol);
                    this.removeObjectsFromLayer(this.nameTable[this.currentSymbol.id]);
                    this.removeElements(this.currentSymbol);
                    //887625-UML class nodes cloned in diagram canvas while dragging nodes outside diagram page
                    if ((this.currentSymbol.shape.isLane ||
                        this.currentSymbol.shape.isPhase) || this.currentSymbol.shape.type === 'UmlClassifier') {
                        this.removeChildInNodes(this.currentSymbol);
                    }
                    if (arg.cancel) {
                        removeChildNodes(this.currentSymbol, this);
                    }
                    if (this.currentSymbol.shape.isPhase) {
                        isPhase = true;
                        orientation_2 = this.currentSymbol.shape.orientation;
                        clonedObject.shape.phases = this.currentSymbol.shape.phases;
                    }
                    this.removePreviewChildren(this.currentSymbol);
                    delete this.nameTable[this.currentSymbol.id];
                    this.currentSymbol = null;
                    this.protectPropertyChange(true);
                    if (!arg.cancel) {
                        this.startGroupAction();
                        if (clonedObject && (clonedObject.shape.isLane || isPhase)) {
                            if (isPhase) {
                                clonedObject.shape.isPhase = isPhase;
                                clonedObject.shape.orientation = orientation_2;
                            }
                            this.eventHandler.addSwimLaneObject(clonedObject);
                        }
                        //The following condition is designed to ensure that only UML nodes are added to the diagram during the drop operation
                        if (clonedObject && clonedObject.shape.type === 'UmlClassifier' && !clonedObject.shape.relationship) {
                            clonedObject.children = undefined;
                            this.clearSelectorLayer();
                            this.add(clonedObject);
                        }
                        if (clonedObject.shape.type === 'Bpmn' && clonedObject.shape.annotation
                            && clonedObject['hasTarget']) {
                            nodeId = clonedObject.shape.annotation.nodeId;
                            clonedObject.shape.annotation.id = clonedObject.id;
                            this.addTextAnnotation(clonedObject.shape.annotation, this.nameTable["" + nodeId]);
                            clonedObject.nodeId = '';
                        }
                        if (!clonedObject.shape.isLane && !isPhase && (clonedObject.type !== undefined || clonedObject.shape.type !== 'UmlClassifier')) {
                            if (clonedObject.children) {
                                this.addChildNodes(clonedObject);
                            }
                            //Bug 880814: Adding element to bpmn expanded subprocess located in swimlane throws an exception.
                            // isTargetSubProcess is checked.
                            if (arg.target && (arg.target instanceof Node) && !isConnector && checkParentAsContainer(this, arg.target)
                                && canAllowDrop(arg.target) && !this.commandHandler.isTargetSubProcess(arg.target)) {
                                addChildToContainer(this, arg.target, clonedObject);
                            }
                            else {
                                // EJ2-62652 - Added below code to empty the segment collection if connector type is bezier
                                if (clonedObject.type === 'Bezier' && clonedObject.segments.length > 0) {
                                    clonedObject.segments = [];
                                }
                                value = this.add(clonedObject, true);
                            }
                            //EJ2-864543 - Added symbols don't get correctly selected in MultipleSelect mode in Diagram
                            if ((clonedObject || value) && (canSingleSelect(this) || canMultiSelect(this))) {
                                this.select([this.nameTable[clonedObject["" + id]]], false, this.previousSelectedObjects);
                            }
                            //EJ2-909180 - Line routing does not take place when drag and drop from symbol Palatte
                            if (this.lineRoutingModule && (this.constraints & DiagramConstraints.LineRouting)) {
                                this.commandHandler.updateSelectedNodeProperties(this.selectedItems);
                            }
                            if (arg.target && arg.target instanceof Connector) {
                                if (this.enableConnectorSplit === true) {
                                    if (this.nameTable[clonedObject["" + id]] instanceof Node) {
                                        this.commandHandler.connectorSplit(this.nameTable[clonedObject["" + id]], arg.target);
                                        this.commandHandler.PreventConnectorSplit = false;
                                    }
                                }
                            }
                        }
                    }
                    else {
                        this.clearSelectorLayer();
                    }
                    this.protectPropertyChange(false);
                    newObj = this.nameTable[clonedObject["" + id]];
                    if (clonedObject['hasTarget']) {
                        clonedObject.nodeId = clonedObject['hasTarget'];
                        this.remove(clonedObject);
                    }
                    if (this.bpmnModule && newObj instanceof Node && clonedObject.processId) {
                        newObj.processId = clonedObject.processId;
                        this.bpmnModule.dropBPMNchild(this.nameTable[newObj.processId], newObj, this);
                    }
                    if (!arg.cancel) {
                        this.endGroupAction();
                    }
                    if (this.mode !== 'SVG') {
                        this.refreshDiagramLayer();
                    }
                    delete this.droppable["" + source];
                }
                else {
                    arg = {
                        source: cloneBlazorObject(args.droppedElement),
                        element: undefined,
                        target: cloneBlazorObject(this.eventHandler['hoverNode'] || (this.eventHandler['lastObjectUnderMouse']) || this), cancel: false,
                        position: undefined
                    };
                    //Removed is Blazor code.
                    this.triggerEvent(DiagramEvent.drop, arg);
                    clonedObject = void 0;
                    id = 'id';
                }
                selectedSymbols = 'selectedSymbols';
                // eslint-disable-next-line max-len
                if (this.droppable["" + selectedSymbols] && this.droppable["" + selectedSymbols].parentNode) {
                    remove(this.droppable["" + selectedSymbols]);
                }
                else {
                    draggableElement = document.getElementsByClassName('e-dragclone');
                    for (i = 0; i < draggableElement.length; i++) {
                        draggableElement[parseInt(i.toString(), 10)].remove();
                    }
                }
                this.allowServerDataBinding = true;
                this.previousSelectedObjects = [];
                return [2 /*return*/];
            });
        }); };
        this.droppable.out = function (args) {
            // EJ2-57221 - Added the below code to check if we drag the node from symbol palette using touch or mouse.
            if (args.evt.type === 'touchmove') {
                _this.eventHandler.mouseLeave(args.evt);
            }
            if (_this.currentSymbol && (!_this.eventHandler.focus)) {
                _this.unSelect(_this.currentSymbol);
                _this.removeFromAQuad(_this.currentSymbol);
                if (_this.mode !== 'SVG' && _this.currentSymbol.shape.type === 'Native') {
                    _this.removeElements(_this.currentSymbol);
                }
                _this.removeObjectsFromLayer(_this.nameTable[_this.currentSymbol.id]);
                if (_this.currentSymbol.shape && _this.currentSymbol.shape.shape === 'TextAnnotation') {
                    var con = _this.nameTable[_this.currentSymbol.inEdges[0]];
                    _this.removeObjectsFromLayer(_this.nameTable[con.id]);
                    _this.removeFromAQuad(con);
                    _this.removePreviewChildren(con);
                    delete _this.nameTable[con.id];
                    var index = _this.connectors.indexOf(con);
                    _this.connectors.splice(index, 1);
                    _this.removeElements(con);
                }
                _this.removePreviewChildren(_this.currentSymbol);
                delete _this.nameTable[_this.currentSymbol.id];
                var args_1 = {
                    element: cloneBlazorObject(_this.currentSymbol),
                    diagram: _this
                };
                //Removed is Blazor code
                _this.triggerEvent(DiagramEvent.dragLeave, args_1);
                if (_this.mode !== 'SVG') {
                    _this.refreshDiagramLayer();
                }
                else {
                    _this.removeElements(_this.currentSymbol);
                    //EJ2-833020-To remove the child element from the group node while dragging the group node from palette
                    //EJ2-842739- Error When Dragging Swimlane from Palette to Diagram and Exiting Without Dropping
                    if (_this.currentSymbol.shape.type !== 'SwimLane' && _this.currentSymbol.children && _this.currentSymbol.children.length > 0) {
                        for (var i = 0; i < _this.currentSymbol.children.length; i++) {
                            var child = _this.nameTable[_this.currentSymbol.children[parseInt(i.toString(), 10)]];
                            _this.removeElements(child);
                            delete _this.nameTable[_this.currentSymbol.children[parseInt(i.toString(), 10)]];
                        }
                    }
                }
                _this.currentSymbol = null;
                var selectedSymbols_1 = 'selectedSymbols';
                _this.droppable["" + selectedSymbols_1].style.opacity = '1';
                var source = 'sourceElement';
                delete _this.droppable["" + source];
                _this.diagramRenderer.rendererActions =
                    _this.removeConstraints(_this.diagramRenderer.rendererActions, RendererAction.DrawSelectorBorder);
                if (_this.previousSelectedObject) {
                    _this.select(_this.previousSelectedObject, _this.previousSelectedObject.length > 1 ? true : false);
                }
                _this.previousSelectedObject = null;
            }
        };
    };
    // Removed Blazor getBlazorDragLeaveEventArgs method
    Diagram.prototype.getDropEventArgs = function (arg) {
        if ((this.eventHandler['lastObjectUnderMouse'] || this.eventHandler['hoverNode'])) {
            var object = this.eventHandler['lastObjectUnderMouse'] || this.eventHandler['hoverNode'];
            // eslint-disable-next-line max-len
            arg.target = getObjectType(object) === Connector ? { connector: cloneBlazorObject(object) } : { node: cloneBlazorObject(object) };
        }
        else {
            arg.target.diagramId = this.element.id;
        }
    };
    Diagram.prototype.removeChildInNodes = function (node) {
        if (node) {
            if (node.children) {
                for (var i = 0; i < node.children.length; i++) {
                    this.removeChildInNodes(this.nameTable[node.children[parseInt(i.toString(), 10)]]);
                }
            }
            var index = this.nodes.indexOf(node);
            if (index !== -1) {
                this.nodes.splice(index, 1);
            }
        }
    };
    Diagram.prototype.getBlazorDragEventArgs = function (args) {
        args = {
            // eslint-disable-next-line max-len
            source: cloneBlazorObject(args.source), element: getObjectType(args.element) === Connector ? { connector: cloneBlazorObject(args.element) }
                : { node: cloneBlazorObject(args.element) },
            cancel: args.cancel, diagramId: this.element.id
        };
        return args;
    };
    Diagram.prototype.findChild = function (node, childTable) {
        var group;
        var newNode;
        for (var i = 0; i < node.children.length; i++) {
            group = childTable[node.children[parseInt(i.toString(), 10)]];
            if (group) {
                if (group.children) {
                    this.findChild(group, childTable);
                }
                group.id = group.id + randomId();
                childTable[group.id] = group;
                node.children[parseInt(i.toString(), 10)] = group.id;
                newNode = new Node(this, 'nodes', group, true);
                this.initObject(newNode, undefined, undefined, true);
                //this.add(group, true);
            }
        }
    };
    Diagram.prototype.getChildren = function (node, entryTable, childTable) {
        var temp;
        for (var i = 0; i < node.children.length; i++) {
            temp = (childTable[node.children[parseInt(i.toString(), 10)]]);
            if (temp) {
                if (temp.children) {
                    entryTable = this.getChildren(temp, entryTable, childTable);
                }
                entryTable[temp.id] = cloneObject(temp);
            }
        }
        return entryTable;
    };
    Diagram.prototype.addChildNodes = function (node) {
        var temp;
        for (var i = 0; i < node.children.length; i++) {
            temp = (this.nameTable[node.children[parseInt(i.toString(), 10)]]);
            if (temp) {
                if (temp.children) {
                    this.addChildNodes(temp);
                }
                this.add(temp, true);
            }
        }
    };
    Diagram.prototype.moveNode = function (node) {
        var currentLayer = this.commandHandler.getObjectLayer(node.id);
        var index = currentLayer.zIndex;
        var length = currentLayer.objects.length;
        var targetLayer;
        for (var i = 0; i < this.layers.length; i++) {
            if (index === this.layers[parseInt(i.toString(), 10)].zIndex) {
                targetLayer = this.layers[i + 1];
            }
        }
        if (length > 1) {
            // Bug 830365: Exception raised on adding group node in layers dynamically.
            // Added below code to check the group node and iterate its children in layer to find the last object in the layer.
            var num = 2;
            if (node.children && node.children.length > 0) {
                while (node.children.indexOf(currentLayer.objects[length - num]) > -1) {
                    num++;
                }
            }
            this.commandHandler.moveSvgNode(node.id, currentLayer.objects[length - num]);
            this.commandHandler.moveSvgNode(currentLayer.objects[length - num], node.id);
        }
        else {
            if (targetLayer) {
                var targetObject = this.commandHandler.getLayer(this.layerZIndexTable[targetLayer.zIndex]).objects[0];
                if (targetObject) {
                    this.commandHandler.moveSvgNode(node.id, targetObject);
                    this.commandHandler.updateNativeNodeIndex(node.id, targetObject);
                }
                else {
                    this.moveObjectsUp(node, currentLayer);
                }
            }
            else {
                this.moveObjectsUp(node, currentLayer);
            }
        }
    };
    /**
     * Moves the node or connector forward within the given layer. \
     *
     * @returns { void }  Moves the node or connector forward within the given layer.\
     * @param {Node | Connector} node - The node or connector to be moved forward within the layer.
     * @param {LayerModel} currentLayer - representing the layer in which the node or connector should be moved.
     *
     */
    Diagram.prototype.moveObjectsUp = function (node, currentLayer) {
        var targetLayer;
        for (var i = this.layers.length - 1; i >= 0; i--) {
            targetLayer = this.layers[parseInt(i.toString(), 10)];
            if (currentLayer.id !== targetLayer.id) {
                // eslint-disable-next-line max-len
                var targetObject = this.commandHandler.getLayer(this.layerZIndexTable[targetLayer.zIndex]).objects[targetLayer.objects.length - 1];
                if (targetObject) {
                    this.commandHandler.moveSvgNode(node.id, targetObject);
                    this.commandHandler.moveSvgNode(targetObject, node.id);
                    break;
                }
            }
        }
    };
    /**
     * Inserts a newly added element into the database. \
     *
     * @returns { void }  Inserts a newly added element into the database.\
     * @param {Node | Connector} node - The node or connector to be inserted into the database.
     *
     */
    Diagram.prototype.insertData = function (node) {
        return this.crudOperation(node, 'create', this.getNewUpdateNodes('New'));
    };
    /**
     * Updates user-defined element properties in the existing database. \
     *
     * @returns { void }     Updates user-defined element properties in the existing database.\
     * @param {Node | Connector} node - The source value representing the element to update.
     *
     */
    Diagram.prototype.updateData = function (node) {
        return this.crudOperation(node, 'update', this.getNewUpdateNodes('Update'));
    };
    /**
     * Removes the user-deleted element from the existing database.\
     *
     * @returns { void }     Removes the user-deleted element from the existing database.\
     * @param {Node | Connector} node - The node or connector to be removed from the database.
     *
     */
    Diagram.prototype.removeData = function (node) {
        return this.crudOperation(node, 'destroy', this.getDeletedNodes());
    };
    Diagram.prototype.crudOperation = function (node, crud, getNodesCollection) {
        if (node) {
            var data = this.parameterMap(node, node instanceof Connector ? false : true);
            if (data) {
                // eslint-disable-next-line max-len
                var url = node instanceof Connector ? this.dataSourceSettings.connectionDataSource.crudAction["" + crud] : this.dataSourceSettings.crudAction["" + crud];
                this.raiseAjaxPost(JSON.stringify(data), url);
            }
            return data;
        }
        else {
            var newObjects = getNodesCollection;
            // eslint-disable-next-line max-len
            this.processCrudCollection(newObjects, this.dataSourceSettings.crudAction["" + crud], this.dataSourceSettings.connectionDataSource.crudAction["" + crud]);
            return newObjects;
        }
    };
    Diagram.prototype.processCrudCollection = function (newObjects, nodeCrudAction, connectorCrudAction) {
        if (newObjects.nodes) {
            var data = [];
            var i = void 0;
            for (i = 0; i < newObjects.nodes.length; i++) {
                data.push(this.parameterMap(newObjects.nodes[parseInt(i.toString(), 10)], true));
            }
            if (data && data.length > 0) {
                this.raiseAjaxPost(JSON.stringify(data), nodeCrudAction);
            }
        }
        if (newObjects.connectors) {
            var data = [];
            var i = void 0;
            for (i = 0; i < newObjects.connectors.length; i++) {
                data.push(this.parameterMap(newObjects.connectors[parseInt(i.toString(), 10)], false));
            }
            if (data && data.length > 0) {
                this.raiseAjaxPost(JSON.stringify(data), connectorCrudAction);
            }
        }
    };
    Diagram.prototype.parameterMap = function (object, isNode) {
        var mappingObj = {};
        var i;
        var fields = isNode ? this.dataSourceSettings : this.dataSourceSettings.connectionDataSource;
        if (fields.id) {
            mappingObj[fields.id] = object.id;
        }
        if (fields.sourcePointX && fields.sourcePointY) {
            mappingObj[fields.sourcePointX] = object.sourcePoint.x;
            mappingObj[fields.sourcePointY] = object.sourcePoint.y;
        }
        if (fields.targetPointX && fields.targetPointY) {
            mappingObj[fields.targetPointX] = object.targetPoint.x;
            mappingObj[fields.targetPointY] = object.targetPoint.y;
        }
        if (fields.sourceID) {
            mappingObj[fields.sourceID] = object.sourceID;
        }
        if (fields.targetID) {
            mappingObj[fields.targetID] = object.targetID;
        }
        if (fields.crudAction && fields.crudAction.customFields && fields.crudAction.customFields.length > 0) {
            for (i = 0; i < fields.crudAction.customFields.length; i++) {
                mappingObj[fields.crudAction.customFields[parseInt(i.toString(), 10)]]
                    = object[fields.crudAction.customFields[parseInt(i.toString(), 10)]];
            }
        }
        return mappingObj;
    };
    Diagram.prototype.getNewUpdateNodes = function (status) {
        var nodes = [];
        var connectors = [];
        // eslint-disable-next-line guard-for-in
        for (var name_1 in this.nameTable) {
            var node = this.nameTable["" + name_1];
            if (node.status === status) {
                if (node && node instanceof Connector) {
                    node.status = 'None';
                    connectors.push(node);
                }
                else {
                    node.status = 'None';
                    nodes.push(node);
                }
            }
        }
        return { nodes: nodes, connectors: connectors };
    };
    Diagram.prototype.getDeletedNodes = function () {
        var nodes = [];
        var connectors = [];
        var i;
        for (i = 0; i < this.crudDeleteNodes.length; i++) {
            var node = this.crudDeleteNodes[parseInt(i.toString(), 10)];
            if (node && node.segments) {
                connectors.push(node);
            }
            else if (node) {
                nodes.push(node);
            }
        }
        this.crudDeleteNodes = [];
        return { nodes: nodes, connectors: connectors };
    };
    Diagram.prototype.raiseAjaxPost = function (value, url) {
        var callback = new Fetch(url, 'POST', 'application/json');
        var data = JSON.stringify(JSON.parse(value));
        callback.send(data).then();
        /* eslint-disable */
        callback.onSuccess = function (data) {
        };
        /* eslint-enable */
    };
    Diagram.prototype.getHiddenItems = function (args) {
        var hiddenItems = [];
        if (this.contextMenuModule) {
            this.contextMenuModule.hiddenItems = [];
            for (var _i = 0, _a = args.items; _i < _a.length; _i++) {
                var item = _a[_i];
                this.contextMenuModule.ensureItems(item, args.event);
                if (item.items && item.items.length) {
                    for (var _b = 0, _c = item.items; _b < _c.length; _b++) {
                        var newItem = _c[_b];
                        this.contextMenuModule.ensureItems(newItem, args.event);
                    }
                }
            }
            return this.contextMenuModule.hiddenItems;
        }
        return hiddenItems;
    };
    __decorate$q([
        Property('100%')
    ], Diagram.prototype, "width", void 0);
    __decorate$q([
        Property(false)
    ], Diagram.prototype, "enableConnectorSplit", void 0);
    __decorate$q([
        Property('SVG')
    ], Diagram.prototype, "mode", void 0);
    __decorate$q([
        Property('100%')
    ], Diagram.prototype, "height", void 0);
    __decorate$q([
        Property('Circle')
    ], Diagram.prototype, "segmentThumbShape", void 0);
    __decorate$q([
        Property(10)
    ], Diagram.prototype, "segmentThumbSize", void 0);
    __decorate$q([
        Complex({}, ContextMenuSettings)
    ], Diagram.prototype, "contextMenuSettings", void 0);
    __decorate$q([
        Property(DiagramConstraints.Default)
    ], Diagram.prototype, "constraints", void 0);
    __decorate$q([
        Property(DiagramTools.Default)
    ], Diagram.prototype, "tool", void 0);
    __decorate$q([
        Property('Top')
    ], Diagram.prototype, "bridgeDirection", void 0);
    __decorate$q([
        Property('transparent')
    ], Diagram.prototype, "backgroundColor", void 0);
    __decorate$q([
        Complex({}, SnapSettings)
    ], Diagram.prototype, "snapSettings", void 0);
    __decorate$q([
        Complex({}, RulerSettings)
    ], Diagram.prototype, "rulerSettings", void 0);
    __decorate$q([
        Complex({}, PageSettings)
    ], Diagram.prototype, "pageSettings", void 0);
    __decorate$q([
        Complex({}, SerializationSettings)
    ], Diagram.prototype, "serializationSettings", void 0);
    __decorate$q([
        Collection([], Node)
    ], Diagram.prototype, "nodes", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "drawingObject", void 0);
    __decorate$q([
        Collection([], Connector)
    ], Diagram.prototype, "connectors", void 0);
    __decorate$q([
        Property([])
    ], Diagram.prototype, "basicElements", void 0);
    __decorate$q([
        Complex({}, DiagramTooltip)
    ], Diagram.prototype, "tooltip", void 0);
    __decorate$q([
        Complex({}, DataSource)
    ], Diagram.prototype, "dataSourceSettings", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "addInfo", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "historyManager", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "nodeTemplate", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "annotationTemplate", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "userHandleTemplate", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "fixedUserHandleTemplate", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "getNodeDefaults", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "nodeDefaults", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "getConnectorDefaults", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "connectorDefaults", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "setNodeTemplate", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "getDescription", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "getCustomProperty", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "getCustomTool", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "getCustomCursor", void 0);
    __decorate$q([
        Collection([], CustomCursorAction)
    ], Diagram.prototype, "customCursor", void 0);
    __decorate$q([
        Property()
    ], Diagram.prototype, "updateSelection", void 0);
    __decorate$q([
        Complex({}, DiagramSettings)
    ], Diagram.prototype, "diagramSettings", void 0);
    __decorate$q([
        Complex({}, Selector)
    ], Diagram.prototype, "selectedItems", void 0);
    __decorate$q([
        Complex({}, ScrollSettings)
    ], Diagram.prototype, "scrollSettings", void 0);
    __decorate$q([
        Complex({}, Layout)
    ], Diagram.prototype, "layout", void 0);
    __decorate$q([
        Complex({}, CommandManager)
    ], Diagram.prototype, "commandManager", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "dataLoaded", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "dragEnter", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "dragLeave", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "dragOver", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "click", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "historyChange", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "historyStateChange", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "doubleClick", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "textEdit", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "scrollChange", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "mouseWheel", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "selectionChange", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "sizeChange", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "connectionChange", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "sourcePointChange", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "targetPointChange", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "propertyChange", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "positionChange", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "keyUp", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "keyDown", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "animationComplete", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "rotateChange", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "collectionChange", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "fixedUserHandleClick", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "onUserHandleMouseDown", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "onUserHandleMouseUp", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "onUserHandleMouseEnter", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "onUserHandleMouseLeave", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "onFixedUserHandleMouseDown", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "onFixedUserHandleMouseUp", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "onFixedUserHandleMouseEnter", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "onFixedUserHandleMouseLeave", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "segmentCollectionChange", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "onImageLoad", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "expandStateChange", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "load", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "created", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "mouseEnter", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "mouseLeave", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "mouseOver", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "elementDraw", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "contextMenuOpen", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "contextMenuBeforeItemRender", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "contextMenuClick", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "commandExecute", void 0);
    __decorate$q([
        Collection([], Layer)
    ], Diagram.prototype, "layers", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "drop", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "segmentChange", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "loaded", void 0);
    __decorate$q([
        Event()
    ], Diagram.prototype, "layoutUpdated", void 0);
    return Diagram;
}(Component));

/* eslint-disable jsdoc/require-param */
var storeFormat;
/**
 * Print and Export Settings
 */
var PrintAndExport = /** @class */ (function () {
    function PrintAndExport(diagram) {
        var _this = this;
        this.printWindow = undefined;
        //833683 - Method for closing the newly opened print window.
        this.closePrintWindow = function () {
            if (_this.printWindow && !_this.printWindow.closed) {
                _this.printWindow.close();
            }
        };
        this.diagram = diagram;
    }
    /**
     * To Export the diagram
     *
     * @private
     */
    PrintAndExport.prototype.exportDiagram = function (options) {
        var fileType;
        var customBounds;
        var content;
        var data = 'data';
        //let mode: string;
        var buffers = [];
        var margin = options.margin || {};
        var region = options && options.region ? options.region : 'Content';
        // isBlazor code removed
        var mode = options && options.mode ? options.mode : 'Download';
        var bounds = this.getDiagramBounds(region, options);
        if (options.bounds) {
            customBounds = true;
            bounds.x = options.bounds.x ? options.bounds.x : bounds.x;
            bounds.y = options.bounds.y ? options.bounds.y : bounds.y;
            bounds.width = options.bounds.width || bounds.width;
            bounds.height = options.bounds.height || bounds.height;
        }
        margin = {
            top: margin.top !== undefined ? margin.top : 25,
            bottom: margin.bottom !== undefined ? margin.bottom : 25,
            right: margin.right !== undefined ? margin.right : 25,
            left: margin.left !== undefined ? margin.left : 25
        };
        var nodes = this.diagram.nodes;
        if (region !== 'PageSettings') {
            bounds.x -= margin.left;
            bounds.y -= margin.top;
            bounds.width += margin.left + margin.right;
            bounds.height += margin.top + margin.bottom;
        }
        var fileName = options.fileName || 'diagram';
        if (options.format !== 'SVG') {
            data = this.setCanvas(options, bounds, margin, mode, customBounds, region, fileName);
            if (data !== null) {
                return data;
            }
        }
        else {
            fileType = options.format;
            options.bounds = bounds;
            options.margin = margin;
            var svg = content = this.diagramAsSvg(options, margin);
            if (mode === 'Data') {
                // isBlazor code removed
                return content;
            }
            var buffer = new XMLSerializer().serializeToString(svg);
            buffers.push(buffer);
        }
        if (mode === 'Download' && data !== null) {
            // Ensure this for Safari
            // if (Browser.info.name === 'msie' && Number(Browser.info.version) < 10 || Browser.info.name === 'webkit') {
            //     let info: string = Browser.info.name === 'webkit' ? 'Safari' : 'IE-9';
            //     alert('Downloading option is not supported in ' + info + ', Please use the returned data');
            //     return content;
            // } else {
            for (var b = 0; b < buffers.length; b++) {
                var blob = new Blob([buffers[parseInt(b.toString(), 10)]], { type: 'application/octet-stream' });
                if (Browser.info.name === 'msie') {
                    window.navigator.msSaveOrOpenBlob(blob, fileName + '.' + fileType);
                }
                else {
                    var pom = createHtmlElement('a', { 'download': fileName + '.' + fileType });
                    var url = URL.createObjectURL(blob);
                    pom.href = url;
                    var e = document.createEvent('MouseEvents');
                    e.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                    pom.dispatchEvent(e);
                }
            }
        }
        return null;
    };
    PrintAndExport.prototype.setCanvas = function (options, bounds, margin, mode, customBounds, region, fileName) {
        var content;
        options.bounds = bounds;
        options.region = region;
        var scaleX = 'scaleX';
        var scaleY = 'scaleY';
        var scaleOffsetX = 'scaleOffsetX';
        var scaleOffsetY = 'scaleOffsetY';
        this.setScaleValueforCanvas(options, bounds);
        var canvas = this.diagramAsCanvas({
            bounds: bounds, margin: margin, region: region, scaleX: options["" + scaleX],
            scaleY: options["" + scaleY], scaleOffsetX: options["" + scaleOffsetX], scaleOffsetY: options["" + scaleOffsetY]
        }, customBounds);
        var image;
        if (options.format === 'JPG') {
            image = content = storeFormat = canvas.toDataURL('image/jpeg');
        }
        else if (options.format === 'BMP') {
            image = content = storeFormat = canvas.toDataURL('image/bmp');
        }
        else {
            image = content = storeFormat = canvas.toDataURL();
        }
        if (mode === 'Data') {
            return content;
        }
        this.canvasMultiplePage(options, canvas, margin, image, fileName);
        return null;
    };
    PrintAndExport.prototype.canvasMultiplePage = function (options, canvas, margin, image, fileName) {
        var _this = this;
        var images = [];
        var imageData = image.substring(image.indexOf(':') + 1, image.indexOf(';'));
        var imageFormat = imageData.substring(imageData.indexOf('/') + 1);
        if (imageFormat === 'jpeg') {
            imageFormat = undefined;
        }
        else {
            imageFormat = imageFormat.toUpperCase();
        }
        var fileType = imageFormat || 'JPG';
        if (options.multiplePage) {
            options.pageHeight = options.pageHeight ? options.pageHeight : this.diagram.pageSettings.height;
            options.pageWidth = options.pageWidth ? options.pageWidth : this.diagram.pageSettings.width;
            options.pageHeight = options.pageHeight ? options.pageHeight : canvas.width;
            options.pageWidth = options.pageWidth ? options.pageWidth : canvas.height;
            margin = options.margin || {};
            if (options.pageOrientation) {
                if ((options.pageOrientation === 'Landscape' && options.pageHeight > options.pageWidth) ||
                    options.pageOrientation === 'Portrait' && options.pageWidth > options.pageHeight) {
                    var temp = options.pageWidth;
                    options.pageWidth = options.pageHeight;
                    options.pageHeight = temp;
                }
            }
            options.margin = {
                top: !isNaN(margin.top) ? margin.top : 0,
                bottom: !isNaN(margin.bottom) ? margin.bottom : 0,
                left: !isNaN(margin.left) ? margin.left : 0,
                right: !isNaN(margin.right) ? margin.right : 0
            };
            var attr = {
                'id': this.diagram.element.id + '_printImage',
                'src': image
            };
            var img_1 = createHtmlElement('img', attr);
            img_1.onload = function () {
                images = _this.getMultipleImage(img_1, options, true);
                _this.exportImage(images, fileName, fileType, image);
            };
        }
        else {
            images = [image];
            this.exportImage(images, fileName, fileType, image);
        }
    };
    PrintAndExport.prototype.exportImage = function (images, fileName, fileType, image) {
        var buffers = [];
        var length = (!(images instanceof HTMLElement)) ? images.length : 0;
        for (var g = 0; g < length; g++) {
            image = images[parseInt(g.toString(), 10)];
            image = image.replace(/^data:[a-z]*;,/, '');
            var image1 = image.split(',');
            var byteString = atob(image1[1]);
            var buffer = new ArrayBuffer(byteString.length);
            var intArray = new Uint8Array(buffer);
            for (var i = 0; i < byteString.length; i++) {
                intArray[parseInt(i.toString(), 10)] = byteString.charCodeAt(i);
            }
            buffers.push(buffer);
        }
        var _loop_1 = function (j) {
            var b = new Blob([buffers[parseInt(j.toString(), 10)]], { type: 'application/octet-stream' });
            if (Browser.info.name === 'msie') {
                window.navigator.msSaveOrOpenBlob(b, fileName + '.' + fileType);
            }
            else {
                var htmlElement_1 = createHtmlElement('a', { 'download': fileName + '.' + fileType });
                var urlLink = URL.createObjectURL(b);
                htmlElement_1.href = urlLink;
                var mouseEvent_1 = document.createEvent('MouseEvents');
                mouseEvent_1.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                setTimeout(function () {
                    htmlElement_1.dispatchEvent(mouseEvent_1);
                }, ((j + 1) * 5));
            }
        };
        // Ensure this for safari
        // if (Browser.info.name === 'msie' && Number(Browser.info.version) < 10 || Browser.info.name === 'webkit') {
        //     let browserInfo: string = Browser.info.name === 'webkit' ? 'Safari' : 'IE-9';
        //     alert('Downloading option is not supported in ' + browserInfo + ', Please use the returned data');
        //     return content;
        // } else {
        for (var j = 0; j < buffers.length; j++) {
            _loop_1(j);
        }
    };
    /**   @private  */
    PrintAndExport.prototype.getObjectsBound = function (options) {
        var nodes = this.diagram.nodes;
        var nodebounds;
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
            var node = nodes_1[_i];
            if (node.visible) {
                if (((options.format !== 'SVG' && !(node instanceof DiagramNativeElement) && !(node instanceof DiagramHtmlElement))
                    || (options.format === 'SVG' && !(node instanceof DiagramHtmlElement)))) {
                    if (!nodebounds) {
                        nodebounds = node.wrapper.outerBounds;
                    }
                    else {
                        nodebounds = nodebounds.uniteRect(node.wrapper.outerBounds);
                    }
                }
            }
        }
        var connectors = this.diagram.connectors;
        for (var _a = 0, connectors_1 = connectors; _a < connectors_1.length; _a++) {
            var connector = connectors_1[_a];
            if (connector.visible) {
                if (!nodebounds) {
                    nodebounds = connector.wrapper.outerBounds;
                }
                else {
                    nodebounds = nodebounds.uniteRect(connector.wrapper.outerBounds);
                }
            }
        }
        return nodebounds || new Rect(0, 0, 0, 0);
    };
    /**   @private  */
    PrintAndExport.prototype.getDiagramBounds = function (mode, options) {
        var rect = this.getObjectsBound(options);
        var left = rect.left;
        var top = rect.top;
        var right = rect.right - rect.left;
        var bottom = rect.bottom - rect.top;
        if (mode !== 'Content') {
            if (this.diagram.pageSettings && this.diagram.pageSettings.multiplePage) {
                left = rect.left;
                top = rect.top;
                if (this.diagram.pageSettings.width) {
                    left = Math.floor(left / this.diagram.pageSettings.width) * this.diagram.pageSettings.width;
                    right = Math.ceil(rect.right / this.diagram.pageSettings.width) * this.diagram.pageSettings.width - left;
                }
                if (this.diagram.pageSettings.height) {
                    top = Math.floor(top / this.diagram.pageSettings.height) * this.diagram.pageSettings.height;
                    bottom = Math.ceil(rect.bottom / this.diagram.pageSettings.height) * this.diagram.pageSettings.height - top;
                }
                if ((rect.width === 0) && this.diagram.pageSettings.width !== null) {
                    right = this.diagram.pageSettings.width;
                }
                if ((rect.height === 0) && this.diagram.pageSettings.height !== null) {
                    bottom = this.diagram.pageSettings.height;
                }
            }
            else {
                if (this.diagram.pageSettings.width) {
                    left = 0;
                    right = this.diagram.pageSettings.width;
                }
                if (this.diagram.pageSettings.height) {
                    top = 0;
                    bottom = this.diagram.pageSettings.height;
                }
            }
        }
        //884801-After zooming and exporting the HTML content, the scroll Padding value is not considered
        if (this.diagram.scrollSettings.padding) {
            var scrollpadding = this.diagram.scrollSettings.padding;
            left -= scrollpadding.left;
            top -= scrollpadding.top;
            right += (scrollpadding.left + scrollpadding.right);
            bottom += (scrollpadding.top + scrollpadding.bottom);
        }
        var svgBounds = new Rect();
        svgBounds.x = left;
        svgBounds.y = top;
        svgBounds.width = right;
        svgBounds.height = bottom;
        return svgBounds;
    };
    PrintAndExport.prototype.setScaleValueforCanvas = function (options, bounds) {
        var scaleX = 'scaleX';
        var scaleY = 'scaleY';
        var scaleOffsetX = 'scaleOffsetX';
        var scaleOffsetY = 'scaleOffsetY';
        options["" + scaleX] = 1;
        options["" + scaleY] = 1;
        options["" + scaleOffsetX] = 0;
        options["" + scaleOffsetY] = 0;
        options.pageHeight = options.pageHeight || this.diagram.pageSettings.height;
        options.pageWidth = options.pageWidth || this.diagram.pageSettings.width;
        var pageOrientation = options.pageOrientation || this.diagram.pageSettings.orientation;
        if (!pageOrientation) {
            pageOrientation = 'Portrait';
        }
        if (pageOrientation === 'Portrait') {
            if (options.pageWidth > options.pageHeight) {
                var temp = options.pageHeight;
                options.pageHeight = options.pageWidth;
                options.pageWidth = temp;
            }
        }
        else {
            if (options.pageHeight > options.pageWidth) {
                var temp = options.pageWidth;
                options.pageWidth = options.pageHeight;
                options.pageHeight = temp;
            }
        }
        if (options.pageWidth && options.pageHeight && !options.multiplePage) {
            options.stretch = 'Meet';
        }
        var height = options.pageHeight || bounds.height;
        var width = options.pageWidth || bounds.width;
        if (options.stretch === 'Stretch' || options.stretch === 'Meet' || options.stretch === 'Slice') {
            options["" + scaleX] = width / bounds.width;
            options["" + scaleY] = height / bounds.height;
            if (options.stretch === 'Meet') {
                options["" + scaleX] = options["" + scaleY] = Math.min(options["" + scaleX], options["" + scaleY]);
                options["" + scaleOffsetY] = (options.pageHeight - bounds.height * options["" + scaleX]) / 2;
                options["" + scaleOffsetX] = (options.pageWidth - bounds.width * options["" + scaleX]) / 2;
            }
            else if (options.stretch === 'Slice') {
                options["" + scaleX] = options["" + scaleY] = Math.max(options["" + scaleX], options["" + scaleY]);
            }
            bounds.width = width;
            bounds.height = height;
        }
        bounds.x *= options["" + scaleX];
        bounds.y *= options["" + scaleY];
    };
    PrintAndExport.prototype.diagramAsSvg = function (options, margin) {
        var svg = this.diagram.createSvg(this.diagram.element.id + '_diagram_svg', options.bounds.width, options.bounds.height);
        document.body.appendChild(svg);
        var g = createSvgElement('g', { 'id': this.diagram.element.id + '_pageBackground' });
        var region = options && options.region ? options.region : 'Content';
        var bounds = this.getDiagramBounds(region, options);
        var left = bounds.x;
        var top = bounds.y;
        var width = bounds.width;
        var height = bounds.height;
        svg.appendChild(g);
        var attr = {
            'x': String(left),
            'y': String(top), 'width': String(width), 'height': String(height)
        };
        setAttributeSvg(g, attr);
        this.setTransform(g, options.bounds, margin);
        var gradient = document.getElementById(this.diagram.element.id + 'gradient_pattern');
        if (gradient) {
            // 914031: Export function breaks gradient background of nodes in the diagram
            svg.appendChild(gradient.cloneNode(true));
        }
        attr = {
            'x': String(left),
            'y': String(top), 'width': String(width + margin.left + margin.right), 'height': String(height + margin.top + margin.bottom)
        };
        var backimage = document.getElementById(this.diagram.element.id + '_backgroundImageLayer').cloneNode(true);
        setAttributeSvg(backimage, attr);
        svg.appendChild(backimage);
        this.setTransform(backimage, bounds, margin);
        var backRect = document.getElementById(this.diagram.element.id + '_backgroundLayerrect').cloneNode(true);
        setAttributeSvg(backRect, attr);
        svg.appendChild(backRect);
        this.setTransform(backRect, bounds, margin);
        if (this.diagram.mode === 'SVG') {
            var element = void 0;
            var i = void 0;
            var diagramLayerSVG = getDiagramLayerSvg(this.diagram.element.id);
            svg.appendChild(diagramLayerSVG.getElementById(this.diagram.diagramLayer.id).cloneNode(true));
            for (i = 0; i < svg.childNodes.length; i++) {
                element = svg.childNodes[parseInt(i.toString(), 10)];
                if (element.id === this.diagram.element.id + '_diagramLayer') {
                    this.setTransform(element, bounds, margin);
                }
            }
        }
        else {
            g = createSvgElement('g', { 'id': this.diagram.element.id + '_diagramLayer' });
            svg.appendChild(g);
            this.setTransform(g, options.bounds, margin);
            //renderLabels
            var renderer = new DiagramRenderer('', null, true);
            var htmlLayer = getHTMLLayer(this.diagram.element.id);
            this.diagram.renderDiagramElements(svg, renderer, htmlLayer, false);
        }
        document.body.removeChild(svg);
        return svg;
    };
    PrintAndExport.prototype.setTransform = function (element, bounds, margin) {
        element.setAttribute('transform', 'translate(' + (-bounds.x + margin.left) + ', ' +
            (-bounds.y + margin.top) + ')');
    };
    PrintAndExport.prototype.diagramAsCanvas = function (options, customBounds) {
        var scaleX = 'scaleX';
        var scaleY = 'scaleY';
        var scaleOffsetX = 'scaleOffsetX';
        var scaleOffsetY = 'scaleOffsetY';
        var region = options.bounds;
        var margin = options.margin;
        var mode = options.region;
        var pageBounds = this.getDiagramBounds(mode, options);
        var bgColor = this.diagram.pageSettings.background.color;
        var canvas = CanvasRenderer.createCanvas(this.diagram.element.id + '_diagram', options.bounds.width, options.bounds.height);
        //canvas.setAttribute('style', 'position:absolute;top:135px;left:160px;');
        var context = canvas.getContext('2d');
        context.translate(-region.x, -region.y);
        context.save();
        context.fillStyle = (this.diagram.pageSettings.background.color === 'transparent') ? 'white' :
            this.diagram.pageSettings.background.color;
        region = mode === 'Content' ? pageBounds : region;
        context.fillRect(region.x, region.y, region.width, region.height);
        var bgImg = this.diagram.pageSettings.background;
        if (bgImg && bgImg.source) {
            pageBounds = this.getDiagramBounds(mode, options);
            var image = new Image();
            image.src = bgImg.source;
            var proportionX = pageBounds.width / image.width;
            var proportionY = pageBounds.height / image.height;
            var x = pageBounds.x;
            var y = pageBounds.y;
            var width = pageBounds.width;
            var height = pageBounds.height;
            var exportable = this.isImageExportable(bgImg);
            if (bgImg.scale !== 'None' && bgImg.align !== 'None') {
                var proportion = bgImg.scale === 'Meet' ? Math.min(proportionX, proportionY) : Math.max(proportionX, proportionY);
                width = proportion * image.width;
                height = proportion * image.height;
                if (bgImg.align.indexOf('xmid') > -1) {
                    x += (pageBounds.width - width) / 2;
                }
                else if (bgImg.align.indexOf('xmax') > -1) {
                    x = x + pageBounds.width - width;
                }
                if (bgImg.align.indexOf('ymid') > -1) {
                    y += (pageBounds.height - height) / 2;
                }
                else if (bgImg.align.indexOf('ymax') > -1) {
                    y = y + pageBounds.height - height;
                }
                if (this.diagram.pageSettings.background.color === 'none' || this.diagram.pageSettings.background.color === 'transparent') {
                    context.fillStyle = 'white';
                    context.fillRect(pageBounds.x * options["" + scaleX], pageBounds.y * options["" + scaleY], pageBounds.width * options["" + scaleX], pageBounds.height * options["" + scaleY]);
                }
                if (exportable) {
                    context.drawImage(image, x, y, proportion * image.width, proportion * image.height);
                }
            }
            else if (exportable) {
                context.drawImage(image, x, y, pageBounds.width, pageBounds.height);
            }
        }
        else {
            context.fillStyle = bgColor === 'transparent' ? 'white' : bgColor;
            context.fillRect((pageBounds.x * options["" + scaleX]) - margin.left, (pageBounds.y * options["" + scaleY]) - margin.top, (pageBounds.width * options["" + scaleX]) + margin.left + margin.right, (options["" + scaleY] * pageBounds.height) + margin.top + margin.bottom);
        }
        var brColor = this.diagram.pageSettings.background.color;
        var brWidth = this.diagram.pageSettings.width;
        if (brWidth) {
            context.strokeStyle = brColor === 'none' ? 'transparent' : brColor;
            context.lineWidth = brWidth;
            context.strokeRect(pageBounds.x * options["" + scaleX], pageBounds.y * options["" + scaleY], pageBounds.width * options["" + scaleX], pageBounds.height * options["" + scaleY]);
        }
        context.restore();
        var htmlLayer = getHTMLLayer(this.diagram.element.id);
        var renderer = new DiagramRenderer('', null, false);
        this.updateObjectValue(options["" + scaleX], options["" + scaleOffsetX], options["" + scaleOffsetY], true);
        this.diagram.renderDiagramElements(canvas, renderer, htmlLayer, false, true);
        this.updateObjectValue(options["" + scaleX], options["" + scaleOffsetX], options["" + scaleOffsetY], false);
        return canvas;
    };
    PrintAndExport.prototype.updateWrapper = function (canvas, value, scaleOffsetX, scaleOffsetY, isExport) {
        if (canvas && canvas.length > 0) {
            for (var j = 0; j < canvas.length; j++) {
                if (canvas[parseInt(j.toString(), 10)].children) {
                    this.updateWrapper(canvas[parseInt(j.toString(), 10)].children, value, scaleOffsetX, scaleOffsetY, isExport);
                }
                canvas[parseInt(j.toString(), 10)].exportScaleValue.x = value;
                canvas[parseInt(j.toString(), 10)].exportScaleValue.y = value;
                canvas[parseInt(j.toString(), 10)].exportScaleOffset.x = scaleOffsetX;
                canvas[parseInt(j.toString(), 10)].exportScaleOffset.y = scaleOffsetY;
                canvas[parseInt(j.toString(), 10)].isExport = isExport;
            }
        }
    };
    PrintAndExport.prototype.scaleGradientValue = function (node, scaleValue, isExport) {
        if (node.style.gradient.stops.length > 0) {
            var gradients = node.style.gradient;
            if (node.style.gradient instanceof LinearGradient) {
                gradients.x1 = isExport ? gradients.x1 * scaleValue : gradients.x1 / scaleValue;
                gradients.y1 = isExport ? gradients.y1 * scaleValue : gradients.y1 / scaleValue;
                gradients.x2 = isExport ? gradients.x2 * scaleValue : gradients.x2 / scaleValue;
                gradients.y2 = isExport ? gradients.y2 * scaleValue : gradients.y2 / scaleValue;
            }
            else {
                gradients.fx = isExport ? gradients.fx * scaleValue : gradients.fx / scaleValue;
                gradients.fy = isExport ? gradients.fy * scaleValue : gradients.fy / scaleValue;
                gradients.cx = isExport ? gradients.cx * scaleValue : gradients.cx / scaleValue;
                gradients.cy = isExport ? gradients.cy * scaleValue : gradients.cy / scaleValue;
                gradients.r = isExport ? gradients.r * scaleValue : gradients.r / scaleValue;
            }
        }
    };
    PrintAndExport.prototype.updateObjectValue = function (value, scaleOffsetX, scaleOffsetY, isExport) {
        var wrapper;
        for (var i = 0; i < this.diagram.nodes.length; i++) {
            wrapper = this.diagram.nodes[parseInt(i.toString(), 10)].wrapper;
            this.scaleGradientValue(this.diagram.nodes[parseInt(i.toString(), 10)], value, isExport);
            this.updateWrapper(wrapper.children, value, scaleOffsetX, scaleOffsetY, isExport);
            wrapper.exportScaleValue.x = value;
            wrapper.exportScaleValue.y = value;
            wrapper.exportScaleOffset.x = scaleOffsetX;
            wrapper.exportScaleOffset.y = scaleOffsetY;
            wrapper.isExport = isExport;
        }
        for (var j = 0; j < this.diagram.connectors.length; j++) {
            wrapper = this.diagram.connectors[parseInt(j.toString(), 10)].wrapper;
            for (var k = 0; k < wrapper.children.length; k++) {
                wrapper.children[parseInt(k.toString(), 10)].isExport = isExport;
                if (isExport) {
                    wrapper.children[parseInt(k.toString(), 10)].exportScaleValue.x = value;
                    wrapper.children[parseInt(k.toString(), 10)].exportScaleValue.y = value;
                    wrapper.children[parseInt(k.toString(), 10)].exportScaleOffset.x = scaleOffsetX;
                    wrapper.children[parseInt(k.toString(), 10)].exportScaleOffset.y = scaleOffsetY;
                }
            }
        }
    };
    PrintAndExport.prototype.isImageExportable = function (backgroundImage) {
        var state = true;
        var content;
        var canvas;
        if (backgroundImage.source) {
            try {
                canvas = CanvasRenderer.createCanvas(this.diagram.element.id + 'temp_canvas', 100, 100);
                var ctx = canvas.getContext('2d');
                ctx.save();
                var image = new Image();
                image.src = backgroundImage.source;
                ctx.drawImage(image, 0, 0, 100, 100);
                ctx.restore();
                content = canvas.toDataURL();
            }
            catch (e) {
                state = false;
            }
        }
        return state;
    };
    PrintAndExport.prototype.getPrintCanvasStyle = function (img, options) {
        var width = 0;
        var height = 0;
        var size = new Size();
        width = img.width;
        height = img.height;
        if (options.pageHeight || options.pageWidth) {
            height = options.pageHeight ? options.pageHeight : height;
            width = options.pageWidth ? options.pageWidth : width;
        }
        if (options.pageOrientation) {
            if ((options.pageOrientation === 'Landscape' && height > width) || options.pageOrientation === 'Portrait' && width > height) {
                var temp = width;
                width = height;
                height = temp;
            }
        }
        size.height = height;
        size.width = width;
        return size;
    };
    PrintAndExport.prototype.getMultipleImage = function (img, options, isExport) {
        var imageArray = [];
        var div = createHtmlElement('div', {});
        var pageSize = this.getPrintCanvasStyle(img, options);
        //let pageWidth: number;
        //let pageHeight: number;
        var margin = options.margin;
        var mLeft = margin.left;
        var mTop = margin.top;
        var mRight = margin.right;
        var mBottom = margin.bottom;
        var x = 0;
        var y = 0;
        var pageWidth = pageSize.width + x;
        var pageHeight = pageSize.height + y;
        var drawnX = 0;
        var drawnY = 0;
        if (options && options.multiplePage) {
            div.style.height = 'auto';
            div.style.width = 'auto';
            var imgHeight = img.height;
            var imgWidth = img.width;
            //if (img) {
            var i = 0;
            var j = 0;
            var url = void 0;
            var clipWidth = 0;
            var clipHeight = 0;
            var ctx = void 0;
            var canvas = void 0;
            do {
                do {
                    clipWidth = pageSize.width;
                    clipHeight = pageSize.height;
                    if ((drawnX + pageSize.width) >= imgWidth) {
                        clipWidth = (imgWidth - drawnX);
                    }
                    if ((drawnY + pageSize.height) >= imgHeight) {
                        clipHeight = (imgHeight - drawnY);
                    }
                    canvas = CanvasRenderer.createCanvas(this.diagram.element.id + '_multiplePrint', pageSize.width, pageSize.height);
                    ctx = canvas.getContext('2d');
                    ctx.drawImage(img, x + drawnX + mLeft, y + drawnY + mTop, clipWidth - mRight - mLeft, clipHeight - mBottom - mTop, 0 + mLeft, 0 + mTop, clipWidth - mRight - mLeft, clipHeight - mBottom - mTop);
                    if ((drawnX + pageSize.width) >= imgWidth) {
                        drawnX -= (drawnX - imgWidth);
                    }
                    url = canvas.toDataURL();
                    ctx.restore();
                    drawnX += pageWidth;
                    if (isExport) {
                        imageArray.push(url);
                    }
                    else {
                        this.printImage(div, url, i + '' + j, pageWidth + 'px;', pageHeight + 'px;');
                    }
                    i++;
                } while (drawnX < imgWidth);
                j++;
                i = x = drawnX = 0;
                if ((drawnY + pageSize.height) >= imgHeight) {
                    drawnY -= (drawnY - imgHeight);
                }
                drawnY += pageHeight;
            } while (drawnY < imgHeight);
            //}
        }
        else {
            var x_1 = 0;
            var y_1 = 0;
            var pageSize_1 = this.getPrintCanvasStyle(img, options);
            ///let pageWidth: number; let pageHeight: number;
            var pageWidth_1 = pageSize_1.width;
            var pageHeight_1 = pageSize_1.height;
            //let ctx: CanvasRenderingContext2D;
            //let canvas: HTMLCanvasElement;
            //let url: string;
            var canvas = CanvasRenderer.createCanvas(this.diagram.element.id + '_diagram', pageWidth_1, pageHeight_1);
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, x_1 + mLeft, y_1 + mTop, img.width - (mRight + mLeft), img.height - (mTop + mBottom), 0 + mLeft, 0 + mTop, pageWidth_1 - (mRight + mLeft), pageHeight_1 - (mTop + mBottom));
            var url = canvas.toDataURL();
            ctx.restore();
            if (isExport) {
                imageArray.push(url);
            }
            else {
                this.printImage(div, url, 0);
            }
        }
        if (isExport) {
            return imageArray;
        }
        else {
            return div;
        }
    };
    PrintAndExport.prototype.printImage = function (div, url, i, pageWidth, pageHeight) {
        var attr = { 'class': 'e-diagram-print-page', 'style': 'width:' + pageWidth + 'height:' + pageHeight };
        var img = createHtmlElement('img', attr);
        var innerDiv = createHtmlElement('div', attr);
        attr = { 'id': this.diagram.element.id + '_multiplePrint_img' + i, 'style': 'float:left', 'src': url };
        setAttributeHtml(img, attr);
        innerDiv.appendChild(img);
        div.appendChild(innerDiv);
    };
    /**
     * To print the image
     *
     * @private
     */
    PrintAndExport.prototype.print = function (options) {
        options.mode = 'Data';
        var url = this.exportDiagram(options);
        this.printImages(url, options);
    };
    PrintAndExport.prototype.printImages = function (url, options) {
        var _this = this;
        var attr = {
            'id': this.diagram.element.id + '_printImage',
            'src': url
        };
        options.margin = { top: 0, bottom: 0, right: 0, left: 0 };
        var img = createHtmlElement('img', attr);
        img.onload = function () {
            var div = _this.getMultipleImage(img, options);
            // specify window parameters
            var printWind = window.open('');
            _this.printWindow = printWind;
            if (printWind != null) {
                if ((div instanceof HTMLElement)) {
                    printWind.document.write('<html><head><style> body{margin:0px;}  @media print { .e-diagram-print-page' +
                        '{page-break-after: left; }.e-diagram-print-page:last-child {page-break-after: avoid;}}' +
                        '</style><title></title></head>');
                    //833683-Need to close print window after closing the parent window
                    window.addEventListener('beforeunload', _this.closePrintWindow);
                    printWind.addEventListener('load', function () {
                        setTimeout(function () {
                            printWind.window.print();
                            //To close new window once print window is closed
                            printWind.close();
                        }, 3000);
                    });
                    printWind.document.write('<center>' + div.innerHTML + '</center>');
                    printWind.document.close();
                }
            }
        };
    };
    PrintAndExport.prototype.getContent = function (styleSheets) {
        var snapConstraints = this.diagram.snapSettings.constraints;
        this.diagram.snapSettings.constraints = (this.diagram.snapSettings.constraints & ~SnapConstraints.ShowLines);
        this.diagram.dataBind();
        this.diagram.clearSelection();
        styleSheets = styleSheets || document.styleSheets;
        var styleSheetRef = '';
        for (var i = 0; i < styleSheets.length; i++) {
            if (styleSheets[parseInt(i.toString(), 10)].href || typeof styleSheets[parseInt(i.toString(), 10)] === 'string') {
                styleSheetRef += '<link href=\'' + (styleSheets[parseInt(i.toString(), 10)].href || styleSheets[parseInt(i.toString(), 10)]) + '\' rel=\'stylesheet\' />';
            }
        }
        var htmlData = document.getElementById(this.diagram.element.id + 'content').innerHTML;
        var marginStyle = 'margin-left:' + 0 + 'px;margin-top:' + 0 + 'px;margin-right:'
            + 0 + 'px;margin-bottom:' + 0 + 'px;';
        htmlData = styleSheetRef + '<body style="margin: 0px; padding: 0px"><div style=\'' +
            marginStyle + '\'>' + htmlData + '</div></body>';
        htmlData = htmlData.replace(/ transform: t/g, ' -webkit-transform: t');
        this.diagram.snapSettings.constraints = snapConstraints;
        this.diagram.dataBind();
        return htmlData;
    };
    /** @private */
    PrintAndExport.prototype.getDiagramContent = function (styleSheets) {
        if (this.diagram.scroller.currentZoom === 1) {
            var htmlData = this.getContent(styleSheets);
            /* tslint:disable */
            // eslint-disable-next-line quotes
            return checkBrowserInfo() ? htmlData.replace("url(" + location.protocol + '//' + location.host + location.pathname + "#diagram_pattern ", "url(#diagram_pattern)") : htmlData;
            /* tslint:enable */
        }
        else {
            var container = document.getElementById(this.diagram.element.id + 'content');
            var scrollerX = container.scrollLeft;
            var scrollerY = container.scrollTop;
            var oldZoom = this.diagram.scrollSettings.currentZoom;
            var oldHorizontalOffset = this.diagram.scroller.horizontalOffset;
            var oldVerticalOffset = this.diagram.scroller.verticalOffset;
            var oldWidth = Number(String(this.diagram.width).split('%')[0]) ?
                container.clientWidth : Number(String(this.diagram.width).split('px')[0]);
            var oldHeight = Number(String(this.diagram.height).split('%')[0]) ?
                container.clientHeight : Number(String(this.diagram.height).split('px')[0]);
            var bounds = this.getDiagramBounds('', {});
            this.diagram.scroller.zoom((1 / oldZoom));
            var scrollX_1 = 0;
            var scrollY_1 = 0;
            scrollX_1 = bounds.x;
            scrollY_1 = bounds.y;
            this.diagram.scroller.transform = {
                tx: -scrollX_1,
                ty: -scrollY_1,
                scale: this.diagram.scroller.currentZoom
            };
            this.diagram.scroller.horizontalOffset = -scrollX_1;
            this.diagram.scroller.verticalOffset = -scrollY_1;
            this.diagram.scroller.setSize();
            this.diagram.setSize(bounds.width, bounds.height);
            var htmlData = this.getContent(styleSheets);
            this.diagram.setSize(oldWidth, oldHeight);
            this.diagram.scroller.zoom(oldZoom / this.diagram.scrollSettings.currentZoom);
            this.diagram.dataBind();
            if (scrollerX || scrollerY) {
                this.diagram.setOffset(scrollerX, scrollerY);
            }
            else {
                this.diagram.scroller.transform = {
                    tx: (oldHorizontalOffset) / this.diagram.scroller.currentZoom,
                    ty: (oldVerticalOffset) / this.diagram.scroller.currentZoom,
                    scale: this.diagram.scroller.currentZoom
                };
                this.diagram.scroller.horizontalOffset = oldHorizontalOffset;
                this.diagram.scroller.verticalOffset = oldVerticalOffset;
            }
            this.diagram.renderSelector(false);
            /* tslint:disable */
            // eslint-disable-next-line quotes
            return checkBrowserInfo() ? htmlData.replace("url(" + location.protocol + '//' + location.host + location.pathname + "#diagram_pattern ", "url(#diagram_pattern)") : htmlData;
            /* tslint:enable */
        }
    };
    /** @private */
    PrintAndExport.prototype.exportImages = function (image, options) {
        var _this = this;
        var region = options && options.region ? options.region : 'Content';
        var margin = options.margin || {};
        margin = {
            top: !isNaN(margin.top) ? margin.top : 0,
            bottom: !isNaN(margin.bottom) ? margin.bottom : 0,
            left: !isNaN(margin.left) ? margin.left : 0,
            right: !isNaN(margin.right) ? margin.right : 0
        };
        var bounds = this.getDiagramBounds(region, {});
        if (options.bounds) {
            bounds.x = (!isNaN(options.bounds.x) ? options.bounds.x : bounds.x);
            bounds.y = (!isNaN(options.bounds.y) ? options.bounds.y : bounds.y);
            bounds.width = (options.bounds.width || bounds.width);
            bounds.height = (options.bounds.height || bounds.height);
        }
        var img = document.createElement('img');
        var attr = {
            'src': image
        };
        setAttributeHtml(img, attr);
        var context = this;
        img.onload = function () {
            var canvas = CanvasRenderer.createCanvas(context.diagram.element.id + 'innerImage', bounds.width + (margin.left + margin.right), bounds.height + (margin.top + margin.bottom));
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = context.diagram.pageSettings.background.color;
            ctx.fillRect(0, 0, bounds.width + (margin.left + margin.right), bounds.height + (margin.top + margin.bottom));
            ctx.drawImage(img, 0, 0, bounds.width, bounds.height, margin.left, margin.top, bounds.width, bounds.height);
            //898304 - exportImage function export images only in "png" format
            if (image && options.format === 'JPG') {
                image = canvas.toDataURL('image/jpeg');
            }
            else {
                image = canvas.toDataURL();
            }
            if (options.printOptions) {
                context.printImages(image, options);
                return;
            }
            ctx.restore();
            var fileName = options.fileName || 'diagram';
            _this.canvasMultiplePage(options, canvas, margin, image, fileName);
        };
        //898304 - exportImage function export images only in "png" format
        if (options.format === 'SVG') {
            this.exportDiagram(options);
        }
    };
    /**
     *To destroy the ruler
     *
     * @returns {void} To destroy the ruler
     */
    PrintAndExport.prototype.destroy = function () {
        /**
         * Destroys the Print and Export module
         */
        //833683 - unwire beforeunload event on destroy
        window.removeEventListener('beforeunload', this.closePrintWindow);
        this.printWindow = undefined;
    };
    /**
     * Get module name.
     */
    PrintAndExport.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'PrintandExport';
    };
    return PrintAndExport;
}());

/**
 * data source defines the basic unit of diagram
 */
var DataBinding = /** @class */ (function () {
    /**
     * Constructor for the data binding module.
     * @private
     */
    function DataBinding() {
        /**   @private  */
        this.dataTable = {};
        //constructs the data binding module
    }
    /**
     * To destroy the data binding module
     *
     * @returns {void}
     * @private
     */
    DataBinding.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    /**
     * Core method to return the component name.
     *
     * @returns {string}  Core method to return the component name.
     * @private
     */
    DataBinding.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'DataBinding';
    };
    /**
     * Initialize nodes and connectors when we have a data as JSON
     *
     * @param {DataSourceModel} data
     * @param {Diagram} diagram
     * @private
     */
    DataBinding.prototype.initData = function (data, diagram) {
        var dataSource;
        var dataProp = 'data';
        var jsonProp = 'json';
        var dataManager = data.dataManager || data.dataSource || {};
        dataSource = dataManager["" + dataProp] || dataManager["" + jsonProp] ||
            (dataManager.dataSource ? dataManager.dataSource.json : undefined);
        if (dataSource && dataSource.length === 0 && dataManager.dataSource.data) {
            dataSource = dataManager.dataSource.data;
        }
        if (dataSource && dataSource.length) {
            this.applyDataSource(data, dataSource, diagram);
            diagram.trigger('dataLoaded', { diagram: (isBlazor()) ? null : cloneBlazorObject(diagram) });
        }
    };
    /**
     * Initialize nodes and connector when we have a data as remote url
     *
     * @param {DataSourceModel} data
     * @param {Diagram} diagram
     * @private
     */
    DataBinding.prototype.initSource = function (data, diagram) {
        var _this = this;
        var dataSource = data;
        var result;
        var mapper = data;
        if (dataSource.dataManager instanceof DataManager || dataSource.dataSource instanceof DataManager) {
            var tempObj = mapper.dataManager || mapper.dataSource;
            var query = tempObj.defaultQuery || new Query();
            var dataManager = data.dataManager || data.dataSource;
            dataManager.executeQuery(query).then(function (e) {
                var prop = 'result';
                result = e["" + prop];
                if (!diagram.isDestroyed) {
                    diagram.protectPropertyChange(true);
                    _this.applyDataSource(data, result, diagram);
                    diagram.refreshDiagram();
                    diagram.protectPropertyChange(false);
                    diagram.trigger('dataLoaded', { diagram: (isBlazor()) ? null : cloneBlazorObject(diagram) });
                }
            });
        }
    };
    DataBinding.prototype.applyDataSource = function (mapper, data, diagram) {
        this.dataTable = {};
        var obj;
        var firstNode;
        var node;
        var rootNodes = [];
        var firstLevel = [];
        var item;
        var nextLevel;
        if (data !== undefined) {
            for (var r = 0; r < data.length; r++) {
                obj = data[parseInt(r.toString(), 10)];
                //832886 - Rendering layout without case sensitivity
                if (obj[mapper.parentId] === undefined || obj[mapper.parentId] === null ||
                    typeof obj[mapper.parentId] !== 'object') {
                    if (isNaN(obj[mapper.parentId]) && obj[mapper.parentId] !== undefined) {
                        if (rootNodes[obj[mapper.parentId] ? obj[mapper.parentId].toLowerCase() : obj[mapper.parentId]] !== undefined) {
                            rootNodes[obj[mapper.parentId].toLowerCase()].items.push(obj);
                        }
                        else {
                            rootNodes[obj[mapper.parentId] ? obj[mapper.parentId].toLowerCase() : obj[mapper.parentId]] = { items: [obj] };
                        }
                    }
                    else {
                        if (rootNodes[obj[mapper.parentId]] !== undefined) {
                            rootNodes[obj[mapper.parentId]].items.push(obj);
                        }
                        else {
                            rootNodes[obj[mapper.parentId]] = { items: [obj] };
                        }
                    }
                }
                else {
                    rootNodes = this.updateMultipleRootNodes(obj, rootNodes, mapper, data);
                }
                if (mapper.root && isNaN(mapper.root) && obj[mapper.id] && isNaN(obj[mapper.id])) {
                    if ((mapper.root).toLowerCase() === obj[mapper.id].toLowerCase()) {
                        firstNode = { items: [obj] };
                    }
                }
                else {
                    if (mapper.root === obj[mapper.id]) {
                        firstNode = { items: [obj] };
                    }
                }
            }
            if (firstNode) {
                firstLevel.push(firstNode);
            }
            else {
                for (var _i = 0, _a = Object.keys(rootNodes); _i < _a.length; _i++) {
                    var n = _a[_i];
                    if (!n || n === 'undefined' || n === '\'\'' || n === 'null') {
                        firstLevel.push(rootNodes["" + n]);
                    }
                }
            }
            for (var i = 0; i < firstLevel.length; i++) {
                for (var j = 0; j < firstLevel[parseInt(i.toString(), 10)].items.length; j++) {
                    item = firstLevel[parseInt(i.toString(), 10)].items[parseInt(j.toString(), 10)];
                    node = this.applyNodeTemplate(mapper, item, diagram);
                    diagram.nodes.push(node);
                    if (isNaN(item[mapper.id]) && item[mapper.id] !== undefined) {
                        this.dataTable[item[mapper.id].toLowerCase()] = node;
                    }
                    else {
                        this.dataTable[item[mapper.id]] = node;
                    }
                    if (isNaN(node.data[mapper.id]) && node.data[mapper.id] !== undefined) {
                        nextLevel = rootNodes[node.data[mapper.id].toLowerCase()];
                    }
                    else {
                        nextLevel = rootNodes[node.data[mapper.id]];
                    }
                    if (nextLevel !== undefined) {
                        this.renderChildNodes(mapper, nextLevel, node.id, rootNodes, diagram);
                    }
                }
            }
        }
        this.dataTable = null;
    };
    /**
     * updateMultipleRootNodes method is used  to update the multiple Root Nodes
     *
     * @param {Object} object
     * @param {Object[]} rootnodes
     * @param {DataSourceModel} mapper
     * @param {Object[]} data
     */
    DataBinding.prototype.updateMultipleRootNodes = function (obj, rootNodes, mapper, data) {
        var parents = obj[mapper.parentId];
        var parent;
        for (var i = 0; i < parents.length; i++) {
            if (parents[parseInt(i.toString(), 10)]) {
                if (isNaN(parents[parseInt(i.toString(), 10)])) {
                    parent = (parents[parseInt(i.toString(), 10)]).toLowerCase();
                }
                else {
                    parent = (parents[parseInt(i.toString(), 10)]);
                }
                if (rootNodes["" + parent]) {
                    rootNodes["" + parent].items.push(obj);
                }
                else {
                    rootNodes["" + parent] = { items: [obj] };
                }
            }
            else {
                parent = parents[parseInt(i.toString(), 10)];
                if (rootNodes["" + parent]) {
                    rootNodes["" + parent].items.push(obj);
                }
                else {
                    rootNodes["" + parent] = { items: [obj] };
                }
            }
        }
        return rootNodes;
    };
    /**
     *  Get the node values\
     *
     * @returns { Node }    Get the node values.\
     * @param {DataSourceModel} mapper - provide the id value.
     * @param {Object} item - provide the id value.
     * @param {Diagram} diagram - provide the id value.
     *
     * @private
     */
    DataBinding.prototype.applyNodeTemplate = function (mapper, item, diagram) {
        //const root: Object = item;
        var id = randomId();
        //const blazor: string = 'Blazor';
        var nodeModel = { id: id, data: item };
        //Task 895538: Flow-chart layout support for EJ2 diagram.
        //Added below code to set node shape and style based on the data.
        if (diagram.layout.type === 'Flowchart') {
            var shape = this.getFlowChartNodeShape(item);
            var style = { fill: item.color ? item.color : 'white',
                strokeColor: item.stroke ? item.stroke : 'black',
                strokeWidth: item.strokeWidth ? item.strokeWidth : 1
            };
            nodeModel.shape = shape;
            nodeModel.style = style;
            nodeModel.annotations = [{ content: item.name ? item.name : '' }];
        }
        // eslint-disable-next-line @typescript-eslint/ban-types
        var doBinding = getFunction(mapper.doBinding);
        if (doBinding) {
            doBinding(nodeModel, item, diagram);
        }
        var obj = new Node(diagram, 'nodes', nodeModel, true);
        updateDefaultValues(obj, nodeModel, diagram.nodeDefaults);
        if (mapper.dataMapSettings) {
            var index = void 0;
            var arrayProperty = [];
            var innerProperty = [];
            for (var i = 0; i < mapper.dataMapSettings.length; i++) {
                if (mapper.dataMapSettings[parseInt(i.toString(), 10)].property.indexOf('.') !== -1) {
                    innerProperty = this.splitString(mapper.dataMapSettings[parseInt(i.toString(), 10)].property);
                    for (var p = 0; p < innerProperty.length; p++) {
                        if (innerProperty[parseInt(p.toString(), 10)].indexOf('[') !== -1) {
                            index = innerProperty[parseInt(p.toString(), 10)].indexOf('[');
                            arrayProperty = innerProperty[parseInt(p.toString(), 10)].split('[');
                        }
                    }
                    if (index) {
                        if (innerProperty[2]) {
                            obj[arrayProperty[0]][innerProperty[0].charAt(index + 1)][innerProperty[1]][innerProperty[2]] =
                                item[mapper.dataMapSettings[parseInt(i.toString(), 10)].field];
                        }
                        else {
                            var value = item[mapper.dataMapSettings[parseInt(i.toString(), 10)].field];
                            obj[arrayProperty[0]][innerProperty[0].charAt(index + 1)][innerProperty[1]] = value;
                        }
                    }
                    else {
                        if (innerProperty[2]) {
                            obj[innerProperty[0]][innerProperty[1]][innerProperty[2]]
                                = item[mapper.dataMapSettings[parseInt(i.toString(), 10)].field];
                        }
                        else {
                            obj[innerProperty[0]][innerProperty[1]] = item[mapper.dataMapSettings[parseInt(i.toString(), 10)].field];
                        }
                    }
                }
                else {
                    var property = mapper.dataMapSettings[parseInt(i.toString(), 10)].property;
                    property = property.charAt(0).toLowerCase() + property.slice(1);
                    obj["" + property] = item[mapper.dataMapSettings[parseInt(i.toString(), 10)].field];
                }
                index = 0;
                arrayProperty = [];
                innerProperty = [];
            }
        }
        if (!this.collectionContains(obj, diagram, mapper.id, mapper.parentId)) {
            return obj;
        }
        else {
            if (item[mapper.id] && isNaN(item[mapper.id])) {
                return this.dataTable[item[mapper.id].toLowerCase()];
            }
            else {
                return this.dataTable[item[mapper.id]];
            }
        }
    };
    DataBinding.prototype.getFlowChartNodeShape = function (data) {
        if (data.shape !== '') {
            switch (data.shape) {
                case 'Rectangle':
                    return { type: 'Basic', shape: 'Rectangle' };
                case 'Decision':
                    return { type: 'Flow', shape: 'Decision' };
                case 'Hexagon':
                    return { type: 'Path', data: 'M 0 0 L 2 -2 L 11 -2 L 13 0 L 11 2 L 2 2 L 0 0' };
                case 'Ellipse':
                    return { type: 'Basic', shape: 'Ellipse' };
                case 'Terminator':
                    return { type: 'Flow', shape: 'Terminator' };
                case 'PredefinedProcess':
                    return { type: 'Flow', shape: 'PreDefinedProcess' };
                case 'Parallelogram':
                    return { type: 'Basic', shape: 'Parallelogram' };
                case 'ParallelogramAlt':
                    return { type: 'Path', data: 'M 0 0 L 12 0 L 14 2 L 2 2 L 0 0' };
                case 'Trapezoid':
                    return { type: 'Path', data: 'M 0 0 L 1 -1 L 5 -1 L 6 0 L 0 0' };
                case 'TrapezoidAlt':
                    return { type: 'Path', data: 'M 0 0 L 5 0 L 4 1 L 1 1 L 0 0' };
                case 'DataSource':
                    return { type: 'Path', data: 'M 0 1 L 0 6 C 2 7 4 7 6 6 L 6 1 C 5 0 1 0 0 1 C 1 2 5 2 6 1' };
                case 'Asymmetric':
                    return { type: 'Path', data: 'M 0 0 L 8 0 L 8 2 L 0 2 L 2 1 L 0 0' };
                case 'DoubleCircle':
                    return { type: 'Path', data: 'M 0 0 A 1 1 0 0 0 7 0 A 1 1 0 0 0 0 0 M -1 0 A 1 1 0 0 0 8 0 A 1 1 0 0 0 -1 0' };
                case 'Document':
                    return { type: 'Flow', shape: 'Document' };
                case 'PaperTap':
                    return { type: 'Flow', shape: 'PaperTap' };
                case 'DirectData':
                    return { type: 'Flow', shape: 'DirectData' };
                case 'SequentialData':
                    return { type: 'Flow', shape: 'SequentialData' };
                case 'Sort':
                    return { type: 'Flow', shape: 'Sort' };
                case 'MultiDocument':
                    return { type: 'Flow', shape: 'MultiDocument' };
                case 'Collate':
                    return { type: 'Flow', shape: 'Collate' };
                case 'SummingJunction':
                    return { type: 'Flow', shape: 'SummingJunction' };
                case 'Or':
                    return { type: 'Flow', shape: 'Or' };
                case 'InternalStorage':
                    return { type: 'Flow', shape: 'InternalStorage' };
                case 'Extract':
                    return { type: 'Flow', shape: 'Extract' };
                case 'ManualOperation':
                    return { type: 'Flow', shape: 'ManualOperation' };
                case 'Merge':
                    return { type: 'Flow', shape: 'Merge' };
                case 'OffPageReference':
                    return { type: 'Flow', shape: 'OffPageReference' };
                case 'SequentialAccessStorage':
                    return { type: 'Flow', shape: 'SequentialAccessStorage' };
                case 'Data':
                    return { type: 'Flow', shape: 'Data' };
                case 'Card':
                    return { type: 'Flow', shape: 'Card' };
                case 'Delay':
                    return { type: 'Flow', shape: 'Delay' };
                case 'Preparation':
                    return { type: 'Flow', shape: 'Preparation' };
                case 'Display':
                    return { type: 'Flow', shape: 'Display' };
                case 'ManualInput':
                    return { type: 'Flow', shape: 'ManualInput' };
                case 'LoopLimit':
                    return { type: 'Flow', shape: 'LoopLimit' };
                case 'StoredData':
                    return { type: 'Flow', shape: 'StoredData' };
                case 'Annotation':
                    return { type: 'Flow', shape: 'Annotation' };
                case 'Annotation2':
                    return { type: 'Flow', shape: 'Annotation2' };
                default:
                    return { type: 'Flow', shape: 'Process' };
            }
        }
        return { type: 'Flow', shape: 'Process' };
    };
    DataBinding.prototype.splitString = function (property) {
        var temp = [];
        temp = property.split('.');
        for (var i = 0; i < temp.length; i++) {
            temp[parseInt(i.toString(), 10)] = temp[parseInt(i.toString(), 10)].charAt(0).toLowerCase()
                + temp[parseInt(i.toString(), 10)].slice(1);
        }
        return temp;
    };
    DataBinding.prototype.renderChildNodes = function (mapper, parent, value, rtNodes, diagram) {
        var child;
        var nextLevel;
        var node;
        for (var j = 0; j < parent.items.length; j++) {
            child = parent.items[parseInt(j.toString(), 10)];
            if (!child[mapper.id]) {
                continue;
            }
            node = this.applyNodeTemplate(mapper, child, diagram);
            var canBreak = false;
            if (!this.collectionContains(node, diagram, mapper.id, mapper.parentId)) {
                if (child[mapper.id] && isNaN(child[mapper.id])) {
                    this.dataTable[child[mapper.id].toLowerCase()] = node;
                }
                else {
                    this.dataTable[child[mapper.id]] = node;
                }
                diagram.nodes.push(node);
            }
            else {
                canBreak = true;
            }
            if (!this.containsConnector(diagram, value, node.id)) {
                diagram.connectors.push(this.applyConnectorTemplate(value, node.id, diagram));
            }
            if (!canBreak) {
                if (node.data[mapper.id] && isNaN(node.data[mapper.id])) {
                    nextLevel = rtNodes[node.data[mapper.id].toLowerCase()];
                }
                else {
                    nextLevel = rtNodes[node.data[mapper.id]];
                }
                if (nextLevel !== undefined) {
                    this.renderChildNodes(mapper, nextLevel, node.id, rtNodes, diagram);
                }
            }
        }
    };
    // Bug 832897: Need to improve performance while rendering layout with large number of nodes.
    // Replaced for loop with some() method to improve performance.
    DataBinding.prototype.containsConnector = function (diagram, sourceNode, targetNode) {
        if (sourceNode === '' || targetNode === '') {
            return false;
        }
        return diagram.connectors.some(function (connector) {
            return connector !== undefined && connector.sourceID === sourceNode && connector.targetID === targetNode;
        });
    };
    /**
     *  collectionContains method is used to  check wthear the node is already present in collection or not
     *
     * @param {Node} node
     * @param {Diagram} diagram
     * @param {string} id
     * @param {string} parentId
     */
    DataBinding.prototype.collectionContains = function (node, diagram, id, parentId) {
        var obj;
        if (isNaN(node.data["" + id]) && node.data["" + id]) {
            obj = this.dataTable[node.data["" + id].toLowerCase()];
        }
        else {
            obj = this.dataTable[node.data["" + id]];
        }
        if (obj !== undefined && obj.data["" + id] === node.data["" + id] && obj.data["" + parentId] === node.data["" + parentId]) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Get the Connector values
     *
     * @param {string} sNode
     * @param {string} tNode
     * @param {Diagram} diagram
     */
    DataBinding.prototype.applyConnectorTemplate = function (sNode, tNode, diagram) {
        var connModel = {
            id: randomId(), sourceID: sNode, targetID: tNode
        };
        var arrowType;
        //Task 895538: Flow-chart layout support for EJ2 diagram.
        //Added below code to set connector annotation and style based on the data.
        if (diagram.layout.type === 'Flowchart') {
            var targetNode = diagram.nodes.find(function (node) { return node.id === tNode; });
            if (typeof targetNode.data.label === 'string') {
                connModel.annotations = [{ content: targetNode.data.label }];
            }
            else if (Array.isArray(targetNode.data.label)) {
                var inConnectors = diagram.connectors.filter(function (connector) { return connector.targetID === tNode; });
                var index = 0;
                if (inConnectors.length > 0) {
                    index = inConnectors.length;
                }
                connModel.annotations = [{ content: targetNode.data.label[parseInt(index.toString(), 10)] }];
            }
            arrowType = this.getConnectorArrowType(targetNode.data);
        }
        var obj = new Connector(diagram, 'connectors', connModel, true);
        if (arrowType) {
            obj.style.strokeWidth = arrowType.strokeWidth;
            obj.targetDecorator.shape = arrowType.targetDecorator;
        }
        updateDefaultValues(obj, connModel, diagram.connectorDefaults);
        return obj;
    };
    DataBinding.prototype.getConnectorArrowType = function (data) {
        if (data.arrowType !== '') {
            switch (data.arrowType) {
                case 'None':
                    return { targetDecorator: 'None', strokeWidth: 1 };
                case 'Arrow':
                    return { targetDecorator: 'Arrow', strokeWidth: 1 };
                case 'Diamond':
                    return { targetDecorator: 'Diamond', strokeWidth: 1 };
                case 'Circle':
                    return { targetDecorator: 'Circle', strokeWidth: 1 };
                case 'OpenArrow':
                    return { targetDecorator: 'OpenArrow', strokeWidth: 1 };
                case 'Square':
                    return { targetDecorator: 'Square', strokeWidth: 1 };
                case 'Fletch':
                    return { targetDecorator: 'Fletch', strokeWidth: 1 };
                case 'OpenFetch':
                    return { targetDecorator: 'OpenFetch', strokeWidth: 1 };
                case 'IndentedArrow':
                    return { targetDecorator: 'IndentedArrow', strokeWidth: 1 };
                case 'OutdentedArrow':
                    return { targetDecorator: 'OutdentedArrow', strokeWidth: 1 };
                case 'DoubleArrow':
                    return { targetDecorator: 'DoubleArrow', strokeWidth: 1 };
                default:
                    return { targetDecorator: 'Arrow', strokeWidth: 1 };
            }
        }
        else {
            return { targetDecorator: 'Arrow', strokeWidth: 1 };
        }
    };
    return DataBinding;
}());

var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$3 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/**
 * @private
 */
var menuClass = {
    content: '.e-diagramcontent',
    copy: 'e-copy',
    paste: 'e-paste',
    undo: 'e-undo',
    redo: 'e-redo',
    cut: 'e-cut',
    selectAll: 'e-selectall',
    grouping: 'e-grouping',
    group: 'e-group',
    unGroup: 'e-ungroup',
    bringToFront: 'e-bringfront',
    sendToBack: 'e-sendback',
    moveForward: 'e-bringforward',
    sendBackward: 'e-sendbackward',
    order: 'e-order'
};
/**
 * 'ContextMenu module used to handle context menu actions.'
 *
 * @private
 */
var DiagramContextMenu = /** @class */ (function () {
    function DiagramContextMenu(parent, service) {
        this.defaultItems = {};
        /**
         * @private
         */
        this.disableItems = [];
        /**
         * @private
         */
        this.hiddenItems = [];
        this.localeText = this.setLocaleKey();
        this.parent = parent;
        this.serviceLocator = service;
        this.addEventListener();
    }
    /**
     * addEventListener method \
     *
     * @returns { void } addEventListener method .\
     *
     * @private
     */
    DiagramContextMenu.prototype.addEventListener = function () {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on('initial-load', this.render, this);
    };
    /**
     * removeEventListener method \
     *
     * @returns { void } removeEventListener method .\
     *
     * @private
     */
    DiagramContextMenu.prototype.removeEventListener = function () {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off('initial-load', this.render);
    };
    DiagramContextMenu.prototype.render = function () {
        this.l10n = this.serviceLocator.getService('localization');
        this.element = createHtmlElement('ul', { id: this.parent.element.id + '_contextMenu' });
        this.parent.element.appendChild(this.element);
        var target = '#' + this.parent.element.id;
        this.contextMenu = new ContextMenu({
            items: this.getMenuItems(),
            enableRtl: this.parent.enableRtl,
            enablePersistence: this.parent.enablePersistence,
            locale: this.parent.locale,
            target: target,
            select: this.contextMenuItemClick.bind(this),
            beforeOpen: this.contextMenuBeforeOpen.bind(this),
            onOpen: this.contextMenuOpen.bind(this),
            beforeItemRender: this.BeforeItemRender.bind(this),
            onClose: this.contextMenuOnClose.bind(this),
            cssClass: 'e-diagram-menu',
            animationSettings: { effect: 'None' }
        });
        this.contextMenu.appendTo(this.element);
    };
    DiagramContextMenu.prototype.getMenuItems = function () {
        var menuItems = [];
        var orderItems = [];
        var groupItems = [];
        if (!this.parent.contextMenuSettings.showCustomMenuOnly) {
            for (var _i = 0, _a = this.getDefaultItems(); _i < _a.length; _i++) {
                var item = _a[_i];
                if (item.toLocaleLowerCase().indexOf('group') !== -1) {
                    if (item.toLocaleLowerCase() !== 'grouping') {
                        groupItems.push(this.buildDefaultItems(item));
                    }
                }
                else if (item.toLocaleLowerCase().indexOf('order') !== -1) {
                    if (item.toLocaleLowerCase() !== 'order') {
                        orderItems.push(this.buildDefaultItems(item));
                    }
                }
                else {
                    menuItems.push(this.buildDefaultItems(item));
                }
            }
            var groupMenus = this.buildDefaultItems('grouping');
            groupMenus.items = groupItems;
            menuItems.push(groupMenus);
            var orderMenus = this.buildDefaultItems('order');
            orderMenus.items = orderItems;
            menuItems.push(orderMenus);
        }
        if (this.parent.contextMenuSettings.items) {
            for (var _b = 0, _c = this.parent.contextMenuSettings.items; _b < _c.length; _b++) {
                var customItem = _c[_b];
                menuItems.push(customItem);
            }
        }
        return menuItems;
    };
    DiagramContextMenu.prototype.contextMenuOpen = function () {
        this.isOpen = true;
    };
    DiagramContextMenu.prototype.BeforeItemRender = function (args) {
        this.parent.trigger(contextMenuBeforeItemRender, args);
    };
    DiagramContextMenu.prototype.contextMenuItemClick = function (args) {
        document.getElementById(this.parent.element.id + 'content').focus();
        this.parent.trigger(contextMenuClick, args);
        var item = this.getKeyFromId(args.item.id);
        if (!args.cancel) {
            switch (item) {
                case 'cut':
                    this.parent.cut();
                    break;
                case 'copy':
                    this.parent.copy();
                    break;
                case 'undo':
                    this.parent.undo();
                    break;
                case 'redo':
                    this.parent.redo();
                    break;
                case 'paste':
                    this.parent.paste();
                    break;
                case 'selectAll':
                    this.parent.selectAll();
                    break;
                case 'group':
                    this.parent.group();
                    break;
                case 'unGroup':
                    this.parent.unGroup();
                    break;
                case 'bringToFrontOrder':
                    this.parent.bringToFront();
                    break;
                case 'moveForwardOrder':
                    this.parent.moveForward();
                    break;
                case 'sendToBackOrder':
                    this.parent.sendToBack();
                    break;
                case 'sendBackwardOrder':
                    this.parent.sendBackward();
                    break;
            }
        }
    };
    DiagramContextMenu.prototype.contextMenuOnClose = function (args) {
        var parent = 'parentObj';
        if (args.items.length > 0 && args.items[0]["" + parent] instanceof ContextMenu) {
            this.updateItemStatus();
        }
    };
    DiagramContextMenu.prototype.getLocaleText = function (item) {
        return this.l10n.getConstant(this.localeText["" + item]);
    };
    DiagramContextMenu.prototype.updateItemStatus = function () {
        this.contextMenu.showItems(this.hiddenItems, true);
        this.contextMenu.enableItems(this.disableItems, false, true);
        this.hiddenItems = [];
        this.disableItems = [];
        this.isOpen = false;
    };
    /**
     * ensureItems method \
     *
     * @returns { void } ensureItems method .\
     * @param {MenuItemModel} item - provide the item value.
     * @param {Event} event - provide the event value.
     *
     * @private
     */
    DiagramContextMenu.prototype.ensureItems = function (item, event) {
        var key = this.getKeyFromId(item.id);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var dItem = this.defaultItems["" + key];
        if (this.getDefaultItems().indexOf(key) !== -1) {
            if (item.target && (event || this.parent.checkMenu) &&
                !this.ensureTarget(item)) {
                this.hiddenItems.push(item.id);
            }
        }
    };
    /**
     * refreshItems method \
     *
     * @returns { void } refreshItems method .\
     *
     * @private
     */
    DiagramContextMenu.prototype.refreshItems = function () {
        this.updateItems();
        this.contextMenu.refresh();
    };
    DiagramContextMenu.prototype.updateItems = function () {
        var canInsert = true;
        for (var i = 0; i < this.parent.contextMenuSettings.items.length; i++) {
            var items = this.parent.contextMenuSettings.items[parseInt(i.toString(), 10)];
            for (var j = 0; j < this.contextMenu.items.length; j++) {
                if (this.contextMenu.items[parseInt(j.toString(), 10)].text
                    === this.parent.contextMenuSettings.items[parseInt(i.toString(), 10)].text) {
                    canInsert = false;
                }
            }
            if (canInsert) {
                this.contextMenu.insertAfter([items], this.contextMenu.items[this.contextMenu.items.length - 1].text);
            }
        }
    };
    DiagramContextMenu.prototype.contextMenuBeforeOpen = function (args) {
        return __awaiter$3(this, void 0, void 0, function () {
            var diagramArgs, _i, _a, item, _b, _c, newItem, hidden, contextItems, i, item, i, item;
            return __generator$3(this, function (_d) {
                if (!this.parent.checkMenu &&
                    (window.navigator.userAgent.indexOf('Linux') !== -1 || window.navigator.userAgent.indexOf('X11') !== -1)) {
                    this.parent.checkMenu = args.cancel = true;
                }
                if (this.parent.checkMenu) {
                    this.hiddenItems = [];
                }
                diagramArgs = args;
                diagramArgs.hiddenItems = [];
                for (_i = 0, _a = args.items; _i < _a.length; _i++) {
                    item = _a[_i];
                    this.ensureItems(item, args.event);
                    if (item.items.length) {
                        for (_b = 0, _c = item.items; _b < _c.length; _b++) {
                            newItem = _c[_b];
                            this.ensureItems(newItem, args.event);
                        }
                    }
                }
                this.eventArgs = args.event;
                //Removed isBlazor code
                this.parent.trigger(contextMenuOpen, diagramArgs);
                hidden = true;
                this.hiddenItems = this.hiddenItems.concat(diagramArgs.hiddenItems);
                this.contextMenu.enableItems(this.disableItems, false, true);
                contextItems = this;
                for (i = 0; i < args.items.length; i++) {
                    item = args.items[parseInt(i.toString(), 10)];
                    if (contextItems.hiddenItems.indexOf(item.id) > -1) {
                        contextItems.contextMenu.hideItems([item.id], true);
                    }
                }
                for (i = 0; i < contextItems.contextMenu.items.length; i++) {
                    item = contextItems.contextMenu.items[parseInt(i.toString(), 10)];
                    if (contextItems.hiddenItems.indexOf(item.id) === -1) {
                        hidden = false;
                        contextItems.contextMenu.showItems([item.id], true);
                    }
                }
                if (hidden) {
                    diagramArgs.cancel = hidden;
                    this.hiddenItems = [];
                }
                /* tslint:disable */
                if (this.parent.selectedItems.nodes.length && this.parent.selectedItems.nodes[0].isPhase
                    && !this.parent.contextMenuSettings.showCustomMenuOnly) {
                    args.cancel = true;
                }
                return [2 /*return*/];
            });
        });
    };
    DiagramContextMenu.prototype.ensureTarget = function (item) {
        var selectedLength = this.parent.selectedItems.nodes.length +
            this.parent.selectedItems.connectors.length;
        var itemText = this.getKeyFromId(item.id);
        var target = false;
        switch (itemText) {
            case 'undo':
                target = this.parent.historyManager && this.parent.historyManager.canUndo ? true : false;
                break;
            case 'redo':
                target = this.parent.historyManager && this.parent.historyManager.canRedo ? true : false;
                break;
            case 'paste':
                target = this.parent.commandHandler.clipboardData.clipObject ? true : false;
                break;
            case 'selectAll':
                target = this.parent.nodes.length + this.parent.connectors.length ? true : false;
                break;
            case 'grouping':
                target = ((selectedLength > 1) || (this.parent.selectedItems.nodes[0] && this.parent.selectedItems.nodes[0].children
                    && this.parent.selectedItems.nodes[0].children.length > 1)) ? true : false;
                break;
            case 'group':
                target = selectedLength > 1;
                break;
            case 'unGroup':
                target = (((this.parent.selectedItems.nodes.length === 1 && this.parent.selectedItems.connectors.length === 0)
                    && this.parent.selectedItems.nodes[0] && this.parent.selectedItems.nodes[0].children
                    && this.parent.selectedItems.nodes[0].children.length > 1)) ? true : false;
                break;
            case 'cut':
            case 'copy':
            case 'order':
            case 'bringToFrontOrder':
            case 'moveForwardOrder':
            case 'sendToBackOrder':
            case 'sendBackwardOrder':
                target = selectedLength ? true : false;
                break;
        }
        return target;
    };
    /**
     *To destroy the context menu
     *
     * @returns {void} To destroy the context menu
     */
    DiagramContextMenu.prototype.destroy = function () {
        this.contextMenu.destroy();
        remove(this.element);
        this.removeEventListener();
    };
    DiagramContextMenu.prototype.getModuleName = function () {
        return 'contextMenu';
    };
    DiagramContextMenu.prototype.generateID = function (item) {
        return this.parent.element.id + '_contextMenu_' + item;
    };
    DiagramContextMenu.prototype.getKeyFromId = function (id) {
        return id.replace(this.parent.element.id + '_contextMenu_', '');
    };
    DiagramContextMenu.prototype.buildDefaultItems = function (item) {
        var menuItem;
        switch (item) {
            case 'copy':
                menuItem = { target: menuClass.content, iconCss: menuClass.copy };
                break;
            case 'cut':
                menuItem = { target: menuClass.content, iconCss: menuClass.cut };
                break;
            case 'paste':
                menuItem = { target: menuClass.content, iconCss: menuClass.paste };
                break;
            case 'undo':
                menuItem = { target: menuClass.content, iconCss: menuClass.undo };
                break;
            case 'redo':
                menuItem = { target: menuClass.content, iconCss: menuClass.redo };
                break;
            case 'grouping':
                menuItem = { target: menuClass.content };
                break;
            case 'group':
                menuItem = { target: menuClass.content, iconCss: menuClass.group };
                break;
            case 'unGroup':
                menuItem = { target: menuClass.content, iconCss: menuClass.unGroup };
                break;
            case 'order':
                menuItem = { target: menuClass.content, iconCss: menuClass.order };
                break;
            case 'bringToFrontOrder':
                menuItem = { target: menuClass.content, iconCss: menuClass.bringToFront };
                break;
            case 'moveForwardOrder':
                menuItem = { target: menuClass.content, iconCss: menuClass.moveForward };
                break;
            case 'sendToBackOrder':
                menuItem = { target: menuClass.content, iconCss: menuClass.sendToBack };
                break;
            case 'sendBackwardOrder':
                menuItem = { target: menuClass.content, iconCss: menuClass.sendBackward };
                break;
            case 'selectAll':
                menuItem = { target: menuClass.content };
                break;
        }
        this.defaultItems["" + item] = {
            text: this.getLocaleText(item), id: this.generateID(item),
            target: menuItem.target, iconCss: menuItem.iconCss ? 'e-icons ' + menuItem.iconCss : ''
        };
        return this.defaultItems["" + item];
    };
    DiagramContextMenu.prototype.getDefaultItems = function () {
        return [
            'copy',
            'cut', 'paste', 'undo', 'redo', 'selectAll', 'grouping', 'group', 'unGroup', 'order',
            'bringToFrontOrder', 'moveForwardOrder', 'sendToBackOrder', 'sendBackwardOrder'
        ];
    };
    DiagramContextMenu.prototype.setLocaleKey = function () {
        return {
            'copy': 'Copy',
            'cut': 'Cut',
            'paste': 'Paste',
            'undo': 'Undo',
            'redo': 'Redo',
            'selectAll': 'SelectAll',
            'grouping': 'Grouping',
            'group': 'Group',
            'unGroup': 'UnGroup',
            'order': 'Order',
            'bringToFrontOrder': 'BringToFront',
            'moveForwardOrder': 'MoveForward',
            'sendToBackOrder': 'SendToBack',
            'sendBackwardOrder': 'SendBackward'
        };
    };
    return DiagramContextMenu;
}());

/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * BPMN Diagrams contains the BPMN functionalities
 */
var BpmnDiagrams = /** @class */ (function () {
    //End size region
    /**
     * Constructor for the BpmnDiagrams module
     *
     * @private
     */
    function BpmnDiagrams() {
        //Code conversion for Bpmn Shapes
        //Start Region
        /**   @private  */
        this.bpmnTextAnnotationConnector = [];
        //constructs the BpmnDiagrams module
    }
    /**   @private  */
    BpmnDiagrams.prototype.getSize = function (node, content) {
        var size = new Size(node.width, node.height);
        if (size.width === undefined || size.height === undefined) {
            if (!(content instanceof PathElement)) {
                size.width = size.width || 50;
                size.height = size.height || 50;
            }
            if (content.actualSize.width && content.actualSize.height) {
                return content.actualSize;
            }
            else {
                content.measure(new Size());
                size.width = size.width || content.desiredSize.width;
                size.height = size.height || content.desiredSize.height;
            }
            if (node.maxWidth !== undefined) {
                size.width = Math.min(size.width, node.maxWidth);
            }
            if (node.maxHeight !== undefined) {
                size.height = Math.min(size.height, node.maxHeight);
            }
            if (node.minWidth !== undefined) {
                size.width = Math.max(size.width, node.minWidth);
            }
            if (node.minHeight !== undefined) {
                size.height = Math.max(size.height, node.minHeight);
            }
        }
        return size;
    };
    /** @private */
    BpmnDiagrams.prototype.initBPMNContent = function (content, node, diagram) {
        var shape = node.shape;
        var bpmnShape = node.shape.shape;
        if (bpmnShape === 'Event') {
            content = this.getBPMNEventShape(node, shape.event);
        }
        if (bpmnShape === 'Gateway') {
            content = this.getBPMNGatewayShape(node);
        }
        if (bpmnShape === 'DataObject') {
            content = this.getBPMNDataObjectShape(node);
        }
        if (bpmnShape === 'Message' || bpmnShape === 'DataSource') {
            content = this.getBPMNShapes(node);
        }
        //848061-BPMN Group shape to be function Like Subprocess Node
        if (bpmnShape === 'Group') {
            //854195 - bpmn group serialization issue
            content = this.getBPMNGroup(node, diagram);
            content.style.strokeDashArray = node.style.strokeDashArray !== '' ? node.style.strokeDashArray : '2 2 6 2';
            content.cornerRadius = 10;
        }
        if (bpmnShape === 'Activity') {
            content = this.getBPMNActivityShape(node);
        }
        //Task 866412: Should revamp BPMN text annotation node.
        if (bpmnShape === 'TextAnnotation') {
            if (node.parentObj instanceof Diagram || node.parentObj instanceof Lane) {
                content = this.getBpmnTextAnnotationShape(node, node.shape, diagram);
            }
            else {
                content = this.getBpmnTextAnnotationSymbol(node, node.shape, diagram);
            }
        }
        return content;
    };
    BpmnDiagrams.prototype.getBpmnTextAnnotationShape = function (textAnnotation, bpmnTextAnnotation, diagram) {
        var annotationsContainer = new Canvas();
        annotationsContainer.measureChildren = false;
        annotationsContainer.offsetX = textAnnotation.offsetX;
        annotationsContainer.offsetY = textAnnotation.offsetY;
        annotationsContainer.float = true;
        annotationsContainer.id = textAnnotation.id + "_textannotation";
        annotationsContainer.style.strokeColor = 'transparent';
        annotationsContainer.style.fill = 'transparent';
        annotationsContainer.relativeMode = 'Object';
        annotationsContainer.rotateAngle = 0;
        var width = textAnnotation.width;
        var height = textAnnotation.height;
        var bounds = new Rect(0, 0, 0, 0);
        if (width !== 0 && height !== 0) {
            bounds = new Rect(textAnnotation.offsetX - width / 2, textAnnotation.offsetY - height / 2, width, height);
        }
        var oldIsProtectedOnChange = diagram.isProtectedOnChange;
        diagram.isProtectedOnChange = false;
        this.setAnnotationPath(bounds, annotationsContainer, textAnnotation, bpmnTextAnnotation, bpmnTextAnnotation.textAnnotation.textAnnotationDirection, diagram);
        diagram.isProtectedOnChange = oldIsProtectedOnChange;
        return annotationsContainer;
    };
    //Task 866412: Should revamp BPMN text annotation node. To render text annotation in symbol palette.
    BpmnDiagrams.prototype.getBpmnTextAnnotationSymbol = function (annotation, bpmnTextAnnotation, diagram) {
        var data = 'M33.33,15 L0,43 M39.33,0 L33.33,0 L33.33,30 L39.33,30 M60,0';
        if (bpmnTextAnnotation.textAnnotation.textAnnotationDirection === 'Top') {
            data = 'M15,33.33 L43,0 M0,39.33 L0,33.33 L30,33.33 L30,39.33 M0,60';
        }
        else if (bpmnTextAnnotation.textAnnotation.textAnnotationDirection === 'Right') {
            data = 'M6,15 L39.33,43 M0,0 L6,0 L6,30 L0,30 M-20,0';
        }
        else if (bpmnTextAnnotation.textAnnotation.textAnnotationDirection === 'Bottom') {
            data = 'M15,6 L43,39.33 M0,0 L0,6 L30,6 L30,0 M0,-20';
        }
        var path = new PathElement();
        path.data = data;
        path.style.fill = ((annotation.style.fill === 'white') ? 'transparent' : annotation.style.fill);
        path.style.strokeDashArray = (annotation.style.strokeDashArray ? annotation.style.strokeDashArray : '');
        path.style.strokeWidth = annotation.style.strokeWidth;
        path.style.strokeColor = ((annotation.style.strokeColor === 'transparent') ? 'black' : annotation.style.strokeColor);
        path.style.opacity = annotation.style.opacity;
        return path;
    };
    /** @private */
    BpmnDiagrams.prototype.getBPMNShapes = function (node) {
        var bpmnShape = new PathElement();
        //set style
        this.setStyle(bpmnShape, node);
        //941052: Issue with visible property doesn't hide shadows
        if ((node.constraints & NodeConstraints.Shadow) !== 0 && node.visible) {
            bpmnShape.shadow = node.shadow;
        }
        var bpmnShapeData = getBpmnShapePathData(node.shape.shape);
        bpmnShape.data = bpmnShapeData;
        bpmnShape.id = node.id + '_' + node.shape.shape;
        if (node.width !== undefined && node.height !== undefined) {
            bpmnShape.width = node.width;
            bpmnShape.height = node.height;
        }
        return bpmnShape;
    };
    //854195 - Method to add the children as canvas in the Bpmn group node container
    /** @private */
    BpmnDiagrams.prototype.getBPMNGroup = function (node, diagram) {
        var group = new Canvas();
        //set style
        this.setStyle(group, node);
        group.id = node.id + '_group';
        if (!group.children) {
            group.children = [];
        }
        var groupShapeObj = (node.shape.group);
        if (node.shape.group) {
            for (var i = 0; i < groupShapeObj.children.length; i++) {
                var child = diagram.nameTable[groupShapeObj.children[parseInt(i.toString(), 10)]];
                group.children.push(child.wrapper);
            }
        }
        group.width = node.width;
        group.height = node.height;
        return group;
    };
    /** @private */
    BpmnDiagrams.prototype.getBPMNGatewayShape = function (node) {
        var gatewayshape = new Canvas();
        //childNode0
        var gatewayNode = new PathElement();
        gatewayNode.id = node.id + '_0_gateway';
        gatewayNode.offsetX = node.offsetX;
        gatewayNode.offsetY = node.offsetY;
        gatewayNode.data = 'M 40 20 L 20 40 L 0 20 L 20 0 L 40 20 Z';
        this.setStyle(gatewayNode, node);
        //childNode1
        var gatewayTypeNode = new PathElement();
        gatewayTypeNode.id = node.id + '_1_gatewayType';
        //set style - opacity
        gatewayTypeNode.style.opacity = node.style.opacity;
        gatewayTypeNode.style.strokeColor = node.style.strokeColor;
        gatewayTypeNode.horizontalAlignment = 'Center';
        gatewayTypeNode.verticalAlignment = 'Center';
        gatewayTypeNode.relativeMode = 'Object';
        var shapeType = node.shape.gateway;
        //let gatewayTypeNodeShapeData: string;
        var gatewayTypeNodeShapeData = getBpmnGatewayShapePathData(shapeType.type);
        if (shapeType.type === 'EventBased' || shapeType.type === 'ExclusiveEventBased' || shapeType.type === 'ParallelEventBased') {
            gatewayTypeNode.style.fill = 'white';
        }
        else {
            gatewayTypeNode.style.fill = 'black';
        }
        gatewayTypeNode.data = gatewayTypeNodeShapeData;
        // append child and set style
        gatewayshape.style.fill = 'transparent';
        gatewayshape.style.strokeColor = 'transparent';
        gatewayshape.style.strokeWidth = 0;
        gatewayshape.children = [gatewayNode, gatewayTypeNode];
        var size = this.getSize(node, gatewayNode);
        this.setSizeForBPMNGateway(node.shape.gateway, gatewayshape, size.width, size.height);
        return gatewayshape;
    };
    /** @private */
    BpmnDiagrams.prototype.getBPMNDataObjectShape = function (node) {
        var dataObjectshape = new Canvas();
        var shape = node.shape.dataObject;
        //childNode0
        var dataobjNode = new PathElement();
        dataobjNode.id = node.id + '_0_dataobj';
        dataobjNode.data = 'M29.904,5 L7.853,5 L7.853,45 L42.147,45 L42.147,17.242,L29.932,5,L29.932,17.242,L42.147,17.242';
        var size = this.getSize(node, dataobjNode);
        dataobjNode.width = size.width;
        dataobjNode.height = size.height;
        this.setStyle(dataobjNode, node);
        //childNode1
        var dataobjTypeNode = new PathElement();
        dataobjTypeNode.id = node.id + '_1_type';
        dataobjTypeNode.width = 25;
        dataobjTypeNode.height = 20;
        dataobjTypeNode.margin.left = 5;
        dataobjTypeNode.margin.top = 5;
        dataobjTypeNode.data = 'M 3 9.4 l 6 0 v 2.4 l 3.6 -4 L 9 4 v 2.5 H 3 V 9.4 Z';
        //set style - opacity
        dataobjTypeNode.style.opacity = node.style.opacity;
        //childNode2
        var dataobjCollectionNode = new PathElement();
        dataobjCollectionNode.id = node.id + '_2_collection';
        dataobjCollectionNode.width = 7.5;
        dataobjCollectionNode.height = 15;
        dataobjCollectionNode.style.fill = 'black';
        dataobjCollectionNode.visible = true;
        dataobjCollectionNode.horizontalAlignment = 'Center';
        dataobjCollectionNode.verticalAlignment = 'Bottom';
        dataobjCollectionNode.relativeMode = 'Object';
        //set style - opacity
        dataobjCollectionNode.style.opacity = node.style.opacity;
        dataobjCollectionNode.data = 'M 0 0 L 0.1 0 L 0.1 2 L 0 2 Z M 0.4 0 L 0.6 0 L 0.6 2 L0.4 2 Z M 0.9 0 L 1 0 L 1 2 L 0.9 2 Z';
        switch (shape.type) {
            case 'None':
                dataobjTypeNode.visible = false;
                break;
            case 'Input':
                dataobjTypeNode.style.fill = 'white';
                break;
            case 'Output':
                dataobjTypeNode.style.fill = 'black';
                break;
        }
        if (shape.collection === false) {
            dataobjCollectionNode.visible = false;
        }
        //append child and set style
        dataObjectshape.style.fill = 'transparent';
        dataObjectshape.style.strokeColor = 'transparent';
        dataObjectshape.style.strokeWidth = 0;
        dataObjectshape.children = [dataobjNode, dataobjTypeNode, dataobjCollectionNode];
        return dataObjectshape;
    };
    /** @private */
    BpmnDiagrams.prototype.getBPMNTaskShape = function (node) {
        var shape = node.shape.activity;
        var task = shape.task;
        var taskShapes = new Canvas();
        //childNode0
        var taskNode = new DiagramElement();
        taskNode.cornerRadius = 10;
        var size = this.getSize(node, taskNode);
        taskNode.id = node.id + '_0_task';
        taskNode.width = size.width;
        taskNode.height = size.height;
        this.setStyle(taskNode, node);
        // if task as call
        if ((task.call !== undefined) && task.call === true) {
            taskNode.style.strokeWidth = 4;
        }
        taskShapes.width = size.width;
        taskShapes.height = size.height;
        var childCount = this.getTaskChildCount(node);
        var x;
        var childSpace = childCount * 12;
        var area = size.width / 2 - childSpace;
        if (childCount === 1) {
            x = area + 8;
        }
        else {
            x = area + (childCount - 1) * 8;
        }
        //childNode1
        var taskTypeNode = new PathElement();
        if (task.type === 'Receive' || task.type === 'Send') {
            taskTypeNode.width = 18;
            taskTypeNode.height = 16;
        }
        else if (task.type === 'Manual') {
            taskTypeNode.width = 16;
            taskTypeNode.height = 11;
        }
        else {
            taskTypeNode.width = 20;
            taskTypeNode.height = 20;
        }
        taskTypeNode.id = node.id + '_1_tasktType';
        taskTypeNode.margin.left = 5;
        taskTypeNode.margin.top = 5;
        task.type = task.type || 'None';
        var taskTypeNodeData = getBpmnTaskShapePathData(task.type);
        taskTypeNode.data = taskTypeNodeData;
        taskTypeNode.style.fill = 'transparent';
        taskTypeNode.style.opacity = node.style.opacity;
        if (task.type === 'Send') {
            taskTypeNode.style.fill = 'black';
        }
        // append child and set style
        taskShapes.style.fill = 'transparent';
        taskShapes.style.strokeColor = 'transparent';
        taskShapes.style.strokeWidth = 0;
        taskShapes.children = [taskNode, taskTypeNode];
        //childnode for service
        if (task.type === 'Service') {
            var taskTypeNodeService = new PathElement();
            taskTypeNodeService.id = node.id + '_1_taskTypeService';
            taskTypeNodeService.data = taskTypeNodeData;
            taskTypeNodeService.margin.left = taskTypeNode.margin.left + 9;
            taskTypeNodeService.margin.top = taskTypeNode.margin.top + 9;
            taskTypeNodeService.style.fill = 'white';
            taskTypeNodeService.style.opacity = node.style.opacity;
            taskShapes.children.push(taskTypeNodeService);
        }
        // if task as loop
        var loopType = task.loop;
        var taskLoopNode = new PathElement(); //let childNode2data: string;
        var childNode2data = getBpmnLoopShapePathData(loopType);
        taskLoopNode.data = childNode2data;
        taskLoopNode.style.fill = 'black';
        if (loopType !== 'None') {
            taskLoopNode.visible = true;
        }
        else {
            taskLoopNode.visible = false;
        }
        if (childCount === 1) {
            x = area + 9;
        }
        //891296: Position of BPMN activity loop node is not proper while save and load
        taskLoopNode.margin.left = x - 3;
        if (taskLoopNode.visible === true) {
            x += 12 + 8;
        }
        taskLoopNode.width = 12;
        taskLoopNode.height = 12;
        taskLoopNode.margin.bottom = 5;
        taskLoopNode.id = node.id + '_2_loop';
        taskLoopNode.horizontalAlignment = 'Left';
        taskLoopNode.verticalAlignment = 'Bottom';
        taskLoopNode.setOffsetWithRespectToBounds(0, 1, 'Fraction');
        taskLoopNode.relativeMode = 'Point';
        taskLoopNode.style.fill = 'transparent';
        taskTypeNode.style.opacity = node.style.opacity;
        taskShapes.children.push(taskLoopNode);
        //if task as compensation
        var taskCompNode = new PathElement();
        taskCompNode = this.getBPMNCompensationShape(node, taskCompNode);
        if (task.compensation === true) {
            taskCompNode.visible = true;
        }
        else {
            taskCompNode.visible = false;
        }
        if (childCount === 1) {
            x = area + 9;
        }
        taskCompNode.margin.left = x - 3;
        x += 12 + 6;
        taskShapes.children.push(taskCompNode);
        return taskShapes;
    };
    /** @private */
    BpmnDiagrams.prototype.getBPMNEventShape = function (node, subEvent, sub, id) {
        var eventshape = new Canvas();
        var event;
        var trigger;
        var width;
        var height;
        id = id || node.id;
        var pathdata = 'M164.1884,84.6909000000001C156.2414,84.6909000000001,149.7764,78.2259000000001,149.7764,70.2769000000001' +
            'C149.7764,62.3279000000001,156.2414,55.8629000000001,164.1884,55.8629000000001C172.1354,55.8629000000001,178.6024,' +
            '62.3279000000001,178.6024,70.2769000000001C178.6024,78.2259000000001,172.1354,84.6909000000001,164.1884,84.6909000000001';
        var shapeEvent = node.shape.event;
        if ((!isBlazor() && node.shape.shape === 'Event')) {
            event = shapeEvent.event;
            trigger = shapeEvent.trigger;
        }
        width = subEvent.width;
        height = subEvent.height;
        if (sub) {
            width = width || 20;
            height = height || 20;
        }
        else if (subEvent.width === undefined || subEvent.height === undefined) {
            var pathElement = new PathElement();
            pathElement.data = pathdata;
            var size = this.getSize(node, pathElement);
            width = size.width;
            height = size.height;
        }
        var shapeActivity = node.shape.activity;
        if ((!isBlazor() && node.shape.shape === 'Activity')) {
            var subProcess = shapeActivity.subProcess;
            event = subEvent.event;
            trigger = subEvent.trigger;
        }
        //childNode0
        var innerEvtNode = new PathElement();
        innerEvtNode.data = pathdata;
        innerEvtNode.id = id + '_0_event';
        innerEvtNode.width = width;
        innerEvtNode.height = height;
        innerEvtNode.horizontalAlignment = 'Center';
        innerEvtNode.verticalAlignment = 'Center';
        innerEvtNode.relativeMode = 'Object';
        this.setStyle(innerEvtNode, node);
        //childNode1
        var outerEvtNode = new PathElement();
        outerEvtNode.data = pathdata;
        outerEvtNode.id = id + '_1_event';
        outerEvtNode.style.gradient = node.style.gradient;
        outerEvtNode.horizontalAlignment = 'Center';
        outerEvtNode.verticalAlignment = 'Center';
        outerEvtNode.relativeMode = 'Object';
        // set style opacity & strokeColor
        outerEvtNode.style.strokeColor = node.style.strokeColor;
        outerEvtNode.style.opacity = node.style.opacity;
        //childNode2
        var triggerNode = new PathElement();
        var triggerNodeData = getBpmnTriggerShapePathData(trigger);
        triggerNode.data = triggerNodeData;
        triggerNode.id = id + '_2_trigger';
        triggerNode.horizontalAlignment = 'Center';
        triggerNode.verticalAlignment = 'Center';
        triggerNode.relativeMode = 'Object';
        // set style opacity & strokeColor
        triggerNode.style.strokeColor = node.style.strokeColor;
        triggerNode.style.opacity = node.style.opacity;
        switch (event) {
            case 'Start':
                outerEvtNode.visible = false;
                break;
            case 'NonInterruptingStart':
                innerEvtNode.style.strokeDashArray = '2 3';
                outerEvtNode.visible = false;
                break;
            case 'Intermediate':
                innerEvtNode.style.fill = node.style.fill;
                innerEvtNode.style.gradient = null;
                break;
            case 'NonInterruptingIntermediate':
                innerEvtNode.style.fill = node.style.fill;
                innerEvtNode.style.gradient = null;
                innerEvtNode.style.strokeDashArray = '2 3';
                outerEvtNode.style.strokeDashArray = '2 3';
                break;
            case 'ThrowingIntermediate':
            case 'End':
                innerEvtNode.style.fill = event !== 'End' ? node.style.fill : node.style.fill !== 'white' ? node.style.fill : 'black';
                innerEvtNode.style.gradient = null;
                triggerNode.style.fill = 'black';
                triggerNode.style.strokeColor = 'white';
                break;
        }
        //append child and set style
        eventshape.style.fill = 'transparent';
        eventshape.style.strokeColor = 'transparent';
        eventshape.style.strokeWidth = 0;
        eventshape.children = [innerEvtNode, outerEvtNode, triggerNode];
        this.setSizeForBPMNEvents(shapeEvent, eventshape, width, height);
        return eventshape;
    };
    BpmnDiagrams.prototype.setEventVisibility = function (node, canvas) {
        var event = node.shape.event.event;
        var innerEvtNode = canvas[0];
        var outerEvtNode = canvas[1];
        var triggerNode = canvas[2];
        switch (event) {
            case 'Start':
                outerEvtNode.visible = false;
                break;
            case 'NonInterruptingStart':
                innerEvtNode.style.strokeDashArray = '2 3';
                outerEvtNode.visible = false;
                break;
        }
    };
    BpmnDiagrams.prototype.setSubProcessVisibility = function (node) {
        var subProcess = node.shape.activity.subProcess;
        var eventLength = subProcess.events.length;
        var index = (node.shape.activity.subProcess.type === 'Transaction') ? 2 : 0;
        var elementWrapper = node.wrapper.children[0].children[0];
        if (subProcess.adhoc === false) {
            elementWrapper.children[3 + index + eventLength].visible = false;
        }
        if (subProcess.compensation === false) {
            elementWrapper.children[4 + index + eventLength].visible = false;
        }
        if (eventLength > 0) {
            for (var i = 0; i < eventLength; i++) {
                this.setEventVisibility(node, elementWrapper.children[2 + i].children);
            }
        }
    };
    /** @private */
    BpmnDiagrams.prototype.getBPMNSubProcessShape = function (node) {
        var subProcessShapes = new Canvas();
        var events;
        var event;
        var subprocessAdhoc = new PathElement();
        var subProcessEventsShapes = new Canvas();
        var subProcessLoopShapes = new PathElement();
        var shape = node.shape.activity;
        var subProcess = shape.subProcess;
        var subChildCount = this.getSubprocessChildCount(node);
        var x;
        var subprocessNode = new DiagramElement();
        subprocessNode.id = node.id + '_0_Subprocess';
        subprocessNode.style.fill = 'transparent';
        subprocessNode.cornerRadius = 10;
        var size = this.getSize(node, subprocessNode);
        subprocessNode.width = size.width;
        subprocessNode.height = size.height;
        subProcessShapes.children = [subprocessNode];
        if (shape.subProcess.type === 'Transaction') {
            this.getBPMNSubProcessTransaction(node, node.shape, subProcessShapes);
        }
        var iconSpace = 4;
        var subChildSpace = 12;
        var childSpace = subChildCount * subChildSpace;
        var area = size.width / 2;
        if (subChildCount === 1) {
            x = area - (subChildSpace * 0.5);
        }
        else {
            x = area - (childSpace / 2) - ((subChildCount - 1) * iconSpace) / 2;
        }
        //set style
        this.setStyle(subprocessNode, node);
        //941052: Issue with visible property doesn't hide shadows
        if ((node.constraints & NodeConstraints.Shadow) !== 0 && node.visible) {
            subProcessShapes.shadow = node.shadow;
        }
        var collapsedShape = new PathElement();
        collapsedShape.id = node.id + '_0_collapsed';
        collapsedShape.width = 12;
        collapsedShape.height = 12;
        collapsedShape.style.fill = 'black';
        collapsedShape.style.strokeColor = node.style.strokeColor;
        collapsedShape.margin.bottom = 5;
        collapsedShape.style.opacity = node.style.opacity;
        collapsedShape.horizontalAlignment = 'Left';
        collapsedShape.verticalAlignment = 'Bottom';
        collapsedShape.setOffsetWithRespectToBounds(0, 1, 'Fraction');
        collapsedShape.relativeMode = 'Point';
        collapsedShape.data = getBpmnShapePathData('collapsedShape');
        collapsedShape.margin.left = x;
        if (subProcess.collapsed === true && !subProcess.processes) {
            collapsedShape.visible = true;
        }
        else {
            collapsedShape.visible = false;
        }
        if (collapsedShape.visible === true) {
            x += subChildSpace + iconSpace;
        }
        subProcessShapes.children.push(collapsedShape);
        if (subProcess.type === 'Event') {
            subprocessNode.style.strokeWidth = 1;
            subprocessNode.style.strokeDashArray = '2 2';
            events = subProcess.events;
            for (var i = 0; i < events.length; i++) {
                event = events[parseInt(i.toString(), 10)];
                this.getBPMNSubEvent(event, node, subProcessShapes);
            }
        }
        // set loop for subprocess
        subProcessLoopShapes = this.getBPMNSubProcessLoopShape(node);
        if (subChildCount === 1) {
            x = area - 6;
        }
        subProcessLoopShapes.margin.left = x;
        if (subProcessLoopShapes.visible === true) {
            x += subChildSpace + iconSpace;
        }
        subProcessLoopShapes.style.opacity = node.style.opacity;
        subProcessShapes.children.push(subProcessLoopShapes);
        // set boundary for subprocess
        subprocessNode.id = node.id + '_boundary';
        if (subProcess.boundary === 'Default') {
            subprocessNode.style.strokeWidth = 1;
            subprocessNode.style.strokeDashArray = '1 0';
        }
        if (subProcess.boundary === 'Call') {
            subprocessNode.style.strokeWidth = 4;
            subprocessNode.style.strokeDashArray = '1 0';
        }
        if (subProcess.boundary === 'Event') {
            subprocessNode.style.strokeWidth = 1;
            subprocessNode.style.strokeDashArray = '2 2';
        }
        //set adhoc for subprocess
        subprocessAdhoc = this.getBPMNAdhocShape(node, subprocessAdhoc, subProcess);
        if (subChildCount === 1) {
            x = area - 6;
        }
        subprocessAdhoc.margin.left = x;
        if (subprocessAdhoc.visible === true) {
            x += subChildSpace + iconSpace;
        }
        subprocessAdhoc.style.opacity = node.style.opacity;
        subProcessShapes.children.push(subprocessAdhoc);
        //set compensation for subprocess
        var subprocessComp = new PathElement();
        if (subProcess.compensation === true) {
            subprocessComp.visible = true;
        }
        else {
            subprocessComp.visible = false;
        }
        subprocessComp = this.getBPMNCompensationShape(node, subprocessComp);
        if (subChildCount === 1) {
            x = area - 6;
        }
        subprocessComp.margin.left = x;
        if (subprocessComp.visible === true) {
            x += subChildSpace + iconSpace;
        }
        subprocessComp.style.opacity = node.style.opacity;
        subProcessShapes.children.push(subprocessComp);
        //set style for subprocess
        subProcessShapes.style.strokeColor = 'transparent';
        subProcessShapes.style.strokeWidth = 0;
        subProcessShapes.style.fill = 'transparent';
        return subProcessShapes;
    };
    BpmnDiagrams.prototype.getBPMNSubEvent = function (event, node, container, id) {
        container.children = container.children || [];
        //let eventContainer: Canvas;
        var eventContainer = this.getBPMNEventShape(node, event, true, id);
        this.getBPMNSubprocessEvent(node, eventContainer, event);
        eventContainer.id = id || (node.id + '_subprocessEvents');
        eventContainer.width = event.width || 20;
        eventContainer.height = event.height || 20;
        // set offset for subevents
        eventContainer.setOffsetWithRespectToBounds(event.offset.x, event.offset.y, 'Fraction');
        eventContainer.relativeMode = 'Point';
        //set margin for subevents
        eventContainer.margin = event.margin;
        //set alignment for subevents
        eventContainer.horizontalAlignment = event.horizontalAlignment;
        eventContainer.verticalAlignment = event.verticalAlignment;
        // set style for subevent
        eventContainer.style.fill = 'transparent';
        eventContainer.style.strokeColor = 'transparent';
        eventContainer.style.strokeWidth = 0;
        container.children.push(eventContainer);
    };
    BpmnDiagrams.prototype.getBPMNSubProcessTransaction = function (node, shape, container) {
        var shapeWidth = container.children[0].width;
        var shapeHeight = container.children[0].height;
        var innerRect = new DiagramElement();
        innerRect.margin = { left: 3, right: 0, top: 3, bottom: 0 };
        innerRect.id = node.id + '_0_Subprocess_innnerRect';
        innerRect.cornerRadius = 10;
        innerRect.width = shapeWidth - 6;
        //EJ2-824711 - Fill color is not applied properly for BPMN transaction subProcess.
        innerRect.style.fill = 'transparent';
        innerRect.height = shapeHeight - 6;
        container.children.push(innerRect);
        var transactionEvents = new Canvas();
        transactionEvents.id = node.id + '_transaction_events';
        transactionEvents.style.gradient = node.style.gradient;
        var transaction = shape.activity.subProcess.transaction;
        this.getBPMNSubEvent(transaction.success, node, transactionEvents, node.id + '_success');
        this.getBPMNSubEvent(transaction.cancel, node, transactionEvents, node.id + '_cancel');
        this.getBPMNSubEvent(transaction.failure, node, transactionEvents, node.id + '_failure');
        this.updateDiagramContainerVisibility(transactionEvents.children[0], transaction.success.visible);
        this.updateDiagramContainerVisibility(transactionEvents.children[1], transaction.cancel.visible);
        this.updateDiagramContainerVisibility(transactionEvents.children[2], transaction.failure.visible);
        transactionEvents.float = true;
        transactionEvents.width = shapeWidth;
        transactionEvents.height = shapeHeight;
        transactionEvents.style.fill = transactionEvents.style.strokeColor = 'transparent';
        container.children.push(transactionEvents);
    };
    /** @private */
    BpmnDiagrams.prototype.getBPMNSubProcessLoopShape = function (node) {
        var shape = node.shape.activity;
        var loopType;
        var subprocessLoop = new PathElement();
        var subprocessLoopData;
        var subProcess = shape.subProcess;
        // eslint-disable-next-line prefer-const
        loopType = subProcess.loop;
        // eslint-disable-next-line prefer-const
        subprocessLoopData = getBpmnLoopShapePathData(loopType);
        if (loopType !== 'None') {
            subprocessLoop.visible = true;
        }
        else {
            subprocessLoop.visible = false;
        }
        subprocessLoop.id = node.id + '_loop';
        subprocessLoop.data = subprocessLoopData;
        subprocessLoop.style.fill = 'black';
        subprocessLoop.width = 12;
        subprocessLoop.height = 12;
        subprocessLoop.horizontalAlignment = 'Left';
        subprocessLoop.verticalAlignment = 'Bottom';
        subprocessLoop.setOffsetWithRespectToBounds(0, 1, 'Fraction');
        subprocessLoop.relativeMode = 'Point';
        subprocessLoop.margin.bottom = 5;
        subprocessLoop.style.fill = 'transparent';
        subprocessLoop.style.strokeColor = node.style.strokeColor;
        return subprocessLoop;
    };
    /** @private */
    BpmnDiagrams.prototype.drag = function (obj, tx, ty, diagram) {
        var node = diagram.nameTable[(obj).processId];
        if (obj.margin.top + ty >= 0) {
            diagram.nodePropertyChange(obj, {}, { margin: { top: obj.margin.top + ty } });
        }
        if (obj.margin.left + tx >= 0) {
            diagram.nodePropertyChange(obj, {}, { margin: { left: obj.margin.left + tx } });
        }
        //const diffX: number = 0;
        //const diffY: number = 0;
        var bound = this.getChildrenBound(node, obj.id, diagram);
        this.updateSubProcessess(bound, obj, diagram);
        node.wrapper.measure(new Size(undefined, undefined));
        node.wrapper.arrange(node.wrapper.desiredSize);
        diagram.refreshCanvasLayers();
        diagram.updateSelector();
        //909205: The selector updates properly, but the node does not update correctly, so call the updateDiagramObject method.
        diagram.updateDiagramObject(node);
        //941048: The connectors not updates properly on redo, so call the updateConnectorEdges method.
        diagram.updateConnectorEdges(obj);
        this.updateDocks(obj, diagram);
    };
    /** @private */
    BpmnDiagrams.prototype.dropBPMNchild = function (target, source, diagram) {
        if (source && source.shape.type === 'Bpmn' && target.shape.type === 'Bpmn'
            && (!isBlazor() && source.shape.shape !== 'TextAnnotation')) {
            var subProcess = diagram.nameTable[target.id].shape.activity.subProcess;
            if (diagram.currentSymbol && target.shape.type === 'Bpmn' && !subProcess.collapsed) {
                source.processId = target.id;
                return;
            }
            subProcess.processes = subProcess.processes || [];
            if (subProcess.processes && subProcess.processes.indexOf(source.id) === -1 && !subProcess.collapsed) {
                subProcess.processes.push(source.id);
                // To arrange the process based on zIndex, which cause issue in save and load.
                if (subProcess.processes.length > 1) {
                    this.sortProcessOrder(subProcess.processes, diagram);
                }
                var redoElement = cloneObject(source);
                var sources = diagram.nameTable[source.id].wrapper;
                var targetWrapper = diagram.nameTable[target.id].wrapper;
                sources.margin.top = (sources.offsetY - (sources.actualSize.height / 2))
                    - (target.offsetY - (target.actualSize.height / 2));
                sources.margin.left = (sources.offsetX - (sources.actualSize.width / 2))
                    - (target.offsetX - (target.actualSize.width / 2));
                sources.margin.top = (sources.margin.top < 0) ? 0 : sources.margin.top;
                sources.margin.left = (sources.margin.left < 0) ? 0 : sources.margin.left;
                diagram.nameTable[source.id].processId = target.id;
                targetWrapper.children.push(diagram.nameTable[source.id].wrapper);
                //To identify the processess added at runtime.
                //diagram.nameTable[source.id].wrapper.isDroppedProcess = true;
                var bound = this.getChildrenBound(target, source.id, diagram);
                this.updateSubProcessess(bound, source, diagram);
                targetWrapper.measure(new Size(undefined, undefined));
                targetWrapper.arrange(targetWrapper.desiredSize);
                diagram.refreshCanvasLayers();
                diagram.updateSelector();
                // 908136: Node goes behind the subprocess and the connector connected to it is destroyed Issue Fix by commenting these lines
                // let edges: string[] = [];
                // edges = edges.concat((source as Node).outEdges, (source as Node).inEdges);
                // for (let i: number = edges.length - 1; i >= 0; i--) {
                //     if (diagram.bpmnModule.bpmnTextAnnotationConnector.indexOf(diagram.nameTable[edges[parseInt(i.toString(), 10)]])
                //         === -1) {
                //         diagram.remove(diagram.nameTable[edges[parseInt(i.toString(), 10)]]);
                //     }
                // }
                var obj = cloneObject(source);
                var entry = {
                    type: 'PositionChanged', undoObject: { nodes: [redoElement] },
                    redoObject: { nodes: [obj] }, category: 'Internal'
                };
                diagram.addHistoryEntry(entry);
                if (diagram.mode === 'SVG') {
                    if (source.zIndex < target.zIndex) {
                        diagram.updateProcesses(source);
                        this.updateSubprocessNodeIndex(source, diagram, target);
                    } //909204-The node inside the subprocess disappears while grouping
                    var parent_1 = getDiagramElement(target.id + '_groupElement');
                    parent_1.appendChild(getDiagramElement(source.id + '_groupElement'));
                }
                this.updateDocks(source, diagram);
            }
        }
    };
    BpmnDiagrams.prototype.sortProcessOrder = function (processes, diagram) {
        // Sort the process array based on node zIndex
        processes.sort(function (a, b) { return diagram.nameTable["" + a].zIndex - diagram.nameTable["" + b].zIndex; });
    };
    BpmnDiagrams.prototype.updateIndex = function (diagram, source) {
        //let processNode: Node;
        var processNode = source;
        var nodeindex = diagram.getIndex(processNode, processNode.id);
        diagram.nodes.splice(Number(nodeindex), 1);
        processNode.zIndex = diagram.nodes[diagram.nodes.length - 1].zIndex + 1;
        diagram.nodes.push(processNode);
    };
    BpmnDiagrams.prototype.updateSubprocessNodeIndex = function (source, diagram, target) {
        if (source.shape.activity.subProcess.processes
            && source.shape.activity.subProcess.processes.length > 0) {
            for (var i = 0; i < source.shape.activity.subProcess.processes.length; i++) {
                this.updateIndex(diagram, source);
                var processes = source.shape.activity.subProcess.processes[parseInt(i.toString(), 10)];
                if (diagram.nameTable["" + processes].shape.activity.subProcess.processes.length > 0) {
                    this.updateSubprocessNodeIndex(diagram.nameTable["" + processes], diagram, target);
                }
                else {
                    var node = diagram.nameTable[source.shape.activity.subProcess.processes[parseInt(i.toString(), 10)]];
                    this.updateIndex(diagram, node);
                }
            }
        }
        else {
            this.updateIndex(diagram, source);
        }
    };
    /** @private */
    BpmnDiagrams.prototype.updateDocks = function (obj, diagram) {
        if (obj.shape.type === 'Bpmn' && obj.shape.activity.subProcess.processes &&
            !obj.shape.activity.subProcess.collapsed) {
            var processTable = obj.shape.activity.subProcess.processes;
            for (var _i = 0, processTable_1 = processTable; _i < processTable_1.length; _i++) {
                var i = processTable_1[_i];
                var actualObject = diagram.nameTable["" + i];
                if (actualObject) {
                    diagram.updateConnectorEdges(actualObject);
                    actualObject.wrapper.measure(new Size(actualObject.wrapper.width, actualObject.wrapper.height));
                    actualObject.wrapper.arrange(actualObject.wrapper.desiredSize);
                    if (actualObject.shape.activity.subProcess.processes
                        && actualObject.shape.activity.subProcess.processes.length) {
                        this.updateDocks(actualObject, diagram);
                    }
                }
            }
        }
    };
    /** @private */
    BpmnDiagrams.prototype.removeBpmnProcesses = function (currentObj, diagram) {
        var element = diagram.nameTable[currentObj.processId];
        if (currentObj.shape.type === 'Bpmn' && currentObj.shape.activity.subProcess.processes &&
            currentObj.shape.activity.subProcess.processes.length > 0) {
            var processes = currentObj.shape.activity.subProcess.processes;
            for (var j = processes.length - 1; j >= 0; j--) {
                diagram.remove(diagram.nameTable[processes[parseInt(j.toString(), 10)]]);
            }
        }
        if (element) {
            diagram.removeDependentConnector(currentObj);
            var processes = element.shape.activity.subProcess.processes;
            this.removeChildFromBPMN(element.wrapper, currentObj.id, diagram, true);
            var processIndex = processes.indexOf(currentObj.id);
            processes.splice(processIndex, 1);
        }
    };
    /** @private */
    BpmnDiagrams.prototype.removeChildFromBPMN = function (wrapper, name, diagram, isDelete) {
        for (var _i = 0, _a = wrapper.children; _i < _a.length; _i++) {
            var i = _a[_i];
            if (i.id === name) {
                wrapper.children.splice(wrapper.children.indexOf(i), 1);
                if (!isDelete) {
                    // To remove the child node from subprocess to diagram in DOM.
                    this.removeGElement(i.id, diagram);
                }
            }
            else if (i.children) {
                this.removeChildFromBPMN(i, name, diagram, isDelete);
            }
        }
    };
    //Bug 858761: Default Tooltip of sub-process node is not positioned properly after drag and drop the child of subprocess in diagram.
    // To remove the child node from subprocess to diagram in DOM.
    BpmnDiagrams.prototype.removeGElement = function (id, diagram) {
        var element = document.getElementById(id + '_groupElement');
        var diagramLayer = document.getElementById(diagram.element.id + '_diagramLayer');
        var parent = element.parentElement;
        parent.removeChild(element);
        diagramLayer.appendChild(element);
        var node = diagram.nameTable["" + id];
        var subProcess = diagram.nameTable["" + node.processId];
        var beforeIndex = node.zIndex + 1;
        var getNode = this.getNode(beforeIndex, diagram);
        if (getNode.length > 0) {
            var neighborElement_1 = document.getElementById(getNode[0].id + '_groupElement');
            var index = Array.from(diagramLayer.children).findIndex(function (child) { return child === neighborElement_1; });
            var domIndex = index !== -1 ? index : 1;
            // 889550: issue with dragging process nodes of the sub process
            // Remove the adjacent element of the node which z index is lessthan subprocess z index
            if (node.zIndex < subProcess.zIndex) {
                diagramLayer.children[parseInt(domIndex.toString(), 10)].insertAdjacentElement('beforebegin', element);
            }
        }
    };
    BpmnDiagrams.prototype.getNode = function (index, diagram) {
        var getNode = diagram.nodes.filter(function (x) { return x.zIndex === index; });
        if (getNode.length === 0 && index > 0) {
            return this.getNode(index - 1, diagram);
        }
        return getNode;
    };
    /** @private */
    BpmnDiagrams.prototype.removeProcess = function (id, diagram) {
        var node = diagram.nameTable["" + id];
        if (node) {
            var parent_2 = diagram.nameTable[node.processId];
            if (parent_2 && parent_2.shape.type === 'Bpmn') {
                var processes = parent_2.shape.activity.subProcess.processes;
                diagram.removeDependentConnector(node);
                this.removeChildFromBPMN(parent_2.wrapper, id, diagram, true);
                var processIndex = processes.indexOf(id);
                processes.splice(processIndex, 1);
                node.processId = '';
                diagram.refreshDiagramLayer();
                diagram.updateSelector();
            }
        }
    };
    /** @private */
    BpmnDiagrams.prototype.addProcess = function (process, parentId, diagram) {
        //let id: string;
        process.id = process.id || randomId();
        var id = process.id;
        var node = diagram.nameTable["" + id];
        //913821-Adding of process node to expanded subprocess at runtime won't be undoed.
        var undoElement = cloneObject(node);
        if (!node) {
            diagram.add(process);
        }
        process.processId = parentId;
        var parentNode = diagram.nameTable["" + parentId];
        var subProcess = parentNode.shape.activity.subProcess;
        //EJ2-942115-The function addProcess is not working when empty processes are not defined in the subprocess object.
        if (!subProcess.processes) {
            subProcess.processes = [];
        }
        if (node && parentNode && parentNode.shape.type === 'Bpmn' && node.shape.type === 'Bpmn') {
            node.processId = parentId;
            var processes = parentNode.shape.activity.subProcess.processes;
            if (processes.indexOf(id) < 0) {
                processes.push(id);
            }
            parentNode.wrapper.children.push(node.wrapper);
            parentNode.wrapper.measure(new Size());
            parentNode.wrapper.arrange(parentNode.wrapper.desiredSize);
            diagram.bpmnModule.updateDocks(parentNode, diagram);
            diagram.refreshDiagramLayer();
            //913821-Adding of process node to expanded subprocess at runtime won't be undoed
            if (!(diagram.diagramActions & DiagramAction.UndoRedo) && (!diagram.historyManager.currentEntry ||
                diagram.historyManager.currentEntry.type !== 'CollectionChanged')) {
                var obj = cloneObject(node);
                var entry = {
                    type: 'PositionChanged', undoObject: { nodes: [undoElement] },
                    redoObject: { nodes: [obj] }, category: 'Internal'
                };
                diagram.addHistoryEntry(entry);
            }
            if (diagram.mode === 'SVG' && (node.shape && node.shape.activity
                && !node.shape.activity.subProcess.processes)) {
                var child = getDiagramElement(parentId + '_groupElement');
                child.appendChild(getDiagramElement(process.id + '_groupElement'));
            }
        }
    };
    /** @private */
    BpmnDiagrams.prototype.getChildrenBound = function (node, excludeChild, diagram) {
        var processes = node.shape.activity.subProcess.processes;
        var bound;
        if (processes && processes.length) {
            for (var _i = 0, processes_1 = processes; _i < processes_1.length; _i++) {
                var i = processes_1[_i];
                if (excludeChild !== i) {
                    if (!bound) {
                        bound = diagram.nameTable["" + i].wrapper.bounds;
                    }
                    else {
                        bound = diagram.nameTable["" + i].wrapper.bounds.uniteRect(bound);
                    }
                }
            }
        }
        return bound || diagram.nameTable["" + excludeChild].wrapper.bounds;
    };
    /** @private */
    BpmnDiagrams.prototype.updateSubProcessess = function (bound, obj, diagram) {
        var diffX;
        var diffY;
        var node = diagram.nameTable[obj.processId];
        var right;
        var bottom;
        var pivot = { x: 0.5, y: 0.5 };
        if ((node.wrapper.bounds.left + obj.margin.left + obj.width) > (node.wrapper.bounds.right)) {
            right = true;
        }
        if ((node.wrapper.bounds.top + obj.margin.top + obj.height) > (node.wrapper.bounds.bottom)) {
            bottom = true;
        }
        if (right) {
            pivot.x = 0;
        }
        if (bottom) {
            pivot.y = 0;
        }
        var actualSize = node.wrapper.actualSize;
        if (right) {
            diffX = (obj.wrapper.margin.left + obj.wrapper.bounds.width) / actualSize.width;
        }
        if (bottom) {
            diffY = (obj.wrapper.margin.top + obj.wrapper.bounds.height) / actualSize.height;
        }
        if (diffX > 0 || diffY > 0) {
            diagram.commandHandler.scale(diagram.nameTable[obj.processId], diffX || 1, diffY || 1, pivot);
        }
    };
    /** @private */
    BpmnDiagrams.prototype.getBPMNCompensationShape = function (node, compensationNode) {
        compensationNode.id = node.id + '_0_compensation';
        compensationNode.width = 12;
        compensationNode.height = 12;
        compensationNode.margin.bottom = 5;
        compensationNode.style.fill = 'transparent';
        compensationNode.style.strokeColor = node.style.strokeColor;
        compensationNode.horizontalAlignment = 'Left';
        compensationNode.verticalAlignment = 'Bottom';
        compensationNode.relativeMode = 'Object';
        compensationNode.data = 'M 22.462 18.754 l -6.79 3.92 l 6.79 3.92 V 22.89 l 6.415 3.705 v -7.841 l -6.415 3.705 V 18.754 Z' +
            ' M 28.331 19.701 v 5.947 l -5.149 -2.973 L 28.331 19.701 Z M 21.916 25.647 l -5.15 -2.973 l 5.15 -2.973 V 25.647 Z' +
            ' M 22.275 12.674 c -5.513 0 -9.999 4.486 -9.999 9.999 c 0 5.514 4.486 10.001 9.999 10.001' +
            ' c 5.514 0 9.999 -4.486 9.999 -10.001 C 32.274 17.16 27.789 12.674 22.275 12.674 Z M 22.275 32.127 ' +
            ' c -5.212 0 -9.453 -4.241 -9.453 -9.454 c 0 -5.212 4.241 -9.453 9.453 -9.453 c 5.212 0 9.453 4.241 9.453 9.453' +
            ' C 31.728 27.887 27.487 32.127 22.275 32.127 Z';
        return compensationNode;
    };
    /** @private */
    BpmnDiagrams.prototype.getBPMNActivityShape = function (node) {
        var eventshape = new Canvas();
        var content;
        var shape = node.shape.activity;
        var task = shape.activity;
        var subProcess = shape.subProcess;
        var activityType = shape.activity;
        if (task === 'Task') {
            content = this.getBPMNTaskShape(node);
        }
        if (task === 'SubProcess' && subProcess) {
            content = this.getBPMNSubProcessShape(node);
        }
        content.id = task + node.id;
        eventshape.children = [content];
        eventshape.style.fill = 'transparent';
        eventshape.style.strokeColor = 'transparent';
        eventshape.style.strokeWidth = 0;
        return eventshape;
    };
    /** @private */
    BpmnDiagrams.prototype.getBPMNSubprocessEvent = function (node, subProcessEventsShapes, events) {
        var annotations;
        var ports;
        if (events.annotations.length !== 0) {
            for (var i = 0; i < events.annotations.length; i++) {
                var annot = events.annotations[parseInt(i.toString(), 10)];
                annotations = node.initAnnotationWrapper(annot);
                annotations.width = events.width;
                annotations.height = events.height;
                subProcessEventsShapes.children.push(annotations);
            }
        }
        if (events.ports.length !== 0) {
            for (var i = 0; i < events.ports.length; i++) {
                var port = events.ports[parseInt(i.toString(), 10)];
                ports = node.initPortWrapper(port);
                subProcessEventsShapes.children.push(ports);
            }
        }
    };
    /** @private */
    BpmnDiagrams.prototype.getBPMNAdhocShape = function (node, adhocNode, subProcess) {
        adhocNode.id = node.id + '_0_adhoc';
        adhocNode.width = 12;
        adhocNode.height = 8;
        adhocNode.style.fill = 'black';
        adhocNode.style.strokeColor = node.style.strokeColor;
        adhocNode.margin.bottom = 5;
        adhocNode.horizontalAlignment = 'Left';
        adhocNode.verticalAlignment = 'Bottom';
        adhocNode.relativeMode = 'Object';
        adhocNode.data = 'M 49.832 76.811 v -2.906 c 0 0 0.466 -1.469 1.931 -1.5 c 1.465 -0.031 2.331 1.219 2.897 1.688 ' +
            's 1.06 0.75 1.526 0.75 c 0.466 0 1.548 -0.521 1.682 -1.208 s 0.083 3.083 0.083 3.083 s -0.76 0.969 -1.859 0.969 ' +
            'c -1.066 0 -1.865 -0.625 -2.464 -1.438 s -1.359 -0.998 -2.064 -0.906 C 50.598 75.467 49.832 76.811 49.832 76.811 Z';
        if (subProcess && subProcess.adhoc === true) {
            adhocNode.visible = true;
        }
        else {
            adhocNode.visible = false;
        }
        return adhocNode;
    };
    // /** @private */
    // public getTextAnnotationWrapper(node: NodeModel, id: string): TextElement {
    //     if (node && node.shape.type === 'Bpmn') {
    //         const shape: BpmnShapes = (node.shape as BpmnShape).shape;
    //         if (shape === 'TextAnnotation') {
    //             return node.wrapper.children[1] as TextElement;
    //         }
    //     }
    //     return null;
    // }
    /**
     *
     * @private
     * To modify the text annotation path while dragging the node and set port offset based on dragging.
     */
    BpmnDiagrams.prototype.setAnnotationPath = function (sourceBounds, wrapper, node, bpmnShape, direction, diagram) {
        var pathElement = new PathElement();
        pathElement.id = wrapper.id + '_path';
        pathElement.width = node.width;
        pathElement.height = node.height;
        pathElement.style.fill = 'transparent';
        pathElement.style.strokeColor = ((node.style.strokeColor === 'transparent') ? 'black' : node.style.strokeColor);
        pathElement.style.opacity = node.style.opacity;
        pathElement.relativeMode = 'Object';
        pathElement.horizontalAlignment = 'Stretch';
        pathElement.verticalAlignment = 'Stretch';
        var pointPort = (node.ports.length > 0) ? node.ports[0] : new PointPort(node, 'ports', '', true);
        diagram.protectPropertyChange(true);
        node.ports = [pointPort];
        diagram.protectPropertyChange(false);
        switch (direction) {
            case 'Left':
                pathElement.data = 'M10,20 L0,20 L0,0 L10,0';
                pathElement.width = 10;
                pathElement.horizontalAlignment = 'Left';
                pointPort.offset = { x: 0.0, y: 0.5 };
                break;
            case 'Right':
                pathElement.data = 'M0,0 L10,0 L10,20 L0,20';
                pathElement.width = 10;
                pathElement.horizontalAlignment = 'Right';
                pointPort.offset =
                    {
                        x: 1.0,
                        y: 0.5
                    };
                break;
            case 'Top':
                pathElement.data = 'M20,10 L20,0 L0,0 L0,10';
                pathElement.height = 10.0;
                pathElement.verticalAlignment = 'Top';
                pointPort.offset =
                    {
                        x: 0.5,
                        y: 0.0
                    };
                break;
            case 'Bottom':
                pathElement.data = 'M0,0 L0,10 L20,10 L20,0';
                pathElement.height = 10;
                pathElement.verticalAlignment = 'Bottom';
                pointPort.offset =
                    {
                        x: 0.5,
                        y: 1.0
                    };
                break;
            default:
                //To check the text annotation has parent and update the path element.
                if (bpmnShape.textAnnotation.textAnnotationTarget !== '') {
                    if (diagram.nameTable[bpmnShape.textAnnotation.textAnnotationTarget]) {
                        var node2 = diagram.nameTable[bpmnShape.textAnnotation.textAnnotationTarget];
                        node2.hasTextAnnotation = true;
                        var wrapper2 = node2.wrapper;
                        if (wrapper2 !== null) {
                            var doubleValue = node2.width;
                            var doubleValue2 = node2.height;
                            var targetBounds = new Rect(0.0, 0.0, 0.0, 0.0);
                            if (doubleValue !== 0.0 && doubleValue2 !== 0.0) {
                                targetBounds = new Rect(node2.offsetX - doubleValue / 2, node2.offsetY - doubleValue2 / 2, doubleValue, doubleValue2);
                            }
                            this.setAnnotationPosition(targetBounds, node, sourceBounds, pathElement);
                        }
                    }
                }
                else if (bpmnShape.textAnnotation.textAnnotationTarget === '') {
                    pathElement.data = 'M10,20 L0,20 L0,0 L10,0';
                    pathElement.width = 10.0;
                    pathElement.horizontalAlignment = 'Left';
                    pointPort.offset = {
                        x: 0.0,
                        y: 0.5
                    };
                }
                break;
        }
        wrapper.children = [];
        wrapper.children.push(pathElement);
    };
    //Task 866412: Should revamp BPMN text annotation node. To modifty the port offset and annotation path based on node bounds while dragging.
    BpmnDiagrams.prototype.setAnnotationPosition = function (targetBounds, annotation, annotationBounds, annotationPath) {
        var pointPort = annotation.ports[0];
        var position = { x: annotationBounds.x, y: annotationBounds.y };
        var rotateAngle = this.getAnnotationPathAngle(position, targetBounds);
        if (rotateAngle === 90) {
            annotationPath.data = 'M20,10 L20,0 L0,0 L0,10';
            annotationPath.height = 10.0;
            annotationPath.verticalAlignment = 'Top';
            pointPort.offset =
                {
                    x: 0.5,
                    y: 0.0
                };
        }
        else if (rotateAngle === 180) {
            annotationPath.data = 'M0,0 L10,0 L10,20 L0,20';
            annotationPath.width = 10.0;
            annotationPath.horizontalAlignment = 'Right';
            pointPort.offset =
                {
                    x: 1.0,
                    y: 0.5
                };
        }
        else if (rotateAngle === 0) {
            annotationPath.data = 'M10,20 L0,20 L0,0 L10,0';
            annotationPath.width = 10.0;
            annotationPath.horizontalAlignment = 'Left';
            pointPort.offset =
                {
                    x: 0.0,
                    y: 0.5
                };
        }
        else {
            annotationPath.data = 'M0,0 L0,10 L20,10 L20,0';
            annotationPath.height = 10.0;
            annotationPath.verticalAlignment = 'Bottom';
            pointPort.offset =
                {
                    x: 0.5,
                    y: 1.0
                };
        }
    };
    // /** @private */
    // public findInteractableObject(obj: ConnectorModel, diagram: Diagram): NodeModel | ConnectorModel {
    //     if (obj.targetID) {
    //         let targetNode: NodeModel = diagram.nameTable[obj.targetID];
    //         if (targetNode.shape.type === 'Bpmn' && (targetNode.shape as BpmnShape).shape === 'TextAnnotation') {
    //             return targetNode;
    //         }
    //     }
    //     return obj;
    // }
    /** @private */
    BpmnDiagrams.prototype.getSubprocessChildCount = function (node) {
        var count = 0;
        var shape = node.shape.activity;
        //let loopType: string;
        var subProcess = shape.subProcess;
        var loopType = subProcess.loop;
        if (loopType !== undefined && loopType !== 'None') {
            count++;
        }
        if ((subProcess.compensation !== undefined) &&
            subProcess.compensation === true) {
            count++;
        }
        if ((subProcess.collapsed !== undefined) &&
            subProcess.collapsed === true) {
            count++;
        }
        if ((subProcess.adhoc !== undefined) &&
            subProcess.adhoc === true) {
            count++;
        }
        return count;
    };
    /** @private */
    BpmnDiagrams.prototype.getTaskChildCount = function (node) {
        var count = 0;
        var shape = node.shape.activity;
        var task = shape.task;
        if ((task.compensation !== undefined) &&
            task.compensation === true) {
            count++;
        }
        if ((task.loop !== undefined) &&
            task.loop !== 'None') {
            count++;
        }
        return count;
    };
    /** @private */
    BpmnDiagrams.prototype.setStyle = function (child, node) {
        //set style
        child.style.fill = node.style.fill;
        child.style.strokeColor = node.style.strokeColor;
        child.style.strokeWidth = node.style.strokeWidth;
        child.style.strokeDashArray = node.style.strokeDashArray;
        child.style.opacity = node.style.opacity;
        child.style.gradient = node.style.gradient;
        //941052: Issue with visible property doesn't hide shadows
        if ((node.constraints & NodeConstraints.Shadow) !== 0 && node.visible) {
            child.shadow = node.shadow;
        }
    };
    //End code conversion region
    //Update BPMN Shapes on NodePropertyChange
    //Start region
    /** @private */
    BpmnDiagrams.prototype.updateBPMN = function (changedProp, oldObject, actualObject, diagram) {
        var newShape = changedProp.shape || {};
        var elementWrapper = actualObject.wrapper.children[0];
        var actualShape = actualObject.shape.shape ||
            (actualObject.shape.bpmnShape);
        //Bug 892767: Unable to update BPMN text annotation direction dynamically
        //To update the text annotation direction and target dynamically.
        if (newShape.textAnnotation && actualShape === 'TextAnnotation') {
            if (newShape.textAnnotation.textAnnotationDirection !== undefined) {
                //Modify text annotation path based on text annotation direction
                this.setAnnotationPath(actualObject.wrapper.bounds, actualObject.wrapper.children[0], actualObject, actualObject.shape, actualObject.shape.textAnnotation.textAnnotationDirection, diagram);
                //Reset the id of path element
                actualObject.wrapper.children[0].children[0].id = actualObject.id + '_textannotation_path';
                var newValue = { ports: { 0: { offset: actualObject.ports[0].offset } } };
                diagram.nodePropertyChange(actualObject, {}, newValue);
            }
            if (newShape.textAnnotation.textAnnotationTarget !== undefined) {
                var sourceNode = diagram.nameTable[newShape.textAnnotation.textAnnotationTarget];
                if (sourceNode && sourceNode.shape.type === 'Bpmn') {
                    var textAnnotationConnector = diagram.nameTable[actualObject.inEdges[0]];
                    if (textAnnotationConnector) {
                        //To modify the sourceID of text annotation connector
                        textAnnotationConnector.sourceID = sourceNode.id;
                        diagram.connectorPropertyChange(textAnnotationConnector, {}, { sourceID: sourceNode.id });
                    }
                }
                else if (newShape.textAnnotation.textAnnotationTarget === '') {
                    var textAnnotationConnector = diagram.nameTable[actualObject.inEdges[0]];
                    if (textAnnotationConnector) {
                        var oldParent = diagram.nameTable[oldObject.shape.textAnnotation.textAnnotationTarget];
                        var index = oldParent.outEdges.indexOf(textAnnotationConnector.id);
                        oldParent.outEdges.splice(index, 1);
                        textAnnotationConnector.sourceID = '';
                        diagram.connectorPropertyChange(textAnnotationConnector, {}, { sourceID: '' });
                    }
                }
            }
        }
        var sizeChanged = changedProp.width !== undefined || changedProp.height !== undefined;
        if ((newShape.shape === 'Gateway') &&
            newShape.gateway) {
            this.removeBPMNElementFromDOM(actualObject, diagram);
            actualObject.wrapper.children[0] = this.getBPMNGatewayShape(actualObject);
        }
        else if ((newShape.shape === 'DataObject') &&
            newShape.dataObject) {
            this.removeBPMNElementFromDOM(actualObject, diagram);
            actualObject.wrapper.children[0] = this.getBPMNDataObjectShape(actualObject);
        }
        else if ((newShape.shape === 'Activity') &&
            newShape.activity) {
            this.removeBPMNElementFromDOM(actualObject, diagram);
            actualObject.wrapper.children[0] = this.getBPMNActivityShape(actualObject);
        }
        /**
         * EJ2-EJ2-60644 - Bpmn event fill color does not applied while changing event in runtime.
         */
        else if (((actualObject.shape.bpmnShape === 'Event' || actualObject.shape.shape === 'Event') || newShape.shape === 'Event') &&
            newShape.event) {
            this.removeBPMNElementFromDOM(actualObject, diagram);
            var shapeEvent = newShape.event;
            actualObject.wrapper.children[0] = this.getBPMNEventShape(actualObject, shapeEvent);
        }
        else if ((newShape.shape === 'Message') ||
            (newShape.shape === 'DataSource')) {
            this.removeBPMNElementFromDOM(actualObject, diagram);
            actualObject.wrapper.children[0] = this.getBPMNShapes(actualObject);
            //}
            // else if (newShape.shape === 'Group') {
            //     actualObject.wrapper.children[0] = this.getBPMNGroup(actualObject, diagram);
        }
        else if (newShape.gateway !== undefined || (actualShape === 'Gateway' && sizeChanged)) {
            this.updateBPMNGateway(actualObject, changedProp);
        }
        else if (newShape.dataObject !== undefined || (actualShape === 'DataObject' && sizeChanged)) {
            this.updateBPMNDataObject(actualObject, changedProp, oldObject);
        }
        else if (newShape.activity !== undefined || (actualShape === 'Activity' && sizeChanged)) {
            this.updateBPMNActivity(actualObject, changedProp, oldObject, diagram);
        }
        else if (newShape.event !== undefined || (actualShape === 'Event' && sizeChanged)) {
            this.updateBPMNEvent(actualObject, changedProp, oldObject);
        }
        actualObject.wrapper.children[0].id = actualObject.wrapper.children[0].id || elementWrapper.id;
        if (changedProp.style) {
            //941045: update styles for bpmn group shape
            var containerChild = elementWrapper;
            if (elementWrapper instanceof Container) {
                if (!isBlazor() && actualObject.shape.shape === 'Activity') {
                    containerChild = elementWrapper.children[0].children[0];
                }
                else if (!isBlazor() && actualObject.shape.shape === 'Group') {
                    containerChild = elementWrapper;
                }
                else {
                    containerChild = elementWrapper.children[0];
                }
            }
            updateStyle(changedProp.style, containerChild);
            if (changedProp.style && changedProp.style.strokeColor) {
                //EJ2-844052-BPMN nodes styles are not updated properly at runtime
                if (elementWrapper && elementWrapper.children !== undefined
                    && elementWrapper.children.length > 0) {
                    if (((!isBlazor() && actualObject.shape.shape === 'Activity')) &&
                        actualObject.shape.activity.activity === 'SubProcess') {
                        var child = elementWrapper.children[0];
                        this.updateBPMNStyle(child, changedProp.style.strokeColor);
                    }
                    else if (((!isBlazor() && actualObject.shape.shape === 'Gateway')) ||
                        ((!isBlazor() && actualObject.shape.shape === 'Event'))) {
                        this.updateBPMNStyle(elementWrapper, changedProp.style.strokeColor);
                    }
                }
            }
            if (changedProp.style && changedProp.style.opacity !== undefined) {
                this.updateBpmnChildOpacity(actualObject.wrapper, changedProp.style.opacity);
            }
        }
    };
    // To update the opacity of BPMN child
    BpmnDiagrams.prototype.updateBpmnChildOpacity = function (wrapper, opacity) {
        if (wrapper.children && wrapper.children.length > 0) {
            for (var i = 0; i < wrapper.children.length; i++) {
                var child = wrapper.children[parseInt(i.toString(), 10)];
                if (child.children) {
                    this.updateBpmnChildOpacity(child, opacity);
                }
                if (!(child instanceof TextElement)) {
                    child.style.opacity = opacity;
                }
            }
        }
    };
    /**
     * EJ2-60574 -BPMN shape do not get changed at runtime properly
     */
    BpmnDiagrams.prototype.removeBPMNElementFromDOM = function (actualObject, diagram) {
        for (var _i = 0, _a = diagram.views; _i < _a.length; _i++) {
            var elementId = _a[_i];
            removeElement(actualObject.id + '_groupElement', elementId);
        }
    };
    /** @private */
    BpmnDiagrams.prototype.updateBPMNStyle = function (elementWrapper, changedProp) {
        for (var i = 0; i < elementWrapper.children.length; i++) {
            var child = elementWrapper.children[parseInt(i.toString(), 10)];
            updateStyle({ strokeColor: changedProp }, child);
        }
    };
    /** @private */
    BpmnDiagrams.prototype.updateBPMNGateway = function (node, changedProp) {
        var bpmnShape = node.shape;
        var elementWrapper = node.wrapper.children[0];
        if (bpmnShape) {
            updateStyle(node.style, elementWrapper.children[0]);
            var pathData = getBpmnGatewayShapePathData(bpmnShape.gateway.type);
            var dataobjTypeNode = this.updateGatewaySubType(elementWrapper, node, pathData);
            // EJ2-912371-BpmnGateway -- BPMN gateway shape runtime change is not properly rendered
            var gatewayType = bpmnShape.gateway.type;
            if (gatewayType === 'None' || gatewayType === 'EventBased' || gatewayType === 'ExclusiveEventBased' || gatewayType === 'ParallelEventBased') {
                dataobjTypeNode.style.fill = 'white';
            }
            else {
                dataobjTypeNode.style.fill = 'black';
            }
            removeElement(elementWrapper.children[1].id);
            elementWrapper.children.splice(1, 1);
            elementWrapper.children.push(dataobjTypeNode);
        }
        if (changedProp.width !== undefined || changedProp.height !== undefined) {
            this.setSizeForBPMNGateway(node.shape.gateway, elementWrapper, changedProp.width || node.width, changedProp.height || node.height);
        }
    };
    /**
     * Used to update Bpmn gateway child in runtime
     * EJ2-60581
     * @param elementWrapper
     * @param node
     * @param pathData
     * @returns
     */
    BpmnDiagrams.prototype.updateGatewaySubType = function (elementWrapper, node, pathData) {
        var dataobjTypeNode = new PathElement();
        dataobjTypeNode.id = node.id + '_1_gatewayType';
        dataobjTypeNode.width = elementWrapper.children[1].width;
        dataobjTypeNode.height = elementWrapper.children[1].height;
        dataobjTypeNode.margin.left = elementWrapper.children[1].margin.left;
        dataobjTypeNode.margin.top = elementWrapper.children[1].margin.top;
        dataobjTypeNode.data = pathData;
        dataobjTypeNode.offsetX = elementWrapper.children[1].offsetX;
        dataobjTypeNode.offsetY = elementWrapper.children[1].offsetY;
        dataobjTypeNode.style = elementWrapper.children[1].style;
        dataobjTypeNode.horizontalAlignment = elementWrapper.children[1].horizontalAlignment;
        dataobjTypeNode.verticalAlignment = elementWrapper.children[1].verticalAlignment;
        dataobjTypeNode.relativeMode = elementWrapper.children[1].relativeMode;
        dataobjTypeNode.transform = elementWrapper.children[1].transform;
        return dataobjTypeNode;
    };
    /** @private */
    BpmnDiagrams.prototype.updateBPMNDataObject = function (node, newObject, oldObject) {
        var bpmnShape = newObject.shape;
        var elementWrapper = node.wrapper.children[0];
        if (bpmnShape) {
            var elementWrapperChild1 = elementWrapper.children[1];
            var elementWrapperChild2 = elementWrapper.children[2];
            if (newObject.style !== undefined) {
                updateStyle(newObject.style, elementWrapper.children[0]);
                elementWrapperChild1.style.opacity = node.style.opacity;
                elementWrapperChild2.style.opacity = node.style.opacity;
            }
            if (bpmnShape.dataObject) {
                switch (bpmnShape.dataObject.type) {
                    case 'None':
                        elementWrapperChild1.visible = false;
                        break;
                    case 'Input':
                        elementWrapperChild1.style.fill = 'white';
                        break;
                    case 'Output':
                        elementWrapperChild1.style.fill = 'black';
                        break;
                }
                if (oldObject.shape.dataObject.type === 'None') {
                    elementWrapperChild1.visible = true;
                }
                if (newObject.shape.dataObject.collection !== undefined) {
                    elementWrapperChild2.visible = bpmnShape.dataObject.collection;
                }
            }
        }
        if (newObject.width !== undefined || newObject.height !== undefined) {
            this.setSizeForBPMNDataObjects(node.shape.dataObject, elementWrapper, newObject.width || node.width, newObject.height || node.height);
        }
    };
    /** @private */
    BpmnDiagrams.prototype.getEvent = function (node, oldObject, event, child0, child1, child2) {
        switch (event) {
            case 'Start':
                child1.visible = false;
                child0.style.strokeDashArray = '';
                child2.style.fill = 'white';
                child2.style.strokeColor = 'black';
                child0.style.fill = 'white';
                break;
            case 'NonInterruptingStart':
                child0.style.strokeDashArray = '2 3';
                child2.style.fill = 'white';
                child0.style.fill = 'white';
                child2.style.strokeColor = 'black';
                child1.visible = false;
                break;
            case 'Intermediate':
                child0.style.strokeDashArray = '';
                child0.style.fill = 'white';
                child1.style.strokeDashArray = '';
                child0.style.gradient = null;
                child2.style.fill = 'white';
                child2.style.strokeColor = 'black';
                this.updateEventVisibility(oldObject, child1);
                break;
            case 'NonInterruptingIntermediate':
                child0.style.fill = 'white';
                child0.style.gradient = null;
                child2.style.fill = 'white';
                child2.style.strokeColor = 'black';
                child0.style.strokeDashArray = '2 3';
                child1.style.strokeDashArray = '2 3';
                this.updateEventVisibility(oldObject, child1);
                break;
            case 'ThrowingIntermediate':
            case 'End':
                child0.style.fill = event !== 'End' ? 'white' : 'black';
                child0.style.strokeDashArray = '';
                child1.style.strokeDashArray = '';
                child0.style.gradient = null;
                child2.style.fill = 'black';
                this.updateEventVisibility(oldObject, child1);
                // child2.style.strokeColor = node.style.fill;
                break;
        }
    };
    /** @private */
    BpmnDiagrams.prototype.updateEventVisibility = function (oldObject, child1) {
        if (oldObject.shape.activity && oldObject.shape.activity.subProcess &&
            oldObject.shape.activity.subProcess.events &&
            oldObject.shape.activity.subProcess.events[0] !== undefined &&
            oldObject.shape.activity.subProcess.events[0].event !== undefined) {
            if (oldObject.shape.activity.subProcess.events[0].event === 'NonInterruptingStart' ||
                oldObject.shape.activity.subProcess.events[0].event === 'Start') {
                child1.visible = true;
            }
        }
        // 922925 - Start event node doesnot change at run time for the transaction Subprocess event that has the event start
        else if (oldObject.shape.activity &&
            oldObject.shape.activity.subProcess &&
            oldObject.shape.activity.subProcess.transaction) {
            var subProcessTransaction_1 = oldObject.shape.activity.subProcess.transaction;
            var isEventStart_1 = function (event) {
                return event === 'Start' || event === 'NonInterruptingStart';
            };
            var validKeys = ['success', 'failure', 'cancel'];
            var hasStartEvent = validKeys.some(function (key) {
                var transactionEvent = subProcessTransaction_1['' + key];
                return transactionEvent ? isEventStart_1(transactionEvent.event) : false;
            });
            child1.visible = hasStartEvent || child1.visible;
        }
        else if (oldObject.shape.event !== undefined) {
            if (oldObject.shape.event.event === 'NonInterruptingStart' ||
                oldObject.shape.event.event === 'Start') {
                child1.visible = true;
            }
        }
    };
    /** @private */
    BpmnDiagrams.prototype.updateBPMNEvent = function (node, newObject, oldObject) {
        var bpmnShape = newObject.shape;
        var trigger;
        var elementWrapper = node.wrapper.children[0];
        // if (bpmnShape) {
        //     const elementWrapperChild0: DiagramElement = elementWrapper.children[0];
        //     const elementWrapperChild1: DiagramElement = elementWrapper.children[1];
        //     const elementWrapperChild2: DiagramElement = elementWrapper.children[2];
        //     //let event: string;
        //     if (newObject.style !== undefined) {
        //         updateStyle(node.style, elementWrapper.children[0]);
        //         if (newObject.style.opacity !== undefined || newObject.style.strokeColor !== undefined) {
        //             elementWrapperChild1.style.opacity = node.style.opacity;
        //             elementWrapperChild1.style.strokeColor = node.style.strokeColor;
        //         }
        //     }
        //     const event: string = bpmnShape.event.event;
        //     trigger = bpmnShape.event.trigger;
        //     if (event !== undefined) {
        //         this.getEvent(node, oldObject, event, elementWrapperChild0, elementWrapperChild1, elementWrapperChild2);
        //     }
        //     if (trigger !== undefined) {
        //         this.updateBPMNEventTrigger(node, newObject);
        //     }
        // }
        if (newObject.width !== undefined || newObject.height !== undefined || trigger !== undefined) {
            this.setSizeForBPMNEvents(node.shape.event, elementWrapper, newObject.width || node.width, newObject.height || node.height);
        }
    };
    // /** @private */
    // public updateBPMNEventTrigger(node: Node, newObject: Node): void {
    //     const bpmnShape: BpmnShapeModel = node.shape as BpmnShapeModel;
    //     const elementWrapper: DiagramElement = (node.wrapper.children[0] as Canvas).children[2];
    //     (elementWrapper as PathElement).canMeasurePath = true;
    //     if (newObject.style &&
    //         (newObject.style.strokeColor !== undefined || newObject.style.opacity !== undefined)) {
    //         updateStyle(node.style, elementWrapper);
    //     }
    //     const bpmnshapeTriggerdata: string = getBpmnTriggerShapePathData(
    //         bpmnShape.event.trigger);
    //     (elementWrapper as PathModel).data = bpmnshapeTriggerdata;
    // }
    /** @private */
    BpmnDiagrams.prototype.updateBPMNActivity = function (node, newObject, oldObject, diagram) {
        var bpmnShape = newObject.shape;
        var elementWrapper = node.wrapper.children[0];
        if (elementWrapper && elementWrapper.children && elementWrapper.children.length > 0 && elementWrapper.children[0]) {
            var size = this.getSize(node, elementWrapper.children[0].children[0]);
            if (bpmnShape) {
                var oldProp = oldObject.shape.activity.activity;
                var actualObjectProp = node.shape.activity.activity;
                if ((oldProp === 'SubProcess' || oldProp === 'Task') && (actualObjectProp === 'SubProcess' || actualObjectProp === 'Task')) {
                    diagram.removeElements(node);
                    node.wrapper.children[0] = this.getBPMNActivityShape(node);
                }
                else {
                    if (actualObjectProp === 'Task' && bpmnShape.activity.task !== undefined) {
                        this.updateBPMNActivityTask(node, newObject);
                        var subChildCount = this.getTaskChildCount(node);
                        var x = void 0;
                        var childSpace = subChildCount * 12;
                        var area = size.width / 2 - childSpace;
                        if (subChildCount === 1) {
                            x = area + 8;
                        }
                        else {
                            x = area + (subChildCount - 1) * 8;
                        }
                        if (bpmnShape.activity.task.loop !== undefined) {
                            this.updateBPMNActivityTaskLoop(node, newObject, x, subChildCount, area, 2);
                        }
                    }
                    if (actualObjectProp === 'SubProcess' && bpmnShape.activity.subProcess !== undefined) {
                        this.updateBPMNActivitySubProcess(node, newObject, oldObject, diagram);
                    }
                }
                this.setSizeForBPMNActivity(node.shape.activity, elementWrapper, newObject.width || size.width, newObject.height || size.height, node);
            }
            if (newObject.width !== undefined || newObject.height !== undefined) {
                this.setSizeForBPMNActivity(node.shape.activity, elementWrapper, newObject.width || size.width, newObject.height || size.height, node);
            }
        }
    };
    /** @private */
    BpmnDiagrams.prototype.updateBPMNActivityTask = function (node, newObject) {
        var bpmnShape = newObject.shape;
        var elementWrapper = node.wrapper.children[0].children[0];
        var task = bpmnShape.activity.task;
        for (var i = 0; i < elementWrapper.children.length; i++) {
            //EJ2-907764-Changing Loop for Activity node with task type, result in change in task type symbols
            if (elementWrapper.children[parseInt(i.toString(), 10)].id === node.id + '_2_loop') {
                var element = document.getElementById(node.id + '_2_loop');
                element.parentNode.removeChild(element);
            }
        }
        if (task.type !== undefined) {
            task.type = task.type || 'None';
            var bpmnshapeTaskdata = getBpmnTaskShapePathData(task.type);
            elementWrapper.children[1].data = bpmnshapeTaskdata;
            for (var i = 0; i < elementWrapper.children.length; i++) {
                if (elementWrapper.children[parseInt(i.toString(), 10)].id === node.id + '_1_tasktType') {
                    elementWrapper.children.splice(i, 1);
                    var element = document.getElementById(node.id + '_1_tasktType');
                    element.parentNode.removeChild(element);
                }
                //EJ2-907764-Changing Loop for Activity node with task type, result in change in task type symbols
                if (elementWrapper.children[parseInt(i.toString(), 10)].id === node.id + '_1_taskTypeService') {
                    elementWrapper.children.splice(i, 1);
                    var element = document.getElementById(node.id + '_1_taskTypeService');
                    element.parentNode.removeChild(element);
                }
            }
            var taskTypeNode = new PathElement();
            taskTypeNode.id = node.id + '_1_tasktType';
            taskTypeNode.margin.left = 5;
            taskTypeNode.margin.top = 5;
            taskTypeNode.data = bpmnshapeTaskdata;
            taskTypeNode.style.fill = 'transparent';
            taskTypeNode.style.opacity = node.style.opacity;
            /**
             * Used to update the Bpmn activity task type at runtime
             * EJ2-60586
             */
            if (task.type === 'Receive' || task.type === 'Send') {
                taskTypeNode.width = 18;
                taskTypeNode.height = 16;
                if (task.type === 'Send') {
                    taskTypeNode.style.fill = 'black';
                }
                elementWrapper.children.splice(1, 0, taskTypeNode);
            }
            else if (task.type === 'Manual') {
                taskTypeNode.width = 16;
                taskTypeNode.height = 11;
                elementWrapper.children.splice(1, 0, taskTypeNode);
            }
            else if (task.type !== 'Service') {
                taskTypeNode.width = 20;
                taskTypeNode.height = 20;
                elementWrapper.children.splice(1, 0, taskTypeNode);
            }
            else {
                taskTypeNode.width = 20;
                taskTypeNode.height = 20;
                elementWrapper.children.splice(1, 0, taskTypeNode);
                var taskTypeNodeService = new PathElement();
                taskTypeNodeService.id = node.id + '_1_taskTypeService';
                taskTypeNodeService.data = bpmnshapeTaskdata;
                taskTypeNodeService.margin.left = elementWrapper.children[1].margin.left + 9;
                taskTypeNodeService.margin.top = elementWrapper.children[1].margin.top + 9;
                taskTypeNodeService.style.fill = 'white';
                taskTypeNodeService.style.opacity = node.style.opacity;
                elementWrapper.children.splice(2, 0, taskTypeNodeService);
            }
        }
        if (bpmnShape.activity.task.call !== undefined) {
            if (bpmnShape.activity.task.call !== false) {
                elementWrapper.children[0].style.strokeWidth = 4;
            }
            else {
                elementWrapper.children[0].style.strokeWidth = 1;
            }
        }
        if (bpmnShape.activity.task.compensation !== undefined) {
            if (bpmnShape.activity.task.compensation === true) {
                var isServiceTask = node.shape.activity.task.type === 'Service';
                elementWrapper.children[isServiceTask ? 4 : 3].visible = true;
            }
            else {
                elementWrapper.children[3].visible = false;
            }
        }
    };
    /** @private */
    BpmnDiagrams.prototype.updateBPMNActivityTaskLoop = function (node, newObject, x, subChildCount, area, start) {
        var bpmnShape = newObject.shape;
        var elementWrapper = node.wrapper.children[0].children[0];
        var activity = bpmnShape.activity;
        var taskType = node.shape.activity.task.type;
        var loop;
        var index = 0;
        var bpmnshapeLoopdata;
        if (activity.subProcess !== undefined) {
            var subProcess = activity.subProcess;
            if (activity.subProcess.type === 'Transaction') {
                index = 2;
            }
            else {
                index = (activity.subProcess.events.length > 0) ? 1 : 0;
            }
            loop = subProcess.loop;
            bpmnshapeLoopdata = getBpmnLoopShapePathData(loop);
            elementWrapper.children[2 + index].data = bpmnshapeLoopdata;
            elementWrapper.children[2 + index].visible = (loop === 'None') ? false : true;
            //EJ2-907764-Changing Loop for Activity node with task type, result in change in task type symbols
        }
        else if (activity.task !== undefined && activity.task.loop !== undefined && taskType !== 'Service') {
            bpmnshapeLoopdata = getBpmnLoopShapePathData(activity.task.loop);
            elementWrapper.children[2].data = bpmnshapeLoopdata;
            elementWrapper.children[2].visible = (activity.task.loop === 'None') ? false : true;
        }
        else if (activity.task !== undefined && activity.task.loop !== undefined && taskType === 'Service') {
            bpmnshapeLoopdata = getBpmnLoopShapePathData(activity.task.loop);
            elementWrapper.children[3].data = bpmnshapeLoopdata;
            elementWrapper.children[3].visible = (activity.task.loop === 'None') ? false : true;
        }
        this.updateChildMargin(elementWrapper, subChildCount, area, x, start + index);
    };
    /** @private */
    BpmnDiagrams.prototype.updateChildMargin = function (elementWrapper, subChildCount, area, x, start) {
        if (subChildCount === 1) {
            for (var i = start; i < elementWrapper.children.length; i++) {
                if (i !== 2 && elementWrapper.children[parseInt(i.toString(), 10)].visible === true) {
                    elementWrapper.children[parseInt(i.toString(), 10)].margin.left = x;
                    x = area + 8;
                }
            }
        }
        else {
            x = area + (subChildCount - 1) * 8;
            for (var i = start; i < elementWrapper.children.length; i++) {
                if (i !== 2 && elementWrapper.children[parseInt(i.toString(), 10)].visible === true) {
                    elementWrapper.children[parseInt(i.toString(), 10)].margin.left = x;
                    x += 12 + 8;
                }
            }
        }
    };
    /** @private */
    BpmnDiagrams.prototype.updateBPMNActivitySubProcess = function (node, newObject, oldObject, diagram) {
        var bpmnShape = newObject.shape;
        var elementWrapper = node.wrapper.children[0];
        var size = this.getSize(node, elementWrapper.children[0].children[0]);
        var subProcess = bpmnShape.activity.subProcess;
        var subChildCount = this.getSubprocessChildCount(node);
        var x;
        var childSpace = subChildCount * 12;
        var area = size.width / 2 - childSpace;
        if (subChildCount === 1) {
            x = area + 8;
        }
        else {
            x = area + (subChildCount - 1) * 8;
        }
        updateStyle(node.style, elementWrapper.children[0].children[0]);
        if (subProcess.events !== undefined) {
            this.updateBPMNSubProcessEvent(node, newObject, oldObject, diagram);
        }
        if (subProcess.adhoc !== undefined) {
            this.updateBPMNSubProcessAdhoc(node, oldObject, subProcess, x, subChildCount, area);
        }
        if (subProcess.boundary !== undefined) {
            this.updateBPMNSubProcessBoundary(node, subProcess);
        }
        if (subProcess.collapsed !== undefined) {
            this.updateBPMNSubProcessCollapsed(node, oldObject, subProcess, x, subChildCount, area, diagram);
        }
        if (subProcess.compensation !== undefined) {
            this.updateBPMNSubProcessCompensation(node, oldObject, subProcess, x, subChildCount, area);
        }
        if (subProcess.loop !== undefined) {
            this.updateBPMNSubProcessLoop(node, oldObject, subProcess, x, subChildCount, area);
        }
        if (subProcess.transaction !== undefined) {
            this.updateBPMNSubProcessTransaction(node, newObject, oldObject, diagram);
        }
    };
    /** @private */
    BpmnDiagrams.prototype.updateBPMNSubProcessEvent = function (node, newObject, oldObject, diagram) {
        var bpmnShape = newObject.shape;
        var elementWrapper = node.wrapper.children[0];
        var nodeContent = elementWrapper.children[0];
        var elementWrapperChildLen = elementWrapper.children[0].children.length;
        var subProcess = bpmnShape.activity.subProcess;
        var start = 2;
        for (var _i = 0, _a = Object.keys(subProcess.events); _i < _a.length; _i++) {
            var key = _a[_i];
            var eventIndex = Number(key);
            var eventWrapper = nodeContent.children[eventIndex + start];
            var actualEvent = node.shape.activity.subProcess.events[parseInt(eventIndex.toString(), 10)];
            this.updateBPMNSubEvent(node, subProcess.events[parseInt(eventIndex.toString(), 10)], actualEvent, eventWrapper, newObject, oldObject, diagram);
        }
    };
    BpmnDiagrams.prototype.updateBPMNSubEvent = function (node, newEvent, actualEvent, eventWrapper, newObject, oldObject, diagram) {
        var elementWrapper = node.wrapper.children[0];
        var bpmnShape = newObject.shape;
        if (eventWrapper.children !== undefined) {
            var child0 = eventWrapper.children[0];
            var child1 = eventWrapper.children[1];
            var child2 = eventWrapper.children[2];
            var eventType = void 0;
            var trigger = void 0;
            if (newObject.style) {
                if (newObject.style.strokeColor !== undefined || newObject.style.opacity !== undefined) {
                    elementWrapper.children[0].children[1].style.strokeColor = newObject.style.strokeColor;
                    elementWrapper.children[0].children[1].style.opacity = newObject.style.opacity;
                }
            }
            if (bpmnShape.activity.subProcess !== undefined) {
                eventType = newEvent.event;
                trigger = newEvent.trigger;
            }
            if (eventType !== undefined) {
                this.getEvent(newObject, oldObject, eventType, child0, child1, child2);
            }
            if (trigger !== undefined) {
                if (newObject.style) {
                    updateStyle(newObject.style, elementWrapper.children[0]);
                }
                //EJ2-913823 - Transaction subprocess event trigger not updated properly at runtime
                this.removeBPMNElementFromDOM(node, diagram);
                node.wrapper.children[0] = this.getBPMNActivityShape(node);
            }
            if (newEvent.height !== undefined || newEvent.width !== undefined) {
                this.getEventSize(newEvent, eventWrapper);
            }
            if (newEvent.id !== undefined) {
                eventWrapper.id = newEvent.id;
            }
            if (newEvent.margin !== undefined) {
                eventWrapper.margin = newEvent.margin;
            }
            if (newEvent.horizontalAlignment !== undefined) {
                eventWrapper.horizontalAlignment = newEvent.horizontalAlignment;
            }
            if (newEvent.verticalAlignment !== undefined) {
                eventWrapper.verticalAlignment = newEvent.verticalAlignment;
            }
            if (newEvent.offset !== undefined) {
                eventWrapper.setOffsetWithRespectToBounds(actualEvent.offset.x, actualEvent.offset.y, 'Fraction');
                eventWrapper.relativeMode = 'Point';
            }
            if (newEvent.annotations !== undefined) {
                var annotations = void 0;
                var annotation = elementWrapper.children[0].children[2];
                if (eventWrapper.children[3] && eventWrapper.children.length > 3) {
                    annotations = eventWrapper.children[3];
                    diagram.updateAnnotation(newEvent.annotations[0], annotations, annotation);
                }
            }
            if (newEvent.ports !== undefined) {
                var ports = void 0;
                var port = elementWrapper.children[0].children[2];
                if (eventWrapper.children[4] && eventWrapper.children.length > 4) {
                    ports = eventWrapper.children[4];
                    diagram.updatePort(newEvent.ports[0], ports, port);
                }
            }
            if (newEvent.visible !== undefined &&
                node.shape.activity.subProcess.type !== 'Event') {
                this.updateDiagramContainerVisibility(eventWrapper, newEvent.visible);
            }
        }
    };
    BpmnDiagrams.prototype.updateBPMNSubProcessTransaction = function (node, newObject, oldObject, diagram) {
        var transaction = newObject.shape.activity.subProcess.transaction;
        var eventContainer = node.wrapper.children[0].children[0].children[2];
        var actualEvent;
        if (transaction.success !== undefined) {
            actualEvent = node.shape.activity.subProcess.transaction.success;
            this.updateBPMNSubEvent(node, transaction.success, actualEvent, eventContainer.children[0], newObject, oldObject, diagram);
        }
        if (transaction.cancel !== undefined) {
            actualEvent = node.shape.activity.subProcess.transaction.cancel;
            this.updateBPMNSubEvent(node, transaction.cancel, actualEvent, eventContainer.children[1], newObject, oldObject, diagram);
        }
        if (transaction.failure !== undefined) {
            actualEvent = node.shape.activity.subProcess.transaction.failure;
            this.updateBPMNSubEvent(node, transaction.failure, actualEvent, eventContainer.children[2], newObject, oldObject, diagram);
        }
        for (var _i = 0, _a = node.outEdges; _i < _a.length; _i++) {
            var edge = _a[_i];
            var connector = diagram.nameTable["" + edge];
            switch (connector.sourcePortID) {
                case 'success':
                    if (transaction.success && transaction.success.visible !== undefined) {
                        diagram.connectorPropertyChange(connector, {}, { sourcePortID: 'success' });
                    }
                    break;
                case 'cancel':
                    if (transaction.cancel && transaction.cancel.visible !== undefined) {
                        diagram.connectorPropertyChange(connector, {}, { sourcePortID: 'cancel' });
                    }
                    break;
                case 'failure':
                    if (transaction.failure && transaction.failure.visible !== undefined) {
                        diagram.connectorPropertyChange(connector, {}, { sourcePortID: 'failure' });
                    }
                    break;
            }
        }
    };
    /** @private */
    BpmnDiagrams.prototype.getEventSize = function (events, wrapperChild) {
        if (events.height !== undefined) {
            wrapperChild.height = events.height;
            wrapperChild.children[0].height = events.height;
            wrapperChild.children[1].height = events.height * 0.85;
            wrapperChild.children[2].height = events.height * 0.54;
        }
        if (events.width !== undefined) {
            wrapperChild.width = events.width;
            wrapperChild.children[0].width = events.width;
            wrapperChild.children[1].width = events.width * 0.85;
            wrapperChild.children[2].width = events.width * 0.54;
        }
    };
    /** @private */
    BpmnDiagrams.prototype.updateBPMNSubProcessAdhoc = function (node, oldObject, subProcess, x, subChildCount, area) {
        var shape = node.shape;
        var elementWrapper = node.wrapper.children[0].children[0];
        var index;
        if (node.shape.activity.subProcess.type === 'Transaction') {
            index = 2;
        }
        else {
            index = (node.shape.activity.subProcess.events.length > 0) ? 1 : 0;
        }
        if (subProcess.adhoc === false) {
            elementWrapper.children[3 + index].visible = false;
        }
        else {
            elementWrapper.children[3 + index].visible = true;
        }
        this.updateChildMargin(elementWrapper, subChildCount, area, x, 3 + index);
    };
    /** @private */
    BpmnDiagrams.prototype.updateBPMNSubProcessBoundary = function (node, subProcess) {
        var shape = node.shape;
        var elementWrapper = (node.wrapper.children[0].children[0].children[0]);
        if (subProcess.boundary === 'Default') {
            elementWrapper.style.strokeWidth = 1;
            elementWrapper.style.strokeDashArray = '1 0';
        }
        if (subProcess.boundary === 'Call') {
            elementWrapper.style.strokeWidth = 4;
            elementWrapper.style.strokeDashArray = '1 0';
        }
        if (subProcess.boundary === 'Event') {
            elementWrapper.style.strokeWidth = 1;
            elementWrapper.style.strokeDashArray = '2 2';
        }
    };
    /** @private */
    BpmnDiagrams.prototype.updateElementVisibility = function (node, visible, diagram) {
        if (node.shape.activity.subProcess.processes
            && node.shape.activity.subProcess.processes.length > 0) {
            var processes = node.shape.activity.subProcess.processes;
            for (var j = processes.length - 1; j >= 0; j--) {
                var currentNode = diagram.nameTable[processes[parseInt(j.toString(), 10)]];
                currentNode.visible = visible;
                diagram.updateElementVisibility(currentNode.wrapper, currentNode, visible);
                if (visible) {
                    if ((!isBlazor() && currentNode.shape.shape === 'Event')) {
                        this.setEventVisibility(currentNode, currentNode.wrapper.children[0].children);
                    }
                    if (currentNode.shape.activity.activity === 'SubProcess') {
                        this.setSubProcessVisibility(currentNode);
                    }
                }
                var connectors = currentNode.inEdges.concat(currentNode.outEdges);
                for (var i = connectors.length - 1; i >= 0; i--) {
                    var connector = diagram.nameTable[connectors[parseInt(i.toString(), 10)]];
                    connector.visible = visible;
                    diagram.updateElementVisibility(connector.wrapper, connector, visible);
                }
            }
        }
        if (visible) {
            if (!isBlazor() && node.shape.shape === 'Event') {
                this.setEventVisibility(node, node.wrapper.children[0].children);
            }
            if (node.shape.activity.activity === 'SubProcess') {
                this.setSubProcessVisibility(node);
            }
            if (node.shape.activity.activity === 'Task' &&
                (!isBlazor() && node.shape.shape === 'Activity')
                && node.shape.activity.subProcess.loop === 'None') {
                node.wrapper.children[0].children[0].children[3].visible = false;
            }
            //(EJ2-843861) - BPMN node subtype visibles whiles changing the node visibility
            if (node.shape.shape === 'DataObject') {
                if (node.shape.dataObject.collection === false && node.shape.dataObject.type === 'None') {
                    for (var i = node.wrapper.children[0].children.length - 1; i > 0; i--) {
                        node.wrapper.children[0].children[parseInt(i.toString(), 10)].visible = false;
                    }
                }
                else if (node.shape.dataObject.collection === true && node.shape.dataObject.type === 'None') {
                    node.wrapper.children[0].children[1].visible = false;
                }
                else if (node.shape.dataObject.collection === false && (node.shape.dataObject.type === 'Input' || node.shape.dataObject.type === 'Output')) {
                    node.wrapper.children[0].children[2].visible = false;
                }
            }
        }
    };
    /** @private */
    BpmnDiagrams.prototype.updateBPMNSubProcessCollapsed = function (node, oldObject, subProcess, x, subChildCount, area, diagram) {
        var eventLength = node.shape.activity.subProcess.events.length;
        var elementWrapper = node.wrapper.children[0].children[0];
        var index;
        if (node.shape.activity.subProcess.type === 'Transaction') {
            index = 3;
        }
        else {
            index = (node.shape.activity.subProcess.events.length > 0) ? 0 : 1;
        }
        if (subProcess.collapsed === false) {
            this.updateElementVisibility(node, true, diagram);
            elementWrapper.children[index + eventLength].visible = false;
        }
        else {
            this.updateElementVisibility(node, false, diagram);
            elementWrapper.children[index + eventLength].visible = true;
        }
        this.updateChildMargin(elementWrapper, subChildCount, area, x, 3 + eventLength);
    };
    /** @private */
    BpmnDiagrams.prototype.updateBPMNSubProcessCompensation = function (node, oldObject, subProcess, x, subChildCount, area) {
        var elementWrapper = node.wrapper.children[0].children[0];
        var index;
        if (node.shape.activity.subProcess.type === 'Transaction') {
            index = 2;
        }
        else {
            index = (node.shape.activity.subProcess.events.length > 0) ? 1 : 0;
        }
        if (subProcess.compensation === false) {
            elementWrapper.children[4 + index].visible = false;
        }
        else {
            elementWrapper.children[4 + index].visible = true;
        }
        this.updateChildMargin(elementWrapper, subChildCount, area, x, 4 + index);
    };
    /** @private */
    BpmnDiagrams.prototype.updateBPMNSubProcessLoop = function (node, oldObject, subProcess, x, subChildCount, area) {
        this.updateBPMNActivityTaskLoop(node, node, x, subChildCount, area, 1);
    };
    /** @private */
    BpmnDiagrams.prototype.updateBPMNConnector = function (actualObject, oldObject, connection, diagram) {
        var flowType = connection.shape;
        //EJ2-66905 - Changing BPMN flow connectors at runtime is not working properly.
        var flow = actualObject.shape.flow;
        if ((flowType.flow === 'Sequence' || flowType.sequence) && flow === 'Sequence') {
            actualObject = this.getSequence(actualObject, oldObject, connection, diagram);
        }
        if ((flowType.flow === 'Association' || flowType.association) && flow === 'Association') {
            actualObject = this.getAssociation(actualObject, oldObject, connection, diagram);
        }
        if ((flowType.flow === 'Message' || flowType.message) && flow === 'Message') {
            actualObject = this.getMessage(actualObject, oldObject, connection, diagram);
        }
        return actualObject;
    };
    /** @private */
    BpmnDiagrams.prototype.getSequence = function (actualObject, oldObject, connection, diagram) {
        if ((connection.shape.sequence) === 'Normal' || actualObject.shape.sequence === 'Normal') {
            actualObject.targetDecorator.shape = 'Arrow';
            actualObject.sourceDecorator.shape = 'None';
            actualObject.style.strokeDashArray = 'None';
            actualObject.targetDecorator.style.fill = 'black';
            actualObject.targetDecorator.width = 10;
            actualObject.targetDecorator.height = 10;
            diagram.connectorPropertyChange(actualObject, oldObject, {
                targetDecorator: { shape: 'Arrow', style: { fill: 'black' }, height: 10, width: 10 },
                sourceDecorator: { shape: 'None' },
                style: { strokeDashArray: 'None' }
            });
            actualObject.wrapper.children[3].visible = false;
        }
        if ((connection.shape.sequence) === 'Default' || actualObject.shape.sequence === 'Default') {
            actualObject.targetDecorator.shape = 'Arrow';
            actualObject.sourceDecorator.shape = 'None';
            actualObject.style.strokeDashArray = 'None';
            actualObject.targetDecorator.style.fill = 'black';
            actualObject.targetDecorator.width = 10;
            actualObject.targetDecorator.height = 10;
            diagram.connectorPropertyChange(actualObject, oldObject, {
                style: { strokeDashArray: 'None' },
                targetDecorator: { shape: 'Arrow', style: { fill: 'black' }, height: 10, width: 10 },
                sourceDecorator: { shape: 'None' }
            });
            var segment = new PathElement();
            var pathseq = new PathElement();
            var pathseqData = void 0;
            segment = actualObject.getSegmentElement(actualObject, segment);
            var anglePoints = actualObject.intermediatePoints;
            for (var j = 0; j < anglePoints.length - 1; j++) {
                // eslint-disable-next-line no-global-assign
                length = length + actualObject.distance(anglePoints[parseInt(j.toString(), 10)], anglePoints[j + 1]);
                pathseqData = actualObject.findPath(anglePoints[parseInt(j.toString(), 10)], anglePoints[j + 1]);
            }
            var content = new PathElement();
            content.data = pathseqData[0];
            content.id = actualObject.id + '_' + connection.shape.sequence || actualObject.shape.sequence;
            content.offsetX = pathseqData[1].x;
            content.offsetY = pathseqData[1].y;
            content.rotateAngle = 45;
            content.transform = Transform.Self;
            this.removeDomElement(actualObject, diagram, content);
        }
        if ((connection.shape.sequence) === 'Conditional' || actualObject.shape.sequence === 'Conditional') {
            actualObject.sourceDecorator.shape = 'Diamond';
            actualObject.sourceDecorator.width = 20;
            actualObject.sourceDecorator.height = 10;
            actualObject.sourceDecorator.style.fill = 'white';
            actualObject.targetDecorator.style.fill = 'black';
            actualObject.style.strokeDashArray = 'None';
            actualObject.targetDecorator.shape = 'Arrow';
            diagram.connectorPropertyChange(actualObject, oldObject, {
                style: { strokeDashArray: 'None' },
                targetDecorator: { shape: 'Arrow', style: { fill: 'black' }, height: 10, width: 10 },
                sourceDecorator: { shape: 'Diamond', width: 20, height: 10, style: { fill: 'white' } }
            });
            actualObject.wrapper.children[3].visible = false;
        }
        return actualObject;
    };
    /** @private */
    BpmnDiagrams.prototype.getAssociation = function (actualObject, oldObject, connection, diagram) {
        if ((connection.shape.association) === 'Default' || actualObject.shape.association === 'Default') {
            actualObject.sourceDecorator.shape = 'None';
            actualObject.targetDecorator.shape = 'None';
            actualObject.style.strokeDashArray = '2 2';
            diagram.connectorPropertyChange(actualObject, oldObject, {
                style: { strokeDashArray: '2 2' },
                targetDecorator: { shape: 'None' },
                sourceDecorator: { shape: 'None' }
            });
            actualObject.wrapper.children[3].visible = false;
        }
        if ((connection.shape.association) === 'Directional' || actualObject.shape.association === 'Directional') {
            actualObject.sourceDecorator.shape = 'None';
            actualObject.style.strokeDashArray = '2 2';
            actualObject.targetDecorator.shape = 'OpenArrow';
            actualObject.targetDecorator.width = 10;
            actualObject.targetDecorator.height = 10;
            diagram.connectorPropertyChange(actualObject, oldObject, {
                style: { strokeDashArray: '2 2' },
                targetDecorator: { shape: 'OpenArrow', width: 10, height: 10 },
                sourceDecorator: { shape: 'None' }
            });
            actualObject.wrapper.children[3].visible = false;
        }
        if ((connection.shape.association) === 'BiDirectional' || actualObject.shape.association === 'BiDirectional') {
            actualObject.sourceDecorator.shape = 'OpenArrow';
            actualObject.targetDecorator.shape = 'OpenArrow';
            actualObject.sourceDecorator.width = 10;
            actualObject.sourceDecorator.height = 10;
            actualObject.sourceDecorator.style.fill = 'black';
            diagram.connectorPropertyChange(actualObject, oldObject, {
                style: { strokeDashArray: '2 2' },
                targetDecorator: { shape: 'OpenArrow', width: 10, height: 10 },
                sourceDecorator: { shape: 'OpenArrow', width: 10, height: 10, style: { fill: 'black' } }
            });
            actualObject.wrapper.children[3].visible = false;
        }
        return actualObject;
    };
    /** @private */
    BpmnDiagrams.prototype.getMessage = function (actualObject, oldObject, connection, diagram) {
        var segmentOffset = 0.5;
        var angle;
        var pt;
        actualObject.sourceDecorator.shape = 'Circle';
        actualObject.sourceDecorator.width = 10;
        actualObject.targetDecorator.shape = 'Arrow';
        actualObject.sourceDecorator.height = 10;
        actualObject.sourceDecorator.style.fill = 'White';
        actualObject.targetDecorator.style.fill = 'White';
        diagram.connectorPropertyChange(actualObject, oldObject, { sourceDecorator: { shape: 'Circle', style: { fill: 'White' }, width: 10, height: 10 }, targetDecorator: { shape: 'Arrow', style: { fill: 'white' } } });
        var anglePoints = actualObject.intermediatePoints;
        var length = 0;
        for (var j = 0; j < anglePoints.length - 1; j++) {
            /* eslint-disable */
            length = length + actualObject.distance(anglePoints[j], anglePoints[j + 1]);
            /* eslint-enable */
            var offLength = length * segmentOffset;
            if (length >= offLength) {
                angle = findAngle(anglePoints[parseInt(j.toString(), 10)], anglePoints[j + 1]);
                pt = Point.transform(anglePoints[parseInt(j.toString(), 10)], angle, offLength);
            }
        }
        var content = new PathElement();
        actualObject.wrapper.children[0].style.strokeDashArray = ' 4 4';
        actualObject.style.strokeDashArray = '4 4';
        content.id = actualObject.id + '_' + connection.shape.message || actualObject.shape.message;
        content.width = 25;
        content.height = 15;
        content.data = 'M0,0 L19.8,12.8 L40,0 L0, 0 L0, 25.5 L40, 25.5 L 40, 0';
        content.horizontalAlignment = 'Center';
        content.verticalAlignment = 'Center';
        content.transform = Transform.Self;
        content.style.fill = connection.shape.message === 'NonInitiatingMessage' ?
            'lightgrey' : 'white';
        content.offsetX = pt.x;
        content.offsetY = pt.y;
        if ((connection.shape.message !== 'Default' && connection.shape.message !== undefined) || actualObject.shape.message !== 'Default') {
            content.style.fill = (connection.shape.message || actualObject.shape.message) === 'NonInitiatingMessage' ?
                'lightgrey' : 'white';
        }
        else {
            content.visible = false;
        }
        this.removeDomElement(actualObject, diagram, content);
        return actualObject;
    };
    // To remove old wrapper element from dom.
    BpmnDiagrams.prototype.removeDomElement = function (actualObject, diagram, content) {
        for (var _i = 0, _a = diagram.views; _i < _a.length; _i++) {
            var elementId = _a[_i];
            removeElement(actualObject.id + '_groupElement', elementId);
            removeElement(actualObject.id + '_content_groupElement', elementId);
            removeElement(actualObject.id + '_html_element', elementId);
        }
        actualObject.wrapper.children.splice(3, 1);
        actualObject.wrapper.children.splice(3, 0, content);
    };
    //End update Region
    //size updation
    BpmnDiagrams.prototype.setSizeForBPMNEvents = function (event, wrapper, width, height) {
        wrapper.children[0].width = width;
        wrapper.children[0].height = height;
        //child node 1 - event node
        var eventNode = wrapper.children[1];
        eventNode.width = width * 0.85;
        eventNode.height = height * 0.85;
        var triggerNode = wrapper.children[2];
        if (event.trigger === 'Message') {
            triggerNode.width = width * 0.54;
            triggerNode.height = height * 0.4;
        }
        else {
            triggerNode.width = width * 0.5;
            triggerNode.height = height * 0.5;
        }
    };
    /** @private */
    BpmnDiagrams.prototype.updateAnnotationDrag = function (node, diagram, tx, ty) {
        if (node.processId) {
            this.drag(node, tx, ty, diagram);
            return true;
        }
        return false;
    };
    BpmnDiagrams.prototype.getAnnotationPathAngle = function (point, bounds) {
        var direction = getPortDirection(point, bounds, bounds);
        var rotateAngle = 0;
        switch (direction) {
            case 'Right':
                rotateAngle = 0;
                break;
            case 'Left':
                rotateAngle = 180;
                break;
            case 'Bottom':
                rotateAngle = 90;
                break;
            case 'Top':
                rotateAngle = 270;
                break;
        }
        return rotateAngle;
    };
    BpmnDiagrams.prototype.setSizeForBPMNGateway = function (event, wrapper, width, height) {
        wrapper.children[0].width = width;
        wrapper.children[0].height = height;
        wrapper.children[1].width = width * 0.45;
        wrapper.children[1].height = height * 0.45;
    };
    BpmnDiagrams.prototype.setSizeForBPMNDataObjects = function (event, wrapper, width, height) {
        wrapper.children[0].width = width;
        wrapper.children[0].height = height;
    };
    BpmnDiagrams.prototype.setSizeForBPMNActivity = function (activity, wrapper, width, height, node) {
        //child node 1 - event node
        wrapper.children[0].width = width;
        wrapper.children[0].height = height;
        wrapper.children[0].children[0].width = width;
        wrapper.children[0].children[0].height = height;
        if (activity.subProcess.type === 'Transaction') {
            wrapper.children[0].children[1].width = Math.max(width - 6, 1);
            wrapper.children[0].children[1].height = Math.max(height - 6, 1);
            wrapper.children[0].children[2].width = width;
            wrapper.children[0].children[2].height = height;
        }
        var taskNode = new DiagramElement();
        var x;
        var size = this.getSize(node, taskNode);
        var childCount;
        var iconSpace = 4;
        if (activity.activity === 'Task') {
            childCount = this.getTaskChildCount(node);
        }
        else {
            childCount = this.getSubprocessChildCount(node);
        }
        var childSpace = childCount * 12;
        var area = (width || size.width) / 2;
        if (childCount === 1) {
            x = area - 6;
        }
        else {
            x = area - (childSpace / 2) - ((childCount - 1) * iconSpace) / 2;
        }
        for (var i = 0; i < wrapper.children[0].children.length; i++) {
            if (wrapper.children[0].children[parseInt(i.toString(), 10)].visible &&
                (wrapper.children[0].children[parseInt(i.toString(), 10)].id.indexOf('_loop') > -1 ||
                    wrapper.children[0].children[parseInt(i.toString(), 10)].id.indexOf('_0_compensation') > -1 ||
                    wrapper.children[0].children[parseInt(i.toString(), 10)].id.indexOf('_0_adhoc') > -1 ||
                    wrapper.children[0].children[parseInt(i.toString(), 10)].id.indexOf('_0_collapsed') > -1)) {
                wrapper.children[0].children[parseInt(i.toString(), 10)].margin.left = x;
                x += wrapper.children[0].children[parseInt(i.toString(), 10)].actualSize.width + iconSpace;
            }
        }
    };
    BpmnDiagrams.prototype.updateDiagramContainerVisibility = function (element, visible) {
        if (element instanceof Container) {
            for (var i = 0; i < element.children.length; i++) {
                this.updateDiagramContainerVisibility(element.children[parseInt(i.toString(), 10)], visible);
            }
        }
        // 913810 : Start is as start event not rendered correctly for success, failure, cancel transaction subprocess events
        if (element.visible && element.visible !== visible) {
            element.visible = visible;
        }
    };
    /**
     *To destroy the ruler
     *
     * @returns {void} To destroy the ruler
     */
    BpmnDiagrams.prototype.destroy = function () {
        /**
         * Destroys the BpmnDiagrams module
         */
    };
    /**
     * Get module name.
     *
     * @returns {string}   Get module name.
     */
    BpmnDiagrams.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'Bpmn';
    };
    return BpmnDiagrams;
}());
/**
 * getBpmnShapePathData method \
 *
 * @returns { string } getBpmnShapePathData method .\
 * @param {string} shape - provide the shape value.
 *
 * @private
 */
function getBpmnShapePathData(shape) {
    return bpmnShapes[shape.toString()];
}
/**
 * getBpmnTriggerShapePathData method \
 *
 * @returns { string } getBpmnTriggerShapePathData method .\
 * @param {string} shape - provide the shape value.
 *
 * @private
 */
function getBpmnTriggerShapePathData(shape) {
    return bpmnTriggerShapes[shape.toString()];
}
/**
 * getBpmnGatewayShapePathData method \
 *
 * @returns { string } getBpmnGatewayShapePathData method .\
 * @param {string} shape - provide the shape value.
 *
 * @private
 */
function getBpmnGatewayShapePathData(shape) {
    return bpmnGatewayShapes[shape.toString()];
}
/**
 * getBpmnTaskShapePathData method \
 *
 * @returns { string } getBpmnTaskShapePathData method .\
 * @param {string} shape - provide the shape value.
 *
 * @private
 */
function getBpmnTaskShapePathData(shape) {
    return bpmnTaskShapes[shape.toString()];
}
/**
 * getBpmnLoopShapePathData method \
 *
 * @returns { string } getBpmnLoopShapePathData method .\
 * @param {string} shape - provide the shape value.
 *
 * @private
 */
function getBpmnLoopShapePathData(shape) {
    return bpmnLoopShapes[shape.toString()];
}
var bpmnShapes = {
    'Event': 'M80.5,12.5 C80.5,19.127417 62.59139,24.5 40.5,24.5 C18.40861,24.5 0.5,19.127417 0.5,12.5' +
        'C0.5,5.872583 18.40861,0.5 40.5,0.5 C62.59139,0.5 80.5,5.872583 80.5,12.5 z',
    'Message': 'M0,0L19.8,12.8L40,0L0,0L0,25.5L40,25.5L40,0z',
    'DataSource': 'M 0 10.6 c 0 5.9 16.8 10.6 37.5 10.6 S 75 16.4 75 10.6 v 0 v 68.9 v -0.1 C 75 85.3 58.2 90 37.5 90 ' +
        'S 0 85.3 0 79.4 l 0 0.1 V 56 V 40.6 L 0 10.6 C 0 4.7 16.8 0 37.5 0 S 75 4.7 75 10.6 S 58.2 21.2 37.5 21.2' +
        'S 0 16.5 0 10.6 l 0 6.7 v -0.2 c 0 5.9 16.8 10.6 37.5 10.6 S 75 22.9 75 17.1 v 6.8 v -0.1 ' +
        'c 0 5.9 -16.8 10.6 -37.5 10.6 S 0 29.6 0 23.8',
    'SubProcess': 'M100,100 h200 a20,20 0 0 1 20,20 v200 a20,20 0 0 1 -20,20 h-200 ' +
        'a20,20 0 0 1 -20,-20 v-200 a20,20 0 0 1 20,-20 z',
    'collapsedShape': 'M 8.13789 15 H 0 V 0 H 8.13789 V 15 Z M 0.625991 13.75 H 7.51189 V 1.25 H 0.625991 V 13.75 Z ' +
        'M 2.18095 7.03125 L 5.95631 7.03125 L 5.95631 7.46875 L 2.18095 7.46875 Z M 3.8342 3.73 ' +
        'L 4.30369 3.73 L 4.30369 11.2687 L 3.8342 11.2687 Z'
};
var bpmnTriggerShapes = {
    // 'None': '',
    'Message': 'M0,0 L19.8,12.8 L40,0 L0, 0 L0, 25.5 L40, 25.5 L 40, 0',
    'Timer': 'M40,20c0,8.654-5.496,16.024-13.189,18.81' +
        'C24.685,39.58,22.392,40,20,40C8.954,40,0,31.046,0,20S8.954,0,20,0S40,8.954,40,20z M20,0 L20,2.583 L20,5.283 M10.027,2.681' +
        'L11.659,5.507 L12.669,7.257 M2.731,9.989 L6.014,11.885 L7.307,12.631 M0.067,19.967 L2.667,19.967 L5.35,19.967' +
        'M2.748,29.939 L5.731,28.217 L7.323,27.298 M10.056,37.236 L11.292,35.095 L12.698,32.66 M20.033,39.9 L20.033,36.417 L20.033,34.617' +
        'M30.006,37.219 L28.893,35.292 L27.364,32.643 M37.302,29.911 L34.608,28.355 L32.727,27.269' +
        'M39.967,19.933 L37.417,19.933 L34.683,19.933 M37.286,9.961 L34.583,11.521 L32.71,12.602 M29.977,2.664 L28.653,4.957 L27.336,' +
        '7.24 M22.104,8.5 L19.688,20 L24.75,20 L31.604,20 L24.75,20 L19.688,20z',
    'Error': 'M 23.77 18.527 l -7.107 27.396 l 8.507 -17.247 L 36.94 40.073 l 6.394 -25.997 l -8.497 15.754 L 23.77 18.527 Z',
    'Escalation': 'M 30.001 8.098 L 11.842 43.543 l 18.159 -18.882 l 18.162 18.882 L 30.001 8.098 Z ',
    'Cancel': 'M 3.5 16 L 0 12.6 L 4.6 8 L 0 3.5 L 3.4 0 L 8 4.6 l 4.5 -4.5 L 16 3.5 L 11.5 8 l 4.5 4.5 l -3.4 3.5 L 8 11.4 L 3.5 16 Z',
    'Compensation': 'M 25.7086 0 L 0 25 L 25.7086 50 V 26.3752 L 50 50 V 0 L 25.7086 23.6248 V 0 Z ',
    'Conditional': 'M 0 0 H 16 V 16 H 0 z M 1.14 3.2 H 14.85 M 1.14 6.4 H 14.85 M 1.14 9.6 H 14.85 M 1.14 12.8 H 14.85',
    'Link': 'M 32.014 19.258 v 5.992 H 9.373 v 9.504 h 22.641 v 5.988 L 50.622 30 L 32.014 19.258 Z',
    'Signal': 'M 50 50 H 0 L 25.0025 0 L 50 50 Z',
    'Terminate': 'M 25 50 C 11.21 50 0 38.79 0 25 C 0 11.21 11.21 0 25 0 C 38.78 0 50 11.21 50 25 C 50 38.79 38.78 50 25 50',
    'Multiple': 'M 17.784 48.889 H 42.21 l 7.548 -23.23 L 29.997 11.303 L 10.236 25.658 L 17.784 48.889 Z',
    'Parallel': 'M 27.276 49.986 h 5.58 v -17.15 h 17.146 V 27.17 h -17.15 l 0.004 -17.15 h -5.58 l -0.004 17.15 ' +
        'H 9.994 v 5.666 h 17.278 L 27.276 49.986 Z'
};
var bpmnGatewayShapes = {
    'None': '',
    //exclusive
    'Exclusive': 'M 11.196 29.009 l 6.36 -9.712 l -5.764 -8.899 h 4.393 l 3.732 5.979 l 3.656 -5.979 h 4.354 l -5.789 9.039' +
        'l 6.36 9.572 h -4.532 l -4.126 -6.437 l -4.139 6.437 H 11.196 Z',
    //inclusive
    'Inclusive': 'M 20.323 31.333 c -6.625 0 -12.015 -5.39 -12.015 -12.015 s 5.39 -12.015 12.015 -12.015 ' +
        's 12.016 5.39 12.016 12.015 S 26.948 31.333 20.323 31.333 Z M 20.323 9.303 c -5.522 0 -10.015 4.493 -10.015 10.015 ' +
        's 4.492 10.015 10.015 10.015 s 10.016 -4.493 10.016 -10.015 S 25.846 9.303 20.323 9.303 Z',
    //parallel
    'Parallel': 'M 18.394 29.542 v -8.833 H 9.626 v -3.691 h 8.768 V 8.251 h 3.734 v 8.767 h 8.768 v 3.691 h -8.768 v 8.833 H 18.394 Z',
    //complex
    'Complex': 'M29.198,19.063L23.089,19.063L27.794,14.358L26.38,12.944L21.223,18.101L21.223,10.443L19.223,10.443L19.223,17.976' +
        'L14.022,12.776L12.608,14.19L17.48,19.063L10.365,19.063L10.365,21.063L18.261,21.063L12.392,26.932L13.806,28.346' +
        'L19.223,22.929L19.223,30.225L21.223,30.225L21.223,22.805L25.925,27.507L27.339,26.093L22.309,21.063L29.198,21.063z',
    //eventbased
    'EventBased': 'M 20.322 29.874 c -5.444 0 -9.873 -4.43 -9.873 -9.874 s 4.429 -9.874 9.873 -9.874 s 9.874 4.429 9.874 9.874 ' +
        'S 25.767 29.874 20.322 29.874 Z M 20.322 32.891 c -7.107 0 -12.89 -5.783 -12.89 -12.891 c 0 -7.107 5.782 -12.89 12.89 -12.89 ' +
        'c 7.108 0 12.891 5.783 12.891 12.89 C 33.213 27.108 27.431 32.891 20.322 32.891 Z M 24.191 25.386 ' +
        'h -7.984 l -2.469 -7.595 l 6.461 -4.693 l 6.461 4.693 L 24.191 25.386 Z',
    //exclusive event based
    'ExclusiveEventBased': 'M 30 15 C 30 23.28 23.28 30 15 30 S 0 23.28 0 15 S 6.72 0 15 0 S 30 6.72 30 15 z M 15 5 ' +
        'L 5 12.5 L 8 22.5 H 22 L 25 12.5 z',
    //parallel event based
    'ParallelEventBased': 'M 35 17.5 C 35 27.16 27.16 35 17.5 35 S 0 27.16 0 17.5 S 7.84 0 17.5 0 S 35 7.84 35 17.5 z M 14.58 5.83 ' +
        'V 14.58 H 5.83 V 20.42 H 14.58 V 29.17 H 20.42 V 20.42 H 29.17 V 14.58 H 20.42 V 5.83 z'
};
var bpmnTaskShapes = {
    'None': '',
    'Service': 'M 32.699 20.187 v -4.005 h -3.32 c -0.125 -0.43 -0.292 -0.83 -0.488 -1.21 l 2.373 -2.375 ' +
        'l -2.833 -2.83 l -2.333 2.333 c -0.44 -0.253 -0.9 -0.448 -1.387 -0.595 v -3.32 h -4.003 v 3.32 c -0.46 0.137 -0.89' +
        '0.322 -1.3 0.537 l -2.285 -2.275 l -2.833 2.83 l 2.285 2.278 c -0.235 0.42 -0.41 0.847 -0.547 1.307 h -3.33 v 4.005 h 3.33 ' +
        'c 0.148 0.488 0.343 0.955 0.588 1.395 l -2.325 2.325 l 2.822 2.832 l 2.373 -2.382 c 0.392 0.205 0.792 0.37 1.212 0.497 v 3.33 ' +
        'h 4.003 v -3.33 c 0.46 -0.138 0.89 -0.323 1.3 -0.547 l 2.43 2.432 l 2.822 -2.832 l -2.42 -2.422 c 0.222 -0.41 0.4 -0.85 0.535' +
        '-1.297 H 32.699 Z M 22.699 21.987 c -2.1 0 -3.803 -1.703 -3.803 -3.803 c 0 -2.1 1.703 -3.803 3.803 -3.803 c 2.1 0 3.803 ' +
        '1.703 3.803 3.803 C 26.502 20.285 24.8 21.987 22.699 21.987 Z',
    'Receive': 'M 12.217 12.134 v 13.334 h 20 V 12.134 H 12.217 Z M 30.44 13.007 l -8.223 5.35 l -8.223 -5.35 H 30.44 Z M 13.09' +
        ' 24.594 V 13.459 l 9.127 5.94 l 9.127 -5.94 v 11.135 H 13.09 Z',
    'Send': 'M0,1.2260086 L8.0000002,8.3380068 16,1.2260086 16,12.000007 0,12.000007 z M1.6300015,0 L14.371001,0 8.0000055,5.662 z',
    'InstantiatingReceive': 'M 16.306 17.39 v 8.79 h 13.198 v -8.79 H 16.306 Z M 28.375 17.946 l -5.47 3.558 l -5.47 -3.558 ' +
        'H 28.375 Z M 28.948 25.625 H 16.861 v -7.389 l 6.043 3.931 l 6.043 -3.931 V 25.625 Z M 22.905 11.785' +
        'c -5.514 0 -9.999 4.486 -9.999 10 c 0 5.514 4.485 10 9.999 10 s 9.999 -4.486 9.999 -10 ' +
        'C 32.904 16.272 28.419 11.785 22.905 11.785 Z M 22.905 31.239 c -5.212 0 -9.453 -4.241 -9.453 -9.454' +
        'c 0 -5.212 4.241 -9.453 9.453 -9.453 s 9.452 4.241 9.452 9.453 C 32.357 26.998 28.117 31.239 22.905 31.239 Z',
    'Manual': 'M9.21 612 L5.82 612 L1.07 612 a1.07317 1 -180 0 1 -1.07317 -1 L0 604.75 A3.42007 1.59344 -180 0 0 1.61 604 L2.6 604 L5.99 604 a0.721171 0.672 0 0 1 0.721171 0.672 a0.721171 0.672 0 0 1 -0.721171 0.672 L2.6 605.34 a0.48818 0.183302 -90 0 0 0.0837073 0.342385 L5.63 605.69 a0.721171 0.672 0 0 1 0.184585 -0.0223847 L10.28 605.66 a0.721171 0.672 0 0 1 0.721171 0.672 a0.721171 0.672 0 0 1 -0.721171 0.672 L5.82 607.01 a0.721171 0.672 0 0 1 -0.184585 -0.0223847 L5.63 607.35 a0.721171 0.672 0 0 1 0.184585 -0.0223847 L10.01 607.33 a0.721171 0.672 0 0 1 0.721171 0.672 a0.721171 0.672 0 0 1 -0.721171 0.672 L5.82 608.67 a0.721171 0.672 0 0 1 -0.184585 -0.0223847 L5.63 609.01 a0.721171 0.672 0 0 1 0.184585 -0.0223847 L9.47 608.99 a0.721171 0.672 0 0 1 0.721171 0.672 a0.721171 0.672 0 0 1 -0.721171 0.672 L5.82 610.34 a0.721171 0.672 0 0 1 -0.184585 -0.0223847 L5.63 610.68 a0.721171 0.672 0 0 1 0.184585 -0.0223847 L9.21 610.66 a0.721171 0.672 0 0 1 0.721171 0.672 a0.721171 0.672 0 0 1 -0.721171 0.672',
    'BusinessRule': 'M 32.844 13.245 h -0.089 v 0 H 13.764 v -0.015 h -1.009 v 16.989 h 0.095 v 0.011 h 19.716 v -0.011 h 0.278 ' +
        'V 13.245 Z M 31.844 14.229 v 4.185 h -18.08 v -4.185 H 31.844 Z M 18.168 25.306 v 3.938 h -4.404 v -3.938 H 18.168 Z ' +
        'M 13.764 24.322 v -4.923 h 4.404 v 4.923 H 13.764 Z M 19.177 25.306 h 12.667 v 3.938 H 19.177 V 25.306 Z M 19.177 24.322' +
        'v -4.923 h 12.667 v 4.923 H 19.177 Z',
    'User': 'M8.6751149,13.75 L10.79009,18.703003 11.664047,18.696991 13.792084,13.75 13.824066,13.75 C18.177001,13.75 21.709022,' +
        '17.259003 21.748998,21.60199 21.748998,21.649994 21.743993,21.700012 21.735021,21.747009 21.137981,24.774994 18.775997,' +
        '27.144989 15.74904,27.75 L6.7491024,27.75 C3.7231224,27.144989 1.3601628,24.774994 0.76312089,21.747009 0.75414884,21.700012 0.74914402,' +
        '21.649994 0.75012076,21.60199 0.78912175,17.259003 4.3221171,13.75 8.6751149,13.75 z M11.249014,0.75 C14.287014,0.75 16.749015,' +
        '3.2119999 16.749015,6.25 16.749015,9.2880001 14.287014,11.75 11.249014,11.75 8.211015,11.75 5.7490147,9.2880001 5.7490147,6.25 5.7490147,3.2119999 8.211015,0.75 11.249014,0.75 z',
    'Script': 'M22.3,80.4 A82.9529,77.0159,-180,0,0,10.3,46.7 A69.8467,64.8477,0,0,1,0,19.7 A27.6207,25.6439,0,0,1,12.1,0 L84.7,0 A37.4124,34.7347,-180,0,0,77.7,19.6 A82.8871,76.9547,' +
        '-180,0,0,89.7,53.3 A69.8146,64.81790000000001,0,0,1,100,80.3 A27.603399999999997,25.6278,0,0,1,87.9,100 L15.3,100 A37.4265,34.7479,-180,0,0,22.3,80.4 M12.5,28.6 L67.3,28.6 M18.3,42.9 L72.1,42.9 M80.8,' +
        '57.1 L26,57.1 M85.6,71.4 L32.6,71.4'
};
var bpmnLoopShapes = {
    'None': '',
    'Standard': 'M 52.002 73.379 c -2.494 -2.536 -6.55 -2.534 -9.043 0 c -1.208 1.228 -1.874 2.861 -1.874 4.598 ' +
        'c 0 1.225 0.337 2.395 0.957 3.411 l -1.167 1.186 l 2.071 0.458 l 2.071 0.458 l -0.45 -2.106 l -0.45 -2.106 l -1.292 1.314' +
        'c -1.119 -2.065 -0.842 -4.709 0.877 -6.458 c 2.084 -2.119 5.475 -2.117 7.557 0 c 2.083 2.119 2.083 5.565 0 7.685' +
        'c -0.976 0.992 -2.272 1.557 -3.65 1.59 l 0.025 1.068 c 1.65 -0.041 3.2 -0.716 4.368 -1.903 ' +
        'c 1.208 -1.228 1.874 -2.861 1.874 -4.597 C 53.875 76.24 53.209 74.607 52.002 73.379 Z',
    'ParallelMultiInstance': 'M 51.5,69.5 L52.5,69.5 L52.5,84.5 L51.5 84.5 Z M 46.5,69.5 L47.5,69.5 L47.5,84.5 L46.5 84.5 Z' +
        ' M 41.5,69.5 L42.5,69.5 L42.5,84.5 L41.5 84.5 Z  ',
    'SequenceMultiInstance': 'M 40.375,71.5 L 55.375,71.5 L 55.375,72.5 L 40.375,72.5 Z M 40.375,76.5 L 55.375,76.5 ' +
        'L 55.375,77.5 L 40.375,77.5 Z M 40.375,76.5 L 55.375,76.5 L 55.375,77.5 L 40.375,77.5 Z M 40.375,81.5 L 55.375,81.5' +
        'L 55.375,82.5 L 40.375,82.5 Z'
};

/* eslint-disable jsdoc/require-returns */
/**
 * ConnectorBridging defines the bridging behavior
 */
/** @private */
var ConnectorBridging = /** @class */ (function () {
    /**
     * Constructor for the bridging module
     *
     * @private
     */
    function ConnectorBridging() {
        //constructs the bridging module
    }
    /**
     * @param {Connector}conn - provide the target  value.
     * @param {Diagram}diagram - provide the target  value.
     * @private
     */
    ConnectorBridging.prototype.updateBridging = function (conn, diagram) {
        var lastBridge = [];
        var bounds;
        conn.bridges = [];
        if (canBridge(conn, diagram)) {
            // if (this.canBridge(conn, diagram)) {
            var points1 = this.getPoints(conn);
            bounds = Rect.toBounds(points1);
            var bridgeSpacing = conn.bridgeSpace;
            var bgedir = diagram.bridgeDirection || 'Top';
            var count = -1;
            var quads = diagram.connectors;
            for (var q = 0; q < quads.length; q++) {
                var connector1 = quads[parseInt(q.toString(), 10)];
                //EJ2-868564- Bridging is enabled when connector visibility is set to False
                if (conn && connector1 && conn.id !== connector1.id && connector1.visible) {
                    var points2 = this.getPoints(connector1);
                    var bounds1 = Rect.toBounds(points2);
                    if (this.intersectsRect(bounds, bounds1)) {
                        var intersectPts = this.intersect(points1, points2, false, bgedir, true);
                        if (intersectPts.length > 0) {
                            for (var i = 0; i < intersectPts.length; i++) {
                                var fullLength = 0;
                                var length_1 = 0;
                                var segmentIndex = 0;
                                var pointIndex = 0;
                                var obj = this.getLengthAtFractionPoint(conn, intersectPts[parseInt(i.toString(), 10)]);
                                if (obj.pointIndex !== -1) {
                                    length_1 = obj.lengthFractionIndex;
                                    fullLength = obj.fullLength;
                                    segmentIndex = obj.segmentIndex;
                                    pointIndex = obj.pointIndex;
                                    var stBridge = this.getPointAtLength((length_1 - (bridgeSpacing / 2)), points1);
                                    var enBridge = this.getPointAtLength((length_1 + (bridgeSpacing / 2)), points1);
                                    if (this.isEmptyPoint(enBridge)) {
                                        enBridge = stBridge;
                                    }
                                    var end = void 0;
                                    var start = conn.sourcePoint;
                                    if (conn.type === 'Straight') {
                                        end = conn.targetPoint;
                                    }
                                    else {
                                        end = conn.intermediatePoints[parseInt(pointIndex.toString(), 10)];
                                    }
                                    var angle = this.angleCalculation(start, end);
                                    if (lastBridge.length) {
                                        var fixedPoint = conn.sourcePoint;
                                        var fix = Math.abs(this.lengthCalculation(fixedPoint, enBridge));
                                        var var1 = 0;
                                        var insertAt = -1;
                                        count = -1;
                                        for (var k = 0; k < lastBridge[parseInt(segmentIndex.toString(), 10)].bridges.length; k++) {
                                            count++;
                                            var arcSeg = lastBridge[parseInt(segmentIndex.toString(), 10)].bridges[parseInt(k.toString(), 10)];
                                            var1 = Math.abs(this.lengthCalculation(fixedPoint, arcSeg.endPoint));
                                            if (fix < var1) {
                                                insertAt = count;
                                                break;
                                            }
                                        }
                                        if (insertAt >= 0) {
                                            //let paths: ArcSegment;
                                            // eslint-disable-next-line max-len
                                            var paths = this.createSegment(stBridge, enBridge, angle, bgedir, pointIndex, conn, diagram);
                                            paths.target = connector1.id;
                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridges.splice(insertAt, 0, paths);
                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridges.join();
                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridgeStartPoint.splice(insertAt, 0, stBridge);
                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridgeStartPoint.join();
                                            lastBridge[parseInt(segmentIndex.toString(), 10)].segmentIndex = segmentIndex;
                                        }
                                        else {
                                            //let paths: ArcSegment;
                                            // eslint-disable-next-line max-len
                                            var paths = this.createSegment(stBridge, enBridge, angle, bgedir, pointIndex, conn, diagram);
                                            paths.target = connector1.id;
                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridges.push(paths);
                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridgeStartPoint.push(stBridge);
                                            lastBridge[parseInt(segmentIndex.toString(), 10)].segmentIndex = segmentIndex;
                                        }
                                    }
                                    else {
                                        if (!isNaN(stBridge.x) && !isNaN(stBridge.y) && !this.isEmptyPoint(enBridge)) {
                                            //let arcs: ArcSegment;
                                            var bges = [];
                                            var bgept = [];
                                            // eslint-disable-next-line max-len
                                            var arcs = this.createSegment(stBridge, enBridge, angle, bgedir, pointIndex, conn, diagram);
                                            var bgseg = {
                                                bridges: bges, bridgeStartPoint: bgept, segmentIndex: segmentIndex
                                            };
                                            arcs.target = connector1.id;
                                            var stPoints = [];
                                            var edPoints = [];
                                            stPoints.push(stBridge);
                                            edPoints.push(enBridge);
                                            lastBridge[parseInt(segmentIndex.toString(), 10)] = bgseg;
                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridges.push(arcs);
                                            lastBridge[parseInt(segmentIndex.toString(), 10)].bridgeStartPoint = stPoints;
                                            lastBridge[parseInt(segmentIndex.toString(), 10)].segmentIndex = segmentIndex;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (lastBridge.length !== 0) {
                this.firstBridge(lastBridge, conn, bridgeSpacing);
            }
        }
    };
    /**
     * @param {BridgeSegment[]}bridgeList - provide the bridgeList  value.
     * @param {Connector}connector - provide the connector  value.
     * @param {number}bridgeSpacing - provide the bridgeSpacing  value.
     * @private
     */
    ConnectorBridging.prototype.firstBridge = function (bridgeList, connector, bridgeSpacing) {
        for (var i = 0; i < bridgeList.length; i++) {
            var bridge = bridgeList[parseInt(i.toString(), 10)];
            for (var k = 1; k < bridge.bridges.length; k++) {
                if (Point.findLength(bridge.bridges[parseInt(k.toString(), 10)].endPoint, bridge.bridges[k - 1].endPoint) < bridgeSpacing) {
                    bridge.bridges[k - 1].endPoint = bridge.bridges[parseInt(k.toString(), 10)].endPoint;
                    var subBridge = bridge.bridges[k - 1];
                    var arc = this.createBridgeSegment(subBridge.startPoint, subBridge.endPoint, subBridge.angle, bridgeSpacing, subBridge.sweep);
                    bridge.bridges[k - 1].path = arc;
                    bridge.bridges.splice(k, 1);
                    bridge.bridgeStartPoint.splice(k, 1);
                    k--;
                }
            }
            var pre = connector.sourcePoint;
            for (var j = 0; j < bridge.bridges.length; j++) {
                var subBridge = bridge.bridges[parseInt(j.toString(), 10)]; //const preventChecking: boolean = true;
                pre = subBridge.endPoint;
                connector.bridges.push(subBridge);
            }
        }
    };
    /**
     * @returns { ArcSegment } checkSourcePointInTarget method .\
     * @param {PointModel}st- provide the st  value.
     * @param {PointModel}end- provide the end  value.
     * @param {number}angle- provide the angle  value.
     * @param {BridgeDirection}direction- provide the direction  value.
     * @param {number}index- provide the index  value.
     * @param {Connector}conn- provide the conn  value.
     * @param {Diagram} diagram- provide the diagram  value.
     * @private
     */
    ConnectorBridging.prototype.createSegment = function (st, end, angle, direction, index, conn, diagram) {
        //let arc: string;
        //let sweep: number;
        var path = {
            angle: 0, endPoint: { x: 0, y: 0 }, target: '', path: '',
            segmentPointIndex: -1, startPoint: { x: 0, y: 0 }, sweep: 1, rendered: false
        };
        var sweep = this.sweepDirection(angle, direction, conn, diagram);
        var arc = this.createBridgeSegment(st, end, angle, conn.bridgeSpace, sweep);
        path.path = arc;
        path.startPoint = st;
        path.endPoint = end;
        path.angle = angle;
        path.segmentPointIndex = index;
        path.sweep = sweep;
        return path;
    };
    /**
     * @param {PointModel}startPt- provide the startPt  value.
     * @param {PointModel}endPt- provide the endPt  value.
     * @param {number}angle- provide the angle  value.
     * @param {number}bridgeSpace- provide the bridgeSpace  value.
     * @param {number}sweep- provide the sweep  value.
     * @private
     */
    ConnectorBridging.prototype.createBridgeSegment = function (startPt, endPt, angle, bridgeSpace, sweep) {
        var path = 'A ' + bridgeSpace / 2 + ' ' + bridgeSpace / 2 + ' ' + angle + ' , 1 ' + sweep + ' ' + endPt.x + ',' + endPt.y;
        return path;
    };
    /**
     * @param {number}angle- provide the source value.
     * @param {BridgeDirection}bridgeDirection- provide the source value.
     * @param {Connector}connector- provide the source value.
     * @param {Diagram}diagram- provide the source value.
     * @private
     */
    ConnectorBridging.prototype.sweepDirection = function (angle, bridgeDirection, connector, diagram) {
        var angle1 = Math.abs(angle);
        var sweep;
        switch (bridgeDirection) {
            case 'Top':
            case 'Bottom':
                sweep = 1;
                if (angle1 >= 0 && angle1 <= 90) {
                    sweep = 0;
                }
                break;
            case 'Left':
            case 'Right':
                sweep = 1;
                if (angle < 0 && angle >= -180) {
                    sweep = 0;
                }
                break;
        }
        if (bridgeDirection === 'Right' || bridgeDirection === 'Bottom') {
            if (sweep === 0) {
                sweep = 1;
            }
            else {
                sweep = 0;
            }
        }
        return sweep;
    };
    /** @private */
    ConnectorBridging.prototype.getPointAtLength = function (length, pts) {
        var run = 0;
        var pre;
        var found = { x: 0, y: 0 };
        for (var i = 0; i < pts.length; i++) {
            var pt = pts[parseInt(i.toString(), 10)];
            if (!pre) {
                pre = pt;
                continue;
            }
            else {
                var l = this.lengthCalculation(pre, pt);
                if (run + l > length) {
                    var r = length - run;
                    var deg = Point.findAngle(pre, pt);
                    var x = r * Math.cos(deg * Math.PI / 180);
                    var y = r * Math.sin(deg * Math.PI / 180);
                    found = { x: pre.x + x, y: pre.y + y };
                    break;
                }
                else {
                    run += l;
                }
            }
            pre = pt;
        }
        return found;
    };
    /**
     * @param {PointModel[]}connector- provide the source value.
     * @private
     */
    ConnectorBridging.prototype.getPoints = function (connector) {
        var points = [];
        if (connector.intermediatePoints && (connector.type === 'Straight' || connector.type === 'Orthogonal')) {
            for (var j = 0; j < connector.intermediatePoints.length; j++) {
                points.push(connector.intermediatePoints[parseInt(j.toString(), 10)]);
            }
        }
        return points;
    };
    ConnectorBridging.prototype.intersectsRect = function (rect1, rect2) {
        return ((((rect2.x < (rect1.x + rect1.width)) && (rect1.x < (rect2.x + rect2.width)))
            && (rect2.y < (rect1.y + rect1.height))) && (rect1.y < (rect2.y + rect2.height)));
    };
    /**
     * @param {PointModel[]}points1- provide the source value.
     * @param {PointModel[]}points2- provide the source value.
     * @param {boolean}self- provide the source value.
     * @param {BridgeDirection}bridgeDirection- provide the source value.
     * @param {PointModel[]}zOrder- provide the source value.
     * @private
     */
    ConnectorBridging.prototype.intersect = function (points1, points2, self, bridgeDirection, zOrder) {
        if (self && points2.length >= 2) {
            points2.splice(0, 1);
            points2.splice(0, 1);
        }
        var points = [];
        for (var i = 0; i < points1.length - 1; i++) {
            var pt = this.inter1(points1[parseInt(i.toString(), 10)], points1[i + 1], points2, zOrder, bridgeDirection);
            if (pt.length > 0) {
                for (var k = 0; k < pt.length; k++) {
                    points.push(pt[parseInt(k.toString(), 10)]);
                }
            }
            if (self && points2.length >= 1) {
                points2.splice(0, 1);
            }
        }
        return points;
    };
    /**
     * @param {PointModel}startPt- provide the target  value.
     * @param {PointModel}endPt- provide the target  value.
     * @param {PointModel[]}pts- provide the target  value.
     * @param {boolean}zOrder- provide the target  value.
     * @param {BridgeDirection}bridgeDirection- provide the target  value.
     * @private
     */
    ConnectorBridging.prototype.inter1 = function (startPt, endPt, pts, zOrder, bridgeDirection) {
        var points1 = [];
        for (var i = 0; i < pts.length - 1; i++) {
            var point = intersect2(startPt, endPt, pts[parseInt(i.toString(), 10)], pts[i + 1]);
            if (!this.isEmptyPoint(point)) {
                var angle = this.angleCalculation(startPt, endPt);
                var angle1 = this.angleCalculation(pts[parseInt(i.toString(), 10)], pts[i + 1]);
                angle = this.checkForHorizontalLine(angle);
                angle1 = this.checkForHorizontalLine(angle1);
                switch (bridgeDirection) {
                    case 'Left':
                    case 'Right':
                        if (angle > angle1) {
                            points1.push(point);
                        }
                        break;
                    case 'Top':
                    case 'Bottom':
                        if (angle < angle1) {
                            points1.push(point);
                        }
                        break;
                }
                if (angle === angle1 && zOrder) {
                    points1.push(point);
                }
            }
        }
        return points1;
    };
    ConnectorBridging.prototype.checkForHorizontalLine = function (angle) {
        var temp = 0;
        var roundedAngle = Math.abs(angle);
        if (roundedAngle > 90) {
            temp = 180 - roundedAngle;
        }
        else {
            temp = roundedAngle;
        }
        return temp;
    };
    ConnectorBridging.prototype.isEmptyPoint = function (point) {
        return point.x === 0 && point.y === 0;
    };
    ConnectorBridging.prototype.getLengthAtFractionPoint = function (connector, pointAt) {
        var confirm = 100;
        var pointIndex = -1;
        var fullLength = 0;
        var segmentIndex = -1;
        var count = 0;
        var lengthAtFractionPt = 0;
        var pt1 = connector.sourcePoint;
        var previouspt2 = pt1;
        var points = [];
        for (var i = 0; i < connector.intermediatePoints.length; i++) {
            var point2 = connector.intermediatePoints[parseInt(i.toString(), 10)];
            points.push(point2);
        }
        for (var j = 0; j < points.length; j++) {
            var pt2 = points[parseInt(j.toString(), 10)];
            var suspect = this.getSlope(pt2, pt1, pointAt, connector);
            if (suspect < confirm) {
                confirm = suspect;
                lengthAtFractionPt = fullLength + this.lengthCalculation(pointAt, previouspt2);
                segmentIndex = count;
                pointIndex = j;
            }
            fullLength += Point.findLength(pt2, pt1);
            pt1 = pt2;
            previouspt2 = pt2;
        }
        count++;
        var lengthFraction = {
            lengthFractionIndex: lengthAtFractionPt, fullLength: fullLength,
            segmentIndex: segmentIndex, pointIndex: pointIndex
        };
        return lengthFraction;
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ConnectorBridging.prototype.getSlope = function (startPt, endPt, point, connector) {
        var three = 3.0;
        var delX = Math.abs(startPt.x - endPt.x);
        var delY = Math.abs(startPt.y - endPt.y);
        var lhs = ((point.y - startPt.y) / (endPt.y - startPt.y));
        var rhs = ((point.x - startPt.x) / (endPt.x - startPt.x));
        if (!isFinite(lhs) || !isFinite(rhs) || isNaN(lhs) || isNaN(rhs)) {
            if (startPt.x === endPt.x) {
                if (startPt.y === endPt.y) {
                    return 10000;
                }
                else if (((startPt.y > point.y) && (point.y > endPt.y)) || ((startPt.y < point.y) && (point.y < endPt.y))) {
                    return Math.abs(startPt.x - point.x);
                }
            }
            else if (startPt.y === endPt.y) {
                if (((startPt.x > point.x) && (point.x > endPt.x)) || ((startPt.x < point.x) && (point.x < endPt.x))) {
                    return Math.abs(startPt.y - point.y);
                }
            }
        }
        else {
            if ((startPt.x >= point.x && point.x >= endPt.x) || (startPt.x <= point.x && point.x <= endPt.x) || delX < three) {
                if ((startPt.y >= point.y && point.y >= endPt.y) || (startPt.y <= point.y && point.y <= endPt.y) || delY < three) {
                    return Math.abs(lhs - rhs);
                }
            }
        }
        return 10000;
    };
    /**
     * @param {PointModel}startPt- provide the target  value.
     * @param {PointModel}endPt- provide the target  value.
     * @private
     */
    ConnectorBridging.prototype.angleCalculation = function (startPt, endPt) {
        var xDiff = startPt.x - endPt.x;
        var yDiff = startPt.y - endPt.y;
        return Math.atan2(yDiff, xDiff) * (180 / Math.PI);
    };
    ConnectorBridging.prototype.lengthCalculation = function (startPt, endPt) {
        //removed a try catch from here
        var len = Math.sqrt(((startPt.x - endPt.x) * (startPt.x - endPt.x)) + ((startPt.y - endPt.y) * (startPt.y - endPt.y)));
        return len;
    };
    /**
     *To destroy the ruler
     *
     * @returns {void} To destroy the ruler
     */
    ConnectorBridging.prototype.destroy = function () {
        /**
         * Destroys the bridging module
         */
    };
    /**
     * Core method to return the component name.
     *
     * @returns {string}  Core method to return the component name.
     * @private
     */
    ConnectorBridging.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'Bridging';
    };
    return ConnectorBridging;
}());

/**
 * Snapping
 */
var Snapping = /** @class */ (function () {
    function Snapping(diagram) {
        this.line = [];
        this.diagram = diagram;
    }
    /** @private */
    Snapping.prototype.canSnap = function () {
        return (this.diagram.snapSettings.constraints
            & (SnapConstraints.SnapToObject | SnapConstraints.SnapToLines)) !== 0;
    };
    Snapping.prototype.getWrapperObject = function (selectedObject, nameTable) {
        if (selectedObject.nodes && selectedObject.nodes.length > 0
            && (this.diagram.snapSettings.constraints & SnapConstraints.SnapToLines || this.diagram.snapSettings.constraints
                & SnapConstraints.SnapToObject)) {
            for (var i = 0; i < selectedObject.nodes.length; i++) {
                if (((selectedObject.nodes[parseInt(i.toString(), 10)].shape.type === 'SwimLane' || selectedObject.nodes[parseInt(i.toString(), 10)].isLane)
                    || selectedObject.nodes[parseInt(i.toString(), 10)].parentId !== ''
                        && nameTable[(selectedObject.nodes[parseInt(i.toString(), 10)].parentId)]
                        && nameTable[(selectedObject.nodes[parseInt(i.toString(), 10)].parentId)].isLane) && nameTable['helper']) {
                    return nameTable['helper'].wrapper;
                }
                else {
                    return selectedObject.wrapper;
                }
            }
        }
        return selectedObject.wrapper;
    };
    Snapping.prototype.setSnapLineColor = function () {
        return this.diagram.snapSettings.snapLineColor;
    };
    /**
     * Snap to object
     *
     * @private
     */
    Snapping.prototype.snapPoint = function (diagram, selectedObject, towardsLeft, towardsTop, delta, startPoint, endPoint) {
        var snapSettings = this.diagram.snapSettings;
        var zoomFactor = this.diagram.scroller.currentZoom;
        var offset = { x: 0, y: 0 };
        var wrapper = this.getWrapperObject(selectedObject, diagram.nameTable);
        var bounds = getBounds(wrapper);
        var horizontallysnapped = { snapped: false, offset: 0 };
        var verticallysnapped = { snapped: false, offset: 0 };
        if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject) {
            //let snapLine: SVGElement;
            var snapLine = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            snapLine.setAttribute('id', '_SnappingLines');
            snapLine.setAttribute('shapeRendering', 'crispEdges');
            this.getAdornerLayerSvg().appendChild(snapLine);
            this.snapObject(diagram, selectedObject, snapLine, horizontallysnapped, verticallysnapped, delta, startPoint === endPoint);
        }
        //original position
        var left = bounds.x + delta.x;
        var top = bounds.y + delta.y;
        var right = bounds.x + bounds.width + delta.x;
        var bottom = bounds.y + bounds.height + delta.y;
        var scaledIntervals = snapSettings.verticalGridlines.scaledIntervals;
        //snapped positions
        var roundedRight = this.round(right, scaledIntervals, zoomFactor);
        var roundedLeft = this.round(left, scaledIntervals, zoomFactor);
        scaledIntervals = snapSettings.horizontalGridlines.scaledIntervals;
        var roundedTop = this.round(top, scaledIntervals, zoomFactor);
        var roundedBottom = this.round(bottom, scaledIntervals, zoomFactor);
        //currentposition
        var currentright = bounds.x + bounds.width;
        var currentbottom = bounds.y + bounds.height;
        if (!horizontallysnapped.snapped) {
            if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToVerticalLines) {
                if (Math.abs(delta.x) >= 1) {
                    if (towardsLeft) {
                        if (Math.abs(roundedRight - currentright) > Math.abs(roundedLeft - bounds.x)) {
                            offset.x += roundedLeft - bounds.x;
                        }
                        else {
                            offset.x += roundedRight - currentright;
                        }
                    }
                    else {
                        if (Math.abs(roundedRight - currentright) < Math.abs(roundedLeft - bounds.x)) {
                            offset.x += roundedRight - currentright;
                        }
                        else {
                            offset.x += roundedLeft - bounds.x;
                        }
                    }
                }
            }
            else {
                offset.x = endPoint.x - startPoint.x;
            }
        }
        else {
            if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject) {
                offset.x = horizontallysnapped.offset;
            }
            else {
                offset.x = endPoint.x - startPoint.x;
            }
        }
        if (!verticallysnapped.snapped) {
            if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToHorizontalLines) {
                if (Math.abs(delta.y) >= 1) {
                    if (towardsTop) {
                        if (Math.abs(roundedBottom - currentbottom) > Math.abs(roundedTop - bounds.y)) {
                            offset.y += roundedTop - bounds.y;
                        }
                        else {
                            offset.y += roundedBottom - currentbottom;
                        }
                    }
                    else {
                        if (Math.abs(roundedBottom - currentbottom) < Math.abs(roundedTop - bounds.y)) {
                            offset.y += roundedBottom - currentbottom;
                        }
                        else {
                            offset.y += roundedTop - bounds.y;
                        }
                    }
                }
            }
            else {
                offset.y = endPoint.y - startPoint.y;
            }
        }
        else {
            offset.y = verticallysnapped.offset;
        }
        return offset;
    };
    /**
     * @private
     */
    Snapping.prototype.round = function (value, snapIntervals, scale) {
        if (scale === 1) {
            scale = Math.pow(2, Math.floor(Math.log(scale) / Math.log(2)));
        }
        else {
            scale = scale;
        }
        var cutoff = 0;
        var i = 0;
        for (i = 0; i < snapIntervals.length; i++) {
            cutoff += snapIntervals[parseInt(i.toString(), 10)];
        }
        cutoff /= scale;
        var quotient = Math.floor(Math.abs(value) / cutoff);
        var bal = value % cutoff;
        var prev = quotient * cutoff;
        if (prev !== value) {
            if (value >= 0) {
                for (i = 0; i < snapIntervals.length; i++) {
                    if (bal <= snapIntervals[parseInt(i.toString(), 10)] / scale) {
                        return prev + (bal < (snapIntervals[parseInt(i.toString(), 10)] / (2 * scale))
                            ? 0 : snapIntervals[parseInt(i.toString(), 10)] / scale);
                    }
                    else {
                        prev += snapIntervals[parseInt(i.toString(), 10)] / scale;
                        bal -= snapIntervals[parseInt(i.toString(), 10)] / scale;
                    }
                }
            }
            else {
                prev = prev * -1;
                for (i = snapIntervals.length - 1; i >= 0; i--) {
                    if (Math.abs(bal) <= snapIntervals[parseInt(i.toString(), 10)] / scale) {
                        return prev - (Math.abs(bal) < (snapIntervals[parseInt(i.toString(), 10)] / (2 * scale))
                            ? 0 : snapIntervals[parseInt(i.toString(), 10)] / scale);
                    }
                    else {
                        prev -= snapIntervals[parseInt(i.toString(), 10)] / scale;
                        bal += snapIntervals[parseInt(i.toString(), 10)] / scale;
                    }
                }
            }
        }
        return value;
    };
    //Snap to Object
    Snapping.prototype.snapObject = function (diagram, selectedObject, g, horizontalSnap, verticalSnap, delta, ended) {
        var lengthX = null;
        var lengthY;
        var hTarget;
        var vTarget;
        var scroller = this.diagram.scroller;
        var snapSettings = this.diagram.snapSettings;
        var objectsAtLeft = [];
        var objectsAtRight = [];
        var objectsAtTop = [];
        var objectsAtBottom = [];
        var wrapper = this.getWrapperObject(selectedObject, diagram.nameTable);
        var bounds = getBounds(wrapper);
        var scale = diagram.scroller.currentZoom;
        var hoffset = -scroller.horizontalOffset;
        var voffset = -scroller.verticalOffset;
        var snapObjDistance = snapSettings.snapObjectDistance / scale;
        var viewPort = new Rect(0, 0, scroller.viewPortWidth, scroller.viewPortHeight);
        var hIntersectRect = new Rect(hoffset / scale, (bounds.y - snapObjDistance - 5), viewPort.width / scale, (bounds.height + 2 * snapObjDistance + 10));
        var vIntersectRect = new Rect((bounds.x - snapObjDistance - 5), voffset / scale, (bounds.width + 2 * snapObjDistance + 10), viewPort.height / scale);
        viewPort = new Rect(hoffset / scale, voffset / scale, viewPort.width / scale, viewPort.height / scale);
        var nodes = this.findNodes(diagram.spatialSearch, selectedObject, vIntersectRect, viewPort);
        var i;
        var target;
        var targetBounds;
        var nameTable = diagram.nameTable;
        for (i = 0; i < nodes.length; i++) {
            target = nodes[parseInt(i.toString(), 10)];
            if (this.canBeTarget(diagram, target)) {
                if (!(this.diagram.nameTable[target.id] instanceof Connector) && this.canConsider(nameTable, selectedObject, target)) {
                    targetBounds = target.bounds;
                    if (targetBounds.height + targetBounds.y < delta.y + bounds.y) {
                        objectsAtTop.push({
                            obj: target, distance: Math.abs(bounds.y + delta.y - targetBounds.y - targetBounds.height)
                        });
                    }
                    else if (targetBounds.y > bounds.y + delta.y + bounds.height) {
                        objectsAtBottom.push({ obj: target, distance: Math.abs(bounds.y + delta.y + bounds.height - targetBounds.y) });
                    }
                    if (lengthX == null || lengthX > Math.abs(targetBounds.y - bounds.y - delta.y)) {
                        if (Math.abs(targetBounds.x + targetBounds.width / 2 - (bounds.x + bounds.width / 2 + delta.x)) <=
                            snapObjDistance) {
                            hTarget = this.createSnapObject(targetBounds, bounds, 'centerX');
                            lengthX = Math.abs(targetBounds.y - bounds.y);
                        }
                        else if (Math.abs(targetBounds.x + targetBounds.width - (bounds.x + bounds.width + delta.x)) <= snapObjDistance) {
                            hTarget = this.createSnapObject(targetBounds, bounds, 'right');
                            lengthX = Math.abs(targetBounds.y - bounds.y);
                        }
                        else if (Math.abs(targetBounds.x - (bounds.x + delta.x)) <= snapObjDistance) {
                            hTarget = this.createSnapObject(targetBounds, bounds, 'left');
                            lengthX = Math.abs(targetBounds.y - bounds.y);
                        }
                        else if (Math.abs(targetBounds.x - (bounds.x + bounds.width + delta.x)) <= snapObjDistance) {
                            hTarget = this.createSnapObject(targetBounds, bounds, 'rightLeft');
                            lengthX = Math.abs(targetBounds.y - bounds.y);
                        }
                        else if (Math.abs(targetBounds.x + targetBounds.width - (bounds.x + delta.x)) <= snapObjDistance) {
                            hTarget = this.createSnapObject(targetBounds, bounds, 'leftRight');
                            lengthX = Math.abs(targetBounds.y - bounds.y);
                        }
                    }
                }
            }
        }
        nodes = this.findNodes(diagram.spatialSearch, selectedObject, hIntersectRect, viewPort);
        for (var j = 0; j < nodes.length; j++) {
            target = nodes[parseInt(j.toString(), 10)];
            if (this.canBeTarget(diagram, target)) {
                if (!(this.diagram.nameTable[target.id] instanceof Connector) && this.canConsider(nameTable, selectedObject, target)) {
                    targetBounds = target.bounds;
                    if (targetBounds.x + targetBounds.width < bounds.x + delta.x) {
                        objectsAtLeft[objectsAtLeft.length] = {
                            obj: target, distance: Math.abs((bounds.x + delta.x) - targetBounds.x - targetBounds.width)
                        };
                    }
                    if (targetBounds.x > bounds.x + delta.x + bounds.width) {
                        objectsAtRight[objectsAtRight.length] = {
                            obj: target, distance: Math.abs(bounds.x + delta.x + bounds.width - targetBounds.x)
                        };
                    }
                    if (lengthY == null || lengthY > Math.abs(targetBounds.x - bounds.x - delta.x)) {
                        if (Math.abs(targetBounds.y + targetBounds.height / 2 - (bounds.y + bounds.height / 2 + delta.y))
                            <= snapObjDistance) {
                            vTarget = this.createSnapObject(targetBounds, bounds, 'centerY');
                            lengthY = Math.abs(targetBounds.x - bounds.x);
                        }
                        else if (Math.abs(targetBounds.y - bounds.y - delta.y) <= snapObjDistance) {
                            vTarget = this.createSnapObject(targetBounds, bounds, 'top');
                            lengthY = Math.abs(targetBounds.x - bounds.x);
                        }
                        else if (Math.abs(targetBounds.y + targetBounds.height - (bounds.y + bounds.height + delta.y)) <=
                            snapObjDistance) {
                            vTarget = this.createSnapObject(targetBounds, bounds, 'bottom');
                            lengthY = Math.abs(targetBounds.x - bounds.x);
                        }
                        else if (Math.abs(targetBounds.y + targetBounds.height - bounds.y - delta.y) <= snapObjDistance) {
                            vTarget = this.createSnapObject(targetBounds, bounds, 'topBottom');
                            lengthY = Math.abs(targetBounds.x - bounds.x);
                        }
                        else if (Math.abs(targetBounds.y - (bounds.y + bounds.height + delta.y)) <= snapObjDistance) {
                            vTarget = this.createSnapObject(targetBounds, bounds, 'bottomTop');
                            lengthY = Math.abs(targetBounds.x - bounds.x);
                        }
                    }
                }
            }
        }
        this.createGuidelines(diagram, hTarget, vTarget, g, horizontalSnap, verticalSnap, ended);
        if (!horizontalSnap.snapped) {
            this.createHSpacingLines(diagram, g, selectedObject, objectsAtLeft, objectsAtRight, horizontalSnap, verticalSnap, ended, delta, snapObjDistance);
        }
        if (!verticalSnap.snapped) {
            this.createVSpacingLines(diagram, g, selectedObject, objectsAtTop, objectsAtBottom, horizontalSnap, verticalSnap, ended, delta, snapObjDistance);
        }
    };
    /**
     * @private
     */
    Snapping.prototype.snapConnectorEnd = function (point) {
        var snapSettings = this.diagram.snapSettings;
        var zoomFactor = this.diagram.scroller.currentZoom;
        if (snapSettings.constraints & SnapConstraints.SnapToLines) {
            point.x = this.round(point.x, snapSettings.verticalGridlines.scaledIntervals, zoomFactor);
            point.y = this.round(point.y, snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);
        }
        return point;
    };
    Snapping.prototype.canBeTarget = function (diagram, node) {
        node = this.diagram.nameTable[node.id];
        return !(isSelected(this.diagram, node, false));
    };
    Snapping.prototype.snapSize = function (diagram, horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, selectedObject, ended) {
        var lengthX;
        var lengthY;
        var snapSettings = this.diagram.snapSettings;
        var scroller = this.diagram.scroller;
        var hTarget;
        var vTarget;
        var bounds = getBounds(selectedObject.wrapper);
        var nameTable = diagram.nameTable;
        var sameWidth = [];
        var sameHeight = [];
        var scale = diagram.scroller.currentZoom;
        var hoffset = -scroller.horizontalOffset;
        var voffset = -scroller.verticalOffset;
        var snapObjDistance = snapSettings.snapObjectDistance / scale;
        var viewPort = new Rect(0, 0, scroller.viewPortWidth, scroller.viewPortHeight);
        var hintersectedrect = new Rect(hoffset / scale, (bounds.y - 5) / scale, viewPort.width / scale, (bounds.height + 10) / scale);
        var vintersectedrect = new Rect((bounds.x - 5) / scale, voffset / scale, (bounds.width + 10) / scale, viewPort.height / scale);
        viewPort = new Rect(hoffset / scale, voffset / scale, viewPort.width / scale, viewPort.height / scale);
        var nodesInView = [];
        var nodes = this.findNodes(diagram.spatialSearch, selectedObject, vintersectedrect, viewPort, nodesInView);
        var i;
        var target;
        var targetBounds;
        for (i = 0; i < nodes.length; i++) {
            target = nodes[parseInt(i.toString(), 10)];
            if (this.canConsider(nameTable, selectedObject, target) && !(this.diagram.nameTable[target.id] instanceof Connector)) {
                targetBounds = target.bounds;
                if (lengthX == null || lengthX > Math.abs(targetBounds.y - bounds.y)) {
                    if (horizontalSnap.left) {
                        if (Math.abs(bounds.x + deltaX - targetBounds.x) <= snapObjDistance) {
                            hTarget = this.createSnapObject(targetBounds, bounds, 'left');
                            lengthX = Math.abs(targetBounds.y - bounds.y);
                        }
                        else if (Math.abs(bounds.x + deltaX - targetBounds.x - targetBounds.width) <= snapObjDistance) {
                            hTarget = this.createSnapObject(targetBounds, bounds, 'leftRight');
                            lengthX = Math.abs(targetBounds.y - bounds.y);
                        }
                    }
                    else if (horizontalSnap.right) {
                        if (Math.abs(bounds.x + deltaX + bounds.width - targetBounds.x - targetBounds.width) <= snapObjDistance) {
                            hTarget = this.createSnapObject(targetBounds, bounds, 'right');
                            lengthX = Math.abs(targetBounds.y - bounds.y);
                        }
                        else if (Math.abs(bounds.x + deltaX + bounds.width - targetBounds.x) <= snapObjDistance) {
                            hTarget = this.createSnapObject(targetBounds, bounds, 'rightLeft');
                            lengthX = Math.abs(targetBounds.y - bounds.y);
                        }
                    }
                }
            }
        }
        nodes = this.findNodes(diagram.spatialSearch, selectedObject, hintersectedrect, viewPort);
        for (var i_1 = 0; i_1 < nodes.length; i_1++) {
            var target_1 = nodes[parseInt(i_1.toString(), 10)];
            if (this.canConsider(nameTable, selectedObject, target_1) && !(this.diagram.nameTable[target_1.id] instanceof Connector)) {
                var targetBounds_1 = target_1.bounds;
                if (lengthY == null || lengthY > Math.abs(targetBounds_1.x - bounds.x)) {
                    if (verticalSnap.top) {
                        if (Math.abs(bounds.y + deltaY - targetBounds_1.y) <= snapObjDistance) {
                            vTarget = this.createSnapObject(targetBounds_1, bounds, 'top');
                            lengthY = Math.abs(targetBounds_1.x - bounds.x);
                        }
                        else if (Math.abs(bounds.y + deltaY - targetBounds_1.y - targetBounds_1.height) <= snapObjDistance) {
                            vTarget = this.createSnapObject(targetBounds_1, bounds, 'topBottom');
                            lengthY = Math.abs(targetBounds_1.x - bounds.x);
                        }
                    }
                    else if (verticalSnap.bottom) {
                        if (Math.abs(bounds.y + bounds.height + deltaY - targetBounds_1.y - targetBounds_1.height) <= snapObjDistance) {
                            vTarget = this.createSnapObject(targetBounds_1, bounds, 'bottom');
                            lengthY = Math.abs(targetBounds_1.x - bounds.x);
                        }
                        else if (Math.abs(bounds.y + bounds.height + deltaY - targetBounds_1.y) <= snapObjDistance) {
                            vTarget = this.createSnapObject(targetBounds_1, bounds, 'bottomTop');
                            lengthY = Math.abs(targetBounds_1.x - bounds.x);
                        }
                    }
                }
            }
        }
        for (i = 0; i < nodesInView.length; i++) {
            target = nodesInView[parseInt(i.toString(), 10)];
            if (this.canConsider(nameTable, selectedObject, target)) {
                var targetBounds_2 = target.bounds;
                var delta = horizontalSnap.left ? -deltaX : deltaX;
                var difference = Math.abs(bounds.width + delta - targetBounds_2.width);
                var actualDiff = void 0;
                if (difference <= snapObjDistance) {
                    actualDiff = horizontalSnap.left ? -targetBounds_2.width + bounds.width : targetBounds_2.width - bounds.width;
                    sameWidth[sameWidth.length] = { source: target, difference: difference, offset: actualDiff };
                }
                delta = verticalSnap.top ? -deltaY : deltaY;
                var dify = Math.abs(bounds.height + delta - targetBounds_2.height);
                if (dify <= snapObjDistance) {
                    actualDiff = verticalSnap.top ? -targetBounds_2.height + bounds.height : targetBounds_2.height - bounds.height;
                    sameHeight[sameHeight.length] = { source: target, difference: dify, offset: actualDiff };
                }
            }
        }
        if (!diagram.getTool) {
            var g_1 = this.createGuidelines(diagram, hTarget, vTarget, snapLine, horizontalSnap, verticalSnap, ended);
        }
        if (!horizontalSnap.snapped && sameWidth.length > 0 && (horizontalSnap.left || horizontalSnap.right)) {
            this.addSameWidthLines(diagram, snapLine, sameWidth, horizontalSnap, ended, selectedObject);
        }
        if (!verticalSnap.snapped && sameHeight.length > 0 && (verticalSnap.top || verticalSnap.bottom)) {
            this.addSameHeightLines(diagram, snapLine, sameHeight, verticalSnap, ended, selectedObject);
        }
    };
    /**
     * Snap to object on top
     *
     * @private
     */
    Snapping.prototype.snapTop = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialBoundsT) {
        var dify = deltaY;
        verticalSnap.top = true;
        var y;
        horizontalSnap.left = horizontalSnap.right = false;
        var zoomFactor = this.diagram.scroller.currentZoom;
        //let initialBoundsT: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);
        if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject && !shape.rotateAngle) {
            //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {
            y = initialBoundsT.y - initialBoundsT.height * shape.pivot.y + deltaY - (shape.offsetY - shape.height * shape.pivot.y);
            this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, deltaX, y, this.diagram.selectedItems, ended);
        }
        if (!verticalSnap.snapped) {
            if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToHorizontalLines) {
                var top_1 = initialBoundsT.y - initialBoundsT.height * shape.pivot.y;
                var actualTop = top_1 + deltaY;
                var roundedTop = this.round(actualTop, this.diagram.snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);
                dify = roundedTop - top_1;
            }
        }
        else {
            dify = (deltaY - y) + verticalSnap.offset;
        }
        return dify;
    };
    /**
     * Snap to object on right
     *
     * @private
     */
    Snapping.prototype.snapRight = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialBound) {
        var difx = deltaX;
        var x;
        horizontalSnap.right = true;
        verticalSnap.top = verticalSnap.bottom = false;
        var zoomFactor = this.diagram.scroller.currentZoom;
        //let initialBound: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);
        if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject && !shape.rotateAngle) {
            //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {
            x = initialBound.x + initialBound.width * (1 - shape.pivot.x) + deltaX - (shape.offsetX + shape.width * (1 - shape.pivot.x));
            this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, x, deltaY, this.diagram.selectedItems, ended);
        }
        if (!horizontalSnap.snapped) {
            if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToVerticalLines) {
                var right = initialBound.x + initialBound.width * (1 - shape.pivot.x);
                var actualRight = right + deltaX;
                var roundedRight = this.round(actualRight, this.diagram.snapSettings.verticalGridlines.scaledIntervals, zoomFactor);
                difx = roundedRight - right;
            }
        }
        else {
            difx = (deltaX - x) + horizontalSnap.offset;
        }
        return difx;
    };
    /**
     * Snap to object on left
     *
     * @private
     */
    Snapping.prototype.snapLeft = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialBoundsB) {
        var difx = deltaX;
        var x = 0;
        horizontalSnap.left = true;
        verticalSnap.top = verticalSnap.bottom = false;
        var zoomFactor = this.diagram.scroller.currentZoom;
        //let initialBoundsB: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);
        if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject && !shape.rotateAngle) {
            //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {
            x = initialBoundsB.x - initialBoundsB.width * shape.pivot.x + deltaX - (shape.offsetX - shape.width * shape.pivot.x);
            this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, x, deltaY, this.diagram.selectedItems, ended);
        }
        if (!horizontalSnap.snapped) {
            if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToVerticalLines) {
                var left = initialBoundsB.x - initialBoundsB.width * shape.pivot.x;
                var actualLeft = left + deltaX;
                var roundedLeft = this.round(actualLeft, this.diagram.snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);
                difx = roundedLeft - left;
            }
        }
        else {
            difx = (deltaX - x) + horizontalSnap.offset;
        }
        return difx;
    };
    /**
     * Snap to object on bottom
     *
     * @private
     */
    Snapping.prototype.snapBottom = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialRect) {
        var dify = deltaY;
        verticalSnap.bottom = true;
        horizontalSnap.left = horizontalSnap.right = false;
        var zoomFactor = this.diagram.scroller.currentZoom;
        var y = 0;
        //let initialRect: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);
        if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject && !shape.rotateAngle) {
            //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {
            y = initialRect.y + initialRect.height * (1 - shape.pivot.y) + deltaY - (shape.offsetY + shape.height * (1 - shape.pivot.y));
            this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, deltaX, y, this.diagram.selectedItems, ended);
        }
        // eslint-disable-next-line max-len
        var bounds = ((shape instanceof TextElement) || (shape instanceof DiagramHtmlElement)) ? getBounds(shape) :
            getBounds(shape.wrapper);
        if (!verticalSnap.snapped) {
            if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToHorizontalLines) {
                var bottom = initialRect.y + initialRect.height * (1 - shape.pivot.y);
                var actualBottom = bottom + deltaY;
                var roundedBottom = this.round(actualBottom, this.diagram.snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);
                dify = roundedBottom - bottom;
            }
        }
        else {
            dify = (deltaY - y) + verticalSnap.offset;
        }
        return dify;
    };
    //To create the same width and same size lines
    Snapping.prototype.createGuidelines = function (diagram, hTarget, vTarget, snapLine, horizontalSnap, verticalSnap, ended) {
        if (hTarget) {
            horizontalSnap.offset = hTarget.offsetX;
            horizontalSnap.snapped = true;
            if (!ended) {
                if (hTarget.type === 'sideAlign') {
                    this.renderAlignmentLines(hTarget.start, hTarget.end, snapLine, diagram.scroller.transform);
                }
                else {
                    this.renderAlignmentLines(hTarget.start, hTarget.end, snapLine, diagram.scroller.transform);
                }
            }
        }
        if (vTarget) {
            verticalSnap.offset = vTarget.offsetY;
            verticalSnap.snapped = true;
            if (!ended) {
                if (vTarget.type === 'sideAlign') {
                    this.renderAlignmentLines(vTarget.start, vTarget.end, snapLine, diagram.scroller.transform);
                }
                else {
                    this.renderAlignmentLines(vTarget.start, vTarget.end, snapLine, diagram.scroller.transform);
                }
            }
        }
        return snapLine;
    };
    //To create the alignment lines
    Snapping.prototype.renderAlignmentLines = function (start, end, svg, transform) {
        start = {
            x: (start.x + transform.tx) * transform.scale,
            y: (start.y + transform.ty) * transform.scale
        };
        end = {
            x: (end.x + transform.tx) * transform.scale,
            y: (end.y + transform.ty) * transform.scale
        };
        var line1 = {
            stroke: this.setSnapLineColor(), strokeWidth: 1, startPoint: { x: start.x, y: start.y },
            endPoint: { x: end.x, y: end.y }, fill: this.setSnapLineColor(), dashArray: '', width: 1,
            x: 0, y: 0, height: 0, angle: 0, pivotX: 0,
            pivotY: 0, visible: true, opacity: 1, id: randomId()
        };
        var i = 0;
        this.line.push(line1);
        for (i = 0; i < this.line.length; i++) {
            this.diagram.diagramRenderer.drawLine(svg, this.line.pop());
        }
    };
    //To create Horizontal spacing lines
    Snapping.prototype.createHSpacingLines = function (diagram, g, shape, objectsAtLeft, objectsAtRight, horizontalSnap, verticalSnap, ended, delta, snapObjDistance) {
        var top = 0;
        this.sortByDistance(objectsAtLeft, 'distance', true);
        this.sortByDistance(objectsAtRight, 'distance', true);
        var equallySpaced = [];
        var bounds;
        if (diagram.selectedObject.helperObject) {
            bounds = getBounds(diagram.selectedObject.helperObject.wrapper);
        }
        else {
            bounds = getBounds(shape.wrapper);
        }
        var nearestleft;
        var nearestright;
        var targetBounds;
        var equaldistance;
        if (objectsAtLeft.length > 0) {
            equallySpaced[equallySpaced.length] = objectsAtLeft[0];
            nearestleft = ((objectsAtLeft[0].obj).bounds);
            top = nearestleft.y;
            if (objectsAtLeft.length > 1) {
                targetBounds = ((objectsAtLeft[1].obj).bounds);
                equaldistance = nearestleft.x - targetBounds.x - targetBounds.width;
                if (Math.abs(equaldistance - objectsAtLeft[0].distance) <= snapObjDistance) {
                    top = this.findEquallySpacedNodesAtLeft(objectsAtLeft, equaldistance, top, equallySpaced);
                }
                else {
                    equaldistance = objectsAtLeft[0].distance;
                }
            }
            else {
                equaldistance = objectsAtLeft[0].distance;
            }
        }
        this.sortByDistance(equallySpaced, 'distance');
        equallySpaced[equallySpaced.length] = { obj: shape, distance: 0 };
        top = bounds.y < top || !top ? bounds.y : top;
        if (objectsAtRight.length > 0) {
            var dist = void 0;
            nearestright = ((objectsAtRight[0].obj).bounds);
            top = nearestright.y < top ? nearestright.y : top;
            if (objectsAtRight.length > 1) {
                targetBounds = ((objectsAtRight[1].obj).bounds);
                dist = targetBounds.x - nearestright.x - nearestright.width;
            }
            if (objectsAtLeft.length > 0) {
                if (Math.abs(objectsAtRight[0].distance - objectsAtLeft[0].distance) <= snapObjDistance) {
                    var adjustablevalue = Math.abs(objectsAtRight[0].distance - objectsAtLeft[0].distance) / 2;
                    (objectsAtRight[0].distance < objectsAtLeft[0].distance) ?
                        equaldistance -= adjustablevalue : equaldistance += adjustablevalue;
                    equallySpaced[equallySpaced.length] = objectsAtRight[0];
                }
                else if (objectsAtLeft.length === 1) {
                    nearestleft = undefined;
                    equallySpaced.splice(0, 1);
                    equallySpaced[equallySpaced.length] = objectsAtRight[0];
                    equaldistance = dist;
                }
            }
            else {
                equaldistance = dist;
                equallySpaced[equallySpaced.length] = objectsAtRight[0];
            }
            if (objectsAtRight.length > 1 && nearestright.x + nearestright.width < targetBounds.x) {
                top = this.findEquallySpacedNodesAtRight(objectsAtRight, dist, top, equallySpaced, snapObjDistance);
            }
        }
        if (equallySpaced.length > 2) {
            this.addHSpacingLines(diagram, g, equallySpaced, ended, top);
            var deltaHorizontal = 0;
            if (ended) {
                deltaHorizontal = delta.x;
            }
            if (nearestleft) {
                horizontalSnap.offset = equaldistance - Math.abs(bounds.x + deltaHorizontal - nearestleft.x - nearestleft.width)
                    + deltaHorizontal;
            }
            else if (nearestright) {
                horizontalSnap.offset = Math.abs(bounds.x + bounds.width + deltaHorizontal - nearestright.x)
                    - equaldistance + deltaHorizontal;
            }
            horizontalSnap.snapped = true;
        }
    };
    //To create vertical spacing lines
    Snapping.prototype.createVSpacingLines = function (diagram, g, shape, objectsAtTop, objectsAtBottom, horizontalSnap, verticalSnap, ended, delta, snapObjDistance) {
        var right = 0;
        this.sortByDistance(objectsAtTop, 'distance', true);
        this.sortByDistance(objectsAtBottom, 'distance', true);
        var equallySpaced = [];
        var wrapper = this.getWrapperObject(shape, diagram.nameTable);
        var bounds = getBounds(wrapper);
        var nearesttop;
        var nearestbottom;
        var targetBounds;
        var equaldistance;
        if (objectsAtTop.length > 0) {
            equallySpaced[equallySpaced.length] = objectsAtTop[0];
            nearesttop = ((objectsAtTop[0].obj).bounds);
            right = nearesttop.x + nearesttop.width;
            if (objectsAtTop.length > 1) {
                targetBounds = ((objectsAtTop[1].obj).bounds);
                equaldistance = nearesttop.y - targetBounds.y - targetBounds.height;
                if (Math.abs(equaldistance - objectsAtTop[0].distance) <= snapObjDistance) {
                    right = this.findEquallySpacedNodesAtTop(objectsAtTop, equaldistance, right, equallySpaced);
                }
                else {
                    equaldistance = objectsAtTop[0].distance;
                }
            }
            else {
                equaldistance = objectsAtTop[0].distance;
            }
        }
        this.sortByDistance(equallySpaced, 'distance');
        equallySpaced[equallySpaced.length] = { obj: shape, distance: 0 };
        right = bounds.x + bounds.width > right || !right ? bounds.x + bounds.width : right;
        var dist;
        if (objectsAtBottom.length > 0) {
            nearestbottom = ((objectsAtBottom[0].obj).bounds);
            right = nearestbottom.x + nearestbottom.width > right ? nearestbottom.x + nearestbottom.width : right;
            if (objectsAtBottom.length > 1) {
                targetBounds = ((objectsAtBottom[1].obj).bounds);
                dist = targetBounds.y - nearestbottom.y - nearestbottom.height;
            }
            if (objectsAtTop.length > 0) {
                if (Math.abs(objectsAtBottom[0].distance - objectsAtTop[0].distance) <= snapObjDistance) {
                    var adjustablevalue = Math.abs(objectsAtBottom[0].distance - objectsAtTop[0].distance) / 2;
                    (objectsAtBottom[0].distance < objectsAtTop[0].distance) ?
                        equaldistance -= adjustablevalue : equaldistance += adjustablevalue;
                    equallySpaced[equallySpaced.length] = objectsAtBottom[0];
                }
                else if (objectsAtTop.length === 1) {
                    nearesttop = undefined;
                    equallySpaced.splice(0, 1);
                    equallySpaced[equallySpaced.length] = objectsAtBottom[0];
                    equaldistance = dist;
                }
            }
            else {
                equaldistance = dist;
                equallySpaced[equallySpaced.length] = objectsAtBottom[0];
            }
            if (objectsAtBottom.length > 1 && targetBounds.y > nearestbottom.y + nearestbottom.height) {
                right = this.findEquallySpacedNodesAtBottom(objectsAtBottom, dist, right, equallySpaced, snapObjDistance);
            }
        }
        if (equallySpaced.length > 2) {
            this.addVSpacingLines(diagram, g, equallySpaced, ended, right);
            var deltaVertical = 0;
            if (ended) {
                deltaVertical = delta.y;
            }
            if (nearesttop) {
                verticalSnap.offset = equaldistance - Math.abs(bounds.y + deltaVertical - nearesttop.y - nearesttop.height) + deltaVertical;
            }
            else if (nearestbottom) {
                verticalSnap.offset = Math.abs(bounds.y + bounds.height + deltaVertical - nearestbottom.y) - equaldistance + deltaVertical;
            }
            verticalSnap.snapped = true;
        }
    };
    //Add the Horizontal spacing lines
    Snapping.prototype.addHSpacingLines = function (diagram, g, equallySpaced, ended, top) {
        var i;
        var start;
        var end;
        if (!ended) {
            for (i = 0; i < equallySpaced.length - 1; i++) {
                var crnt = equallySpaced[parseInt(i.toString(), 10)].obj instanceof Selector ?
                    getBounds((equallySpaced[parseInt(i.toString(), 10)].obj).wrapper)
                    : ((equallySpaced[parseInt(i.toString(), 10)].obj).bounds);
                var next = equallySpaced[i + 1].obj instanceof Selector ?
                    getBounds((equallySpaced[i + 1].obj).wrapper) : ((equallySpaced[i + 1].obj).bounds);
                start = { x: crnt.x + crnt.width, y: top - 15 };
                end = { x: next.x, y: top - 15 };
                this.renderSpacingLines(start, end, g, this.getAdornerLayerSvg(), diagram.scroller.transform);
            }
        }
    };
    //Add the vertical spacing lines
    Snapping.prototype.addVSpacingLines = function (diagram, g, equallySpacedObjects, ended, right) {
        var start;
        var end;
        if (!ended) {
            for (var i = 0; i < equallySpacedObjects.length - 1; i++) {
                var crnt = equallySpacedObjects[parseInt(i.toString(), 10)].obj instanceof Selector ?
                    getBounds((equallySpacedObjects[parseInt(i.toString(), 10)].obj).wrapper)
                    : ((equallySpacedObjects[parseInt(i.toString(), 10)].obj).bounds);
                var next = equallySpacedObjects[i + 1].obj instanceof Selector ?
                    getBounds((equallySpacedObjects[i + 1].obj).wrapper) :
                    ((equallySpacedObjects[i + 1].obj).bounds);
                start = { x: right + 15, y: crnt.y + crnt.height };
                end = { x: right + 15, y: next.y };
                this.renderSpacingLines(start, end, g, this.getAdornerLayerSvg(), diagram.scroller.transform);
            }
        }
    };
    //To add same width lines
    Snapping.prototype.addSameWidthLines = function (diagram, snapLine, sameWidths, horizontalSnap, ended, shape) {
        this.sortByDistance(sameWidths, 'offset');
        var bounds = getBounds(shape.wrapper);
        var target = sameWidths[0];
        var startPt;
        var endPt;
        var targetBounds = (target.source).bounds;
        var sameSizes = [];
        sameSizes.push(sameWidths[0]);
        var i;
        var crntbounds;
        for (i = 1; i < sameWidths.length; i++) {
            crntbounds = (sameWidths[parseInt(i.toString(), 10)].source).bounds;
            if (crntbounds.width === targetBounds.width) {
                sameSizes.push(sameWidths[parseInt(i.toString(), 10)]);
            }
        }
        if (!ended) {
            startPt = { x: bounds.x + target.offset, y: bounds.y - 15 };
            endPt = { x: bounds.x + bounds.width + target.offset, y: bounds.y - 15 };
            this.renderSpacingLines(startPt, endPt, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);
            for (i = 0; i < sameSizes.length; i++) {
                bounds = (sameSizes[parseInt(i.toString(), 10)].source).bounds;
                startPt = { x: bounds.x, y: bounds.y - 15 };
                endPt = { x: bounds.x + bounds.width, y: bounds.y - 15 };
                this.renderSpacingLines(startPt, endPt, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);
            }
        }
        horizontalSnap.offset = target.offset;
        horizontalSnap.snapped = true;
    };
    //To add same height lines
    Snapping.prototype.addSameHeightLines = function (diagram, snapLine, sameHeights, verticalSnap, ended, shape) {
        this.sortByDistance(sameHeights, 'offset');
        var bounds = getBounds(shape.wrapper);
        var target = sameHeights[0];
        var targetBounds = (target.source).bounds;
        var start;
        var end;
        var sameSizes = [];
        sameSizes.push(sameHeights[0]);
        var i;
        var crntbounds;
        for (i = 0; i < sameHeights.length; i++) {
            crntbounds = (sameHeights[parseInt(i.toString(), 10)].source).bounds;
            if (crntbounds.height === targetBounds.height) {
                sameSizes.push(sameHeights[parseInt(i.toString(), 10)]);
            }
        }
        if (!ended) {
            start = { x: bounds.x + bounds.width + 15, y: bounds.y + target.offset };
            end = { x: bounds.x + bounds.width + 15, y: bounds.y + target.offset + bounds.height };
            this.renderSpacingLines(start, end, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);
            for (i = 0; i < sameSizes.length; i++) {
                bounds = (sameSizes[parseInt(i.toString(), 10)].source).bounds;
                start = { x: bounds.x + bounds.width + 15, y: bounds.y };
                end = { x: bounds.x + bounds.width + 15, y: bounds.y + bounds.height };
                this.renderSpacingLines(start, end, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);
            }
        }
        verticalSnap.offset = target.offset;
        verticalSnap.snapped = true;
    };
    //Render spacing lines
    Snapping.prototype.renderSpacingLines = function (start, end, snapLine, svg, transform) {
        var d;
        var line1;
        var element = new PathElement();
        var options = {};
        start = {
            x: (start.x + transform.tx) * transform.scale,
            y: (start.y + transform.ty) * transform.scale
        };
        end = {
            x: (end.x + transform.tx) * transform.scale,
            y: (end.y + transform.ty) * transform.scale
        };
        if (start.x === end.x) {
            d = 'M' + (start.x - 5) + ' ' + (start.y + 5) + 'L' + start.x + ' ' + start.y +
                'L' + (start.x + 5) + ' ' + (start.y + 5) + 'z' + 'M' + (end.x - 5) + ' ' +
                (end.y - 5) + ' L' + end.x + ' ' + end.y + ' L' +
                (end.x + 5) + ' ' + (end.y - 5) + 'z';
            line1 = {
                startPoint: { x: start.x - 8, y: start.y - 1 },
                endPoint: { x: start.x + 8, y: start.y - 1 },
                stroke: this.setSnapLineColor(),
                strokeWidth: 1, fill: this.setSnapLineColor(), dashArray: '', width: 1, x: 0, y: 0, height: 0, angle: 0, pivotX: 0,
                pivotY: 0, visible: true, opacity: 1, id: randomId()
            };
            element.data = d;
            options.data = element.data;
            options.angle = 0;
            options.pivotX = 0;
            options.pivotY = 0;
            options.x = 0;
            options.y = 0;
            options.height = 0;
            options.width = 1;
            options.id = randomId();
            this.diagram.diagramRenderer.drawPath(snapLine, options);
            this.line.push(line1);
            this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());
            line1 = {
                startPoint: { x: end.x - 8, y: end.y + 1 },
                endPoint: { x: end.x + 8, y: end.y + 1 },
                stroke: this.setSnapLineColor(),
                strokeWidth: 1, fill: this.setSnapLineColor(), dashArray: '', width: 1, x: 0, y: 0, height: 0, angle: 0, pivotX: 0,
                pivotY: 0, visible: true, opacity: 1, id: this.getAdornerLayerSvg().id + 'spacing'
            };
            this.line.push(line1);
            this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());
        }
        else {
            d = 'M' + (start.x + 5) + ' ' + (start.y + 5) + ' L' + start.x + ' ' + start.y +
                ' L' + (start.x + 5) + ' ' + (start.y - 5) + 'z' + 'M' + (end.x - 5) + ' ' +
                (end.y - 5) + ' L' + end.x + ' ' + end.y +
                ' L' + (end.x - 5) + ' ' + (end.y + 5) + 'z';
            element.data = d;
            options.data = d;
            options.angle = 0;
            options.pivotX = 0;
            options.pivotY = 0;
            options.x = 0;
            options.y = 0;
            options.height = 0;
            options.width = 1;
            options.id = randomId();
            this.diagram.diagramRenderer.drawPath(snapLine, options);
            line1 = {
                visible: true, opacity: 1, id: randomId(),
                startPoint: { x: start.x - 1, y: start.y - 8 },
                endPoint: { x: start.x - 1, y: start.y + 8 },
                stroke: this.setSnapLineColor(),
                strokeWidth: 1, fill: this.setSnapLineColor(), dashArray: '0', width: 1, x: 0, y: 0, height: 0, angle: 0, pivotX: 0,
                pivotY: 0
            };
            this.line.push(line1);
            this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());
            line1 = {
                width: 1, x: 0, y: 0, height: 0, angle: 0, pivotX: 0,
                pivotY: 0, visible: true, opacity: 1, id: randomId(),
                startPoint: { x: end.x + 1, y: end.y - 8 },
                endPoint: { x: end.x + 1, y: end.y + 8 },
                stroke: this.setSnapLineColor(),
                strokeWidth: 1, fill: this.setSnapLineColor(), dashArray: '0'
            };
            this.line.push(line1);
            this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());
        }
        line1 = {
            startPoint: { x: start.x, y: start.y },
            endPoint: { x: end.x, y: end.y }, stroke: this.setSnapLineColor(), strokeWidth: 1, fill: this.setSnapLineColor(),
            dashArray: '0', width: 1, x: 0, y: 0, height: 0, angle: 0, pivotX: 0,
            pivotY: 0, visible: true, opacity: 1, id: randomId()
        };
        this.line.push(line1);
        this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());
    };
    /**
     * To Create Snap object with position, initial bounds, and final bounds \
     *
     * @returns {  void }  To Create Snap object with position, initial bounds, and final bounds .\
     * @param {Diagram} targetBounds - provide the targetBounds value.
     * @param {Rect} bounds - provide the angle value.
     * @param {string} snap - provide the angle value.
     * @private
     */
    Snapping.prototype.createSnapObject = function (targetBounds, bounds, snap) {
        var snapObject;
        switch (snap) {
            case 'left':
                snapObject = {
                    start: { x: (targetBounds.x), y: Math.min(targetBounds.y, bounds.y) },
                    end: { x: (targetBounds.x), y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height) },
                    offsetX: targetBounds.x - bounds.x, offsetY: 0, type: 'sideAlign'
                };
                break;
            case 'right':
                snapObject = {
                    type: 'sideAlign',
                    start: { x: (targetBounds.x + targetBounds.width), y: Math.min(targetBounds.y, bounds.y) },
                    offsetX: targetBounds.x + targetBounds.width - bounds.x - bounds.width,
                    offsetY: 0,
                    end: {
                        x: (targetBounds.x + targetBounds.width),
                        y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height)
                    }
                };
                break;
            case 'top':
                snapObject = {
                    offsetY: targetBounds.y - bounds.y, offsetX: 0, type: 'sideAlign',
                    start: { x: (Math.min(targetBounds.x, bounds.x)), y: targetBounds.y },
                    end: { x: (Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width)), y: targetBounds.y }
                };
                break;
            case 'bottom':
                snapObject = {
                    type: 'sideAlign', offsetY: targetBounds.y + targetBounds.height - bounds.y - bounds.height, offsetX: 0,
                    end: {
                        x: (Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width)),
                        y: targetBounds.y + targetBounds.height
                    },
                    start: { x: (Math.min(targetBounds.x, bounds.x)), y: targetBounds.y + targetBounds.height }
                };
                break;
            case 'topBottom':
                snapObject = {
                    start: { x: (Math.min(targetBounds.x, bounds.x)), y: targetBounds.y + targetBounds.height },
                    end: {
                        x: (Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width)),
                        y: targetBounds.y + targetBounds.height
                    },
                    offsetY: targetBounds.y + targetBounds.height - bounds.y, offsetX: 0, type: 'sideAlign'
                };
                break;
            case 'bottomTop':
                snapObject = {
                    start: { x: (Math.min(targetBounds.x, bounds.x)), y: targetBounds.y },
                    end: { x: (Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width)), y: targetBounds.y },
                    offsetY: targetBounds.y - bounds.y - bounds.height, offsetX: 0, type: 'sideAlign'
                };
                break;
            case 'leftRight':
                snapObject = {
                    start: { x: (targetBounds.x + targetBounds.width), y: Math.min(targetBounds.y, bounds.y) },
                    end: {
                        x: (targetBounds.x + targetBounds.width),
                        y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height)
                    },
                    offsetX: targetBounds.x + targetBounds.width - bounds.x, offsetY: 0, type: 'sideAlign'
                };
                break;
            case 'rightLeft':
                snapObject = {
                    start: { x: (targetBounds.x), y: (Math.min(targetBounds.y, bounds.y)) },
                    end: { x: (targetBounds.x), y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height) },
                    offsetX: targetBounds.x - bounds.x - bounds.width, offsetY: 0, type: 'sideAlign'
                };
                break;
            case 'centerX':
                snapObject = {
                    start: { x: (targetBounds.x + targetBounds.width / 2), y: (Math.min(targetBounds.y, bounds.y)) },
                    end: {
                        x: (targetBounds.x + targetBounds.width / 2),
                        y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height)
                    },
                    offsetX: targetBounds.x + targetBounds.width / 2 - (bounds.x + bounds.width / 2), offsetY: 0, type: 'centerAlign'
                };
                break;
            case 'centerY':
                snapObject = {
                    start: { x: (Math.min(targetBounds.x, bounds.x)), y: targetBounds.y + targetBounds.height / 2 },
                    end: {
                        x: (Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width)),
                        y: targetBounds.y + targetBounds.height / 2
                    },
                    offsetY: targetBounds.y + targetBounds.height / 2 - (bounds.y + bounds.height / 2), offsetX: 0, type: 'centerAlign'
                };
                break;
        }
        return snapObject;
    };
    /**
     *  Calculate the snap angle \
     *
     * @returns {  void }  Calculate the snap angle .\
     * @param {Diagram} diagram - provide the diagram value.
     * @param {number} angle - provide the angle value.
     * @private
     */
    Snapping.prototype.snapAngle = function (diagram, angle) {
        var snapSettings = this.diagram.snapSettings;
        var snapAngle = snapSettings.snapAngle;
        var width = angle % (snapAngle || 0);
        if (width >= (snapAngle / 2)) {
            return angle + snapAngle - width;
        }
        else {
            return angle - width;
        }
    };
    //Check whether the node to be snapped or not.
    Snapping.prototype.canConsider = function (nameTable, selectedObject, target) {
        if (this.diagram.selectedItems.nodes.length && this.diagram.selectedItems.nodes[0].id === target.id) {
            return false;
        }
        else {
            return true;
        }
    };
    //Find the total number of nodes in diagram using SpatialSearch
    Snapping.prototype.findNodes = function (spatialSearch, node, child, viewPort, nodesInView) {
        var nodes = [];
        var nd;
        var bounds;
        var quads = spatialSearch.findQuads(nodesInView ? viewPort : child);
        for (var i = 0; i < quads.length; i++) {
            var quad = quads[parseInt(i.toString(), 10)];
            if (quad.objects.length > 0) {
                for (var j = 0; j < quad.objects.length; j++) {
                    nd = quad.objects[parseInt(j.toString(), 10)];
                    if (!(this.diagram.nameTable[nd.id] instanceof Connector) && nd.visible
                        && !(this.diagram.nameTable[nd.id].shape.type === 'SwimLane') && !(this.diagram.nameTable[nd.id].isLane) &&
                        !(this.diagram.nameTable[nd.id].isPhase) && !(this.diagram.nameTable[nd.id].isHeader) && nd.id !== 'helper') {
                        bounds = getBounds(nd);
                        if (nodes.indexOf(nd) === -1 && this.intersectsRect(child, bounds)) {
                            nodes.push(nd);
                        }
                        if (nodesInView && nodesInView.indexOf(nd) && this.intersectsRect(viewPort, bounds)) {
                            nodesInView.push(nd);
                        }
                    }
                }
            }
        }
        return nodes;
    };
    Snapping.prototype.intersectsRect = function (child, bounds) {
        return ((((bounds.x < (child.x + child.width)) && (child.x < (bounds.x + bounds.width)))
            && (bounds.y < (child.y + child.height))) && (child.y < (bounds.y + bounds.height)));
    };
    Snapping.prototype.getAdornerLayerSvg = function () {
        return this.diagram.diagramRenderer.adornerSvgLayer;
    };
    /**
     *  To remove grid lines on mouse move and mouse up \
     *
     * @returns {  void }  To remove grid lines on mouse move and mouse up .\
     * @param {Diagram} diagram - provide the source value.
     * @private
     */
    Snapping.prototype.removeGuidelines = function (diagram) {
        var selectionRect = this.getAdornerLayerSvg().getElementById('_SnappingLines');
        var line = this.getAdornerLayerSvg().getElementById('pivotLine');
        if (selectionRect) {
            selectionRect.parentNode.removeChild(selectionRect);
        }
        if (line) {
            line.parentNode.removeChild(line);
        }
    };
    //Sort the objects by its distance
    Snapping.prototype.sortByDistance = function (obj, value, ascending) {
        var i;
        var j;
        var temp;
        if (ascending) {
            for (i = 0; i < obj.length; i++) {
                for (j = i + 1; j < obj.length; j++) {
                    if (obj[parseInt(i.toString(), 10)]["" + value] > obj[parseInt(j.toString(), 10)]["" + value]) {
                        temp = obj[parseInt(i.toString(), 10)];
                        obj[parseInt(i.toString(), 10)] = obj[parseInt(j.toString(), 10)];
                        obj[parseInt(j.toString(), 10)] = temp;
                    }
                }
            }
        }
        else {
            for (i = 0; i < obj.length; i++) {
                for (j = i + 1; j < obj.length; j++) {
                    if (obj[parseInt(i.toString(), 10)]["" + value] < obj[parseInt(j.toString(), 10)]["" + value]) {
                        temp = obj[parseInt(i.toString(), 10)];
                        obj[parseInt(i.toString(), 10)] = obj[parseInt(j.toString(), 10)];
                        obj[parseInt(j.toString(), 10)] = temp;
                    }
                }
            }
        }
    };
    //To find nodes that are equally placed at left of the selected node
    Snapping.prototype.findEquallySpacedNodesAtLeft = function (objectsAtLeft, equalDistance, top, equallySpaced) {
        var prevBounds;
        var targetBounds;
        var dist;
        var i;
        for (i = 1; i < objectsAtLeft.length; i++) {
            prevBounds = ((objectsAtLeft[i - 1].obj).bounds);
            targetBounds = ((objectsAtLeft[parseInt(i.toString(), 10)].obj).bounds);
            dist = prevBounds.x - targetBounds.x - targetBounds.width;
            if (Math.abs(dist - equalDistance) <= 1) {
                equallySpaced[equallySpaced.length] = objectsAtLeft[parseInt(i.toString(), 10)];
                if (targetBounds.y < top) {
                    top = targetBounds.y;
                }
            }
            else {
                break;
            }
        }
        return top;
    };
    //To find nodes that are equally placed at right of the selected node
    Snapping.prototype.findEquallySpacedNodesAtRight = function (objectsAtRight, equalDistance, top, equallySpaced, snapObjDistance) {
        var actualDistance = objectsAtRight[0].distance;
        var target;
        var targetBounds;
        var prevBounds;
        var dist;
        if (Math.abs(equalDistance - actualDistance) <= snapObjDistance) {
            for (var i = 0; i < objectsAtRight.length - 1; i++) {
                target = objectsAtRight[parseInt(i.toString(), 10)].obj;
                targetBounds = ((objectsAtRight[i + 1].obj).bounds);
                prevBounds = (target.bounds);
                dist = targetBounds.x - prevBounds.x - prevBounds.width;
                if (Math.abs(dist - equalDistance) <= 1) {
                    equallySpaced[equallySpaced.length] = objectsAtRight[i + 1];
                    if (prevBounds.y < top) {
                        top = prevBounds.y;
                    }
                }
                else {
                    break;
                }
            }
        }
        return top;
    };
    Snapping.prototype.findEquallySpacedNodesAtTop = function (objectsAtTop, equalDistance, right, equallySpaced) {
        var prevBounds;
        var targetBounds;
        var dist;
        for (var i = 1; i < objectsAtTop.length; i++) {
            prevBounds = ((objectsAtTop[i - 1].obj).bounds);
            targetBounds = ((objectsAtTop[parseInt(i.toString(), 10)].obj).bounds);
            dist = prevBounds.y - targetBounds.y - targetBounds.height;
            if (Math.abs(dist - equalDistance) <= 1) {
                equallySpaced[equallySpaced.length] = objectsAtTop[parseInt(i.toString(), 10)];
                if (targetBounds.x + targetBounds.width > right) {
                    right = targetBounds.x + targetBounds.width;
                }
            }
            else {
                break;
            }
        }
        return right;
    };
    //To find nodes that are equally placed at bottom of the selected node
    Snapping.prototype.findEquallySpacedNodesAtBottom = function (objectsAtBottom, equalDistance, right, equallySpaced, snapObjDistance) {
        var actualDistance = objectsAtBottom[0].distance;
        var target;
        var targetBounds;
        var prevBounds;
        var dist;
        if (Math.abs(equalDistance - actualDistance) <= snapObjDistance) {
            for (var i = 0; i < objectsAtBottom.length - 1; i++) {
                target = objectsAtBottom[parseInt(i.toString(), 10)].obj;
                targetBounds = ((objectsAtBottom[i + 1].obj).bounds);
                prevBounds = (target.bounds);
                dist = targetBounds.y - prevBounds.y - prevBounds.height;
                if (Math.abs(dist - equalDistance) <= 1) {
                    equallySpaced[equallySpaced.length] = objectsAtBottom[i + 1];
                    if (prevBounds.x + prevBounds.width > right) {
                        right = prevBounds.x + prevBounds.width;
                    }
                }
                else {
                    break;
                }
            }
        }
        return right;
    };
    /**
     * To get Adoner layer to draw snapLine
     *
     * @private
     */
    Snapping.prototype.getLayer = function () {
        var snapLine;
        if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject) {
            snapLine = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            snapLine.setAttribute('id', '_SnappingLines');
            snapLine.setAttribute('shapeRendering', 'crispEdges');
            this.getAdornerLayerSvg().appendChild(snapLine);
        }
        return snapLine;
    };
    /**
     * Constructor for the snapping module
     *
     * @private
     */
    // constructor() {
    //     //constructs the snapping module
    // }
    /**
     *To destroy the ruler
     *
     * @returns {void} To destroy the ruler
     */
    Snapping.prototype.destroy = function () {
        /**
         * Destroys the snapping module
         */
    };
    /**
     * Core method to return the component name.
     *
     * @returns {string}  Core method to return the component name.
     * @private
     */
    Snapping.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'Snapping';
    };
    return Snapping;
}());

/**
 * Undo redo function used for revert and restore the changes
 */
var UndoRedo = /** @class */ (function () {
    /**
     * Constructor for the undo redo module
     *
     * @private
     */
    function UndoRedo() {
        this.groupUndo = false;
        this.childTable = [];
        this.historyCount = 0;
        this.hasGroup = false;
        this.groupCount = 0;
        this.undoOffsets = [];
        this.checkRedo = false;
        //constructs the undo redo module
    }
    /**
     * initHistory method \
     *
     * @returns { void } initHistory method .\
     * @param {Diagram} diagram - provide the points value.
     *
     * @private
     */
    UndoRedo.prototype.initHistory = function (diagram) {
        diagram.historyManager = {
            canRedo: false, canUndo: false, currentEntry: null,
            push: diagram.addHistoryEntry.bind(diagram), undo: Function, redo: Function,
            startGroupAction: diagram.startGroupAction.bind(diagram), endGroupAction: diagram.endGroupAction.bind(diagram),
            canLog: null, undoStack: [], redoStack: [], stackLimit: diagram.historyManager ? diagram.historyManager.stackLimit : undefined
        };
    };
    /**
     * addHistoryEntry method \
     *
     * @returns { void } addHistoryEntry method .\
     * @param {HistoryEntry} entry - provide the points value.
     * @param {Diagram} diagram - provide the points value.
     *
     * @private
     */
    UndoRedo.prototype.addHistoryEntry = function (entry, diagram) {
        // Bug: 903791-remove StartGroup & EndGroup entry when no actual changes wrapped between them.
        if (entry.type === 'EndGroup' && diagram.historyManager.currentEntry.type === 'StartGroup') {
            if (diagram.historyManager.currentEntry.previous) {
                diagram.historyManager.currentEntry.previous.next = undefined;
            }
            diagram.historyManager.currentEntry = diagram.historyManager.currentEntry.previous;
            // when cancelled change startGroup is only entry in history manager
            if (!diagram.historyManager.currentEntry) {
                diagram.historyManager.canUndo = false;
            }
            return false;
        }
        var entryObject = null;
        var nextEntry = null;
        if (diagram.historyManager.canLog) {
            var hEntry = diagram.historyManager.canLog(entry);
            if (hEntry.cancel === true) {
                return false;
            }
        }
        if (diagram.historyManager && diagram.historyManager.canUndo && diagram.historyManager.currentEntry) {
            entryObject = diagram.historyManager.currentEntry;
            if (entryObject.next) {
                if (entryObject.previous) {
                    nextEntry = entryObject.next;
                    nextEntry.previous = null;
                    entryObject.next = entry;
                    entry.previous = entryObject;
                }
            }
            else {
                entryObject.next = entry;
                entry.previous = entryObject;
            }
        }
        diagram.historyManager.currentEntry = entry;
        if (diagram.historyManager.stackLimit) {
            if (entry.type === 'StartGroup' || entry.type === 'EndGroup') {
                var value = entry.type === 'EndGroup' ? true : false;
                this.setEntryLimit(value);
            }
            if (!this.hasGroup && this.groupCount === 0) {
                if (this.historyCount < diagram.historyManager.stackLimit) {
                    this.historyCount++;
                }
                else {
                    this.applyLimit(diagram.historyManager.currentEntry, diagram.historyManager.stackLimit, diagram);
                }
            }
        }
        this.getHistoryList(diagram);
        diagram.historyManager.canUndo = true;
        diagram.historyManager.canRedo = false;
        return true;
    };
    /**
     * applyLimit method \
     *
     * @returns { void } applyLimit method .\
     * @param {HistoryEntry} list - provide the list value.
     * @param {number} stackLimit - provide the list value.
     * @param {Diagram} diagram - provide the list value.
     * @param {boolean} limitHistory - provide the list value.
     *
     * @private
     */
    UndoRedo.prototype.applyLimit = function (list, stackLimit, diagram, limitHistory) {
        if (list && list.previous) {
            if (list.type === 'StartGroup' || list.type === 'EndGroup') {
                var value = list.type === 'StartGroup' ? true : false;
                this.setEntryLimit(value);
            }
            if (!this.hasGroup && this.groupCount === 0) {
                stackLimit--;
            }
            if (stackLimit === 0) {
                if (limitHistory) {
                    this.limitHistoryStack(list.previous, diagram);
                }
                if (diagram.historyManager.stackLimit < this.historyCount) {
                    this.historyCount = diagram.historyManager.stackLimit;
                }
                delete list.previous;
            }
            else if (list.previous) {
                this.applyLimit(list.previous, stackLimit, diagram, limitHistory);
            }
        }
        this.groupCount = 0;
    };
    /**
     * clearHistory method \
     *
     * @returns { void } clearHistory method .\
     * @param {Diagram} diagram - provide the points value.
     *
     * @private
     */
    UndoRedo.prototype.clearHistory = function (diagram) {
        var hList = diagram.historyManager;
        hList.currentEntry = undefined;
        hList.canUndo = false;
        hList.canRedo = false;
        this.historyCount = 0;
        this.groupCount = 0;
        diagram.historyManager.undoStack = [];
        diagram.historyManager.redoStack = [];
    };
    UndoRedo.prototype.setEntryLimit = function (value) {
        // eslint-disable-next-line @typescript-eslint/no-unused-expressions
        value ? this.groupCount-- : this.groupCount++;
        // eslint-disable-next-line @typescript-eslint/no-unused-expressions
        value ? this.hasGroup = !value : this.hasGroup = value;
    };
    UndoRedo.prototype.limitHistoryStack = function (list, diagram) {
        if (list.type !== 'StartGroup' && list.type !== 'EndGroup') {
            this.removeFromStack(diagram.historyManager.undoStack, list);
            this.removeFromStack(diagram.historyManager.redoStack, list);
        }
        if (list.previous) {
            this.limitHistoryStack(list.previous, diagram);
        }
    };
    UndoRedo.prototype.removeFromStack = function (entyList, list) {
        if (entyList.length) {
            for (var i = 0; i <= entyList.length; i++) {
                if (entyList[parseInt(i.toString(), 10)].undoObject === list.undoObject
                    && entyList[parseInt(i.toString(), 10)].redoObject === list.redoObject) {
                    entyList.splice(i, 1);
                    break;
                }
            }
        }
    };
    /**
     * undo method \
     *
     * @returns { void } undo method .\
     * @param {Diagram} diagram - provide the diagram value.
     *
     * @private
     */
    UndoRedo.prototype.undo = function (diagram) {
        var entry = this.getUndoEntry(diagram);
        var endGroupActionCount = 0;
        if (entry) {
            if (entry.category === 'Internal') {
                if (entry.type === 'EndGroup') {
                    endGroupActionCount++;
                    this.groupUndo = true;
                    //Removed isBlazor code
                }
                else {
                    this.undoEntry(entry, diagram);
                }
                if (this.groupUndo) {
                    this.undoGroupAction(entry, diagram, endGroupActionCount);
                    this.groupUndo = false;
                }
            }
            else {
                if (!isBlazor()) {
                    diagram.historyManager.undo(entry);
                }
                var arg = {
                    entryType: 'undo', oldValue: entry.undoObject, newValue: entry.redoObject
                };
                // Removed isBlazor code
                diagram.triggerEvent(DiagramEvent.historyStateChange, arg);
            }
        }
    };
    // Removed getHistoryChangeEvent method as it is not used anywhere
    UndoRedo.prototype.getHistoryList = function (diagram) {
        var undoStack = [];
        var redoStack = [];
        var currEntry = diagram.historyManager.currentEntry;
        var undoObj;
        var redoObj;
        currEntry = diagram.historyManager.currentEntry;
        if (diagram.historyManager.canUndo || diagram.historyManager.undoStack.length === 0) {
            this.getHistroyObject(undoStack, currEntry);
        }
        else {
            this.getHistroyObject(redoStack, currEntry);
        }
        while (currEntry && currEntry.previous) {
            undoObj = currEntry.previous;
            this.getHistroyObject(undoStack, undoObj);
            currEntry = currEntry.previous;
        }
        currEntry = diagram.historyManager.currentEntry;
        while (currEntry && currEntry.next) {
            redoObj = currEntry.next;
            this.getHistroyObject(redoStack, redoObj);
            currEntry = currEntry.next;
        }
        diagram.historyManager.undoStack = undoStack;
        diagram.historyManager.redoStack = redoStack;
    };
    UndoRedo.prototype.getHistroyObject = function (list, obj) {
        if (obj && obj.type !== 'StartGroup' && obj.type !== 'EndGroup') {
            list.push({
                redoObject: obj.redoObject ? obj.redoObject : null,
                undoObject: obj.undoObject ? obj.undoObject : null,
                type: obj.type ? obj.type : null,
                category: obj.category ? obj.category : null
            });
        }
    };
    UndoRedo.prototype.undoGroupAction = function (entry, diagram, endGroupActionCount) {
        while (endGroupActionCount !== 0) {
            this.undoEntry(entry, diagram);
            entry = this.getUndoEntry(diagram);
            if (entry.type === 'StartGroup') {
                endGroupActionCount--;
            }
            else if (entry.type === 'EndGroup') {
                endGroupActionCount++;
            }
        }
        endGroupActionCount = 0;
    };
    UndoRedo.prototype.undoEntry = function (entry, diagram) {
        var obj;
        var nodeObject;
        if (entry.type !== 'PropertyChanged' && entry.type !== 'CollectionChanged' && entry.type !== 'LabelCollectionChanged') {
            obj = entry.undoObject ? entry.undoObject : (entry.previous.undoObject);
            nodeObject = obj;
        }
        if (entry.type !== 'StartGroup' && entry.type !== 'EndGroup') {
            if (diagram.historyManager.undoStack.length > 0) {
                var addObject = diagram.historyManager.undoStack.splice(0, 1);
                diagram.historyManager.redoStack.splice(0, 0, addObject[0]);
                nodeObject = (entry.undoObject);
            }
        }
        diagram.protectPropertyChange(true);
        diagram.diagramActions |= DiagramAction.UndoRedo;
        //Removed isBlazor code
        switch (entry.type) {
            case 'PositionChanged':
            case 'Align':
            case 'Distribute':
                this.recordPositionChanged(obj, diagram);
                break;
            case 'SizeChanged':
            case 'Sizing':
                this.recordSizeChanged(obj, diagram, entry);
                break;
            case 'RotationChanged':
                this.recordRotationChanged(obj, diagram, entry, 'undo');
                break;
            case 'ConnectionChanged':
                this.recordConnectionChanged(obj, diagram);
                break;
            case 'PropertyChanged':
                this.recordPropertyChanged(entry, diagram, false);
                break;
            case 'CollectionChanged':
                if (entry && entry.next && entry.next.type === 'AddChildToGroupNode' && entry.next.changeType === 'Insert') {
                    var group = diagram.getObject(entry.next.undoObject.id);
                    diagram.insertValue(cloneObject(group), true);
                }
                entry.isUndo = true;
                this.recordCollectionChanged(entry, diagram);
                entry.isUndo = false;
                if (entry && entry.next && entry.next.type === 'AddChildToGroupNode' && entry.next.changeType === 'Insert') {
                    var group = diagram.getObject(entry.next.undoObject.id);
                    group.wrapper.measure(new Size());
                    group.wrapper.arrange(group.wrapper.desiredSize);
                    diagram.updateDiagramObject(group);
                }
                break;
            case 'LabelCollectionChanged':
                entry.isUndo = true;
                this.recordLabelCollectionChanged(entry, diagram);
                entry.isUndo = false;
                break;
            case 'PortCollectionChanged':
                entry.isUndo = true;
                this.recordPortCollectionChanged(entry, diagram);
                entry.isUndo = false;
                break;
            case 'Group':
                this.unGroup(entry, diagram);
                break;
            case 'UnGroup':
                this.group(entry, diagram);
                break;
            case 'SegmentChanged':
                this.recordSegmentChanged(obj, diagram);
                break;
            case 'PortPositionChanged':
                this.recordPortChanged(entry, diagram, false);
                break;
            case 'AnnotationPropertyChanged':
                this.recordAnnotationChanged(entry, diagram, false);
                break;
            case 'ChildCollectionChanged':
                this.recordChildCollectionChanged(entry, diagram, false);
                break;
            case 'StackChildPositionChanged':
                this.recordStackPositionChanged(entry, diagram, false);
                break;
            case 'RowHeightChanged':
                this.recordGridSizeChanged(entry, diagram, false, true);
                break;
            case 'ColumnWidthChanged':
                this.recordGridSizeChanged(entry, diagram, false, false);
                break;
            case 'LanePositionChanged':
                this.recordLanePositionChanged(entry, diagram, false);
                break;
            case 'LaneCollectionChanged':
            case 'PhaseCollectionChanged':
                entry.isUndo = true;
                this.recordLaneOrPhaseCollectionChanged(entry, diagram, false);
                entry.isUndo = false;
                break;
            case 'SendToBack':
            case 'SendForward':
            case 'SendBackward':
            case 'BringToFront':
                this.recordOrderCommandChanged(entry, diagram, false);
                break;
            case 'AddChildToGroupNode':
                this.recordAddChildToGroupNode(entry, diagram, false);
                break;
            case 'RemoveChildFromGroupNode':
                this.recordRemoveChildFromGroupNode(entry, diagram, false);
                break;
            case 'ExternalEntry':
                //EJ2-848643 - Need to consider custom entries in start and end group action
                diagram.historyManager.undo(entry);
                break;
        }
        diagram.diagramActions &= ~DiagramAction.UndoRedo;
        diagram.protectPropertyChange(false);
        diagram.historyChangeTrigger(entry, 'Undo');
        if (nodeObject) {
            var object = this.checkNodeObject(nodeObject, diagram);
            if (object) {
                var getnodeDefaults = getFunction(diagram.updateSelection);
                if (getnodeDefaults) {
                    getnodeDefaults(object, diagram);
                }
            }
        }
    };
    UndoRedo.prototype.checkNodeObject = function (value, diagram) {
        var object;
        if (!value.id) {
            if ((value.nodes && value.nodes.length > 0) ||
                (value.connectors && value.connectors.length > 0)) {
                var undoNode = value.nodes.length > 0 ?
                    value.nodes : value.connectors;
                for (var _i = 0, undoNode_1 = undoNode; _i < undoNode_1.length; _i++) {
                    object = undoNode_1[_i];
                    object = diagram.nameTable[object.id];
                }
            }
            else {
                var knownNode = value.nodes ?
                    value.nodes : value.connectors;
                if (knownNode) {
                    for (var _a = 0, _b = Object.keys(knownNode); _a < _b.length; _a++) {
                        var key = _b[_a];
                        var index = Number(key);
                        object = value.nodes ? diagram.nodes[parseInt(index.toString(), 10)]
                            : diagram.connectors[parseInt(index.toString(), 10)];
                    }
                }
            }
        }
        else {
            object = diagram.nameTable[value.id];
        }
        return object;
    };
    UndoRedo.prototype.group = function (historyEntry, diagram) {
        diagram.add(historyEntry.undoObject);
    };
    UndoRedo.prototype.unGroup = function (entry, diagram) {
        //const i: number = 0;
        entry.redoObject = cloneObject(entry.undoObject);
        var node = entry.undoObject;
        diagram.commandHandler.unGroup(node);
    };
    UndoRedo.prototype.ignoreProperty = function (key) {
        if (key === 'zIndex' || key === 'wrapper' || key === 'parentObj' || key === 'controlParent') {
            return true;
        }
        return false;
    };
    UndoRedo.prototype.getProperty = function (collection, property) {
        for (var _i = 0, _a = Object.keys(property); _i < _a.length; _i++) {
            var key = _a[_i];
            if (collection) {
                if (!this.ignoreProperty(key)) {
                    if (property["" + key] instanceof Object) {
                        this.getProperty(collection["" + key], property["" + key]);
                    }
                    else {
                        collection["" + key] = property["" + key];
                    }
                }
            }
        }
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    UndoRedo.prototype.recordLaneOrPhaseCollectionChanged = function (entry, diagram, isRedo) {
        var node = entry.redoObject;
        var obj = entry.undoObject;
        var changeType;
        if (entry.isUndo) {
            if (entry.changeType === 'Insert') {
                changeType = 'Remove';
            }
            else {
                changeType = 'Insert';
            }
        }
        else {
            changeType = entry.changeType;
        }
        if (changeType === 'Remove') {
            diagram.remove(node);
        }
        else {
            if (node.isPhase) {
                var swimlane = diagram.nameTable[node.parentId];
                diagram.addPhases(swimlane, [obj]);
            }
            else {
                var swimlane = diagram.nameTable[node.parentId];
                var laneIndex = findLaneIndex(swimlane, node);
                diagram.addLanes(swimlane, [obj], laneIndex);
            }
        }
        diagram.clearSelection();
    };
    UndoRedo.prototype.recordAnnotationChanged = function (entry, diagram, isRedo) {
        var entryObject = ((isRedo) ? entry.redoObject : entry.undoObject);
        if (diagram.canEnableBlazorObject) {
            var node = cloneObject(diagram.nameTable[entryObject.id]);
            diagram.insertValue(node, node instanceof Node ? true : false);
        }
        var oldElement = findAnnotation(entryObject, entry.objectId);
        var undoChanges = diagram.commandHandler.getAnnotationChanges(diagram.nameTable[entryObject.id], oldElement);
        var currentObject = diagram.nameTable[entryObject.id];
        var currentElement = findAnnotation(currentObject, entry.objectId);
        currentElement.offset = oldElement.offset;
        currentElement.margin = oldElement.margin;
        currentElement.width = oldElement.width;
        currentElement.height = oldElement.height;
        currentElement.rotateAngle = oldElement.rotateAngle;
        currentElement.margin = oldElement.margin;
        if (currentObject instanceof Node) {
            diagram.nodePropertyChange(currentObject, {}, undoChanges);
        }
        else {
            diagram.connectorPropertyChange(currentObject, {}, undoChanges);
        }
    };
    UndoRedo.prototype.recordChildCollectionChanged = function (entry, diagram, isRedo) {
        var entryObject = ((isRedo) ? entry.redoObject : entry.undoObject);
        var parentNode = diagram.nameTable[entryObject.parentId];
        var actualObject = diagram.nameTable[entryObject.id];
        if (parentNode) {
            addChildToContainer(diagram, parentNode, actualObject, !isRedo, entry.historyAction === 'AddNodeToLane', isRedo);
        }
        else {
            if (actualObject.parentId) {
                parentNode = diagram.nameTable[actualObject.parentId];
                if (parentNode) {
                    //929543: To remove the child node from lane children collection.
                    this.removeChildFromLane(diagram, parentNode, actualObject);
                    parentNode.children.splice(parentNode.children.indexOf(actualObject.id), 1);
                    parentNode.wrapper.children.splice(parentNode.wrapper.children.indexOf(actualObject.wrapper), 1);
                }
            }
            if (entryObject.parentId && entryObject.parentId !== '') {
                parentNode = diagram.nameTable[entryObject.parentId];
                parentNode.children.push(entryObject.id);
                parentNode.wrapper.children.push(actualObject.wrapper);
            }
            actualObject.parentId = entryObject.parentId;
            diagram.removeElements(actualObject);
            diagram.updateDiagramObject(actualObject);
        }
    };
    /**
     * removeChildFromLane method \
     *
     * @returns { void } undo method .\
     * @param {Diagram} diagram - provide the diagram value.
     * @param {NodeModel} parentNode - provide the lane obj.
     * @param {Node} actualObject - provide the node value.
     * @private
     */
    UndoRedo.prototype.removeChildFromLane = function (diagram, parentNode, actualObject) {
        var swimlane = diagram.nameTable[parentNode.parentId];
        if (swimlane && swimlane.shape && swimlane.shape.lanes.length > 0) {
            var isHorizontal = swimlane.shape.orientation === 'Horizontal';
            var hasPhases = (swimlane.shape.phases.length > 0) && (swimlane.shape.phaseSize > 0);
            var phaseIndex = 0;
            if (!hasPhases) {
                phaseIndex = 1;
            }
            var index = isHorizontal
                ? (swimlane.shape.hasHeader ? (parentNode.rowIndex - (2 - phaseIndex))
                    : (parentNode.rowIndex - (1 - phaseIndex)))
                : parentNode.columnIndex - (1 - phaseIndex);
            var lane = swimlane.shape.lanes[parseInt(index.toString(), 10)];
            if (lane && lane.children && lane.children.length > 0) {
                for (var i = lane.children.length - 1; i >= 0; i--) {
                    if (lane.children[parseInt(i.toString(), 10)].id === actualObject.id) {
                        lane.children.splice(i, 1);
                    }
                }
            }
        }
    };
    UndoRedo.prototype.recordStackPositionChanged = function (entry, diagram, isRedo) {
        var entryObject = ((isRedo) ? entry.redoObject : entry.undoObject);
        if (entryObject.source) {
            var parent_1 = diagram.nameTable[entryObject.source.parentId];
            if (parent_1) {
                if (entryObject.target) {
                    parent_1.wrapper.children.splice(entryObject.targetIndex, 1);
                    parent_1.wrapper.children.splice(entryObject.sourceIndex, 0, entryObject.source.wrapper);
                }
                else {
                    if (entryObject.sourceIndex !== undefined) {
                        if (!diagram.nameTable[entryObject.source.id]) {
                            diagram.add(entryObject.source);
                        }
                        parent_1.wrapper.children.splice(entryObject.sourceIndex, 0, diagram.nameTable[entryObject.source.id].wrapper);
                        diagram.nameTable[entryObject.source.id].parentId = parent_1.id;
                    }
                    else {
                        parent_1.wrapper.children.splice(parent_1.wrapper.children.indexOf(diagram.nameTable[entryObject.source.id].wrapper), 1);
                        diagram.nameTable[entryObject.source.id].parentId = '';
                    }
                }
                if (isRedo && parent_1.shape.type === 'UmlClassifier') {
                    diagram.remove(entryObject.source);
                }
                parent_1.wrapper.measure(new Size());
                parent_1.wrapper.arrange(parent_1.wrapper.desiredSize);
                diagram.updateDiagramObject(parent_1);
                diagram.updateSelector();
            }
        }
    };
    UndoRedo.prototype.recordGridSizeChanged = function (entry, diagram, isRedo, isRow) {
        var obj = (isRedo) ? entry.redoObject : entry.undoObject;
        var node = (!isRedo) ? entry.redoObject : entry.undoObject;
        if (obj.parentId) {
            var swimlane = diagram.nameTable[obj.parentId];
            var actualObject = diagram.nameTable[obj.id];
            var x = swimlane.wrapper.bounds.x;
            var y = swimlane.wrapper.bounds.y;
            if (swimlane.shape.type === 'SwimLane') {
                var grid = swimlane.wrapper.children[0];
                var padding = swimlane.shape.padding;
                var isUndoRedo = false;
                if (diagram.diagramActions & DiagramAction.UndoRedo) {
                    isUndoRedo = true;
                }
                updateSwimLaneObject(diagram, node, swimlane, obj);
                if (isRow) {
                    grid.updateRowHeight(obj.rowIndex, obj.wrapper.actualSize.height, true, padding, isUndoRedo);
                    swimlane.height = swimlane.wrapper.height = grid.height;
                }
                else {
                    grid.updateColumnWidth(obj.columnIndex, obj.wrapper.actualSize.width, true, padding, isUndoRedo);
                    swimlane.width = swimlane.wrapper.width = grid.width;
                    if (obj.isPhase) {
                        actualObject.maxWidth = actualObject.wrapper.maxWidth = obj.wrapper.actualSize.width;
                    }
                }
                swimLaneMeasureAndArrange(swimlane);
                var tx = x - swimlane.wrapper.bounds.x;
                var ty = y - swimlane.wrapper.bounds.y;
                diagram.drag(swimlane, tx, ty);
                diagram.clearSelection();
                diagram.updateDiagramObject(swimlane);
            }
        }
    };
    UndoRedo.prototype.recordLanePositionChanged = function (entry, diagram, isRedo) {
        var entryObject = ((isRedo) ? entry.redoObject : entry.undoObject);
        if (entryObject.source) {
            var parent_2 = diagram.nameTable[entryObject.source.parentId];
            if (parent_2 && parent_2.shape.type === 'SwimLane') {
                laneInterChanged(diagram, entryObject.target, entryObject.source);
                diagram.clearSelection();
            }
        }
    };
    UndoRedo.prototype.recordPortChanged = function (entry, diagram, isRedo) {
        var entryObject = ((isRedo) ? entry.redoObject.nodes[0] :
            entry.undoObject.nodes[0]);
        if (diagram.canEnableBlazorObject) {
            var node = cloneObject(diagram.nameTable[entryObject.id]);
            diagram.insertValue(node, true);
        }
        var oldElement = findPort(entryObject, entry.objectId);
        var undoChanges = diagram.commandHandler.getPortChanges(diagram.nameTable[entryObject.id], oldElement);
        var currentObject = diagram.nameTable[entryObject.id];
        var currentElement = findPort(currentObject, entry.objectId);
        currentElement.offset = oldElement.offset;
        diagram.nodePropertyChange(currentObject, {}, undoChanges);
        if (currentObject.parentId) {
            diagram.updateConnectorEdges(diagram.nameTable[currentObject.parentId]);
        }
    };
    UndoRedo.prototype.recordPropertyChanged = function (entry, diagram, isRedo) {
        var redoObject = entry.redoObject;
        var undoObject = entry.undoObject;
        //Removed isBlazor code
        this.getProperty(diagram, (isRedo ? redoObject : undoObject));
        // eslint-disable-next-line @typescript-eslint/no-unused-expressions
        isRedo ? diagram.onPropertyChanged(redoObject, undoObject) : diagram.onPropertyChanged(undoObject, redoObject);
        diagram.diagramActions = diagram.diagramActions | DiagramAction.UndoRedo;
    };
    UndoRedo.prototype.recordOrderCommandChanged = function (entry, diagram, isRedo) {
        var redoObject = entry.redoObject;
        var undoObject = entry.undoObject;
        diagram.commandHandler.orderCommands(isRedo, (isRedo ? redoObject : undoObject), entry.type);
        diagram.diagramActions = diagram.diagramActions | DiagramAction.UndoRedo;
    };
    UndoRedo.prototype.recordAddChildToGroupNode = function (entry, diagram, isRedo) {
        var group = diagram.nameTable[entry.undoObject.id];
        var child = diagram.nameTable[entry.objectId];
        if (isRedo && entry.changeType === 'Insert') {
            diagram.addChildToGroup(group, child.id);
        }
        else {
            diagram.removeChildFromGroup(group, child.id);
        }
    };
    UndoRedo.prototype.recordRemoveChildFromGroupNode = function (entry, diagram, isRedo) {
        var group = diagram.nameTable[entry.undoObject.id];
        var child = diagram.nameTable[entry.objectId];
        if (isRedo && entry.changeType === 'Remove') {
            diagram.removeChildFromGroup(group, child.id);
        }
        else {
            diagram.addChildToGroup(group, child.id);
        }
    };
    UndoRedo.prototype.recordSegmentChanged = function (obj, diagram) {
        var i = 0;
        //let node: NodeModel;
        var connector;
        if (obj.connectors && obj.connectors.length > 0) {
            for (i = 0; i < obj.connectors.length; i++) {
                connector = obj.connectors[parseInt(i.toString(), 10)];
                this.segmentChanged(connector, diagram);
            }
        }
    };
    UndoRedo.prototype.segmentChanged = function (connector, diagram) {
        var conn = diagram.nameTable[connector.id];
        conn.segments = connector.segments;
        diagram.commandHandler.updateEndPoint(conn);
    };
    UndoRedo.prototype.recordPositionChanged = function (obj, diagram) {
        var i = 0;
        var node;
        var connector;
        if (obj.nodes && obj.nodes.length > 0) {
            for (i = 0; i < obj.nodes.length; i++) {
                if (diagram.bpmnModule) {
                    diagram.isPositionUndo = true;
                }
                node = obj.nodes[parseInt(i.toString(), 10)];
                this.positionChanged(node, diagram);
            }
            diagram.isPositionUndo = false;
        }
        if (obj.connectors && obj.connectors.length > 0) {
            for (i = 0; i < obj.connectors.length; i++) {
                connector = obj.connectors[parseInt(i.toString(), 10)];
                // 927019: Undo/Redo Does Not Restore Connector Segment Changes
                this.segmentChanged(connector, diagram);
                this.connectionChanged(connector, diagram);
            }
        }
    };
    UndoRedo.prototype.positionChanged = function (obj, diagram) {
        var node = diagram.nameTable[obj.id];
        if (obj.processId && !node.processId) {
            diagram.addProcess(obj, obj.processId);
        }
        if (!obj.processId && node.processId) {
            diagram.removeProcess(obj.id);
        }
        if (node.processId) {
            var tx = obj.margin.left - node.margin.left;
            var ty = obj.margin.top - node.margin.top;
            diagram.drag(node, tx, ty);
        }
        else {
            if (node.parentId) {
                var parent_3 = diagram.nameTable[node.parentId];
                if (parent_3.isLane) {
                    obj.wrapper.offsetX = (obj.width / 2) + (parent_3.wrapper.bounds.x + obj.margin.left);
                    obj.wrapper.offsetY = (obj.height / 2) + (parent_3.wrapper.bounds.y + obj.margin.top);
                }
            }
            var tx = obj.wrapper.offsetX - node.offsetX;
            var ty = obj.wrapper.offsetY - node.offsetY;
            diagram.drag(node, tx, ty);
        }
        if (diagram.bpmnModule) {
            diagram.bpmnModule.updateDocks(node, diagram);
        }
    };
    UndoRedo.prototype.recordSizeChanged = function (obj, diagram, entry) {
        var i = 0;
        var connector;
        var node;
        if (obj && obj.nodes && obj.nodes.length > 0) {
            for (i = 0; i < obj.nodes.length; i++) {
                node = obj.nodes[parseInt(i.toString(), 10)];
                if (node.children && !node.container) {
                    var elements = [];
                    var nodes = diagram.commandHandler.getAllDescendants(node, elements);
                    for (var i_1 = 0; i_1 < nodes.length; i_1++) {
                        var tempNode = entry.childTable[nodes[parseInt(i_1.toString(), 10)].id];
                        if ((getObjectType(tempNode) === Node)) {
                            this.sizeChanged(tempNode, diagram, entry);
                            this.positionChanged(tempNode, diagram);
                        }
                        else {
                            this.connectionChanged(tempNode, diagram, entry);
                        }
                    }
                }
                else {
                    if (diagram.bpmnModule) {
                        diagram.sizeUndo = true;
                    }
                    this.sizeChanged(node, diagram);
                    this.positionChanged(node, diagram);
                    if (diagram.bpmnModule) {
                        diagram.sizeUndo = false;
                    }
                }
            }
        }
        if (obj && obj.connectors && obj.connectors.length > 0) {
            var connectors = obj.connectors;
            for (i = 0; i < connectors.length; i++) {
                connector = connectors[parseInt(i.toString(), 10)];
                this.connectionChanged(connector, diagram);
            }
        }
    };
    UndoRedo.prototype.sizeChanged = function (obj, diagram, entry) {
        var node = diagram.nameTable[obj.id];
        var scaleWidth = obj.wrapper.actualSize.width / node.wrapper.actualSize.width;
        var scaleHeight = obj.wrapper.actualSize.height / node.wrapper.actualSize.height;
        if (entry && entry.childTable) {
            entry.childTable[obj.id] = cloneObject(node);
        }
        diagram.scale(node, scaleWidth, scaleHeight, {
            x: obj.wrapper.offsetX / node.wrapper.offsetX,
            y: obj.wrapper.offsetY / node.wrapper.offsetY
        });
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    UndoRedo.prototype.recordRotationChanged = function (obj, diagram, entry, type) {
        var i = 0;
        var node;
        var connector;
        var selectorObj = diagram.selectedItems;
        selectorObj.rotateAngle = obj.rotateAngle;
        if (selectorObj && selectorObj.wrapper) {
            selectorObj.wrapper.rotateAngle = obj.rotateAngle;
        }
        diagram.fromUndo = true;
        if (obj && obj.nodes && obj.nodes.length > 0) {
            for (i = 0; i < obj.nodes.length; i++) {
                node = obj.nodes[parseInt(i.toString(), 10)];
                // Bug 832864: Undo redo not working properly for group node with connectors.
                // This code is executed only for group nodes with connectors when the connector is not connected to a node either as a source or target.
                var isConnect = false;
                if (node.children && node.children.length > 0) {
                    for (var j = 0; j < node.children.length; j++) {
                        var child = diagram.nameTable[node.children[parseInt(j.toString(), 10)]];
                        if (!(getObjectType(child) === Node)) {
                            if (child.sourceID === '' || child.targetID === '') {
                                isConnect = true;
                                break;
                            }
                        }
                    }
                    if (isConnect && Object.keys(entry.childTable).length > 0) {
                        var elements = [];
                        var nodes = diagram.commandHandler.getAllDescendants(node, elements);
                        for (var i2 = 0; i2 < nodes.length; i2++) {
                            var tempNode = entry.childTable[nodes[parseInt(i2.toString(), 10)].id];
                            if ((getObjectType(tempNode) === Node)) {
                                var object = { id: '', rotateAngle: 0, wrapper: { offsetX: 0, offsetY: 0 } };
                                if (type === 'redo') {
                                    object.id = tempNode.id;
                                    object.rotateAngle = node.rotateAngle;
                                }
                                else {
                                    object = tempNode;
                                }
                                this.rotationChanged(object, diagram);
                                if (type === 'undo') {
                                    var offNode = diagram.nameTable[object.id];
                                    this.undoOffsets.push({ id: offNode.id, offsetX: offNode.offsetX, offsetY: offNode.offsetY });
                                }
                                else {
                                    var lastIndex = -1;
                                    for (var i_2 = this.undoOffsets.length - 1; i_2 >= 0; i_2--) {
                                        if (this.undoOffsets[parseInt(i_2.toString(), 10)].id === object.id) {
                                            object.wrapper = this.undoOffsets[parseInt(i_2.toString(), 10)];
                                            lastIndex = i_2;
                                            break;
                                        }
                                    }
                                    if (lastIndex !== -1) {
                                        this.undoOffsets.splice(lastIndex, 1);
                                    }
                                }
                                this.positionChanged(object, diagram);
                            }
                            else {
                                this.connectionChanged(tempNode, diagram, entry);
                            }
                        }
                        var nd = diagram.nameTable[node.id];
                        nd.rotateAngle = obj.rotateAngle;
                        diagram.updateSelector();
                        this.rotationChanged(node, diagram);
                    }
                    else {
                        this.rotationChanged(node, diagram);
                        this.positionChanged(node, diagram);
                    }
                }
                else {
                    this.rotationChanged(node, diagram);
                    this.positionChanged(node, diagram);
                }
            }
        }
        diagram.fromUndo = false;
        if (obj && obj.connectors && obj.connectors.length > 0) {
            for (i = 0; i < obj.connectors.length; i++) {
                connector = obj.connectors[parseInt(i.toString(), 10)];
                this.connectionChanged(connector, diagram);
            }
        }
    };
    UndoRedo.prototype.rotationChanged = function (obj, diagram) {
        var node = diagram.nameTable[obj.id];
        diagram.rotate(node, obj.rotateAngle - node.rotateAngle);
    };
    UndoRedo.prototype.recordConnectionChanged = function (obj, diagram) {
        var connector;
        if (obj && obj.connectors) {
            connector = obj.connectors[0];
        }
        else {
            connector = obj;
        }
        if (connector.sourceID && diagram.nameTable[connector.sourceID]) {
            diagram.insertValue(diagram.nameTable[connector.sourceID], true);
        }
        if (connector.targetID && diagram.nameTable[connector.targetID]) {
            diagram.insertValue(diagram.nameTable[connector.targetID], true);
        }
        if (connector instanceof Connector || connector.shape.type === 'None' || connector.shape.type === 'Bpmn') {
            this.connectionChanged(connector, diagram);
        }
    };
    UndoRedo.prototype.connectionChanged = function (obj, diagram, entry) {
        var connector = diagram.nameTable[obj.id];
        var node;
        if (obj.sourcePortID !== connector.sourcePortID) {
            diagram.removePortEdges(diagram.nameTable[connector.sourceID], connector.sourcePortID, connector.id, false);
            connector.sourcePortID = obj.sourcePortID;
            diagram.connectorPropertyChange(connector, {}, { sourcePortID: obj.sourcePortID });
        }
        if (obj.targetPortID !== connector.targetPortID) {
            diagram.removePortEdges(diagram.nameTable[connector.targetID], connector.targetPortID, connector.id, true);
            connector.targetPortID = obj.targetPortID;
            diagram.connectorPropertyChange(connector, {}, { targetPortID: obj.targetPortID });
        }
        if (obj.sourceID !== connector.sourceID) {
            if (obj.sourceID === '') {
                node = diagram.nameTable[connector.sourceID];
                removeItem(node.outEdges, obj.id);
            }
            else {
                node = diagram.nameTable[obj.sourceID];
                node.outEdges.push(obj.id);
                diagram.updatePortEdges(node, obj, false);
            }
            connector.sourceID = obj.sourceID;
            diagram.connectorPropertyChange(connector, {}, { sourceID: obj.sourceID });
        }
        if (obj.targetID !== connector.targetID) {
            if (obj.targetID === '') {
                node = diagram.nameTable[connector.targetID];
                removeItem(node.inEdges, obj.id);
            }
            else {
                node = diagram.nameTable[obj.targetID];
                node.inEdges.push(obj.id);
                diagram.updatePortEdges(node, obj, true);
            }
            connector.targetID = obj.targetID;
            diagram.connectorPropertyChange(connector, {}, { targetID: obj.targetID });
        }
        if (entry && entry.childTable) {
            entry.childTable[obj.id] = cloneObject(connector);
        }
        var sx = obj.sourcePoint.x - connector.sourcePoint.x;
        var sy = obj.sourcePoint.y - connector.sourcePoint.y;
        if (sx !== 0 || sy !== 0) {
            diagram.dragSourceEnd(connector, sx, sy);
        }
        var tx = obj.targetPoint.x - connector.targetPoint.x;
        var ty = obj.targetPoint.y - connector.targetPoint.y;
        if (tx !== 0 || ty !== 0) {
            diagram.dragTargetEnd(connector, tx, ty);
        }
        diagram.updateSelector();
        if (diagram.mode !== 'SVG') {
            diagram.refreshDiagramLayer();
        }
    };
    UndoRedo.prototype.recordCollectionChanged = function (entry, diagram) {
        var obj = entry.undoObject;
        if (entry && entry.changeType) {
            var changeType = void 0;
            if (entry.isUndo) {
                if (entry.changeType === 'Insert') {
                    changeType = 'Remove';
                }
                else {
                    changeType = 'Insert';
                }
            }
            else {
                changeType = entry.changeType;
            }
            if (changeType === 'Remove') {
                if (obj.nodeId) {
                    diagram.remove(diagram.nameTable[obj.nodeId + '_textannotation_' + obj.id]);
                }
                else {
                    diagram.remove(obj);
                    if (obj.parentId) {
                        var parentNode = diagram.nameTable[obj.parentId];
                        if (parentNode) {
                            this.removeChildFromLane(diagram, parentNode, obj);
                        }
                    }
                    diagram.clearSelectorLayer();
                }
            }
            else {
                diagram.clearSelectorLayer();
                if (obj.parentId) {
                    var parentNode = diagram.nameTable[obj.parentId];
                    if (parentNode) {
                        diagram.addChild(parentNode, obj);
                    }
                    else {
                        diagram.add(obj);
                    }
                }
                else if (obj.nodeId) {
                    diagram.addTextAnnotation(obj, diagram.nameTable[obj.nodeId]);
                }
                else {
                    if (!diagram.nameTable[obj.id]) {
                        if (obj && obj.shape && obj.shape.type === 'SwimLane' && entry.isUndo) {
                            pasteSwimLane(obj, undefined, undefined, undefined, undefined, true);
                        }
                        //Bug 909155: Issue in connecting nodes with ports.
                        // When we add child nodes at runtime and connect them with connector at runtime and perform undo redo, the connector is not visible after undo redo.
                        //Added below code to update the zIndex of the connector to make it visible above the swimlane.
                        this.updateConnectorZindex(obj, diagram);
                        diagram.add(obj);
                    }
                }
                if (obj.processId && diagram.nameTable[obj.processId]) {
                    diagram.addProcess(obj, obj.processId);
                }
            }
            if (diagram.mode !== 'SVG') {
                diagram.refreshDiagramLayer();
            }
        }
    };
    /**
     * updateConnectorZindex method \
     *
     * @returns { void }
     * @param {NodeModel | ConnectorModel} obj - provide the diagram value.
     * @param {Diagram} diagram - provide the diagram value.
     * @private
     */
    UndoRedo.prototype.updateConnectorZindex = function (obj, diagram) {
        if (obj.sourceID || obj.targetID) {
            var sourceNode = diagram.nameTable[obj.sourceID];
            var targetNode = diagram.nameTable[obj.targetID];
            if (sourceNode && sourceNode.parentId) {
                var sourceParent = diagram.nameTable[sourceNode.parentId];
                if (sourceParent && sourceParent.isLane) {
                    var parentSwimlane = diagram.nameTable[sourceParent.parentId];
                    updateZindex(obj, parentSwimlane, diagram);
                }
            }
            else if (targetNode && targetNode.parentId) {
                var targetParent = diagram.nameTable[targetNode.parentId];
                if (targetParent && targetParent.isLane) {
                    var parentSwimlane = diagram.nameTable[targetParent.parentId];
                    updateZindex(obj, parentSwimlane, diagram);
                }
            }
        }
    };
    UndoRedo.prototype.recordLabelCollectionChanged = function (entry, diagram) {
        var label = entry.undoObject;
        var obj = entry.redoObject;
        var node = diagram.nameTable[obj.id];
        if (entry && entry.changeType) {
            var changeType = void 0;
            if (entry.isUndo) {
                changeType = (entry.changeType === 'Insert') ? 'Remove' : 'Insert';
            }
            else {
                changeType = entry.changeType;
            }
            if (changeType === 'Remove') {
                diagram.removeLabels(node, [label]);
                diagram.clearSelectorLayer();
            }
            else {
                diagram.clearSelectorLayer();
                diagram.addLabels(node, [label]);
            }
            if (diagram.mode !== 'SVG') {
                diagram.refreshDiagramLayer();
            }
        }
    };
    UndoRedo.prototype.recordPortCollectionChanged = function (entry, diagram) {
        var port = entry.undoObject;
        var obj = entry.redoObject;
        var node = diagram.nameTable[obj.id];
        if (entry && entry.changeType) {
            var changeType = void 0;
            if (entry.isUndo) {
                changeType = (entry.changeType === 'Insert') ? 'Remove' : 'Insert';
            }
            else {
                changeType = entry.changeType;
            }
            if (changeType === 'Remove') {
                diagram.removePorts(node, [port]);
                diagram.clearSelectorLayer();
            }
            else {
                diagram.clearSelectorLayer();
                diagram.addPorts(node, [port]);
            }
            if (diagram.mode !== 'SVG') {
                diagram.refreshDiagramLayer();
            }
        }
    };
    /**
     * redo method \
     *
     * @returns { void } redo method .\
     * @param {Diagram} diagram - provide the diagram value.
     *
     * @private
     */
    UndoRedo.prototype.redo = function (diagram) {
        this.checkRedo = true;
        var entry = this.getRedoEntry(diagram);
        var startGroupActionCount = 0;
        if (entry) {
            if (entry.category === 'Internal') {
                if (entry.type === 'StartGroup') {
                    startGroupActionCount++;
                    this.groupUndo = true;
                    //Removed isBlazor code
                }
                else {
                    this.redoEntry(entry, diagram);
                }
                if (this.groupUndo) {
                    this.redoGroupAction(entry, diagram, startGroupActionCount);
                    this.groupUndo = false;
                }
            }
            else {
                if (!isBlazor()) {
                    diagram.historyManager.redo(entry);
                }
                var arg = {
                    entryType: 'redo', oldValue: entry.redoObject, newValue: entry.undoObject
                };
                //Removed isBlazor code
                diagram.triggerEvent(DiagramEvent.historyStateChange, arg);
            }
        }
        this.checkRedo = false;
    };
    UndoRedo.prototype.redoGroupAction = function (entry, diagram, startGroupActionCount) {
        while (startGroupActionCount !== 0) {
            this.redoEntry(entry, diagram);
            entry = this.getRedoEntry(diagram);
            if (entry.type === 'EndGroup') {
                startGroupActionCount--;
            }
            else if (entry.type === 'StartGroup') {
                startGroupActionCount++;
            }
        }
        startGroupActionCount = 0;
    };
    UndoRedo.prototype.redoEntry = function (historyEntry, diagram) {
        var redoObject;
        var redovalue;
        if (historyEntry.type !== 'PropertyChanged' && historyEntry.type !== 'CollectionChanged') {
            redoObject = (historyEntry.redoObject);
            redovalue = (historyEntry.redoObject);
        }
        diagram.diagramActions |= DiagramAction.UndoRedo;
        if (historyEntry.type !== 'StartGroup' && historyEntry.type !== 'EndGroup') {
            if (diagram.historyManager.redoStack.length > 0) {
                var addObject = diagram.historyManager.redoStack.splice(0, 1);
                diagram.historyManager.undoStack.splice(0, 0, addObject[0]);
                redovalue = (historyEntry.redoObject);
            }
        }
        diagram.protectPropertyChange(true);
        //Removed isBlazor code
        switch (historyEntry.type) {
            case 'PositionChanged':
            case 'Align':
            case 'Distribute':
                this.recordPositionChanged(redoObject, diagram);
                break;
            case 'SizeChanged':
            case 'Sizing':
                this.recordSizeChanged(redoObject, diagram, historyEntry);
                break;
            case 'RotationChanged':
                this.recordRotationChanged(redoObject, diagram, historyEntry, 'redo');
                break;
            case 'ConnectionChanged':
                this.recordConnectionChanged(redoObject, diagram);
                break;
            case 'PropertyChanged':
                this.recordPropertyChanged(historyEntry, diagram, true);
                break;
            case 'CollectionChanged':
                this.recordCollectionChanged(historyEntry, diagram);
                break;
            case 'LabelCollectionChanged':
                this.recordLabelCollectionChanged(historyEntry, diagram);
                break;
            case 'PortCollectionChanged':
                this.recordPortCollectionChanged(historyEntry, diagram);
                break;
            case 'Group':
                this.group(historyEntry, diagram);
                break;
            case 'UnGroup':
                this.unGroup(historyEntry, diagram);
                break;
            case 'SegmentChanged':
                this.recordSegmentChanged(redoObject, diagram);
                break;
            case 'PortPositionChanged':
                this.recordPortChanged(historyEntry, diagram, true);
                break;
            case 'AnnotationPropertyChanged':
                this.recordAnnotationChanged(historyEntry, diagram, true);
                break;
            case 'ChildCollectionChanged':
                this.recordChildCollectionChanged(historyEntry, diagram, true);
                break;
            case 'StackChildPositionChanged':
                this.recordStackPositionChanged(historyEntry, diagram, true);
                break;
            case 'RowHeightChanged':
                this.recordGridSizeChanged(historyEntry, diagram, true, true);
                break;
            case 'ColumnWidthChanged':
                this.recordGridSizeChanged(historyEntry, diagram, true, false);
                break;
            case 'LanePositionChanged':
                this.recordLanePositionChanged(historyEntry, diagram, true);
                break;
            case 'LaneCollectionChanged':
            case 'PhaseCollectionChanged':
                this.recordLaneOrPhaseCollectionChanged(historyEntry, diagram, true);
                break;
            case 'SendToBack':
            case 'SendForward':
            case 'SendBackward':
            case 'BringToFront':
                this.recordOrderCommandChanged(historyEntry, diagram, true);
                break;
            case 'AddChildToGroupNode':
                this.recordAddChildToGroupNode(historyEntry, diagram, true);
                break;
            case 'RemoveChildFromGroupNode':
                this.recordRemoveChildFromGroupNode(historyEntry, diagram, true);
                break;
            case 'ExternalEntry':
                //EJ2-848643 - Need to consider custom entries in start and end group action
                diagram.historyManager.redo(historyEntry);
                break;
        }
        diagram.protectPropertyChange(false);
        diagram.diagramActions &= ~DiagramAction.UndoRedo;
        diagram.historyChangeTrigger(historyEntry, 'Redo');
        if (redovalue) {
            var value = this.checkNodeObject(redovalue, diagram);
            if (value) {
                var getnodeDefaults = getFunction(diagram.updateSelection);
                if (getnodeDefaults) {
                    getnodeDefaults(value, diagram);
                }
            }
        }
    };
    UndoRedo.prototype.getUndoEntry = function (diagram) {
        var undoEntry = null;
        var currentObject;
        var hList = diagram.historyManager;
        if (hList.canUndo) {
            undoEntry = hList.currentEntry;
            currentObject = hList.currentEntry.previous;
            if (currentObject) {
                hList.currentEntry = currentObject;
                if (!hList.canRedo) {
                    hList.canRedo = true;
                }
            }
            else {
                hList.canRedo = true;
                hList.canUndo = false;
            }
        }
        return undoEntry;
    };
    UndoRedo.prototype.getRedoEntry = function (diagram) {
        var redoEntry = null;
        var entryCurrent;
        var hList = diagram.historyManager;
        if (hList.canRedo) {
            if (!hList.currentEntry.previous && !hList.canUndo) {
                entryCurrent = hList.currentEntry;
            }
            else {
                entryCurrent = hList.currentEntry.next;
            }
            if (entryCurrent) {
                hList.currentEntry = entryCurrent;
                if (!hList.canUndo) {
                    hList.canUndo = true;
                }
                if (!entryCurrent.next) {
                    hList.canRedo = false;
                    hList.canUndo = true;
                }
            }
            redoEntry = hList.currentEntry;
        }
        return redoEntry;
    };
    /**
     * To destroy the undo redo module
     *
     * @returns {void}
     * @private
     */
    UndoRedo.prototype.destroy = function () {
        /**
         * Destroys the undo redo module
         */
    };
    /**
     * @returns { string } toBounds method .\
     * Get getModuleName name.
     */
    UndoRedo.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'UndoRedo';
    };
    return UndoRedo;
}());

/**
 * Layout Animation function to enable or disable layout animation
 */
var LayoutAnimation = /** @class */ (function () {
    function LayoutAnimation() {
        this.protectChange = false;
        this.setIntervalObject = [];
    }
    /**
     * Layout expand function for animation of expand and collapse \
     *
     * @returns {  void }   Layout expand function for animation of expand and collapse .\
     * @param {boolean} animation - provide the angle value.
     * @param {ILayout} objects - provide the angle value.
     * @param {Node} node - provide the angle value.
     * @param {Diagram} diagram - provide the angle value.
     * @private
     */
    LayoutAnimation.prototype.expand = function (animation, objects, node, diagram) {
        var _this = this;
        var i = 0;
        var j = 0;
        diagram.realActions = diagram.realActions | RealAction.AnimationClick;
        this.setIntervalObject[parseInt(i.toString(), 10)] = setInterval(function () {
            j++;
            return _this.layoutAnimation(objects, _this.setIntervalObject, j === 6, diagram, node);
        }, 20);
        if (node.isExpanded) {
            var opacity_1 = .2;
            diagram.protectPropertyChange(false);
            //let objects: ILayout = diagram.doLayout();
            var setIntervalObjects_1 = {};
            var x = 0;
            if (animation) {
                this.updateOpacity(node, opacity_1, diagram);
                setIntervalObjects_1[parseInt(x.toString(), 10)] = setInterval(function () {
                    diagram.allowServerDataBinding = false;
                    // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                    opacity_1 <= 1 ? _this.updateOpacity(node, opacity_1, diagram) : clearInterval(setIntervalObjects_1[0]);
                    opacity_1 += .2;
                    diagram.allowServerDataBinding = true;
                }, 20);
            }
        }
    };
    // Bug 877226: Nodes overlapped while changing isExpanded property with Layout Animation.
    // To stop the and clear the existing setinterval object
    // Added this to stop the existing setinterval object when the layout animation is called for multiple nodes.
    LayoutAnimation.prototype.stopCurrentAnimation = function (objValue, diagram, node) {
        clearInterval(this.setIntervalObject[0]);
        this.setIntervalObject = [];
        for (var k = 0; k < objValue.objects.length; k++) {
            var node1 = diagram.nameTable[objValue.objects[parseInt(k.toString(), 10)].id];
            node1.offsetX += objValue.objects[parseInt(k.toString(), 10)].differenceX
                - (objValue.objects[parseInt(k.toString(), 10)].differenceX / 5);
            node1.offsetY += objValue.objects[parseInt(k.toString(), 10)].differenceY
                - (objValue.objects[parseInt(k.toString(), 10)].differenceY / 5);
        }
        diagram.realActions = diagram.realActions & RealAction.AnimationClick;
        diagram.refreshCanvasLayers();
        diagram.protectPropertyChange(true);
        diagram.triggerEvent(DiagramEvent.animationComplete, undefined);
        diagram.layout.fixedNode = '';
        diagram.protectPropertyChange(this.protectChange);
        var arg = {
            element: cloneBlazorObject(cloneObject(node)), state: (node.isExpanded) ? true : false
        };
        diagram.triggerEvent(DiagramEvent.expandStateChange, arg);
        if (diagram.lineRoutingModule && diagram.constraints & DiagramConstraints.LineRouting) {
            diagram.resetSegments();
        }
    };
    /**
     * Setinterval and Clear interval for layout animation \
     *
     * @returns {  void }   Setinterval and Clear interval for layout animation .\
     * @param {ILayout} objValue - provide the angle value.
     * @param {Object} layoutTimer - provide the angle value.
     * @param {ILayout} stop - provide the angle value.
     * @param {Diagram} diagram - provide the angle value.
     * @param {NodeModel} node - provide the angle value.
     * @private
     */
    LayoutAnimation.prototype.layoutAnimation = function (objValue, layoutTimer, stop, diagram, node) {
        if (!stop) {
            for (var k = 0; k < objValue.objects.length; k++) {
                var node_1 = diagram.nameTable[objValue.objects[parseInt(k.toString(), 10)].id];
                node_1.offsetX += objValue.objects[parseInt(k.toString(), 10)].differenceX / 5;
                node_1.offsetY += objValue.objects[parseInt(k.toString(), 10)].differenceY / 5;
            }
        }
        if (stop) {
            clearInterval(layoutTimer[0]);
            this.setIntervalObject = [];
            diagram.realActions = diagram.realActions & ~RealAction.AnimationClick;
            diagram.refreshCanvasLayers();
            diagram.protectPropertyChange(true);
            diagram.triggerEvent(DiagramEvent.animationComplete, undefined);
            diagram.organizationalChartModule.isAnimation = false;
            diagram.layout.fixedNode = '';
            diagram.protectPropertyChange(this.protectChange);
            var arg = {
                element: cloneBlazorObject(cloneObject(node)), state: (node.isExpanded) ? true : false
            };
            diagram.triggerEvent(DiagramEvent.expandStateChange, arg);
            if (diagram.lineRoutingModule && diagram.constraints & DiagramConstraints.LineRouting) {
                diagram.resetSegments();
            }
        }
    };
    /**
     *update the node opacity for the node and connector once the layout animation starts \
     *
     * @returns {  void }    update the node opacity for the node and connector once the layout animation starts .\
     * @param {Node} source - provide the source value.
     * @param {number} value - provide the value.
     * @param {Diagram} diagram - provide the diagram value.
     * @private
     */
    LayoutAnimation.prototype.updateOpacity = function (source, value, diagram) {
        for (var i = 0; i < source.outEdges.length; i++) {
            var connector = diagram.nameTable[source.outEdges[parseInt(i.toString(), 10)]];
            var target = diagram.nameTable[connector.targetID];
            connector.style.opacity = value;
            for (var j = 0; j < connector.wrapper.children.length; j++) {
                connector.wrapper.children[parseInt(j.toString(), 10)].style.opacity = value;
                target.style.opacity = value;
                if (target.wrapper instanceof Container) {
                    diagram.updateNodeProperty(target.wrapper, undefined, value);
                }
            }
            this.updateOpacity(target, value, diagram);
        }
    };
    /**
     *To destroy the ruler
     *
     * @returns {void} To destroy the ruler
     */
    LayoutAnimation.prototype.destroy = function () {
        /**
         * Destroys the LayoutAnimate module
         */
    };
    /**
     * Core method to return the component name.
     *
     * @returns {string}  Core method to return the component name.
     * @private
     */
    LayoutAnimation.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'LayoutAnimate';
    };
    return LayoutAnimation;
}());

// Class representing a line segment
var LineSegment = /** @class */ (function () {
    /**
     * Constructor to initialize a LineSegment.
     * @param {PointModel} start - The starting point of the line segment.
     * @param {PointModel} end - The ending point of the line segment.
     * @param {ILineSegment} [previousSegment] - The previous line segment in the sequence (optional).
     * @returns {ILineSegment} The newly created line segment.
     */
    function LineSegment(start, end, previousSegment) {
        this.startPoint = start;
        this.endPoint = end;
        this.previous = previousSegment;
        // Link the previous segment to this one, if it exists
        if (previousSegment) {
            previousSegment.next = this;
        }
        // Determine if the segment is vertical or horizontal
        var isVertical = start.x === end.x;
        this.coordinate = isVertical ? start.x : start.y;
        this.sortedStart = isVertical ? Math.min(start.y, end.y) : Math.min(start.x, end.x);
        this.sortedEnd = isVertical ? Math.max(start.y, end.y) : Math.max(start.x, end.x);
        this.direction = isVertical ? (start.y < end.y ? 'Bottom' : 'Top') : (start.x < end.x ? 'Right' : 'Left');
        // Create sweep events for the start and end of the segment
        this.startEvent = new SweepEvent(this, true);
        this.endEvent = new SweepEvent(this, false);
    }
    /**
     * Updates the coordinate of the line segment by a given delta.
     * @param {number} delta - The amount to adjust the coordinate by.
     * @returns {void}
     * @private
     */
    LineSegment.prototype.updateCoordinate = function (delta) {
        this.coordinate += delta;
        var isHorizontal = this.direction === 'Left' || this.direction === 'Right';
        // Calculate new start and end points based on the updated coordinate
        var newStartPoint = isHorizontal
            ? { x: this.startPoint.x, y: this.coordinate }
            : { x: this.coordinate, y: this.startPoint.y };
        var newEndPoint = isHorizontal
            ? { x: this.endPoint.x, y: this.coordinate }
            : { x: this.coordinate, y: this.endPoint.y };
        // Update the start point and adjust the previous segment if it exists
        this.startPoint = newStartPoint;
        if (this.previous) {
            this.previous.adjustEnd(newStartPoint);
        }
        // Update the end point and adjust the next segment if it exists
        this.endPoint = newEndPoint;
        if (this.next) {
            this.next.adjustStart(newEndPoint);
        }
    };
    /**
     * Adjusts the start point of the segment and updates sorted values.
     * @param {PointModel} point - The new start point.
     * @returns {void}
     */
    LineSegment.prototype.adjustStart = function (point) {
        this.startPoint = point;
        this.updateSortedValues();
    };
    /**
     * Adjusts the end point of the segment and updates sorted values.
     * @param {PointModel} point - The new end point.
     * @returns {void}
     */
    LineSegment.prototype.adjustEnd = function (point) {
        this.endPoint = point;
        this.updateSortedValues();
    };
    /**
     * Updates the sorted start and end values based on the current points.
     * @returns {void}
     */
    LineSegment.prototype.updateSortedValues = function () {
        var isVertical = this.direction === 'Top' || this.direction === 'Bottom';
        this.sortedStart = isVertical ? Math.min(this.startPoint.y, this.endPoint.y) : Math.min(this.startPoint.x, this.endPoint.x);
        this.sortedEnd = isVertical ? Math.max(this.startPoint.y, this.endPoint.y) : Math.max(this.startPoint.x, this.endPoint.x);
        // Refresh the start and end events to reflect the updated sorted values
        this.startEvent.refresh();
        this.endEvent.refresh();
    };
    return LineSegment;
}());
// Class representing an event in the sweep line algorithm
var SweepEvent = /** @class */ (function () {
    /**
     * Constructor to initialize a SweepEvent.
     * @param {ILineSegment} segment - The line segment associated with this event.
     * @param {boolean} isStart - Whether this event is the start of the segment.
     */
    function SweepEvent(segment, isStart) {
        this.segment = segment;
        this.isStart = isStart;
        // Set the value based on whether this is a start or end event
        this.value = isStart ? segment.sortedStart : segment.sortedEnd;
    }
    /**
     * Refreshes the value of the event based on the segment's current sorted values.
     * @returns {void}
     */
    SweepEvent.prototype.refresh = function () {
        // Update the value to reflect the current position of the segment
        this.value = this.isStart ? this.segment.sortedStart : this.segment.sortedEnd;
    };
    /**
     * Compares this event to another event for sorting purposes.
     * @param {SweepEvent} other - The other event to compare to.
     * @returns {number} -1 if this event is less than the other, 1 if greater, 0 if equal.
     */
    SweepEvent.prototype.compareTo = function (other) {
        // Compare based on the value of the events
        if (this.value !== other.value) {
            return this.value < other.value ? -1 : 1;
        }
        // If values are equal, prioritize start events over end events
        return this.isStart ? -1 : other.isStart ? 1 : 0;
    };
    return SweepEvent;
}());
// Class representing a segment tree used for efficient line segment intersection detection
var SegmentTree = /** @class */ (function () {
    function SegmentTree() {
        // Maps to store horizontal and vertical branches of segments
        this.horizontalBranches = new Map();
        this.verticalBranches = new Map();
    }
    /**
     * Adds a line segment to the segment tree.
     * @param {ILineSegment} segment - The line segment to add.
     * @returns {void}
     * @private
     */
    SegmentTree.prototype.addSegment = function (segment) {
        // Get the appropriate branches (horizontal or vertical) based on the segment's direction
        var branches = this.getBranches(segment.direction);
        this.addSegmentToBranch(branches, segment);
    };
    /**
     * Adds a line segment to the appropriate branch (horizontal or vertical).
     * @param {Map<number, Set<SweepEvent>>} branches - The map of branches to add the segment to.
     * @param {ILineSegment} segment - The line segment to add.
     * @returns {void}
     */
    SegmentTree.prototype.addSegmentToBranch = function (branches, segment) {
        // If the branch for the segment's coordinate does not exist, create it
        if (!branches.has(segment.coordinate)) {
            branches.set(segment.coordinate, new Set());
        }
        var branch = branches.get(segment.coordinate);
        if (branch) {
            // Add the start and end events of the segment to the branch
            branch.add(segment.startEvent);
            branch.add(segment.endEvent);
        }
    };
    /**
     * Removes a line segment from the segment tree.
     * @param {ILineSegment} segment - The line segment to remove.
     * @returns {void}
     * @private
     */
    SegmentTree.prototype.removeSegment = function (segment) {
        // Get the appropriate branches (horizontal or vertical) based on the segment's direction
        var branches = this.getBranches(segment.direction);
        this.removeSegmentFromBranch(branches, segment);
    };
    /**
     * Removes a line segment from the appropriate branch (horizontal or vertical).
     * @param {Map<number, Set<SweepEvent>>} branches - The map of branches to remove the segment from.
     * @param {ILineSegment} segment - The line segment to remove.
     * @returns {void}
     */
    SegmentTree.prototype.removeSegmentFromBranch = function (branches, segment) {
        var branch = branches.get(segment.coordinate);
        if (branch) {
            // Remove the start and end events of the segment from the branch
            branch.delete(segment.startEvent);
            branch.delete(segment.endEvent);
            // If the branch is empty after removal, delete the branch
            if (branch.size === 0) {
                branches.delete(segment.coordinate);
            }
        }
    };
    /**
     * Finds segments that overlap with the given segment.
     * @param {ILineSegment} segment - The line segment to check for overlaps.
     * @returns {ILineSegment[]} An array of overlapping line segments.
     * @private
     */
    SegmentTree.prototype.findOverlappingSegments = function (segment) {
        // Get the appropriate branches (horizontal or vertical) based on the segment's direction
        var branches = this.getBranches(segment.direction);
        return this.findOverlappingSegmentsInBranch(branches, segment);
    };
    /**
     * Finds overlapping segments within the appropriate branch.
     * @param {Map<number, Set<SweepEvent>>} branches - The map of branches to search for overlaps.
     * @param {ILineSegment} segment - The line segment to check for overlaps.
     * @returns {ILineSegment[]} An array of overlapping line segments.
     */
    SegmentTree.prototype.findOverlappingSegmentsInBranch = function (branches, segment) {
        var result = [];
        var seenSegments = new Set();
        var branch = branches.get(segment.coordinate);
        if (branch) {
            var branchArray_1 = [];
            branch.forEach(function (item) { return branchArray_1.push(item); });
            for (var i = 0; i < branchArray_1.length; i++) {
                var sweepEvent = branchArray_1[parseInt(i.toString(), 10)];
                // Check if the segment overlaps with the current sweep event
                if (!(sweepEvent.segment.sortedStart < segment.sortedStart && sweepEvent.segment.sortedEnd > segment.sortedEnd)) {
                    if (sweepEvent.value < segment.sortedStart || sweepEvent.value > segment.sortedEnd) {
                        continue;
                    }
                }
                // Add the overlapping segment to the result if it hasn't been seen before
                if (sweepEvent.segment !== segment && !seenSegments.has(sweepEvent.segment)) {
                    seenSegments.add(sweepEvent.segment);
                    var maxStart = Math.max(segment.sortedStart, sweepEvent.segment.sortedStart);
                    var minEnd = Math.min(segment.sortedEnd, sweepEvent.segment.sortedEnd);
                    if (maxStart < minEnd) {
                        result.push(sweepEvent.segment);
                    }
                }
            }
        }
        return result;
    };
    /**
     * Gets the branches (horizontal or vertical) based on the segment's direction.
     * @param {Direction} direction - The direction of the segment.
     * @returns {Map<number, Set<SweepEvent>>} The map of branches.
     */
    SegmentTree.prototype.getBranches = function (direction) {
        // Return horizontal branches for left/right direction, vertical branches for top/bottom direction
        return direction === 'Left' || direction === 'Right' ? this.horizontalBranches : this.verticalBranches;
    };
    return SegmentTree;
}());
// Class responsible for managing line segment overlaps and ensuring connectors do not visually overlap in a diagram.
var AvoidLineOverlapping = /** @class */ (function () {
    function AvoidLineOverlapping(parent) {
        this.requireReroute = false;
        this.reRoutedCount = 0;
        this.considerNonWalkable = [];
        this.diagram = parent;
        this.segmentTree = new SegmentTree();
        this.segmentMappings = new Map();
        this.connectorMappings = new Map();
        this.modifiedConnector = new Set();
        this.modifiedSegments = new Map();
        this.currentSegments = new Map();
    }
    ///**
    // * Processes all connectors in the diagram to resolve line overlapping issues.
    // * @returns {void}
    // * @private
    // */
    //public refreshLineOverlapping(): void {
    //    if (this.diagram && this.diagram.lineRoutingModule) {
    //        if (this.diagram.connectors.length > 0) {
    //            this.diagram.connectors.forEach((connector: Connector) => {
    //                if (connector.type === 'Orthogonal' && connector.visible) {
    //                    this.addConnector(connector);
    //                }
    //            });
    //            this.refreshModifiedConnectors(this.diagram);
    //        }
    //    }
    //}
    /**
     * Gets the set of connectors that have been modified.
     * @returns {Set<Connector>} A set of modified connectors.
     * @private
     */
    AvoidLineOverlapping.prototype.getModifiedConnector = function () {
        return this.modifiedConnector;
    };
    /**
     * Gets the modified segments of a given connector.
     * @param {Connector} connector - The connector to get the modified segments for.
     * @returns {OrthogonalSegmentModel[]} An array of orthogonal segment models representing the modified segments.
     * @private
     */
    AvoidLineOverlapping.prototype.getModifiedConnectorSegments = function (connector) {
        // Retrieve the segments associated with the given connector
        var segments = this.segmentMappings.get(connector);
        // Convert the segments to orthogonal segment models if they exist, otherwise return an empty array
        return segments ? this.convertSegmentsToOrthogonal(segments) : [];
    };
    /**
     * Refreshes the modified connectors in the diagram.
     * @param {Diagram} diagram - The diagram instance containing the connectors.
     * @returns {void}
     * @private
     */
    AvoidLineOverlapping.prototype.refreshModifiedConnectors = function (diagram) {
        var _this = this;
        // Iterate over each modified connector
        this.modifiedConnector.forEach(function (modifiedConnector) {
            // Get the segments of the modified connector
            var segments = _this.getModifiedConnectorSegments(modifiedConnector);
            if (segments.length) {
                // Add the modified segments to the connector
                modifiedConnector.segments = segments;
                // Update the connector properties in the diagram
                diagram.connectorPropertyChange(modifiedConnector, {}, { type: 'Orthogonal', segments: segments });
            }
        });
        // Clear the modified connectors
        this.modifiedConnector.clear();
    };
    /**
     * Removes a connector and its associated segments from the internal mappings and segment tree.
     * @param {Connector} connector - The connector to remove.
     * @returns {void}
     * @private
     */
    AvoidLineOverlapping.prototype.removeConnector = function (connector) {
        var _this = this;
        // Retrieve the line segments associated with the connector
        var segments = this.segmentMappings.get(connector);
        if (segments) {
            // Remove each line segment from the segment tree and delete its mapping
            segments.forEach(function (segment) {
                _this.segmentTree.removeSegment(segment);
                _this.connectorMappings.delete(segment);
            });
        }
        // Remove the mapping between the connector and its segments
        this.segmentMappings.delete(connector);
    };
    /**
     * Adds a connector and processes it to remove overlapping lines in its segments.
     * @param {Connector} connector - The connector to process.
     * @param {PointModel[]} points - The points to adjust (optional).
     * @param {OrthogonalSegmentModel[]} segments - The segments to adjust (optional).
     * @returns {void} The adjusted segments.
     * @private
     */
    AvoidLineOverlapping.prototype.addConnector = function (connector, points, segments) {
        var _this = this;
        if (points === void 0) { points = []; }
        // Generate points based on the provided segments or use the connector's intermediate points
        // Needed in case of without using line routing
        // if (!points.length) {
        //     points = segments.length ? this.generatePoints(connector, segments) : connector.intermediatePoints;
        // }
        if (points.length === 0) {
            points = connector.intermediatePoints;
        }
        // Remove the connector from the current mappings
        this.removeConnector(connector);
        // Create line segments from the points
        var lineSegments = this.createLineSegments(points);
        // Map the segments to the connector
        this.mapSegmentsToConnector(connector, lineSegments);
        // If there are more than 3 points, process the connector to remove overlapping
        if (points.length > 3) {
            // Adjust the connector to resolve overlaps in the segments
            this.adjustConnector(connector);
        }
        else {
            var overlappingConnectors = new Set();
            for (var _i = 0, lineSegments_1 = lineSegments; _i < lineSegments_1.length; _i++) {
                var lineSegment = lineSegments_1[_i];
                // Find overlapping segments of current connector
                var overlappingsegments = this.segmentTree.findOverlappingSegments(lineSegment);
                for (var _a = 0, overlappingsegments_1 = overlappingsegments; _a < overlappingsegments_1.length; _a++) {
                    var overlappingSegment = overlappingsegments_1[_a];
                    // Fetch overlapping connector
                    var overlappingConnector = this.connectorMappings.get(overlappingSegment);
                    // Add overlapping connector to the set
                    overlappingConnectors.add(overlappingConnector);
                }
            }
            // Adjust the overlapping connector to resolve overlaps in the segments
            overlappingConnectors.forEach(function (overlappingConnector) { return _this.adjustConnector(overlappingConnector); });
        }
    };
    // Needed in case of without using line routing
    // /**
    //  * Generates points based on the connector and segments.
    //  * @param {Connector} connector - The connector to process.
    //  * @param {OrthogonalSegmentModel[]} segments - The segments to adjust.
    //  * @returns {PointModel[]} An array of points representing the connector's path.
    //  */
    // private generatePoints(connector: Connector, segments: OrthogonalSegmentModel[]): PointModel[] {
    //     const points: PointModel[] = [];
    //     let currentPoint: PointModel = connector.sourcePoint;
    //     points.push(currentPoint);
    //     // Iterate through each segment to generate the corresponding points
    //     segments.forEach((segment: OrthogonalSegmentModel) => {
    //         const newPoint: PointModel = { x: currentPoint.x, y: currentPoint.y };
    //         switch (segment.direction) {
    //         case 'Left':
    //             newPoint.x -= segment.length;
    //             break;
    //         case 'Right':
    //             newPoint.x += segment.length;
    //             break;
    //         case 'Top':
    //             newPoint.y -= segment.length;
    //             break;
    //         case 'Bottom':
    //             newPoint.y += segment.length;
    //             break;
    //         }
    //         points.push(newPoint);
    //         currentPoint = newPoint;
    //     });
    //     return points;
    // }
    /**
     * Creates line segments from the given points.
     * @param {PointModel[]} points - The points to create segments from.
     * @returns {ILineSegment[]} An array of line segments.
     */
    AvoidLineOverlapping.prototype.createLineSegments = function (points) {
        var lineSegments = [];
        // Iterate through the points to create line segments
        for (var i = 0; i < points.length - 1; i++) {
            // Create a new line segment from the current point to the next point
            var segment = new LineSegment(points[parseInt(i.toString(), 10)], points[parseInt((i + 1).toString(), 10)], i === 0 ? null : lineSegments[parseInt((i - 1).toString(), 10)]);
            lineSegments.push(segment);
        }
        return lineSegments;
    };
    /**
     * Maps line segments to the given connector.
     * @param {Connector} connector - The connector to map segments to.
     * @param {ILineSegment[]} lineSegments - The line segments to map.
     * @returns {void}
     */
    AvoidLineOverlapping.prototype.mapSegmentsToConnector = function (connector, lineSegments) {
        var _this = this;
        // Store the mapping of segments to the connector
        this.segmentMappings.set(connector, lineSegments);
        // Add each segment to the segment tree and update connector mappings
        lineSegments.forEach(function (lineSegment) {
            _this.segmentTree.addSegment(lineSegment);
            if (!_this.connectorMappings.has(lineSegment)) {
                _this.connectorMappings.set(lineSegment, connector);
            }
        });
    };
    /**
     * Converts line segments to orthogonal segments.
     * @param {ILineSegment[]} lineSegments - The line segments to convert.
     * @returns {OrthogonalSegmentModel[]} An array of orthogonal segments.
     */
    AvoidLineOverlapping.prototype.convertSegmentsToOrthogonal = function (lineSegments) {
        var modifiedSegments = [];
        // Iterate through each line segment to create corresponding orthogonal segments
        lineSegments.forEach(function (lineSegment) {
            var orthogonalSegment = {
                type: 'Orthogonal',
                direction: lineSegment.direction,
                length: Math.abs(lineSegment.sortedEnd - lineSegment.sortedStart)
            };
            modifiedSegments.push(orthogonalSegment);
        });
        return modifiedSegments;
    };
    /**
     * Adjusts the connector to resolve overlapping segments.
     * @param {Connector} connector - The connector to adjust.
     * @returns {void}
     */
    AvoidLineOverlapping.prototype.adjustConnector = function (connector) {
        var _this = this;
        this.requireReroute = false;
        // Retrieve the line segments associated with the connector
        var segments = this.segmentMappings.get(connector);
        var failedSegment = undefined;
        // Iterate through each segment to check for overlaps
        for (var i = 0; i < segments.length - 1; i++) {
            var segment = segments[parseInt(i.toString(), 10)];
            if (segment.previous && segment.next) {
                // Find overlapping segments for this segment
                var overlappingSegments = this.segmentTree.findOverlappingSegments(segment);
                if (overlappingSegments.length > 0) {
                    // Resolve any overlapping segments found
                    if (!this.resolveOverlappingSegments(segment, overlappingSegments)) {
                        if (this.requireReroute) {
                            failedSegment = segment;
                            break;
                        }
                    }
                }
            }
        }
        // If a failed segment is found and rerouting is required, attempt to reroute the connector
        if (failedSegment && this.diagram.lineRoutingModule) {
            if (this.reRoutedCount <= AvoidLineOverlapping.maxReRouteLimit) {
                // Reset the walkable state of previously considered non-walkable grids
                while (this.considerNonWalkable.length > 0) {
                    var grid = this.considerNonWalkable.pop();
                    grid.walkable = true;
                }
                // Fetch the grids that intersect with the segment path
                var grids = this.diagram.lineRoutingModule
                    .getGridsIntersect(failedSegment.startPoint, failedSegment.endPoint);
                // Mark the grids in the segment path as non-walkable temporarily
                grids.forEach(function (grid) {
                    grid.walkable = false;
                    _this.considerNonWalkable.push(grid);
                });
                this.reRoutedCount++;
                // Refresh the connector segments to attempt rerouting
                this.diagram.lineRoutingModule.refreshConnectorSegments(this.diagram, connector, false);
            }
        }
        // Reset the rerouted count and restore the walkable state of grids
        this.reRoutedCount = 0;
        while (this.considerNonWalkable.length > 0) {
            var grid = this.considerNonWalkable.pop();
            grid.walkable = true;
        }
    };
    /**
     * Resolves overlapping segments by adjusting their positions.
     * @param {ILineSegment} segment - The segment to adjust.
     * @param {ILineSegment[]} overlappingSegments - The overlapping segments to resolve.
     * @returns {boolean} whether the shifted segments get resolved with overlapping segment in finding a free coordinate
     */
    AvoidLineOverlapping.prototype.resolveOverlappingSegments = function (segment, overlappingSegments) {
        // Clear maps to track modified and current segments
        this.modifiedSegments.clear();
        this.currentSegments.clear();
        var adjustSelfFirst = this.shouldAdjustSelfFirst(segment, overlappingSegments);
        // Get the first overlapping segment
        var overlapSegment = overlappingSegments[0];
        // Calculate the direction to shift the segment
        var shiftDirection = adjustSelfFirst
            ? this.calculateShiftDirection(segment, overlappingSegments)
            : this.calculateShiftDirection(overlapSegment, this.segmentTree.findOverlappingSegments(overlapSegment));
        var shifted = false;
        if (adjustSelfFirst) {
            var secondarySegment = overlappingSegments.length === 1 ? overlapSegment : undefined;
            // Adjust the segment in calculated direction
            shifted = this.attemptAdjustment(segment, shiftDirection, secondarySegment);
            if (!shifted) {
                // Adjust the segment in the opposite direction
                shiftDirection = getOppositeDirection(shiftDirection);
                shifted = this.attemptAdjustment(segment, shiftDirection, secondarySegment);
            }
        }
        else {
            // Adjust the segment in calculated direction
            shifted = this.attemptAdjustment(overlapSegment, shiftDirection, segment);
            if (!shifted) {
                // Adjust the segment in the opposite direction
                shiftDirection = getOppositeDirection(shiftDirection);
                shifted = this.attemptAdjustment(overlapSegment, shiftDirection, segment);
            }
        }
        // Update the segment tree with the modified segments
        this.updateSegmentTreeWithModifiedSegments();
        return shifted;
    };
    /**
     * Determines whether the current segment should be adjusted before its overlapping segment.
     * @param {ILineSegment } segment - The current segment.
     * @param {ILineSegment[]} overlappingSegments - The list of overlapping segments.
     * @returns {boolean} True if the current segment should be adjusted first, otherwise false.
     */
    AvoidLineOverlapping.prototype.shouldAdjustSelfFirst = function (segment, overlappingSegments) {
        var adjustSelfFirst = overlappingSegments.length > 1;
        // Determine if the current segment should be adjusted first
        if (overlappingSegments.length === 1) {
            // Get the first overlapping segment
            var overlapSegment = overlappingSegments[0];
            if (overlapSegment.previous && overlapSegment.next) {
                var maxStart = Math.max(segment.sortedStart, overlapSegment.sortedStart);
                var minEnd = Math.min(segment.sortedEnd, overlapSegment.sortedEnd);
                var currentRatio = (minEnd - maxStart) / (segment.sortedEnd - segment.sortedStart);
                var overlapRatio = (minEnd - maxStart) / (overlapSegment.sortedEnd - overlapSegment.sortedStart);
                if (currentRatio >= overlapRatio) {
                    adjustSelfFirst = true;
                }
            }
            else {
                adjustSelfFirst = true;
            }
        }
        return adjustSelfFirst;
    };
    /**
     * Attempts to adjust the primary segment and optionally a secondary segment to resolve overlaps.
     * @param {ILineSegment} primarySegment - The primary line segment to adjust.
     * @param {Direction} shiftDirection - The direction to shift the primary segment.
     * @param {ILineSegment} secondarySegment - The secondary line segment to adjust in the opposite direction (optional).
     * @returns {boolean} True if any segment was adjusted, otherwise false.
     */
    AvoidLineOverlapping.prototype.attemptAdjustment = function (primarySegment, shiftDirection, secondarySegment) {
        if (secondarySegment === void 0) { secondarySegment = undefined; }
        // Adjust the primary segment first in shift direction
        var isShifted = this.adjustSegment(primarySegment, shiftDirection);
        this.updateModifiedSegments(isShifted);
        if (!isShifted || this.modifiedSegments.size !== 1) {
            if (secondarySegment && secondarySegment.previous && secondarySegment.next) {
                var dependentSegments = this.getDependentSegments(primarySegment, this.modifiedSegments);
                // Adjust the secondary segment in the opposite direction
                var isShiftedOpposite = this.adjustSegment(secondarySegment, getOppositeDirection(shiftDirection), true);
                // free coordinate found only in opposite direction
                if (!isShifted && isShiftedOpposite) {
                    this.updateModifiedSegments(true);
                }
                // free coordinate found in both the directions
                else if (isShifted && isShiftedOpposite) {
                    var dependentSegments1 = this.getDependentSegments(primarySegment, this.currentSegments);
                    var canReset = this.modifiedSegments.size === 0 || this.modifiedSegments.size > this.currentSegments.size
                        || dependentSegments.length > dependentSegments1.length;
                    this.updateModifiedSegments(canReset);
                }
                else {
                    this.updateModifiedSegments(false);
                }
                // if any segment got shifted in either of the directions
                isShifted = isShifted || isShiftedOpposite;
            }
        }
        return isShifted;
    };
    /**
     * Gets dependent segments based on a reference segment and a map of segments.
     * @param {ILineSegment} segment - The reference segment.
     * @param {Map<ILineSegment, number>} segmentMap - The map of segments.
     * @returns {ILineSegment[]} An array of dependent segments.
     */
    AvoidLineOverlapping.prototype.getDependentSegments = function (segment, segmentMap) {
        var dependentSegments = [];
        segmentMap.forEach(function (newCoordinate, dependentSegment) {
            if (dependentSegment !== segment) {
                dependentSegments.push(dependentSegment);
            }
        });
        return dependentSegments;
    };
    /**
     * Updates the modified segments by adjusting their coordinates and re-adding them to the segment tree.
     * @param {boolean} resetModifiedSegments - Indicates if the segments have been shifted.
     * @returns {void}
     */
    AvoidLineOverlapping.prototype.updateModifiedSegments = function (resetModifiedSegments) {
        var _this = this;
        if (resetModifiedSegments) {
            this.modifiedSegments.clear();
        }
        // Update each current segment's coordinate and re-add it to the segment tree
        this.currentSegments.forEach(function (oldCoordinate, currentSegment) {
            if (resetModifiedSegments) {
                _this.modifiedSegments.set(currentSegment, currentSegment.coordinate);
            }
            _this.segmentTree.removeSegment(currentSegment);
            currentSegment.updateCoordinate(oldCoordinate - currentSegment.coordinate);
            _this.segmentTree.addSegment(currentSegment);
        });
        // Clear the current segments
        this.currentSegments.clear();
    };
    /**
     * Updates the segment tree with the modified segments.
     * Removes the old segments and adds the new segments with their updated positions.
     * @returns {void}
     */
    AvoidLineOverlapping.prototype.updateSegmentTreeWithModifiedSegments = function () {
        var _this = this;
        if (this.modifiedSegments.size > 0) {
            this.modifiedSegments.forEach(function (newCoordinate, modifiedSegment) {
                // Update the segment tree with shifted segments
                _this.segmentTree.removeSegment(modifiedSegment);
                modifiedSegment.updateCoordinate(newCoordinate - modifiedSegment.coordinate);
                _this.segmentTree.addSegment(modifiedSegment);
                // Add the connector to the set of modified connectors
                var connector = _this.connectorMappings.get(modifiedSegment);
                if (!_this.modifiedConnector.has(connector)) {
                    _this.modifiedConnector.add(connector);
                }
            });
        }
    };
    /**
     * Resolves overlapping segments in a given direction.
     * @param {ILineSegment} segment - The line segment to resolve overlaps for.
     * @param {ILineSegment[]} overlappingSegments - The list of overlapping segments.
     * @param {Direction} shiftDirection - The direction to shift the segment.
     * @param {boolean} isOppositeShifting - Enabled when tried to shift secondary segment in opposite direction
     * @returns {boolean} True if the segment was adjusted, otherwise false.
     */
    AvoidLineOverlapping.prototype.resolveOverlappingAtGivenDirection = function (segment, overlappingSegments, shiftDirection, isOppositeShifting) {
        var adjustSelfFirst = this.shouldAdjustSelfFirst(segment, overlappingSegments);
        // Get the first overlapping segment
        var overlapSegment = overlappingSegments[0];
        var segmentToShift = adjustSelfFirst ? segment : overlapSegment;
        if (isOppositeShifting) {
            segmentToShift = adjustSelfFirst &&
                (overlapSegment.previous && overlapSegment.next) ? overlapSegment : segment;
        }
        // Adjust the segment or the overlapping segment based on the direction
        return this.adjustSegment(segmentToShift, shiftDirection, isOppositeShifting);
    };
    /**
     * Calculates the direction to shift a line segment to resolve overlaps.
     * @param {ILineSegment} lineSegment - The line segment to calculate the shift direction for.
     * @param {ILineSegment[]} overlappingSegments - The list of overlapping segments.
     * @returns {Direction} The direction to shift the segment.
     */
    AvoidLineOverlapping.prototype.calculateShiftDirection = function (lineSegment, overlappingSegments) {
        var overlapSegment = overlappingSegments[0];
        var segment = lineSegment;
        var previousSegment = segment.previous;
        var nextSegment = segment.next;
        var nonSortedStart = segment.direction === 'Left' || segment.direction === 'Right' ? segment.startPoint.x : segment.startPoint.y;
        var nonSortedEnd = segment.direction === 'Left' || segment.direction === 'Right' ? segment.endPoint.x : segment.endPoint.y;
        var shiftDirection = segment.direction;
        // Determine the shift direction based on the previous and next segments
        if (previousSegment.direction === nextSegment.direction) {
            var overlapsPrevious = overlapSegment.previous;
            var overlapsNext = overlapSegment.next;
            var isStartCovered = overlapSegment.sortedStart <= nonSortedStart && nonSortedStart <= overlapSegment.sortedEnd;
            var isEndCovered = overlapSegment.sortedStart <= nonSortedEnd && nonSortedEnd <= overlapSegment.sortedEnd;
            // Determine if the start or end of the segment is covered by the overlap
            if (isStartCovered && isEndCovered) {
                var nonSortedStart1 = overlapSegment.direction === 'Left' || overlapSegment.direction === 'Right' ? overlapSegment.startPoint.x : overlapSegment.startPoint.y;
                var nonSortedEnd1 = overlapSegment.direction === 'Left' || overlapSegment.direction === 'Right' ? overlapSegment.endPoint.x : overlapSegment.endPoint.y;
                if (segment.direction !== overlapSegment.direction) {
                    var temp = nonSortedStart1;
                    nonSortedStart1 = nonSortedEnd1;
                    nonSortedEnd1 = temp;
                }
                var startDistance = Math.abs(nonSortedStart - nonSortedStart1);
                var endDistance = Math.abs(nonSortedEnd - nonSortedEnd1);
                if (startDistance > endDistance) {
                    isEndCovered = false;
                }
                else {
                    isStartCovered = false;
                }
            }
            // Determine the shift direction based on the overlap and segment directions
            if (isStartCovered) {
                if (segment.direction === overlapSegment.direction && overlapsNext) {
                    shiftDirection = getOppositeDirection(overlapsNext.direction);
                }
                else if (segment.direction !== overlapSegment.direction && overlapsPrevious) {
                    shiftDirection = overlapsPrevious.direction;
                }
                else {
                    shiftDirection = getOppositeDirection(previousSegment.direction);
                }
            }
            else if (isEndCovered) {
                if (segment.direction === overlapSegment.direction && overlapsPrevious) {
                    shiftDirection = overlapsPrevious.direction;
                }
                else if (segment.direction !== overlapSegment.direction && overlapsNext) {
                    shiftDirection = getOppositeDirection(overlapsNext.direction);
                }
                else {
                    shiftDirection = getOppositeDirection(previousSegment.direction);
                }
            }
        }
        else {
            shiftDirection = nextSegment.direction;
        }
        return shiftDirection;
    };
    /**
     * Adjusts a segment by shifting it in a given direction.
     * @param {ILineSegment} segment - The segment to adjust.
     * @param {Direction} directionToShift - The direction to shift the segment.
     * @param {boolean} isOppositeShifting - Enabled when shifting secondary segment in opposite direction.
     * @returns {boolean} True if the segment was adjusted, false otherwise.
     */
    AvoidLineOverlapping.prototype.adjustSegment = function (segment, directionToShift, isOppositeShifting) {
        if (isOppositeShifting === void 0) { isOppositeShifting = false; }
        var currentCoord = segment.coordinate;
        var previousSegment = segment.previous;
        var nextSegment = segment.next;
        var isShortSegment = true;
        // Determine if the segment is short based on the direction of previous and next segments
        if (previousSegment.direction === nextSegment.direction) {
            isShortSegment = !(nextSegment.direction === directionToShift);
        }
        // Calculate the maximum allowed shift for the segment
        var maximumAllowedShift = AvoidLineOverlapping.ConnectorSpacing * -1;
        maximumAllowedShift += isShortSegment
            ? this.calculateShortSegmentShift(previousSegment, nextSegment)
            : this.calculateLongSegmentShift(previousSegment, nextSegment);
        // Determine the shift delta based on the direction
        var directionMultiplier = directionToShift === 'Right' || directionToShift === 'Bottom' ? 1 : -1;
        var shiftDelta = directionMultiplier * AvoidLineOverlapping.ConnectorSpacing;
        // Adjust the segment if the shift delta is within the allowed range
        if (Math.abs(shiftDelta) <= maximumAllowedShift) {
            this.segmentTree.removeSegment(segment);
            segment.updateCoordinate(shiftDelta);
            this.segmentTree.addSegment(segment);
            // Store the segment's initial routed coordinate.
            if (!this.currentSegments.has(segment)) {
                this.currentSegments.set(segment, currentCoord);
            }
            if (this.diagram.lineRoutingModule) {
                // Check if the shifted segment overlaps with a node.
                var startPoint = segment.startPoint;
                var endPoint = segment.endPoint;
                if (!this.diagram.lineRoutingModule.isPathWalkable(startPoint, endPoint, this.diagram)) {
                    this.requireReroute = true;
                    return false;
                }
            }
            var overlappingSegments = this.segmentTree.findOverlappingSegments(segment);
            if (overlappingSegments.length !== 0) {
                if (this.modifiedSegments.size !== 0 && this.modifiedSegments.size > (this.currentSegments.size + 1)) {
                    return false;
                }
                return this.resolveOverlappingAtGivenDirection(segment, overlappingSegments, directionToShift, isOppositeShifting);
            }
            else {
                var overlappingSegments_1 = this.segmentTree.findOverlappingSegments(previousSegment);
                if (overlappingSegments_1.length !== 0) {
                    var overlappingSegment = overlappingSegments_1[0];
                    if (overlappingSegment.previous && overlappingSegment.next) {
                        return this.adjustSegment(segment, directionToShift, isOppositeShifting);
                    }
                }
            }
        }
        return segment.coordinate !== currentCoord;
    };
    /**
     * Calculates the maximum allowed shift for short segments.
     * @param {ILineSegment} previousSegment - The previous segment.
     * @param {ILineSegment} nextSegment - The next segment.
     * @returns {number} The maximum allowed shift.
     */
    AvoidLineOverlapping.prototype.calculateShortSegmentShift = function (previousSegment, nextSegment) {
        // Calculate the lengths of the previous and next segments
        var previousLength = previousSegment ? Math.abs(previousSegment.sortedEnd - previousSegment.sortedStart) : 0;
        var nextLength = nextSegment ? Math.abs(nextSegment.sortedEnd - nextSegment.sortedStart) : 0;
        // If the directions of the previous and next segments are the same, return the length of the previous segment
        // Otherwise, return the minimum length between the previous and next segments
        return previousSegment.direction === nextSegment.direction
            ? previousLength
            : Math.min(previousLength, nextLength);
    };
    /**
     * Calculates the maximum allowed shift for long segments.
     * @param {ILineSegment} previousSegment - The previous segment.
     * @param {ILineSegment} nextSegment - The next segment.
     * @returns {number} The maximum allowed shift.
     */
    AvoidLineOverlapping.prototype.calculateLongSegmentShift = function (previousSegment, nextSegment) {
        // Calculate the lengths of the previous and next segments
        var previousLength = previousSegment ? Math.abs(previousSegment.sortedEnd - previousSegment.sortedStart) : 0;
        var nextLength = nextSegment ? Math.abs(nextSegment.sortedEnd - nextSegment.sortedStart) : 0;
        // If the directions of the previous and next segments are the same, return the length of the next segment
        // Otherwise, return the maximum length between the previous and next segments, multiplied by 2, plus the connector spacing
        return previousSegment.direction === nextSegment.direction
            ? nextLength
            : Math.max(previousLength, nextLength) * 2 + AvoidLineOverlapping.ConnectorSpacing;
    };
    /**
     *To destroy the line overlapping
     *
     * @returns {void} To destroy the line overlapping
     */
    AvoidLineOverlapping.prototype.destroy = function () {
        /**
         * Destroys the line overlapping module
         */
    };
    /**
     * Core method to return the component name.
     *
     * @returns {string}  Core method to return the component name.
     * @private
     */
    AvoidLineOverlapping.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'AvoidLineOverlapping';
    };
    // Constant defining the default spacing between connectors
    AvoidLineOverlapping.ConnectorSpacing = 5;
    // Constant defining the maximum number of times to re-route a connector to resolve overlaps
    AvoidLineOverlapping.maxReRouteLimit = 5;
    return AvoidLineOverlapping;
}());

/**
 * Line Distribution
 * @private
 */
var LineDistribution = /** @class */ (function () {
    ///** @private */
    //public edgeMapper: EdgeMapperObject[];
    /**
     * Constructor for the line distribution module
     * @private
     */
    function LineDistribution() {
        //constructs the line distribution module
    }
    /**
     * To destroy the line distribution module
     * @returns {void}
     * @private
     */
    LineDistribution.prototype.destroy = function () {
        /**
         * Destroys the line distribution module
         */
    };
    ///**
    // * Get the diagram instance.
    // */
    //private diagram: Diagram;
    /**
     * Core method to return the component name.
     *
     * @returns {string}  Core method to return the component name.
     * @private
     */
    LineDistribution.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'LineDistribution';
    };
    /** @private */
    LineDistribution.prototype.initLineDistribution = function (graph, diagram) {
        var srcDirection = 'Bottom';
        //this.diagram = diagram;
        if (diagram.layout.connectionPointOrigin === 'DifferentPoint' || diagram.layout.enableRouting) {
            var tarDirection = 'Top';
            if (graph.orientation === 'BottomToTop') {
                srcDirection = 'Top';
                tarDirection = 'Bottom';
            }
            else if (graph.orientation === 'RightToLeft') {
                srcDirection = 'Left';
                tarDirection = 'Right';
            }
            else if (graph.orientation === 'LeftToRight') {
                srcDirection = 'Right';
                tarDirection = 'Left';
            }
            var graphnodes = diagram.nodes;
            if (graphnodes.length > 0) {
                for (var i = 0; i < graphnodes.length; i++) {
                    var node = diagram.nameTable[graphnodes[parseInt(i.toString(), 10)].id];
                    this.addDynamicPortandDistrrbuteLine(graph, node, srcDirection, tarDirection, diagram);
                }
            }
        }
    };
    LineDistribution.prototype.ObstacleSegment = function (options) {
        options.direction = getConnectorDirection(options.startpt, options.endpt);
        options.distance = Point.findLength(options.startpt, options.endpt);
        options.orientation = options.direction === 'Left' || options.direction === 'Right' ? 'horizontal' : 'vertical';
        // eslint-disable-next-line no-self-assign
        options.id = options.id;
        if (options.orientation === 'horizontal') {
            options.coord = options.startpt.y;
            if (options.direction === 'Left') {
                options.start = options.endpt.x;
                options.end = options.startpt.x;
            }
            else {
                options.start = options.startpt.x;
                options.end = options.endpt.x;
            }
        }
        else {
            options.coord = options.startpt.x;
            if (options.direction === 'Top') {
                options.start = options.endpt.y;
                options.end = options.startpt.y;
            }
            else {
                options.start = options.startpt.y;
                options.end = options.endpt.y;
            }
        }
        return options;
    };
    /** @private */
    LineDistribution.prototype.distributeLines = function (layout, diagram) {
        var isHorizontal = layout.orientation === 'LeftToRight'
            || layout.orientation === 'RightToLeft';
        var inversespacing = !isHorizontal ? layout.verticalSpacing : layout.horizontalSpacing;
        var srcdecoratorSize = 8.0;
        var obstacleCollection = 'obstaclePointCollection';
        var tardecoratorSize = 10.0;
        var avaibaleSpace = inversespacing - srcdecoratorSize - tardecoratorSize;
        var graph = [];
        var connectorObstacles = [];
        var globalConnectors = diagram.connectors;
        for (var i = 0; i < globalConnectors.length; i++) {
            var connector = globalConnectors[parseInt(i.toString(), 10)];
            var pts = [];
            for (var key = 0; key < connector.segments.length; key++) {
                var seg = connector.segments[parseInt(key.toString(), 10)];
                for (var k = 0; k < seg.points.length; k++) {
                    var pt = seg.points[parseInt(k.toString(), 10)];
                    if (pts.length === 0 || !(Point.equals(pt, pts[pts.length - 1]))) {
                        pts.push(pt);
                    }
                }
            }
            var obssegments = [];
            for (var j = 1; j < pts.length; j++) {
                var obstacle = this.ObstacleSegment({
                    startpt: pts[j - 1], endpt: pts[parseInt(j.toString(), 10)], id: connector.id
                });
                obssegments.push(obstacle);
            }
            var connectorObstacle = { wrapper: connector, segments: obssegments };
            var segments = [];
            if (!isHorizontal) {
                for (var key = 0; key < connectorObstacle.segments.length; key++) {
                    var obstacle = connectorObstacle.segments[parseInt(key.toString(), 10)];
                    if (obstacle.orientation === 'horizontal') {
                        segments.push(obstacle);
                    }
                }
            }
            else {
                for (var key = 0; key < connectorObstacle.segments.length; key++) {
                    var obstacle = connectorObstacle.segments[parseInt(key.toString(), 10)];
                    if (obstacle.orientation === 'vertical') {
                        segments.push(obstacle);
                    }
                }
            }
            for (var j = 0; j < segments.length; j++) {
                var obstacleSegment = segments[parseInt(j.toString(), 10)];
                if (!this.containsValue(graph, obstacleSegment.coord)) {
                    graph.push({ key: obstacleSegment.coord, value: [] });
                }
                var index = void 0;
                for (var k = 0; k < graph.length; k++) {
                    var key = graph[parseInt(k.toString(), 10)].key;
                    if (Number(key) === obstacleSegment.coord) {
                        index = k;
                        break;
                    }
                }
                graph[parseInt(index.toString(), 10)].value.push(obstacleSegment);
            }
            connectorObstacles.push(connectorObstacle);
        }
        this.sortConnectors(graph, diagram);
        var modifiedgrap = [];
        for (var m = 0; m < graph.length; m++) {
            var row = graph[parseInt(m.toString(), 10)];
            var sortedrow = row.value;
            sortedrow.sort();
            var groupby = void 0;
            groupby = [];
            var index = 0;
            var maxEnd = Number.MIN_VALUE;
            groupby.push([]);
            for (var n = 0; n < sortedrow.length; n++) {
                var obstacleSegment = sortedrow[parseInt(n.toString(), 10)];
                if (!(groupby[parseInt(index.toString(), 10)].length > 0) || maxEnd >= obstacleSegment.start) {
                    groupby[parseInt(index.toString(), 10)].push(obstacleSegment);
                    maxEnd = Math.max(maxEnd, groupby[parseInt(index.toString(), 10)][groupby[parseInt(index.toString(), 10)].length - 1].end);
                }
                else {
                    index++;
                    groupby.push([]);
                    groupby[parseInt(index.toString(), 10)].push(obstacleSegment);
                    maxEnd = groupby[parseInt(index.toString(), 10)][groupby[parseInt(index.toString(), 10)].length - 1].end;
                }
            }
            for (var n = 0; n < groupby.length; n++) {
                var group = groupby[parseInt(n.toString(), 10)];
                var sortedGroup = [];
                for (var j = 0; j < group.length; j++) {
                    var e = group[parseInt(j.toString(), 10)];
                    if (e.start) {
                        sortedGroup.push(e);
                    }
                }
                var comparingDir = isHorizontal ? 'Bottom' : 'Right';
                var directed = [];
                for (var j = 0; j < sortedGroup.length; j++) {
                    var e = sortedGroup[parseInt(j.toString(), 10)];
                    if (e.direction === comparingDir) {
                        directed.push(e);
                    }
                }
                var reversedirected = [];
                for (var j = 0; j < sortedGroup.length; j++) {
                    var e = sortedGroup[parseInt(j.toString(), 10)];
                    if (e.direction !== comparingDir) {
                        reversedirected.push(e);
                    }
                }
                var mutual = [];
                if (directed.length > 0) {
                    var temp = directed[0].start;
                    var j = 0;
                    while (j < reversedirected.length) {
                        if (reversedirected[parseInt(j.toString(), 10)].end > temp) {
                            mutual.push(reversedirected[parseInt(j.toString(), 10)]);
                            reversedirected.splice(j, 1);
                        }
                        else {
                            j++;
                        }
                    }
                }
                var mutualRow = [];
                mutualRow = this.updateSegmentRow(mutual, mutualRow);
                var directedRow = [];
                directedRow = [];
                directedRow = this.updateSegmentRow(reversedirected, directedRow);
                directed.reverse();
                directedRow = this.updateSegmentRow(directed, directedRow);
                if (!(mutualRow[mutualRow.length - 1].length > 0)) {
                    mutualRow.splice(mutualRow.length - 1, 1);
                }
                if (!(directedRow[directedRow.length - 1].length > 0)) {
                    directedRow.splice(directedRow.length - 1, 1);
                }
                var subrow = [];
                var descAdding = mutual.length > 0 && (sortedGroup[sortedGroup.length - 1].direction
                    === mutual[mutual.length - 1].direction
                    || sortedGroup[0].direction === mutual[0].direction);
                if (descAdding) {
                    subrow = directedRow;
                    for (var p = 0; p < mutualRow.length; p++) {
                        var obj = mutualRow[parseInt(p.toString(), 10)];
                        subrow[subrow.length] = obj;
                    }
                }
                else {
                    subrow = mutualRow;
                    for (var p = 0; p < directedRow.length; p++) {
                        var obj = directedRow[parseInt(p.toString(), 10)];
                        subrow[subrow.length] = obj;
                    }
                }
                if (subrow.length > 1) {
                    var directionModifier = 1;
                    if (layout.orientation === 'BottomToTop'
                        || layout.orientation === 'RightToLeft') {
                        directionModifier = -1;
                    }
                    var startCoord = row.key - (directionModifier * avaibaleSpace / 2.0);
                    var diff = avaibaleSpace / subrow.length;
                    for (var i = 0; i < subrow.length; i++) {
                        var newcoord = startCoord + (i * diff * directionModifier);
                        for (var p = 0; p < subrow[parseInt(i.toString(), 10)].length; p++) {
                            var obstacleSegment = subrow[parseInt(i.toString(), 10)][parseInt(p.toString(), 10)];
                            obstacleSegment.coord = newcoord;
                            if (!this.containsValue(modifiedgrap, obstacleSegment.coord)) {
                                modifiedgrap.push({ key: obstacleSegment.coord, value: [] });
                            }
                            var index_1 = void 0;
                            for (var k = 0; k < modifiedgrap.length; k++) {
                                var keyCheck = modifiedgrap[parseInt(k.toString(), 10)].key;
                                if (keyCheck === obstacleSegment.coord) {
                                    index_1 = k;
                                    break;
                                }
                            }
                            modifiedgrap[parseInt(index_1.toString(), 10)].value.push(obstacleSegment);
                        }
                    }
                }
            }
        }
        for (var m = 0; m < connectorObstacles.length; m++) {
            var connectorObstacle = connectorObstacles[parseInt(m.toString(), 10)];
            var pts = [];
            for (var i = 0; i < connectorObstacle.segments.length; i++) {
                if (i === 0) {
                    pts.push(this.getObstacleStartPoint(connectorObstacle.segments[parseInt(i.toString(), 10)]));
                }
                else if (isHorizontal) {
                    if (connectorObstacle.segments[parseInt(i.toString(), 10)].orientation === 'vertical') {
                        pts[pts.length - 1] = this.getObstacleStartPoint(connectorObstacle.segments[parseInt(i.toString(), 10)]);
                    }
                }
                else if (!isHorizontal) {
                    if (connectorObstacle.segments[parseInt(i.toString(), 10)].orientation === 'horizontal') {
                        pts[pts.length - 1] = this.getObstacleStartPoint(connectorObstacle.segments[parseInt(i.toString(), 10)]);
                    }
                }
                pts.push(this.getObstacleEndPoint(connectorObstacle.segments[parseInt(i.toString(), 10)]));
            }
            /* tslint:disable */
            connectorObstacle.wrapper["" + obstacleCollection] = [];
            for (var j = 0; j < pts.length; j++) {
                var point = pts[parseInt(j.toString(), 10)];
                if (j === 0 || (j > 0 && !(Point.equals(point, pts[j - 1])))) {
                    connectorObstacle.wrapper["" + obstacleCollection].push(this.getPointvalue(point.x, point.y));
                }
            }
            /* tslint:enable */
            //EJ2-70198 - The layout ConnectionPointOrigin DifferentPoint property is not working for bezier connector
            //Bug 851920: Connector overlaps the node in complex hierarchical tree layout. Here the below condition is modified to check connector type.
            if (connectorObstacle.wrapper.type === 'Orthogonal') {
                this.resetConnectorPoints(connectorObstacle.wrapper, diagram);
            }
        }
    };
    //Bug 862601: Connectors are not rendered properly with lineRouting and lineDistribution enables during doLayout process.
    //To sort the connectors order in graph based on its target point and orientation to avoid connector segments path in same line.
    LineDistribution.prototype.sortConnectors = function (graph, diagram) {
        for (var i = 0; i < graph.length; i++) {
            for (var j = 0; j < graph[parseInt(i.toString(), 10)].value.length; j++) {
                if (graph[parseInt(i.toString(), 10)].value.length > 1) {
                    if (diagram.layout.orientation === 'LeftToRight' || diagram.layout.orientation === 'RightToLeft') {
                        graph[parseInt(i.toString(), 10)].value.sort(function (a, b) {
                            var connectorA = diagram.nameTable["" + a.id];
                            var connectorB = diagram.nameTable["" + b.id];
                            return connectorA.targetPoint.y - connectorB.targetPoint.y;
                        });
                    }
                    else if (diagram.layout.orientation === 'TopToBottom' || diagram.layout.orientation === 'BottomToTop') {
                        graph[parseInt(i.toString(), 10)].value.sort(function (a, b) {
                            var connectorA = diagram.nameTable["" + a.id];
                            var connectorB = diagram.nameTable["" + b.id];
                            return connectorA.targetPoint.x - connectorB.targetPoint.x;
                        });
                    }
                }
            }
        }
    };
    //private inflate(rect: Rect, x: number, y: number): Rect {
    //    rect.x -= x;
    //    rect.y -= y;
    //    rect.width += 2 * x;
    //    rect.height += 2 * y;
    //    return rect;
    //}
    //private updateConnectorPoints(
    //    connectorPoints: Point[], startSegmentSize: number, intermediatePoint: Point, bounds: object, orientation: string):
    //    Point[] {
    //    const layoutBounds: Rect = bounds as Rect;
    //    const isHorizontal: boolean = orientation === 'LeftToRight' || orientation === 'RightToLeft';
    //    const pts: Point[] = connectorPoints;
    //    if (pts.length > 2) {
    //        const newPt: Point = Point.transform(pts[0], Point.findAngle(pts[0], pts[1]), startSegmentSize) as Point;
    //        const nextPt: Point = Point.transform(newPt, Point.findAngle(pts[1], pts[2]), Point.findLength(pts[1], pts[2])) as Point;
    //        pts.splice(1, 2, newPt, nextPt);
    //        if (intermediatePoint != null) {
    //            const index: number = 2;
    //            const ptsCount: number = pts.length;
    //            const newPt1: Point = Point.transform(
    //                pts[ptsCount - 1],
    //                Point.findAngle(pts[ptsCount - 1], pts[ptsCount - 2]),
    //                startSegmentSize) as Point;
    //            pts.splice(ptsCount - 1, 0, newPt1);
    //            while (index < (pts.length - 2)) {
    //                pts.splice(index, 1);
    //            }
    //            const edgePt: Point = intermediatePoint;
    //            this.inflate((layoutBounds as Rect), (layoutBounds as Rect).width, layoutBounds.height);
    //            const line1: Point[] = [];
    //            line1[0] = this.getPointvalue(edgePt.x, layoutBounds.y) as Point;
    //            line1[1] = this.getPointvalue(edgePt.x, layoutBounds.y + layoutBounds.height) as Point;
    //            const line2: Point[] = [];
    //            line2[0] = this.getPointvalue(layoutBounds.x, pts[1].y) as Point;
    //            line2[1] = this.getPointvalue(layoutBounds.x + layoutBounds.width, pts[1].y) as Point;
    //            const line3: Point[] = [];
    //            line3[0] = this.getPointvalue(layoutBounds.x, newPt1.y) as Point;
    //            line3[1] = this.getPointvalue(layoutBounds.x + layoutBounds.width, newPt1.y) as Point;
    //            if (isHorizontal) {
    //                line1[0] = this.getPointvalue(layoutBounds.x, edgePt.y) as Point;
    //                line1[1] = this.getPointvalue(layoutBounds.x + layoutBounds.width, edgePt.y) as Point;
    //                line2[0] = this.getPointvalue(pts[1].x, layoutBounds.y) as Point;
    //                line2[1] = this.getPointvalue(pts[1].x, layoutBounds.y + layoutBounds.height) as Point;
    //                line3[0] = this.getPointvalue(newPt1.x, layoutBounds.y) as Point;
    //                line2[1] = this.getPointvalue(newPt1.x, layoutBounds.y + layoutBounds.height) as Point;
    //            }
    //            const intercepts1: Point[] = [intersect2(
    //                line1[0] as Point,
    //                line1[1] as Point, line2[0] as Point, line2[1] as Point)] as Point[];
    //            const intercepts2: Point[] = [intersect2(
    //                line1[0] as Point, line1[1] as Point,
    //                line3[0] as Point, line3[1] as Point)] as Point[];
    //            if (intercepts2.length > 0) {
    //                pts.splice(2, 0, intercepts2[0]);
    //            }
    //            if (intercepts1.length > 0) {
    //                pts.splice(2, 0, intercepts1[0]);
    //            }
    //        }
    //    }
    //    let i: number = 1;
    //    while (i < pts.length - 1) {
    //        if (Point.equals(pts[i - 1], pts[parseInt(i.toString(), 10)])) {
    //            pts.splice(i, 1);
    //        } else if (Point.findAngle(pts[i - 1], pts[parseInt(i.toString(), 10)])
    //            === Point.findAngle(pts[parseInt(i.toString(), 10)], pts[i + 1])) {
    //            pts.splice(i, 1);
    //        } else {
    //            i++;
    //        }
    //    }
    //    return pts;
    //}
    /* tslint:disable */
    LineDistribution.prototype.resetConnectorPoints = function (edge, diagram) {
        var obstacleCollection = 'obstaclePointCollection';
        if (edge.segments[0].points
            && edge.segments[0].points.length > 0 && edge["" + obstacleCollection]) {
            var connector = edge;
            connector.sourcePoint = edge["" + obstacleCollection][0];
            connector.targetPoint = edge["" + obstacleCollection][edge["" + obstacleCollection].length - 1];
            var segments = void 0;
            segments = [];
            for (var i = 0; i < edge["" + obstacleCollection].length - 1; i++) {
                var point1 = edge["" + obstacleCollection][parseInt(i.toString(), 10)];
                var point2 = edge["" + obstacleCollection][i + 1];
                var length_1 = findDistance(point1, point2);
                var direction = getConnectorDirection(point1, point2);
                if (i === edge["" + obstacleCollection].length - 2) {
                    if ((diagram.layout.orientation === 'RightToLeft' && direction === 'Left')
                        || (diagram.layout.orientation === 'LeftToRight' && direction === 'Right')
                        || (diagram.layout.orientation === 'TopToBottom' && direction === 'Bottom')
                        || (diagram.layout.orientation === 'BottomToTop' && direction === 'Top')) {
                        length_1 = length_1 / 2;
                    }
                }
                /* tslint:enable */
                var tempSegment = new OrthogonalSegment(edge, 'segments', { type: 'Orthogonal' }, true);
                tempSegment.length = length_1;
                tempSegment.direction = direction;
                segments.push(tempSegment);
            }
            connector.segments = segments;
            connector.type = 'Orthogonal';
            diagram.connectorPropertyChange(connector, {}, {
                type: 'Orthogonal',
                segments: connector.segments
            });
        }
    };
    LineDistribution.prototype.getObstacleEndPoint = function (segment) {
        if (segment.orientation === 'horizontal') {
            if (segment.direction === 'Left') {
                return this.getPointvalue(segment.start, segment.coord);
            }
            return this.getPointvalue(segment.end, segment.coord);
        }
        if (segment.direction === 'Top') {
            return this.getPointvalue(segment.coord, segment.start);
        }
        return this.getPointvalue(segment.coord, segment.end);
    };
    LineDistribution.prototype.getObstacleStartPoint = function (segment) {
        if (segment.orientation === 'horizontal') {
            if (segment.direction === 'Left') {
                return this.getPointvalue(segment.end, segment.coord);
            }
            return this.getPointvalue(segment.start, segment.coord);
        }
        if (segment.direction === 'Top') {
            return this.getPointvalue(segment.coord, segment.end);
        }
        return this.getPointvalue(segment.coord, segment.start);
    };
    LineDistribution.prototype.updateSegmentRow = function (obstacleSegments, segmentRow) {
        var k = 0;
        if (!(segmentRow.length > 0)) {
            segmentRow[0] = [];
        }
        for (var i = 0; i < obstacleSegments.length; i++) {
            var obstacleSegment = obstacleSegments[parseInt(i.toString(), 10)];
            while (k < segmentRow.length) {
                if (k === segmentRow.length - 1) {
                    segmentRow[k + 1] = [];
                }
                if (!(segmentRow[parseInt(k.toString(), 10)].length > 0)
                    || segmentRow[parseInt(k.toString(), 10)][segmentRow[parseInt(k.toString(), 10)].length - 1].end
                        < obstacleSegment.start) {
                    segmentRow[parseInt(k.toString(), 10)].push(obstacleSegment);
                    break;
                }
                k++;
            }
        }
        return segmentRow;
    };
    LineDistribution.prototype.portOffsetCalculation = function (port, length, direction, i) {
        if (direction === 'Top') {
            port.offset = { x: (i + 1) * (1.0 / (length + 1)), y: 0 };
        }
        if (direction === 'Bottom') {
            port.offset = { x: (i + 1) * (1.0 / (length + 1)), y: 1 };
        }
        if (direction === 'Left') {
            port.offset = { x: 0, y: (i + 1) * (1.0 / (length + 1)) };
        }
        if (direction === 'Right') {
            port.offset = { x: 1, y: (i + 1) * (1.0 / (length + 1)) };
        }
    };
    LineDistribution.prototype.addDynamicPortandDistrrbuteLine = function (layout, node, sourceDirection, targetDirection, diagram) {
        if ((node.ports && node.ports.length > 0)) {
            var port = node.ports;
            diagram.removePorts(node, port);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var existingPorts = node.ports;
        var outConnectors = node.outEdges;
        var inConnectors = node.inEdges;
        this.initPort(outConnectors, diagram, node, sourceDirection, false);
        this.initPort(inConnectors, diagram, node, targetDirection, true);
    };
    /* tslint:disable */
    LineDistribution.prototype.initPort = function (connectors, diagram, node, targetDirection, inConnectors) {
        var obstacleCollection = 'obstaclePointCollection';
        var objects = connectors;
        // EJ2-61463 - Added below code to sort the objects based on the source node offset position
        if (connectors.length > 1 && inConnectors) {
            connectors = this.sortObjects(objects, inConnectors, diagram);
        }
        for (var i = 0; i <= connectors.length - 1; i++) {
            var internalConnector = diagram.nameTable[connectors[parseInt(i.toString(), 10)]];
            internalConnector["" + obstacleCollection] = [];
            var newPort = findPort(node, inConnectors ? internalConnector.targetPortID : internalConnector.sourcePortID);
            var direction = targetDirection;
            if (newPort === undefined) {
                newPort = new PointPort(node, 'ports', '', true);
                newPort.id = randomId() + '_LineDistribution';
                if (inConnectors) {
                    internalConnector.targetPortID = newPort.id;
                }
                else {
                    internalConnector.sourcePortID = newPort.id;
                }
            }
            this.portOffsetCalculation(newPort, connectors.length, direction, i);
            node.ports.push(newPort);
            var portWrapper = node.initPortWrapper(node.ports[node.ports.length - 1]);
            node.wrapper.children.push(portWrapper);
            // EJ2-66867 -  Exception occurs on calling doLayout while injecting Linerouting module
            // nodes portWrapper bouds is updated below
            node.wrapper.measure(new Size(node.width, node.height), node.id);
            node.wrapper.arrange(node.wrapper.desiredSize);
            diagram.connectorPropertyChange(internalConnector, inConnectors ? { targetPortID: '' } : { sourcePortID: '' }, 
            // eslint-disable-next-line
            inConnectors ? { targetPortID: newPort.id } : { sourcePortID: newPort.id });
        }
    };
    /* tslint:enable */
    //EJ2-61463 - Method used to sort the connectors based on the source node offset position
    LineDistribution.prototype.sortObjects = function (objects, inConnectors, diagram) {
        var temp;
        for (var i = 0; i < objects.length; i++) {
            for (var j = i + 1; j < objects.length; j++) {
                var internalConnector = diagram.nameTable[objects[parseInt(i.toString(), 10)]];
                var internalConnector2 = diagram.nameTable[objects[parseInt(j.toString(), 10)]];
                if (inConnectors) {
                    var childNode = diagram.nameTable[internalConnector.sourceID];
                    var childNode2 = diagram.nameTable[internalConnector2.sourceID];
                    // For LeftToRight and RightToLeft we want to consider source node offsetY position
                    if (diagram.layout.orientation === 'LeftToRight' || diagram.layout.orientation === 'RightToLeft') {
                        if (childNode.offsetY > childNode2.offsetY) {
                            temp = objects[parseInt(i.toString(), 10)];
                            objects[parseInt(i.toString(), 10)] = objects[parseInt(j.toString(), 10)];
                            objects[parseInt(j.toString(), 10)] = temp;
                        }
                    }
                    else {
                        // For TopToBottom or BottomToTop means we want to consider source node offsetX position
                        if (childNode.offsetX > childNode2.offsetX) {
                            temp = objects[parseInt(i.toString(), 10)];
                            objects[parseInt(i.toString(), 10)] = objects[parseInt(j.toString(), 10)];
                            objects[parseInt(j.toString(), 10)] = temp;
                        }
                    }
                }
            }
        }
        return objects;
    };
    //private shiftMatrixCells(
    //    value: number, startingCell: MatrixCellGroupObject, shiftChildren: boolean,
    //    parentCell: MatrixCellGroupObject, matrixModel: MatrixModelObject):
    //    void {
    //    if (!(value === 0)) {
    //        const matrix: MatrixObject[] = matrixModel.matrix;
    //        const matrixRow: MatrixCellGroupObject[] = matrix[startingCell.level].value;
    //        const index: number = matrixRow.indexOf(startingCell);
    //        for (let i: number = index; i < matrixRow.length; i++) {
    //            matrixRow[parseInt(i.toString(), 10)].offset += value;
    //        }
    //        if (shiftChildren) {
    //            if (startingCell.visitedChildren.length > 0) {
    //                this.shiftMatrixCells(
    //                    value,
    //                    startingCell.visitedChildren[0],
    //                    true,
    //                    startingCell,
    //                    matrixModel);
    //            } else {
    //                let i: number = 1;
    //                let nextSibilingwithChild: MatrixCellGroupObject = null;
    //                while (index + i < matrixRow.length) {
    //                    const nextCell: MatrixCellGroupObject = matrixRow[index + i];
    //                    if (parentCell != null && this.containsValue(nextCell.visitedParents, parentCell)) {
    //                        if (nextCell.visitedChildren.length > 0) {
    //                            nextSibilingwithChild = nextCell;
    //                        } else {
    //                            i++;
    //                            continue;
    //                        }
    //                    }
    //                    break;
    //                }
    //                if (nextSibilingwithChild != null) {
    //                    this.shiftMatrixCells(
    //                        value,
    //                        nextSibilingwithChild.visitedChildren[0],
    //                        true,
    //                        nextSibilingwithChild,
    //                        matrixModel);
    //                }
    //            }
    //        }
    //    }
    //}
    //private arrangeMatrix(cell: MatrixCellGroupObject, parent: MatrixCellGroupObject, matrixModel: MatrixModelObject): void {
    //    const layoutSettings: LayoutProp = matrixModel.model.layout;
    //    const isHorizontal: boolean = layoutSettings.orientation === 'LeftToRight'
    //        || layoutSettings.orientation === 'RightToLeft';
    //    const spacing: number = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
    //    const matrix: MatrixObject[] = matrixModel.matrix;
    //    const matrixRow: MatrixCellGroupObject[] = matrix[cell.level].value;
    //    const matrixIndex: number = matrixRow.indexOf(cell);
    //    if (cell.visitedParents.length > 0) {
    //        if (cell.visitedParents.length === 1) {
    //            cell.initialOffset = cell.offset;
    //        }
    //        if (matrixIndex + 1 < matrixRow.length) {
    //            const nextCell: MatrixCellGroupObject = matrixRow[matrixIndex + 1];
    //            if (nextCell.visitedParents.length > 0) {
    //                if (!this.containsValue(cell.visitedParents, parent)) {
    //                    cell.visitedParents.push(parent);
    //                    parent.ignoredChildren.push(cell);
    //                    return;
    //                }
    //            }
    //        }
    //    }
    //    if (!(cell.children.length > 0)) {
    //        let validOffset: number = cell.offset;
    //        if (matrixIndex > 0) {
    //            const prevCell: MatrixCellGroupObject = matrixRow[matrixIndex - 1];
    //            validOffset = prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);
    //        }
    //        this.shiftMatrixCells(validOffset - cell.offset, cell, false, null, matrixModel);
    //    } else {
    //        for (let i: number = 0; i < cell.children.length; i++) {
    //            const matrixCellChild: MatrixCellGroupObject = cell.children[parseInt(i.toString(), 10)];
    //            if (!this.containsValue(cell.visitedChildren, matrixCellChild)) {
    //                this.arrangeMatrix(matrixCellChild, cell, matrixModel);
    //                cell.visitedChildren.push(matrixCellChild);
    //            }
    //        }
    //        if (cell.visitedChildren.length > 0) {
    //            const children: MatrixCellGroupObject[] = cell.visitedChildren.slice();
    //            for (let i: number = 0; i < cell.ignoredChildren.length; i++) {
    //                //let cellIgnoredChild: MatrixCellGroupObject = cell.ignoredChildren[i];
    //                children.splice(0, 1);
    //                cell.visitedChildren.splice(0, 1);
    //            }
    //            if (children.length > 0) {
    //                const firstChild: MatrixCellGroupObject = cell.visitedChildren[0];
    //                const lastChild: MatrixCellGroupObject = cell.visitedChildren[cell.visitedChildren.length - 1];
    //                const x1: number = firstChild.offset - (firstChild.size / 2);
    //                const x2: number = lastChild.offset + (lastChild.size / 2);
    //                const newoffset: number = (x1 + x2) / 2;
    //                if (newoffset < cell.offset) {
    //                    this.shiftMatrixCells(cell.offset - newoffset, firstChild, true, cell, matrixModel);
    //                } else if (newoffset > cell.offset) {
    //                    this.shiftMatrixCells(newoffset - cell.offset, cell, false, null, matrixModel);
    //                }
    //            }
    //        }
    //    }
    //    if (!this.containsValue(cell.visitedParents, parent)) {
    //        cell.visitedParents.push(parent);
    //    }
    //}
    /** @private */
    LineDistribution.prototype.resetConnectorSegments = function (connector) {
        var segements = connector.segments;
        for (var i = segements.length; i > 0; i--) {
            segements.splice(i - 1, 1);
        }
    };
    /* tslint:disable */
    /** @private */
    LineDistribution.prototype.resetRoutingSegments = function (connector, diagram, points) {
        if (connector['levelSkip']) {
            //Bug 877799: Optimize the routing segment distance while using enableRouting in layout.
            var sourceLevel = void 0;
            var targetLevel = void 0;
            var collection = diagram.layout.ranks.reverse();
            //To find the source level and target level of the level skip connector
            for (var i = 0; i < collection.length; i++) {
                for (var j = 0; j < collection[parseInt(i.toString(), 10)].length; j++) {
                    if (connector.sourceID === collection[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)].id) {
                        sourceLevel = i;
                    }
                    if (connector.targetID === collection[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)].id) {
                        targetLevel = i;
                    }
                }
            }
            // To find the overlapping collection between the source and target level
            var overlappCollection = [];
            if (sourceLevel < targetLevel) {
                for (var i = 0; i < collection.length; i++) {
                    if (i > sourceLevel && i < targetLevel) {
                        overlappCollection.push(collection[parseInt(i.toString(), 10)]);
                    }
                }
            }
            else {
                for (var i = 0; i < collection.length; i++) {
                    if (i < sourceLevel && i > targetLevel) {
                        overlappCollection.push(collection[parseInt(i.toString(), 10)]);
                    }
                }
            }
            // To find the overlapping nodes between the source and target level
            var overLapNodesCollection = [];
            for (var i = 0; i < overlappCollection.length; i++) {
                for (var j = 0; j < overlappCollection[parseInt(i.toString(), 10)].length; j++) {
                    if (overlappCollection[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)].edges === undefined) {
                        var node = diagram.nameTable[overlappCollection[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)].id];
                        overLapNodesCollection.push(node);
                    }
                }
            }
            var isInsideBounds = false;
            if (!diagram.routingConnectors) {
                diagram.routingConnectors = [];
            }
            //To find whether the connector is overlapping with the nodes in the overlapping collection.
            // eslint-disable-next-line no-labels
            overlapping: for (var count = 0; count < overLapNodesCollection.length; count++) {
                var bounds = overLapNodesCollection[parseInt(count.toString(), 10)].wrapper.bounds;
                for (var i = 0; i < connector.segments.length; i++) {
                    var points_1 = connector.segments[parseInt(i.toString(), 10)].points;
                    for (var j = 0; j < points_1.length; j++) {
                        var lineStart = points_1[parseInt(j.toString(), 10)];
                        var lineEnd = points_1[j + 1];
                        if (lineEnd) {
                            var connectorPoints = this.pointsAlongLine(lineStart, lineEnd);
                            isInsideBounds = this.pointInsideBounds(connectorPoints, bounds);
                            if (isInsideBounds) {
                                diagram.routingConnectors.push(connector);
                                // eslint-disable-next-line no-labels
                                break overlapping;
                            }
                        }
                    }
                }
            }
        }
    };
    /**
     * Calculates points along a line between two given points.
     *  @param start The starting point of the line.
     *  @param end The ending point of the line.
     *  @return An array of points along the line.
     */
    LineDistribution.prototype.pointsAlongLine = function (start, end) {
        var granularity = 1;
        var dx = end.x - start.x;
        var dy = end.y - start.y;
        var length = Math.sqrt(dx * dx + dy * dy);
        var stepX = (dx / length) * granularity;
        var stepY = (dy / length) * granularity;
        var points = [];
        for (var i = 0; i <= length; i += granularity) {
            points.push({ x: start.x + stepX * i, y: start.y + stepY * i });
        }
        return points;
    };
    /**
     *
     * Checks if any of the given points fall inside the specified bounding rectangle.
     *  @param points An array of points to be checked.
     *  @param bounds The bounding rectangle to check against.
     *  @return True if any point is inside the bounds, false otherwise.
     */
    LineDistribution.prototype.pointInsideBounds = function (points, bounds) {
        for (var _i = 0, points_2 = points; _i < points_2.length; _i++) {
            var point = points_2[_i];
            if (bounds.right > point.x &&
                bounds.left < point.x &&
                bounds.top < point.y &&
                bounds.bottom > point.y) {
                return true;
            }
        }
        return false;
    };
    /* tslint:enable */
    /** @private */
    //public arrangeElements(matrixModel: MatrixModelObject, layout: Layout): void {
    //    const layoutSettings: LayoutProp = matrixModel.model.layout;
    //    let isHorizontal: boolean;
    //    if (layout.orientation === 'LeftToRight' || layout.orientation === 'RightToLeft') {
    //        isHorizontal = true;
    //    } else {
    //        isHorizontal = false;
    //    }
    //    const spacing: number = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
    //    //let spacingInverse: number = !isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
    //    // Need to group element before
    //    this.groupLayoutCells(matrixModel);
    //    this.createMatrixCells(matrixModel);
    //    for (let j: number = 0; j < matrixModel.matrix.length; j++) {
    //        const matrixKey: number = matrixModel.matrix[parseInt(j.toString(), 10)].key;
    //        const matrixrow: MatrixCellGroupObject[] = matrixModel.matrix[parseInt(matrixKey.toString(), 10)].value;
    //        for (let i: number = 1; i < matrixrow.length; i++) {
    //            const cell: MatrixCellGroupObject = matrixrow[parseInt(i.toString(), 10)];
    //            const prevCell: MatrixCellGroupObject = matrixrow[i - 1];
    //            cell.offset += prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);
    //        }
    //    }
    //    for (let j: number = 0; j < matrixModel.matrix[0].value.length; j++) {
    //        const root: MatrixCellGroupObject = matrixModel.matrix[0].value[parseInt(j.toString(), 10)];
    //        this.arrangeMatrix(root, null, matrixModel);
    //    }
    //    for (let k: number = 0; k < matrixModel.matrix.length; k++) {
    //        const row: MatrixCellGroupObject[] = matrixModel.matrix[parseInt(k.toString(), 10)].value;
    //        for (let i: number = 0; i < row.length; i++) {
    //            const cell: MatrixCellGroupObject = row[parseInt(i.toString(), 10)];
    //            if (cell.visitedParents.length > 1) {
    //                let firstParent: MatrixCellGroupObject = cell.visitedParents[0];
    //                let lastParent: MatrixCellGroupObject = cell.visitedParents[cell.visitedParents.length - 1];
    //                const firstVertexParent: MatrixCellGroupObject = this.findParentVertexCellGroup(firstParent);
    //                const lastVertexParent: MatrixCellGroupObject = this.findParentVertexCellGroup(lastParent);
    //                if (firstParent !== firstVertexParent && firstVertexParent.offset < firstParent.offset) {
    //                    firstParent = firstVertexParent;
    //                }
    //                if (lastParent !== lastVertexParent && lastVertexParent.offset > lastParent.offset) {
    //                    lastParent = firstVertexParent;
    //                }
    //                const newoffset: number = (firstParent.offset + lastParent.offset) / 2;
    //                const availOffsetMin: number = cell.initialOffset;
    //                const availOffsetMax: number = cell.offset;
    //                if (!(availOffsetMax === availOffsetMin)) {
    //                    if (newoffset >= availOffsetMin && newoffset <= availOffsetMax) {
    //                        this.translateMatrixCells(newoffset - cell.offset, cell);
    //                    } else if (newoffset < availOffsetMin) {
    //                        this.translateMatrixCells(availOffsetMin - cell.offset, cell);
    //                    }
    //                }
    //            }
    //        }
    //    }
    //    this.setXYforMatrixCell(matrixModel);
    //}
    //private findParentVertexCellGroup(cell: MatrixCellGroupObject): MatrixCellGroupObject {
    //    if (cell.cells[0]) {
    //        return cell;
    //    }
    //    if (cell.parents.length > 0) {
    //        return this.findParentVertexCellGroup(cell.parents[0]);
    //    }
    //    return cell;
    //}
    //private setXYforMatrixCell(matrixModel: MatrixModelObject): void {
    //    const layoutSettings: LayoutProp = matrixModel.model.layout;
    //    const isHorizontal: boolean = layoutSettings.orientation === 'LeftToRight'
    //        || layoutSettings.orientation === 'RightToLeft';
    //    const spacing: number = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
    //    for (let i: number = 0; i < matrixModel.matrix.length; i++) {
    //        const matrixrow1: MatrixCellGroupObject[] = matrixModel.matrix[parseInt(i.toString(), 10)].value;
    //        for (let j: number = 0; j < matrixrow1.length; j++) {
    //            const matrixCell: MatrixCellGroupObject = matrixrow1[parseInt(j.toString(), 10)];
    //            let start: number = matrixCell.offset - (matrixCell.size / 2);
    //            for (let k: number = 0; k < (matrixCell.cells as CellObject[]).length; k++) {
    //                const cell: CellObject = matrixCell.cells[parseInt(k.toString(), 10)];
    //                const type: string = this.getType(cell.type);
    //                if (type === 'internalVertex') {
    //                    const internalVertex: CellObject = cell;
    //                    const width: number = internalVertex.cell.geometry.width;
    //                    const height: number = internalVertex.cell.geometry.height;
    //                    if (isHorizontal) {
    //                        internalVertex.cell.geometry = new Rect(
    //                            matrixModel.rowOffset[matrixCell.level] - (width / 2),
    //                            start,
    //                            width,
    //                            height) as Rect;
    //                    } else {
    //                        internalVertex.cell.geometry = new Rect(
    //                            start,
    //                            matrixModel.rowOffset[matrixCell.level] - (height / 2),
    //                            width,
    //                            height) as Rect;
    //                    }
    //                    start += (isHorizontal ? height : width) + spacing;
    //                } else if (type === 'internalEdge') {
    //                    const internalEdges: CellObject = cell;
    //                    const parent: MatrixCellGroupObject = matrixCell.visitedParents[0];
    //                    let isContainSibilingVertex: boolean = false;
    //                    if (parent) {
    //                        for (let l: number = 0; l < parent.visitedChildren.length; l++) {
    //                            const children: MatrixCellGroupObject = parent.visitedChildren[parseInt(l.toString(), 10)];
    //                            const cells: CellObject[] = [];
    //                            for (let m: number = 0; m < (children.cells as CellObject[]).length; m++) {
    //                                const cell: CellObject = children.cells[parseInt(m.toString(), 10)];
    //                                const type: string = this.getType(cell.type);
    //                                if (type === 'internalVertex') {
    //                                    cells.push(cell);
    //                                }
    //                            }
    //                            if (cells.length > 0) {
    //                                isContainSibilingVertex = true;
    //                                break;
    //                            }
    //                        }
    //                    }
    //                    // Need to updated line width
    //                    const lineWidth: number = 1;
    //                    const edgeSpacing: number = 5;
    //                    for (let m: number = 0; m < internalEdges.edges.length; m++) {
    //                        const internalConnector: Connector = internalEdges.edges[parseInt(m.toString(), 10)];
    //                        let pt: Point = this.getPointvalue(start + (lineWidth / 2.0), matrixModel.rowOffset[matrixCell.level]) as Point;
    //                        if (isHorizontal) {
    //                            pt = this.getPointvalue(matrixModel.rowOffset[matrixCell.level], start + (lineWidth / 2.0)) as Point;
    //                        }
    //                        if (this.containsValue((this.getEdgeMapper() as EdgeMapperObject[]), internalConnector)) {
    //                            let key: number;
    //                            for (let l: number = 0; l < this.getEdgeMapper().length; l++) {
    //                                if ((this.getEdgeMapper())[parseInt(l.toString(), 10)].key === internalConnector) {
    //                                    key = l;
    //                                    break;
    //                                }
    //                            }
    //                            (this.getEdgeMapper())[parseInt(key.toString(), 10)].value.push(pt as Point);
    //                        }
    //                        start += lineWidth + edgeSpacing;
    //                    }
    //                    start += spacing;
    //                }
    //            }
    //        }
    //    }
    //}
    //private getEdgeMapper(): EdgeMapperObject[] {
    //    return this.edgeMapper;
    //}
    ///** @private */
    //public setEdgeMapper(value: EdgeMapperObject): void {
    //    this.edgeMapper.push(value);
    //}
    //private translateMatrixCells(value: number, cell: MatrixCellGroupObject): void {
    //    if (!(value === 0)) {
    //        cell.offset += value;
    //        if (cell.visitedChildren.length > 0) {
    //            for (let i: number = 0; i < cell.visitedChildren.length; i++) {
    //                let cellVisitedChild: MatrixCellGroupObject = cell.visitedChildren[parseInt(i.toString(), 10)];
    //                this.translateMatrixCells(value, cellVisitedChild);
    //            }
    //        }
    //    }
    //}
    //private groupLayoutCells(matrixModel: MatrixModelObject): void {
    //    let ranks: IVertex[][] = matrixModel.model.ranks;
    //    for (let j: number = ranks.length - 1; j >= 0; j--) {
    //        let vertices: IVertex[] = [];
    //        for (let v: number = 0; v < ranks[parseInt(j.toString(), 10)].length; v++) {
    //            let rank: IVertex = ranks[parseInt(j.toString(), 10)][parseInt(v.toString(), 10)];
    //            let type: string = this.getType(rank.type);
    //            if (type === 'internalVertex') {
    //                vertices.push(ranks[parseInt(j.toString(), 10)][parseInt(v.toString(), 10)]);
    //            }
    //        }
    //        let edges: IVertex[] = [];
    //        for (let e: number = 0; e < ranks[parseInt(j.toString(), 10)].length; e++) {
    //            let rank: IVertex = ranks[parseInt(j.toString(), 10)][parseInt(e.toString(), 10)];
    //            let type: string = this.getType(rank.type);
    //            if (type === 'internalEdge') {
    //                edges.push(rank);
    //            }
    //        }
    //        while (vertices.length > 1) {
    //            const vertex1: IVertex = vertices[0];
    //            const parentset1: string[] = this.selectIds(vertex1.connectsAsTarget, true);
    //            const childset1: string[] = this.selectIds(vertex1.connectsAsSource, false);
    //            while (vertices.length > 1) {
    //                const vertex2: IVertex = vertices[1];
    //                const parentset2: string[] = this.selectIds(vertex2.connectsAsTarget, true);
    //                const childset2: string[] = this.selectIds(vertex2.connectsAsSource, false);
    //                const parentequals: boolean = this.compareLists(parentset1, parentset2);
    //                const childequals: boolean = this.compareLists(childset1, childset2);
    //                if (parentequals && childequals) {
    //                    this.updateMutualSharing(vertices[0], vertex2.id);
    //                    this.updateMutualSharing(vertices[1], vertex1.id);
    //                    vertices.splice(1, 1);
    //                    continue;
    //                }
    //                break;
    //            }
    //            vertices.splice(0, 1);
    //        }
    //        while (edges.length > 1) {
    //            const internalEdge: IVertex = edges[0];
    //            const parentset: IVertex = internalEdge.source;
    //            const childset: IVertex = internalEdge.target;
    //            if (parentset.identicalSibiling != null) {
    //                const groupedges: IVertex[] = [];
    //                for (let i: number = 0; i < edges.length; i++) {
    //                    const edge: IVertex = edges[parseInt(i.toString(), 10)];
    //                    if (edge.target === childset) {
    //                        groupedges.push(edge);
    //                    }
    //                }
    //                for (let i: number = 0; i < groupedges.length; i++) {
    //                    const internalEdgese: IVertex = groupedges[parseInt(i.toString(), 10)];
    //                    if (this.containsValue(parentset.identicalSibiling, internalEdgese.source.id)) {
    //                        internalEdgese.source.identicalSibiling = null;
    //                    }
    //                }
    //                internalEdge.source.identicalSibiling = null;
    //            }
    //            edges.splice(0, 1);
    //        }
    //    }
    //}
    //private getType(type: string): string {
    //    if (type === 'internalVertex') {
    //        return 'internalVertex';
    //    } else {
    //        return 'internalEdge';
    //    }
    //}
    //private selectIds(node: IEdge[], source: boolean): string[] {
    //    const returnIds: string[] = [];
    //    for (let i: number = 0; i < node.length; i++) {
    //        const connector: IEdge = node[parseInt(i.toString(), 10)];
    //        if (source) {
    //            {
    //                returnIds.push(connector.source.id);
    //            }
    //        } else {
    //            returnIds.push(connector.target.id);
    //        }
    //    }
    //    return returnIds;
    //}
    //private compareLists(list1: string[], list2: string[]): boolean {
    //    const newList1: string[] = list1.slice();
    //    const newList2: string[] = list2.slice();
    //    if (newList1.length === newList2.length) {
    //        if (newList1.length === 0) {
    //            return true;
    //        } else {
    //            let isSame: boolean = true;
    //            for (let i: number = 0; i < newList2.length; i++) {
    //                const o: string = newList2[parseInt(i.toString(), 10)];
    //                // EJ2-63944 - Nodes overlapping in Complex hierarchical tree layout in linear arrangement.
    //                if (newList1.indexOf(o) === -1)
    //                {
    //                    isSame = false;
    //                    break;
    //                }
    //            }
    //            return isSame;
    //        }
    //    }
    //    return false;
    //}
    //private updateMutualSharing(cell: IVertex, id: string): void {
    //    if (cell.identicalSibiling != null) {
    //        cell.identicalSibiling.push(id);
    //    } else {
    //        cell.identicalSibiling = [];
    //        cell.identicalSibiling.push(id);
    //    }
    //}
    //private matrixCellGroup(options: MatrixCellGroupObject): MatrixCellGroupObject {
    //    options.level = options.level;
    //    options.parents = options.parents;
    //    options.children = options.children;
    //    options.visitedChildren = options.visitedChildren;
    //    options.visitedParents = options.visitedParents;
    //    options.ignoredChildren = options.ignoredChildren;
    //    options.cells = options.cells;
    //    options.offset = options.offset;
    //    options.initialOffset = options.initialOffset;
    //    return options;
    //}
    LineDistribution.prototype.getPointvalue = function (x, y) {
        return { 'x': Number(x) || 0, 'y': Number(y) || 0 };
    };
    LineDistribution.prototype.containsValue = function (list, keyValue) {
        for (var i = 0; i < list.length; i++) {
            if (list[parseInt(i.toString(), 10)] === keyValue) {
                return true;
            }
        }
        return false;
    };
    return LineDistribution;
}());
///** @private */
//interface ConnectsAsSourceObject {
//    id: string[];
//    source: ConnectsAsSourceObject;
//    target: ConnectsAsSourceObject;
//    temp: number[];
//    x: number[];
//    y: number[];
//}

/**
 * Hierarchical Tree and Organizational Chart
 */
var HierarchicalTree = /** @class */ (function () {
    /**
     * Constructor for the organizational chart module.
     *
     * @private
     */
    function HierarchicalTree() {
        /**
         * Defines the layout animation
         *
         */
        this.isAnimation = false;
        //constructs the layout module
    }
    /**
     * To destroy the organizational chart
     *
     * @returns {void}
     * @private
     */
    HierarchicalTree.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    /**
     * Get module name.
     */
    HierarchicalTree.prototype.getModuleName = function () {
        /**
         * Returns the module name of the layout
         */
        return 'OrganizationalChart';
    };
    /**
     * @param nodes
     * @param nameTable
     * @param layoutProp
     * @param viewport
     * @param uniqueId
     * @param action
     * @private
     */
    HierarchicalTree.prototype.updateLayout = function (nodes, nameTable, layoutProp, viewport, uniqueId, action) {
        var layout = {
            type: layoutProp.type,
            connectionPointOrigin: layoutProp.connectionPointOrigin,
            nameTable: nameTable, anchorX: 0, anchorY: 0,
            firstLevelNodes: [], centerNode: null, levels: [], maxLevel: 0, graphNodes: {},
            orientation: layoutProp.orientation,
            horizontalSpacing: layoutProp.horizontalSpacing, verticalSpacing: layoutProp.verticalSpacing,
            verticalAlignment: layoutProp.verticalAlignment, horizontalAlignment: layoutProp.horizontalAlignment,
            fixedNode: layoutProp.fixedNode, getLayoutInfo: getFunction(layoutProp.getLayoutInfo),
            layoutInfo: layoutProp.layoutInfo, margin: layoutProp.margin,
            bounds: layoutProp.bounds, objects: [], root: layoutProp.root
        };
        this.doLayout(layout, nodes, viewport, uniqueId, action);
        return layout;
    };
    HierarchicalTree.prototype.doLayout = function (layout, nodes, viewport, uniqueId, action) {
        var node;
        var i;
        var layoutInfo = {};
        var rootNodes = [];
        if (layout.nameTable[layout.root]) {
            layout.firstLevelNodes.push(layout.nameTable[layout.root]);
        }
        for (i = 0; i < nodes.length; i++) {
            node = nodes[parseInt(i.toString(), 10)];
            if (!node.excludeFromLayout) {
                layoutInfo = layout.graphNodes[node.id] = this.setUpLayoutInfo(layout, node);
                layoutInfo.tree.hasSubTree = false;
                if (!layout.nameTable[layout.root]) {
                    if (!node.inEdges || !node.inEdges.length) {
                        var parentId = 'parentId';
                        var processId = 'processId';
                        if (!node["" + parentId] && !node["" + processId]) {
                            rootNodes.push(node);
                        }
                        if (node.data && String(node.data["" + uniqueId]) === layout.root) {
                            layout.firstLevelNodes.push(node);
                        }
                    }
                }
            }
        }
        if (layout.firstLevelNodes.length === 0) {
            layout.firstLevelNodes = rootNodes;
        }
        //Update relationship(parent and children)
        for (i = 0; i < layout.firstLevelNodes.length; i++) {
            node = layout.firstLevelNodes[parseInt(i.toString(), 10)];
            //let check: boolean;
            this.updateEdges(layout, node, 1, action, nodes);
        }
        if (layout.firstLevelNodes.length > 0) {
            layout.rootNode = layout.firstLevelNodes[0];
            var x = 0;
            var y = 0;
            var minX = void 0;
            var maxY = void 0;
            var maxX = void 0;
            var minY = void 0;
            //let j: number;
            var bounds = void 0;
            for (i = 0; i < layout.firstLevelNodes.length; i++) {
                bounds = this.updateTree(layout, x, y, layout.firstLevelNodes[parseInt(i.toString(), 10)], 0, layout.firstLevelNodes[i - 1]);
                var rootInfo = layout.graphNodes[layout.firstLevelNodes[parseInt(i.toString(), 10)].id];
                bounds.y = Math.min(bounds.y, rootInfo.y);
                bounds.x = Math.min(bounds.x, rootInfo.x);
                if (layout.orientation.indexOf('Left') !== -1) {
                    y = bounds.right + layout.horizontalSpacing;
                }
                else {
                    x = bounds.right + layout.horizontalSpacing;
                }
                if (i === 0) {
                    minX = bounds.x;
                    minY = bounds.y;
                    maxX = bounds.right;
                    maxY = bounds.bottom;
                }
                else {
                    minX = Math.min(minX, bounds.x);
                    minY = Math.min(minY, bounds.y);
                    maxX = Math.max(maxX, bounds.right);
                    maxY = Math.max(maxY, bounds.bottom);
                }
                //Bug 924568: Hierarchical tree child nodes are positioned unevenly when rendering with multiple root nodes.
                //Added below code to empty the layout levels after processing the first root node.
                layout.levels = [];
                layout.maxLevel = undefined;
            }
            this.updateAnchor(layout, { x: minX, y: minY, right: maxX, bottom: maxY }, viewport);
            for (i = 0; i < layout.firstLevelNodes.length; i++) {
                this.updateNodes(layout, layout.firstLevelNodes[parseInt(i.toString(), 10)], 0);
            }
            for (i = 0; i < layout.firstLevelNodes.length; i++) {
                this.updateConnectors(layout, layout.firstLevelNodes[parseInt(i.toString(), 10)], 1);
            }
        }
    };
    HierarchicalTree.prototype.getBounds = function (node) {
        var x = node.offsetX - node.actualSize.width * node.pivot.x;
        var y = node.offsetY - node.actualSize.height * node.pivot.y;
        return new Rect(x, y, node.actualSize.width, node.actualSize.height);
    };
    HierarchicalTree.prototype.updateTree = function (layout, x, y, shape, level, prev, dontupdate) {
        //let dimensions: Dimensions;
        var info = {};
        var lev;
        var obj;
        //let hasChild: number;
        var dimensions = this.getDimensions(layout, shape, x, y, level);
        info = layout.graphNodes[shape.id];
        //Set maximum level of layout
        layout.maxLevel = Math.max(layout.maxLevel, level);
        lev = level;
        var hasChild = this.hasChild(layout, shape);
        if (!hasChild && !info.tree.assistants.length) {
            //update leaf nodes
            shape.treeBounds = this.updateLeafNode(layout, shape, prev, dimensions, level, dontupdate);
            return shape.treeBounds;
        }
        else {
            var treeBounds = void 0;
            var shapeBounds = void 0;
            var levelBounds = void 0;
            var d = void 0;
            var asstBounds = void 0;
            var space = void 0;
            var bottom = void 0;
            bottom = dimensions.y + dimensions.height + layout.verticalSpacing;
            if (info.tree.assistants.length) {
                //Vertically place assistants
                obj = this.setDepthSpaceForAssitants(layout, shape, bottom, dimensions.height, level, layout.verticalSpacing);
                lev = obj.level;
                bottom = obj.bottom;
            }
            if (!info.tree.assistants.length && info.tree.orientation !== 'Horizontal') {
                bottom = dimensions.y + dimensions.height + layout.verticalSpacing / 2;
            }
            if (info.tree.children.length) {
                if (info.tree.orientation === 'Horizontal' && (info.tree.type !== 'Balanced' || info.tree.children.length === 1)) {
                    treeBounds = this.updateHorizontalTree(layout, shape, prev, dimensions.x, bottom, lev);
                }
                else if (info.tree.type === 'Balanced') {
                    treeBounds = this.updateHorizontalTreeWithMultipleRows(layout, shape, prev, dimensions.x, bottom, lev);
                }
                else {
                    treeBounds = this.updateVerticalTree(layout, shape, dimensions.x, bottom, lev, dontupdate);
                }
            }
            if (!(info.y && info.y > dimensions.y)) {
                info.y = dimensions.y;
            }
            // 919520: Leaf node position does not align correctly for subTreeAlignment 'Center'
            if (info.mid !== undefined) {
                x = info.mid;
            }
            if (info.tree.assistants.length) {
                //Set breadth space for assistants
                space = x !== undefined ? x : dimensions.x;
                asstBounds = this.setBreadthSpaceForAssistants(layout, shape, dimensions, space, bottom, level);
                if (!hasChild) {
                    levelBounds = treeBounds = asstBounds;
                    x = (levelBounds.x + levelBounds.right) / 2 - dimensions.width / 2;
                    treeBounds = levelBounds;
                }
                d = asstBounds ? asstBounds.canMoveBy : undefined;
            }
            info.x = x;
            if (!info.translate) {
                info.treeWidth = treeBounds.right - treeBounds.x;
            }
            {
                shapeBounds = { x: x, y: dimensions.y, right: x + dimensions.width, bottom: dimensions.y + dimensions.height };
            }
            var translateInfo = {
                layout: layout, shape: shape, shapeBounds: shapeBounds, treeBounds: treeBounds,
                dim: dimensions, level: level
            };
            this.translateSubTree(translateInfo, d, prev !== undefined, dontupdate);
            if (info.firstChild && typeof info.firstChild !== 'string') {
                info.firstChild.x += info.subTreeTranslation;
            }
            shape.treeBounds = treeBounds;
            return treeBounds;
        }
    };
    HierarchicalTree.prototype.updateLeafNode = function (layout, shape, prev, dimensions, level, dontupdate) {
        //let bounds: Bounds;
        var info = layout.graphNodes[shape.id];
        info.x = dimensions.x;
        if (!(info.y && info.y > dimensions.y)) {
            info.y = dimensions.y;
            info.maxLevel = Math.max(level, info.maxLevel || 0);
        }
        // eslint-disable-next-line max-len
        var bounds = { x: dimensions.x, y: dimensions.y, right: dimensions.x + dimensions.width, bottom: dimensions.y + dimensions.height };
        info.maxLevel = Math.max(info.maxLevel || 0, level);
        var translateInfo = {
            layout: layout, shape: shape, shapeBounds: bounds, treeBounds: bounds,
            dim: dimensions, level: level
        };
        this.translateSubTree(translateInfo, undefined, prev !== undefined, dontupdate);
        return { x: info.x, y: info.y, right: info.x + dimensions.width, bottom: info.y + dimensions.height };
    };
    HierarchicalTree.prototype.setUpLayoutInfo = function (layout, item) {
        var info = {};
        info.subTreeTranslation = 0;
        if (layout.type === 'OrganizationalChart') {
            info.tree = { orientation: 'Vertical', type: 'Alternate', offset: 20, enableRouting: true };
        }
        else {
            info.tree = { orientation: 'Horizontal', type: 'Center', enableRouting: true };
        }
        info.tree.children = [];
        info.tree.assistants = [];
        info.tree.level = 0;
        info.translate = true;
        return info;
    };
    HierarchicalTree.prototype.translateSubTree = function (translateInfo, asstDif, translate, dontupdate) {
        var layout = translateInfo.layout;
        var shape = translateInfo.shape;
        var shapeBounds = translateInfo.shapeBounds;
        var treeBounds = translateInfo.treeBounds;
        var level = translateInfo.level;
        var dim = translateInfo.dim;
        var info = layout.graphNodes[shape.id];
        var firstChild = layout.nameTable[info.firstChild ? info.firstChild.child : info.tree.children[0]];
        var firstChildInfo = firstChild ? layout.graphNodes[firstChild.id] : null;
        var hasChild = this.hasChild(layout, shape);
        var intersect = this.findIntersectingLevels(layout, shapeBounds, level, info.actualLevel);
        var treeIntersect = this.findIntersectingLevels(layout, treeBounds, level, info.actualLevel);
        var levelBounds = [];
        //const diff: number;
        if (intersect.length && info.translate) {
            info.intersect = intersect;
            this.spaceLeftFromPrevSubTree(layout, shape, shapeBounds);
            info.canMoveBy = info.diff;
            if (asstDif !== undefined) {
                info.canMoveBy = Math.min(asstDif, info.canMoveBy);
            }
            if (firstChild && firstChildInfo.canMoveBy !== undefined) {
                if (firstChildInfo.canMoveBy >= info.canMoveBy) {
                    info.translated = true;
                }
                info.canMoveBy = Math.min(info.canMoveBy, firstChildInfo.canMoveBy);
            }
            if (translate) {
                info.x -= info.canMoveBy;
                info.subTreeTranslation -= info.canMoveBy;
                if (hasChild) {
                    this.shiftSubordinates(layout, treeIntersect, info.canMoveBy);
                    treeBounds.x = Math.min(treeBounds.x, info.x);
                    treeBounds.right = Math.max(treeBounds.right, info.x + dim.width);
                    treeBounds.bottom = Math.max(treeBounds.bottom, info.y + dim.height);
                    treeBounds.x -= info.canMoveBy;
                    treeBounds.right -= info.canMoveBy;
                }
                if (firstChild && firstChildInfo.canMoveBy > info.canMoveBy) {
                    info.canMoveBy = firstChildInfo.canMoveBy - info.canMoveBy;
                }
                else if (firstChild && info.canMoveBy !== undefined) {
                    info.canMoveBy = 0;
                }
            }
        }
        else {
            if (hasChild) {
                treeBounds.x = Math.min(treeBounds.x, shapeBounds.x);
                treeBounds.right = Math.max(treeBounds.right, shapeBounds.x + dim.width);
                treeBounds.bottom = Math.max(treeBounds.bottom, info.y + dim.height);
            }
            if (!info.translate) {
                info.canMoveBy = 0;
                info.subTreeTranslation = 0;
            }
        }
        if (!dontupdate) {
            shapeBounds = { x: info.x, y: dim.y, right: info.x + dim.width, bottom: dim.y + dim.height };
            levelBounds.push({ rBounds: shapeBounds });
            this.updateRearBounds(layout, shape, levelBounds, level);
        }
    };
    HierarchicalTree.prototype.updateRearBounds = function (layout, shape, levelBounds, level, intersect) {
        var bnds;
        var index;
        var isLastLeaf = true;
        var i;
        var info = {};
        //let firstLevel: Bounds;
        //let lastLevel: Bounds;
        var bottom;
        if (shape) {
            info = layout.graphNodes[shape.id];
            intersect = info.intersect;
            isLastLeaf = !info.tree.children.length && !info.tree.assistants.length;
        }
        var firstLevel = levelBounds[0].rBounds;
        var lastLevel = levelBounds[levelBounds.length - 1].rBounds;
        if (intersect && intersect.length) {
            bnds = layout.levels[intersect[0]].rBounds;
            bottom = bnds.bottom;
            if (bnds.y < firstLevel.y) {
                bnds.bottom = firstLevel.y;
                levelBounds.splice(0, 0, { rBounds: bnds });
            }
            if (bottom > lastLevel.bottom) {
                levelBounds.push({ rBounds: { x: bnds.x, right: bnds.right, y: firstLevel.bottom, bottom: bottom } });
            }
            else {
                bnds = layout.levels[intersect[intersect.length - 1]].rBounds;
                if (isLastLeaf && bnds.bottom > lastLevel.bottom) {
                    bnds.y = lastLevel.bottom;
                    levelBounds.push({ rBounds: bnds });
                }
            }
            index = intersect[0];
            for (i = levelBounds.length - 1; i >= 0; i--) {
                layout.levels.splice(index, 0, levelBounds[parseInt(i.toString(), 10)]);
            }
            index += levelBounds.length;
            layout.levels.splice(index, intersect.length);
        }
        else {
            index = this.findLevel(layout, levelBounds[levelBounds.length - 1].rBounds, level);
            for (i = levelBounds.length - 1; i >= 0; i--) {
                layout.levels.splice(index, 0, levelBounds[parseInt(i.toString(), 10)]);
            }
        }
    };
    HierarchicalTree.prototype.shiftSubordinates = function (layout, intersect, diff) {
        var i;
        //Shift the sublevels by the distance diff
        if (diff !== 0) {
            for (i = 0; i < intersect.length; i++) {
                if (layout.levels[intersect[parseInt(i.toString(), 10)]].rBounds) {
                    layout.levels[intersect[parseInt(i.toString(), 10)]].rBounds.x -= diff;
                    layout.levels[intersect[parseInt(i.toString(), 10)]].rBounds.right -= diff;
                }
            }
        }
    };
    HierarchicalTree.prototype.setDepthSpaceForAssitants = function (layout, shape, bottom, height, lev, vSpace) {
        var info = layout.graphNodes[shape.id];
        var asst = {};
        var asstHeight;
        var i;
        var asstElement;
        var max;
        max = bottom;
        //Vertically place the assistants as alternate layout(alternatively at both right and left sides of parent)
        for (i = 0; i < info.tree.assistants.length; i++) {
            asst = layout.graphNodes[info.tree.assistants[parseInt(i.toString(), 10)]];
            if (asst) {
                asst.tree.children = asst.tree.assistants = [];
                asst.y = bottom;
                asstElement = layout.nameTable[info.tree.assistants[parseInt(i.toString(), 10)]];
                asstHeight = asstElement.actualSize.height;
                if (layout.orientation.indexOf('Left') !== -1) {
                    asstHeight = asstElement.actualSize.width;
                }
                max = bottom + asstHeight + vSpace / 2;
                layout.maxLevel = lev + 1;
                if (i % 2 === 1 && i !== info.tree.assistants.length - 1) {
                    bottom = max;
                    lev++;
                }
            }
        }
        return { level: layout.maxLevel, bottom: bottom + asstHeight + vSpace };
    };
    HierarchicalTree.prototype.setBreadthSpaceForAssistants = function (layout, shape, dim, space, bottom, level) {
        var asst = {};
        var asstWidth;
        //let prevBounds: number;
        var bounds;
        var asstElement;
        var i;
        var info = layout.graphNodes[shape.id];
        //let max: number = bottom;
        var lev = level;
        var left;
        var diff;
        var intersect;
        var levelBounds = { x: 0, y: 0, right: 0, bottom: 0 };
        for (i = 0; i < info.tree.assistants.length; i++) {
            asst = layout.graphNodes[info.tree.assistants[parseInt(i.toString(), 10)]];
            //Arrange assistants at both left and right sides of parent(like alternate layout)
            //Check - By default, distance to be left between parent and child nodes is assumed as 20.
            //It can be modified/customized later.
            if (asst) {
                asstElement = layout.nameTable[info.tree.assistants[parseInt(i.toString(), 10)]];
                asstWidth = asstElement.actualSize.width;
                if (layout.orientation.indexOf('Left') !== -1) {
                    asstWidth = asstElement.actualSize.height;
                }
                if (i % 2 === 0) {
                    left = space + dim.width / 2 - 20 - asstWidth;
                }
                else {
                    left = space + dim.width / 2 + 20;
                }
                //Check - What will happen if update leaf node is called? Since assistants don't have children
                bounds = this.updateTree(layout, left, asst.y, layout.nameTable[info.tree.assistants[parseInt(i.toString(), 10)]], lev + 1);
                if (!this.hasChild(layout, shape)) {
                    if (i === 0) {
                        levelBounds = bounds;
                    }
                    else {
                        this.uniteRects(levelBounds, bounds);
                    }
                }
                if (i % 2 === 0 && asst.prevBounds) {
                    if (diff === undefined) {
                        diff = asst.canMoveBy;
                    }
                    else {
                        diff = Math.min(diff, asst.canMoveBy);
                    }
                }
                if (i % 2 === 1 || i === info.tree.assistants.length - 1) {
                    intersect = this.findIntersectingLevels(layout, bounds, lev + 1);
                    //Update rightmost positions of known layout levels
                    this.updateRearBounds(layout, null, [{ rBounds: bounds }], lev + 1, intersect);
                    lev++;
                }
            }
        }
        if (levelBounds) {
            levelBounds.canMoveBy = diff;
        }
        return levelBounds;
    };
    HierarchicalTree.prototype.getDimensions = function (layout, shape, x, y, level) {
        var width;
        width = shape.actualSize.width;
        var height;
        height = shape.actualSize.height;
        layout.orientation = layout.orientation || 'TopToBottom';
        if (layout.orientation.indexOf('Left') !== -1) {
            if (!level) {
                //let temp: number;
                var temp = x;
                x = y;
                y = temp;
            }
            height = shape.actualSize.width;
            width = shape.actualSize.height;
        }
        return { x: x, y: y, width: width, height: height };
    };
    HierarchicalTree.prototype.hasChild = function (layout, shape) {
        //Check whether the node has children
        var shape1 = layout.graphNodes[shape.id];
        return shape1 ? shape1.tree.children && shape1.tree.children.length : 0;
    };
    HierarchicalTree.prototype.updateHorizontalTree = function (layout, shape, prev, x, y, level) {
        //Get dimensions with respect to layout orientations
        //let dimensions: Dimensions;
        var dimensions = this.getDimensions(layout, shape, x, y, level);
        var info = {};
        info = layout.graphNodes[shape.id];
        var side = info.tree.type;
        //let lev: number;
        var lev = level;
        var right = 0;
        right = x;
        var bottom = y;
        var width;
        var height;
        var child;
        var childBounds;
        var childWidth;
        var childHeight;
        //let prevBounds: Bounds;
        var bounds;
        var actBounds;
        var maxLevel;
        var translateSibilingsBy;
        var canMoveBy;
        var oldActBounds;
        var i;
        var childInfo;
        var firstChildInfo;
        var prevLayoutLevels = layout.levels.slice(0, layout.levels.length);
        if (this.hasChild(layout, shape)) {
            //let h: boolean;
            var h = layout.orientation.indexOf('Left') !== -1 ? true : false;
            for (i = 0; i < info.tree.children.length; i++) {
                child = layout.nameTable[info.tree.children[parseInt(i.toString(), 10)]];
                width = child.actualSize.width;
                height = child.actualSize.height;
                childWidth = h ? height : width;
                childHeight = h ? width : height;
                var prevBounds = layout.levels[lev + 1] ? layout.levels[lev + 1].rBounds : null;
                //Update sub tree
                childBounds = this.updateTree(layout, right, bottom, child, lev + 1, layout.nameTable[info.tree.children[i - 1]]);
                childInfo = layout.graphNodes[child.id];
                info.maxLevel = Math.max(info.maxLevel || 0, childInfo.maxLevel || 0);
                actBounds = { x: childInfo.x, y: childInfo.y, right: childInfo.x + childWidth, bottom: childInfo.y + childHeight };
                if (i === 0) {
                    //Compare with previous(right most) subtree
                    bounds = {
                        x: Math.min(childInfo.x, childBounds.x), y: Math.min(childInfo.y, childBounds.y),
                        right: childBounds.right, bottom: childBounds.bottom
                    };
                    firstChildInfo = childInfo;
                }
                if (!oldActBounds) {
                    oldActBounds = actBounds;
                }
                else {
                    oldActBounds.x = actBounds.x;
                    oldActBounds.y = actBounds.y;
                    if (actBounds.right > oldActBounds.right) {
                        oldActBounds.right = actBounds.right;
                    }
                    oldActBounds.bottom = actBounds.bottom;
                    //oldActBounds = actBounds;
                }
                //Compare with previous subtree if level of the child is greater than the level of previous sub tree
                //Check - what will happen if level of second child is greater than current child
                if (i === 0) {
                    info.firstChild = { x: childInfo.x, canMoveBy: childInfo.canMoveBy, child: child.id };
                }
                if (this.hasChild(layout, child)) {
                    if (!info.firstChild || info.firstChild.x >= childInfo.firstChild.x) {
                        if (childInfo.firstChild && info.firstChild.canMoveBy < childInfo.canMoveBy) {
                            canMoveBy = info.firstChild.canMoveBy;
                            childInfo.canMoveBy = canMoveBy;
                            layout.graphNodes[info.firstChild.child].canMoveBy = canMoveBy;
                            info.firstChild.canMoveBy = canMoveBy;
                        }
                        var canMoveValue = canMoveBy !== undefined ? canMoveBy : childInfo.canMoveBy;
                        info.firstChild = { x: childInfo.firstChild.x, canMoveBy: canMoveValue, child: child.id };
                    }
                    else if (childInfo.firstChild && childInfo.translated && info.firstChild.canMoveBy > childInfo.canMoveBy) {
                        info.firstChild.canMoveBy = layout.graphNodes[info.firstChild.child].canMoveBy = childInfo.canMoveBy;
                    }
                }
                maxLevel = maxLevel ? Math.max(childInfo.maxLevel, maxLevel) : childInfo.maxLevel;
                this.uniteRects(bounds, childBounds);
                if (i !== 0 && !this.hasChild(layout, child) && childInfo.subTreeTranslation < 0) {
                    right = childBounds.right - childInfo.subTreeTranslation + layout.horizontalSpacing;
                }
                else {
                    right = childBounds.right + layout.horizontalSpacing;
                }
            }
            if (!isNaN(translateSibilingsBy)) {
                firstChildInfo.canMoveBy = translateSibilingsBy;
            }
            info.mid = (firstChildInfo.x + oldActBounds.right) / 2 - dimensions.width / 2;
            //Set parent based on the chart type
            if (side === 'Left') {
                info.mid = actBounds.right - dimensions.width;
            }
            else if (side === 'Right') {
                info.mid = x;
            }
        }
        return bounds;
    };
    /* eslint-disable */
    HierarchicalTree.prototype.updateHorizontalTreeWithMultipleRows = function (layout, shape, prev, x, y, level) {
        //declarations
        var child;
        var childInfo;
        var childBounds;
        var childWidth;
        var bounds;
        var width;
        var height;
        var j;
        var i;
        var leftCenter;
        var rightCenter;
        //Get dimensions with respect to layout orientations
        var dimensions = this.getDimensions(layout, shape, x, y, level);
        var info = layout.graphNodes[shape.id];
        var side = info.tree.type;
        var lev = level;
        var right = x;
        var bottom = y;
        var prevLayoutLevels = layout.levels.slice(0, layout.levels.length);
        var minTranslation = 0;
        if (this.hasChild(layout, shape)) {
            var h = layout.orientation.indexOf('Left') !== -1 ? true : false;
            var align = void 0;
            var rows = this.splitChildrenInRows(layout, shape);
            var unique = info.tree.children.length === 5 && rows[0].length === 3;
            var leftTree = [];
            var rightTree = [];
            if (!unique) {
                this.splitRows(rows, leftTree, rightTree);
            }
            else {
                rightTree = rows;
            }
            var treeInfo = { leftTree: leftTree, rows: rows, rightTree: rightTree, dimensions: dimensions };
            var rightMost = this.updateLeftTree(layout, treeInfo, shape, x, bottom, lev);
            bounds = treeInfo.bounds;
            var rightX = void 0;
            var center = (rightMost || 0) + (rightMost !== undefined ? (layout.horizontalSpacing / 2) : 0);
            if (rightMost !== undefined) {
                info.mid = center - dimensions.width / 2;
                rightX = rightMost + layout.horizontalSpacing;
            }
            bottom = y;
            var rightBounds = void 0;
            rightBounds = [];
            for (i = 0; i < rightTree.length; i++) {
                if (rows[i].length % 2 === 1 && i === rightTree.length - 1 || unique) {
                    right = x;
                }
                else {
                    right = rightX || x;
                }
                if (i !== 0) {
                    bottom = rightBounds[i - 1].bottom + layout.verticalSpacing;
                }
                for (j = 0; j < rightTree[i].length; j++) {
                    child = layout.nameTable[rightTree[i][j]];
                    width = child.actualSize.width;
                    height = child.actualSize.height;
                    childWidth = h ? height : width;
                    //Update sub tree
                    childInfo = layout.graphNodes[child.id];
                    childInfo.actualLevel = lev + 1 + i;
                    if (j === 0 && leftTree[i] && leftTree[i].length) {
                        childInfo.translate = false;
                    }
                    if (unique && i === 1) {
                        if (j === 0 && leftCenter + childWidth + layout.horizontalSpacing <= rightCenter) {
                            align = true;
                            right = leftCenter - childWidth / 2;
                        }
                        if (align && j === 1) {
                            right = rightCenter - childWidth / 2;
                        }
                    }
                    childBounds = this.updateTree(layout, right, bottom, child, lev + 1, layout.nameTable[rightTree[i][j - 1]]);
                    if (unique && j <= 2 && i === 0) {
                        if (j === 1) {
                            leftCenter = childBounds.x - layout.horizontalSpacing / 2;
                            rightCenter = childBounds.x + childWidth + layout.horizontalSpacing / 2;
                        }
                    }
                    if (j === 0) {
                        rightBounds[i] = { x: childBounds.x, y: childBounds.y, right: childBounds.right, bottom: childBounds.bottom };
                    }
                    else {
                        this.uniteRects(rightBounds[i], childBounds);
                    }
                    if (!bounds) {
                        bounds = {
                            x: rightBounds[i].x, y: rightBounds[i].y, right: rightBounds[i].right,
                            bottom: rightBounds[i].bottom
                        };
                    }
                    this.uniteRects(bounds, rightBounds[i]);
                    right = childBounds.right + layout.horizontalSpacing;
                    if (!info.firstChild || ((i === rightTree.length - 1 && rows[i].length % 2 === 1) || unique)
                        && j === 0 && childInfo.canMoveBy !== undefined && minTranslation > childInfo.canMoveBy) {
                        minTranslation = Math.min(minTranslation, childInfo.canMoveBy || 0);
                        info.firstChild = { x: childInfo.x, child: child.id, canMoveBy: childInfo.canMoveBy };
                    }
                    treeInfo.leftCenter = leftCenter;
                    treeInfo.rightCenter = rightCenter;
                    treeInfo.align = align;
                    treeInfo.level = lev;
                    treeInfo.rightBounds = rightBounds;
                    this.alignRowsToCenter(layout, i, shape, treeInfo, rightX);
                }
            }
        }
        return bounds;
    };
    /* eslint-enable */
    HierarchicalTree.prototype.updateLeftTree = function (layout, treeInfo, shape, x, bottom, lev) {
        var leftTree = treeInfo.leftTree;
        var info = layout.graphNodes[shape.id];
        var right;
        var leftBounds = [];
        var minTranslation;
        var rightMost;
        var childBounds;
        var bounds;
        var h = layout.orientation.indexOf('Left') !== -1 ? true : false;
        //Arrange left side
        for (var i = 0; i < leftTree.length && leftTree[parseInt(i.toString(), 10)].length; i++) {
            right = x;
            if (leftBounds[i - 1]) {
                bottom = leftBounds[i - 1].bottom + layout.verticalSpacing;
            }
            for (var j = 0; j < leftTree[parseInt(i.toString(), 10)].length; j++) {
                var child = layout.nameTable[leftTree[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)]];
                var childWidth = h ? child.actualSize.height : child.actualSize.width;
                var childHeight = h ? child.actualSize.width : child.actualSize.height;
                //Update sub tree
                var childInfo = layout.graphNodes[child.id];
                childInfo.actualLevel = lev + 1 + i;
                childBounds = this.updateTree(layout, right, bottom, child, lev + 1, layout.nameTable[leftTree[parseInt(i.toString(), 10)][j - 1]]);
                if (j === 0) {
                    leftBounds[parseInt(i.toString(), 10)] = {
                        x: childBounds.x, y: childBounds.y, right: childBounds.right, bottom: childBounds.bottom
                    };
                }
                else {
                    this.uniteRects(leftBounds[parseInt(i.toString(), 10)], childBounds);
                }
                if (i === 0 && j === 0) {
                    minTranslation = childInfo.canMoveBy;
                    info.firstChild = { x: childInfo.x, child: child.id, canMoveBy: childInfo.canMoveBy };
                }
                else if (j === 0 && childInfo.canMoveBy !== undefined && minTranslation > childInfo.canMoveBy) {
                    minTranslation = Math.min(minTranslation, childInfo.canMoveBy || 0);
                    info.firstChild = { x: childInfo.x, child: child.id, canMoveBy: childInfo.canMoveBy };
                }
                right = childBounds.right + layout.horizontalSpacing;
            }
            if (i === 0) {
                rightMost = leftBounds[parseInt(i.toString(), 10)].right;
            }
            else {
                rightMost = Math.max(rightMost, leftBounds[parseInt(i.toString(), 10)].right);
            }
        }
        //Translate to same positions
        for (var i = 0; i < leftTree.length && leftTree[parseInt(i.toString(), 10)].length; i++) {
            if (rightMost !== leftBounds[parseInt(i.toString(), 10)].right) {
                var diff = rightMost - leftBounds[parseInt(i.toString(), 10)].right;
                for (var j = 0; j < leftTree[parseInt(i.toString(), 10)].length; j++) {
                    var element = layout.nameTable[leftTree[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)]];
                    var elementInfo = layout.graphNodes[leftTree[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)]];
                    elementInfo.x += diff;
                }
                //leftBounds[i].x += diff;
                //leftBounds[i].right += diff;
            }
            if (i === 0) {
                bounds = { x: leftBounds[0].x, y: leftBounds[0].y, right: leftBounds[0].right, bottom: leftBounds[0].bottom };
            }
            else {
                this.uniteRects(bounds, leftBounds[parseInt(i.toString(), 10)]);
            }
        }
        treeInfo.bounds = bounds;
        return rightMost;
    };
    HierarchicalTree.prototype.alignRowsToCenter = function (layout, i, shape, treeInfo, rightX) {
        var max;
        var centered;
        var diff;
        var info = layout.graphNodes[shape.id];
        var rows = treeInfo.rows;
        var rightTree = treeInfo.rightTree;
        var leftCenter = treeInfo.leftCenter;
        var rightCenter = treeInfo.rightCenter;
        var align = treeInfo.align;
        var rightBounds = treeInfo.rightBounds;
        var dimensions = treeInfo.dimensions;
        var lev = treeInfo.level;
        var unique = info.tree.children.length === 5 && rows[0].length === 3;
        if (unique && i === 1) {
            max = (rightBounds[0].right - rightBounds[0].x) >= (rightBounds[1].right - rightBounds[1].x) ? 0 : 1;
        }
        if (i === rows.length - 1) {
            if (rows[parseInt(i.toString(), 10)].length % 2 === 1 || unique && i === 1) {
                centered = rightTree[parseInt(i.toString(), 10)][Math.floor(rightTree[parseInt(i.toString(), 10)].length / 2)];
                //let centerObjct: INode;
                var centerObjct = layout.nameTable["" + centered];
                //let childDimension: Dimensions;
                var centeredX = layout.graphNodes["" + centered].x;
                var centeredY = layout.graphNodes["" + centered].y;
                var childDimension = this.getDimensions(layout, centerObjct, centeredX, centeredY, lev + 1);
                diff = undefined;
                if (!align && unique) {
                    if (max === 1) {
                        i = 0;
                    }
                    diff = (rightBounds[parseInt(max.toString(), 10)].x + rightBounds[parseInt(max.toString(), 10)].right) / 2
                        - (rightBounds[parseInt(i.toString(), 10)].x
                            + rightBounds[parseInt(i.toString(), 10)].right) / 2;
                    if (i === 0) {
                        info.mid += diff;
                    }
                }
                else if (!unique && rightX !== undefined) {
                    diff = rightX - layout.horizontalSpacing / 2 - (centeredX + childDimension.width / 2);
                }
                if (diff !== undefined) {
                    this.updateRearBoundsOfTree(layout, rightTree[parseInt(i.toString(), 10)], diff, dimensions);
                }
                if (unique) {
                    info.mid = (rightCenter + leftCenter) / 2 + (i === 0 ? diff : 0) - dimensions.width / 2;
                }
                if (info.mid === undefined && layout.graphNodes["" + centered]) {
                    info.mid = centeredX;
                }
                align = false;
                i++;
            }
        }
    };
    HierarchicalTree.prototype.updateRearBoundsOfTree = function (layout, rightTree, diff, dimensions) {
        for (var j = 0; j < rightTree.length; j++) {
            var childInfo = layout.graphNodes[rightTree[parseInt(j.toString(), 10)]];
            //let child: INode = layout.nameTable[rightTree[j]];
            childInfo.x += diff;
            childInfo.canMoveBy += diff;
            if (j === rightTree.length - 1) {
                //removed child dimensions call calculation, since that is not used
                var childBnds = {
                    x: childInfo.x, y: childInfo.y, right: childInfo.x +
                        dimensions.width, bottom: childInfo.y + dimensions.height
                };
                var intersect = this.findIntersectingLevels(layout, childBnds, childInfo.actualLevel);
                this.updateRearBounds(layout, null, [{ rBounds: childBnds }], childInfo.actualLevel, intersect);
            }
        }
    };
    HierarchicalTree.prototype.splitRows = function (rows, leftTree, rightTree) {
        for (var i = 0; i < rows.length; i++) {
            leftTree[parseInt(i.toString(), 10)] = [];
            rightTree[parseInt(i.toString(), 10)] = [];
            var half = void 0;
            half = rows[parseInt(i.toString(), 10)].length;
            if (rows[parseInt(i.toString(), 10)].length % 2 !== 1) {
                half = Math.ceil(rows[parseInt(i.toString(), 10)].length / 2);
                for (var k = 0; k < half; k++) {
                    leftTree[parseInt(i.toString(), 10)].push(rows[parseInt(i.toString(), 10)][parseInt(k.toString(), 10)]);
                }
            }
            for (var j = leftTree[parseInt(i.toString(), 10)].length; j < rows[parseInt(i.toString(), 10)].length; j++) {
                rightTree[parseInt(i.toString(), 10)].push(rows[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)]);
            }
        }
    };
    HierarchicalTree.prototype.updateVerticalTree = function (layout, shape, x, y, level, dontUpdate) {
        //declarations
        var child;
        var childInfo;
        var childBounds;
        var childWidth;
        var childHeight;
        var prevBounds;
        var bounds;
        var actBounds;
        var oddBounds;
        var evenBounds;
        //let dimensions: Dimensions = this.getDimensions(layout, shape, x, y, level);
        var info = layout.graphNodes[shape.id];
        var firstChild = layout.nameTable[info.tree.children[0]];
        var h = layout.orientation.indexOf('Left') !== -1 ? true : false;
        var factor = info.tree.type === 'Left' ? -1 : 0;
        var right = x;
        var bottom = y;
        var lev = level;
        var i;
        var intersect;
        var type;
        var levels = [];
        var oddLevels = [];
        var canMoveBy; //let diff: number;
        for (i = 0; i < info.tree.children.length; i++) {
            if (info.tree.type === 'Alternate') {
                //arrange at both left and right
                type = (i % 2 === 0 && info.tree.children.length > 2) ? 'Left' : 'Right';
                factor = (i % 2 === 0 && info.tree.children.length > 2) ? -1 : 0;
            }
            right = x + this.findOffset(layout, shape, info, type);
            child = layout.nameTable[info.tree.children[parseInt(i.toString(), 10)]];
            childWidth = h ? child.actualSize.height : child.actualSize.width;
            childHeight = h ? child.actualSize.width : child.actualSize.height;
            //Update sub tree
            childBounds = this.updateTree(layout, right + factor * childWidth, bottom, child, level + 1, undefined, true);
            childInfo = layout.graphNodes[child.id];
            actBounds = { x: childInfo.x, y: childInfo.y, right: childInfo.x + childWidth, bottom: childInfo.y + childHeight };
            if (i === 0) {
                this.uniteRects(childBounds, actBounds);
                bounds = childBounds;
            }
            else {
                this.uniteRects(bounds, childBounds);
            }
            //Check and adjust the space left from previous subtree/sibling
            if (childInfo.prevBounds && !(info.tree.type === 'Alternate' && i % 2 === 1 && info.tree.children.length > 2)) {
                canMoveBy = canMoveBy !== undefined ? Math.min(childInfo.canMoveBy, canMoveBy) : childInfo.canMoveBy;
            }
            //Max level of the subtree node
            info.maxLevel = Math.max(info.maxLevel || 0, childInfo.maxLevel || 0);
            if (!(info.tree.type === 'Alternate' && info.tree.children.length > 2 && i % 2 === 0)) {
                if (info.tree.type === 'Alternate' && info.tree.children.length > 2) {
                    //alternate - arrange children with even index(0,2,4,6,..) at the next level
                    bottom = Math.max(childBounds.bottom, prevBounds.bottom) + layout.verticalSpacing / 2;
                }
                else {
                    // left/right - arrange next child at the nect level(bottom)
                    bottom = childBounds.bottom + layout.verticalSpacing / 2;
                }
                level = info.maxLevel;
                levels.push({ rBounds: actBounds });
                if (!evenBounds) {
                    evenBounds = {
                        x: childInfo.x, y: childInfo.y, right: childInfo.x + childWidth,
                        bottom: childInfo.y + childHeight
                    };
                }
                else {
                    this.uniteRects(evenBounds, actBounds);
                }
                if (childInfo.levelBounds) {
                    levels = levels.concat(childInfo.levelBounds);
                }
            }
            else {
                if (i !== 0) {
                    bottom = prevBounds.bottom + layout.verticalSpacing / 2;
                }
                oddLevels.push({ rBounds: actBounds });
                if (childInfo.levelBounds) {
                    oddLevels = oddLevels.concat(childInfo.levelBounds);
                }
            }
            if (i === 0) {
                info.firstChild = { x: childInfo.x, canMoveBy: childInfo.canMoveBy, child: child.id };
            }
            if (this.hasChild(layout, child)) {
                if (!info.firstChild || info.firstChild.x >= childInfo.firstChild.x) {
                    if (childInfo.firstChild && info.firstChild.canMoveBy < childInfo.canMoveBy) {
                        var canMoveBy_1 = info.firstChild.canMoveBy;
                        childInfo.canMoveBy = canMoveBy_1;
                        layout.graphNodes[info.firstChild.child].canMoveBy = canMoveBy_1;
                        info.firstChild.canMoveBy = canMoveBy_1;
                    }
                    info.firstChild = {
                        x: childInfo.firstChild.x, canMoveBy: canMoveBy !== undefined ? canMoveBy : childInfo.canMoveBy,
                        child: child.id
                    };
                }
                else if (childInfo.firstChild && childInfo.translated && info.firstChild.canMoveBy > childInfo.canMoveBy) {
                    info.firstChild.canMoveBy = layout.graphNodes[info.firstChild.child].canMoveBy = childInfo.canMoveBy;
                }
            }
            prevBounds = actBounds;
        }
        //To set level bounds(right most position of levels)
        if (!dontUpdate) {
            if (info.tree.type === 'Alternate' && info.tree.children.length > 2) {
                oddBounds = {
                    x: oddLevels[0].rBounds.x, y: oddLevels[0].rBounds.y,
                    right: oddLevels[oddLevels.length - 1].rBounds.right, bottom: oddLevels[oddLevels.length - 1].rBounds.bottom
                };
                intersect = this.findIntersectingLevels(layout, oddBounds, lev + 1);
                this.updateRearBounds(layout, null, oddLevels, lev + 1, intersect);
            }
            intersect = this.findIntersectingLevels(layout, evenBounds || bounds, lev + 1);
            this.updateRearBounds(layout, null, evenBounds ? levels : [{ rBounds: bounds }], lev + 1, intersect);
        }
        else {
            info.levelBounds = levels;
        }
        if (!isNaN(canMoveBy)) {
            layout.graphNodes[firstChild.id].canMoveBy = canMoveBy;
        }
        info.childBounds = bounds;
        info.mid = x;
        return bounds;
    };
    HierarchicalTree.prototype.splitChildrenInRows = function (layout, shape) {
        //let info: LayoutInfo;
        var info = layout.graphNodes[shape.id];
        var column;
        column = 4;
        var rows = [];
        var childNodes;
        childNodes = info.tree.children.length;
        var children = this.extend(info.tree.children);
        if (info.tree.rows) {
            //let count: number;
            var count = info.tree.children.length;
            //let columns: number;
            var columns = info.tree.rows;
            if (columns % 2 === 0) {
                column = columns;
            }
            else {
                column = columns - 1;
            }
        }
        else if (info.tree.children.length === 3 || info.tree.children.length === 4) {
            column = 2;
        }
        else if (info.tree.children.length === 5) {
            column = 3;
        }
        while (childNodes > 0) {
            rows[rows.length] = children.splice(0, column);
            childNodes -= column;
            if (childNodes < column) {
                if (childNodes % 2 === 0) {
                    column = childNodes;
                }
                else if (childNodes !== 1) {
                    column = childNodes - 1;
                }
                if (childNodes < column) {
                    column = childNodes;
                }
            }
        }
        return rows;
    };
    HierarchicalTree.prototype.extend = function (temp) {
        var i;
        var dummy = [];
        for (i = 0; i < temp.length; i++) {
            dummy[parseInt(i.toString(), 10)] = temp[parseInt(i.toString(), 10)];
        }
        return dummy;
    };
    HierarchicalTree.prototype.findOffset = function (layout, shape, info, type) {
        var offset = 0;
        var space = (layout.orientation.indexOf('Left') !== -1) ? shape.actualSize.height :
            shape.actualSize.width;
        var treeType = type ? type : info.tree.type;
        offset = info.tree.offset || 20;
        if (info.tree.type === 'Alternate') {
            if (offset >= layout.horizontalSpacing) {
                offset = layout.horizontalSpacing / 2;
            }
        }
        switch (treeType) {
            case 'Left':
                offset = space / 2 - offset;
                break;
            case 'Right':
                offset = offset + space / 2;
                break;
        }
        return offset;
    };
    HierarchicalTree.prototype.uniteRects = function (rect1, rect2) {
        //Unite two rects
        rect1.x = Math.min(rect1.x, rect2.x);
        rect1.right = Math.max(rect1.right, rect2.right);
        rect1.bottom = Math.max(rect1.bottom, rect2.bottom);
    };
    HierarchicalTree.prototype.spaceLeftFromPrevSubTree = function (layout, shape, bounds) {
        //let info: LayoutInfo;
        var info = layout.graphNodes[shape.id];
        var dif;
        var prevBounds; //let intersect: number[]; let k: number;
        //let space: number;
        var space = layout.horizontalSpacing;
        //Find the minimum distance to move towards previous sub tree
        for (var k = 0; k < info.intersect.length; k++) {
            prevBounds = layout.levels[info.intersect[parseInt(k.toString(), 10)]].rBounds;
            dif = bounds.x - (prevBounds.right + space);
            if (info.diff === undefined || dif < info.diff) {
                info.diff = dif;
                info.prevBounds = layout.levels[info.intersect[parseInt(k.toString(), 10)]].rBounds;
            }
        }
    };
    HierarchicalTree.prototype.findIntersectingLevels = function (layout, bounds, level, actualLevel) {
        //intersecting with exact Level
        //let bnds: Bounds;
        var bnds = { x: bounds.x, y: bounds.y, right: bounds.right, bottom: bounds.bottom };
        bnds.y -= layout.verticalSpacing / 2;
        bnds.bottom += layout.verticalSpacing / 2;
        //let intersectingLevels: number[];
        var intersectingLevels = [];
        var rBounds;
        var l;
        l = actualLevel !== undefined ? actualLevel : level;
        rBounds = layout.levels[parseInt(l.toString(), 10)] ? layout.levels[parseInt(l.toString(), 10)].rBounds : null;
        //Performance - We can consider only the intersecting levels
        do {
            if (rBounds && ((bnds.y < rBounds.y && bnds.bottom > rBounds.y)
                || (bnds.y < rBounds.bottom && rBounds.bottom < bnds.bottom) ||
                bnds.y >= rBounds.y &&
                    bnds.bottom <= rBounds.bottom || bnds.y < rBounds.y && bnds.bottom > rBounds.bottom)) {
                var index = 0;
                intersectingLevels.splice(index, 0, l);
            }
            else if (rBounds && rBounds.bottom < bnds.y) {
                break;
            }
            l--;
            rBounds = layout.levels[parseInt(l.toString(), 10)] ? layout.levels[parseInt(l.toString(), 10)].rBounds : null;
        } while (l >= 0);
        l = (actualLevel !== undefined ? actualLevel : level) + 1;
        rBounds = layout.levels[parseInt(l.toString(), 10)] ? layout.levels[parseInt(l.toString(), 10)].rBounds : null;
        do {
            if (rBounds && ((bnds.y < rBounds.y && bnds.bottom > rBounds.y) ||
                (bnds.y < rBounds.bottom && rBounds.bottom < bnds.bottom) ||
                bnds.y >= rBounds.y && bnds.bottom <= rBounds.bottom || bnds.y < rBounds.y && bnds.bottom > rBounds.bottom)) {
                intersectingLevels.push(l);
            }
            else if (rBounds && rBounds.y > bnds.bottom) {
                break;
            }
            l++;
            rBounds = layout.levels[parseInt(l.toString(), 10)] ? layout.levels[parseInt(l.toString(), 10)].rBounds : null;
        } while (l <= layout.levels.length);
        return intersectingLevels;
    };
    HierarchicalTree.prototype.findLevel = function (layout, bounds, level) {
        //let bnds: Bounds;
        var bnds = bounds;
        var l;
        l = 0;
        var rBounds;
        rBounds = layout.levels[parseInt(l.toString(), 10)] ? layout.levels[parseInt(l.toString(), 10)].rBounds : null;
        while (l < layout.levels.length) {
            if (rBounds && bnds.bottom < rBounds.y) {
                return l;
            }
            else {
                l++;
            }
            rBounds = layout.levels[parseInt(l.toString(), 10)] ? layout.levels[parseInt(l.toString(), 10)].rBounds : null;
        }
        return l;
    };
    HierarchicalTree.prototype.getParentNode = function (layout, node) {
        //Return the first parent node
        return layout.nameTable[layout.nameTable[node.inEdges[0]].sourceID];
    };
    HierarchicalTree.prototype.updateEdges = function (layout, node, depth, action, nodes) {
        //let layoutInfo: LayoutInfo;
        var layoutInfo = layout.graphNodes[node.id];
        var j;
        if (node.outEdges && node.outEdges.length && (node.isExpanded || (action === DiagramAction.Render))) {
            for (j = 0; j < node.outEdges.length; j++) {
                //let edge: INode;
                var edge = layout.nameTable[layout.nameTable[node.outEdges[parseInt(j.toString(), 10)]].targetID];
                if (edge && !edge.excludeFromLayout) {
                    if (layoutInfo.tree.children.indexOf(edge.id) === -1) {
                        layoutInfo.tree.children.push(edge.id);
                    }
                    if (edge.outEdges && edge.outEdges.length && edge.isExpanded) {
                        layoutInfo.tree.hasSubTree = true;
                    }
                    this.updateEdges(layout, edge, depth + 1, action, nodes);
                }
            }
        }
        //set level info
        layoutInfo.tree.level = depth;
        //By default, orientation is horizontal for nested trees
        if (layoutInfo.tree.hasSubTree) {
            layoutInfo.tree.orientation = 'Horizontal';
            layoutInfo.tree.type = 'Center';
        }
        //Customizing assistants and children collection
        //Performance-Instead of reading the method everytime, we can set once and can reuse that
        if ((layout.getLayoutInfo || layout.layoutInfo) && layout.type === 'OrganizationalChart') {
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            layout.getLayoutInfo ?
                layout.getLayoutInfo(node, layoutInfo.tree) : updateLayoutValue(layoutInfo.tree, layout.layoutInfo, nodes, node);
            if (layoutInfo.tree.type === 'Balanced' && layoutInfo.tree.hasSubTree) {
                layoutInfo.tree.type = 'Center';
                layoutInfo.tree.orientation = 'Horizontal';
            }
        }
        if (layout.level && layoutInfo.tree.type !== 'Alternate' && depth >= layout.level) {
            layoutInfo.tree.hasSubTree = false;
        }
    };
    /* eslint-disable */
    HierarchicalTree.prototype.updateAnchor = function (layout, bounds, viewPort) {
        var node;
        var fixedNode;
        var width = 0;
        var height = 0;
        var mod = 0;
        var yValue = 0;
        var viewPortBounds = new Rect(0, 0, viewPort.x, viewPort.y); //let layoutBounds: Rect;
        var layoutBounds = layout.bounds ? layout.bounds : viewPortBounds;
        var orientation = layout.orientation;
        //Anchor based on fixed nodes
        if (layout.fixedNode) {
            fixedNode = layout.nameTable[layout.fixedNode];
            width = fixedNode.actualSize.width;
            height = fixedNode.actualSize.height;
            layout.anchorX = fixedNode.offsetX;
            layout.anchorY = fixedNode.offsetY;
            var pivot = fixedNode.pivot;
            layout.anchorX += layout.orientation === 'RightToLeft' ? width * pivot.x : -width * pivot.x;
            layout.anchorY += layout.orientation === 'BottomToTop' ? height * pivot.y : -height * pivot.y;
            node = fixedNode;
            mod = 0;
            while (node.inEdges.length) {
                node = this.getParentNode(layout, node);
                mod += layout.graphNodes[node.id].subTreeTranslation || 0;
            }
            if (layout.orientation.indexOf('Left') !== -1) {
                yValue = layout.graphNodes[fixedNode.id].y;
                // eslint-disable-next-line
                orientation === 'LeftToRight' ? layout.anchorX -= yValue : layout.anchorX += yValue;
                layout.anchorY -= layout.graphNodes[fixedNode.id].x + mod;
            }
            else {
                yValue = layout.graphNodes[fixedNode.id].y;
                // eslint-disable-next-line
                layout.anchorX -= layout.graphNodes[fixedNode.id].x + mod;
                orientation === 'TopToBottom' ? layout.anchorY -= yValue : layout.anchorY += yValue;
            }
        }
        else {
            if (orientation === 'TopToBottom' || orientation === 'BottomToTop') {
                switch (layout.horizontalAlignment) {
                    case 'Left':
                        layout.anchorX = (layoutBounds.x - bounds.x) + layout.margin.left;
                        break;
                    case 'Right':
                        layout.anchorX = layoutBounds.x + layoutBounds.width - layout.margin.right - bounds.right;
                        break;
                    case 'Auto':
                    case 'Center':
                        layout.anchorX = layoutBounds.x + layoutBounds.width / 2 - (bounds.x + bounds.right) / 2;
                        break;
                }
                switch (layout.verticalAlignment) {
                    case 'Auto':
                    case 'Top':
                        var top_1;
                        top_1 = layoutBounds.y + layout.margin.top;
                        layout.anchorY = orientation === 'TopToBottom' ? top_1 : bounds.bottom + top_1;
                        break;
                    case 'Bottom':
                        var bottom = void 0;
                        bottom = layoutBounds.y + layoutBounds.height - layout.margin.bottom;
                        layout.anchorY = orientation === 'TopToBottom' ? bottom - bounds.bottom : bottom;
                        break;
                    case 'Center':
                        var center = void 0;
                        center = layoutBounds.y + layoutBounds.height / 2;
                        layout.anchorY = layout.orientation === 'TopToBottom' ?
                            center - (bounds.y + bounds.bottom) / 2 : center + (bounds.y + bounds.bottom) / 2;
                        break;
                }
            }
            else {
                switch (layout.horizontalAlignment) {
                    case 'Auto':
                    case 'Left':
                        var left = void 0;
                        left = layoutBounds.x + layout.margin.left;
                        layout.anchorX = orientation === 'LeftToRight' ? left : bounds.bottom + left;
                        break;
                    case 'Right':
                        var right = void 0;
                        right = layoutBounds.x + layoutBounds.width - layout.margin.right;
                        layout.anchorX = orientation === 'LeftToRight' ? right - bounds.bottom : right;
                        break;
                    case 'Center':
                        var center = void 0;
                        center = layoutBounds.width / 2 + layoutBounds.x;
                        layout.anchorX = layout.orientation === 'LeftToRight' ?
                            center - (bounds.y + bounds.bottom) / 2 : center + (bounds.y + bounds.bottom) / 2;
                        break;
                }
                switch (layout.verticalAlignment) {
                    case 'Top':
                        layout.anchorY = layoutBounds.y + layout.margin.top - bounds.x;
                        break;
                    case 'Auto':
                    case 'Center':
                        layout.anchorY = layoutBounds.y + layoutBounds.height / 2 - (bounds.right + bounds.x) / 2;
                        break;
                    case 'Bottom':
                        layout.anchorY = layoutBounds.y + layoutBounds.height - layout.margin.bottom - bounds.right;
                        break;
                }
            }
        }
    };
    /* eslint-enable */
    HierarchicalTree.prototype.updateConnectors = function (layout, node, level) {
        var i;
        //let info: LayoutInfo;
        //let nodeWidth: number; let nodeHeight: number; let targetWidth: number; let targetHeight: number;
        //let length: number; let offsetLen: number; let points: PointModel[];
        //let segments: ConnSegments;
        var target;
        var conn;
        //Route out edges
        var info = layout.graphNodes[node.id];
        if (node.outEdges.length) {
            for (i = 0; i < node.outEdges.length; i++) {
                conn = layout.nameTable[node.outEdges[parseInt(i.toString(), 10)]];
                conn.points = [];
                target = layout.nameTable[conn.targetID];
                if (conn.visible) {
                    conn.visited = true;
                    if (layout.getConnectorSegments) {
                        var segments = layout.getConnectorSegments(conn);
                    }
                    else {
                        if (info && info.tree.children.indexOf(conn.targetID) !== -1) {
                            //Bug 908662: Connector segments are not proper when we change orientation.
                            //Empty the segments collection before updating the segments.
                            conn.segments = [];
                            if (conn.type === 'Bezier' && layout.connectionPointOrigin === 'SamePoint') {
                                (conn.segments).push(new BezierSegment(conn, 'segments', { type: 'Bezier' }, true));
                            }
                            if (layout.type === 'OrganizationalChart' && conn.type === 'Orthogonal') {
                                this.updateSegments(layout, conn, node, target, i);
                            }
                        }
                    }
                    if (target && (target.isExpanded || this.hasChild(layout, target))) {
                        this.updateConnectors(layout, target, level + 1);
                    }
                }
            }
        }
        if (info && info.tree.assistants.length) {
            //In-Edge routing of assistant nodes
            for (i = 0; i < info.tree.assistants.length; i++) {
                target = layout.nameTable[info.tree.assistants[parseInt(i.toString(), 10)]];
                conn = layout.nameTable[target.inEdges[0]];
                this.get3Points(layout, node, target, conn);
                if (target.isExpanded || this.hasChild(layout, target)) {
                    this.updateConnectors(layout, target, level + 1);
                }
            }
        }
    };
    HierarchicalTree.prototype.updateSegments = function (layout, conn, node, target, i) {
        var info = layout.graphNodes[node.id];
        //Connector routing - Horizontal layout orientation
        if (info.tree.assistants.length) {
            //Route in-edge of child node, if the parent has assistant
            this.updateSegmentsForHorizontalOrientation(layout, node, target, conn);
        }
        else {
            //Route in-edge of child node
            if (info.tree.orientation === 'Horizontal' && info.tree.type === 'Balanced') {
                this.updateSegmentsForBalancedTree(layout, conn, node, target, i);
            }
            else {
                if (info.tree.orientation === 'Horizontal') {
                    this.updateSegmentsForHorizontalOrientation(layout, node, target, conn);
                }
                else {
                    if (info.tree.offset < 5) {
                        this.get5Points(layout, node, target, conn);
                    }
                    else {
                        this.get3Points(layout, node, target, conn);
                    }
                }
            }
        }
    };
    HierarchicalTree.prototype.updateSegmentsForBalancedTree = function (layout, connector, node, target, i) {
        var info = layout.graphNodes[node.id];
        var center;
        var relative;
        if (info.tree.children.length === 5 && i > 2) {
            relative = info.tree.children[1];
            if (isNaN(layout.graphNodes["" + relative].treeWidth)) {
                layout.graphNodes["" + relative].treeWidth = layout.nameTable["" + relative].actualSize.width;
            }
            var factor = i !== 3 ? 1 : -1;
            if (layout.orientation.indexOf('Left') !== -1) {
                center = layout.nameTable["" + relative].offsetY - layout.graphNodes["" + relative].treeWidth / 2 -
                    (layout.verticalSpacing * factor / 2);
            }
            else {
                var center_1 = layout.nameTable["" + relative].offsetX +
                    layout.graphNodes["" + relative].treeWidth / 2 + (layout.horizontalSpacing * factor) / 2;
            }
            this.getSegmentsForMultipleRows(layout, node, target, connector);
        }
        else {
            if (info.tree.children.length > 5) {
                if (i < 4 || i < info.tree.rows) {
                    this.getSegmentsForMultipleRows(layout, node, target, connector);
                }
                else {
                    this.updateSegmentsForHorizontalOrientation(layout, node, target, connector);
                }
            }
            else if (info.tree.children.length === 4) {
                if (i < 2 || i < info.tree.rows) {
                    this.getSegmentsForMultipleRows(layout, node, target, connector);
                }
                else {
                    this.updateSegmentsForHorizontalOrientation(layout, node, target, connector);
                }
            }
            else {
                this.getSegmentsForMultipleRows(layout, node, target, connector);
            }
        }
    };
    HierarchicalTree.prototype.get3Points = function (layout, node, target, connector) {
        var points = [];
        var nodeBounds = this.getBounds(node);
        var targetBounds = this.getBounds(target);
        if (layout.orientation.indexOf('Top') !== -1) {
            var startingPoint = layout.orientation.indexOf('Top') === 0 ? nodeBounds.bottomCenter :
                nodeBounds.topCenter;
            var endPoint = node.offsetX > target.offsetX ? targetBounds.middleRight : targetBounds.middleLeft;
            points.push(startingPoint, { x: nodeBounds.bottomCenter.x, y: endPoint.y }, endPoint);
        }
        else {
            var startingPoint = layout.orientation.indexOf('Left') === 0 ? nodeBounds.middleRight :
                nodeBounds.middleLeft;
            var endPoint = node.offsetY > target.offsetY ? targetBounds.bottomCenter : targetBounds.topCenter;
            points.push(startingPoint, { x: targetBounds.bottomCenter.x, y: nodeBounds.middleRight.y }, endPoint);
        }
        this.getSegmentsFromPoints(points, connector);
    };
    HierarchicalTree.prototype.get5Points = function (layout, node, target, connector) {
        var points = [];
        //let layoutprop: Layout;
        var nodeBounds = this.getBounds(node);
        var targetBounds = this.getBounds(target);
        //let info: LayoutInfo = layout.graphNodes[node.id];
        var startingPoint;
        var endPoint;
        var horizontalSpacing;
        var verticalSpacing;
        if (layout.orientation.indexOf('Top') !== -1) {
            startingPoint = (node.offsetY < target.offsetY) ? nodeBounds.bottomCenter : nodeBounds.topCenter;
            verticalSpacing = layout.verticalSpacing / 4 * ((node.offsetY < target.offsetY) ? 1 : -1);
            horizontalSpacing = layout.horizontalSpacing / 2 * ((node.offsetX > target.offsetX) ? 1 : -1);
            endPoint = (node.offsetX > target.offsetX) ? targetBounds.middleRight : targetBounds.middleLeft;
            points.push(startingPoint, { x: startingPoint.x, y: startingPoint.y + verticalSpacing }, { x: endPoint.x + horizontalSpacing, y: startingPoint.y + verticalSpacing }, { x: endPoint.x + horizontalSpacing, y: endPoint.y }, endPoint);
        }
        else {
            startingPoint = (node.offsetX > target.offsetX) ? nodeBounds.middleLeft : nodeBounds.middleRight;
            endPoint = node.offsetY > target.offsetY ? targetBounds.bottomCenter : targetBounds.topCenter;
            horizontalSpacing = layout.horizontalSpacing / 4 * ((node.offsetX < target.offsetX) ? 1 : -1);
            verticalSpacing = layout.verticalSpacing / 2 * ((node.offsetY > target.offsetY) ? 1 : -1);
            points.push(startingPoint, { x: startingPoint.x + horizontalSpacing, y: startingPoint.y }, { x: startingPoint.x + horizontalSpacing, y: startingPoint.y + verticalSpacing }, { x: endPoint.x, y: startingPoint.y + verticalSpacing }, endPoint);
        }
        this.getSegmentsFromPoints(points, connector);
    };
    HierarchicalTree.prototype.getSegmentsFromPoints = function (points, connector) {
        var segments = [];
        var segment;
        for (var i = 0; i < points.length - 2; i++) {
            segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);
            segment.direction = Point.direction(points[parseInt(i.toString(), 10)], points[i + 1]);
            segment.length = Point.distancePoints(points[parseInt(i.toString(), 10)], points[i + 1]);
            segments.push(segment);
        }
        connector.segments = segments;
    };
    HierarchicalTree.prototype.getSegmentsForMultipleRows = function (layout, node, target, connector) {
        //let points: PointModel[] = [];
        var segments = [];
        var point;
        var segment;
        var targetBounds = this.getBounds(target);
        var nodeBounds = this.getBounds(node);
        switch (layout.orientation) {
            case 'TopToBottom':
                point = { x: nodeBounds.bottomCenter.x, y: (nodeBounds.bottomCenter.y + layout.verticalSpacing / 4) };
                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);
                segment.direction = Point.direction(nodeBounds.bottomCenter, point);
                segment.length = Point.distancePoints(nodeBounds.bottomCenter, point);
                segments.push(segment);
                break;
            case 'BottomToTop':
                point = { x: nodeBounds.bottomCenter.x, y: (nodeBounds.topCenter.y - layout.verticalSpacing / 4) };
                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);
                segment.direction = Point.direction(nodeBounds.topCenter, point);
                segment.length = Point.distancePoints(nodeBounds.topCenter, point);
                segments.push(segment);
                break;
            case 'LeftToRight':
                point = { x: (nodeBounds.middleRight.x + layout.verticalSpacing / 4), y: nodeBounds.middleRight.y };
                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);
                segment.direction = Point.direction(nodeBounds.middleRight, point);
                segment.length = Point.distancePoints(nodeBounds.middleRight, point);
                segments.push(segment);
                if (targetBounds.center.y !== nodeBounds.center.y) {
                    var point3 = { x: (nodeBounds.middleRight.x + layout.verticalSpacing / 4), y: targetBounds.middleLeft.y };
                    segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);
                    segment.direction = Point.direction(point, point3);
                    segment.length = Point.distancePoints(point, point3);
                    segments.push(segment);
                }
                break;
            case 'RightToLeft':
                point = { x: (nodeBounds.middleLeft.x - layout.verticalSpacing / 4), y: nodeBounds.middleRight.y };
                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);
                segment.direction = Point.direction(nodeBounds.middleLeft, point);
                segment.length = Point.distancePoints(nodeBounds.middleLeft, point);
                segments.push(segment);
                if (targetBounds.center.y !== nodeBounds.center.y) {
                    var point_1 = { x: (nodeBounds.middleLeft.x - layout.verticalSpacing / 4), y: targetBounds.middleLeft.y };
                    segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);
                    segment.direction = Point.direction(point_1, point_1);
                    segment.length = Point.distancePoints(point_1, point_1);
                    segments.push(segment);
                }
                break;
        }
        connector.segments = segments;
    };
    HierarchicalTree.prototype.updateSegmentsForHorizontalOrientation = function (layout, node, target, connector) {
        var points = [];
        var point2;
        var segment;
        var segments = [];
        var nodeBounds = this.getBounds(node);
        var targetBounds = this.getBounds(target);
        switch (layout.orientation) {
            case 'TopToBottom':
                point2 = { x: nodeBounds.bottomCenter.x, y: (targetBounds.topCenter.y - layout.verticalSpacing / 2) };
                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);
                segment.direction = Point.direction(nodeBounds.bottomCenter, point2);
                segment.length = Point.distancePoints(nodeBounds.bottomCenter, point2);
                segments.push(segment);
                break;
            case 'BottomToTop':
                point2 = { x: nodeBounds.topCenter.x, y: (targetBounds.bottomCenter.y + layout.verticalSpacing / 2) };
                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);
                segment.direction = Point.direction(nodeBounds.topCenter, point2);
                segment.length = Point.distancePoints(nodeBounds.topCenter, point2);
                segments.push(segment);
                break;
            case 'LeftToRight':
                point2 = { x: (targetBounds.middleLeft.x - layout.verticalSpacing / 2), y: nodeBounds.middleRight.y };
                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);
                segment.direction = Point.direction(nodeBounds.middleRight, point2);
                segment.length = Point.distancePoints(nodeBounds.middleRight, point2);
                segments.push(segment);
                if (targetBounds.center.y !== nodeBounds.center.y) {
                    var point3 = { x: (targetBounds.middleLeft.x - layout.verticalSpacing / 2), y: targetBounds.middleLeft.y };
                    segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);
                    segment.direction = Point.direction(point2, point3);
                    segment.length = Point.distancePoints(point2, point3);
                    segments.push(segment);
                }
                break;
            case 'RightToLeft':
                point2 = { x: (targetBounds.middleRight.x + layout.verticalSpacing / 2), y: nodeBounds.middleRight.y };
                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);
                segment.direction = Point.direction(nodeBounds.middleLeft, point2);
                segment.length = Point.distancePoints(nodeBounds.middleLeft, point2);
                segments.push(segment);
                if (targetBounds.center.y !== nodeBounds.center.y) {
                    var point = { x: (targetBounds.middleRight.x + layout.verticalSpacing / 2), y: targetBounds.middleLeft.y };
                    segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);
                    segment.direction = Point.direction(point2, point);
                    segment.length = Point.distancePoints(point2, point);
                    segments.push(segment);
                }
                break;
        }
        connector.segments = segments;
        return points;
    };
    HierarchicalTree.prototype.updateNodes = function (layout, node, mod, update, dx, dy) {
        var i;
        var child;
        var width;
        var height;
        var offsetX;
        var offsetY;
        if (node && !node.excludeFromLayout) {
            width = node.actualSize.width;
            height = node.actualSize.height;
            offsetX = layout.anchorX;
            offsetY = layout.anchorY;
            /*Performance - instead of checking conditions for every node, we can make the layout related
            conditions once and we can reuse them*/
            if (layout.orientation === 'LeftToRight') {
                offsetX += layout.graphNodes[node.id].y + width / 2;
                offsetY += layout.graphNodes[node.id].x + mod + height / 2;
            }
            else if (layout.orientation === 'RightToLeft') {
                offsetX -= layout.graphNodes[node.id].y + width / 2;
                offsetY += layout.graphNodes[node.id].x + mod + height / 2;
            }
            else if (layout.orientation === 'TopToBottom') {
                offsetX += layout.graphNodes[node.id].x + mod + width / 2;
                offsetY += layout.graphNodes[node.id].y + height / 2;
            }
            else {
                offsetX += layout.graphNodes[node.id].x + mod + width / 2;
                offsetY -= layout.graphNodes[node.id].y + height / 2;
            }
            if (layout.graphNodes) {
                dx = dx ? dx : 0;
                dy = dy ? dy : 0;
                offsetX += dx;
                offsetY += dy;
                if (!this.isAnimation) {
                    node.offsetX = offsetX;
                    node.offsetY = offsetY;
                }
            }
            var objects = { id: node.id, differenceX: offsetX - node.offsetX, differenceY: offsetY - node.offsetY };
            layout.objects.push(objects);
            var list = [];
            if (this.hasChild(layout, node)) {
                for (i = 0; i < layout.graphNodes[node.id].tree.children.length; i++) {
                    child = layout.nameTable[layout.graphNodes[node.id].tree.children[parseInt(i.toString(), 10)]];
                    this.updateNodes(layout, child, mod + (layout.graphNodes[node.id].subTreeTranslation || 0), update, dx, dy);
                    list.push(child);
                }
            }
            if (layout.graphNodes[node.id].tree.assistants.length) {
                for (i = 0; i < layout.graphNodes[node.id].tree.assistants.length; i++) {
                    child = layout.nameTable[layout.graphNodes[node.id].tree.assistants[parseInt(i.toString(), 10)]];
                    this.updateNodes(layout, child, mod + (layout.graphNodes[node.id].subTreeTranslation || 0), null, dx, dy);
                }
            }
        }
    };
    return HierarchicalTree;
}());

/**
 * Layout for mind-map tree
 */
var MindMap = /** @class */ (function () {
    /**
     * Constructor for the organizational chart module.
     *
     * @private
     */
    function MindMap() {
        /**
         * Defines the layout animation
         *
         */
        this.isAnimation = false;
        //constructs the layout module
    }
    /**
     * To destroy the organizational chart
     *
     * @returns {void}
     * @private
     */
    MindMap.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    /**
     * Get module name.
     */
    MindMap.prototype.getModuleName = function () {
        /**
         * Returns the module name of the layout
         */
        return 'MindMapChart';
    };
    /**
     * @param nodes
     * @param nameTable
     * @param layoutProp
     * @param viewPort
     * @param uniqueId
     * @param root
     * @private
     */
    MindMap.prototype.updateLayout = function (nodes, nameTable, layoutProp, viewPort, uniqueId, root) {
        var isRoot = this.checkRoot(nodes, layoutProp, uniqueId, root, nameTable);
        if (isRoot) {
            layoutProp.fixedNode = isRoot;
        }
        else {
            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                var node = nodes_1[_i];
                if (!node.excludeFromLayout) {
                    if (!node.inEdges || !node.inEdges.length) {
                        layoutProp.fixedNode = node.id;
                        break;
                    }
                }
            }
        }
        var rootNode = nameTable[layoutProp.fixedNode];
        var fistLevelNodes = this.findFirstLevelNodes(rootNode, layoutProp, nameTable);
        var leftNodes = [];
        var rightNodes = [];
        var getMindmapBranch = getFunction(layoutProp.getBranch);
        getMindmapBranch = getMindmapBranch || getFunction(this.getBranch);
        for (var _a = 0, fistLevelNodes_1 = fistLevelNodes; _a < fistLevelNodes_1.length; _a++) {
            var node = fistLevelNodes_1[_a];
            var align = getMindmapBranch(node, fistLevelNodes);
            align = node && node.branch ? node.branch : align;
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            (align === 'Left') ? leftNodes.push(node) : rightNodes.push(node);
        }
        var viewPortBounds = new Rect(0, 0, viewPort.x, viewPort.y);
        nameTable[layoutProp.fixedNode].offsetX = viewPortBounds.x + viewPortBounds.width / 2;
        nameTable[layoutProp.fixedNode].offsetY = viewPortBounds.y + viewPortBounds.height / 2;
        if (leftNodes.length) {
            this.updateMindMapBranch(nodes, rightNodes, nameTable, layoutProp, viewPort, uniqueId, 'Left');
        }
        if (rightNodes.length) {
            this.updateMindMapBranch(nodes, leftNodes, nameTable, layoutProp, viewPort, uniqueId, 'Right');
        }
    };
    MindMap.prototype.checkRoot = function (nodes, layoutProp, uniqueId, root, nameTable) {
        for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {
            var node = nodes_2[_i];
            if (!node.excludeFromLayout) {
                if (node.data && (node.data["" + uniqueId].toString() === root || node.data["" + uniqueId].toString()
                    === layoutProp.root)) {
                    return node.id;
                }
                else if (!node.data && node.id === layoutProp.root) {
                    return node.id;
                }
            }
        }
        return '';
    };
    MindMap.prototype.updateMindMapBranch = function (nodes, excludeNodes, nameTable, layoutProp, viewPort, uniqueId, side) {
        var layout = {
            type: 'HierarchicalTree',
            horizontalSpacing: layoutProp.verticalSpacing, verticalSpacing: layoutProp.horizontalSpacing,
            verticalAlignment: layoutProp.verticalAlignment, horizontalAlignment: layoutProp.horizontalAlignment,
            fixedNode: layoutProp.fixedNode, getLayoutInfo: getFunction(layoutProp.getLayoutInfo),
            layoutInfo: layoutProp.layoutInfo, margin: layoutProp.margin,
            orientation: layoutProp.orientation,
            root: layoutProp.fixedNode
        };
        //(EJ2-277624)-Vertical orientation is not working in mindmap
        if (layout.orientation === 'Vertical') {
            layout.orientation = (side === 'Left') ? 'TopToBottom' : 'BottomToTop';
        }
        else {
            layout.orientation = (side === 'Left') ? 'LeftToRight' : 'RightToLeft';
        }
        this.excludeFromLayout(excludeNodes, nameTable, true);
        var mapLayout = new HierarchicalTree();
        mapLayout.updateLayout(nodes, nameTable, layout, viewPort, uniqueId);
        this.excludeFromLayout(excludeNodes, nameTable, false);
    };
    MindMap.prototype.getBranch = function (obj, firstLevelNodes) {
        var side;
        var i = firstLevelNodes.indexOf(obj);
        if (i % 2 === 0) {
            side = 'Left';
        }
        else {
            side = 'Right';
        }
        return side;
    };
    MindMap.prototype.excludeFromLayout = function (newCollection, nameTable, exclude) {
        for (var _i = 0, newCollection_1 = newCollection; _i < newCollection_1.length; _i++) {
            var newcol = newCollection_1[_i];
            var node = nameTable[newcol.id];
            node.excludeFromLayout = exclude;
        }
    };
    MindMap.prototype.findFirstLevelNodes = function (node, layout, nameTable) {
        var fistLevelNodes = [];
        if (node && node.outEdges.length) {
            for (var _i = 0, _a = node.outEdges; _i < _a.length; _i++) {
                var outEdge = _a[_i];
                fistLevelNodes.push(nameTable[nameTable["" + outEdge].targetID]);
            }
        }
        return fistLevelNodes;
    };
    return MindMap;
}());

/**
 * Radial Tree
 */
var RadialTree = /** @class */ (function () {
    /**
     * Constructor for the organizational chart module.
     *
     * @private
     */
    function RadialTree() {
        //constructs the layout module
    }
    /**
     * To destroy the organizational chart
     *
     * @returns {void}
     * @private
     */
    RadialTree.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    /**
     * Get module name.
     */
    RadialTree.prototype.getModuleName = function () {
        /**
         * Returns the module name of the layout
         */
        return 'RadialTree';
    };
    /**
     * @param nodes
     * @param nameTable
     * @param layoutProp
     * @param viewport
     * @private
     */
    RadialTree.prototype.updateLayout = function (nodes, nameTable, layoutProp, viewport) {
        var layout = {
            type: layoutProp.type,
            nameTable: nameTable, anchorX: 0, anchorY: 0,
            firstLevelNodes: [], centerNode: null, levels: [], maxLevel: 0, graphNodes: {}, layoutNodes: [],
            orientation: layoutProp.orientation,
            horizontalSpacing: layoutProp.horizontalSpacing, verticalSpacing: layoutProp.verticalSpacing,
            verticalAlignment: layoutProp.verticalAlignment, horizontalAlignment: layoutProp.horizontalAlignment,
            fixedNode: layoutProp.fixedNode, margin: layoutProp.margin,
            bounds: layoutProp.bounds, objects: [], root: layoutProp.root
        };
        this.doLayout(layout, nodes, nameTable, viewport);
    };
    RadialTree.prototype.doLayout = function (layout, nodes, nameTable, viewport) {
        var node;
        for (var i = 0; i < nodes.length; i++) {
            node = nodes[parseInt(i.toString(), 10)];
            if (!node.excludeFromLayout) {
                layout.graphNodes[node.id] = this.setUpLayoutInfo(layout, node);
                if (!node.inEdges || !node.inEdges.length) {
                    layout.firstLevelNodes.push(node);
                }
            }
        }
        if (layout.root && nameTable[layout.root]) {
            layout.centerNode = nameTable[layout.root];
        }
        else if (layout.firstLevelNodes.length) {
            layout.centerNode = layout.firstLevelNodes[0];
            layout.root = layout.centerNode.id;
        }
        if (layout.centerNode) {
            this.updateEdges(layout, layout.centerNode, 0, nameTable);
            this.depthFirstAllignment(layout, layout.centerNode, 0, 0);
            this.populateLevels(layout);
            this.transformToCircleLayout(layout);
            this.updateAnchor(layout, viewport);
            this.updateNodes(layout, layout.centerNode, nameTable);
        }
    };
    RadialTree.prototype.updateEdges = function (layout, node, depth, nameTable) {
        var nodeInfo = layout.graphNodes[node.id];
        layout.layoutNodes.push(nodeInfo);
        nodeInfo.level = depth;
        nodeInfo.visited = true;
        layout.maxLevel = Math.max(layout.maxLevel, depth);
        for (var j = 0; j < node.outEdges.length; j++) {
            var edge = nameTable[nameTable[node.outEdges[parseInt(j.toString(), 10)]].targetID];
            if (!edge.excludeFromLayout && !edge.visited) {
                nodeInfo.children.push(edge);
                this.updateEdges(layout, edge, depth + 1, nameTable);
            }
        }
    };
    RadialTree.prototype.depthFirstAllignment = function (layout, node, x, y) {
        var newValue;
        var nodeInfo = layout.graphNodes[node.id];
        if (nodeInfo.children.length) {
            y += 300;
            for (var i = 0; i < nodeInfo.children.length; i++) {
                newValue = this.depthFirstAllignment(layout, nodeInfo.children[parseInt(i.toString(), 10)], x, y);
                x = newValue.x;
                y = newValue.y;
            }
            nodeInfo.children = nodeInfo.children.sort(function (obj1, obj2) {
                return layout.graphNodes[obj1.id].x - layout.graphNodes[obj2.id].x;
            });
            var min = layout.graphNodes[nodeInfo.children[0].id].min;
            var max = layout.graphNodes[nodeInfo.children[nodeInfo.children.length - 1].id].max;
            nodeInfo.x = min + (max - min) / 2;
            x = max + layout.horizontalSpacing;
            nodeInfo.segmentOffset = max + layout.horizontalSpacing;
            nodeInfo.x -= nodeInfo.width / 2;
            nodeInfo.y -= nodeInfo.height / 2;
            nodeInfo.min = min;
            nodeInfo.max = max;
            if (nodeInfo.x < min && nodeInfo.visited) {
                nodeInfo.x = min;
                x = nodeInfo.x + nodeInfo.width / 2 - (max - min) / 2;
                nodeInfo.visited = false;
                for (var i = 0; i < nodeInfo.children.length; i++) {
                    newValue = this.depthFirstAllignment(layout, nodeInfo.children[parseInt(i.toString(), 10)], x, y);
                }
                nodeInfo.visited = true;
                x = nodeInfo.x + nodeInfo.width + layout.horizontalSpacing;
            }
            max = layout.graphNodes[nodeInfo.children[nodeInfo.children.length - 1].id].segmentOffset;
            x = x < max ? max : x;
            y -= 300;
            nodeInfo.y = y;
        }
        else {
            nodeInfo.x = x;
            nodeInfo.y = y;
            nodeInfo.min = x;
            nodeInfo.max = x + nodeInfo.width;
            x += nodeInfo.width + layout.horizontalSpacing;
        }
        return { x: x, y: y };
    };
    RadialTree.prototype.populateLevels = function (layout) {
        var stages = [];
        // eslint-disable-next-line prefer-spread
        var min = Math.min.apply(Math, layout.layoutNodes.map(function (nodeInfo) { return nodeInfo.x; }));
        // eslint-disable-next-line prefer-spread
        var max = Math.max.apply(Math, layout.layoutNodes.map(function (nodeInfo) {
            return nodeInfo.x + nodeInfo.width + layout.horizontalSpacing;
        }));
        var full = max - min;
        layout.levels = [];
        var _loop_1 = function (i) {
            stages = layout.layoutNodes.filter(function (nodeInfo) {
                if (nodeInfo.level === i) {
                    return nodeInfo;
                }
                else {
                    return null;
                }
            });
            var newlevel = {};
            stages = stages.sort(function (nodeInfo1, nodeInfo2) { return nodeInfo1.x - nodeInfo2.x; });
            newlevel.min = stages[0].x;
            newlevel.max = stages[stages.length - 1].x + stages[stages.length - 1].width + layout.horizontalSpacing;
            newlevel.actualCircumference = 0;
            newlevel.height = 0;
            for (var k = 0; k < stages.length; k++) {
                if (stages[parseInt(k.toString(), 10)].height > newlevel.height) {
                    newlevel.height = stages[parseInt(k.toString(), 10)].height;
                }
                newlevel.actualCircumference += Math.max(stages[parseInt(k.toString(), 10)].width, stages[parseInt(k.toString(), 10)].height);
                if (k !== stages.length - 1) {
                    newlevel.actualCircumference += layout.horizontalSpacing;
                }
            }
            newlevel.circumference = newlevel.max - newlevel.min;
            if (newlevel.actualCircumference < newlevel.circumference) {
                newlevel.circumference = (newlevel.circumference + newlevel.actualCircumference) / 2;
            }
            newlevel.radius = newlevel.circumference / (2 * Math.PI) + newlevel.height;
            newlevel.nodes = [];
            if (i > 1) {
                if (layout.levels[i - 1].radius + layout.levels[i - 1].height >= newlevel.radius) {
                    newlevel.radius = layout.levels[i - 1].radius + layout.levels[i - 1].height;
                }
            }
            for (var j = 0; j < stages.length; j++) {
                stages[parseInt(j.toString(), 10)].ratio = Math.abs(stages[parseInt(j.toString(), 10)].x
                    + stages[parseInt(j.toString(), 10)].width / 2 - min) / full;
                newlevel.nodes.push(stages[parseInt(j.toString(), 10)]);
            }
            layout.levels.push(newlevel);
        };
        for (var i = 0; i <= layout.maxLevel; i++) {
            _loop_1(i);
        }
    };
    RadialTree.prototype.transformToCircleLayout = function (layout) {
        var root = layout.graphNodes[layout.centerNode.id];
        root.x = 0;
        root.y = 0;
        for (var i = 1; i < layout.levels.length; i++) {
            for (var j = 0; j < layout.levels[parseInt(i.toString(), 10)].nodes.length; j++) {
                var nodeInfo = layout.levels[parseInt(i.toString(), 10)].nodes[parseInt(j.toString(), 10)];
                nodeInfo.x = Math.cos(nodeInfo.ratio * 360 * Math.PI / 180)
                    * (layout.levels[parseInt(i.toString(), 10)].radius + layout.verticalSpacing * i);
                nodeInfo.y = Math.sin(nodeInfo.ratio * 360 * Math.PI / 180)
                    * (layout.levels[parseInt(i.toString(), 10)].radius + layout.verticalSpacing * i);
                layout.anchorX = Math.min(layout.anchorX, nodeInfo.x);
                layout.anchorY = Math.min(layout.anchorY, nodeInfo.y);
            }
        }
    };
    RadialTree.prototype.updateAnchor = function (layout, viewPort) {
        layout.anchorX = layout.centerNode.offsetX || viewPort.x / 2;
        layout.anchorY = layout.centerNode.offsetY || viewPort.y / 2;
    };
    RadialTree.prototype.updateNodes = function (layout, node, nameTable) {
        var nodeInfo = layout.graphNodes[node.id];
        var offsetX = nodeInfo.x + layout.anchorX;
        var offsetY = nodeInfo.y + layout.anchorY;
        node.offsetX = offsetX;
        node.offsetY = offsetY;
        for (var i = 0; i < nodeInfo.children.length; i++) {
            var childInfo = nodeInfo.children[parseInt(i.toString(), 10)];
            this.updateNodes(layout, nameTable[childInfo.id], nameTable);
        }
    };
    RadialTree.prototype.setUpLayoutInfo = function (layout, item) {
        var info = {};
        info.name = item.id;
        info.x = 0;
        info.y = 0;
        info.min = 0;
        info.max = 0;
        info.width = item.actualSize.width;
        info.height = item.actualSize.height;
        info.children = [];
        info.level = 0;
        info.ratio = 0;
        info.visited = false;
        return info;
    };
    return RadialTree;
}());

var GraphForceNode = /** @class */ (function () {
    function GraphForceNode(gnNode) {
        /**
         * @private
         */
        this.velocityX = 0;
        /**
         * @private
         */
        this.velocityY = 0;
        /**
         * @private
         */
        this.nodes = [];
        this.graphNode = gnNode;
        var nNode = this.graphNode;
        var bounds = getGraphBounds(nNode);
        this.location = bounds.center;
        this.nodes = [];
        if (!gnNode.treeInfo.parents) {
            gnNode.treeInfo.parents = [];
        }
        if (!gnNode.treeInfo.children) {
            gnNode.treeInfo.children = [];
        }
        this.nodes = (gnNode.treeInfo.parents).concat(gnNode.treeInfo.children);
    }
    /**
     * applyChanges method\
     *
     * @returns {  void }    applyChanges method .\
     * @private
     */
    GraphForceNode.prototype.applyChanges = function () {
        this.graphNode.treeInfo.center = this.location;
    };
    return GraphForceNode;
}());
/**
 * SymmetricalLayout
 */
var SymmetricLayout = /** @class */ (function () {
    function SymmetricLayout() {
        this.cdCOEF = 0.442;
        this.cfMAXVELOCITY = 50;
        this.cnMAXITERACTION = 1000;
        this.cnSPRINGLENGTH = 100;
        this.mszMaxForceVelocity = { width: this.cfMAXVELOCITY, height: this.cfMAXVELOCITY };
        /**
         * @private
         */
        this.springLength = 0;
        /**
         * @private
         */
        this.springFactor = this.cdCOEF;
        /**
         * @private
         */
        this.maxIteration = this.cnMAXITERACTION;
        this.springLength = this.cnSPRINGLENGTH;
    }
    /**
     *To destroy the layout
     *
     * @returns {void} To destroy the layout
     */
    SymmetricLayout.prototype.destroy = function () {
        /**
         * Destroys symmetricLayout
         */
    };
    SymmetricLayout.prototype.getModuleName = function () {
        return 'SymmetricalLayout';
    };
    SymmetricLayout.prototype.doGraphLayout = function (graphLayoutManager) {
        var graph = this.selectedNode;
        graph.treeInfo.Bounds = graphLayoutManager.getModelBounds(graphLayoutManager.nodes);
        var lstGraphNodes = graph.treeInfo.GraphNodes;
        var lstNodes = this.convertGraphNodes(lstGraphNodes);
        var count = lstNodes.length;
        count = Math.min(this.maxIteration, count * count * count);
        this.preLayoutNodes(lstNodes, graph.treeInfo.Bounds);
        for (var i = 0, nLenght = count; i < nLenght; i++) {
            this.makeSymmetricLayout(lstNodes);
            this.appendForces(lstNodes);
        }
        this.resetGraphPosition(lstNodes, graph);
    };
    SymmetricLayout.prototype.preLayoutNodes = function (lstNodes, rcBounds) {
        var fMaxSize = Math.max(rcBounds.width, rcBounds.height);
        var ptCenter = { x: fMaxSize / 2, y: fMaxSize / 2 };
        var dRotateAngle = 2 * Math.PI / lstNodes.length;
        var dAngle = dRotateAngle;
        for (var i = 0; i < lstNodes.length; i++) {
            var gnNode = lstNodes[parseInt(i.toString(), 10)];
            var forceNode = this.getForceNode(gnNode);
            forceNode.location = {
                x: ptCenter.x + fMaxSize * Number((Math.cos(dAngle)).toFixed(2)),
                y: ptCenter.y + fMaxSize * Number(Math.sin(dAngle).toFixed(2))
            };
            dAngle -= dRotateAngle;
        }
    };
    /**
     * doLayout method\
     *
     * @returns {  void }    doLayout method .\
     * @param {GraphLayoutManager} graphLayoutManager - provide the angle value.
     * @private
     */
    SymmetricLayout.prototype.doLayout = function (graphLayoutManager) {
        this.selectedNode = graphLayoutManager.selectedNode;
        this.doGraphLayout(graphLayoutManager);
    };
    SymmetricLayout.prototype.makeSymmetricLayout = function (lstNodes) {
        var forceNode;
        var force;
        for (var k = 0; k < lstNodes.length; k++) {
            var gnNode = lstNodes[parseInt(k.toString(), 10)];
            forceNode = this.getForceNode(gnNode);
            var nodes = forceNode.nodes;
            for (var l = 0; l < nodes.length; l++) {
                var gnChild = nodes[parseInt(l.toString(), 10)];
                this.calcNodesForce(forceNode, this.getForceNode(gnChild));
            }
            for (var i = 0, length_1 = nodes.length; i < length_1; i++) {
                if (length_1 < 2) {
                    break;
                }
                var vtx1 = this.getForceNode(nodes[parseInt(i.toString(), 10)]);
                var vtx2 = (i + 1 >= length_1) ? this.getForceNode(nodes[0]) : this.getForceNode((nodes[i + 1]));
                var angle = (360 / nodes.length / 2) * Math.PI / 180;
                var normalDistance = 2 * this.springLength * Math.sin(angle);
                this.calcRelatesForce(vtx1, vtx2, normalDistance);
            }
            for (var s = 0; s < lstNodes.length; s++) {
                var gnChild = lstNodes[parseInt(s.toString(), 10)];
                if (!collectionContains(gnChild.id, nodes) && gnChild.id !== gnNode.id) {
                    force = this.getForceNode(gnChild);
                    this.updateNeigbour(forceNode, force);
                }
            }
        }
    };
    SymmetricLayout.prototype.appendForces = function (lstNodes) {
        var gfnNode = null;
        for (var k = 0; k < lstNodes.length; k++) {
            var gnNode = lstNodes[parseInt(k.toString(), 10)];
            gfnNode = this.getForceNode(gnNode);
            var ptPoint = gfnNode.location;
            ptPoint.x += Math.min(gfnNode.velocityX, this.mszMaxForceVelocity.width);
            ptPoint.y += Math.min(gfnNode.velocityY, this.mszMaxForceVelocity.height);
            gfnNode.velocityX = 0;
            gfnNode.velocityY = 0;
            gfnNode.location = ptPoint;
        }
    };
    SymmetricLayout.prototype.resetGraphPosition = function (lstNodes, graph) {
        var szMin = { width: Number.MAX_VALUE, height: Number.MAX_VALUE };
        var gfnNode = null;
        var gnNode;
        for (var k = 0; k < lstNodes.length; k++) {
            gnNode = lstNodes[parseInt(k.toString(), 10)];
            gfnNode = this.getForceNode(gnNode);
            var ptLocation = {
                x: gfnNode.location.x - gnNode.actualSize.width / 2,
                y: gfnNode.location.y - gnNode.actualSize.height / 2
            };
            szMin.width = Math.min(szMin.width, ptLocation.x);
            szMin.height = Math.min(szMin.height, ptLocation.y);
        }
        for (var k = 0; k < lstNodes.length; k++) {
            gnNode = lstNodes[parseInt(k.toString(), 10)];
            gfnNode = this.getForceNode(gnNode);
            var ptLocation = gfnNode.location;
            ptLocation.x -= szMin.width - (graph.treeInfo.location ? graph.treeInfo.location.x : 0);
            ptLocation.y -= szMin.height - (graph.treeInfo.location ? graph.treeInfo.location.y : 0);
            gfnNode.location = ptLocation;
            gfnNode.applyChanges();
        }
    };
    SymmetricLayout.prototype.convertGraphNodes = function (lstNodes) {
        var lstToReturn = [];
        var keys = Object.keys(lstNodes);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var k = keys_1[_i];
            var gnNode = lstNodes["" + k];
            var forceNode = new GraphForceNode(gnNode);
            gnNode.treeInfo.tag = forceNode;
            lstToReturn.push(gnNode);
        }
        return lstToReturn;
    };
    /**
     * getForceNode method\
     *
     * @returns {  GraphForceNode }    getForceNode method .\
     * @param {IGraphObject} gnNode - provide the angle value.
     * @private
     */
    SymmetricLayout.prototype.getForceNode = function (gnNode) {
        return gnNode.treeInfo.tag;
    };
    SymmetricLayout.prototype.updateNeigbour = function (vtSource, vtTarget) {
        if (vtTarget == null || vtSource == null) {
            return;
        }
        var distance = this.pointDistance(vtSource.location, vtTarget.location);
        var angle = this.lineAngle(vtSource.location, vtTarget.location);
        var normalDistance = (this.springLength * 0.9);
        if (distance < normalDistance) {
            this.calcForce(distance, normalDistance, angle, vtTarget);
        }
    };
    SymmetricLayout.prototype.lineAngle = function (pt1, pt2) {
        var radians = 0;
        var vx = pt2.x - pt1.x;
        var vy = pt2.y - pt1.y;
        if (vx === 0) {
            if (vy <= 0) {
                radians = (3.0 * Math.PI) / 2.0;
            }
            else {
                radians = Math.PI / 2.0;
            }
        }
        else if (vy === 0) {
            if (vx < 0) {
                radians = Math.PI;
            }
            else {
                radians = 0;
            }
        }
        else {
            radians = Math.atan(vy / vx);
            if (vx < 0 && vy > 0) {
                radians = Math.PI + radians;
            }
            else if (vx < 0 && vy < 0) {
                radians = Math.PI + radians;
            }
            else if (vx > 0 && vy < 0) {
                radians = 2.0 * Math.PI + radians;
            }
        }
        return radians;
    };
    SymmetricLayout.prototype.pointDistance = function (pt1, pt2) {
        var d = 0;
        var dx = pt2.x - pt1.x;
        var dy = pt2.y - pt1.y;
        var t = (dx * dx) + (dy * dy);
        d = Math.sqrt(t);
        return d;
    };
    SymmetricLayout.prototype.calcRelatesForce = function (vtSource, vtTarget, normalDistance) {
        var distance = this.pointDistance(vtSource.location, vtTarget.location);
        var angle = this.lineAngle(vtSource.location, vtTarget.location);
        if (distance < normalDistance) {
            this.calcForce(distance, normalDistance, angle, vtTarget);
        }
    };
    /**
     * @param nodeCollection
     * @param connectors
     * @param symmetricLayout
     * @param nameTable
     * @param layout
     * @param viewPort
     * @private
     */
    /**
     * updateLayout method\
     *
     * @returns {  void }    updateLayout method .\
     * @param {IGraphObject[]} nodeCollection - provide the angle value.
     * @param {IGraphObject[]} connectors - provide the connectors value.
     * @param {SymmetricLayout} symmetricLayout - provide the symmetricLayout value.
     * @param {Object} nameTable - provide the nameTable value.
     * @param {Layout} layout - provide the layout value.
     * @param {PointModel} viewPort - provide the viewPort value.
     * @private
     */
    SymmetricLayout.prototype.updateLayout = function (nodeCollection, connectors, symmetricLayout, nameTable, layout, viewPort) {
        var layoutManager = new GraphLayoutManager();
        layoutManager.updateLayout(nodeCollection, connectors, symmetricLayout, nameTable, layout, viewPort);
    };
    SymmetricLayout.prototype.calcNodesForce = function (vtSource, vtTarget) {
        var distance = this.pointDistance(vtSource.location, vtTarget.location);
        var angle = this.lineAngle(vtSource.location, vtTarget.location);
        if (distance > this.springLength || distance < this.springLength) {
            this.calcForce(distance, this.springLength, angle, vtTarget);
        }
    };
    SymmetricLayout.prototype.calcForce = function (distance, minDist, angle, vtTarget) {
        var count = vtTarget.nodes.length;
        var length = distance - minDist;
        var factor = this.springFactor / (count * count) * Math.sqrt(count);
        var fVelocity = length * factor;
        var fOffset = fVelocity;
        var offsetX = Math.cos(angle) * fOffset;
        var offsetY = Math.sin(angle) * fOffset;
        vtTarget.velocityX -= offsetX;
        vtTarget.velocityY -= offsetY;
    };
    return SymmetricLayout;
}());
var GraphLayoutManager = /** @class */ (function () {
    function GraphLayoutManager() {
        this.visitedStack = [];
        this.cycleEdgesCollection = [];
        this.graphObjects = [];
        this.passedNodes = [];
    }
    /**
     * @param nodeCollection
     * @param connectors
     * @param symmetricLayout
     * @param nameTable
     * @param layout
     * @param viewPort
     * @private
     */
    /**
     * updateLayout method\
     *
     * @returns {  boolean }    updateLayout method .\
     * @param {IGraphObject[]} nodeCollection - provide the nodeCollection value.
     * @param {IGraphObject[]} connectors - provide the nodeCollection value.
     * @param {SymmetricLayout} symmetricLayout - provide the nodeCollection value.
     * @param {Object} nameTable - provide the nodeCollection value.
     * @param {Layout} layout - provide the nodeCollection value.
     * @param {PointModel} viewPort - provide the nodeCollection value.
     * @private
     */
    GraphLayoutManager.prototype.updateLayout = function (nodeCollection, connectors, symmetricLayout, nameTable, layout, viewPort) {
        this.nameTable = nameTable;
        this.nodes = nodeCollection;
        this.connectors = connectors;
        var selectionList = nodeCollection;
        if (selectionList.length > 0) {
            this.mhelperSelectedNode = cloneObject(selectionList[0]);
        }
        for (var _i = 0, nodeCollection_1 = nodeCollection; _i < nodeCollection_1.length; _i++) {
            var node = nodeCollection_1[_i];
            var nodeGraphObject = node;
            nodeGraphObject.treeInfo = {};
            nodeGraphObject.treeInfo.graphType = 'Node';
            this.graphObjects.push(nodeGraphObject);
        }
        for (var _a = 0, connectors_1 = connectors; _a < connectors_1.length; _a++) {
            var connector = connectors_1[_a];
            var connectorGraphObject = connector;
            connectorGraphObject.treeInfo = {};
            connectorGraphObject.treeInfo.graphType = 'Connector';
            this.graphObjects.push(connectorGraphObject);
        }
        this.updateLayout1(this.graphObjects, symmetricLayout);
        var modelBounds = this.getModelBounds(selectionList);
        for (var i = 0; i < selectionList.length; i++) {
            var node = selectionList[parseInt(i.toString(), 10)];
            var trnsX = (viewPort.x - modelBounds.width) / 2;
            var margin = layout.margin;
            var dx = (node.treeInfo.tag.location.x - (node.offsetX - (node.actualSize.width / 2)) -
                modelBounds.x + trnsX + margin.left);
            var dy = (node.treeInfo.tag.location.y - (node.offsetY - (node.actualSize.height / 2)) - modelBounds.y + margin.top);
            node.offsetX += dx;
            node.offsetY += dy;
            delete node.treeInfo;
        }
        return true;
    };
    /**
     * getModelBounds method\
     *
     * @returns {  Rect }    getModelBounds method .\
     * @param {IGraphObject[]} lNodes - provide the angle value.
     * @private
     */
    GraphLayoutManager.prototype.getModelBounds = function (lNodes) {
        lNodes = lNodes.slice();
        var rect = null;
        var rect1 = null;
        var node;
        for (var i = 0; i < lNodes.length; i++) {
            node = lNodes[parseInt(i.toString(), 10)];
            var bounds = getGraphBounds(node);
            rect = new Rect(node.treeInfo.tag ? node.treeInfo.tag.location.x : bounds.x, node.treeInfo.tag ? node.treeInfo.tag.location.y : bounds.y, node.actualSize.width, node.actualSize.height);
            if (rect1) {
                rect1 = rect1.uniteRect(rect);
            }
            else {
                rect1 = rect;
            }
        }
        return rect1;
    };
    GraphLayoutManager.prototype.updateLayout1 = function (nodesToLayout, symmetricLayout) {
        this.detectCyclesInGraph(nodesToLayout);
        var nodesCount = nodesToLayout.length;
        if (nodesCount > 0) {
            var cycleConnColln = [];
            var nodes = [];
            var nodeSymbols = [];
            for (var s = 0; s < nodesToLayout.length; s++) {
                var nd = nodesToLayout[parseInt(s.toString(), 10)];
                if (nd.treeInfo.isCycleEdge === undefined) {
                    nd.treeInfo.isCycleEdge = false;
                }
                if (nd.treeInfo.graphType === 'Connector' && !nd.treeInfo.isCycleEdge) {
                    nodes.push(nd);
                }
                else if (nd.treeInfo.graphType === 'Connector') {
                    cycleConnColln.push(nd);
                }
                else {
                    nodeSymbols.push(nd);
                }
            }
            nodes = nodes.concat(nodeSymbols);
            nodes = cycleConnColln.concat(nodes);
            while (nodesCount > this.dictionaryLength(this.passedNodes)) {
                this.getNodesToPosition(nodes);
                if (this.selectedNode == null) {
                    continue;
                }
                symmetricLayout.doLayout(this);
                this.selectedNode = null;
                this.visitedStack = [];
            }
            this.passedNodes = null;
            this.selectedNode = null;
        }
        return false;
    };
    GraphLayoutManager.prototype.getNodesToPosition = function (nodes) {
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[parseInt(i.toString(), 10)];
            this.selectNodes(node);
            break;
        }
    };
    GraphLayoutManager.prototype.selectNodes = function (node) {
        var nodeGraph = node;
        if (node.treeInfo.graphType === 'Connector') {
            this.exploreGraphEdge(node);
        }
        else if (nodeGraph != null) {
            if (this.addNode(node, 'passed')) {
                this.addNode(node, 'selected');
                if (this.isConnectedToAnotherNode(nodeGraph)) {
                    this.selectedNode = { treeInfo: {} };
                    this.selectedNode.treeInfo.LeftMargin = 10;
                    this.selectedNode.treeInfo.TopMargin = 10;
                    this.selectConnectedNodes(nodeGraph);
                }
            }
        }
    };
    GraphLayoutManager.prototype.selectConnectedNodes = function (nodeGraph) {
        var graph = this.selectedNode;
        if (!graph.treeInfo.GraphNodes) {
            graph.treeInfo.GraphNodes = {};
        }
        var node = nodeGraph;
        this.addNode(node, 'passed');
        var nodeName = node.id;
        if (!this.dictionaryContains(graph.treeInfo.GraphNodes, node)) {
            var gnNode = this.addGraphNode(node);
            this.getConnectedRelatives(gnNode);
            this.exploreRelatives(nodeGraph);
        }
        else {
            var graphNode = graph.treeInfo.GraphNodes["" + nodeName];
            if (graphNode.treeInfo.Added) {
                graphNode.treeInfo.Added = false;
                this.getConnectedRelatives(graphNode);
                this.exploreRelatives(nodeGraph);
            }
        }
    };
    GraphLayoutManager.prototype.exploreRelatives = function (nodeGraph) {
        this.exploreRelatives1(nodeGraph, 'Parents');
        this.exploreRelatives1(nodeGraph, 'Children');
    };
    GraphLayoutManager.prototype.exploreRelatives1 = function (nodeGraph, relativesToExplore) {
        var edges = [];
        if (relativesToExplore === 'Parents') {
            edges = nodeGraph.inEdges;
        }
        else {
            edges = nodeGraph.outEdges;
        }
        for (var i = 0; i < edges.length; i++) {
            var edge = this.nameTable[edges[parseInt(i.toString(), 10)]];
            if (this.addNode(edge, 'passed')) {
                var fromNode = this.nameTable[edge.sourceID];
                var toNode = this.nameTable[edge.targetID];
                if (relativesToExplore === 'Parents' && fromNode != null &&
                    collectionContains(fromNode.id, this.nodes)) {
                    this.selectConnectedNodes(this.nameTable[edge.sourceID]);
                }
                else if (relativesToExplore === 'Children' && toNode != null &&
                    collectionContains(toNode.id, this.nodes)) {
                    this.selectConnectedNodes(this.nameTable[edge.targetID]);
                }
            }
        }
    };
    GraphLayoutManager.prototype.getConnectedRelatives = function (graphNode) {
        this.getConnectedParents(graphNode);
        this.getConnectedChildren(graphNode);
    };
    GraphLayoutManager.prototype.dictionaryContains = function (obj, keyObj) {
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) {
            if (keys[parseInt(i.toString(), 10)] === keyObj.id) {
                return true;
            }
        }
        return false;
    };
    GraphLayoutManager.prototype.dictionaryLength = function (obj) {
        var keys = Object.keys(obj);
        return keys.length;
    };
    GraphLayoutManager.prototype.getConnectedChildren = function (graphNode) {
        var graph = this.selectedNode;
        var nodeGraph = graphNode;
        for (var s = 0; s < nodeGraph.outEdges.length; s++) {
            var edge = this.nameTable[nodeGraph.outEdges[parseInt(s.toString(), 10)]];
            if (!edge.treeInfo.isCycleEdge) {
                var node = this.nameTable[edge.targetID];
                if (collectionContains(node.id, this.nodes) && node != null && node.visible) {
                    var gnNodeChildren = void 0;
                    if (!this.dictionaryContains(graph.treeInfo.GraphNodes, node)) {
                        gnNodeChildren = this.addGraphNode(node);
                        gnNodeChildren.treeInfo.Added = true;
                    }
                    else {
                        gnNodeChildren = graph.treeInfo.GraphNodes[node.id];
                    }
                    if (!graphNode.treeInfo.children) {
                        graphNode.treeInfo.children = [];
                    }
                    if (!gnNodeChildren.treeInfo.parents) {
                        gnNodeChildren.treeInfo.parents = [];
                    }
                    this.setNode(gnNodeChildren.treeInfo.parents, graphNode);
                    if (this.findNode(graphNode.treeInfo.children, gnNodeChildren.id) < 0) {
                        graphNode.treeInfo.children.push(gnNodeChildren);
                    }
                }
            }
        }
    };
    GraphLayoutManager.prototype.getConnectedParents = function (graphNode) {
        var graph = this.selectedNode;
        var nodeGraph = graphNode;
        for (var s = 0; s < nodeGraph.inEdges.length; s++) {
            var edge = this.nameTable[nodeGraph.inEdges[parseInt(s.toString(), 10)]];
            if (!edge.treeInfo.isCycleEdge) {
                var node = this.nameTable[edge.sourceID];
                if (collectionContains(node.id, this.nodes) && node != null && node.visible) {
                    var gnNode = void 0;
                    if (!this.dictionaryContains(graph.treeInfo.GraphNodes, node)) {
                        gnNode = this.addGraphNode(node);
                        gnNode.treeInfo.Added = true;
                    }
                    else {
                        gnNode = graph.treeInfo.GraphNodes[node.id];
                    }
                    if (!graphNode.treeInfo.parents) {
                        graphNode.treeInfo.parents = [];
                    }
                    if (!gnNode.treeInfo.children) {
                        gnNode.treeInfo.children = [];
                    }
                    this.setNode(gnNode.treeInfo.children, graphNode);
                    if (this.findNode(graphNode.treeInfo.parents, gnNode.id) < 0) {
                        graphNode.treeInfo.parents.push(gnNode);
                    }
                }
            }
        }
    };
    GraphLayoutManager.prototype.setNode = function (list, node) {
        var nIndex = this.findNode(list, node.id);
        if (nIndex >= 0 && nIndex < list.length) {
            list[parseInt(nIndex.toString(), 10)] = node;
        }
        else {
            list.push(node);
        }
    };
    GraphLayoutManager.prototype.findNode = function (list, fullName) {
        var nIndex = -1;
        if (list != null && fullName !== '') {
            for (var i = 0, nLength = list.length; i < nLength; i++) {
                var gnNode = list[parseInt(i.toString(), 10)];
                if (gnNode != null && gnNode.id === fullName) {
                    nIndex = i;
                    break;
                }
            }
        }
        return nIndex;
    };
    GraphLayoutManager.prototype.addGraphNode = function (node) {
        var graph = this.selectedNode;
        var gnNode = node;
        graph.treeInfo.GraphNodes[gnNode.id] = gnNode;
        var nodeHelper = this.mhelperSelectedNode;
        if (nodeHelper != null && node.id === nodeHelper.id) {
            this.mhelperSelectedNode = gnNode;
        }
        return gnNode;
    };
    GraphLayoutManager.prototype.isConnectedToAnotherNode = function (gnNode) {
        var bFoundConnectedNode = false;
        var edges = (gnNode.inEdges).concat(gnNode.outEdges);
        if (edges.length > 0) {
            if ((gnNode.inEdges != null) && (gnNode.inEdges.length > 0)) {
                bFoundConnectedNode = this.searchEdgeCollection(gnNode.inEdges, 'FromNode');
            }
            if ((!bFoundConnectedNode) && (gnNode.outEdges != null) && (gnNode.outEdges.length > 0)) {
                bFoundConnectedNode = this.searchEdgeCollection(gnNode.outEdges, 'ToNode');
            }
        }
        return bFoundConnectedNode;
    };
    GraphLayoutManager.prototype.searchEdgeCollection = function (edgesToSearchThrough, connectionDirection) {
        var bFoundConnectedNode = false;
        for (var i = 0; i < edgesToSearchThrough.length - 1; i++) {
            var edge = this.nameTable[edgesToSearchThrough[parseInt(i.toString(), 10)]];
            if (!this.addNode(edge, 'passed')) {
                continue;
            }
            if (!edge.treeInfo.isCycleEdge && ((connectionDirection === 'FromNode' && this.nameTable[edge.sourceID] != null)
                || (connectionDirection === 'ToNode' && this.nameTable[edge.targetID] != null))) {
                bFoundConnectedNode = true;
                break;
            }
        }
        return bFoundConnectedNode;
    };
    GraphLayoutManager.prototype.exploreGraphEdge = function (node) {
        var nodeLink = node;
        if (nodeLink != null && !nodeLink.treeInfo.isCycleEdge && this.addNode(node, 'passed')) {
            this.addNode(node, 'selected');
            var fromNode = this.nameTable[nodeLink.sourceID];
            var toNode = this.nameTable[nodeLink.targetID];
            if (fromNode != null) {
                this.selectNodes(fromNode);
            }
        }
    };
    GraphLayoutManager.prototype.addNode = function (nodeToAdd, collectionToAdd) {
        var bResult = true;
        var node = nodeToAdd;
        if (collectionToAdd === 'passed' || !node.visible) {
            if (!this.dictionaryContains(this.passedNodes, node)) {
                this.passedNodes[node.id] = node;
            }
        }
        if (!node.visible) {
            return false;
        }
        return bResult;
    };
    GraphLayoutManager.prototype.detectCyclesInGraph = function (nodes) {
        var vertex = [];
        var currentStack = [];
        for (var k = 0; k < nodes.length; k++) {
            if (!(nodes[parseInt(k.toString(), 10)].treeInfo.graphType === 'Connector')) {
                vertex.push(nodes[parseInt(k.toString(), 10)]);
            }
        }
        if (vertex.length > 0) {
            currentStack.push(vertex[0]);
            this.visitedStack.push(vertex[0]);
            while (currentStack.length > 0) {
                var top_1 = currentStack[currentStack.length - 1];
                var childNodes = this.getUnVisitedChildNodes(top_1);
                if (childNodes.length > 0) {
                    var child = childNodes[0];
                    var currentEdge = childNodes[childNodes.length - 1];
                    if (collectionContains(child.id, this.visitedStack)) {
                        currentEdge.treeInfo.isCycleEdge = true;
                        this.cycleEdgesCollection.push(currentEdge);
                    }
                    else {
                        currentStack.push(child);
                        this.visitedStack.splice(0, 0, child);
                    }
                }
                else {
                    currentStack.pop();
                }
            }
        }
    };
    GraphLayoutManager.prototype.getUnVisitedChildNodes = function (top) {
        var childNodes = [];
        if (top.outEdges.length > 0) {
            for (var i = 0; i < top.outEdges.length; i++) {
                var con = this.nameTable[top.outEdges[parseInt(i.toString(), 10)]];
                if (!collectionContains(con.id, this.visitedStack)) {
                    var toNode = this.nameTable[con.targetID];
                    if (toNode != null) {
                        childNodes.push(toNode);
                    }
                    childNodes.push(con);
                    this.visitedStack.splice(0, 0, con);
                    return childNodes;
                }
            }
            return childNodes;
        }
        return childNodes;
    };
    return GraphLayoutManager;
}());
/**
 * getGraphBounds method\
 *
 * @returns {  void }    getGraphBounds method .\
 * @param {IGraphObject} node - provide the angle value.
 * @private
 */
function getGraphBounds(node) {
    var x = node.offsetX - node.actualSize.width * node.pivot.x;
    var y = node.offsetY - node.actualSize.height * node.pivot.y;
    return new Rect(x, y, node.actualSize.width, node.actualSize.height);
}
/**
 * @param id
 * @param coll
 */
/**
 * collectionContains method\
 *
 * @returns {  boolean }    collectionContains method .\
 * @param {string} id - provide the id value.
 * @param {IGraphObject[]} coll - provide the id value.
 * @private
 */
function collectionContains(id, coll) {
    for (var i = 0; i < coll.length; i++) {
        if (coll[parseInt(i.toString(), 10)].id === id) {
            return true;
        }
    }
    return false;
}

/**
 * Connects diagram objects with layout algorithm
 */
var ComplexHierarchicalTree = /** @class */ (function () {
    /**
     * Constructor for the hierarchical tree layout module
     *
     * @private
     */
    function ComplexHierarchicalTree() {
        //constructs the layout module
    }
    /**
     * To destroy the hierarchical tree module
     *
     * @returns {void}
     * @private
     */
    ComplexHierarchicalTree.prototype.destroy = function () {
        /**
         * Destroy method performed here
         */
    };
    /**
     * Core method to return the component name.
     *
     * @returns {string}  Core method to return the component name.
     * @private
     */
    ComplexHierarchicalTree.prototype.getModuleName = function () {
        /**
         * Returns the module name of the layout
         *
         */
        return 'ComplexHierarchicalTree';
    };
    /**
     * doLayout method\
     *
     * @returns {  void }    doLayout method .\
     * @param {INode[]} nodes - provide the nodes value.
     * @param {{}} nameTable - provide the nameTable value.
     * @param {Layout} layout - provide the layout value.
     * @param {PointModel} viewPort - provide the viewPort value.
     * @param {Diagram} diagram - provide the diagram model.
     * @private
     */
    ComplexHierarchicalTree.prototype.doLayout = function (nodes, nameTable, layout, viewPort, diagram) {
        new HierarchicalLayoutUtil().doLayout(nodes, nameTable, layout, viewPort, diagram);
    };
    ComplexHierarchicalTree.prototype.getLayoutNodesCollection = function (nodes) {
        var nodesCollection = [];
        var node;
        var parentId = 'parentId';
        var processId = 'processId';
        for (var i = 0; i < nodes.length; i++) {
            node = nodes[parseInt(i.toString(), 10)];
            //885697:Position of root node without the child node in complex hierarchical layout is not proper
            // 941582: ExcludeFromLayout Option Not Supported in Complex Hierarchical Tree
            if (!node.excludeFromLayout) {
                if (((node.inEdges.length + node.outEdges.length > 0) || (node.offsetX === 0 && node.offsetY === 0)) &&
                    !node['' + parentId] && !node['' + processId]) {
                    nodesCollection.push(node);
                }
            }
        }
        return nodesCollection;
    };
    return ComplexHierarchicalTree;
}());
/**
 * Utility that arranges the nodes in hierarchical structure
 */
var HierarchicalLayoutUtil = /** @class */ (function () {
    function HierarchicalLayoutUtil() {
        this.nameTable = {};
        this.crossReduction = new CrossReduction();
        /**
         * The preferred vertical offset between edges exiting a vertex Default is 2.
         */
        this.previousEdgeOffset = 6;
        /**
         * The preferred horizontal distance between edges exiting a vertex Default is 5.
         */
        this.previousEdgeDistance = 5;
        /**
         * Holds the collection vertices, that are equivalent to nodes to be arranged
         */
        this.jettyPositions = {};
        /**
         * Internal cache of bottom-most value of Y for each rank
         */
        this.rankBottomY = null;
        /**
         * Internal cache of bottom-most value of X for each rank
         */
        this.limitX = null;
        /**
         * Internal cache of top-most values of Y for each rank
         */
        this.rankTopY = null;
        /**
         * The minimum parallelEdgeSpacing value is 12.
         */
        this.parallelEdgeSpacing = 10;
        /**
         * The minimum distance for an edge jetty from a vertex Default is 12.
         */
        this.minEdgeJetty = 12;
    }
    //Defines a vertex that is equivalent to a node object
    HierarchicalLayoutUtil.prototype.createVertex = function (node, value, x, y, width, height) {
        var geometry = { x: x, y: y, width: width, height: height };
        var vertex = {
            value: value, geometry: geometry, name: value, vertex: true,
            inEdges: node.inEdges.slice(), outEdges: node.outEdges.slice()
        };
        return vertex;
    };
    /**
     * Initializes the edges collection of the vertices\
     *
     * @returns {  IConnector[] }    Initializes the edges collection of the vertices\
     * @param {Vertex} node - provide the node value.
     * @private
     */
    HierarchicalLayoutUtil.prototype.getEdges = function (node) {
        var edges = [];
        var node1 = this.nameTable[node.name];
        // 941582: ExcludeFromLayout Option Not Supported in Complex Hierarchical Tree
        if (node && !node1.excludeFromLayout) {
            for (var i = 0; node.inEdges.length > 0 && i < node.inEdges.length; i++) {
                var connector = this.nameTable[node.inEdges[parseInt(i.toString(), 10)]];
                if (!this.nameTable[connector.sourceID].excludeFromLayout) {
                    edges.push(connector);
                }
            }
            for (var i = 0; node.outEdges.length > 0 && i < node.outEdges.length; i++) {
                var connector = this.nameTable[node.outEdges[parseInt(i.toString(), 10)]];
                if (!this.nameTable[connector.targetID].excludeFromLayout) {
                    edges.push(connector);
                }
            }
        }
        return edges;
    };
    //Finds the root nodes of the layout
    HierarchicalLayoutUtil.prototype.findRoots = function (vertices) {
        var roots = [];
        var best = null;
        var maxDiff = -100000;
        for (var _i = 0, _a = Object.keys(vertices); _i < _a.length; _i++) {
            var i = _a[_i];
            var cell = vertices["" + i];
            var conns = this.getEdges(cell);
            var outEdges = 0;
            var inEdges = 0;
            for (var k = 0; k < conns.length; k++) {
                var src = this.getVisibleTerminal(conns[parseInt(k.toString(), 10)], true);
                if (src.name === cell.name) {
                    outEdges++;
                }
                else {
                    inEdges++;
                }
            }
            if (inEdges === 0 && outEdges > 0) {
                roots.push(cell);
            }
            var diff = outEdges - inEdges;
            if (diff > maxDiff) {
                maxDiff = diff;
                best = cell;
            }
        }
        if (roots.length === 0 && best != null) {
            roots.push(best);
        }
        return roots;
    };
    /**
     * Returns the source/target vertex of the given connector \
     *
     * @returns {  Vertex }    Returns the source/target vertex of the given connector \
     * @param {IConnector} edge - provide the node value.
     * @param {boolean} source - provide the node value.
     * @private
     */
    HierarchicalLayoutUtil.prototype.getVisibleTerminal = function (edge, source) {
        var terminalCache = this.nameTable[edge.targetID];
        if (source) {
            terminalCache = this.nameTable[edge.sourceID];
        }
        for (var i = 0; i < this.vertices.length; i++) {
            if (this.vertices[parseInt(i.toString(), 10)].name === terminalCache.id) {
                return this.vertices[parseInt(i.toString(), 10)];
            }
        }
        return null;
    };
    /**
     * Traverses each sub tree, ensures there is no cycle in traversing \
     *
     * @returns {  {} }    Traverses each sub tree, ensures there is no cycle in traversing .\
     * @param {Vertex} vertex - provide the vertex value.
     * @param {boolean} directed - provide the directed value.
     * @param {IConnector} edge - provide the edge value.
     * @param {{}} currentComp - provide the currentComp value.
     * @param {{}[]} hierarchyVertices - provide the hierarchyVertices value.
     * @param {{}} filledVertices - provide the filledVertices value.
     * @private
     */
    HierarchicalLayoutUtil.prototype.traverse = function (vertex, directed, edge, currentComp, hierarchyVertices, filledVertices) {
        if (vertex != null) {
            var vertexID = vertex.name;
            if ((filledVertices == null ? true : filledVertices["" + vertexID] != null)) {
                if (currentComp["" + vertexID] == null) {
                    currentComp["" + vertexID] = vertex;
                }
                if (filledVertices != null) {
                    delete filledVertices["" + vertexID];
                }
                var edges = this.getEdges(vertex);
                var edgeIsSource = [];
                for (var i = 0; i < edges.length; i++) {
                    edgeIsSource[parseInt(i.toString(), 10)] = this.getVisibleTerminal(edges[parseInt(i.toString(), 10)], true) === vertex;
                }
                for (var i = 0; i < edges.length; i++) {
                    if (!directed || edgeIsSource[parseInt(i.toString(), 10)]) {
                        var next = this.getVisibleTerminal(edges[parseInt(i.toString(), 10)], !edgeIsSource[parseInt(i.toString(), 10)]);
                        var netCount = 1;
                        for (var j = 0; j < edges.length; j++) {
                            if (j === i) {
                                continue;
                            }
                            else {
                                var isSource2 = edgeIsSource[parseInt(j.toString(), 10)];
                                var otherTerm = this.getVisibleTerminal(edges[parseInt(j.toString(), 10)], !isSource2);
                                if (otherTerm === next) {
                                    if (isSource2) {
                                        netCount++;
                                    }
                                    else {
                                        netCount--;
                                    }
                                }
                            }
                        }
                        if (netCount >= 0) {
                            currentComp = this.traverse(next, directed, edges[parseInt(i.toString(), 10)], currentComp, hierarchyVertices, filledVertices);
                        }
                    }
                }
            }
            else {
                if (currentComp["" + vertexID] == null) {
                    // We've seen this vertex before, but not in the current component This component and the one it's in need to be merged
                    for (var i = 0; i < hierarchyVertices.length; i++) {
                        var comp = hierarchyVertices[parseInt(i.toString(), 10)];
                        if (comp["" + vertexID] != null) {
                            for (var _i = 0, _a = Object.keys(comp); _i < _a.length; _i++) {
                                var key = _a[_i];
                                currentComp["" + key] = comp["" + key];
                            }
                            // Remove the current component from the hierarchy set
                            hierarchyVertices.splice(i, 1);
                            return currentComp;
                        }
                    }
                }
            }
        }
        return currentComp;
    };
    //Returns the bounds of the given vertices
    HierarchicalLayoutUtil.prototype.getModelBounds = function (nodes) {
        nodes = nodes.slice();
        var rect = null;
        var rect1 = null;
        for (var i = 0; i < nodes.length; i++) {
            rect = nodes[parseInt(i.toString(), 10)].geometry;
            if (rect1) {
                var right = Math.max(rect1.x + rect1.width, rect.x + rect.width);
                var bottom = Math.max(rect1.y + rect1.height, rect.y + rect.height);
                rect1.x = Math.min(rect1.x, rect.x);
                rect1.y = Math.min(rect1.y, rect.y);
                rect1.width = right - rect1.x;
                rect1.height = bottom - rect1.y;
            }
            else {
                rect1 = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
            }
        }
        return rect1;
    };
    /* tslint:disable */
    /**
     *  Initializes the layouting process \
     *
     * @returns {  Vertex }     Initializes the layouting process \
     * @param {INode[]} nodes - provide the node value.
     * @param {{}} nameTable - provide the nameTable value.
     * @param {Layout} layoutProp - provide the layoutProp value.
     * @param {PointModel} viewPort - provide the viewPort value.
     * @param {Diagram} diagram - provide the diagram model.
     * @private
     */
    HierarchicalLayoutUtil.prototype.doLayout = function (nodes, nameTable, layoutProp, viewPort, diagram) {
        this.nameTable = nameTable;
        var canEnableRouting = layoutProp.enableRouting;
        var layout = {
            horizontalSpacing: layoutProp.horizontalSpacing, verticalSpacing: layoutProp.verticalSpacing,
            orientation: layoutProp.orientation, marginX: layoutProp.margin.left, marginY: layoutProp.margin.top,
            enableLayoutRouting: canEnableRouting
        };
        var model;
        var matrixModel = new MatrixModel();
        matrixModel.edgeMapper = [];
        matrixModel.diagram = diagram;
        var nodeWithMultiEdges = [];
        this.vertices = [];
        var filledVertexSet = {};
        for (var i = 0; i < nodes.length; i++) {
            var node1 = this.nameTable[nodes[parseInt(i.toString(), 10)].id];
            // 941582: ExcludeFromLayout Option Not Supported in Complex Hierarchical Tree
            if (!node1.excludeFromLayout) {
                var node = this.createVertex(nodes[parseInt(i.toString(), 10)], nodes[parseInt(i.toString(), 10)].id, 0, 0, nodes[parseInt(i.toString(), 10)].actualSize.width, nodes[parseInt(i.toString(), 10)].actualSize.height);
                this.vertices.push(node);
                if (nodes[parseInt(i.toString(), 10)].inEdges.length > 0
                    || nodes[parseInt(i.toString(), 10)].outEdges.length > 0) {
                    nodeWithMultiEdges.push(nodes[parseInt(i.toString(), 10)]);
                }
                filledVertexSet[node.name] = node;
                if (matrixModel) {
                    var outEdges = nodes[parseInt(i.toString(), 10)].outEdges.slice();
                    for (var j = 0; j < outEdges.length; j++) {
                        var outEdge = nameTable[outEdges[parseInt(j.toString(), 10)]];
                        matrixModel.setEdgeMapper({ key: outEdge, value: [] });
                    }
                }
            }
        }
        var hierarchyVertices = [];
        //let candidateRoots: Vertex[];
        var candidateRoots = this.findRoots(filledVertexSet);
        for (var i = 0; i < candidateRoots.length; i++) {
            var vertexSet = {};
            hierarchyVertices.push(vertexSet);
            this.traverse(candidateRoots[parseInt(i.toString(), 10)], true, null, vertexSet, hierarchyVertices, filledVertexSet);
        }
        var limit = { marginX: 0, marginY: 0 };
        var tmp = [];
        var checkLinear = false;
        var matrixModelObject;
        for (var i = 0; i < hierarchyVertices.length; i++) {
            var vertexSet = hierarchyVertices[parseInt(i.toString(), 10)];
            // eslint-disable-next-line
            for (var _i = 0, _a = Object.keys(vertexSet); _i < _a.length; _i++) {
                var key = _a[_i];
                tmp.push(vertexSet["" + key]);
            }
            if ((layoutProp.arrangement === 'Linear' && i === hierarchyVertices.length - 1) || canEnableRouting) {
                checkLinear = true;
            }
            model = new MultiParentModel(this, tmp, candidateRoots, layout);
            this.cycleStage(model);
            this.layeringStage(model);
            //897503: Child Nodes position in ComplexHierarchicalTree updated wrongly results in connector overlap
            if ((matrixModel && layoutProp.connectionPointOrigin === 'DifferentPoint') || checkLinear) {
                matrixModelObject = { model: model, matrix: [], rowOffset: [], roots: [] };
                matrixModel.arrangeElements(matrixModelObject, layoutProp);
                layoutProp.ranks = matrixModelObject.model.ranks;
            }
            else {
                if (layoutProp.arrangement === 'Nonlinear') {
                    this.crossingStage(model);
                    limit = this.placementStage(model, limit.marginX, limit.marginY);
                    tmp = [];
                }
            }
        }
        var modelBounds = this.getModelBounds(this.vertices);
        this.updateMargin(layoutProp, layout, modelBounds, viewPort);
        for (var i = 0; i < this.vertices.length; i++) {
            var clnode = this.vertices[parseInt(i.toString(), 10)];
            if (clnode) { //Check what is node.source/node.target -  && !clnode.source && !clnode.target) {
                var dnode = this.nameTable[clnode.name];
                dnode.offsetX = 0;
                dnode.offsetY = 0;
                //initialize layout
                var dx = (clnode.geometry.x - (dnode.offsetX - (dnode.actualSize.width / 2))) + layout.marginX;
                var dy = (clnode.geometry.y - (dnode.offsetY - (dnode.actualSize.height / 2))) + layout.marginY;
                var x = dx;
                var y = dy;
                if (layout.orientation === 'BottomToTop') {
                    if (canEnableRouting) {
                        clnode.geometry.y = modelBounds.height - dy - dnode.actualSize.height / 2;
                    }
                    y = modelBounds.height - dy;
                }
                else if (layout.orientation === 'RightToLeft') {
                    x = modelBounds.width - dx;
                }
                dnode.offsetX += x - dnode.offsetX;
                dnode.offsetY += y - dnode.offsetY;
                matrixModel.nodePropertyChange(dnode);
            }
        }
        if (!checkLinear) {
            for (var i = 0; i < this.vertices.length; i++) {
                this.isNodeOverLap(this.nameTable[this.vertices[parseInt(i.toString(), 10)].name], layoutProp);
            }
        }
        matrixModel.updateLayout(viewPort, modelBounds, layoutProp, layout, nodeWithMultiEdges, nameTable);
        if (canEnableRouting) {
            var vertices = {};
            var matrixrow1 = void 0;
            for (var p = 0; p < matrixModelObject.matrix.length; p++) {
                matrixrow1 = matrixModelObject.matrix[parseInt(p.toString(), 10)].value;
                for (var q = 0; q < matrixrow1.length; q++) {
                    var matrixCell = matrixrow1[parseInt(q.toString(), 10)];
                    for (var r = 0; r < matrixCell.cells.length; r++) {
                        var cell = matrixCell.cells[parseInt(r.toString(), 10)];
                        var type = this.getType(cell.type);
                        if (type === 'internalVertex') {
                            var internalVertex = cell;
                            vertices[internalVertex.id] = internalVertex;
                        }
                    }
                }
            }
            this.updateRankValuess(model);
            for (var i = 0, a = Object.keys(vertices); i < a.length; i++) {
                var key = a[parseInt(i.toString(), 10)];
                this.setVertexLocationValue(vertices["" + key], layoutProp.orientation, modelBounds);
            }
            this.localEdgeProcessing(model, vertices);
            this.assignRankOffset(model);
            this.updateEdgeSetXYValue(model);
            var edges = this.getValues(model.edgeMapper);
            for (var i = 0; i < edges.length; i++) {
                if ((edges[parseInt(i.toString(), 10)]).x.length > 0) {
                    for (var j = 0; j < (edges[parseInt(i.toString(), 10)]).x.length; j++) {
                        if (layoutProp.orientation !== 'RightToLeft' && layoutProp.orientation !== 'LeftToRight') {
                            (edges[parseInt(i.toString(), 10)]).x[parseInt(j.toString(), 10)]
                                = (edges[parseInt(i.toString(), 10)]).x[parseInt(j.toString(), 10)] + layout.marginX;
                        }
                        else if (layoutProp.orientation === 'LeftToRight') {
                            (edges[parseInt(i.toString(), 10)]).x[parseInt(j.toString(), 10)]
                                = (edges[parseInt(i.toString(), 10)]).x[parseInt(j.toString(), 10)] + layoutProp.verticalSpacing / 2;
                        }
                        else {
                            (edges[parseInt(i.toString(), 10)]).x[parseInt(j.toString(), 10)]
                                = (edges[parseInt(i.toString(), 10)]).x[parseInt(j.toString(), 10)] + layoutProp.verticalSpacing / 2;
                        }
                    }
                }
                this.setEdgePosition(edges[parseInt(i.toString(), 10)], model, layout);
            }
            for (var p = 0; p < this.vertices.length; p++) {
                var clnode = this.vertices[parseInt(p.toString(), 10)];
                if (clnode.outEdges.length > 1) {
                    this.updateMultiOutEdgesPoints(clnode);
                }
            }
        }
    };
    HierarchicalLayoutUtil.prototype.setEdgeXY = function (ranks, node, spacing, layer) {
        if (ranks && node.source.id) {
            var targetValue = void 0;
            var sourceValue = void 0;
            for (var i = 0; i < ranks.length; i++) {
                for (var k = 0; k < ranks[parseInt(i.toString(), 10)].length; k++) {
                    if (ranks[parseInt(i.toString(), 10)][parseInt(k.toString(), 10)].id === node.target.id
                        || ranks[parseInt(i.toString(), 10)][parseInt(k.toString(), 10)].id === node.source.id) {
                        if (ranks[parseInt(i.toString(), 10)][parseInt(k.toString(), 10)].id === node.target.id
                            && targetValue === undefined) {
                            targetValue = i;
                        }
                        if (ranks[parseInt(i.toString(), 10)][parseInt(k.toString(), 10)].id === node.source.id
                            && sourceValue === undefined) {
                            sourceValue = i;
                        }
                    }
                }
            }
            var rankOffsetValue = void 0;
            for (var m = targetValue; m <= sourceValue; m++) {
                if (rankOffsetValue === undefined) {
                    rankOffsetValue = this[m + '_RankOffset'];
                }
                if (rankOffsetValue !== undefined && rankOffsetValue < this[m + '_RankOffset']) {
                    rankOffsetValue = this[m + '_RankOffset'];
                }
            }
            if (this['edges'] === undefined) {
                this['edges'] = {};
            }
            this['edges'][(node).ids[0]] = { x: node.x, y: 0 };
            var value = this.resetOffsetXValue(rankOffsetValue, spacing / 10);
            node.x[layer - node.minRank - 1] = value;
            for (var k = 0; k < (node).edges.length; k++) {
                (node).edges[parseInt(k.toString(), 10)]['levelSkip'] = true;
            }
        }
    };
    HierarchicalLayoutUtil.prototype.resetOffsetXValue = function (value, spacing) {
        for (var i = 0, a = Object.keys(this['edges']); i < a.length; i++) {
            var key = a[parseInt(i.toString(), 10)];
            var length_1 = this['edges']["" + key].x;
            for (var j = 0; j < length_1.length; j++) {
                var offsetValue = void 0;
                if (this['edges']["" + key].x[parseInt(j.toString(), 10)] === value) {
                    offsetValue = value + spacing;
                    offsetValue = this.resetOffsetXValue(offsetValue, spacing);
                    return offsetValue;
                }
            }
        }
        return value;
    };
    HierarchicalLayoutUtil.prototype.setEdgePosition = function (cell, model, layout) {
        // For parallel edges we need to seperate out the points a
        // little
        var offsetX = 0;
        // Only set the edge control points once
        if (cell.temp[0] !== 101207) {
            if (cell.maxRank === undefined) {
                cell.maxRank = -1;
            }
            if (cell.minRank === undefined) {
                cell.minRank = -1;
            }
            var maxRank = cell.maxRank;
            var minRank = cell.minRank;
            if (maxRank === minRank) {
                maxRank = cell.source.maxRank;
                minRank = cell.target.minRank;
            }
            var parallelEdgeCount = 0;
            var jettys = this.jettyPositions[cell.ids[0]];
            if (cell.isReversed === undefined) {
                cell.isReversed = false;
            }
            else {
                cell.isReversed = true;
            }
            var source = cell.isReversed ? cell.target.cell : cell.source.cell;
            var layoutReversed = false;
            if (model.layout.orientation === 'TopToBottom' || model.layout.orientation === 'LeftToRight') {
                if (model.layout.orientation === 'TopToBottom') {
                    layoutReversed = false;
                }
                if (model.layout.orientation === 'LeftToRight') {
                    if (!cell.isReversed) {
                        layoutReversed = false;
                    }
                    else {
                        layoutReversed = false;
                    }
                }
            }
            else {
                if (!cell.isReversed) {
                    layoutReversed = true;
                }
            }
            for (var i = 0; i < cell.edges.length; i++) {
                var realEdge = cell.edges[parseInt(i.toString(), 10)];
                var realSource = this.getVisibleTerminal(realEdge, true);
                //List oldPoints = graph.getPoints(realEdge);
                var newPoints = [];
                // Single length reversed edges end up with the jettys in the wrong
                // places. Since single length edges only have jettys, not segment
                // control points, we just say the edge isn't reversed in this section
                var reversed = cell.isReversed;
                // if(cell.isReversed===undefined){
                //     reversed = false
                // }else{
                //     reversed =cell.isReversed
                // }
                if (realSource !== source) {
                    // The real edges include all core model edges and these can go
                    // in both directions. If the source of the hierarchical model edge
                    // isn't the source of the specific real edge in this iteration
                    // treat if as reversed
                    reversed = !reversed;
                }
                // First jetty of edge
                if (jettys != null) {
                    var arrayOffset = reversed ? 2 : 0;
                    var y = reversed ?
                        (layoutReversed ? this.rankBottomY[parseInt(minRank.toString(), 10)]
                            : this.rankTopY[parseInt(minRank.toString(), 10)])
                        : (layoutReversed ? this.rankTopY[parseInt(maxRank.toString(), 10)]
                            : this.rankBottomY[parseInt(maxRank.toString(), 10)]);
                    var jetty = jettys[parallelEdgeCount * 4 + 1 + arrayOffset];
                    if (reversed !== layoutReversed) {
                        jetty = -jetty;
                    }
                    if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {
                        y += jetty;
                    }
                    var x = jettys[parallelEdgeCount * 4 + arrayOffset];
                    if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {
                        newPoints.push(this.getPointvalue(x, y + layout.marginY));
                    }
                    else {
                        if (layout.orientation === 'LeftToRight') {
                            newPoints.push(this.getPointvalue(y + jetty, x + layout.marginY));
                        }
                        else {
                            newPoints.push(this.getPointvalue(y, x + layout.marginY));
                        }
                    }
                }
                var loopStart = cell.x.length - 1;
                var loopLimit = -1;
                var loopDelta = -1;
                var currentRank = cell.maxRank - 1;
                if (reversed) {
                    loopStart = 0;
                    loopLimit = cell.x.length;
                    loopDelta = 1;
                    currentRank = cell.minRank + 1;
                }
                // Reversed edges need the points inserted in
                // reverse order
                for (var j = loopStart; (cell.maxRank !== cell.minRank) && j !== loopLimit; j += loopDelta) {
                    // The horizontal position in a vertical layout
                    var positionX = cell.x[parseInt(j.toString(), 10)] + offsetX;
                    // This cell.x determines the deviated points of the connectors and jetty positions
                    //determine the src and targetgeo points .
                    // Work out the vertical positions in a vertical layout
                    // in the edge buffer channels above and below this rank
                    var topChannelY = (this.rankTopY[parseInt(currentRank.toString(), 10)]
                        + this.rankBottomY[currentRank + 1]) / 2.0;
                    var bottomChannelY = (this.rankTopY[currentRank - 1]
                        + this.rankBottomY[parseInt(currentRank.toString(), 10)]) / 2.0;
                    if (reversed) {
                        var tmp = topChannelY;
                        topChannelY = bottomChannelY;
                        bottomChannelY = tmp;
                    }
                    if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {
                        newPoints.push(this.getPointvalue(positionX, topChannelY + layout.marginY));
                        newPoints.push(this.getPointvalue(positionX, bottomChannelY + layout.marginY));
                    }
                    else {
                        newPoints.push(this.getPointvalue(topChannelY, positionX + layout.marginY));
                        newPoints.push(this.getPointvalue(bottomChannelY, positionX + layout.marginY));
                    }
                    this.limitX = Math.max(this.limitX, positionX);
                    currentRank += loopDelta;
                }
                // Second jetty of edge
                if (jettys != null) {
                    var arrayOffset = reversed ? 2 : 0;
                    var rankY = reversed ?
                        (layoutReversed ? this.rankTopY[parseInt(maxRank.toString(), 10)]
                            : this.rankBottomY[parseInt(maxRank.toString(), 10)])
                        : (layoutReversed ? this.rankBottomY[parseInt(minRank.toString(), 10)]
                            : this.rankTopY[parseInt(minRank.toString(), 10)]);
                    var jetty = jettys[parallelEdgeCount * 4 + 3 - arrayOffset];
                    if (reversed !== layoutReversed) {
                        jetty = -jetty;
                    }
                    var y = rankY - jetty;
                    var x = jettys[parallelEdgeCount * 4 + 2 - arrayOffset];
                    if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {
                        newPoints.push(this.getPointvalue(x, y + layout.marginY));
                    }
                    else {
                        newPoints.push(this.getPointvalue(y, x + layout.marginY));
                    }
                }
                this.setEdgePoints(realEdge, newPoints, model);
                // Increase offset so next edge is drawn next to
                // this one
                if (offsetX === 0.0) {
                    offsetX = this.parallelEdgeSpacing;
                }
                else if (offsetX > 0) {
                    offsetX = -offsetX;
                }
                else {
                    offsetX = -offsetX + this.parallelEdgeSpacing;
                }
                parallelEdgeCount++;
            }
            cell.temp[0] = 101207;
        }
    };
    /* tslint:enable */
    // eslint-disable-next-line
    HierarchicalLayoutUtil.prototype.getPointvalue = function (x, y) {
        return { 'x': Number(x) || 0, 'y': Number(y) || 0 };
    };
    HierarchicalLayoutUtil.prototype.updateEdgeSetXYValue = function (model) {
        if (model.layout.enableLayoutRouting) {
            var isHorizontal = false;
            if (model.layout.orientation === 'LeftToRight' || model.layout.orientation === 'RightToLeft') {
                isHorizontal = true;
            }
            for (var i = 0; i < model.ranks.length; i++) {
                var rank = model.ranks[parseInt(i.toString(), 10)];
                for (var k = 0; k < rank.length; k++) {
                    var cell = rank[parseInt(k.toString(), 10)];
                    if ((cell).edges && (cell).edges.length > 0) {
                        var spacing = model.layout.horizontalSpacing > 0 ? (model.layout.horizontalSpacing / 2) : 15;
                        var check = true;
                        if (!(cell.minRank === i - 1 || cell.maxRank === i - 1)) {
                            check = false;
                        }
                        if (check) {
                            this.setXY(cell, i, undefined, isHorizontal ? true : false, model.ranks, spacing);
                        }
                    }
                }
            }
        }
    };
    HierarchicalLayoutUtil.prototype.getPreviousLayerConnectedCells = function (layer, cell) {
        if (cell.previousLayerConnectedCells == null) {
            cell.previousLayerConnectedCells = [];
            cell.previousLayerConnectedCells[0] = [];
            for (var i = 0; i < cell.connectsAsSource.length; i++) {
                var edge = cell.connectsAsSource[parseInt(i.toString(), 10)];
                if (edge.minRank === -1 || edge.minRank === layer - 1) {
                    // No dummy nodes in edge, add node of other side of edge
                    cell.previousLayerConnectedCells[0].push(edge.target);
                }
                else {
                    // Edge spans at least two layers, add edge
                    cell.previousLayerConnectedCells[0].push(edge);
                }
            }
        }
        return cell.previousLayerConnectedCells[0];
    };
    HierarchicalLayoutUtil.prototype.compare = function (a, b) {
        if (a != null && b != null) {
            if (b.weightedValue > a.weightedValue) {
                return -1;
            }
            else if (b.weightedValue < a.weightedValue) {
                return 1;
            }
        }
        return 0;
    };
    /* tslint:disable */
    // eslint-disable-next-line
    HierarchicalLayoutUtil.prototype.localEdgeProcessing = function (model, vertices) {
        // Iterate through each vertex, look at the edges connected in
        // both directions.
        for (var rankIndex = 0; rankIndex < model.ranks.length; rankIndex++) {
            var rank = model.ranks[parseInt(rankIndex.toString(), 10)];
            for (var cellIndex = 0; cellIndex < rank.length; cellIndex++) {
                var cell = rank[parseInt(cellIndex.toString(), 10)];
                if (this.crossReduction.isVertex(cell)) {
                    var currentCells = this.getPreviousLayerConnectedCells(rankIndex, cell);
                    var currentRank = rankIndex - 1;
                    // Two loops, last connected cells, and next
                    for (var k = 0; k < 2; k++) {
                        if (currentRank > -1
                            && currentRank < model.ranks.length
                            && currentCells != null
                            && currentCells.length > 0) {
                            var sortedCells = [];
                            for (var j = 0; j < currentCells.length; j++) {
                                var sorter = this.weightedCellSorter(currentCells[parseInt(j.toString(), 10)], this.getX(currentRank, currentCells[parseInt(j.toString(), 10)]));
                                sortedCells.push(sorter);
                            }
                            sortedCells.sort(this.compare);
                            cell.width = vertices[cell.id].cell.geometry.width;
                            cell.height = vertices[cell.id].cell.geometry.height;
                            var leftLimit = void 0;
                            if (model.layout.orientation === 'TopToBottom' || model.layout.orientation === 'BottomToTop') {
                                cell.x[0] = vertices[cell.id].cell.geometry.x + vertices[cell.id].cell.geometry.width / 2;
                                leftLimit = cell.x[0] - cell.width / 2 + vertices[cell.id].cell.geometry.height / 2;
                            }
                            else {
                                cell.x[0] = vertices[cell.id].cell.geometry.y;
                                leftLimit = cell.x[0];
                            }
                            var rightLimit = leftLimit + cell.width;
                            // Connected edge count starts at 1 to allow for buffer
                            // with edge of vertex
                            var connectedEdgeCount = 0;
                            var connectedEdges = [];
                            // Calculate width requirements for all connected edges
                            for (var j = 0; j < sortedCells.length; j++) {
                                var innerCell = sortedCells[parseInt(j.toString(), 10)].cell;
                                var connections = void 0;
                                if (this.crossReduction.isVertex(innerCell)) {
                                    // Get the connecting edge
                                    if (k === 0) {
                                        connections = cell.connectsAsSource;
                                    }
                                    else {
                                        connections = cell.connectsAsTarget;
                                    }
                                    for (var connIndex = 0; connIndex < connections.length; connIndex++) {
                                        if (connections[parseInt(connIndex.toString(), 10)].source === innerCell
                                            || connections[parseInt(connIndex.toString(), 10)].target === innerCell) {
                                            connectedEdgeCount += connections[parseInt(connIndex.toString(), 10)].edges
                                                .length;
                                            connectedEdges.push(connections[parseInt(connIndex.toString(), 10)]);
                                        }
                                    }
                                }
                                else {
                                    connectedEdgeCount += innerCell.edges.length;
                                    connectedEdges.push(innerCell);
                                }
                            }
                            var requiredWidth = (connectedEdgeCount + 1)
                                * this.previousEdgeDistance;
                            // Add a buffer on the edges of the vertex if the edge count allows
                            if (cell.width > requiredWidth
                                + (2 * this.previousEdgeDistance)) {
                                leftLimit += this.previousEdgeDistance;
                                rightLimit -= this.previousEdgeDistance;
                            }
                            var availableWidth = rightLimit - leftLimit;
                            var edgeSpacing = availableWidth / connectedEdgeCount;
                            var currentX = leftLimit + edgeSpacing / 2.0;
                            var currentYOffset = this.minEdgeJetty - this.previousEdgeOffset;
                            for (var j = 0; j < connectedEdges.length; j++) {
                                var numActualEdges = connectedEdges[parseInt(j.toString(), 10)].edges
                                    .length;
                                if (this.jettyPositions === undefined) {
                                    this.jettyPositions = {};
                                }
                                var pos = this.jettyPositions[connectedEdges[parseInt(j.toString(), 10)].ids[0]];
                                if (pos == null) {
                                    pos = [];
                                    this.jettyPositions[connectedEdges[parseInt(j.toString(), 10)].ids[0]] = pos;
                                }
                                if (j < connectedEdgeCount / 2) {
                                    currentYOffset += this.previousEdgeOffset;
                                }
                                else if (j > connectedEdgeCount / 2) {
                                    currentYOffset -= this.previousEdgeOffset;
                                }
                                // Ignore the case if equals, this means the second of 2
                                // jettys with the same y (even number of edges)
                                for (var m = 0; m < numActualEdges; m++) {
                                    pos[m * 4 + k * 2] = currentX;
                                    currentX += edgeSpacing;
                                    pos[m * 4 + k * 2 + 1] = currentYOffset;
                                }
                            }
                        }
                        currentCells = this.getNextLayerConnectedCells(rankIndex, cell);
                        currentRank = rankIndex + 1;
                    }
                }
            }
        }
    };
    /* tslint:enable */
    HierarchicalLayoutUtil.prototype.updateMultiOutEdgesPoints = function (clnode) {
        for (var i = 0; i < clnode.outEdges.length / 2; i++) {
            var connector1 = this.nameTable[clnode.outEdges[parseInt(i.toString(), 10)]];
            var connector2 = this.nameTable[clnode.outEdges[clnode.outEdges.length - (i + 1)]];
            var geometry = 'geometry';
            //900930: To exclude self-loop in layouts
            if (connector1.sourceID !== connector2.targetID && connector1.targetID !== connector2.sourceID) {
                connector2["" + geometry].points[0].y = connector1["" + geometry].points[0].y;
            }
        }
    };
    HierarchicalLayoutUtil.prototype.getNextLayerConnectedCells = function (layer, cell) {
        if (cell.nextLayerConnectedCells == null) {
            cell.nextLayerConnectedCells = [];
            cell.nextLayerConnectedCells[0] = [];
            for (var i = 0; i < cell.connectsAsTarget.length; i++) {
                var edge = cell.connectsAsTarget[parseInt(i.toString(), 10)];
                if (edge.maxRank === -1 || edge.maxRank === layer + 1) {
                    // Either edge is not in any rank or
                    // no dummy nodes in edge, add node of other side of edge
                    cell.nextLayerConnectedCells[0].push(edge.source);
                }
                else {
                    // Edge spans at least two layers, add edge
                    cell.nextLayerConnectedCells[0].push(edge);
                }
            }
        }
        return cell.nextLayerConnectedCells[0];
    };
    HierarchicalLayoutUtil.prototype.getX = function (layer, cell) {
        if (this.crossReduction.isVertex(cell)) {
            return cell.x[0];
        }
        else if (!this.crossReduction.isVertex(cell)) {
            return cell.x[layer - cell.minRank - 1] || cell.temp[layer - cell.minRank - 1];
        }
        return 0.0;
    };
    HierarchicalLayoutUtil.prototype.getGeometry = function (edge) {
        var geometry = 'geometry';
        return edge["" + geometry];
    };
    HierarchicalLayoutUtil.prototype.setEdgePoints = function (edge, points, model) {
        if (edge != null) {
            var geometryValue = 'geometry';
            var geometry = this.getGeometry(edge);
            if (points != null) {
                for (var i = 0; i < points.length; i++) {
                    // eslint-disable-next-line
                    points[i].x = points[i].x;
                    // eslint-disable-next-line
                    points[i].y = points[i].y;
                }
            }
            geometry.points = points;
            edge["" + geometryValue] = geometry;
        }
    };
    HierarchicalLayoutUtil.prototype.assignRankOffset = function (model) {
        if (model) {
            for (var i = 0; i < model.ranks.length; i++) {
                this.rankCoordinatesAssigment(i, model);
            }
        }
    };
    HierarchicalLayoutUtil.prototype.rankCoordinatesAssigment = function (rankValue, model) {
        var rank = model.ranks[parseInt(rankValue.toString(), 10)];
        var spacing = model.layout.horizontalSpacing;
        var localOffset;
        for (var i = 0; i < rank.length; i++) {
            if (this[rankValue + '_' + 'RankOffset'] === undefined) {
                this[rankValue + '_' + 'RankOffset'] = 0;
            }
            localOffset = rank[parseInt(i.toString(), 10)].x[0];
            if (this[rankValue + '_' + 'RankOffset'] < localOffset) {
                this[rankValue + '_' + 'RankOffset'] = localOffset + rank[parseInt(i.toString(), 10)].width / 2 + spacing;
            }
        }
    };
    HierarchicalLayoutUtil.prototype.getType = function (type) {
        if (type === 'internalVertex') {
            return 'internalVertex';
        }
        else {
            return 'internalEdge';
        }
    };
    HierarchicalLayoutUtil.prototype.updateRankValuess = function (model) {
        this.rankTopY = [];
        this.rankBottomY = [];
        for (var i = 0; i < model.ranks.length; i++) {
            this.rankTopY[parseInt(i.toString(), 10)] = Number.MAX_VALUE;
            this.rankBottomY[parseInt(i.toString(), 10)] = -Number.MAX_VALUE;
        }
    };
    HierarchicalLayoutUtil.prototype.setVertexLocationValue = function (cell, orientation, modelBounds) {
        var cellGeomtry = cell.cell.geometry;
        var positionX;
        var positionY;
        if (orientation === 'TopToBottom' || orientation === 'BottomToTop') {
            positionX = cellGeomtry.x;
            positionY = cellGeomtry.y;
        }
        else {
            positionX = cellGeomtry.y;
            positionY = cellGeomtry.x;
        }
        if (orientation === 'RightToLeft') {
            // eslint-disable-next-line
            positionX = cellGeomtry.y;
            positionY = modelBounds.width - cellGeomtry.x - cellGeomtry.height;
            this.rankBottomY[cell.minRank] = Math.max(this.rankBottomY[cell.minRank], positionY);
            this.rankTopY[cell.minRank] = Math.min(this.rankTopY[cell.minRank], positionY + cellGeomtry.height);
        }
        else {
            this.rankTopY[cell.minRank] = Math.min(this.rankTopY[cell.minRank], positionY);
            this.rankBottomY[cell.minRank] = Math.max(this.rankBottomY[cell.minRank], positionY + cellGeomtry.height);
        }
    };
    HierarchicalLayoutUtil.prototype.calculateRectValue = function (dnode) {
        var rect = { x: 0, y: 0, right: 0, bottom: 0, height: 0, width: 0 };
        rect.x = dnode.offsetX - dnode.actualSize.width / 2;
        rect.right = dnode.offsetX + dnode.actualSize.width / 2;
        rect.y = dnode.offsetY - dnode.actualSize.height / 2;
        rect.bottom = dnode.offsetY + dnode.actualSize.height / 2;
        return rect;
    };
    HierarchicalLayoutUtil.prototype.isNodeOverLap = function (dnode, layoutProp) {
        var nodeRect = { x: 0, y: 0, right: 0, bottom: 0, height: 0, width: 0 };
        for (var i = 0; i < this.vertices.length; i++) {
            var rect = { x: 0, y: 0, width: 0, height: 0 };
            //let tempnode1: INode;
            var tempnode1 = this.nameTable[this.vertices[parseInt(i.toString(), 10)].value];
            if (dnode.id !== tempnode1.id && tempnode1.offsetX !== 0 && tempnode1.offsetY !== 0) {
                nodeRect = this.calculateRectValue(dnode);
                rect = this.calculateRectValue(tempnode1);
                if (this.isIntersect(rect, nodeRect, layoutProp)) {
                    if (layoutProp.orientation === 'TopToBottom' || layoutProp.orientation === 'BottomToTop') {
                        dnode.offsetX += layoutProp.horizontalSpacing;
                    }
                    else {
                        dnode.offsetY += layoutProp.verticalSpacing;
                    }
                    this.isNodeOverLap(dnode, layoutProp);
                }
            }
        }
    };
    HierarchicalLayoutUtil.prototype.isIntersect = function (rect, nodeRect, layoutProp) {
        if (!(Math.floor(rect.right + layoutProp.horizontalSpacing) <= Math.floor(nodeRect.x) ||
            Math.floor(rect.x - layoutProp.horizontalSpacing) >= Math.floor(nodeRect.right)
            || Math.floor(rect.y - layoutProp.verticalSpacing) >= Math.floor(nodeRect.bottom)
            || Math.floor(rect.bottom + layoutProp.verticalSpacing) <= Math.floor(nodeRect.y))) {
            return true;
        }
        else {
            return false;
        }
    };
    /* eslint-disable */
    HierarchicalLayoutUtil.prototype.updateMargin = function (layoutProp, layout, modelBounds, viewPort) {
        var viewPortBounds = { x: 0, y: 0, width: viewPort.x, height: viewPort.y };
        //let layoutBounds: Rect;
        var bounds = {
            x: modelBounds.x, y: modelBounds.y,
            right: modelBounds.x + modelBounds.width,
            bottom: modelBounds.y + modelBounds.height
        };
        var layoutBounds = layoutProp.bounds ? layoutProp.bounds : viewPortBounds;
        if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {
            switch (layoutProp.horizontalAlignment) {
                case 'Auto':
                case 'Left':
                    layout.marginX = (layoutBounds.x - bounds.x) + layoutProp.margin.left;
                    break;
                case 'Right':
                    layout.marginX = layoutBounds.x + layoutBounds.width - layoutProp.margin.right - bounds.right;
                    break;
                case 'Center':
                    layout.marginX = layoutBounds.x + layoutBounds.width / 2 - (bounds.x + bounds.right) / 2;
                    break;
            }
            switch (layoutProp.verticalAlignment) {
                case 'Top':
                    //const top: number;
                    var top_1 = layoutBounds.y + layoutProp.margin.top;
                    layout.marginY = layout.orientation === 'TopToBottom' ? top_1 : -top_1;
                    break;
                case 'Bottom':
                    //const bottom: number;
                    var bottom = layoutBounds.y + layoutBounds.height - layoutProp.margin.bottom;
                    layout.marginY = layout.orientation === 'TopToBottom' ? bottom - bounds.bottom : -(bottom - bounds.bottom);
                    break;
                case 'Auto':
                case 'Center':
                    //const center: number;
                    var center = layoutBounds.y + layoutBounds.height / 2;
                    layout.marginY = layout.orientation === 'TopToBottom' ?
                        center - (bounds.y + bounds.bottom) / 2 : -center + (bounds.y + bounds.bottom) / 2;
                    break;
            }
        }
        else {
            switch (layoutProp.horizontalAlignment) {
                case 'Auto':
                case 'Left':
                    //let left: number;
                    var left = layoutBounds.x + layoutProp.margin.left;
                    layout.marginX = layout.orientation === 'LeftToRight' ? left : -left;
                    break;
                case 'Right':
                    var right = void 0;
                    right = layoutBounds.x + layoutBounds.width - layoutProp.margin.right;
                    layout.marginX = layout.orientation === 'LeftToRight' ? right - bounds.right : bounds.right - right;
                    break;
                case 'Center':
                    var center = void 0;
                    center = layoutBounds.width / 2 + layoutBounds.x;
                    layout.marginX = layout.orientation === 'LeftToRight' ?
                        center - (bounds.y + bounds.bottom) / 2 : -center + (bounds.x + bounds.right) / 2;
                    break;
            }
            switch (layoutProp.verticalAlignment) {
                case 'Top':
                    layout.marginY = layoutBounds.y + layoutProp.margin.top - bounds.y;
                    break;
                case 'Auto':
                case 'Center':
                    layout.marginY = layoutBounds.y + layoutBounds.height / 2 - (bounds.y + bounds.bottom) / 2;
                    break;
                case 'Bottom':
                    layout.marginY = layoutBounds.y + layoutBounds.height - layoutProp.margin.bottom - bounds.bottom;
                    break;
            }
        }
    };
    /* eslint-enable */
    //Handles positioning the nodes
    HierarchicalLayoutUtil.prototype.placementStage = function (model, marginX, marginY) {
        var placementStage = this.coordinateAssignment(marginX, marginY, parent, model);
        placementStage.model = model;
        placementStage.widestRankValue = null;
        this.placementStageExecute(placementStage);
        return {
            marginX: placementStage.marginX + model.layout.horizontalSpacing,
            marginY: placementStage.marginY + model.layout.verticalSpacing
        };
    };
    //Initializes the layout properties for positioning
    HierarchicalLayoutUtil.prototype.coordinateAssignment = function (marginX, marginY, parent, model) {
        var plalementChange = {};
        if (model.layout.orientation === 'TopToBottom' || model.layout.orientation === 'BottomToTop') {
            plalementChange.horizontalSpacing = model.layout.horizontalSpacing;
            plalementChange.verticalSpacing = model.layout.verticalSpacing;
        }
        else {
            plalementChange.horizontalSpacing = model.layout.verticalSpacing;
            plalementChange.verticalSpacing = model.layout.horizontalSpacing;
        }
        plalementChange.orientation = 'north';
        //Removed the conditions here. So check here in case of any issue
        plalementChange.marginX = plalementChange.marginX = marginX;
        plalementChange.marginY = plalementChange.marginY = marginY;
        return plalementChange;
    };
    //Calculate the largest size of the node either height or width depends upon the layoutorientation
    HierarchicalLayoutUtil.prototype.calculateWidestRank = function (plalementChange, graph, model) {
        var isHorizontal = false;
        if (plalementChange.model.layout.orientation === 'LeftToRight' || plalementChange.model.layout.orientation === 'RightToLeft') {
            isHorizontal = true;
        }
        var offset = -plalementChange.verticalSpacing;
        var lastRankMaxCellSize = 0.0;
        plalementChange.rankSizes = [];
        plalementChange.rankOffset = [];
        for (var rankValue = model.maxRank; rankValue >= 0; rankValue--) {
            var maxCellSize = 0.0;
            var rank = model.ranks[parseInt(rankValue.toString(), 10)];
            var localOffset = isHorizontal ? plalementChange.marginY : plalementChange.marginX;
            for (var i = 0; i < rank.length; i++) {
                var node = rank[parseInt(i.toString(), 10)];
                if (this.crossReduction.isVertex(node)) {
                    var vertex = node;
                    if (vertex.cell && (vertex.cell.inEdges || vertex.cell.outEdges)) {
                        var obj = this.nameTable[vertex.cell.name];
                        vertex.width = obj.actualSize.width;
                        vertex.height = obj.actualSize.height;
                        maxCellSize = Math.max(maxCellSize, (isHorizontal ? vertex.width : vertex.height));
                    }
                }
                else {
                    if (node) {
                        var edge = node;
                        var numEdges = 1;
                        if (edge.edges != null) {
                            numEdges = edge.edges.length;
                        }
                        node.width = (numEdges - 1) * 10;
                    }
                }
                if (isHorizontal) {
                    if (!node.height) {
                        node.height = 0;
                    }
                }
                // Set the initial x-value as being the best result so far
                localOffset += (isHorizontal ? node.height : node.width) / 2.0;
                this.setXY(node, rankValue, localOffset, isHorizontal ? true : false);
                this.setTempVariable(node, rankValue, localOffset);
                localOffset += ((isHorizontal ? node.height : node.width) / 2.0) + plalementChange.horizontalSpacing;
                if (localOffset > plalementChange.widestRankValue) {
                    plalementChange.widestRankValue = localOffset;
                    plalementChange.widestRank = rankValue;
                }
                plalementChange.rankSizes[parseInt(rankValue.toString(), 10)] = localOffset;
            }
            plalementChange.rankOffset[parseInt(rankValue.toString(), 10)] = offset;
            var distanceToNextRank = maxCellSize / 2.0 + lastRankMaxCellSize / 2.0 + plalementChange.verticalSpacing;
            lastRankMaxCellSize = maxCellSize;
            if (plalementChange.orientation === 'north' || plalementChange.orientation === 'west') {
                offset += distanceToNextRank;
            }
            else {
                offset -= distanceToNextRank;
            }
            for (var i = 0; i < rank.length; i++) {
                var cell = rank[parseInt(i.toString(), 10)];
                this.setXY(cell, rankValue, offset, isHorizontal ? false : true);
            }
        }
    };
    /**
     * Sets the temp position of the node on the layer \
     *
     * @returns {  void }  Sets the temp position of the node on the layer \
     * @param {IVertex} node - provide the nodes value.
     * @param {number} layer - provide the layer value.
     * @param {number} value - provide the value value.
     * @private
     */
    HierarchicalLayoutUtil.prototype.setTempVariable = function (node, layer, value) {
        if (this.crossReduction.isVertex(node)) {
            node.temp[0] = value;
        }
        else {
            node.temp[layer - node.minRank - 1] = value;
        }
    };
    // eslint-disable-next-line valid-jsdoc
    /**
     * setXY method \
     *
     * @returns { void }     setXY method .\
     * @param {IVertex} node - provide the source value.
     * @param {number} layer - provide the target value.
     * @param {number} value - provide the layoutOrientation value.
     * @param {boolean} isY - provide the layoutOrientation value.
     * @param {IVertex[][]} ranks - provide the layoutOrientation value.
     * @param {number} spacing - provide the layoutOrientation value.
     *
     * @private
     */
    HierarchicalLayoutUtil.prototype.setXY = function (node, layer, value, isY, ranks, spacing) {
        if (node && node.cell) {
            if (node.cell.inEdges.length > 0 || node.cell.outEdges.length > 0) {
                if (isY) {
                    node.y[0] = value;
                }
                else {
                    node.x[0] = value;
                }
            }
            else {
                if (isY) {
                    node.y[layer - node.minRank - 1] = value;
                }
                else {
                    node.x[layer - node.minRank - 1] = value;
                }
            }
        }
        else {
            this.setEdgeXY(ranks, node, spacing, layer);
        }
    };
    //Sets geometry position of the layout node on the layout model
    HierarchicalLayoutUtil.prototype.rankCoordinates = function (stage, rankValue, graph, model) {
        var isHorizontal = false;
        if (stage.model.layout.orientation === 'LeftToRight' || stage.model.layout.orientation === 'RightToLeft') {
            isHorizontal = true;
        }
        var rank = model.ranks[parseInt(rankValue.toString(), 10)];
        var maxOffset = 0.0;
        var localOffset = (isHorizontal ? stage.marginY : stage.marginX)
            + (stage.widestRankValue - stage.rankSizes[parseInt(rankValue.toString(), 10)]) / 2;
        for (var i = 0; i < rank.length; i++) {
            var node = rank[parseInt(i.toString(), 10)];
            if (this.crossReduction.isVertex(node)) {
                var obj = this.nameTable[node.cell.name];
                node.width = obj.actualSize.width;
                node.height = obj.actualSize.height;
                maxOffset = Math.max(maxOffset, node.height);
            }
            else {
                var edge = node;
                var numEdges = 1;
                if (edge.edges != null) {
                    numEdges = edge.edges.length;
                }
                if (isHorizontal) {
                    node.height = (numEdges - 1) * 10;
                }
                else {
                    node.width = (numEdges - 1) * 10;
                }
            }
            var size = (isHorizontal ? node.height : node.width) / 2.0;
            localOffset += size;
            this.setXY(node, rankValue, localOffset, isHorizontal ? true : false);
            this.setTempVariable(node, rankValue, localOffset);
            localOffset += (size + stage.horizontalSpacing);
        }
    };
    //sets the layout in an initial positioning.it will arange all the ranks as much as possible
    HierarchicalLayoutUtil.prototype.initialCoords = function (plalementChange, facade, model) {
        this.calculateWidestRank(plalementChange, facade, model);
        // Reverse sweep direction each time from widest rank
        for (var i = plalementChange.widestRank; i >= 0; i--) {
            if (i < model.maxRank) {
                this.rankCoordinates(plalementChange, i, facade, model);
            }
        }
        for (var i = plalementChange.widestRank + 1; i <= model.maxRank; i++) {
            if (i > 0) {
                this.rankCoordinates(plalementChange, i, facade, model);
            }
        }
    };
    /**
     *  Checks whether the given node is an ancestor \
     *
     * @returns {  boolean }  Checks whether the given node is an ancestor \
     * @param {IVertex} node - provide the nodes value.
     * @param {IVertex} otherNode - provide the layer value.
     * @private
     */
    HierarchicalLayoutUtil.prototype.isAncestor = function (node, otherNode) {
        // Firstly, the hash code of this node needs to be shorter than the other node
        if (otherNode != null && node.hashCode != null && otherNode.hashCode != null
            && node.hashCode.length < otherNode.hashCode.length) {
            if (node.hashCode === otherNode.hashCode) {
                return true;
            }
            if (node.hashCode == null || node.hashCode == null) {
                return false;
            }
            for (var i = 0; i < node.hashCode.length; i++) {
                if (node.hashCode[parseInt(i.toString(), 10)] !== otherNode.hashCode[parseInt(i.toString(), 10)]) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };
    //initializes the sorter object
    HierarchicalLayoutUtil.prototype.weightedCellSorter = function (cell, weightedValue) {
        var weightedCellSorter = {};
        weightedCellSorter.cell = cell ? cell : null;
        weightedCellSorter.weightedValue = weightedValue ? weightedValue : 0;
        weightedCellSorter.visited = false;
        weightedCellSorter.rankIndex = null;
        return weightedCellSorter;
    };
    //Performs one node positioning in both directions
    HierarchicalLayoutUtil.prototype.minNode = function (plalementChange, model) {
        var nodeList = [];
        var map = { map: {} };
        var rank = [];
        for (var i = 0; i <= model.maxRank; i++) {
            rank[parseInt(i.toString(), 10)] = model.ranks[parseInt(i.toString(), 10)];
            for (var j = 0; j < rank[parseInt(i.toString(), 10)].length; j++) {
                var node = rank[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)];
                var nodeWrapper = this.weightedCellSorter(node, i);
                nodeWrapper.rankIndex = j;
                nodeWrapper.visited = true;
                nodeList.push(nodeWrapper);
                model.setDictionaryForSorter(map, node, nodeWrapper, true);
            }
        }
        var maxTries = nodeList.length * 10;
        var count = 0;
        var tolerance = 1;
        while (nodeList.length > 0 && count <= maxTries) {
            var cellWrapper = nodeList.shift();
            var cell = cellWrapper.cell;
            var rankValue = cellWrapper.weightedValue;
            var rankIndex = cellWrapper.rankIndex;
            var nextLayerConnectedCells = this.crossReduction.getConnectedCellsOnLayer(cell, rankValue);
            var previousLayerConnectedCells = this.crossReduction.getConnectedCellsOnLayer(cell, rankValue, true);
            var nextConnectedCount = nextLayerConnectedCells ? nextLayerConnectedCells.length : 0;
            var prevConnectedCount = previousLayerConnectedCells ? previousLayerConnectedCells.length : 0;
            var medianNextLevel = this.medianXValue(plalementChange, nextLayerConnectedCells, rankValue + 1);
            var medianPreviousLevel = this.medianXValue(plalementChange, previousLayerConnectedCells, rankValue - 1);
            var numConnectedNeighbours = nextConnectedCount + prevConnectedCount;
            var currentPosition = this.crossReduction.getTempVariable(cell, rankValue);
            var cellMedian = currentPosition;
            if (numConnectedNeighbours > 0) {
                cellMedian = (medianNextLevel * nextConnectedCount + medianPreviousLevel * prevConnectedCount) / numConnectedNeighbours;
            }
            if (nextConnectedCount === 1 && prevConnectedCount === 1) {
                cellMedian = (medianPreviousLevel * prevConnectedCount) / prevConnectedCount;
            }
            else if (nextConnectedCount === 1) {
                cellMedian = (medianNextLevel * nextConnectedCount) / nextConnectedCount;
            }
            var positionChanged = false;
            var tempValue = undefined;
            if (cellMedian < currentPosition - tolerance) {
                if (rankIndex === 0) {
                    tempValue = cellMedian;
                    positionChanged = true;
                }
                else {
                    var leftCell = rank[parseInt(rankValue.toString(), 10)][rankIndex - 1];
                    var leftLimit = this.crossReduction.getTempVariable(leftCell, rankValue);
                    leftLimit = leftLimit + leftCell.width / 2 + plalementChange.intraCellSpacing + cell.width / 2;
                    if (leftLimit < cellMedian) {
                        tempValue = cellMedian;
                        positionChanged = true;
                    }
                    else if (leftLimit < this.crossReduction.getTempVariable(cell, rankValue) - tolerance) {
                        tempValue = leftLimit;
                        positionChanged = true;
                    }
                }
            }
            else if (cellMedian > currentPosition + tolerance) {
                var rankSize = rank[parseInt(rankValue.toString(), 10)].length;
                if (rankIndex === rankSize - 1) {
                    tempValue = cellMedian;
                    positionChanged = true;
                }
                else {
                    var rightCell = rank[parseInt(rankValue.toString(), 10)][rankIndex + 1];
                    var rightLimit = this.crossReduction.getTempVariable(rightCell, rankValue);
                    rightLimit = rightLimit - rightCell.width / 2 - plalementChange.intraCellSpacing - cell.width / 2;
                    if (rightLimit > cellMedian) {
                        tempValue = cellMedian;
                        positionChanged = true;
                    }
                    else if (rightLimit > this.crossReduction.getTempVariable(cell, rankValue) + tolerance) {
                        tempValue = rightLimit;
                        positionChanged = true;
                    }
                }
            }
            if (positionChanged) {
                this.setTempVariable(cell, rankValue, tempValue);
                // Add connected nodes to map and list
                this.updateNodeList(nodeList, map, nextLayerConnectedCells, model);
                this.updateNodeList(nodeList, map, previousLayerConnectedCells, model);
            }
            if (this.crossReduction.isVertex(cellWrapper.cell)) {
                cellWrapper.visited = false;
            }
            count++;
        }
    };
    //Updates the ndoes collection
    HierarchicalLayoutUtil.prototype.updateNodeList = function (nodeList, map, collection, model) {
        for (var i = 0; i < collection.length; i++) {
            var connectedCell = collection[parseInt(i.toString(), 10)];
            var connectedCellWrapper = model.getDictionaryForSorter(map, connectedCell);
            if (connectedCellWrapper != null) {
                if (connectedCellWrapper.visited === false) {
                    connectedCellWrapper.visited = true;
                    nodeList.push(connectedCellWrapper);
                }
            }
        }
    };
    //Calculates the node position of the connected cell on the specified rank
    HierarchicalLayoutUtil.prototype.medianXValue = function (plalementChange, connectedCells, rankValue) {
        if (!connectedCells || connectedCells.length === 0) {
            return 0;
        }
        var medianValues = [];
        for (var i = 0; i < connectedCells.length; i++) {
            medianValues[parseInt(i.toString(), 10)]
                = this.crossReduction.getTempVariable(connectedCells[parseInt(i.toString(), 10)], rankValue);
        }
        medianValues.sort(function (a, b) {
            return a - b;
        });
        if (connectedCells.length % 2 === 1) {
            return medianValues[Math.floor(connectedCells.length / 2)];
        }
        else {
            var medianPoint = connectedCells.length / 2;
            var leftMedian = medianValues[medianPoint - 1];
            var rightMedian = medianValues[parseInt(medianPoint.toString(), 10)];
            return ((leftMedian + rightMedian) / 2);
        }
    };
    //Updates the geometry of the vertices
    HierarchicalLayoutUtil.prototype.placementStageExecute = function (plalementChange) {
        var isHorizontal = false;
        if (plalementChange.model.layout.orientation === 'LeftToRight' || plalementChange.model.layout.orientation === 'RightToLeft') {
            isHorizontal = true;
        }
        plalementChange.jettyPositions = {};
        var model = plalementChange.model;
        // eslint-disable-next-line
        isHorizontal ? plalementChange.currentYDelta = 0.0 : plalementChange.currentXDelta = 0.0;
        this.initialCoords(plalementChange, { model: model }, model);
        this.minNode(plalementChange, model);
        var bestOffsetDelta = 100000000.0;
        if (!plalementChange.maxIterations) {
            plalementChange.maxIterations = 8;
        }
        for (var i = 0; i < plalementChange.maxIterations; i++) {
            // if the total offset is less for the current positioning,
            //there are less heavily angled edges and so the current positioning is used
            if ((isHorizontal ? plalementChange.currentYDelta : plalementChange.currentXDelta) < bestOffsetDelta) {
                for (var j = 0; j < model.ranks.length; j++) {
                    var rank = model.ranks[parseInt(j.toString(), 10)];
                    for (var k = 0; k < rank.length; k++) {
                        var cell = rank[parseInt(k.toString(), 10)];
                        this.setXY(cell, j, this.crossReduction.getTempVariable(cell, j), isHorizontal ? true : false);
                    }
                }
                bestOffsetDelta = isHorizontal ? plalementChange.currentYDelta : plalementChange.currentXDelta;
            }
            // eslint-disable-next-line
            isHorizontal ? plalementChange.currentYDelta = 0 : plalementChange.currentXDelta = 0;
        }
        this.setCellLocations(plalementChange, model);
    };
    //sets the cell position in the after the layout operation
    HierarchicalLayoutUtil.prototype.setCellLocations = function (plalementChange, model) {
        var vertices = this.getValues(model.vertexMapper);
        for (var i = 0; i < vertices.length; i++) {
            this.setVertexLocation(plalementChange, vertices[parseInt(i.toString(), 10)]);
        }
    };
    //used to specify the geometrical position of the layout model cell
    HierarchicalLayoutUtil.prototype.garphModelsetVertexLocation = function (plalementChange, cell, x, y) {
        //let model: MultiParentModel = plalementChange.model;
        var geometry = cell.geometry;
        var result = null;
        if (geometry != null) {
            result = { x: x, y: y, width: geometry.width, height: geometry.height };
            if (geometry.x !== x || geometry.y !== y) {
                cell.geometry = result;
            }
        }
        return result;
    };
    //set the position of the specified node
    HierarchicalLayoutUtil.prototype.setVertexLocation = function (plalementChange, cell) {
        var isHorizontal = false;
        if (plalementChange.model.layout.orientation === 'LeftToRight' || plalementChange.model.layout.orientation === 'RightToLeft') {
            isHorizontal = true;
        }
        var realCell = cell.cell;
        var positionX = cell.x[0] - cell.width / 2;
        var positionY = cell.y[0] - cell.height / 2;
        this.garphModelsetVertexLocation(plalementChange, realCell, positionX, positionY);
        if (isHorizontal) {
            if (!plalementChange.marginY) {
                plalementChange.marginY = 0;
            }
            plalementChange.marginY = Math.max(plalementChange.marginY, positionY + cell.height);
        }
        else {
            if (!plalementChange.marginX) {
                plalementChange.marginX = 0;
            }
            plalementChange.marginX = Math.max(plalementChange.marginX, positionX + cell.width);
        }
    };
    /**
     *  get the specific value from the key value pair \
     *
     * @returns {  {}[] }  get the specific value from the key value pair \
     * @param {VertexMapper} mapper - provide the mapper value.
     * @private
     */
    HierarchicalLayoutUtil.prototype.getValues = function (mapper) {
        var list = [];
        if (mapper.map) {
            for (var _i = 0, _a = Object.keys(mapper.map); _i < _a.length; _i++) {
                var key = _a[_i];
                list.push(mapper.map["" + key]);
            }
        }
        return list;
    };
    /**
     *Checks and reduces the crosses in between line segments \
     *
     * @returns { void }    Checks and reduces the crosses in between line segments.\
     * @param {End} model - provide the model value.
     *
     * @private
     */
    HierarchicalLayoutUtil.prototype.crossingStage = function (model) {
        this.crossReduction.execute(model);
    };
    //Initializes the ranks of the vertices
    HierarchicalLayoutUtil.prototype.layeringStage = function (model) {
        this.initialRank(model);
        this.fixRanks(model);
    };
    //determine the initial rank for the each vertex on the relevent direction
    HierarchicalLayoutUtil.prototype.initialRank = function (model) {
        var startNodes = model.startNodes;
        var internalNodes = model.getDictionaryValues(model.vertexMapper);
        var startNodesCopy = startNodes.slice();
        while (startNodes.length > 0) {
            var internalNode = startNodes[0];
            var layerDeterminingEdges = internalNode.connectsAsTarget;
            var edgesToBeMarked = internalNode.connectsAsSource;
            var allEdgesScanned = true;
            var minimumLayer = 100000000;
            for (var i = 0; i < layerDeterminingEdges.length; i++) {
                var internalEdge = layerDeterminingEdges[parseInt(i.toString(), 10)];
                if (internalEdge.temp[0] === 5270620) {
                    // This edge has been scanned, get the layer of the node on the other end
                    var otherNode = internalEdge.source;
                    minimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);
                }
                else {
                    allEdgesScanned = false;
                    break;
                }
            }
            // If all edge have been scanned, assign the layer, mark all edges in the other direction and remove from the nodes list
            if (allEdgesScanned) {
                internalNode.temp[0] = minimumLayer;
                if (!model.maxRank) {
                    model.maxRank = 100000000;
                }
                model.maxRank = Math.min(model.maxRank, minimumLayer);
                if (edgesToBeMarked != null) {
                    for (var i = 0; i < edgesToBeMarked.length; i++) {
                        var internalEdge = edgesToBeMarked[parseInt(i.toString(), 10)];
                        internalEdge.temp[0] = 5270620;
                        // Add node on other end of edge to LinkedList of nodes to be analysed
                        var otherNode = internalEdge.target;
                        // Only add node if it hasn't been assigned a layer
                        if (otherNode.temp[0] === -1) {
                            startNodes.push(otherNode);
                            // Mark this other node as neither being unassigned nor assigned
                            //so it isn't added to this list again, but it's layer isn't used in any calculation.
                            otherNode.temp[0] = -2;
                        }
                    }
                }
                startNodes.shift();
            }
            else {
                // Not all the edges have been scanned, get to the back of the class and put the dunces cap on
                var removedCell = startNodes.shift();
                startNodes.push(internalNode);
                if (removedCell === internalNode && startNodes.length === 1) {
                    // This is an error condition, we can't get out of this loop.
                    //It could happen for more than one node but that's a lot harder to detect. Log the error
                    break;
                }
            }
        }
        for (var i = 0; i < internalNodes.length; i++) {
            internalNodes[parseInt(i.toString(), 10)].temp[0] -= model.maxRank;
        }
        for (var i = 0; i < startNodesCopy.length; i++) {
            var internalNode = startNodesCopy[parseInt(i.toString(), 10)];
            var currentMaxLayer = 0;
            var layerDeterminingEdges = internalNode.connectsAsSource;
            for (var j = 0; j < layerDeterminingEdges.length; j++) {
                var internalEdge = layerDeterminingEdges[parseInt(j.toString(), 10)];
                var otherNode = internalEdge.target;
                internalNode.temp[0] = Math.max(currentMaxLayer, otherNode.temp[0] + 1);
                currentMaxLayer = internalNode.temp[0];
            }
        }
        model.maxRank = 100000000 - model.maxRank;
    };
    //used to set the optimum value of each vertex on the layout
    HierarchicalLayoutUtil.prototype.fixRanks = function (model) {
        model.fixRanks();
    };
    //used to determine any cyclic stage have been created on the layout model
    HierarchicalLayoutUtil.prototype.cycleStage = function (model) {
        var seenNodes = {};
        model.startNodes = [];
        var unseenNodesArray = model.getDictionaryValues(model.vertexMapper);
        var unseenNodes = [];
        for (var i = 0; i < unseenNodesArray.length; i++) {
            unseenNodesArray[parseInt(i.toString(), 10)].temp[0] = -1;
            unseenNodes[unseenNodesArray[parseInt(i.toString(), 10)].id] = unseenNodesArray[parseInt(i.toString(), 10)];
        }
        var rootsArray = null;
        if (model.roots != null) {
            var modelRoots = model.roots;
            rootsArray = [];
            for (var i = 0; i < modelRoots.length; i++) {
                rootsArray[parseInt(i.toString(), 10)] = model.getDictionary(model.vertexMapper, modelRoots[parseInt(i.toString(), 10)]);
                if (rootsArray[parseInt(i.toString(), 10)] != null) {
                    model.startNodes.push(rootsArray[parseInt(i.toString(), 10)]);
                }
            }
        }
        model.visit('removeParentConnection', rootsArray, true, null, { seenNodes: seenNodes, unseenNodes: unseenNodes });
        var seenNodesCopy = model.clone(seenNodes, null, true);
        model.visit('removeNodeConnection', unseenNodes, true, seenNodesCopy, { seenNodes: seenNodes, unseenNodes: unseenNodes });
    };
    /**
     * removes the edge from the given collection \
     *
     * @returns {  IEdge }    removes the edge from the given collection .\
     * @param {IEdge} obj - provide the angle value.
     * @param { IEdge[]} array - provide the angle value.
     * @private
     */
    HierarchicalLayoutUtil.prototype.remove = function (obj, array) {
        var index = array.indexOf(obj);
        if (index !== -1) {
            array.splice(index, 1);
        }
        return obj;
    };
    /**
     * Inverts the source and target of an edge \
     *
     * @returns {  void }    Inverts the source and target of an edge .\
     * @param {IEdge} connectingEdge - provide the angle value.
     * @param { number} layer - provide the angle value.
     * @private
     */
    HierarchicalLayoutUtil.prototype.invert = function (connectingEdge, layer) {
        var temp = connectingEdge.source;
        connectingEdge.source = connectingEdge.target;
        connectingEdge.target = temp;
        connectingEdge.isReversed = !connectingEdge.isReversed;
    };
    /**
     * used to get the edges between the given source and target  \
     *
     * @returns {  IConnector[] }    used to get the edges between the given source and target  .\
     * @param {Vertex} source - provide the angle value.
     * @param { Vertex} target - provide the angle value.
     * @param { boolean} directed - provide the angle value.
     * @private
     */
    HierarchicalLayoutUtil.prototype.getEdgesBetween = function (source, target, directed) {
        directed = (directed != null) ? directed : false;
        var edges = this.getEdges(source);
        var result = [];
        for (var i = 0; i < edges.length; i++) {
            var src = this.getVisibleTerminal(edges[parseInt(i.toString(), 10)], true);
            var trg = this.getVisibleTerminal(edges[parseInt(i.toString(), 10)], false);
            if ((src === source && trg === target) || (!directed && src === target && trg === source)) {
                result.push(edges[parseInt(i.toString(), 10)]);
            }
        }
        return result;
    };
    return HierarchicalLayoutUtil;
}());
/**
 * Handles position the objects in a hierarchical tree structure
 */
var MultiParentModel = /** @class */ (function () {
    function MultiParentModel(layout, vertices, roots, dlayout) {
        this.multiObjectIdentityCounter = 0;
        //used to count the no of times the parent have been used
        this.dfsCount = 0;
        this.hierarchicalUtil = new HierarchicalLayoutUtil();
        this.roots = roots;
        this.vertexMapper = { map: {} };
        var internalVertices = [];
        this.layout = dlayout;
        this.maxRank = 100000000;
        this.edgeMapper = { map: {} };
        this.hierarchicalLayout = layout;
        this.createInternalCells(layout, vertices, internalVertices, dlayout);
        for (var i = 0; i < vertices.length; i++) {
            var edges = internalVertices[parseInt(i.toString(), 10)].connectsAsSource;
            for (var j = 0; j < edges.length; j++) {
                var internalEdge = edges[parseInt(j.toString(), 10)];
                var realEdges = internalEdge.edges;
                if (realEdges != null && realEdges.length > 0) {
                    var realEdge = realEdges[0];
                    var targetCell = layout.getVisibleTerminal(realEdge, false);
                    var internalTargetCell = this.getDictionary(this.vertexMapper, targetCell);
                    if (internalVertices[parseInt(i.toString(), 10)] === internalTargetCell) {
                        targetCell = layout.getVisibleTerminal(realEdge, true);
                        internalTargetCell = this.getDictionary(this.vertexMapper, targetCell);
                    }
                    if (internalTargetCell != null && internalVertices[parseInt(i.toString(), 10)] !== internalTargetCell) {
                        internalEdge.target = internalTargetCell;
                        if (internalTargetCell.connectsAsTarget.length === 0) {
                            internalTargetCell.connectsAsTarget = [];
                        }
                        if (internalTargetCell.connectsAsTarget.indexOf(internalEdge) < 0) {
                            internalTargetCell.connectsAsTarget.push(internalEdge);
                        }
                    }
                }
            }
            internalVertices[parseInt(i.toString(), 10)].temp[0] = 1;
        }
    }
    /* tslint:disable */
    MultiParentModel.prototype.resetEdge = function (edge) {
        var geometry = { x: 0, y: 0, width: 0, height: 0, relative: true };
        var geo = geometry;
        edge['geometry'] = geo;
        return edge;
    };
    // eslint-disable-next-line max-len
    MultiParentModel.prototype.createInternalCells = function (layout, vertices, internalVertices, dlayout) {
        for (var i = 0; i < vertices.length; i++) {
            internalVertices[parseInt(i.toString(), 10)] = {
                x: [], y: [], temp: [], cell: vertices[parseInt(i.toString(), 10)],
                id: vertices[parseInt(i.toString(), 10)].name, connectsAsTarget: [], connectsAsSource: [], type: 'internalVertex'
            };
            this.setDictionary(this.vertexMapper, vertices[parseInt(i.toString(), 10)], internalVertices[parseInt(i.toString(), 10)]);
            var conns = layout.getEdges(vertices[parseInt(i.toString(), 10)]);
            internalVertices[parseInt(i.toString(), 10)].connectsAsSource = [];
            for (var j = 0; j < conns.length; j++) {
                var cell = layout.getVisibleTerminal(conns[parseInt(j.toString(), 10)], false);
                if (cell !== vertices[parseInt(i.toString(), 10)]) {
                    var undirectedEdges = layout.getEdgesBetween(vertices[parseInt(i.toString(), 10)], cell, false);
                    var directedEdges = layout.getEdgesBetween(vertices[parseInt(i.toString(), 10)], cell, true);
                    if (undirectedEdges != null && undirectedEdges.length > 0 && directedEdges.length * 2 >= undirectedEdges.length) {
                        var internalEdge = { x: [], y: [], temp: [], edges: undirectedEdges, ids: [] };
                        if (dlayout.enableLayoutRouting) {
                            for (var k = 0; k < undirectedEdges.length; k++) {
                                var edge = undirectedEdges[parseInt(k.toString(), 10)];
                                this.setDictionary(this.edgeMapper, undefined, internalEdge, edge.id);
                                // Resets all point on the edge and disables the edge style
                                // without deleting it from the cell style
                                this.resetEdge(edge);
                            }
                        }
                        internalEdge.source = internalVertices[parseInt(i.toString(), 10)];
                        for (var m = 0; m < undirectedEdges.length; m++) {
                            internalEdge.ids.push(undirectedEdges[parseInt(m.toString(), 10)].id);
                        }
                        internalEdge.source = internalVertices[parseInt(i.toString(), 10)];
                        if (!internalVertices[parseInt(i.toString(), 10)].connectsAsSource) {
                            internalVertices[parseInt(i.toString(), 10)].connectsAsSource = [];
                        }
                        if (internalVertices[parseInt(i.toString(), 10)].connectsAsSource.indexOf(internalEdge) < 0) {
                            internalVertices[parseInt(i.toString(), 10)].connectsAsSource.push(internalEdge);
                        }
                    }
                }
            }
            internalVertices[parseInt(i.toString(), 10)].temp[0] = 0;
        }
    };
    /* tslint:enable */
    /**
     * used to set the optimum value of each vertex on the layout \
     *
     * @returns {  void }   used to set the optimum value of each vertex on the layout .\
     * @private
     */
    MultiParentModel.prototype.fixRanks = function () {
        var rankList = [];
        this.ranks = [];
        for (var i = 0; i < this.maxRank + 1; i++) {
            rankList[parseInt(i.toString(), 10)] = [];
            this.ranks[parseInt(i.toString(), 10)] = rankList[parseInt(i.toString(), 10)];
        }
        var rootsArray = null;
        if (this.roots != null) {
            var oldRootsArray = this.roots;
            rootsArray = [];
            for (var i = 0; i < oldRootsArray.length; i++) {
                var cell = oldRootsArray[parseInt(i.toString(), 10)];
                var internalNode = this.getDictionary(this.vertexMapper, cell);
                rootsArray[parseInt(i.toString(), 10)] = internalNode;
            }
        }
        this.visit('updateMinMaxRank', rootsArray, false, null, { seenNodes: null, unseenNodes: null, rankList: rankList });
    };
    //Updates the min/max rank of the layer
    MultiParentModel.prototype.updateMinMaxRank = function (layer, seen, data) {
        //let seenNodes: {} = data.seenNodes;
        //let unseenNodes: {} = data.unseenNodes;
        var parent = data.parent;
        var node = data.root;
        var edge = data.edge;
        var rankList = data.rankList;
        if (!node.maxRank && node.maxRank !== 0) {
            node.maxRank = -1;
        }
        if (!node.minRank && node.minRank !== 0) {
            node.minRank = -1;
        }
        if (seen === 0 && node.maxRank < 0 && node.minRank < 0) {
            rankList[node.temp[0]].push(node);
            node.maxRank = node.temp[0];
            node.minRank = node.temp[0];
            node.temp[0] = rankList[node.maxRank].length - 1;
        }
        if (parent != null && edge != null) {
            var parentToCellRankDifference = parent.maxRank - node.maxRank;
            if (parentToCellRankDifference > 1) {
                edge.maxRank = parent.maxRank;
                edge.minRank = node.maxRank;
                edge.temp = [];
                edge.x = [];
                edge.y = [];
                for (var i = edge.minRank + 1; i < edge.maxRank; i++) {
                    rankList[parseInt(i.toString(), 10)].push(edge);
                    this.hierarchicalUtil.setTempVariable(edge, i, rankList[parseInt(i.toString(), 10)].length - 1);
                }
            }
        }
    };
    //used to store the value of th given key on the object
    MultiParentModel.prototype.setDictionary = function (dic, key, value, edgeId) {
        if (!edgeId) {
            var id = key.name;
            var previous = dic.map["" + id];
            dic.map["" + id] = value;
            return previous;
        }
        else {
            var previous = dic.map["" + edgeId];
            dic.map["" + edgeId] = value;
            return previous;
        }
    };
    /**
     * used to store the value of th given key on the objectt \
     *
     * @returns {  IVertex }   used to store the value of th given key on the object .\
     * @param {VertexMapper} dic - provide the angle value.
     * @param {IVertex} key - provide the angle value.
     * @param {WeightedCellSorter} value - provide the angle value.
     * @param {boolean} flag - provide the angle value.
     * @private
     */
    MultiParentModel.prototype.setDictionaryForSorter = function (dic, key, value, flag) {
        var id = key.id;
        var previous = dic.map["" + id];
        dic.map["" + id] = value;
        return previous;
    };
    /**
     * used to get the value of the given key \
     *
     * @returns {  IVertex }  used to get the value of the given key .\
     * @param {VertexMapper} dic - provide the angle value.
     * @param {IVertex} key - provide the angle value.
     * @private
     */
    MultiParentModel.prototype.getDictionary = function (dic, key) {
        if (!this.multiObjectIdentityCounter && this.multiObjectIdentityCounter !== 0) {
            this.multiObjectIdentityCounter = 0;
        }
        var id = key.name;
        if (!id) {
            if (!key.layoutObjectId) { ///####
                key.layoutObjectId = 'graphHierarchyNode#' + this.multiObjectIdentityCounter++;
                return key.layoutObjectId;
            }
            else {
                return dic.map[key.layoutObjectId];
            }
        }
        return dic.map["" + id];
    };
    /**
     * used to get the value of the given key \
     *
     * @returns {  IVertex }  used to get the value of the given key .\
     * @param {VertexMapper} dic - provide the angle value.
     * @param {IVertex} key - provide the angle value.
     * @private
     */
    MultiParentModel.prototype.getDictionaryForSorter = function (dic, key) {
        if (!this.multiObjectIdentityCounter && this.multiObjectIdentityCounter !== 0) {
            this.multiObjectIdentityCounter = 0;
        }
        var id = key.id;
        if (!id) {
            if (!key.layoutObjectId) { ///####
                key.layoutObjectId = 'graphHierarchyNode#' + this.multiObjectIdentityCounter++;
                return key.layoutObjectId;
            }
            else {
                return dic.map[key.layoutObjectId];
            }
        }
        return dic.map["" + id];
    };
    /**
     * used to get all the values of the dictionary object \
     *
     * @returns {  IVertex[] }  used to get all the values of the dictionary object .\
     * @param {VertexMapper} dic - provide the angle value.
     * @private
     */
    MultiParentModel.prototype.getDictionaryValues = function (dic) {
        var result = [];
        for (var _i = 0, _a = Object.keys(dic.map); _i < _a.length; _i++) {
            var key = _a[_i];
            result.push(dic.map["" + key]);
        }
        return result;
    };
    /**
     * used to visit all the entries on the given dictionary with given function \
     *
     * @returns { void }  used to visit all the entries on the given dictionary with given function .\
     * @param {string} visitor - provide the visitor value.
     * @param {IVertex[]} dfsRoots - provide the dfsRoots value.
     * @param {boolean} trackAncestors - provide the trackAncestors value.
     * @param {{}} seenNodes - provide the seenNodes value.
     * @param {TraverseData} data - provide the data value.
     * @private
     */
    MultiParentModel.prototype.visit = function (visitor, dfsRoots, trackAncestors, seenNodes, data) {
        //let seenNodes1: {} = data.seenNodes;
        //let unseenNodes1: {} = data.unseenNodes;
        //let rankList: IVertex[][] = data.rankList;
        // Run depth first search through on all roots
        if (dfsRoots != null) {
            for (var i = 0; i < dfsRoots.length; i++) {
                var internalNode = dfsRoots[parseInt(i.toString(), 10)];
                if (internalNode != null) {
                    if (seenNodes == null) {
                        seenNodes = new Object();
                    }
                    data.parent = null;
                    data.root = internalNode;
                    data.edge = null;
                    if (trackAncestors) {
                        // Set up hash code for root
                        internalNode.hashCode = [];
                        internalNode.hashCode[0] = this.dfsCount;
                        internalNode.hashCode[1] = i;
                        this.extendedDfs(visitor, seenNodes, i, 0, data);
                    }
                    else {
                        this.depthFirstSearch(visitor, seenNodes, 0, data);
                    }
                }
            }
            this.dfsCount++;
        }
    };
    //used to perform the depth fisrt search on the layout model
    MultiParentModel.prototype.depthFirstSearch = function (visitor, seen, layer, data) {
        //let seenNodes1: {} = data.seenNodes;
        //let unseenNodes1: {} = data.unseenNodes;
        //let rankList: IVertex[][] = data.rankList;
        //let parent: IVertex = data.parent;
        var root = data.root;
        //let edge: IEdge = data.edge;
        if (root != null) {
            var rootId = root.id;
            if (seen["" + rootId] == null) {
                seen["" + rootId] = root;
                this.updateConnectionRank(visitor, layer, 0, data);
                // Copy the connects as source list so that visitors can change the original for edge direction inversions
                var outgoingEdges = root.connectsAsSource.slice();
                for (var i = 0; i < outgoingEdges.length; i++) {
                    var internalEdge = outgoingEdges[parseInt(i.toString(), 10)];
                    var targetNode = internalEdge.target;
                    // Root check is O(|roots|)
                    data.parent = root;
                    data.root = targetNode;
                    data.edge = internalEdge;
                    this.depthFirstSearch(visitor, seen, layer + 1, data);
                }
            }
            else {
                this.updateConnectionRank(visitor, layer, 1, data);
            }
        }
    };
    //Updates the rank of the connection
    MultiParentModel.prototype.updateConnectionRank = function (visitor, layer, seen, traversedList) {
        var parent = traversedList.parent;
        var root = traversedList.root;
        var edge = traversedList.edge;
        if (visitor === 'removeParentConnection' || visitor === 'removeNodeConnection') {
            var remove = visitor === 'removeNodeConnection';
            this.removeConnectionEdge(parent, root, edge, layer, traversedList, remove);
        }
        if (visitor === 'updateMinMaxRank') {
            this.updateMinMaxRank(layer, seen, traversedList);
        }
    };
    //Removes the edge from the collection
    MultiParentModel.prototype.removeConnectionEdge = function (parent, node, edge, layer, data, remove) {
        var seenNodes = data.seenNodes;
        var unseenNodes = data.unseenNodes;
        //let rankList: IVertex[][] = data.rankList;
        if (this.hierarchicalUtil.isAncestor(node, parent)) {
            this.hierarchicalUtil.invert(edge, 0);
            this.hierarchicalUtil.remove(edge, parent.connectsAsSource);
            if (remove) {
                node.connectsAsSource.push(edge);
                parent.connectsAsTarget.push(edge);
                this.hierarchicalUtil.remove(edge, node.connectsAsTarget);
            }
            else {
                parent.connectsAsTarget.push(edge);
                this.hierarchicalUtil.remove(edge, node.connectsAsTarget);
                node.connectsAsSource.push(edge);
            }
        }
        seenNodes[node.id] = node;
        delete unseenNodes[node.id];
    };
    //the dfs extends the default version by keeping track of cells ancestors, but it should be only used when necessary
    MultiParentModel.prototype.extendedDfs = function (visitor, seen, cHash, layer, data) {
        //let seenNodes: {} = data.seenNodes;
        //let unseenNodes: {} = data.unseenNodes;
        //let rankList: IVertex[][] = data.rankList;
        var parent = data.parent;
        var root = data.root;
        var edge = data.edge;
        if (root != null) {
            if (parent != null) {
                if (root.hashCode == null ||
                    root.hashCode[0] !== parent.hashCode[0]) {
                    var hashCodeLength = parent.hashCode.length + 1;
                    root.hashCode = parent.hashCode.slice();
                    root.hashCode[hashCodeLength - 1] = cHash;
                }
            }
            var rootId = root.id;
            if (seen["" + rootId] == null) {
                seen["" + rootId] = root;
                this.updateConnectionRank(visitor, layer, 0, data);
                var outgoingEdges = root.connectsAsSource.slice();
                for (var i = 0; i < outgoingEdges.length; i++) {
                    var internalEdge = outgoingEdges[parseInt(i.toString(), 10)];
                    var targetNode = internalEdge.target;
                    data.parent = root;
                    data.root = targetNode;
                    data.edge = internalEdge;
                    this.extendedDfs(visitor, seen, i, layer + 1, data);
                }
            }
            else {
                this.updateConnectionRank(visitor, layer, 1, data);
            }
        }
    };
    /**
     * used to clone the specified object ignoring all fieldnames in the given array of transient fields \
     *
     * @returns { void }    used to clone the specified object ignoring all fieldnames in the given array of transient fields .\
     * @param {Object} obj - provide the source value.
     * @param {string[]} transients - provide the target value.
     * @param {boolean} shallow - provide the shallow value.
     *
     * @private
     */
    MultiParentModel.prototype.clone = function (obj, transients, shallow) {
        shallow = (shallow != null) ? shallow : false;
        if (obj != null && typeof (obj.constructor) === 'function') {
            var clonedObj = obj.constructor();
            for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
                var i = _a[_i];
                if (i !== 'layoutObjectId' && (transients == null || transients.indexOf(i) < 0)) {
                    if (!shallow && typeof (obj["" + i]) === 'object') ;
                    else {
                        clonedObj["" + i] = obj["" + i];
                    }
                }
            }
            return clonedObj;
        }
        return null;
    };
    return MultiParentModel;
}());
/**
 * Defines how to reduce the crosses in between the line segments
 */
var CrossReduction = /** @class */ (function () {
    function CrossReduction() {
    }
    /**
     *  used to calculate the number of edges crossing the layout model \
     *
     * @returns { number }  used to calculate the number of edges crossing the layout model\
     * @param {MultiParentModel} model - provide the model value.
     *
     * @private
     */
    CrossReduction.prototype.calculateCrossings = function (model) {
        var numRanks = model.ranks.length;
        var totalCrossings = 0;
        for (var i = 1; i < numRanks; i++) {
            totalCrossings += this.calculateRankCrossing(i, model);
        }
        return totalCrossings;
    };
    /**
     *  used to get the temp value specified for the node or connector. \
     *
     * @returns { boolean }  used to get the temp value specified for the node or connector.\
     * @param {IVertex} node - provide the node value.
     * @param {IVertex} layer - provide the layer value.
     *
     * @private
     */
    CrossReduction.prototype.getTempVariable = function (node, layer) {
        if (node) {
            if (this.isVertex(node)) {
                return node.temp[0];
            }
            else {
                return node.temp[layer - node.minRank - 1];
            }
        }
        return 0;
    };
    //used to specify the number of conenctors crossing between the specified rank and its below rank
    CrossReduction.prototype.calculateRankCrossing = function (i, model) {
        var totalCrossings = 0;
        var rank = model.ranks[parseInt(i.toString(), 10)];
        var previousRank = model.ranks[i - 1];
        var tmpIndices = [];
        // Iterate over the top rank and fill in the connection information
        for (var j = 0; j < rank.length; j++) {
            var node = rank[parseInt(j.toString(), 10)];
            var rankPosition = this.getTempVariable(node, i);
            var connectedCells = this.getConnectedCellsOnLayer(node, i, true);
            ///####
            var nodeIndices = [];
            for (var k = 0; k < connectedCells.length; k++) {
                var connectedNode = connectedCells[parseInt(k.toString(), 10)];
                var otherCellRankPosition = this.getTempVariable(connectedNode, i - 1);
                nodeIndices.push(otherCellRankPosition);
            }
            nodeIndices.sort(function (x, y) { return x - y; });
            tmpIndices[parseInt(rankPosition.toString(), 10)] = nodeIndices;
        }
        var indices = [];
        for (var j = 0; j < tmpIndices.length; j++) {
            indices = indices.concat(tmpIndices[parseInt(j.toString(), 10)]);
        }
        var firstIndex = 1;
        while (firstIndex < previousRank.length) {
            firstIndex <<= 1;
        }
        var treeSize = 2 * firstIndex - 1;
        firstIndex -= 1;
        var tree = [];
        for (var j = 0; j < treeSize; ++j) {
            tree[parseInt(j.toString(), 10)] = 0;
        }
        for (var j = 0; j < indices.length; j++) {
            var index = indices[parseInt(j.toString(), 10)];
            var treeIndex = index + firstIndex;
            ++tree[parseInt(treeIndex.toString(), 10)];
            while (treeIndex > 0) {
                if (treeIndex % 2) {
                    totalCrossings += tree[treeIndex + 1];
                }
                treeIndex = (treeIndex - 1) >> 1;
                ++tree[parseInt(treeIndex.toString(), 10)];
            }
        }
        return totalCrossings;
    };
    /**
     * Calculates and reduces the crosses between line segments
     *
     * @returns { void }Calculates and reduces the crosses between line segments.\
     * @param {MultiParentModel} model - provide the target value.
     * @private
     */
    CrossReduction.prototype.execute = function (model) {
        // Stores initial ordering
        this.nestedBestRanks = [];
        for (var i = 0; i < model.ranks.length; i++) {
            this.nestedBestRanks[parseInt(i.toString(), 10)] = model.ranks[parseInt(i.toString(), 10)].slice();
        }
        var iterationsWithoutImprovement = 0;
        var currentBestCrossings = this.calculateCrossings(model);
        for (var i = 0; i < 24 && iterationsWithoutImprovement < 2; i++) {
            this.weightedMedian(i, model);
            var candidateCrossings = this.calculateCrossings(model);
            if (candidateCrossings < currentBestCrossings) {
                currentBestCrossings = candidateCrossings;
                iterationsWithoutImprovement = 0;
                for (var j = 0; j < this.nestedBestRanks.length; j++) {
                    var rank = model.ranks[parseInt(j.toString(), 10)];
                    for (var k = 0; k < rank.length; k++) {
                        var cell = rank[parseInt(k.toString(), 10)];
                        var obj = this.nestedBestRanks[parseInt(j.toString(), 10)][cell.temp[0]];
                        var check = true;
                        if (cell.edges && obj && !obj.edges) {
                            check = false;
                        }
                        if (obj && check) {
                            this.nestedBestRanks[parseInt(j.toString(), 10)][cell.temp[0]] = cell;
                        }
                    }
                }
            }
            else {
                // Increase count of iterations
                iterationsWithoutImprovement++;
                // Restore the best values to the cells
                for (var j = 0; j < this.nestedBestRanks.length; j++) {
                    var rank = model.ranks[parseInt(j.toString(), 10)];
                    for (var k = 0; k < rank.length; k++) {
                        var cell = rank[parseInt(k.toString(), 10)];
                        this.setTempVariable(cell, j, k);
                    }
                }
            }
            if (currentBestCrossings === 0) {
                break;
            }
        }
        // Store the best rankings but in the model
        var ranks = [];
        var rankList = [];
        for (var i = 0; i < model.maxRank + 1; i++) {
            rankList[parseInt(i.toString(), 10)] = [];
            ranks[parseInt(i.toString(), 10)] = rankList[parseInt(i.toString(), 10)];
        }
        for (var i = 0; i < this.nestedBestRanks.length; i++) {
            for (var j = 0; j < this.nestedBestRanks[parseInt(i.toString(), 10)].length; j++) {
                rankList[parseInt(i.toString(), 10)].push(this.nestedBestRanks[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)]);
            }
        }
        model.ranks = ranks;
    };
    /**
     *  check whether the object is vertext or edge on the layout model. \
     *
     * @returns { boolean }  check whether the object is vertext or edge on the layout model..\
     * @param {IVertex} node - provide the iteration value.
     *
     * @private
     */
    CrossReduction.prototype.isVertex = function (node) {
        if (node && node.cell && ((node.cell.inEdges && node.cell.inEdges.length) || (node.cell.outEdges && node.cell.outEdges.length))) {
            return true;
        }
        return false;
    };
    /**
     *  used to move up or move down the node position on the adjacent ranks \
     *
     * @returns { void }  used to move up or move down the node position on the adjacent ranks.\
     * @param {number} iteration - provide the iteration value.
     * @param {MultiParentModel} model - provide the model value.
     *
     * @private
     */
    CrossReduction.prototype.weightedMedian = function (iteration, model) {
        // Reverse sweep direction each time through this method
        var downwardSweep = (iteration % 2 === 0);
        if (downwardSweep) {
            for (var j = model.maxRank - 1; j >= 0; j--) {
                this.medianRank(j, downwardSweep);
            }
        }
        else {
            for (var j = 1; j < model.maxRank; j++) {
                this.medianRank(j, downwardSweep);
            }
        }
    };
    /**
     * used to get the node next(up) connected to the specified node or connector \
     *
     * @returns { void } calculates the rank elements on the specified rank.\
     * @param {IVertex} cell - provide the cell value.
     * @param {number} layer - provide the layer value.
     * @param {boolean} isPrevious - provide the isPrevious value.
     *
     * @private
     */
    CrossReduction.prototype.getConnectedCellsOnLayer = function (cell, layer, isPrevious) {
        if (isPrevious === void 0) { isPrevious = false; }
        var connectedlayer = 'nextLayerConnectedCells';
        var connectedAs = 'connectsAsTarget';
        if (isPrevious) {
            connectedlayer = 'previousLayerConnectedCells';
            connectedAs = 'connectsAsSource';
        }
        if (cell) {
            if (this.isVertex(cell)) {
                if (cell["" + connectedlayer] == null) {
                    cell["" + connectedlayer] = [];
                    cell["" + connectedlayer][0] = [];
                    for (var i = 0; i < cell["" + connectedAs].length; i++) {
                        var edge = cell["" + connectedAs][parseInt(i.toString(), 10)];
                        if (edge.maxRank === undefined) {
                            edge.maxRank = -1;
                        }
                        if (edge.maxRank === -1 || (isPrevious ? (edge.minRank === layer - 1) : (edge.maxRank === layer + 1))) {
                            // Either edge is not in any rank or no dummy nodes in edge, add node of other side of edge
                            cell["" + connectedlayer][0].push(isPrevious ? edge.target : edge.source);
                        }
                        else {
                            // Edge spans at least two layers, add edge
                            cell["" + connectedlayer][0].push(edge);
                        }
                    }
                }
                return cell["" + connectedlayer][0];
            }
            else {
                if (cell["" + connectedlayer] == null) {
                    cell["" + connectedlayer] = [];
                    for (var i = 0; i < cell.temp.length; i++) {
                        cell["" + connectedlayer][parseInt(i.toString(), 10)] = [];
                        if (i === (isPrevious ? 0 : (cell.temp.length - 1))) {
                            cell["" + connectedlayer][parseInt(i.toString(), 10)].push(isPrevious ? cell.target : cell.source);
                        }
                        else {
                            cell["" + connectedlayer][parseInt(i.toString(), 10)].push(cell);
                        }
                    }
                }
                return cell["" + connectedlayer][layer - cell.minRank - 1];
            }
        }
        return null;
    };
    /**
     * calculates the rank elements on the specified rank \
     *
     * @returns { void } calculates the rank elements on the specified rank.\
     * @param {IVertex[]} connectedCells - provide the cell value.
     * @param {number} rankValue - provide the layer value.
     *
     * @private
     */
    CrossReduction.prototype.medianValue = function (connectedCells, rankValue) {
        var medianValues = [];
        var arrayCount = 0;
        for (var i = 0; i < connectedCells.length; i++) {
            var cell = connectedCells[parseInt(i.toString(), 10)];
            medianValues[arrayCount++] = this.getTempVariable(cell, rankValue);
        }
        // sorts numerical order sort
        medianValues.sort(function (a, b) { return a - b; });
        if (arrayCount % 2 === 1) {
            // For odd numbers of adjacent vertices return the median
            return medianValues[Math.floor(arrayCount / 2)];
        }
        else if (arrayCount === 2) {
            return ((medianValues[0] + medianValues[1]) / 2.0);
        }
        else {
            var medianPoint = arrayCount / 2;
            var leftMedian = medianValues[medianPoint - 1] - medianValues[0];
            var rightMedian = medianValues[arrayCount - 1]
                - medianValues[parseInt(medianPoint.toString(), 10)];
            return (medianValues[medianPoint - 1] * rightMedian + medianValues[parseInt(medianPoint.toString(), 10)] * leftMedian)
                / (leftMedian + rightMedian);
        }
    };
    /**
     * get the temp value of the specified layer \
     *
     * @returns { void }     getDirection method .\
     * @param {IVertex} cell - provide the cell value.
     * @param {layer} layer - provide the layer value.
     * @param {LayoutOrientation} value - provide the value value.
     *
     * @private
     */
    CrossReduction.prototype.setTempVariable = function (cell, layer, value) {
        if (cell) {
            cell.temp[0] = value;
        }
    };
    /**
     * used to minimize the node position on this rank and one of its adjacent ranks
     */
    CrossReduction.prototype.medianRank = function (rankValue, downwardSweep) {
        var numCellsForRank = this.nestedBestRanks[parseInt(rankValue.toString(), 10)].length;
        var medianValues = [];
        var reservedPositions = [];
        for (var i = 0; i < numCellsForRank; i++) {
            var cell = this.nestedBestRanks[parseInt(rankValue.toString(), 10)][parseInt(i.toString(), 10)];
            var sorterEntry = { medianValue: 0 };
            sorterEntry.cell = cell;
            // Flip whether or not equal medians are flipped on up and down sweeps
            //TODO re-implement some kind of nudge medianValues[i].nudge = !downwardSweep;
            var nextLevelConnectedCells = void 0;
            if (downwardSweep) {
                nextLevelConnectedCells = this.getConnectedCellsOnLayer(cell, rankValue);
            }
            else {
                nextLevelConnectedCells = this.getConnectedCellsOnLayer(cell, rankValue, true);
            }
            var nextRankValue = void 0;
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            downwardSweep ? nextRankValue = rankValue + 1 : nextRankValue = rankValue - 1;
            if (nextLevelConnectedCells != null && nextLevelConnectedCells.length !== 0) {
                sorterEntry.medianValue = this.medianValue(nextLevelConnectedCells, nextRankValue);
                medianValues.push(sorterEntry);
            }
            else {
                // Nodes with no adjacent vertices are flagged in the reserved array to
                //indicate they should be left in their current position.
                reservedPositions[this.getTempVariable(cell, rankValue)] = true;
            }
        }
        medianValues.sort(this.compare);
        // Set the new position of each node within the rank using its temp variable
        for (var i = 0; i < numCellsForRank; i++) {
            if (reservedPositions[parseInt(i.toString(), 10)] == null && medianValues.length > 0) {
                var cell = medianValues.shift().cell;
                this.setTempVariable(cell, rankValue, i);
            }
        }
    };
    //compares two values, it sends the values to the compare function,
    //and sorts the values according to the returned (negative, zero, positive) value
    CrossReduction.prototype.compare = function (a, b) {
        if (a != null && b != null) {
            if (b.medianValue > a.medianValue) {
                return -1;
            }
            else if (b.medianValue < a.medianValue) {
                return 1;
            }
        }
        return 0;
    };
    return CrossReduction;
}());
var MatrixModel = /** @class */ (function () {
    function MatrixModel() {
        this.edgeMapper = [];
    }
    /* tslint:disable */
    /** @private */
    /**
     * Arrange the elements
     *
     * @returns { void }  arrange the elements.\
     * @param {MatrixModelObject} matrixModel - provide the Matrix Model Object.
     * @param {Layout} layout - provide the layout value.
     *
     * @private
     */
    MatrixModel.prototype.arrangeElements = function (matrixModel, layout) {
        var layoutSettings = matrixModel.model.layout;
        var isHorizontal;
        if (layout.orientation === 'LeftToRight' || layout.orientation === 'RightToLeft') {
            isHorizontal = true;
        }
        else {
            isHorizontal = false;
        }
        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
        //let spacingInverse: number = !isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
        // Need to group element before
        this.groupLayoutCells(matrixModel);
        this.createMatrixCells(matrixModel);
        for (var j = 0; j < matrixModel.matrix.length; j++) {
            var matrixKey = matrixModel.matrix[parseInt(j.toString(), 10)].key;
            var matrixrow = matrixModel.matrix[parseInt(matrixKey.toString(), 10)].value;
            for (var i = 1; i < matrixrow.length; i++) {
                var cell = matrixrow[parseInt(i.toString(), 10)];
                var prevCell = matrixrow[i - 1];
                cell.offset += prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);
            }
        }
        // Sort roots based on their indices
        matrixModel.roots.sort(function (a, b) {
            if (a.cells[0] && b.cells[0]) {
                var indexA = matrixModel.model.roots.indexOf(a.cells[0].cell);
                var indexB = matrixModel.model.roots.indexOf(b.cells[0].cell);
                return indexA - indexB;
            }
            return 0;
        });
        for (var j = 0; j < matrixModel.roots.length; j++) {
            var root = matrixModel.roots[parseInt(j.toString(), 10)];
            this.arrangeMatrix(root, null, matrixModel);
        }
        for (var k = 0; k < matrixModel.matrix.length; k++) {
            var row = matrixModel.matrix[parseInt(k.toString(), 10)].value;
            for (var i = 0; i < row.length; i++) {
                var cell = row[parseInt(i.toString(), 10)];
                if (cell.visitedParents.length > 1) {
                    var firstParent = cell.visitedParents[0];
                    var lastParent = cell.visitedParents[cell.visitedParents.length - 1];
                    var firstVertexParent = this.findParentVertexCellGroup(firstParent);
                    var lastVertexParent = this.findParentVertexCellGroup(lastParent);
                    if (firstParent !== firstVertexParent && firstVertexParent.offset < firstParent.offset) {
                        firstParent = firstVertexParent;
                    }
                    if (lastParent !== lastVertexParent && lastVertexParent.offset > lastParent.offset) {
                        lastParent = firstVertexParent;
                    }
                    var newoffset = (lastParent.offset + lastParent.size * 0.5 + firstParent.offset - firstParent.size * 0.5) / 2;
                    var availOffsetMin = cell.initialOffset;
                    var availOffsetMax = cell.offset;
                    if (!(availOffsetMax === availOffsetMin)) {
                        if (newoffset >= availOffsetMin && newoffset <= availOffsetMax) {
                            this.translateMatrixCells(newoffset - cell.offset, cell);
                        }
                        else if (newoffset < availOffsetMin) {
                            this.translateMatrixCells(availOffsetMin - cell.offset, cell);
                        }
                    }
                }
            }
        }
        this.setXYforMatrixCell(matrixModel);
    };
    /* tslint:enable */
    MatrixModel.prototype.groupLayoutCells = function (matrixModel) {
        var ranks = matrixModel.model.ranks;
        for (var j = ranks.length - 1; j >= 0; j--) {
            var vertices = [];
            for (var v = 0; v < ranks[parseInt(j.toString(), 10)].length; v++) {
                var rank = ranks[parseInt(j.toString(), 10)][parseInt(v.toString(), 10)];
                var type = this.getType(rank.type);
                if (type === 'internalVertex') {
                    vertices.push(ranks[parseInt(j.toString(), 10)][parseInt(v.toString(), 10)]);
                }
            }
            var edges = [];
            for (var e = 0; e < ranks[parseInt(j.toString(), 10)].length; e++) {
                var rank = ranks[parseInt(j.toString(), 10)][parseInt(e.toString(), 10)];
                var type = this.getType(rank.type);
                if (type === 'internalEdge') {
                    edges.push(rank);
                }
            }
            while (vertices.length > 1) {
                var vertex1 = vertices[0];
                var parentset1 = this.selectIds(vertex1.connectsAsTarget, true);
                var childset1 = this.selectIds(vertex1.connectsAsSource, false);
                while (vertices.length > 1) {
                    var vertex2 = vertices[1];
                    var parentset2 = this.selectIds(vertex2.connectsAsTarget, true);
                    var childset2 = this.selectIds(vertex2.connectsAsSource, false);
                    var parentequals = this.compareLists(parentset1, parentset2);
                    var childequals = this.compareLists(childset1, childset2);
                    if (parentequals && childequals) {
                        this.updateMutualSharing(vertices[0], vertex2.id);
                        this.updateMutualSharing(vertices[1], vertex1.id);
                        vertices.splice(1, 1);
                        continue;
                    }
                    break;
                }
                vertices.splice(0, 1);
            }
            while (edges.length > 1) {
                var internalEdge = edges[0];
                var parentset = internalEdge.source;
                var childset = internalEdge.target;
                if (parentset.identicalSibiling != null) {
                    var groupedges = [];
                    for (var i = 0; i < edges.length; i++) {
                        var edge = edges[parseInt(i.toString(), 10)];
                        if (edge.target === childset) {
                            groupedges.push(edge);
                        }
                    }
                    for (var i = 0; i < groupedges.length; i++) {
                        var internalEdgese = groupedges[parseInt(i.toString(), 10)];
                        if (this.containsValue(parentset.identicalSibiling, internalEdgese.source.id)) {
                            internalEdgese.source.identicalSibiling = null;
                        }
                    }
                    internalEdge.source.identicalSibiling = null;
                }
                edges.splice(0, 1);
            }
        }
    };
    /* tslint:disable */
    MatrixModel.prototype.createMatrixCells = function (matrixModel) {
        var layoutSettings = matrixModel.model.layout;
        var isHorizontal = layoutSettings.orientation === 'LeftToRight'
            || layoutSettings.orientation === 'RightToLeft';
        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
        var spacingInverse = !isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
        var ranks = matrixModel.model.ranks;
        var matrixCellMapper = [];
        var rowoffset = -spacingInverse;
        for (var j = ranks.length - 1; j >= 0; j--) {
            var maxDimension = 0.0;
            var index = (ranks.length - 1) - j;
            var rank = ranks[parseInt(j.toString(), 10)].slice(); //.ToList();
            // Creating new row and adding it to matrix
            var matrixRow = [];
            matrixModel.matrix.push({ key: index, value: matrixRow });
            // Creating new row mapper
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var tempMatrixRow = [];
            matrixCellMapper.push({ index: index, value: tempMatrixRow });
            while (rank.length > 0) //.Any())
             {
                var layoutCell = rank[0];
                // eslint-disable-next-line max-len
                var matrixCell = { level: index, parents: [], children: [], visitedParents: [], visitedChildren: [], ignoredChildren: [], cells: [], size: 0, offset: 0, initialOffset: 0 };
                matrixRow.push(matrixCell);
                var type = this.getType(layoutCell.type);
                if (type === 'internalVertex') {
                    matrixCell.cells.push(layoutCell);
                    if (layoutCell.identicalSibiling != null) {
                        for (var i = 0; i < rank.length; i++) {
                            var internalVertex = rank[parseInt(i.toString(), 10)];
                            var type_1 = this.getType(internalVertex.type);
                            if (type_1 === 'internalVertex' && this.containsValue(layoutCell.identicalSibiling, internalVertex.id)) {
                                matrixCell.cells.push(internalVertex);
                                if (matrixCell.cells.length > layoutCell.identicalSibiling.length) {
                                    break;
                                }
                            }
                        }
                    }
                    for (var i = 0; i < matrixCell.cells.length; i++) {
                        var internalVertex = matrixCell.cells[parseInt(i.toString(), 10)];
                        var type_2 = this.getType(internalVertex.type);
                        if (type_2 === 'internalVertex') {
                            var geometry = internalVertex.cell.geometry;
                            matrixCell.size += isHorizontal ? geometry.height : geometry.width;
                            maxDimension = Math.max(maxDimension, !isHorizontal ? geometry.height : geometry.width);
                            tempMatrixRow.push({ key: internalVertex.id, value: matrixCell });
                            if (internalVertex.connectsAsTarget.length > 0) {
                                for (var k = 0; k < internalVertex.connectsAsTarget.length; k++) {
                                    var internalEdgese = internalVertex.connectsAsTarget[parseInt(k.toString(), 10)];
                                    var key = null;
                                    if (this.containsValue(matrixCellMapper[index - 1].value, internalEdgese.ids)) {
                                        key = internalEdgese.ids;
                                    }
                                    else if (this.containsValue(matrixCellMapper[index - 1].value, internalEdgese.source.id)) {
                                        key = internalEdgese.source.id;
                                    }
                                    if (key != null) {
                                        var parentcellValue = matrixCellMapper[index - 1].value;
                                        var parentMartixCell = void 0;
                                        for (var v = 0; v < parentcellValue.length; v++) {
                                            if (parentcellValue[parseInt(v.toString(), 10)].key === key) {
                                                parentMartixCell = parentcellValue[parseInt(v.toString(), 10)].value;
                                                break;
                                            }
                                        }
                                        if (!this.containsValue(matrixCell.parents, parentMartixCell)) {
                                            matrixCell.parents.push(parentMartixCell);
                                        }
                                        if (!this.containsValue(parentMartixCell.children, matrixCell)) {
                                            parentMartixCell.children.push(matrixCell);
                                        }
                                    }
                                }
                            }
                            // 933466: Excessive Spacing Between Nodes in Complex Hierarchical Tree Layout
                            var vertex = matrixCell.cells[parseInt(i.toString(), 10)];
                            if (rank.indexOf(vertex) !== -1) {
                                rank.splice(rank.indexOf(vertex), 1);
                            }
                        }
                    }
                    matrixCell.size += (matrixCell.cells.length - 1) * spacing;
                }
                else if (type === 'internalEdge') {
                    matrixCell.cells.push(layoutCell);
                    for (var i = 0; i < matrixCell.cells.length; i++) {
                        var internalEdge = matrixCell.cells[parseInt(i.toString(), 10)];
                        var type1 = this.getType(internalEdge.type);
                        if (type1 === 'internalEdge' && internalEdge.edges != null) {
                            // need to spacing based on its source and target Node
                            var edgeSpacing = 5;
                            var cellSize = -edgeSpacing;
                            for (var k = 0; k < internalEdge.edges.length; k++) {
                                //const internalConnector = internalEdge.edges[k];
                                // need to summ up the line width
                                cellSize += 1 + edgeSpacing;
                            }
                            matrixCell.size += cellSize;
                        }
                        tempMatrixRow.push({ key: internalEdge.ids, value: matrixCell });
                        var key = null;
                        if (this.containsValue(matrixCellMapper[index - 1].value, internalEdge.ids)) {
                            key = internalEdge.ids;
                        }
                        else if (this.containsValue(matrixCellMapper[index - 1].value, internalEdge.source.id)) {
                            key = internalEdge.source.id;
                        }
                        if (key != null) {
                            var parentcell = matrixCellMapper[index - 1].value;
                            var parentMartixCell = void 0;
                            for (var v = 0; v < parentcell.length; v++) {
                                if (parentcell[parseInt(v.toString(), 10)].key === key) {
                                    parentMartixCell = parentcell[parseInt(v.toString(), 10)].value;
                                    break;
                                }
                            }
                            if (!this.containsValue(matrixCell.parents, parentMartixCell)) {
                                matrixCell.parents.push(parentMartixCell);
                            }
                            if (!this.containsValue(parentMartixCell.children, matrixCell)) {
                                parentMartixCell.children.push(matrixCell);
                            }
                        }
                        // 933466: Excessive Spacing Between Nodes in Complex Hierarchical Tree Layout
                        var vertex = matrixCell.cells[parseInt(i.toString(), 10)];
                        if (rank.indexOf(vertex) !== -1) {
                            rank.splice(rank.indexOf(vertex), 1);
                        }
                    }
                    matrixCell.size += (matrixCell.cells.length - 1) * spacing;
                }
                if (matrixCell.cells.length) {
                    var internalVertices = matrixCell.cells.filter(function (e) { return e.type === 'internalVertex'; });
                    if (internalVertices.length > 0) {
                        var _loop_1 = function (cell) {
                            var vertex = cell.cell;
                            if (matrixModel.model.roots.some(function (root) { return root === vertex; })) {
                                matrixModel.roots.push(matrixCell);
                                return "break";
                            }
                        };
                        for (var _i = 0, internalVertices_1 = internalVertices; _i < internalVertices_1.length; _i++) {
                            var cell = internalVertices_1[_i];
                            var state_1 = _loop_1(cell);
                            if (state_1 === "break")
                                break;
                        }
                    }
                }
            }
            matrixModel.rowOffset.push(rowoffset + (maxDimension / 2) + spacingInverse);
            rowoffset += maxDimension + spacingInverse;
        }
    };
    MatrixModel.prototype.arrangeMatrix = function (cell, parent, matrixModel) {
        var layoutSettings = matrixModel.model.layout;
        var isHorizontal = layoutSettings.orientation === 'LeftToRight'
            || layoutSettings.orientation === 'RightToLeft';
        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
        var matrix = matrixModel.matrix;
        var matrixRow = matrix[cell.level].value;
        var matrixIndex = matrixRow.indexOf(cell);
        if (cell.visitedParents.length > 0) {
            if (cell.visitedParents.length === 1) {
                cell.initialOffset = cell.offset;
            }
            if (matrixIndex + 1 < matrixRow.length) {
                var nextCell = matrixRow[matrixIndex + 1];
                if (nextCell.visitedParents.length > 0) {
                    if (!this.containsValue(cell.visitedParents, parent)) {
                        cell.visitedParents.push(parent);
                        parent.ignoredChildren.push(cell);
                        return;
                    }
                }
            }
        }
        if (!(cell.children.length > 0)) {
            var validOffset = cell.offset;
            if (matrixIndex > 0) {
                var prevCell = matrixRow[matrixIndex - 1];
                validOffset = prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);
            }
            this.shiftMatrixCells(validOffset - cell.offset, cell, false, null, matrixModel);
        }
        else {
            for (var i = 0; i < cell.children.length; i++) {
                var matrixCellChild = cell.children[parseInt(i.toString(), 10)];
                if (!this.containsValue(cell.visitedChildren, matrixCellChild)) {
                    this.arrangeMatrix(matrixCellChild, cell, matrixModel);
                    cell.visitedChildren.push(matrixCellChild);
                }
            }
            if (cell.visitedChildren.length > 0) {
                var children = cell.visitedChildren.slice();
                for (var i = 0; i < cell.ignoredChildren.length; i++) {
                    //let cellIgnoredChild: MatrixCellGroupObject = cell.ignoredChildren[i];
                    children.splice(0, 1);
                    cell.visitedChildren.splice(0, 1);
                }
                if (children.length > 0) {
                    var firstChild = cell.visitedChildren[0];
                    var lastChild = cell.visitedChildren[cell.visitedChildren.length - 1];
                    var x1 = firstChild.offset - (firstChild.size / 2);
                    var x2 = lastChild.offset + (lastChild.size / 2);
                    var newoffset = (x1 + x2) / 2;
                    if (newoffset < cell.offset) {
                        this.shiftMatrixCells(cell.offset - newoffset, firstChild, true, cell, matrixModel);
                    }
                    else if (newoffset > cell.offset) {
                        this.shiftMatrixCells(newoffset - cell.offset, cell, false, null, matrixModel);
                    }
                }
            }
        }
        if (!this.containsValue(cell.visitedParents, parent)) {
            cell.visitedParents.push(parent);
        }
    };
    MatrixModel.prototype.findParentVertexCellGroup = function (cell) {
        if (cell.cells[0]) {
            return cell;
        }
        if (cell.parents.length > 0) {
            return this.findParentVertexCellGroup(cell.parents[0]);
        }
        return cell;
    };
    MatrixModel.prototype.translateMatrixCells = function (value, cell) {
        if (!(value === 0)) {
            cell.offset += value;
            if (cell.visitedChildren.length > 0) {
                for (var i = 0; i < cell.visitedChildren.length; i++) {
                    var cellVisitedChild = cell.visitedChildren[parseInt(i.toString(), 10)];
                    this.translateMatrixCells(value, cellVisitedChild);
                }
            }
        }
    };
    MatrixModel.prototype.setXYforMatrixCell = function (matrixModel) {
        var layoutSettings = matrixModel.model.layout;
        var isHorizontal = layoutSettings.orientation === 'LeftToRight'
            || layoutSettings.orientation === 'RightToLeft';
        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
        for (var i = 0; i < matrixModel.matrix.length; i++) {
            var matrixrow1 = matrixModel.matrix[parseInt(i.toString(), 10)].value;
            for (var j = 0; j < matrixrow1.length; j++) {
                var matrixCell = matrixrow1[parseInt(j.toString(), 10)];
                var start = matrixCell.offset - (matrixCell.size / 2);
                for (var k = 0; k < matrixCell.cells.length; k++) {
                    var cell = matrixCell.cells[parseInt(k.toString(), 10)];
                    var type = this.getType(cell.type);
                    if (type === 'internalVertex') {
                        var internalVertex = cell;
                        var width = internalVertex.cell.geometry.width;
                        var height = internalVertex.cell.geometry.height;
                        if (isHorizontal) {
                            internalVertex.cell.geometry = new Rect(matrixModel.rowOffset[matrixCell.level] - (width / 2), start, width, height);
                        }
                        else {
                            internalVertex.cell.geometry = new Rect(start, matrixModel.rowOffset[matrixCell.level] - (height / 2), width, height);
                        }
                        start += (isHorizontal ? height : width) + spacing;
                    }
                    else if (type === 'internalEdge') {
                        var internalEdges = cell;
                        var parent_1 = matrixCell.visitedParents[0];
                        if (parent_1) {
                            for (var l = 0; l < parent_1.visitedChildren.length; l++) {
                                var children = parent_1.visitedChildren[parseInt(l.toString(), 10)];
                                var cells = [];
                                for (var m = 0; m < children.cells.length; m++) {
                                    var cell_1 = children.cells[parseInt(m.toString(), 10)];
                                    var type_3 = this.getType(cell_1.type);
                                    if (type_3 === 'internalVertex') {
                                        cells.push(cell_1);
                                    }
                                }
                                if (cells.length > 0) {
                                    break;
                                }
                            }
                        }
                        // Need to updated line width
                        var lineWidth = 1;
                        var edgeSpacing = 5;
                        for (var m = 0; m < internalEdges.edges.length; m++) {
                            var internalConnector = internalEdges.edges[parseInt(m.toString(), 10)];
                            var pt = this.getPointvalue(start + (lineWidth / 2.0), matrixModel.rowOffset[matrixCell.level]);
                            if (isHorizontal) {
                                pt = this.getPointvalue(matrixModel.rowOffset[matrixCell.level], start + (lineWidth / 2.0));
                            }
                            if (this.containsValue(this.getEdgeMapper(), internalConnector)) {
                                var key = void 0;
                                for (var l = 0; l < this.getEdgeMapper().length; l++) {
                                    if ((this.getEdgeMapper())[parseInt(l.toString(), 10)].key === internalConnector) {
                                        key = l;
                                        break;
                                    }
                                }
                                (this.getEdgeMapper())[parseInt(key.toString(), 10)].value.push(pt);
                            }
                            start += lineWidth + edgeSpacing;
                        }
                        start += spacing;
                    }
                }
            }
        }
    };
    MatrixModel.prototype.getType = function (type) {
        if (type === 'internalVertex') {
            return 'internalVertex';
        }
        else {
            return 'internalEdge';
        }
    };
    MatrixModel.prototype.selectIds = function (node, source) {
        var returnIds = [];
        for (var i = 0; i < node.length; i++) {
            var connector = node[parseInt(i.toString(), 10)];
            if (source) {
                {
                    returnIds.push(connector.source.id);
                }
            }
            else {
                returnIds.push(connector.target.id);
            }
        }
        return returnIds;
    };
    MatrixModel.prototype.compareLists = function (list1, list2) {
        var newList1 = list1.slice();
        var newList2 = list2.slice();
        if (newList1.length === newList2.length) {
            if (newList1.length === 0) {
                return true;
            }
            else {
                var isSame = true;
                for (var i = 0; i < newList2.length; i++) {
                    var o = newList2[parseInt(i.toString(), 10)];
                    // EJ2-63944 - Nodes overlapping in Complex hierarchical tree layout in linear arrangement.
                    if (newList1.indexOf(o) === -1) {
                        isSame = false;
                        break;
                    }
                }
                return isSame;
            }
        }
        return false;
    };
    MatrixModel.prototype.updateMutualSharing = function (cell, id) {
        if (cell.identicalSibiling != null) {
            cell.identicalSibiling.push(id);
        }
        else {
            cell.identicalSibiling = [];
            cell.identicalSibiling.push(id);
        }
    };
    MatrixModel.prototype.containsValue = function (list, keyValue) {
        for (var i = 0; i < list.length; i++) {
            if (list[parseInt(i.toString(), 10)].key === keyValue
                || list[parseInt(i.toString(), 10)] === keyValue) {
                return true;
            }
        }
        return false;
    };
    MatrixModel.prototype.shiftMatrixCells = function (value, startingCell, shiftChildren, parentCell, matrixModel) {
        if (!(value === 0)) {
            var matrix = matrixModel.matrix;
            var matrixRow = matrix[startingCell.level].value;
            var index = matrixRow.indexOf(startingCell);
            for (var i = index; i < matrixRow.length; i++) {
                matrixRow[parseInt(i.toString(), 10)].offset += value;
            }
            if (shiftChildren) {
                if (startingCell.visitedChildren.length > 0) {
                    this.shiftMatrixCells(value, startingCell.visitedChildren[0], true, startingCell, matrixModel);
                }
                else {
                    var i = 1;
                    var nextSibilingwithChild = null;
                    while (index + i < matrixRow.length) {
                        var nextCell = matrixRow[index + i];
                        if (parentCell != null && this.containsValue(nextCell.visitedParents, parentCell)) {
                            if (nextCell.visitedChildren.length > 0) {
                                nextSibilingwithChild = nextCell;
                            }
                            else {
                                i++;
                                continue;
                            }
                        }
                        break;
                    }
                    if (nextSibilingwithChild != null) {
                        this.shiftMatrixCells(value, nextSibilingwithChild.visitedChildren[0], true, nextSibilingwithChild, matrixModel);
                    }
                }
            }
        }
    };
    MatrixModel.prototype.getPointvalue = function (x, y) {
        return { 'x': Number(x) || 0, 'y': Number(y) || 0 };
    };
    MatrixModel.prototype.getEdgeMapper = function () {
        return this.edgeMapper;
    };
    MatrixModel.prototype.setEdgeMapper = function (value) {
        this.edgeMapper.push(value);
    };
    MatrixModel.prototype.updateLayout = function (viewPort, modelBounds, layoutProp, layout, nodeWithMultiEdges, nameTable) {
        var trnsX = ((viewPort.x - modelBounds.width) / 2) - modelBounds.x;
        var trnsY = ((viewPort.y - modelBounds.height) / 2) - modelBounds.y;
        trnsX = Math.round(trnsX);
        trnsY = Math.round(trnsY);
        var modifiedConnectors = [];
        var transModelBounds = new Rect(modelBounds.x + trnsX, modelBounds.y + trnsY, modelBounds.width, modelBounds.height);
        var margin = layoutProp.margin;
        var isHorizontal = layout.orientation === 'RightToLeft' || layout.orientation === 'LeftToRight';
        var inversespacing = !isHorizontal ? layout.verticalSpacing : layout.horizontalSpacing;
        for (var i = 0; i < nodeWithMultiEdges.length; i++) {
            var node = nodeWithMultiEdges[parseInt(i.toString(), 10)];
            if (node.outEdges != null && node.outEdges.length > 0) {
                var count = node.outEdges.length;
                for (var j = 0; j < count; j++) {
                    var internalConnector = nameTable[node.outEdges[parseInt(j.toString(), 10)]];
                    internalConnector['pointCollection'] = [];
                    if (count > 1) {
                        var segmentsize = inversespacing / 2.0;
                        var intermediatePoint = null;
                        var key = void 0;
                        var edgeMapper = this.getEdgeMapper();
                        for (var k = 0; k < edgeMapper.length; k++) {
                            if (edgeMapper[parseInt(k.toString(), 10)].key === internalConnector) {
                                key = k;
                                break;
                            }
                        }
                        if (key && edgeMapper[parseInt(key.toString(), 10)].value.length > 0) {
                            var edgePoint = edgeMapper[parseInt(key.toString(), 10)].value[0];
                            var dxValue1 = edgePoint.x + margin.left;
                            var dyValue1 = edgePoint.y + margin.top;
                            var x1 = dxValue1;
                            var y1 = dyValue1;
                            if (layout.orientation === 'BottomToTop') {
                                y1 = modelBounds.height - dyValue1;
                            }
                            else if (layout.orientation === 'RightToLeft') {
                                x1 = modelBounds.width - dxValue1;
                            }
                            if (modelBounds.x < 0) {
                                x1 -= modelBounds.x;
                            }
                            if (modelBounds.y < 0) {
                                y1 -= modelBounds.y;
                            }
                            intermediatePoint = this.getPointvalue(x1, y1);
                        }
                        var pts = [];
                        for (var i_1 = 0; i_1 < internalConnector.segments.length; i_1++) {
                            var pt = internalConnector.segments[parseInt(i_1.toString(), 10)].points;
                            // eslint-disable-next-line guard-for-in
                            for (var temp in pt) {
                                pts.push(pt[parseInt(temp.toString(), 10)]);
                            }
                        }
                        // eslint-disable-next-line max-len
                        pts = this.updateConnectorPoints(pts, segmentsize, intermediatePoint, transModelBounds, layout.orientation);
                        // 933466: Excessive Spacing Between Nodes in Complex Hierarchical Tree Layout
                        if (intermediatePoint != null && this.diagram.layout.connectionPointOrigin !== 'DifferentPoint') {
                            for (var p = 0; p < pts.length; p++) {
                                var pt = pts[parseInt(p.toString(), 10)];
                                internalConnector['pointCollection'].push(this.getPointvalue(pt.x, pt.y));
                            }
                        }
                        this.resetConnectorPoints(internalConnector);
                    }
                    modifiedConnectors.push(internalConnector);
                }
            }
            if (node.inEdges != null && node.inEdges.length > 1) {
                var count = node.inEdges.length;
                var edgeMapper = this.getEdgeMapper();
                for (var j = 0; j < count; j++) {
                    var internalConnector = nameTable[node.inEdges[parseInt(j.toString(), 10)]];
                    if (!this.containsValue(modifiedConnectors, internalConnector)) {
                        internalConnector['pointCollection'] = [];
                    }
                    if (count > 1) {
                        var segmentsize = inversespacing / 2.0;
                        var intermediatePoint = null;
                        var key = void 0;
                        var k = void 0;
                        for (k = 0; k < edgeMapper.length; k++) {
                            if (edgeMapper[parseInt(k.toString(), 10)].key === internalConnector) {
                                key = k;
                                break;
                            }
                        }
                        if (key && edgeMapper[parseInt(key.toString(), 10)].value.length > 0
                            && !this.containsValue(modifiedConnectors, internalConnector)) {
                            var edgePt = edgeMapper[parseInt(k.toString(), 10)].value[0];
                            var dx1 = edgePt.x + margin.left;
                            var dy1 = edgePt.y + margin.top;
                            // eslint-disable-next-line one-var
                            var x1 = dx1, y1 = dy1;
                            if (layout.orientation === 'BottomToTop') {
                                y1 = modelBounds.height - dy1;
                            }
                            else if (layout.orientation === 'RightToLeft') {
                                x1 = modelBounds.width - dx1;
                            }
                            if (modelBounds.x < 0) {
                                x1 -= modelBounds.x;
                            }
                            if (modelBounds.y < 0) {
                                y1 -= modelBounds.y;
                            }
                            intermediatePoint = this.getPointvalue(x1, y1);
                        }
                        var pts = [];
                        for (var p = 0; p < internalConnector.segments.length; p++) {
                            var pt = internalConnector.segments[parseInt(p.toString(), 10)].points;
                            // eslint-disable-next-line guard-for-in
                            for (var temp in pt) {
                                pts.push(pt[parseInt(temp.toString(), 10)]);
                            }
                        }
                        pts.reverse();
                        // eslint-disable-next-line
                        pts = this.updateConnectorPoints(pts, segmentsize, intermediatePoint, transModelBounds, layoutProp.orientation);
                        pts.reverse();
                        internalConnector['pointCollection'] = [];
                        // 933466: Excessive Spacing Between Nodes in Complex Hierarchical Tree Layout
                        if (intermediatePoint != null && this.diagram.layout.connectionPointOrigin !== 'DifferentPoint') {
                            for (var p = 0; p < pts.length; p++) {
                                var pt = pts[parseInt(p.toString(), 10)];
                                internalConnector['pointCollection'].push(this.getPointvalue(pt.x, pt.y));
                            }
                        }
                        this.resetConnectorPoints(internalConnector);
                    }
                }
            }
        }
    };
    MatrixModel.prototype.inflate = function (rect, x, y) {
        rect.x -= x;
        rect.y -= y;
        rect.width += 2 * x;
        rect.height += 2 * y;
        return rect;
    };
    MatrixModel.prototype.updateConnectorPoints = function (connectorPoints, startSegmentSize, intermediatePoint, bounds, orientation) {
        var isHorizontal = orientation === 'LeftToRight' || orientation === 'RightToLeft';
        var pts = connectorPoints;
        var startPoint = pts[0];
        var endPoint = pts[pts.length - 1];
        if (intermediatePoint != null) {
            var startNext = Point.transform(startPoint, Point.findAngle(startPoint, pts[1]), startSegmentSize);
            var endBefore = Point.transform(endPoint, Point.findAngle(endPoint, pts[pts.length - 2]), startSegmentSize);
            var intermediateStart = this.getPointvalue(intermediatePoint.x, startNext.y);
            var intermediateEnd = this.getPointvalue(intermediatePoint.x, endBefore.y);
            if (isHorizontal) {
                intermediateStart.x = startNext.x;
                intermediateStart.y = intermediatePoint.y;
                intermediateEnd.x = endBefore.x;
                intermediateEnd.y = intermediatePoint.y;
            }
            var length_2 = Math.abs(Point.findAngle(intermediateEnd, endBefore));
            if (length_2 < 0.1) {
                return [startPoint, startNext, intermediateStart, endBefore, endPoint];
            }
            return [startPoint, startNext, intermediateStart, intermediateEnd, endBefore, endPoint];
        }
        else if (pts.length === 4) {
            var startNext = Point.transform(startPoint, Point.findAngle(startPoint, pts[1]), startSegmentSize);
            var intermediateStart = this.getPointvalue(pts[2].x, startNext.y);
            if (isHorizontal) {
                intermediateStart.x = startNext.x;
                intermediateStart.y = pts[2].y;
            }
            return [startPoint, startNext, intermediateStart, endPoint];
        }
        return pts;
    };
    MatrixModel.prototype.resetConnectorPoints = function (edge) {
        // 933466: Excessive Spacing Between Nodes in Complex Hierarchical Tree Layout
        if (edge['pointCollection'] && edge['pointCollection'].length > 0) {
            var connector = edge;
            connector.sourcePoint = edge['pointCollection'][0];
            connector.targetPoint = edge['pointCollection'][edge['pointCollection'].length - 1];
            var segments = [];
            for (var i = 0; i < edge['pointCollection'].length - 1; i++) {
                var point1 = edge['pointCollection'][parseInt(i.toString(), 10)];
                var point2 = edge['pointCollection'][i + 1];
                var length_3 = findDistance(point1, point2);
                var direction = getConnectorDirection(point1, point2);
                if (i === edge['pointCollection'].length - 2) {
                    if ((this.diagram.layout.orientation === 'RightToLeft' && direction === 'Left')
                        || (this.diagram.layout.orientation === 'LeftToRight' && direction === 'Right')
                        || (this.diagram.layout.orientation === 'TopToBottom' && direction === 'Bottom')
                        || (this.diagram.layout.orientation === 'BottomToTop' && direction === 'Top')) {
                        length_3 = length_3 / 2;
                    }
                }
                /* tslint:enable */
                var tempSegment = new OrthogonalSegment(edge, 'segments', { type: 'Orthogonal' }, true);
                tempSegment.length = length_3;
                tempSegment.direction = direction;
                segments.push(tempSegment);
            }
            connector.segments = segments;
            connector.type = 'Orthogonal';
            this.diagram.connectorPropertyChange(connector, {}, {
                type: 'Orthogonal',
                segments: connector.segments
            });
        }
        else if (this.diagram.layout.connectionPointOrigin === 'DifferentPoint') {
            var obstacleCollection = 'obstaclePointCollection';
            if (edge.segments[0].points
                && edge.segments[0].points.length > 0 && edge["" + obstacleCollection]) {
                var connector = edge;
                connector.sourcePoint = edge["" + obstacleCollection][0];
                connector.targetPoint = edge["" + obstacleCollection][edge["" + obstacleCollection].length - 1];
                var segments = [];
                for (var i = 0; i < edge["" + obstacleCollection].length - 1; i++) {
                    var point1 = edge["" + obstacleCollection][parseInt(i.toString(), 10)];
                    var point2 = edge["" + obstacleCollection][i + 1];
                    var length_4 = findDistance(point1, point2);
                    var direction = getConnectorDirection(point1, point2);
                    if (i === edge["" + obstacleCollection].length - 2) {
                        if ((this.diagram.layout.orientation === 'RightToLeft' && direction === 'Left')
                            || (this.diagram.layout.orientation === 'LeftToRight' && direction === 'Right')
                            || (this.diagram.layout.orientation === 'TopToBottom' && direction === 'Bottom')
                            || (this.diagram.layout.orientation === 'BottomToTop' && direction === 'Top')) {
                            length_4 = length_4 / 2;
                        }
                    }
                    /* tslint:enable */
                    var tempSegment = new OrthogonalSegment(edge, 'segments', { type: 'Orthogonal' }, true);
                    tempSegment.length = length_4;
                    tempSegment.direction = direction;
                    segments.push(tempSegment);
                }
                connector.segments = segments;
                connector.type = 'Orthogonal';
                this.diagram.connectorPropertyChange(connector, {}, {
                    type: 'Orthogonal',
                    segments: connector.segments
                });
            }
        }
    };
    MatrixModel.prototype.nodePropertyChange = function (dnode) {
        // 933466: Excessive Spacing Between Nodes in Complex Hierarchical Tree Layout
        this.diagram.nodePropertyChange(dnode, {}, { offsetX: dnode.offsetX, offsetY: dnode.offsetY });
    };
    return MatrixModel;
}());

var FlowchartModel = /** @class */ (function () {
    function FlowchartModel(layout, root, vertices) {
        var _this = this;
        this.dfsCount = 0;
        this.maxRank = 100000000;
        this.layout = layout;
        this.vertexMapper = new Map();
        this.ranks = new Map();
        var internalVertices = [];
        this.createInternalCells(vertices, internalVertices);
        internalVertices.forEach(function (internalVertex) {
            var edges = internalVertex.internalOutEdges;
            edges.forEach(function (internalEdge) {
                var realEdges = internalEdge.edges;
                if (realEdges && realEdges.length > 0) {
                    var realEdge = realEdges[0];
                    var targetCell = _this.layout.getVisibleTerminal(realEdge, false);
                    var internalTargetCell = _this.vertexMapper.get(targetCell.id);
                    if (internalVertex === internalTargetCell) {
                        targetCell = _this.layout.getVisibleTerminal(realEdge, true);
                        internalTargetCell = _this.vertexMapper.get(targetCell.id);
                    }
                    if (internalTargetCell && internalVertex !== internalTargetCell) {
                        internalEdge.target = internalTargetCell;
                        if (internalVertex.internalInEdges.indexOf(internalEdge) === -1) {
                            internalTargetCell.internalInEdges.push(internalEdge);
                        }
                    }
                }
            });
        });
        this.rootNode = this.vertexMapper.get(root.id);
    }
    FlowchartModel.prototype.createInternalCells = function (vertices, internalVertices) {
        for (var j = 0; j < vertices.length; j++) {
            var vertex = vertices[parseInt(j.toString(), 10)];
            var internalVertex = {
                tempRank: -1, cell: vertex, hashCode: [], maxRank: null, minRank: null,
                id: vertex.id, internalOutEdges: [], internalInEdges: [], identicalSibling: []
            };
            internalVertices.push(internalVertex);
            this.vertexMapper.set(vertex.id, internalVertex);
            var connectors = this.layout.getEdges(vertex);
            var i = 0;
            while (i < connectors.length) {
                var connector = connectors[parseInt(i.toString(), 10)];
                var childVertex = this.layout.getVisibleTerminal(connector, false);
                if (childVertex !== vertex) {
                    var undirectedEdges = this.layout.getEdgesBetween(vertex, childVertex, true);
                    if (undirectedEdges.length > 0) {
                        var internalEdge = {
                            connectorIds: [], edges: undirectedEdges, ids: [], isReversed: false,
                            source: null, target: null, tempRank: 0, maxRank: null, minRank: null
                        };
                        for (var k = 0; k < undirectedEdges.length; k++) {
                            var undirectedEdge = undirectedEdges[parseInt(k.toString(), 10)];
                            //   if (!undirectedEdge.id) {
                            //     undirectedEdge.id = randomId();
                            //   }
                            internalEdge.ids.push(undirectedEdge.id);
                            if (connectors.indexOf(undirectedEdge) !== -1) {
                                if (connectors.indexOf(undirectedEdge) < i) {
                                    i--;
                                }
                                connectors.splice(connectors.indexOf(undirectedEdge), 1);
                            }
                        }
                        internalEdge.source = internalVertex;
                        if (internalVertex.internalOutEdges.indexOf(internalEdge) === -1) {
                            internalVertex.internalOutEdges.push(internalEdge);
                        }
                    }
                }
                else {
                    i++;
                }
            }
        }
    };
    //Initializes the ranks of the vertices
    /**
     * @Private
     * @returns { void }  Initializes the ranks of the vertices .\
     */
    FlowchartModel.prototype.layeringStage = function () {
        this.recycleConnectors();
        this.initialRank();
        this.fixRanks();
    };
    FlowchartModel.prototype.recycleConnectors = function () {
        var startNodes = [this.rootNode];
        this.visit(startNodes, true);
    };
    FlowchartModel.prototype.initialRank = function () {
        var startNodes = [this.rootNode];
        var internalNodes = Array.from(this.vertexMapper.values());
        while (startNodes.length > 0) {
            var internalNode = startNodes[0];
            var outEdges = internalNode.internalOutEdges;
            var inEdges = internalNode.internalInEdges;
            var allEdgesScanned = true;
            var minimumLayer = 100000000;
            for (var i = 0; i < inEdges.length; i++) {
                var internalEdge = inEdges[parseInt(i.toString(), 10)];
                if (internalEdge.tempRank === 5270620) {
                    // This edge has been scanned, get the layer of the node on the other end
                    var otherNode = internalEdge.source;
                    minimumLayer = otherNode.tempRank ? Math.min(minimumLayer, otherNode.tempRank - 1) : minimumLayer;
                }
                else {
                    allEdgesScanned = false;
                    break;
                }
            }
            // If all edge have been scanned, assign the layer, mark all edges in the other direction and remove from the nodes list
            if (allEdgesScanned) {
                internalNode.tempRank = minimumLayer;
                this.maxRank = Math.min(this.maxRank, minimumLayer);
                if (outEdges.length) {
                    if (internalNode.cell.isDecisionNode) {
                        var yesChild = outEdges.find(function (e) { return e.target.cell.isYesChild; });
                        var decisionNode = outEdges.find(function (e) { return e.target.cell.isDecisionNode; });
                        if (outEdges.indexOf(decisionNode) === -1 && outEdges.indexOf(yesChild) !== 0) {
                            outEdges.reverse();
                        }
                        if (this.layout.yesBranchDirection === 'RightInFlow'
                            || (this.layout.yesBranchDirection === 'SameAsFlow'
                                && this.layout.noBranchDirection === 'LeftInFlow')) {
                            outEdges.reverse();
                        }
                    }
                    for (var i = 0; i < outEdges.length; i++) {
                        var internalEdge = outEdges[parseInt(i.toString(), 10)];
                        internalEdge.tempRank = 5270620;
                        // Add node on other end of edge to LinkedList of nodes to be analysed
                        var otherNode = internalEdge.target;
                        // Only add node if it hasn't been assigned a layer
                        if (otherNode.tempRank === -1) {
                            // Mark this other node as neither being unassigned nor assigned
                            //so it isn't added to this list again, but it's layer isn't used in any calculation.
                            otherNode.tempRank = -2;
                            startNodes.push(otherNode);
                        }
                    }
                }
                startNodes.shift();
            }
            else {
                // Not all the edges have been scanned, get to the back of the class and put the dunces cap on
                var removedCell = startNodes.shift();
                startNodes.push(internalNode);
                if (removedCell === internalNode && startNodes.length === 1) {
                    // This is an error condition, we can't get out of this loop.
                    //It could happen for more than one node but that's a lot harder to detect. Log the error
                    break;
                }
            }
        }
        for (var i = 0; i < internalNodes.length; i++) {
            internalNodes[parseInt(i.toString(), 10)].tempRank -= this.maxRank;
        }
        var currentMaxLayer = 0;
        var layerDeterminingEdges = this.rootNode.internalOutEdges;
        for (var j = 0; j < layerDeterminingEdges.length; j++) {
            var internalEdge = layerDeterminingEdges[parseInt(j.toString(), 10)];
            var otherNode = internalEdge.target;
            this.rootNode.tempRank = (otherNode.tempRank !== undefined && otherNode.tempRank !== null) ?
                Math.max(currentMaxLayer, otherNode.tempRank + 1) : currentMaxLayer;
            currentMaxLayer = this.rootNode.tempRank;
        }
        this.maxRank = 100000000 - this.maxRank;
    };
    FlowchartModel.prototype.fixRanks = function () {
        var rankList = new Map();
        this.ranks = new Map();
        for (var i = 0; i <= this.maxRank; i++) {
            rankList.set(i, []);
            this.ranks.set(i, rankList.get(i));
        }
        var rootsArray = [this.rootNode];
        this.visit(rootsArray, false, rankList);
    };
    /**
     * used to visit all the entries on the given dictionary with given function \
     *
     * @returns { void }  used to visit all the entries on the given dictionary with given function .\
     * @param {InternalVertex[]} dfsRoots - provide the dfsRoots value.
     * @param {boolean} trackAncestors - provide the trackAncestors value.
     * @param {Map<number, []>} rankList - provide the rankList value.
     * @private
     */
    FlowchartModel.prototype.visit = function (dfsRoots, trackAncestors, rankList) {
        if (rankList === void 0) { rankList = null; }
        if (dfsRoots) {
            for (var i = 0; i < dfsRoots.length; i++) {
                var internalNode = dfsRoots[parseInt(i.toString(), 10)];
                if (internalNode) {
                    var seenNodes = new Map();
                    if (trackAncestors) {
                        internalNode.hashCode = [this.dfsCount, i];
                        this.extendedDfs(null, internalNode, null, seenNodes, i);
                    }
                    else {
                        this.depthFirstSearch(null, internalNode, null, seenNodes, rankList);
                    }
                }
            }
            this.dfsCount++;
        }
    };
    FlowchartModel.prototype.extendedDfs = function (parent, root, connectingEdge, seen, childHash) {
        var _this = this;
        if (parent) {
            if (!root.hashCode || root.hashCode[0] !== parent.hashCode[0]) {
                root.hashCode = parent.hashCode.concat([childHash]);
            }
        }
        var rootId = root.id;
        if (!seen.has(rootId)) {
            seen.set(rootId, root);
            this.removeConnectionEdge(parent, root, connectingEdge);
            var outgoingEdges = root.internalOutEdges.slice();
            outgoingEdges.forEach(function (internalEdge, i) {
                var targetNode = internalEdge.target;
                _this.extendedDfs(root, targetNode, internalEdge, seen, i);
            });
        }
        else {
            this.removeConnectionEdge(parent, root, connectingEdge);
        }
    };
    FlowchartModel.prototype.removeConnectionEdge = function (parent, node, connectingEdge) {
        if (parent && this.isAncestor(node, parent)) {
            this.invert(connectingEdge);
            this.remove(connectingEdge, parent.internalOutEdges);
            parent.internalInEdges.push(connectingEdge);
            this.remove(connectingEdge, node.internalInEdges);
            node.internalOutEdges.push(connectingEdge);
        }
    };
    FlowchartModel.prototype.invert = function (edge) {
        var temp = edge.source;
        edge.source = edge.target;
        edge.target = temp;
        edge.isReversed = !edge.isReversed;
    };
    FlowchartModel.prototype.remove = function (edge, edges) {
        var index = edges.indexOf(edge);
        edges.splice(index, 1);
    };
    FlowchartModel.prototype.isAncestor = function (node, otherNode) {
        // Firstly, the hash code of this node needs to be shorter than the other node
        if (otherNode !== null && node.hashCode !== null && otherNode.hashCode !== null
            && node.hashCode.length < otherNode.hashCode.length) {
            if (node.hashCode === otherNode.hashCode) {
                return true;
            }
            for (var i = 0; i < node.hashCode.length; i++) {
                if (node.hashCode[parseInt(i.toString(), 10)] !== otherNode.hashCode[parseInt(i.toString(), 10)]) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };
    FlowchartModel.prototype.depthFirstSearch = function (parent, root, connectingEdge, seen, rankList) {
        var _this = this;
        var rootId = root.id;
        if (!seen.has(rootId)) {
            seen.set(rootId, root);
            this.updateMinMaxRank(parent, root, connectingEdge, 0, rankList);
            var outgoingEdges = root.internalOutEdges.slice();
            outgoingEdges.forEach(function (internalEdge) {
                var targetNode = internalEdge.target;
                _this.depthFirstSearch(root, targetNode, internalEdge, seen, rankList);
            });
        }
        else {
            this.updateMinMaxRank(parent, root, connectingEdge, 1, rankList);
        }
    };
    FlowchartModel.prototype.updateMinMaxRank = function (parent, node, edge, seen, rankList) {
        var rankListArray = Array.from(rankList.values());
        if (node.maxRank == null && node.maxRank !== 0) {
            node.maxRank = -1;
        }
        if (node.minRank == null && node.minRank !== 0) {
            node.minRank = -1;
        }
        if (seen === 0 && node.maxRank < 0 && node.minRank < 0) {
            if (node.tempRank >= 0) {
                var rank = node.tempRank;
                rankListArray[parseInt(rank.toString(), 10)].push(node);
                node.maxRank = rank;
                node.minRank = rank;
                node.tempRank = rankListArray[node.maxRank].length - 1;
            }
        }
        if (parent !== null && edge !== null) {
            var parentToCellRankDifference = parent.maxRank - node.maxRank;
            if (parentToCellRankDifference > 1) {
                edge.maxRank = parent.maxRank;
                edge.minRank = node.maxRank;
                for (var i = edge.minRank + 1; i < edge.maxRank; i++) {
                    rankListArray[parseInt(i.toString(), 10)].push(edge);
                    // CheckMe
                    // this.layout.setTempVariable(edge, i, rankList[i].length - 1);
                }
            }
            else if (edge.isReversed) {
                edge.maxRank = parent.maxRank;
                edge.minRank = node.maxRank;
                for (var i = edge.minRank; i <= edge.maxRank; i++) {
                    rankListArray[parseInt(i.toString(), 10)].push(edge);
                }
            }
        }
    };
    return FlowchartModel;
}());

var MatrixModel$1 = /** @class */ (function () {
    function MatrixModel(model) {
        this.flowchartModel = model;
        this.matrix = [];
        this.rowOffset = [];
        this.rowMaxDimension = [];
        this.siblingModel = null;
    }
    /**
     * @private
     * @returns {void} - Arranges the elements in the flowchart layout
     */
    MatrixModel.prototype.arrangeElements = function () {
        if (this.flowchartModel === null) {
            return;
        }
        var layoutSettings = this.flowchartModel.layout;
        var isHorizontal = layoutSettings.orientation === 'LeftToRight';
        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
        this.groupLayoutCells();
        this.createMatrixCells();
        for (var _i = 0, _a = this.matrix; _i < _a.length; _i++) {
            var matrixRow = _a[_i];
            for (var i = 1; i < matrixRow.length; i++) {
                var cell = matrixRow[parseInt(i.toString(), 10)];
                var prevCell = matrixRow[i - 1];
                cell.offset += prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);
            }
        }
        for (var _b = 0, _c = this.matrix[0]; _b < _c.length; _b++) {
            var root = _c[_b];
            this.arrangeMatrix(root, null);
        }
        for (var _d = 0, _e = this.matrix; _d < _e.length; _d++) {
            var row = _e[_d];
            for (var i = 0; i < row.length; i++) {
                var cell = row[parseInt(i.toString(), 10)];
                if (cell.visitedParents.length > 1) {
                    var firstParent = cell.visitedParents[0];
                    var lastParent = cell.visitedParents[cell.visitedParents.length - 1];
                    var firstVertexParent = this.findParentVertexCellGroup(firstParent);
                    var lastVertexParent = this.findParentVertexCellGroup(lastParent);
                    if (firstParent !== firstVertexParent && firstVertexParent.offset < firstParent.offset) {
                        firstParent = firstVertexParent;
                    }
                    if (lastParent !== lastVertexParent && lastVertexParent.offset > lastParent.offset) {
                        lastParent = firstVertexParent;
                    }
                    var newOffset = (firstParent.offset + lastParent.offset) / 2;
                    var interVertex = cell.cells.find(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; });
                    if (this.flowchartModel.layout.yesBranchDirection === 'SameAsFlow') {
                        var tempVisitedParents = cell.visitedParents.slice();
                        if (interVertex && interVertex.cell.isYesChild) {
                            for (var _f = 0, tempVisitedParents_1 = tempVisitedParents; _f < tempVisitedParents_1.length; _f++) {
                                var tempParent = tempVisitedParents_1[_f];
                                var tempParentVertex = tempParent.cells.find(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; });
                                if (!tempParentVertex) {
                                    newOffset = tempParent.offset;
                                    break;
                                }
                            }
                        }
                        else {
                            if (this.flowchartModel.layout.noBranchDirection === 'LeftInFlow') {
                                tempVisitedParents.reverse();
                            }
                            for (var _g = 0, tempVisitedParents_2 = tempVisitedParents; _g < tempVisitedParents_2.length; _g++) {
                                var tempParent = tempVisitedParents_2[_g];
                                var tempParentVertex = tempParent.cells.find(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; });
                                if (tempParentVertex) {
                                    if (tempParentVertex.cell.isYesChild) {
                                        newOffset = tempParent.offset;
                                        break;
                                    }
                                }
                                else {
                                    var tempSuperParent = this.findParentVertexCellGroup(tempParent);
                                    if (tempSuperParent) {
                                        var superParentVertex = tempSuperParent.cells.find(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; });
                                        if (superParentVertex && superParentVertex.cell.isYesChild) {
                                            newOffset = tempParent.offset;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else if (this.flowchartModel.layout.noBranchDirection === 'SameAsFlow') {
                        var tempVisitedParents = cell.visitedParents.slice();
                        if (interVertex && interVertex.cell.isNoChild) {
                            for (var _h = 0, tempVisitedParents_3 = tempVisitedParents; _h < tempVisitedParents_3.length; _h++) {
                                var tempParent = tempVisitedParents_3[_h];
                                var tempParentVertex = tempParent.cells.find(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; });
                                if (!tempParentVertex) {
                                    newOffset = tempParent.offset;
                                    break;
                                }
                            }
                        }
                        else {
                            if (this.flowchartModel.layout.yesBranchDirection === 'LeftInFlow') {
                                tempVisitedParents.reverse();
                            }
                            for (var _j = 0, tempVisitedParents_4 = tempVisitedParents; _j < tempVisitedParents_4.length; _j++) {
                                var tempParent = tempVisitedParents_4[_j];
                                var tempParentVertex = tempParent.cells.find(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; });
                                if (tempParentVertex) {
                                    if (tempParentVertex.cell.isNoChild) {
                                        newOffset = tempParent.offset;
                                        break;
                                    }
                                }
                                else {
                                    var tempSuperParent = this.findParentVertexCellGroup(tempParent);
                                    if (tempSuperParent) {
                                        var superParentVertex = tempSuperParent.cells.find(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; });
                                        if (superParentVertex && superParentVertex.cell.isNoChild) {
                                            newOffset = tempParent.offset;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    var availOffsetMin = cell.initialOffset;
                    var availOffsetMax = cell.offset;
                    if (availOffsetMax !== availOffsetMin) {
                        if (newOffset >= availOffsetMin && newOffset <= availOffsetMax) {
                            this.translateMatrixCells(newOffset - cell.offset, cell);
                        }
                        else if (newOffset < availOffsetMin) {
                            this.translateMatrixCells(availOffsetMin - cell.offset, cell);
                        }
                    }
                }
            }
        }
        this.setXYForMatrixCell();
    };
    MatrixModel.prototype.arrangeMatrix = function (cell, parent) {
        var layoutSettings = this.flowchartModel.layout;
        var isHorizontal = layoutSettings.orientation === 'LeftToRight';
        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
        var matrixRow = this.matrix[cell.level];
        var matrixIndex = matrixRow.indexOf(cell);
        if (cell.visitedParents.length) {
            if (cell.visitedParents.length === 1) {
                cell.initialOffset = cell.offset;
            }
            if (matrixIndex + 1 < matrixRow.length) {
                var nextCell = matrixRow[matrixIndex + 1];
                if (nextCell.visitedParents.length) {
                    if (cell.visitedParents.indexOf(parent) === -1) {
                        if (cell.level !== parent.level) {
                            cell.visitedParents.push(parent);
                            parent.ignoredChildren.push(cell);
                        }
                        return;
                    }
                }
            }
        }
        if (!cell.children.length) {
            var validOffset = cell.offset;
            if (matrixIndex > 0) {
                var prevCell = matrixRow[matrixIndex - 1];
                validOffset = prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);
            }
            this.shiftMatrixCells(validOffset - cell.offset, cell);
        }
        else {
            for (var _i = 0, _a = cell.children; _i < _a.length; _i++) {
                var matrixCellChild = _a[_i];
                if (cell.visitedChildren.indexOf(matrixCellChild)) {
                    this.arrangeMatrix(matrixCellChild, cell);
                    if (cell.level !== matrixCellChild.level) {
                        cell.visitedChildren.push(matrixCellChild);
                    }
                    else {
                        cell.loopChildren.push(matrixCellChild);
                    }
                }
            }
            if (cell.visitedChildren.length) {
                var children = cell.visitedChildren.slice();
                var _loop_1 = function (cellIgnoredChild) {
                    children = children.filter(function (child) { return child !== cellIgnoredChild; });
                };
                for (var _b = 0, _c = cell.ignoredChildren; _b < _c.length; _b++) {
                    var cellIgnoredChild = _c[_b];
                    _loop_1(cellIgnoredChild);
                }
                if (children.length) {
                    var firstChild = children[0];
                    var lastChild = children[children.length - 1];
                    var x1 = firstChild.offset;
                    var x2 = lastChild.offset;
                    var newOffset = (x1 + x2) / 2;
                    if (cell.cells.length) {
                        var interVertex = cell.cells.filter(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; })[0];
                        var firstChildVertex = firstChild.cells.filter(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; })[0];
                        var lastChildVertex = lastChild.cells.filter(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; })[0];
                        if (interVertex && interVertex.cell.isDecisionNode) {
                            if (this.flowchartModel.layout.yesBranchDirection === 'SameAsFlow') {
                                if (firstChildVertex) {
                                    newOffset = firstChildVertex.cell.isYesChild ? firstChild.offset : lastChild.offset;
                                }
                                else if (lastChildVertex) {
                                    newOffset = lastChildVertex.cell.isYesChild ? lastChild.offset : firstChild.offset;
                                }
                            }
                            else if (this.flowchartModel.layout.noBranchDirection === 'SameAsFlow') {
                                if (firstChildVertex) {
                                    newOffset = firstChildVertex.cell.isNoChild ? firstChild.offset : lastChild.offset;
                                }
                                else if (lastChildVertex) {
                                    newOffset = lastChildVertex.cell.isNoChild ? lastChild.offset : firstChild.offset;
                                }
                            }
                        }
                    }
                    if (newOffset < cell.offset) {
                        this.shiftMatrixCells(cell.offset - newOffset, firstChild, true, cell);
                    }
                    else if (newOffset > cell.offset) {
                        this.shiftMatrixCells(newOffset - cell.offset, cell);
                    }
                }
            }
        }
        if (cell.visitedParents.indexOf(parent) === -1) {
            if (parent !== null && cell.level !== parent.level) {
                cell.visitedParents.push(parent);
            }
        }
    };
    MatrixModel.prototype.shiftMatrixCells = function (value, startingCell, shiftChildren, parentCell) {
        if (shiftChildren === void 0) { shiftChildren = false; }
        if (parentCell === void 0) { parentCell = null; }
        if (value !== 0) {
            var matrixRow = this.matrix[startingCell.level];
            var index = matrixRow.indexOf(startingCell);
            for (var i = index; i < matrixRow.length; i++) {
                matrixRow[parseInt(i.toString(), 10)].offset += value;
            }
            if (shiftChildren) {
                if (startingCell.visitedChildren.length) {
                    this.shiftMatrixCells(value, startingCell.visitedChildren[0], true, startingCell);
                }
                else {
                    var i = 1;
                    var nextSiblingWithChild = null;
                    while (index + i < matrixRow.length) {
                        var nextCell = matrixRow[index + i];
                        if (parentCell !== null && nextCell.visitedParents.indexOf(parentCell) !== -1) {
                            if (nextCell.visitedChildren.length) {
                                nextSiblingWithChild = nextCell;
                            }
                            else {
                                i++;
                                continue;
                            }
                        }
                        break;
                    }
                    if (nextSiblingWithChild !== null) {
                        this.shiftMatrixCells(value, nextSiblingWithChild.visitedChildren[0], true, nextSiblingWithChild);
                    }
                }
            }
        }
    };
    MatrixModel.prototype.findParentVertexCellGroup = function (cell) {
        if ('internalInEdges' in cell.cells[0] && 'internalOutEdges' in cell.cells[0]) {
            return cell;
        }
        if (cell.parents.length) {
            return this.findParentVertexCellGroup(cell.parents[0]);
        }
        return cell;
    };
    MatrixModel.prototype.translateMatrixCells = function (value, cell) {
        if (value !== 0) {
            cell.offset += value;
            if (cell.visitedChildren.length) {
                for (var _i = 0, _a = cell.visitedChildren; _i < _a.length; _i++) {
                    var child = _a[_i];
                    this.translateMatrixCells(value, child);
                }
                for (var _b = 0, _c = cell.loopChildren; _b < _c.length; _b++) {
                    var loopChild = _c[_b];
                    this.translateMatrixCells(value, loopChild);
                }
            }
        }
    };
    MatrixModel.prototype.getObjectValues = function (obj) {
        var values = [];
        for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                values.push(obj["" + key]);
            }
        }
        return values;
    };
    MatrixModel.prototype.setXYForMatrixCell = function () {
        var layoutSettings = this.flowchartModel.layout;
        var isHorizontal = layoutSettings.orientation === 'LeftToRight';
        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
        var siblingSize = 0;
        if (this.siblingModel) {
            var rowMaxValues = this.getObjectValues(this.rowMaxDimension);
            var maxRowValue = Math.max.apply(Math, rowMaxValues);
            siblingSize = this.siblingModel.getSiblingDimension(maxRowValue);
        }
        for (var _i = 0, _a = this.getObjectValues(this.matrix); _i < _a.length; _i++) {
            var matrixRow1 = _a[_i];
            for (var _b = 0, matrixRow1_1 = matrixRow1; _b < matrixRow1_1.length; _b++) {
                var matrixCell = matrixRow1_1[_b];
                var start = matrixCell.offset - (matrixCell.size / 2);
                if (siblingSize !== 0) {
                    start += siblingSize + spacing;
                }
                for (var _c = 0, _d = matrixCell.cells; _c < _d.length; _c++) {
                    var cell = _d[_c];
                    if ('internalInEdges' in cell && 'internalOutEdges' in cell) {
                        var internalVertex = cell;
                        var width = internalVertex.cell.geometry.width;
                        var height = internalVertex.cell.geometry.height;
                        if (isHorizontal) {
                            internalVertex.cell.geometry = new Rect(this.rowOffset[matrixCell.level] - (width / 2), start, width, height);
                        }
                        else {
                            internalVertex.cell.geometry = new Rect(start, this.rowOffset[matrixCell.level] - (height / 2), width, height);
                        }
                        start += (isHorizontal ? height : width) + spacing;
                    }
                    else if ('edges' in cell) {
                        var internalEdges = cell;
                        var isContainSiblingVertex = internalEdges.isReversed;
                        if (!isContainSiblingVertex) {
                            var parent_1 = matrixCell.visitedParents[0];
                            if (parent_1) {
                                for (var _e = 0, _f = parent_1.visitedChildren; _e < _f.length; _e++) {
                                    var child = _f[_e];
                                    if (child.cells.some(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; })) {
                                        isContainSiblingVertex = true;
                                        break;
                                    }
                                }
                            }
                        }
                        var lineWidth = 1;
                        var edgeSpacing = 5;
                        for (var _g = 0, _h = internalEdges.edges; _g < _h.length; _g++) {
                            var internalConnector = _h[_g];
                            if (isContainSiblingVertex) {
                                var pt = { x: start + (lineWidth / 2.0), y: this.rowOffset[matrixCell.level] };
                                if (isHorizontal) {
                                    pt = { x: this.rowOffset[matrixCell.level], y: start + (lineWidth / 2.0) };
                                }
                                if (this.flowchartModel.layout.edgesMapper.has(internalConnector)) {
                                    this.flowchartModel.layout.edgesMapper.get(internalConnector).push(pt);
                                    this.flowchartModel.layout.loopedgesMapper.set(internalConnector, internalEdges.isReversed);
                                }
                            }
                            start += lineWidth + edgeSpacing;
                        }
                        start += spacing;
                    }
                }
            }
        }
    };
    MatrixModel.prototype.getSiblingDimension = function (maxHeight) {
        var layoutSettings = this.flowchartModel.layout;
        var isHorizontal = layoutSettings.orientation === 'LeftToRight';
        var spacing = isHorizontal ? layoutSettings.horizontalSpacing : layoutSettings.verticalSpacing;
        var commonRowIndex = 0;
        for (var key in this.rowMaxDimension) {
            if (Object.prototype.hasOwnProperty.call(this.rowMaxDimension, key)) {
                var value = this.rowMaxDimension["" + key];
                if (value < maxHeight) {
                    commonRowIndex = parseInt(key, 10);
                }
                else {
                    break;
                }
            }
        }
        if (this.rowMaxDimension[parseInt(commonRowIndex.toString(), 10)] + spacing <= maxHeight
            && this.rowMaxDimension[commonRowIndex + 1]) {
            commonRowIndex++;
        }
        var commonRows = [];
        for (var key in this.matrix) {
            if (Object.prototype.hasOwnProperty.call(this.matrix, key) && parseInt(key, 10) <= commonRowIndex) {
                commonRows["" + key] = this.matrix["" + key];
            }
        }
        var maxSize = 0;
        for (var key in commonRows) {
            if (Object.prototype.hasOwnProperty.call(commonRows, key)) {
                var matrixRow1 = commonRows["" + key];
                if (matrixRow1.length) {
                    var firstCell = matrixRow1[0].cells[0];
                    var rowStart = 0;
                    if (firstCell && 'cell' in firstCell) {
                        var geometry = firstCell.cell.geometry;
                        rowStart = isHorizontal ? geometry.y : geometry.x;
                    }
                    else if (firstCell && 'edges' in firstCell) {
                        var internalConnector = firstCell.edges[firstCell.edges.length - 1];
                        var edgePts = this.flowchartModel.layout.edgesMapper.get(internalConnector);
                        if (edgePts.length) {
                            rowStart = isHorizontal ? edgePts[0].y : edgePts[0].x;
                        }
                    }
                    var rowEnd = 0;
                    var lastCell = matrixRow1[matrixRow1.length - 1]
                        .cells[matrixRow1[matrixRow1.length - 1].cells.length - 1];
                    if (lastCell && 'cell' in lastCell) {
                        var geometry = lastCell.cell.geometry;
                        rowEnd = isHorizontal ? geometry.y + geometry.height : geometry.x + geometry.width;
                    }
                    else if (lastCell && 'edges' in lastCell) {
                        var internalConnector = lastCell.edges[lastCell.edges.length - 1];
                        var edgePts = this.flowchartModel.layout.edgesMapper.get(internalConnector);
                        if (edgePts.length) {
                            rowEnd = isHorizontal ? edgePts[0].y : edgePts[0].x;
                        }
                    }
                    maxSize = Math.max(maxSize, rowEnd - rowStart);
                }
            }
        }
        return maxSize;
    };
    MatrixModel.prototype.createMatrixCells = function () {
        var layoutSettings = this.flowchartModel.layout;
        var isHorizontal = layoutSettings.orientation === 'LeftToRight';
        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;
        var spacingInverse = isHorizontal ? layoutSettings.horizontalSpacing : layoutSettings.verticalSpacing;
        var rank = this.flowchartModel.ranks;
        var ranks = Array.from(rank.values());
        var matrixCellMapper = {};
        var matrixRowOffset = -spacingInverse;
        for (var j = ranks.length - 1; j >= 0; j--) {
            var maxDimension = 0.0;
            var index = (ranks.length - 1) - j;
            var rank_1 = ranks[parseInt(j.toString(), 10)].slice();
            // Creating new row and adding it to matrix
            var matrixRow = [];
            this.matrix[parseInt(index.toString(), 10)] = matrixRow;
            // Creating new row mapper
            var tempMatrixRow = {};
            matrixCellMapper[parseInt(index.toString(), 10)] = tempMatrixRow;
            while (rank_1.length > 0) {
                var layoutCell = rank_1[0];
                var matrixCell = {
                    parents: [],
                    children: [],
                    visitedParents: [],
                    visitedChildren: [],
                    ignoredChildren: [],
                    loopChildren: [],
                    cells: [],
                    level: index,
                    initialOffset: 0,
                    size: 0,
                    offset: 0
                };
                matrixRow.push(matrixCell);
                if ('internalInEdges' in layoutCell && 'internalOutEdges' in layoutCell) {
                    matrixCell.cells.push(layoutCell);
                    if (layoutCell.identicalSibling) {
                        for (var i = 0; i < rank_1.length; i++) {
                            var internalVertex = rank_1[parseInt(i.toString(), 10)];
                            if ('internalInEdges' in internalVertex && 'internalOutEdges' in internalVertex) {
                                if (layoutCell.identicalSibling.indexOf(internalVertex.id) !== -1) {
                                    matrixCell.cells.push(internalVertex);
                                    if (matrixCell.cells.length > layoutCell.identicalSibling.length) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    var cells = matrixCell.cells;
                    for (var i = 0; i < cells.length; i++) {
                        var internalVertex = cells[parseInt(i.toString(), 10)];
                        if ('internalInEdges' in internalVertex && 'internalOutEdges' in internalVertex) {
                            var geometry = internalVertex.cell.geometry;
                            matrixCell.size += isHorizontal ? geometry.height : geometry.width;
                            maxDimension = Math.max(maxDimension, isHorizontal ? geometry.width : geometry.height);
                            tempMatrixRow[internalVertex.id] = matrixCell;
                            if (internalVertex.internalInEdges.length) {
                                var internalInEdges = internalVertex.internalInEdges;
                                for (var j_1 = 0; j_1 < internalInEdges.length; j_1++) {
                                    var internalEdges = internalInEdges[parseInt(j_1.toString(), 10)];
                                    if (internalEdges.isReversed) {
                                        continue;
                                    }
                                    var key = null;
                                    if (matrixCellMapper[index - 1] &&
                                        Object.prototype.hasOwnProperty.call(matrixCellMapper[index - 1], internalEdges.ids)) {
                                        key = internalEdges.ids;
                                    }
                                    else if (matrixCellMapper[index - 1] &&
                                        Object.prototype.hasOwnProperty.call(matrixCellMapper[index - 1], internalEdges.source.id)) {
                                        key = internalEdges.source.id;
                                    }
                                    if (key !== null) {
                                        var parentMatrixCell = matrixCellMapper[index - 1]["" + key];
                                        if (matrixCell.parents.indexOf(parentMatrixCell) === -1) {
                                            matrixCell.parents.push(parentMatrixCell);
                                        }
                                        if (parentMatrixCell.children.indexOf(matrixCell) === -1) {
                                            if (parentMatrixCell.children.length) {
                                                if (parentMatrixCell.children[0].level === parentMatrixCell.level) {
                                                    parentMatrixCell.children.unshift(matrixCell);
                                                }
                                                else {
                                                    parentMatrixCell.children.push(matrixCell);
                                                }
                                            }
                                            else {
                                                parentMatrixCell.children.push(matrixCell);
                                            }
                                        }
                                    }
                                }
                            }
                            rank_1.splice(rank_1.indexOf(internalVertex), 1);
                        }
                    }
                    matrixCell.size += (matrixCell.cells.length - 1) * spacing;
                }
                else if ('edges' in layoutCell) {
                    matrixCell.cells.push(layoutCell);
                    var cells = matrixCell.cells;
                    for (var i = 0; i < cells.length; i++) {
                        var internalEdge = cells[parseInt(i.toString(), 10)];
                        if ('edges' in internalEdge && internalEdge.edges) {
                            var lineWidth = 1;
                            var edgeSpacing = 5;
                            var cellSize = -edgeSpacing;
                            for (var j_2 = 0; j_2 < internalEdge.edges.length; j_2++) {
                                var internalConnector = internalEdge.edges[parseInt(j_2.toString(), 10)];
                                cellSize += lineWidth + edgeSpacing;
                            }
                            matrixCell.size += cellSize;
                        }
                        var key = null;
                        if (internalEdge.isReversed) {
                            if (matrixCellMapper[parseInt(index.toString(), 10)][internalEdge.ids]) {
                                key = internalEdge.ids;
                            }
                            else if (matrixCellMapper[parseInt(index.toString(), 10)][internalEdge.source.id]) {
                                key = internalEdge.source.id;
                            }
                        }
                        else {
                            if (matrixCellMapper[index - 1][internalEdge.ids]) {
                                key = internalEdge.ids;
                            }
                            else if (matrixCellMapper[index - 1][internalEdge.source.id]) {
                                key = internalEdge.source.id;
                            }
                        }
                        if (key !== null) {
                            var parentMatrixCell = matrixCellMapper[internalEdge.isReversed ?
                                index : index - 1]["" + key];
                            if (matrixCell.parents.indexOf(parentMatrixCell) === -1) {
                                matrixCell.parents.push(parentMatrixCell);
                            }
                            if (parentMatrixCell.children.indexOf(matrixCell) === -1) {
                                parentMatrixCell.children.push(matrixCell);
                            }
                        }
                        tempMatrixRow[internalEdge.ids] = matrixCell;
                        rank_1.splice(rank_1.indexOf(internalEdge), 1);
                    }
                    matrixCell.size += (matrixCell.cells.length - 1) * spacing;
                }
            }
            this.rowOffset[parseInt(index.toString(), 10)] = matrixRowOffset + (maxDimension / 2) + spacingInverse;
            this.rowMaxDimension[parseInt(index.toString(), 10)] = this.rowOffset[parseInt(index.toString(), 10)] + maxDimension / 2;
            matrixRowOffset += maxDimension + spacingInverse;
        }
    };
    MatrixModel.prototype.groupLayoutCells = function () {
        var rank = this.flowchartModel.ranks;
        var ranks = Array.from(rank.values());
        ranks.reverse();
        for (var j = ranks.length - 1; j >= 0; j--) {
            var vertices = ranks[parseInt(j.toString(), 10)].filter(function (v) { return 'internalInEdges' in v && 'internalOutEdges' in v; });
            var edges = ranks[parseInt(j.toString(), 10)].filter(function (e) { return 'edges' in e && 'edges' in e; });
            while (vertices.length > 1) {
                var vertex1 = vertices[0];
                if (vertex1.cell.isYesChild || vertex1.cell.isNoChild) {
                    vertices.shift();
                    continue;
                }
                var parentSet1 = vertex1.internalInEdges.map(function (e) { return e.source.id; });
                var childSet1 = vertex1.internalOutEdges.map(function (e) { return e.target.id; });
                while (vertices.length > 1) {
                    var vertex2 = vertices[1];
                    var parentSet2 = vertex2.internalInEdges.map(function (e) { return e.source.id; });
                    var childSet2 = vertex2.internalOutEdges.map(function (e) { return e.target.id; });
                    var parentEquals = this.compareLists(parentSet1, parentSet2);
                    var childEquals = this.compareLists(childSet1, childSet2);
                    if (parentEquals && childEquals) {
                        this.updateMutualSharing(vertices[0], vertex2.id);
                        this.updateMutualSharing(vertices[1], vertex1.id);
                        vertices.splice(1, 1);
                        continue;
                    }
                    break;
                }
                vertices.shift();
            }
            var _loop_2 = function () {
                var internalEdge = edges[0];
                var parentSet = internalEdge.source;
                var childSet = internalEdge.target;
                if (parentSet.identicalSibling) {
                    var groupEdges = edges.filter(function (e) { return e.target === childSet; });
                    for (var _i = 0, groupEdges_1 = groupEdges; _i < groupEdges_1.length; _i++) {
                        var internalEdges = groupEdges_1[_i];
                        if ((parentSet.identicalSibling).indexOf(internalEdges.source.id) !== -1) {
                            internalEdges.source.identicalSibling = null;
                        }
                    }
                    internalEdge.source.identicalSibling = null;
                }
                edges.shift();
            };
            while (edges.length > 1) {
                _loop_2();
            }
        }
    };
    MatrixModel.prototype.updateMutualSharing = function (cell, id) {
        if (cell.identicalSibling) {
            cell.identicalSibling.push(id);
        }
        else {
            cell.identicalSibling = [id];
        }
    };
    MatrixModel.prototype.compareLists = function (list1, list2) {
        var newList1 = list1.slice();
        var newList2 = list2.slice();
        if (newList1.length === newList2.length) {
            if (newList1.length === 0) {
                return true;
            }
            for (var _i = 0, newList2_1 = newList2; _i < newList2_1.length; _i++) {
                var o = newList2_1[_i];
                if (newList1.indexOf(o) === -1) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };
    return MatrixModel;
}());

/**
 * Defines the Flowchart Layout
 */
var FlowchartLayout = /** @class */ (function () {
    function FlowchartLayout() {
        this.rootNodes = [];
        this.vertexMapper = new Map();
        this.edgesMapper = new Map();
        this.loopedgesMapper = new Map();
        this.anchorX = 0;
        this.anchorY = 0;
        this.verticalSpacing = 50;
        this.horizontalSpacing = 50;
        this.horizontalAlignment = 'Center';
        this.verticalAlignment = 'Top';
        this.margin = { top: 50, right: 50, bottom: 50, left: 50 };
        this.orientation = 'TopToBottom';
        this.yesBranchDirection = 'SameAsFlow';
        this.noBranchDirection = 'RightInFlow';
        this.yesBranchValues = ['Yes', 'True'];
        this.noBranchValues = ['No', 'False'];
        this.diagram = new Diagram();
    }
    /**
     * To update the layout of the diagram.
     * @private
     * @param {NodeModel[]} nodes - provide the node value.
     * @param {Diagram} diagram - provide the diagram value.
     * @returns { void }
     */
    FlowchartLayout.prototype.updateLayout = function (nodes, diagram) {
        this.diagram = diagram;
        this.yesBranchDirection = this.diagram.layout.flowchartLayoutSettings.yesBranchDirection;
        this.noBranchDirection = this.diagram.layout.flowchartLayoutSettings.noBranchDirection;
        this.yesBranchValues = this.diagram.layout.flowchartLayoutSettings.yesBranchValues || ['Yes', 'True'];
        this.noBranchValues = this.diagram.layout.flowchartLayoutSettings.noBranchValues || ['No', 'False'];
        this.orientation = this.diagram.layout.orientation === 'TopToBottom' || this.diagram.layout.orientation === 'BottomToTop' ? 'TopToBottom' : 'LeftToRight';
        this.horizontalAlignment = this.diagram.layout.horizontalAlignment;
        this.verticalAlignment = this.diagram.layout.verticalAlignment;
        this.verticalSpacing = this.diagram.layout.verticalSpacing;
        this.horizontalSpacing = this.diagram.layout.horizontalSpacing;
        this.margin = this.diagram.layout.margin;
        var firstLevelNodes = [];
        var unseenVertices = [];
        this.rootNodes = [];
        this.vertexMapper.clear();
        this.edgesMapper.clear();
        this.loopedgesMapper.clear();
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
            var item = nodes_1[_i];
            if (!item.excludeFromLayout) {
                var vertex = this.createVertex(item);
                this.vertexMapper.set(vertex.id, vertex);
                unseenVertices.push(vertex);
                if (!vertex.inEdges || vertex.inEdges.length === 0) {
                    firstLevelNodes.push(vertex);
                    this.rootNodes.push(item);
                }
            }
        }
        var previousModel = null;
        for (var _a = 0, firstLevelNodes_1 = firstLevelNodes; _a < firstLevelNodes_1.length; _a++) {
            var firstLevelNode = firstLevelNodes_1[_a];
            var vertexSet = [];
            this.getTreeVertices(firstLevelNode, vertexSet, unseenVertices);
            var layoutModel = new FlowchartModel(this, firstLevelNode, vertexSet);
            layoutModel.layeringStage();
            var matrixModel = new MatrixModel$1(layoutModel);
            matrixModel.siblingModel = previousModel;
            matrixModel.arrangeElements();
            previousModel = matrixModel;
        }
        var vertices = Array.from(this.vertexMapper.values());
        var modelBounds = this.getModelBounds(vertices);
        this.updateAnchor(modelBounds);
        var isHorizontal = this.orientation === 'LeftToRight';
        var inverseSpacing = !isHorizontal ? this.verticalSpacing : this.horizontalSpacing;
        var nodeWithMultiEdges = [];
        for (var _b = 0, vertices_1 = vertices; _b < vertices_1.length; _b++) {
            var vertex = vertices_1[_b];
            if (vertex) {
                var node = vertex.item;
                if (node) {
                    node.offsetX = vertex.geometry.x + (vertex.geometry.width / 2) + this.anchorX;
                    node.offsetY = vertex.geometry.y + (vertex.geometry.height / 2) + this.anchorY;
                    if ((vertex.inEdges && vertex.inEdges.length > 0) || (vertex.outEdges && vertex.outEdges.length > 0)) {
                        nodeWithMultiEdges.push(node);
                    }
                }
                diagram.dataBind();
            }
        }
        var transModelBounds = new Rect(modelBounds.x + this.anchorX, modelBounds.y
            + this.anchorY, modelBounds.width, modelBounds.height);
        this.nodeWithMultiEdges = nodeWithMultiEdges;
        this.inverseSpacing = inverseSpacing;
        this.transModelBounds = transModelBounds;
        this.diagram.layout.flowChartData = this;
    };
    /**
     * To re-rout the flowchart connectors.
     * @private
     * @param {FlowchartLayout} layoutData - provide the layoutData value.
     * @param {Diagram} diagram - provide the diagram value.
     * @returns { void }
     */
    FlowchartLayout.prototype.reRouteFlowChartConnectors = function (layoutData, diagram) {
        this.diagram = diagram;
        var nodeWithMultiEdges = layoutData.nodeWithMultiEdges;
        var inverseSpacing = layoutData.inverseSpacing;
        this.orientation = layoutData.orientation;
        var isVertical = this.orientation === 'TopToBottom';
        var transModelBounds = layoutData.transModelBounds;
        this.vertexMapper = layoutData.vertexMapper;
        this.loopedgesMapper = layoutData.loopedgesMapper;
        this.edgesMapper = layoutData.edgesMapper;
        this.anchorX = layoutData.anchorX;
        this.anchorY = layoutData.anchorY;
        var modifiedConnectors = [];
        for (var _i = 0, nodeWithMultiEdges_1 = nodeWithMultiEdges; _i < nodeWithMultiEdges_1.length; _i++) {
            var node = nodeWithMultiEdges_1[_i];
            if (node.outEdges && node.outEdges.length > 0) {
                for (var _a = 0, _b = node.outEdges; _a < _b.length; _a++) {
                    var edge = _b[_a];
                    var internalConnector = this.diagram.nameTable["" + edge];
                    if (this.loopedgesMapper.has(internalConnector) && this.loopedgesMapper.get(internalConnector)) {
                        if (modifiedConnectors.indexOf(internalConnector) === -1) {
                            this.updateLoopConnector(internalConnector);
                            modifiedConnectors.push(internalConnector);
                        }
                    }
                    else {
                        var updatedPts = [];
                        if (node.outEdges.length > 1) {
                            var segmentSize = inverseSpacing / 2.0;
                            var intermediatePoint = null;
                            if (this.edgesMapper.has(internalConnector)) {
                                var edgePt = this.edgesMapper.get(internalConnector)[0];
                                if (edgePt) {
                                    intermediatePoint = { x: edgePt.x + this.anchorX, y: edgePt.y + this.anchorY };
                                }
                            }
                            internalConnector.segments = [];
                            internalConnector.intermediatePoints = [];
                            var pts = [internalConnector.sourcePoint, internalConnector.targetPoint];
                            if (isVertical) {
                                updatedPts = this.updateVerticalConnectorSegments(internalConnector, pts);
                                var sourceNode = this.diagram.nameTable[internalConnector.sourceID];
                                var decisionNode = this.vertexMapper.get(sourceNode.id).isDecisionNode;
                                if (!decisionNode && updatedPts.length <= 2) {
                                    pts = this.updateConnectorPoints(updatedPts, segmentSize, intermediatePoint, transModelBounds);
                                }
                                else {
                                    pts = updatedPts;
                                }
                            }
                            else {
                                updatedPts = this.updateHorizontalSegments(internalConnector, pts);
                                pts = updatedPts;
                            }
                            if (pts.length > 2) {
                                this.updatePoints(pts, internalConnector);
                            }
                            modifiedConnectors.push(internalConnector);
                        }
                        else if (internalConnector.intermediatePoints.length === 4) {
                            // Determine updated points based on orientation (vertical or horizontal)
                            var start = internalConnector.intermediatePoints[0];
                            var end = internalConnector.intermediatePoints[3];
                            var offsetPoint = isVertical
                                ? { x: start.x, y: end.y - 20 }
                                : { x: end.x - 20, y: start.y };
                            var updatedPts_1 = [start, offsetPoint, end];
                            // Update connector points and add to modified list
                            this.updatePoints(updatedPts_1, internalConnector);
                            modifiedConnectors.push(internalConnector);
                        }
                    }
                }
            }
            if (node.inEdges && node.inEdges.length > 1) {
                for (var _c = 0, _d = node.inEdges; _c < _d.length; _c++) {
                    var edge = _d[_c];
                    var internalConnector = this.diagram.nameTable["" + edge];
                    if (modifiedConnectors.indexOf(internalConnector) === -1) {
                        internalConnector.segments[0].points = [];
                        if (this.loopedgesMapper.has(internalConnector) && this.loopedgesMapper.get(internalConnector)) {
                            this.updateLoopConnector(internalConnector);
                            modifiedConnectors.push(internalConnector);
                        }
                        else {
                            if (node.inEdges.length > 1) {
                                var segmentSize = inverseSpacing / 2.0;
                                var intermediatePoint = null;
                                if (this.edgesMapper.has(internalConnector) && modifiedConnectors.indexOf(internalConnector) === -1) {
                                    var edgePt = this.edgesMapper.get(internalConnector)[0];
                                    if (edgePt) {
                                        intermediatePoint = { x: edgePt.x + this.anchorX, y: edgePt.y + this.anchorY };
                                    }
                                }
                                internalConnector.segments = [];
                                var pts = [internalConnector.targetPoint, internalConnector.sourcePoint];
                                var updatedPts = [];
                                if (isVertical) {
                                    updatedPts = this.updateVerticalConnectorSegments(internalConnector, pts);
                                }
                                else {
                                    updatedPts = this.updateHorizontalSegments(internalConnector, pts);
                                }
                                pts = this.updateConnectorPoints(updatedPts, segmentSize, intermediatePoint, transModelBounds);
                                pts.reverse();
                                if (pts.length > 2) {
                                    this.updatePoints(pts, internalConnector);
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    FlowchartLayout.prototype.updateAnchor = function (bounds) {
        var viewPort = {
            width: this.diagram.scrollSettings.viewPortWidth,
            height: this.diagram.scrollSettings.viewPortHeight
        };
        if (this.orientation === 'TopToBottom') {
            this.anchorX = viewPort.width / 2 - bounds.width / 2 - bounds.x;
            this.anchorY = this.margin.top;
        }
        else {
            this.anchorX = this.margin.left;
            this.anchorY = viewPort.height / 2 - bounds.height / 2 - bounds.y;
        }
        if (this.rootNodes.length === 1) {
            var fixedNode = this.rootNodes[0]; // Assuming rootNodes is defined elsewhere
            var fixedNodeGeometry = this.vertexMapper.get(fixedNode.id).geometry; // Assuming vertexMapper and its usage are defined elsewhere
            var offsetX = fixedNodeGeometry.x + fixedNodeGeometry.width / 2;
            var offsetY = fixedNodeGeometry.y + fixedNodeGeometry.height / 2;
            var dx = offsetX - (bounds.x + bounds.width / 2);
            var dy = offsetY - (bounds.y + bounds.height / 2);
            if (this.orientation === 'TopToBottom') {
                this.anchorX -= dx;
            }
            else {
                this.anchorY -= dy;
            }
        }
    };
    FlowchartLayout.prototype.updateConnectorPoints = function (connectorPoints, startSegmentSize, intermediatePoint, layoutBounds) {
        var isHorizontal = this.orientation === 'LeftToRight';
        var pts = connectorPoints.slice();
        // Helper function to find angle between two points
        function findAngle(point1, point2) {
            return Math.atan2(point2.y - point1.y, point2.x - point1.x) * (180 / Math.PI);
        }
        // Function to find the distance (length) between two points
        function findLength(point1, point2) {
            var dx = point2.x - point1.x;
            var dy = point2.y - point1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        // Helper function to transform a point
        function transform(point, length, angle) {
            var rad = angle * (Math.PI / 180);
            var newX = point.x + length * Math.cos(rad);
            var newY = point.y + length * Math.sin(rad);
            return { x: newX, y: newY };
        }
        if (pts.length > 2) {
            var newPt = transform(pts[0], startSegmentSize, findAngle(pts[0], pts[1]));
            var nextPt = transform(newPt, findLength(newPt, pts[1]), findAngle(newPt, pts[2]));
            pts.splice(1, 0, nextPt);
            pts.splice(1, 0, newPt);
            pts.splice(3, 2);
            if (intermediatePoint != null) {
                var index = 2;
                var ptsCount = pts.length;
                var newPt1 = transform(pts[ptsCount - 1], startSegmentSize, findAngle(pts[ptsCount - 1], pts[ptsCount - 2]));
                pts.splice(ptsCount - 1, 0, newPt1);
                while (index < pts.length - 2) {
                    pts.splice(index, 1);
                }
                var edgePt = intermediatePoint;
                this.inflate(layoutBounds, layoutBounds.width, layoutBounds.height);
                if (isHorizontal) {
                    var line1 = [{ x: layoutBounds.left, y: edgePt.y }, { x: layoutBounds.right, y: edgePt.y }];
                    var line2 = [{ x: pts[1].x, y: layoutBounds.top }, { x: pts[1].x, y: layoutBounds.bottom }];
                    var line3 = [{ x: newPt1.x, y: layoutBounds.top }, { x: newPt1.x, y: layoutBounds.bottom }];
                    var intercepts1 = [];
                    var intercepts2 = [];
                    // Dummy function calls, replace with actual implementation or mock
                    intercepts1 = this.diagram.commandHandler.intersect(line1, line2, false);
                    intercepts2 = this.diagram.commandHandler.intersect(line1, line3, false);
                    if (intercepts2.length) {
                        pts.splice(2, 0, intercepts2[0]);
                    }
                    if (intercepts1.length) {
                        pts.splice(2, 0, intercepts1[0]);
                    }
                }
                else {
                    var line1 = [{ x: edgePt.x, y: layoutBounds.top }, { x: edgePt.x, y: layoutBounds.bottom }];
                    var line2 = [{ x: layoutBounds.left, y: pts[1].y }, { x: layoutBounds.right, y: pts[1].y }];
                    var line3 = [{ x: layoutBounds.left, y: newPt1.y }, { x: layoutBounds.right, y: newPt1.y }];
                    var intercepts1 = [];
                    var intercepts2 = [];
                    // Dummy function calls, replace with actual implementation or mock
                    intercepts1 = this.diagram.commandHandler.intersect(line1, line2, false);
                    intercepts2 = this.diagram.commandHandler.intersect(line1, line3, false);
                    if (intercepts2.length) {
                        pts.splice(2, 0, intercepts2[0]);
                    }
                    if (intercepts1.length) {
                        pts.splice(2, 0, intercepts1[0]);
                    }
                }
            }
        }
        else if (pts.length === 2 && intermediatePoint != null) {
            var startPt = pts[0];
            var endPt = pts[1];
            var lineAngle = findAngle(pts[0], pts[1]);
            var newPt1 = transform(startPt, startSegmentSize, lineAngle);
            var newPt2 = transform(endPt, startSegmentSize, (lineAngle + 180) % 360);
            pts.splice(1, 0, newPt2);
            if (isHorizontal) {
                var nextPt1 = { x: newPt1.x, y: intermediatePoint.y };
                var nextPt2 = { x: newPt2.x, y: intermediatePoint.y };
                pts.splice(1, 0, nextPt2);
                pts.splice(1, 0, nextPt1);
            }
            else {
                var nextPt1 = { x: intermediatePoint.x, y: newPt1.y };
                var nextPt2 = { x: intermediatePoint.x, y: newPt2.y };
                pts.splice(1, 0, nextPt2);
                pts.splice(1, 0, nextPt1);
            }
            pts.splice(1, 0, newPt1);
        }
        return pts;
    };
    FlowchartLayout.prototype.inflate = function (rect, width, height) {
        rect.x -= width;
        rect.y -= height;
        rect.width += 2 * width;
        rect.height += 2 * height;
    };
    FlowchartLayout.isBranchConnector = function (internalConnector, branchValues) {
        if (internalConnector.annotations.length > 0 && internalConnector.annotations[0].content) {
            var text_1 = internalConnector.annotations[0].content;
            return branchValues.some(function (branchText) { return text_1.localeCompare(branchText, undefined, { sensitivity: 'accent' }) === 0; });
        }
        return false;
    };
    FlowchartLayout.prototype.isYesBranchConnector = function (internalConnector) {
        return FlowchartLayout.isBranchConnector(internalConnector, this.yesBranchValues);
    };
    FlowchartLayout.prototype.isNoBranchConnector = function (internalConnector) {
        return FlowchartLayout.isBranchConnector(internalConnector, this.noBranchValues);
    };
    FlowchartLayout.prototype.updateHorizontalSegments = function (internalConnector, pts) {
        var updatedPts = [];
        var sourcenode = this.diagram.nameTable[internalConnector.sourceID];
        var targetnode = this.diagram.nameTable[internalConnector.targetID];
        var decisionNode = this.vertexMapper.get(sourcenode.id).isDecisionNode;
        var hSpacing = this.horizontalSpacing / 2;
        var vSpacing = this.verticalSpacing / 2;
        if (decisionNode) {
            var isYesBranch = this.isYesBranchConnector(internalConnector);
            var isNoBranch = this.isNoBranchConnector(internalConnector);
            if ((!targetnode.wrapper.bounds.containsPoint({ x: targetnode.offsetX, y: sourcenode.offsetY })) &&
                !((sourcenode.offsetY !== targetnode.offsetY) &&
                    ((isYesBranch && this.yesBranchDirection === 'SameAsFlow') ||
                        (isNoBranch && this.noBranchDirection === 'SameAsFlow' && this.yesBranchDirection !== 'SameAsFlow')))) {
                if (sourcenode.wrapper.bounds.bottom < targetnode.wrapper.bounds.center.y) {
                    var spoint1 = sourcenode.wrapper.bounds.bottom;
                    var spoint2 = sourcenode.offsetX;
                    var tpoint1 = targetnode.wrapper.bounds.left;
                    var tpoint2 = targetnode.offsetY;
                    updatedPts.push({ x: spoint2, y: spoint1 });
                    updatedPts.push({ x: spoint2, y: tpoint2 });
                    updatedPts.push({ x: tpoint1, y: tpoint2 });
                }
                else if (sourcenode.wrapper.bounds.top > targetnode.wrapper.bounds.center.y) {
                    var spoint1 = sourcenode.wrapper.bounds.top;
                    var spoint2 = sourcenode.offsetX;
                    var tpoint1 = targetnode.wrapper.bounds.left;
                    var tpoint2 = targetnode.offsetY;
                    updatedPts.push({ x: spoint2, y: spoint1 });
                    updatedPts.push({ x: spoint2, y: tpoint2 });
                    updatedPts.push({ x: tpoint1, y: tpoint2 });
                }
                else if ((isYesBranch && this.yesBranchDirection === 'RightInFlow') ||
                    (isNoBranch && ((this.yesBranchDirection === 'SameAsFlow' &&
                        (this.noBranchDirection === 'RightInFlow' || this.noBranchDirection === 'SameAsFlow')) ||
                        (this.yesBranchDirection === 'LeftInFlow' &&
                            (this.noBranchDirection === 'LeftInFlow' || this.noBranchDirection === 'RightInFlow'))))) {
                    var spoint1 = sourcenode.offsetX;
                    var spoint2 = sourcenode.wrapper.bounds.bottom;
                    var tpoint1 = targetnode.wrapper.bounds.left;
                    var tpoint2 = targetnode.wrapper.bounds.center.y;
                    updatedPts.push({ x: spoint1, y: spoint2 });
                    updatedPts.push({ x: spoint1, y: spoint2 + vSpacing });
                    updatedPts.push({ x: tpoint1 - hSpacing, y: spoint2 + vSpacing });
                    updatedPts.push({ x: tpoint1 - hSpacing, y: tpoint2 });
                    updatedPts.push({ x: tpoint1, y: tpoint2 });
                }
            }
            else if ((isYesBranch && this.yesBranchDirection === 'LeftInFlow') ||
                (isNoBranch && ((this.yesBranchDirection === 'SameAsFlow' &&
                    (this.noBranchDirection === 'SameAsFlow' || this.noBranchDirection === 'LeftInFlow')) ||
                    (this.yesBranchDirection === 'RightInFlow' &&
                        (this.noBranchDirection === 'LeftInFlow' || this.noBranchDirection === 'RightInFlow'))))) {
                var spoint1 = sourcenode.offsetX;
                var spoint2 = sourcenode.wrapper.bounds.top;
                var tpoint1 = targetnode.wrapper.bounds.left;
                var tpoint2 = targetnode.wrapper.bounds.center.y;
                updatedPts.push({ x: spoint1, y: spoint2 });
                updatedPts.push({ x: spoint1, y: spoint2 - vSpacing });
                updatedPts.push({ x: tpoint1 - hSpacing, y: spoint2 - vSpacing });
                updatedPts.push({ x: tpoint1 - hSpacing, y: tpoint2 });
                updatedPts.push({ x: tpoint1, y: tpoint2 });
            }
            else if ((sourcenode.offsetY !== targetnode.offsetY) &&
                ((isYesBranch && this.yesBranchDirection === 'SameAsFlow') ||
                    (isNoBranch && this.noBranchDirection === 'SameAsFlow' &&
                        this.yesBranchDirection !== 'SameAsFlow'))) {
                var spoint1 = sourcenode.wrapper.bounds.right;
                var spoint2 = sourcenode.offsetY;
                var tpoint1 = targetnode.wrapper.bounds.left;
                var tpoint2 = targetnode.wrapper.bounds.center.y;
                updatedPts.push({ x: spoint1, y: spoint2 });
                updatedPts.push({ x: tpoint1 - hSpacing, y: spoint2 });
                updatedPts.push({ x: tpoint1 - hSpacing, y: tpoint2 });
                updatedPts.push({ x: tpoint1, y: tpoint2 });
            }
        }
        else {
            updatedPts = pts;
        }
        return updatedPts;
    };
    FlowchartLayout.prototype.updateVerticalConnectorSegments = function (internalConnector, pts) {
        var updatedPts = [];
        var sourcenode = this.diagram.nameTable[internalConnector.sourceID];
        var targetnode = this.diagram.nameTable[internalConnector.targetID];
        var decisionNode = this.vertexMapper.get(sourcenode.id).isDecisionNode;
        var hSpacing = this.horizontalSpacing / 2;
        var vSpacing = this.verticalSpacing / 2;
        if (decisionNode) {
            var isYesBranch = this.isYesBranchConnector(internalConnector);
            var isNoBranch = this.isNoBranchConnector(internalConnector);
            if ((sourcenode.wrapper.bounds.right < targetnode.wrapper.bounds.center.x) &&
                ((isYesBranch && this.yesBranchDirection === 'RightInFlow') ||
                    (isNoBranch && ((this.yesBranchDirection === 'SameAsFlow' &&
                        (this.noBranchDirection === 'RightInFlow' || this.noBranchDirection === 'SameAsFlow')) ||
                        (this.yesBranchDirection === 'LeftInFlow' &&
                            (this.noBranchDirection === 'LeftInFlow' || this.noBranchDirection === 'RightInFlow')))))) {
                var spoint1 = sourcenode.wrapper.bounds.right;
                var spoint2 = sourcenode.offsetY;
                var tpoint1 = targetnode.wrapper.bounds.top;
                var tpoint2 = targetnode.offsetY;
                updatedPts.push({ x: spoint1, y: spoint2 });
                var overlappingNodes = this.diagram.nodes.filter(function (e) {
                    return e.wrapper.bounds.containsPoint({ x: targetnode.offsetX, y: sourcenode.offsetY });
                });
                overlappingNodes = overlappingNodes.sort(function (a, b) {
                    return b.wrapper.bounds.left - a.wrapper.bounds.left;
                });
                if (overlappingNodes.length === 0) {
                    updatedPts.push({ x: targetnode.offsetX, y: spoint2 });
                }
                else {
                    var bounds = overlappingNodes[0].wrapper.bounds;
                    updatedPts.push({ x: bounds.left - hSpacing, y: overlappingNodes[0].offsetY });
                    updatedPts.push({ x: bounds.left - hSpacing, y: bounds.bottom + vSpacing });
                }
                updatedPts.push({ x: tpoint1, y: tpoint2 });
            }
            else if ((sourcenode.wrapper.bounds.left > targetnode.wrapper.bounds.center.x) &&
                ((isYesBranch && this.yesBranchDirection === 'LeftInFlow') ||
                    (isNoBranch && ((this.yesBranchDirection === 'SameAsFlow' &&
                        (this.noBranchDirection === 'SameAsFlow' || this.noBranchDirection === 'LeftInFlow')) ||
                        (this.yesBranchDirection === 'RightInFlow' &&
                            (this.noBranchDirection === 'LeftInFlow' || this.noBranchDirection === 'RightInFlow')))))) {
                var spoint1 = sourcenode.wrapper.bounds.left;
                var spoint2 = sourcenode.offsetY;
                var tpoint1 = targetnode.wrapper.bounds.top;
                var tpoint2 = targetnode.offsetY;
                updatedPts.push({ x: spoint1, y: spoint2 });
                var middleRect_1 = Rect.toBounds([updatedPts[0], { x: targetnode.offsetX, y: spoint2 }]);
                var overlappingNodes = this.diagram.nodes.filter(function (e) {
                    return e.wrapper.bounds.intersects(middleRect_1) &&
                        e.id !== sourcenode.id &&
                        e.id !== targetnode.id;
                });
                overlappingNodes = overlappingNodes.sort(function (a, b) {
                    return b.wrapper.bounds.right - a.wrapper.bounds.right;
                });
                if (overlappingNodes.length === 0) {
                    updatedPts.push({ x: targetnode.offsetX, y: spoint2 });
                }
                else {
                    var bounds = overlappingNodes[0].wrapper.bounds;
                    updatedPts.push({ x: bounds.right + hSpacing, y: overlappingNodes[0].offsetY });
                    updatedPts.push({ x: bounds.right + hSpacing, y: bounds.bottom + vSpacing });
                }
                updatedPts.push({ x: tpoint1, y: tpoint2 });
            }
            else if ((isYesBranch && this.yesBranchDirection === 'RightInFlow') ||
                (isNoBranch && ((this.yesBranchDirection === 'SameAsFlow' &&
                    (this.noBranchDirection === 'RightInFlow' || this.noBranchDirection === 'SameAsFlow')) ||
                    (this.yesBranchDirection === 'LeftInFlow' &&
                        (this.noBranchDirection === 'LeftInFlow' || this.noBranchDirection === 'RightInFlow'))))) {
                var spoint1 = sourcenode.wrapper.bounds.right;
                var spoint2 = sourcenode.offsetY;
                var tpoint1 = targetnode.wrapper.bounds.topCenter.x;
                var tpoint2 = targetnode.wrapper.bounds.topCenter.y;
                updatedPts.push({ x: spoint1, y: spoint2 });
                updatedPts.push({ x: spoint1 + hSpacing, y: spoint2 });
                updatedPts.push({ x: spoint1 + hSpacing, y: tpoint2 - vSpacing });
                updatedPts.push({ x: tpoint1, y: tpoint2 - vSpacing });
                updatedPts.push({ x: tpoint1, y: tpoint2 });
                var middleRect_2 = Rect.toBounds([updatedPts[1], updatedPts[2]]);
                var overlappingNodes = this.diagram.nodes.filter(function (e) {
                    return e.wrapper.bounds.intersects(middleRect_2);
                });
                overlappingNodes = overlappingNodes.sort(function (a, b) {
                    return b.wrapper.bounds.right - a.wrapper.bounds.right;
                });
                if (overlappingNodes.length > 0 && overlappingNodes[0].wrapper.bounds.intersects(middleRect_2)) {
                    var bounds = overlappingNodes[0].wrapper.bounds;
                    updatedPts[1].x = bounds.right + hSpacing;
                    updatedPts[2].x = bounds.right + hSpacing;
                }
            }
            else if ((isYesBranch && this.yesBranchDirection === 'LeftInFlow') ||
                (isNoBranch && ((this.yesBranchDirection === 'SameAsFlow' &&
                    (this.noBranchDirection === 'SameAsFlow' || this.noBranchDirection === 'LeftInFlow')) ||
                    (this.yesBranchDirection === 'RightInFlow' &&
                        (this.noBranchDirection === 'LeftInFlow' || this.noBranchDirection === 'RightInFlow'))))) {
                var spoint1 = sourcenode.wrapper.bounds.left;
                var spoint2 = sourcenode.offsetY;
                var tpoint1 = targetnode.wrapper.bounds.topCenter.x;
                var tpoint2 = targetnode.wrapper.bounds.topCenter.y;
                updatedPts.push({ x: spoint1, y: spoint2 });
                updatedPts.push({ x: spoint1 - hSpacing, y: spoint2 });
                updatedPts.push({ x: spoint1 - hSpacing, y: tpoint2 - vSpacing });
                updatedPts.push({ x: tpoint1, y: tpoint2 - vSpacing });
                updatedPts.push({ x: tpoint1, y: tpoint2 });
                var middleRect_3 = Rect.toBounds([updatedPts[1], updatedPts[2]]);
                var overlappingNodes = this.diagram.nodes.filter(function (e) {
                    return e.wrapper.bounds.intersects(middleRect_3);
                });
                overlappingNodes = overlappingNodes.sort(function (a, b) {
                    return b.wrapper.bounds.left - a.wrapper.bounds.left;
                });
                if (overlappingNodes.length > 0 && overlappingNodes[0].wrapper.bounds.intersects(middleRect_3)) {
                    var bounds = overlappingNodes[0].wrapper.bounds;
                    updatedPts[1].x = bounds.left - hSpacing;
                    updatedPts[2].x = bounds.left - hSpacing;
                }
            }
            else if ((sourcenode.offsetX !== targetnode.offsetX) &&
                ((isYesBranch && this.yesBranchDirection === 'SameAsFlow') ||
                    (isNoBranch &&
                        this.noBranchDirection === 'SameAsFlow' &&
                        this.yesBranchDirection !== 'SameAsFlow'))) {
                var spoint1 = sourcenode.offsetX;
                var spoint2 = sourcenode.wrapper.bounds.bottom;
                var tpoint1 = targetnode.wrapper.bounds.topCenter.x;
                var tpoint2 = targetnode.wrapper.bounds.topCenter.y;
                updatedPts.push({ x: spoint1, y: spoint2 });
                updatedPts.push({ x: spoint1, y: tpoint2 - vSpacing });
                updatedPts.push({ x: tpoint1, y: tpoint2 - vSpacing });
                updatedPts.push({ x: tpoint1, y: tpoint2 });
            }
            else {
                updatedPts = pts;
            }
        }
        else {
            updatedPts = pts;
        }
        return updatedPts;
    };
    FlowchartLayout.prototype.getModelBounds = function (nodes) {
        var rect = new Rect(0, 0, 0, 0);
        nodes = Array.from(nodes);
        nodes.forEach(function (vertex) {
            var geo = vertex.geometry;
            rect.uniteRect(geo);
        });
        return rect;
    };
    FlowchartLayout.prototype.createVertex = function (node) {
        var _this = this;
        var nodeWidth = isNaN(node.width) ? node.wrapper.bounds.width : node.width;
        var nodeHeight = isNaN(node.height) ? node.wrapper.bounds.height : node.height;
        var geometry = new Rect(0, 0, nodeWidth, nodeHeight);
        var inEdges = [];
        var outEdges = [];
        var branches = { isYesBranch: false, isNoBranch: false };
        if (node.inEdges != null) {
            for (var _i = 0, _a = node.inEdges; _i < _a.length; _i++) {
                var edge = _a[_i];
                var con = this.diagram.nameTable["" + edge];
                if (con) {
                    inEdges.push(con);
                }
            }
        }
        if (node.outEdges != null) {
            for (var _b = 0, _c = node.outEdges; _b < _c.length; _b++) {
                var edge = _c[_b];
                var con = this.diagram.nameTable["" + edge];
                if (con) {
                    outEdges.push(con);
                }
            }
        }
        var isYesBranch = branches.isYesBranch;
        var isNoBranch = branches.isNoBranch;
        if (inEdges != null) {
            inEdges.forEach(function (inEdge) {
                branches = _this.checkForYesOrNoBranch(inEdge, isYesBranch, isNoBranch);
            });
        }
        if (outEdges != null) {
            outEdges.forEach(function (outEdge) {
                _this.edgesMapper.set(outEdge, []);
                _this.loopedgesMapper.set(outEdge, false);
            });
        }
        var vert = {
            id: node.id,
            geometry: geometry,
            inEdges: inEdges,
            layoutObjectId: {},
            outEdges: outEdges,
            item: node,
            isDecisionNode: false,
            isYesChild: branches.isYesBranch,
            isNoChild: branches.isNoBranch
        };
        return vert;
    };
    FlowchartLayout.prototype.updatePoints = function (pts, internalConnector) {
        var pointSets = [];
        var segCollection = [];
        for (var i = 0; i < pts.length; i++) {
            if (pts[i + 2]) {
                pointSets.push(pts[parseInt(i.toString(), 10)]);
                pointSets.push(pts[i + 1]);
                var seg = {
                    type: 'Orthogonal',
                    points: pointSets,
                    length: pointSets[0].x === pointSets[1].x ? Math.abs(pointSets[0].y - pointSets[1].y)
                        : Math.abs(pointSets[0].x - pointSets[1].x),
                    direction: pointSets[0].x === pointSets[1].x ? pointSets[0].y > pointSets[1].y ? 'Top' : 'Bottom'
                        : pointSets[0].x > pointSets[1].x ? 'Left' : 'Right'
                };
                pointSets = [];
                segCollection.push(seg);
            }
        }
        internalConnector.segments = segCollection;
    };
    FlowchartLayout.prototype.contains = function (point, bounds) {
        return (point.x >= bounds.left && point.x <= bounds.right && point.y >= bounds.top && point.y <= bounds.bottom);
    };
    FlowchartLayout.prototype.updateLoopConnector = function (internalConnector) {
        var loopPts = [];
        if (this.edgesMapper.has(internalConnector)) {
            var loopPoints = this.edgesMapper.get(internalConnector);
            if (loopPoints) {
                for (var _i = 0, loopPoints_1 = loopPoints; _i < loopPoints_1.length; _i++) {
                    var loopPt = loopPoints_1[_i];
                    var pointX = loopPt.x + this.anchorX;
                    var pointY = loopPt.y + this.anchorY;
                    loopPts.push({ x: pointX, y: pointY });
                }
            }
        }
        loopPts.reverse();
        var pts = [];
        var sourceNode = this.diagram.nameTable[internalConnector.sourceID];
        var targetNode = this.diagram.nameTable[internalConnector.targetID];
        var srcBounds = sourceNode.wrapper.bounds;
        var tarBounds = targetNode.wrapper.bounds;
        var srcNode = sourceNode;
        var tarNode = targetNode;
        var decisionNode = this.vertexMapper.get(internalConnector.sourceID).isDecisionNode;
        var isYesBranch = this.isYesBranchConnector(internalConnector);
        var isNoBranch = this.isNoBranchConnector(internalConnector);
        var isYesBranchLeft = isYesBranch && this.yesBranchDirection === 'LeftInFlow';
        var isNoBranchRight = isNoBranch && ((this.yesBranchDirection === 'RightInFlow' &&
            (this.noBranchDirection === 'RightInFlow' || this.noBranchDirection === 'SameAsFlow')) ||
            (this.noBranchDirection === 'LeftInFlow' &&
                (this.yesBranchDirection === 'RightInFlow' || this.yesBranchDirection === 'SameAsFlow')));
        var hSpacing = this.horizontalSpacing / 2;
        var vSpacing = this.verticalSpacing / 2;
        var combinedBounds = new Rect().uniteRect(srcNode.wrapper.bounds).uniteRect(tarNode.wrapper.bounds);
        var overlappingNodesInDiagram = this.diagram.nodes.filter(function (node) {
            return node.id !== tarNode.id && node.id !== srcNode.id && node.wrapper.bounds.intersects(combinedBounds);
        });
        if (this.orientation === 'TopToBottom') {
            var source = Array.from(this.vertexMapper.values())
                .filter(function (e) {
                return e.item.wrapper.bounds.containsPoint({ x: e.item.wrapper.bounds.x, y: srcNode.offsetY }) &&
                    srcNode.id !== e.item.id;
            });
            var target = Array.from(this.vertexMapper.values())
                .filter(function (e) {
                return e.item.wrapper.bounds.containsPoint({ x: e.item.wrapper.bounds.x, y: tarNode.offsetY }) &&
                    tarNode.id !== e.item.id;
            });
            var max = Math.max.apply(Math, loopPts.map(function (pt) { return pt.x; }));
            var isSiblingsInRight = false;
            if (decisionNode) {
                if (isYesBranchLeft || isNoBranchRight) {
                    isSiblingsInRight = true;
                }
            }
            else {
                isSiblingsInRight = (source.length > 0 && source[0].item.wrapper.bounds.x > srcBounds.x);
            }
            if (target.length === 0 || (!isSiblingsInRight && target.length > 0 && target.filter(function (e) {
                return e.item.wrapper.bounds.right < tarBounds.left;
            }).length > 0)) {
                // Determine X coordinates based on conditions
                var initialX = (!isSiblingsInRight && max > srcBounds.right) ? srcBounds.right : srcBounds.left;
                var midX = initialX + (isSiblingsInRight ? -hSpacing : hSpacing);
                var targetX = (!isSiblingsInRight && max > tarBounds.right) ? tarBounds.right : tarBounds.left;
                // Add points to the collection
                pts.push({ x: initialX, y: srcNode.offsetY });
                pts.push({ x: midX, y: srcNode.offsetY });
                pts.push({ x: midX, y: tarNode.offsetY });
                pts.push({ x: targetX, y: tarNode.offsetY });
            }
            else {
                var targetBottom = target[0].item.wrapper.bounds.bottom;
                var verticalMiddle = targetBottom + vSpacing;
                var startX = !isSiblingsInRight ? srcBounds.right : srcBounds.left;
                var middleX = startX + (isSiblingsInRight ? -hSpacing : hSpacing);
                var endX = !isSiblingsInRight && max > tarBounds.right ? tarBounds.right + hSpacing : tarBounds.left - hSpacing;
                var finalX = !isSiblingsInRight && max > tarBounds.right ? tarBounds.right : tarBounds.left;
                pts.push({ x: startX, y: srcNode.offsetY });
                pts.push({ x: middleX, y: srcNode.offsetY });
                pts.push({ x: middleX, y: verticalMiddle });
                pts.push({ x: endX, y: verticalMiddle });
                pts.push({ x: endX, y: tarNode.offsetY });
                pts.push({ x: finalX, y: tarNode.offsetY });
            }
            if (overlappingNodesInDiagram.length > 0) {
                var boundsValue = isSiblingsInRight
                    ? Math.min.apply(Math, overlappingNodesInDiagram.map(function (node) { return node.wrapper.bounds.left; })) : Math.max.apply(Math, overlappingNodesInDiagram.map(function (node) { return node.wrapper.bounds.right; }));
                if ((isSiblingsInRight && boundsValue < pts[1].x) || (!isSiblingsInRight && boundsValue > pts[1].x)) {
                    var newX = boundsValue + (isSiblingsInRight ? -hSpacing : hSpacing);
                    pts[1].x = newX;
                    pts[2].x = newX;
                }
            }
        }
        else {
            var source = Array.from(this.vertexMapper.values())
                .filter(function (e) {
                return e.item.wrapper.bounds.containsPoint({ y: e.item.wrapper.bounds.y, x: srcNode.offsetX }) &&
                    srcNode.id !== e.item.id;
            });
            var target = Array.from(this.vertexMapper.values())
                .filter(function (e) {
                return e.item.wrapper.bounds.containsPoint({ y: e.item.wrapper.bounds.y, x: tarNode.offsetX }) &&
                    tarNode.id !== e.item.id;
            });
            var max = Math.max.apply(Math, loopPts.map(function (pt) { return pt.y; }));
            var isSiblingsInBottom = false;
            if (decisionNode) {
                if (isYesBranchLeft || isNoBranchRight) {
                    isSiblingsInBottom = true;
                }
            }
            else {
                isSiblingsInBottom = (source.length > 0 && source[0].item.wrapper.bounds.y > srcBounds.y);
            }
            if (target.length === 0 || (!isSiblingsInBottom && target.length > 0 && target.some(function (e) {
                return e.item.wrapper.bounds.bottom < tarBounds.top;
            }))) {
                pts.push({ x: srcNode.offsetX, y: (!isSiblingsInBottom && max > srcBounds.bottom) ? srcBounds.bottom : srcBounds.top });
                var midY = pts[0].y + (isSiblingsInBottom ? -vSpacing : vSpacing);
                pts.push({ x: srcNode.offsetX, y: midY });
                pts.push({ x: tarNode.offsetX, y: midY });
                pts.push({ x: tarNode.offsetX, y: (!isSiblingsInBottom && max > tarBounds.bottom) ? tarBounds.bottom : tarBounds.top });
            }
            else {
                var targetRight = target[0].item.wrapper.bounds.right + hSpacing;
                var midY = (!isSiblingsInBottom && max > tarBounds.bottom)
                    ? tarBounds.bottom + vSpacing : tarBounds.top - vSpacing;
                pts.push({ x: srcNode.offsetX, y: (!isSiblingsInBottom) ? srcBounds.bottom : srcBounds.top });
                pts.push({ x: srcNode.offsetX, y: pts[0].y + (isSiblingsInBottom ? -vSpacing : vSpacing) });
                pts.push({ x: targetRight, y: pts[1].y });
                pts.push({ x: targetRight, y: midY });
                pts.push({ x: tarNode.offsetX, y: midY });
                pts.push({ x: tarNode.offsetX, y: ((!isSiblingsInBottom && max > tarBounds.bottom) ? tarBounds.bottom : tarBounds.top) });
            }
            if (overlappingNodesInDiagram.length > 0) {
                var boundsValue = isSiblingsInBottom
                    ? Math.min.apply(Math, overlappingNodesInDiagram.map(function (e) { return e.wrapper.bounds.top; })) : Math.max.apply(Math, overlappingNodesInDiagram.map(function (e) { return e.wrapper.bounds.bottom; }));
                if ((isSiblingsInBottom && pts[1].y > boundsValue) || (!isSiblingsInBottom && pts[1].y < boundsValue)) {
                    var adjustment = isSiblingsInBottom ? -vSpacing : vSpacing;
                    pts[1].y = boundsValue + adjustment;
                    pts[2].y = boundsValue + adjustment;
                }
            }
        }
        this.updatePoints(pts, internalConnector);
    };
    FlowchartLayout.prototype.checkForYesOrNoBranch = function (edge, isYesBranch, isNoBranch) {
        var _this = this;
        if (edge.annotations && edge.annotations.length) {
            edge.annotations.forEach(function (annotation) {
                if (typeof annotation.content === 'string') {
                    var text_2 = annotation.content.toString();
                    _this.yesBranchValues.forEach(function (branchText) {
                        if (text_2.localeCompare(branchText, undefined, { sensitivity: 'accent' }) === 0) {
                            isYesBranch = true;
                            return;
                        }
                    });
                    _this.noBranchValues.forEach(function (branchText) {
                        if (text_2.localeCompare(branchText, undefined, { sensitivity: 'accent' }) === 0) {
                            isNoBranch = true;
                            return;
                        }
                    });
                }
            });
        }
        return { isYesBranch: isYesBranch, isNoBranch: isNoBranch };
    };
    FlowchartLayout.prototype.getTreeVertices = function (root, seenVertices, unseenVertices) {
        var _this = this;
        if (root != null && seenVertices.indexOf(root) === -1) {
            seenVertices.push(root);
            unseenVertices = unseenVertices.filter(function (vertex) { return vertex !== root; });
            var children = root.item.outEdges;
            if (children.length === 2) {
                var c1 = this.diagram.nameTable[this.diagram.nameTable[children[0]].targetID];
                var c2 = this.diagram.nameTable[this.diagram.nameTable[children[1]].targetID];
                var childVertex1 = this.vertexMapper.get(c1.id);
                var childVertex2 = this.vertexMapper.get(c2.id);
                if (childVertex1 && childVertex2) {
                    var hasYesChild = childVertex1.isYesChild || childVertex2.isYesChild;
                    var hasNoChild = childVertex1.isNoChild || childVertex2.isNoChild;
                    if (hasYesChild && !hasNoChild) {
                        if (childVertex1.isYesChild) {
                            childVertex2.isNoChild = true;
                        }
                        else {
                            childVertex1.isNoChild = true;
                        }
                        hasNoChild = true;
                    }
                    else if (!hasYesChild && hasNoChild) {
                        if (childVertex1.isNoChild) {
                            childVertex2.isYesChild = true;
                        }
                        else {
                            childVertex1.isYesChild = true;
                        }
                        hasYesChild = true;
                    }
                    root.isDecisionNode = hasYesChild;
                }
            }
            root.outEdges.forEach(function (outConnector) {
                var child = _this.diagram.nameTable[outConnector.targetID];
                var childVertex = _this.vertexMapper.get(child.id);
                if (childVertex != null) {
                    if (!root.isDecisionNode) {
                        childVertex.isYesChild = false;
                        childVertex.isNoChild = false;
                    }
                    _this.getTreeVertices(childVertex, seenVertices, unseenVertices);
                }
            });
        }
    };
    /**
     * Initializes the edges collection of the vertices\
     *
     * @returns {  IConnector[] }    Initializes the edges collection of the vertices\
     * @param {FlowChartVertex} node - provide the node value.
     * @private
     */
    FlowchartLayout.prototype.getEdges = function (node) {
        var edges = [];
        if (node !== null && node !== undefined) {
            for (var _i = 0, _a = node.inEdges; _i < _a.length; _i++) {
                var inEdge = _a[_i];
                edges.push(inEdge);
            }
            for (var _b = 0, _c = node.outEdges; _b < _c.length; _b++) {
                var outEdge = _c[_b];
                edges.push(outEdge);
            }
        }
        return edges;
    };
    /**
     * Returns the source/target vertex of the given connector \
     *
     * @returns {  FlowChartVertex }    Returns the source/target vertex of the given connector \
     * @param {IConnector} edge - provide the node value.
     * @param {boolean} source - provide the node value.
     * @private
     */
    FlowchartLayout.prototype.getVisibleTerminal = function (edge, source) {
        //differ from complex-hierarchical-tree.ts
        var nodeWrapper = source ? edge.sourceID : edge.targetID;
        return this.vertexMapper.get(nodeWrapper);
    };
    /**
     * used to get the edges between the given source and target  \
     *
     * @returns {  IConnector[] }    used to get the edges between the given source and target  .\
     * @param {FlowChartVertex} source - provide the angle value.
     * @param { FlowChartVertex} target - provide the angle value.
     * @param { boolean} directed - provide the angle value.
     * @private
     */
    FlowchartLayout.prototype.getEdgesBetween = function (source, target, directed) {
        var edges = this.getEdges(source);
        var result = [];
        for (var i = 0; i < edges.length; i++) {
            var src = this.getVisibleTerminal(edges[parseInt(i.toString(), 10)], true);
            var trg = this.getVisibleTerminal(edges[parseInt(i.toString(), 10)], false);
            if ((src.id === source.id && trg.id === target.id)) {
                result.push(edges[parseInt(i.toString(), 10)]);
            }
        }
        return result;
    };
    /**
     *To destroy the FlowchartLayout
     *
     * @returns {void} To destroy the FlowchartLayout
     */
    FlowchartLayout.prototype.destroy = function () {
        /**
         * Destroys the FlowchartLayout module
         */
    };
    /**
     * @returns { string } toBounds method .\
     * Get getModuleName name.
     */
    FlowchartLayout.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'FlowchartLayout';
    };
    return FlowchartLayout;
}());

var ConnectorProperties = /** @class */ (function () {
    function ConnectorProperties(labelProperties) {
        this.labelProperties = labelProperties;
    }
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Convert and render the connector collection from EJ1 to EJ2
    ConnectorProperties.prototype.renderConnectorsCollection = function (convertedData, data) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        convertedData.connectors = [];
        var connectors = [];
        for (var i = 0; i < data.connectors.length; i++) {
            var connector = data.connectors[parseInt(i.toString(), 10)];
            var newConnector = this.convertToConnector(connector);
            connectors.push(newConnector);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        convertedData.connectors = connectors;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Convert and render the connector properties from EJ1 to EJ2
    ConnectorProperties.prototype.convertToConnector = function (connector) {
        var newConnector = {};
        newConnector.style = {};
        if (connector.name) {
            newConnector.id = connector.name;
        }
        if (connector.addInfo) {
            newConnector.addInfo = connector.addInfo;
        }
        if (connector.bridgeSpace) {
            newConnector.bridgeSpace = connector.bridgeSpace;
        }
        if (connector.constraints) {
            newConnector.constraints = this.setConnectorConstraints(connector.constraints);
        }
        if (connector.cornerRadius) {
            newConnector.cornerRadius = connector.cornerRadius;
        }
        if (connector.labels) {
            newConnector.annotations = this.labelProperties.setLabelProperties(connector.labels, connector);
        }
        if (connector.lineColor) {
            newConnector.style.fill = connector.lineColor;
        }
        if (connector.lineWidth) {
            newConnector.style.strokeWidth = connector.lineWidth;
        }
        if (connector.lineDashArray) {
            newConnector.style.strokeDashArray = connector.lineDashArray;
        }
        if (connector.opacity) {
            newConnector.style.opacity = connector.opacity;
        }
        if (connector.lineHitPadding) {
            newConnector.hitPadding = connector.lineHitPadding;
        }
        if (connector.margin) {
            // eslint-disable-next-line max-len
            newConnector.margin = { left: connector.margin.left, right: connector.margin.right, top: connector.margin.top, bottom: connector.margin.bottom };
        }
        if (connector.segments) {
            newConnector.type = connector.segments[0].type.charAt(0).toUpperCase() + (connector.segments[0].type).slice(1);
            newConnector.segments = this.setConnectorSegments(connector.segments);
        }
        if (connector.shape) {
            newConnector.shape = this.getConnectorShape(connector.shape);
        }
        if (connector.sourceDecorator) {
            newConnector.sourceDecorator = {
                height: connector.sourceDecorator.height,
                width: connector.sourceDecorator.width,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                shape: (this.getDecoratorShape(connector.sourceDecorator.shape)),
                pathData: connector.sourceDecorator.pathData,
                style: {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    fill: connector.sourceDecorator.fillColor,
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    strokeColor: connector.sourceDecorator.lineColor,
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    strokeWidth: connector.sourceDecorator.lineWidth
                }
            };
        }
        if (connector.targetDecorator) {
            newConnector.targetDecorator = {
                height: connector.targetDecorator.height,
                width: connector.targetDecorator.width,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                shape: this.getDecoratorShape(connector.targetDecorator.shape),
                pathData: connector.targetDecorator.pathData,
                style: {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    fill: connector.targetDecorator.fillColor,
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    strokeColor: connector.targetDecorator.lineColor,
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    strokeWidth: connector.targetDecorator.lineWidth
                }
            };
        }
        if (connector.sourceNode) {
            newConnector.sourceID = connector.sourceNode;
        }
        if (connector.targetNode) {
            newConnector.targetID = connector.targetNode;
        }
        if (connector.sourcePoint) {
            newConnector.sourcePoint = { x: connector.sourcePoint.x, y: connector.sourcePoint.y };
        }
        if (connector.targetPoint) {
            newConnector.targetPoint = { x: connector.targetPoint.x, y: connector.targetPoint.y };
        }
        if (connector.sourcePort) {
            newConnector.sourcePortID = connector.sourcePort;
        }
        if (connector.targetPort) {
            newConnector.targetPortID = connector.targetPort;
        }
        if (connector.tooltip) {
            newConnector.tooltip = {
                content: connector.tooltip.content,
                relativeMode: connector.tooltip.relativeMode
            };
        }
        if (connector.visible) {
            newConnector.visible = connector.visible;
        }
        if (connector.zOrder) {
            newConnector.zIndex = connector.zOrder;
        }
        return newConnector;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Convert and assign the connector shapes from EJ1 to EJ2
    ConnectorProperties.prototype.getConnectorShape = function (shape) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var connectorShape = null;
        if (shape) {
            if (shape.type === 'bpmn') {
                connectorShape = {
                    type: 'Bpmn',
                    flow: (shape.flow).charAt(0).toUpperCase() + (shape.flow).slice(1)
                };
                if (shape.flow === 'sequence') {
                    connectorShape.sequence = (shape.sequence).charAt(0).toUpperCase() + (shape.sequence).slice(1);
                }
                else if (shape.flow === 'association') {
                    connectorShape.association = (shape.association).charAt(0).toUpperCase() + (shape.association).slice(1);
                }
                else {
                    connectorShape.message = (shape.message).charAt(0).toUpperCase() + (shape.message).slice(1);
                }
            }
            if (shape.type === 'umlclassifier') {
                connectorShape = {
                    type: 'UmlClassifier',
                    relationship: (shape.relationship).charAt(0).toUpperCase() + (shape.relationship).slice(1),
                    multiplicity: {
                        type: (shape.multiplicity.type).charAt(0).toUpperCase() + (shape.multiplicity.type).slice(1),
                        source: {
                            upperBounds: shape.multiplicity.source.upperBounds,
                            optional: shape.multiplicity.source.optional,
                            lowerBounds: shape.multiplicity.source.lowerBounds
                        },
                        target: {
                            upperBounds: shape.multiplicity.target.upperBounds,
                            optional: shape.multiplicity.target.optional,
                            lowerBounds: shape.multiplicity.target.lowerBounds
                        }
                    }
                };
            }
            if (shape.type === 'umlactivity') {
                connectorShape = {
                    type: 'UmlActivity',
                    flow: (shape.flow).charAt(0).toUpperCase() + (shape.flow).slice(1)
                };
            }
        }
        return connectorShape;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Sets the connector decorator shapes from EJ1 to EJ2
    ConnectorProperties.prototype.getDecoratorShape = function (shape) {
        var decoratorShape = 'None';
        if (shape === 'path') {
            decoratorShape = 'Custom';
        }
        else {
            decoratorShape = (shape).charAt(0).toUpperCase() + (shape).slice(1);
        }
        return decoratorShape;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Convert and render the connector collection from EJ1 to EJ2
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ConnectorProperties.prototype.setConnectorSegments = function (segments) {
        var connectorSegments = [];
        if (segments.length > 0) {
            for (var i = 0; i < segments.length; i++) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var segment = {};
                var segmentProp = segments[parseInt(i.toString(), 10)];
                // eslint-disable-next-line max-len
                segment.direction = segmentProp.direction ? segmentProp.direction.charAt(0).toUpperCase() + segmentProp.direction.slice(1) : segmentProp._direction ? segmentProp._direction.charAt(0).toUpperCase() + segmentProp._direction.slice(1) : null;
                segment.length = segmentProp.length ? segmentProp.length : segmentProp._length ? segmentProp._length : null;
                segment.point = segmentProp.point ? { x: segmentProp.point.x, y: segmentProp.point.y } : null;
                segment.point1 = segmentProp.point1 ? { x: segmentProp.point1.x, y: segmentProp.point1.y } : null;
                segment.point2 = segmentProp.point2 ? { x: segmentProp.point2.x, y: segmentProp.point2.y } : null;
                // eslint-disable-next-line max-len
                segment.vector1 = segmentProp.vector1 ? { angle: segmentProp.vector1.angle, distance: segmentProp.vector1.distance } : null;
                // eslint-disable-next-line max-len
                segment.vector2 = segmentProp.vector2 ? { angle: segmentProp.vector2.angle, distance: segmentProp.vector2.distance } : null;
                if (segmentProp.points) {
                    segment.points = this.getSegmentPoints(segmentProp.points);
                }
                if (segmentProp.type) {
                    segment.type = (segmentProp.type).charAt(0).toUpperCase() + (segmentProp.type).slice(1);
                }
                connectorSegments.push(segment);
            }
        }
        return connectorSegments;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Render the connector Segment points from EJ1 to EJ2
    ConnectorProperties.prototype.getSegmentPoints = function (points) {
        var pointsCollection = [];
        if (points.length > 0) {
            for (var i = 0; i < points.length; i++) {
                var newPoint = {};
                var point = points[parseInt(i.toString(), 10)];
                newPoint.x = point.x;
                newPoint.y = point.y;
                pointsCollection.push(newPoint);
            }
        }
        return pointsCollection;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Sets the connector constraints
    ConnectorProperties.prototype.setConnectorConstraints = function (constraints) {
        var connectorConstraints = ConnectorConstraints.None;
        if (constraints & ConnectorConstraints.Select) {
            connectorConstraints = connectorConstraints | ConnectorConstraints.Select;
        }
        if (constraints & ConnectorConstraints.Delete) {
            connectorConstraints = connectorConstraints | ConnectorConstraints.Delete;
        }
        if (constraints & ConnectorConstraints.Drag) {
            connectorConstraints = connectorConstraints | ConnectorConstraints.Drag;
        }
        if (constraints & ConnectorConstraints.DragSourceEnd) {
            connectorConstraints = connectorConstraints | ConnectorConstraints.DragSourceEnd;
        }
        if (constraints & ConnectorConstraints.DragTargetEnd) {
            connectorConstraints = connectorConstraints | ConnectorConstraints.DragTargetEnd;
        }
        if (constraints & ConnectorConstraints.DragSegmentThumb) {
            connectorConstraints = connectorConstraints | ConnectorConstraints.DragSegmentThumb;
        }
        if (constraints & ConnectorConstraints.Bridging) {
            connectorConstraints = connectorConstraints | ConnectorConstraints.Bridging;
        }
        if (constraints & ConnectorConstraints.InheritBridging) {
            connectorConstraints = connectorConstraints | ConnectorConstraints.InheritBridging;
        }
        if (constraints & ConnectorConstraints.AllowDrop) {
            connectorConstraints = connectorConstraints | ConnectorConstraints.AllowDrop;
        }
        if (constraints & ConnectorConstraints.InheritTooltip) {
            connectorConstraints = connectorConstraints | ConnectorConstraints.InheritTooltip;
        }
        if (constraints & ConnectorConstraints.PointerEvents) {
            connectorConstraints = connectorConstraints | ConnectorConstraints.PointerEvents;
        }
        if (constraints & ConnectorConstraints.BridgeObstacle) {
            connectorConstraints = connectorConstraints | ConnectorConstraints.BridgeObstacle;
        }
        if (constraints & ConnectorConstraints.Interaction) {
            connectorConstraints = connectorConstraints | ConnectorConstraints.Interaction;
        }
        if (constraints & ConnectorConstraints.Default) {
            connectorConstraints = connectorConstraints | ConnectorConstraints.Default;
        }
        return connectorConstraints;
    };
    /**
     * Get module name.
     *
     * @returns {string} Returns the module name
     */
    ConnectorProperties.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'ConnectorProperties';
    };
    return ConnectorProperties;
}());

var LabelProperties = /** @class */ (function () {
    function LabelProperties(modelProperties) {
        this.modelProperties = modelProperties;
    }
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update and assign the annotation properties from EJ1 to EJ2
    LabelProperties.prototype.setLabelProperties = function (oldLabels, item) {
        var labelCollection = [];
        if (oldLabels.length > 0) {
            for (var i = 0; i < oldLabels.length; i++) {
                var label = oldLabels[parseInt(i.toString(), 10)];
                var newLabel = {};
                (newLabel).style = {};
                // 930796: EJ1's Annotation id is not applied properly in EJ2 diagram
                if (label.name) {
                    var annotationId = label.name.split('_');
                    var id = annotationId[annotationId.length - 1];
                    newLabel.id = id;
                }
                if (label.addInfo) {
                    newLabel.addInfo = label.addInfo;
                }
                if (label.text) {
                    newLabel.content = label.text;
                }
                if (label.constraints) {
                    newLabel.constraints = this.setLabelConstraints(label.constraints);
                }
                if (label.readOnly) {
                    newLabel.constraints = newLabel.constraints | AnnotationConstraints.ReadOnly;
                }
                if (label.dragLimit) {
                    newLabel.dragLimit = {
                        left: label.dragLimit.left, right: label.dragLimit.right,
                        top: label.dragLimit.top, bottom: label.dragLimit.bottom
                    };
                }
                if (label.height) {
                    newLabel.height = label.height;
                }
                if (label.horizontalAlignment) {
                    newLabel.horizontalAlignment = label.horizontalAlignment.charAt(0).toUpperCase() +
                        label.horizontalAlignment.slice(1).toLowerCase();
                }
                if (label.verticalAlignment) {
                    newLabel.verticalAlignment = label.verticalAlignment.charAt(0).toUpperCase() +
                        label.verticalAlignment.slice(1).toLowerCase();
                }
                if (label.hyperlink) {
                    newLabel.hyperlink = { link: label.hyperlink, color: 'blue' };
                }
                if (label.margin) {
                    newLabel.margin = {
                        left: label.margin.left, right: label.margin.right,
                        top: label.margin.top, bottom: label.margin.bottom
                    };
                }
                newLabel.rotateAngle = label.rotateAngle;
                if (label.offset) {
                    if (item) {
                        newLabel.offset = label.offset.x;
                    }
                    else {
                        newLabel.offset = { x: label.offset.x, y: label.offset.y };
                    }
                }
                newLabel.style.color = label.fontColor;
                newLabel.style.fontFamily = label.fontFamily;
                newLabel.style.fontSize = label.fontSize;
                newLabel.style.italic = label.italic;
                newLabel.style.bold = label.bold;
                if (label.borderColor) {
                    newLabel.style.strokeColor = label.borderColor;
                }
                if (label.borderWidth) {
                    newLabel.style.strokeWidth = label.borderWidth;
                }
                // 930796: EJ1's Annotation wrapping and text overflow style is not applied properly in EJ2 diagram
                if (label.wrapping) {
                    switch (label.wrapping) {
                        case 'wrap':
                            newLabel.style.textWrapping = 'Wrap';
                            break;
                        case 'nowrap':
                            newLabel.style.textWrapping = 'NoWrap';
                            break;
                        case 'wrapwithoverflow':
                            newLabel.style.textWrapping = 'WrapWithOverflow';
                            break;
                    }
                }
                if (label.textOverflow && label.overflowType) {
                    newLabel.style.textOverflow = (label.overflowType.charAt(0).toUpperCase() +
                        (label.overflowType).slice(1));
                }
                if (label.textAlign) {
                    newLabel.style.textAlign = label.textAlign.charAt(0).toUpperCase() +
                        label.textAlign.slice(1).toLowerCase();
                }
                if (label.textDecoration) {
                    newLabel.style.textDecoration = label.textDecoration.charAt(0).toUpperCase() +
                        label.textDecoration.slice(1).toLowerCase();
                    if (newLabel.style.textDecoration === 'Linethrough') {
                        newLabel.style.textDecoration = 'LineThrough';
                    }
                }
                var appearance = this.setLabelAppearance(newLabel, label);
                newLabel.style.fill = appearance.fill;
                newLabel.style.opacity = appearance.opacity;
                //  if (label.templateId)
                //  newLabel.template = getTemplateContent(label.templateId);
                newLabel.visibility = appearance.visibility;
                if (label.width) {
                    newLabel.width = label.width;
                }
                labelCollection.push(newLabel);
            }
        }
        return labelCollection;
    };
    LabelProperties.prototype.setLabelAppearance = function (newLabel, label) {
        var appearance = {};
        if (label.fillColor) {
            appearance.fill = label.fillColor === 'white' ? 'transparent' : label.fillColor;
        }
        if (label.opacity) {
            appearance.opacity = label.opacity;
        }
        //  if (label.templateId)
        //  newLabel.template = getTemplateContent(label.templateId);
        if (label.visible) {
            appearance.visibility = label.visible;
        }
        return appearance;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update the annotation constraints from EJ1 to EJ2
    LabelProperties.prototype.setLabelConstraints = function (constraints) {
        var annotationConstraints = AnnotationConstraints.None;
        if (constraints & AnnotationConstraints.Select) {
            annotationConstraints = annotationConstraints | AnnotationConstraints.Select;
        }
        if (constraints & AnnotationConstraints.Drag) {
            annotationConstraints = annotationConstraints | AnnotationConstraints.Drag;
        }
        if (constraints & AnnotationConstraints.Resize) {
            annotationConstraints = annotationConstraints | AnnotationConstraints.Resize;
        }
        if (constraints & AnnotationConstraints.Rotate) {
            annotationConstraints = annotationConstraints | AnnotationConstraints.Rotate;
        }
        return annotationConstraints;
    };
    /**
     * Get module name.
     * @returns {string} returns Module name
     */
    LabelProperties.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'LabelProperties';
    };
    return LabelProperties;
}());

var NodeProperties = /** @class */ (function () {
    function NodeProperties(labelProperties, portProperties) {
        this.labelProperties = labelProperties;
        this.portProperties = portProperties;
    }
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Convert and render the node collection from EJ1 to EJ2
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    NodeProperties.prototype.renderNodesCollection = function (convertedData, data) {
        convertedData.nodes = [];
        var nodes = [];
        for (var i = 0; i < data.nodes.length; i++) {
            var node = data.nodes[parseInt(i.toString(), 10)];
            var processCollection = [];
            var newNode = this.convertToNode(node);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            // eslint-disable-next-line max-len
            if (newNode.shape && newNode.shape.activity && newNode.shape.activity.subProcess && newNode.shape.activity.subProcess.processes && newNode.shape.activity.subProcess.processes.length > 0) {
                var processName = [];
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                for (var k = 0; k < newNode.shape.activity.subProcess.processes.length; k++) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    var processes = newNode.shape.activity.subProcess.processes[parseInt(k.toString(), 10)];
                    processes.margin.right = 0;
                    processes.margin.bottom = 0;
                    processes.processId = newNode.id;
                    processName.push(processes.id);
                    processCollection.push(processes);
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                newNode.shape.activity.subProcess.processes = processName;
            }
            if (node.type === 'group' && !node.isSwimlane) {
                var childCollection = [];
                if (newNode.children && newNode.children.length > 0) {
                    for (var j = 0; j < newNode.children.length; j++) {
                        var child = newNode.children[parseInt(j.toString(), 10)];
                        nodes.push(child);
                        childCollection.push(child.id);
                    }
                    newNode.children = childCollection;
                }
            }
            nodes.push(newNode);
            if (processCollection && processCollection.length > 0) {
                nodes = nodes.concat(processCollection);
            }
        }
        convertedData.nodes = nodes;
        return convertedData.nodes;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Convert the node from EJ1 to EJ2 and assign all the properties
    NodeProperties.prototype.convertToNode = function (node) {
        var newNode = {};
        newNode.style = {};
        newNode.margin = {};
        if (node.name) {
            newNode.id = node.name;
        }
        if (node.fillColor) {
            newNode.style.fill = node.fillColor;
        }
        if (node.borderColor) {
            newNode.style.strokeColor = node.borderColor;
        }
        if (node.borderWidth) {
            newNode.style.strokeWidth = node.borderWidth;
        }
        if (node.borderDashArray) {
            newNode.style.strokeDashArray = node.borderDashArray;
        }
        if (node.opacity) {
            newNode.style.opacity = node.opacity;
        }
        if (node.gradient) {
            newNode.style.gradient = this.setGradient(node.gradient);
        }
        if (node.isExpanded) {
            newNode.isExpanded = node.isExpanded;
        }
        if (node.width) {
            newNode.width = node.width;
        }
        if (node.height) {
            newNode.height = node.height;
        }
        if (node.offsetX) {
            newNode.offsetX = node.offsetX;
        }
        if (node.offsetY) {
            newNode.offsetY = node.offsetY;
        }
        if (node.visible) {
            newNode.visible = node.visible;
        }
        newNode.zIndex = node.zOrder === -1 ? -1 : node.zOrder;
        if (node.excludeFromLayout) {
            newNode.excludeFromLayout = node.excludeFromLayout;
        }
        if (node.rotateAngle) {
            newNode.rotateAngle = node.rotateAngle;
        }
        if (node.pivot) {
            newNode.pivot = node.pivot;
        }
        if (node.addInfo) {
            newNode.addInfo = node.addInfo;
        }
        if (node.marginLeft) {
            newNode.margin.left = node.marginLeft;
        }
        if (node.marginRight) {
            newNode.margin.right = node.marginRight;
        }
        if (node.marginTop) {
            newNode.margin.top = node.marginTop;
        }
        if (node.marginBottom) {
            newNode.margin.bottom = node.marginBottom;
        }
        if (node.horizontalAlign) {
            newNode.horizontalAlignment = node.horizontalAlign;
        }
        if (node.verticalAlign) {
            newNode.verticalAlignment = node.verticalAlign;
        }
        if (node.constraints) {
            newNode.constraints = this.setNodeConstraints(node.constraints);
        }
        if (node.labels) {
            newNode.annotations = this.labelProperties.setLabelProperties(node.labels, undefined);
        }
        if (node.shadow) {
            newNode.shadow = {
                angle: node.shadow.angle, opacity: node.shadow.opacity, distance: node.shadow.distance
            };
        }
        if (node.tooltip) {
            newNode.tooltip = {
                // content: this.getTemplateContent(node.tooltip.templateId),
                relativeMode: node.tooltip.relativeMode
            };
        }
        if (node.expandIcon) {
            newNode.expandIcon = {
                shape: node.expandIcon.shape.charAt(0).toUpperCase() + (node.expandIcon.shape).slice(1),
                width: node.expandIcon.width, height: node.expandIcon.height,
                margin: {
                    left: node.expandIcon.margin.left,
                    right: node.expandIcon.margin.right,
                    top: node.expandIcon.margin.top,
                    bottom: node.expandIcon.margin.bottom
                },
                offset: {
                    x: node.expandIcon.offset.x,
                    y: node.expandIcon.offset.y
                },
                borderColor: node.expandIcon.borderColor, borderWidth: node.expandIcon.borderWidth,
                cornerRadius: node.expandIcon.cornerRadius,
                //fill: (node.expandIcon as any).fillColor,
                pathData: node.expandIcon.pathData
                // content: getTemplateContent(node.expandIcon.templateId)
            };
            if (newNode.expandIcon.shape === 'Arrowup') {
                newNode.expandIcon.shape = 'ArrowUp';
            }
            else if (newNode.expandIcon.shape === 'Arrowdown') {
                newNode.expandIcon.shape = 'ArrowDown';
            }
        }
        if (node.collapseIcon) {
            newNode.collapseIcon = {
                shape: node.collapseIcon.shape.charAt(0).toUpperCase() + (node.collapseIcon.shape).slice(1),
                width: node.collapseIcon.width, height: node.collapseIcon.height,
                margin: {
                    left: node.collapseIcon.margin.left,
                    right: node.collapseIcon.margin.right,
                    top: node.collapseIcon.margin.top,
                    bottom: node.collapseIcon.margin.bottom
                },
                offset: {
                    x: node.collapseIcon.offset.x,
                    y: node.collapseIcon.offset.y
                },
                borderColor: node.collapseIcon.borderColor, borderWidth: node.collapseIcon.borderWidth,
                cornerRadius: node.collapseIcon.cornerRadius,
                // fill: (node.collapseIcon as any).fillColor,
                pathData: node.collapseIcon.pathData
                //  content: getTemplateContent(node.collapseIcon.templateId)
            };
            if (newNode.collapseIcon.shape === 'Arrowup') {
                newNode.collapseIcon.shape = 'ArrowUp';
            }
            else if (newNode.collapseIcon.shape === 'Arrowdown') {
                newNode.collapseIcon.shape = 'ArrowDown';
            }
        }
        if (node.ports) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            newNode.ports = this.portProperties.setPortProperties(node.ports);
        }
        if (node.children) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (node.type !== 'bpmn' && !node.isSwimlane) {
                newNode.children = this.getChildren(newNode, node);
            }
        }
        if (!(node.children && node.children.length > 0)) {
            newNode.maxWidth = node.maxWidth;
            newNode.maxHeight = node.maxHeight;
            newNode.minWidth = node.minWidth;
            newNode.minHeight = node.minHeight;
        }
        if (node.shape || node.type) {
            newNode = this.setShape(newNode, node);
        }
        return newNode;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Iterate the swimlane child nodes and assign all the node properties from the EJ1 to EJ2
    NodeProperties.prototype.getChildren = function (newNode, node) {
        if (node.children && node.children.length > 0) {
            var newChild = [];
            for (var i = 0; i < node.children.length; i++) {
                var child = this.convertToNode(node.children[parseInt(i.toString(), 10)]);
                if (child.children) {
                    this.getChildren(newNode, child);
                }
                newChild.push(child);
            }
            newNode.children = newChild;
        }
        return newNode.children;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Sets the shapes for all the node from conversion
    NodeProperties.prototype.setShape = function (newNode, node) {
        switch (node.type) {
            case 'basic': {
                var basicShape = (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1);
                if (node.shape === 'path') {
                    newNode.shape = { type: 'Path', data: node.pathData };
                }
                else {
                    newNode.shape = {
                        type: 'Basic', shape: basicShape, cornerRadius: node.cornerRadius, points: node.points
                    };
                }
                break;
            }
            case 'flow': {
                var flowShape = (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1);
                newNode.shape = {
                    type: 'Flow', shape: flowShape
                };
                break;
            }
            case 'umlactivity':
                newNode.shape = {
                    type: 'UmlActivity', shape: (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1)
                };
                break;
            case 'image':
                newNode.shape = {
                    type: 'Image', source: node.source, align: this.getImageContentAlignment(node.contentAlignment),
                    scale: (node.scale).charAt(0).toUpperCase() + (node.scale).slice(1)
                };
                break;
            case 'html':
                newNode.shape = { type: 'HTML' };
                break;
            case 'native':
                newNode.shape = { type: 'Native' };
                break;
            case 'text':
                newNode.shape = { type: 'Text', content: node.textBlock.text };
                break;
            case 'bpmn':
                newNode.shape = this.renderBpmnShape(newNode, node);
                break;
            case 'group':
                if (node.isSwimlane) {
                    newNode.shape = this.renderSwimlaneShape(newNode, node);
                }
        }
        return newNode;
    };
    NodeProperties.prototype.getImageContentAlignment = function (option) {
        if (option) {
            switch (option) {
                case 'xminymin':
                    return 'XMinYMin';
                case 'xminymid':
                    return 'XMinYMid';
                case 'xminymax':
                    return 'XMinYMax';
                case 'xmidymin':
                    return 'XMidYMin';
                case 'xmidymid':
                    return 'XMidYMid';
                case 'xmidymax':
                    return 'XMidYMax';
                case 'xmaxymin':
                    return 'XMaxYMin';
                case 'xmaxymid':
                    return 'XMaxYMid';
                case 'xmaxymax':
                    return 'XMaxYMax';
                case 'none':
                    return 'None';
            }
        }
        return 'None';
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    // Sets the node constraints from EJ1 to EJ2
    NodeProperties.prototype.setNodeConstraints = function (constraints) {
        var nodeConstraints = NodeConstraints.None;
        if (constraints & NodeConstraints.Select) {
            nodeConstraints = nodeConstraints | NodeConstraints.Select;
        }
        if (constraints & NodeConstraints.Delete) {
            nodeConstraints = nodeConstraints | NodeConstraints.Delete;
        }
        if (constraints & NodeConstraints.Drag) {
            nodeConstraints = nodeConstraints | NodeConstraints.Drag;
        }
        if (constraints & NodeConstraints.Rotate) {
            nodeConstraints = nodeConstraints | NodeConstraints.Rotate;
        }
        if (constraints & NodeConstraints.ResizeNorthEast) {
            nodeConstraints = nodeConstraints | NodeConstraints.ResizeNorthEast;
        }
        if (constraints & NodeConstraints.ResizeEast) {
            nodeConstraints = nodeConstraints | NodeConstraints.ResizeEast;
        }
        if (constraints & NodeConstraints.OutConnect) {
            nodeConstraints = nodeConstraints | NodeConstraints.ResizeSouthEast;
        }
        if (constraints & NodeConstraints.Expandable) {
            nodeConstraints = nodeConstraints | NodeConstraints.ResizeSouth;
        }
        if (constraints & NodeConstraints.AllowDrop) {
            nodeConstraints = nodeConstraints | NodeConstraints.ResizeSouthWest;
        }
        if (constraints & NodeConstraints.ResizeNorthEast) {
            nodeConstraints = nodeConstraints | NodeConstraints.ResizeWest;
        }
        if (constraints & NodeConstraints.ResizeEast) {
            nodeConstraints = nodeConstraints | NodeConstraints.ResizeNorthWest;
        }
        if (constraints & NodeConstraints.ResizeNorth) {
            nodeConstraints = nodeConstraints | NodeConstraints.ResizeNorth;
        }
        if (constraints & NodeConstraints.Resize) {
            nodeConstraints = nodeConstraints | NodeConstraints.Resize;
        }
        if (constraints & NodeConstraints.Shadow) {
            nodeConstraints = nodeConstraints | NodeConstraints.Shadow;
        }
        if (constraints & NodeConstraints.AspectRatio) {
            nodeConstraints = nodeConstraints | NodeConstraints.AspectRatio;
        }
        if (constraints & NodeConstraints.AllowDrop) {
            nodeConstraints = nodeConstraints | NodeConstraints.AllowDrop;
        }
        if (constraints & NodeConstraints.InheritTooltip) {
            nodeConstraints = nodeConstraints | NodeConstraints.InheritTooltip;
        }
        if (constraints & NodeConstraints.PointerEvents) {
            nodeConstraints = nodeConstraints | NodeConstraints.PointerEvents;
        }
        if (constraints & NodeConstraints.Inherit) {
            nodeConstraints = nodeConstraints | NodeConstraints.Inherit;
        }
        if (constraints & NodeConstraints.Default) {
            nodeConstraints = nodeConstraints | NodeConstraints.Default;
        }
        return nodeConstraints;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Sets the gradient for the nodes
    NodeProperties.prototype.setGradient = function (gradient) {
        var newGradient = {};
        if (gradient) {
            if (gradient.type === 'linear') {
                newGradient = {
                    type: 'Linear',
                    x1: gradient.x1, x2: gradient.x2, y1: gradient.y1, y2: gradient.y2,
                    stops: this.getGradientStops(gradient.stops)
                };
            }
            else if (gradient.type === 'radial') {
                newGradient = {
                    type: 'Radial',
                    cx: gradient.cx, cy: gradient.cy, fx: gradient.fx, fy: gradient.fy,
                    stops: this.getGradientStops(gradient.stops)
                };
            }
        }
        return newGradient;
    };
    NodeProperties.prototype.getGradientStops = function (gradientStops) {
        var stopsCollection = [];
        for (var i = 0; i < gradientStops.length; i++) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var newStop = {};
            var stop_1 = gradientStops[parseInt(i.toString(), 10)];
            newStop.color = stop_1.color;
            newStop.offset = stop_1.offset;
            stopsCollection.push(newStop);
        }
        return stopsCollection;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Assign the BPMN shape values from the EJ1
    NodeProperties.prototype.renderBpmnShape = function (newNode, node) {
        if (node.shape === 'event') {
            newNode.shape = {
                type: 'Bpmn',
                shape: (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1),
                event: {
                    event: (node.event).charAt(0).toUpperCase() + (node.event).slice(1),
                    trigger: (node.trigger).charAt(0).toUpperCase() + (node.trigger).slice(1)
                }
            };
        }
        else if (node.shape === 'gateway') {
            newNode.shape = {
                type: 'Bpmn',
                shape: (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1),
                gateway: {
                    type: (node.gateway).charAt(0).toUpperCase() + (node.gateway).slice(1)
                }
            };
        }
        else if (node.shape === 'activity') {
            newNode.shape = {
                type: 'Bpmn',
                shape: (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1),
                activity: {
                    activity: (node.activity).charAt(0).toUpperCase() + (node.activity).slice(1)
                }
            };
            newNode.shape.activity.activity = newNode.shape.activity.activity === 'Subprocess' ? 'SubProcess' : newNode.shape.activity.activity;
            if (node.activity === 'task') {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                newNode.shape.activity.task = {
                    type: (node.task.type).charAt(0).toUpperCase() + (node.task.type).slice(1),
                    loop: (node.task.loop).charAt(0).toUpperCase() + (node.task.loop).slice(1),
                    compensation: node.task.compensation,
                    call: node.task.call
                };
            }
            if (node.activity === 'subprocess') {
                if (node.subProcess.type === 'event') {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    newNode.shape.activity.subProcess = {
                        collapsed: node.subProcess.collapsed,
                        compensation: node.subProcess.compensation,
                        adhoc: node.subProcess.adhoc,
                        loop: (node.subProcess.loop).charAt(0).toUpperCase() + (node.subProcess.loop).slice(1),
                        boundary: (node.subProcess.boundary).charAt(0).toUpperCase() + (node.subProcess.boundary).slice(1),
                        type: (node.subProcess.type).charAt(0).toUpperCase() + (node.subProcess.type).slice(1),
                        event: {
                            event: (node.subProcess.event).charAt(0).toUpperCase() + (node.subProcess.event).slice(1),
                            trigger: (node.subProcess.trigger).charAt(0).toUpperCase() + (node.subProcess.trigger).slice(1)
                        }
                    };
                }
                else if (node.subProcess.type === 'transaction') {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    newNode.shape.activity.subProcess = {
                        collapsed: node.subProcess.collapsed,
                        compensation: node.subProcess.compensation,
                        adhoc: node.subProcess.adhoc,
                        loop: (node.subProcess.loop).charAt(0).toUpperCase() + (node.subProcess.loop).slice(1),
                        boundary: (node.subProcess.boundary).charAt(0).toUpperCase() + (node.subProcess.boundary).slice(1),
                        type: (node.subProcess.type).charAt(0).toUpperCase() + (node.subProcess.type).slice(1),
                        events: this.renderEventsCollection(node.subProcess.events),
                        processes: this.renderProcessesCollection(node)
                    };
                }
            }
        }
        else if (node.shape === 'dataobject') {
            newNode.shape = {
                type: 'Bpmn',
                shape: (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1)
                // data: {
                //     type: this.getKeyByValue(node.data.type),
                //     collection: true
                // }
            };
            if (node.annotation) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                newNode.shape.annotation = {
                    text: node.annotation.text,
                    angle: node.annotation.angle,
                    width: node.annotation.width,
                    height: node.annotation.height,
                    length: node.annotation.length
                };
            }
        }
        else {
            newNode.shape = {
                type: 'Bpmn',
                shape: (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1)
            };
        }
        return newNode.shape;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Renders the swimlane from the conversion
    NodeProperties.prototype.renderSwimlaneShape = function (newNode, node) {
        newNode.shape = {
            type: 'SwimLane', orientation: (node.orientation).charAt(0).toUpperCase() + (node.orientation).slice(1),
            header: {
                annotation: { content: node.header.text },
                height: 50, style: { fontSize: node.header.fontSize, color: node.header.fontColor, fill: node.header.fillColor }
            }
        };
        var lanes = [];
        var phases = [];
        for (var i = 0; i < node.lanes.length; i++) {
            lanes[parseInt(i.toString(), 10)] = {
                header: {
                    annotation: {
                        content: node.lanes[parseInt(i.toString(), 10)].header.text,
                        width: node.lanes[parseInt(i.toString(), 10)].header.width,
                        style: {
                            fontSize: node.lanes[parseInt(i.toString(), 10)].header.fontSize,
                            color: node.lanes[parseInt(i.toString(), 10)].header.fontColor
                        }
                    }
                },
                style: { fill: node.lanes[parseInt(i.toString(), 10)].fillColor },
                children: []
            };
            for (var j = 0; j < node.lanes[parseInt(i.toString(), 10)].children.length; j++) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var childNode = this.convertToNode(node.lanes[parseInt(i.toString(), 10)].children[parseInt(j.toString(), 10)]);
                if (childNode.wrapper == null) {
                    childNode.wrapper = {
                        actualSize: { width: childNode.width, height: childNode.height },
                        offsetX: childNode.offsetX, offsetY: childNode.offsetY
                    };
                }
                lanes[parseInt(i.toString(), 10)].children.push(childNode);
            }
        }
        for (var i = 0; i < node.phases.length; i++) {
            phases[parseInt(i.toString(), 10)] = {
                header: {
                    annotation: {
                        content: node.phases[parseInt(i.toString(), 10)].label.text,
                        // eslint-disable-next-line max-len
                        style: { fill: node.phases[parseInt(i.toString(), 10)].label.fillColor, fontSize: node.phases[parseInt(i.toString(), 10)].label.fontSize, color: node.phases[parseInt(i.toString(), 10)].label.fontColor }
                    }
                },
                offset: node.phases[parseInt(i.toString(), 10)].offset,
                // eslint-disable-next-line max-len
                style: { fill: node.phases[parseInt(i.toString(), 10)].fillColor, strokeColor: node.phases[parseInt(i.toString(), 10)].lineColor, strokeDashArray: node.phases[parseInt(i.toString(), 10)].lineDashArray }
            };
        }
        newNode.shape.lanes = lanes;
        newNode.shape.phases = phases;
        return newNode.shape;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Rendered the event collections for the node properties
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    NodeProperties.prototype.renderEventsCollection = function (subProcessEvents) {
        var eventsCollection = [];
        if (subProcessEvents.length > 0) {
            for (var i = 0; i < subProcessEvents.length; i++) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var newEvent = {};
                var eventObject = subProcessEvents[parseInt(i.toString(), 10)];
                newEvent.event = (eventObject.event).charAt(0).toUpperCase() + (eventObject.event).slice(1);
                newEvent.trigger = (eventObject.trigger).charAt(0).toUpperCase() + (eventObject.trigger).slice(1);
                newEvent.offset = { x: eventObject.offset.x, y: eventObject.offset.y };
                eventsCollection.push(newEvent);
            }
        }
        return eventsCollection;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Rendered the process collections for the node properties
    NodeProperties.prototype.renderProcessesCollection = function (node) {
        var processesCollection = [];
        if (node.subProcess && node.subProcess.processes.length > 0) {
            for (var i = 0; i < node.subProcess.processes.length; i++) {
                var processObject = node.subProcess.processes[parseInt(i.toString(), 10)];
                var data = this.convertToNode(processObject);
                processesCollection.push(data);
            }
        }
        return processesCollection;
    };
    /**
     * Get module name.
     * @returns {string} Returns the module name
     */
    NodeProperties.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'NodeProperties';
    };
    return NodeProperties;
}());

var PortProperties = /** @class */ (function () {
    function PortProperties(modelProperties) {
        this.modelProperties = modelProperties;
    }
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Convert and assign EJ1 to EJ2 port properties
    PortProperties.prototype.setPortProperties = function (oldPorts) {
        var portCollection = [];
        if (oldPorts.length > 0) {
            for (var i = 0; i < oldPorts.length; i++) {
                var port = oldPorts[parseInt(i.toString(), 10)];
                var newPort = {};
                newPort.style = {};
                newPort.id = port.name;
                if (port.addInfo) {
                    newPort.addInfo = port.addInfo;
                }
                newPort.height = port.size;
                newPort.width = port.size;
                if (port.horizontalAlignment) {
                    newPort.horizontalAlignment = port.horizontalAlignment.charAt(0).toUpperCase() +
                        port.horizontalAlignment.slice(1);
                }
                if (port.verticalAlignment) {
                    newPort.verticalAlignment = port.verticalAlignment.charAt(0).toUpperCase() +
                        port.verticalAlignment.slice(1);
                }
                // 925993: Unable to load an EJ1 diagram JSON into EJ2 Diagram because of port margin undefined.
                if (port.margin) {
                    // eslint-disable-next-line max-len
                    newPort.margin = { left: port.margin.left, right: port.margin.right, top: port.margin.top, bottom: port.margin.bottom };
                }
                newPort.offset = { x: port.offset.x, y: port.offset.y };
                newPort.style.strokeColor = port.borderColor;
                newPort.style.strokeWidth = port.borderWidth;
                newPort.style.fill = port.fillColor;
                newPort.constraints = this.setPortConstraints(port.constraints);
                if (port.pathData) {
                    newPort.pathData = port.pathData;
                }
                if (port.shape === 'path') {
                    newPort.shape = 'Custom';
                }
                else {
                    // 930796: EJ1 Diagram Fails to Load in EJ2 Diagram Builder when port shape is undefined
                    if (port.shape) {
                        newPort.shape = port.shape.charAt(0).toUpperCase() + (port.shape).slice(1);
                    }
                    else {
                        newPort.shape = 'Square';
                    }
                }
                newPort.visibility = this.setPortVisibility(port.visibility);
                portCollection.push(newPort);
            }
        }
        return portCollection;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Sets the port constraints from EJ1 to EJ2
    PortProperties.prototype.setPortConstraints = function (constraints) {
        var portConstraints = PortConstraints.Default;
        // if (constraints & PortConstraints.Drag) {
        //     portConstraints = portConstraints | PortConstraints.Drag;
        // }
        if (constraints & PortConstraints.Draw) {
            portConstraints = portConstraints | PortConstraints.Draw;
        }
        if (constraints & PortConstraints.None) {
            portConstraints = PortConstraints.None;
        }
        return portConstraints;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Sets the portVisibility from EJ1 to EJ2
    PortProperties.prototype.setPortVisibility = function (visibility) {
        var portVisibility;
        if (visibility & PortVisibility.Visible) {
            portVisibility = portVisibility | PortVisibility.Visible;
        }
        if (visibility & PortVisibility.Hidden) {
            portVisibility = portVisibility | PortVisibility.Hidden;
        }
        if (visibility & PortVisibility.Hover) {
            portVisibility = portVisibility | PortVisibility.Hover;
        }
        if (visibility & PortVisibility.Connect) {
            portVisibility = portVisibility | PortVisibility.Connect;
        }
        return portVisibility;
    };
    /**
     * Get module name.
     * @returns {string} Returns the module name
     */
    PortProperties.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'PortProperties';
    };
    return PortProperties;
}());

var Ej1Serialization = /** @class */ (function () {
    function Ej1Serialization(diagram) {
        this.labelProperties = new LabelProperties(this);
        this.connectorProperties = new ConnectorProperties(this.labelProperties);
        this.portProperties = new PortProperties(this);
        this.nodeProperties = new NodeProperties(this.labelProperties, this.portProperties);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.convertedData = {};
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.items = [];
        this.diagram = diagram;
    }
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Getting the object data from the load diagram and serialize it into from EJ1 to EJ2
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Ej1Serialization.prototype.getSerializedData = function (data) {
        this.convertedData.mode = 'SVG';
        this.convertedData.basicElements = [];
        this.convertedData.width = data.width;
        this.convertedData.height = data.height;
        if (data.nodes && data.nodes.length > 0) {
            this.nodeProperties.renderNodesCollection(this.convertedData, data);
        }
        else {
            this.convertedData.nodes = data.nodes;
        }
        if (data.connectors && data.connectors.length > 0) {
            this.connectorProperties.renderConnectorsCollection(this.convertedData, data);
        }
        else {
            this.convertedData.connectors = data.connectors;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (data.defaultSettings !== undefined) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.convertedData.getNodeDefaults = this.getNodeDefaults(data.defaultSettings.node);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.convertedData.getConnectorDefaults = this.getConnectorDefaults(data.defaultSettings.connector);
        }
        //this.convertedData.setNodeTemplate = this.getNodeTemplate((data as Diagram).nodeTemplate);
        this.setLayers(this.convertedData, data);
        this.setDataSourceSettings(this.convertedData, data);
        this.setRulerSettings(this.convertedData, data);
        this.setSnapSettings(this.convertedData, data);
        if (data.snapSettings.enableSnapToObject) {
            this.convertedData.snapSettings.constraints = this.convertedData.snapSettings.constraints | SnapConstraints.SnapToObject;
        }
        else {
            this.convertedData.snapSettings.constraints = this.convertedData.snapSettings.constraints & ~SnapConstraints.SnapToObject;
        }
        if (data.pageSettings.backgroundImage === undefined) {
            data.pageSettings.pageBackgroundColor = 'transparent';
            data.pageSettings.backgroundImage = {
                source: '',
                scale: 'meet',
                alignment: 'xmidymid'
            };
            data.pageSettings.showPageBreak = false;
        }
        this.setScrollSettings(this.convertedData, data);
        this.setPageSettings(this.convertedData, data);
        this.setContextMenu(this.convertedData, data);
        this.setTooltip(this.convertedData, data);
        this.setModelLayout(this.convertedData, data);
        this.setSelectedItems(this.convertedData, data);
        this.convertedData.constraints = this.setDiagramConstraints(data.constraints);
        this.convertedData.tool = this.setDiagramTool(data.tool);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.convertedData.drawType = data.drawType;
        this.convertedData.commandManager = data.commandManager;
        return this.convertedData;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //declare the node default properties
    Ej1Serialization.prototype.getNodeDefaults = function (node) {
        if (node) {
            return this.nodeProperties.convertToNode(node);
        }
        else {
            return null;
        }
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //declare the node default properties
    Ej1Serialization.prototype.getConnectorDefaults = function (connector) {
        if (connector) {
            return this.connectorProperties.convertToConnector(connector);
        }
        else {
            return null;
        }
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update the layers from the EJ1 JSON
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Ej1Serialization.prototype.setLayers = function (convertedData, data) {
        convertedData.layers = [];
        if (data.layers.length > 0) {
            for (var i = 0; i < data.layers.length; i++) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var newLayer = {};
                var layer = data.layers[parseInt(i.toString(), 10)];
                newLayer.id = layer.name;
                newLayer.visible = layer.visible;
                newLayer.lock = layer.lock;
                newLayer.objects = layer.objects;
                convertedData.layers.push(newLayer);
            }
        }
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update the dataSourceSettings from EJ1 to EJ2
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Ej1Serialization.prototype.setDataSourceSettings = function (convertedData, data) {
        convertedData.dataSourceSettings = {};
        convertedData.dataSourceSettings.id = data.dataSourceSettings.id;
        convertedData.dataSourceSettings.dataManager = data.dataSourceSettings.dataSource;
        convertedData.dataSourceSettings.root = data.dataSourceSettings.root;
        convertedData.dataSourceSettings.parentId = data.dataSourceSettings.parent;
        convertedData.dataSourceSettings.crudAction = {
            read: data.dataSourceSettings.crudAction.read,
            create: data.dataSourceSettings.crudAction.create,
            update: data.dataSourceSettings.crudAction.update,
            destroy: data.dataSourceSettings.crudAction.destroy,
            customFields: data.dataSourceSettings.customFields
        };
        if (data.dataSourceSettings.connectionDataSource) {
            convertedData.dataSourceSettings.connectionDataSource = {};
            convertedData.dataSourceSettings.connectionDataSource.id = data.dataSourceSettings.connectionDataSource.id;
            convertedData.dataSourceSettings.connectionDataSource.dataManager = data.dataSourceSettings.connectionDataSource.dataSource;
            convertedData.dataSourceSettings.connectionDataSource.sourceID = data.dataSourceSettings.connectionDataSource.sourceNode;
            convertedData.dataSourceSettings.connectionDataSource.targetID = data.dataSourceSettings.connectionDataSource.targetNode;
            convertedData.dataSourceSettings.connectionDataSource.sourcePointX = data.dataSourceSettings.connectionDataSource.sourcePointX;
            convertedData.dataSourceSettings.connectionDataSource.sourcePointY = data.dataSourceSettings.connectionDataSource.sourcePointY;
            convertedData.dataSourceSettings.connectionDataSource.targetPointX = data.dataSourceSettings.connectionDataSource.targetPointX;
            convertedData.dataSourceSettings.connectionDataSource.targetPointY = data.dataSourceSettings.connectionDataSource.targetPointY;
            convertedData.dataSourceSettings.connectionDataSource.crudAction = {
                read: data.dataSourceSettings.connectionDataSource.crudAction.read,
                create: data.dataSourceSettings.connectionDataSource.crudAction.create,
                update: data.dataSourceSettings.connectionDataSource.crudAction.update,
                destroy: data.dataSourceSettings.connectionDataSource.crudAction.destroy,
                customFields: data.dataSourceSettings.connectionDataSource.customFields
            };
        }
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update the ruler settings
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Ej1Serialization.prototype.setRulerSettings = function (convertedData, data) {
        convertedData.rulerSettings = {};
        convertedData.rulerSettings.showRulers = data.rulerSettings.showRulers;
        convertedData.rulerSettings.horizontalRuler = this.setRulerProperties(data.rulerSettings.horizontalRuler);
        convertedData.rulerSettings.verticalRuler = this.setRulerProperties(data.rulerSettings.verticalRuler);
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update the orientation of the ruler
    Ej1Serialization.prototype.setRulerProperties = function (ruler) {
        var rulerProperties = {};
        rulerProperties.interval = ruler.interval;
        rulerProperties.segmentWidth = ruler.segmentWidth;
        // rulerProperties.tickAlignment = ruler.tickAlignment === 'rightorbottom' ? 'RightOrBottom' : 'LeftOrTop';
        rulerProperties.markerColor = ruler.markerColor;
        rulerProperties.thickness = ruler.thickness;
        rulerProperties.arrangeTick = ruler.arrangeTick;
        return rulerProperties;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update the snap settings
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Ej1Serialization.prototype.setSnapSettings = function (convertedData, data) {
        convertedData.snapSettings = {};
        if (data.snapSettings) {
            convertedData.snapSettings.horizontalGridLines = this.setGridLines(data.snapSettings.horizontalGridLines);
            convertedData.snapSettings.verticalGridLines = this.setGridLines(data.snapSettings.verticalGridLines);
            convertedData.snapSettings.snapAngle = data.snapSettings.snapAngle;
            convertedData.snapSettings.snapObjectDistance = data.snapSettings.snapObjectDistance;
            convertedData.snapSettings.constraints = this.setSnapConstraints(data.snapSettings.snapConstraints);
        }
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update the snap constraints from EJ1 to EJ2
    Ej1Serialization.prototype.setSnapConstraints = function (constraints) {
        var snapConstraints = SnapConstraints.None;
        if (constraints & SnapConstraints.ShowHorizontalLines) {
            snapConstraints = snapConstraints | SnapConstraints.ShowHorizontalLines;
        }
        if (constraints & SnapConstraints.ShowVerticalLines) {
            snapConstraints = snapConstraints | SnapConstraints.ShowVerticalLines;
        }
        if (constraints & SnapConstraints.ShowLines) {
            snapConstraints = snapConstraints | SnapConstraints.ShowLines;
        }
        if (constraints & SnapConstraints.SnapToHorizontalLines) {
            snapConstraints = snapConstraints | SnapConstraints.SnapToHorizontalLines;
        }
        if (constraints & SnapConstraints.SnapToVerticalLines) {
            snapConstraints = snapConstraints | SnapConstraints.SnapToVerticalLines;
        }
        if (constraints & SnapConstraints.SnapToLines) {
            snapConstraints = snapConstraints | SnapConstraints.SnapToLines;
        }
        return snapConstraints;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update the gridlines
    Ej1Serialization.prototype.setGridLines = function (gridlines) {
        var gridLinesProperties = {};
        gridLinesProperties.lineColor = gridlines.lineColor;
        gridLinesProperties.lineDashArray = gridlines.lineDashArray;
        gridLinesProperties.lineIntervals = gridlines.lineInterval;
        gridLinesProperties.snapIntervals = gridlines.snapInterval;
        return gridLinesProperties;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update the scroll-settings
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Ej1Serialization.prototype.setScrollSettings = function (convertedData, data) {
        convertedData.scrollSettings = {
            horizontalOffset: data.scrollSettings.horizontalOffset,
            verticalOffset: data.scrollSettings.verticalOffset,
            currentZoom: data.scrollSettings.currentZoom,
            viewPortWidth: data.scrollSettings.viewPortWidth,
            viewPortHeight: data.scrollSettings.viewPortHeight,
            minZoom: data.scrollSettings.minZoom,
            maxZoom: data.scrollSettings.maxZoom,
            scrollLimit: (data.pageSettings.scrollLimit).charAt(0).toUpperCase() + (data.pageSettings.scrollLimit).slice(1),
            scrollableArea: data.pageSettings.scrollableArea,
            canAutoScroll: data.enableAutoScroll,
            autoScrollBorder: data.pageSettings.autoScrollBorder
        };
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update the page settings
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Ej1Serialization.prototype.setPageSettings = function (convertedData, data) {
        convertedData.pageSettings = {
            width: data.pageSettings.pageWidth,
            height: data.pageSettings.pageHeight,
            // eslint-disable-next-line max-len
            margin: { left: data.pageSettings.pageMargin, right: data.pageSettings.pageMargin, top: data.pageSettings.pageMargin, bottom: data.pageSettings.pageMargin },
            orientation: (data.pageSettings.pageOrientation).charAt(0).toUpperCase() + (data.pageSettings.pageOrientation).slice(1),
            // eslint-disable-next-line max-len
            boundaryConstraints: (data.pageSettings.boundaryConstraints).charAt(0).toUpperCase() + (data.pageSettings.boundaryConstraints).slice(1),
            // eslint-disable-next-line max-len
            background: { color: data.pageSettings.pageBackgroundColor, source: data.backgroundImage.source, scale: data.backgroundImage.scale, align: data.backgroundImage.align },
            multiplePage: data.pageSettings.multiplePage,
            showPageBreaks: data.pageSettings.showPageBreak
        };
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Sets the contextmenu settings
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Ej1Serialization.prototype.setContextMenu = function (convertedData, data) {
        convertedData.contextMenuSettings = {};
        convertedData.contextMenuSettings.show = data.enableContextMenu;
        if (data.contextMenu !== undefined) {
            convertedData.contextMenuSettings.showCustomMenuOnly = data.contextMenu.showCustomMenuItemsOnly;
            convertedData.contextMenuSettings.items = this.getContextMenuItems(data.contextMenu.items);
        }
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update the contextmenu items
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Ej1Serialization.prototype.getContextMenuItems = function (contextMenuItems) {
        var menuItem = {};
        for (var i = 0; i < contextMenuItems.length; i++) {
            var oldMenuItem = contextMenuItems[parseInt(i.toString(), 10)];
            menuItem.id = oldMenuItem.name;
            menuItem.text = oldMenuItem.text;
            this.items.push(menuItem);
            if (contextMenuItems.subItems && contextMenuItems.subItems.length > 0) {
                this.getContextMenuItems(contextMenuItems.subItems);
            }
        }
        return this.items;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update the tooltip items
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Ej1Serialization.prototype.setTooltip = function (convertedData, data) {
        convertedData.tooltip = {
            content: data.tooltip.templateId,
            relativeMode: data.tooltip.relativeMode
        };
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Sets the model layout for the converted data
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Ej1Serialization.prototype.setModelLayout = function (convertedData, data) {
        convertedData.layout = {
            fixedNode: data.layout.fixedNode,
            horizontalSpacing: data.layout.horizontalSpacing,
            verticalSpacing: data.layout.verticalSpacing,
            maxIteration: data.layout.maxIteration,
            springFactor: data.layout.springFactor,
            springLength: data.layout.springLength,
            // eslint-disable-next-line max-len
            margin: { left: data.layout.margin.left, right: data.layout.margin.right, top: data.layout.margin.top, bottom: data.layout.margin.bottom },
            horizontalAlignment: (data.layout.horizontalAlignment).charAt(0).toUpperCase() + (data.layout.horizontalAlignment).slice(1),
            verticalAlignment: (data.layout.verticalAlignment).charAt(0).toUpperCase() + (data.layout.verticalAlignment).slice(1),
            orientation: data.layout.orientation === 'toptobottom' ? 'TopToBottom' : data.layout.orientation === 'bottomtotop' ? 'BottomToTop' : data.layout.orientation === 'righttoleft' ? 'RightToLeft' : 'LeftToRight',
            connectorSegments: data.layout.getConnectorSegments,
            type: (data.layout.type).charAt(0).toUpperCase() + (data.layout.type).slice(1),
            getLayoutInfo: data.layout.getLayoutInfo,
            bounds: data.layout.bounds,
            root: data.layout.root
        };
        if (convertedData.layout && convertedData.layout.type === 'Hierarchicaltree') {
            convertedData.layout.type = 'HierarchicalTree';
        }
        else if (convertedData.layout && convertedData.layout.type === 'Organizationalchart') {
            convertedData.layout.type = 'OrganizationalChart';
        }
        else if (convertedData.layout && convertedData.layout.type === 'Radialtree') {
            convertedData.layout.type = 'RadialTree';
        }
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Sets the selected items to convert the data
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Ej1Serialization.prototype.setSelectedItems = function (convertedData, data) {
        convertedData.selectedItems = {};
        var nodes = [];
        var connectors = [];
        convertedData.selectedItems.nodes = nodes;
        convertedData.selectedItems.connectors = connectors;
        convertedData.selectedItems.offsetX = data.selectedItems.offsetX;
        convertedData.selectedItems.offsetY = data.selectedItems.offsetY;
        convertedData.selectedItems.width = data.selectedItems.width;
        convertedData.selectedItems.height = data.selectedItems.height;
        convertedData.selectedItems.rotateAngle = data.selectedItems.rotateAngle;
        convertedData.selectedItems.constraints = this.setSelectorConstraints(data.selectedItems.constraints);
        convertedData.selectedItems.userHandles = data.selectedItems.userHandles;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update the selector constraints from EJ1 to EJ2
    Ej1Serialization.prototype.setSelectorConstraints = function (constraints) {
        var selectorConstraints = SelectorConstraints.None;
        if (constraints & SelectorConstraints.ConnectorSourceThumb) {
            selectorConstraints = selectorConstraints | SelectorConstraints.Rotate;
        }
        if (constraints & SelectorConstraints.ResizeAll) {
            selectorConstraints = selectorConstraints | SelectorConstraints.ResizeAll;
        }
        if (constraints & SelectorConstraints.ResizeSouthEast) {
            selectorConstraints = selectorConstraints | SelectorConstraints.UserHandle;
        }
        if (constraints & SelectorConstraints.ToolTip) {
            selectorConstraints = selectorConstraints | SelectorConstraints.ToolTip;
        }
        if (constraints & SelectorConstraints.All) {
            selectorConstraints = selectorConstraints | SelectorConstraints.All;
        }
        return selectorConstraints;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update the diagram constraints from EJ1 to EJ2
    Ej1Serialization.prototype.setDiagramConstraints = function (constraints) {
        var diagramConstraints = DiagramConstraints.None;
        if (constraints & DiagramConstraints.UserInteraction) {
            diagramConstraints = diagramConstraints | DiagramConstraints.UserInteraction;
        }
        if (constraints & DiagramConstraints.ApiUpdate) {
            diagramConstraints = diagramConstraints | DiagramConstraints.ApiUpdate;
        }
        if (constraints & DiagramConstraints.PageEditable) {
            diagramConstraints = diagramConstraints | DiagramConstraints.PageEditable;
        }
        if (constraints & DiagramConstraints.LineRouting) {
            diagramConstraints = diagramConstraints | DiagramConstraints.Bridging;
        }
        if (constraints & DiagramConstraints.Zoom) {
            diagramConstraints = diagramConstraints | DiagramConstraints.Zoom;
        }
        if (constraints & DiagramConstraints.PanX) {
            diagramConstraints = diagramConstraints | DiagramConstraints.PanX;
        }
        if (constraints & DiagramConstraints.PanY) {
            diagramConstraints = diagramConstraints | DiagramConstraints.PanY;
        }
        if (constraints & DiagramConstraints.Pan) {
            diagramConstraints = diagramConstraints | DiagramConstraints.Pan;
        }
        if (constraints & DiagramConstraints.UndoRedo) {
            diagramConstraints = diagramConstraints | DiagramConstraints.UndoRedo;
        }
        if (constraints & DiagramConstraints.ZoomTextEdit) {
            diagramConstraints = diagramConstraints | DiagramConstraints.ZoomTextEdit;
        }
        return diagramConstraints;
    };
    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram
    //Update the diagram tool from EJ1 to EJ2
    Ej1Serialization.prototype.setDiagramTool = function (tool) {
        var diagramTool = DiagramTools.None;
        if (tool & DiagramTools.MultipleSelect) {
            diagramTool = diagramTool | DiagramTools.SingleSelect;
        }
        if (tool & DiagramTools.ZoomPan) {
            diagramTool = diagramTool | DiagramTools.MultipleSelect;
        }
        if (tool & DiagramTools.DrawOnce) {
            diagramTool = diagramTool | DiagramTools.ZoomPan;
        }
        if (tool & DiagramTools.ContinuousDraw) {
            diagramTool = diagramTool | DiagramTools.DrawOnce;
        }
        if (tool & DiagramTools.ContinuousDraw) {
            diagramTool = diagramTool | DiagramTools.ContinuousDraw;
        }
        return diagramTool;
    };
    //     /* tslint:disable */
    // /**
    //  * To provide the array of modules needed for control rendering
    //  *
    //  * @returns {ModuleDeclaration[]} To provide the array of modules needed for control rendering .\
    //  * @private
    //  */
    //  public requiredModules(): ModuleDeclaration[] {
    //     const modules: ModuleDeclaration[] = [];
    //     modules.push({
    //         member: 'NodeProperties',
    //         args: []
    //     });
    //  return modules;
    //  }
    /**
     * To destroy the ruler
     *
     * @returns {void} To destroy the ruler
     */
    Ej1Serialization.prototype.destroy = function () {
        /**
         * Destroys the Print and Export module
         */
    };
    /**
     * Get module name.
     *
     * @returns {string} Returns the module name
     */
    Ej1Serialization.prototype.getModuleName = function () {
        /**
         * Returns the module name
         */
        return 'Ej1Serialization';
    };
    return Ej1Serialization;
}());

var __extends$C = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
// eslint-disable-next-line
var getObjectType$1 = function (obj) {
    var conn = obj;
    if (conn.sourcePoint || conn.targetPoint || conn.sourceID || conn.targetID
        || conn.sourcePortID || conn.targetPortID || conn.sourceDecorator || conn.targetDecorator) {
        return Connector;
    }
    if (obj.shape && (obj.shape instanceof Shape || obj.shape.type)) {
        return Node;
    }
    return Node;
};
/**
 * A palette allows to display a group of related symbols and it textually annotates the group with its header.
 */
var Palette = /** @class */ (function (_super) {
    __extends$C(Palette, _super);
    // eslint-disable-next-line
    function Palette(parent, propName, defaultValue, isArray) {
        return _super.call(this, parent, propName, defaultValue, isArray) || this;
    }
    __decorate$r([
        Property('')
    ], Palette.prototype, "id", void 0);
    __decorate$r([
        Property()
    ], Palette.prototype, "height", void 0);
    __decorate$r([
        Property(true)
    ], Palette.prototype, "expanded", void 0);
    __decorate$r([
        Property('')
    ], Palette.prototype, "iconCss", void 0);
    __decorate$r([
        Property('')
    ], Palette.prototype, "title", void 0);
    __decorate$r([
        CollectionFactory(getObjectType$1)
    ], Palette.prototype, "symbols", void 0);
    return Palette;
}(ChildProperty));
/**
 * customize the drag size of the individual palette items.
 */
var SymbolDragSize = /** @class */ (function (_super) {
    __extends$C(SymbolDragSize, _super);
    function SymbolDragSize() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$r([
        Property()
    ], SymbolDragSize.prototype, "width", void 0);
    __decorate$r([
        Property()
    ], SymbolDragSize.prototype, "height", void 0);
    return SymbolDragSize;
}(ChildProperty));
/**
 * customize the preview size and position of the individual palette items.
 */
var SymbolPreview = /** @class */ (function (_super) {
    __extends$C(SymbolPreview, _super);
    function SymbolPreview() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$r([
        Property()
    ], SymbolPreview.prototype, "width", void 0);
    __decorate$r([
        Property()
    ], SymbolPreview.prototype, "height", void 0);
    __decorate$r([
        Complex({}, Point)
    ], SymbolPreview.prototype, "offset", void 0);
    return SymbolPreview;
}(ChildProperty));
/**
 * Represents the Symbol Palette Component.
 * ```html
 * <div id="symbolpalette"></div>
 * <script>
 *  var palette = new SymbolPalatte({ allowDrag:true });
 *  palette.appendTo("#symbolpalette");
 * </script>
 * ```
 */
/**
 * The symbol palette control allows to predefine the frequently used nodes and connectors
 * and to drag and drop those nodes/connectors to drawing area
 */
var SymbolPalette = /** @class */ (function (_super) {
    __extends$C(SymbolPalette, _super);
    //region - protected methods
    /**
     *  Constructor for creating the symbol palette Component
     *
     * @param {SymbolPaletteModel} options The symbol palette model.
     * @param {string | HTMLElement} element The symbol palette element.
     */
    function SymbolPalette(options, element) {
        var _this = _super.call(this, options, element) || this;
        /**   @private  */
        _this.symbolTable = {};
        /**   @private  */
        _this.childTable = {};
        _this.info = 'info';
        _this.oldObject = null;
        _this.laneTable = {};
        _this.isExpand = false;
        _this.isExpandMode = false;
        _this.isMethod = false;
        _this.paletteid = 88123;
        _this.checkOnRender = false;
        _this.symbolTooltipObject = null;
        // eslint-disable
        _this.helper = function (e) {
            var clonedElement;
            var id = (_this.selectedSymbol && _this.selectedSymbol.id) || e.sender.target.id.split('_container')[0];
            var symbol = _this.symbolTable["" + id];
            if (symbol && _this.selectedSymbol) {
                _this.selectedSymbols = _this.selectedSymbol.id === symbol.id ? symbol : _this.selectedSymbol;
                //const position: PointModel = this.getMousePosition(e.sender);
                clonedElement = _this.getSymbolPreview(_this.selectedSymbols, e.sender, _this.element);
                clonedElement.setAttribute('paletteId', _this.element.id);
            }
            return clonedElement;
        };
        var child;
        var node;
        for (var i = 0; _this && _this.palettes && i < _this.palettes.length; i++) {
            for (var j = 0; j < _this.palettes[parseInt(i.toString(), 10)].symbols.length; j++) {
                child = _this.palettes[parseInt(i.toString(), 10)].symbols[parseInt(j.toString(), 10)];
                node = options.palettes[parseInt(i.toString(), 10)].symbols[parseInt(j.toString(), 10)];
                if (child && child.shape.type === 'UmlActivity') {
                    setUMLActivityDefaults(node, child);
                }
                if (_this.nodeDefaults || _this.connectorDefaults) {
                    updateDefaultValues(child, node, child instanceof Node ? _this.nodeDefaults : _this.connectorDefaults);
                }
            }
        }
        return _this;
    }
    /**
     * Refreshes the panel when the symbol palette properties are updated\
     *
     * @returns {  void}    Refreshes the panel when the symbol palette properties are updated .\
     * @param {SymbolPaletteModel} newProp - Defines the new values of the changed properties.
     * @param {SymbolPaletteModel} oldProp - Defines the old values of the changed properties.
     */
    // eslint-disable-next-line
    SymbolPalette.prototype.onPropertyChanged = function (newProp, oldProp) {
        var refresh = false;
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'width':
                    this.element.style.width = this.width.toString();
                    break;
                case 'height':
                    this.element.style.height = this.height.toString();
                    break;
                case 'symbolPreview':
                    break;
                case 'symbolWidth':
                case 'symbolHeight':
                case 'getSymbolInfo':
                    if (this.isReact) {
                        refresh = false;
                    }
                    else {
                        refresh = true;
                    }
                    break;
                case 'enableSearch':
                    if (newProp.enableSearch && !isBlazor()) {
                        this.createTextbox();
                    }
                    else {
                        var divElement = document.getElementById(this.element.id + '_search');
                        if (divElement) {
                            divElement.parentNode.removeChild(divElement);
                        }
                    }
                    break;
                case 'palettes':
                    for (var _b = 0, _c = Object.keys(newProp.palettes); _b < _c.length; _b++) {
                        var i = _c[_b];
                        var index = Number(i);
                        if (!isBlazor() && !this.accordionElement.items[parseInt(index.toString(), 10)]) {
                            this.accordionElement.items[parseInt(index.toString(), 10)] = {
                                header: newProp.palettes[parseInt(index.toString(), 10)].title || '',
                                expanded: newProp.palettes[parseInt(index.toString(), 10)].expanded,
                                iconCss: newProp.palettes[parseInt(index.toString(), 10)].iconCss || ''
                            };
                        }
                        if (newProp.palettes[parseInt(index.toString(), 10)].height) {
                            var paletteDiv = document.getElementById(this.palettes[parseInt(index.toString(), 10)].id + '_content');
                            paletteDiv.style.height = newProp.palettes[parseInt(index.toString(), 10)].height + 'px';
                        }
                        if (newProp.palettes[parseInt(index.toString(), 10)].iconCss !== undefined) {
                            if (!isBlazor()) {
                                this.accordionElement.items[parseInt(index.toString(), 10)].iconCss = newProp.palettes[parseInt(index.toString(), 10)].iconCss || '';
                                refresh = true;
                            }
                        }
                        if (newProp.palettes[parseInt(index.toString(), 10)].expanded !== undefined && !isBlazor()) {
                            if (!this.palettes[parseInt(index.toString(), 10)].isInteraction) {
                                this.accordionElement.items[parseInt(index.toString(), 10)].expanded
                                    = newProp.palettes[parseInt(index.toString(), 10)].expanded;
                                this.isExpand = true;
                            }
                            else {
                                this.palettes[parseInt(index.toString(), 10)].isInteraction = false;
                            }
                            if (!this.isExpandMode && !this.isMethod && !this.isExpand) {
                                this.isExpand = true;
                            }
                        }
                    }
                    break;
                case 'enableAnimation':
                    if (!isBlazor()) {
                        if (!this.enableAnimation) {
                            this.accordionElement.animation = { expand: { duration: 0 }, collapse: { duration: 0 } };
                        }
                        else {
                            this.accordionElement.animation = { expand: { duration: 400 }, collapse: { duration: 400 } };
                        }
                    }
                    break;
                case 'expandMode':
                    if (!isBlazor()) {
                        this.accordionElement.expandMode = this.expandMode;
                        refresh = true;
                        this.isExpandMode = true;
                    }
                    break;
                case 'allowDrag':
                    this.allowDrag = newProp.allowDrag;
                    if (!this.allowDrag) {
                        this.draggable.helper = function () {
                            return null;
                        };
                    }
                    else {
                        this.initDraggable();
                        this.draggable.helper = this.helper;
                    }
                    break;
            }
        }
        if (refresh) {
            this.refreshPalettes();
        }
        if (this.isExpand && !refresh) {
            this.refresh();
            this.isExpand = false;
            for (var p = 0; p < this.palettes.length; p++) {
                var paletteElement = this.palettes[parseInt(p.toString(), 10)].id;
                if (window["" + paletteElement]) {
                    if (window["" + paletteElement].length > 1) {
                        window["" + paletteElement][1].parentNode.removeChild(window["" + paletteElement][1]);
                        window["" + paletteElement][1] = null;
                    }
                }
            }
        }
        this.isMethod = false;
    };
    /**
     * updateBlazorProperties method\
     *
     * @returns {void}    updateBlazorProperties method .\
     * @param {SymbolPaletteModel} newProp - provide the scale value.
     *
     * @private
     */
    // public updateBlazorProperties(newProp: SymbolPaletteModel): void {
    //     const blazorInterop: string = 'sfBlazor';
    //     const blazor: string = 'Blazor';
    //     if (window && window[`${blazor}`]) {
    //         const palObj: object = { palette: newProp.palettes };
    //         const obj: object = { 'methodName': 'UpdateBlazorProperties', 'paletteobj': palObj };
    //         window[`${blazorInterop}`].updateBlazorProperties(obj, this);
    //     }
    // }
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @returns {string}  Get the properties to be maintained in the persisted state.
     */
    SymbolPalette.prototype.getPersistData = function () {
        var keyEntity = ['loaded'];
        return this.addOnPersist(keyEntity);
    };
    /**
     * Initializes the values of private members.
     *
     * @returns {void}  Initializes the values of private members.
     * @private
     */
    SymbolPalette.prototype.preRender = function () {
        var _this = this;
        this.l10n = new L10n(this.getModuleName(), this.defaultLocale(), this.locale);
        if (this.element.id === '') {
            var collection = document.getElementsByClassName('e-symbolpalette').length;
            this.element.id = 'symbolpalette_' + this.paletteid + '_' + collection;
        }
        this.element.style.overflow = 'auto';
        this.element.style.height = this.height.toString();
        this.element.style.width = this.width.toString();
        if (this.enableSearch && !isBlazor()) {
            this.createTextbox();
        }
        //create accordion element
        if (!isBlazor()) {
            var accordionDiv = createHtmlElement('div', { id: this.element.id + '_container' });
            this.accordionElement = new Accordion({
                expandMode: this.expandMode
            });
            if (!this.enableAnimation) {
                this.accordionElement.animation = { expand: { duration: 0 }, collapse: { duration: 0 } };
            }
            this.accordionElement.created = function () {
                _this.checkOnRender = true;
            };
            this.accordionElement.expanded = function (args) {
                var index = _this.accordionElement.items.indexOf(args.item);
                var isAllowDatabind = _this.allowServerDataBinding;
                _this.allowServerDataBinding = false;
                _this.palettes[parseInt(index.toString(), 10)].expanded = args.isExpanded;
                _this.palettes[parseInt(index.toString(), 10)].isInteraction = true;
                _this.allowServerDataBinding = isAllowDatabind;
            };
            this.accordionElement.expanding = function (args) {
                if (_this.checkOnRender) {
                    // eslint-disable-next-line
                    var diagramArgs = {
                        element: args.element, content: args.content, index: args.index, cancel: false,
                        isExpanded: args.isExpanded, palette: _this.palettes[args.index]
                    };
                    var event_1 = 'paletteExpanding';
                    _this.trigger(event_1, diagramArgs);
                    args.cancel = diagramArgs.cancel;
                }
            };
            this.element.appendChild(accordionDiv);
        }
        var measureWindowElement = 'measureElement';
        if (window["" + measureWindowElement]) {
            window["" + measureWindowElement] = null;
        }
        createMeasureElements();
        this.unWireEvents();
        this.wireEvents();
    };
    /**
     * EJ2-61531- Localization support for the symbol palette search box placeholder.
     * @returns {Object} defaultLocale
     */
    SymbolPalette.prototype.defaultLocale = function () {
        return { SearchShapes: 'Search Shapes' };
    };
    /**
     * Renders the rulers.
     *
     * @returns {void}  Renders the rulers.
     * @private
     */
    SymbolPalette.prototype.render = function () {
        this.diagramRenderer = new DiagramRenderer(this.element.id, new SvgRenderer(), false);
        this.svgRenderer = new DiagramRenderer(this.element.id, new SvgRenderer(), true);
        this.updatePalettes();
        if (!isBlazor()) {
            this.accordionElement.appendTo('#' + this.element.id + '_container');
        }
        this.renderComplete();
    };
    /**
     * Core method to return the component name.
     *
     * @returns {string}  Core method to return the component name.
     * @private
     */
    SymbolPalette.prototype.getModuleName = function () {
        return 'SymbolPalette';
    };
    /**
     * To provide the array of modules needed for control rendering.
     *
     * @returns {ModuleDeclaration[]}  To provide the array of modules needed for control rendering .
     * @private
     */
    SymbolPalette.prototype.requiredModules = function () {
        var modules = [];
        modules.push({
            member: 'Bpmn',
            args: []
        });
        return modules;
    };
    /**
     *To destroy the ruler
     *
     * @returns {void} To destroy the ruler
     */
    SymbolPalette.prototype.destroy = function () {
        if (this.allowDrag) {
            this.draggable.destroy();
            this.unWireEvents();
            this.notify('destroy', {});
            _super.prototype.destroy.call(this);
            var content = document.getElementById(this.element.id + '_container');
            if (content) {
                this.element.removeChild(content);
                var measureElemnt = 'measureElement';
                if (window["" + measureElemnt]) {
                    window["" + measureElemnt].usageCount -= 1;
                    var measureElementCount = 'measureElementCount';
                    window["" + measureElementCount]--;
                    if (window["" + measureElementCount] === 0) {
                        window["" + measureElemnt].parentNode.removeChild(window["" + measureElemnt]);
                        window["" + measureElemnt] = null;
                    }
                }
            }
            content = document.getElementById(this.element.id + '_search');
            if (content) {
                content.parentNode.removeChild(content);
            }
        }
    };
    /**
     * Add particular palettes to symbol palette at runtime.\
     *
     * @returns {  void}    Refreshes the ruler when the Ruler properties are updated .\
     * @param { PaletteModel[]} palettes -Defines the collection of palettes to be added.
     */
    SymbolPalette.prototype.addPalettes = function (palettes) {
        var palette;
        for (var i = 0; i < palettes.length; i++) {
            var isEnableServerDatabind = this.allowServerDataBinding;
            this.isProtectedOnChange = true;
            this.allowServerDataBinding = false;
            palette = new Palette(this, 'palettes', palettes[parseInt(i.toString(), 10)], true);
            this.palettes.push(palette);
            this.initSymbols(palette);
            this.allowServerDataBinding = isEnableServerDatabind;
            this.isProtectedOnChange = false;
            this.renderPalette(palette);
        }
        this.bulkChanges = {};
        if (!isBlazor()) {
            this.accordionElement.refresh();
        }
    };
    /**
     * removePalette method\
     *
     * @returns {void}    removePalette method .\
     * @param {string} paletteId - provide the scale value.
     *
     * @private
     */
    SymbolPalette.prototype.removePalette = function (paletteId) {
        for (var i = 0; i < this.palettes.length; i++) {
            if (this.palettes[parseInt(i.toString(), 10)].id === paletteId) {
                this.palettes.splice(i, 1);
                if (!isBlazor()) {
                    this.accordionElement.items.splice(i, 1);
                }
                break;
            }
        }
    };
    /**
     * Remove particular palettes to symbol palette at runtime \
     *
     * @returns {void}   Remove particular palettes to symbol palette at runtime .\
     * @param {string[]} palettes - provide the scale value.
     */
    SymbolPalette.prototype.removePalettes = function (palettes) {
        var isEnableServerDatabind = this.allowServerDataBinding;
        this.allowServerDataBinding = false;
        for (var i = 0; i < palettes.length; i++) {
            this.removePalette(palettes[parseInt(i.toString(), 10)]);
        }
        if (!isBlazor()) {
            this.accordionElement.refresh();
        }
        else {
            this.updatePalettes();
        }
        this.allowServerDataBinding = isEnableServerDatabind;
    };
    //end region - protected methods
    //region - private methods to render symbols
    /**
     * Method to initialize the items in the symbols \
     *
     * @returns {void}    Method to initialize the items in the symbols .\
     * @param {PaletteModel} symbolGroup - provide the scale value.
     *
     */
    SymbolPalette.prototype.initSymbols = function (symbolGroup) {
        var group = [];
        var laneHeight = 0;
        var laneWidth = 0;
        for (var _i = 0, _a = symbolGroup.symbols; _i < _a.length; _i++) {
            var symbol = _a[_i];
            if (symbol.shape.type === 'SwimLane') {
                var swimLaneObj = symbol;
                var swimLaneShape = symbol.shape;
                var isHorizontal = (swimLaneShape.orientation === 'Horizontal') ? true : false;
                if (swimLaneShape.isLane) {
                    laneHeight = isHorizontal ? this.symbolHeight - this.symbolHeight / 2 : this.symbolHeight - this.symbolHeight / 4;
                    laneWidth = isHorizontal ? this.symbolWidth - this.symbolWidth / 4 : this.symbolWidth - this.symbolWidth / 2;
                    this.laneTable[symbol.id] = { height: laneHeight, width: laneWidth };
                    var header = swimLaneShape.lanes[0].header;
                    var laneStyle = swimLaneShape.lanes[0].style;
                    var headerStyle = header.style;
                    var headerObj = {
                        id: 'header' + randomId(), shape: { type: 'Basic', shape: 'Rectangle' },
                        width: isHorizontal ? header.width : swimLaneObj.width,
                        height: isHorizontal ? swimLaneObj.height : header.height,
                        style: headerStyle,
                        annotations: [{ content: header.annotation.content }]
                    };
                    headerObj.offsetX = headerObj.width / 2;
                    headerObj.offsetY = headerObj.height / 2;
                    this.addPaletteItem(symbolGroup.id, headerObj);
                    var laneObj = {
                        id: 'lane' + randomId(), shape: { type: 'Basic', shape: 'Rectangle' },
                        width: isHorizontal ? (swimLaneObj.width - header.width) : swimLaneObj.width,
                        height: isHorizontal ? swimLaneObj.height : (swimLaneObj.height - header.height),
                        style: laneStyle
                    };
                    laneObj.offsetX = isHorizontal ? (headerObj.width + (laneObj.width / 2)) : laneObj.width / 2;
                    laneObj.offsetY = isHorizontal ? laneObj.height / 2 : (headerObj.height + (laneObj.height / 2));
                    this.addPaletteItem(symbolGroup.id, laneObj);
                    swimLaneObj.children = [headerObj.id, laneObj.id];
                }
                else if (swimLaneShape.isPhase) {
                    laneHeight = swimLaneObj.height ? swimLaneObj.height : this.symbolHeight;
                    laneWidth = swimLaneObj.width ? swimLaneObj.width : this.symbolWidth;
                    symbol.shape.type = 'Path';
                    if (isHorizontal) {
                        symbol.shape.data = 'M0,0 L' + laneWidth + ',' + '0';
                    }
                    else {
                        symbol.shape.data = 'M0,0 L0,' + laneWidth;
                    }
                }
            }
            //Rendering the UML node as an HTML group node ensures that it is visually represented exactly as intended in the diagram
            if (symbol.shape.type === 'UmlClassifier' && !symbol.shape.relationship) {
                var umlObj = symbol;
                var newObj = void 0;
                var getStyle = void 0;
                if (symbol.style.fill === 'white') {
                    getStyle = {
                        fill: '#26A0DA'
                    };
                }
                else {
                    getStyle = {
                        fill: symbol.style.fill
                    };
                }
                if (symbol.shape.classifier === 'Class') {
                    newObj = {
                        id: 'node' + randomId(), shape: {
                            type: 'HTML', content: '<div id="parentDiv" style="width:100%; height:50%; border:1px solid #000; background:#6BA5D7; display: flex; align-items: center; justify-content: center;"><div id="textDiv" style="font-size:0.7vw;">class</div></div>'
                        },
                        width: umlObj.width ? umlObj.width : 100,
                        height: umlObj.height ? umlObj.height : 100,
                        style: getStyle,
                        offsetX: umlObj.width ? umlObj.width / 2 : 50,
                        offsetY: umlObj.height ? umlObj.height / 2 : 50
                    };
                    this.addPaletteItem(symbolGroup.id, newObj);
                }
                else if (symbol.shape.classifier === 'Enumeration') {
                    newObj = {
                        id: 'node' + randomId(), shape: {
                            type: 'HTML', content: '<div id="parentDiv2" style="width:100%; height:50%; border:1px solid #000; background:#6BA5D7; display: flex; align-items: center; justify-content: center;"><div id="textDiv2" style="font-size:0.5vw;">Enumeration</div></div>'
                        },
                        width: umlObj.width ? umlObj.width : 100,
                        height: umlObj.height ? umlObj.height : 100,
                        style: getStyle,
                        offsetX: umlObj.width ? umlObj.width / 2 : 50,
                        offsetY: umlObj.height ? umlObj.height / 2 : 50
                    };
                    this.addPaletteItem(symbolGroup.id, newObj);
                }
                else if (symbol.shape.classifier === 'Interface') {
                    newObj = {
                        id: 'node' + randomId(), shape: {
                            type: 'HTML', content: '<div id="parentDiv3" style="width:100%; height:50%; border:1px solid #000; background:#6BA5D7; display: flex; align-items: center; justify-content: center;"><div id="textDiv3" style="font-size:0.7vw;">Interface</div></div>'
                        },
                        width: umlObj.width ? umlObj.width : 100,
                        height: umlObj.height ? umlObj.height : 100,
                        style: getStyle,
                        offsetX: umlObj.width ? umlObj.width / 2 : 50,
                        offsetY: umlObj.height ? umlObj.height / 2 : 50
                    };
                    this.addPaletteItem(symbolGroup.id, newObj);
                }
                var memberObj = {
                    id: 'member' + randomId(), shape: { type: 'HTML', content: '<div style="width:100%;height:100%;border:1px solid #000;background:white"></div>' },
                    width: umlObj.width ? umlObj.width : 100,
                    height: umlObj.height ? umlObj.height : 100,
                    offsetX: umlObj.width ? umlObj.width / 2 : 50,
                    offsetY: umlObj.height ? umlObj.height / 2 + (newObj.height / 2) : 50 + (newObj.height / 2)
                };
                this.addPaletteItem(symbolGroup.id, memberObj);
                umlObj.children = [newObj.id, memberObj.id];
            }
            //Set the strokeDashArray for specific connectors to ensure that it is visually represented exactly as intended in the diagram
            if (symbol.shape.type === 'UmlClassifier' && symbol.shape.relationship) {
                if (symbol.shape.relationship === 'Inheritance') {
                    symbol.style.strokeDashArray = symbol.style.strokeDashArray ? symbol.style.strokeDashArray : '4 4';
                }
                if (symbol.shape.relationship === 'Dependency') {
                    symbol.style.strokeDashArray = symbol.style.strokeDashArray ? symbol.style.strokeDashArray : '4 4';
                }
            }
            if (symbol instanceof Node) {
                var getNodeDefaults = getFunction(this.getNodeDefaults);
                if (getNodeDefaults) {
                    getNodeDefaults(symbol, this);
                }
            }
            else if (symbol instanceof Connector) {
                var getConnectorDefaults = getFunction(this.getConnectorDefaults);
                if (getConnectorDefaults) {
                    getConnectorDefaults(symbol, this);
                }
            }
            this.symbolTable[symbol.id] = symbol;
            if (symbol instanceof Node && symbol.children) {
                group.push(symbol);
            }
        }
        for (var i = 0; i < group.length; i++) {
            var node = void 0;
            for (var j = 0; j < group[parseInt(i.toString(), 10)].children.length; j++) {
                node = (this.symbolTable[group[parseInt(i.toString(), 10)].children[parseInt(j.toString(), 10)]]);
                if (node) {
                    this.childTable[node.id] = node;
                    node.parentId = group[parseInt(i.toString(), 10)].id;
                }
            }
        }
        for (var _b = 0, _c = symbolGroup.symbols; _b < _c.length; _b++) {
            var symbol = _c[_b];
            if (!(symbol instanceof Node && symbol.children)) {
                this.prepareSymbol(symbol);
            }
        }
        for (var _d = 0, group_1 = group; _d < group_1.length; _d++) {
            var symbol = group_1[_d];
            this.prepareSymbol(symbol);
        }
    };
    SymbolPalette.prototype.renderPalette = function (symbolGroup) {
        var style = 'display:none;overflow:auto;';
        if (symbolGroup.height) {
            style += 'height:' + symbolGroup.height + 'px';
        }
        var paletteParentDiv = document.getElementById(symbolGroup.id);
        var paletteDiv = createHtmlElement('div', { 'id': symbolGroup.id, style: style, class: 'e-remove-palette' });
        this.element.appendChild(paletteDiv);
        if (!isBlazor()) {
            var item = {
                header: symbolGroup.title, expanded: symbolGroup.expanded,
                content: '#' + symbolGroup.id, iconCss: symbolGroup.iconCss
            };
            this.accordionElement.items.push(item);
        }
        this.renderSymbols(symbolGroup, paletteDiv);
    };
    /**
     * Used to add the palette item as nodes or connectors in palettes \
     *
     * @returns {void}    Used to add the palette item as nodes or connectors in palettes .\
     * @param {string} paletteName - provide the scale value.
     * @param {NodeModel | ConnectorModel} paletteSymbol - provide the scale value.
     * @param {boolean} isChild - provide the scale value.
     */
    SymbolPalette.prototype.addPaletteItem = function (paletteName, paletteSymbol, isChild) {
        paletteSymbol = cloneObject(paletteSymbol);
        //let refresh: boolean;
        for (var i = 0; i < this.palettes.length; i++) {
            var symbolPaletteGroup = this.palettes[parseInt(i.toString(), 10)];
            if (symbolPaletteGroup.id.indexOf(paletteName) !== -1) {
                // eslint-disable-next-line
                var param = [undefined, symbolPaletteGroup, 'symbols', {}, true];
                // eslint-disable-next-line
                var obj = new (Function.prototype.bind.apply(getObjectType$1(paletteSymbol), param));
                for (var i_1 = 0; i_1 < Object.keys(paletteSymbol).length; i_1++) {
                    var isEnableServerDatabind_1 = this.allowServerDataBinding;
                    this.allowServerDataBinding = false;
                    obj[Object.keys(paletteSymbol)[parseInt(i_1.toString(), 10)]]
                        = paletteSymbol[Object.keys(paletteSymbol)[parseInt(i_1.toString(), 10)]];
                    this.allowServerDataBinding = isEnableServerDatabind_1;
                }
                updateDefaultValues(obj, paletteSymbol, obj instanceof Node ? this.nodeDefaults : this.connectorDefaults);
                symbolPaletteGroup.symbols.push(obj);
                var isEnableServerDatabind = this.allowServerDataBinding;
                this.allowServerDataBinding = false;
                this.prepareSymbol(obj);
                this.allowServerDataBinding = isEnableServerDatabind;
                this.symbolTable[obj.id] = obj;
                if (isChild) {
                    this.childTable[obj.id] = obj;
                }
                else {
                    var paletteDiv = document.getElementById(symbolPaletteGroup.id);
                    if (paletteDiv) {
                        paletteDiv.appendChild(this.getSymbolContainer(obj, paletteDiv));
                    }
                }
                break;
            }
        }
    };
    /**
     * Used to remove the palette item as nodes or connectors in palettes \
     *
     * @returns {void}    Used to remove the palette item as nodes or connectors in palettes .\
     * @param {string} paletteName - provide the scale value.
     * @param {string} symbolId - provide the scale value.
     */
    SymbolPalette.prototype.removePaletteItem = function (paletteName, symbolId) {
        var refresh;
        for (var i = 0; i < this.palettes.length; i++) {
            var symbolPaletteGroup = this.palettes[parseInt(i.toString(), 10)];
            if (symbolPaletteGroup.id.indexOf(paletteName) !== -1) {
                for (var _i = 0, _a = symbolPaletteGroup.symbols; _i < _a.length; _i++) {
                    var symbol = _a[_i];
                    if (symbol.id.indexOf(symbolId) !== -1) {
                        var index = symbolPaletteGroup.symbols.indexOf(symbol);
                        symbolPaletteGroup.symbols.splice(index, 1);
                        if (symbol.children) {
                            var parentNode = symbol.children;
                            for (var i_2 = 0; i_2 < parentNode.length; i_2++) {
                                delete this.symbolTable[(parentNode[parseInt(i_2.toString(), 10)])];
                            }
                        }
                        delete this.symbolTable[symbol.id];
                        var element = document.getElementById(symbol.id + '_container');
                        element.parentNode.removeChild(element);
                        refresh = true;
                        break;
                    }
                }
            }
            if (refresh) {
                break;
            }
        }
    };
    SymbolPalette.prototype.prepareSymbol = function (symbol) {
        var width;
        var sw;
        var height;
        var sh;
        var stackPanel = new StackPanel();
        var obj = symbol;
        var content;
        var symbolContainer = new Canvas();
        var container = (symbol instanceof Node) ? symbol.initContainer() : null;
        if (container && !container.children) {
            container.children = [];
        }
        //preparing objects
        var getSymbolTemplate = getFunction(this.getSymbolTemplate);
        if (getSymbolTemplate) {
            content = getSymbolTemplate(symbol);
        }
        if (!content) {
            if (obj.children) {
                content = this.getContainer(obj, container);
            }
            else {
                if (symbol instanceof Connector && symbol.shape.type === 'UmlClassifier' && symbol.shape.relationship) {
                    content = symbol.init(this);
                    for (var i = content.children.length - 1; i >= 0; i--) {
                        if (content.children[parseInt(i.toString(), 10)] instanceof TextElement) {
                            content.children.splice(i, 1);
                        }
                    }
                }
                else {
                    content = symbol.init(this);
                }
                if (symbol instanceof Node && symbol.parentId) {
                    container.children.push(content);
                }
            }
        }
        if (!symbol.parentId) {
            var symbolInfo = { width: this.symbolWidth, height: this.symbolHeight };
            var getSymbolInfo = getFunction(this.getSymbolInfo);
            if (getSymbolInfo) {
                symbolInfo = getSymbolInfo(symbol);
            }
            symbolInfo = symbolInfo || this.symbolInfo || {};
            if (symbol.shape && symbol.shape.isPhase) {
                symbolInfo.width = symbolInfo.width || this.symbolWidth;
                symbolInfo.height = symbolInfo.height || this.symbolHeight;
            }
            //defining custom templates
            content.relativeMode = 'Object';
            content.horizontalAlignment = content.verticalAlignment = 'Center';
            symbolContainer.style.strokeColor = symbolContainer.style.fill = 'none';
            symbolContainer.children = [content];
            content.measure(new Size());
            content.arrange(content.desiredSize);
            width = symbolInfo.width = symbolInfo.width ||
                (obj.width !== undefined ? content.actualSize.width : undefined) || this.symbolWidth;
            height = symbolInfo.height = symbolInfo.height ||
                (obj.height !== undefined ? content.actualSize.height : undefined) || this.symbolHeight;
            if (width !== undefined && height !== undefined) {
                var actualWidth = width;
                var actualHeight = height;
                //let isLane: boolean = (symbol.shape as SwimLane).isLane ? true : false;
                var isPhase = symbol.shape.isPhase ? true : false;
                if (this.symbolWidth !== undefined) {
                    actualWidth = this.symbolWidth - this.symbolMargin.left - this.symbolMargin.right;
                }
                else {
                    width += obj.style.strokeWidth;
                }
                if (this.symbolHeight !== undefined) {
                    actualHeight = this.symbolHeight - this.symbolMargin.top - this.symbolMargin.bottom;
                }
                else {
                    height += obj.style.strokeWidth;
                }
                //Bug 873843: Issue with node height and width in the symbol palette. Checked !== Bpmn to avoid the actual height decrement for bpmn nodes
                if (symbol.shape && symbol.shape.type !== 'Bpmn' && symbolInfo.description && symbolInfo.description.text !== '') {
                    actualHeight -= 20; // default height of the text have been reduced from the container.
                }
                sw = actualWidth / ((!isPhase && content.width) || width);
                sh = actualHeight / ((!isPhase && content.height) || height);
                if (symbolInfo.fit) {
                    sw = actualWidth / symbolInfo.width;
                    sh = actualHeight / symbolInfo.height;
                }
                width = actualWidth;
                height = actualHeight;
                sw = sh = Math.min(sw, sh);
                symbolContainer.width = width;
                symbolContainer.height = height;
                content.width = symbolInfo.width;
                content.height = symbolInfo.height;
                this.scaleSymbol(symbol, symbolContainer, sw, sh, width, height);
            }
            else {
                var outerBounds = void 0;
                if (symbol instanceof Connector) {
                    outerBounds = getOuterBounds(symbol);
                }
                content.width = symbol.width || (outerBounds) ? outerBounds.width : content.actualSize.width;
                content.height = symbol.height || (outerBounds) ? outerBounds.height : content.actualSize.height;
            }
            symbol.wrapper = stackPanel;
            stackPanel.children = [symbolContainer];
            content.pivot = stackPanel.pivot = { x: 0, y: 0 };
            stackPanel.id = content.id + '_symbol';
            stackPanel.style.fill = stackPanel.style.strokeColor = 'transparent';
            if (symbol instanceof Node) {
                stackPanel.offsetX = symbol.style.strokeWidth / 2;
                stackPanel.offsetY = symbol.style.strokeWidth / 2;
            }
            else {
                stackPanel.offsetX = 0.5;
                stackPanel.offsetY = 0.5;
            }
            //symbol description-textElement
            this.getSymbolDescription(symbolInfo, width, stackPanel, symbol);
            //EJ2-867827 - In diagram palette symbols, part of the symbol is not visible in left and top side
            stackPanel.padding = { left: 1, right: 1, bottom: 1, top: 1 };
            stackPanel.measure(new Size());
            stackPanel.arrange(stackPanel.desiredSize);
            symbolInfo.width = symbolInfo.width || content.actualSize.width;
            symbolInfo.height = symbolInfo.height || content.actualSize.height;
            symbol[this.info] = symbolInfo;
        }
        if (symbol.parentId) {
            container.measure(new Size(obj.width, obj.height));
            container.arrange(container.desiredSize);
        }
    };
    // private getBlazorSymbolInfo(symbol: NodeModel | ConnectorModel, symbolInfo: SymbolInfo): SymbolInfo {
    //     const node: NodeModel | ConnectorModel = symbol as NodeModel | ConnectorModel;
    //     const shapeSymbolInfo: SymbolPaletteInfoModel = node.symbolInfo;
    //     if (shapeSymbolInfo) {
    //         symbolInfo.description = shapeSymbolInfo.description || this.symbolInfo.description;
    //         symbolInfo.fit = shapeSymbolInfo.fit || this.symbolInfo.fit;
    //         symbolInfo.height = shapeSymbolInfo.height || this.symbolInfo.height;
    //         symbolInfo.width = shapeSymbolInfo.width || this.symbolInfo.width;
    //         symbolInfo.tooltip = shapeSymbolInfo.tooltip || this.symbolInfo.tooltip;
    //         symbolInfo.template = shapeSymbolInfo.template || this.symbolInfo.template;
    //     }
    //     return symbolInfo;
    // }
    SymbolPalette.prototype.getContainer = function (obj, container) {
        container.measureChildren = false;
        var bounds;
        var child = obj.children;
        container.children = [];
        for (var i = 0; i < child.length; i++) {
            if (this.symbolTable[child[parseInt(i.toString(), 10)]]) {
                container.children.push(this.symbolTable[child[parseInt(i.toString(), 10)]].wrapper);
            }
        }
        container.measure(new Size(obj.width, obj.height));
        container.arrange(container.desiredSize);
        if (container.bounds.x !== 0 || container.bounds.y !== 0) {
            bounds = container.bounds;
            arrangeChild(obj, bounds.x, bounds.y, this.symbolTable, false, this);
            container = this.getContainer(obj, container);
        }
        return container;
    };
    /**
     * Feature [EJ2- 47318] - Support for the change of the symbol description
     * Feature [EJ2- 50705] - Support to add margin between the text and symbols
     */
    SymbolPalette.prototype.getSymbolDescription = function (symbolInfo, width, parent, symbol) {
        if (symbolInfo && symbolInfo.description && symbolInfo.description.text) {
            var textElement = new TextElement();
            //symbol description-textElement
            symbolInfo.description.overflow = symbolInfo.description.overflow || 'Ellipsis';
            symbolInfo.description.wrap = symbolInfo.description.wrap || 'WrapWithOverflow';
            textElement.id = parent.id + '_text';
            textElement.content = symbolInfo.description.text;
            textElement.width = width;
            textElement.height = 20;
            textElement.style.strokeColor = 'transparent';
            textElement.style.color = symbolInfo.description.color || 'black';
            textElement.style.fill = symbolInfo.description.fill || 'transparent';
            textElement.style.fontFamily = symbolInfo.description.fontFamily || 'Arial';
            textElement.style.fontSize = symbolInfo.description.fontSize || 12;
            textElement.style.bold = symbolInfo.description.bold || false;
            textElement.style.italic = symbolInfo.description.italic || false;
            textElement.style.textDecoration = symbolInfo.description.textDecoration || 'None';
            textElement.style.strokeWidth = 0;
            textElement.style.textWrapping = symbolInfo.description.wrap;
            textElement.style.textOverflow = symbolInfo.description.overflow;
            //Bug 873843: Issue with node height and width in the symbol palette. Added below to set margin bottom value for bpmn symbol with description.
            if (symbol.shape && symbol.shape.type === 'Bpmn') {
                textElement.margin = {
                    left: 0, right: 0,
                    top: symbolInfo.description.margin ? symbolInfo.description.margin.top : 0,
                    bottom: symbolInfo.description.margin ? symbolInfo.description.margin.bottom : this.symbolMargin.bottom
                };
            }
            else {
                textElement.margin = {
                    left: 0, right: 0,
                    top: symbolInfo.description.margin ? symbolInfo.description.margin.top : 0,
                    bottom: symbolInfo.description.margin ? symbolInfo.description.margin.bottom : 5
                };
            }
            parent.children.push(textElement);
        }
    };
    SymbolPalette.prototype.renderSymbols = function (symbolGroup, parentDiv) {
        for (var _i = 0, _a = symbolGroup.symbols; _i < _a.length; _i++) {
            var symbol = _a[_i];
            if (!symbol.parentId) {
                this.getSymbolContainer(symbol, parentDiv);
            }
        }
    };
    SymbolPalette.prototype.getSymbolPreview = function (
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    symbol, evt, parentDiv) {
        this.allowServerDataBinding = false;
        var canvas;
        var sw;
        var sh;
        var symbolPreviewWidth = symbol.wrapper.children[0].desiredSize.width + symbol.style.strokeWidth;
        var symbolPreviewHeight = symbol.wrapper.children[0].desiredSize.height + symbol.style.strokeWidth;
        var content = symbol.wrapper.children[0].children[0];
        var symbolPreview = symbol.previewSize;
        if ((symbol && (symbolPreview.width || symbolPreview.height)) ||
            this.symbolPreview.width !== undefined || this.symbolPreview.height !== undefined) {
            symbolPreviewWidth = (symbolPreview.width || this.symbolPreview.width || symbolPreviewWidth) - symbol.style.strokeWidth;
            symbolPreviewHeight = (symbolPreview.height || this.symbolPreview.height || symbolPreviewHeight) - symbol.style.strokeWidth;
            // EJ2-56887 - Connector do not get rendered properly in symbol palette.
            // Added below code to check if connector width is less than strokewidth means then set symbol width for connector.
            if (symbol instanceof Connector) {
                if (content.actualSize.width <= symbol.style.strokeWidth) {
                    content.actualSize.width = this.symbolWidth;
                }
                if (content.actualSize.height <= symbol.style.strokeWidth) {
                    content.actualSize.height = this.symbolHeight;
                }
            }
            sw = symbolPreviewWidth / content.actualSize.width;
            sh = symbolPreviewHeight / content.actualSize.height;
            sw = sh = Math.min(sw, sh);
            var symbolWidth = content.actualSize.width * sw;
            var symbolHeight = content.actualSize.height * sh;
            symbol.wrapper.children[0].width = symbolPreviewWidth;
            symbol.wrapper.children[0].height = symbolPreviewHeight;
            this.measureAndArrangeSymbol(content, symbol instanceof Node);
            this.scaleSymbol(symbol, symbol.wrapper.children[0], sw, sh, symbolWidth, symbolHeight, true);
            symbolPreviewWidth = symbolWidth;
            symbolPreviewHeight = symbolHeight;
        }
        var prevPosition = { x: content.offsetX, y: content.offsetY };
        content.offsetX = content.offsetY = symbol.style.strokeWidth / 2;
        content.pivot = { x: 0, y: 0 };
        this.measureAndArrangeSymbol(content, symbol instanceof Node);
        var previewContainer = createHtmlElement('div', { 'draggable': 'true', 'class': 'e-dragclone', 'style': 'pointer-events:none' });
        var div;
        document.body.appendChild(previewContainer);
        var style = 'margin:5px;';
        if (symbol.shape.type === 'Native') {
            canvas = createSvgElement('svg', {
                id: symbol.id + '_preview',
                width: Math.ceil(symbolPreviewWidth) + 1,
                height: Math.ceil(symbolPreviewHeight) + 1
            });
            var gElement = createSvgElement('g', { id: symbol.id + '_g' });
            canvas.appendChild(gElement);
            previewContainer.appendChild(canvas);
            this.svgRenderer.renderElement(content, gElement, undefined, undefined, canvas);
            //EJ2-838575 - for refreshing the symbols after dragged
            this.prepareSymbol(symbol);
        }
        else if (symbol.shape.type === 'HTML') {
            div = this.getHtmlSymbol(symbol, canvas, previewContainer, symbolPreviewHeight, symbolPreviewWidth, true);
            //EJ2-838575 - for refreshing the symbols after dragged
            this.prepareSymbol(symbol);
        }
        else if (symbol.shape.type === 'UmlClassifier' && !symbol.shape.relationship) {
            if (symbol.children &&
                symbol.children.length > 0 && groupHasType(symbol, 'HTML', this.childTable)) {
                div = this.getHtmlSymbol(symbol, canvas, previewContainer, symbol.wrapper.actualSize.height, symbol.wrapper.actualSize.width, true);
                this.prepareSymbol(symbol);
            }
        }
        else {
            if (symbol.children &&
                symbol.children.length > 0 && groupHasType(symbol, 'HTML', this.childTable)) {
                div = this.getGroupParent(symbol, canvas, previewContainer, symbol.wrapper.actualSize.height, symbol.wrapper.actualSize.width, true);
                //EJ2-838575 - for refreshing the symbols after dragged
                this.prepareSymbol(symbol);
            }
            else {
                canvas = CanvasRenderer.createCanvas(symbol.id + '_preview', (Math.ceil(symbolPreviewWidth) + symbol.style.strokeWidth + 1) * 2, (Math.ceil(symbolPreviewHeight) + symbol.style.strokeWidth + 1) * 2);
                previewContainer.appendChild(canvas);
                // BLAZ-3223: translate applied only for Basic and Flow now and need to add for remaining shapes in future
                if (symbol.shape.type === 'Basic' || symbol.shape.type === 'Flow') {
                    style += 'transform: scale(0.5) translate(-' + canvas.width / 2 + 'px, -' + canvas.height / 2 + 'px);';
                }
                else {
                    style += 'transform:scale(0.5);';
                }
                canvas.setAttribute('transform-origin', '0 0');
                var index = 2;
                if (symbol instanceof Connector) {
                    index = 1.9;
                }
                canvas.getContext('2d').setTransform(index, 0, 0, index, 0, 0);
                this.diagramRenderer.renderElement(content, canvas, undefined);
                //EJ2-838575 - for refreshing the symbols after dragged
                this.prepareSymbol(symbol);
            }
        }
        applyStyleAgainstCsp(((div && (symbol.shape.type === 'HTML' || symbol.children
            && symbol.children.length > 0)) ? div : canvas), style);
        content.offsetX = prevPosition.x;
        content.offsetY = prevPosition.y;
        this.allowServerDataBinding = true;
        return previewContainer;
    };
    SymbolPalette.prototype.measureAndArrangeSymbol = function (content, isNode) {
        if (content.children && !isNode) {
            content.children[0].transform = Transform.Self;
        }
        content.measure(new Size());
        content.arrange(content.desiredSize);
        if (content.children && content.children.length > 0) {
            content.children[0].transform = Transform.Parent;
        }
    };
    SymbolPalette.prototype.updateSymbolSize = function (symbol, width, height) {
        var element = symbol.wrapper.children[0].children[0];
        var strokeWidth = symbol.style.strokeWidth;
        element.width = (width || element.width) - (strokeWidth + 1);
        element.height = (height || element.height) - (strokeWidth + 1);
        symbol.wrapper.measure(new Size());
        symbol.wrapper.arrange(symbol.wrapper.desiredSize);
    };
    SymbolPalette.prototype.getSymbolContainer = function (symbol, parentDiv, preview) {
        var symbolInfo = this.symbolTable[symbol.id][this.info];
        var size = this.getSymbolSize(symbol, symbolInfo);
        var width = size.width + 1;
        var height = size.height + 1;
        //Bug 857673: Symbol palette tooltip is not rendered properly after search symbols and hover over palette shapes
        // If the shape is to be rendered in search palette, then the id of the shape is appended with 'SearchSymbol'
        // To create a unique id for the shape in search palette to avoid tooltip issue.
        var symbolId = parentDiv.id === 'SearchPalette' ? symbol.id + 'SearchSymbol' : symbol.id;
        var container = createHtmlElement('div', {
            id: symbolId + '_container',
            style: 'width:' + width + 'px;height:' + height + 'px;float:left;overflow:hidden'
            // title: symbolInfo.tooltip ? symbolInfo.tooltip : symbol.id
        });
        parentDiv.appendChild(container);
        var canvas;
        var gElement;
        var div;
        if (symbol.shape.type === 'Native') {
            canvas = createSvgElement('svg', {
                id: symbolId,
                width: Math.ceil(symbol.wrapper.actualSize.width) + 1,
                height: Math.ceil(symbol.wrapper.actualSize.height) + 1
            });
            gElement = createSvgElement('g', { id: symbolId + '_g' });
            canvas.appendChild(gElement);
            container.appendChild(canvas);
            this.updateSymbolSize(symbol);
            this.svgRenderer.renderElement(symbol.wrapper, gElement, undefined, undefined, canvas);
        }
        else if (symbol.shape.type === 'HTML') {
            div = this.getHtmlSymbol(symbol, canvas, container, symbol.wrapper.actualSize.height, symbol.wrapper.actualSize.width, false, parentDiv.id === 'SearchPalette');
        }
        //This method is responsible for rendering the UML node, as the UML node is displayed as an HTML group node.
        else if (symbol.shape.type === 'UmlClassifier' && !symbol.shape.relationship) {
            if (symbol.children &&
                symbol.children.length > 0 && groupHasType(symbol, 'HTML', this.childTable)) {
                div = this.getHtmlSymbol(symbol, canvas, container, symbol.wrapper.actualSize.height, symbol.wrapper.actualSize.width, false);
            }
        }
        else {
            if (symbol.children &&
                symbol.children.length > 0 && groupHasType(symbol, 'HTML', this.childTable)) {
                div = this.getGroupParent(symbol, canvas, container, symbol.wrapper.actualSize.height, symbol.wrapper.actualSize.width, false);
            }
            else {
                canvas = CanvasRenderer.createCanvas(symbolId, Math.ceil((symbol.wrapper.actualSize.width + symbol.style.strokeWidth) * 2) + 1, Math.ceil((symbol.wrapper.actualSize.height + symbol.style.strokeWidth) * 2) + 1);
                container.appendChild(canvas);
                var index = 2;
                if (symbol instanceof Connector) {
                    index = 1.9;
                }
                canvas.getContext('2d').setTransform(index, 0, 0, index, 0, 0);
                this.diagramRenderer.renderElement(symbol.wrapper, gElement || canvas, undefined, undefined, undefined, undefined, true, undefined, true);
            }
        }
        if (!preview) {
            var actualWidth = symbol.wrapper.actualSize.width + symbol.style.strokeWidth;
            var actualHeight = symbol.wrapper.actualSize.height + symbol.style.strokeWidth;
            var style = 'pointer-events:none;transform-origin:0 0;overflow:hidden;';
            if (symbol.shape.isPhase) {
                if (symbol.shape.orientation === 'Horizontal') {
                    style += 'margin-left:' +
                        Math.max(this.symbolMargin.left, ((width - actualWidth) / 2))
                        + 'px;margin-top:' + size.height / 2
                        + 'px;';
                }
                else {
                    style += 'margin-left:' +
                        size.width / 2
                        + 'px;margin-top:' + Math.max(this.symbolMargin.top, ((height - actualHeight) / 2))
                        + 'px;';
                }
            }
            else {
                style += 'margin-left:' +
                    Math.max(this.symbolMargin.left, ((width - actualWidth) / 2))
                    + 'px;margin-top:' + Math.max(this.symbolMargin.top, ((height - actualHeight) / 2))
                    + 'px;';
            }
            if (canvas instanceof HTMLCanvasElement) {
                style += 'transform:scale(.5,.5);';
            }
            applyStyleAgainstCsp(((div && (symbol.shape.type === 'HTML' || symbol.children &&
                symbol.children.length > 0)) ? div : canvas), style);
            container.classList.add('e-symbol-draggable');
            return container;
        }
        return canvas;
    };
    SymbolPalette.prototype.getGroupParent = function (item, canvas, container, height, width, isPreview) {
        var div = createHtmlElement('div', { 'id': item.id + (isPreview ? '_html_div_preview' : '_html_div') });
        var htmlLayer = createHtmlElement('div', {
            'id': item.id + (isPreview ? '_htmlLayer_preview' : '_htmlLayer'),
            'style': 'width:' + Math.ceil(width + 1) + 'px;' +
                'height:' + Math.ceil(height + 1) + 'px;position:absolute',
            'class': 'e-html-layer'
        });
        var htmlLayerDiv = createHtmlElement('div', {
            'id': item.id + (isPreview ? '_htmlLayer_div_preview' : '_htmlLayer_div'),
            'style': 'width:' + Math.ceil(width + 1) + 'px;' +
                'height:' + Math.ceil(height + 1) + 'px;position:absolute'
        });
        htmlLayer.appendChild(htmlLayerDiv);
        div.appendChild(htmlLayer);
        canvas = CanvasRenderer.createCanvas((isPreview ? (item.id + '_preview') : item.id), Math.ceil(width) + 1, Math.ceil(height) + 1);
        div.appendChild(canvas);
        container.appendChild(div);
        this.diagramRenderer.renderElement(item.wrapper.children[0].children[0], canvas, htmlLayer);
        return div;
    };
    SymbolPalette.prototype.getHtmlSymbol = function (symbol, canvas, container, height, width, isPreview, isSearchSymbol) {
        //Bug 857673: Symbol palette tooltip is not rendered properly after search symbols and hover over palette shapes
        // If the shape is to be rendered in search palette, then the id of the shape is appended with 'SearchSymbol'
        // To create a unique id for the shape in search palette to avoid tooltip issue.
        var symbolId = isSearchSymbol ? symbol.id + 'SearchSymbol' : symbol.id;
        var div = createHtmlElement('div', {
            'id': symbolId + (isPreview ? '_html_div_preview' : '_html_div')
        });
        var htmlLayer = createHtmlElement('div', {
            'id': symbolId + (isPreview ? '_htmlLayer_preview' : '_htmlLayer'),
            'style': 'width:' + Math.ceil(width + 1) + 'px;' +
                'height:' + Math.ceil(height + 1) + 'px;position:absolute',
            'class': 'e-html-layer'
        });
        var htmlLayerDiv = createHtmlElement('div', {
            'id': symbolId + (isPreview ? '_htmlLayer_div_preview' : '_htmlLayer_div'),
            'style': 'width:' + Math.ceil(width + 1) + 'px;' +
                'height:' + Math.ceil(height + 1) + 'px;position:absolute'
        });
        htmlLayer.appendChild(htmlLayerDiv);
        div.appendChild(htmlLayer);
        //EJ2-841339 - Html shapes in palette are not rendered properly
        var actualWidth = symbol.wrapper.actualSize.width + symbol.style.strokeWidth;
        var actualHeight = symbol.wrapper.actualSize.height + symbol.style.strokeWidth;
        var style = 'pointer-events:none;transform-origin:0 0;overflow:hidden;';
        style += 'margin-left:' +
            Math.max(this.symbolMargin.left, ((width - actualWidth) / 2))
            + 'px;margin-top:' + Math.max(this.symbolMargin.top, ((height - actualHeight) / 2))
            + 'px;';
        style += 'transform:scale(.5,.5);position:absolute';
        canvas = CanvasRenderer.createCanvas(symbolId, Math.ceil((symbol.wrapper.actualSize.width + symbol.style.strokeWidth) * 2) + 1, Math.ceil((symbol.wrapper.actualSize.height + symbol.style.strokeWidth) * 2) + 1);
        container.appendChild(canvas);
        canvas.getContext('2d').setTransform(2, 0, 0, 2, 0, 0);
        applyStyleAgainstCsp(canvas, style);
        container.appendChild(div);
        //EJ2-70280 - Text description in symbol palette for HTML nodes is not visible.
        if (isPreview) {
            //When dragging the UML node from the palette, set the preview specifically for that UML node
            if (symbol.shape.type === 'UmlClassifier') {
                if (symbol.shape.classifier === 'Class') {
                    symbol.wrapper.children[0].children[0].children[0].content = '<div id="parentDiv" style="width:100%; height:50%; border:1px solid #000; background:#6BA5D7; display: flex; align-items: center; justify-content: center;"><div id="textDiv" style="font-size:1vw;">class</div></div>';
                }
                else if (symbol.shape.classifier === 'Enumeration') {
                    symbol.wrapper.children[0].children[0].children[0].content = '<div id="parentDiv2" style="width:100%; height:50%; border:1px solid #000; background:#6BA5D7; display: flex; align-items: center; justify-content: center;"><div id="textDiv2" style="font-size:0.8vw;">Enumeration</div></div>';
                }
                else if (symbol.shape.classifier === 'Interface') {
                    symbol.wrapper.children[0].children[0].children[0].content = '<div id="parentDiv3" style="width:100%; height:50%; border:1px solid #000; background:#6BA5D7; display: flex; align-items: center; justify-content: center;"><div id="textDiv3" style="font-size:0.9vw;">Interface</div></div>';
                }
            }
            this.diagramRenderer.renderElement(symbol.wrapper.children[0].children[0], canvas, htmlLayer);
        }
        else {
            this.diagramRenderer.renderElement(symbol.wrapper, canvas, htmlLayer);
        }
        return div;
    };
    // eslint-disable-next-line
    SymbolPalette.prototype.getSymbolSize = function (symbol, symbolInfo) {
        var width = symbol.wrapper.actualSize.width;
        var height = symbol.wrapper.actualSize.height;
        if (!this.symbolWidth && !this.symbolHeight) {
            width += this.symbolMargin.left + this.symbolMargin.right + symbol.style.strokeWidth;
            height += this.symbolMargin.top + this.symbolMargin.bottom + symbol.style.strokeWidth;
        }
        else {
            width = this.symbolWidth;
            height = Math.max(this.symbolHeight, height);
        }
        return new Size(width, height);
    };
    //end region - rendering symbols
    //region event handlers
    SymbolPalette.prototype.getMousePosition = function (e) {
        var offsetY;
        var offsetX;
        var touchArg;
        if (e.type.indexOf('touch') !== -1) {
            touchArg = e;
            var pageY = touchArg.changedTouches[0].clientY;
            var pageX = touchArg.changedTouches[0].clientX;
            offsetY = pageY - this.element.offsetTop;
            offsetX = pageX - this.element.offsetLeft;
        }
        else {
            offsetY = e.clientY - this.element.offsetTop;
            offsetX = e.clientX - this.element.offsetLeft;
        }
        return { x: offsetX, y: offsetY };
    };
    /** Gets the default content of the Tooltip
     *
     * @returns {string | HTMLElement} Returns the default content of the Tooltip.\
     * @param {object} obj - provide the Symbol object.
     */
    SymbolPalette.prototype.getContent = function (obj) {
        var isPrivateTooltip = ((this.hoverElement instanceof Node) &&
            this.hoverElement.constraints & NodeConstraints.Tooltip) ||
            ((this.hoverElement instanceof Connector) &&
                this.hoverElement.constraints & ConnectorConstraints.Tooltip);
        var content = isPrivateTooltip ? this.hoverElement.tooltip.content :
            obj.id;
        return content;
    };
    /**
     * Initialize the basic properties of Toolip object
     *
     * @returns {Tooltip} Returns the basic properties of Toolip object.\
     * @param {NodeModel | ConnectorModel} element - provide the Symbol object.
     */
    SymbolPalette.prototype.initTooltip = function (element) {
        var tooltip;
        if (!isBlazor()) {
            var tooltipOption = new Tooltip;
            tooltipOption = this.updateTooltipContent(this.hoverElement.tooltip, tooltipOption);
            tooltip = new Tooltip(tooltipOption);
            tooltip.cssClass = 'e-symbolPalette-tooltip';
            tooltip.opensOn = 'custom';
            tooltip.appendTo('#' + element.id);
            tooltip.close();
        }
        return tooltip;
    };
    /**Method to update Tooltip Content
     *
     * @returns { Tooltip } Returns the basic properties of Toolip object.\
     *
     * @param {TooltipModel} tooltip - provide the Symbol object.
     * @param {Tooltip} tooltipObject - provide the Symbol object.
     */
    SymbolPalette.prototype.updateTooltipContent = function (tooltip, tooltipObject) {
        tooltipObject.content = tooltip.content;
        tooltipObject.position = 'BottomRight';
        tooltipObject.showTipPointer = tooltip.showTipPointer;
        tooltipObject.width = tooltip.width;
        tooltipObject.height = tooltip.height;
        if (!tooltip.animation) {
            tooltipObject.animation = { close: { effect: 'None' } };
        }
        else {
            tooltipObject.animation = tooltip.animation;
        }
        return tooltipObject;
    };
    /**
     * To open the Tooltip element relevant to the target and relative mode
     *
     * @returns { void} opens the Tooltip element relevant to the target and relative mode.\
     *
     * @param {PointModel} mousePosition - provide the mousePosition value.
     * @param {boolean} elementOver - provide the elementOver value.
     * @param {boolean} isSearchSymbol - provide the isSearchSymbol value.
     */
    SymbolPalette.prototype.elementEnter = function (mousePosition, elementOver, isSearchSymbol) {
        if (!elementOver) {
            //set the collision target element to given position if enabled
            this.symbolTooltipObject.windowCollision = true;
            //840454 - support to provide isSticky property for tooltip in diagram control
            if (this.hoverElement.tooltip.isSticky) {
                this.symbolTooltipObject.isSticky = true;
            }
            if (this.hoverElement instanceof Node) {
                if (!(this.hoverElement.constraints & (NodeConstraints.Default && NodeConstraints.Tooltip))) {
                    this.hoverElement.tooltip.content = this.hoverElement.id;
                    //Task 834121: Content-Security-Policy support for diagram
                    this.symbolTooltipObject.content = initializeCSPTemplate(function () {
                        return this.hoverElement.id;
                    }, this);
                }
            }
            else if (this.hoverElement instanceof Connector) {
                if (!(this.hoverElement.constraints & (ConnectorConstraints.Default && ConnectorConstraints.Tooltip))) {
                    this.hoverElement.tooltip.content = this.hoverElement.id;
                    this.symbolTooltipObject.content = initializeCSPTemplate(function () {
                        return this.hoverElement.id;
                    }, this);
                }
            }
            if (this.hoverElement.tooltip.content) {
                if (this.hoverElement.tooltip.relativeMode === 'Mouse') {
                    //To set relative mode only to object for Symbol Palatte
                    this.hoverElement.tooltip.relativeMode = 'Object';
                    this.symbolTooltipObject.offsetX = 0;
                    this.symbolTooltipObject.offsetY = 0;
                }
                else {
                    this.symbolTooltipObject.offsetX = 0;
                    this.symbolTooltipObject.offsetY = 0;
                }
            }
            //Bug 857673: Symbol palette tooltip is not rendered properly after search symbols and hover over palette shapes
            // To render tooltip for the symbol in search palette, the id of the shape is appended with 'SearchSymbol'.
            var targetId = isSearchSymbol ? this.hoverElement.id + 'SearchSymbol' : this.hoverElement.id;
            var targetEle = document.getElementById(targetId);
            if (this.hoverElement.tooltip.openOn === 'Auto' && this.hoverElement.tooltip.content !== '') {
                this.symbolTooltipObject.close();
                this.symbolTooltipObject.opensOn = this.hoverElement.tooltip.openOn;
                this.symbolTooltipObject.dataBind();
            }
            if (this.hoverElement.tooltip.openOn === 'Auto') {
                this.symbolTooltipObject.target = this.hoverElement.id;
                this.symbolTooltipObject.open(targetEle);
            }
        }
    };
    // eslint-disable-next-line
    SymbolPalette.prototype.mouseMove = function (e, touches) {
        if (this.highlightedSymbol && (!this.selectedSymbol
            || this.selectedSymbol.id + '_container' !== this.highlightedSymbol.id)) {
            this.highlightedSymbol.classList.remove('e-symbol-hover');
            this.highlightedSymbol.style.backgroundColor = '';
            this.highlightedSymbol = null;
        }
        var id = e.target.id.split('_container')[0];
        //Bug 857673: Symbol palette tooltip is not rendered properly after search symbols and hover over palette shapes
        // To render highlighter for the search symbols while hovering over the symbol in search palette.
        if (this.symbolTable["" + id] || (id !== 'SearchPalette' && e.target && e.target.id.includes('SearchSymbol'))) {
            var container = document.getElementById(id + '_container');
            container.classList.add('e-symbol-hover');
            this.highlightedSymbol = container;
        }
        e.preventDefault();
        var isSearchSymbol = false;
        if (e.target && e.target.id.includes('SearchSymbol')) {
            isSearchSymbol = true;
            id = id.split('SearchSymbol')[0];
        }
        //EJ2-66311-tooltip support for Symbolpalette
        var obj = this.symbolTable["" + id];
        if (this.symbolTable["" + id] && obj !== this.hoverElement) {
            this.currentPosition = this.getMousePosition(e);
            var content = this.getContent(obj);
            if (this.hoverElement && this.hoverElement.tooltip.openOn === 'Auto' && content !== '') {
                this.elementLeave();
            }
            this.hoverElement = obj;
            this.symbolTooltipObject = this.initTooltip(this.hoverElement);
            if (content === '') {
                content = this.hoverElement.id;
            }
            if (this.hoverElement.tooltip && content !== '') {
                this.elementEnter(this.currentPosition, false, isSearchSymbol);
            }
        }
        if (obj === undefined && this.hoverElement && !this.hoverElement.tooltip.isSticky && this.hoverElement.tooltip.openOn === 'Auto') {
            this.hoverElement = null;
            this.elementLeave();
        }
    };
    /**
     * When Mouse pointer leaves the symbol palette object Mouse leave event is called and closes Tooltip
     * @returns {void} Function to close symbol tooltip on mouse leave.
     */
    SymbolPalette.prototype.elementLeave = function () {
        if (this.symbolTooltipObject && this.symbolTooltipObject.opensOn !== 'Custom') {
            this.symbolTooltipObject.close();
        }
    };
    /** @private
     * @returns {void} Handles mouse leave events
     * @param {PointerEvent} evt - provide event name
     */
    SymbolPalette.prototype.mouseLeave = function (evt) {
        this.elementLeave();
        evt.preventDefault();
    };
    // eslint-enable
    SymbolPalette.prototype.mouseUp = function (evt) {
        this.isMethod = true;
        if (evt && evt.target) {
            if (evt.srcElement.id === 'iconSearch') {
                var element = document.getElementById('iconSearch');
                if (element.classList.contains('e-clear-searchtext')) {
                    element.className = 'e-input-group-icon e-search e-icons';
                    document.getElementById('textEnter').value = '';
                    this.searchPalette('');
                }
            }
            else {
                var id = evt.target.id.split('_container')[0];
                if (id && this.selectedSymbol) {
                    var args = { oldValue: this.oldObject, newValue: id };
                    var event_2 = 'paletteSelectionChange';
                    this.trigger(event_2, args);
                    this.oldObject = id;
                    evt.preventDefault();
                }
                else if (this.oldObject !== '') {
                    this.oldObject = '';
                }
            }
        }
    };
    SymbolPalette.prototype.keyUp = function (evt) {
        var _this = this;
        if (this.enableSearch) {
            // eslint-disable-next-line
            var palette_1 = this;
            var element = document.getElementById('iconSearch');
            element.className = 'e-input-group-icon e-clear-searchtext e-icons';
            if (evt && (evt.key === 'Enter' || evt.keyCode === 13)) {
                if (evt.target instanceof HTMLInputElement) {
                    this.searchPalette(evt.target.value);
                }
            }
            else {
                if (this.timer) {
                    clearTimeout(this.timer);
                }
                this.timer = setTimeout(function () {
                    if (evt.target instanceof HTMLInputElement) {
                        palette_1.searchPalette(evt.target.value);
                        _this.timer = null;
                    }
                }, 500);
            }
        }
    };
    SymbolPalette.prototype.mouseDown = function (evt) {
        var id = evt.target.id.split('_container')[0];
        var isSearchSymbol = false;
        //Bug 857673: Symbol palette tooltip is not rendered properly after search symbols and hover over palette shapes
        // To split the original id of shape to find it in symbol table.
        if (id.includes('SearchSymbol')) {
            id = id.split('SearchSymbol')[0];
            isSearchSymbol = true;
        }
        if (this.selectedSymbol) {
            var oldSymbol = document.getElementById(this.selectedSymbol.id + '_container');
            //Bug 857673: Symbol palette tooltip is not rendered properly after search symbols and hover over palette shapes
            // To highlight and remove highlight of the selected symbol in search palette on mouse down.
            var oldSearchSymbol = document.getElementById(this.selectedSymbol.id + 'SearchSymbol' + '_container');
            if ((oldSymbol || oldSearchSymbol)) {
                oldSymbol.classList.remove('e-symbol-selected');
                if (oldSearchSymbol) {
                    oldSearchSymbol.classList.remove('e-symbol-selected');
                }
            }
            var container = document.getElementById(this.selectedSymbol.id + '_container');
            if (container) {
                container.style.backgroundColor = '';
            }
            this.selectedSymbol = null;
        }
        if (this.symbolTable["" + id]) {
            var containerId = id;
            if (isSearchSymbol) {
                containerId = id + 'SearchSymbol';
            }
            var container = document.getElementById(containerId + '_container');
            container.classList.add('e-symbol-selected');
            this.selectedSymbol = this.symbolTable["" + id];
            evt.preventDefault();
        }
    };
    SymbolPalette.prototype.keyDown = function (evt) {
        // eslint-disable-next-line
        var palette = this;
        var helperElement = 'helperElement';
        var intDestroy = 'intDestroy';
        if (evt && (evt.key === 'Escape')) {
            var element = palette.draggable["" + helperElement];
            if (element && element.parentNode) {
                element.parentNode.removeChild(element);
                palette.draggable["" + intDestroy]();
            }
        }
    };
    //end region - event handlers
    // region - draggable
    SymbolPalette.prototype.initDraggable = function () {
        if (this.allowDrag) {
            //let drag: Draggable;
            this.draggable = new Draggable(this.element, {
                dragTarget: '.e-symbol-draggable',
                helper: this.helper,
                dragStart: this.dragStart,
                preventDefault: false,
                dragStop: this.dragStop,
                drag: function (args) {
                    var target = 'target';
                    var parent = parentsUntil(args["" + target], 'e-droppable');
                    if (parent && parent.classList.contains('e-diagram')) {
                        var e2eInstance = 'ej2_instances';
                        parent["" + e2eInstance][0].droppable.over(args);
                    }
                },
                cursorAt: { left: this.symbolPreview.offset.x, top: this.symbolPreview.offset.y }
            });
        }
    };
    // eslint-enable
    SymbolPalette.prototype.dragStart = function (e) {
        var element = this.helper[0];
        if (element) {
            element.setAttribute('paletteId', this.element.id);
        }
    };
    SymbolPalette.prototype.dragStop = function (e) {
        if (!parentsUntil(e.target, 'e-diagram')) {
            remove(e.helper);
        }
    };
    //end region - draggable
    //region - helper methods
    SymbolPalette.prototype.scaleSymbol = function (symbol, symbolContainer, sw, sh, width, height, preview) {
        if (symbol instanceof Connector) {
            var wrapper = symbol.wrapper;
            symbol.wrapper = symbolContainer.children[0];
            var point = symbol.scale(sw, sh, width, height, symbolContainer.children[0]);
            var difX = width / 2 - symbolContainer.children[0].children[0].offsetX + point.x / 2;
            var difY = height / 2 - symbolContainer.children[0].children[0].offsetY + point.y / 2;
            for (var _i = 0, _a = symbolContainer.children[0].children; _i < _a.length; _i++) {
                var child = _a[_i];
                child.offsetX += difX;
                child.offsetY += difY;
                child.staticSize = false;
            }
            symbol.wrapper = wrapper;
        }
        else if (symbol.shape.type === 'Bpmn' && this.bpmnModule) {
            var wrapper = symbol.wrapper;
            symbol.wrapper = symbolContainer;
            symbolContainer.children[0].width = width;
            symbolContainer.children[0].height = height;
            this.bpmnModule.updateBPMN({ width: width, height: height }, symbol, symbol, null);
            symbol.wrapper = wrapper;
        }
        else {
            if (symbol.children) {
                var parentNode = symbol.children;
                var w = 0;
                var h = 0;
                if (!preview) {
                    var node = void 0;
                    var container = void 0;
                    for (var i = 0; i < parentNode.length; i++) {
                        container = symbolContainer.children[0].children[parseInt(i.toString(), 10)];
                        if (container) {
                            if (container.children[0].children) {
                                this.measureChild(container);
                            }
                            node = this.symbolTable[container.id];
                            container.width = node.width;
                            container.height = node.height;
                            container.measure(new Size());
                            container.arrange(container.children[0].desiredSize);
                        }
                    }
                }
                w = width / symbolContainer.children[0].desiredSize.width;
                h = height / symbolContainer.children[0].desiredSize.height;
                symbolContainer.children[0].measure(new Size());
                symbolContainer.children[0].arrange(symbolContainer.children[0].desiredSize);
                if (!preview) {
                    var children = void 0;
                    for (var i = 0; i < parentNode.length; i++) {
                        children = symbolContainer.children[0].children[parseInt(i.toString(), 10)];
                        if (children) {
                            if (children.children[0].children) {
                                this.scaleChildren(children, w, h, symbol);
                            }
                            this.scaleGroup(children, w, h, symbol);
                        }
                    }
                }
                if (preview) {
                    ///let node: Node;
                    var scaleWidth = void 0;
                    var scaleHeight = void 0;
                    var children = void 0;
                    for (var i = 0; i < parentNode.length; i++) {
                        //const node: Node = this.symbolTable[parentNode[i]];
                        scaleWidth = width / symbol.wrapper.children[0].desiredSize.width;
                        scaleHeight = height / symbol.wrapper.children[0].desiredSize.height;
                        children = symbolContainer.children[0].children[parseInt(i.toString(), 10)];
                        if (children) {
                            if (children.children[0].children) {
                                this.scaleChildren(children, scaleWidth, scaleHeight, symbol, true);
                            }
                            this.scaleGroup(children, scaleWidth, scaleHeight, symbol, true);
                        }
                    }
                    symbol.wrapper.children[0].measure(new Size());
                    symbol.wrapper.children[0].arrange(symbol.wrapper.children[0].desiredSize);
                }
            }
            else {
                scaleElement(symbolContainer.children[0], sw, sh, symbolContainer);
            }
        }
    };
    SymbolPalette.prototype.scaleChildren = function (container, w, h, symbol, preview) {
        var child;
        for (var i = 0; i < container.children.length; i++) {
            child = container.children[parseInt(i.toString(), 10)];
            if (!child.children[0].children) {
                this.scaleGroup(child, w, h, symbol, preview);
            }
            else {
                this.scaleChildren(child, w, h, symbol, preview);
            }
        }
    };
    SymbolPalette.prototype.measureChild = function (container) {
        var childContainer;
        var node;
        for (var i = 0; i < container.children.length; i++) {
            childContainer = container.children[parseInt(i.toString(), 10)];
            if (!childContainer.children[0].children) {
                node = this.symbolTable[childContainer.id];
                childContainer.width = node.width;
                childContainer.height = node.height;
                childContainer.measure(new Size());
                childContainer.arrange(childContainer.children[0].desiredSize);
            }
            else {
                this.measureChild(childContainer);
            }
        }
    };
    SymbolPalette.prototype.scaleGroup = function (child, w, h, symbol, preview) {
        child.width = child.width * w;
        child.height = (child.height * h);
        child.offsetX = preview ? (child.offsetX * w) - symbol.style.strokeWidth : (child.offsetX * w) + symbol.style.strokeWidth / 2;
        child.offsetY = preview ? (child.offsetY * h) - symbol.style.strokeWidth : (child.offsetY * h) + symbol.style.strokeWidth / 2;
        child.measure(new Size());
        child.arrange(child.children[0].desiredSize);
    };
    SymbolPalette.prototype.refreshPalettes = function () {
        if (!isBlazor()) {
            this.accordionElement.items = [];
        }
        removeElementsByClass('e-remove-palette', this.element.id);
        this.updatePalettes();
        if (!isBlazor()) {
            this.accordionElement.dataBind();
        }
    };
    SymbolPalette.prototype.updatePalettes = function () {
        for (var i = 0; i < this.palettes.length; i++) {
            var symGroup = this.palettes[parseInt(i.toString(), 10)];
            //Bug 857693: Collapsing the palettes after searching shapes throws wrong arguments in paletteExpanding event.
            //To remove search palette from palette collection.
            if (symGroup.id === 'search_palette') {
                this.palettes.splice(i, 1);
                i--;
            }
            else {
                this.initSymbols(symGroup);
                this.renderPalette(symGroup);
            }
        }
    };
    SymbolPalette.prototype.createTextbox = function () {
        var searchDiv = createHtmlElement('div', { id: this.element.id + '_search' });
        applyStyleAgainstCsp(searchDiv, 'height:30px');
        //  searchDiv.setAttribute('style', 'backgroundColor:white;height:30px');
        searchDiv.className = 'e-input-group';
        this.element.appendChild(searchDiv);
        var textBox = createHtmlElement('input', {});
        textBox.placeholder = this.l10n.getConstant('SearchShapes');
        textBox.id = 'textEnter';
        applyStyleAgainstCsp(textBox, 'width:100%;height:auto');
        //textBox.setAttribute('style', 'width:100%;height:auto');
        textBox.className = 'e-input';
        searchDiv.appendChild(textBox);
        var span = createHtmlElement('span', { id: 'iconSearch', className: 'e-input-group-icon e-search e-icons' });
        searchDiv.appendChild(span);
    };
    SymbolPalette.prototype.getFilterSymbol = function (symbol) {
        var _this = this;
        var items = [];
        //884490: filter the symbol based on ignoreSymbolsOnSearch property
        items = symbol.filter(function (element) { return !_this.ignoreSymbolsOnSearch.includes(element.id); });
        return items;
    };
    SymbolPalette.prototype.searchPalette = function (value) {
        var symbolGroup = [];
        var element = document.getElementById('SearchPalette');
        var paletteDiv;
        //remove the existing child in palette
        if (element) {
            for (var i = element.children.length - 1; i >= 0; i--) {
                element.removeChild(element.children[parseInt(i.toString(), 10)]);
            }
            //Bug-857693: Collapsing the palettes after searching shapes throws wrong arguments in paletteExpanding event.
            //To remove search palette from palette collection.
            this.palettes.splice(0, 1);
        }
        //add the searched item in array collection
        for (var i = 0; i < this.palettes.length; i++) {
            var symbolPaletteGroup = this.palettes[parseInt(i.toString(), 10)];
            for (var j = 0; j < symbolPaletteGroup.symbols.length; j++) {
                var item = symbolPaletteGroup.symbols[parseInt(j.toString(), 10)];
                if (value !== '' && item.id.toLowerCase().indexOf(value.toLowerCase()) !== -1) {
                    symbolGroup.push(item);
                }
            }
        }
        var filterSymbols = getFunction(this.filterSymbols);
        if (filterSymbols) {
            symbolGroup = filterSymbols(symbolGroup) || [];
        }
        if (this.ignoreSymbolsOnSearch && this.ignoreSymbolsOnSearch.length > 0) {
            symbolGroup = this.getFilterSymbol(symbolGroup);
        }
        //Bug 857693: Collapsing the palettes after searching shapes throws wrong arguments in paletteExpanding event.
        //To render search palette and add it to the palettes collection.
        if (value !== '') {
            var searchPalette = { id: 'search_palette', expanded: true, symbols: symbolGroup, title: 'Search Shapes' };
            var palette = new Palette(this, 'palettes', searchPalette, true);
            this.palettes.splice(0, 0, palette);
        }
        //create a palette collection
        if (!element && !isBlazor()) {
            paletteDiv = this.createSearchPalette(paletteDiv);
            element = paletteDiv;
        }
        //add the symbols into search palette
        if (symbolGroup.length > 0) {
            for (var _i = 0, symbolGroup_1 = symbolGroup; _i < symbolGroup_1.length; _i++) {
                var symbol = symbolGroup_1[_i];
                if (symbol.parentId === '') {
                    this.getSymbolContainer(symbol, element);
                }
            }
        }
        else if (value !== '') {
            var emptyDiv = createHtmlElement('div', { 'id': 'EmptyDiv', 'style': 'text-align:center;font-style:italic' });
            emptyDiv.innerHTML = 'No Items To Display';
            element.appendChild(emptyDiv);
        }
        else {
            var element_1 = document.getElementById('iconSearch');
            element_1.className = 'e-input-group-icon e-search e-icons';
            if (!isBlazor()) {
                this.accordionElement.removeItem(0);
                var searchPalette = document.getElementById('SearchPalette');
                if (searchPalette) {
                    searchPalette.remove();
                }
            }
        }
    };
    SymbolPalette.prototype.createSearchPalette = function (paletteDiv) {
        paletteDiv = createHtmlElement('div', { 'id': 'SearchPalette', 'style': 'display:none;overflow:auto;' });
        this.element.appendChild(paletteDiv);
        var paletteCollection = {
            header: 'Search Results', expanded: true,
            content: '#SearchPalette'
        };
        this.accordionElement.addItem(paletteCollection, 0);
        return paletteDiv;
    };
    SymbolPalette.prototype.wireEvents = function () {
        var startEvent = Browser.touchStartEvent;
        var stopEvent = Browser.touchEndEvent;
        var moveEvent = Browser.touchMoveEvent;
        var cancelEvent = 'mouseleave';
        var keyEvent = 'keyup';
        var keyDownEvent = 'keydown';
        EventHandler.add(this.element, startEvent, this.mouseDown, this);
        EventHandler.add(this.element, moveEvent, this.mouseMove, this);
        EventHandler.add(this.element, stopEvent, this.mouseUp, this);
        EventHandler.add(this.element, cancelEvent, this.mouseLeave, this);
        EventHandler.add(this.element, keyEvent, this.keyUp, this);
        EventHandler.add(document, keyDownEvent, this.keyDown, this);
        // initialize the draggable component
        this.initDraggable();
    };
    SymbolPalette.prototype.unWireEvents = function () {
        var startEvent = Browser.touchStartEvent;
        var stopEvent = Browser.touchEndEvent;
        var moveEvent = Browser.touchMoveEvent;
        var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';
        var keyEvent = 'keyup';
        var keyDownEvent = 'keydown';
        EventHandler.remove(this.element, startEvent, this.mouseDown);
        EventHandler.remove(this.element, moveEvent, this.mouseMove);
        EventHandler.remove(this.element, stopEvent, this.mouseUp);
        EventHandler.remove(this.element, cancelEvent, this.mouseLeave);
        EventHandler.remove(this.element, keyEvent, this.keyUp);
        EventHandler.remove(document, keyDownEvent, this.keyDown);
    };
    __decorate$r([
        Property('S')
    ], SymbolPalette.prototype, "accessKey", void 0);
    __decorate$r([
        Property('100%')
    ], SymbolPalette.prototype, "width", void 0);
    __decorate$r([
        Property('100%')
    ], SymbolPalette.prototype, "height", void 0);
    __decorate$r([
        Collection([], Palette)
    ], SymbolPalette.prototype, "palettes", void 0);
    __decorate$r([
        Property()
    ], SymbolPalette.prototype, "getSymbolInfo", void 0);
    __decorate$r([
        Property({ fit: true })
    ], SymbolPalette.prototype, "symbolInfo", void 0);
    __decorate$r([
        Property()
    ], SymbolPalette.prototype, "filterSymbols", void 0);
    __decorate$r([
        Property()
    ], SymbolPalette.prototype, "ignoreSymbolsOnSearch", void 0);
    __decorate$r([
        Property()
    ], SymbolPalette.prototype, "getSymbolTemplate", void 0);
    __decorate$r([
        Property()
    ], SymbolPalette.prototype, "symbolWidth", void 0);
    __decorate$r([
        Property()
    ], SymbolPalette.prototype, "symbolHeight", void 0);
    __decorate$r([
        Complex({ left: 10, right: 10, top: 10, bottom: 10 }, Margin)
    ], SymbolPalette.prototype, "symbolMargin", void 0);
    __decorate$r([
        Property(true)
    ], SymbolPalette.prototype, "allowDrag", void 0);
    __decorate$r([
        Complex({}, SymbolPreview)
    ], SymbolPalette.prototype, "symbolPreview", void 0);
    __decorate$r([
        Complex({}, SymbolDragSize)
    ], SymbolPalette.prototype, "symbolDragSize", void 0);
    __decorate$r([
        Property(false)
    ], SymbolPalette.prototype, "enableSearch", void 0);
    __decorate$r([
        Property(true)
    ], SymbolPalette.prototype, "enableAnimation", void 0);
    __decorate$r([
        Property('Multiple')
    ], SymbolPalette.prototype, "expandMode", void 0);
    __decorate$r([
        Event()
    ], SymbolPalette.prototype, "paletteSelectionChange", void 0);
    __decorate$r([
        Event()
    ], SymbolPalette.prototype, "paletteExpanding", void 0);
    __decorate$r([
        Property()
    ], SymbolPalette.prototype, "getNodeDefaults", void 0);
    __decorate$r([
        Property()
    ], SymbolPalette.prototype, "nodeDefaults", void 0);
    __decorate$r([
        Property()
    ], SymbolPalette.prototype, "getConnectorDefaults", void 0);
    __decorate$r([
        Property()
    ], SymbolPalette.prototype, "connectorDefaults", void 0);
    return SymbolPalette;
}(Component));

export { ActivityFlow, Annotation, AnnotationConstraints, AvoidLineOverlapping, BasicShape, BezierSegment, BezierSettings, BezierSmoothness, BlazorAction, BpmnActivity, BpmnAnnotation, BpmnDataObject, BpmnDiagrams, BpmnEvent, BpmnFlow, BpmnGateway, BpmnShape, BpmnSubEvent, BpmnSubProcess, BpmnTask, BpmnTextAnnotation, BpmnTransactionSubProcess, Canvas, CanvasRenderer, ChildArrangement, ChildContainer, ClassifierMultiplicity, ColumnDefinition, Command, CommandHandler, CommandManager, ComplexHierarchicalTree, ConnectTool, ConnectionDataSource, ConnectionPointOrigin, Connector, ConnectorBridging, ConnectorConstraints, ConnectorDrawingTool, ConnectorEditing, ConnectorFixedUserHandle, ConnectorProperties, ConnectorSegment, ConnectorShape, Container, ContextMenuSettings, ControlPointsVisibility, CrudAction, CustomCursorAction, DataBinding, DataMappingItems, DataSource, Decorator, Diagram, DiagramAction, DiagramConnectorSegment, DiagramConnectorShape, DiagramConstraints, DiagramContextMenu, DiagramElement, DiagramEvent, DiagramEventHandler, DiagramGradient, DiagramRenderer, DiagramShape, DiagramShapeStyle, DiagramTools, DiagramTooltip, Ej1Serialization, ElementAction, ExpandTool, FixedUserHandle, FixedUserHandleTool, FlipDirection, FlowShape, FlowchartLayout, FlowchartLayoutSettings, FreeHandTool, Gradient, GraphForceNode, GraphLayoutManager, GridCell, GridPanel, GridRow, Gridlines, Header, HierarchicalTree, Html, Hyperlink, Image$1 as Image, ImageElement, KeyGesture, KeyModifiers, Keys, LabelDragTool, LabelProperties, LabelResizeTool, LabelRotateTool, LabelTool, Lane, Layout, LayoutAnimation, LineDistribution, LineRouting, LinearGradient, Margin, Matrix, MatrixTypes, MethodArguments, MindMap, MoveTool, MultiplicityLabel, Native, NoOfSegments, Node, NodeConstraints, NodeDrawingTool, NodeFixedUserHandle, NodeProperties, OrthogonalSegment, Overview, Palette, Path, PathAnnotation, PathElement, PathPort, Phase, Point, PointPort, PolyLineDrawingTool, PolygonDrawingTool, Port, PortConstraints, PortProperties, PortVisibility, PrintAndExport, RadialGradient, RadialTree, RealAction, Rect, RelationShip, RenderMode, RendererAction, ResizeTool, RotateTool, RowDefinition, Ruler, ScrollActions, SelectTool, Selector, SelectorConstraints, Shadow, Shape, ShapeAnnotation, ShapeStyle, Size, SnapConstraints, SnapSettings, Snapping, StackPanel, Stop, StraightSegment, StrokeStyle, SwimLane, SymbolDragSize, SymbolPalette, SymbolPaletteInfo, SymbolPreview, SymbolSize, SymmetricLayout, Text, TextDrawingTool, TextElement, TextStyle, Thickness, ThumbsConstraints, ToolBase, Transform, UmlActivityShape, UmlClass, UmlClassAttribute, UmlClassMethod, UmlClassifierShape, UmlEnumeration, UmlEnumerationMember, UmlInterface, UndoRedo, UserHandle, Vector, ZoomPanTool, addChildToContainer, alignElement, alignLabelOnSegments, arrangeChild, bBoxText, bezierPoints, canMeasureDecoratorPath, canResizeCorner, canShowControlPoints, canShowCorner, changeOldFlipDirectionType, checkBrowserInfo, checkChildNodeInContainer, checkParentAsContainer, checkPort, checkPortRestriction, cloneArray, cloneBlazorObject, cloneObject, cloneSelectedObjects, completeRegion, contains, contextMenuBeforeItemRender, contextMenuClick, contextMenuOpen, cornersPointsBeforeRotation, createHelper, deserialize, extendArray, extendObject, findAngle, findAnnotation, findBounds, findConnectorPoints, findDistance, findMargin, findNearestPoint, findNodeByName, findObjectIndex, findObjectType, findParentInSwimlane, findPath, findPoint, findPort, findPortIndex, findPortToolToActivate, findToolToActivate, flipConnector, getAlignedPosition, getAlignedPositionForPorts, getAnnotationPosition, getBasicShape, getBezierBounds, getBezierDirection, getBezierPoints, getBounds, getBpmnGatewayShapePathData, getBpmnLoopShapePathData, getBpmnShapePathData, getBpmnTaskShapePathData, getBpmnTriggerShapePathData, getChild, getCollectionChangeEventArguements, getConnectorArrowType, getConnectorDirection, getCursor, getDecoratorShape, getDirection$1 as getDirection, getDropEventArguements, getElement, getFlowShape, getFreeHandPath, getFunction, getIconShape, getInOutConnectPorts, getIndex, getInternalProperties, getIntersection, getIntersectionPoints, getInterval, getLineSegment, getObjectFromCollection, getObjectType, getOffset, getOffsetOfConnector, getOffsetOfPorts, getOppositeDirection, getOuterBounds, getPathOffset, getPathString, getPoint, getPoints, getPolygonPath, getPortDirection, getPortShape, getPortsPosition, getPreviewSize, getRectanglePath, getSegmentThumbShapeHorizontal, getSegmentThumbShapeVertical, getSpaceValue, getString, getSymbolSize, getTooltipOffset, getUMLActivityShapes, getUMLFinalNode, getUserHandlePosition, groupHasType, hasSelection, hasSingleConnection, identityMatrix, initFixedUserHandlesSymbol, initTooltip, insertObject, intersect2, intersect3, isDiagramChild, isEmptyVector, isPointOverConnector, isSelected, menuClass, middleElement, moveChildInStack, multiplyMatrix, orthoConnection2Segment, overFlow, parsePathData, pathSegmentCollection, processPathData, randomId, removeChildInContainer, removeChildNodes, removeGradient, removeItem, renderContainerHelper, renderStackHighlighter, rotateMatrix, rotatePoint, rotateSize, scaleElement, scaleMatrix, scalePathData, selectionHasConnector, serialize, setConnectorDefaults, setPortsEdges, setSwimLaneDefaults, setUMLActivityDefaults, sort, splitArrayCollection, swapBounds, templateCompiler, textAlignToString, transformPath, transformPointByMatrix, transformPointsByMatrix, translateMatrix, updateCanvasBounds, updateConnector, updateContent, updateDefaultValues, updateHyperlink, updateLaneBoundsAfterAddChild, updateLaneBoundsWithSelector, updateLayoutValue, updatePathElement, updatePortEdges, updateShape, updateShapeContent, updateStyle, updateTooltip, updateUmlActivityNode, updateZindex, updatedSegment, upgrade, whiteSpaceToString, wordBreakToString };
//# sourceMappingURL=ej2-diagrams.es5.js.map
